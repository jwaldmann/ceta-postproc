{-# LANGUAGE EmptyDataDecls, RankNTypes, ScopedTypeVariables #-}

module
  Ceta(Nat, Nibble, Term, Sum(..), Lab, Xml, Sum_bot(..), Cert_result(..),
        Cert_problem, Tp, Dpp, Ac_dpp, Tp_ops_ext, Dpp_ops_ext, Ac_tp_ops_ext,
        Ac_dpp_ops_ext, certify_proof)
  where {

import Prelude ((==), (/=), (<), (<=), (>=), (>), (+), (-), (*), (/), (**),
  (>>=), (>>), (=<<), (&&), (||), (^), (^^), (.), ($), ($!), (++), (!!), Eq,
  error, id, return, not, fst, snd, map, filter, concat, concatMap, reverse,
  zip, null, takeWhile, dropWhile, all, any, Integer, negate, abs, divMod,
  String, Bool(True, False), Maybe(Nothing, Just));
import qualified Prelude;
import qualified IArray;

newtype Int = Int_of_integer Integer;

integer_of_int :: Int -> Integer;
integer_of_int (Int_of_integer k) = k;

times_int :: Int -> Int -> Int;
times_int k l = Int_of_integer (integer_of_int k * integer_of_int l);

zero_int :: Int;
zero_int = Int_of_integer (0 :: Integer);

data Num = One | Bit0 Num | Bit1 Num;

one_int :: Int;
one_int = Int_of_integer (1 :: Integer);

class Times a where {
  times :: a -> a -> a;
};

apsnd :: forall a b c. (a -> b) -> (c, a) -> (c, b);
apsnd f (x, y) = (x, f y);

divmod_integer :: Integer -> Integer -> (Integer, Integer);
divmod_integer k l =
  (if k == (0 :: Integer) then ((0 :: Integer), (0 :: Integer))
    else (if (0 :: Integer) < l
           then (if (0 :: Integer) < k then divMod ( k ) ( l )
                  else let {
                         (r, s) = divMod ( (negate k) ) ( l );
                       } in (if s == (0 :: Integer)
                              then (negate r, (0 :: Integer))
                              else (negate r - (1 :: Integer), l - s)))
           else (if l == (0 :: Integer) then ((0 :: Integer), k)
                  else apsnd negate
                         (if k < (0 :: Integer)
                           then divMod ( (negate k) ) ( (negate l) )
                           else let {
                                  (r, s) = divMod ( k ) ( (negate l) );
                                } in (if s == (0 :: Integer)
                                       then (negate r, (0 :: Integer))
                                       else (negate r - (1 :: Integer),
      negate l - s))))));

divide_integer :: Integer -> Integer -> Integer;
divide_integer k l = fst (divmod_integer k l);

divide_int :: Int -> Int -> Int;
divide_int k l =
  Int_of_integer (divide_integer (integer_of_int k) (integer_of_int l));

lcm_integer :: Integer -> Integer -> Integer;
lcm_integer a b =
  divide_integer (Prelude.abs a * Prelude.abs b) (Prelude.gcd a b);

uminus_int :: Int -> Int;
uminus_int k = Int_of_integer (negate (integer_of_int k));

less_int :: Int -> Int -> Bool;
less_int k l = integer_of_int k < integer_of_int l;

abs_int :: Int -> Int;
abs_int i = (if less_int i zero_int then uminus_int i else i);

equal_int :: Int -> Int -> Bool;
equal_int k l = integer_of_int k == integer_of_int l;

mod_integer :: Integer -> Integer -> Integer;
mod_integer k l = snd (divmod_integer k l);

mod_int :: Int -> Int -> Int;
mod_int k l =
  Int_of_integer (mod_integer (integer_of_int k) (integer_of_int l));

gcd_int :: Int -> Int -> Int;
gcd_int (Int_of_integer x) (Int_of_integer y) =
  Int_of_integer (Prelude.gcd x y);
gcd_int k l =
  abs_int
    (if equal_int l zero_int then k
      else gcd_int l (mod_int (abs_int k) (abs_int l)));

lcm_int :: Int -> Int -> Int;
lcm_int (Int_of_integer x) (Int_of_integer y) =
  Int_of_integer (lcm_integer x y);
lcm_int a b = divide_int (times_int (abs_int a) (abs_int b)) (gcd_int a b);

class Zero a where {
  zeroa :: a;
};

class One a where {
  onea :: a;
};

class (Times a) => Dvd a where {
};

class (One a, Zero a, Dvd a) => Gcd a where {
  gcd :: a -> a -> a;
  lcm :: a -> a -> a;
};

instance Zero Int where {
  zeroa = zero_int;
};

instance One Int where {
  onea = one_int;
};

instance Times Int where {
  times = times_int;
};

instance Dvd Int where {
};

instance Gcd Int where {
  gcd = gcd_int;
  lcm = lcm_int;
};

instance Eq Int where {
  a == b = equal_int a b;
};

newtype Nat = Nat Integer;

integer_of_nat :: Nat -> Integer;
integer_of_nat (Nat x) = x;

divide_nat :: Nat -> Nat -> Nat;
divide_nat m n = Nat (divide_integer (integer_of_nat m) (integer_of_nat n));

equal_nat :: Nat -> Nat -> Bool;
equal_nat m n = integer_of_nat m == integer_of_nat n;

class Ord a where {
  less_eq :: a -> a -> Bool;
  less :: a -> a -> Bool;
};

max :: forall a. (Ord a) => a -> a -> a;
max a b = (if less_eq a b then b else a);

instance Ord Integer where {
  less_eq = (\ a b -> a <= b);
  less = (\ a b -> a < b);
};

nat_of_integer :: Integer -> Nat;
nat_of_integer k = Nat (max (0 :: Integer) k);

zero_nat :: Nat;
zero_nat = Nat (0 :: Integer);

one_nat :: Nat;
one_nat = Nat (1 :: Integer);

data Nibble = Nibble0 | Nibble1 | Nibble2 | Nibble3 | Nibble4 | Nibble5
  | Nibble6 | Nibble7 | Nibble8 | Nibble9 | NibbleA | NibbleB | NibbleC
  | NibbleD | NibbleE | NibbleF;

string_of_digit :: Nat -> [Prelude.Char];
string_of_digit n =
  (if equal_nat n zero_nat then ['0']
    else (if equal_nat n one_nat then ['1']
           else (if equal_nat n (nat_of_integer (2 :: Integer)) then ['2']
                  else (if equal_nat n (nat_of_integer (3 :: Integer))
                         then ['3']
                         else (if equal_nat n (nat_of_integer (4 :: Integer))
                                then ['4']
                                else (if equal_nat n
   (nat_of_integer (5 :: Integer))
                                       then ['5']
                                       else (if equal_nat n
          (nat_of_integer (6 :: Integer))
      then ['6']
      else (if equal_nat n (nat_of_integer (7 :: Integer)) then ['7']
             else (if equal_nat n (nat_of_integer (8 :: Integer)) then ['8']
                    else ['9'])))))))));

mod_nat :: Nat -> Nat -> Nat;
mod_nat m n = Nat (mod_integer (integer_of_nat m) (integer_of_nat n));

less_nat :: Nat -> Nat -> Bool;
less_nat m n = integer_of_nat m < integer_of_nat n;

shows_string :: [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
shows_string = (\ a b -> a ++ b);

showsp_nat :: Nat -> Nat -> [Prelude.Char] -> [Prelude.Char];
showsp_nat p n =
  (if less_nat n (nat_of_integer (10 :: Integer))
    then shows_string (string_of_digit n)
    else showsp_nat p (divide_nat n (nat_of_integer (10 :: Integer))) .
           shows_string
             (string_of_digit (mod_nat n (nat_of_integer (10 :: Integer)))));

nat :: Int -> Nat;
nat k = Nat (max (0 :: Integer) (integer_of_int k));

showsp_int :: Nat -> Int -> [Prelude.Char] -> [Prelude.Char];
showsp_int p i =
  (if less_int i zero_int
    then shows_string ['-'] . showsp_nat p (nat (uminus_int i))
    else showsp_nat p (nat i));

shows_prec_int :: Nat -> Int -> [Prelude.Char] -> [Prelude.Char];
shows_prec_int = showsp_int;

shows_sep ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ([Prelude.Char] -> [Prelude.Char]) ->
        [a] -> [Prelude.Char] -> [Prelude.Char];
shows_sep s sep [] = shows_string [];
shows_sep s sep [x] = s x;
shows_sep s sep (x : v : va) = (s x . sep) . shows_sep s sep (v : va);

shows_list_gen ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      [Prelude.Char] ->
        [Prelude.Char] ->
          [Prelude.Char] ->
            [Prelude.Char] -> [a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_gen showsx e l s r xs =
  (if null xs then shows_string e
    else (shows_string l . shows_sep showsx (shows_string s) xs) .
           shows_string r);

showsp_list ::
  forall a.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      Nat -> [a] -> [Prelude.Char] -> [Prelude.Char];
showsp_list s p xs =
  shows_list_gen (s zero_nat) ['[', ']'] ['['] [',', ' '] [']'] xs;

shows_list_int :: [Int] -> [Prelude.Char] -> [Prelude.Char];
shows_list_int = showsp_list shows_prec_int zero_nat;

class Showa a where {
  shows_prec :: Nat -> a -> [Prelude.Char] -> [Prelude.Char];
  shows_list :: [a] -> [Prelude.Char] -> [Prelude.Char];
};

instance Showa Int where {
  shows_prec = shows_prec_int;
  shows_list = shows_list_int;
};

class Abs a where {
  absa :: a -> a;
};

instance Abs Int where {
  absa = abs_int;
};

sgn_int :: Int -> Int;
sgn_int i =
  (if equal_int i zero_int then zero_int
    else (if less_int zero_int i then Int_of_integer (1 :: Integer)
           else uminus_int (Int_of_integer (1 :: Integer))));

class Sgn a where {
  sgn :: a -> a;
};

instance Sgn Int where {
  sgn = sgn_int;
};

minus_int :: Int -> Int -> Int;
minus_int k l = Int_of_integer (integer_of_int k - integer_of_int l);

plus_int :: Int -> Int -> Int;
plus_int k l = Int_of_integer (integer_of_int k + integer_of_int l);

class Uminus a where {
  uminusa :: a -> a;
};

class Minus a where {
  minus :: a -> a -> a;
};

class Plus a where {
  plus :: a -> a -> a;
};

class (Plus a) => Semigroup_add a where {
};

class (Semigroup_add a) => Cancel_semigroup_add a where {
};

class (Semigroup_add a) => Ab_semigroup_add a where {
};

class (Ab_semigroup_add a, Cancel_semigroup_add a,
        Minus a) => Cancel_ab_semigroup_add a where {
};

class (Semigroup_add a, Zero a) => Monoid_add a where {
};

class (Ab_semigroup_add a, Monoid_add a) => Comm_monoid_add a where {
};

class (Cancel_ab_semigroup_add a,
        Comm_monoid_add a) => Cancel_comm_monoid_add a where {
};

class (Times a, Zero a) => Mult_zero a where {
};

class (Times a) => Semigroup_mult a where {
};

class (Ab_semigroup_add a, Semigroup_mult a) => Semiring a where {
};

class (Comm_monoid_add a, Mult_zero a, Semiring a) => Semiring_0 a where {
};

class (Cancel_comm_monoid_add a, Semiring_0 a) => Semiring_0_cancel a where {
};

class (Semigroup_mult a) => Ab_semigroup_mult a where {
};

class (Ab_semigroup_mult a, Semiring a) => Comm_semiring a where {
};

class (Comm_semiring a, Semiring_0 a) => Comm_semiring_0 a where {
};

class (Comm_semiring_0 a,
        Semiring_0_cancel a) => Comm_semiring_0_cancel a where {
};

class (One a, Times a) => Power a where {
};

class (Semigroup_mult a, Power a) => Monoid_mult a where {
};

class (One a, Semigroup_add a) => Numeral a where {
};

class (Monoid_mult a, Numeral a, Semiring a) => Semiring_numeral a where {
};

class (One a, Zero a) => Zero_neq_one a where {
};

class (Semiring_numeral a, Semiring_0 a, Zero_neq_one a) => Semiring_1 a where {
};

class (Semiring_0_cancel a, Semiring_1 a) => Semiring_1_cancel a where {
};

class (Ab_semigroup_mult a, Monoid_mult a, Dvd a) => Comm_monoid_mult a where {
};

class (Comm_monoid_mult a, Comm_semiring_0 a,
        Semiring_1 a) => Comm_semiring_1 a where {
};

class (Comm_semiring_0_cancel a, Comm_semiring_1 a,
        Semiring_1_cancel a) => Comm_semiring_1_cancel a where {
};

class (Comm_semiring_1_cancel a) => Comm_semiring_1_cancel_crossproduct a where {
};

class (Semiring_0 a) => Semiring_no_zero_divisors a where {
};

class (Semiring_1 a,
        Semiring_no_zero_divisors a) => Semiring_1_no_zero_divisors a where {
};

class (Semiring_no_zero_divisors a) => Semiring_no_zero_divisors_cancel a where {
};

class (Cancel_semigroup_add a, Minus a, Monoid_add a,
        Uminus a) => Group_add a where {
};

class (Cancel_comm_monoid_add a, Group_add a) => Ab_group_add a where {
};

class (Ab_group_add a, Semiring_0_cancel a) => Ring a where {
};

class (Ring a,
        Semiring_no_zero_divisors_cancel a) => Ring_no_zero_divisors a where {
};

class (Group_add a, Numeral a) => Neg_numeral a where {
};

class (Neg_numeral a, Ring a, Semiring_1_cancel a) => Ring_1 a where {
};

class (Semiring_1_no_zero_divisors a, Ring_1 a,
        Ring_no_zero_divisors a) => Ring_1_no_zero_divisors a where {
};

class (Comm_semiring_0_cancel a, Ring a) => Comm_ring a where {
};

class (Comm_ring a, Comm_semiring_1_cancel a, Ring_1 a) => Comm_ring_1 a where {
};

class (Semiring_1_no_zero_divisors a,
        Comm_semiring_1_cancel a) => Semidom a where {
};

class (Comm_ring_1 a, Ring_1_no_zero_divisors a, Semidom a,
        Comm_semiring_1_cancel_crossproduct a) => Idom a where {
};

instance Plus Int where {
  plus = plus_int;
};

instance Semigroup_add Int where {
};

instance Cancel_semigroup_add Int where {
};

instance Ab_semigroup_add Int where {
};

instance Minus Int where {
  minus = minus_int;
};

instance Cancel_ab_semigroup_add Int where {
};

instance Monoid_add Int where {
};

instance Comm_monoid_add Int where {
};

instance Cancel_comm_monoid_add Int where {
};

instance Mult_zero Int where {
};

instance Semigroup_mult Int where {
};

instance Semiring Int where {
};

instance Semiring_0 Int where {
};

instance Semiring_0_cancel Int where {
};

instance Ab_semigroup_mult Int where {
};

instance Comm_semiring Int where {
};

instance Comm_semiring_0 Int where {
};

instance Comm_semiring_0_cancel Int where {
};

instance Power Int where {
};

instance Monoid_mult Int where {
};

instance Numeral Int where {
};

instance Semiring_numeral Int where {
};

instance Zero_neq_one Int where {
};

instance Semiring_1 Int where {
};

instance Semiring_1_cancel Int where {
};

instance Comm_monoid_mult Int where {
};

instance Comm_semiring_1 Int where {
};

instance Comm_semiring_1_cancel Int where {
};

instance Comm_semiring_1_cancel_crossproduct Int where {
};

instance Semiring_no_zero_divisors Int where {
};

instance Semiring_1_no_zero_divisors Int where {
};

instance Semiring_no_zero_divisors_cancel Int where {
};

instance Uminus Int where {
  uminusa = uminus_int;
};

instance Group_add Int where {
};

instance Ab_group_add Int where {
};

instance Ring Int where {
};

instance Ring_no_zero_divisors Int where {
};

instance Neg_numeral Int where {
};

instance Ring_1 Int where {
};

instance Ring_1_no_zero_divisors Int where {
};

instance Comm_ring Int where {
};

instance Comm_ring_1 Int where {
};

instance Semidom Int where {
};

instance Idom Int where {
};

class Divide a where {
  divide :: a -> a -> a;
};

class (Divide a, Dvd a) => Div a where {
  mod :: a -> a -> a;
};

instance Divide Int where {
  divide = divide_int;
};

instance Div Int where {
  mod = mod_int;
};

less_eq_int :: Int -> Int -> Bool;
less_eq_int k l = integer_of_int k <= integer_of_int l;

class (Abs a, Minus a, Uminus a, Zero a, Ord a) => Abs_if a where {
};

instance Ord Int where {
  less_eq = less_eq_int;
  less = less_int;
};

instance Abs_if Int where {
};

class (Minus a, One a, Sgn a, Uminus a, Zero a, Ord a) => Sgn_if a where {
};

instance Sgn_if Int where {
};

class (Semiring_1 a) => Semiring_char_0 a where {
};

class (Semiring_char_0 a, Ring_1 a) => Ring_char_0 a where {
};

instance Semiring_char_0 Int where {
};

instance Ring_char_0 Int where {
};

class (Ord a) => Preorder a where {
};

class (Preorder a) => Order a where {
};

instance Preorder Int where {
};

instance Order Int where {
};

unit_factor_int :: Int -> Int;
unit_factor_int = sgn_int;

normalize_int :: Int -> Int;
normalize_int = abs_int;

class (Divide a, Semidom a,
        Semiring_no_zero_divisors_cancel a) => Semidom_divide a where {
};

class (Semidom_divide a) => Algebraic_semidom a where {
};

class (Algebraic_semidom a) => Normalization_semidom a where {
  normalizeb :: a -> a;
  unit_factor :: a -> a;
};

class (Gcd a, Normalization_semidom a) => Semiring_gcd a where {
};

instance Semidom_divide Int where {
};

instance Algebraic_semidom Int where {
};

instance Normalization_semidom Int where {
  normalizeb = normalize_int;
  unit_factor = unit_factor_int;
};

instance Semiring_gcd Int where {
};

ceq_int :: Maybe (Int -> Int -> Bool);
ceq_int = Just equal_int;

class Ceq a where {
  ceq :: Maybe (a -> a -> Bool);
};

instance Ceq Int where {
  ceq = ceq_int;
};

newtype Phantom a b = Phantom b;

data Set_impla = Set_Choose | Set_Collect | Set_DList | Set_RBT | Set_Monada;

set_impl_int :: Phantom Int Set_impla;
set_impl_int = Phantom Set_RBT;

class Set_impl a where {
  set_impl :: Phantom a Set_impla;
};

instance Set_impl Int where {
  set_impl = set_impl_int;
};

class (Order a) => Linorder a where {
};

instance Linorder Int where {
};

class (Ab_semigroup_add a, Order a) => Ordered_ab_semigroup_add a where {
};

class (Cancel_ab_semigroup_add a,
        Ordered_ab_semigroup_add a) => Ordered_cancel_ab_semigroup_add a where {
};

class (Comm_monoid_add a, Ordered_ab_semigroup_add a,
        Semiring a) => Ordered_semiring a where {
};

class (Ordered_cancel_ab_semigroup_add a, Ordered_semiring a,
        Semiring_0_cancel a) => Ordered_cancel_semiring a where {
};

class (Ordered_cancel_ab_semigroup_add a) => Ordered_ab_semigroup_add_imp_le a where {
};

class (Comm_monoid_add a,
        Ordered_cancel_ab_semigroup_add a) => Ordered_comm_monoid_add a where {
};

class (Ab_group_add a, Ordered_ab_semigroup_add_imp_le a,
        Ordered_comm_monoid_add a) => Ordered_ab_group_add a where {
};

class (Ordered_ab_group_add a, Ordered_cancel_semiring a,
        Ring a) => Ordered_ring a where {
};

instance Ordered_ab_semigroup_add Int where {
};

instance Ordered_cancel_ab_semigroup_add Int where {
};

instance Ordered_semiring Int where {
};

instance Ordered_cancel_semiring Int where {
};

instance Ordered_ab_semigroup_add_imp_le Int where {
};

instance Ordered_comm_monoid_add Int where {
};

instance Ordered_ab_group_add Int where {
};

instance Ordered_ring Int where {
};

class (Div a, Algebraic_semidom a) => Semiring_div a where {
};

instance Semiring_div Int where {
};

cEnum_int :: Maybe ([Int], ((Int -> Bool) -> Bool, (Int -> Bool) -> Bool));
cEnum_int = Nothing;

class Cenum a where {
  cEnum :: Maybe ([a], ((a -> Bool) -> Bool, (a -> Bool) -> Bool));
};

instance Cenum Int where {
  cEnum = cEnum_int;
};

class (Ordered_ab_semigroup_add a,
        Linorder a) => Linordered_ab_semigroup_add a where {
};

class (Linordered_ab_semigroup_add a,
        Ordered_ab_semigroup_add_imp_le a) => Linordered_cancel_ab_semigroup_add a where {
};

class (Linordered_cancel_ab_semigroup_add a, Ordered_comm_monoid_add a,
        Ordered_cancel_semiring a) => Linordered_semiring a where {
};

class (Linordered_semiring a) => Linordered_semiring_strict a where {
};

class (Linordered_semiring a, Semiring_1 a) => Linordered_semiring_1 a where {
};

class (Linordered_semiring_1 a,
        Linordered_semiring_strict a) => Linordered_semiring_1_strict a where {
};

class (Abs a, Ordered_ab_group_add a) => Ordered_ab_group_add_abs a where {
};

class (Linordered_cancel_ab_semigroup_add a,
        Ordered_ab_group_add a) => Linordered_ab_group_add a where {
};

class (Abs_if a, Linordered_ab_group_add a, Ordered_ab_group_add_abs a,
        Linordered_semiring a, Ordered_ring a) => Linordered_ring a where {
};

class (Linordered_ring a, Linordered_semiring_strict a,
        Ring_no_zero_divisors a) => Linordered_ring_strict a where {
};

class (Comm_semiring_0 a, Ordered_semiring a) => Ordered_comm_semiring a where {
};

class (Comm_semiring_0_cancel a, Ordered_cancel_semiring a,
        Ordered_comm_semiring a) => Ordered_cancel_comm_semiring a where {
};

class (Linordered_semiring_strict a,
        Ordered_cancel_comm_semiring a) => Linordered_comm_semiring_strict a where {
};

class (Semiring_char_0 a, Linordered_comm_semiring_strict a,
        Semidom a) => Linordered_semidom a where {
};

class (Comm_ring a, Ordered_cancel_comm_semiring a,
        Ordered_ring a) => Ordered_comm_ring a where {
};

class (Ordered_ab_group_add_abs a, Ordered_ring a) => Ordered_ring_abs a where {
};

class (Sgn_if a, Ring_char_0 a, Idom a, Linordered_ring_strict a,
        Linordered_semidom a, Linordered_semiring_1_strict a,
        Ordered_comm_ring a, Ordered_ring_abs a) => Linordered_idom a where {
};

instance Linordered_ab_semigroup_add Int where {
};

instance Linordered_cancel_ab_semigroup_add Int where {
};

instance Linordered_semiring Int where {
};

instance Linordered_semiring_strict Int where {
};

instance Linordered_semiring_1 Int where {
};

instance Linordered_semiring_1_strict Int where {
};

instance Ordered_ab_group_add_abs Int where {
};

instance Linordered_ab_group_add Int where {
};

instance Linordered_ring Int where {
};

instance Linordered_ring_strict Int where {
};

instance Ordered_comm_semiring Int where {
};

instance Ordered_cancel_comm_semiring Int where {
};

instance Linordered_comm_semiring_strict Int where {
};

instance Linordered_semidom Int where {
};

instance Ordered_comm_ring Int where {
};

instance Ordered_ring_abs Int where {
};

instance Linordered_idom Int where {
};

class (Ord a) => Non_strict_order a where {
};

class (Ab_semigroup_add a, Monoid_add a,
        Non_strict_order a) => Ordered_ab_semigroup a where {
};

class (Semiring_0 a, Ordered_ab_semigroup a) => Ordered_semiring_0 a where {
};

class (Semiring_1 a, Ordered_semiring_0 a) => Ordered_semiring_1 a where {
};

class (Comm_semiring_1 a, Ordered_semiring_1 a) => Poly_carrier a where {
};

instance Non_strict_order Int where {
};

instance Ordered_ab_semigroup Int where {
};

instance Ordered_semiring_0 Int where {
};

instance Ordered_semiring_1 Int where {
};

instance Poly_carrier Int where {
};

data Ordera = Eqa | Lt | Gt;

comparator_of :: forall a. (Eq a, Linorder a) => a -> a -> Ordera;
comparator_of x y = (if less x y then Lt else (if x == y then Eqa else Gt));

compare_int :: Int -> Int -> Ordera;
compare_int = comparator_of;

ccompare_int :: Maybe (Int -> Int -> Ordera);
ccompare_int = Just compare_int;

class Ccompare a where {
  ccompare :: Maybe (a -> a -> Ordera);
};

instance Ccompare Int where {
  ccompare = ccompare_int;
};

exact_div_int :: Int -> Int -> Int;
exact_div_int = divide_int;

class (Idom a) => Idom_div a where {
  exact_div :: a -> a -> a;
};

instance Idom_div Int where {
  exact_div = exact_div_int;
};

numeral :: forall a. (Numeral a) => Num -> a;
numeral (Bit1 n) = let {
                     m = numeral n;
                   } in plus (plus m m) onea;
numeral (Bit0 n) = let {
                     m = numeral n;
                   } in plus m m;
numeral One = onea;

of_inta :: forall a. (Ring_1 a) => Int -> a;
of_inta k =
  (if equal_int k zero_int then zeroa
    else (if less_int k zero_int then uminusa (of_inta (uminus_int k))
           else let {
                  l = times (numeral (Bit0 One))
                        (of_inta
                          (divide_int k (Int_of_integer (2 :: Integer))));
                  j = mod_int k (Int_of_integer (2 :: Integer));
                } in (if equal_int j zero_int then l else plus l onea)));

data Poly_type = Monic_Irreducible | Monic_Root_Free | Arbitrary_Poly;

newtype Rat = Frct (Int, Int);

data Root_info = Root_Info (Rat -> Rat -> Nat) (Rat -> Nat);

newtype Poly a = Poly [a];

newtype Real_alg_intern = Abs_real_alg_intern
  (Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))));

data Real_alg_dt = Rationala Rat | Irrational Real_alg_intern;

newtype Real_alg_dtc = Abs_real_alg_dtc Real_alg_dt;

newtype Real_alg = Abstr_real_alg Real_alg_dtc;

newtype Real = Real_of Real_alg;

rep_real_alg_dtc :: Real_alg_dtc -> Real_alg_dt;
rep_real_alg_dtc (Abs_real_alg_dtc x) = x;

data Normalization_mode = No_Guarantee | Root_Free | Irreducible;

rep_real_alg_intern ::
  Real_alg_intern -> Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
rep_real_alg_intern (Abs_real_alg_intern x) = x;

data Factorization_mode = Uncertified_Factorization | Full_Factorization
  | Check_Irreducible | Check_Root_Free;

normalization_to_factorization_mode :: Normalization_mode -> Factorization_mode;
normalization_to_factorization_mode No_Guarantee = Uncertified_Factorization;
normalization_to_factorization_mode Root_Free = Check_Root_Free;
normalization_to_factorization_mode Irreducible = Check_Irreducible;

quotient_of :: Rat -> (Int, Int);
quotient_of (Frct x) = x;

normalize :: (Int, Int) -> (Int, Int);
normalize p =
  (if less_int zero_int (snd p)
    then let {
           a = gcd_int (fst p) (snd p);
         } in (divide_int (fst p) a, divide_int (snd p) a)
    else (if equal_int (snd p) zero_int
           then (zero_int, Int_of_integer (1 :: Integer))
           else let {
                  a = uminus_int (gcd_int (fst p) (snd p));
                } in (divide_int (fst p) a, divide_int (snd p) a)));

divide_rat :: Rat -> Rat -> Rat;
divide_rat p q = Frct (let {
                         a = quotient_of p;
                         (aa, c) = a;
                         b = quotient_of q;
                         (ba, d) = b;
                       } in normalize (times_int aa d, times_int c ba));

plus_rat :: Rat -> Rat -> Rat;
plus_rat p q =
  Frct (let {
          a = quotient_of p;
          (aa, c) = a;
          b = quotient_of q;
          (ba, d) = b;
        } in normalize
               (plus_int (times_int aa d) (times_int ba c), times_int c d));

of_int :: Int -> Rat;
of_int a = Frct (a, Int_of_integer (1 :: Integer));

tighten_poly_bounds :: (Rat -> Rat -> Nat) -> Rat -> Rat -> (Rat, Rat);
tighten_poly_bounds cr l r =
  let {
    m = divide_rat (plus_rat l r) (of_int (Int_of_integer (2 :: Integer)));
  } in (if equal_nat (cr m r) zero_nat then (l, m) else (m, r));

less_eq_rat :: Rat -> Rat -> Bool;
less_eq_rat p q = let {
                    a = quotient_of p;
                    (aa, c) = a;
                    b = quotient_of q;
                    (ba, d) = b;
                  } in less_eq_int (times_int aa d) (times_int c ba);

minus_rat :: Rat -> Rat -> Rat;
minus_rat p q =
  Frct (let {
          a = quotient_of p;
          (aa, c) = a;
          b = quotient_of q;
          (ba, d) = b;
        } in normalize
               (minus_int (times_int aa d) (times_int ba c), times_int c d));

tighten_poly_bounds_epsilon ::
  (Rat -> Rat -> Nat) -> Rat -> Rat -> Rat -> (Rat, Rat);
tighten_poly_bounds_epsilon cr x l r =
  (if less_eq_rat (minus_rat r l) x then (l, r)
    else let {
           (a, b) = tighten_poly_bounds cr l r;
         } in tighten_poly_bounds_epsilon cr x a b);

less_rat :: Rat -> Rat -> Bool;
less_rat p q = let {
                 a = quotient_of p;
                 (aa, c) = a;
                 b = quotient_of q;
                 (ba, d) = b;
               } in less_int (times_int aa d) (times_int c ba);

tighten_poly_bounds_for_x ::
  (Rat -> Rat -> Nat) -> Rat -> Rat -> Rat -> (Rat, Rat);
tighten_poly_bounds_for_x cr x l r =
  (if less_rat x l || less_rat r x then (l, r)
    else let {
           (a, b) = tighten_poly_bounds cr l r;
         } in tighten_poly_bounds_for_x cr x a b);

floor_rat :: Rat -> Int;
floor_rat p = let {
                a = quotient_of p;
                (aa, b) = a;
              } in divide_int aa b;

equal_rat :: Rat -> Rat -> Bool;
equal_rat a b = quotient_of a == quotient_of b;

zero_rat :: Rat;
zero_rat = Frct (zero_int, Int_of_integer (1 :: Integer));

l_r :: Root_info -> Rat -> Rat -> Nat;
l_r (Root_Info x1 x2) = x1;

coeffs :: forall a. (Zero a) => Poly a -> [a];
coeffs (Poly x) = x;

foldr :: forall a b. (a -> b -> b) -> [a] -> b -> b;
foldr f [] = id;
foldr f (x : xs) = f x . foldr f xs;

fold_coeffs :: forall a b. (Zero a) => (a -> b -> b) -> Poly a -> b -> b;
fold_coeffs f p = foldr f (coeffs p);

poly :: forall a. (Comm_semiring_0 a) => Poly a -> a -> a;
poly p = fold_coeffs (\ a f x -> plus a (times x (f x))) p (\ _ -> zeroa);

times_rat :: Rat -> Rat -> Rat;
times_rat p q = Frct (let {
                        a = quotient_of p;
                        (aa, c) = a;
                        b = quotient_of q;
                        (ba, d) = b;
                      } in normalize (times_int aa ba, times_int c d));

instance Times Rat where {
  times = times_rat;
};

instance Semigroup_mult Rat where {
};

instance Ab_semigroup_mult Rat where {
};

instance Plus Rat where {
  plus = plus_rat;
};

instance Semigroup_add Rat where {
};

instance Ab_semigroup_add Rat where {
};

instance Semiring Rat where {
};

instance Comm_semiring Rat where {
};

instance Zero Rat where {
  zeroa = zero_rat;
};

instance Monoid_add Rat where {
};

instance Comm_monoid_add Rat where {
};

instance Mult_zero Rat where {
};

instance Semiring_0 Rat where {
};

instance Comm_semiring_0 Rat where {
};

rai_normalize_bounds_flat ::
  Rat ->
    (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
rai_normalize_bounds_flat eps rai =
  let {
    (un, (ri, (p, (l, r)))) = rai;
    (la, ra) = tighten_poly_bounds_epsilon (l_r ri) eps l r;
    fr = of_int (floor_rat ra);
  } in (if less_eq_rat la fr && equal_rat (poly p fr) zero_rat
         then (un, (ri, (p, (fr, fr))))
         else let {
                (lb, rb) = tighten_poly_bounds_for_x (l_r ri) fr la ra;
              } in (un, (ri, (p, (lb, rb)))));

equal_poly_type :: Poly_type -> Poly_type -> Bool;
equal_poly_type Monic_Root_Free Arbitrary_Poly = False;
equal_poly_type Arbitrary_Poly Monic_Root_Free = False;
equal_poly_type Monic_Irreducible Arbitrary_Poly = False;
equal_poly_type Arbitrary_Poly Monic_Irreducible = False;
equal_poly_type Monic_Irreducible Monic_Root_Free = False;
equal_poly_type Monic_Root_Free Monic_Irreducible = False;
equal_poly_type Arbitrary_Poly Arbitrary_Poly = True;
equal_poly_type Monic_Root_Free Monic_Root_Free = True;
equal_poly_type Monic_Irreducible Monic_Irreducible = True;

factorization_guarantee :: Factorization_mode -> Poly_type;
factorization_guarantee Uncertified_Factorization = Arbitrary_Poly;
factorization_guarantee Full_Factorization = Monic_Irreducible;
factorization_guarantee Check_Irreducible = Monic_Irreducible;
factorization_guarantee Check_Root_Free = Monic_Root_Free;

plus_nat :: Nat -> Nat -> Nat;
plus_nat m n = Nat (integer_of_nat m + integer_of_nat n);

suc :: Nat -> Nat;
suc n = plus_nat n one_nat;

gen_length :: forall a. Nat -> [a] -> Nat;
gen_length n (x : xs) = gen_length (suc n) xs;
gen_length n [] = n;

size_list :: forall a. [a] -> Nat;
size_list = gen_length zero_nat;

minus_nat :: Nat -> Nat -> Nat;
minus_nat m n = Nat (max (0 :: Integer) (integer_of_nat m - integer_of_nat n));

uminus_rat :: Rat -> Rat;
uminus_rat p = Frct (let {
                       a = quotient_of p;
                       (aa, b) = a;
                     } in (uminus_int aa, b));

sgn_rat :: Rat -> Rat;
sgn_rat p = Frct (sgn_int (fst (quotient_of p)), Int_of_integer (1 :: Integer));

dvd :: forall a. (Semiring_div a, Eq a) => a -> a -> Bool;
dvd a b = mod b a == zeroa;

degreea :: forall a. (Zero a) => Poly a -> Nat;
degreea p = minus_nat (size_list (coeffs p)) one_nat;

nth :: forall a. [a] -> Nat -> a;
nth (x : xs) n =
  (if equal_nat n zero_nat then x else nth xs (minus_nat n one_nat));

nth_default :: forall a. a -> [a] -> Nat -> a;
nth_default dflt xs n = (if less_nat n (size_list xs) then nth xs n else dflt);

coeff :: forall a. (Zero a) => Poly a -> Nat -> a;
coeff p = nth_default zeroa (coeffs p);

times_nat :: Nat -> Nat -> Nat;
times_nat m n = Nat (integer_of_nat m * integer_of_nat n);

instance Plus Nat where {
  plus = plus_nat;
};

instance Semigroup_add Nat where {
};

instance Ab_semigroup_add Nat where {
};

instance Zero Nat where {
  zeroa = zero_nat;
};

instance Monoid_add Nat where {
};

instance Comm_monoid_add Nat where {
};

instance Times Nat where {
  times = times_nat;
};

instance Mult_zero Nat where {
};

instance Semigroup_mult Nat where {
};

instance Semiring Nat where {
};

instance Semiring_0 Nat where {
};

instance Semiring_no_zero_divisors Nat where {
};

instance Semiring_no_zero_divisors_cancel Nat where {
};

instance One Nat where {
  onea = one_nat;
};

instance Power Nat where {
};

instance Monoid_mult Nat where {
};

instance Numeral Nat where {
};

instance Semiring_numeral Nat where {
};

instance Zero_neq_one Nat where {
};

instance Semiring_1 Nat where {
};

instance Semiring_1_no_zero_divisors Nat where {
};

instance Cancel_semigroup_add Nat where {
};

instance Minus Nat where {
  minus = minus_nat;
};

instance Cancel_ab_semigroup_add Nat where {
};

instance Cancel_comm_monoid_add Nat where {
};

instance Semiring_0_cancel Nat where {
};

instance Ab_semigroup_mult Nat where {
};

instance Comm_semiring Nat where {
};

instance Comm_semiring_0 Nat where {
};

instance Comm_semiring_0_cancel Nat where {
};

instance Semiring_1_cancel Nat where {
};

instance Dvd Nat where {
};

instance Comm_monoid_mult Nat where {
};

instance Comm_semiring_1 Nat where {
};

instance Comm_semiring_1_cancel Nat where {
};

instance Semidom Nat where {
};

instance Divide Nat where {
  divide = divide_nat;
};

instance Semidom_divide Nat where {
};

instance Algebraic_semidom Nat where {
};

instance Div Nat where {
  mod = mod_nat;
};

instance Semiring_div Nat where {
};

instance Eq Nat where {
  a == b = equal_nat a b;
};

poly_neg_inf_rat :: Poly Rat -> Rat;
poly_neg_inf_rat p =
  (if dvd (nat_of_integer (2 :: Integer)) (degreea p)
    then sgn_rat (coeff p (degreea p))
    else uminus_rat (sgn_rat (coeff p (degreea p))));

remdups_adj :: forall a. (Eq a) => [a] -> [a];
remdups_adj [] = [];
remdups_adj [x] = [x];
remdups_adj (x : y : xs) =
  (if x == y then remdups_adj (x : xs) else x : remdups_adj (y : xs));

instance Eq Rat where {
  a == b = equal_rat a b;
};

sign_changes_neg_inf_rat :: [Poly Rat] -> Nat;
sign_changes_neg_inf_rat ps =
  minus_nat
    (size_list
      (remdups_adj
        (filter (\ x -> not (equal_rat x zero_rat)) (map poly_neg_inf_rat ps))))
    one_nat;

uminus_poly :: forall a. (Ab_group_add a) => Poly a -> Poly a;
uminus_poly p = Poly (map uminusa (coeffs p));

cCons :: forall a. (Zero a, Eq a) => a -> [a] -> [a];
cCons x xs = (if null xs && x == zeroa then [] else x : xs);

plus_coeffs :: forall a. (Comm_monoid_add a, Eq a) => [a] -> [a] -> [a];
plus_coeffs xs [] = xs;
plus_coeffs [] (v : va) = v : va;
plus_coeffs (x : xs) (y : ys) = cCons (plus x y) (plus_coeffs xs ys);

plus_poly :: forall a. (Comm_monoid_add a, Eq a) => Poly a -> Poly a -> Poly a;
plus_poly p q = Poly (plus_coeffs (coeffs p) (coeffs q));

minus_poly :: forall a. (Ab_group_add a, Eq a) => Poly a -> Poly a -> Poly a;
minus_poly p q = plus_poly p (uminus_poly q);

zero_polya :: forall a. (Zero a) => Poly a;
zero_polya = Poly [];

class (Divide a) => Inverse a where {
  inverse :: a -> a;
};

is_zero :: forall a. (Zero a) => Poly a -> Bool;
is_zero p = null (coeffs p);

smult :: forall a. (Eq a, Idom a) => a -> Poly a -> Poly a;
smult a p = Poly (if a == zeroa then [] else map (times a) (coeffs p));

pCons :: forall a. (Zero a, Eq a) => a -> Poly a -> Poly a;
pCons a p = Poly (cCons a (coeffs p));

class (Idom a) => Ufd a where {
};

class (Inverse a, Ring_1_no_zero_divisors a) => Division_ring a where {
};

class (Idom a, Semidom_divide a) => Idom_divide a where {
};

class (Division_ring a, Idom_divide a, Ufd a) => Field a where {
};

pdivmod :: forall a. (Field a, Eq a) => Poly a -> Poly a -> (Poly a, Poly a);
pdivmod p q =
  (if is_zero q then (zero_polya, p)
    else let {
           n = degreea q;
           x = inverse (coeff q n);
         } in fold_coeffs
                (\ a (s, r) -> let {
                                 ar = pCons a r;
                                 b = times (coeff ar n) x;
                               } in (pCons b s, minus_poly ar (smult b q)))
                p (zero_polya, zero_polya));

divide_poly :: forall a. (Field a, Eq a) => Poly a -> Poly a -> Poly a;
divide_poly p q = fst (pdivmod p q);

inverse_rat :: Rat -> Rat;
inverse_rat p =
  Frct (let {
          a = quotient_of p;
          (aa, b) = a;
        } in (if equal_int aa zero_int
               then (zero_int, Int_of_integer (1 :: Integer))
               else (times_int (sgn_int aa) b, abs_int aa)));

equal_poly :: forall a. (Zero a, Eq a) => Poly a -> Poly a -> Bool;
equal_poly p q = coeffs p == coeffs q;

times_poly :: forall a. (Eq a, Idom a) => Poly a -> Poly a -> Poly a;
times_poly p q =
  fold_coeffs (\ a pa -> plus_poly (smult a q) (pCons zeroa pa)) p zero_polya;

replicate :: forall a. Nat -> a -> [a];
replicate n x =
  (if equal_nat n zero_nat then [] else x : replicate (minus_nat n one_nat) x);

monom :: forall a. (Zero a, Eq a) => a -> Nat -> Poly a;
monom a n = Poly (if a == zeroa then [] else replicate n zeroa ++ [a]);

pseudo_mod_main ::
  forall a. (Eq a, Idom_div a) => a -> Poly a -> Poly a -> Nat -> Nat -> Poly a;
pseudo_mod_main lc r d dr n =
  (if equal_nat n zero_nat then r
    else let {
           rr = smult lc r;
           a = coeff rr dr;
           qq = exact_div a lc;
           n1 = minus_nat n one_nat;
           b = monom qq n1;
           rrr = minus_poly rr (times_poly b d);
         } in pseudo_mod_main lc rrr d (minus_nat dr one_nat) n1);

pseudo_mod :: forall a. (Eq a, Idom_div a) => Poly a -> Poly a -> Poly a;
pseudo_mod p q =
  let {
    dp = degreea p;
    dq = degreea q;
  } in pseudo_mod_main (coeff q dq) p q dp (minus_nat (plus_nat one_nat dp) dq);

map_poly :: forall a b. (Zero a, Zero b, Eq b) => (a -> b) -> Poly a -> Poly b;
map_poly f p = fold_coeffs (\ c -> pCons (f c)) p zero_polya;

div_poly :: forall a. (Semiring_div a, Eq a) => a -> Poly a -> Poly a;
div_poly a p = map_poly (\ c -> divide c a) p;

list_gcd :: forall a. (Semiring_gcd a) => [a] -> a;
list_gcd xs = foldr gcd xs zeroa;

content :: forall a. (Semiring_gcd a) => Poly a -> a;
content p = list_gcd (coeffs p);

normalize_content ::
  forall a. (Semiring_div a, Semiring_gcd a, Eq a) => Poly a -> Poly a;
normalize_content p = div_poly (content p) p;

primitive_prs :: Poly Int -> Poly Int -> Poly Int;
primitive_prs f g =
  (if equal_poly g zero_polya then f else let {
    r = pseudo_mod f g;
    a = normalize_content r;
  } in primitive_prs g a);

gcd_int_poly :: Poly Int -> Poly Int -> Poly Int;
gcd_int_poly f g = let {
                     cf = content f;
                     cg = content g;
                     fa = div_poly cf f;
                     ga = div_poly cg g;
                   } in smult (gcd_int cf cg) (primitive_prs fa ga);

list_lcm :: forall a. (Semiring_gcd a) => [a] -> a;
list_lcm xs = foldr lcm xs onea;

common_denom :: [Rat] -> (Int, [Int]);
common_denom xs = let {
                    nds = map quotient_of xs;
                    denom = list_lcm (map snd nds);
                    a = map (\ (n, a) -> divide_int (times_int n denom) a) nds;
                  } in (denom, a);

rat_to_int_poly :: Poly Rat -> (Int, Poly Int);
rat_to_int_poly p =
  let {
    ais = coeffs p;
    d = fst (common_denom ais);
  } in (d, map_poly (\ x -> let {
                              (pa, a) = quotient_of x;
                            } in divide_int (times_int pa d) a)
             p);

one_rat :: Rat;
one_rat = Frct (Int_of_integer (1 :: Integer), Int_of_integer (1 :: Integer));

instance Cancel_semigroup_add Rat where {
};

instance Minus Rat where {
  minus = minus_rat;
};

instance Cancel_ab_semigroup_add Rat where {
};

instance Cancel_comm_monoid_add Rat where {
};

instance Semiring_0_cancel Rat where {
};

instance Comm_semiring_0_cancel Rat where {
};

instance One Rat where {
  onea = one_rat;
};

instance Power Rat where {
};

instance Monoid_mult Rat where {
};

instance Numeral Rat where {
};

instance Semiring_numeral Rat where {
};

instance Zero_neq_one Rat where {
};

instance Semiring_1 Rat where {
};

instance Semiring_1_cancel Rat where {
};

instance Dvd Rat where {
};

instance Comm_monoid_mult Rat where {
};

instance Comm_semiring_1 Rat where {
};

instance Comm_semiring_1_cancel Rat where {
};

instance Comm_semiring_1_cancel_crossproduct Rat where {
};

instance Semiring_no_zero_divisors Rat where {
};

instance Semiring_1_no_zero_divisors Rat where {
};

instance Semiring_no_zero_divisors_cancel Rat where {
};

instance Uminus Rat where {
  uminusa = uminus_rat;
};

instance Group_add Rat where {
};

instance Ab_group_add Rat where {
};

instance Ring Rat where {
};

instance Ring_no_zero_divisors Rat where {
};

instance Neg_numeral Rat where {
};

instance Ring_1 Rat where {
};

instance Ring_1_no_zero_divisors Rat where {
};

instance Comm_ring Rat where {
};

instance Comm_ring_1 Rat where {
};

instance Semidom Rat where {
};

instance Idom Rat where {
};

gcd_rat_poly :: Poly Rat -> Poly Rat -> Poly Rat;
gcd_rat_poly f g = let {
                     fa = snd (rat_to_int_poly f);
                     ga = snd (rat_to_int_poly g);
                     h = map_poly of_int (gcd_int_poly fa ga);
                   } in smult (inverse_rat (coeff h (degreea h))) h;

mod_poly :: forall a. (Field a, Eq a) => Poly a -> Poly a -> Poly a;
mod_poly p q = snd (pdivmod p q);

instance Ufd Rat where {
};

instance Divide Rat where {
  divide = divide_rat;
};

instance Inverse Rat where {
  inverse = inverse_rat;
};

instance Division_ring Rat where {
};

instance Semidom_divide Rat where {
};

instance Idom_divide Rat where {
};

instance Field Rat where {
};

sturm_aux_rat :: Poly Rat -> Poly Rat -> [Poly Rat];
sturm_aux_rat p q =
  (if equal_nat (degreea q) zero_nat then [p, q]
    else p : sturm_aux_rat q (uminus_poly (mod_poly p q)));

pderiv_coeffs_code :: forall a. (Eq a, Semidom a) => a -> [a] -> [a];
pderiv_coeffs_code f (x : xs) =
  cCons (times f x) (pderiv_coeffs_code (plus f onea) xs);
pderiv_coeffs_code f [] = [];

tla :: forall a. [a] -> [a];
tla [] = [];
tla (x21 : x22) = x22;

pderiv_coeffs :: forall a. (Eq a, Semidom a) => [a] -> [a];
pderiv_coeffs xs = pderiv_coeffs_code onea (tla xs);

pderiv :: forall a. (Eq a, Semidom a) => Poly a -> Poly a;
pderiv p = Poly (pderiv_coeffs (coeffs p));

sturm_rat :: Poly Rat -> [Poly Rat];
sturm_rat p = sturm_aux_rat p (pderiv p);

sturm_squarefree_rat :: Poly Rat -> [Poly Rat];
sturm_squarefree_rat p = sturm_rat (divide_poly p (gcd_rat_poly p (pderiv p)));

sign_changes_rat :: [Poly Rat] -> Rat -> Nat;
sign_changes_rat ps x =
  minus_nat
    (size_list
      (remdups_adj
        (filter (\ xa -> not (equal_rat xa zero_rat))
          (map (\ p -> sgn_rat (poly p x)) ps))))
    one_nat;

count_roots_interval_rat :: Poly Rat -> Root_info;
count_roots_interval_rat p =
  let {
    ps = sturm_squarefree_rat p;
  } in Root_Info
         (\ a b ->
           plus_nat (minus_nat (sign_changes_rat ps a) (sign_changes_rat ps b))
             (if equal_rat (poly p a) zero_rat then one_nat else zero_nat))
         (\ a ->
           minus_nat (sign_changes_neg_inf_rat ps) (sign_changes_rat ps a));

rai_normalize_poly_main ::
  Factorization_mode ->
    Rat ->
      Rat -> [Poly Rat] -> (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
rai_normalize_poly_main mode l r (p : ps) =
  let {
    ri = count_roots_interval_rat p;
  } in (if equal_nat (l_r ri l r) zero_nat
         then rai_normalize_poly_main mode l r ps
         else (factorization_guarantee mode, (ri, (p, (l, r)))));

equal_factorization_mode :: Factorization_mode -> Factorization_mode -> Bool;
equal_factorization_mode Check_Irreducible Check_Root_Free = False;
equal_factorization_mode Check_Root_Free Check_Irreducible = False;
equal_factorization_mode Full_Factorization Check_Root_Free = False;
equal_factorization_mode Check_Root_Free Full_Factorization = False;
equal_factorization_mode Full_Factorization Check_Irreducible = False;
equal_factorization_mode Check_Irreducible Full_Factorization = False;
equal_factorization_mode Uncertified_Factorization Check_Root_Free = False;
equal_factorization_mode Check_Root_Free Uncertified_Factorization = False;
equal_factorization_mode Uncertified_Factorization Check_Irreducible = False;
equal_factorization_mode Check_Irreducible Uncertified_Factorization = False;
equal_factorization_mode Uncertified_Factorization Full_Factorization = False;
equal_factorization_mode Full_Factorization Uncertified_Factorization = False;
equal_factorization_mode Check_Root_Free Check_Root_Free = True;
equal_factorization_mode Check_Irreducible Check_Irreducible = True;
equal_factorization_mode Full_Factorization Full_Factorization = True;
equal_factorization_mode Uncertified_Factorization Uncertified_Factorization =
  True;

map_prod :: forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d);
map_prod f g (a, b) = (f a, g b);

divmod_nat :: Nat -> Nat -> (Nat, Nat);
divmod_nat m n =
  let {
    k = integer_of_nat m;
    l = integer_of_nat n;
  } in map_prod nat_of_integer nat_of_integer
         (if k == (0 :: Integer) then ((0 :: Integer), (0 :: Integer))
           else (if l == (0 :: Integer) then ((0 :: Integer), k)
                  else divMod ( k ) ( l )));

binary_power :: forall a. (Monoid_mult a) => a -> Nat -> a;
binary_power x n =
  (if equal_nat n zero_nat then onea
    else let {
           (d, r) = divmod_nat n (nat_of_integer (2 :: Integer));
           rec = binary_power (times x x) d;
         } in (if equal_nat r zero_nat then rec else times rec x));

normalize_content_f :: [Int] -> [Int];
normalize_content_f f = let {
                          ct = list_gcd f;
                        } in map (\ x -> divide_int x ct) f;

coeff_0_int_poly :: [Int] -> Int;
coeff_0_int_poly (x : xs) = x;
coeff_0_int_poly [] = zero_int;

sublists_i_n_main ::
  forall a b. (a -> b -> b) -> b -> [a] -> Nat -> Nat -> [(b, [a])];
sublists_i_n_main f b xs i n =
  (if equal_nat i zero_nat then [(b, [])]
    else (if equal_nat i n then [(foldr f xs b, xs)]
           else let {
                  (y : ys) = xs;
                } in map (\ (c, zs) -> (c, y : zs))
                       (sublists_i_n_main f (f y b) ys (minus_nat i one_nat)
                         (minus_nat n one_nat)) ++
                       sublists_i_n_main f b ys i (minus_nat n one_nat)));

sublists_length :: forall a b. (a -> b -> b) -> b -> Nat -> [a] -> [(b, [a])];
sublists_length f b i xs =
  let {
    n = size_list xs;
  } in (if less_nat n i then [] else sublists_i_n_main f b xs i n);

minus_poly_rev_int :: [Int] -> [Int] -> [Int];
minus_poly_rev_int (x : xs) (y : ys) = minus_int x y : minus_poly_rev_int xs ys;
minus_poly_rev_int xs [] = xs;

divmod_int :: Int -> Int -> (Int, Int);
divmod_int m n =
  map_prod Int_of_integer Int_of_integer
    (divmod_integer (integer_of_int m) (integer_of_int n));

hda :: forall a. [a] -> a;
hda (x21 : x22) = x21;

dvd_poly_int_main :: Int -> [Int] -> [Int] -> Nat -> Bool;
dvd_poly_int_main lc r d n =
  (if equal_nat n zero_nat then all (equal_int zero_int) r
    else let {
           a = hda r;
           (q, re) = divmod_int a lc;
         } in equal_int re zero_int &&
                let {
                  n1 = minus_nat n one_nat;
                  rr = tla (if equal_int q zero_int then r
                             else minus_poly_rev_int r (map (times_int q) d));
                } in dvd_poly_int_main lc rr d n1);

degree_poly_f :: forall a. [a] -> Nat;
degree_poly_f pp = minus_nat (size_list pp) one_nat;

last :: forall a. [a] -> a;
last (x : xs) = (if null xs then x else last xs);

dvd_int_poly_f :: [Int] -> [Int] -> Bool;
dvd_int_poly_f q p =
  let {
    dp = degree_poly_f p;
    dq = degree_poly_f q;
  } in dvd_poly_int_main (last q) (reverse p) (reverse q)
         (minus_nat (plus_nat one_nat dp) dq);

smult_poly_int :: Int -> [Int] -> [Int];
smult_poly_int a pp =
  (if equal_int a zero_int then [] else map (times_int a) pp);

uminus_poly_int :: [Int] -> [Int];
uminus_poly_int = map uminus_int;

cCons_int :: Int -> [Int] -> [Int];
cCons_int x xs = (if null xs && equal_int x zero_int then [] else x : xs);

minus_poly_int :: [Int] -> [Int] -> [Int];
minus_poly_int (x : xs) (y : ys) =
  cCons_int (minus_int x y) (minus_poly_int xs ys);
minus_poly_int xs [] = xs;
minus_poly_int [] (v : va) = uminus_poly_int (v : va);

coeff_poly_int :: [Int] -> Nat -> Int;
coeff_poly_int = nth_default zero_int;

div_int_poly_ff :: [Int] -> [Int] -> Maybe [Int];
div_int_poly_ff pp q =
  let {
    n = degree_poly_f q;
    qn = coeff_poly_int q n;
  } in (case foldr (\ a b ->
                     (case b of {
                       Nothing -> Nothing;
                       Just (s, r) ->
                         let {
                           ar = cCons_int a r;
                           (ba, m) = divmod_int (coeff_poly_int ar n) qn;
                         } in (if equal_int m zero_int
                                then Just (cCons_int ba s,
    minus_poly_int ar (smult_poly_int ba q))
                                else Nothing);
                     }))
               pp (Just ([], []))
         of {
         Nothing -> Nothing;
         Just (d, m) -> (if null m then Just d else Nothing);
       });

div_int_poly_f :: [Int] -> [Int] -> [Int];
div_int_poly_f p q =
  (case div_int_poly_ff p q of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "integer poly division error" (\ _ -> []);
    Just d -> d;
  });

mod_int_poly :: Int -> [Int] -> [Int];
mod_int_poly n f = let {
                     g = map (\ x -> mod_int x n) f;
                   } in foldr cCons g [];

int_poly_bnd :: Int -> [Int] -> [Int];
int_poly_bnd b =
  map (\ x ->
        (if less_eq_int (times_int (Int_of_integer (2 :: Integer)) x) b then x
          else minus_int x b));

data Ffield_ext a b =
  Ffield_ext (a -> a -> a) (a -> a -> a) (a -> a) (a -> a -> a) (a -> Nat -> a)
    (a -> a) (a -> a -> a) a a Int (Int -> a) (a -> Int) b;

fast_power :: forall a. (a -> a -> a) -> a -> a -> Nat -> a;
fast_power mult one x n =
  (if equal_nat n zero_nat then one
    else let {
           (d, r) = divmod_nat n (nat_of_integer (2 :: Integer));
           rec = fast_power mult one (mult x x) d;
         } in (if equal_nat r one_nat then mult x rec else rec));

integer_ops :: Ffield_ext Int ();
integer_ops =
  Ffield_ext plus_int minus_int uminus_int times_int
    (fast_power times_int (Int_of_integer (1 :: Integer))) (\ _ -> zero_int)
    (\ _ _ -> zero_int) zero_int (Int_of_integer (1 :: Integer)) zero_int id id
    ();

mul_const :: Int -> [Int] -> Int -> Int;
mul_const m p c = mod_int (times_int (coeff_0_int_poly p) c) m;

zerob :: forall a b. Ffield_ext a b -> a;
zerob (Ffield_ext plus minus uminus mult power inverse_f divide zero one
        characteristic of_int_f to_int_f more)
  = zero;

multa :: forall a b. Ffield_ext a b -> a -> a -> a;
multa (Ffield_ext plus minus uminus mult power inverse_f divide zero one
        characteristic of_int_f to_int_f more)
  = mult;

smult_poly_f :: forall a. (Eq a) => Ffield_ext a () -> a -> [a] -> [a];
smult_poly_f f a pp = (if a == zerob f then [] else map (multa f a) pp);

cCons_f :: forall a. (Eq a) => Ffield_ext a () -> a -> [a] -> [a];
cCons_f f x xs = (if null xs && x == zerob f then [] else x : xs);

plusa :: forall a b. Ffield_ext a b -> a -> a -> a;
plusa (Ffield_ext plus minus uminus mult power inverse_f divide zero one
        characteristic of_int_f to_int_f more)
  = plus;

plus_poly_f :: forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> [a];
plus_poly_f f (x : xs) (y : ys) = cCons_f f (plusa f x y) (plus_poly_f f xs ys);
plus_poly_f f xs [] = xs;
plus_poly_f f [] (v : va) = v : va;

times_poly_f :: forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> [a];
times_poly_f f pp qq =
  foldr (\ a pa -> plus_poly_f f (smult_poly_f f a qq) (cCons_f f (zerob f) pa))
    pp [];

oneb :: forall a b. Ffield_ext a b -> a;
oneb (Ffield_ext plus minus uminus mult power inverse_f divide zero one
       characteristic of_int_f to_int_f more)
  = one;

listprod_poly_f :: forall a. (Eq a) => Ffield_ext a () -> [[a]] -> [a];
listprod_poly_f f (x : xs) = times_poly_f f x (listprod_poly_f f xs);
listprod_poly_f f [] = [oneb f];

remove1 :: forall a. (Eq a) => a -> [a] -> [a];
remove1 x [] = [];
remove1 x (y : xs) = (if x == y then xs else y : remove1 x xs);

factorization_f_to_factorization_int ::
  Int ->
    [Int] ->
      [Int] ->
        Int -> Nat -> Nat -> [[Int]] -> [[Int]] -> [(Int, [[Int]])] -> [[Int]];
factorization_f_to_factorization_int m u luu lu d r vs res cands =
  (case cands of {
    [] -> let {
            da = plus_nat d one_nat;
          } in (if less_nat r (times_nat (nat_of_integer (2 :: Integer)) da)
                 then u : res
                 else factorization_f_to_factorization_int m u luu lu da r vs
                        res (sublists_length (mul_const m) lu da vs));
    (lv, ws) : candsa ->
      let {
        lva = (if less_eq_int (times_int (Int_of_integer (2 :: Integer)) lv) m
                then lv else minus_int lv m);
      } in (if dvd lva (coeff_0_int_poly luu)
             then let {
                    z = integer_ops;
                    v = int_poly_bnd m
                          (mod_int_poly m
                            (smult_poly_f z lu (listprod_poly_f z ws)));
                  } in (if dvd_int_poly_f v luu
                         then let {
                                vv = normalize_content_f v;
                                ua = div_int_poly_f u vv;
                                lua = last ua;
                                luua = smult_poly_f z lua ua;
                                vsa = foldr remove1 ws vs;
                                resa = vv : res;
                                ra = minus_nat r (size_list ws);
                              } in (if less_nat ra
 (times_nat (nat_of_integer (2 :: Integer)) d)
                                     then ua : resa
                                     else factorization_f_to_factorization_int m
    ua luua lua d ra vsa resa (sublists_length (mul_const m) lua d vsa))
                         else factorization_f_to_factorization_int m u luu lu d
                                r vs res candsa)
             else factorization_f_to_factorization_int m u luu lu d r vs res
                    candsa);
  });

primes_1000 :: [Nat];
primes_1000 =
  [nat_of_integer (2 :: Integer), nat_of_integer (3 :: Integer),
    nat_of_integer (5 :: Integer), nat_of_integer (7 :: Integer),
    nat_of_integer (11 :: Integer), nat_of_integer (13 :: Integer),
    nat_of_integer (17 :: Integer), nat_of_integer (19 :: Integer),
    nat_of_integer (23 :: Integer), nat_of_integer (29 :: Integer),
    nat_of_integer (31 :: Integer), nat_of_integer (37 :: Integer),
    nat_of_integer (41 :: Integer), nat_of_integer (43 :: Integer),
    nat_of_integer (47 :: Integer), nat_of_integer (53 :: Integer),
    nat_of_integer (59 :: Integer), nat_of_integer (61 :: Integer),
    nat_of_integer (67 :: Integer), nat_of_integer (71 :: Integer),
    nat_of_integer (73 :: Integer), nat_of_integer (79 :: Integer),
    nat_of_integer (83 :: Integer), nat_of_integer (89 :: Integer),
    nat_of_integer (97 :: Integer), nat_of_integer (101 :: Integer),
    nat_of_integer (103 :: Integer), nat_of_integer (107 :: Integer),
    nat_of_integer (109 :: Integer), nat_of_integer (113 :: Integer),
    nat_of_integer (127 :: Integer), nat_of_integer (131 :: Integer),
    nat_of_integer (137 :: Integer), nat_of_integer (139 :: Integer),
    nat_of_integer (149 :: Integer), nat_of_integer (151 :: Integer),
    nat_of_integer (157 :: Integer), nat_of_integer (163 :: Integer),
    nat_of_integer (167 :: Integer), nat_of_integer (173 :: Integer),
    nat_of_integer (179 :: Integer), nat_of_integer (181 :: Integer),
    nat_of_integer (191 :: Integer), nat_of_integer (193 :: Integer),
    nat_of_integer (197 :: Integer), nat_of_integer (199 :: Integer),
    nat_of_integer (211 :: Integer), nat_of_integer (223 :: Integer),
    nat_of_integer (227 :: Integer), nat_of_integer (229 :: Integer),
    nat_of_integer (233 :: Integer), nat_of_integer (239 :: Integer),
    nat_of_integer (241 :: Integer), nat_of_integer (251 :: Integer),
    nat_of_integer (257 :: Integer), nat_of_integer (263 :: Integer),
    nat_of_integer (269 :: Integer), nat_of_integer (271 :: Integer),
    nat_of_integer (277 :: Integer), nat_of_integer (281 :: Integer),
    nat_of_integer (283 :: Integer), nat_of_integer (293 :: Integer),
    nat_of_integer (307 :: Integer), nat_of_integer (311 :: Integer),
    nat_of_integer (313 :: Integer), nat_of_integer (317 :: Integer),
    nat_of_integer (331 :: Integer), nat_of_integer (337 :: Integer),
    nat_of_integer (347 :: Integer), nat_of_integer (349 :: Integer),
    nat_of_integer (353 :: Integer), nat_of_integer (359 :: Integer),
    nat_of_integer (367 :: Integer), nat_of_integer (373 :: Integer),
    nat_of_integer (379 :: Integer), nat_of_integer (383 :: Integer),
    nat_of_integer (389 :: Integer), nat_of_integer (397 :: Integer),
    nat_of_integer (401 :: Integer), nat_of_integer (409 :: Integer),
    nat_of_integer (419 :: Integer), nat_of_integer (421 :: Integer),
    nat_of_integer (431 :: Integer), nat_of_integer (433 :: Integer),
    nat_of_integer (439 :: Integer), nat_of_integer (443 :: Integer),
    nat_of_integer (449 :: Integer), nat_of_integer (457 :: Integer),
    nat_of_integer (461 :: Integer), nat_of_integer (463 :: Integer),
    nat_of_integer (467 :: Integer), nat_of_integer (479 :: Integer),
    nat_of_integer (487 :: Integer), nat_of_integer (491 :: Integer),
    nat_of_integer (499 :: Integer), nat_of_integer (503 :: Integer),
    nat_of_integer (509 :: Integer), nat_of_integer (521 :: Integer),
    nat_of_integer (523 :: Integer), nat_of_integer (541 :: Integer),
    nat_of_integer (547 :: Integer), nat_of_integer (557 :: Integer),
    nat_of_integer (563 :: Integer), nat_of_integer (569 :: Integer),
    nat_of_integer (571 :: Integer), nat_of_integer (577 :: Integer),
    nat_of_integer (587 :: Integer), nat_of_integer (593 :: Integer),
    nat_of_integer (599 :: Integer), nat_of_integer (601 :: Integer),
    nat_of_integer (607 :: Integer), nat_of_integer (613 :: Integer),
    nat_of_integer (617 :: Integer), nat_of_integer (619 :: Integer),
    nat_of_integer (631 :: Integer), nat_of_integer (641 :: Integer),
    nat_of_integer (643 :: Integer), nat_of_integer (647 :: Integer),
    nat_of_integer (653 :: Integer), nat_of_integer (659 :: Integer),
    nat_of_integer (661 :: Integer), nat_of_integer (673 :: Integer),
    nat_of_integer (677 :: Integer), nat_of_integer (683 :: Integer),
    nat_of_integer (691 :: Integer), nat_of_integer (701 :: Integer),
    nat_of_integer (709 :: Integer), nat_of_integer (719 :: Integer),
    nat_of_integer (727 :: Integer), nat_of_integer (733 :: Integer),
    nat_of_integer (739 :: Integer), nat_of_integer (743 :: Integer),
    nat_of_integer (751 :: Integer), nat_of_integer (757 :: Integer),
    nat_of_integer (761 :: Integer), nat_of_integer (769 :: Integer),
    nat_of_integer (773 :: Integer), nat_of_integer (787 :: Integer),
    nat_of_integer (797 :: Integer), nat_of_integer (809 :: Integer),
    nat_of_integer (811 :: Integer), nat_of_integer (821 :: Integer),
    nat_of_integer (823 :: Integer), nat_of_integer (827 :: Integer),
    nat_of_integer (829 :: Integer), nat_of_integer (839 :: Integer),
    nat_of_integer (853 :: Integer), nat_of_integer (857 :: Integer),
    nat_of_integer (859 :: Integer), nat_of_integer (863 :: Integer),
    nat_of_integer (877 :: Integer), nat_of_integer (881 :: Integer),
    nat_of_integer (883 :: Integer), nat_of_integer (887 :: Integer),
    nat_of_integer (907 :: Integer), nat_of_integer (911 :: Integer),
    nat_of_integer (919 :: Integer), nat_of_integer (929 :: Integer),
    nat_of_integer (937 :: Integer), nat_of_integer (941 :: Integer),
    nat_of_integer (947 :: Integer), nat_of_integer (953 :: Integer),
    nat_of_integer (967 :: Integer), nat_of_integer (971 :: Integer),
    nat_of_integer (977 :: Integer), nat_of_integer (983 :: Integer),
    nat_of_integer (991 :: Integer), nat_of_integer (997 :: Integer)];

next_candidates :: Nat -> (Nat, [Nat]);
next_candidates n =
  (if equal_nat n zero_nat then (nat_of_integer (1001 :: Integer), primes_1000)
    else (plus_nat n (nat_of_integer (30 :: Integer)),
           [n, plus_nat n (nat_of_integer (2 :: Integer)),
             plus_nat n (nat_of_integer (6 :: Integer)),
             plus_nat n (nat_of_integer (8 :: Integer)),
             plus_nat n (nat_of_integer (12 :: Integer)),
             plus_nat n (nat_of_integer (18 :: Integer)),
             plus_nat n (nat_of_integer (20 :: Integer)),
             plus_nat n (nat_of_integer (26 :: Integer))]));

less_eq_nat :: Nat -> Nat -> Bool;
less_eq_nat m n = integer_of_nat m <= integer_of_nat n;

prime_nat_main :: Nat -> Nat -> [Nat] -> Bool;
prime_nat_main n j is =
  (case is of {
    [] -> let {
            (a, b) = next_candidates j;
          } in prime_nat_main n a b;
    i : isa ->
      (if dvd i n then less_eq_nat n i
        else (if less_eq_nat (times_nat i i) n then prime_nat_main n j isa
               else True));
  });

prime_nat :: Nat -> Bool;
prime_nat n =
  (if less_nat n (nat_of_integer (2 :: Integer)) then False
    else let {
           (a, b) = next_candidates zero_nat;
         } in prime_nat_main n a b);

prime :: Nat -> Bool;
prime = prime_nat;

next_primes :: Nat -> (Nat, [Nat]);
next_primes n =
  (if equal_nat n zero_nat then let {
                                  (m, ps) = next_candidates zero_nat;
                                } in (m, tla ps)
    else let {
           (m, ps) = next_candidates n;
         } in (m, filter prime ps));

list_to_poly_f :: forall a. (Eq a) => Ffield_ext a () -> [a] -> [a];
list_to_poly_f f (x : xs) = cCons_f f x (list_to_poly_f f xs);
list_to_poly_f f [] = [];

of_int_f :: forall a b. Ffield_ext a b -> Int -> a;
of_int_f
  (Ffield_ext plus minus uminus mult power inverse_f divide zero one
    characteristic of_int_f to_int_f more)
  = of_int_f;

int_list_to_poly_f :: forall a. (Eq a) => Ffield_ext a () -> [Int] -> [a];
int_list_to_poly_f f xs = list_to_poly_f f (map (of_int_f f) xs);

pderiv_poly_f_main :: forall a. (Eq a) => Ffield_ext a () -> a -> [a] -> [a];
pderiv_poly_f_main f i (x : xs) =
  cCons_f f (multa f i x) (pderiv_poly_f_main f (plusa f i (oneb f)) xs);
pderiv_poly_f_main f i [] = [];

pderiv_poly_f :: forall a. (Eq a) => Ffield_ext a () -> [a] -> [a];
pderiv_poly_f f pp = pderiv_poly_f_main f (oneb f) (tla pp);

leading_coeff_f :: forall a. Ffield_ext a () -> [a] -> a;
leading_coeff_f f pp = (if null pp then zerob f else last pp);

inverse_f :: forall a b. Ffield_ext a b -> a -> a;
inverse_f
  (Ffield_ext plus minus uminus mult power inverse_f divide zero one
    characteristic of_int_f to_int_f more)
  = inverse_f;

minusa :: forall a b. Ffield_ext a b -> a -> a -> a;
minusa
  (Ffield_ext plus minus uminus mult power inverse_f divide zero one
    characteristic of_int_f to_int_f more)
  = minus;

minus_poly_rev_f :: forall a. Ffield_ext a () -> [a] -> [a] -> [a];
minus_poly_rev_f f (x : xs) (y : ys) = minusa f x y : minus_poly_rev_f f xs ys;
minus_poly_rev_f f xs [] = xs;

divmod_poly_one_main_f ::
  forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> [a] -> Nat -> ([a], [a]);
divmod_poly_one_main_f f q r d n =
  (if equal_nat n zero_nat then (q, r)
    else let {
           a = hda r;
           n1 = minus_nat n one_nat;
           qqq = cCons_f f a q;
           rr = tla (if a == zerob f then r
                      else minus_poly_rev_f f r (map (multa f a) d));
         } in divmod_poly_one_main_f f qqq rr d n1);

divmod_poly_one_f ::
  forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> ([a], [a]);
divmod_poly_one_f f p q =
  let {
    dp = degree_poly_f p;
    dq = degree_poly_f q;
    (qu, re) =
      divmod_poly_one_main_f f [] (reverse p) (reverse q)
        (minus_nat (plus_nat one_nat dp) dq);
  } in (qu, reverse (dropWhile (\ a -> zerob f == a) re));

divmod_poly_f ::
  forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> ([a], [a]);
divmod_poly_f f pp q =
  (if null q then ([], pp) else let {
                                  lc = leading_coeff_f f q;
                                  ilc = inverse_f f lc;
                                  qa = smult_poly_f f ilc q;
                                  a = divmod_poly_one_f f pp qa;
                                  (qu, aa) = a;
                                } in (smult_poly_f f ilc qu, aa));

mod_poly_f :: forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> [a];
mod_poly_f f pp qq = snd (divmod_poly_f f pp qq);

gcd_poly_f :: forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> [a];
gcd_poly_f f x y =
  (if null y then smult_poly_f f (inverse_f f (leading_coeff_f f x)) x
    else gcd_poly_f f y (mod_poly_f f x y));

int_of_nat :: Nat -> Int;
int_of_nat n = Int_of_integer (integer_of_nat n);

newtype GFp = Abs_GFp Int;

equal_GFp :: GFp -> GFp -> Bool;
equal_GFp (Abs_GFp xb) (Abs_GFp x) = equal_int xb x;

mult_GFp :: Int -> GFp -> GFp -> GFp;
mult_GFp p (Abs_GFp xa) (Abs_GFp x) = Abs_GFp (mod_int (times_int xa x) p);

one_GFp :: GFp;
one_GFp = Abs_GFp (Int_of_integer (1 :: Integer));

power_GFp :: Int -> GFp -> Nat -> GFp;
power_GFp p = fast_power (mult_GFp p) one_GFp;

zero_GFp :: GFp;
zero_GFp = Abs_GFp zero_int;

inverse_GFp :: Int -> GFp -> GFp;
inverse_GFp p x =
  (if equal_GFp x zero_GFp then zero_GFp
    else power_GFp p x (nat (minus_int p (Int_of_integer (2 :: Integer)))));

uminus_GFp :: Int -> GFp -> GFp;
uminus_GFp p (Abs_GFp x) =
  Abs_GFp (if equal_int x zero_int then zero_int else minus_int p x);

to_int_GFp :: GFp -> Int;
to_int_GFp (Abs_GFp y) = y;

of_int_GFp :: Int -> Int -> GFp;
of_int_GFp p x = Abs_GFp (mod_int x p);

divide_GFp :: Int -> GFp -> GFp -> GFp;
divide_GFp p x y = mult_GFp p x (inverse_GFp p y);

minus_GFp :: Int -> GFp -> GFp -> GFp;
minus_GFp p (Abs_GFp xa) (Abs_GFp x) =
  Abs_GFp (let {
             z = minus_int xa x;
           } in (if less_int z zero_int then plus_int z p else z));

plus_GFp :: Int -> GFp -> GFp -> GFp;
plus_GFp p (Abs_GFp xa) (Abs_GFp x) =
  Abs_GFp (let {
             z = plus_int xa x;
           } in (if less_eq_int p z then minus_int z p else z));

gFp :: Int -> Ffield_ext GFp ();
gFp p =
  Ffield_ext (plus_GFp p) (minus_GFp p) (uminus_GFp p) (mult_GFp p)
    (power_GFp p) (inverse_GFp p) (divide_GFp p) zero_GFp one_GFp p
    (of_int_GFp p) to_int_GFp ();

instance Eq GFp where {
  a == b = equal_GFp a b;
};

prime_for_finite_factorization_main :: [Nat] -> Nat -> [Int] -> Int;
prime_for_finite_factorization_main ps np f =
  (case ps of {
    [] -> let {
            (npa, psa) = next_primes np;
          } in prime_for_finite_factorization_main psa npa f;
    p : psa ->
      let {
        fa = gFp (int_of_nat p);
        g = int_list_to_poly_f fa f;
      } in (if gcd_poly_f fa g (pderiv_poly_f fa g) == [oneb fa] &&
                 equal_int (gcd_int (last f) (int_of_nat p))
                   (Int_of_integer (1 :: Integer))
             then int_of_nat p
             else prime_for_finite_factorization_main psa np f);
  });

prime_for_finite_factorization :: [Int] -> Int;
prime_for_finite_factorization p =
  prime_for_finite_factorization_main [] zero_nat p;

characteristic :: forall a b. Ffield_ext a b -> Int;
characteristic
  (Ffield_ext plus minus uminus mult power inverse_f divide zero one
    characteristic of_int_f to_int_f more)
  = characteristic;

partition :: forall a. (a -> Bool) -> [a] -> ([a], [a]);
partition p [] = ([], []);
partition p (x : xs) = let {
                         (yes, no) = partition p xs;
                       } in (if p x then (x : yes, no) else (yes, x : no));

upto_aux :: Int -> Int -> [Int] -> [Int];
upto_aux i j js =
  (if less_int j i then js
    else upto_aux i (minus_int j (Int_of_integer (1 :: Integer))) (j : js));

upto :: Int -> Int -> [Int];
upto i j = upto_aux i j [];

berlekamp_factorization_main ::
  Ffield_ext GFp () -> [[GFp]] -> [[GFp]] -> Nat -> [[GFp]];
berlekamp_factorization_main f divs (v : vs) n =
  let {
    facts =
      concatMap
        (\ u ->
          concatMap
            (\ s ->
              concatMap (\ w -> (if not (w == [oneb f]) then [w] else []))
                [gcd_poly_f f u (plus_poly_f f v [of_int_f f s])])
            (upto zero_int
              (minus_int (characteristic f) (Int_of_integer (1 :: Integer)))))
        divs;
  } in (if equal_nat (size_list facts) n then facts
         else let {
                (lin, nonlin) =
                  partition (\ q -> equal_nat (degree_poly_f q) one_nat) facts;
              } in lin ++
                     berlekamp_factorization_main f nonlin vs
                       (minus_nat n (size_list lin)));
berlekamp_factorization_main f divs [] n = divs;

power_polys :: Ffield_ext GFp () -> [GFp] -> [GFp] -> [GFp] -> Nat -> [[GFp]];
power_polys f mul_p u curr_p i =
  (if equal_nat i zero_nat then []
    else curr_p :
           power_polys f mul_p u (mod_poly_f f (times_poly_f f curr_p mul_p) u)
             (minus_nat i one_nat));

power_poly_f_mod ::
  forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> Nat -> [a];
power_poly_f_mod f modulus =
  fast_power (\ a b -> mod_poly_f f (times_poly_f f a b) modulus) [oneb f];

newtype Vec_impl a = Abs_vec_impl (Nat, IArray.IArray a);

rep_vec_impl :: forall a. Vec_impl a -> (Nat, IArray.IArray a);
rep_vec_impl (Abs_vec_impl x) = x;

sub :: forall a. IArray.IArray a -> Nat -> a;
sub asa n = IArray.sub (asa, integer_of_nat n);

vec_index_impl :: forall a. Vec_impl a -> Nat -> a;
vec_index_impl xa = let {
                      (_, a) = rep_vec_impl xa;
                    } in sub a;

newtype Vec a = Vec_impl (Vec_impl a);

vec_index :: forall a. Vec a -> Nat -> a;
vec_index (Vec_impl v) i = vec_index_impl v i;

newtype Mat_impl a = Abs_mat_impl (Nat, (Nat, IArray.IArray (IArray.IArray a)));

of_fun :: forall a. (Nat -> a) -> Nat -> IArray.IArray a;
of_fun f n =
  (let x = (integer_of_nat n,
             f . nat_of_integer) in (IArray.array (snd x) (fst x)));

mat_of_fun :: forall a. Nat -> Nat -> ((Nat, Nat) -> a) -> Mat_impl a;
mat_of_fun xc xd xe =
  Abs_mat_impl (xc, (xd, of_fun (\ i -> of_fun (\ j -> xe (i, j)) xd) xc));

newtype Mat a = Mat_impl (Mat_impl a);

mat :: forall a. Nat -> Nat -> ((Nat, Nat) -> a) -> Mat a;
mat nr nc f = Mat_impl (mat_of_fun nr nc f);

mat_of_rows :: forall a. Nat -> [Vec a] -> Mat a;
mat_of_rows n rs = mat (size_list rs) n (\ (i, a) -> vec_index (nth rs i) a);

vec_of_fun :: forall a. Nat -> (Nat -> a) -> Vec_impl a;
vec_of_fun xb xc = Abs_vec_impl (xb, of_fun xc xb);

vec :: forall a. Nat -> (Nat -> a) -> Vec a;
vec n f = Vec_impl (vec_of_fun n f);

mat_of_rows_list :: forall a. Nat -> [[a]] -> Mat a;
mat_of_rows_list nc vs = mat_of_rows nc (map (\ v -> vec nc (nth v)) vs);

berlekamp_mat :: Ffield_ext GFp () -> [GFp] -> Mat GFp;
berlekamp_mat f u =
  let {
    n = degree_poly_f u;
    mul_p = power_poly_f_mod f u [zerob f, oneb f] (nat (characteristic f));
    xks = power_polys f mul_p u [oneb f] n;
  } in mat_of_rows_list n (map (\ cs -> let {
  k = minus_nat n (size_list cs);
} in cs ++ replicate k (zerob f))
                            xks);

rep_mat_impl ::
  forall a. Mat_impl a -> (Nat, (Nat, IArray.IArray (IArray.IArray a)));
rep_mat_impl (Abs_mat_impl x) = x;

list_update :: forall a. [a] -> Nat -> a -> [a];
list_update [] i y = [];
list_update (x : xs) i y =
  (if equal_nat i zero_nat then y : xs
    else x : list_update xs (minus_nat i one_nat) y);

length :: forall a. IArray.IArray a -> Nat;
length asa = nat_of_integer (IArray.lengthIArray asa);

upt :: Nat -> Nat -> [Nat];
upt i j = (if less_nat i j then i : upt (suc i) j else []);

list_of :: forall a. IArray.IArray a -> [a];
list_of asa = map (sub asa) (upt zero_nat (length asa));

mat_addrow_gen_impl ::
  forall a.
    (a -> a -> a) ->
      (a -> a -> a) -> a -> Nat -> Nat -> Mat_impl a -> Mat_impl a;
mat_addrow_gen_impl xd xe xf xh xi xj =
  Abs_mat_impl
    (let {
       (nr, a) = rep_mat_impl xj;
       (nc, aa) = a;
     } in (if less_nat xi nr
            then let {
                   ak = sub aa xh;
                   al = sub aa xi;
                   arows = list_of aa;
                   aka = IArray.listIArray
                           (map (\ (ala, ab) -> xd (xe xf ala) ab)
                             (zip (list_of al) (list_of ak)));
                   ab = IArray.listIArray (list_update arows xh aka);
                 } in (nr, (nc, ab))
            else (nr, (nc, aa))));

mat_dim_row_impl :: forall a. Mat_impl a -> Nat;
mat_dim_row_impl xa = fst (rep_mat_impl xa);

mat_addrow_gen ::
  forall a. (a -> a -> a) -> (a -> a -> a) -> a -> Nat -> Nat -> Mat a -> Mat a;
mat_addrow_gen ad mul aa k l (Mat_impl a) =
  (if less_nat l (mat_dim_row_impl a)
    then Mat_impl (mat_addrow_gen_impl ad mul aa k l a)
    else (error :: forall a. String -> (() -> a) -> a)
           "index out of bounds in mat_addrow"
           (\ _ -> mat_addrow_gen ad mul aa k l (Mat_impl a)));

mat_index_impl :: forall a. Mat_impl a -> (Nat, Nat) -> a;
mat_index_impl xa =
  let {
    (nr, (_, m)) = rep_mat_impl xa;
  } in (\ (i, j) ->
         (if less_nat i nr then sub (sub m i) j
           else sub (IArray.listIArray (nth [] (minus_nat i nr))) j));

mat_index :: forall a. Mat a -> (Nat, Nat) -> a;
mat_index (Mat_impl m) ij = mat_index_impl m ij;

eliminate_entries_gen ::
  forall a.
    (Eq a) => (a -> a -> a) ->
                (a -> a -> a) ->
                  (a -> a) ->
                    a -> Mat a -> Mat a -> Nat -> Nat -> [Nat] -> Mat a;
eliminate_entries_gen add times uminus zero a b i j [] = b;
eliminate_entries_gen add times uminus zero a b ia j (i : is) =
  let {
    ai_j = mat_index a (i, j);
  } in (if ai_j == zero
         then eliminate_entries_gen add times uminus zero a b ia j is
         else eliminate_entries_gen add times uminus zero a
                (mat_addrow_gen add times (uminus ai_j) i ia b) ia j is);

mat_multrow_gen_impl ::
  forall a. (a -> a -> a) -> Nat -> a -> Mat_impl a -> Mat_impl a;
mat_multrow_gen_impl xc xd xe xf =
  Abs_mat_impl (let {
                  (nr, a) = rep_mat_impl xf;
                  (nc, aa) = a;
                  ak = sub aa xd;
                  arows = list_of aa;
                  aka = IArray.listIArray (map (xc xe) (list_of ak));
                  ab = IArray.listIArray (list_update arows xd aka);
                } in (nr, (nc, ab)));

mat_multrow_gen :: forall a. (a -> a -> a) -> Nat -> a -> Mat a -> Mat a;
mat_multrow_gen mul k aa (Mat_impl a) =
  Mat_impl (mat_multrow_gen_impl mul k aa a);

mat_swaprows_impl :: forall a. Nat -> Nat -> Mat_impl a -> Mat_impl a;
mat_swaprows_impl xc xd xe =
  Abs_mat_impl
    (let {
       (nr, a) = rep_mat_impl xe;
       (nc, aa) = a;
     } in (if less_nat xc nr && less_nat xd nr
            then let {
                   ai = sub aa xc;
                   aj = sub aa xd;
                   arows = list_of aa;
                   ab = IArray.listIArray
                          (list_update (list_update arows xc aj) xd ai);
                 } in (nr, (nc, ab))
            else (nr, (nc, aa))));

mat_swaprows :: forall a. Nat -> Nat -> Mat a -> Mat a;
mat_swaprows k l (Mat_impl a) =
  let {
    nr = mat_dim_row_impl a;
  } in (if less_nat l nr && less_nat k nr
         then Mat_impl (mat_swaprows_impl k l a)
         else (error :: forall a. String -> (() -> a) -> a)
                "index out of bounds in mat_swaprows"
                (\ _ -> mat_swaprows k l (Mat_impl a)));

uminus :: forall a b. Ffield_ext a b -> a -> a;
uminus
  (Ffield_ext plus minus uminus mult power inverse_f divide zero one
    characteristic of_int_f to_int_f more)
  = uminus;

gauss_jordan_main_f ::
  forall a.
    (Eq a) => Ffield_ext a () -> Nat -> Nat -> Mat a -> Nat -> Nat -> Mat a;
gauss_jordan_main_f f nr nc a i j =
  (if less_nat i nr && less_nat j nc
    then let {
           aij = mat_index a (i, j);
         } in (if aij == zerob f
                then (case concatMap
                             (\ ia ->
                               (if not (mat_index a (ia, j) == zerob f)
                                 then [ia] else []))
                             (upt (suc i) nr)
                       of {
                       [] -> gauss_jordan_main_f f nr nc a i (suc j);
                       ia : _ ->
                         gauss_jordan_main_f f nr nc (mat_swaprows i ia a) i j;
                     })
                else (if aij == oneb f
                       then let {
                              is = filter (\ ia -> not (equal_nat ia i))
                                     (upt zero_nat nr);
                            } in gauss_jordan_main_f f nr nc
                                   (eliminate_entries_gen (plusa f) (multa f)
                                     (uminus f) (zerob f) a a i j is)
                                   (suc i) (suc j)
                       else let {
                              iaij = inverse_f f aij;
                            } in gauss_jordan_main_f f nr nc
                                   (mat_multrow_gen (multa f) i iaij a) i j))
    else a);

mat_dim_row :: forall a. Mat a -> Nat;
mat_dim_row (Mat_impl m) = mat_dim_row_impl m;

mat_dim_col_impl :: forall a. Mat_impl a -> Nat;
mat_dim_col_impl xa = fst (snd (rep_mat_impl xa));

mat_dim_col :: forall a. Mat a -> Nat;
mat_dim_col (Mat_impl m) = mat_dim_col_impl m;

gauss_jordan_f :: forall a. (Eq a) => Ffield_ext a () -> Mat a -> Mat a;
gauss_jordan_f f a =
  gauss_jordan_main_f f (mat_dim_row a) (mat_dim_col a) a zero_nat zero_nat;

mat_transpose :: forall a. Mat a -> Mat a;
mat_transpose a =
  mat (mat_dim_col a) (mat_dim_row a) (\ (i, j) -> mat_index a (j, i));

berlekamp_resulting_mat :: Ffield_ext GFp () -> [GFp] -> Mat GFp;
berlekamp_resulting_mat f u =
  let {
    q = berlekamp_mat f u;
    n = mat_dim_row q;
    qi = mat n n
           (\ (i, j) ->
             (if equal_nat i j then minusa f (mat_index q (i, j)) (oneb f)
               else mat_index q (i, j)));
  } in gauss_jordan_f f (mat_transpose qi);

pivot_positions_main_gen ::
  forall a. (Eq a) => a -> Mat a -> Nat -> Nat -> Nat -> Nat -> [(Nat, Nat)];
pivot_positions_main_gen zero a nr nc i j =
  (if less_nat i nr
    then (if less_nat j nc
           then (if mat_index a (i, j) == zero
                  then pivot_positions_main_gen zero a nr nc i (suc j)
                  else (i, j) :
                         pivot_positions_main_gen zero a nr nc (suc i) (suc j))
           else [])
    else []);

pivot_positions_gen :: forall a. (Eq a) => a -> Mat a -> [(Nat, Nat)];
pivot_positions_gen zer a =
  pivot_positions_main_gen zer a (mat_dim_row a) (mat_dim_col a) zero_nat
    zero_nat;

swap :: forall a b. (a, b) -> (b, a);
swap p = (snd p, fst p);

map_of :: forall a b. (Eq a) => [(a, b)] -> a -> Maybe b;
map_of ((l, v) : ps) k = (if l == k then Just v else map_of ps k);
map_of [] k = Nothing;

non_pivot_base_gen ::
  forall a. (a -> a) -> a -> a -> Mat a -> [(Nat, Nat)] -> Nat -> Vec a;
non_pivot_base_gen uminus zero one a pivots =
  let {
    _ = mat_dim_row a;
    nc = mat_dim_col a;
    invers = map_of (map swap pivots);
  } in (\ qj ->
         vec nc
           (\ i ->
             (if equal_nat i qj then one
               else (case invers i of {
                      Nothing -> zero;
                      Just j -> uminus (mat_index a (j, qj));
                    }))));

membera :: forall a. (Eq a) => [a] -> a -> Bool;
membera [] y = False;
membera (x : xs) y = x == y || membera xs y;

find_base_vectors_gen ::
  forall a. (Eq a) => (a -> a) -> a -> a -> Mat a -> [Vec a];
find_base_vectors_gen uminus zero one a =
  let {
    pp = pivot_positions_gen zero a;
    b = filter (\ j -> not (membera (map snd pp) j))
          (upt zero_nat (mat_dim_col a));
  } in map (non_pivot_base_gen uminus zero one a pp) b;

list_of_vec_impl :: forall a. Vec_impl a -> [a];
list_of_vec_impl xa = let {
                        (_, a) = rep_vec_impl xa;
                      } in list_of a;

list_of_vec :: forall a. Vec a -> [a];
list_of_vec (Vec_impl v) = list_of_vec_impl v;

berlekamp_basis :: Ffield_ext GFp () -> [GFp] -> [[GFp]];
berlekamp_basis f u =
  map (list_to_poly_f f . list_of_vec)
    (find_base_vectors_gen (uminus f) (zerob f) (oneb f)
      (berlekamp_resulting_mat f u));

to_int_f :: forall a b. Ffield_ext a b -> a -> Int;
to_int_f
  (Ffield_ext plus minus uminus mult power inverse_f divide zero one
    characteristic of_int_f to_int_f more)
  = to_int_f;

shows_prec_nat :: Nat -> Nat -> [Prelude.Char] -> [Prelude.Char];
shows_prec_nat = showsp_nat;

show_factor :: Nat -> [Prelude.Char];
show_factor va =
  (if equal_nat va zero_nat then []
    else (if equal_nat (minus_nat va one_nat) zero_nat then ['x']
           else ['x', '^'] ++
                  shows_prec_nat zero_nat
                    (suc (suc (minus_nat (minus_nat va one_nat) one_nat))) []));

show_coeff_factor ::
  forall a. (One a, Eq a, Showa a) => a -> Nat -> [Prelude.Char];
show_coeff_factor c n =
  (if equal_nat n zero_nat then shows_prec zero_nat c []
    else (if c == onea then show_factor n
           else shows_prec zero_nat c [] ++ show_factor n));

show_poly_main ::
  forall a. (One a, Zero a, Eq a, Showa a) => Nat -> [a] -> [Prelude.Char];
show_poly_main uu [] = ['0'];
show_poly_main n [c] = show_coeff_factor c n;
show_poly_main n (c : v : va) =
  (if c == zeroa then show_poly_main (suc n) (v : va)
    else show_coeff_factor c n ++
           [' ', '+', ' '] ++ show_poly_main (suc n) (v : va));

show_poly_f :: forall a. Ffield_ext a () -> [a] -> [Prelude.Char];
show_poly_f f p = show_poly_main zero_nat (map (to_int_f f) p);

berlekamp_factorization :: Ffield_ext GFp () -> [GFp] -> (GFp, [[GFp]]);
berlekamp_factorization fa f =
  let {
    a = leading_coeff_f fa f;
    u = smult_poly_f fa (inverse_f fa a) f;
    vs = berlekamp_basis fa u;
    n = size_list vs;
    fs = berlekamp_factorization_main fa [u] vs n;
  } in (case True of {
         True -> (a, fs);
         False ->
           (error :: forall a. String -> (() -> a) -> a)
             (['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'b', 'e', 'r', 'l',
                'e', 'k', 'a', 'm', 'p', '_', 'f', 'a', 'c', 't', 'o', 'r', 'i',
                'z', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] ++
               show_poly_f fa u ++
                 [' ', 'm', 'o', 'd', 'u', 'l', 'o', ' '] ++
                   shows_prec_int zero_nat (characteristic fa) [])
             (\ _ -> (a, fs));
       });

hensel_prime_power_main :: Nat -> Nat -> Nat -> Nat -> Nat;
hensel_prime_power_main p pm m bnd =
  (if less_nat bnd pm then m
    else hensel_prime_power_main p (times_nat pm p) (suc m) bnd);

hensel_prime_power :: Nat -> Nat -> Nat;
hensel_prime_power p bnd = hensel_prime_power_main p p one_nat bnd;

listsum :: forall a. (Monoid_add a) => [a] -> a;
listsum xs = foldr plus xs zeroa;

sqrt_int_maina :: Int -> Int -> (Int, Bool);
sqrt_int_maina x n =
  let {
    x2 = times_int x x;
  } in (if less_eq_int x2 n then (x, equal_int x2 n)
         else sqrt_int_maina
                (divide_int (plus_int (divide_int n x) x)
                  (Int_of_integer (2 :: Integer)))
                n);

of_nat :: forall a. (Semiring_1 a) => Nat -> a;
of_nat n =
  (if equal_nat n zero_nat then zeroa
    else let {
           (m, q) = divmod_nat n (nat_of_integer (2 :: Integer));
           ma = times (numeral (Bit0 One)) (of_nat m);
         } in (if equal_nat q zero_nat then ma else plus ma onea));

class (Order a) => Dense_order a where {
};

class (Dense_order a, Linorder a) => Dense_linorder a where {
};

class (Order a) => No_top a where {
};

class (Order a) => No_bot a where {
};

class (Dense_linorder a, No_bot a,
        No_top a) => Unbounded_dense_linorder a where {
};

class (Field a, Ring_char_0 a) => Field_char_0 a where {
};

class (Field_char_0 a, Unbounded_dense_linorder a,
        Linordered_idom a) => Linordered_field a where {
};

class (Linordered_field a) => Archimedean_field a where {
};

class (Poly_carrier a) => Large_ordered_semiring_1 a where {
};

class (Archimedean_field a,
        Large_ordered_semiring_1 a) => Floor_ceiling a where {
  floor :: a -> Int;
};

ceiling :: forall a. (Floor_ceiling a) => a -> Int;
ceiling x = uminus_int (floor (uminusa x));

log_ceil_impl :: Nat -> Int -> Int -> Nat -> Nat;
log_ceil_impl b x prod sum =
  (if less_eq_int x prod then sum
    else log_ceil_impl b x (times_int prod (int_of_nat b))
           (plus_nat sum one_nat));

log_ceil :: Nat -> Int -> Nat;
log_ceil b x =
  (if less_nat one_nat b && less_eq_int zero_int x
    then log_ceil_impl b x (Int_of_integer (1 :: Integer)) zero_nat
    else zero_nat);

abs_rat :: Rat -> Rat;
abs_rat p = Frct (let {
                    a = quotient_of p;
                    (aa, b) = a;
                  } in (abs_int aa, b));

instance Ord Rat where {
  less_eq = less_eq_rat;
  less = less_rat;
};

instance Preorder Rat where {
};

instance Order Rat where {
};

instance Dense_order Rat where {
};

instance Linorder Rat where {
};

instance Dense_linorder Rat where {
};

instance No_top Rat where {
};

instance No_bot Rat where {
};

instance Unbounded_dense_linorder Rat where {
};

instance Ordered_ab_semigroup_add Rat where {
};

instance Ordered_cancel_ab_semigroup_add Rat where {
};

instance Ordered_ab_semigroup_add_imp_le Rat where {
};

instance Linordered_ab_semigroup_add Rat where {
};

instance Linordered_cancel_ab_semigroup_add Rat where {
};

instance Ordered_comm_monoid_add Rat where {
};

instance Ordered_semiring Rat where {
};

instance Ordered_cancel_semiring Rat where {
};

instance Linordered_semiring Rat where {
};

instance Linordered_semiring_strict Rat where {
};

instance Linordered_semiring_1 Rat where {
};

instance Linordered_semiring_1_strict Rat where {
};

instance Ordered_ab_group_add Rat where {
};

instance Abs Rat where {
  absa = abs_rat;
};

instance Ordered_ab_group_add_abs Rat where {
};

instance Linordered_ab_group_add Rat where {
};

instance Ordered_ring Rat where {
};

instance Abs_if Rat where {
};

instance Linordered_ring Rat where {
};

instance Linordered_ring_strict Rat where {
};

instance Ordered_comm_semiring Rat where {
};

instance Ordered_cancel_comm_semiring Rat where {
};

instance Linordered_comm_semiring_strict Rat where {
};

instance Semiring_char_0 Rat where {
};

instance Linordered_semidom Rat where {
};

instance Ordered_comm_ring Rat where {
};

instance Ordered_ring_abs Rat where {
};

instance Ring_char_0 Rat where {
};

instance Sgn Rat where {
  sgn = sgn_rat;
};

instance Sgn_if Rat where {
};

instance Linordered_idom Rat where {
};

instance Field_char_0 Rat where {
};

instance Linordered_field Rat where {
};

instance Archimedean_field Rat where {
};

instance Non_strict_order Rat where {
};

instance Ordered_ab_semigroup Rat where {
};

instance Ordered_semiring_0 Rat where {
};

instance Ordered_semiring_1 Rat where {
};

instance Poly_carrier Rat where {
};

instance Large_ordered_semiring_1 Rat where {
};

instance Floor_ceiling Rat where {
  floor = floor_rat;
};

start_value :: Int -> Nat -> Int;
start_value n p =
  binary_power (Int_of_integer (2 :: Integer))
    (nat (ceiling
           (divide_rat
             (of_int (int_of_nat (log_ceil (nat_of_integer (2 :: Integer)) n)))
             (of_nat p))));

sqrt_int_main :: Int -> (Int, Bool);
sqrt_int_main x =
  sqrt_int_maina (start_value x (nat_of_integer (2 :: Integer))) x;

sqrt_int_ceiling_pos :: Int -> Int;
sqrt_int_ceiling_pos x =
  (case sqrt_int_main x of {
    (y, True) -> y;
    (y, False) -> plus_int y (Int_of_integer (1 :: Integer));
  });

sqrt_int_floor_pos :: Int -> Int;
sqrt_int_floor_pos x = fst (sqrt_int_main x);

sqrt_int_floor :: Int -> Int;
sqrt_int_floor x =
  (if less_eq_int zero_int x then sqrt_int_floor_pos x
    else uminus_int (sqrt_int_ceiling_pos (uminus_int x)));

fold_atLeastAtMost_nat :: forall a. (Nat -> a -> a) -> Nat -> Nat -> a -> a;
fold_atLeastAtMost_nat f a b acc =
  (if less_nat b a then acc
    else fold_atLeastAtMost_nat f (plus_nat a one_nat) b (f a acc));

fact :: forall a. (Semiring_char_0 a) => Nat -> a;
fact n =
  of_nat
    (fold_atLeastAtMost_nat times_nat (nat_of_integer (2 :: Integer)) n
      one_nat);

instance Semiring_char_0 Nat where {
};

binomial :: Nat -> Nat -> Nat;
binomial n k =
  (if less_eq_nat k n
    then divide_nat (fact n) (times_nat (fact k) (fact (minus_nat n k)))
    else zero_nat);

instance Ord Nat where {
  less_eq = less_eq_nat;
  less = less_nat;
};

max_list :: [Nat] -> Nat;
max_list [] = zero_nat;
max_list (x : xs) = max x (max_list xs);

mignotte_bounds :: [Int] -> Nat -> Int;
mignotte_bounds p n =
  let {
    f = nat (sqrt_int_floor (listsum (map (\ a -> times_int a a) p)));
    am = nat (abs_int (last p));
  } in int_of_nat
         (max_list
           (map (\ j ->
                  plus_nat (times_nat (binomial (minus_nat n one_nat) j) f)
                    (times_nat
                      (binomial (minus_nat n one_nat) (minus_nat j one_nat))
                      am))
             (upt zero_nat (suc n))));

pre_hensel_factorization :: [Int] -> ([[GFp]], (Int, Nat));
pre_hensel_factorization g =
  let {
    p = prime_for_finite_factorization g;
    f = gFp p;
    dg = degree_poly_f g;
    m = mignotte_bounds g (divide_nat dg (nat_of_integer (2 :: Integer)));
    a = last g;
    n = hensel_prime_power (nat p)
          (nat (times_int (times_int (Int_of_integer (2 :: Integer)) a) m));
    fa = int_list_to_poly_f f g;
    (_, fs) = berlekamp_factorization f fa;
  } in (fs, (p, n));

extended_gcd_int_main ::
  Int -> Int -> Int -> Int -> Int -> Int -> (Int, (Int, Int));
extended_gcd_int_main ri1 si1 ti1 ri si ti =
  (if equal_int ri zero_int then (ri1, (si1, ti1))
    else let {
           q = divide_int ri1 ri;
         } in extended_gcd_int_main ri si ti (minus_int ri1 (times_int q ri))
                (minus_int si1 (times_int q si))
                (minus_int ti1 (times_int q ti)));

extended_gcd_int :: Int -> Int -> (Int, (Int, Int));
extended_gcd_int a b =
  extended_gcd_int_main a (Int_of_integer (1 :: Integer)) zero_int b zero_int
    (Int_of_integer (1 :: Integer));

inverse_int_modulo :: Int -> Int -> Int;
inverse_int_modulo x y = let {
                           a = extended_gcd_int x y;
                           (_, aa) = a;
                           (ab, _) = aa;
                         } in ab;

div_int_polya :: Int -> [Int] -> [Int];
div_int_polya n f = let {
                      g = map (\ x -> divide_int x n) f;
                    } in foldr cCons g [];

hensel_dupe ::
  Ffield_ext GFp () ->
    Int -> [GFp] -> [GFp] -> [GFp] -> [GFp] -> [GFp] -> ([GFp], [GFp]);
hensel_dupe fq q u d h s t = let {
                               pp = plus_poly_f fq;
                               tt = times_poly_f fq;
                               lc = to_int_f fq (leading_coeff_f fq d);
                               ilc = inverse_int_modulo lc q;
                               ilca = of_int_f fq ilc;
                               da = smult_poly_f fq ilca d;
                               (qa, r) = divmod_poly_one_f fq (tt t u) da;
                               qb = smult_poly_f fq ilca qa;
                               a = pp (tt s u) (tt h qb);
                               b = r;
                             } in (a, b);

uminus_poly_f :: forall a. Ffield_ext a () -> [a] -> [a];
uminus_poly_f f = map (uminus f);

minus_poly_f :: forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> [a];
minus_poly_f f (x : xs) (y : ys) =
  cCons_f f (minusa f x y) (minus_poly_f f xs ys);
minus_poly_f f xs [] = xs;
minus_poly_f f [] (v : va) = uminus_poly_f f (v : va);

quadratic_hensel_lifting_main ::
  Nat ->
    [Int] -> Int -> Nat -> [Int] -> [Int] -> [Int] -> [Int] -> ([Int], [Int]);
quadratic_hensel_lifting_main k c q j d h s t =
  (if less_eq_nat k j then (d, h)
    else let {
           z = integer_ops;
           fq = gFp q;
           mm = minus_poly_f z;
           pp = plus_poly_f z;
           tt = times_poly_f z;
           sm = smult_poly_f z;
           i = int_list_to_poly_f fq;
           ia = map (to_int_f fq);
           u = div_int_polya q (mm c (tt d h));
         } in (if null u then (d, h)
                else let {
                       ih = i h;
                       ida = i d;
                       is = i s;
                       it = i t;
                       ua = int_list_to_poly_f fq u;
                       a = hensel_dupe fq q ua ida ih is it;
                       (aa, b) = a;
                       da = pp d (sm q (ia b));
                       ha = pp h (sm q (ia aa));
                       ub = div_int_polya q
                              (mm (pp (tt s da) (tt t ha)) [oneb z]);
                       uc = int_list_to_poly_f fq ub;
                       ab = hensel_dupe fq q uc ida ih is it;
                       (ac, ba) = ab;
                       sa = mm s (sm q (ia ac));
                       ta = mm t (sm q (ia ba));
                       db = da;
                       hb = ha;
                       ja = times_nat j (nat_of_integer (2 :: Integer));
                       qa = times_int q q;
                     } in quadratic_hensel_lifting_main k c qa ja db hb sa ta));

div_poly_f :: forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> [a];
div_poly_f f pp qq = fst (divmod_poly_f f pp qq);

extended_gcd_poly_f_main ::
  forall a.
    (Eq a) => Ffield_ext a () ->
                [a] -> [a] -> [a] -> [a] -> [a] -> [a] -> ([a], ([a], [a]));
extended_gcd_poly_f_main f ri1 si1 ti1 ri si ti =
  (if null ri then (ri1, (si1, ti1))
    else let {
           q = div_poly_f f ri1 ri;
         } in extended_gcd_poly_f_main f ri si ti
                (minus_poly_f f ri1 (times_poly_f f q ri))
                (minus_poly_f f si1 (times_poly_f f q si))
                (minus_poly_f f ti1 (times_poly_f f q ti)));

extended_gcd_poly_f ::
  forall a. (Eq a) => Ffield_ext a () -> [a] -> [a] -> ([a], ([a], [a]));
extended_gcd_poly_f f a b =
  let {
    (g, (c, d)) = extended_gcd_poly_f_main f a [oneb f] [] b [] [oneb f];
    l = leading_coeff_f f g;
    i = inverse_f f l;
    scale = smult_poly_f f i;
  } in (if l == zerob f then (g, (c, d)) else (scale g, (scale c, scale d)));

quadratic_hensel_lifting_binary ::
  Ffield_ext GFp () -> Nat -> [Int] -> [Int] -> [Int] -> ([Int], [Int]);
quadratic_hensel_lifting_binary fp k c d1 h1 =
  let {
    p = characteristic fp;
    g = int_list_to_poly_f fp;
    i = map (to_int_f fp);
    d1a = g d1;
    h1a = g h1;
    (_, (s, t)) = extended_gcd_poly_f fp d1a h1a;
    j = one_nat;
    q = p;
    d = d1;
    h = h1;
  } in quadratic_hensel_lifting_main k c q j d h (i s) (i t);

take :: forall a. Nat -> [a] -> [a];
take n [] = [];
take n (x : xs) =
  (if equal_nat n zero_nat then [] else x : take (minus_nat n one_nat) xs);

drop :: forall a. Nat -> [a] -> [a];
drop n [] = [];
drop n (x : xs) =
  (if equal_nat n zero_nat then x : xs else drop (minus_nat n one_nat) xs);

hensel_lifting :: Ffield_ext GFp () -> Nat -> [Int] -> [[GFp]] -> [[Int]];
hensel_lifting f m u vs =
  let {
    n = size_list vs;
  } in (if less_eq_nat n one_nat then (if equal_nat n one_nat then [u] else [])
         else let {
                i = divide_nat n (nat_of_integer (2 :: Integer));
                vs_1 = take i vs;
                vs_2 = drop i vs;
                _ = upt zero_nat n;
                ia = map (to_int_f f);
                v = ia (listprod_poly_f f vs_1);
                w = ia (listprod_poly_f f vs_2);
                (va, wa) = quadratic_hensel_lifting_binary f m u v w;
              } in hensel_lifting f m va vs_1 ++ hensel_lifting f m wa vs_2);

shows_prec_list ::
  forall a. (Showa a) => Nat -> [a] -> [Prelude.Char] -> [Prelude.Char];
shows_prec_list p xs = shows_list xs;

berlekamp_hensel_factorization_init :: [Int] -> (Int, ([[Int]], Int));
berlekamp_hensel_factorization_init f =
  let {
    a = last f;
    (ps, (p, m)) = pre_hensel_factorization f;
    fa = gFp p;
    mm = binary_power p m;
    i = inverse_int_modulo a mm;
    g = map (times_int i) f;
    _ = map (map to_int_GFp) ps;
    qs = hensel_lifting fa m g ps;
  } in (case True of {
         True -> (a, (qs, mm));
         False ->
           (error :: forall a. String -> (() -> a) -> a)
             (['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'b', 'e', 'r', 'l',
                'e', 'k', 'a', 'm', 'p', '_', 'h', 'e', 'n', 's', 'e', 'l', '_',
                'f', 'a', 'c', 't', 'o', 'r', 'i', 'z', 'a', 't', 'i', 'o', 'n',
                ' ', 'o', 'n', ' ', 'i', 'n', 'p', 'u', 't', ' '] ++
               shows_prec_list zero_nat f [])
             (\ _ -> (a, (qs, mm)));
       });

berlekamp_hensel_factorization :: [Int] -> [[Int]];
berlekamp_hensel_factorization f =
  let {
    a = berlekamp_hensel_factorization_init f;
    (aa, (vs, m)) = a;
    af = smult_poly_f integer_ops aa f;
  } in factorization_f_to_factorization_int m f af aa zero_nat (size_list vs) vs
         [] [];

factorization_oracle_int_poly :: [Int] -> [[Int]];
factorization_oracle_int_poly = berlekamp_hensel_factorization;

one_polya :: forall a. (Comm_semiring_1 a) => Poly a;
one_polya = Poly [onea];

instance (Zero a, Eq a) => Eq (Poly a) where {
  a == b = equal_poly a b;
};

yun_factorization_main ::
  forall a.
    (Eq a,
      Field_char_0 a) => (Poly a -> Poly a -> Poly a) ->
                           Poly a ->
                             Poly a ->
                               Nat -> [(Poly a, Nat)] -> [(Poly a, Nat)];
yun_factorization_main gcd bn cn i sqr =
  (if bn == one_polya then sqr
    else let {
           dn = minus_poly cn (pderiv bn);
           an = gcd bn dn;
         } in yun_factorization_main gcd (divide_poly bn an) (divide_poly dn an)
                (suc i) ((an, i) : sqr));

yun_monic_factorization ::
  forall a.
    (Eq a,
      Field_char_0 a) => (Poly a -> Poly a -> Poly a) ->
                           Poly a -> [(Poly a, Nat)];
yun_monic_factorization gcd p =
  let {
    pp = pderiv p;
    u = gcd p pp;
    b0 = divide_poly p u;
    c0 = divide_poly pp u;
  } in filter (\ (a, _) -> not (a == one_polya))
         (yun_factorization_main gcd b0 c0 zero_nat []);

yun_factorization ::
  forall a.
    (Eq a,
      Field_char_0 a) => (Poly a -> Poly a -> Poly a) ->
                           Poly a -> (a, [(Poly a, Nat)]);
yun_factorization gcd p =
  (if is_zero p then (zeroa, []) else let {
c = coeff p (degreea p);
q = smult (inverse c) p;
                                      } in (c, yun_monic_factorization gcd q));

listprod :: forall a. (Monoid_mult a) => [a] -> a;
listprod xs = foldr times xs onea;

rat_to_normalized_int_poly :: Poly Rat -> (Rat, Poly Int);
rat_to_normalized_int_poly p =
  (if equal_poly p zero_polya then (one_rat, zero_polya)
    else let {
           (s, q) = rat_to_int_poly p;
           c = content q;
         } in (divide_rat (of_int c) (of_int s), div_poly c q));

list_to_poly :: forall a. (Comm_monoid_add a, Eq a) => [a] -> Poly a;
list_to_poly (a : asa) = pCons a (list_to_poly asa);
list_to_poly [] = zero_polya;

showsp_rat :: Nat -> Rat -> [Prelude.Char] -> [Prelude.Char];
showsp_rat p x =
  let {
    (d, n) = quotient_of x;
  } in (if equal_int n (Int_of_integer (1 :: Integer)) then showsp_int p d
         else (showsp_int p d . shows_string ['/']) . showsp_int p n);

shows_prec_rat :: Nat -> Rat -> [Prelude.Char] -> [Prelude.Char];
shows_prec_rat = showsp_rat;

shows_list_rat :: [Rat] -> [Prelude.Char] -> [Prelude.Char];
shows_list_rat = showsp_list shows_prec_rat zero_nat;

instance Showa Rat where {
  shows_prec = shows_prec_rat;
  shows_list = shows_list_rat;
};

factorization_oracle_rat_poly :: Poly Rat -> (Rat, [(Poly Rat, Nat)]);
factorization_oracle_rat_poly p =
  let {
    a = yun_factorization gcd_rat_poly p;
    (aa, psi) = a;
    ber_hen = (\ (q, i) -> let {
                             (b, f) = rat_to_normalized_int_poly q;
                             fs = factorization_oracle_int_poly (coeffs f);
                             gs = map (map of_int) fs;
                             ab = map (\ h -> (list_to_poly h, suc i)) gs;
                           } in (binary_power b (suc i), ab));
    pre_result = map ber_hen psi;
    factors = concatMap snd pre_result;
    b = times_rat aa (listprod (map fst pre_result));
  } in (case True of {
         True -> (b, factors);
         False ->
           (error :: forall a. String -> (() -> a) -> a)
             (['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'f', 'a', 'c', 't',
                'o', 'r', 'i', 'z', 'a', 't', 'i', 'o', 'n', '_', 'o', 'r', 'a',
                'c', 'l', 'e', '_', 'r', 'a', 't', '_', 'p', 'o', 'l', 'y', ' ',
                'o', 'n', ' ', 'i', 'n', 'p', 'u', 't', ' '] ++
               shows_prec_list zero_nat (coeffs p) [])
             (\ _ -> (b, factors));
       });

show_poly ::
  forall a. (One a, Zero a, Eq a, Showa a) => Poly a -> [Prelude.Char];
show_poly p = show_poly_main zero_nat (coeffs p);

instance (Eq a, Idom a) => Times (Poly a) where {
  times = times_poly;
};

instance (Eq a, Idom a) => Semigroup_mult (Poly a) where {
};

instance (Comm_semiring_1 a) => One (Poly a) where {
  onea = one_polya;
};

instance (Eq a, Idom a) => Power (Poly a) where {
};

instance (Eq a, Idom a) => Monoid_mult (Poly a) where {
};

initial_factorization_rat ::
  Factorization_mode -> Poly Rat -> (Rat, [(Poly Rat, Nat)]);
initial_factorization_rat mode p =
  (if equal_factorization_mode mode Check_Irreducible ||
        equal_factorization_mode mode Check_Root_Free
    then (if equal_poly p zero_polya then (zero_rat, [])
           else (one_rat, [(p, one_nat)]))
    else let {
           (c, pis) = factorization_oracle_rat_poly p;
         } in (if equal_poly p
                    (smult c
                      (listprod (map (\ (a, b) -> binary_power a b) pis))) &&
                    all (\ (pa, i) ->
                          not (equal_nat i zero_nat) &&
                            not (equal_poly pa zero_polya))
                      pis
                then (c, pis)
                else (error :: forall a. String -> (() -> a) -> a)
                       (['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'f', 'a',
                          'c', 't', 'o', 'r', 'i', 'z', 'a', 't', 'i', 'o', 'n',
                          '-', 'o', 'r', 'a', 'c', 'l', 'e', ' ', 'o', 'n', ' ',
                          'i', 'n', 'p', 'u', 't', ' '] ++
                         show_poly p)
                       (\ _ ->
                         let {
                           (ca, pisa) = yun_factorization gcd_rat_poly p;
                         } in (ca, map (\ (pa, i) -> (pa, suc i)) pisa))));

divided_differences_impl_int :: [Int] -> Int -> Int -> [Int] -> Maybe [Int];
divided_differences_impl_int (xi_j1 : x_j1s) fj xj (xi : xis) =
  (case divided_differences_impl_int x_j1s fj xj xis of {
    Nothing -> Nothing;
    Just x_js ->
      let {
        (new, m) = divmod_int (minus_int (hda x_js) xi_j1) (minus_int xj xi);
      } in (if equal_int m zero_int then Just (new : x_js) else Nothing);
  });
divided_differences_impl_int [] fj xj xis = Just [fj];

bind :: forall a b. Maybe a -> (a -> Maybe b) -> Maybe b;
bind Nothing f = Nothing;
bind (Just x) f = f x;

newton_coefficients_main_int :: [Int] -> [Int] -> [Int] -> Maybe [[Int]];
newton_coefficients_main_int xs [fj] xjs = Just [[fj]];
newton_coefficients_main_int xs (fj : v : va) (xj : xjs) =
  bind (newton_coefficients_main_int xs (v : va) xjs)
    (\ rec ->
      let {
        row = hda rec;
      } in bind (divided_differences_impl_int row fj xj xs)
             (\ new_row -> Just (new_row : rec)));
newton_coefficients_main_int xs [] uv = Just [];
newton_coefficients_main_int xs (v : vb : vc) [] = Just [];

map_option :: forall a b. (a -> b) -> Maybe a -> Maybe b;
map_option f Nothing = Nothing;
map_option f (Just x2) = Just (f x2);

newton_coefficients_int :: [Int] -> [Int] -> Maybe [Int];
newton_coefficients_int xs fs =
  map_option (map hda)
    (newton_coefficients_main_int xs (reverse fs) (reverse xs));

horner_composition :: forall a. (Eq a, Idom a) => [a] -> [a] -> Poly a;
horner_composition [cn] xis = pCons cn zero_polya;
horner_composition (ci : v : va) (xi : xis) =
  plus_poly
    (times_poly (horner_composition (v : va) xis)
      (pCons (uminusa xi) (pCons onea zero_polya)))
    (pCons ci zero_polya);
horner_composition [] uv = zero_polya;
horner_composition (v : vb : vc) [] = zero_polya;

newton_poly_impl_int :: [Int] -> [Int] -> Maybe (Poly Int);
newton_poly_impl_int xs fs =
  (case newton_coefficients_int xs fs of {
    Nothing -> Nothing;
    Just nc -> Just (horner_composition (reverse nc) xs);
  });

newton_interpolation_poly_int :: [(Int, Int)] -> Maybe (Poly Int);
newton_interpolation_poly_int x_fs = let {
                                       xs = map fst x_fs;
                                       a = map snd x_fs;
                                     } in newton_poly_impl_int xs a;

kronecker_samples :: Nat -> [Int];
kronecker_samples n =
  let {
    min = uminus_int
            (int_of_nat (divide_nat n (nat_of_integer (2 :: Integer))));
  } in upto min (plus_int min (int_of_nat n));

div_mod_int_poly :: Poly Int -> Poly Int -> Maybe (Poly Int, Poly Int);
div_mod_int_poly p q =
  (if equal_poly q zero_polya then Nothing
    else let {
           n = degreea q;
           _ = coeff q n;
         } in fold_coeffs
                (\ a b ->
                  (case b of {
                    Nothing -> Nothing;
                    Just (s, r) ->
                      let {
                        ar = pCons a r;
                        (ba, m) =
                          divmod_int (coeff ar (degreea q))
                            (coeff q (degreea q));
                      } in (if equal_int m zero_int
                             then Just (pCons ba s, minus_poly ar (smult ba q))
                             else Nothing);
                  }))
                p (Just (zero_polya, zero_polya)));

div_int_poly :: Poly Int -> Poly Int -> Maybe (Poly Int);
div_int_poly p q =
  (case div_mod_int_poly p q of {
    Nothing -> Nothing;
    Just (d, m) -> (if equal_poly m zero_polya then Just d else Nothing);
  });

is_none :: forall a. Maybe a -> Bool;
is_none (Just x) = False;
is_none Nothing = True;

dvd_int_poly_non_0 :: Poly Int -> Poly Int -> Bool;
dvd_int_poly_non_0 q p = not (is_none (div_int_poly p q));

find_map_filter :: forall a b. (a -> b) -> (b -> Bool) -> [a] -> Maybe b;
find_map_filter f p [] = Nothing;
find_map_filter f p (a : asa) =
  let {
    b = f a;
  } in (if p b then Just b else find_map_filter f p asa);

concat_lists :: forall a. [[a]] -> [[a]];
concat_lists [] = [[]];
concat_lists (asa : xs) =
  concatMap (\ vec -> map (\ a -> a : vec) asa) (concat_lists xs);

the :: forall a. Maybe a -> a;
the (Just x2) = x2;

kronecker_factorization_main ::
  (Int -> [Int]) -> (Int -> [Int]) -> Nat -> Poly Int -> Maybe (Poly Int);
kronecker_factorization_main df dp bnd p =
  (if less_eq_nat (degreea p) one_nat then Nothing
    else let {
           pa = normalize_content p;
           js = kronecker_samples bnd;
           cjs = map (\ j -> (poly pa j, j)) js;
         } in (case map_of cjs zero_int of {
                Nothing ->
                  let {
                    djs = map (\ (v, j) ->
                                map (\ a -> (j, a))
                                  (if equal_int j zero_int then dp v else df v))
                            cjs;
                  } in map_option the
                         (find_map_filter newton_interpolation_poly_int
                           (\ a ->
                             (case a of {
                               Nothing -> False;
                               Just g ->
                                 dvd_int_poly_non_0 g pa &&
                                   less_eq_nat one_nat (degreea g);
                             }))
                           (concat_lists djs));
                Just j ->
                  Just (pCons (uminus_int j)
                         (pCons (Int_of_integer (1 :: Integer)) zero_polya));
              }));

kronecker_factorization_rat_main ::
  (Int -> [Int]) -> (Int -> [Int]) -> Nat -> Poly Rat -> Maybe (Poly Rat);
kronecker_factorization_rat_main df dp bnd p =
  map_option (map_poly of_int)
    (kronecker_factorization_main df dp bnd
      (snd (rat_to_normalized_int_poly p)));

remove_prime_factor :: Nat -> Nat -> [Nat] -> (Nat, [Nat]);
remove_prime_factor p n ps =
  let {
    (na, m) = divmod_nat n p;
  } in (if equal_nat m zero_nat then remove_prime_factor p na (p : ps)
         else (n, ps));

prime_factorization_nat_main :: Nat -> Nat -> [Nat] -> [Nat] -> [Nat];
prime_factorization_nat_main n j is ps =
  (case is of {
    [] -> let {
            (ja, isa) = next_candidates j;
          } in prime_factorization_nat_main n ja isa ps;
    i : isa ->
      let {
        (na, m) = divmod_nat n i;
      } in (if equal_nat m zero_nat
             then let {
                    (nb, psa) = remove_prime_factor i na (i : ps);
                  } in (if equal_nat nb one_nat then psa
                         else prime_factorization_nat_main nb j isa psa)
             else (if less_eq_nat (times_nat i i) n
                    then prime_factorization_nat_main n j isa ps else n : ps));
  });

prime_factorization_nat :: Nat -> [Nat];
prime_factorization_nat n =
  reverse
    (if less_nat n (nat_of_integer (2 :: Integer)) then []
      else let {
             (j, is) = next_candidates zero_nat;
           } in prime_factorization_nat_main n j is []);

sequences :: forall a b. (Linorder b) => (a -> b) -> [a] -> [[a]];
sequences key (a : b : xs) =
  (if less (key b) (key a) then desca key b [a] xs
    else asc key b (\ ba -> a : ba) xs);
sequences key [] = [[]];
sequences key [v] = [[v]];

asc ::
  forall a b. (Linorder b) => (a -> b) -> a -> ([a] -> [a]) -> [a] -> [[a]];
asc key a f (b : bs) =
  (if not (less (key b) (key a)) then asc key b (f . (\ ba -> a : ba)) bs
    else f [a] : sequences key (b : bs));
asc key a f [] = f [a] : sequences key [];

desca :: forall a b. (Linorder b) => (a -> b) -> a -> [a] -> [a] -> [[a]];
desca key a asa (b : bs) =
  (if less (key b) (key a) then desca key b (a : asa) bs
    else (a : asa) : sequences key (b : bs));
desca key a asa [] = (a : asa) : sequences key [];

mergeb :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a] -> [a];
mergeb key (a : asa) (b : bs) =
  (if less (key b) (key a) then b : mergeb key (a : asa) bs
    else a : mergeb key asa (b : bs));
mergeb key [] bs = bs;
mergeb key (v : va) [] = v : va;

merge_pairs :: forall a b. (Linorder b) => (a -> b) -> [[a]] -> [[a]];
merge_pairs key (a : b : xs) = mergeb key a b : merge_pairs key xs;
merge_pairs key [] = [];
merge_pairs key [v] = [v];

merge_alla :: forall a b. (Linorder b) => (a -> b) -> [[a]] -> [a];
merge_alla key [] = [];
merge_alla key [x] = x;
merge_alla key (v : vb : vc) = merge_alla key (merge_pairs key (v : vb : vc));

sort_key :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a];
sort_key key = merge_alla key . sequences key;

sublists :: forall a. [a] -> [[a]];
sublists [] = [[]];
sublists (x : xs) = let {
                      xss = sublists xs;
                    } in map (\ a -> x : a) xss ++ xss;

instance Preorder Nat where {
};

instance Order Nat where {
};

instance Linorder Nat where {
};

divisors_nat_copy :: Nat -> [Nat];
divisors_nat_copy n =
  (if equal_nat n zero_nat then []
    else remdups_adj
           (sort_key (\ x -> x)
             (map listprod (sublists (prime_factorization_nat n)))));

data Color = R | B;

data Rbta a b = Emptya | Branch Color (Rbta a b) a b (Rbta a b);

newtype Mapping_rbt b a = Mapping_RBTa (Rbta b a);

newtype Alist b a = Alist [(b, a)];

data Mapping a b = Assoc_List_Mapping (Alist a b)
  | RBT_Mapping (Mapping_rbt a b) | Mapping (a -> Maybe b);

balance :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance (Branch R a w x b) s t (Branch R c y z d) =
  Branch R (Branch B a w x b) s t (Branch B c y z d);
balance (Branch R (Branch R a w x b) s t c) y z Emptya =
  Branch R (Branch B a w x b) s t (Branch B c y z Emptya);
balance (Branch R (Branch R a w x b) s t c) y z (Branch B va vb vc vd) =
  Branch R (Branch B a w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch R Emptya w x (Branch R b s t c)) y z Emptya =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z Emptya);
balance (Branch R (Branch B va vb vc vd) w x (Branch R b s t c)) y z Emptya =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z Emptya);
balance (Branch R Emptya w x (Branch R b s t c)) y z (Branch B va vb vc vd) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch R (Branch B ve vf vg vh) w x (Branch R b s t c)) y z
  (Branch B va vb vc vd) =
  Branch R (Branch B (Branch B ve vf vg vh) w x b) s t
    (Branch B c y z (Branch B va vb vc vd));
balance Emptya w x (Branch R b s t (Branch R c y z d)) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z d);
balance (Branch B va vb vc vd) w x (Branch R b s t (Branch R c y z d)) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z d);
balance Emptya w x (Branch R (Branch R b s t c) y z Emptya) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z Emptya);
balance Emptya w x (Branch R (Branch R b s t c) y z (Branch B va vb vc vd)) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch B va vb vc vd) w x (Branch R (Branch R b s t c) y z Emptya) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z Emptya);
balance (Branch B va vb vc vd) w x
  (Branch R (Branch R b s t c) y z (Branch B ve vf vg vh)) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t
    (Branch B c y z (Branch B ve vf vg vh));
balance Emptya s t Emptya = Branch B Emptya s t Emptya;
balance Emptya s t (Branch B va vb vc vd) =
  Branch B Emptya s t (Branch B va vb vc vd);
balance Emptya s t (Branch v Emptya vb vc Emptya) =
  Branch B Emptya s t (Branch v Emptya vb vc Emptya);
balance Emptya s t (Branch v (Branch B ve vf vg vh) vb vc Emptya) =
  Branch B Emptya s t (Branch v (Branch B ve vf vg vh) vb vc Emptya);
balance Emptya s t (Branch v Emptya vb vc (Branch B vf vg vh vi)) =
  Branch B Emptya s t (Branch v Emptya vb vc (Branch B vf vg vh vi));
balance Emptya s t
  (Branch v (Branch B ve vj vk vl) vb vc (Branch B vf vg vh vi)) =
  Branch B Emptya s t
    (Branch v (Branch B ve vj vk vl) vb vc (Branch B vf vg vh vi));
balance (Branch B va vb vc vd) s t Emptya =
  Branch B (Branch B va vb vc vd) s t Emptya;
balance (Branch B va vb vc vd) s t (Branch B ve vf vg vh) =
  Branch B (Branch B va vb vc vd) s t (Branch B ve vf vg vh);
balance (Branch B va vb vc vd) s t (Branch v Emptya vf vg Emptya) =
  Branch B (Branch B va vb vc vd) s t (Branch v Emptya vf vg Emptya);
balance (Branch B va vb vc vd) s t
  (Branch v (Branch B vi vj vk vl) vf vg Emptya) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v (Branch B vi vj vk vl) vf vg Emptya);
balance (Branch B va vb vc vd) s t
  (Branch v Emptya vf vg (Branch B vj vk vl vm)) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v Emptya vf vg (Branch B vj vk vl vm));
balance (Branch B va vb vc vd) s t
  (Branch v (Branch B vi vn vo vp) vf vg (Branch B vj vk vl vm)) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v (Branch B vi vn vo vp) vf vg (Branch B vj vk vl vm));
balance (Branch v Emptya vb vc Emptya) s t Emptya =
  Branch B (Branch v Emptya vb vc Emptya) s t Emptya;
balance (Branch v Emptya vb vc (Branch B ve vf vg vh)) s t Emptya =
  Branch B (Branch v Emptya vb vc (Branch B ve vf vg vh)) s t Emptya;
balance (Branch v (Branch B vf vg vh vi) vb vc Emptya) s t Emptya =
  Branch B (Branch v (Branch B vf vg vh vi) vb vc Emptya) s t Emptya;
balance (Branch v (Branch B vf vg vh vi) vb vc (Branch B ve vj vk vl)) s t
  Emptya =
  Branch B (Branch v (Branch B vf vg vh vi) vb vc (Branch B ve vj vk vl)) s t
    Emptya;
balance (Branch v Emptya vf vg Emptya) s t (Branch B va vb vc vd) =
  Branch B (Branch v Emptya vf vg Emptya) s t (Branch B va vb vc vd);
balance (Branch v Emptya vf vg (Branch B vi vj vk vl)) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v Emptya vf vg (Branch B vi vj vk vl)) s t
    (Branch B va vb vc vd);
balance (Branch v (Branch B vj vk vl vm) vf vg Emptya) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v (Branch B vj vk vl vm) vf vg Emptya) s t
    (Branch B va vb vc vd);
balance (Branch v (Branch B vj vk vl vm) vf vg (Branch B vi vn vo vp)) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v (Branch B vj vk vl vm) vf vg (Branch B vi vn vo vp)) s t
    (Branch B va vb vc vd);

rbt_comp_ins ::
  forall a b.
    (a -> a -> Ordera) -> (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_ins c f k v Emptya = Branch R Emptya k v Emptya;
rbt_comp_ins c f k v (Branch B l x y r) =
  (case c k x of {
    Eqa -> Branch B l x (f k y v) r;
    Lt -> balance (rbt_comp_ins c f k v l) x y r;
    Gt -> balance l x y (rbt_comp_ins c f k v r);
  });
rbt_comp_ins c f k v (Branch R l x y r) =
  (case c k x of {
    Eqa -> Branch R l x (f k y v) r;
    Lt -> Branch R (rbt_comp_ins c f k v l) x y r;
    Gt -> Branch R l x y (rbt_comp_ins c f k v r);
  });

paint :: forall a b. Color -> Rbta a b -> Rbta a b;
paint c Emptya = Emptya;
paint c (Branch uu l k v r) = Branch c l k v r;

rbt_comp_insert_with_key ::
  forall a b.
    (a -> a -> Ordera) -> (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_insert_with_key c f k v t = paint B (rbt_comp_ins c f k v t);

rbt_comp_insert ::
  forall a b. (a -> a -> Ordera) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_insert c = rbt_comp_insert_with_key c (\ _ _ nv -> nv);

impl_ofb :: forall b a. (Ccompare b) => Mapping_rbt b a -> Rbta b a;
impl_ofb (Mapping_RBTa x) = x;

insertf ::
  forall a b. (Ccompare a) => a -> b -> Mapping_rbt a b -> Mapping_rbt a b;
insertf xc xd xe =
  Mapping_RBTa (rbt_comp_insert (the ccompare) xc xd (impl_ofb xe));

impl_ofa :: forall b a. Alist b a -> [(b, a)];
impl_ofa (Alist x) = x;

update :: forall a b. (Eq a) => a -> b -> [(a, b)] -> [(a, b)];
update k v [] = [(k, v)];
update k v (p : ps) = (if fst p == k then (k, v) : ps else p : update k v ps);

updatea :: forall a b. (Eq a) => a -> b -> Alist a b -> Alist a b;
updatea xc xd xe = Alist (update xc xd (impl_ofa xe));

fun_upd :: forall a b. (Eq a) => (a -> b) -> a -> b -> a -> b;
fun_upd f a b = (\ x -> (if x == a then b else f x));

updateb ::
  forall a b. (Ccompare a, Eq a) => a -> b -> Mapping a b -> Mapping a b;
updateb k v (RBT_Mapping t) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "update RBT_Mapping: ccompare = None"
        (\ _ -> updateb k v (RBT_Mapping t));
    Just _ -> RBT_Mapping (insertf k v t);
  });
updateb k v (Assoc_List_Mapping al) = Assoc_List_Mapping (updatea k v al);
updateb k v (Mapping m) = Mapping (fun_upd m k (Just v));

data Mapping_impla = Mapping_Choose | Mapping_Assoc_List | Mapping_RBT
  | Mapping_Mapping;

class Mapping_impl a where {
  mapping_impl :: Phantom a Mapping_impla;
};

of_phantom :: forall a b. Phantom a b -> b;
of_phantom (Phantom x) = x;

emptyf :: forall a b. (Ccompare a) => Mapping_rbt a b;
emptyf = Mapping_RBTa Emptya;

emptyb :: forall a b. Alist a b;
emptyb = Alist [];

mapping_empty_choose :: forall a b. (Ccompare a) => Mapping a b;
mapping_empty_choose = (case (ccompare :: Maybe (a -> a -> Ordera)) of {
                         Nothing -> Assoc_List_Mapping emptyb;
                         Just _ -> RBT_Mapping emptyf;
                       });

mapping_empty :: forall a b. (Ccompare a) => Mapping_impla -> Mapping a b;
mapping_empty Mapping_RBT = RBT_Mapping emptyf;
mapping_empty Mapping_Assoc_List = Assoc_List_Mapping emptyb;
mapping_empty Mapping_Mapping = Mapping (\ _ -> Nothing);
mapping_empty Mapping_Choose = mapping_empty_choose;

emptyc :: forall a b. (Ccompare a, Mapping_impl a) => Mapping a b;
emptyc = mapping_empty (of_phantom (mapping_impl :: Phantom a Mapping_impla));

fold :: forall a b. (a -> b -> b) -> [a] -> b -> b;
fold f (x : xs) s = fold f xs (f x s);
fold f [] s = s;

tabulate ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a) => [a] -> (a -> b) -> Mapping a b;
tabulate xs f = fold (\ k -> updateb k (f k)) xs emptyc;

rbt_comp_lookup :: forall a b. (a -> a -> Ordera) -> Rbta a b -> a -> Maybe b;
rbt_comp_lookup c Emptya k = Nothing;
rbt_comp_lookup c (Branch uu l x y r) k = (case c k x of {
    Eqa -> Just y;
    Lt -> rbt_comp_lookup c l k;
    Gt -> rbt_comp_lookup c r k;
  });

lookupd :: forall a b. (Ccompare a) => Mapping_rbt a b -> a -> Maybe b;
lookupd xa = rbt_comp_lookup (the ccompare) (impl_ofb xa);

lookupa :: forall a b. (Eq a) => Alist a b -> a -> Maybe b;
lookupa xa = map_of (impl_ofa xa);

lookupb :: forall a b. (Ccompare a, Eq a) => Mapping a b -> a -> Maybe b;
lookupb (RBT_Mapping t) = lookupd t;
lookupb (Assoc_List_Mapping al) = lookupa al;

mapping_impl_nat :: Phantom Nat Mapping_impla;
mapping_impl_nat = Phantom Mapping_RBT;

instance Mapping_impl Nat where {
  mapping_impl = mapping_impl_nat;
};

compare_nat :: Nat -> Nat -> Ordera;
compare_nat = comparator_of;

ccompare_nat :: Maybe (Nat -> Nat -> Ordera);
ccompare_nat = Just compare_nat;

instance Ccompare Nat where {
  ccompare = ccompare_nat;
};

memo_nat :: forall a. Nat -> Nat -> (Nat -> a) -> Nat -> a;
memo_nat low up f =
  let {
    m = tabulate (upt low up) f;
  } in (\ x ->
         (if less_eq_nat low x && less_nat x up then the (lookupb m x)
           else f x));

memo_divisors_nat :: Nat -> [Nat];
memo_divisors_nat =
  memo_nat zero_nat (nat_of_integer (100 :: Integer)) divisors_nat_copy;

divisors_int_pos :: Int -> [Int];
divisors_int_pos x = map int_of_nat (memo_divisors_nat (nat (abs_int x)));

divisors_int :: Int -> [Int];
divisors_int x = let {
                   xs = divisors_int_pos x;
                 } in xs ++ map uminus_int xs;

kronecker_factorization_rat :: Poly Rat -> Maybe (Poly Rat);
kronecker_factorization_rat p =
  kronecker_factorization_rat_main divisors_int divisors_int_pos
    (divide_nat (degreea p) (nat_of_integer (2 :: Integer))) p;

rational_root_test_main ::
  (Int -> [Int]) -> (Int -> [Int]) -> Poly Rat -> Maybe Rat;
rational_root_test_main df dp p =
  let {
    ip = snd (rat_to_normalized_int_poly p);
    a0 = coeff ip zero_nat;
    an = coeff ip (degreea ip);
  } in (if equal_int a0 zero_int then Just zero_rat
         else let {
                d0 = df a0;
                dn = dp an;
              } in map_option fst
                     (find_map_filter (\ x -> (x, poly p x))
                       (\ (_, res) -> equal_rat res zero_rat)
                       (concatMap
                         (\ b0 ->
                           concatMap
                             (\ bn ->
                               (if equal_int (gcd_int b0 bn)
                                     (Int_of_integer (1 :: Integer))
                                 then [divide_rat (of_int b0) (of_int bn)]
                                 else []))
                             dn)
                         d0)));

rational_root_test :: Poly Rat -> Maybe Rat;
rational_root_test p = rational_root_test_main divisors_int divisors_int_pos p;

sqrt_int :: Int -> [Int];
sqrt_int x =
  (if less_int x zero_int then []
    else (case sqrt_int_main x of {
           (y, True) ->
             (if equal_int y zero_int then [zero_int] else [y, uminus_int y]);
           (_, False) -> [];
         }));

sqrt_rat :: Rat -> [Rat];
sqrt_rat x =
  let {
    (z, n) = quotient_of x;
  } in (case sqrt_int n of {
         [] -> [];
         sn : _ ->
           map (\ sz -> divide_rat (of_int sz) (of_int sn)) (sqrt_int z);
       });

rat_roots2 :: Poly Rat -> [Rat];
rat_roots2 p =
  let {
    a = coeff p (nat_of_integer (2 :: Integer));
    b = coeff p one_nat;
    c = coeff p zero_nat;
    b2a = divide_rat b (times_rat (of_int (Int_of_integer (2 :: Integer))) a);
    bac = minus_rat (binary_power b2a (nat_of_integer (2 :: Integer)))
            (divide_rat c a);
  } in map (plus_rat (uminus_rat b2a)) (sqrt_rat bac);

rational_proper_factor :: Poly Rat -> Maybe (Poly Rat);
rational_proper_factor p =
  (if less_eq_nat (degreea p) one_nat then Nothing
    else (if equal_nat (degreea p) (nat_of_integer (2 :: Integer))
           then (case rat_roots2 p of {
                  [] -> Nothing;
                  x : _ ->
                    Just (pCons (uminus_rat x) (pCons one_rat zero_polya));
                })
           else (if equal_nat (degreea p) (nat_of_integer (3 :: Integer))
                  then (case rational_root_test p of {
                         Nothing -> Nothing;
                         Just x ->
                           Just (pCons (uminus_rat x)
                                  (pCons one_rat zero_polya));
                       })
                  else kronecker_factorization_rat p)));

factorize_rat_poly_main :: Rat -> [Poly Rat] -> [Poly Rat] -> (Rat, [Poly Rat]);
factorize_rat_poly_main c irr [] = (c, irr);
factorize_rat_poly_main c irr (p : ps) =
  (if equal_nat (degreea p) zero_nat
    then factorize_rat_poly_main (times_rat c (coeff p zero_nat)) irr ps
    else (case rational_proper_factor p of {
           Nothing -> factorize_rat_poly_main c (p : irr) ps;
           Just q -> factorize_rat_poly_main c irr (q : divide_poly p q : ps);
         }));

factorize_root_free_main ::
  Poly Rat -> [Rat] -> [Poly Rat] -> (Rat, [Poly Rat]);
factorize_root_free_main p xs fs =
  (case xs of {
    [] -> let {
            l = coeff p (degreea p);
            q = smult (inverse_rat l) p;
          } in (l, (if equal_poly q one_polya then fs else q : fs));
    x : xsa ->
      (if equal_rat (poly p x) zero_rat
        then factorize_root_free_main
               (divide_poly p (pCons (uminus_rat x) (pCons one_rat zero_polya)))
               (x : xsa) (pCons (uminus_rat x) (pCons one_rat zero_polya) : fs)
        else factorize_root_free_main p xsa fs);
  });

p_div_main ::
  forall a.
    (Eq a,
      Idom_div a) => a -> Poly a -> Poly a -> Poly a -> Nat -> Nat -> Poly a;
p_div_main lc q r d dr n =
  (if equal_nat n zero_nat then q
    else let {
           a = coeff r dr;
           qq = exact_div a lc;
           n1 = minus_nat n one_nat;
           b = monom qq n1;
           rr = minus_poly r (times_poly b d);
           qqq = plus_poly q b;
         } in p_div_main lc qqq rr d (minus_nat dr one_nat) n1);

p_div :: forall a. (Eq a, Idom_div a) => Poly a -> Poly a -> Poly a;
p_div p q =
  let {
    dp = degreea p;
    dq = degreea q;
  } in p_div_main (coeff q dq) zero_polya p q dp
         (minus_nat (plus_nat one_nat dp) dq);

roots1 :: forall a. (Field a) => Poly a -> a;
roots1 p = divide (uminusa (coeff p zero_nat)) (coeff p one_nat);

exact_div_rat :: Rat -> Rat -> Rat;
exact_div_rat = divide_rat;

instance Idom_div Rat where {
  exact_div = exact_div_rat;
};

roots_of_rat_poly_main :: Poly Rat -> [Rat];
roots_of_rat_poly_main p =
  let {
    n = degreea p;
  } in (if equal_nat n zero_nat then []
         else (if equal_nat n one_nat then [roots1 p]
                else (if equal_nat n (nat_of_integer (2 :: Integer))
                       then rat_roots2 p
                       else (case rational_root_test p of {
                              Nothing -> [];
                              Just x ->
                                x : roots_of_rat_poly_main
                                      (p_div p
(pCons (uminus_rat x) (pCons one_rat zero_polya)));
                            }))));

roots_of_rat_poly :: Poly Rat -> [Rat];
roots_of_rat_poly p = let {
                        a = yun_factorization gcd_rat_poly p;
                        (_, aa) = a;
                      } in concatMap (roots_of_rat_poly_main . fst) aa;

factorize_root_free :: Poly Rat -> (Rat, [Poly Rat]);
factorize_root_free p =
  (if equal_poly p zero_polya then (zero_rat, [])
    else factorize_root_free_main p (roots_of_rat_poly p) []);

exp_const_poly ::
  forall a. (Field a) => (a, [Poly a]) -> Nat -> (a, [(Poly a, Nat)]);
exp_const_poly cps n = let {
                         (c, ps) = cps;
                       } in (binary_power c n, map (\ p -> (p, n)) ps);

factorize_rat_poly_start ::
  Factorization_mode -> Poly Rat -> (Rat, [(Poly Rat, Nat)]);
factorize_rat_poly_start mode p =
  let {
    (c, pi) = initial_factorization_rat mode p;
  } in (if equal_factorization_mode mode Full_Factorization ||
             equal_factorization_mode mode Check_Irreducible
         then let {
                powers =
                  map (\ (pa, a) ->
                        exp_const_poly (factorize_rat_poly_main one_rat [] [pa])
                          a)
                    pi;
                const = times_rat c (listprod (map fst powers));
                a = concatMap snd powers;
              } in (const, a)
         else (if equal_factorization_mode mode Check_Root_Free
                then let {
                       (ca, ps) = factorize_root_free p;
                     } in (ca, map (\ q -> (q, one_nat)) ps)
                else (c, pi)));

normalize_factorization ::
  forall a. (Field a, Eq a) => (a, [(Poly a, Nat)]) -> (a, [(Poly a, Nat)]);
normalize_factorization (c, []) = (c, []);
normalize_factorization (c, (p, n) : ps) =
  let {
    d = coeff p (degreea p);
    q = smult (inverse d) p;
    (e, res) = normalize_factorization (times c (binary_power d n), ps);
  } in (e, (q, n) : res);

factorize_rat_poly ::
  Factorization_mode -> Poly Rat -> (Rat, [(Poly Rat, Nat)]);
factorize_rat_poly mode p =
  (if equal_poly p zero_polya then (zero_rat, [])
    else let {
           main = factorize_rat_poly_start mode p;
         } in (if equal_factorization_mode mode Check_Root_Free then main
                else normalize_factorization main));

factors_of_rat_poly :: Factorization_mode -> Poly Rat -> [Poly Rat];
factors_of_rat_poly mode p = map fst (snd (factorize_rat_poly mode p));

rai_normalize_poly_flat ::
  Factorization_mode ->
    (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
rai_normalize_poly_flat mode rai =
  let {
    (un, (ri, (p, (l, r)))) = rai;
  } in (if equal_poly_type un Monic_Irreducible then (un, (ri, (p, (l, r))))
         else rai_normalize_poly_main mode l r (factors_of_rat_poly mode p));

real_alg_precision :: Rat;
real_alg_precision = inverse_rat (of_int (Int_of_integer (8 :: Integer)));

rai_normalize ::
  Normalization_mode ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
rai_normalize mode =
  map_option
    (rai_normalize_bounds_flat real_alg_precision .
      rai_normalize_poly_flat (normalization_to_factorization_mode mode));

normalize_rai :: Normalization_mode -> Real_alg_intern -> Real_alg_intern;
normalize_rai xb xc =
  Abs_real_alg_intern (rai_normalize xb (rep_real_alg_intern xc));

poly_rat :: Rat -> Poly Rat;
poly_rat x = pCons (uminus_rat x) (pCons one_rat zero_polya);

inf_r :: Root_info -> Rat -> Nat;
inf_r (Root_Info x1 x2) = x2;

info_fun_rai ::
  Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) -> (Poly Rat, Nat);
info_fun_rai rai = (case rai of {
                     Nothing -> (poly_rat zero_rat, one_nat);
                     Just (_, (ri, (p, (_, r)))) -> (p, inf_r ri r);
                   });

info_rai :: Real_alg_intern -> (Poly Rat, Nat);
info_rai xa = info_fun_rai (rep_real_alg_intern xa);

real_alg_dt :: Real_alg_intern -> Real_alg_dt;
real_alg_dt rai =
  let {
    raia = normalize_rai No_Guarantee rai;
    (p, _) = info_rai raia;
  } in (if equal_nat (degreea p) one_nat
         then Rationala (uminus_rat (coeff p zero_nat)) else Irrational raia);

poly_rat_root_info :: Rat -> Root_info;
poly_rat_root_info x =
  Root_Info
    (\ a b ->
      (if less_eq_rat a x && less_eq_rat x b then one_nat else zero_nat))
    (\ a -> (if less_eq_rat x a then one_nat else zero_nat));

of_rat_rai_fun :: Rat -> Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
of_rat_rai_fun =
  (\ x ->
    (if equal_rat x zero_rat then Nothing
      else Just (Monic_Irreducible,
                  (poly_rat_root_info x, (poly_rat x, (x, x))))));

of_rat_rai :: Rat -> Real_alg_intern;
of_rat_rai xa = Abs_real_alg_intern (of_rat_rai_fun xa);

rai_of_radt :: Real_alg_dt -> Real_alg_intern;
rai_of_radt (Rationala r) = of_rat_rai r;
rai_of_radt (Irrational rai) = rai;

pcompose :: forall a. (Eq a, Idom a) => Poly a -> Poly a -> Poly a;
pcompose p q =
  fold_coeffs (\ a c -> plus_poly (pCons a zero_polya) (times_poly q c)) p
    zero_polya;

poly_uminus :: forall a. (Field a, Eq a) => Poly a -> Poly a;
poly_uminus p = pcompose p (pCons zeroa (pCons (uminusa onea) zero_polya));

monic_poly :: forall a. (Field a, Eq a) => Poly a -> Poly a;
monic_poly p = let {
                 a = coeff p (degreea p);
               } in (if a == onea then p else smult (inverse a) p);

uminus_rai_fun ::
  Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
uminus_rai_fun =
  map_option
    (\ (un, (_, (p, (l, r)))) ->
      let {
        pa = monic_poly (poly_uminus p);
      } in ((case un of {
              Monic_Irreducible -> un;
              Monic_Root_Free -> Arbitrary_Poly;
              Arbitrary_Poly -> Arbitrary_Poly;
            }),
             (count_roots_interval_rat pa,
               (pa, (uminus_rat r, uminus_rat l)))));

uminus_rai :: Real_alg_intern -> Real_alg_intern;
uminus_rai xa = Abs_real_alg_intern (uminus_rai_fun (rep_real_alg_intern xa));

uminus_radt :: Real_alg_dt -> Real_alg_dt;
uminus_radt (Rationala r) = Rationala (uminus_rat r);
uminus_radt (Irrational v) =
  real_alg_dt (uminus_rai (rai_of_radt (Irrational v)));

uminus_radtc :: Real_alg_dtc -> Real_alg_dtc;
uminus_radtc xa = Abs_real_alg_dtc (uminus_radt (rep_real_alg_dtc xa));

uminus_real_alg :: Real_alg -> Real_alg;
uminus_real_alg (Abstr_real_alg x) = Abstr_real_alg (uminus_radtc x);

uminus_real :: Real -> Real;
uminus_real (Real_of x) = Real_of (uminus_real_alg x);

poly_mult_rat :: Rat -> Poly Rat -> Poly Rat;
poly_mult_rat r p =
  pcompose p (pCons zero_rat (pCons (inverse_rat r) zero_polya));

mult_rat_rai_fun_pos ::
  Rat ->
    (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
mult_rat_rai_fun_pos r1 (un2, (ri2, (p2, (l2, r2)))) =
  let {
    p = monic_poly (poly_mult_rat r1 p2);
    ri = count_roots_interval_rat p;
    _ = l_r ri;
    (l, r) = (times_rat l2 r1, times_rat r2 r1);
  } in ((case un2 of {
          Monic_Irreducible -> un2;
          Monic_Root_Free -> Arbitrary_Poly;
          Arbitrary_Poly -> Arbitrary_Poly;
        }),
         (ri, (p, (l, r))));

mult_rat_rai_fun ::
  Rat ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
mult_rat_rai_fun x (Just y) =
  (if less_rat x zero_rat
    then uminus_rai_fun (Just (mult_rat_rai_fun_pos (uminus_rat x) y))
    else (if equal_rat x zero_rat then Nothing
           else Just (mult_rat_rai_fun_pos x y)));
mult_rat_rai_fun x Nothing = Nothing;

mult_rat_rai :: Rat -> Real_alg_intern -> Real_alg_intern;
mult_rat_rai xb xc =
  Abs_real_alg_intern (mult_rat_rai_fun xb (rep_real_alg_intern xc));

mult_rat_radt :: Rat -> Real_alg_dt -> Real_alg_dt;
mult_rat_radt x y = real_alg_dt (mult_rat_rai x (rai_of_radt y));

tighten_poly_bounds_binary ::
  (Rat -> Rat -> Nat) ->
    (Rat -> Rat -> Nat) ->
      (Rat -> Rat -> Nat) ->
        (Rat -> Rat -> Rat -> Rat -> (Rat, Rat)) ->
          Rat -> Rat -> Rat -> Rat -> (Rat, Rat);
tighten_poly_bounds_binary cr1 cr2 cr bnd l1 r1 l2 r2 =
  let {
    (l, r) = bnd l1 r1 l2 r2;
  } in (if equal_nat (cr l r) one_nat then (l, r)
         else let {
                (l1a, r1a) = tighten_poly_bounds cr1 l1 r1;
                a = tighten_poly_bounds cr2 l2 r2;
                (aa, b) = a;
              } in tighten_poly_bounds_binary cr1 cr2 cr bnd l1a r1a aa b);

eliminate_zero_divisors :: forall a. (Eq a, Idom_div a) => Poly a -> Poly a;
eliminate_zero_divisors p =
  (if coeff p zero_nat == zeroa && not (is_zero p)
    then eliminate_zero_divisors (p_div p (pCons zeroa (pCons onea zero_polya)))
    else p);

instance (Zero a) => Zero (Poly a) where {
  zeroa = zero_polya;
};

poly_lift :: forall a. (Zero a, Eq a) => Poly a -> Poly (Poly a);
poly_lift = map_poly (\ a -> pCons a zero_polya);

instance (Comm_monoid_add a, Eq a) => Plus (Poly a) where {
  plus = plus_poly;
};

instance (Comm_monoid_add a, Eq a) => Semigroup_add (Poly a) where {
};

instance (Comm_monoid_add a, Eq a) => Ab_semigroup_add (Poly a) where {
};

instance (Comm_monoid_add a, Eq a) => Monoid_add (Poly a) where {
};

instance (Comm_monoid_add a, Eq a) => Comm_monoid_add (Poly a) where {
};

poly_x_div_y :: forall a. (Eq a, Comm_ring_1 a) => Poly a -> Poly (Poly a);
poly_x_div_y p =
  listsum
    (map (\ i -> monom (monom (coeff p i) i) (minus_nat (degreea p) i))
      (upt zero_nat (suc (degreea p))));

newtype Common_divisor a = Abs_common_divisor (a -> a -> a);

exact_div_polya :: forall a. (Eq a, Idom_div a) => Poly a -> Poly a -> Poly a;
exact_div_polya = p_div;

instance (Cancel_comm_monoid_add a,
           Eq a) => Cancel_semigroup_add (Poly a) where {
};

instance (Ab_group_add a, Eq a) => Minus (Poly a) where {
  minus = minus_poly;
};

instance (Ab_group_add a, Eq a) => Cancel_ab_semigroup_add (Poly a) where {
};

instance (Ab_group_add a, Eq a) => Cancel_comm_monoid_add (Poly a) where {
};

instance (Eq a, Idom a) => Mult_zero (Poly a) where {
};

instance (Eq a, Idom a) => Semiring (Poly a) where {
};

instance (Eq a, Idom a) => Semiring_0 (Poly a) where {
};

instance (Eq a, Idom a) => Semiring_0_cancel (Poly a) where {
};

instance (Eq a, Idom a) => Ab_semigroup_mult (Poly a) where {
};

instance (Eq a, Idom a) => Comm_semiring (Poly a) where {
};

instance (Eq a, Idom a) => Comm_semiring_0 (Poly a) where {
};

instance (Eq a, Idom a) => Comm_semiring_0_cancel (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a) => Numeral (Poly a) where {
};

instance (Eq a, Idom a) => Semiring_numeral (Poly a) where {
};

instance (Comm_semiring_1 a) => Zero_neq_one (Poly a) where {
};

instance (Eq a, Idom a) => Semiring_1 (Poly a) where {
};

instance (Eq a, Idom a) => Semiring_1_cancel (Poly a) where {
};

instance (Eq a, Idom a) => Dvd (Poly a) where {
};

instance (Eq a, Idom a) => Comm_monoid_mult (Poly a) where {
};

instance (Eq a, Idom a) => Comm_semiring_1 (Poly a) where {
};

instance (Eq a, Idom a) => Comm_semiring_1_cancel (Poly a) where {
};

instance (Eq a, Idom a) => Comm_semiring_1_cancel_crossproduct (Poly a) where {
};

instance (Eq a, Idom a) => Semiring_no_zero_divisors (Poly a) where {
};

instance (Eq a, Idom a) => Semiring_1_no_zero_divisors (Poly a) where {
};

instance (Eq a, Idom a) => Semiring_no_zero_divisors_cancel (Poly a) where {
};

instance (Ab_group_add a) => Uminus (Poly a) where {
  uminusa = uminus_poly;
};

instance (Ab_group_add a, Eq a) => Group_add (Poly a) where {
};

instance (Ab_group_add a, Eq a) => Ab_group_add (Poly a) where {
};

instance (Eq a, Idom a) => Ring (Poly a) where {
};

instance (Eq a, Idom a) => Ring_no_zero_divisors (Poly a) where {
};

instance (Eq a, Comm_ring_1 a) => Neg_numeral (Poly a) where {
};

instance (Eq a, Idom a) => Ring_1 (Poly a) where {
};

instance (Eq a, Idom a) => Ring_1_no_zero_divisors (Poly a) where {
};

instance (Eq a, Idom a) => Comm_ring (Poly a) where {
};

instance (Eq a, Idom a) => Comm_ring_1 (Poly a) where {
};

instance (Eq a, Idom a) => Semidom (Poly a) where {
};

instance (Eq a, Idom a) => Idom (Poly a) where {
};

instance (Eq a, Idom_div a) => Idom_div (Poly a) where {
  exact_div = exact_div_polya;
};

common_divisor_int_poly :: Common_divisor (Poly Int);
common_divisor_int_poly = Abs_common_divisor gcd_int_poly;

pseudo_divmod_main ::
  forall a.
    (Eq a,
      Idom_div a) => a -> Poly a ->
                            Poly a -> Poly a -> Nat -> Nat -> (Poly a, Poly a);
pseudo_divmod_main lc q r d dr n =
  (if equal_nat n zero_nat then (q, r)
    else let {
           rr = smult lc r;
           a = coeff rr dr;
           qq = exact_div a lc;
           n1 = minus_nat n one_nat;
           b = monom qq n1;
           rrr = minus_poly rr (times_poly b d);
           qqq = plus_poly (smult lc q) b;
         } in pseudo_divmod_main lc qqq rrr d (minus_nat dr one_nat) n1);

pseudo_divmod ::
  forall a. (Eq a, Idom_div a) => Poly a -> Poly a -> (Poly a, Poly a);
pseudo_divmod p q =
  let {
    dp = degreea p;
    dq = degreea q;
  } in pseudo_divmod_main (coeff q dq) zero_polya p q dp
         (minus_nat (plus_nat one_nat dp) dq);

rep_common_divisor :: forall a. (Idom_div a) => Common_divisor a -> a -> a -> a;
rep_common_divisor (Abs_common_divisor x) = x;

common_divisor :: forall a. (Idom_div a) => Common_divisor a -> a -> a -> a;
common_divisor x = rep_common_divisor x;

common_divisor_list :: forall a. (Idom_div a) => Common_divisor a -> [a] -> a;
common_divisor_list f xs = let {
                             cd = common_divisor f;
                           } in foldr cd xs zeroa;

exact_div_poly :: forall a. (Eq a, Idom_div a) => Poly a -> a -> Poly a;
exact_div_poly p a = map_poly (\ c -> exact_div c a) p;

resultant_impl_main ::
  forall a.
    (Eq a,
      Idom_div a) => Common_divisor a -> Poly a -> Poly a -> Nat -> Nat -> a;
resultant_impl_main cdf f g df dg =
  (if equal_nat dg zero_nat then binary_power (coeff g zero_nat) df
    else let {
           cd = common_divisor_list cdf (coeffs g);
           pg = exact_div_poly g cd;
           (_, r) = pseudo_divmod f pg;
           dr = degreea r;
           c = coeff pg dg;
           e1 = times_nat (minus_nat (suc df) dg) dg;
           e2 = minus_nat df dr;
           rgr = resultant_impl_main cdf pg r dg dr;
           rrg = (if dvd (nat_of_integer (2 :: Integer)) dg ||
                       dvd (nat_of_integer (2 :: Integer)) dr ==
                         dvd (nat_of_integer (2 :: Integer)) e2
                   then rgr else uminusa rgr);
         } in times (binary_power cd df)
                (exact_div rrg (binary_power c (minus_nat e1 e2))));

resultant_impl ::
  forall a. (Eq a, Idom_div a) => Common_divisor a -> Poly a -> Poly a -> a;
resultant_impl cdf f g =
  let {
    df = degreea f;
    dg = degreea g;
  } in (if less_eq_nat dg df then resultant_impl_main cdf f g df dg
         else let {
                gf = resultant_impl_main cdf g f dg df;
              } in (if dvd (nat_of_integer (2 :: Integer)) df ||
                         dvd (nat_of_integer (2 :: Integer)) dg
                     then gf else uminusa gf));

resultant_int_poly :: Poly (Poly Int) -> Poly (Poly Int) -> Poly Int;
resultant_int_poly = resultant_impl common_divisor_int_poly;

poly_mult_inta :: Poly Int -> Poly Int -> Poly Int;
poly_mult_inta p q = resultant_int_poly (poly_x_div_y p) (poly_lift q);

poly_mult_int :: Poly Int -> Poly Int -> Poly Int;
poly_mult_int p q =
  poly_mult_inta (eliminate_zero_divisors p) (eliminate_zero_divisors q);

mult_rai_fun_pos ::
  (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
    (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
mult_rai_fun_pos (un1, (ri1, (p1, (l1, r1)))) (un2, (ri2, (p2, (l2, r2)))) =
  let {
    p = map_poly of_int
          (poly_mult_int (snd (rat_to_int_poly p1)) (snd (rat_to_int_poly p2)));
    ri = count_roots_interval_rat p;
    (l, r) =
      tighten_poly_bounds_binary (l_r ri1) (l_r ri2) (l_r ri)
        (\ l1a r1a l2a r2a -> (times_rat l1a l2a, times_rat r1a r2a)) l1 r1 l2
        r2;
    (un, (ria, (pa, _))) =
      rai_normalize_poly_flat Uncertified_Factorization
        (Arbitrary_Poly, (ri, (p, (l, r))));
  } in (un, (ria, (pa, (l, r))));

mult_rai_fun ::
  Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
mult_rai_fun (Just x) (Just y) =
  let {
    ((_, (_, (_, (_, r1)))), (_, (_, (_, (_, r2))))) = (x, y);
  } in (if less_rat zero_rat r1 && less_rat zero_rat r2
         then Just (mult_rai_fun_pos x y)
         else (if less_rat zero_rat r1 && less_rat r2 zero_rat
                then uminus_rai_fun
                       (Just (mult_rai_fun_pos x
                               (the (uminus_rai_fun (Just y)))))
                else (if less_rat r1 zero_rat && less_rat zero_rat r2
                       then uminus_rai_fun
                              (Just (mult_rai_fun_pos
                                      (the (uminus_rai_fun (Just x))) y))
                       else Just (mult_rai_fun_pos
                                   (the (uminus_rai_fun (Just x)))
                                   (the (uminus_rai_fun (Just y)))))));
mult_rai_fun Nothing y = Nothing;
mult_rai_fun (Just v) Nothing = Nothing;

mult_rai :: Real_alg_intern -> Real_alg_intern -> Real_alg_intern;
mult_rai xb xc =
  Abs_real_alg_intern
    (mult_rai_fun (rep_real_alg_intern xb) (rep_real_alg_intern xc));

mult_radt :: Real_alg_dt -> Real_alg_dt -> Real_alg_dt;
mult_radt (Rationala r) (Rationala q) = Rationala (times_rat r q);
mult_radt (Rationala r) (Irrational v) = mult_rat_radt r (Irrational v);
mult_radt (Irrational v) (Rationala q) = mult_rat_radt q (Irrational v);
mult_radt (Irrational v) (Irrational va) =
  real_alg_dt
    (mult_rai (rai_of_radt (Irrational v)) (rai_of_radt (Irrational va)));

mult_radtc :: Real_alg_dtc -> Real_alg_dtc -> Real_alg_dtc;
mult_radtc xb xc =
  Abs_real_alg_dtc (mult_radt (rep_real_alg_dtc xb) (rep_real_alg_dtc xc));

times_real_alg :: Real_alg -> Real_alg -> Real_alg;
times_real_alg (Abstr_real_alg xa) (Abstr_real_alg x) =
  Abstr_real_alg (mult_radtc xa x);

times_real :: Real -> Real -> Real;
times_real (Real_of x) (Real_of y) = Real_of (times_real_alg x y);

poly_add_rat :: Rat -> Poly Rat -> Poly Rat;
poly_add_rat r p = pcompose p (pCons (uminus_rat r) (pCons one_rat zero_polya));

add_rat_rai_fun ::
  Rat ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
add_rat_rai_fun r1 (Just (un2, (ri2, (p2, (l2, r2))))) =
  let {
    p = monic_poly (poly_add_rat r1 p2);
    ri = count_roots_interval_rat p;
    cr = l_r ri;
    (l, r) = (plus_rat l2 r1, plus_rat r2 r1);
  } in (if less_eq_rat l zero_rat &&
             less_eq_rat zero_rat r && equal_rat (poly p zero_rat) zero_rat
         then Nothing
         else let {
                (la, ra) = tighten_poly_bounds_for_x cr zero_rat l r;
              } in Just ((case un2 of {
                           Monic_Irreducible -> un2;
                           Monic_Root_Free -> Arbitrary_Poly;
                           Arbitrary_Poly -> Arbitrary_Poly;
                         }),
                          (ri, (p, (la, ra)))));
add_rat_rai_fun r1 Nothing = of_rat_rai_fun r1;

add_rat_rai :: Rat -> Real_alg_intern -> Real_alg_intern;
add_rat_rai xb xc =
  Abs_real_alg_intern (add_rat_rai_fun xb (rep_real_alg_intern xc));

add_rat_radt :: Rat -> Real_alg_dt -> Real_alg_intern;
add_rat_radt x y = add_rat_rai x (rai_of_radt y);

plus_rat_radt :: Rat -> Real_alg_dt -> Real_alg_dt;
plus_rat_radt x y = real_alg_dt (add_rat_radt x y);

poly_x_minus_y :: forall a. (Eq a, Idom a) => Poly a -> Poly (Poly a);
poly_x_minus_y p =
  pcompose (poly_lift p)
    (pCons (pCons zeroa (pCons onea zero_polya))
      (pCons (uminus_poly one_polya) zero_polya));

poly_add_int :: Poly Int -> Poly Int -> Poly Int;
poly_add_int p q = resultant_int_poly (poly_x_minus_y p) (poly_lift q);

add_rai_fun ::
  Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
add_rai_fun (Just (un1, (ri1, (p1, (l1, r1)))))
  (Just (un2, (ri2, (p2, (l2, r2))))) =
  let {
    p = map_poly of_int
          (poly_add_int (snd (rat_to_int_poly p1)) (snd (rat_to_int_poly p2)));
    ri = count_roots_interval_rat p;
    cr = l_r ri;
    (l, r) =
      tighten_poly_bounds_binary (l_r ri1) (l_r ri2) cr
        (\ l1a r1a l2a r2a -> (plus_rat l1a l2a, plus_rat r1a r2a)) l1 r1 l2 r2;
    (un, (ria, (pa, _))) =
      rai_normalize_poly_flat Uncertified_Factorization
        (Arbitrary_Poly, (ri, (p, (l, r))));
  } in (if less_eq_rat l zero_rat &&
             less_eq_rat zero_rat r && equal_rat (poly pa zero_rat) zero_rat
         then Nothing
         else let {
                (la, ra) = tighten_poly_bounds_for_x (l_r ria) zero_rat l r;
              } in Just (un, (ria, (pa, (la, ra)))));
add_rai_fun Nothing y = y;
add_rai_fun (Just v) Nothing = Just v;

add_rai :: Real_alg_intern -> Real_alg_intern -> Real_alg_intern;
add_rai xb xc =
  Abs_real_alg_intern
    (add_rai_fun (rep_real_alg_intern xb) (rep_real_alg_intern xc));

plus_radt :: Real_alg_dt -> Real_alg_dt -> Real_alg_dt;
plus_radt (Rationala r) (Rationala q) = Rationala (plus_rat r q);
plus_radt (Rationala r) (Irrational v) = plus_rat_radt r (Irrational v);
plus_radt (Irrational v) (Rationala q) = plus_rat_radt q (Irrational v);
plus_radt (Irrational v) (Irrational va) =
  real_alg_dt
    (add_rai (rai_of_radt (Irrational v)) (rai_of_radt (Irrational va)));

plus_radtc :: Real_alg_dtc -> Real_alg_dtc -> Real_alg_dtc;
plus_radtc xb xc =
  Abs_real_alg_dtc (plus_radt (rep_real_alg_dtc xb) (rep_real_alg_dtc xc));

plus_real_alg :: Real_alg -> Real_alg -> Real_alg;
plus_real_alg (Abstr_real_alg xa) (Abstr_real_alg x) =
  Abstr_real_alg (plus_radtc xa x);

minus_real_alg :: Real_alg -> Real_alg -> Real_alg;
minus_real_alg x y = plus_real_alg x (uminus_real_alg y);

minus_real :: Real -> Real -> Real;
minus_real (Real_of x) (Real_of y) = Real_of (minus_real_alg x y);

of_rat_radtc :: Rat -> Real_alg_dtc;
of_rat_radtc xa = Abs_real_alg_dtc (Rationala xa);

of_rat_real_alg :: Rat -> Real_alg;
of_rat_real_alg x = Abstr_real_alg (of_rat_radtc x);

zero_real_alg :: Real_alg;
zero_real_alg = of_rat_real_alg zero_rat;

zero_real :: Real;
zero_real = Real_of zero_real_alg;

plus_real :: Real -> Real -> Real;
plus_real (Real_of x) (Real_of y) = Real_of (plus_real_alg x y);

one_real_alg :: Real_alg;
one_real_alg = of_rat_real_alg one_rat;

one_real :: Real;
one_real = Real_of one_real_alg;

instance Plus Real where {
  plus = plus_real;
};

instance Semigroup_add Real where {
};

instance Cancel_semigroup_add Real where {
};

instance Ab_semigroup_add Real where {
};

instance Minus Real where {
  minus = minus_real;
};

instance Cancel_ab_semigroup_add Real where {
};

instance Zero Real where {
  zeroa = zero_real;
};

instance Monoid_add Real where {
};

instance Comm_monoid_add Real where {
};

instance Cancel_comm_monoid_add Real where {
};

instance Times Real where {
  times = times_real;
};

instance Mult_zero Real where {
};

instance Semigroup_mult Real where {
};

instance Semiring Real where {
};

instance Semiring_0 Real where {
};

instance Semiring_0_cancel Real where {
};

instance One Real where {
  onea = one_real;
};

instance Power Real where {
};

instance Monoid_mult Real where {
};

instance Numeral Real where {
};

instance Semiring_numeral Real where {
};

instance Zero_neq_one Real where {
};

instance Semiring_1 Real where {
};

instance Semiring_1_cancel Real where {
};

instance Uminus Real where {
  uminusa = uminus_real;
};

instance Group_add Real where {
};

instance Neg_numeral Real where {
};

instance Ab_group_add Real where {
};

instance Ring Real where {
};

instance Ring_1 Real where {
};

real_of_int :: Int -> Real;
real_of_int x = of_inta x;

class (Linordered_idom a) => Real_embedding a where {
  real_of :: a -> Real;
};

instance Real_embedding Int where {
  real_of = real_of_int;
};

instance Large_ordered_semiring_1 Int where {
};

class (Real_embedding a,
        Large_ordered_semiring_1 a) => Large_real_ordered_semiring_1 a where {
};

instance Large_real_ordered_semiring_1 Int where {
};

shows_list_nat :: [Nat] -> [Prelude.Char] -> [Prelude.Char];
shows_list_nat = showsp_list shows_prec_nat zero_nat;

instance Showa Nat where {
  shows_prec = shows_prec_nat;
  shows_list = shows_list_nat;
};

min :: forall a. (Ord a) => a -> a -> a;
min a b = (if less_eq a b then a else b);

inf_nat :: Nat -> Nat -> Nat;
inf_nat = min;

class Inf a where {
  inf :: a -> a -> a;
};

instance Inf Nat where {
  inf = inf_nat;
};

sup_nat :: Nat -> Nat -> Nat;
sup_nat = max;

class Sup a where {
  sup :: a -> a -> a;
};

instance Sup Nat where {
  sup = sup_nat;
};

class Compare a where {
  compare :: a -> a -> Ordera;
};

class (Compare a, Linorder a) => Compare_order a where {
};

class (Compare_order a) => Key a where {
};

instance Compare Nat where {
  compare = compare_nat;
};

instance Compare_order Nat where {
};

instance Key Nat where {
};

class (Sup a, Order a) => Semilattice_sup a where {
};

class (Inf a, Order a) => Semilattice_inf a where {
};

class (Semilattice_inf a, Semilattice_sup a) => Lattice a where {
};

instance Semilattice_sup Nat where {
};

instance Semilattice_inf Nat where {
};

instance Lattice Nat where {
};

ceq_nat :: Maybe (Nat -> Nat -> Bool);
ceq_nat = Just equal_nat;

instance Ceq Nat where {
  ceq = ceq_nat;
};

set_impl_nat :: Phantom Nat Set_impla;
set_impl_nat = Phantom Set_RBT;

instance Set_impl Nat where {
  set_impl = set_impl_nat;
};

finite_UNIV_nat :: Phantom Nat Bool;
finite_UNIV_nat = Phantom False;

card_UNIV_nat :: Phantom Nat Nat;
card_UNIV_nat = Phantom zero_nat;

class Finite_UNIV a where {
  finite_UNIV :: Phantom a Bool;
};

class (Finite_UNIV a) => Card_UNIV a where {
  card_UNIVa :: Phantom a Nat;
};

instance Finite_UNIV Nat where {
  finite_UNIV = finite_UNIV_nat;
};

instance Card_UNIV Nat where {
  card_UNIVa = card_UNIV_nat;
};

cEnum_nat :: Maybe ([Nat], ((Nat -> Bool) -> Bool, (Nat -> Bool) -> Bool));
cEnum_nat = Nothing;

instance Cenum Nat where {
  cEnum = cEnum_nat;
};

proper_interval_nat :: Maybe Nat -> Maybe Nat -> Bool;
proper_interval_nat no Nothing = True;
proper_interval_nat Nothing (Just x) = less_nat zero_nat x;
proper_interval_nat (Just x) (Just y) = less_nat one_nat (minus_nat y x);

cproper_interval_nat :: Maybe Nat -> Maybe Nat -> Bool;
cproper_interval_nat = proper_interval_nat;

class (Ccompare a) => Cproper_interval a where {
  cproper_interval :: Maybe a -> Maybe a -> Bool;
};

instance Cproper_interval Nat where {
  cproper_interval = cproper_interval_nat;
};

compare_rat :: Rat -> Rat -> Ordera;
compare_rat = comparator_of;

instance Compare Rat where {
  compare = compare_rat;
};

ceq_rat :: Maybe (Rat -> Rat -> Bool);
ceq_rat = Just equal_rat;

instance Ceq Rat where {
  ceq = ceq_rat;
};

set_impl_rat :: Phantom Rat Set_impla;
set_impl_rat = Phantom Set_RBT;

instance Set_impl Rat where {
  set_impl = set_impl_rat;
};

cEnum_rat :: Maybe ([Rat], ((Rat -> Bool) -> Bool, (Rat -> Bool) -> Bool));
cEnum_rat = Nothing;

instance Cenum Rat where {
  cEnum = cEnum_rat;
};

ccompare_rat :: Maybe (Rat -> Rat -> Ordera);
ccompare_rat = Just compare_rat;

instance Ccompare Rat where {
  ccompare = ccompare_rat;
};

of_rat :: forall a. (Field_char_0 a) => Rat -> a;
of_rat p = let {
             a = quotient_of p;
             (aa, b) = a;
           } in divide (of_inta aa) (of_inta b);

poly_inverse :: forall a. (Field a, Eq a) => Poly a -> Poly a;
poly_inverse p =
  listsum
    (map (\ i -> monom (coeff p (minus_nat (degreea p) i)) i)
      (upt zero_nat (suc (degreea p))));

inverse_rai_fun ::
  forall a b c.
    (Inverse b,
      Inverse c) => Maybe (Poly_type, (a, (Poly Rat, (b, c)))) ->
                      Maybe (Poly_type, (Root_info, (Poly Rat, (c, b))));
inverse_rai_fun =
  map_option
    (\ (un, (_, (p, (l, r)))) ->
      let {
        pa = monic_poly (poly_inverse p);
      } in ((case un of {
              Monic_Irreducible -> un;
              Monic_Root_Free -> Arbitrary_Poly;
              Arbitrary_Poly -> Arbitrary_Poly;
            }),
             (count_roots_interval_rat pa, (pa, (inverse r, inverse l)))));

inverse_rai :: Real_alg_intern -> Real_alg_intern;
inverse_rai xa = Abs_real_alg_intern (inverse_rai_fun (rep_real_alg_intern xa));

inverse_radt :: Real_alg_dt -> Real_alg_dt;
inverse_radt (Rationala r) = Rationala (inverse_rat r);
inverse_radt (Irrational v) =
  real_alg_dt (inverse_rai (rai_of_radt (Irrational v)));

inverse_radtc :: Real_alg_dtc -> Real_alg_dtc;
inverse_radtc xa = Abs_real_alg_dtc (inverse_radt (rep_real_alg_dtc xa));

inverse_real_alg :: Real_alg -> Real_alg;
inverse_real_alg (Abstr_real_alg x) = Abstr_real_alg (inverse_radtc x);

inverse_real :: Real -> Real;
inverse_real (Real_of x) = Real_of (inverse_real_alg x);

divide_real_alg :: Real_alg -> Real_alg -> Real_alg;
divide_real_alg x y = times_real_alg x (inverse_real_alg y);

divide_real :: Real -> Real -> Real;
divide_real (Real_of x) (Real_of y) = Real_of (divide_real_alg x y);

instance Semiring_char_0 Real where {
};

instance Ring_char_0 Real where {
};

instance Ab_semigroup_mult Real where {
};

instance Comm_semiring Real where {
};

instance Comm_semiring_0 Real where {
};

instance Comm_semiring_0_cancel Real where {
};

instance Dvd Real where {
};

instance Comm_monoid_mult Real where {
};

instance Comm_semiring_1 Real where {
};

instance Comm_semiring_1_cancel Real where {
};

instance Comm_semiring_1_cancel_crossproduct Real where {
};

instance Semiring_no_zero_divisors Real where {
};

instance Semiring_1_no_zero_divisors Real where {
};

instance Semiring_no_zero_divisors_cancel Real where {
};

instance Ring_no_zero_divisors Real where {
};

instance Ring_1_no_zero_divisors Real where {
};

instance Comm_ring Real where {
};

instance Comm_ring_1 Real where {
};

instance Semidom Real where {
};

instance Idom Real where {
};

instance Ufd Real where {
};

instance Divide Real where {
  divide = divide_real;
};

instance Inverse Real where {
  inverse = inverse_real;
};

instance Division_ring Real where {
};

instance Semidom_divide Real where {
};

instance Idom_divide Real where {
};

instance Field Real where {
};

instance Field_char_0 Real where {
};

real_of_rat :: Rat -> Real;
real_of_rat x = of_rat x;

instance Real_embedding Rat where {
  real_of = real_of_rat;
};

instance Large_real_ordered_semiring_1 Rat where {
};

equal_order :: Ordera -> Ordera -> Bool;
equal_order Lt Gt = False;
equal_order Gt Lt = False;
equal_order Eqa Gt = False;
equal_order Gt Eqa = False;
equal_order Eqa Lt = False;
equal_order Lt Eqa = False;
equal_order Gt Gt = True;
equal_order Lt Lt = True;
equal_order Eqa Eqa = True;

newtype Generator a b = Generator (b -> Bool, b -> (a, b));

generator :: forall a b. Generator a b -> (b -> Bool, b -> (a, b));
generator (Generator x) = x;

has_next :: forall a b. Generator a b -> b -> Bool;
has_next g = fst (generator g);

next :: forall a b. Generator a b -> b -> (a, b);
next g = snd (generator g);

sorted_list_subset_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
sorted_list_subset_fusion less eq g1 g2 s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in has_next g2 s2 &&
                let {
                  (y, s2a) = next g2 s2;
                } in (if eq x y
                       then sorted_list_subset_fusion less eq g1 g2 s1a s2a
                       else less y x &&
                              sorted_list_subset_fusion less eq g1 g2 s1 s2a)
    else True);

list_all_fusion :: forall a b. Generator a b -> (a -> Bool) -> b -> Bool;
list_all_fusion g p s =
  (if has_next g s then let {
                          (x, sa) = next g s;
                        } in p x && list_all_fusion g p sa
    else True);

rbt_keys_next ::
  forall a b. ([(a, Rbta a b)], Rbta a b) -> (a, ([(a, Rbta a b)], Rbta a b));
rbt_keys_next ((k, t) : kts, Emptya) = (k, (kts, t));
rbt_keys_next (kts, Branch c l k v r) = rbt_keys_next ((k, r) : kts, l);

rbt_has_next :: forall a b c. ([(a, Rbta b c)], Rbta b c) -> Bool;
rbt_has_next ([], Emptya) = False;
rbt_has_next (vb : vc, va) = True;
rbt_has_next (v, Branch vb vc vd ve vf) = True;

rbt_keys_generator :: forall a b. Generator a ([(a, Rbta a b)], Rbta a b);
rbt_keys_generator = Generator (rbt_has_next, rbt_keys_next);

lt_of_comp :: forall a. (a -> a -> Ordera) -> a -> a -> Bool;
lt_of_comp acomp x y = (case acomp x y of {
                         Eqa -> False;
                         Lt -> True;
                         Gt -> False;
                       });

newtype Set_dlist a = Abs_dlist [a];

data Set a = Collect_set (a -> Bool) | DList_set (Set_dlist a)
  | RBT_set (Mapping_rbt a ()) | Set_Monad [a] | Complement (Set a);

list_of_dlista :: forall a. (Ceq a) => Set_dlist a -> [a];
list_of_dlista (Abs_dlist x) = x;

dlist_all :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Bool;
dlist_all x xc = all x (list_of_dlista xc);

rbt_init :: forall a b c. Rbta a b -> ([(c, Rbta a b)], Rbta a b);
rbt_init = (\ a -> ([], a));

init ::
  forall a b c. (Ccompare a) => Mapping_rbt a b -> ([(c, Rbta a b)], Rbta a b);
init xa = rbt_init (impl_ofb xa);

collect :: forall a. (Cenum a) => (a -> Bool) -> Set a;
collect p = (case cEnum of {
              Nothing -> Collect_set p;
              Just (enum, _) -> Set_Monad (filter p enum);
            });

list_member :: forall a. (a -> a -> Bool) -> [a] -> a -> Bool;
list_member equal (x : xs) y = equal x y || list_member equal xs y;
list_member equal [] y = False;

memberc :: forall a. (Ceq a) => Set_dlist a -> a -> Bool;
memberc xa = list_member (the ceq) (list_of_dlista xa);

memberb :: forall a. (Ccompare a) => Mapping_rbt a () -> a -> Bool;
memberb t x = lookupd t x == Just ();

member :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Bool;
member x (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "member Set_Monad: ceq = None" (\ _ -> member x (Set_Monad xs));
    Just eq -> list_member eq xs x;
  });
member xa (Complement x) = not (member xa x);
member x (RBT_set rbt) = memberb rbt x;
member x (DList_set dxs) = memberc dxs x;
member x (Collect_set a) = a x;

subset_eq :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
subset_eq (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset RBT_set RBT_set: ccompare = None"
        (\ _ -> subset_eq (RBT_set rbt1) (RBT_set rbt2));
    Just c ->
      (case ceq of {
        Nothing ->
          sorted_list_subset_fusion (lt_of_comp c)
            (\ x y -> equal_order (c x y) Eqa) rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
        Just eq ->
          sorted_list_subset_fusion (lt_of_comp c) eq rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
      });
  });
subset_eq (Complement a1) (Complement a2) = subset_eq a2 a1;
subset_eq (Collect_set p) (Complement a) =
  subset_eq a (collect (\ x -> not (p x)));
subset_eq (Set_Monad xs) c = all (\ x -> member x c) xs;
subset_eq (DList_set dxs) c =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset DList_set1: ceq = None" (\ _ -> subset_eq (DList_set dxs) c);
    Just _ -> dlist_all (\ x -> member x c) dxs;
  });
subset_eq (RBT_set rbt) b =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset RBT_set1: ccompare = None" (\ _ -> subset_eq (RBT_set rbt) b);
    Just _ -> list_all_fusion rbt_keys_generator (\ x -> member x b) (init rbt);
  });

less_eq_set :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
less_eq_set = subset_eq;

equal_set ::
  forall a. (Cenum a, Ceq a, Ccompare a, Eq a) => Set a -> Set a -> Bool;
equal_set a b = less_eq_set a b && less_eq_set b a;

instance (Cenum a, Ceq a, Ccompare a, Eq a) => Eq (Set a) where {
  a == b = equal_set a b;
};

uminus_set :: forall a. Set a -> Set a;
uminus_set (Complement b) = b;
uminus_set (Collect_set p) = Collect_set (\ x -> not (p x));
uminus_set a = Complement a;

comp_sunion_with ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
comp_sunion_with c f ((ka, va) : asa) ((k, v) : bs) =
  (case c k ka of {
    Eqa -> (ka, f ka va v) : comp_sunion_with c f asa bs;
    Lt -> (k, v) : comp_sunion_with c f ((ka, va) : asa) bs;
    Gt -> (ka, va) : comp_sunion_with c f asa ((k, v) : bs);
  });
comp_sunion_with c f [] bs = bs;
comp_sunion_with c f asa [] = asa;

data Comparea = LT | GT | EQ;

skip_red :: forall a b. Rbta a b -> Rbta a b;
skip_red (Branch R l k v r) = l;
skip_red Emptya = Emptya;
skip_red (Branch B va vb vc vd) = Branch B va vb vc vd;

skip_black :: forall a b. Rbta a b -> Rbta a b;
skip_black t = let {
                 ta = skip_red t;
               } in (case ta of {
                      Emptya -> ta;
                      Branch R _ _ _ _ -> ta;
                      Branch B l _ _ _ -> l;
                    });

compare_height ::
  forall a b. Rbta a b -> Rbta a b -> Rbta a b -> Rbta a b -> Comparea;
compare_height sx s t tx =
  (case (skip_red sx, (skip_red s, (skip_red t, skip_red tx))) of {
    (Emptya, (Emptya, (_, Emptya))) -> EQ;
    (Emptya, (Emptya, (_, Branch _ _ _ _ _))) -> LT;
    (Emptya, (Branch _ _ _ _ _, (Emptya, _))) -> EQ;
    (Emptya, (Branch _ _ _ _ _, (Branch _ _ _ _ _, Emptya))) -> EQ;
    (Emptya, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Branch _ txa _ _ _))) ->
      compare_height Emptya sa ta (skip_black txa);
    (Branch _ _ _ _ _, (Emptya, (Emptya, Emptya))) -> GT;
    (Branch _ _ _ _ _, (Emptya, (Emptya, Branch _ _ _ _ _))) -> LT;
    (Branch _ _ _ _ _, (Emptya, (Branch _ _ _ _ _, Emptya))) -> EQ;
    (Branch _ _ _ _ _, (Emptya, (Branch _ _ _ _ _, Branch _ _ _ _ _))) -> LT;
    (Branch _ _ _ _ _, (Branch _ _ _ _ _, (Emptya, _))) -> GT;
    (Branch _ sxa _ _ _, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Emptya))) ->
      compare_height (skip_black sxa) sa ta Emptya;
    (Branch _ sxa _ _ _,
      (Branch _ sa _ _ _, (Branch _ ta _ _ _, Branch _ txa _ _ _)))
      -> compare_height (skip_black sxa) sa ta (skip_black txa);
  });

apfst :: forall a b c. (a -> b) -> (a, c) -> (b, c);
apfst f (x, y) = (f x, y);

rbtreeify_g :: forall a b. Nat -> [(a, b)] -> (Rbta a b, [(a, b)]);
rbtreeify_g n kvs =
  (if equal_nat n zero_nat || equal_nat n one_nat then (Emptya, kvs)
    else let {
           (na, r) = divmod_nat n (nat_of_integer (2 :: Integer));
         } in (if equal_nat r zero_nat
                then let {
                       (t1, (k, v) : kvsa) = rbtreeify_g na kvs;
                     } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)
                else let {
                       (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                     } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)));

rbtreeify_f :: forall a b. Nat -> [(a, b)] -> (Rbta a b, [(a, b)]);
rbtreeify_f n kvs =
  (if equal_nat n zero_nat then (Emptya, kvs)
    else (if equal_nat n one_nat then let {
((k, v) : kvsa) = kvs;
                                      } in (Branch R Emptya k v Emptya, kvsa)
           else let {
                  (na, r) = divmod_nat n (nat_of_integer (2 :: Integer));
                } in (if equal_nat r zero_nat
                       then let {
                              (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                            } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)
                       else let {
                              (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                            } in apfst (Branch B t1 k v)
                                   (rbtreeify_f na kvsa))));

rbtreeify :: forall a b. [(a, b)] -> Rbta a b;
rbtreeify kvs = fst (rbtreeify_g (suc (size_list kvs)) kvs);

gen_entries :: forall a b. [((a, b), Rbta a b)] -> Rbta a b -> [(a, b)];
gen_entries kvts (Branch c l k v r) = gen_entries (((k, v), r) : kvts) l;
gen_entries ((kv, t) : kvts) Emptya = kv : gen_entries kvts t;
gen_entries [] Emptya = [];

entries :: forall a b. Rbta a b -> [(a, b)];
entries = gen_entries [];

folda :: forall a b c. (a -> b -> c -> c) -> Rbta a b -> c -> c;
folda f (Branch c lt k v rt) x = folda f rt (f k v (folda f lt x));
folda f Emptya x = x;

rbt_comp_union_with_key ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_comp_union_with_key c f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> folda (rbt_comp_insert_with_key c (\ k v w -> f k w v)) t1 t2;
    GT -> folda (rbt_comp_insert_with_key c f) t2 t1;
    EQ -> rbtreeify (comp_sunion_with c f (entries t1) (entries t2));
  });

join ::
  forall a b.
    (Ccompare a) => (a -> b -> b -> b) ->
                      Mapping_rbt a b -> Mapping_rbt a b -> Mapping_rbt a b;
join xc xd xe =
  Mapping_RBTa
    (rbt_comp_union_with_key (the ccompare) xc (impl_ofb xd) (impl_ofb xe));

list_insert :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
list_insert equal x xs = (if list_member equal xs x then xs else x : xs);

insertd :: forall a. (Ceq a) => a -> Set_dlist a -> Set_dlist a;
insertd xb xc = Abs_dlist (list_insert (the ceq) xb (list_of_dlista xc));

foldc :: forall a b. (Ceq a) => (a -> b -> b) -> Set_dlist a -> b -> b;
foldc x xc = fold x (list_of_dlista xc);

uniona :: forall a. (Ceq a) => Set_dlist a -> Set_dlist a -> Set_dlist a;
uniona = foldc insertd;

inter_list ::
  forall a. (Ccompare a) => Mapping_rbt a () -> [a] -> Mapping_rbt a ();
inter_list xb xc =
  Mapping_RBTa
    (fold (\ k -> rbt_comp_insert (the ccompare) k ())
      (filter
        (\ x -> not (is_none (rbt_comp_lookup (the ccompare) (impl_ofb xb) x)))
        xc)
      Emptya);

filterc ::
  forall a b.
    (Ccompare a) => ((a, b) -> Bool) -> Mapping_rbt a b -> Mapping_rbt a b;
filterc xb xc = Mapping_RBTa (rbtreeify (filter xb (entries (impl_ofb xc))));

comp_sinter_with ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
comp_sinter_with c f ((ka, va) : asa) ((k, v) : bs) =
  (case c k ka of {
    Eqa -> (ka, f ka va v) : comp_sinter_with c f asa bs;
    Lt -> comp_sinter_with c f ((ka, va) : asa) bs;
    Gt -> comp_sinter_with c f asa ((k, v) : bs);
  });
comp_sinter_with c f [] uu = [];
comp_sinter_with c f uv [] = [];

map_filter :: forall a b. (a -> Maybe b) -> [a] -> [b];
map_filter f [] = [];
map_filter f (x : xs) = (case f x of {
                          Nothing -> map_filter f xs;
                          Just y -> y : map_filter f xs;
                        });

rbt_comp_inter_with_key ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_comp_inter_with_key c f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> rbtreeify
            (map_filter
              (\ (k, v) ->
                map_option (\ w -> (k, f k v w)) (rbt_comp_lookup c t2 k))
              (entries t1));
    GT -> rbtreeify
            (map_filter
              (\ (k, v) ->
                map_option (\ w -> (k, f k w v)) (rbt_comp_lookup c t1 k))
              (entries t2));
    EQ -> rbtreeify (comp_sinter_with c f (entries t1) (entries t2));
  });

meet ::
  forall a b.
    (Ccompare a) => (a -> b -> b -> b) ->
                      Mapping_rbt a b -> Mapping_rbt a b -> Mapping_rbt a b;
meet xc xd xe =
  Mapping_RBTa
    (rbt_comp_inter_with_key (the ccompare) xc (impl_ofb xd) (impl_ofb xe));

filterb :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Set_dlist a;
filterb xb xc = Abs_dlist (filter xb (list_of_dlista xc));

inf_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
inf_set (RBT_set rbt1) (Set_Monad xs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set Set_Monad: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (Set_Monad xs));
    Just _ -> RBT_set (inter_list rbt1 xs);
  });
inf_set (RBT_set rbt) (DList_set dxs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set DList_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "inter RBT_set DList_set: ceq = None"
            (\ _ -> inf_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (inter_list rbt (list_of_dlista dxs));
      });
  });
inf_set (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set RBT_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (RBT_set rbt2));
    Just _ -> RBT_set (meet (\ _ _ -> id) rbt1 rbt2);
  });
inf_set (DList_set dxs1) (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set Set_Monad: ceq = None"
        (\ _ -> inf_set (DList_set dxs1) (Set_Monad xs));
    Just eq -> DList_set (filterb (list_member eq xs) dxs1);
  });
inf_set (DList_set dxs1) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set DList_set: ceq = None"
        (\ _ -> inf_set (DList_set dxs1) (DList_set dxs2));
    Just _ -> DList_set (filterb (memberc dxs2) dxs1);
  });
inf_set (DList_set dxs) (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set RBT_set: ccompare = None"
        (\ _ -> inf_set (DList_set dxs) (RBT_set rbt));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "inter DList_set RBT_set: ceq = None"
            (\ _ -> inf_set (DList_set dxs) (RBT_set rbt));
        Just _ -> RBT_set (inter_list rbt (list_of_dlista dxs));
      });
  });
inf_set (Set_Monad xs1) (Set_Monad xs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad Set_Monad: ceq = None"
        (\ _ -> inf_set (Set_Monad xs1) (Set_Monad xs2));
    Just eq -> Set_Monad (filter (list_member eq xs2) xs1);
  });
inf_set (Set_Monad xs) (DList_set dxs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad DList_set: ceq = None"
        (\ _ -> inf_set (Set_Monad xs) (DList_set dxs2));
    Just eq -> DList_set (filterb (list_member eq xs) dxs2);
  });
inf_set (Set_Monad xs) (RBT_set rbt1) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad RBT_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (Set_Monad xs));
    Just _ -> RBT_set (inter_list rbt1 xs);
  });
inf_set (Complement ba) (Complement b) = Complement (sup_set ba b);
inf_set g (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set2: ccompare = None" (\ _ -> inf_set g (RBT_set rbt2));
    Just _ -> RBT_set (filterc ((\ x -> member x g) . fst) rbt2);
  });
inf_set (RBT_set rbt1) g =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set1: ccompare = None" (\ _ -> inf_set (RBT_set rbt1) g);
    Just _ -> RBT_set (filterc ((\ x -> member x g) . fst) rbt1);
  });
inf_set h (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set2: ceq = None" (\ _ -> inf_set h (DList_set dxs2));
    Just _ -> DList_set (filterb (\ x -> member x h) dxs2);
  });
inf_set (DList_set dxs1) h =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set1: ceq = None" (\ _ -> inf_set (DList_set dxs1) h);
    Just _ -> DList_set (filterb (\ x -> member x h) dxs1);
  });
inf_set i (Set_Monad xs) = Set_Monad (filter (\ x -> member x i) xs);
inf_set (Set_Monad xs) i = Set_Monad (filter (\ x -> member x i) xs);
inf_set j (Collect_set a) = Collect_set (\ x -> a x && member x j);
inf_set (Collect_set a) j = Collect_set (\ x -> a x && member x j);

sup_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
sup_set ba (Complement b) = Complement (inf_set (uminus_set ba) b);
sup_set (Complement ba) b = Complement (inf_set ba (uminus_set b));
sup_set b (Collect_set a) = Collect_set (\ x -> a x || member x b);
sup_set (Collect_set a) b = Collect_set (\ x -> a x || member x b);
sup_set (Set_Monad xs) (Set_Monad ys) = Set_Monad (xs ++ ys);
sup_set (DList_set dxs1) (Set_Monad ws) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set Set_Monad: ceq = None"
        (\ _ -> sup_set (DList_set dxs1) (Set_Monad ws));
    Just _ -> DList_set (fold insertd ws dxs1);
  });
sup_set (Set_Monad ws) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union Set_Monad DList_set: ceq = None"
        (\ _ -> sup_set (Set_Monad ws) (DList_set dxs2));
    Just _ -> DList_set (fold insertd ws dxs2);
  });
sup_set (RBT_set rbt1) (Set_Monad zs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set Set_Monad: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt1) (Set_Monad zs));
    Just _ -> RBT_set (fold (\ k -> insertf k ()) zs rbt1);
  });
sup_set (Set_Monad zs) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union Set_Monad RBT_set: ccompare = None"
        (\ _ -> sup_set (Set_Monad zs) (RBT_set rbt2));
    Just _ -> RBT_set (fold (\ k -> insertf k ()) zs rbt2);
  });
sup_set (DList_set dxs1) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set DList_set: ceq = None"
        (\ _ -> sup_set (DList_set dxs1) (DList_set dxs2));
    Just _ -> DList_set (uniona dxs1 dxs2);
  });
sup_set (DList_set dxs) (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set RBT_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "union DList_set RBT_set: ceq = None"
            (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (foldc (\ k -> insertf k ()) dxs rbt);
      });
  });
sup_set (RBT_set rbt) (DList_set dxs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set DList_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "union RBT_set DList_set: ceq = None"
            (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (foldc (\ k -> insertf k ()) dxs rbt);
      });
  });
sup_set (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set RBT_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt1) (RBT_set rbt2));
    Just _ -> RBT_set (join (\ _ _ -> id) rbt1 rbt2);
  });

instance (Ceq a, Ccompare a) => Inf (Set a) where {
  inf = inf_set;
};

instance (Ceq a, Ccompare a) => Sup (Set a) where {
  sup = sup_set;
};

less_set :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
less_set a b = less_eq_set a b && not (less_eq_set b a);

instance (Cenum a, Ceq a, Ccompare a) => Ord (Set a) where {
  less_eq = less_eq_set;
  less = less_set;
};

instance (Cenum a, Ceq a, Ccompare a) => Preorder (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Order (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Semilattice_sup (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Semilattice_inf (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Lattice (Set a) where {
};

list_all2_fusion ::
  forall a b c d.
    (a -> b -> Bool) -> Generator a c -> Generator b d -> c -> d -> Bool;
list_all2_fusion p g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 && let {
                             (x, s1a) = next g1 s1;
                             (y, s2a) = next g2 s2;
                           } in p x y && list_all2_fusion p g1 g2 s1a s2a
    else not (has_next g2 s2));

set_eq :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
set_eq (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_eq RBT_set RBT_set: ccompare = None"
        (\ _ -> set_eq (RBT_set rbt1) (RBT_set rbt2));
    Just c ->
      (case ceq of {
        Nothing ->
          list_all2_fusion (\ x y -> equal_order (c x y) Eqa) rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
        Just eq ->
          list_all2_fusion eq rbt_keys_generator rbt_keys_generator (init rbt1)
            (init rbt2);
      });
  });
set_eq (Complement a) (Complement b) = set_eq a b;
set_eq a b = less_eq_set a b && less_eq_set b a;

ceq_set ::
  forall a. (Cenum a, Ceq a, Ccompare a) => Maybe (Set a -> Set a -> Bool);
ceq_set = (case (ceq :: Maybe (a -> a -> Bool)) of {
            Nothing -> Nothing;
            Just _ -> Just set_eq;
          });

instance (Cenum a, Ceq a, Ccompare a) => Ceq (Set a) where {
  ceq = ceq_set;
};

set_impl_set :: forall a. Phantom (Set a) Set_impla;
set_impl_set = Phantom Set_Choose;

instance Set_impl (Set a) where {
  set_impl = set_impl_set;
};

emptyd :: forall a. (Ceq a) => Set_dlist a;
emptyd = Abs_dlist [];

set_empty_choose :: forall a. (Ceq a, Ccompare a) => Set a;
set_empty_choose = (case (ccompare :: Maybe (a -> a -> Ordera)) of {
                     Nothing -> (case (ceq :: Maybe (a -> a -> Bool)) of {
                                  Nothing -> Set_Monad [];
                                  Just _ -> DList_set emptyd;
                                });
                     Just _ -> RBT_set emptyf;
                   });

set_empty :: forall a. (Ceq a, Ccompare a) => Set_impla -> Set a;
set_empty Set_Choose = set_empty_choose;
set_empty Set_Monada = Set_Monad [];
set_empty Set_RBT = RBT_set emptyf;
set_empty Set_DList = DList_set emptyd;
set_empty Set_Collect = Collect_set (\ _ -> False);

fun_upda :: forall a b. (a -> a -> Bool) -> (a -> b) -> a -> b -> a -> b;
fun_upda equal f aa b a = (if equal aa a then b else f a);

balance_right :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance_right a k x (Branch R b s y c) = Branch R a k x (Branch B b s y c);
balance_right (Branch B a k x b) s y Emptya =
  balance (Branch R a k x b) s y Emptya;
balance_right (Branch B a k x b) s y (Branch B va vb vc vd) =
  balance (Branch R a k x b) s y (Branch B va vb vc vd);
balance_right (Branch R a k x (Branch B b s y c)) t z Emptya =
  Branch R (balance (paint R a) k x b) s y (Branch B c t z Emptya);
balance_right (Branch R a k x (Branch B b s y c)) t z (Branch B va vb vc vd) =
  Branch R (balance (paint R a) k x b) s y
    (Branch B c t z (Branch B va vb vc vd));
balance_right Emptya k x Emptya = Emptya;
balance_right (Branch R va vb vc Emptya) k x Emptya = Emptya;
balance_right (Branch R va vb vc (Branch R ve vf vg vh)) k x Emptya = Emptya;
balance_right Emptya k x (Branch B va vb vc vd) = Emptya;
balance_right (Branch R ve vf vg Emptya) k x (Branch B va vb vc vd) = Emptya;
balance_right (Branch R ve vf vg (Branch R vi vj vk vl)) k x
  (Branch B va vb vc vd) = Emptya;

balance_left :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance_left (Branch R a k x b) s y c = Branch R (Branch B a k x b) s y c;
balance_left Emptya k x (Branch B a s y b) =
  balance Emptya k x (Branch R a s y b);
balance_left (Branch B va vb vc vd) k x (Branch B a s y b) =
  balance (Branch B va vb vc vd) k x (Branch R a s y b);
balance_left Emptya k x (Branch R (Branch B a s y b) t z c) =
  Branch R (Branch B Emptya k x a) s y (balance b t z (paint R c));
balance_left (Branch B va vb vc vd) k x (Branch R (Branch B a s y b) t z c) =
  Branch R (Branch B (Branch B va vb vc vd) k x a) s y
    (balance b t z (paint R c));
balance_left Emptya k x Emptya = Emptya;
balance_left Emptya k x (Branch R Emptya vb vc vd) = Emptya;
balance_left Emptya k x (Branch R (Branch R ve vf vg vh) vb vc vd) = Emptya;
balance_left (Branch B va vb vc vd) k x Emptya = Emptya;
balance_left (Branch B va vb vc vd) k x (Branch R Emptya vf vg vh) = Emptya;
balance_left (Branch B va vb vc vd) k x
  (Branch R (Branch R vi vj vk vl) vf vg vh) = Emptya;

combine :: forall a b. Rbta a b -> Rbta a b -> Rbta a b;
combine Emptya x = x;
combine (Branch v va vb vc vd) Emptya = Branch v va vb vc vd;
combine (Branch R a k x b) (Branch R c s y d) =
  (case combine b c of {
    Emptya -> Branch R a k x (Branch R Emptya s y d);
    Branch R b2 t z c2 -> Branch R (Branch R a k x b2) t z (Branch R c2 s y d);
    Branch B b2 t z c2 -> Branch R a k x (Branch R (Branch B b2 t z c2) s y d);
  });
combine (Branch B a k x b) (Branch B c s y d) =
  (case combine b c of {
    Emptya -> balance_left a k x (Branch B Emptya s y d);
    Branch R b2 t z c2 -> Branch R (Branch B a k x b2) t z (Branch B c2 s y d);
    Branch B b2 t z c2 ->
      balance_left a k x (Branch B (Branch B b2 t z c2) s y d);
  });
combine (Branch B va vb vc vd) (Branch R b k x c) =
  Branch R (combine (Branch B va vb vc vd) b) k x c;
combine (Branch R a k x b) (Branch B va vb vc vd) =
  Branch R a k x (combine b (Branch B va vb vc vd));

rbt_comp_del :: forall a b. (a -> a -> Ordera) -> a -> Rbta a b -> Rbta a b;
rbt_comp_del c x Emptya = Emptya;
rbt_comp_del c x (Branch uu a y s b) =
  (case c x y of {
    Eqa -> combine a b;
    Lt -> rbt_comp_del_from_left c x a y s b;
    Gt -> rbt_comp_del_from_right c x a y s b;
  });

rbt_comp_del_from_left ::
  forall a b.
    (a -> a -> Ordera) -> a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_del_from_left c x (Branch B lt z v rt) y s b =
  balance_left (rbt_comp_del c x (Branch B lt z v rt)) y s b;
rbt_comp_del_from_left c x Emptya y s b =
  Branch R (rbt_comp_del c x Emptya) y s b;
rbt_comp_del_from_left c x (Branch R va vb vc vd) y s b =
  Branch R (rbt_comp_del c x (Branch R va vb vc vd)) y s b;

rbt_comp_del_from_right ::
  forall a b.
    (a -> a -> Ordera) -> a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_del_from_right c x a y s (Branch B lt z v rt) =
  balance_right a y s (rbt_comp_del c x (Branch B lt z v rt));
rbt_comp_del_from_right c x a y s Emptya =
  Branch R a y s (rbt_comp_del c x Emptya);
rbt_comp_del_from_right c x a y s (Branch R va vb vc vd) =
  Branch R a y s (rbt_comp_del c x (Branch R va vb vc vd));

rbt_comp_delete :: forall a b. (a -> a -> Ordera) -> a -> Rbta a b -> Rbta a b;
rbt_comp_delete c k t = paint B (rbt_comp_del c k t);

deletea :: forall a b. (Ccompare a) => a -> Mapping_rbt a b -> Mapping_rbt a b;
deletea xb xc = Mapping_RBTa (rbt_comp_delete (the ccompare) xb (impl_ofb xc));

list_remove1 :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
list_remove1 equal x (y : xs) =
  (if equal x y then xs else y : list_remove1 equal x xs);
list_remove1 equal x [] = [];

removea :: forall a. (Ceq a) => a -> Set_dlist a -> Set_dlist a;
removea xb xc = Abs_dlist (list_remove1 (the ceq) xb (list_of_dlista xc));

inserta :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Set a;
inserta xa (Complement x) = Complement (remove xa x);
inserta x (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert RBT_set: ccompare = None" (\ _ -> inserta x (RBT_set rbt));
    Just _ -> RBT_set (insertf x () rbt);
  });
inserta x (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert DList_set: ceq = None" (\ _ -> inserta x (DList_set dxs));
    Just _ -> DList_set (insertd x dxs);
  });
inserta x (Set_Monad xs) = Set_Monad (x : xs);
inserta x (Collect_set a) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert Collect_set: ceq = None" (\ _ -> inserta x (Collect_set a));
    Just eq -> Collect_set (fun_upda eq a x True);
  });

remove :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Set a;
remove x (Complement a) = Complement (inserta x a);
remove x (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "remove RBT_set: ccompare = None" (\ _ -> remove x (RBT_set rbt));
    Just _ -> RBT_set (deletea x rbt);
  });
remove x (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "remove DList_set: ceq = None" (\ _ -> remove x (DList_set dxs));
    Just _ -> DList_set (removea x dxs);
  });
remove x (Collect_set a) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "remove Collect: ceq = None"
        (\ _ -> remove x (Collect_set a));
    Just eq -> Collect_set (fun_upda eq a x False);
  });

foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a;
foldl f a [] = a;
foldl f a (x : xs) = foldl f (f a x) xs;

set_aux :: forall a. (Ceq a, Ccompare a) => Set_impla -> [a] -> Set a;
set_aux Set_Monada = Set_Monad;
set_aux Set_Choose =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing -> (case (ceq :: Maybe (a -> a -> Bool)) of {
                 Nothing -> Set_Monad;
                 Just _ -> foldl (\ s x -> inserta x s) (DList_set emptyd);
               });
    Just _ -> foldl (\ s x -> inserta x s) (RBT_set emptyf);
  });
set_aux impl = foldl (\ s x -> inserta x s) (set_empty impl);

set :: forall a. (Ceq a, Ccompare a, Set_impl a) => [a] -> Set a;
set xs = set_aux (of_phantom (set_impl :: Phantom a Set_impla)) xs;

cEnum_set ::
  forall a.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Maybe ([Set a],
                             ((Set a -> Bool) -> Bool,
                               (Set a -> Bool) -> Bool));
cEnum_set =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (_, _)) ->
      Just (map set (sublists enum_a),
             ((\ p -> all p (map set (sublists enum_a))),
               (\ p -> any p (map set (sublists enum_a)))));
  });

instance (Cenum a, Ceq a, Ccompare a, Set_impl a) => Cenum (Set a) where {
  cEnum = cEnum_set;
};

bot_set :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set a;
bot_set = set_empty (of_phantom (set_impl :: Phantom a Set_impla));

newtype Comp_fun_idem b a = Abs_comp_fun_idem (b -> a -> a);

comp_fun_idem_apply :: forall b a. Comp_fun_idem b a -> b -> a -> a;
comp_fun_idem_apply (Abs_comp_fun_idem x) = x;

foldb ::
  forall a b. (Ccompare a) => (a -> b -> b) -> Mapping_rbt a () -> b -> b;
foldb x xc = folda (\ a _ -> x a) (impl_ofb xc);

set_fold_cfi ::
  forall a b. (Ceq a, Ccompare a) => Comp_fun_idem a b -> b -> Set a -> b;
set_fold_cfi f b (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold_cfi RBT_set: ccompare = None"
        (\ _ -> set_fold_cfi f b (RBT_set rbt));
    Just _ -> foldb (comp_fun_idem_apply f) rbt b;
  });
set_fold_cfi f b (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold_cfi DList_set: ceq = None"
        (\ _ -> set_fold_cfi f b (DList_set dxs));
    Just _ -> foldc (comp_fun_idem_apply f) dxs b;
  });
set_fold_cfi f b (Set_Monad xs) = fold (comp_fun_idem_apply f) xs b;
set_fold_cfi f b (Collect_set p) =
  (error :: forall a. String -> (() -> a) -> a)
    "set_fold_cfi not supported on Collect_set"
    (\ _ -> set_fold_cfi f b (Collect_set p));
set_fold_cfi f b (Complement a) =
  (error :: forall a. String -> (() -> a) -> a)
    "set_fold_cfi not supported on Complement"
    (\ _ -> set_fold_cfi f b (Complement a));

finite :: forall a. (Finite_UNIV a, Ceq a, Ccompare a) => Set a -> Bool;
finite (Collect_set p) =
  of_phantom (finite_UNIV :: Phantom a Bool) ||
    (error :: forall a. String -> (() -> a) -> a) "finite Collect_set"
      (\ _ -> finite (Collect_set p));
finite (Set_Monad xs) = True;
finite (Complement a) =
  (if of_phantom (finite_UNIV :: Phantom a Bool) then True
    else (if finite a then False
           else (error :: forall a. String -> (() -> a) -> a)
                  "finite Complement: infinite set"
                  (\ _ -> finite (Complement a))));
finite (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "finite RBT_set: ccompare = None" (\ _ -> finite (RBT_set rbt));
    Just _ -> True;
  });
finite (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "finite DList_set: ceq = None" (\ _ -> finite (DList_set dxs));
    Just _ -> True;
  });

sup_cfi :: forall a. (Lattice a) => Comp_fun_idem a a;
sup_cfi = Abs_comp_fun_idem sup;

set_less_eq_aux_Compl_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
set_less_eq_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then let {
                  (x, s1a) = next g1 s1;
                  (y, s2a) = next g2 s2;
                } in (if less x y
                       then proper_interval ao (Just x) ||
                              set_less_eq_aux_Compl_fusion less proper_interval
                                g1 g2 (Just x) s1a s2
                       else (if less y x
                              then proper_interval ao (Just y) ||
                                     set_less_eq_aux_Compl_fusion less
                                       proper_interval g1 g2 (Just y) s1 s2a
                              else proper_interval ao (Just y)))
           else True)
    else True);

compl_set_less_eq_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
compl_set_less_eq_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then not (proper_interval ao (Just x)) &&
                                   compl_set_less_eq_aux_fusion less
                                     proper_interval g1 g2 (Just x) s1a s2
                            else (if less y x
                                   then not (proper_interval ao (Just y)) &&
  compl_set_less_eq_aux_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                   else not (proper_interval ao (Just y))))
                else not (proper_interval ao (Just x)) &&
                       compl_set_less_eq_aux_fusion less proper_interval g1 g2
                         (Just x) s1a s2)
    else (if has_next g2 s2
           then let {
                  (y, s2a) = next g2 s2;
                } in not (proper_interval ao (Just y)) &&
                       compl_set_less_eq_aux_fusion less proper_interval g1 g2
                         (Just y) s1 s2a
           else not (proper_interval ao Nothing)));

set_less_eq_aux_Compl ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
set_less_eq_aux_Compl less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           set_less_eq_aux_Compl less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  set_less_eq_aux_Compl less proper_interval (Just y) (x : xs)
                    ys
           else proper_interval ao (Just y)));
set_less_eq_aux_Compl less proper_interval ao xs [] = True;
set_less_eq_aux_Compl less proper_interval ao [] ys = True;

compl_set_less_eq_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
compl_set_less_eq_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           compl_set_less_eq_aux less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  compl_set_less_eq_aux less proper_interval (Just y) (x : xs)
                    ys
           else not (proper_interval ao (Just y))));
compl_set_less_eq_aux less proper_interval ao (x : xs) [] =
  not (proper_interval ao (Just x)) &&
    compl_set_less_eq_aux less proper_interval (Just x) xs [];
compl_set_less_eq_aux less proper_interval ao [] (y : ys) =
  not (proper_interval ao (Just y)) &&
    compl_set_less_eq_aux less proper_interval (Just y) [] ys;
compl_set_less_eq_aux less proper_interval ao [] [] =
  not (proper_interval ao Nothing);

lexord_eq_fusion ::
  forall a b c.
    (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
lexord_eq_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 &&
           let {
             (x, s1a) = next g1 s1;
             (y, s2a) = next g2 s2;
           } in less x y ||
                  not (less y x) && lexord_eq_fusion less g1 g2 s1a s2a
    else True);

remdups_sorted :: forall a. (a -> a -> Bool) -> [a] -> [a];
remdups_sorted less (x : y : xs) =
  (if less x y then x : remdups_sorted less (y : xs)
    else remdups_sorted less (y : xs));
remdups_sorted less [x] = [x];
remdups_sorted less [] = [];

quicksort_acc :: forall a. (a -> a -> Bool) -> [a] -> [a] -> [a];
quicksort_acc less ac (x : v : va) = quicksort_part less ac x [] [] [] (v : va);
quicksort_acc less ac [x] = x : ac;
quicksort_acc less ac [] = ac;

quicksort_part ::
  forall a. (a -> a -> Bool) -> [a] -> a -> [a] -> [a] -> [a] -> [a] -> [a];
quicksort_part less ac x lts eqs gts (z : zs) =
  (if less x z then quicksort_part less ac x lts eqs (z : gts) zs
    else (if less z x then quicksort_part less ac x (z : lts) eqs gts zs
           else quicksort_part less ac x lts (z : eqs) gts zs));
quicksort_part less ac x lts eqs gts [] =
  quicksort_acc less (eqs ++ x : quicksort_acc less ac gts) lts;

quicksort :: forall a. (a -> a -> Bool) -> [a] -> [a];
quicksort less = quicksort_acc less [];

gen_keys :: forall a b. [(a, Rbta a b)] -> Rbta a b -> [a];
gen_keys kts (Branch c l k v r) = gen_keys ((k, r) : kts) l;
gen_keys ((k, t) : kts) Emptya = k : gen_keys kts t;
gen_keys [] Emptya = [];

keys :: forall a b. Rbta a b -> [a];
keys = gen_keys [];

keysa :: forall a. (Ccompare a) => Mapping_rbt a () -> [a];
keysa xa = keys (impl_ofb xa);

csorted_list_of_set :: forall a. (Ceq a, Ccompare a) => Set a -> [a];
csorted_list_of_set (Set_Monad xs) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set Set_Monad: ccompare = None"
        (\ _ -> csorted_list_of_set (Set_Monad xs));
    Just c -> remdups_sorted (lt_of_comp c) (quicksort (lt_of_comp c) xs);
  });
csorted_list_of_set (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set DList_set: ceq = None"
        (\ _ -> csorted_list_of_set (DList_set dxs));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "csorted_list_of_set DList_set: ccompare = None"
            (\ _ -> csorted_list_of_set (DList_set dxs));
        Just c -> quicksort (lt_of_comp c) (list_of_dlista dxs);
      });
  });
csorted_list_of_set (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set RBT_set: ccompare = None"
        (\ _ -> csorted_list_of_set (RBT_set rbt));
    Just _ -> keysa rbt;
  });

top_set :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set a;
top_set = uminus_set bot_set;

le_of_comp :: forall a. (a -> a -> Ordera) -> a -> a -> Bool;
le_of_comp acomp x y = (case acomp x y of {
                         Eqa -> True;
                         Lt -> True;
                         Gt -> False;
                       });

lexordp_eq :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
lexordp_eq less (x : xs) (y : ys) =
  less x y || not (less y x) && lexordp_eq less xs ys;
lexordp_eq less (x : xs) [] = False;
lexordp_eq less xs [] = null xs;
lexordp_eq less [] ys = True;

set_less_aux_Compl_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
set_less_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then proper_interval ao (Just x) ||
                                   set_less_aux_Compl_fusion less
                                     proper_interval g1 g2 (Just x) s1a s2
                            else (if less y x
                                   then proper_interval ao (Just y) ||
  set_less_aux_Compl_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                   else proper_interval ao (Just y)))
                else proper_interval ao (Just x) ||
                       set_less_aux_Compl_fusion less proper_interval g1 g2
                         (Just x) s1a s2)
    else (if has_next g2 s2
           then let {
                  (y, s2a) = next g2 s2;
                } in proper_interval ao (Just y) ||
                       set_less_aux_Compl_fusion less proper_interval g1 g2
                         (Just y) s1 s2a
           else proper_interval ao Nothing));

compl_set_less_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
compl_set_less_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 &&
    has_next g2 s2 &&
      let {
        (x, s1a) = next g1 s1;
        (y, s2a) = next g2 s2;
      } in (if less x y
             then not (proper_interval ao (Just x)) &&
                    compl_set_less_aux_fusion less proper_interval g1 g2
                      (Just x) s1a s2
             else (if less y x
                    then not (proper_interval ao (Just y)) &&
                           compl_set_less_aux_fusion less proper_interval g1 g2
                             (Just y) s1 s2a
                    else not (proper_interval ao (Just y))));

set_less_aux_Compl ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
set_less_aux_Compl less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           set_less_aux_Compl less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  set_less_aux_Compl less proper_interval (Just y) (x : xs) ys
           else proper_interval ao (Just y)));
set_less_aux_Compl less proper_interval ao (x : xs) [] =
  proper_interval ao (Just x) ||
    set_less_aux_Compl less proper_interval (Just x) xs [];
set_less_aux_Compl less proper_interval ao [] (y : ys) =
  proper_interval ao (Just y) ||
    set_less_aux_Compl less proper_interval (Just y) [] ys;
set_less_aux_Compl less proper_interval ao [] [] = proper_interval ao Nothing;

compl_set_less_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
compl_set_less_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           compl_set_less_aux less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  compl_set_less_aux less proper_interval (Just y) (x : xs) ys
           else not (proper_interval ao (Just y))));
compl_set_less_aux less proper_interval ao xs [] = False;
compl_set_less_aux less proper_interval ao [] ys = False;

lexord_fusion ::
  forall a b c.
    (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
lexord_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then let {
                  (x, s1a) = next g1 s1;
                  (y, s2a) = next g2 s2;
                } in less x y ||
                       not (less y x) && lexord_fusion less g1 g2 s1a s2a
           else False)
    else has_next g2 s2);

lexordp :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
lexordp less (x : xs) (y : ys) =
  less x y || not (less y x) && lexordp less xs ys;
lexordp less xs [] = False;
lexordp less [] ys = not (null ys);

comp_of_ords ::
  forall a. (a -> a -> Bool) -> (a -> a -> Bool) -> a -> a -> Ordera;
comp_of_ords le lt x y = (if lt x y then Lt else (if le x y then Eqa else Gt));

ccompare_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Maybe (Set a -> Set a -> Ordera);
ccompare_set = (case (ccompare :: Maybe (a -> a -> Ordera)) of {
                 Nothing -> Nothing;
                 Just _ -> Just (comp_of_ords cless_eq_set cless_set);
               });

cless_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Set a -> Set a -> Bool;
cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ -> cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        compl_set_less_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set RBT_set (Complement RBT_set): ccompare = None"
        (\ _ -> cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)));
    Just c ->
      (if (finite :: Set a -> Bool) (top_set :: Set a)
        then set_less_aux_Compl_fusion (lt_of_comp c) cproper_interval
               rbt_keys_generator rbt_keys_generator Nothing (init rbt1)
               (init rbt2)
        else True);
  });
cless_set (RBT_set rbta) (RBT_set rbt) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set RBT_set RBT_set: ccompare = None"
        (\ _ -> cless_set (RBT_set rbta) (RBT_set rbt));
    Just c ->
      lexord_fusion (\ x y -> lt_of_comp c y x) rbt_keys_generator
        rbt_keys_generator (init rbta) (init rbt);
  });
cless_set (Complement a) (Complement b) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement Complement: ccompare = None"
        (\ _ -> cless_set (Complement a) (Complement b));
    Just _ -> lt_of_comp (the ccompare_set) b a;
  });
cless_set (Complement a) b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement1: ccompare = None"
        (\ _ -> cless_set (Complement a) b);
    Just c ->
      (if finite a && finite b
        then (finite :: Set a -> Bool) (top_set :: Set a) &&
               compl_set_less_aux (lt_of_comp c) cproper_interval Nothing
                 (csorted_list_of_set a) (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set Complement1: infinite set"
               (\ _ -> cless_set (Complement a) b));
  });
cless_set a (Complement b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement2: ccompare = None"
        (\ _ -> cless_set a (Complement b));
    Just c ->
      (if finite a && finite b
        then (if (finite :: Set a -> Bool) (top_set :: Set a)
               then set_less_aux_Compl (lt_of_comp c) cproper_interval Nothing
                      (csorted_list_of_set a) (csorted_list_of_set b)
               else True)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set Complement2: infinite set"
               (\ _ -> cless_set a (Complement b)));
  });
cless_set a b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "cless_set: ccompare = None"
        (\ _ -> cless_set a b);
    Just c ->
      (if finite a && finite b
        then lexordp (\ x y -> lt_of_comp c y x) (csorted_list_of_set a)
               (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set: infinite set" (\ _ -> cless_set a b));
  });

cless_eq_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Set a -> Set a -> Bool;
cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ -> cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        compl_set_less_eq_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set RBT_set (Complement RBT_set): ccompare = None"
        (\ _ -> cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)));
    Just c ->
      (if (finite :: Set a -> Bool) (top_set :: Set a)
        then set_less_eq_aux_Compl_fusion (lt_of_comp c) cproper_interval
               rbt_keys_generator rbt_keys_generator Nothing (init rbt1)
               (init rbt2)
        else True);
  });
cless_eq_set (RBT_set rbta) (RBT_set rbt) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set RBT_set RBT_set: ccompare = None"
        (\ _ -> cless_eq_set (RBT_set rbta) (RBT_set rbt));
    Just c ->
      lexord_eq_fusion (\ x y -> lt_of_comp c y x) rbt_keys_generator
        rbt_keys_generator (init rbta) (init rbt);
  });
cless_eq_set (Complement a) (Complement b) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement Complement: ccompare = None"
        (\ _ -> le_of_comp (the ccompare_set) (Complement a) (Complement b));
    Just _ -> cless_eq_set b a;
  });
cless_eq_set (Complement a) b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement1: ccompare = None"
        (\ _ -> cless_eq_set (Complement a) b);
    Just c ->
      (if finite a && finite b
        then (finite :: Set a -> Bool) (top_set :: Set a) &&
               compl_set_less_eq_aux (lt_of_comp c) cproper_interval Nothing
                 (csorted_list_of_set a) (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set Complement1: infinite set"
               (\ _ -> cless_eq_set (Complement a) b));
  });
cless_eq_set a (Complement b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement2: ccompare = None"
        (\ _ -> cless_eq_set a (Complement b));
    Just c ->
      (if finite a && finite b
        then (if (finite :: Set a -> Bool) (top_set :: Set a)
               then set_less_eq_aux_Compl (lt_of_comp c) cproper_interval
                      Nothing (csorted_list_of_set a) (csorted_list_of_set b)
               else True)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set Complement2: infinite set"
               (\ _ -> cless_eq_set a (Complement b)));
  });
cless_eq_set a b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set: ccompare = None" (\ _ -> cless_eq_set a b);
    Just c ->
      (if finite a && finite b
        then lexordp_eq (\ x y -> lt_of_comp c y x) (csorted_list_of_set a)
               (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set: infinite set" (\ _ -> cless_eq_set a b));
  });

instance (Finite_UNIV a, Ceq a, Cproper_interval a,
           Set_impl a) => Ccompare (Set a) where {
  ccompare = ccompare_set;
};

finite_UNIV_set :: forall a. (Finite_UNIV a) => Phantom (Set a) Bool;
finite_UNIV_set = Phantom (of_phantom (finite_UNIV :: Phantom a Bool));

instance (Finite_UNIV a) => Finite_UNIV (Set a) where {
  finite_UNIV = finite_UNIV_set;
};

sup_seta ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a,
      Set_impl a) => Set (Set a) -> Set a;
sup_seta a =
  (if finite a then set_fold_cfi sup_cfi bot_set a
    else (error :: forall a. String -> (() -> a) -> a) "Sup: infinite"
           (\ _ -> sup_seta a));

class Supa a where {
  supa :: Set a -> a;
};

instance (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a,
           Set_impl a) => Supa (Set a) where {
  supa = sup_seta;
};

fold_fusion :: forall a b c. Generator a b -> (a -> c -> c) -> b -> c -> c;
fold_fusion g f s b =
  (if has_next g s then let {
                          (x, sa) = next g s;
                        } in fold_fusion g f sa (f x b)
    else b);

length_last_fusion :: forall a b. Generator a b -> b -> (Nat, a);
length_last_fusion g s =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in fold_fusion g (\ xa (n, _) -> (plus_nat n one_nat, xa)) sa
                (one_nat, x)
    else (zero_nat, error "undefined"));

gen_length_fusion :: forall a b. Generator a b -> Nat -> b -> Nat;
gen_length_fusion g n s =
  (if has_next g s then gen_length_fusion g (suc n) (snd (next g s)) else n);

length_fusion :: forall a b. Generator a b -> b -> Nat;
length_fusion g = gen_length_fusion g zero_nat;

card_UNIV :: forall a. (Card_UNIV a) => Phantom a Nat;
card_UNIV = card_UNIVa;

proper_interval_set_Compl_aux_fusion ::
  forall a b c.
    (Card_UNIV a) => (a -> a -> Bool) ->
                       (Maybe a -> Maybe a -> Bool) ->
                         Generator a b ->
                           Generator a c -> Maybe a -> Nat -> b -> c -> Bool;
proper_interval_set_Compl_aux_fusion less proper_interval g1 g2 ao n s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then proper_interval ao (Just x) ||
                                   proper_interval_set_Compl_aux_fusion less
                                     proper_interval g1 g2 (Just x)
                                     (plus_nat n one_nat) s1a s2
                            else (if less y x
                                   then proper_interval ao (Just y) ||
  proper_interval_set_Compl_aux_fusion less proper_interval g1 g2 (Just y)
    (plus_nat n one_nat) s1 s2a
                                   else proper_interval ao (Just x) &&
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
  } in not (equal_nat (minus_nat m (length_fusion g2 s2a))
             (nat_of_integer (2 :: Integer))) ||
         not (equal_nat (minus_nat m (length_fusion g1 s1a))
               (nat_of_integer (2 :: Integer)))))
                else let {
                       m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat))
                             n;
                       (len_x, xa) = length_last_fusion g1 s1;
                     } in not (equal_nat m len_x) &&
                            (if equal_nat m (plus_nat len_x one_nat)
                              then not (proper_interval (Just xa) Nothing)
                              else True))
    else (if has_next g2 s2
           then let {
                  (_, _) = next g2 s2;
                  m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                  (len_y, y) = length_last_fusion g2 s2;
                } in not (equal_nat m len_y) &&
                       (if equal_nat m (plus_nat len_y one_nat)
                         then not (proper_interval (Just y) Nothing) else True)
           else less_nat (plus_nat n one_nat)
                  (of_phantom (card_UNIV :: Phantom a Nat))));

proper_interval_Compl_set_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
proper_interval_Compl_set_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 &&
    has_next g2 s2 &&
      let {
        (x, s1a) = next g1 s1;
        (y, s2a) = next g2 s2;
      } in (if less x y
             then not (proper_interval ao (Just x)) &&
                    proper_interval_Compl_set_aux_fusion less proper_interval g1
                      g2 (Just x) s1a s2
             else (if less y x
                    then not (proper_interval ao (Just y)) &&
                           proper_interval_Compl_set_aux_fusion less
                             proper_interval g1 g2 (Just y) s1 s2a
                    else not (proper_interval ao (Just x)) &&
                           (has_next g2 s2a || has_next g1 s1a)));

exhaustive_above_fusion ::
  forall a b. (Maybe a -> Maybe a -> Bool) -> Generator a b -> a -> b -> Bool;
exhaustive_above_fusion proper_interval g y s =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in not (proper_interval (Just y) (Just x)) &&
                exhaustive_above_fusion proper_interval g x sa
    else not (proper_interval (Just y) Nothing));

proper_interval_set_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> b -> c -> Bool;
proper_interval_set_aux_fusion less proper_interval g1 g2 s1 s2 =
  has_next g2 s2 &&
    let {
      (y, s2a) = next g2 s2;
    } in (if has_next g1 s1
           then let {
                  (x, s1a) = next g1 s1;
                } in (if less x y then False
                       else (if less y x
                              then proper_interval (Just y) (Just x) ||
                                     (has_next g2 s2a ||
                                       not
 (exhaustive_above_fusion proper_interval g1 x s1a))
                              else proper_interval_set_aux_fusion less
                                     proper_interval g1 g2 s1a s2a))
           else has_next g2 s2a || proper_interval (Just y) Nothing);

length_last :: forall a. [a] -> (Nat, a);
length_last (x : xs) =
  fold (\ xa (n, _) -> (plus_nat n one_nat, xa)) xs (one_nat, x);
length_last [] = (zero_nat, error "undefined");

proper_interval_set_Compl_aux ::
  forall a.
    (Card_UNIV a) => (a -> a -> Bool) ->
                       (Maybe a -> Maybe a -> Bool) ->
                         Maybe a -> Nat -> [a] -> [a] -> Bool;
proper_interval_set_Compl_aux less proper_interval ao n (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           proper_interval_set_Compl_aux less proper_interval (Just x)
             (plus_nat n one_nat) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  proper_interval_set_Compl_aux less proper_interval (Just y)
                    (plus_nat n one_nat) (x : xs) ys
           else proper_interval ao (Just x) &&
                  let {
                    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                  } in not (equal_nat (minus_nat m (size_list ys))
                             (nat_of_integer (2 :: Integer))) ||
                         not (equal_nat (minus_nat m (size_list xs))
                               (nat_of_integer (2 :: Integer)))));
proper_interval_set_Compl_aux less proper_interval ao n (x : xs) [] =
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
    (len_x, xa) = length_last (x : xs);
  } in not (equal_nat m len_x) &&
         (if equal_nat m (plus_nat len_x one_nat)
           then not (proper_interval (Just xa) Nothing) else True);
proper_interval_set_Compl_aux less proper_interval ao n [] (y : ys) =
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
    (len_y, ya) = length_last (y : ys);
  } in not (equal_nat m len_y) &&
         (if equal_nat m (plus_nat len_y one_nat)
           then not (proper_interval (Just ya) Nothing) else True);
proper_interval_set_Compl_aux less proper_interval ao n [] [] =
  less_nat (plus_nat n one_nat) (of_phantom (card_UNIV :: Phantom a Nat));

proper_interval_Compl_set_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
proper_interval_Compl_set_aux less proper_interval ao uu [] = False;
proper_interval_Compl_set_aux less proper_interval ao [] uv = False;
proper_interval_Compl_set_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           proper_interval_Compl_set_aux less proper_interval (Just x) xs
             (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  proper_interval_Compl_set_aux less proper_interval (Just y)
                    (x : xs) ys
           else not (proper_interval ao (Just x)) &&
                  (if null ys then not (null xs) else True)));

exhaustive_above :: forall a. (Maybe a -> Maybe a -> Bool) -> a -> [a] -> Bool;
exhaustive_above proper_interval x (y : ys) =
  not (proper_interval (Just x) (Just y)) &&
    exhaustive_above proper_interval y ys;
exhaustive_above proper_interval x [] = not (proper_interval (Just x) Nothing);

proper_interval_set_aux ::
  forall a.
    (a -> a -> Bool) -> (Maybe a -> Maybe a -> Bool) -> [a] -> [a] -> Bool;
proper_interval_set_aux less proper_interval (x : xs) (y : ys) =
  (if less x y then False
    else (if less y x
           then proper_interval (Just y) (Just x) ||
                  (not (null ys) || not (exhaustive_above proper_interval x xs))
           else proper_interval_set_aux less proper_interval xs ys));
proper_interval_set_aux less proper_interval [] (y : ys) =
  not (null ys) || proper_interval (Just y) Nothing;
proper_interval_set_aux less proper_interval xs [] = False;

exhaustive_fusion ::
  forall a b. (Maybe a -> Maybe a -> Bool) -> Generator a b -> b -> Bool;
exhaustive_fusion proper_interval g s =
  has_next g s &&
    let {
      (x, sa) = next g s;
    } in not (proper_interval Nothing (Just x)) &&
           exhaustive_above_fusion proper_interval g x sa;

list_remdups :: forall a. (a -> a -> Bool) -> [a] -> [a];
list_remdups equal (x : xs) =
  (if list_member equal xs x then list_remdups equal xs
    else x : list_remdups equal xs);
list_remdups equal [] = [];

lengtha :: forall a. (Ceq a) => Set_dlist a -> Nat;
lengtha xa = size_list (list_of_dlista xa);

card :: forall a. (Card_UNIV a, Ceq a, Ccompare a) => Set a -> Nat;
card (Complement a) =
  let {
    aa = card a;
    s = of_phantom (card_UNIV :: Phantom a Nat);
  } in (if less_nat zero_nat s then minus_nat s aa
         else (if finite a then zero_nat
                else (error :: forall a. String -> (() -> a) -> a)
                       "card Complement: infinite"
                       (\ _ -> card (Complement a))));
card (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "card Set_Monad: ceq = None"
        (\ _ -> card (Set_Monad xs));
    Just eq -> size_list (list_remdups eq xs);
  });
card (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "card RBT_set: ccompare = None" (\ _ -> card (RBT_set rbt));
    Just _ -> size_list (keysa rbt);
  });
card (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "card DList_set: ceq = None"
        (\ _ -> card (DList_set dxs));
    Just _ -> lengtha dxs;
  });

is_UNIV :: forall a. (Card_UNIV a, Ceq a, Cproper_interval a) => Set a -> Bool;
is_UNIV (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_UNIV RBT_set: ccompare = None" (\ _ -> is_UNIV (RBT_set rbt));
    Just _ ->
      of_phantom (finite_UNIV :: Phantom a Bool) &&
        exhaustive_fusion cproper_interval rbt_keys_generator (init rbt);
  });
is_UNIV a =
  let {
    aa = of_phantom (card_UNIV :: Phantom a Nat);
    b = card a;
  } in (if less_nat zero_nat aa then equal_nat aa b
         else (if less_nat zero_nat b then False
                else (error :: forall a. String -> (() -> a) -> a)
                       "is_UNIV called on infinite type and set"
                       (\ _ -> is_UNIV a)));

is_emptya :: forall a b. (Ccompare a) => Mapping_rbt a b -> Bool;
is_emptya xa = (case impl_ofb xa of {
                 Emptya -> True;
                 Branch _ _ _ _ _ -> False;
               });

nulla :: forall a. (Ceq a) => Set_dlist a -> Bool;
nulla xa = null (list_of_dlista xa);

is_empty :: forall a. (Card_UNIV a, Ceq a, Cproper_interval a) => Set a -> Bool;
is_empty (Complement a) = is_UNIV a;
is_empty (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_empty RBT_set: ccompare = None" (\ _ -> is_empty (RBT_set rbt));
    Just _ -> is_emptya rbt;
  });
is_empty (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_empty DList_set: ceq = None" (\ _ -> is_empty (DList_set dxs));
    Just _ -> nulla dxs;
  });
is_empty (Set_Monad xs) = null xs;

cproper_interval_set ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Maybe (Set a) -> Maybe (Set a) -> Bool;
cproper_interval_set (Just (Complement (RBT_set rbt1))) (Just (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (Complement (RBT_set rbt1)))
            (Just (RBT_set rbt2)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_Compl_set_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cproper_interval_set (Just (RBT_set rbt1)) (Just (Complement (RBT_set rbt2))) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval RBT_set (Complement RBT_set): ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (RBT_set rbt1))
            (Just (Complement (RBT_set rbt2))));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_Compl_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing zero_nat (init rbt1)
          (init rbt2);
  });
cproper_interval_set (Just (RBT_set rbt1)) (Just (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval RBT_set RBT_set: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (RBT_set rbt1)) (Just (RBT_set rbt2)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator (init rbt1) (init rbt2);
  });
cproper_interval_set (Just (Complement a)) (Just (Complement b)) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement Complement: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (Complement a)) (Just (Complement b)));
    Just _ -> cproper_interval_set (Just b) (Just a);
  });
cproper_interval_set (Just (Complement a)) (Just b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement1: ccompare = None"
        (\ _ -> cproper_interval_set (Just (Complement a)) (Just b));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_Compl_set_aux (lt_of_comp c) cproper_interval Nothing
          (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) (Just (Complement b)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement2: ccompare = None"
        (\ _ -> cproper_interval_set (Just a) (Just (Complement b)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_Compl_aux (lt_of_comp c) cproper_interval Nothing
          zero_nat (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) (Just b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval: ccompare = None"
        (\ _ -> cproper_interval_set (Just a) (Just b));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_aux (lt_of_comp c) cproper_interval
          (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) Nothing = not (is_UNIV a);
cproper_interval_set Nothing (Just b) = not (is_empty b);
cproper_interval_set Nothing Nothing = True;

instance (Card_UNIV a, Ceq a, Cproper_interval a,
           Set_impl a) => Cproper_interval (Set a) where {
  cproper_interval = cproper_interval_set;
};

shows_list_list ::
  forall a. (Showa a) => [[a]] -> [Prelude.Char] -> [Prelude.Char];
shows_list_list xss = showsp_list shows_prec_list zero_nat xss;

instance (Showa a) => Showa [a] where {
  shows_prec = shows_prec_list;
  shows_list = shows_list_list;
};

default_list :: forall a. [a];
default_list = [];

class Default a where {
  defaulta :: a;
};

instance Default [a] where {
  defaulta = default_list;
};

less_eq_list :: forall a. (Eq a, Order a) => [a] -> [a] -> Bool;
less_eq_list (x : xs) (y : ys) = less x y || x == y && less_eq_list xs ys;
less_eq_list [] xs = True;
less_eq_list (x : xs) [] = False;

less_list :: forall a. (Eq a, Order a) => [a] -> [a] -> Bool;
less_list (x : xs) (y : ys) = less x y || x == y && less_list xs ys;
less_list [] (x : xs) = True;
less_list xs [] = False;

instance (Eq a, Order a) => Ord [a] where {
  less_eq = less_eq_list;
  less = less_list;
};

comparator_list :: forall a. (a -> a -> Ordera) -> [a] -> [a] -> Ordera;
comparator_list comp_a (x : xa) (y : ya) =
  (case comp_a x y of {
    Eqa -> comparator_list comp_a xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_list comp_a (x : xa) [] = Gt;
comparator_list comp_a [] (y : ya) = Lt;
comparator_list comp_a [] [] = Eqa;

compare_list :: forall a. (Compare a) => [a] -> [a] -> Ordera;
compare_list = comparator_list compare;

instance (Eq a, Order a) => Preorder [a] where {
};

instance (Eq a, Order a) => Order [a] where {
};

instance (Eq a, Linorder a) => Linorder [a] where {
};

instance (Compare a) => Compare [a] where {
  compare = compare_list;
};

instance (Compare_order a, Eq a) => Compare_order [a] where {
};

instance (Eq a, Key a) => Key [a] where {
};

equality_list :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
equality_list eq_a (x : xa) (y : ya) = eq_a x y && equality_list eq_a xa ya;
equality_list eq_a (x : xa) [] = False;
equality_list eq_a [] (y : ya) = False;
equality_list eq_a [] [] = True;

ceq_list :: forall a. (Ceq a) => Maybe ([a] -> [a] -> Bool);
ceq_list = (case ceq of {
             Nothing -> Nothing;
             Just eq_a -> Just (equality_list eq_a);
           });

instance (Ceq a) => Ceq [a] where {
  ceq = ceq_list;
};

class Infinite a where {
};

instance Infinite [a] where {
};

set_impl_list :: forall a. Phantom [a] Set_impla;
set_impl_list = Phantom Set_Choose;

instance Set_impl [a] where {
  set_impl = set_impl_list;
};

class Countable a where {
};

instance (Countable a) => Countable [a] where {
};

finite_UNIV_list :: forall a. Phantom [a] Bool;
finite_UNIV_list = Phantom False;

card_UNIV_list :: forall a. Phantom [a] Nat;
card_UNIV_list = Phantom zero_nat;

instance Finite_UNIV [a] where {
  finite_UNIV = finite_UNIV_list;
};

instance Card_UNIV [a] where {
  card_UNIVa = card_UNIV_list;
};

cEnum_list ::
  forall a. Maybe ([[a]], (([a] -> Bool) -> Bool, ([a] -> Bool) -> Bool));
cEnum_list = Nothing;

instance Cenum [a] where {
  cEnum = cEnum_list;
};

ccompare_list :: forall a. (Ccompare a) => Maybe ([a] -> [a] -> Ordera);
ccompare_list = (case ccompare of {
                  Nothing -> Nothing;
                  Just comp_a -> Just (comparator_list comp_a);
                });

instance (Ccompare a) => Ccompare [a] where {
  ccompare = ccompare_list;
};

mapping_impl_list :: forall a. Phantom [a] Mapping_impla;
mapping_impl_list = Phantom Mapping_Choose;

instance Mapping_impl [a] where {
  mapping_impl = mapping_impl_list;
};

cproper_interval_list ::
  forall a. (Ccompare a) => Maybe [a] -> Maybe [a] -> Bool;
cproper_interval_list xso yso = error "undefined";

instance (Ccompare a) => Cproper_interval [a] where {
  cproper_interval = cproper_interval_list;
};

compare_rai_intern_main ::
  (Rat -> Rat -> Nat) ->
    (Rat -> Rat -> Nat) -> Rat -> Rat -> Rat -> Rat -> Maybe Ordera;
compare_rai_intern_main cr1 cr2 l1 r1 l2 r2 =
  (if less_rat r1 l2 then Just Lt
    else (if less_rat r2 l1 then Just Gt
           else let {
                  (l1a, r1a) = tighten_poly_bounds cr1 l1 r1;
                  a = tighten_poly_bounds cr2 l2 r2;
                  (aa, b) = a;
                } in compare_rai_intern_main cr1 cr2 l1a r1a aa b));

compare_code_intern ::
  Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) -> Ordera;
compare_code_intern x y = compare_code_intern x y;

compare_rai_intern ::
  Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) -> Ordera;
compare_rai_intern (Just x) (Just y) =
  (if info_fun_rai (Just x) == info_fun_rai (Just y) then Eqa
    else let {
           (_, (ri, (_, (l, r)))) = x;
           (_, (ria, (_, (la, ra)))) = y;
         } in (case compare_rai_intern_main (l_r ri) (l_r ria) l r la ra of {
                Nothing ->
                  (error :: forall a. String -> (() -> a) -> a)
                    "error in compare_rai_intern_main"
                    (\ _ -> compare_code_intern (Just x) (Just y));
                Just res -> res;
              }));
compare_rai_intern (Just (un, (ri, (p, (l, r))))) Nothing =
  (if equal_rat (sgn_rat r) one_rat then Gt else Lt);
compare_rai_intern Nothing (Just (un, (ri, (p, (l, r))))) =
  (if equal_rat (sgn_rat r) one_rat then Lt else Gt);
compare_rai_intern Nothing Nothing = Eqa;

compare_rai :: Real_alg_intern -> Real_alg_intern -> Ordera;
compare_rai xa xc =
  compare_rai_intern (rep_real_alg_intern xa) (rep_real_alg_intern xc);

compare_radt :: Real_alg_dt -> Real_alg_dt -> Ordera;
compare_radt (Rationala r) (Rationala q) = compare_rat r q;
compare_radt (Irrational xx) (Irrational yy) = compare_rai xx yy;
compare_radt (Rationala r) (Irrational xx) = compare_rai (of_rat_rai r) xx;
compare_radt (Irrational xx) (Rationala r) = compare_rai xx (of_rat_rai r);

equal_radt :: Real_alg_dt -> Real_alg_dt -> Bool;
equal_radt (Rationala r) (Rationala q) = equal_rat r q;
equal_radt (Irrational v) y = (case compare_radt (Irrational v) y of {
                                Eqa -> True;
                                Lt -> False;
                                Gt -> False;
                              });
equal_radt x (Irrational v) = (case compare_radt x (Irrational v) of {
                                Eqa -> True;
                                Lt -> False;
                                Gt -> False;
                              });

equal_radtc :: Real_alg_dtc -> Real_alg_dtc -> Bool;
equal_radtc xa xc = equal_radt (rep_real_alg_dtc xa) (rep_real_alg_dtc xc);

equal_real_alg :: Real_alg -> Real_alg -> Bool;
equal_real_alg (Abstr_real_alg xc) (Abstr_real_alg xa) = equal_radtc xc xa;

equal_real :: Real -> Real -> Bool;
equal_real (Real_of x) (Real_of y) = equal_real_alg x y;

instance Eq Real where {
  a == b = equal_real a b;
};

floor_rai_fun :: Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) -> Int;
floor_rai_fun Nothing = zero_int;
floor_rai_fun (Just (un, (ri, (p, (l, r))))) =
  let {
    cr = l_r ri;
    (la, ra) =
      tighten_poly_bounds_epsilon cr
        (divide_rat one_rat (of_int (Int_of_integer (2 :: Integer)))) l r;
    fr = floor_rat ra;
    fl = floor_rat la;
    fra = of_int fr;
  } in (if equal_int fr fl || equal_rat (poly p fra) zero_rat then fr
         else let {
                (lb, _) = tighten_poly_bounds_for_x cr fra la ra;
              } in (if less_rat fra lb then fr else fl));

floor_rai :: Real_alg_intern -> Int;
floor_rai xa = floor_rai_fun (rep_real_alg_intern xa);

floor_radt :: Real_alg_dt -> Int;
floor_radt (Rationala r) = floor_rat r;
floor_radt (Irrational rai) = floor_rai rai;

floor_radtc :: Real_alg_dtc -> Int;
floor_radtc xa = floor_radt (rep_real_alg_dtc xa);

floor_real_alg :: Real_alg -> Int;
floor_real_alg (Abstr_real_alg xa) = floor_radtc xa;

showsp_poly ::
  forall a.
    (One a, Zero a, Eq a,
      Showa a) => Nat -> Poly a -> [Prelude.Char] -> [Prelude.Char];
showsp_poly p x = shows_string (show_poly x);

shows_prec_poly ::
  forall a.
    (One a, Zero a, Eq a,
      Showa a) => Nat -> Poly a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_poly p x = showsp_poly p x;

show_rai_info :: Int -> (Poly Rat, Nat) -> [Prelude.Char];
show_rai_info fl (p, n) =
  (if equal_nat (degreea p) one_nat
    then shows_prec_rat zero_nat (uminus_rat (coeff p zero_nat)) []
    else (if equal_nat (degreea p) (nat_of_integer (2 :: Integer))
           then let {
                  p2 = divide_rat (coeff p one_nat)
                         (of_int (Int_of_integer (2 :: Integer)));
                  q = coeff p zero_nat;
                  sqrt =
                    ['s', 'q', 'r', 't', '('] ++
                      shows_prec_rat zero_nat (minus_rat (times_rat p2 p2) q)
                        [] ++
                        [')'];
                } in (if equal_rat p2 zero_rat
                       then (if equal_nat n one_nat then [' ', '-'] else []) ++
                              sqrt
                       else ['('] ++
                              shows_prec_rat zero_nat (uminus_rat p2) [] ++
                                (if equal_nat n one_nat then ['-']
                                  else ['+']) ++
                                  sqrt ++ [')'])
           else ['(', 'n', 'u', 'm', ' ', 'i', 'n', ' ', '('] ++
                  shows_prec_int zero_nat fl [] ++
                    [','] ++
                      shows_prec_int zero_nat
                        (plus_int fl (Int_of_integer (1 :: Integer))) [] ++
                        [')', ',', ' ', 'r', 'o', 'o', 't', ' ', '#'] ++
                          shows_prec_nat zero_nat n [] ++
                            [' ', 'o', 'f', ' '] ++
                              shows_prec_poly zero_nat p [] ++ [')']));

info_radt :: Real_alg_dt -> (Poly Rat, Nat);
info_radt (Rationala r) = info_rai (of_rat_rai r);
info_radt (Irrational rai) = info_rai (normalize_rai Irreducible rai);

info_radtc :: Real_alg_dtc -> (Poly Rat, Nat);
info_radtc xa = info_radt (rep_real_alg_dtc xa);

real_alg_info :: Real_alg -> (Poly Rat, Nat);
real_alg_info (Abstr_real_alg xa) = info_radtc xa;

show_real_alg :: Real_alg -> [Prelude.Char];
show_real_alg x = show_rai_info (floor_real_alg x) (real_alg_info x);

show_real :: Real -> [Prelude.Char];
show_real (Real_of x) = show_real_alg x;

showsp_real :: Nat -> Real -> [Prelude.Char] -> [Prelude.Char];
showsp_real p x y = show_real x ++ y;

shows_prec_real :: Nat -> Real -> [Prelude.Char] -> [Prelude.Char];
shows_prec_real = showsp_real;

shows_list_real :: [Real] -> [Prelude.Char] -> [Prelude.Char];
shows_list_real = showsp_list shows_prec_real zero_nat;

instance Showa Real where {
  shows_prec = shows_prec_real;
  shows_list = shows_list_real;
};

compare_radtc :: Real_alg_dtc -> Real_alg_dtc -> Ordera;
compare_radtc xa xc = compare_radt (rep_real_alg_dtc xa) (rep_real_alg_dtc xc);

compare_real_alg :: Real_alg -> Real_alg -> Ordera;
compare_real_alg (Abstr_real_alg xc) (Abstr_real_alg xa) = compare_radtc xc xa;

less_real_alg :: Real_alg -> Real_alg -> Bool;
less_real_alg = lt_of_comp compare_real_alg;

less_real :: Real -> Real -> Bool;
less_real (Real_of x) (Real_of y) = less_real_alg x y;

abs_real_alg :: Real_alg -> Real_alg;
abs_real_alg x =
  (if less_real (Real_of x) zero_real then uminus_real_alg x else x);

abs_real :: Real -> Real;
abs_real (Real_of x) = Real_of (abs_real_alg x);

instance Abs Real where {
  absa = abs_real;
};

sgn_rai :: Real_alg_intern -> Rat;
sgn_rai xa = (case rep_real_alg_intern xa of {
               Nothing -> zero_rat;
               Just a -> let {
                           (_, aa) = a;
                           (_, ab) = aa;
                           (_, ac) = ab;
                           (_, ad) = ac;
                         } in sgn_rat ad;
             });

sgn_radt :: Real_alg_dt -> Rat;
sgn_radt (Rationala r) = sgn_rat r;
sgn_radt (Irrational rai) = sgn_rai rai;

sgn_radtc :: Real_alg_dtc -> Rat;
sgn_radtc xa = sgn_radt (rep_real_alg_dtc xa);

sgn_real_alg_rat :: Real_alg -> Rat;
sgn_real_alg_rat (Abstr_real_alg xa) = sgn_radtc xa;

sgn_real_alg :: Real_alg -> Real_alg;
sgn_real_alg x = of_rat_real_alg (sgn_real_alg_rat x);

sgn_real :: Real -> Real;
sgn_real (Real_of x) = Real_of (sgn_real_alg x);

instance Sgn Real where {
  sgn = sgn_real;
};

less_eq_real_alg :: Real_alg -> Real_alg -> Bool;
less_eq_real_alg = le_of_comp compare_real_alg;

less_eq_real :: Real -> Real -> Bool;
less_eq_real (Real_of x) (Real_of y) = less_eq_real_alg x y;

instance Ord Real where {
  less_eq = less_eq_real;
  less = less_real;
};

instance Abs_if Real where {
};

instance Sgn_if Real where {
};

instance Preorder Real where {
};

instance Order Real where {
};

instance No_bot Real where {
};

instance No_top Real where {
};

ceq_real :: Maybe (Real -> Real -> Bool);
ceq_real = Just equal_real;

instance Ceq Real where {
  ceq = ceq_real;
};

set_impl_real :: Phantom Real Set_impla;
set_impl_real = Phantom Set_DList;

instance Set_impl Real where {
  set_impl = set_impl_real;
};

instance Linorder Real where {
};

instance Ordered_ab_semigroup_add Real where {
};

instance Ordered_cancel_ab_semigroup_add Real where {
};

instance Ordered_semiring Real where {
};

instance Ordered_cancel_semiring Real where {
};

instance Ordered_ab_semigroup_add_imp_le Real where {
};

instance Ordered_comm_monoid_add Real where {
};

instance Ordered_ab_group_add Real where {
};

instance Ordered_ring Real where {
};

cEnum_real :: Maybe ([Real], ((Real -> Bool) -> Bool, (Real -> Bool) -> Bool));
cEnum_real = Nothing;

instance Cenum Real where {
  cEnum = cEnum_real;
};

instance Dense_order Real where {
};

instance Linordered_ab_semigroup_add Real where {
};

instance Linordered_cancel_ab_semigroup_add Real where {
};

instance Linordered_semiring Real where {
};

instance Linordered_semiring_strict Real where {
};

instance Linordered_semiring_1 Real where {
};

instance Linordered_semiring_1_strict Real where {
};

instance Ordered_ab_group_add_abs Real where {
};

instance Linordered_ab_group_add Real where {
};

instance Linordered_ring Real where {
};

instance Linordered_ring_strict Real where {
};

instance Ordered_comm_semiring Real where {
};

instance Ordered_cancel_comm_semiring Real where {
};

instance Linordered_comm_semiring_strict Real where {
};

instance Linordered_semidom Real where {
};

instance Ordered_comm_ring Real where {
};

instance Ordered_ring_abs Real where {
};

instance Linordered_idom Real where {
};

instance Non_strict_order Real where {
};

instance Ordered_ab_semigroup Real where {
};

instance Ordered_semiring_0 Real where {
};

instance Ordered_semiring_1 Real where {
};

instance Poly_carrier Real where {
};

instance Dense_linorder Real where {
};

instance Unbounded_dense_linorder Real where {
};

instance Linordered_field Real where {
};

compare_real :: Real -> Real -> Ordera;
compare_real (Real_of x) (Real_of y) = compare_real_alg x y;

ccompare_real :: Maybe (Real -> Real -> Ordera);
ccompare_real = Just compare_real;

instance Ccompare Real where {
  ccompare = ccompare_real;
};

real_of_real :: Real -> Real;
real_of_real x = x;

instance Real_embedding Real where {
  real_of = real_of_real;
};

floor_real :: Real -> Int;
floor_real (Real_of x) = floor_real_alg x;

instance Archimedean_field Real where {
};

instance Large_ordered_semiring_1 Real where {
};

instance Floor_ceiling Real where {
  floor = floor_real;
};

instance Large_real_ordered_semiring_1 Real where {
};

data Term a b = Var b | Fun a [Term a b];

data Ctxt a b = Hole | More a [Term a b] (Ctxt a b) [Term a b];

instance (Eq a, Eq b) => Eq (Term a b) where {
  a == b = equal_term a b;
};

equal_term :: forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Bool;
equal_term (Var x1) (Fun x21 x22) = False;
equal_term (Fun x21 x22) (Var x1) = False;
equal_term (Fun x21 x22) (Fun y21 y22) = x21 == y21 && x22 == y22;
equal_term (Var x1) (Var y1) = x1 == y1;

equal_ctxt :: forall a b. (Eq a, Eq b) => Ctxt a b -> Ctxt a b -> Bool;
equal_ctxt Hole (More x21 x22 x23 x24) = False;
equal_ctxt (More x21 x22 x23 x24) Hole = False;
equal_ctxt (More x21 x22 x23 x24) (More y21 y22 y23 y24) =
  x21 == y21 && x22 == y22 && equal_ctxt x23 y23 && x24 == y24;
equal_ctxt Hole Hole = True;

instance (Eq a, Eq b) => Eq (Ctxt a b) where {
  a == b = equal_ctxt a b;
};

ceq_ctxt :: forall a b. (Eq a, Eq b) => Maybe (Ctxt a b -> Ctxt a b -> Bool);
ceq_ctxt = Just equal_ctxt;

instance (Eq a, Eq b) => Ceq (Ctxt a b) where {
  ceq = ceq_ctxt;
};

set_impl_ctxt :: forall a b. Phantom (Ctxt a b) Set_impla;
set_impl_ctxt = Phantom Set_RBT;

instance Set_impl (Ctxt a b) where {
  set_impl = set_impl_ctxt;
};

comparator_term ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Term a b -> Term a b -> Ordera;
comparator_term comp_f comp_v (Fun x xa) (Fun ya yb) =
  (case comp_f x ya of {
    Eqa -> comparator_list (comparator_term comp_f comp_v) xa yb;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_term comp_f comp_v (Fun x xa) (Var y) = Gt;
comparator_term comp_f comp_v (Var x) (Fun ya yb) = Lt;
comparator_term comp_f comp_v (Var x) (Var y) = comp_v x y;

comparator_ctxt ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Ctxt a b -> Ctxt a b -> Ordera;
comparator_ctxt comp_f comp_v (More x xa xb xc) (More y ya yb yc) =
  (case comp_f x y of {
    Eqa ->
      (case comparator_list (comparator_term comp_f comp_v) xa ya of {
        Eqa -> (case comparator_ctxt comp_f comp_v xb yb of {
                 Eqa -> comparator_list (comparator_term comp_f comp_v) xc yc;
                 Lt -> Lt;
                 Gt -> Gt;
               });
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_ctxt comp_f comp_v (More x xa xb xc) Hole = Gt;
comparator_ctxt comp_f comp_v Hole (More y ya yb yc) = Lt;
comparator_ctxt comp_f comp_v Hole Hole = Eqa;

compare_ctxt ::
  forall a b. (Compare a, Compare b) => Ctxt a b -> Ctxt a b -> Ordera;
compare_ctxt = comparator_ctxt compare compare;

ccompare_ctxt ::
  forall a b. (Compare a, Compare b) => Maybe (Ctxt a b -> Ctxt a b -> Ordera);
ccompare_ctxt = Just compare_ctxt;

instance (Compare a, Compare b) => Ccompare (Ctxt a b) where {
  ccompare = ccompare_ctxt;
};

shows_term ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Term a b -> [Prelude.Char] -> [Prelude.Char];
shows_term fun var (Var x) = var x;
shows_term fun var (Fun f ts) =
  fun f .
    shows_list_gen id [] ['('] [',', ' '] [')'] (map (shows_term fun var) ts);

shows_prec_term ::
  forall a b.
    (Showa a, Showa b) => Nat -> Term a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_term d t = shows_term (shows_prec zero_nat) (shows_prec zero_nat) t;

shows_list_term ::
  forall a b.
    (Showa a, Showa b) => [Term a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_term ts = showsp_list shows_prec_term zero_nat ts;

instance (Showa a, Showa b) => Showa (Term a b) where {
  shows_prec = shows_prec_term;
  shows_list = shows_list_term;
};

compare_term ::
  forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Ordera;
compare_term = comparator_term compare compare;

less_eq_term ::
  forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Bool;
less_eq_term = le_of_comp compare_term;

less_term :: forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Bool;
less_term = lt_of_comp compare_term;

instance (Compare a, Compare b) => Ord (Term a b) where {
  less_eq = less_eq_term;
  less = less_term;
};

instance (Compare a, Compare b) => Preorder (Term a b) where {
};

instance (Compare a, Compare b) => Order (Term a b) where {
};

instance (Compare a, Compare b) => Linorder (Term a b) where {
};

instance (Compare a, Compare b) => Compare (Term a b) where {
  compare = compare_term;
};

instance (Compare a, Compare b) => Compare_order (Term a b) where {
};

instance (Key a, Key b) => Key (Term a b) where {
};

ceq_term :: forall a b. (Eq a, Eq b) => Maybe (Term a b -> Term a b -> Bool);
ceq_term = Just equal_term;

instance (Eq a, Eq b) => Ceq (Term a b) where {
  ceq = ceq_term;
};

set_impl_term :: forall a b. Phantom (Term a b) Set_impla;
set_impl_term = Phantom Set_RBT;

instance Set_impl (Term a b) where {
  set_impl = set_impl_term;
};

cEnum_term ::
  forall a b.
    Maybe ([Term a b],
            ((Term a b -> Bool) -> Bool, (Term a b -> Bool) -> Bool));
cEnum_term = Nothing;

instance Cenum (Term a b) where {
  cEnum = cEnum_term;
};

finite_UNIV_term :: forall a b. Phantom (Term a b) Bool;
finite_UNIV_term = Phantom False;

instance Finite_UNIV (Term a b) where {
  finite_UNIV = finite_UNIV_term;
};

ccompare_term ::
  forall a b. (Compare a, Compare b) => Maybe (Term a b -> Term a b -> Ordera);
ccompare_term = Just compare_term;

instance (Compare a, Compare b) => Ccompare (Term a b) where {
  ccompare = ccompare_term;
};

cproper_interval_term ::
  forall a b.
    (Compare a, Compare b) => Maybe (Term a b) -> Maybe (Term a b) -> Bool;
cproper_interval_term = (\ _ _ -> False);

instance (Compare a, Compare b) => Cproper_interval (Term a b) where {
  cproper_interval = cproper_interval_term;
};

equal_iarray :: forall a. (Eq a) => IArray.IArray a -> IArray.IArray a -> Bool;
equal_iarray asa bs = list_of asa == list_of bs;

mat_equal_impl :: forall a. (Eq a) => Mat_impl a -> Mat_impl a -> Bool;
mat_equal_impl xa xc =
  let {
    (nr1, (nc1, m1)) = rep_mat_impl xa;
  } in (\ (nr2, (nc2, m2)) ->
         equal_nat nr1 nr2 && equal_nat nc1 nc2 && equal_iarray m1 m2)
    (rep_mat_impl xc);

equal_mat :: forall a. (Eq a) => Mat a -> Mat a -> Bool;
equal_mat (Mat_impl m1) (Mat_impl m2) = mat_equal_impl m1 m2;

instance (Eq a) => Eq (Mat a) where {
  a == b = equal_mat a b;
};

mat_to_list :: forall a. Mat a -> [[a]];
mat_to_list a =
  map (\ i -> map (\ j -> mat_index a (i, j)) (upt zero_nat (mat_dim_col a)))
    (upt zero_nat (mat_dim_row a));

shows_mat :: forall a. (Showa a) => Mat a -> [Prelude.Char] -> [Prelude.Char];
shows_mat a = shows_prec_list zero_nat (mat_to_list a);

shows_prec_mat ::
  forall a. (Showa a) => Nat -> Mat a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_mat p a = shows_mat a;

shows_prec_char :: Nat -> Prelude.Char -> [Prelude.Char] -> [Prelude.Char];
shows_prec_char p c = (\ a -> c : a);

shows_list_char :: [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
shows_list_char cs = shows_string cs;

instance Showa Prelude.Char where {
  shows_prec = shows_prec_char;
  shows_list = shows_list_char;
};

shows_list_mat ::
  forall a. (Showa a) => [Mat a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_mat asa =
  shows_sep shows_mat (shows_prec_list zero_nat [',', ' ']) asa;

instance (Showa a) => Showa (Mat a) where {
  shows_prec = shows_prec_mat;
  shows_list = shows_list_mat;
};

ceq_mat :: forall a. (Eq a) => Maybe (Mat a -> Mat a -> Bool);
ceq_mat = Just equal_mat;

instance (Eq a) => Ceq (Mat a) where {
  ceq = ceq_mat;
};

set_impl_mat :: forall a. Phantom (Mat a) Set_impla;
set_impl_mat = Phantom Set_DList;

instance Set_impl (Mat a) where {
  set_impl = set_impl_mat;
};

cEnum_mat ::
  forall a. Maybe ([Mat a], ((Mat a -> Bool) -> Bool, (Mat a -> Bool) -> Bool));
cEnum_mat = Nothing;

instance Cenum (Mat a) where {
  cEnum = cEnum_mat;
};

ccompare_mat :: forall a. Maybe (Mat a -> Mat a -> Ordera);
ccompare_mat = Nothing;

instance Ccompare (Mat a) where {
  ccompare = ccompare_mat;
};

instance Ord Prelude.Char where {
  less_eq = (\ a b -> a <= b);
  less = (\ a b -> a < b);
};

instance Preorder Prelude.Char where {
};

instance Order Prelude.Char where {
};

instance Linorder Prelude.Char where {
};

compare_char :: Prelude.Char -> Prelude.Char -> Ordera;
compare_char = comparator_of;

instance Compare Prelude.Char where {
  compare = compare_char;
};

instance Compare_order Prelude.Char where {
};

instance Key Prelude.Char where {
};

ceq_char :: Maybe (Prelude.Char -> Prelude.Char -> Bool);
ceq_char = Just (\ a b -> a == b);

instance Ceq Prelude.Char where {
  ceq = ceq_char;
};

instance Countable Prelude.Char where {
};

ccompare_char :: Maybe (Prelude.Char -> Prelude.Char -> Ordera);
ccompare_char = Just compare_char;

instance Ccompare Prelude.Char where {
  ccompare = ccompare_char;
};

data Pos = Empty | PCons Nat Pos;

equal_pos :: Pos -> Pos -> Bool;
equal_pos Empty (PCons x21 x22) = False;
equal_pos (PCons x21 x22) Empty = False;
equal_pos (PCons x21 x22) (PCons y21 y22) =
  equal_nat x21 y21 && equal_pos x22 y22;
equal_pos Empty Empty = True;

instance Eq Pos where {
  a == b = equal_pos a b;
};

shows_pos :: Pos -> [Prelude.Char] -> [Prelude.Char];
shows_pos (PCons i Empty) = shows_prec_nat zero_nat (suc i);
shows_pos (PCons i (PCons v va)) =
  shows_prec_nat zero_nat (suc i) . shows_pos (PCons v va);
shows_pos Empty = shows_string ['e', 'p', 's', 'i', 'l', 'o', 'n'];

shows_prec_pos :: Nat -> Pos -> [Prelude.Char] -> [Prelude.Char];
shows_prec_pos d p = shows_pos p;

shows_list_pos :: [Pos] -> [Prelude.Char] -> [Prelude.Char];
shows_list_pos ps = showsp_list shows_prec_pos zero_nat ps;

instance Showa Pos where {
  shows_prec = shows_prec_pos;
  shows_list = shows_list_pos;
};

one_pos :: Pos;
one_pos = Empty;

instance One Pos where {
  onea = one_pos;
};

append :: Pos -> Pos -> Pos;
append Empty q = q;
append (PCons i p) q = PCons i (append p q);

times_pos :: Pos -> Pos -> Pos;
times_pos p q = append p q;

instance Times Pos where {
  times = times_pos;
};

instance Power Pos where {
};

ceq_pos :: Maybe (Pos -> Pos -> Bool);
ceq_pos = Just equal_pos;

instance Ceq Pos where {
  ceq = ceq_pos;
};

set_impl_pos :: Phantom Pos Set_impla;
set_impl_pos = Phantom Set_RBT;

instance Set_impl Pos where {
  set_impl = set_impl_pos;
};

cEnum_pos :: Maybe ([Pos], ((Pos -> Bool) -> Bool, (Pos -> Bool) -> Bool));
cEnum_pos = Nothing;

instance Cenum Pos where {
  cEnum = cEnum_pos;
};

finite_UNIV_pos :: Phantom Pos Bool;
finite_UNIV_pos = Phantom False;

instance Finite_UNIV Pos where {
  finite_UNIV = finite_UNIV_pos;
};

comparator_pos :: Pos -> Pos -> Ordera;
comparator_pos (PCons x xa) (PCons y ya) = (case comparator_of x y of {
     Eqa -> comparator_pos xa ya;
     Lt -> Lt;
     Gt -> Gt;
   });
comparator_pos (PCons x xa) Empty = Gt;
comparator_pos Empty (PCons y ya) = Lt;
comparator_pos Empty Empty = Eqa;

compare_pos :: Pos -> Pos -> Ordera;
compare_pos = comparator_pos;

ccompare_pos :: Maybe (Pos -> Pos -> Ordera);
ccompare_pos = Just compare_pos;

instance Ccompare Pos where {
  ccompare = ccompare_pos;
};

cproper_interval_pos :: Maybe Pos -> Maybe Pos -> Bool;
cproper_interval_pos = (\ _ _ -> False);

instance Cproper_interval Pos where {
  cproper_interval = cproper_interval_pos;
};

data Sum a b = Inl a | Inr b;

equal_sum :: forall a b. (Eq a, Eq b) => Sum a b -> Sum a b -> Bool;
equal_sum (Inl x1) (Inr x2) = False;
equal_sum (Inr x2) (Inl x1) = False;
equal_sum (Inr x2) (Inr y2) = x2 == y2;
equal_sum (Inl x1) (Inl y1) = x1 == y1;

instance (Eq a, Eq b) => Eq (Sum a b) where {
  a == b = equal_sum a b;
};

data Lab a b = Lab (Lab a b) b | FunLab (Lab a b) [Lab a b] | UnLab a
  | Sharp (Lab a b);

instance (Eq a, Eq b) => Eq (Lab a b) where {
  a == b = equal_lab a b;
};

equal_lab :: forall a b. (Eq a, Eq b) => Lab a b -> Lab a b -> Bool;
equal_lab (UnLab x3) (Sharp x4) = False;
equal_lab (Sharp x4) (UnLab x3) = False;
equal_lab (FunLab x21 x22) (Sharp x4) = False;
equal_lab (Sharp x4) (FunLab x21 x22) = False;
equal_lab (FunLab x21 x22) (UnLab x3) = False;
equal_lab (UnLab x3) (FunLab x21 x22) = False;
equal_lab (Lab x11 x12) (Sharp x4) = False;
equal_lab (Sharp x4) (Lab x11 x12) = False;
equal_lab (Lab x11 x12) (UnLab x3) = False;
equal_lab (UnLab x3) (Lab x11 x12) = False;
equal_lab (Lab x11 x12) (FunLab x21 x22) = False;
equal_lab (FunLab x21 x22) (Lab x11 x12) = False;
equal_lab (Sharp x4) (Sharp y4) = equal_lab x4 y4;
equal_lab (UnLab x3) (UnLab y3) = x3 == y3;
equal_lab (FunLab x21 x22) (FunLab y21 y22) = equal_lab x21 y21 && x22 == y22;
equal_lab (Lab x11 x12) (Lab y11 y12) = equal_lab x11 y11 && x12 == y12;

shows_lab ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Lab a b -> [Prelude.Char] -> [Prelude.Char];
shows_lab fun lab (UnLab f) = fun f;
shows_lab fun lab (Lab f l) =
  shows_lab fun lab f . shows_string ['['] . lab l . shows_string [']'];
shows_lab fun lab (Sharp f) = shows_lab fun lab f . shows_string ['#'];
shows_lab fun lab (FunLab f l) =
  shows_lab fun lab f .
    shows_string ['['] .
      shows_list_gen (shows_lab fun lab) [] [] [] [] l . shows_string [']'];

shows_prec_lab ::
  forall a b.
    (Showa a, Showa b) => Nat -> Lab a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_lab d l = shows_lab (shows_prec zero_nat) (shows_prec zero_nat) l;

shows_list_lab ::
  forall a b.
    (Showa a, Showa b) => [Lab a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_lab fs = showsp_list shows_prec_lab zero_nat fs;

instance (Showa a, Showa b) => Showa (Lab a b) where {
  shows_prec = shows_prec_lab;
  shows_list = shows_list_lab;
};

default_lab :: forall a b. (Default a) => Lab a b;
default_lab = UnLab defaulta;

instance (Default a) => Default (Lab a b) where {
  defaulta = default_lab;
};

comparator_lab ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Lab a b -> Lab a b -> Ordera;
comparator_lab comp_f comp_l (Sharp x) (Sharp ye) =
  comparator_lab comp_f comp_l x ye;
comparator_lab comp_f comp_l (Sharp x) (UnLab yd) = Gt;
comparator_lab comp_f comp_l (Sharp x) (FunLab yb yc) = Gt;
comparator_lab comp_f comp_l (Sharp x) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (UnLab x) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (UnLab x) (UnLab yd) = comp_f x yd;
comparator_lab comp_f comp_l (UnLab x) (FunLab yb yc) = Gt;
comparator_lab comp_f comp_l (UnLab x) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (FunLab x xa) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (FunLab x xa) (UnLab yd) = Lt;
comparator_lab comp_f comp_l (FunLab x xa) (FunLab yb yc) =
  (case comparator_lab comp_f comp_l x yb of {
    Eqa -> comparator_list (comparator_lab comp_f comp_l) xa yc;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_lab comp_f comp_l (FunLab x xa) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (Lab x xa) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (UnLab yd) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (FunLab yb yc) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (Lab y ya) =
  (case comparator_lab comp_f comp_l x y of {
    Eqa -> comp_l xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });

compare_lab ::
  forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Ordera;
compare_lab = comparator_lab compare compare;

less_eq_lab :: forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Bool;
less_eq_lab = le_of_comp compare_lab;

less_lab :: forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Bool;
less_lab = lt_of_comp compare_lab;

instance (Compare a, Compare b) => Ord (Lab a b) where {
  less_eq = less_eq_lab;
  less = less_lab;
};

instance (Compare a, Compare b) => Preorder (Lab a b) where {
};

instance (Compare a, Compare b) => Order (Lab a b) where {
};

instance (Compare a, Compare b) => Linorder (Lab a b) where {
};

instance (Compare a, Compare b) => Compare (Lab a b) where {
  compare = compare_lab;
};

instance (Compare a, Compare b) => Compare_order (Lab a b) where {
};

instance (Key a, Key b) => Key (Lab a b) where {
};

ceq_lab :: forall a b. (Eq a, Eq b) => Maybe (Lab a b -> Lab a b -> Bool);
ceq_lab = Just equal_lab;

instance (Eq a, Eq b) => Ceq (Lab a b) where {
  ceq = ceq_lab;
};

set_impl_lab :: forall a b. Phantom (Lab a b) Set_impla;
set_impl_lab = Phantom Set_RBT;

instance Set_impl (Lab a b) where {
  set_impl = set_impl_lab;
};

finite_UNIV_lab :: forall a b. Phantom (Lab a b) Bool;
finite_UNIV_lab = Phantom False;

card_UNIV_lab :: forall a b. Phantom (Lab a b) Nat;
card_UNIV_lab = Phantom zero_nat;

instance Finite_UNIV (Lab a b) where {
  finite_UNIV = finite_UNIV_lab;
};

instance Card_UNIV (Lab a b) where {
  card_UNIVa = card_UNIV_lab;
};

cEnum_lab ::
  forall a b.
    Maybe ([Lab a b], ((Lab a b -> Bool) -> Bool, (Lab a b -> Bool) -> Bool));
cEnum_lab = Nothing;

instance Cenum (Lab a b) where {
  cEnum = cEnum_lab;
};

ccompare_lab ::
  forall a b. (Compare a, Compare b) => Maybe (Lab a b -> Lab a b -> Ordera);
ccompare_lab = Just compare_lab;

instance (Compare a, Compare b) => Ccompare (Lab a b) where {
  ccompare = ccompare_lab;
};

mapping_impl_lab :: forall a b. Phantom (Lab a b) Mapping_impla;
mapping_impl_lab = Phantom Mapping_RBT;

instance Mapping_impl (Lab a b) where {
  mapping_impl = mapping_impl_lab;
};

cproper_interval_lab ::
  forall a b.
    (Compare a, Compare b) => Maybe (Lab a b) -> Maybe (Lab a b) -> Bool;
cproper_interval_lab = (\ _ _ -> False);

instance (Compare a, Compare b) => Cproper_interval (Lab a b) where {
  cproper_interval = cproper_interval_lab;
};

equality_option :: forall a. (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool;
equality_option eq_a (Just x) (Just y) = eq_a x y;
equality_option eq_a (Just x) Nothing = False;
equality_option eq_a Nothing (Just y) = False;
equality_option eq_a Nothing Nothing = True;

ceq_option :: forall a. (Ceq a) => Maybe (Maybe a -> Maybe a -> Bool);
ceq_option = (case ceq of {
               Nothing -> Nothing;
               Just eq_a -> Just (equality_option eq_a);
             });

instance (Ceq a) => Ceq (Maybe a) where {
  ceq = ceq_option;
};

set_impl_option :: forall a. (Set_impl a) => Phantom (Maybe a) Set_impla;
set_impl_option = Phantom (of_phantom (set_impl :: Phantom a Set_impla));

instance (Set_impl a) => Set_impl (Maybe a) where {
  set_impl = set_impl_option;
};

cEnum_option ::
  forall a.
    (Cenum a) => Maybe ([Maybe a],
                         ((Maybe a -> Bool) -> Bool,
                           (Maybe a -> Bool) -> Bool));
cEnum_option =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (enum_all_a, enum_ex_a)) ->
      Just (Nothing : map Just enum_a,
             ((\ p -> p Nothing && enum_all_a (\ x -> p (Just x))),
               (\ p -> p Nothing || enum_ex_a (\ x -> p (Just x)))));
  });

instance (Cenum a) => Cenum (Maybe a) where {
  cEnum = cEnum_option;
};

finite_UNIV_option :: forall a. (Finite_UNIV a) => Phantom (Maybe a) Bool;
finite_UNIV_option = Phantom (of_phantom (finite_UNIV :: Phantom a Bool));

instance (Finite_UNIV a) => Finite_UNIV (Maybe a) where {
  finite_UNIV = finite_UNIV_option;
};

comparator_option ::
  forall a. (a -> a -> Ordera) -> Maybe a -> Maybe a -> Ordera;
comparator_option comp_a (Just x) (Just y) = comp_a x y;
comparator_option comp_a (Just x) Nothing = Gt;
comparator_option comp_a Nothing (Just y) = Lt;
comparator_option comp_a Nothing Nothing = Eqa;

ccompare_option ::
  forall a. (Ccompare a) => Maybe (Maybe a -> Maybe a -> Ordera);
ccompare_option = (case ccompare of {
                    Nothing -> Nothing;
                    Just comp_a -> Just (comparator_option comp_a);
                  });

instance (Ccompare a) => Ccompare (Maybe a) where {
  ccompare = ccompare_option;
};

mapping_impl_option ::
  forall a. (Mapping_impl a) => Phantom (Maybe a) Mapping_impla;
mapping_impl_option =
  Phantom (of_phantom (mapping_impl :: Phantom a Mapping_impla));

instance (Mapping_impl a) => Mapping_impl (Maybe a) where {
  mapping_impl = mapping_impl_option;
};

cproper_interval_option ::
  forall a. (Cproper_interval a) => Maybe (Maybe a) -> Maybe (Maybe a) -> Bool;
cproper_interval_option Nothing Nothing = True;
cproper_interval_option Nothing (Just x) = not (is_none x);
cproper_interval_option (Just x) Nothing = cproper_interval x Nothing;
cproper_interval_option (Just x) (Just Nothing) = False;
cproper_interval_option (Just x) (Just (Just y)) = cproper_interval x (Just y);

instance (Cproper_interval a) => Cproper_interval (Maybe a) where {
  cproper_interval = cproper_interval_option;
};

data Complex = Complex Real Real;

equal_complex :: Complex -> Complex -> Bool;
equal_complex (Complex x1 x2) (Complex y1 y2) =
  equal_real x1 y1 && equal_real x2 y2;

instance Eq Complex where {
  a == b = equal_complex a b;
};

re :: Complex -> Real;
re (Complex x1 x2) = x1;

im :: Complex -> Real;
im (Complex x1 x2) = x2;

times_complex :: Complex -> Complex -> Complex;
times_complex x y =
  Complex (minus_real (times_real (re x) (re y)) (times_real (im x) (im y)))
    (plus_real (times_real (re x) (im y)) (times_real (im x) (re y)));

instance Times Complex where {
  times = times_complex;
};

instance Dvd Complex where {
};

show_complex :: Complex -> [Prelude.Char];
show_complex x =
  let {
    r = re x;
    i = im x;
  } in (if equal_real i zero_real then show_real r
         else (if equal_real r zero_real then show_real i ++ ['i']
                else ['('] ++
                       show_real r ++ ['+'] ++ show_real i ++ ['i', ')']));

showsp_complex :: Nat -> Complex -> [Prelude.Char] -> [Prelude.Char];
showsp_complex p x y = show_complex x ++ y;

shows_prec_complex :: Nat -> Complex -> [Prelude.Char] -> [Prelude.Char];
shows_prec_complex = showsp_complex;

shows_list_complex :: [Complex] -> [Prelude.Char] -> [Prelude.Char];
shows_list_complex = showsp_list shows_prec_complex zero_nat;

instance Showa Complex where {
  shows_prec = shows_prec_complex;
  shows_list = shows_list_complex;
};

one_complex :: Complex;
one_complex = Complex one_real zero_real;

instance One Complex where {
  onea = one_complex;
};

uminus_complex :: Complex -> Complex;
uminus_complex x = Complex (uminus_real (re x)) (uminus_real (im x));

minus_complex :: Complex -> Complex -> Complex;
minus_complex x y =
  Complex (minus_real (re x) (re y)) (minus_real (im x) (im y));

zero_complex :: Complex;
zero_complex = Complex zero_real zero_real;

plus_complex :: Complex -> Complex -> Complex;
plus_complex x y = Complex (plus_real (re x) (re y)) (plus_real (im x) (im y));

instance Plus Complex where {
  plus = plus_complex;
};

instance Semigroup_add Complex where {
};

instance Cancel_semigroup_add Complex where {
};

instance Ab_semigroup_add Complex where {
};

instance Minus Complex where {
  minus = minus_complex;
};

instance Cancel_ab_semigroup_add Complex where {
};

instance Zero Complex where {
  zeroa = zero_complex;
};

instance Monoid_add Complex where {
};

instance Comm_monoid_add Complex where {
};

instance Cancel_comm_monoid_add Complex where {
};

instance Mult_zero Complex where {
};

instance Semigroup_mult Complex where {
};

instance Semiring Complex where {
};

instance Semiring_0 Complex where {
};

instance Semiring_0_cancel Complex where {
};

instance Ab_semigroup_mult Complex where {
};

instance Comm_semiring Complex where {
};

instance Comm_semiring_0 Complex where {
};

instance Comm_semiring_0_cancel Complex where {
};

instance Power Complex where {
};

instance Monoid_mult Complex where {
};

instance Numeral Complex where {
};

instance Semiring_numeral Complex where {
};

instance Zero_neq_one Complex where {
};

instance Semiring_1 Complex where {
};

instance Semiring_1_cancel Complex where {
};

instance Comm_monoid_mult Complex where {
};

instance Comm_semiring_1 Complex where {
};

instance Comm_semiring_1_cancel Complex where {
};

instance Comm_semiring_1_cancel_crossproduct Complex where {
};

instance Semiring_no_zero_divisors Complex where {
};

instance Semiring_1_no_zero_divisors Complex where {
};

instance Semiring_no_zero_divisors_cancel Complex where {
};

instance Uminus Complex where {
  uminusa = uminus_complex;
};

instance Group_add Complex where {
};

instance Ab_group_add Complex where {
};

instance Ring Complex where {
};

instance Ring_no_zero_divisors Complex where {
};

instance Neg_numeral Complex where {
};

instance Ring_1 Complex where {
};

instance Ring_1_no_zero_divisors Complex where {
};

instance Comm_ring Complex where {
};

instance Comm_ring_1 Complex where {
};

instance Semidom Complex where {
};

instance Idom Complex where {
};

inverse_complex :: Complex -> Complex;
inverse_complex x =
  Complex
    (divide_real (re x)
      (plus_real (binary_power (re x) (nat_of_integer (2 :: Integer)))
        (binary_power (im x) (nat_of_integer (2 :: Integer)))))
    (divide_real (uminus_real (im x))
      (plus_real (binary_power (re x) (nat_of_integer (2 :: Integer)))
        (binary_power (im x) (nat_of_integer (2 :: Integer)))));

divide_complex :: Complex -> Complex -> Complex;
divide_complex x y = times_complex x (inverse_complex y);

instance Ufd Complex where {
};

instance Divide Complex where {
  divide = divide_complex;
};

instance Inverse Complex where {
  inverse = inverse_complex;
};

instance Division_ring Complex where {
};

instance Semidom_divide Complex where {
};

instance Idom_divide Complex where {
};

instance Field Complex where {
};

instance Semiring_char_0 Complex where {
};

instance Ring_char_0 Complex where {
};

instance Field_char_0 Complex where {
};

scaleR_complex :: Real -> Complex -> Complex;
scaleR_complex r x = Complex (times_real r (re x)) (times_real r (im x));

class ScaleR a where {
  scaleR :: Real -> a -> a;
};

instance ScaleR Complex where {
  scaleR = scaleR_complex;
};

class (Ab_group_add a, ScaleR a) => Real_vector a where {
};

instance Real_vector Complex where {
};

class (Real_vector a, Ring a) => Real_algebra a where {
};

instance Real_algebra Complex where {
};

class (Ring_char_0 a, Real_algebra a) => Real_algebra_1 a where {
};

instance Real_algebra_1 Complex where {
};

gcd_poly :: forall a. (Field a, Eq a) => Poly a -> Poly a -> Poly a;
gcd_poly x y =
  (if is_zero y then smult (inverse (coeff x (degreea x))) x
    else gcd_poly y (mod_poly x y));

lcm_poly :: forall a. (Field a, Eq a) => Poly a -> Poly a -> Poly a;
lcm_poly a b =
  divide_poly (times_poly a b)
    (smult (times (coeff a (degreea a)) (coeff b (degreea b))) (gcd_poly a b));

instance (Field a, Eq a) => Gcd (Poly a) where {
  gcd = gcd_poly;
  lcm = lcm_poly;
};

instance (Field a, Eq a) => Divide (Poly a) where {
  divide = divide_poly;
};

unit_factor_poly :: forall a. (Field a, Eq a) => Poly a -> Poly a;
unit_factor_poly p = monom (coeff p (degreea p)) zero_nat;

normalize_poly :: forall a. (Field a, Eq a) => Poly a -> Poly a;
normalize_poly p = smult (divide onea (coeff p (degreea p))) p;

instance (Field a, Eq a) => Semidom_divide (Poly a) where {
};

instance (Field a, Eq a) => Algebraic_semidom (Poly a) where {
};

instance (Field a, Eq a) => Normalization_semidom (Poly a) where {
  normalizeb = normalize_poly;
  unit_factor = unit_factor_poly;
};

instance (Field a, Eq a) => Semiring_gcd (Poly a) where {
};

instance (Field a, Eq a) => Idom_divide (Poly a) where {
};

newtype Multiset a = Bag (Alist a Nat);

count_of :: forall a. (Eq a) => [(a, Nat)] -> a -> Nat;
count_of xs x = (case map_of xs x of {
                  Nothing -> zero_nat;
                  Just n -> n;
                });

count :: forall a. (Eq a) => Multiset a -> a -> Nat;
count (Bag xs) = count_of (impl_ofa xs);

subseteq_mset :: forall a. (Eq a) => Multiset a -> Multiset a -> Bool;
subseteq_mset (Bag xs) a =
  all (\ (x, n) -> less_eq_nat n (count a x)) (impl_ofa xs);

equal_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Bool;
equal_multiset m1 m2 = subseteq_mset m1 m2 && subseteq_mset m2 m1;

instance (Eq a) => Eq (Multiset a) where {
  a == b = equal_multiset a b;
};

map_default :: forall a b. (Eq a) => a -> b -> (b -> b) -> [(a, b)] -> [(a, b)];
map_default k v f [] = [(k, v)];
map_default k v f (p : ps) =
  (if fst p == k then (k, f (snd p)) : ps else p : map_default k v f ps);

join_raw ::
  forall a b. (Eq a) => (a -> (b, b) -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
join_raw f xs ys =
  foldr (\ (k, v) -> map_default k v (\ va -> f k (va, v))) ys xs;

joina ::
  forall a b.
    (Eq a) => (a -> (b, b) -> b) -> Alist a b -> Alist a b -> Alist a b;
joina xc xd xe = Alist (join_raw xc (impl_ofa xd) (impl_ofa xe));

plus_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
plus_multiset (Bag xs) (Bag ys) =
  Bag (joina (\ _ (a, b) -> plus_nat a b) xs ys);

instance (Eq a) => Plus (Multiset a) where {
  plus = plus_multiset;
};

zero_multiset :: forall a. Multiset a;
zero_multiset = Bag emptyb;

instance Zero (Multiset a) where {
  zeroa = zero_multiset;
};

instance (Eq a) => Semigroup_add (Multiset a) where {
};

instance (Eq a) => Monoid_add (Multiset a) where {
};

instance (Eq a) => Ab_semigroup_add (Multiset a) where {
};

instance (Eq a) => Comm_monoid_add (Multiset a) where {
};

showsp_prod ::
  forall a b.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      (Nat -> b -> [Prelude.Char] -> [Prelude.Char]) ->
        Nat -> (a, b) -> [Prelude.Char] -> [Prelude.Char];
showsp_prod s1 s2 p (x, y) =
  (((shows_string ['('] . s1 one_nat x) . shows_string [',', ' ']) .
    s2 one_nat y) .
    shows_string [')'];

shows_prec_prod ::
  forall a b.
    (Showa a, Showa b) => Nat -> (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_prec_prod = showsp_prod shows_prec shows_prec;

shows_list_prod ::
  forall a b.
    (Showa a, Showa b) => [(a, b)] -> [Prelude.Char] -> [Prelude.Char];
shows_list_prod = showsp_list shows_prec_prod zero_nat;

instance (Showa a, Showa b) => Showa (a, b) where {
  shows_prec = shows_prec_prod;
  shows_list = shows_list_prod;
};

less_eq_prod :: forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Bool;
less_eq_prod (x1, y1) (x2, y2) = less x1 x2 || less_eq x1 x2 && less_eq y1 y2;

less_prod :: forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Bool;
less_prod (x1, y1) (x2, y2) = less x1 x2 || less_eq x1 x2 && less y1 y2;

instance (Ord a, Ord b) => Ord (a, b) where {
  less_eq = less_eq_prod;
  less = less_prod;
};

comparator_prod ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> (a, b) -> (a, b) -> Ordera;
comparator_prod comp_a comp_b (x, xa) (y, ya) = (case comp_a x y of {
          Eqa -> comp_b xa ya;
          Lt -> Lt;
          Gt -> Gt;
        });

compare_prod ::
  forall a b. (Compare a, Compare b) => (a, b) -> (a, b) -> Ordera;
compare_prod = comparator_prod compare compare;

instance (Preorder a, Preorder b) => Preorder (a, b) where {
};

instance (Order a, Order b) => Order (a, b) where {
};

instance (Linorder a, Linorder b) => Linorder (a, b) where {
};

instance (Compare a, Compare b) => Compare (a, b) where {
  compare = compare_prod;
};

instance (Compare_order a, Compare_order b) => Compare_order (a, b) where {
};

instance (Key a, Key b) => Key (a, b) where {
};

equality_prod ::
  forall a b. (a -> a -> Bool) -> (b -> b -> Bool) -> (a, b) -> (a, b) -> Bool;
equality_prod eq_a eq_b (x, xa) (y, ya) = eq_a x y && eq_b xa ya;

ceq_prod :: forall a b. (Ceq a, Ceq b) => Maybe ((a, b) -> (a, b) -> Bool);
ceq_prod = (case ceq of {
             Nothing -> Nothing;
             Just eq_a -> (case ceq of {
                            Nothing -> Nothing;
                            Just eq_b -> Just (equality_prod eq_a eq_b);
                          });
           });

instance (Ceq a, Ceq b) => Ceq (a, b) where {
  ceq = ceq_prod;
};

set_impl_choose2 :: Set_impla -> Set_impla -> Set_impla;
set_impl_choose2 Set_Monada Set_Monada = Set_Monada;
set_impl_choose2 Set_RBT Set_RBT = Set_RBT;
set_impl_choose2 Set_DList Set_DList = Set_DList;
set_impl_choose2 Set_Collect Set_Collect = Set_Collect;
set_impl_choose2 x y = Set_Choose;

set_impl_prod ::
  forall a b. (Set_impl a, Set_impl b) => Phantom (a, b) Set_impla;
set_impl_prod =
  Phantom
    (set_impl_choose2 (of_phantom (set_impl :: Phantom a Set_impla))
      (of_phantom (set_impl :: Phantom b Set_impla)));

instance (Set_impl a, Set_impl b) => Set_impl (a, b) where {
  set_impl = set_impl_prod;
};

finite_UNIV_prod ::
  forall a b. (Finite_UNIV a, Finite_UNIV b) => Phantom (a, b) Bool;
finite_UNIV_prod =
  Phantom
    (of_phantom (finite_UNIV :: Phantom a Bool) &&
      of_phantom (finite_UNIV :: Phantom b Bool));

card_UNIV_prod :: forall a b. (Card_UNIV a, Card_UNIV b) => Phantom (a, b) Nat;
card_UNIV_prod =
  Phantom
    (times_nat (of_phantom (card_UNIVa :: Phantom a Nat))
      (of_phantom (card_UNIVa :: Phantom b Nat)));

instance (Finite_UNIV a, Finite_UNIV b) => Finite_UNIV (a, b) where {
  finite_UNIV = finite_UNIV_prod;
};

instance (Card_UNIV a, Card_UNIV b) => Card_UNIV (a, b) where {
  card_UNIVa = card_UNIV_prod;
};

product :: forall a b. [a] -> [b] -> [(a, b)];
product [] uu = [];
product (x : xs) ys = map (\ a -> (x, a)) ys ++ product xs ys;

cEnum_prod ::
  forall a b.
    (Cenum a,
      Cenum b) => Maybe ([(a, b)],
                          (((a, b) -> Bool) -> Bool, ((a, b) -> Bool) -> Bool));
cEnum_prod =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (enum_all_a, enum_ex_a)) ->
      (case cEnum of {
        Nothing -> Nothing;
        Just (enum_b, (enum_all_b, enum_ex_b)) ->
          Just (product enum_a enum_b,
                 ((\ p -> enum_all_a (\ x -> enum_all_b (\ y -> p (x, y)))),
                   (\ p -> enum_ex_a (\ x -> enum_ex_b (\ y -> p (x, y))))));
      });
  });

instance (Cenum a, Cenum b) => Cenum (a, b) where {
  cEnum = cEnum_prod;
};

ccompare_prod ::
  forall a b. (Ccompare a, Ccompare b) => Maybe ((a, b) -> (a, b) -> Ordera);
ccompare_prod =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_a -> (case ccompare of {
                     Nothing -> Nothing;
                     Just comp_b -> Just (comparator_prod comp_a comp_b);
                   });
  });

instance (Ccompare a, Ccompare b) => Ccompare (a, b) where {
  ccompare = ccompare_prod;
};

mapping_impl_choose2 :: Mapping_impla -> Mapping_impla -> Mapping_impla;
mapping_impl_choose2 Mapping_RBT Mapping_RBT = Mapping_RBT;
mapping_impl_choose2 Mapping_Assoc_List Mapping_Assoc_List = Mapping_Assoc_List;
mapping_impl_choose2 Mapping_Mapping Mapping_Mapping = Mapping_Mapping;
mapping_impl_choose2 x y = Mapping_Choose;

mapping_impl_prod ::
  forall a b. (Mapping_impl a, Mapping_impl b) => Phantom (a, b) Mapping_impla;
mapping_impl_prod =
  Phantom
    (mapping_impl_choose2 (of_phantom (mapping_impl :: Phantom a Mapping_impla))
      (of_phantom (mapping_impl :: Phantom b Mapping_impla)));

instance (Mapping_impl a, Mapping_impl b) => Mapping_impl (a, b) where {
  mapping_impl = mapping_impl_prod;
};

cproper_interval_prod ::
  forall a b.
    (Cproper_interval a,
      Cproper_interval b) => Maybe (a, b) -> Maybe (a, b) -> Bool;
cproper_interval_prod Nothing Nothing = True;
cproper_interval_prod Nothing (Just (y1, y2)) =
  cproper_interval Nothing (Just y1) || cproper_interval Nothing (Just y2);
cproper_interval_prod (Just (x1, x2)) Nothing =
  cproper_interval (Just x1) Nothing || cproper_interval (Just x2) Nothing;
cproper_interval_prod (Just (x1, x2)) (Just (y1, y2)) =
  cproper_interval (Just x1) (Just y1) ||
    (lt_of_comp (the ccompare) x1 y1 &&
       (cproper_interval (Just x2) Nothing ||
         cproper_interval Nothing (Just y2)) ||
      not (lt_of_comp (the ccompare) y1 x1) &&
        cproper_interval (Just x2) (Just y2));

instance (Cproper_interval a,
           Cproper_interval b) => Cproper_interval (a, b) where {
  cproper_interval = cproper_interval_prod;
};

comparator_unit :: () -> () -> Ordera;
comparator_unit x y = Eqa;

compare_unit :: () -> () -> Ordera;
compare_unit = comparator_unit;

instance Compare () where {
  compare = compare_unit;
};

data Gctxt a b = GCHole | GCFun a [Gctxt a b];

instance (Eq a) => Eq (Gctxt a b) where {
  a == b = equal_gctxt a b;
};

equal_gctxt :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Bool;
equal_gctxt GCHole (GCFun x21 x22) = False;
equal_gctxt (GCFun x21 x22) GCHole = False;
equal_gctxt (GCFun x21 x22) (GCFun y21 y22) = x21 == y21 && x22 == y22;
equal_gctxt GCHole GCHole = True;

ceq_gctxt :: forall a b. (Eq a) => Maybe (Gctxt a b -> Gctxt a b -> Bool);
ceq_gctxt = Just equal_gctxt;

instance (Eq a) => Ceq (Gctxt a b) where {
  ceq = ceq_gctxt;
};

set_impl_gctxt :: forall a b. Phantom (Gctxt a b) Set_impla;
set_impl_gctxt = Phantom Set_RBT;

instance Set_impl (Gctxt a b) where {
  set_impl = set_impl_gctxt;
};

comparator_gctxt ::
  forall a b. (a -> a -> Ordera) -> Gctxt a b -> Gctxt a b -> Ordera;
comparator_gctxt comp_f (GCFun x xa) (GCFun y ya) =
  (case comp_f x y of {
    Eqa -> comparator_list (comparator_gctxt comp_f) xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_gctxt comp_f (GCFun x xa) GCHole = Gt;
comparator_gctxt comp_f GCHole (GCFun y ya) = Lt;
comparator_gctxt comp_f GCHole GCHole = Eqa;

compare_gctxt :: forall a b. (Compare a) => Gctxt a b -> Gctxt a b -> Ordera;
compare_gctxt = comparator_gctxt compare;

ccompare_gctxt ::
  forall a b.
    (Compare a, Compare b) => Maybe (Gctxt a b -> Gctxt a b -> Ordera);
ccompare_gctxt = Just compare_gctxt;

instance (Compare a, Compare b) => Ccompare (Gctxt a b) where {
  ccompare = ccompare_gctxt;
};

data Acterm a b = AVar b | AFun a [Acterm a b] | AAC a (Multiset (Acterm a b));

instance (Eq a, Eq b) => Eq (Acterm a b) where {
  a == b = equal_acterm a b;
};

equal_acterm :: forall a b. (Eq a, Eq b) => Acterm a b -> Acterm a b -> Bool;
equal_acterm (AFun x21 x22) (AAC x31 x32) = False;
equal_acterm (AAC x31 x32) (AFun x21 x22) = False;
equal_acterm (AVar x1) (AAC x31 x32) = False;
equal_acterm (AAC x31 x32) (AVar x1) = False;
equal_acterm (AVar x1) (AFun x21 x22) = False;
equal_acterm (AFun x21 x22) (AVar x1) = False;
equal_acterm (AAC x31 x32) (AAC y31 y32) = x31 == y31 && equal_multiset x32 y32;
equal_acterm (AFun x21 x22) (AFun y21 y22) = x21 == y21 && x22 == y22;
equal_acterm (AVar x1) (AVar y1) = x1 == y1;

data Ta_rule a b = TA_rule b [a] a;

equal_ta_rule :: forall a b. (Eq a, Eq b) => Ta_rule a b -> Ta_rule a b -> Bool;
equal_ta_rule (TA_rule x1 x2 x3) (TA_rule y1 y2 y3) =
  x1 == y1 && x2 == y2 && x3 == y3;

instance (Eq a, Eq b) => Eq (Ta_rule a b) where {
  a == b = equal_ta_rule a b;
};

show_ta_rule ::
  forall a b.
    (Showa a, Showa b) => Ta_rule a b -> [Prelude.Char] -> [Prelude.Char];
show_ta_rule (TA_rule f qs q) =
  ((shows_prec zero_nat f . shows_prec_list zero_nat qs) .
    shows_prec_list zero_nat [' ', '-', '>', ' ']) .
    shows_prec zero_nat q;

shows_prec_ta_rule ::
  forall a b.
    (Showa a,
      Showa b) => Nat -> Ta_rule a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_ta_rule p r = show_ta_rule r;

shows_list_ta_rule ::
  forall a b.
    (Showa a, Showa b) => [Ta_rule a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_ta_rule ps = showsp_list shows_prec_ta_rule zero_nat ps;

instance (Showa a, Showa b) => Showa (Ta_rule a b) where {
  shows_prec = shows_prec_ta_rule;
  shows_list = shows_list_ta_rule;
};

comparator_ta_rule ::
  forall a b.
    (a -> a -> Ordera) ->
      (b -> b -> Ordera) -> Ta_rule a b -> Ta_rule a b -> Ordera;
comparator_ta_rule comp_q comp_f (TA_rule x xa xb) (TA_rule y ya yb) =
  (case comp_f x y of {
    Eqa -> (case comparator_list comp_q xa ya of {
             Eqa -> comp_q xb yb;
             Lt -> Lt;
             Gt -> Gt;
           });
    Lt -> Lt;
    Gt -> Gt;
  });

compare_ta_rule ::
  forall a b. (Compare a, Compare b) => Ta_rule a b -> Ta_rule a b -> Ordera;
compare_ta_rule = comparator_ta_rule compare compare;

less_eq_ta_rule ::
  forall a b. (Compare a, Compare b) => Ta_rule a b -> Ta_rule a b -> Bool;
less_eq_ta_rule = le_of_comp compare_ta_rule;

less_ta_rule ::
  forall a b. (Compare a, Compare b) => Ta_rule a b -> Ta_rule a b -> Bool;
less_ta_rule = lt_of_comp compare_ta_rule;

instance (Compare a, Compare b) => Ord (Ta_rule a b) where {
  less_eq = less_eq_ta_rule;
  less = less_ta_rule;
};

instance (Compare a, Compare b) => Compare (Ta_rule a b) where {
  compare = compare_ta_rule;
};

instance (Compare a, Compare b) => Preorder (Ta_rule a b) where {
};

instance (Compare a, Compare b) => Order (Ta_rule a b) where {
};

ceq_ta_rule ::
  forall a b. (Eq a, Eq b) => Maybe (Ta_rule a b -> Ta_rule a b -> Bool);
ceq_ta_rule = Just equal_ta_rule;

instance (Eq a, Eq b) => Ceq (Ta_rule a b) where {
  ceq = ceq_ta_rule;
};

set_impl_ta_rule :: forall a b. Phantom (Ta_rule a b) Set_impla;
set_impl_ta_rule = Phantom Set_RBT;

instance Set_impl (Ta_rule a b) where {
  set_impl = set_impl_ta_rule;
};

instance (Compare a, Compare b) => Linorder (Ta_rule a b) where {
};

cEnum_ta_rule ::
  forall a b.
    Maybe ([Ta_rule a b],
            ((Ta_rule a b -> Bool) -> Bool, (Ta_rule a b -> Bool) -> Bool));
cEnum_ta_rule = Nothing;

instance Cenum (Ta_rule a b) where {
  cEnum = cEnum_ta_rule;
};

instance (Compare a, Compare b) => Compare_order (Ta_rule a b) where {
};

finite_UNIV_ta_rule :: forall a b. Phantom (Ta_rule a b) Bool;
finite_UNIV_ta_rule = Phantom False;

instance Finite_UNIV (Ta_rule a b) where {
  finite_UNIV = finite_UNIV_ta_rule;
};

ccompare_ta_rule ::
  forall a b.
    (Ccompare a, Ccompare b) => Maybe (Ta_rule a b -> Ta_rule a b -> Ordera);
ccompare_ta_rule =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_q -> (case ccompare of {
                     Nothing -> Nothing;
                     Just comp_f -> Just (comparator_ta_rule comp_q comp_f);
                   });
  });

instance (Ccompare a, Ccompare b) => Ccompare (Ta_rule a b) where {
  ccompare = ccompare_ta_rule;
};

cproper_interval_ta_rule ::
  forall a b.
    (Ccompare a,
      Ccompare b) => Maybe (Ta_rule a b) -> Maybe (Ta_rule a b) -> Bool;
cproper_interval_ta_rule = (\ _ _ -> False);

instance (Ccompare a, Ccompare b) => Cproper_interval (Ta_rule a b) where {
  cproper_interval = cproper_interval_ta_rule;
};

data Mctxt a b = MVar b | MHole | MFun a [Mctxt a b];

instance (Eq a, Eq b) => Eq (Mctxt a b) where {
  a == b = equal_mctxt a b;
};

equal_mctxt :: forall a b. (Eq a, Eq b) => Mctxt a b -> Mctxt a b -> Bool;
equal_mctxt MHole (MFun x31 x32) = False;
equal_mctxt (MFun x31 x32) MHole = False;
equal_mctxt (MVar x1) (MFun x31 x32) = False;
equal_mctxt (MFun x31 x32) (MVar x1) = False;
equal_mctxt (MVar x1) MHole = False;
equal_mctxt MHole (MVar x1) = False;
equal_mctxt (MFun x31 x32) (MFun y31 y32) = x31 == y31 && x32 == y32;
equal_mctxt (MVar x1) (MVar y1) = x1 == y1;
equal_mctxt MHole MHole = True;

ceq_mctxt :: forall a b. (Eq a, Eq b) => Maybe (Mctxt a b -> Mctxt a b -> Bool);
ceq_mctxt = Just equal_mctxt;

instance (Eq a, Eq b) => Ceq (Mctxt a b) where {
  ceq = ceq_mctxt;
};

set_impl_mctxt :: forall a b. Phantom (Mctxt a b) Set_impla;
set_impl_mctxt = Phantom Set_RBT;

instance Set_impl (Mctxt a b) where {
  set_impl = set_impl_mctxt;
};

comparator_mctxt ::
  forall a b.
    (a -> a -> Ordera) ->
      (b -> b -> Ordera) -> Mctxt a b -> Mctxt a b -> Ordera;
comparator_mctxt comp_f comp_v (MFun x xa) (MFun ya yb) =
  (case comp_f x ya of {
    Eqa -> comparator_list (comparator_mctxt comp_f comp_v) xa yb;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_mctxt comp_f comp_v (MFun x xa) MHole = Gt;
comparator_mctxt comp_f comp_v (MFun x xa) (MVar y) = Gt;
comparator_mctxt comp_f comp_v MHole (MFun ya yb) = Lt;
comparator_mctxt comp_f comp_v MHole MHole = Eqa;
comparator_mctxt comp_f comp_v MHole (MVar y) = Gt;
comparator_mctxt comp_f comp_v (MVar x) (MFun ya yb) = Lt;
comparator_mctxt comp_f comp_v (MVar x) MHole = Lt;
comparator_mctxt comp_f comp_v (MVar x) (MVar y) = comp_v x y;

compare_mctxt ::
  forall a b. (Compare a, Compare b) => Mctxt a b -> Mctxt a b -> Ordera;
compare_mctxt = comparator_mctxt compare compare;

ccompare_mctxt ::
  forall a b.
    (Compare a, Compare b) => Maybe (Mctxt a b -> Mctxt a b -> Ordera);
ccompare_mctxt = Just compare_mctxt;

instance (Compare a, Compare b) => Ccompare (Mctxt a b) where {
  ccompare = ccompare_mctxt;
};

data Arctic = MinInfty | Num_arc Int;

equal_arctic :: Arctic -> Arctic -> Bool;
equal_arctic MinInfty (Num_arc x2) = False;
equal_arctic (Num_arc x2) MinInfty = False;
equal_arctic (Num_arc x2) (Num_arc y2) = equal_int x2 y2;
equal_arctic MinInfty MinInfty = True;

instance Eq Arctic where {
  a == b = equal_arctic a b;
};

shows_arctic :: Arctic -> [Prelude.Char] -> [Prelude.Char];
shows_arctic (Num_arc i) = shows_prec_int zero_nat i;
shows_arctic MinInfty = shows_prec_list zero_nat ['-', 'i', 'n', 'f'];

shows_prec_arctic :: Nat -> Arctic -> [Prelude.Char] -> [Prelude.Char];
shows_prec_arctic p ai = shows_arctic ai;

shows_list_arctic :: [Arctic] -> [Prelude.Char] -> [Prelude.Char];
shows_list_arctic asa = showsp_list shows_prec_arctic zero_nat asa;

instance Showa Arctic where {
  shows_prec = shows_prec_arctic;
  shows_list = shows_list_arctic;
};

one_arctic :: Arctic;
one_arctic = Num_arc zero_int;

instance One Arctic where {
  onea = one_arctic;
};

plus_arctic :: Arctic -> Arctic -> Arctic;
plus_arctic MinInfty y = y;
plus_arctic (Num_arc v) MinInfty = Num_arc v;
plus_arctic (Num_arc x) (Num_arc y) = Num_arc (max x y);

instance Plus Arctic where {
  plus = plus_arctic;
};

zero_arctic :: Arctic;
zero_arctic = MinInfty;

instance Zero Arctic where {
  zeroa = zero_arctic;
};

instance Semigroup_add Arctic where {
};

instance Numeral Arctic where {
};

times_arctic :: Arctic -> Arctic -> Arctic;
times_arctic MinInfty y = MinInfty;
times_arctic (Num_arc v) MinInfty = MinInfty;
times_arctic (Num_arc x) (Num_arc y) = Num_arc (plus_int x y);

instance Times Arctic where {
  times = times_arctic;
};

instance Power Arctic where {
};

less_eq_arctic :: Arctic -> Arctic -> Bool;
less_eq_arctic MinInfty x = True;
less_eq_arctic (Num_arc uu) MinInfty = False;
less_eq_arctic (Num_arc y) (Num_arc x) = less_eq_int y x;

less_arctic :: Arctic -> Arctic -> Bool;
less_arctic MinInfty x = True;
less_arctic (Num_arc uu) MinInfty = False;
less_arctic (Num_arc y) (Num_arc x) = less_int y x;

instance Ord Arctic where {
  less_eq = less_eq_arctic;
  less = less_arctic;
};

instance Ab_semigroup_add Arctic where {
};

instance Semigroup_mult Arctic where {
};

instance Semiring Arctic where {
};

instance Mult_zero Arctic where {
};

instance Monoid_add Arctic where {
};

instance Comm_monoid_add Arctic where {
};

instance Semiring_0 Arctic where {
};

instance Monoid_mult Arctic where {
};

instance Semiring_numeral Arctic where {
};

instance Zero_neq_one Arctic where {
};

instance Semiring_1 Arctic where {
};

ceq_arctic :: Maybe (Arctic -> Arctic -> Bool);
ceq_arctic = Just equal_arctic;

instance Ceq Arctic where {
  ceq = ceq_arctic;
};

set_impl_arctic :: Phantom Arctic Set_impla;
set_impl_arctic = Phantom Set_RBT;

instance Set_impl Arctic where {
  set_impl = set_impl_arctic;
};

cEnum_arctic ::
  Maybe ([Arctic], ((Arctic -> Bool) -> Bool, (Arctic -> Bool) -> Bool));
cEnum_arctic = Nothing;

instance Cenum Arctic where {
  cEnum = cEnum_arctic;
};

comparator_arctic :: Arctic -> Arctic -> Ordera;
comparator_arctic (Num_arc x) (Num_arc y) = comparator_of x y;
comparator_arctic (Num_arc x) MinInfty = Gt;
comparator_arctic MinInfty (Num_arc y) = Lt;
comparator_arctic MinInfty MinInfty = Eqa;

compare_arctic :: Arctic -> Arctic -> Ordera;
compare_arctic = comparator_arctic;

ccompare_arctic :: Maybe (Arctic -> Arctic -> Ordera);
ccompare_arctic = Just compare_arctic;

instance Ccompare Arctic where {
  ccompare = ccompare_arctic;
};

instance Non_strict_order Arctic where {
};

instance Ordered_ab_semigroup Arctic where {
};

instance Ordered_semiring_0 Arctic where {
};

instance Ordered_semiring_1 Arctic where {
};

data Filtered a = FPair a Nat;

equal_filtered :: forall a. (Eq a) => Filtered a -> Filtered a -> Bool;
equal_filtered (FPair x1 x2) (FPair y1 y2) = x1 == y1 && equal_nat x2 y2;

instance (Eq a) => Eq (Filtered a) where {
  a == b = equal_filtered a b;
};

filtered_fun :: forall a. Filtered a -> a;
filtered_fun (FPair f n) = f;

shows_prec_filtered ::
  forall a. (Showa a) => Nat -> Filtered a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_filtered p f = shows_prec zero_nat (filtered_fun f);

shows_list_filtered ::
  forall a. (Showa a) => [Filtered a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_filtered fs = showsp_list shows_prec_filtered zero_nat fs;

instance (Showa a) => Showa (Filtered a) where {
  shows_prec = shows_prec_filtered;
  shows_list = shows_list_filtered;
};

comparator_filtered ::
  forall a. (a -> a -> Ordera) -> Filtered a -> Filtered a -> Ordera;
comparator_filtered comp_f (FPair x xa) (FPair y ya) =
  (case comp_f x y of {
    Eqa -> comparator_of xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });

compare_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Ordera;
compare_filtered = comparator_filtered compare;

less_eq_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Bool;
less_eq_filtered = le_of_comp compare_filtered;

less_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Bool;
less_filtered = lt_of_comp compare_filtered;

instance (Compare a) => Ord (Filtered a) where {
  less_eq = less_eq_filtered;
  less = less_filtered;
};

instance (Compare a) => Preorder (Filtered a) where {
};

instance (Compare a) => Order (Filtered a) where {
};

instance (Compare a) => Linorder (Filtered a) where {
};

instance (Compare a) => Compare (Filtered a) where {
  compare = compare_filtered;
};

instance (Compare a) => Compare_order (Filtered a) where {
};

instance (Key a) => Key (Filtered a) where {
};

data L_poly a b = LPoly b [(a, b)];

cEnum_l_poly ::
  forall a b.
    Maybe ([L_poly a b],
            ((L_poly a b -> Bool) -> Bool, (L_poly a b -> Bool) -> Bool));
cEnum_l_poly = Nothing;

instance Cenum (L_poly a b) where {
  cEnum = cEnum_l_poly;
};

data Location = H | A | Ba | Ra;

equal_location :: Location -> Location -> Bool;
equal_location Ba Ra = False;
equal_location Ra Ba = False;
equal_location A Ra = False;
equal_location Ra A = False;
equal_location A Ba = False;
equal_location Ba A = False;
equal_location H Ra = False;
equal_location Ra H = False;
equal_location H Ba = False;
equal_location Ba H = False;
equal_location H A = False;
equal_location A H = False;
equal_location Ra Ra = True;
equal_location Ba Ba = True;
equal_location A A = True;
equal_location H H = True;

instance Eq Location where {
  a == b = equal_location a b;
};

ceq_location :: Maybe (Location -> Location -> Bool);
ceq_location = Just equal_location;

instance Ceq Location where {
  ceq = ceq_location;
};

set_impl_location :: Phantom Location Set_impla;
set_impl_location = Phantom Set_RBT;

instance Set_impl Location where {
  set_impl = set_impl_location;
};

comparator_location :: Location -> Location -> Ordera;
comparator_location Ra Ra = Eqa;
comparator_location Ra Ba = Gt;
comparator_location Ra A = Gt;
comparator_location Ra H = Gt;
comparator_location Ba Ra = Lt;
comparator_location Ba Ba = Eqa;
comparator_location Ba A = Gt;
comparator_location Ba H = Gt;
comparator_location A Ra = Lt;
comparator_location A Ba = Lt;
comparator_location A A = Eqa;
comparator_location A H = Gt;
comparator_location H Ra = Lt;
comparator_location H Ba = Lt;
comparator_location H A = Lt;
comparator_location H H = Eqa;

compare_location :: Location -> Location -> Ordera;
compare_location = comparator_location;

ccompare_location :: Maybe (Location -> Location -> Ordera);
ccompare_location = Just compare_location;

instance Ccompare Location where {
  ccompare = ccompare_location;
};

data Scg a b = Null | Scg a a [(b, b)] [(b, b)];

equal_scg :: forall a b. (Eq a, Eq b) => Scg a b -> Scg a b -> Bool;
equal_scg Null (Scg x21 x22 x23 x24) = False;
equal_scg (Scg x21 x22 x23 x24) Null = False;
equal_scg (Scg x21 x22 x23 x24) (Scg y21 y22 y23 y24) =
  x21 == y21 && x22 == y22 && x23 == y23 && x24 == y24;
equal_scg Null Null = True;

instance (Eq a, Eq b) => Eq (Scg a b) where {
  a == b = equal_scg a b;
};

comparator_scg ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Scg a b -> Scg a b -> Ordera;
comparator_scg comp_p_p comp_a_p (Scg x xa xb xc) (Scg y ya yb yc) =
  (case comp_p_p x y of {
    Eqa ->
      (case comp_p_p xa ya of {
        Eqa ->
          (case comparator_list (comparator_prod comp_a_p comp_a_p) xb yb of {
            Eqa -> comparator_list (comparator_prod comp_a_p comp_a_p) xc yc;
            Lt -> Lt;
            Gt -> Gt;
          });
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_scg comp_p_p comp_a_p (Scg x xa xb xc) Null = Gt;
comparator_scg comp_p_p comp_a_p Null (Scg y ya yb yc) = Lt;
comparator_scg comp_p_p comp_a_p Null Null = Eqa;

compare_scg ::
  forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Ordera;
compare_scg = comparator_scg compare compare;

less_eq_scg :: forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Bool;
less_eq_scg = le_of_comp compare_scg;

less_scg :: forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Bool;
less_scg = lt_of_comp compare_scg;

instance (Compare a, Compare b) => Ord (Scg a b) where {
  less_eq = less_eq_scg;
  less = less_scg;
};

instance (Compare a, Compare b) => Compare (Scg a b) where {
  compare = compare_scg;
};

instance (Compare a, Compare b) => Preorder (Scg a b) where {
};

instance (Compare a, Compare b) => Order (Scg a b) where {
};

instance (Compare a, Compare b) => Linorder (Scg a b) where {
};

instance (Compare a, Compare b) => Compare_order (Scg a b) where {
};

data Arctic_delta a = MinInfty_delta | Num_arc_delta a;

equal_arctic_delta ::
  forall a. (Eq a) => Arctic_delta a -> Arctic_delta a -> Bool;
equal_arctic_delta MinInfty_delta (Num_arc_delta x2) = False;
equal_arctic_delta (Num_arc_delta x2) MinInfty_delta = False;
equal_arctic_delta (Num_arc_delta x2) (Num_arc_delta y2) = x2 == y2;
equal_arctic_delta MinInfty_delta MinInfty_delta = True;

instance (Eq a) => Eq (Arctic_delta a) where {
  a == b = equal_arctic_delta a b;
};

shows_arctic_delta ::
  forall a. (Showa a) => Arctic_delta a -> [Prelude.Char] -> [Prelude.Char];
shows_arctic_delta (Num_arc_delta i) = shows_prec zero_nat i;
shows_arctic_delta MinInfty_delta =
  shows_prec_list zero_nat ['-', 'i', 'n', 'f'];

shows_prec_arctic_delta ::
  forall a.
    (Showa a) => Nat -> Arctic_delta a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_arctic_delta d ari = shows_arctic_delta ari;

shows_list_arctic_delta ::
  forall a. (Showa a) => [Arctic_delta a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_arctic_delta ps = showsp_list shows_prec_arctic_delta zero_nat ps;

instance (Showa a) => Showa (Arctic_delta a) where {
  shows_prec = shows_prec_arctic_delta;
  shows_list = shows_list_arctic_delta;
};

one_arctic_delta :: forall a. (Linordered_field a) => Arctic_delta a;
one_arctic_delta = Num_arc_delta zeroa;

instance (Linordered_field a) => One (Arctic_delta a) where {
  onea = one_arctic_delta;
};

plus_arctic_delta ::
  forall a.
    (Linordered_field a) => Arctic_delta a -> Arctic_delta a -> Arctic_delta a;
plus_arctic_delta MinInfty_delta y = y;
plus_arctic_delta (Num_arc_delta v) MinInfty_delta = Num_arc_delta v;
plus_arctic_delta (Num_arc_delta x) (Num_arc_delta y) = Num_arc_delta (max x y);

instance (Linordered_field a) => Plus (Arctic_delta a) where {
  plus = plus_arctic_delta;
};

zero_arctic_delta :: forall a. (Linordered_field a) => Arctic_delta a;
zero_arctic_delta = MinInfty_delta;

instance (Linordered_field a) => Zero (Arctic_delta a) where {
  zeroa = zero_arctic_delta;
};

instance (Linordered_field a) => Semigroup_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Numeral (Arctic_delta a) where {
};

times_arctic_delta ::
  forall a.
    (Linordered_field a) => Arctic_delta a -> Arctic_delta a -> Arctic_delta a;
times_arctic_delta MinInfty_delta y = MinInfty_delta;
times_arctic_delta (Num_arc_delta v) MinInfty_delta = MinInfty_delta;
times_arctic_delta (Num_arc_delta x) (Num_arc_delta y) =
  Num_arc_delta (plus x y);

instance (Linordered_field a) => Times (Arctic_delta a) where {
  times = times_arctic_delta;
};

instance (Linordered_field a) => Power (Arctic_delta a) where {
};

less_eq_arctic_delta ::
  forall a. (Ord a) => Arctic_delta a -> Arctic_delta a -> Bool;
less_eq_arctic_delta MinInfty_delta x = True;
less_eq_arctic_delta (Num_arc_delta uu) MinInfty_delta = False;
less_eq_arctic_delta (Num_arc_delta y) (Num_arc_delta x) = less_eq y x;

less_arctic_delta ::
  forall a. (Ord a) => Arctic_delta a -> Arctic_delta a -> Bool;
less_arctic_delta MinInfty_delta x = True;
less_arctic_delta (Num_arc_delta uu) MinInfty_delta = False;
less_arctic_delta (Num_arc_delta y) (Num_arc_delta x) = less y x;

instance (Ord a) => Ord (Arctic_delta a) where {
  less_eq = less_eq_arctic_delta;
  less = less_arctic_delta;
};

instance (Linordered_field a) => Ab_semigroup_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Semigroup_mult (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring (Arctic_delta a) where {
};

instance (Linordered_field a) => Mult_zero (Arctic_delta a) where {
};

instance (Linordered_field a) => Monoid_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Comm_monoid_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_0 (Arctic_delta a) where {
};

instance (Linordered_field a) => Monoid_mult (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_numeral (Arctic_delta a) where {
};

instance (Linordered_field a) => Zero_neq_one (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_1 (Arctic_delta a) where {
};

ceq_arctic_delta ::
  forall a. (Eq a) => Maybe (Arctic_delta a -> Arctic_delta a -> Bool);
ceq_arctic_delta = Just equal_arctic_delta;

instance (Eq a) => Ceq (Arctic_delta a) where {
  ceq = ceq_arctic_delta;
};

set_impl_arctic_delta :: forall a. Phantom (Arctic_delta a) Set_impla;
set_impl_arctic_delta = Phantom Set_RBT;

instance Set_impl (Arctic_delta a) where {
  set_impl = set_impl_arctic_delta;
};

cEnum_arctic_delta ::
  forall a.
    Maybe ([Arctic_delta a],
            ((Arctic_delta a -> Bool) -> Bool,
              (Arctic_delta a -> Bool) -> Bool));
cEnum_arctic_delta = Nothing;

instance Cenum (Arctic_delta a) where {
  cEnum = cEnum_arctic_delta;
};

comparator_arctic_delta ::
  forall a. (a -> a -> Ordera) -> Arctic_delta a -> Arctic_delta a -> Ordera;
comparator_arctic_delta comp_a (Num_arc_delta x) (Num_arc_delta y) = comp_a x y;
comparator_arctic_delta comp_a (Num_arc_delta x) MinInfty_delta = Gt;
comparator_arctic_delta comp_a MinInfty_delta (Num_arc_delta y) = Lt;
comparator_arctic_delta comp_a MinInfty_delta MinInfty_delta = Eqa;

compare_arctic_delta ::
  forall a. (Compare a) => Arctic_delta a -> Arctic_delta a -> Ordera;
compare_arctic_delta = comparator_arctic_delta compare;

ccompare_arctic_delta ::
  forall a. (Compare a) => Maybe (Arctic_delta a -> Arctic_delta a -> Ordera);
ccompare_arctic_delta = Just compare_arctic_delta;

instance (Compare a) => Ccompare (Arctic_delta a) where {
  ccompare = ccompare_arctic_delta;
};

instance (Linordered_field a) => Non_strict_order (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_ab_semigroup (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_semiring_0 (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_semiring_1 (Arctic_delta a) where {
};

data Cond_constraint a b = CC_cond Bool (Term a b, Term a b)
  | CC_rewr (Term a b) (Term a b)
  | CC_impl [Cond_constraint a b] (Cond_constraint a b)
  | CC_all b (Cond_constraint a b);

instance (Eq a, Eq b) => Eq (Cond_constraint a b) where {
  a == b = equal_cond_constraint a b;
};

equal_cond_constraint ::
  forall a b.
    (Eq a, Eq b) => Cond_constraint a b -> Cond_constraint a b -> Bool;
equal_cond_constraint (CC_impl x31 x32) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_impl x31 x32) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_impl x31 x32) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_all x41 x42) (CC_all y41 y42) =
  x41 == y41 && equal_cond_constraint x42 y42;
equal_cond_constraint (CC_impl x31 x32) (CC_impl y31 y32) =
  x31 == y31 && equal_cond_constraint x32 y32;
equal_cond_constraint (CC_rewr x21 x22) (CC_rewr y21 y22) =
  equal_term x21 y21 && equal_term x22 y22;
equal_cond_constraint (CC_cond x11 x12) (CC_cond y11 y12) =
  x11 == y11 && x12 == y12;

data Itself a = Type;

newtype Rbt b a = RBT (Rbta b a);

data Xml = XML [Prelude.Char] [([Prelude.Char], [Prelude.Char])] [Xml]
  | XML_text [Prelude.Char];

data Xmldoc = XMLDOC [[Prelude.Char]] Xml;

newtype Dlist a = Dlist [a];

data Order_tag = Lex | Mul;

data Tree_automaton a b = Tree_Automaton [a] [Ta_rule a b] [(a, a)];

data Complexity_measure a b = Derivational_Complexity [(a, Nat)]
  | Runtime_Complexity [(a, Nat)] [(a, Nat)];

newtype Complexity_class = Comp_Poly Nat;

data Strategy a b = No_Strategy | Innermost | Innermost_Q [Term a b];

data Fp_strategy a b = Outermost | Context_Sensitive [((a, Nat), [Nat])]
  | Forbidden_Patterns [(Ctxt a b, (Term a b, Location))];

data Input a b =
  DP_input
    (Bool, ([(Term a b, Term a b)], (Strategy a b, [(Term a b, Term a b)])))
  | Inn_TRS_input
      (Strategy a b, ([(Term a b, Term a b)], Maybe [(Term a b, Term a b)]))
  | COMP_input ([(Term a b, Term a b)], [(Term a b, Term a b)])
  | EQ_input ([(Term a b, Term a b)], (Term a b, Term a b))
  | CPX_input
      (Strategy a b,
        ([(Term a b, Term a b)],
          (Maybe [(Term a b, Term a b)],
            (Complexity_measure a b, Complexity_class))))
  | FP_TRS_input (Fp_strategy a b, [(Term a b, Term a b)])
  | CTRS_input [((Term a b, Term a b), [(Term a b, Term a b)])]
  | TA_input (Tree_automaton [Prelude.Char] a) [(Term a b, Term a b)]
  | AC_input [(Term a b, Term a b)] [a] [a] | Unknown_input [Prelude.Char];

data Domain = Natural Nat | Integera | Arctic | Arctic_rat | Int_mat Nat Nat
  | Arctic_mat Nat | Arctic_rat_mat Nat | Rational Rat Nat | Rat_mat Nat Nat
  | Mini_Alg Real Nat | Mini_Alg_mat Nat Nat;

data Tpoly a b = PVar a | PNum b | PSum [Tpoly a b] | PMult [Tpoly a b];

newtype Status a = Abs_status ((a, Nat) -> [Nat]);

data Const_string_sound_proof a b =
  Const_string_sound_proof b [(a, a)] [(Term a b, Term a b)]
    [(Term a b, Term a b)];

data Af_entry = Collapse Nat | AFList [Nat];

data Redtriple_impl a = Int_carrier [((a, Nat), (Int, [Int]))]
  | Int_nl_carrier [((a, Nat), [([(Nat, Nat)], Int)])]
  | Rat_carrier [((a, Nat), (Rat, [Rat]))]
  | Rat_nl_carrier Rat [((a, Nat), [([(Nat, Nat)], Rat)])]
  | Real_carrier [((a, Nat), (Real, [Real]))]
  | Real_nl_carrier Real [((a, Nat), [([(Nat, Nat)], Real)])]
  | Arctic_carrier [((a, Nat), (Arctic, [Arctic]))]
  | Arctic_rat_carrier [((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]))]
  | Int_mat_carrier Nat Nat [((a, Nat), (Mat Int, [Mat Int]))]
  | Rat_mat_carrier Nat Nat [((a, Nat), (Mat Rat, [Mat Rat]))]
  | Real_mat_carrier Nat Nat [((a, Nat), (Mat Real, [Mat Real]))]
  | Arctic_mat_carrier Nat [((a, Nat), (Mat Arctic, [Mat Arctic]))]
  | Arctic_rat_mat_carrier Nat
      [((a, Nat), (Mat (Arctic_delta Rat), [Mat (Arctic_delta Rat)]))]
  | RPO [((a, Nat), (Nat, Order_tag))] [((a, Nat), Af_entry)]
  | KBO ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) [((a, Nat), Af_entry)]
  | WPO [((a, Nat), (Nat, [Nat]))] (Redtriple_impl a);

data Complex_constant_removal_prf a b =
  Complex_Constant_Removal_Proof (Term a b)
    [((Term a b, Term a b), (Term a b, Term a b))];

data List_order_type = MS_Ext | Max_Ext | Min_Ext | Dms_Ext;

data Root_redtriple_impl a =
  SCNP List_order_type [((a, Nat), [(Nat, Nat)])] (Redtriple_impl a);

data Cond_constraint_prf a b = Final
  | Delete_Condition (Cond_constraint a b) (Cond_constraint_prf a b)
  | Different_Constructor (Cond_constraint a b)
  | Same_Constructor (Cond_constraint a b) (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Variable_Equation b (Term a b) (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Funarg_Into_Var (Cond_constraint a b) Nat b (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Simplify_Condition (Cond_constraint a b) [(b, Term a b)]
      (Cond_constraint a b) (Cond_constraint_prf a b)
  | Induction (Cond_constraint a b) [Cond_constraint a b]
      [((Term a b, Term a b),
         ([(Term a b, [b])], (Cond_constraint a b, Cond_constraint_prf a b)))];

data Cond_red_pair_prf a b =
  Cond_Red_Pair_Prf a
    [(Cond_constraint a b, ([(Term a b, Term a b)], Cond_constraint_prf a b))]
    Nat Nat;

data ArithFun = Arg Nat | Const Nat | Sum [ArithFun] | Max [ArithFun]
  | Min [ArithFun] | Prod [ArithFun]
  | IfEqual ArithFun ArithFun ArithFun ArithFun;

data Sl_inter a = SL_Inter Nat [((a, Nat), ArithFun)];

data Sl_variant a b = Rootlab (Maybe (a, Nat)) | Finitelab (Sl_inter a)
  | QuasiFinitelab (Sl_inter a) b;

data Generic_assm_proof a b c d e f g h =
  SN_assm_proof
    (Bool,
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          [(Term (Lab a b) c, Term (Lab a b) c)])))
    d
  | Finite_assm_proof
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      e
  | SN_FP_assm_proof
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      f
  | Not_SN_assm_proof
      (Bool, ([Term (Lab a b) c], [(Term (Lab a b) c, Term (Lab a b) c)])) d
  | Infinite_assm_proof
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      e
  | Not_RelSN_assm_proof
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      f
  | Not_SN_FP_assm_proof
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      g
  | Complexity_assm_proof
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            (Complexity_measure (Lab a b) c, Complexity_class))))
      d
  | Unknown_assm_proof [Prelude.Char] h;

data Join_info a =
  Guided
    [(Term a [Prelude.Char],
       ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                 Term a [Prelude.Char]))],
         (Term a [Prelude.Char],
           [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                    Term a [Prelude.Char]))])))]
  | Join_NF | Join_BFS Nat;

newtype ProjL a = Projection [((a, Nat), Nat)];

data Ta_relation a = Decision_Proc_Old | Decision_Proc | Id_Relation
  | Some_Relation [(a, a)];

data Boundstype = Roof | Match;

data Bounds_info a b =
  Bounds_Info Boundstype Nat [b] (Tree_automaton b (a, Nat)) (Ta_relation b);

data Trs_termination_proof a b c =
  DP_Trans Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
    (Dp_termination_proof a b c)
  | Rule_Removal (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | String_Reversal (Trs_termination_proof a b c)
  | Constant_String (Const_string_sound_proof (Lab a b) c)
      (Trs_termination_proof a b c)
  | Bounds (Bounds_info (Lab a b) c)
  | Uncurry
      (Lab a b,
        ([((Lab a b, Nat), [Lab a b])],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | Semlab (Sl_variant (Lab a b) c) [Term (Lab a b) c]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | R_is_Empty
  | Fcc [Ctxt (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c)
  | Split [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
      (Trs_termination_proof a b c)
  | Switch_Innermost (Join_info (Lab a b)) (Trs_termination_proof a b c)
  | Drop_Equality (Trs_termination_proof a b c)
  | Remove_Nonapplicable_Rules [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c)
  | Permuting_AFS [((Lab a b, Nat), Af_entry)] (Trs_termination_proof a b c)
  | Assume_SN
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [Generic_assm_proof a b c (Trs_termination_proof a b c)
         (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
         (Unknown_proof a b c)];

data Fptrs_termination_proof a b c =
  Assume_FP_SN
    ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
      [(Term (Lab a b) c, Term (Lab a b) c)])
    [Generic_assm_proof a b c (Trs_termination_proof a b c)
       (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
       (Unknown_proof a b c)];

data Dp_termination_proof a b c = P_is_Empty
  | Subterm_Criterion_Proc (ProjL (Lab a b))
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Gen_Subterm_Criterion_Proc [((Lab a b, Nat), [Nat])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Redpair_Proc
      (Sum (Root_redtriple_impl (Lab a b)) (Redtriple_impl (Lab a b)))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Redpair_UR_Proc
      (Sum (Root_redtriple_impl (Lab a b)) (Redtriple_impl (Lab a b)))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Usable_Rules_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_termination_proof a b c)
  | Dep_Graph_Proc
      [(Maybe (Dp_termination_proof a b c),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
  | Mono_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Mono_URM_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Mono_Redpair_UR_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Size_Change_Subterm_Proc
      [((Term (Lab a b) c, Term (Lab a b) c), ([(Nat, Nat)], [(Nat, Nat)]))]
  | Size_Change_Redpair_Proc (Redtriple_impl (Lab a b))
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      [((Term (Lab a b) c, Term (Lab a b) c), ([(Nat, Nat)], [(Nat, Nat)]))]
  | Uncurry_Proc (Maybe Nat)
      (Lab a b,
        ([((Lab a b, Nat), [Lab a b])],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Fcc_Proc (Lab a b) [Ctxt (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Split_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
      (Dp_termination_proof a b c)
  | Semlab_Proc (Sl_variant (Lab a b) c) [(Term (Lab a b) c, Term (Lab a b) c)]
      [Term (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_termination_proof a b c)
  | Switch_Innermost_Proc (Join_info (Lab a b)) (Dp_termination_proof a b c)
  | Rewriting_Proc (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Term (Lab a b) c, Term (Lab a b) c) (Term (Lab a b) c, Term (Lab a b) c)
      (Term (Lab a b) c, Term (Lab a b) c) (Term (Lab a b) c, Term (Lab a b) c)
      Pos (Dp_termination_proof a b c)
  | Instantiation_Proc (Term (Lab a b) c, Term (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Forward_Instantiation_Proc (Term (Lab a b) c, Term (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Dp_termination_proof a b c)
  | Narrowing_Proc (Term (Lab a b) c, Term (Lab a b) c) Pos
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Assume_Finite
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      [Generic_assm_proof a b c (Trs_termination_proof a b c)
         (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
         (Unknown_proof a b c)]
  | Unlab_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Q_Reduction_Proc [Term (Lab a b) c] (Dp_termination_proof a b c)
  | Complex_Constant_Removal_Proc (Complex_constant_removal_prf (Lab a b) c)
      (Dp_termination_proof a b c)
  | General_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Cond_red_pair_prf (Lab a b) c)
      [Dp_termination_proof a b c]
  | To_Trs_Proc (Trs_termination_proof a b c);

data Unknown_proof a b c =
  Assume_Unknown [Prelude.Char]
    [Generic_assm_proof a b c (Trs_termination_proof a b c)
       (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
       (Unknown_proof a b c)];

data Cr_proof a b c = SN_WCR (Join_info (Lab a b)) (Trs_termination_proof a b c)
  | Weakly_Orthogonal | Strongly_Closed Nat
  | Rule_Labeling [((Term (Lab a b) c, Term (Lab a b) c), Nat)]
      [(Term (Lab a b) [Prelude.Char],
         ([(Pos, ((Term (Lab a b) [Prelude.Char],
                    Term (Lab a b) [Prelude.Char]),
                   Term (Lab a b) [Prelude.Char]))],
           (Term (Lab a b) [Prelude.Char],
             [(Pos, ((Term (Lab a b) [Prelude.Char],
                       Term (Lab a b) [Prelude.Char]),
                      Term (Lab a b) [Prelude.Char]))])))]
      (Maybe (Trs_termination_proof a b c))
  | Rule_Labeling_Conv [((Term (Lab a b) c, Term (Lab a b) c), Nat)]
      [(Term (Lab a b) [Prelude.Char],
         (Term (Lab a b) [Prelude.Char],
           ([(Pos, ((Term (Lab a b) [Prelude.Char],
                      Term (Lab a b) [Prelude.Char]),
                     (Bool, Term (Lab a b) [Prelude.Char])))],
             ([(Pos, ((Term (Lab a b) [Prelude.Char],
                        Term (Lab a b) [Prelude.Char]),
                       Term (Lab a b) [Prelude.Char]))],
               ([(Pos, ((Term (Lab a b) [Prelude.Char],
                          Term (Lab a b) [Prelude.Char]),
                         (Bool, Term (Lab a b) [Prelude.Char])))],
                 (Term (Lab a b) [Prelude.Char],
                   ([(Pos, ((Term (Lab a b) [Prelude.Char],
                              Term (Lab a b) [Prelude.Char]),
                             (Bool, Term (Lab a b) [Prelude.Char])))],
                     ([(Pos, ((Term (Lab a b) [Prelude.Char],
                                Term (Lab a b) [Prelude.Char]),
                               Term (Lab a b) [Prelude.Char]))],
                       [(Pos, ((Term (Lab a b) [Prelude.Char],
                                 Term (Lab a b) [Prelude.Char]),
                                (Bool,
                                  Term (Lab a b) [Prelude.Char])))]))))))))]
      (Maybe (Nat, Trs_termination_proof a b c))
  | Redundant_Rules [(Term (Lab a b) c, Term (Lab a b) c)] Nat
      [[(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                (Bool, Term (Lab a b) c)))]]
      (Cr_proof a b c)
  | Parallel_Closed (Maybe Nat);

newtype Multimap a b = Abs_multimap (b -> a, (Mapping a [b], [b]));

data Ring_ext a b = Ring_ext a (a -> a -> a) b;

newtype Sum_bot a b = Sumbot (Sum a b);

newtype Afs a = Abs_afs ((a, Nat) -> Af_entry, Set (a, Nat));

data Non_join_info a b c = Diff_NFs
  | Tcap_Non_Unif (Term a b -> Term a b -> b -> Term a b)
  | Tree_Aut_Intersect_Empty (Tree_automaton c a) (Ta_relation c)
      (Tree_automaton c a) (Ta_relation c)
  | Finite_Model_Gt (Sl_variant a b) | Reduction_Pair_Gt (Redtriple_impl a)
  | Usable_Rules_Reach_NJ (Non_join_info a b c)
  | Usable_Rules_Reach_Unif_NJ
      (Sum [(Term a b, Term a b)] [(Term a b, Term a b)]) (Non_join_info a b c)
  | Argument_Filter_NJ [((a, Nat), Af_entry)] (Non_join_info a b c)
  | Grounding [(b, Term a b)] (Non_join_info a b c)
  | Subterm_NJ Pos (Non_join_info a b c);

data Ncr_proof a b c d = SN_NWCR (Trs_termination_proof a b c)
  | Non_Join (Term (Lab a b) c)
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))]
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))]
      (Non_join_info (Lab a b) c d)
  | NCR_Disj_Subtrs [(Term (Lab a b) c, Term (Lab a b) c)] (Ncr_proof a b c d)
  | NCR_Redundant_Rules [(Term (Lab a b) c, Term (Lab a b) c)] Nat
      (Ncr_proof a b c d);

newtype Rai_list = Abs_rai_list
  [Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))))];

data Dp_loop_prf a b =
  DP_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), (Bool, Term a b)))]
    [(b, Term a b)] (Ctxt a b);

data Monoid_ext a b = Monoid_ext (a -> a -> a) a b;

data Trs_loop_prf a b =
  TRS_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), Term a b))]
    [(b, Term a b)] (Ctxt a b);

data Ta_ext a b c = Ta_ext (Set a) (Set (Ta_rule a b)) (Set (a, a)) c;

data Dependance = Ignore | Increase | Decrease | Wild;

data Pat_eqv_prf a b = Pat_Dom_Renaming [(b, Term a b)]
  | Pat_Irrelevant [(b, Term a b)] [(b, Term a b)]
  | Pat_Simplify [(b, Term a b)] [(b, Term a b)];

newtype Semilattice_set a = Abs_semilattice_set (a -> a -> a);

data Interpretation a = Int_linear_poly ((a, Nat), (Int, [Int]))
  | Rat_linear_poly ((a, Nat), (Rat, [Rat]))
  | Arctic_linear_poly ((a, Nat), (Arctic, [Arctic]))
  | Arctic_rat_linear_poly ((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]))
  | Real_linear_poly ((a, Nat), (Real, [Real]))
  | Int_matrix ((a, Nat), (Mat Int, [Mat Int]))
  | Rat_matrix ((a, Nat), (Mat Rat, [Mat Rat]))
  | Arctic_matrix ((a, Nat), (Mat Arctic, [Mat Arctic]))
  | Arctic_rat_matrix
      ((a, Nat), (Mat (Arctic_delta Rat), [Mat (Arctic_delta Rat)]))
  | Real_matrix ((a, Nat), (Mat Real, [Mat Real]))
  | Int_non_linear_poly ((a, Nat), [([(Nat, Nat)], Int)])
  | Rat_non_linear_poly ((a, Nat), [([(Nat, Nat)], Rat)])
  | Real_non_linear_poly ((a, Nat), [([(Nat, Nat)], Real)]);

data Relation_kind = Strict_TRS | Weak_TRS (Maybe Nat);

data Pat_rule_pos = Pat_Base | Pat_Pump | Pat_Close;

data Pat_rule_prf a b = Pat_OrigRule (Term a b, Term a b) Bool
  | Pat_InitPump (Pat_rule_prf a b) [(b, Term a b)] [(b, Term a b)]
  | Pat_InitPumpCtxt (Pat_rule_prf a b) [(b, Term a b)] Pos b
  | Pat_Equiv (Pat_rule_prf a b) Bool (Pat_eqv_prf a b)
  | Pat_Narrow (Pat_rule_prf a b) (Pat_rule_prf a b) Pos
  | Pat_Inst (Pat_rule_prf a b) [(b, Term a b)] Pat_rule_pos
  | Pat_Rewr (Pat_rule_prf a b)
      (Term a b, [(Pos, ((Term a b, Term a b), Term a b))]) Pat_rule_pos b
  | Pat_Exp_Sigma (Pat_rule_prf a b) Nat;

data Non_loop_prf a b =
  Non_loop_prf (Pat_rule_prf a b) [(b, Term a b)] [(b, Term a b)] Nat Nat Pos;

data Cert_result = Certified [Prelude.Char] | Unsupported [Prelude.Char]
  | Error [Prelude.Char];

newtype Subst_incr a b = Abs_subst_incr
  (b -> Term a b, (Set b, Term a b -> [b]));

data Memory_ext a b c d =
  Memory_ext (() -> a) (a -> b -> Maybe c) (a -> (b, c) -> a) d;

data Rule_removal_nonterm_reltrs_prf a b =
  Rule_removal_nonterm_reltrs_prf (Maybe [(Term a b, Term a b)])
    (Maybe [(Term a b, Term a b)]);

newtype Dp_trans_nontermination_tt_prf a b c = DP_trans_nontermination_tt_prf
  [(Term (Lab a b) c, Term (Lab a b) c)];

data Const_string_complete_proof a b =
  Const_string_complete_proof b [(a, a)] [(Term a b, Term a b)];

newtype Rule_removal_nonterm_trs_prf a b = Rule_removal_nonterm_trs_prf
  [(Term a b, Term a b)];

newtype Q_increase_nonterm_trs_prf a b = Q_increase_nonterm_trs_prf [Term a b];

newtype Instantiation_complete_proc_prf a b = Instantiation_complete_proc_prf
  [(Term a b, Term a b)];

data Rule_removal_nonterm_dp_prf a b =
  Rule_removal_nonterm_dp_prf (Maybe [(Term a b, Term a b)])
    (Maybe [(Term a b, Term a b)]);

newtype Q_increase_nonterm_dp_prf a b = Q_increase_nonterm_dp_prf [Term a b];

newtype Dp_q_reduction_nonterm_prf a b = DP_q_reduction_nonterm_prf [Term a b];

data Rewriting_complete_proc_prf a b =
  Rewriting_complete_proc_prf (Maybe [(Term a b, Term a b)])
    (Term a b, Term a b) (Term a b, Term a b) (Term a b, Term a b)
    (Term a b, Term a b) Pos;

data Narrowing_complete_proc_prf a b =
  Narrowing_complete_proc_prf (Term a b, Term a b) Pos [(Term a b, Term a b)];

data Fp_loop_prf a b =
  FP_loop_prf (Ctxt a b) [(b, Term a b)] (Term a b)
    [(Pos, ((Term a b, Term a b), Term a b))];

data Not_wn_ta_prf a b = Not_wn_ta_prf (Tree_automaton b a) (Ta_relation b);

data Dp_proof_step a = OC1 ([a], [a]) Bool
  | OC2 ([a], [a]) ([a], [a]) ([a], [a]) [a] [a] [a]
  | OC2p ([a], [a]) ([a], [a]) ([a], [a]) [a] [a] [a]
  | OC3 ([a], [a]) ([a], [a]) ([a], [a]) [a] [a]
  | OC3p ([a], [a]) ([a], [a]) ([a], [a]) [a] [a]
  | OCDP1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a])
  | OCDP2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a])
  | WPEQ (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
  | Lift (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
  | DPOC1_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC1_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a] [a]
  | DPOC2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC3_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC3_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a] [a]
  | DPDP1_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP1_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP2_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP2_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a]
      [a];

data Non_loop_srs_proof a = SE_OC ([a], [a]) [a] [a] [Dp_proof_step a]
  | SE_DP (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a]
      [a] [Dp_proof_step a];

data Uncurry_nt_proof a b c =
  Uncurry_nt_proof
    (Lab a b,
      ([((Lab a b, Nat), [Lab a b])],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          [(Term (Lab a b) c, Term (Lab a b) c)])))
    [(Term (Lab a b) c, Term (Lab a b) c)];

data Rel_trs_loop_prf a b =
  Rel_trs_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), (Bool, Term a b)))]
    [(b, Term a b)] (Ctxt a b);

data Reltrs_nontermination_proof a b c = Rel_Loop (Rel_trs_loop_prf (Lab a b) c)
  | Rel_TRS_String_Reversal (Reltrs_nontermination_proof a b c)
  | Rel_Not_Well_Formed
  | Rel_Rule_Removal (Rule_removal_nonterm_reltrs_prf (Lab a b) c)
      (Reltrs_nontermination_proof a b c)
  | Rel_R_Not_SN (Trs_nontermination_proof a b c)
  | Rel_TRS_Assume_Not_SN
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Trs_nontermination_proof a b c = TRS_Loop (Trs_loop_prf (Lab a b) c)
  | TRS_Not_Well_Formed
  | TRS_Rule_Removal (Rule_removal_nonterm_trs_prf (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_String_Reversal (Trs_nontermination_proof a b c)
  | TRS_Constant_String (Const_string_complete_proof (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_DP_Trans (Dp_trans_nontermination_tt_prf a b c)
      (Dp_nontermination_proof a b c)
  | TRS_Termination_Switch (Join_info (Lab a b))
      (Trs_nontermination_proof a b c)
  | TRS_Nonloop (Non_loop_prf (Lab a b) c)
  | TRS_Nonloop_SRS (Non_loop_srs_proof (Lab a b))
  | TRS_Q_Increase (Q_increase_nonterm_trs_prf (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_Uncurry (Uncurry_nt_proof a b c) (Trs_nontermination_proof a b c)
  | TRS_Not_WN_Tree_Automaton (Not_wn_ta_prf (Lab a b) c)
  | TRS_Assume_Not_SN
      (Bool, ([Term (Lab a b) c], [(Term (Lab a b) c, Term (Lab a b) c)]))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Fp_nontermination_proof a b c = FPTRS_Loop (Fp_loop_prf (Lab a b) c)
  | FPTRS_Rule_Removal (Rule_removal_nonterm_trs_prf (Lab a b) c)
      (Fp_nontermination_proof a b c)
  | FPTRS_Assume_Not_SN
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Dp_nontermination_proof a b c = DP_Loop (Dp_loop_prf (Lab a b) c)
  | DP_Nonloop (Non_loop_prf (Lab a b) c)
  | DP_Rule_Removal (Rule_removal_nonterm_dp_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Q_Increase (Q_increase_nonterm_dp_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Q_Reduction (Dp_q_reduction_nonterm_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Termination_Switch (Join_info (Lab a b)) (Dp_nontermination_proof a b c)
  | DP_Instantiation (Instantiation_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Rewriting (Rewriting_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Narrowing (Narrowing_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Assume_Infinite
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Neg_unknown_proof a b c =
  Assume_NT_Unknown [Prelude.Char]
    [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
       (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
       (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Quasi_reductive_proof a b c =
  Unravel
    [(((Term (Lab a b) c, Term (Lab a b) c),
        [(Term (Lab a b) c, Term (Lab a b) c)]),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
    (Trs_termination_proof a b c);

data Completion_proof a b c =
  SN_WCR_Eq (Join_info (Lab a b)) (Trs_termination_proof a b c)
    [((Term (Lab a b) c, Term (Lab a b) c),
       [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                (Bool, Term (Lab a b) c)))])]
    (Maybe [((Term (Lab a b) c, Term (Lab a b) c),
              [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                       (Bool, Term (Lab a b) c)))])]);

data Equational_disproof a b c =
  Completion_and_Normalization_Different [(Term (Lab a b) c, Term (Lab a b) c)]
    (Completion_proof a b c);

data Nonreachability_proof a b = Nonreachable_Tcap
  | Nonreachable_ETAC [(a, Nat)] a a (Tree_automaton (Term a b) a)
  | Nonreachable_Subst_Approx [(Term a b, Term a b)] (Nonreachability_proof a b)
  | Nonreachable_Reverse (Nonreachability_proof a b);

data Nonjoinability_proof a b = Nonjoinable_Tcap
  | Nonjoinable_Ground_NF (Nonreachability_proof a b);

data Infeasibility_proof a b =
  Infeasible_Compound_Conditions a (Nonreachability_proof a b)
  | Infeasible_Equation (Term a b) (Term a b) (Nonreachability_proof a b)
  | Infeasible_Subset [(Term a b, Term a b)] (Infeasibility_proof a b)
  | Infeasible_Rhss_Equal (Term a b) (Term a b) (Term a b)
      (Nonjoinability_proof a b);

data Ao_infeasibility_proof a b =
  AO_Infeasibility_Proof (Infeasibility_proof a b)
  | AO_Lhss_Equal (Term a b) (Term a b) (Term a b) (Nonjoinability_proof a b);

data Conditional_cr_proof a b c =
  Unravel_CR
    [(((Term (Lab a b) c, Term (Lab a b) c),
        [(Term (Lab a b) c, Term (Lab a b) c)]),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
    (Cr_proof a b c)
  | Almost_Orthogonal_CR
  | Almost_Orthogonal_Modulo_Infeasibility_CR
      [([(Term (Lab a b) c, Term (Lab a b) c)],
         Infeasibility_proof (Lab a b) c)]
  | Almost_Orthogonal_Modulo_Infeasibility_CRa
      [([(Term (Lab a b) c, Term (Lab a b) c)],
         ([(Term (Lab a b) c, Term (Lab a b) c)],
           Ao_infeasibility_proof (Lab a b) c))];

data Ac_dependency_pairs_proof a b =
  AC_dependency_pairs_proof [(Term a b, Term a b)] [(Term a b, Term a b)]
    [(Term a b, Term a b)] [(Term a b, Term a b)];

data Ac_dp_termination_proof a b = AC_P_is_Empty
  | AC_Subterm_Proc [((a, Nat), [Nat])] [(Term a b, Term a b)]
      (Ac_dp_termination_proof a b)
  | AC_Redpair_UR_Proc (Redtriple_impl a) [(Term a b, Term a b)]
      [(Term a b, Term a b)] (Ac_dp_termination_proof a b)
  | AC_Mono_Redpair_UR_Proc (Redtriple_impl a) [(Term a b, Term a b)]
      [(Term a b, Term a b)] [(Term a b, Term a b)]
      (Ac_dp_termination_proof a b)
  | AC_Dep_Graph_Proc
      [(Maybe (Ac_dp_termination_proof a b), [(Term a b, Term a b)])];

data Ac_termination_proof a b c =
  AC_DP_Trans (Ac_dependency_pairs_proof (Lab a b) c)
    (Ac_dp_termination_proof (Lab a b) c) (Ac_dp_termination_proof (Lab a b) c)
  | AC_DP_Trans_Single (Ac_dependency_pairs_proof (Lab a b) c)
      (Ac_dp_termination_proof (Lab a b) c)
  | AC_Rule_Removal (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Ac_termination_proof a b c)
  | AC_R_is_Empty;

data Eq_proof a b = Refl (Term a b) | Sym (Eq_proof a b)
  | Trans (Eq_proof a b) (Eq_proof a b)
  | Assm (Term a b, Term a b) (b -> Term a b) | Cong a [Eq_proof a b];

data Equational_proof a b c = Equational_Proof_Tree (Eq_proof (Lab a b) c)
  | Completion_and_Normalization [(Term (Lab a b) c, Term (Lab a b) c)]
      (Completion_proof a b c)
  | Conversion
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), (Bool, Term (Lab a b) c)))]
  | Conversion_With_History
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                  (Bool, Term (Lab a b) c)))])];

data Dt_transformation_info a b =
  DT_Transformation_Info [((Term a b, Term a b), (Term a b, Term a b))]
    [((Term a b, Term a b), (Term a b, Term a b))] [Term a b];

data Wdp_trans_info a b =
  WDP_Trans_Info (Set (a, Nat)) [((Term a b, Term a b), (Term a b, Term a b))]
    [((Term a b, Term a b), (Term a b, Term a b))] [Term a b];

data Complexity_proof a b c =
  Rule_Shift_Complexity (Redtriple_impl (Lab a b))
    [(Term (Lab a b) c, Term (Lab a b) c)]
    (Maybe [(Term (Lab a b) c, Term (Lab a b) c)]) (Complexity_proof a b c)
  | RisEmpty_Complexity
  | Remove_Nonapplicable_Rules_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c)
  | Matchbounds_Complexity (Bounds_info (Lab a b) c)
  | Matchbounds_Rel_Complexity (Bounds_info (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Complexity_proof a b c)
  | DT_Transformation (Dt_transformation_info (Lab a b) c)
      (Complexity_proof a b c)
  | WDP_Transformation (Wdp_trans_info (Lab a b) c) (Complexity_proof a b c)
  | Complexity_Assumption
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            (Complexity_measure (Lab a b) c, Complexity_class))))
      [Generic_assm_proof a b c (Complexity_proof a b c) () () () ()]
  | Usable_Rules_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c)
  | Split_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c) (Complexity_proof a b c);

data Cert_problem a b c =
  TRS_Termination_Proof Bool (Strategy (Lab a b) c)
    [(Term (Lab a b) c, Term (Lab a b) c)]
    (Maybe [(Term (Lab a b) c, Term (Lab a b) c)]) (Trs_termination_proof a b c)
  | Complexity_Proof (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Complexity_measure (Lab a b) c) Complexity_class (Complexity_proof a b c)
  | DP_Termination_Proof Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | DP_Nontermination_Proof Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      (Strategy (Lab a b) c) [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_nontermination_proof a b c)
  | TRS_Nontermination_Proof Bool (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_nontermination_proof a b c)
  | Outermost_Termination_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Fptrs_termination_proof a b c)
  | Outermost_Nontermination_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Fp_nontermination_proof a b c)
  | CS_Termination_Proof [((Lab a b, Nat), [Nat])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fptrs_termination_proof a b c)
  | CS_Nontermination_Proof [((Lab a b, Nat), [Nat])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fp_nontermination_proof a b c)
  | FP_Termination_Proof [(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fptrs_termination_proof a b c)
  | FP_Nontermination_Proof [(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fp_nontermination_proof a b c)
  | Relative_TRS_Nontermination_Proof Bool (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Reltrs_nontermination_proof a b c)
  | TRS_Confluence_Proof Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      (Cr_proof a b c)
  | TRS_Non_Confluence_Proof Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      (Ncr_proof a b c c)
  | Completion_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Completion_proof a b c)
  | Equational_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Term (Lab a b) c, Term (Lab a b) c) (Equational_proof a b c)
  | Equational_Disproof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Term (Lab a b) c, Term (Lab a b) c) (Equational_disproof a b c)
  | Quasi_Reductive_Proof
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
      (Quasi_reductive_proof a b c)
  | Conditional_CR_Proof
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
      (Conditional_cr_proof a b c)
  | Tree_Automata_Closed_Proof (Tree_automaton [Prelude.Char] (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Ta_relation [Prelude.Char])
  | AC_Termination_Proof [(Term (Lab a b) c, Term (Lab a b) c)] [Lab a b]
      [Lab a b] (Ac_termination_proof a b c)
  | Unknown_Proof [Prelude.Char] (Unknown_proof a b c)
  | Unknown_Disproof [Prelude.Char] (Neg_unknown_proof a b c);

data Ta_rule_impl a b = TA_rule_impl b [a] a (Rbt a ());

data Ta_impl a b =
  TA_Impl (Rbt a ()) (Rbt (b, Nat) [Ta_rule_impl a b]) [a] (Rbt a ()) [(a, a)]
    (a -> Rbt a ()) (a -> Rbt a ());

newtype Tp b a = TP
  (Bool,
    ([Term b a],
      (Bool,
        ([(Term b a, Term b a)],
          ([(Term b a, Term b a)],
            (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
              Term b a -> Bool))))));

newtype Ta_code b a = Abs_ta_code
  (Rbt b (),
    (Rbt (Ta_rule b a) (),
      (Dlist (b, b),
        (Rbt b (),
          (Rbt (a, Nat) (Rbt ([b], b) ()),
            (Bool, (b -> Rbt b (), b -> Rbt b ())))))));

data C_constraint a b =
  Conditional_C Bool (Term a b, Term a b) (Term a b, Term a b)
  | Unconditional_C Bool (Term a b, Term a b);

newtype Dpp b a = DPP
  (Bool,
    (Bool,
      ([(Term b a, Term b a)],
        ([(Term b a, Term b a)],
          ([Term b a],
            (Bool,
              (Bool,
                ([(Term b a, Term b a)],
                  ([(Term b a, Term b a)],
                    (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                      (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                        (Bool, Term b a -> Bool))))))))))));

newtype Ac_dpp b a = AC_DPP
  ([(Term b a, Term b a)],
    ([(Term b a, Term b a)],
      ([(Term b a, Term b a)],
        ([(Term b a, Term b a)],
          ([(Term b a, Term b a)],
            Rbt (b, Nat) [((), (Term b a, Term b a))])))));

data Condition_type = Bound | Strict | Non_Strict;

data Redtriple_ext a b c =
  Redtriple_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Set Nat) ((a, Nat) -> Set Nat)
    ([(Term a b, Term a b)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ([Prelude.Char] -> [Prelude.Char]) (Maybe [(a, Nat)])
    (Complexity_measure a b ->
      Complexity_class -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    c;

data Sl_ops_ext a b c d e =
  Sl_ops_ext (a -> [b] -> c) (a -> Nat -> c -> Bool) (a -> [b] -> b) [b] b
    ([(Term a d, Term a d)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    (a -> [b] -> c) (a -> Nat -> c -> Bool) (c -> [c]) (a -> Nat -> [c]) e;

data Slm_ops_ext a b c d =
  Slm_ops_ext (a -> [b] -> c) (a -> [b] -> b) [b] b (a -> [b] -> c) d;

data Tp_ops_ext a b c d =
  Tp_ops_ext
    (a -> (Bool,
            (Set (Term b c),
              (Set (Term b c, Term b c), Set (Term b c, Term b c)))))
    (a -> [Term b c]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)]) (a -> Bool)
    (a -> Term b c -> Bool) (a -> Bool)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (Bool ->
      [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> Bool) d;

data Partial_object_ext a b = Partial_object_ext (Set a) b;

data Dpp_ops_ext a b c d =
  Dpp_ops_ext
    (a -> (Bool,
            (Bool,
              (Set (Term b c, Term b c),
                (Set (Term b c, Term b c),
                  (Set (Term b c),
                    (Set (Term b c, Term b c), Set (Term b c, Term b c))))))))
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [Term b c])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> Bool) (a -> Bool) (a -> Bool)
    (a -> Term b c -> Bool) (a -> Bool)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> (b, Nat) -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)] -> a)
    (a -> (Term b c, Term b c) -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (Bool ->
      Bool ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] ->
            [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> Bool) (a -> Bool) (a -> Bool) d;

data Root_redtriple_ext a b c =
  Root_redtriple_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Set Nat) ((a, Nat) -> Set Nat)
    ([Prelude.Char] -> [Prelude.Char]) c;

data Non_inf_order_ext a b c =
  Non_inf_order_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    (C_constraint a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Nat -> Dependance) ([Prelude.Char] -> [Prelude.Char]) c;

data Ac_tp_ops_ext a b c d =
  Ac_tp_ops_ext (a -> (Set (Term b c, Term b c), (Set b, Set b)))
    (a -> [(Term b c, Term b c)]) (a -> [b]) (a -> [b])
    ([(Term b c, Term b c)] -> [b] -> [b] -> a)
    (a -> [(Term b c, Term b c)] -> a) (a -> [(Term b c, Term b c)]) d;

data Ordered_semiring_ext a b =
  Ordered_semiring_ext (a -> a -> Bool) (a -> a -> Bool) (a -> a -> a) b;

data Ac_dpp_ops_ext a b c d =
  Ac_dpp_ops_ext
    (a -> (Set (Term b c, Term b c),
            (Set (Term b c, Term b c),
              (Set (Term b c, Term b c),
                (Set (Term b c, Term b c), Set (Term b c, Term b c))))))
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)])
    ([(Term b c, Term b c)] ->
      [(Term b c, Term b c)] ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a) (a -> Bool)
    (a -> Bool) (a -> [(Term b c, Term b c)] -> a) d;

data Lpoly_order_semiring_ext a b =
  Lpoly_order_semiring_ext Bool a (a -> Bool) (a -> Bool) (a -> Nat)
    (a -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) [Prelude.Char] b;

newtype X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a =
  Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
  (Maybe ((a, Nat) -> [Nat]));

newtype
  X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
    a
  = Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
  (Maybe ((a, Nat) -> Af_entry, Set (a, Nat)));

dom :: forall a b. (Cenum a) => (a -> Maybe b) -> Set a;
dom m = collect (\ a -> not (is_none (m a)));

dlist_ex :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Bool;
dlist_ex x xc = any x (list_of_dlista xc);

rBT_Impl_rbt_ex :: forall a b. (a -> b -> Bool) -> Rbta a b -> Bool;
rBT_Impl_rbt_ex p (Branch c l k v r) =
  p k v || (rBT_Impl_rbt_ex p l || rBT_Impl_rbt_ex p r);
rBT_Impl_rbt_ex p Emptya = False;

ex :: forall a b. (Ccompare a) => (a -> b -> Bool) -> Mapping_rbt a b -> Bool;
ex xb xc = rBT_Impl_rbt_ex xb (impl_ofb xc);

bex :: forall a. (Ceq a, Ccompare a) => Set a -> (a -> Bool) -> Bool;
bex (RBT_set rbt) p =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Bex RBT_set: ccompare = None" (\ _ -> bex (RBT_set rbt) p);
    Just _ -> ex (\ k _ -> p k) rbt;
  });
bex (DList_set dxs) p =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "Bex DList_set: ceq = None"
        (\ _ -> bex (DList_set dxs) p);
    Just _ -> dlist_ex p dxs;
  });
bex (Set_Monad xs) p = any p xs;

tag :: Xml -> [Prelude.Char];
tag (XML name uu uv) = name;
tag (XML_text uw) = [];

rBT_Impl_rbt_all :: forall a b. (a -> b -> Bool) -> Rbta a b -> Bool;
rBT_Impl_rbt_all p (Branch c l k v r) =
  p k v && rBT_Impl_rbt_all p l && rBT_Impl_rbt_all p r;
rBT_Impl_rbt_all p Emptya = True;

alla :: forall a b. (Ccompare a) => (a -> b -> Bool) -> Mapping_rbt a b -> Bool;
alla xb xc = rBT_Impl_rbt_all xb (impl_ofb xc);

ball :: forall a. (Ceq a, Ccompare a) => Set a -> (a -> Bool) -> Bool;
ball (RBT_set rbt) p =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Ball RBT_set: ccompare = None" (\ _ -> ball (RBT_set rbt) p);
    Just _ -> alla (\ k _ -> p k) rbt;
  });
ball (DList_set dxs) p =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "Ball DList_set: ceq = None"
        (\ _ -> ball (DList_set dxs) p);
    Just _ -> dlist_all p dxs;
  });
ball (Set_Monad xs) p = all p xs;

returna :: forall a b. a -> Sum_bot b a;
returna x = Sumbot (Inr x);

errora :: forall a b. a -> Sum_bot a b;
errora x = Sumbot (Inl x);

int_of_digit :: Prelude.Char -> Sum_bot [Prelude.Char] Int;
int_of_digit x =
  (if x == '0' then returna zero_int
    else (if x == '1' then returna (Int_of_integer (1 :: Integer))
           else (if x == '2' then returna (Int_of_integer (2 :: Integer))
                  else (if x == '3' then returna (Int_of_integer (3 :: Integer))
                         else (if x == '4'
                                then returna (Int_of_integer (4 :: Integer))
                                else (if x == '5'
                                       then returna
      (Int_of_integer (5 :: Integer))
                                       else (if x == '6'
      then returna (Int_of_integer (6 :: Integer))
      else (if x == '7' then returna (Int_of_integer (7 :: Integer))
             else (if x == '8' then returna (Int_of_integer (8 :: Integer))
                    else (if x == '9'
                           then returna (Int_of_integer (9 :: Integer))
                           else errora
                                  [x, ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                                    'a', ' ', 'd', 'i', 'g', 'i',
                                    't']))))))))));

binda :: forall a b c. Sum_bot a b -> (b -> Sum_bot a c) -> Sum_bot a c;
binda (Sumbot a) f = (case a of {
                       Inl b -> Sumbot (Inl b);
                       Inr aa -> f aa;
                     });

int_of_string_aux :: Int -> [Prelude.Char] -> Sum_bot [Prelude.Char] Int;
int_of_string_aux n [] = returna n;
int_of_string_aux n (d : s) =
  binda (int_of_digit d)
    (\ m ->
      int_of_string_aux
        (plus_int (times_int (Int_of_integer (10 :: Integer)) n) m) s);

int_of_string :: [Prelude.Char] -> Sum_bot [Prelude.Char] Int;
int_of_string s =
  (if null s
    then errora
           ['c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'o', 'n', 'v', 'e', 'r',
             't', ' ', 'e', 'm', 'p', 't', 'y', ' ', 's', 't', 'r', 'i', 'n',
             'g', ' ', 'i', 'n', 't', 'o', ' ', 'n', 'u', 'm', 'b', 'e', 'r']
    else (if take one_nat s == ['-']
           then binda (int_of_string_aux zero_int (tla s))
                  (\ i -> returna (minus_int zero_int i))
           else int_of_string_aux zero_int s));

shows_attr ::
  ([Prelude.Char], [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_attr av =
  shows_prec_list zero_nat (fst av) .
    shows_string (['=', '\"'] ++ snd av ++ ['\"']);

shows_attrs ::
  [([Prelude.Char], [Prelude.Char])] -> [Prelude.Char] -> [Prelude.Char];
shows_attrs asa = foldr (\ a -> shows_string [' '] . shows_attr a) asa;

shows_XML_indent ::
  [Prelude.Char] -> Nat -> Xml -> [Prelude.Char] -> [Prelude.Char];
shows_XML_indent ind i (XML n a c) =
  shows_string ['\n'] .
    shows_string ind .
      shows_string ['<'] .
        shows_prec_list zero_nat n .
          shows_attrs a .
            (if null c then shows_string ['/', '>']
              else shows_string ['>'] .
                     foldr (shows_XML_indent (replicate i ' ' ++ ind) i) c .
                       shows_string ['\n'] .
                         shows_string ind .
                           shows_string ['<', '/'] .
                             shows_prec_list zero_nat n . shows_string ['>']);
shows_XML_indent ind i (XML_text t) = shows_string t;

shows_prec_xml :: Nat -> Xml -> [Prelude.Char] -> [Prelude.Char];
shows_prec_xml d xml = shows_XML_indent [] (nat_of_integer (2 :: Integer)) xml;

text :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
text tag (XML n atts [XML_text t]) =
  (if n == tag && null atts then returna t
    else errora
           (concat
             [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't',
                'r', 'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r',
                ' '],
               tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
               shows_prec_xml zero_nat (XML n atts [XML_text t]) []]));
text tag (XML v va []) =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't', 'r',
         'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r', ' '],
        tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
        shows_prec_xml zero_nat (XML v va []) []]);
text tag (XML v va (XML ve vf vg : vd)) =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't', 'r',
         'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r', ' '],
        tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
        shows_prec_xml zero_nat (XML v va (XML ve vf vg : vd)) []]);
text tag (XML v va (vc : ve : vf)) =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't', 'r',
         'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r', ' '],
        tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
        shows_prec_xml zero_nat (XML v va (vc : ve : vf)) []]);
text tag (XML_text v) =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't', 'r',
         'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r', ' '],
        tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
        shows_prec_xml zero_nat (XML_text v) []]);

int :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Int;
int tag x = binda (text tag x) int_of_string;

nata :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Nat;
nata tag x =
  binda (text tag x)
    (\ txt -> binda (int_of_string txt) (\ i -> returna (nat i)));

options ::
  forall a.
    [([Prelude.Char], Xml -> Sum_bot [Prelude.Char] a)] ->
      Xml -> Sum_bot [Prelude.Char] a;
options ps x =
  (case map_of ps (tag x) of {
    Nothing ->
      errora
        (concat
          [['e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'o', 'n', 'e', ' ',
             'o', 'f', ':', ' '],
            concatMap (\ p -> fst p ++ [' ']) ps, ['\n'],
            ['b', 'u', 't', ' ', 'f', 'o', 'u', 'n', 'd'], ['\n'],
            shows_prec_xml zero_nat x []]);
    Just p -> p x;
  });

change ::
  forall a b.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      (a -> b) -> Xml -> Sum_bot [Prelude.Char] b;
change p f x = binda (p x) (returna . f);

list2elements :: forall a. [a] -> Maybe (a, a);
list2elements [x, y] = Just (x, y);
list2elements [] = Nothing;
list2elements [v] = Nothing;
list2elements (v : vb : vd : ve) = Nothing;

fail :: forall a. [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] a;
fail tag xml =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 't', 'r', 'a', 'n',
         's', 'f', 'o', 'r', 'm', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
         'o', 'w', 'i', 'n', 'g', ' ', 'x', 'm', 'l', ' ', 'e', 'l', 'e', 'm',
         'e', 'n', 't', ' ', '(', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' '],
        tag, [')'], ['\n'], shows_prec_xml zero_nat xml []]);

pair ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> b -> c) -> Xml -> Sum_bot [Prelude.Char] c;
pair tag p1 p2 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list2elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, cs2) ->
                 binda (p1 cs1)
                   (\ a -> binda (p2 cs2) (\ b -> returna (f a b)));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

rat :: Xml -> Sum_bot [Prelude.Char] Rat;
rat = options
        [(['i', 'n', 't', 'e', 'g', 'e', 'r'],
           change (int ['i', 'n', 't', 'e', 'g', 'e', 'r']) of_int),
          (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l'],
            pair ['r', 'a', 't', 'i', 'o', 'n', 'a', 'l']
              (int ['n', 'u', 'm', 'e', 'r', 'a', 't', 'o', 'r'])
              (int ['d', 'e', 'n', 'o', 'm', 'i', 'n', 'a', 't', 'o', 'r'])
              (\ x y -> divide_rat (of_int x) (of_int y)))];

find :: forall a. (a -> Bool) -> [a] -> Maybe a;
find uu [] = Nothing;
find p (x : xs) = (if p x then Just x else find p xs);

empty :: forall a b. (Linorder a) => Rbt a b;
empty = RBT Emptya;

rbt_ins ::
  forall a b.
    (Compare_order a) => (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_ins f k v (Branch R l x y r) = (case compare k x of {
                                     Eqa -> Branch R l x (f k y v) r;
                                     Lt -> Branch R (rbt_ins f k v l) x y r;
                                     Gt -> Branch R l x y (rbt_ins f k v r);
                                   });
rbt_ins f k v (Branch B l x y r) = (case compare k x of {
                                     Eqa -> Branch B l x (f k y v) r;
                                     Lt -> balance (rbt_ins f k v l) x y r;
                                     Gt -> balance l x y (rbt_ins f k v r);
                                   });
rbt_ins f k v Emptya = Branch R Emptya k v Emptya;

rbt_insert_with_key ::
  forall a b.
    (Compare_order a) => (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_insert_with_key f k v t = paint B (rbt_ins f k v t);

sunion_with ::
  forall a b.
    (Compare_order a) => (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
sunion_with f asa [] = asa;
sunion_with f [] bs = bs;
sunion_with f ((ka, va) : asa) ((k, v) : bs) =
  (case compare k ka of {
    Eqa -> (ka, f ka va v) : sunion_with f asa bs;
    Lt -> (k, v) : sunion_with f ((ka, va) : asa) bs;
    Gt -> (ka, va) : sunion_with f asa ((k, v) : bs);
  });

rbt_union_with_key ::
  forall a b.
    (Compare_order a) => (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_union_with_key f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> folda (rbt_insert_with_key (\ k v w -> f k w v)) t1 t2;
    GT -> folda (rbt_insert_with_key f) t2 t1;
    EQ -> rbtreeify (sunion_with f (entries t1) (entries t2));
  });

rbt_union :: forall a b. (Compare_order a) => Rbta a b -> Rbta a b -> Rbta a b;
rbt_union = rbt_union_with_key (\ _ _ rv -> rv);

impl_of :: forall b a. (Linorder b) => Rbt b a -> Rbta b a;
impl_of (RBT x) = x;

union :: forall a b. (Compare_order a) => Rbt a b -> Rbt a b -> Rbt a b;
union xb xc = RBT (rbt_union (impl_of xb) (impl_of xc));

image ::
  forall a b.
    (Ceq a, Ccompare a, Ceq b, Ccompare b,
      Set_impl b) => (a -> b) -> Set a -> Set b;
image h (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "image RBT_set: ccompare = None" (\ _ -> image h (RBT_set rbt));
    Just _ -> foldb (inserta . h) rbt bot_set;
  });
image g (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "image DList_set: ceq = None" (\ _ -> image g (DList_set dxs));
    Just _ -> foldc (inserta . g) dxs bot_set;
  });
image f (Complement (Complement b)) = image f b;
image f (Collect_set a) =
  (error :: forall a. String -> (() -> a) -> a) "image Collect_set"
    (\ _ -> image f (Collect_set a));
image f (Set_Monad xs) = Set_Monad (map f xs);

zip_option :: forall a b. [a] -> [b] -> Maybe [(a, b)];
zip_option [] [] = Just [];
zip_option (x : xs) (y : ys) =
  bind (zip_option xs ys) (\ zs -> Just ((x, y) : zs));
zip_option (x : xs) [] = Nothing;
zip_option [] (y : ys) = Nothing;

guarda :: Bool -> Maybe ();
guarda b = (if b then Just () else Nothing);

match_lista ::
  forall a b. (Eq a) => [(Gctxt a b, Term a b)] -> Maybe [(Gctxt a b, b)];
match_lista ((GCFun f ss, Var x) : ps) =
  bind (match_lista ps) (\ psa -> Just ((GCFun f ss, x) : psa));
match_lista ((GCFun f ss, Fun g ts) : ps) =
  bind (guarda (f == g))
    (\ _ -> bind (zip_option ss ts) (\ psa -> match_lista (psa ++ ps)));
match_lista ((GCHole, t) : ps) = match_lista ps;
match_lista [] = Just [];

merge_lists ::
  forall a b. (Eq a) => [Gctxt a b] -> [Gctxt a b] -> Maybe [Gctxt a b];
merge_lists (c : cs) [] = Nothing;
merge_lists [] (d : ds) = Nothing;
merge_lists (GCFun f ss : cs) (GCFun g ts : ds) =
  bind (guarda (f == g))
    (\ _ ->
      bind (merge_lists ss ts)
        (\ us -> bind (merge_lists cs ds) (\ es -> Just (GCFun f us : es))));
merge_lists (c : cs) (GCHole : ds) =
  bind (merge_lists cs ds) (\ es -> Just (c : es));
merge_lists (GCHole : cs) (d : ds) =
  bind (merge_lists cs ds) (\ es -> Just (d : es));
merge_lists [] [] = Just [];

merge :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Maybe (Gctxt a b);
merge c d = bind (merge_lists [c] [d]) (\ es -> Just (nth es zero_nat));

merge_var ::
  forall a b.
    (Eq a,
      Eq b) => a -> Gctxt b a ->
                      [(Gctxt b a, a)] ->
                        Maybe ((Gctxt b a, a), [(Gctxt b a, a)]);
merge_var x c ((d, y) : ps) =
  (if x == y then bind (merge c d) (\ e -> merge_var x e ps)
    else bind (merge_var x c ps) (\ (b, psa) -> Just (b, (d, y) : psa)));
merge_var x c [] = Just ((c, x), []);

merge_all ::
  forall a b. (Eq a, Eq b) => [(Gctxt a b, b)] -> Maybe [(Gctxt a b, b)];
merge_all [] = Just [];
merge_all ((c, x) : ps) =
  bind (merge_var x c ps)
    (\ (cx, psa) -> bind (merge_all psa) (\ psb -> Just (cx : psb)));

matchc ::
  forall a b. (Eq a, Eq b) => (Gctxt a b, Term a b) -> Maybe [(Gctxt a b, b)];
matchc (c, t) = bind (match_lista [(c, t)]) merge_all;

matchb :: forall a b. (Eq a, Eq b) => Gctxt a b -> Term a b -> Bool;
matchb c t = not (is_none (matchc (c, t)));

tcap ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Set (Term a b, Term a b) -> Term a b -> Gctxt a b;
tcap uu (Var uv) = GCHole;
tcap r (Fun f ts) =
  let {
    h = GCFun f (map (tcap r) ts);
  } in (if bex r (\ ra -> matchb h (fst ra)) then GCHole else h);

root :: forall a b. Term a b -> Maybe (a, Nat);
root (Var x) = Nothing;
root (Fun f ts) = Just (f, size_list ts);

bool_of_string :: [Prelude.Char] -> Sum_bot [Prelude.Char] Bool;
bool_of_string s =
  (if s == ['t', 'r', 'u', 'e'] then returna True
    else (if s == ['f', 'a', 'l', 's', 'e'] then returna False
           else errora
                  (['c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'o', 'n', 'v', 'e',
                     'r', 't', ' '] ++
                    s ++ [' ', 'i', 'n', 't', 'o', ' ', 'B', 'o', 'o', 'l', 'e',
                           'a', 'n'])));

bool :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Bool;
bool tag node = binda (text tag node) bool_of_string;

leaf :: forall a. [Prelude.Char] -> a -> Xml -> Sum_bot [Prelude.Char] a;
leaf tag x (XML name atts cs) =
  (if name == tag && null atts && null cs then returna x
    else fail tag (XML name atts cs));
leaf tag x (XML_text v) = fail tag (XML_text v);

map_sum_bot :: forall a b c. (a -> Sum_bot b c) -> [a] -> Sum_bot b [c];
map_sum_bot f [] = returna [];
map_sum_bot f (x : xs) =
  binda (f x) (\ y -> binda (map_sum_bot f xs) (\ ys -> returna (y : ys)));

many ::
  forall a b.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        ([a] -> b) -> Xml -> Sum_bot [Prelude.Char] b;
many tag p f (XML name atts cs) =
  (if name == tag && null atts then binda (map_sum_bot p cs) (returna . f)
    else fail tag (XML name atts cs));
many tag p f (XML_text v) = fail tag (XML_text v);

col :: forall a. Mat a -> Nat -> Vec a;
col a j = vec (mat_dim_row a) (\ i -> mat_index a (i, j));

row :: forall a. Mat a -> Nat -> Vec a;
row a i = vec (mat_dim_col a) (\ j -> mat_index a (i, j));

funpow :: forall a. Nat -> (a -> a) -> a -> a;
funpow n f =
  (if equal_nat n zero_nat then id else f . funpow (minus_nat n one_nat) f);

rbt_del :: forall a b. (Compare_order a) => a -> Rbta a b -> Rbta a b;
rbt_del x (Branch c a y s b) = (case compare x y of {
                                 Eqa -> combine a b;
                                 Lt -> rbt_del_from_left x a y s b;
                                 Gt -> rbt_del_from_right x a y s b;
                               });
rbt_del x Emptya = Emptya;

rbt_del_from_left ::
  forall a b.
    (Compare_order a) => a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_left x (Branch B lt z v rt) y s b =
  balance_left (rbt_del x (Branch B lt z v rt)) y s b;
rbt_del_from_left x Emptya y s b = Branch R (rbt_del x Emptya) y s b;
rbt_del_from_left x (Branch R va vb vc vd) y s b =
  Branch R (rbt_del x (Branch R va vb vc vd)) y s b;

rbt_del_from_right ::
  forall a b.
    (Compare_order a) => a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_right x a y s (Branch B lt z v rt) =
  balance_right a y s (rbt_del x (Branch B lt z v rt));
rbt_del_from_right x a y s Emptya = Branch R a y s (rbt_del x Emptya);
rbt_del_from_right x a y s (Branch R va vb vc vd) =
  Branch R a y s (rbt_del x (Branch R va vb vc vd));

rbt_delete :: forall a b. (Compare_order a) => a -> Rbta a b -> Rbta a b;
rbt_delete k t = paint B (rbt_del k t);

delete :: forall a b. (Compare_order a) => a -> Rbt a b -> Rbt a b;
delete xb xc = RBT (rbt_delete xb (impl_of xc));

rbt_insert :: forall a b. (Compare_order a) => a -> b -> Rbta a b -> Rbta a b;
rbt_insert = rbt_insert_with_key (\ _ _ nv -> nv);

insert :: forall a b. (Compare_order a) => a -> b -> Rbt a b -> Rbt a b;
insert xc xd xe = RBT (rbt_insert xc xd (impl_of xe));

rbt_lookup :: forall a b. (Compare_order a) => Rbta a b -> a -> Maybe b;
rbt_lookup (Branch uu l x y r) k = (case compare k x of {
                                     Eqa -> Just y;
                                     Lt -> rbt_lookup l k;
                                     Gt -> rbt_lookup r k;
                                   });
rbt_lookup Emptya k = Nothing;

lookup :: forall a b. (Compare_order a) => Rbt a b -> a -> Maybe b;
lookup x = rbt_lookup (impl_of x);

proja :: forall a b. Term a b -> Nat -> Term a b;
proja (Fun f ts) i = (if less_nat i (size_list ts) then nth ts i else Fun f ts);

filtera :: forall a. (Ceq a, Ccompare a) => (a -> Bool) -> Set a -> Set a;
filtera p a = inf_set a (Collect_set p);

subst :: forall a b. (Eq a) => a -> Term b a -> a -> Term b a;
subst x t = fun_upd Var x t;

debug :: forall a. [Prelude.Char] -> [Prelude.Char] -> a -> a;
debug i t x = x;

guard ::
  forall a.
    (Xml -> Bool) ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] a;
guard p p1 p2 x = (if p x then p1 x else p2 x);

many1_gen ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> [b] -> c) -> Xml -> Sum_bot [Prelude.Char] c;
many1_gen tag p1 p2 f (XML name atts cs) =
  (if name == tag && null atts && not (null cs)
    then let {
           (h : t) = cs;
         } in binda (p1 h)
                (\ x -> binda (map_sum_bot (p2 x) t) (\ xs -> returna (f x xs)))
    else fail tag (XML name atts cs));
many1_gen tag p1 p2 f (XML_text v) = fail tag (XML_text v);

many1 ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> [b] -> c) -> Xml -> Sum_bot [Prelude.Char] c;
many1 tag p1 p2 = many1_gen tag p1 (\ _ -> p2);

length_ge_2 :: forall a. [a] -> Bool;
length_ge_2 (uu : uv : uw) = True;
length_ge_2 [] = False;
length_ge_2 [v] = False;

many2 ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> b -> [c] -> d) -> Xml -> Sum_bot [Prelude.Char] d;
many2 tag p1 p2 p3 f (XML name atts cs) =
  (if name == tag && null atts && length_ge_2 cs
    then let {
           (cs0 : cs1 : t) = cs;
         } in binda (p1 cs0)
                (\ x ->
                  binda (p2 cs1)
                    (\ y ->
                      binda (map_sum_bot p3 t) (\ xs -> returna (f x y xs))))
    else fail tag (XML name atts cs));
many2 tag p1 p2 p3 f (XML_text v) = fail tag (XML_text v);

cnj :: Complex -> Complex;
cnj z = Complex (re z) (uminus_real (im z));

emptya :: forall a. Dlist a;
emptya = Dlist [];

insertb :: forall a. (Eq a) => a -> [a] -> [a];
insertb x xs = (if membera xs x then xs else x : xs);

lterms ::
  forall a b. ((a, Nat) -> [(Nat, Nat)]) -> Term a b -> [(Term a b, Nat)];
lterms pi =
  (\ (Fun f ts) ->
    map (\ (i, a) -> (proja (Fun f ts) i, a)) (pi (f, size_list ts)));

ground :: forall a b. Term a b -> Bool;
ground (Var x) = False;
ground (Fun f ts) = all ground ts;

insert_vars_term :: forall a b. (Eq b) => Term a b -> [b] -> [b];
insert_vars_term (Var x) xs = insertb x xs;
insert_vars_term (Fun f ts) xs = foldr insert_vars_term ts xs;

is_Var :: forall a b. Term a b -> Bool;
is_Var (Var x1) = True;
is_Var (Fun x21 x22) = False;

wf_rule :: forall a b. (Eq b) => (Term a b, Term a b) -> Bool;
wf_rule r =
  not (is_Var (fst r)) &&
    all (membera (insert_vars_term (fst r) [])) (insert_vars_term (snd r) []);

fun_of :: forall a b. (Eq a) => [(a, b)] -> a -> b;
fun_of vec x = the (map_of vec x);

letters :: [Prelude.Char];
letters =
  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',
    'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', '0', '1', '2', '3', '4', '5', '6',
    '7', '8', '9', '&', ';', ':', '-'];

catch_error :: forall a b c. Sum_bot a b -> (a -> Sum_bot c b) -> Sum_bot c b;
catch_error (Sumbot a) f = (case a of {
                             Inl aa -> f aa;
                             Inr aa -> Sumbot (Inr aa);
                           });

choice ::
  forall a.
    [Prelude.Char] ->
      [Xml -> Sum_bot [Prelude.Char] a] -> Xml -> Sum_bot [Prelude.Char] a;
choice e [] x =
  errora
    (concat
      [['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'p', 'a', 'r', 's', 'i',
         'n', 'g', ' ', 'c', 'h', 'o', 'i', 'c', 'e', ' ', 'f', 'o', 'r', ' '],
        e, ['\n'], shows_prec_xml zero_nat x []]);
choice e (p : ps) x = catch_error (p x) (\ _ -> choice e ps x);

list3elements :: forall a. [a] -> Maybe (a, (a, a));
list3elements [x, y, z] = Just (x, (y, z));
list3elements [] = Nothing;
list3elements [v] = Nothing;
list3elements [v, vb] = Nothing;
list3elements (v : vb : vd : vf : vg) = Nothing;

triple ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> b -> c -> d) -> Xml -> Sum_bot [Prelude.Char] d;
triple tag p1 p2 p3 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list3elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, (cs2, cs3)) ->
                 binda (p1 cs1)
                   (\ a ->
                     binda (p2 cs2)
                       (\ b -> binda (p3 cs3) (\ c -> returna (f a b c))));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

list4elements :: forall a. [a] -> Maybe (a, (a, (a, a)));
list4elements [x, y, z, u] = Just (x, (y, (z, u)));
list4elements [] = Nothing;
list4elements [v] = Nothing;
list4elements [v, vb] = Nothing;
list4elements [v, vb, vd] = Nothing;
list4elements (v : vb : vd : vf : vh : vi) = Nothing;

tuple4 ::
  forall a b c d e.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (a -> b -> c -> d -> e) -> Xml -> Sum_bot [Prelude.Char] e;
tuple4 tag p1 p2 p3 p4 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list4elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, (cs2, (cs3, cs4))) ->
                 binda (p1 cs1)
                   (\ a ->
                     binda (p2 cs2)
                       (\ b ->
                         binda (p3 cs3)
                           (\ c ->
                             binda (p4 cs4) (\ d -> returna (f a b c d)))));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

list5elements :: forall a. [a] -> Maybe (a, (a, (a, (a, a))));
list5elements [x, y, z, u, v] = Just (x, (y, (z, (u, v))));
list5elements [] = Nothing;
list5elements [v] = Nothing;
list5elements [v, vb] = Nothing;
list5elements [v, vb, vd] = Nothing;
list5elements [v, vb, vd, vf] = Nothing;
list5elements (v : vb : vd : vf : vh : vj : vk) = Nothing;

tuple5 ::
  forall a b c d e f.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (Xml -> Sum_bot [Prelude.Char] e) ->
                (a -> b -> c -> d -> e -> f) -> Xml -> Sum_bot [Prelude.Char] f;
tuple5 tag p1 p2 p3 p4 p5 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list5elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, (cs2, (cs3, (cs4, cs5)))) ->
                 binda (p1 cs1)
                   (\ a ->
                     binda (p2 cs2)
                       (\ b ->
                         binda (p3 cs3)
                           (\ c ->
                             binda (p4 cs4)
                               (\ d ->
                                 binda (p5 cs5)
                                   (\ e -> returna (f a b c d e))))));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

list6elements :: forall a. [a] -> Maybe (a, (a, (a, (a, (a, a)))));
list6elements [x, y, z, u, v, w] = Just (x, (y, (z, (u, (v, w)))));
list6elements [] = Nothing;
list6elements [v] = Nothing;
list6elements [v, vb] = Nothing;
list6elements [v, vb, vd] = Nothing;
list6elements [v, vb, vd, vf] = Nothing;
list6elements [v, vb, vd, vf, vh] = Nothing;
list6elements (v : vb : vd : vf : vh : vj : vl : vm) = Nothing;

tuple6 ::
  forall a b c d e f g.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (Xml -> Sum_bot [Prelude.Char] e) ->
                (Xml -> Sum_bot [Prelude.Char] f) ->
                  (a -> b -> c -> d -> e -> f -> g) ->
                    Xml -> Sum_bot [Prelude.Char] g;
tuple6 tag p1 p2 p3 p4 p5 p6 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list6elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, (cs2, (cs3, (cs4, (cs5, cs6))))) ->
                 binda (p1 cs1)
                   (\ a ->
                     binda (p2 cs2)
                       (\ b ->
                         binda (p3 cs3)
                           (\ c ->
                             binda (p4 cs4)
                               (\ d ->
                                 binda (p5 cs5)
                                   (\ e ->
                                     binda (p6 cs6)
                                       (\ ff -> returna (f a b c d e ff)))))));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

hd :: forall a. (Ceq a) => Set_dlist a -> a;
hd xa = hda (list_of_dlista xa);

tl :: forall a. (Ceq a) => Set_dlist a -> Set_dlist a;
tl xa = Abs_dlist (tla (list_of_dlista xa));

list_of_dlist :: forall a. Dlist a -> [a];
list_of_dlist (Dlist x) = x;

insertc :: forall a. (Eq a) => a -> Dlist a -> Dlist a;
insertc x dxs = Dlist (insertb x (list_of_dlist dxs));

foldli :: forall a b. [a] -> (b -> Bool) -> (a -> b -> b) -> b -> b;
foldli [] c f sigma = sigma;
foldli (x : xs) c f sigma =
  (if c sigma then foldli xs c f (f x sigma) else sigma);

scf_list :: forall a. (Nat -> Nat) -> [a] -> [a];
scf_list scf xs =
  concatMap (\ (x, i) -> replicate (scf i) x)
    (zip xs (upt zero_nat (size_list xs)));

scf_term :: forall a b. ((a, Nat) -> Nat -> Nat) -> Term a b -> Term a b;
scf_term scf (Var x) = Var x;
scf_term scf (Fun f ts) =
  Fun f (scf_list (scf (f, size_list ts)) (map (scf_term scf) ts));

butlast :: forall a. [a] -> [a];
butlast [] = [];
butlast (x : xs) = (if null xs then [] else x : butlast xs);

extract :: forall a. (a -> Bool) -> [a] -> Maybe ([a], (a, [a]));
extract p (x : xs) =
  (if p x then Just ([], (x, xs))
    else (case extract p xs of {
           Nothing -> Nothing;
           Just (ys, (y, zs)) -> Just (x : ys, (y, zs));
         }));
extract p [] = Nothing;

productb ::
  forall a b. (Ceq a, Ceq b) => Set_dlist a -> Set_dlist b -> Set_dlist (a, b);
productb dxs1 dxs2 =
  Abs_dlist (foldc (\ a -> foldc (\ c -> (\ b -> (a, c) : b)) dxs2) dxs1 []);

rbt_product ::
  forall a b c d e.
    (a -> b -> c -> d -> e) -> Rbta a b -> Rbta c d -> Rbta (a, c) e;
rbt_product f rbt1 rbt2 =
  rbtreeify
    (reverse
      (folda (\ a b -> folda (\ c d -> (\ e -> ((a, c), f a b c d) : e)) rbt2)
        rbt1 []));

productd ::
  forall a d b e c.
    (Ccompare a,
      Ccompare b) => (a -> d -> b -> e -> c) ->
                       Mapping_rbt a d ->
                         Mapping_rbt b e -> Mapping_rbt (a, b) c;
productd xc xd xe = Mapping_RBTa (rbt_product xc (impl_ofb xd) (impl_ofb xe));

producta ::
  forall a b.
    (Ccompare a,
      Ccompare b) => Mapping_rbt a () ->
                       Mapping_rbt b () -> Mapping_rbt (a, b) ();
producta rbt1 rbt2 = productd (\ _ _ _ _ -> ()) rbt1 rbt2;

productc ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Set a -> Set b -> Set (a, b);
productc (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set RBT_set: ccompare1 = None"
        (\ _ -> productc (RBT_set rbt1) (RBT_set rbt2));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "product RBT_set RBT_set: ccompare2 = None"
            (\ _ -> productc (RBT_set rbt1) (RBT_set rbt2));
        Just _ -> RBT_set (producta rbt1 rbt2);
      });
  });
productc a2 (RBT_set rbt2) =
  (case (ccompare :: Maybe (b -> b -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set: ccompare2 = None" (\ _ -> productc a2 (RBT_set rbt2));
    Just _ -> foldb (\ y -> sup_set (image (\ x -> (x, y)) a2)) rbt2 bot_set;
  });
productc (RBT_set rbt1) b2 =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set: ccompare1 = None" (\ _ -> productc (RBT_set rbt1) b2);
    Just _ -> foldb (\ x -> sup_set (image (\ a -> (x, a)) b2)) rbt1 bot_set;
  });
productc (DList_set dxs) (DList_set dys) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set DList_set: ceq1 = None"
        (\ _ -> productc (DList_set dxs) (DList_set dys));
    Just _ ->
      (case (ceq :: Maybe (b -> b -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "product DList_set DList_set: ceq2 = None"
            (\ _ -> productc (DList_set dxs) (DList_set dys));
        Just _ -> DList_set (productb dxs dys);
      });
  });
productc a1 (DList_set dys) =
  (case (ceq :: Maybe (b -> b -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set2: ceq = None" (\ _ -> productc a1 (DList_set dys));
    Just _ -> foldc (\ y -> sup_set (image (\ x -> (x, y)) a1)) dys bot_set;
  });
productc (DList_set dxs) b1 =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set1: ceq = None" (\ _ -> productc (DList_set dxs) b1);
    Just _ -> foldc (\ x -> sup_set (image (\ a -> (x, a)) b1)) dxs bot_set;
  });
productc (Set_Monad xs) (Set_Monad ys) =
  Set_Monad (fold (\ x -> fold (\ y -> (\ a -> (x, y) : a)) ys) xs []);
productc a b = Collect_set (\ (x, y) -> member x a && member y b);

set_Cons ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Set a -> Set [a] -> Set [a];
set_Cons a xs =
  image (\ (aa, b) -> aa : b)
    (productc (inf_set (image (\ x -> x) a) top_set)
      (inf_set top_set (image (\ xsa -> xsa) xs)));

listset :: forall a. (Ceq a, Ccompare a, Set_impl a) => [Set a] -> Set [a];
listset [] = inserta [] (set_empty (of_phantom set_impl_list));
listset (a : asa) = set_Cons a (listset asa);

remdups :: forall a. (Eq a) => [a] -> [a];
remdups [] = [];
remdups (x : xs) = (if membera xs x then remdups xs else x : remdups xs);

l2m_lookup ::
  forall a b c. (Eq a, Eq b) => [(a, [(b, c)])] -> (a, b) -> Maybe c;
l2m_lookup [] uu = Nothing;
l2m_lookup ((a, kvs) : rec) (k1, k2) = (case k1 == a of {
 True -> map_of kvs k2;
 False -> l2m_lookup rec (k1, k2);
                                       });

lm_store_acc ::
  forall a b. (Eq a) => [(a, b)] -> (a, b) -> [(a, b)] -> [(a, b)];
lm_store_acc [] kv accu = kv : accu;
lm_store_acc ((a, uu) : rec) (k, v) accu =
  (case k == a of {
    True -> accu;
    False -> lm_store_acc rec (k, v) accu;
  });

lm_store :: forall a b. (Eq a) => [(a, b)] -> (a, b) -> [(a, b)];
lm_store m kv = lm_store_acc m kv m;

l2m_store ::
  forall a b c.
    (Eq a, Eq b) => [(a, [(b, c)])] -> ((a, b), c) -> [(a, [(b, c)])];
l2m_store [] ((k1, k2), v) = [(k1, [(k2, v)])];
l2m_store ((a, kvs) : rec) ((k1, k2), v) =
  (case k1 == a of {
    True -> (a, lm_store kvs (k2, v)) : rec;
    False -> (a, kvs) : l2m_store rec ((k1, k2), v);
  });

l2m :: forall a b c. (Eq a, Eq b) => Memory_ext [(a, [(b, c)])] (a, b) c ();
l2m = Memory_ext (\ _ -> []) l2m_lookup l2m_store ();

aux ::
  forall a b.
    (Eq a,
      Compare_order b) => (a -> Maybe b) ->
                            Rbt b [a] -> a -> Rbt b [a] -> Rbt b [a];
aux key ma v m =
  (case key v of {
    Nothing -> m;
    Just k ->
      (case lookup ma k of {
        Nothing -> m;
        Just ws ->
          (if membera ws v then (case lookup m k of {
                                  Nothing -> insert k [v] m;
                                  Just vs -> insert k (insertb v vs) m;
                                })
            else m);
      });
  });

root_int_maina :: Nat -> Int -> Int -> Int -> Int -> (Int, Bool);
root_int_maina pm ipm ip x n =
  let {
    xpm = binary_power x pm;
    xp = times_int xpm x;
  } in (if less_eq_int xp n then (x, equal_int xp n)
         else root_int_maina pm ipm ip
                (divide_int (plus_int (divide_int n xpm) (times_int x ipm)) ip)
                n);

root_int_main :: Nat -> Int -> (Int, Bool);
root_int_main p n =
  (if equal_nat p zero_nat
    then (Int_of_integer (1 :: Integer),
           equal_int n (Int_of_integer (1 :: Integer)))
    else let {
           pm = minus_nat p one_nat;
         } in root_int_maina pm (int_of_nat pm) (int_of_nat p) (start_value n p)
                n);

root_int_ceiling_pos :: Nat -> Int -> Int;
root_int_ceiling_pos p x =
  (if equal_nat p zero_nat then zero_int
    else (case root_int_main p x of {
           (y, True) -> y;
           (y, False) -> plus_int y (Int_of_integer (1 :: Integer));
         }));

root_int_floor_pos :: Nat -> Int -> Int;
root_int_floor_pos p x =
  (if equal_nat p zero_nat then zero_int else fst (root_int_main p x));

root_int_floor :: Nat -> Int -> Int;
root_int_floor p x =
  (if less_eq_int zero_int x then root_int_floor_pos p x
    else uminus_int (root_int_ceiling_pos p (uminus_int x)));

root_rat_floor :: Nat -> Rat -> Int;
root_rat_floor p x =
  let {
    (a, b) = quotient_of x;
  } in divide_int
         (root_int_floor p (times_int a (binary_power b (minus_nat p one_nat))))
         b;

root_rat_ceiling :: Nat -> Rat -> Int;
root_rat_ceiling p x = uminus_int (root_rat_floor p (uminus_rat x));

initial_upper_bound :: Nat -> Rat -> Rat;
initial_upper_bound n r = of_int (root_rat_ceiling n r);

initial_lower_bound :: Nat -> Rat -> Rat;
initial_lower_bound n l =
  (if less_eq_rat l one_rat then l else of_int (root_rat_floor n l));

tighten_bound_root ::
  Nat ->
    Poly Rat ->
      Poly Rat ->
        Root_info ->
          (Rat -> Rat -> Nat) ->
            (Rat -> Rat -> Nat) ->
              (Rat, Rat) ->
                (Rat, Rat) -> (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
tighten_bound_root n pa p ri cra cr rbnd pbnd =
  let {
    ((l, r), (la, ra)) = (rbnd, pbnd);
  } in (if equal_nat (cra l r) one_nat then (Arbitrary_Poly, (ri, (pa, (l, r))))
         else let {
                m = divide_rat (plus_rat l r)
                      (of_int (Int_of_integer (2 :: Integer)));
                ma = binary_power m n;
              } in (if less_eq_rat la ma &&
                         less_eq_rat ma ra && equal_rat (poly p ma) zero_rat
                     then (Arbitrary_Poly,
                            (poly_rat_root_info m, (poly_rat m, (m, m))))
                     else let {
                            (laa, raa) = tighten_poly_bounds_for_x cr ma la ra;
                          } in (if less_rat ma laa
                                 then tighten_bound_root n pa p ri cra cr (m, r)
(laa, raa)
                                 else tighten_bound_root n pa p ri cra cr (l, m)
(laa, raa))));

poly_nth_root :: forall a. (Field a, Eq a) => Nat -> Poly a -> Poly a;
poly_nth_root n p = pcompose p (monom onea n);

root_rai_fun_pos ::
  Nat ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
root_rai_fun_pos n =
  map_option
    (\ (_, (ri, (p, (l, r)))) ->
      let {
        pa = poly_nth_root n p;
        ria = count_roots_interval_rat pa;
      } in rai_normalize_poly_flat Uncertified_Factorization
             (tighten_bound_root n pa p ria (l_r ria) (l_r ri)
               (initial_lower_bound n l, initial_upper_bound n r) (l, r)));

sgn_rai_rat :: Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) -> Rat;
sgn_rai_rat impl = (case impl of {
                     Nothing -> zero_rat;
                     Just a -> let {
                                 (_, aa) = a;
                                 (_, ab) = aa;
                                 (_, ac) = ab;
                                 (_, ad) = ac;
                               } in sgn_rat ad;
                   });

root_rai_fun ::
  Nat ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat)))) ->
      Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
root_rai_fun n impl =
  (if equal_nat n zero_nat then of_rat_rai_fun zero_rat
    else (if less_eq_rat zero_rat (sgn_rai_rat impl)
           then root_rai_fun_pos n impl
           else uminus_rai_fun (root_rai_fun_pos n (uminus_rai_fun impl))));

root_rai :: Nat -> Real_alg_intern -> Real_alg_intern;
root_rai n xa = Abs_real_alg_intern (root_rai_fun n (rep_real_alg_intern xa));

root_radt :: Nat -> Real_alg_dt -> Real_alg_dt;
root_radt n x = real_alg_dt (root_rai n (rai_of_radt x));

root_radtc :: Nat -> Real_alg_dtc -> Real_alg_dtc;
root_radtc xb xc = Abs_real_alg_dtc (root_radt xb (rep_real_alg_dtc xc));

root_real_alg :: Nat -> Real_alg -> Real_alg;
root_real_alg xa (Abstr_real_alg x) = Abstr_real_alg (root_radtc xa x);

roota :: Nat -> Real -> Real;
roota n (Real_of x) = Real_of (root_real_alg n x);

sqrt :: Real -> Real;
sqrt = roota (nat_of_integer (2 :: Integer));

these :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set (Maybe a) -> Set a;
these a = image the (filtera (\ x -> not (is_none x)) a);

rev :: Pos -> Pos;
rev Empty = Empty;
rev (PCons i p) = append (rev p) (PCons i Empty);

key :: forall a b c. (a, (Term b c, Term b c)) -> Maybe (b, Nat);
key (uu, (Fun f ts, uv)) = Just (f, size_list ts);
key (uw, (Var ux, uy)) = Nothing;

subt_at :: forall a b. Term a b -> Pos -> Term a b;
subt_at s Empty = s;
subt_at (Fun f ss) (PCons i p) = subt_at (nth ss i) p;

supremum ::
  forall a b.
    (Ceq a, Ccompare a, Ceq b, Ccompare b, Supa b,
      Set_impl b) => Set a -> (a -> b) -> b;
supremum a f = supa (image f a);

varposs :: forall a b. Term a b -> Set Pos;
varposs (Var x) = inserta Empty (set_empty (of_phantom set_impl_pos));
varposs (Fun f ts) =
  supremum (set (upt zero_nat (size_list ts)))
    (\ i -> image (PCons i) (varposs (nth ts i)));

children :: Xml -> [Xml];
children (XML uu uv cs) = cs;
children (XML_text uw) = [];

norm_complex :: Complex -> Real;
norm_complex z =
  sqrt (plus_real (binary_power (re z) (nat_of_integer (2 :: Integer)))
         (binary_power (im z) (nat_of_integer (2 :: Integer))));

csqrt :: Complex -> Complex;
csqrt z =
  Complex
    (sqrt (divide_real (plus_real (norm_complex z) (re z))
            (of_inta (Int_of_integer (2 :: Integer)))))
    (times_real
      (if equal_real (im z) zero_real then one_real else sgn_real (im z))
      (sqrt (divide_real (minus_real (norm_complex z) (re z))
              (of_inta (Int_of_integer (2 :: Integer))))));

distinct :: forall a. (Eq a) => [a] -> Bool;
distinct [] = True;
distinct (x : xs) = not (membera xs x) && distinct xs;

single :: forall a. (Eq a) => a -> Multiset a;
single x = Bag (updatea x one_nat emptyb);

mset :: forall a. (Eq a) => [a] -> Multiset a;
mset (a : x) = plus_multiset (mset x) (single a);
mset [] = zero_multiset;

add ::
  forall a b. Partial_object_ext a (Monoid_ext a (Ring_ext a b)) -> a -> a -> a;
add (Partial_object_ext carrier (Monoid_ext mult one (Ring_ext zero add more)))
  = add;

shows_nl :: [Prelude.Char] -> [Prelude.Char];
shows_nl = shows_prec_char zero_nat '\n';

shows_pl :: Nat -> [Prelude.Char] -> [Prelude.Char];
shows_pl p = (if less_nat zero_nat p then shows_prec_char zero_nat '(' else id);

shows_pr :: Nat -> [Prelude.Char] -> [Prelude.Char];
shows_pr p = (if less_nat zero_nat p then shows_prec_char zero_nat ')' else id);

hole_pos :: forall a b. Ctxt a b -> Pos;
hole_pos Hole = Empty;
hole_pos (More f ss d ts) = PCons (size_list ss) (hole_pos d);

mk_subst ::
  forall a b c. (Eq a) => (a -> Term b c) -> [(a, Term b c)] -> a -> Term b c;
mk_subst d xts = (\ x -> (case map_of xts x of {
                           Nothing -> d x;
                           Just t -> t;
                         }));

funas_term ::
  forall a b. (Ceq a, Ccompare a, Set_impl a) => Term a b -> Set (a, Nat);
funas_term (Var uu) = bot_set;
funas_term (Fun f ts) =
  sup_set (inserta (f, size_list ts) bot_set)
    (foldr (sup_set . funas_term) ts bot_set);

funas_rule ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a) => (Term a b, Term a b) -> Set (a, Nat);
funas_rule r = sup_set (funas_term (fst r)) (funas_term (snd r));

funas_trs ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Set (Term a b, Term a b) -> Set (a, Nat);
funas_trs r = supremum r funas_rule;

vars_term ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => Term a b -> Set b;
vars_term (Var x1) = inserta x1 bot_set;
vars_term (Fun x21 x22) = supremum (set x22) vars_term;

vars_rule ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Set b;
vars_rule r = sup_set (vars_term (fst r)) (vars_term (snd r));

unapp :: forall a b. (Eq a) => a -> Term a b -> (Term a b, [Term a b]);
unapp a (Var x) = (Var x, []);
unapp a (Fun f ss) =
  (if f == a && equal_nat (size_list ss) (nat_of_integer (2 :: Integer))
    then let {
           (r, ts) = unapp a (nth ss zero_nat);
         } in (r, ts ++ [nth ss one_nat])
    else (Fun f ss, []));

update_tokens :: forall a. ([a] -> [a]) -> [a] -> Sum [Prelude.Char] ([a], [a]);
update_tokens f ts = Inr (ts, f ts);

remove_comments_aux_acc ::
  [Prelude.Char] -> Bool -> [Prelude.Char] -> [Prelude.Char];
remove_comments_aux_acc a False (c : cs) =
  (if c == '<' && take (nat_of_integer (3 :: Integer)) cs == ['!', '-', '-']
    then remove_comments_aux_acc a True (tla cs)
    else remove_comments_aux_acc (c : a) False cs);
remove_comments_aux_acc a True (c : cs) =
  (if c == '-' && take (nat_of_integer (2 :: Integer)) cs == ['-', '>']
    then remove_comments_aux_acc a False
           (drop (nat_of_integer (2 :: Integer)) cs)
    else remove_comments_aux_acc a True cs);
remove_comments_aux_acc a uu [] = a;

remove_comments_aux :: Bool -> [Prelude.Char] -> [Prelude.Char];
remove_comments_aux False (c : cs) =
  (if c == '<' && take (nat_of_integer (3 :: Integer)) cs == ['!', '-', '-']
    then remove_comments_aux True (tla cs)
    else c : remove_comments_aux False cs);
remove_comments_aux True (c : cs) =
  (if c == '-' && take (nat_of_integer (2 :: Integer)) cs == ['-', '>']
    then remove_comments_aux False (drop (nat_of_integer (2 :: Integer)) cs)
    else remove_comments_aux True cs);
remove_comments_aux uu [] = [];

remove_comments :: [Prelude.Char] -> [Prelude.Char];
remove_comments =
  (if False then reverse . remove_comments_aux_acc [] False
    else remove_comments_aux False);

returnb :: forall a b. a -> [b] -> Sum [Prelude.Char] (a, [b]);
returnb x = (\ ts -> Inr (x, ts));

bindb :: forall a b c. Sum a b -> (b -> Sum a c) -> Sum a c;
bindb m f = (case m of {
              Inl a -> Inl a;
              Inr a -> f a;
            });

bindc ::
  forall a b c.
    ([a] -> Sum [Prelude.Char] (b, [a])) ->
      (b -> [a] -> Sum [Prelude.Char] (c, [a])) ->
        [a] -> Sum [Prelude.Char] (c, [a]);
bindc m f ts = bindb (m ts) (\ (a, b) -> f a b);

shows_quote ::
  ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_quote s =
  (shows_prec_char zero_nat '\'' . s) . shows_prec_char zero_nat '\'';

scan_upto ::
  [Prelude.Char] ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
scan_upto end (t : ts) =
  (if map snd (zip end (t : ts)) == end
    then Inr (end, drop (size_list end) (t : ts))
    else bindb (scan_upto end ts) (\ (res, tsa) -> Inr (t : res, tsa)));
scan_upto end [] =
  Inl (['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 'e',
         'n', 'd', '-', 'm', 'a', 'r', 'k', 'e', 'r', ' '] ++
        shows_quote (shows_prec_list zero_nat end) []);

trim :: [Prelude.Char] -> [Prelude.Char];
trim = dropWhile (membera [' ', '\n', '\t', '\r']);

manya ::
  (Prelude.Char -> Bool) ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
manya p (t : ts) =
  (if p t then bindb (manya p ts) (\ (rs, tsa) -> Inr (t : rs, tsa))
    else Inr ([], t : ts));
manya p [] = Inr ([], []);

parse_header ::
  [Prelude.Char] -> Sum [Prelude.Char] ([[Prelude.Char]], [Prelude.Char]);
parse_header ts =
  (if take (nat_of_integer (2 :: Integer)) (trim ts) == ['<', '?']
    then bindc (scan_upto ['?', '>'])
           (\ h -> bindc parse_header (\ hs -> returnb (h : hs))) ts
    else bindc (bindc (manya (membera [' ', '\n', '\t', '\r']))
                 (\ _ -> returnb ()))
           (\ _ -> returnb []) ts);

err_expecting ::
  forall a b. (Showa a) => [Prelude.Char] -> [a] -> Sum [Prelude.Char] (b, [a]);
err_expecting msg ts =
  Inl (['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' '] ++
        msg ++
          [',', ' ', 'b', 'u', 't', ' ', 'f', 'o', 'u', 'n', 'd', ':', ' '] ++
            shows_quote
              (shows_prec_list zero_nat
                (take (nat_of_integer (30 :: Integer)) ts))
              []);

eoi :: forall a. (Showa a) => [a] -> Sum [Prelude.Char] ((), [a]);
eoi [] = Inr ((), []);
eoi (v : va) =
  err_expecting ['e', 'n', 'd', ' ', 'o', 'f', ' ', 'i', 'n', 'p', 'u', 't']
    (v : va);

exactly_aux ::
  [Prelude.Char] ->
    [Prelude.Char] ->
      [Prelude.Char] ->
        [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
exactly_aux s i (x : xs) (y : ys) =
  (if x == y then exactly_aux s i xs ys
    else err_expecting (['\"'] ++ s ++ ['\"']) i);
exactly_aux s i [] xs = Inr (s, trim xs);
exactly_aux s i (x : xs) [] = err_expecting (['\"'] ++ s ++ ['\"']) i;

exactly ::
  [Prelude.Char] ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
exactly s x = exactly_aux s x s x;

parse_attribute_value ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
parse_attribute_value =
  bindc (exactly ['\"'])
    (\ _ ->
      bindc (manya (\ y -> not ('\"' == y)))
        (\ v -> bindc (exactly ['\"']) (\ _ -> returnb v)));

errorb :: forall a b. [Prelude.Char] -> [a] -> Sum [Prelude.Char] (b, [a]);
errorb e = (\ _ -> Inl e);

letters_impl :: Prelude.Char -> Bool;
letters_impl c =
  'a' <= c && c <= 'z' ||
    ('A' <= c && c <= 'Z' ||
      ('0' <= c && c <= '9' || membera ['_', '&', ';', ':', '-'] c));

parse_name ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
parse_name s =
  bindc (manya letters_impl)
    (\ n ->
      bindc (bindc (manya (membera [' ', '\n', '\t', '\r']))
              (\ _ -> returnb ()))
        (\ _ ->
          (if null n
            then errorb
                   (['e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'l', 'e', 't',
                      't', 'e', 'r', ' '] ++
                     letters ++
                       [' ', 'b', 'u', 't', ' ', 'f', 'i', 'r', 's', 't', ' ',
                         's', 'y', 'm', 'b', 'o', 'l', ' ', 'i', 's', ' ',
                         '\"'] ++
                         take one_nat s ++ ['\"'])
            else returnb n)))
    s;

parse_attributes ::
  [Prelude.Char] ->
    Sum [Prelude.Char] ([([Prelude.Char], [Prelude.Char])], [Prelude.Char]);
parse_attributes [] = Inr ([], []);
parse_attributes (c : s) =
  (if membera ['/', '>'] c then Inr ([], c : s)
    else bindc parse_name
           (\ k ->
             bindc (exactly ['='])
               (\ _ ->
                 bindc parse_attribute_value
                   (\ v ->
                     bindc parse_attributes
                       (\ atts -> returnb ((k, v) : atts)))))
           (c : s));

oneof_closed ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
oneof_closed (x : xs) =
  (if x == '>' then Inr (['>'], trim xs)
    else (if x == '/' && (case xs of {
                           [] -> False;
                           y : _ -> y == '>';
                         })
           then Inr (['/', '>'], trim (tla xs))
           else err_expecting
                  ['o', 'n', 'e', ' ', 'o', 'f', ' ', '[', '/', '>', ',', ' ',
                    '>', ']']
                  (x : xs)));
oneof_closed [] =
  err_expecting
    ['o', 'n', 'e', ' ', 'o', 'f', ' ', '[', '/', '>', ',', ' ', '>', ']'] [];

parse_text ::
  [Prelude.Char] -> Sum [Prelude.Char] (Maybe [Prelude.Char], [Prelude.Char]);
parse_text =
  bindc (manya (\ y -> not ('<' == y)))
    (\ ts ->
      let {
        text = trim ts;
      } in (if null text then returnb Nothing
             else returnb (Just (reverse (trim (reverse text))))));

parse_nodes :: [Prelude.Char] -> Sum [Prelude.Char] ([Xml], [Prelude.Char]);
parse_nodes ts =
  (if null ts || take (nat_of_integer (2 :: Integer)) ts == ['<', '/']
    then returnb [] ts
    else (if not (hda ts == '<')
           then bindc parse_text
                  (\ t ->
                    bindc parse_nodes (\ ns -> returnb (XML_text (the t) : ns)))
                  ts
           else bindc (exactly ['<'])
                  (\ _ ->
                    bindc parse_name
                      (\ n ->
                        bindc parse_attributes
                          (\ atts ->
                            bindc oneof_closed
                              (\ e ->
                                (if e == ['/', '>']
                                  then bindc parse_nodes
 (\ cs -> returnb (XML n atts [] : cs))
                                  else bindc parse_nodes
 (\ cs ->
   bindc (exactly ['<', '/'])
     (\ _ ->
       bindc (exactly n)
         (\ _ ->
           bindc (exactly ['>'])
             (\ _ ->
               bindc parse_nodes (\ ns -> returnb (XML n atts cs : ns)))))))))))
                  ts));

parse_node :: [Prelude.Char] -> Sum [Prelude.Char] (Xml, [Prelude.Char]);
parse_node =
  bindc (exactly ['<'])
    (\ _ ->
      bindc parse_name
        (\ n ->
          bindc parse_attributes
            (\ atts ->
              bindc oneof_closed
                (\ e ->
                  (if e == ['/', '>'] then returnb (XML n atts [])
                    else bindc parse_nodes
                           (\ cs ->
                             bindc (exactly ['<', '/'])
                               (\ _ ->
                                 bindc (exactly n)
                                   (\ _ ->
                                     bindc (exactly ['>'])
                                       (\ _ -> returnb (XML n atts cs))))))))));

parse_doc :: [Prelude.Char] -> Sum [Prelude.Char] (Xmldoc, [Prelude.Char]);
parse_doc =
  bindc (update_tokens remove_comments)
    (\ _ ->
      bindc parse_header
        (\ h ->
          bindc parse_node
            (\ xml -> bindc eoi (\ _ -> returnb (XMLDOC h xml)))));

position :: Xml -> Sum_bot [Prelude.Char] Nat;
position =
  change (nata ['p', 'o', 's', 'i', 't', 'i', 'o', 'n'])
    (\ n -> minus_nat n one_nat);

afs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), Af_entry)];
afs xml2name =
  many ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r']
    (triple
      ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r',
        'E', 'n', 't', 'r', 'y']
      xml2name (nata ['a', 'r', 'i', 't', 'y'])
      (options
        [(['c', 'o', 'l', 'l', 'a', 'p', 's', 'i', 'n', 'g'],
           change (nata ['c', 'o', 'l', 'l', 'a', 'p', 's', 'i', 'n', 'g'])
             (\ i -> Collapse (minus_nat i one_nat))),
          (['n', 'o', 'n', 'C', 'o', 'l', 'l', 'a', 'p', 's', 'i', 'n', 'g'],
            many ['n', 'o', 'n', 'C', 'o', 'l', 'l', 'a', 'p', 's', 'i', 'n',
                   'g']
              position AFList)])
      (\ f a -> (\ b -> ((f, a), b))))
    id;

list2position :: [Nat] -> Pos;
list2position [] = Empty;
list2position (n : ns) = PCons n (list2position ns);

pos :: Xml -> Sum_bot [Prelude.Char] Pos;
pos = many ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', 'I', 'n', 'T', 'e', 'r',
             'm']
        position list2position;

scg_position :: Xml -> Sum_bot [Prelude.Char] Nat;
scg_position = nata ['p', 'o', 's', 'i', 't', 'i', 'o', 'n'];

list1element :: forall a. [a] -> Maybe a;
list1element [x] = Just x;
list1element [] = Nothing;
list1element (v : vb : vc) = Nothing;

singleton ::
  forall a b.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> b) -> Xml -> Sum_bot [Prelude.Char] b;
singleton tag p1 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list1element cs of {
               Nothing -> fail tag xml;
               Just cs1 -> binda (p1 cs1) (returna . f);
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

var :: forall a. Xml -> Sum_bot [Prelude.Char] (Term a [Prelude.Char]);
var x = binda (text ['v', 'a', 'r'] x) (returna . Var);

term ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Term a [Prelude.Char]);
term xml2name x =
  options
    [(['v', 'a', 'r'], var),
      (['f', 'u', 'n', 'a', 'p', 'p'],
        many1 ['f', 'u', 'n', 'a', 'p', 'p'] xml2name
          (singleton ['a', 'r', 'g'] (term xml2name) id) Fun)]
    x;

rule ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char] (Term a [Prelude.Char], Term a [Prelude.Char]);
rule xml2name =
  pair ['r', 'u', 'l', 'e'] (singleton ['l', 'h', 's'] (term xml2name) id)
    (singleton ['r', 'h', 's'] (term xml2name) id) (\ a b -> (a, b));

scg ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ((Term a [Prelude.Char], Term a [Prelude.Char]),
            ([(Nat, Nat)], [(Nat, Nat)]));
scg xml2name =
  many1 ['s', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'G', 'r', 'a', 'p',
          'h']
    (rule xml2name)
    (triple ['e', 'd', 'g', 'e'] scg_position
      (bool ['s', 't', 'r', 'i', 'c', 't']) scg_position
      (\ p s q -> (s, (p, q))))
    (\ lr edges ->
      (lr, (map_filter (\ x -> (if fst x then Just (snd x) else Nothing)) edges,
             map_filter (\ x -> (if not (fst x) then Just (snd x) else Nothing))
               edges)));

map_term :: forall a b c d. (a -> b) -> (c -> d) -> Term a c -> Term b d;
map_term f1 f2 (Var x1) = Var (f2 x1);
map_term f1 f2 (Fun x21 x22) = Fun (f1 x21) (map (map_term f1 f2) x22);

class_to_term_intern ::
  forall a b. (Nat -> a) -> Nat -> Term b (Sum () a) -> (Nat, Term b a);
class_to_term_intern iv i (Fun f ts) =
  let {
    (k, ss) =
      foldr (\ t (j, ss) -> let {
                              (k, s) = class_to_term_intern iv j t;
                            } in (k, s : ss))
        ts (i, []);
  } in (k, Fun f ss);
class_to_term_intern iv i (Var (Inl uu)) = (plus_nat i one_nat, Var (iv i));
class_to_term_intern iv i (Var (Inr x)) = (i, Var x);

class_to_term ::
  forall a.
    Prelude.Char -> Term a (Sum () [Prelude.Char]) -> Term a [Prelude.Char];
class_to_term c t =
  snd (class_to_term_intern (\ i -> c : shows_prec_nat zero_nat i []) zero_nat
        t);

subst_apply_term :: forall a b c. Term a b -> (b -> Term a c) -> Term a c;
subst_apply_term (Var x) sigma = sigma x;
subst_apply_term (Fun f ss) sigma =
  Fun f (map (\ t -> subst_apply_term t sigma) ss);

subst_compose ::
  forall a b c d. (a -> Term b c) -> (c -> Term b d) -> a -> Term b d;
subst_compose sigma tau = (\ x -> subst_apply_term (sigma x) tau);

subst_of :: forall a b. (Eq a) => [(a, Term b a)] -> a -> Term b a;
subst_of ss = foldr (\ (x, t) sigma -> subst_compose sigma (subst x t)) ss Var;

contains_var_term :: forall a b. (Eq a) => a -> Term b a -> Bool;
contains_var_term x (Var y) = x == y;
contains_var_term x (Fun uu ts) = any (contains_var_term x) ts;

subst_list ::
  forall a b.
    (a -> Term b a) -> [(Term b a, Term b a)] -> [(Term b a, Term b a)];
subst_list sigma ys =
  map (\ p -> (subst_apply_term (fst p) sigma, subst_apply_term (snd p) sigma))
    ys;

decompose ::
  forall a b c. (Eq a) => Term a b -> Term a c -> Maybe [(Term a b, Term a c)];
decompose s t =
  (case (s, t) of {
    (Var _, _) -> Nothing;
    (Fun _ _, Var _) -> Nothing;
    (Fun f ss, Fun g ts) -> (if f == g then zip_option ss ts else Nothing);
  });

unify ::
  forall a b.
    (Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(b, Term a b)] -> Maybe [(b, Term a b)];
unify [] bs = Just bs;
unify ((Fun f ss, Fun g ts) : e) bs =
  (case decompose (Fun f ss) (Fun g ts) of {
    Nothing -> Nothing;
    Just us -> unify (us ++ e) bs;
  });
unify ((Var x, t) : e) bs =
  (if equal_term t (Var x) then unify e bs
    else (if contains_var_term x t then Nothing
           else unify (subst_list (subst x t) e) ((x, t) : bs)));
unify ((Fun v va, Var x) : e) bs =
  (if contains_var_term x (Fun v va) then Nothing
    else unify (subst_list (subst x (Fun v va)) e) ((x, Fun v va) : bs));

mgu ::
  forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Maybe (b -> Term a b);
mgu s t = (case unify [(s, t)] [] of {
            Nothing -> Nothing;
            Just res -> Just (subst_of res);
          });

mgu_class ::
  forall a.
    (Eq a) => Term a (Sum () [Prelude.Char]) ->
                Term a [Prelude.Char] ->
                  Maybe ([Prelude.Char] -> Term a [Prelude.Char]);
mgu_class cs t =
  mgu (class_to_term 'z' cs) (map_term (\ x -> x) (\ a -> 'y' : a) t);

removeAll :: forall a. (Eq a) => a -> [a] -> [a];
removeAll x [] = [];
removeAll x (y : xs) = (if x == y then removeAll x xs else y : removeAll x xs);

span :: forall a. (a -> Bool) -> [a] -> ([a], [a]);
span p (x : xs) = (if p x then let {
                                 a = span p xs;
                                 (ys, aa) = a;
                               } in (x : ys, aa)
                    else ([], x : xs));
span uu [] = ([], []);

match_term_list_code ::
  forall a b c.
    (Eq a, Ccompare b, Eq b,
      Eq c) => [(Term a b, Term a c)] ->
                 Mapping b (Term a c) -> Maybe (Mapping b (Term a c));
match_term_list_code ((Fun f ss, Var x) : p) sigma = Nothing;
match_term_list_code ((Fun f ss, Fun g ts) : p) sigma =
  (case decompose (Fun f ss) (Fun g ts) of {
    Nothing -> Nothing;
    Just us -> match_term_list_code (us ++ p) sigma;
  });
match_term_list_code ((Var x, t) : p) sigma =
  (if is_none (lookupb sigma x) || lookupb sigma x == Just t
    then match_term_list_code p (updateb x t sigma) else Nothing);
match_term_list_code [] sigma = Just sigma;

subst_of_map :: forall a b. (a -> b) -> (a -> Maybe b) -> a -> b;
subst_of_map d sigma x = (case sigma x of {
                           Nothing -> d x;
                           Just t -> t;
                         });

match_list ::
  forall a b c.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Eq c) => (a -> Term b c) ->
                 [(Term b a, Term b c)] -> Maybe (a -> Term b c);
match_list d p =
  map_option (subst_of_map d . lookupb) (match_term_list_code p emptyc);

match ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b -> Term a b -> Maybe (b -> Term a b);
match t l = match_list Var [(l, t)];

mat_add :: forall a. (Plus a) => Mat a -> Mat a -> Mat a;
mat_add a b =
  mat (mat_dim_row b) (mat_dim_col b)
    (\ ij -> plus (mat_index a ij) (mat_index b ij));

mat_map :: forall a b. (a -> b) -> Mat a -> Mat b;
mat_map f a = mat (mat_dim_row a) (mat_dim_col a) (\ ij -> f (mat_index a ij));

mat_one :: forall a. (One a, Zero a) => Nat -> Mat a;
mat_one n = mat n n (\ (i, j) -> (if equal_nat i j then onea else zeroa));

vec_dim_impl :: forall a. Vec_impl a -> Nat;
vec_dim_impl xa = fst (rep_vec_impl xa);

vec_dim :: forall a. Vec a -> Nat;
vec_dim (Vec_impl v) = vec_dim_impl v;

scalar_prod :: forall a. (Semiring_0 a) => Vec a -> Vec a -> a;
scalar_prod v w =
  listsum
    (map (\ i -> times (vec_index v i) (vec_index w i))
      (upt zero_nat (vec_dim w)));

mat_mult_mat :: forall a. (Semiring_0 a) => Mat a -> Mat a -> Mat a;
mat_mult_mat a b =
  mat (mat_dim_row a) (mat_dim_col b)
    (\ (i, j) -> scalar_prod (row a i) (col b j));

mat_pow :: forall a. (Semiring_1 a) => Mat a -> Nat -> Mat a;
mat_pow a k =
  (if equal_nat k zero_nat then mat_one (mat_dim_row a)
    else mat_mult_mat (mat_pow a (minus_nat k one_nat)) a);

rBT_Impl_fold1 :: forall a. (a -> a -> a) -> Rbta a () -> a;
rBT_Impl_fold1 f (Branch ca (Branch c l ka va ra) k v r) =
  folda (\ kb _ -> f kb) r (f k (rBT_Impl_fold1 f (Branch c l ka va ra)));
rBT_Impl_fold1 f (Branch c Emptya k v r) = folda (\ ka _ -> f ka) r k;
rBT_Impl_fold1 f Emptya = error "undefined";

fold1 :: forall a. (Ccompare a) => (a -> a -> a) -> Mapping_rbt a () -> a;
fold1 x xc = rBT_Impl_fold1 x (impl_ofb xc);

imagea ::
  forall a b.
    (Ceq a, Ccompare a, Ceq b, Ccompare b,
      Set_impl b) => Set (a, b) -> Set a -> Set b;
imagea (RBT_set rbt) c =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Image RBT_set: ccompare1 = None" (\ _ -> imagea (RBT_set rbt) c);
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "Image RBT_set: ccompare2 = None" (\ _ -> imagea (RBT_set rbt) c);
        Just _ ->
          foldb (\ (x, y) acc -> (if member x c then inserta y acc else acc))
            rbt bot_set;
      });
  });
imagea (DList_set dxs) b =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Image DList_set: ceq1 = None" (\ _ -> imagea (DList_set dxs) b);
    Just _ ->
      (case (ceq :: Maybe (b -> b -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "Image DList_set: ceq2 = None" (\ _ -> imagea (DList_set dxs) b);
        Just _ ->
          foldc (\ (x, y) acc -> (if member x b then inserta y acc else acc))
            dxs bot_set;
      });
  });
imagea (Set_Monad rxs) a =
  Set_Monad
    (fold (\ (x, y) rest -> (if member x a then y : rest else rest)) rxs []);
imagea x y = image snd (filtera (\ (xa, _) -> member xa y) x);

zero :: forall a b. Partial_object_ext a (Monoid_ext a (Ring_ext a b)) -> a;
zero (Partial_object_ext carrier (Monoid_ext mult one (Ring_ext zero add more)))
  = zero;

args :: forall a b. Term a b -> [Term a b];
args (Var x1) = [];
args (Fun x21 x22) = x22;

aarity :: forall a. (a -> Nat -> [a]) -> a -> Nat -> Nat;
aarity sm f n = minus_nat (size_list (sm f n)) one_nat;

map_entry :: forall a b. (Eq a) => a -> (b -> b) -> [(a, b)] -> [(a, b)];
map_entry k f [] = [];
map_entry k f (p : ps) =
  (if fst p == k then (k, f (snd p)) : ps else p : map_entry k f ps);

ctxt ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Ctxt a [Prelude.Char]);
ctxt xml2name x =
  options
    [(['b', 'o', 'x'], leaf ['b', 'o', 'x'] Hole),
      (['f', 'u', 'n', 'C', 'o', 'n', 't', 'e', 'x', 't'],
        tuple4 ['f', 'u', 'n', 'C', 'o', 'n', 't', 'e', 'x', 't'] xml2name
          (many ['b', 'e', 'f', 'o', 'r', 'e'] (term xml2name) id)
          (ctxt xml2name) (many ['a', 'f', 't', 'e', 'r'] (term xml2name) id)
          More)]
    x;

xml3to4elements ::
  forall a b c d e.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (a -> b -> Maybe c -> d -> e) -> Xml -> Sum_bot [Prelude.Char] e;
xml3to4elements tag p1 p2 p3 p4 f (XML name atts cs) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts &&
               less_eq_nat (nat_of_integer (3 :: Integer)) l &&
                 less_eq_nat l (nat_of_integer (4 :: Integer))
         then binda (p1 (nth cs zero_nat))
                (\ x1 ->
                  binda (p2 (nth cs one_nat))
                    (\ x2 ->
                      (if equal_nat l (nat_of_integer (4 :: Integer))
                        then binda (p3 (nth cs (nat_of_integer (2 :: Integer))))
                               (\ x3 ->
                                 binda (p4
 (nth cs (nat_of_integer (3 :: Integer))))
                                   (\ x4 -> returna (f x1 x2 (Just x3) x4)))
                        else binda (p4 (nth cs (nat_of_integer (2 :: Integer))))
                               (\ x4 -> returna (f x1 x2 Nothing x4)))))
         else fail tag (XML name atts cs));
xml3to4elements tag p1 p2 p3 p4 f (XML_text v) = fail tag (XML_text v);

relstep ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                  (Bool, Term a [Prelude.Char])));
relstep xml2name =
  xml3to4elements ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 't', 'e', 'p'] pos
    (rule xml2name) (leaf ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e'] ())
    (term xml2name) (\ p r rel t -> (p, (r, (is_none rel, t))));

relsteps ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                     (Bool, Term a [Prelude.Char])))]);
relsteps xml2name =
  many1 ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c',
          'e']
    (singleton ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm'] (term xml2name) id)
    (relstep xml2name) (\ a b -> (a, b));

substa ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [([Prelude.Char], Term a [Prelude.Char])];
substa xml2name =
  many ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n']
    (pair ['s', 'u', 'b', 's', 't', 'E', 'n', 't', 'r', 'y']
      (text ['v', 'a', 'r']) (term xml2name) (\ a b -> (a, b)))
    id;

loop ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                      (Bool, Term a [Prelude.Char])))],
              ([([Prelude.Char], Term a [Prelude.Char])],
                Ctxt a [Prelude.Char])));
loop xml2name =
  triple ['l', 'o', 'o', 'p'] (relsteps xml2name) (substa xml2name)
    (ctxt xml2name) (\ (s, rseq) sigma c -> (s, (rseq, (sigma, c))));

proj ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (ProjL a);
proj xml2name =
  change (afs xml2name)
    (\ afl -> Projection (map (\ (fa, a) -> (case a of {
      Collapse aa -> (fa, aa);
      AFList _ -> (fa, snd fa);
    }))
                           afl));

real :: Xml -> Sum_bot [Prelude.Char] Real;
real x =
  catch_error (change rat of_rat x)
    (\ _ ->
      triple ['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c'] rat rat rat
        (\ a b c ->
          plus_real (of_rat a) (times_real (of_rat b) (sqrt (of_rat c))))
        x);

proj_term :: forall a b. ((a, Nat) -> Nat) -> Term a b -> Term a b;
proj_term p (Var x) = Var x;
proj_term p (Fun f ts) = let {
                           n = size_list ts;
                           i = p (f, n);
                         } in (if less_nat i n then nth ts i else Fun f ts);

start_term ::
  forall a.
    (Eq a) => (Xml -> Sum_bot [Prelude.Char] a) ->
                Term a [Prelude.Char] ->
                  Xml -> Sum_bot [Prelude.Char] (Term a [Prelude.Char]);
start_term xml2name t =
  singleton ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm']
    (\ xml ->
      binda (term xml2name xml)
        (\ s ->
          (if equal_term s t then returna t
            else errora
                   ['<', 's', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm', '>', ' ',
                     'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                     'c', 'h', ' ', 'l', 'h', 's'])))
    id;

rstep ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                  Term a [Prelude.Char]));
rstep xml2name =
  triple ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 't', 'e', 'p'] pos
    (rule xml2name) (term xml2name) (\ p r t -> (p, (r, t)));

rseq ::
  forall a.
    (Eq a) => (Xml -> Sum_bot [Prelude.Char] a) ->
                ((a, Nat) -> Nat) ->
                  (Term a [Prelude.Char], Term a [Prelude.Char]) ->
                    Xml ->
                      Sum_bot [Prelude.Char]
                        ((Term a [Prelude.Char], Term a [Prelude.Char]),
                          [(Pos, ((Term a [Prelude.Char],
                                    Term a [Prelude.Char]),
                                   Term a [Prelude.Char]))]);
rseq xml2name pi r =
  many1 ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c',
          'e']
    (start_term xml2name (proj_term pi (fst r))) (rstep xml2name)
    (\ _ -> (\ a -> (r, a)));

trivial_mute_fun :: forall a. (Comm_ring_1 a) => a -> a -> (a, (a, a));
trivial_mute_fun x y = (x, (y, onea));

fst_sel_fun :: forall a. [(Nat, a)] -> Nat;
fst_sel_fun x = fst (hda x);

find_non0 ::
  forall a.
    (Eq a, Idom_divide a) => ([(Nat, a)] -> Nat) -> Nat -> Mat a -> Maybe Nat;
find_non0 sel_fun l a =
  let {
    is = upt (suc l) (mat_dim_row a);
    ais = filter (\ (_, ail) -> not (ail == zeroa))
            (map (\ i -> (i, mat_index a (i, l))) is);
  } in (case ais of {
         [] -> Nothing;
         _ : _ -> Just (sel_fun ais);
       });

mute ::
  forall a.
    (Eq a,
      Idom_divide a) => (a -> a -> (a, (a, a))) ->
                          a -> Nat -> Nat -> (a, Mat a) -> (a, Mat a);
mute mf a_ll k l (r, a) =
  let {
    p = mat_index a (k, l);
  } in (if p == zeroa then (r, a)
         else let {
                (q, (pa, _)) = mf a_ll p;
              } in (times r q,
                     mat_addrow_gen plus times (uminusa pa) k l
                       (mat_multrow_gen times k q a)));

sub1 ::
  forall a.
    (Eq a,
      Idom_divide a) => (a -> a -> (a, (a, a))) ->
                          a -> Nat -> Nat -> (a, Mat a) -> (a, Mat a);
sub1 mf q k l rA =
  (if equal_nat k zero_nat then rA
    else mute mf q (plus_nat l (suc (minus_nat k one_nat))) l
           (sub1 mf q (minus_nat k one_nat) l rA));

sub2 ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) ->
                            Nat -> Nat -> (a, Mat a) -> (a, Mat a);
sub2 sel_fun mf d l (r, a) =
  (case find_non0 sel_fun l a of {
    Nothing -> (r, a);
    Just m ->
      let {
        aa = mat_swaprows m l a;
      } in sub1 mf (mat_index aa (l, l)) (minus_nat d (suc l)) l
             (uminusa r, aa);
  });

sub3 ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) ->
                            Nat -> Nat -> (a, Mat a) -> (a, Mat a);
sub3 sel_fun mf d l rA =
  (if equal_nat l zero_nat then rA
    else sub2 sel_fun mf d (minus_nat l one_nat)
           (sub3 sel_fun mf d (minus_nat l one_nat) rA));

triangulize ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) -> Mat a -> (a, Mat a);
triangulize sel_fun mf a =
  sub3 sel_fun mf (mat_dim_row a) (mat_dim_row a) (onea, a);

mat_diag :: forall a. Mat a -> [a];
mat_diag a = map (\ i -> mat_index a (i, i)) (upt zero_nat (mat_dim_row a));

det_code ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) -> Mat a -> a;
det_code sel_fun mf a =
  (if equal_nat (mat_dim_row a) (mat_dim_col a)
    then let {
           (m, aa) = triangulize sel_fun mf a;
         } in divide (listprod (mat_diag aa)) m
    else zeroa);

det :: forall a. (Eq a, Idom_divide a) => Mat a -> a;
det a = det_code fst_sel_fun trivial_mute_fun a;

label :: forall a b. Lab a b -> Nat -> Sum b [Lab a b] -> Lab a b;
label f n (Inl l) = Lab f l;
label f n (Inr l) = FunLab f l;

unlab :: forall a b. Lab a b -> Lab a b;
unlab (Lab f l) = f;
unlab (FunLab f l) = f;
unlab (UnLab v) = UnLab v;
unlab (Sharp v) = Sharp v;

mat_carrier :: forall a. Nat -> Nat -> Set (Mat a);
mat_carrier nr nc =
  Collect_set
    (\ a -> equal_nat (mat_dim_row a) nr && equal_nat (mat_dim_col a) nc);

mat_zero :: forall a. (Zero a) => Nat -> Nat -> Mat a;
mat_zero nr nc = mat nr nc (\ _ -> zeroa);

mat_ring ::
  forall a b.
    (Semiring_1 a) => Itself a ->
                        Nat ->
                          b -> Partial_object_ext (Mat a)
                                 (Monoid_ext (Mat a) (Ring_ext (Mat a) b));
mat_ring ty n b =
  Partial_object_ext (mat_carrier n n)
    (Monoid_ext mat_mult_mat (mat_one n) (Ring_ext (mat_zero n n) mat_add b));

emptye :: forall a b. (Ccompare b, Mapping_impl b) => (a -> b) -> Multimap b a;
emptye xa = Abs_multimap (xa, (emptyc, []));

rm_iterateoi ::
  forall a b c. Rbta a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
rm_iterateoi Emptya c f sigma = sigma;
rm_iterateoi (Branch col l k v r) c f sigma =
  (if c sigma
    then let {
           sigmaa = rm_iterateoi l c f sigma;
         } in (if c sigmaa then rm_iterateoi r c f (f (k, v) sigmaa)
                else sigmaa)
    else sigma);

iteratei_bmap_op_list_it_rm_basic_ops ::
  forall a b c.
    (Linorder a) => Rbt a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
iteratei_bmap_op_list_it_rm_basic_ops s = rm_iterateoi (impl_of s);

g_to_list_rm_basic_ops :: forall a b. (Linorder a) => Rbt a b -> [(a, b)];
g_to_list_rm_basic_ops m =
  iteratei_bmap_op_list_it_rm_basic_ops m (\ _ -> True) (\ a b -> a : b) [];

values :: forall a b. (Linorder a) => Rbt a [b] -> [b];
values m = concatMap snd (g_to_list_rm_basic_ops m);

tcapI ::
  forall a b. (Eq a, Eq b) => [(Term a b, Term a b)] -> Term a b -> Gctxt a b;
tcapI uu (Var uv) = GCHole;
tcapI r (Fun f ts) =
  let {
    h = GCFun f (map (tcapI r) ts);
  } in (if any (\ ra -> matchb h (fst ra)) r then GCHole else h);

sharp_term :: forall a b. (a -> a) -> Term a b -> Term a b;
sharp_term shp (Var x) = Var x;
sharp_term shp (Fun f ss) = Fun (shp f) ss;

hvf_top :: forall a b. (Eq a) => a -> Nat -> Term a b -> Bool;
hvf_top a n (Fun f ts) =
  (if f == a && equal_nat (size_list ts) n then not (is_Var (hda ts))
    else True);
hvf_top a n (Var uu) = False;

status :: forall a. Status a -> (a, Nat) -> [Nat];
status (Abs_status x) = x;

af_wpo :: forall a. ((a, Nat) -> Set Nat) -> Status a -> (a, Nat) -> Set Nat;
af_wpo pi sigma f = sup_set (set (status sigma f)) (pi f);

lex_ext_unbounded ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
lex_ext_unbounded f [] [] = (False, True);
lex_ext_unbounded f (uu : uv) [] = (True, True);
lex_ext_unbounded f [] (uw : ux) = (False, False);
lex_ext_unbounded f (a : asa) (b : bs) =
  (case f a b of {
    (True, _) -> (True, True);
    (False, True) -> lex_ext_unbounded f asa bs;
    (False, False) -> (False, False);
  });

wpo_ub ::
  forall a b.
    (Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool)) ->
                ((a, Nat) -> Bool) ->
                  (Term a b -> Term a b -> Bool) ->
                    (Term a b -> Term a b -> Bool) ->
                      Status a -> Term a b -> Term a b -> (Bool, Bool);
wpo_ub pr prl cS cNS sigma s t =
  (case s of {
    Var x ->
      (False,
        (case t of {
          Var a -> x == a;
          Fun g ts ->
            cNS s t &&
              null (status sigma (g, size_list ts)) && prl (g, size_list ts);
        }));
    Fun f ss ->
      (if cS s t then (True, True)
        else let {
               ff = (f, size_list ss);
               sf = status sigma ff;
             } in (if cNS s t
                    then (if any (\ i ->
                                   snd (wpo_ub pr prl cS cNS sigma (nth ss i)
 t))
                               sf
                           then (True, True)
                           else (case t of {
                                  Var _ -> (False, False);
                                  Fun g ts ->
                                    let {
                                      gg = (g, size_list ts);
                                      sg = status sigma gg;
                                      (prs, prns) = pr ff gg;
                                    } in (if prns &&
       all (\ j -> fst (wpo_ub pr prl cS cNS sigma s (nth ts j))) sg
   then (if prs then (True, True)
          else lex_ext_unbounded (wpo_ub pr prl cS cNS sigma) (map (nth ss) sf)
                 (map (nth ts) sg))
   else (False, False));
                                }))
                    else (False, False)));
  });

crule ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ((Term a [Prelude.Char], Term a [Prelude.Char]),
            [(Term a [Prelude.Char], Term a [Prelude.Char])]);
crule xml2name =
  many1 ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'u', 'l',
          'e']
    (rule xml2name) (rule xml2name) (\ a b -> (a, b));

estep ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                  (Bool, Term a [Prelude.Char])));
estep xml2name =
  tuple4 ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'S', 't', 'e', 'p'] pos
    (rule xml2name)
    (options
      [(['l', 'e', 'f', 't', 'R', 'i', 'g', 'h', 't'],
         leaf ['l', 'e', 'f', 't', 'R', 'i', 'g', 'h', 't'] True),
        (['r', 'i', 'g', 'h', 't', 'L', 'e', 'f', 't'],
          leaf ['r', 'i', 'g', 'h', 't', 'L', 'e', 'f', 't'] False)])
    (term xml2name) (\ p r b t -> (p, (r, (b, t))));

rules ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char] [(Term a [Prelude.Char], Term a [Prelude.Char])];
rules xml2name = many ['r', 'u', 'l', 'e', 's'] (rule xml2name) id;

state :: Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
state = text ['s', 't', 'a', 't', 'e'];

isOK :: forall a b. Sum a b -> Bool;
isOK m = (case m of {
           Inl _ -> False;
           Inr _ -> True;
         });

mapM :: forall a b c. (a -> Sum b c) -> [a] -> Sum b [c];
mapM f [] = Inr [];
mapM f (x : xs) = bindb (f x) (\ y -> bindb (mapM f xs) (\ ys -> Inr (y : ys)));

one :: forall a b. Partial_object_ext a (Monoid_ext a b) -> a;
one (Partial_object_ext carrier (Monoid_ext mult one more)) = one;

base :: forall a. (a, Nat) -> a;
base (f, h) = f;

lift :: forall a. Nat -> a -> (a, Nat);
lift h f = (f, h);

add_vars_term :: forall a b. Term a b -> [b] -> [b];
add_vars_term (Var x) xs = x : xs;
add_vars_term (Fun uu ts) xs = foldr add_vars_term ts xs;

vars_term_list :: forall a b. Term a b -> [b];
vars_term_list t = add_vars_term t [];

roof ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Term a b -> Bool;
roof (l, r) = let {
                xs = vars_term_list r;
              } in (\ t -> let {
                             xt = vars_term t;
                           } in all (\ x -> member x xt) xs);

matches ::
  forall a b c.
    (Eq a, Eq b, Ccompare c, Eq c,
      Mapping_impl c) => Term a b -> Term a c -> Bool;
matches t p = (case match_list (\ _ -> t) [(p, t)] of {
                Nothing -> False;
                Just _ -> True;
              });

option_list_to_list :: forall a. Maybe [a] -> [a];
option_list_to_list Nothing = [];
option_list_to_list (Just asa) = asa;

rep_multimap :: forall a b. Multimap a b -> (b -> a, (Mapping a [b], [b]));
rep_multimap (Abs_multimap x) = x;

inserte :: forall a b. (Ccompare b, Eq b) => a -> Multimap b a -> Multimap b a;
inserte xb xc = Abs_multimap (let {
                                (f, (m, alla)) = rep_multimap xc;
                                k = f xb;
                                old = option_list_to_list (lookupb m k);
                                new = xb : old;
                              } in (f, (updateb k new m, xb : alla)));

lookupc :: forall a b. (Ccompare a, Eq a) => Multimap a b -> a -> [b];
lookupc xa = let {
               (_, (m, _)) = rep_multimap xa;
             } in (\ k -> option_list_to_list (lookupb m k));

valuesa :: forall a b. Multimap a b -> [b];
valuesa xa = let {
               (_, (_, alla)) = rep_multimap xa;
             } in alla;

is_Inr :: forall a b. Sum a b -> Bool;
is_Inr (Inr uu) = True;
is_Inr (Inl uv) = False;

eq_monom :: forall a. (Eq a) => [(a, Nat)] -> [(a, Nat)] -> Bool;
eq_monom [] n = null n;
eq_monom ((x, p) : m) n =
  (case extract (\ yq -> fst yq == x) n of {
    Nothing -> False;
    Just (n1, ((_, q), n2)) -> equal_nat p q && eq_monom m (n1 ++ n2);
  });

poly_split ::
  forall a b.
    (Eq a, Zero b) => [(a, Nat)] -> [([(a, Nat)], b)] -> (b, [([(a, Nat)], b)]);
poly_split m p = (case extract (\ (n, _) -> eq_monom m n) p of {
                   Nothing -> (zeroa, p);
                   Just (p1, ((_, c), p2)) -> (c, p1 ++ p2);
                 });

max_v ::
  forall a b.
    (Zero a,
      Ord a) => a -> ((b, Nat) -> [([(Nat, Nat)], a)]) -> [(b, Nat)] -> a;
max_v v i fs =
  max v (foldr (\ f m -> max m (fst (poly_split [] (i f)))) fs zeroa);

order :: forall a. (Field a, Eq a) => a -> Poly a -> Nat;
order a p =
  (if is_zero p
    then (error :: forall a. String -> (() -> a) -> a)
           "order of polynomial 0 undefined" (\ _ -> order a p)
    else (if not (poly p a == zeroa) then zero_nat
           else suc (order a
                      (divide_poly p
                        (pCons (uminusa a) (pCons onea zero_polya))))));

to_list :: Pos -> [Nat];
to_list Empty = [];
to_list (PCons i p) = i : to_list p;

relcomp ::
  forall a b c.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b, Ceq c, Ccompare c,
      Set_impl c) => Set (a, b) -> Set (b, c) -> Set (a, c);
relcomp (Set_Monad xs6) (DList_set dxs4) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad DList_set: ceq1 = None"
        (\ _ -> relcomp (Set_Monad xs6) (DList_set dxs4));
    Just eq ->
      (case (ceq :: Maybe (c -> c -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp Set_Monad DList_set: ceq2 = None"
            (\ _ -> relcomp (Set_Monad xs6) (DList_set dxs4));
        Just _ ->
          fold (\ (x, y) ->
                 foldc (\ (ya, z) a ->
                         (if eq y ya then inserta (x, z) a else a))
                   dxs4)
            xs6 bot_set;
      });
  });
relcomp (DList_set dxs3) (Set_Monad xs5) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set Set_Monad: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs3) (Set_Monad xs5));
    Just _ ->
      (case ceq of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set Set_Monad: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs3) (Set_Monad xs5));
        Just eq ->
          foldc (\ (x, y) ->
                  fold (\ (ya, z) a ->
                         (if eq y ya then inserta (x, z) a else a))
                    xs5)
            dxs3 bot_set;
      });
  });
relcomp (Set_Monad xs4) (RBT_set rbt5) =
  (case (ccompare :: Maybe (c -> c -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad RBT_set: ccompare1 = None"
        (\ _ -> relcomp (Set_Monad xs4) (RBT_set rbt5));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp Set_Monad RBT_set: ccompare2 = None"
            (\ _ -> relcomp (Set_Monad xs4) (RBT_set rbt5));
        Just c_b ->
          fold (\ (x, y) ->
                 foldb (\ (ya, z) a ->
                         (if not (equal_order (c_b y ya) Eqa) then a
                           else inserta (x, z) a))
                   rbt5)
            xs4 bot_set;
      });
  });
relcomp (RBT_set rbt1) (Set_Monad xs3) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set Set_Monad: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt1) (Set_Monad xs3));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set Set_Monad: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt1) (Set_Monad xs3));
        Just c_b ->
          foldb (\ (x, y) ->
                  fold (\ (ya, z) a ->
                         (if not (equal_order (c_b y ya) Eqa) then a
                           else inserta (x, z) a))
                    xs3)
            rbt1 bot_set;
      });
  });
relcomp (Set_Monad xs1) (Set_Monad xs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad Set_Monad: ceq = None"
        (\ _ -> relcomp (Set_Monad xs1) (Set_Monad xs2));
    Just eq ->
      fold (\ (x, y) ->
             fold (\ (ya, z) a -> (if eq y ya then inserta (x, z) a else a))
               xs2)
        xs1 bot_set;
  });
relcomp (DList_set dxs3) (DList_set dxs4) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set DList_set: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
    Just _ ->
      (case ceq of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set DList_set: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
        Just eq ->
          (case (ceq :: Maybe (c -> c -> Bool)) of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp DList_set DList_set: ceq3 = None"
                (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
            Just _ ->
              foldc (\ (x, y) ->
                      foldc (\ (ya, z) a ->
                              (if eq y ya then inserta (x, z) a else a))
                        dxs4)
                dxs3 bot_set;
          });
      });
  });
relcomp (DList_set dxs2) (RBT_set rbt4) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set RBT_set: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set RBT_set: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
        Just _ ->
          (case ceq of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp DList_set RBT_set: ccompare2 = None"
                (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
            Just eq ->
              (case (ccompare :: Maybe (c -> c -> Ordera)) of {
                Nothing ->
                  (error :: forall a. String -> (() -> a) -> a)
                    "relcomp DList_set RBT_set: ccompare3 = None"
                    (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
                Just _ ->
                  foldc (\ (x, y) ->
                          foldb (\ (ya, z) a ->
                                  (if eq y ya then inserta (x, z) a else a))
                            rbt4)
                    dxs2 bot_set;
              });
          });
      });
  });
relcomp (RBT_set rbt3) (DList_set dxs1) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set DList_set: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set DList_set: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
        Just _ ->
          (case ceq of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp RBT_set DList_set: ceq2 = None"
                (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
            Just eq ->
              (case (ceq :: Maybe (c -> c -> Bool)) of {
                Nothing ->
                  (error :: forall a. String -> (() -> a) -> a)
                    "relcomp RBT_set DList_set: ceq3 = None"
                    (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
                Just _ ->
                  foldb (\ (x, y) ->
                          foldc (\ (ya, z) a ->
                                  (if eq y ya then inserta (x, z) a else a))
                            dxs1)
                    rbt3 bot_set;
              });
          });
      });
  });
relcomp (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set RBT_set: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set RBT_set: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
        Just c_b ->
          (case (ccompare :: Maybe (c -> c -> Ordera)) of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp RBT_set RBT_set: ccompare3 = None"
                (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
            Just _ ->
              foldb (\ (x, y) ->
                      foldb (\ (ya, z) a ->
                              (if not (equal_order (c_b y ya) Eqa) then a
                                else inserta (x, z) a))
                        rbt2)
                rbt1 bot_set;
          });
      });
  });

max_sls :: forall a. (Linorder a) => Semilattice_set a;
max_sls = Abs_semilattice_set max;

shows_lines :: forall a. (Showa a) => [a] -> [Prelude.Char] -> [Prelude.Char];
shows_lines = shows_sep (shows_prec zero_nat) shows_nl;

shows_space :: [Prelude.Char] -> [Prelude.Char];
shows_space = shows_prec_char zero_nat ' ';

tcapRM2 ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> [(Term a b, Term a b)]) -> Term a b -> Gctxt a b;
tcapRM2 uu (Var uv) = GCHole;
tcapRM2 rm (Fun f ts) =
  let {
    h = GCFun f (map (tcapRM2 rm) ts);
    n = size_list ts;
  } in (if any (\ r -> matchb h (fst r)) (rm (f, n)) then GCHole else h);

tcapRM ::
  forall a b.
    (Eq a,
      Eq b) => Bool ->
                 ((a, Nat) -> [(Term a b, Term a b)]) -> Term a b -> Gctxt a b;
tcapRM nlv rm = (if nlv then tcapRM2 rm else (\ _ -> GCHole));

linear_term_impl ::
  forall a b. (Ceq a, Ccompare a) => Set a -> Term b a -> Maybe (Set a);
linear_term_impl xs (Var x) =
  (if member x xs then Nothing else Just (inserta x xs));
linear_term_impl xs (Fun uu []) = Just xs;
linear_term_impl xs (Fun f (t : ts)) =
  (case linear_term_impl xs t of {
    Nothing -> Nothing;
    Just ys -> linear_term_impl ys (Fun f ts);
  });

linear_term :: forall a b. (Ceq b, Ccompare b, Set_impl b) => Term a b -> Bool;
linear_term t = not (is_none (linear_term_impl bot_set t));

funposs_list :: forall a b. Term a b -> [Pos];
funposs_list (Var x) = [];
funposs_list (Fun f ss) =
  Empty :
    concatMap (\ (i, a) -> map (PCons i) a)
      (zip (upt zero_nat (size_list ss)) (map funposs_list ss));

ctxt_of_pos_term :: forall a b. Pos -> Term a b -> Ctxt a b;
ctxt_of_pos_term Empty t = Hole;
ctxt_of_pos_term (PCons i ps) (Fun f ts) =
  More f (take i ts) (ctxt_of_pos_term ps (nth ts i)) (drop (suc i) ts);

ctxt_apply_term :: forall a b. Ctxt a b -> Term a b -> Term a b;
ctxt_apply_term Hole s = s;
ctxt_apply_term (More f ss1 c ss2) s = Fun f (ss1 ++ ctxt_apply_term c s : ss2);

poss_list :: forall a b. Term a b -> [Pos];
poss_list (Var x) = [Empty];
poss_list (Fun f ss) =
  Empty :
    concatMap (\ (i, a) -> map (PCons i) a)
      (zip (upt zero_nat (size_list ss)) (map poss_list ss));

rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
rewrite r s =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ p ->
          (case match (subt_at s p) l of {
            Nothing -> [];
            Just sigma ->
              [ctxt_apply_term (ctxt_of_pos_term p s)
                 (subst_apply_term ra sigma)];
          }))
        (poss_list s))
    r;

hvf_term :: forall a b. (Eq a) => a -> Term a b -> Bool;
hvf_term a t = (case unapp a t of {
                 (Var _, ts) -> null ts;
                 (Fun _ us, ts) -> all (hvf_term a) (us ++ ts);
               });

num_children :: Xml -> Nat;
num_children (XML uu uv cs) = size_list cs;
num_children (XML_text uw) = zero_nat;

crules ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]),
             [(Term a [Prelude.Char], Term a [Prelude.Char])])];
crules xml2name =
  many ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'u', 'l',
         'e', 's']
    (crule xml2name) id;

string ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] [a];
string xml2name = many ['s', 't', 'r', 'i', 'n', 'g'] xml2name id;

oc_srs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ([a], [a]);
oc_srs xml2name =
  pair ['o', 'v', 'e', 'r', 'l', 'a', 'p', 'C', 'l', 'o', 's', 'u', 'r', 'e',
         'S', 'R', 'S']
    (string xml2name) (string xml2name) (\ a b -> (a, b));

rsteps ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                     Term a [Prelude.Char]))]);
rsteps xml2name =
  many1 ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c',
          'e']
    (singleton ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm'] (term xml2name) id)
    (rstep xml2name) (\ a b -> (a, b));

xml_state :: [Prelude.Char] -> Xml;
xml_state s = XML ['s', 't', 'a', 't', 'e'] [] [XML_text s];

xml_eps_transition :: ([Prelude.Char], [Prelude.Char]) -> Xml;
xml_eps_transition (s, t) =
  XML ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n'] []
    [XML ['l', 'h', 's'] [] [xml_state s],
      XML ['r', 'h', 's'] [] [xml_state t]];

xml_lab :: forall a b. (Showa a, Showa b) => Lab a [b] -> Xml;
xml_lab (UnLab x) =
  XML ['n', 'a', 'm', 'e'] [] [XML_text (shows_prec zero_nat x [])];
xml_lab (Sharp x) = XML ['s', 'h', 'a', 'r', 'p'] [] [xml_lab x];
xml_lab (FunLab x l) =
  XML ['l', 'a', 'b', 'e', 'l', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l'] []
    [xml_lab x,
      XML ['s', 'y', 'm', 'b', 'o', 'l', 'L', 'a', 'b', 'e', 'l'] []
        (map xml_lab l)];
xml_lab (Lab x l) =
  XML ['l', 'a', 'b', 'e', 'l', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l'] []
    [xml_lab x,
      XML ['n', 'u', 'm', 'b', 'e', 'r', 'L', 'a', 'b', 'e', 'l'] []
        (map (\ n ->
               XML ['n', 'u', 'm', 'b', 'e', 'r'] []
                 [XML_text (shows_prec zero_nat n [])])
          l)];

xml_transition ::
  forall a b. (Showa a, Showa b) => Ta_rule [Prelude.Char] (Lab a [b]) -> Xml;
xml_transition (TA_rule f qs q) =
  XML ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n'] []
    [XML ['l', 'h', 's'] [] (xml_lab f : map xml_state qs),
      XML ['r', 'h', 's'] [] [xml_state q]];

xml_ta ::
  forall a b.
    (Showa a, Showa b) => Tree_automaton [Prelude.Char] (Lab a [b]) -> Xml;
xml_ta (Tree_Automaton fin tran eps) =
  XML ['t', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n'] []
    [XML ['f', 'i', 'n', 'a', 'l', 'S', 't', 'a', 't', 'e', 's'] []
       (map xml_state fin),
      XML ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 's'] []
        (map xml_transition tran ++ map xml_eps_transition eps)];

check :: forall a. Bool -> a -> Sum a ();
check b e = (if b then Inr () else Inl e);

degree :: Complexity_class -> Nat;
degree (Comp_Poly d) = d;

catch_errora :: forall a b c. Sum a b -> (a -> Sum c b) -> Sum c b;
catch_errora m f = (case m of {
                     Inl a -> f a;
                     Inr a -> Inr a;
                   });

check_no_edge ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ((a, a) -> Bool) -> a -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_edge ss g m n =
  check (not (g (m, n)))
    (shows_string ['e', 'd', 'g', 'e', ' ', 'f', 'r', 'o', 'm', ' '] .
      ss m . shows_string [' ', 't', 'o', ' '] . ss n);

forallM :: forall a b. (a -> Sum b ()) -> [a] -> Sum (a, b) ();
forallM f [] = Inr ();
forallM f (x : xs) =
  bindb (catch_errora (f x) (\ xa -> Inl (x, xa))) (\ _ -> forallM f xs);

check_edges ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ((a, a) -> Bool) ->
        [a] -> [a] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_edges ss g c d =
  catch_errora
    (forallM
      (\ n ->
        catch_errora (forallM (check_no_edge ss g n) d) (\ x -> Inl (snd x)))
      c)
    (\ x -> Inl (snd x));

mult :: forall a b. Partial_object_ext a (Monoid_ext a b) -> a -> a -> a;
mult (Partial_object_ext carrier (Monoid_ext mult one more)) = mult;

matcha :: forall a b. (Term a b, Term a b) -> Term a b -> Bool;
matcha = (\ _ _ -> True);

fold_impl :: forall a b. (a -> Nat -> b -> b) -> b -> [(a, Nat)] -> b;
fold_impl fn e ((a, n) : ms) = fold_impl fn (fn a n e) ms;
fold_impl fn e [] = e;

foldd :: forall a b. (a -> Nat -> b -> b) -> b -> Alist a Nat -> b;
foldd f e al = fold_impl f e (impl_ofa al);

set_mset :: forall a. (Ceq a, Ccompare a, Set_impl a) => Multiset a -> Set a;
set_mset (Bag ms) =
  foldd (\ a n -> (if equal_nat n zero_nat then (\ m -> m) else inserta a))
    bot_set ms;

fresh_strings_list ::
  [Prelude.Char] -> Nat -> [[Prelude.Char]] -> Nat -> [[Prelude.Char]];
fresh_strings_list name offset used n =
  take n
    (filter (\ s -> not (membera (remdups used) s))
      (map (\ i -> name ++ shows_prec_nat zero_nat (plus_nat i offset) [])
        (upt zero_nat (plus_nat n (size_list (remdups used))))));

fresh_string :: [Prelude.Char] -> [[Prelude.Char]] -> [Prelude.Char];
fresh_string pre = (\ s -> hda (fresh_strings_list pre one_nat s one_nat));

mapMa :: forall a b. (a -> Maybe b) -> [a] -> Maybe [b];
mapMa f [] = Just [];
mapMa f (x : xs) =
  bind (f x) (\ y -> bind (mapMa f xs) (\ ys -> Just (y : ys)));

equal_order_tag :: Order_tag -> Order_tag -> Bool;
equal_order_tag Lex Mul = False;
equal_order_tag Mul Lex = False;
equal_order_tag Mul Mul = True;
equal_order_tag Lex Lex = True;

any_nstri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> (Bool, b);
any_nstri_efficient_m f [] m = (False, m);
any_nstri_efficient_m f (a : asa) m =
  let {
    aa = f a m;
    (ab, b) = aa;
  } in let {
         (_, ns) = ab;
       } in (\ ma ->
              (if ns then (True, ma) else any_nstri_efficient_m f asa ma))
         b;

all_stri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> (Bool, b);
all_stri_efficient_m f [] m = (True, m);
all_stri_efficient_m f (a : asa) m =
  let {
    aa = f a m;
    (ab, b) = aa;
  } in let {
         (s, _) = ab;
       } in (\ ma -> (if s then all_stri_efficient_m f asa ma else (False, ma)))
         b;

filter_not_stri_efficient_m_aux ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ([a], b);
filter_not_stri_efficient_m_aux f [] bs m = (bs, m);
filter_not_stri_efficient_m_aux f (a : asa) bs m =
  let {
    b = f a m;
    (ba, c) = b;
  } in let {
         (s, _) = ba;
       } in (\ ma ->
              (if s then filter_not_stri_efficient_m_aux f asa bs ma
                else filter_not_stri_efficient_m_aux f asa (a : bs) ma))
         c;

filter_not_stri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> ([a], b);
filter_not_stri_efficient_m f asa m =
  let {
    a = filter_not_stri_efficient_m_aux f asa [] m;
    (ys, aa) = a;
  } in (reverse ys, aa);

mul_ext_efficient_m ::
  forall a b.
    (Eq a) => (a -> a -> b -> ((Bool, Bool), b)) ->
                [a] -> [a] -> b -> ((Bool, Bool), b);
mul_ext_efficient_m f [] [] m = ((False, True), m);
mul_ext_efficient_m f [] (v : va) m = ((False, False), m);
mul_ext_efficient_m f (v : va) [] m = ((True, True), m);
mul_ext_efficient_m f (v : va) (y : ys) m =
  ex_dom_efficient_m f y (v : va) (v : va) ys m;

ex_dom_efficient_m ::
  forall a b.
    (Eq a) => (a -> a -> b -> ((Bool, Bool), b)) ->
                a -> [a] -> [a] -> [a] -> b -> ((Bool, Bool), b);
ex_dom_efficient_m f y [] uw ux m = ((False, False), m);
ex_dom_efficient_m f y (b : bs) xs ys m =
  let {
    a = f b y m;
    (aa, c) = a;
  } in let {
         (s, ns) = aa;
       } in (\ ma ->
              (if s then let {
                           (ysa, m2) = filter_not_stri_efficient_m (f b) ys ma;
                           ab = mul_ext_efficient_m f (remove1 b xs) ysa m2;
                           (ac, ba) = ab;
                         } in let {
                                (_, ns1) = ac;
                              } in (\ m3 ->
                                     (if ns1 then ((True, True), m3)
                                       else ex_dom_efficient_m f y bs xs ys m3))
                                ba
                else (if ns
                       then let {
                              ab = mul_ext_efficient_m f (remove1 b xs) ys ma;
                              (ac, ba) = ab;
                            } in let {
                                   (s1, ns1) = ac;
                                 } in (\ mb ->
(if s1 then ((True, True), mb)
  else let {
         ad = ex_dom_efficient_m f y bs xs ys mb;
         (ae, bb) = ad;
       } in let {
              (s2, ns2) = ae;
            } in (\ m3 ->
                   (if s2 then ((True, True), m3)
                     else ((False, ns1 || ns2), m3)))
              bb))
                                   ba
                       else ex_dom_efficient_m f y bs xs ys ma)))
         c;

lex_ext_efficient_m ::
  forall a b.
    (a -> a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ((Bool, Bool), b);
lex_ext_efficient_m f [] [] m = ((False, True), m);
lex_ext_efficient_m f (uu : uv) [] m = ((True, True), m);
lex_ext_efficient_m f [] (uw : ux) m = ((False, False), m);
lex_ext_efficient_m f (a : asa) (b : bs) m =
  let {
    aa = f a b m;
    (ab, ba) = aa;
  } in let {
         (s, ns) = ab;
       } in (\ ma ->
              (if s then ((True, True), ma)
                else (if ns then lex_ext_efficient_m f asa bs ma
                       else ((False, False), ma))))
         ba;

lookupe :: forall a b c d. Memory_ext a b c d -> a -> b -> Maybe c;
lookupe (Memory_ext empty lookup store more) = lookup;

store :: forall a b c d. Memory_ext a b c d -> a -> (b, c) -> a;
store (Memory_ext empty lookup store more) = store;

diag_l :: forall a b. (a, b) -> ((a, a), b);
diag_l (a, b) = ((a, a), b);

rpo_efficient_m ::
  forall a b c.
    (Eq b,
      Eq c) => Memory_ext a (Term b c, Term b c) (Bool, Bool) () ->
                 ((b, Nat) -> (b, Nat) -> (Bool, Bool), (b, Nat) -> Bool) ->
                   ((b, Nat) -> Order_tag) ->
                     Term b c -> Term b c -> a -> ((Bool, Bool), a);
rpo_efficient_m model pr tag s t m =
  (case lookupe model m (s, t) of {
    Nothing ->
      let {
        (res, res_m) =
          (case (s, t) of {
            (Var x, Var y) -> ((False, x == y), m);
            (Var _, Fun g ts) -> ((False, null ts && snd pr (g, zero_nat)), m);
            (Fun _ ss, Var y) ->
              diag_l
                (any_nstri_efficient_m
                  (\ sa -> rpo_efficient_m model pr tag sa (Var y)) ss m);
            (Fun f ss, Fun g ts) ->
              (case any_nstri_efficient_m
                      (\ sa -> rpo_efficient_m model pr tag sa (Fun g ts)) ss m
                of {
                (True, ma) -> ((True, True), ma);
                (False, ma) ->
                  let {
                    maa = size_list ss;
                    n = size_list ts;
                  } in (case fst pr (f, maa) (g, n) of {
                         (prs, True) ->
                           (case all_stri_efficient_m
                                   (rpo_efficient_m model pr tag (Fun f ss)) ts
                                   ma
                             of {
                             (True, mb) ->
                               (if prs then ((True, True), mb)
                                 else let {
cf = tag (f, maa);
                                      } in
(if equal_order_tag cf (tag (g, n))
  then (if equal_order_tag cf Mul
         then mul_ext_efficient_m (rpo_efficient_m model pr tag) ss ts mb
         else lex_ext_efficient_m (rpo_efficient_m model pr tag) ss ts mb)
  else let {
         b = equal_nat n zero_nat;
       } in ((not (equal_nat maa zero_nat) && b, b), mb)));
                             (False, mb) -> ((False, False), mb);
                           });
                         (_, False) -> ((False, False), ma);
                       });
              });
          });
      } in (res, store model res_m ((s, t), res));
    Just v -> (v, m);
  });

emptyg :: forall a b c d. Memory_ext a b c d -> () -> a;
emptyg (Memory_ext empty lookup store more) = empty;

efficient_rpo_2 ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
efficient_rpo_2 pr tag p q =
  fst (rpo_efficient_m l2m pr tag p q (emptyg l2m ()));

rpo_unbounded_impl ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
rpo_unbounded_impl = efficient_rpo_2;

rpo_unbounded ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
rpo_unbounded = rpo_unbounded_impl;

converse ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Set (a, b) -> Set (b, a);
converse r = image (\ (x, y) -> (y, x)) r;

ctxt_compose :: forall a b. Ctxt a b -> Ctxt a b -> Ctxt a b;
ctxt_compose Hole d = d;
ctxt_compose (More f ss1 c ss2) d = More f ss1 (ctxt_compose c d) ss2;

msetsum :: forall a. (Comm_monoid_add a) => Multiset a -> a;
msetsum (Bag ms) = foldd (\ a n -> funpow n (plus a)) zeroa ms;

funs_term_ms :: forall a b. (Eq a) => Term a b -> Multiset a;
funs_term_ms (Var x) = zero_multiset;
funs_term_ms (Fun f ts) =
  plus_multiset (single f) (msetsum (mset (map funs_term_ms ts)));

subt_at_ctxt :: forall a b. Ctxt a b -> Pos -> Ctxt a b;
subt_at_ctxt c Empty = c;
subt_at_ctxt (More f bef c aft) (PCons i p) = subt_at_ctxt c p;

the_Var :: forall a b. Term a b -> b;
the_Var (Var x1) = x1;

vars_term_ms :: forall a b. (Eq b) => Term a b -> Multiset b;
vars_term_ms (Var x) = single x;
vars_term_ms (Fun f ts) = msetsum (mset (map vars_term_ms ts));

in_poss :: forall a b. Pos -> Term a b -> Bool;
in_poss Empty uu = True;
in_poss (PCons i p) (Fun f ts) =
  less_nat i (size_list ts) && in_poss p (nth ts i);
in_poss (PCons i p) (Var uv) = False;

add_funs_term :: forall a b. Term a b -> [a] -> [a];
add_funs_term (Var uu) fs = fs;
add_funs_term (Fun f ts) fs = f : foldr add_funs_term ts fs;

add_funs_rule :: forall a b. (Term a b, Term a b) -> [a] -> [a];
add_funs_rule r fs = add_funs_term (fst r) (add_funs_term (snd r) fs);

funs_trs_list :: forall a b. [(Term a b, Term a b)] -> [a];
funs_trs_list trs = foldr add_funs_rule trs [];

instance_rule ::
  forall a b c.
    (Eq a, Eq b, Ccompare c, Eq c,
      Mapping_impl c) => (Term a b, Term a b) -> (Term a c, Term a c) -> Bool;
instance_rule lr st =
  not (is_none
        (match_list (\ _ -> fst lr) [(fst st, fst lr), (snd st, snd lr)]));

map_funs_rule ::
  forall a b c. (a -> b) -> (Term a c, Term a c) -> (Term b c, Term b c);
map_funs_rule fg lr =
  (map_term fg (\ x -> x) (fst lr), map_term fg (\ x -> x) (snd lr));

add_vars_rule :: forall a b. (Term a b, Term a b) -> [b] -> [b];
add_vars_rule r xs = add_vars_term (fst r) (add_vars_term (snd r) xs);

vars_trs_list :: forall a b. [(Term a b, Term a b)] -> [b];
vars_trs_list trs = foldr add_vars_rule trs [];

elem_list_to_rm ::
  forall a b. (Compare_order b) => (a -> b) -> [a] -> Rbt b [a];
elem_list_to_rm key (d : ds) = let {
                                 rm = elem_list_to_rm key ds;
                                 k = key d;
                               } in (case lookup rm k of {
                                      Nothing -> insert k [d] rm;
                                      Just dataa -> insert k (d : dataa) rm;
                                    });
elem_list_to_rm key [] = empty;

fun_of_map :: forall a b. (a -> Maybe b) -> b -> a -> b;
fun_of_map m d a = (case m a of {
                     Nothing -> d;
                     Just b -> b;
                   });

term_map :: forall a b. (Key a) => [Term a b] -> (a, Nat) -> [Term a b];
term_map ts = fun_of_map (lookup (elem_list_to_rm (the . root) ts)) [];

label_depth :: forall a b. Lab a b -> Nat;
label_depth (UnLab uu) = zero_nat;
label_depth (Lab f uv) = suc (label_depth f);
label_depth (FunLab f uw) = suc (label_depth f);
label_depth (Sharp f) = suc (label_depth f);

gen_label :: forall a b. Lab a b -> Nat -> Lab a b;
gen_label f n =
  (if equal_nat n zero_nat then f
    else FunLab (gen_label f (minus_nat n one_nat)) []);

fmap ::
  forall a b.
    (Eq a,
      Eq b) => Lab a b ->
                 Nat ->
                   [((Lab a b, Nat), [Lab a b])] -> Lab a b -> Nat -> Lab a b;
fmap a nn sml =
  let {
    m = suc (max_list (map label_depth (a : concatMap snd sml)));
  } in (\ f n -> (if (f, n) == (a, nn) then a else gen_label f m));

enum_vectors :: forall a b. [a] -> [b] -> [[(b, a)]];
enum_vectors c [] = [[]];
enum_vectors c (x : xs) =
  let {
    a = enum_vectors c xs;
  } in concatMap (\ vec -> map (\ ca -> (x, ca) : vec) c) a;

replace_impl :: forall a. (Eq a) => a -> [a] -> [a] -> [a];
replace_impl a bs m =
  (if membera m a then bs ++ filter (\ b -> not (b == a)) m else m);

doc_of_string :: [Prelude.Char] -> Sum [Prelude.Char] Xmldoc;
doc_of_string s = bindb (parse_doc s) (\ (doc, _) -> Inr doc);

pat_eqv_prf ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Pat_eqv_prf a [Prelude.Char]);
pat_eqv_prf xml2name =
  let {
    sub = substa xml2name;
  } in singleton
         ['p', 'a', 't', 't', 'e', 'r', 'n', 'E', 'q', 'u', 'i', 'v', 'a', 'l',
           'e', 'n', 'c', 'e']
         (options
           [(['d', 'o', 'm', 'a', 'i', 'n', 'R', 'e', 'n', 'a', 'm', 'i', 'n',
               'g'],
              singleton
                ['d', 'o', 'm', 'a', 'i', 'n', 'R', 'e', 'n', 'a', 'm', 'i',
                  'n', 'g']
                sub Pat_Dom_Renaming),
             (['i', 'r', 'r', 'e', 'l', 'e', 'v', 'a', 'n', 't'],
               pair ['i', 'r', 'r', 'e', 'l', 'e', 'v', 'a', 'n', 't'] sub sub
                 Pat_Irrelevant),
             (['s', 'i', 'm', 'p', 'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o',
                'n'],
               pair ['s', 'i', 'm', 'p', 'l', 'i', 'f', 'i', 'c', 'a', 't', 'i',
                      'o', 'n']
                 sub sub Pat_Simplify)])
         id;

pat_term ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            ([([Prelude.Char], Term a [Prelude.Char])],
              [([Prelude.Char], Term a [Prelude.Char])]));
pat_term xml2name =
  triple ['p', 'a', 't', 't', 'e', 'r', 'n', 'T', 'e', 'r', 'm'] (term xml2name)
    (substa xml2name) (substa xml2name) (\ t s1 s2 -> (t, (s1, s2)));

pat_rule_prf ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Pat_rule_prf a [Prelude.Char]);
pat_rule_prf xml2name x =
  let {
    pat = pat_rule_prf xml2name;
    sub = substa xml2name;
    pt = pat_term xml2name;
    var = text ['v', 'a', 'r'];
  } in triple ['p', 'a', 't', 't', 'e', 'r', 'n', 'R', 'u', 'l', 'e'] pt pt
         (options
           [(['o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', 'R', 'u', 'l', 'e'],
              pair ['o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', 'R', 'u', 'l', 'e']
                (rule xml2name) (bool ['i', 's', 'P', 'a', 'i', 'r'])
                Pat_OrigRule),
             (['i', 'n', 'i', 't', 'i', 'a', 'l', 'P', 'u', 'm', 'p', 'i', 'n',
                'g'],
               triple
                 ['i', 'n', 'i', 't', 'i', 'a', 'l', 'P', 'u', 'm', 'p', 'i',
                   'n', 'g']
                 pat sub sub Pat_InitPump),
             (['i', 'n', 'i', 't', 'i', 'a', 'l', 'P', 'u', 'm', 'p', 'i', 'n',
                'g', 'C', 'o', 'n', 't', 'e', 'x', 't'],
               tuple4
                 ['i', 'n', 'i', 't', 'i', 'a', 'l', 'P', 'u', 'm', 'p', 'i',
                   'n', 'g', 'C', 'o', 'n', 't', 'e', 'x', 't']
                 pat sub pos var Pat_InitPumpCtxt),
             (['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e'],
               triple ['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e']
                 pat (options
                       [(['l', 'e', 'f', 't'], leaf ['l', 'e', 'f', 't'] True),
                         (['r', 'i', 'g', 'h', 't'],
                           leaf ['r', 'i', 'g', 'h', 't'] False)])
                 (pat_eqv_prf xml2name) Pat_Equiv),
             (['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g'],
               triple ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g'] pat pat pos
                 Pat_Narrow),
             (['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n'],
               triple
                 ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o',
                   'n']
                 pat sub
                 (options
                   [(['b', 'a', 's', 'e'], leaf ['b', 'a', 's', 'e'] Pat_Base),
                     (['p', 'u', 'm', 'p', 'i', 'n', 'g'],
                       leaf ['p', 'u', 'm', 'p', 'i', 'n', 'g'] Pat_Pump),
                     (['c', 'l', 'o', 's', 'i', 'n', 'g'],
                       leaf ['c', 'l', 'o', 's', 'i', 'n', 'g'] Pat_Close)])
                 Pat_Inst),
             (['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                'P', 'u', 'm', 'p', 'i', 'n', 'g'],
               pair ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o',
                      'n', 'P', 'u', 'm', 'p', 'i', 'n', 'g']
                 pat (nata ['p', 'o', 'w', 'e', 'r']) Pat_Exp_Sigma),
             (['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g'],
               triple ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g'] pat
                 (rsteps xml2name)
                 (options
                   [(['b', 'a', 's', 'e'],
                      leaf ['b', 'a', 's', 'e'] (Pat_Base, [])),
                     (['p', 'u', 'm', 'p', 'i', 'n', 'g'],
                       singleton ['p', 'u', 'm', 'p', 'i', 'n', 'g'] var
                         (\ a -> (Pat_Pump, a))),
                     (['c', 'l', 'o', 's', 'i', 'n', 'g'],
                       singleton ['c', 'l', 'o', 's', 'i', 'n', 'g'] var
                         (\ a -> (Pat_Close, a)))])
                 (\ p seq (a, b) -> Pat_Rewr p seq a b))])
         (\ _ _ z -> z) x;

nonloop ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Non_loop_prf a [Prelude.Char]);
nonloop xml2name =
  tuple6 ['n', 'o', 'n', 'L', 'o', 'o', 'p'] (pat_rule_prf xml2name)
    (substa xml2name) (substa xml2name)
    (nata ['n', 'a', 't', 'u', 'r', 'a', 'l'])
    (nata ['n', 'a', 't', 'u', 'r', 'a', 'l']) pos Non_loop_prf;

symbols ::
  forall a.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] [(a, Nat)];
symbols tagname xml2name =
  many tagname
    (pair ['s', 'y', 'm', 'b', 'o', 'l'] xml2name
      (nata ['a', 'r', 'i', 't', 'y']) (\ a b -> (a, b)))
    id;

xml_single_pos :: Nat -> Xml;
xml_single_pos i =
  XML ['p', 'o', 's', 'i', 't', 'i', 'o', 'n'] []
    [XML_text (shows_prec_nat zero_nat (suc i) [])];

xml_pos :: Pos -> Xml;
xml_pos p =
  XML ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', 'I', 'n', 'T', 'e', 'r', 'm'] []
    (map xml_single_pos (to_list p));

eq_set ::
  forall a. (Card_UNIV a, Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
eq_set = set_eq;

choicea :: forall a b. [Sum a b] -> Sum [a] b;
choicea [] = Inl [];
choicea (x : xs) =
  catch_errora x (\ e -> catch_errora (choicea xs) (\ xa -> Inl (e : xa)));

rec_list :: forall a b. a -> (b -> [b] -> a -> a) -> [b] -> a;
rec_list f1 f2 [] = f1;
rec_list f1 f2 (x21 : x22) = f2 x21 x22 (rec_list f1 f2 x22);

product_lists :: forall a. [[a]] -> [[a]];
product_lists [] = [[]];
product_lists (xs : xss) =
  concatMap (\ x -> map (\ a -> x : a) (product_lists xss)) xs;

min_list :: forall a. (Linorder a) => [a] -> a;
min_list [x] = x;
min_list (x : v : va) = min x (min_list (v : va));

height :: forall a. (a, Nat) -> Nat;
height (f, h) = h;

mat_of_cols :: forall a. Nat -> [Vec a] -> Mat a;
mat_of_cols n cs = mat n (size_list cs) (\ (i, j) -> vec_index (nth cs j) i);

vec_of_list_impl :: forall a. [a] -> Vec_impl a;
vec_of_list_impl xa = Abs_vec_impl (size_list xa, IArray.listIArray xa);

vec_of_list :: forall a. [a] -> Vec a;
vec_of_list v = Vec_impl (vec_of_list_impl v);

check_poly_ge ::
  forall a b.
    (Eq a,
      Ordered_semiring_0 b) => [([(a, Nat)], b)] -> [([(a, Nat)], b)] -> Bool;
check_poly_ge [] q = all (\ (_, d) -> less_eq d zeroa) q;
check_poly_ge ((m, c) : p) q =
  (case extract (\ nd -> eq_monom (fst nd) m) q of {
    Nothing -> less_eq zeroa c && check_poly_ge p q;
    Just (q1, ((_, d), q2)) -> less_eq d c && check_poly_ge p (q1 ++ q2);
  });

check_poly_gt ::
  forall a b.
    (Ordered_semiring_0 a,
      Eq b) => (a -> a -> Bool) ->
                 [([(b, Nat)], a)] -> [([(b, Nat)], a)] -> Bool;
check_poly_gt gt p q = let {
                         (a1, p1) = poly_split [] p;
                         (b1, q1) = poly_split [] q;
                       } in gt a1 b1 && check_poly_ge p1 q1;

shows_monom ::
  forall a. (Showa a) => [(a, Nat)] -> [Prelude.Char] -> [Prelude.Char];
shows_monom [(x, p)] =
  (if equal_nat p one_nat then shows_prec zero_nat x
    else shows_prec zero_nat x .
           shows_string ['^'] . shows_prec_nat zero_nat p);
shows_monom ((x, p) : v : va) =
  (if equal_nat p one_nat then shows_prec zero_nat x
    else shows_prec zero_nat x .
           shows_string ['^'] . shows_prec_nat zero_nat p) .
    shows_string ['*'] . shows_monom (v : va);
shows_monom [] = shows_string ['1'];

shows_poly ::
  forall a b.
    (Showa a, Eq b, Poly_carrier b,
      Showa b) => [([(a, Nat)], b)] -> [Prelude.Char] -> [Prelude.Char];
shows_poly [] = shows_string ['0'];
shows_poly ((m, c) : p) =
  (if c == onea then shows_monom m
    else (if null m then shows_prec zero_nat c
           else shows_prec zero_nat c . shows_string ['*'] . shows_monom m)) .
    (if null p then shows_string []
      else shows_string [' ', '+', ' '] . shows_poly p);

monom_mult :: forall a. (Eq a) => [(a, Nat)] -> [(a, Nat)] -> [(a, Nat)];
monom_mult [] n = n;
monom_mult ((x, p) : m) n =
  (case extract (\ yq -> fst yq == x) n of {
    Nothing -> (x, p) : monom_mult m n;
    Just (n1, ((_, q), n2)) -> (x, plus_nat p q) : monom_mult m (n1 ++ n2);
  });

monom_mult_poly ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => ([(a, Nat)], b) ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
monom_mult_poly uu [] = [];
monom_mult_poly (ma, c) ((m, d) : p) =
  (if times c d == zeroa then monom_mult_poly (ma, c) p
    else (monom_mult ma m, times c d) : monom_mult_poly (ma, c) p);

poly_add ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
poly_add [] q = q;
poly_add ((m, c) : p) q =
  (case extract (\ mc -> eq_monom (fst mc) m) q of {
    Nothing -> (m, c) : poly_add p q;
    Just (q1, ((_, d), q2)) ->
      (if plus c d == zeroa then poly_add p (q1 ++ q2)
        else (m, plus c d) : poly_add p (q1 ++ q2));
  });

poly_mult ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
poly_mult [] q = [];
poly_mult (mc : p) q = poly_add (monom_mult_poly mc q) (poly_mult p q);

one_poly :: forall a b. (Semiring_1 b) => [([(a, Nat)], b)];
one_poly = [([], onea)];

poly_power ::
  forall a b.
    (Eq a, Eq b,
      Comm_semiring_1 b) => [([(a, Nat)], b)] -> Nat -> [([(a, Nat)], b)];
poly_power uu n =
  (if equal_nat n zero_nat then one_poly
    else poly_mult uu (poly_power uu (minus_nat n one_nat)));

monom_subst ::
  forall a b c.
    (Eq b, Eq c,
      Comm_semiring_1 c) => (a -> [([(b, Nat)], c)]) ->
                              [(a, Nat)] -> [([(b, Nat)], c)];
monom_subst sigma [] = one_poly;
monom_subst sigma ((x, p) : m) =
  poly_mult (poly_power (sigma x) p) (monom_subst sigma m);

zero_poly :: forall a b. [([(a, Nat)], b)];
zero_poly = [];

poly_subst ::
  forall a b c.
    (Eq b, Eq c,
      Comm_semiring_1 c) => (a -> [([(b, Nat)], c)]) ->
                              [([(a, Nat)], c)] -> [([(b, Nat)], c)];
poly_subst sigma [] = zero_poly;
poly_subst sigma ((m, c) : p) =
  poly_add (poly_mult [([], c)] (monom_subst sigma m)) (poly_subst sigma p);

eval_term ::
  forall a b c.
    (Eq b, Poly_carrier b,
      Eq c) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                 Term a c -> [([(c, Nat)], b)];
eval_term uu (Var x) = [([(x, one_nat)], onea)];
eval_term i (Fun f ts) =
  let {
    ps = map (eval_term i) ts;
    n = size_list ts;
  } in poly_subst (\ ia -> (if less_nat ia n then nth ps ia else zero_poly))
         (i (f, n));

check_s ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Showa b, Eq c,
      Showa c) => (a -> a -> Bool) ->
                    ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                      (Term b c, Term b c) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_s gt i =
  (\ (s, t) ->
    let {
      p = eval_term i s;
      q = eval_term i t;
    } in check (check_poly_gt gt p q)
           (shows_string
              ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
                'u', 'r', 'e', ' '] .
             shows_prec_term zero_nat s .
               shows_string [' ', '>', ' '] .
                 shows_prec_term zero_nat t .
                   shows_string
                     [' ', 's', 'i', 'n', 'c', 'e', ' ', 'w', 'e', ' '] .
                     shows_nl .
                       shows_string
                         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e',
                           'n', 's', 'u', 'r', 'e', ' '] .
                         shows_poly p .
                           shows_string [' ', '>', ' '] . shows_poly q));

shows_rpo_repr ::
  forall a.
    (Showa a) => [((a, Nat), (Nat, Order_tag))] ->
                   [Prelude.Char] -> [Prelude.Char];
shows_rpo_repr prs =
  ((((((((((shows_prec_list zero_nat
              ['R', 'P', 'O', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'e', ' ',
                'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'p', 'r', 'e',
                'c', 'e', 'd', 'e', 'n', 'c', 'e'] .
             shows_nl) .
            foldr (\ (a, b) ->
                    let {
                      (f, n) = a;
                    } in (\ (pr, _) ->
                           (((((shows_prec_list zero_nat
                                  ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c',
                                    'e', '('] .
                                 shows_prec zero_nat f) .
                                shows_prec_list zero_nat ['[']) .
                               shows_prec_nat zero_nat n) .
                              shows_prec_list zero_nat
                                [']', ')', ' ', '=', ' ']) .
                             shows_prec_nat zero_nat pr) .
                             shows_nl)
                      b)
              prs) .
           shows_nl) .
          shows_prec_list zero_nat
            ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', '(', '_', ')',
              ' ', '=', ' ', '0']) .
         shows_nl) .
        shows_prec_list zero_nat
          ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w',
            'i', 'n', 'g', ' ', 's', 't', 'a', 't', 'u', 's']) .
       shows_nl) .
      foldr (\ (a, b) ->
              let {
                (f, n) = a;
              } in (\ (_, s) ->
                     (((((shows_prec_list zero_nat
                            ['s', 't', 'a', 't', 'u', 's', '('] .
                           shows_prec zero_nat f) .
                          shows_prec_list zero_nat ['[']) .
                         shows_prec_nat zero_nat n) .
                        shows_prec_list zero_nat [']', ')', ' ', '=', ' ']) .
                       shows_prec_list zero_nat (case s of {
          Lex -> ['l', 'e', 'x'];
          Mul -> ['m', 'u', 'l'];
        })) .
                       shows_nl)
                b)
        prs) .
     shows_nl) .
    shows_prec_list zero_nat
      ['s', 't', 'a', 't', 'u', 's', '(', '_', ')', ' ', '=', ' ', 'l', 'e',
        'x']) .
    shows_nl;

scnp_af_to_af ::
  forall a.
    ((a, Nat) -> [(Nat, Nat)]) -> ((a, Nat) -> Set Nat) -> (a, Nat) -> Set Nat;
scnp_af_to_af pia pi =
  (\ (f, n) ->
    let {
      is = map fst (pia (f, n));
    } in (if any (less_eq_nat n) is then sup_set (pi (f, n)) (set is)
           else set is));

semilattice_set_apply :: forall a. Semilattice_set a -> a -> a -> a;
semilattice_set_apply (Abs_semilattice_set x) = x;

set_fold1 ::
  forall a. (Ceq a, Ccompare a, Lattice a) => Semilattice_set a -> Set a -> a;
set_fold1 f (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold1 RBT_set: ccompare = None" (\ _ -> set_fold1 f (RBT_set rbt));
    Just _ ->
      (if is_emptya rbt
        then (error :: forall a. String -> (() -> a) -> a)
               "set_fold1 RBT_set: empty set" (\ _ -> set_fold1 f (RBT_set rbt))
        else fold1 (semilattice_set_apply f) rbt);
  });
set_fold1 f (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold1 DList_set: ceq = None" (\ _ -> set_fold1 f (DList_set dxs));
    Just _ ->
      (if nulla dxs
        then (error :: forall a. String -> (() -> a) -> a)
               "set_fold1 DList_set: empty set"
               (\ _ -> set_fold1 f (DList_set dxs))
        else foldc (semilattice_set_apply f) (tl dxs) (hd dxs));
  });
set_fold1 f (Set_Monad (x : xs)) = fold (semilattice_set_apply f) xs x;
set_fold1 f (Collect_set p) =
  (error :: forall a. String -> (() -> a) -> a) "set_fold1: Collect_set"
    (\ _ -> set_fold1 f (Collect_set p));
set_fold1 f (Complement a) =
  (error :: forall a. String -> (() -> a) -> a) "set_fold1: Complement"
    (\ _ -> set_fold1 f (Complement a));

projr :: forall a b. Sum a b -> b;
projr (Inr x2) = x2;

rec_term ::
  forall a b c. (a -> b) -> (c -> [(Term c a, b)] -> b) -> Term c a -> b;
rec_term f1 f2 (Var x1) = f1 x1;
rec_term f1 f2 (Fun x21 x22) =
  f2 x21 (map (\ term -> (term, rec_term f1 f2 term)) x22);

mk_subst_domain ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)];
mk_subst_domain sigma =
  let {
    tau = mk_subst Var sigma;
  } in filter (\ (x, t) -> not (equal_term (Var x) t))
         (map (\ x -> (x, tau x)) (remdups (map fst sigma)));

subst_eq ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> Bool;
subst_eq sigma tau = let {
                       sigmaa = mk_subst_domain sigma;
                       taua = mk_subst_domain tau;
                     } in set_eq (set sigmaa) (set taua);

full_af :: forall a. (a, Nat) -> Set Nat;
full_af fn = set (upt zero_nat (snd fn));

add_funas_term :: forall a b. Term a b -> [(a, Nat)] -> [(a, Nat)];
add_funas_term (Var uu) fs = fs;
add_funas_term (Fun f ts) fs = (f, size_list ts) : foldr add_funas_term ts fs;

add_funas_rule :: forall a b. (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
add_funas_rule r fs = add_funas_term (fst r) (add_funas_term (snd r) fs);

funas_trs_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
funas_trs_list trs = foldr add_funas_rule trs [];

funs_rule_list :: forall a b. (Term a b, Term a b) -> [a];
funs_rule_list r = add_funs_rule r [];

vars_rule_list :: forall a b. (Term a b, Term a b) -> [b];
vars_rule_list r = add_vars_rule r [];

supteq_list :: forall a b. Term a b -> [Term a b];
supteq_list (Var x) = [Var x];
supteq_list (Fun f ts) = Fun f ts : concatMap supteq_list ts;

is_NF_main ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool -> ((a, Nat) -> [Term a b]) -> Term a b -> Bool;
is_NF_main var_cond r_empty m =
  (if var_cond then (\ _ -> False)
    else (if r_empty then (\ _ -> True)
           else (\ t ->
                  all (\ u ->
                        (if not (is_Var u)
                          then all (\ l -> not (matches u l)) (m (the (root u)))
                          else True))
                    (supteq_list t))));

is_NF_trs ::
  forall a b c.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, c)] -> Term a b -> Bool;
is_NF_trs r =
  is_NF_main (any (\ ra -> is_Var (fst ra)) r) (null r) (term_map (map fst r));

apply_args :: forall a b. a -> Term a b -> [Term a b] -> Term a b;
apply_args a t [] = t;
apply_args a t (s : ss) = apply_args a (Fun a [t, s]) ss;

get_symbol :: forall a. (a -> Nat -> [a]) -> a -> Nat -> Nat -> a;
get_symbol sm f n i = nth (sm f n) i;

xml2nd_choice ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        [Prelude.Char] ->
          (Xml -> Sum_bot [Prelude.Char] b) ->
            (a -> Maybe b -> c) -> Xml -> Sum_bot [Prelude.Char] c;
xml2nd_choice tag p1 cn p2 f (XML name atts cs) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts && less_eq_nat (nat_of_integer (2 :: Integer)) l
         then binda (p1 (nth cs zero_nat))
                (\ x1 ->
                  binda (bool cn (nth cs one_nat))
                    (\ b ->
                      (if b then binda (p2 (nth cs (minus_nat l one_nat)))
                                   (\ x2 -> returna (f x1 (Just x2)))
                        else returna (f x1 Nothing))))
         else fail tag (XML name atts cs));
xml2nd_choice tag p1 cn p2 f (XML_text v) = fail tag (XML_text v);

rep_afs :: forall a. Afs a -> ((a, Nat) -> Af_entry, Set (a, Nat));
rep_afs (Abs_afs x) = x;

afsa :: forall a. Afs a -> (a, Nat) -> Af_entry;
afsa xa = fst (rep_afs xa);

sum_lpoly ::
  forall a.
    Partial_object_ext a (Monoid_ext a (Ring_ext a ())) -> [a] -> [a] -> [a];
sum_lpoly c [] ys = ys;
sum_lpoly c (v : va) [] = v : va;
sum_lpoly c (x : xs) (y : ys) = add c x y : sum_lpoly c xs ys;

lpoly_of ::
  forall a.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a ())) ->
                Tpoly Nat a -> Sum_bot [Prelude.Char] (a, [a]);
lpoly_of c (PNum i) = returna (i, []);
lpoly_of c (PVar x) = returna (zero c, replicate x (zero c) ++ [one c]);
lpoly_of c (PSum []) = returna (zero c, []);
lpoly_of c (PSum (p : ps)) =
  binda (lpoly_of c p)
    (\ (cp, ncp) ->
      binda (lpoly_of c (PSum ps))
        (\ (cq, ncq) -> returna (add c cp cq, sum_lpoly c ncp ncq)));
lpoly_of c (PMult []) = returna (one c, []);
lpoly_of c (PMult (p : ps)) =
  binda (lpoly_of c p)
    (\ (cp, ncp) ->
      binda (lpoly_of c (PMult ps))
        (\ (cq, ncq) ->
          (if all (\ a -> zero c == a) ncp
            then returna (mult c cp cq, map (mult c cp) ncq)
            else (if all (\ a -> zero c == a) ncq
                   then returna (mult c cp cq, map (\ x -> mult c x cq) ncp)
                   else errora
                          ['c', 'a', 'n', 'n', 'o', 't', ' ', 't', 'r', 'a',
                            'n', 's', 'f', 'o', 'r', 'm', ' ', 'n', 'o', 'n',
                            '-', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'p', 'o',
                            'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 't',
                            'o', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'p',
                            'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']))));

renaming ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] [(a, a)];
renaming xml2name =
  many ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g']
    (pair ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', 'E', 'n', 't', 'r', 'y']
      xml2name xml2name (\ a b -> (a, b)))
    id;

innermostLhss ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [Term a [Prelude.Char]];
innermostLhss xml2name =
  many ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's']
    (term xml2name) id;

strategy ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Strategy a [Prelude.Char]);
strategy xml2name =
  singleton ['s', 't', 'r', 'a', 't', 'e', 'g', 'y']
    (options
      [(['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'],
         leaf ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'] Innermost),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's'],
          change (innermostLhss xml2name) Innermost_Q)])
    id;

xml_term ::
  forall a b c. (Showa a, Showa b, Showa c) => Term (Lab a [b]) c -> Xml;
xml_term (Var x) = XML ['v', 'a', 'r'] [] [XML_text (shows_prec zero_nat x [])];
xml_term (Fun f ts) =
  XML ['f', 'u', 'n', 'a', 'p', 'p'] []
    (xml_lab f : map (\ t -> XML ['a', 'r', 'g'] [] [xml_term t]) ts);

xml_rule ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (Term (Lab a [b]) c, Term (Lab a [b]) c) -> Xml;
xml_rule =
  (\ (l, r) ->
    XML ['r', 'u', 'l', 'e'] []
      [XML ['l', 'h', 's'] [] [xml_term l],
        XML ['r', 'h', 's'] [] [xml_term r]]);

subset ::
  forall a. (Card_UNIV a, Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
subset = subset_eq;

mat_scalar_mult :: forall a. (Times a) => a -> Mat a -> Mat a;
mat_scalar_mult aa a = mat_map (times aa) a;

char_poly_matrix :: forall a. (Eq a, Idom a) => Mat a -> Mat (Poly a);
char_poly_matrix a =
  mat_add
    (mat_scalar_mult (pCons zeroa (pCons onea zero_polya))
      (mat_one (mat_dim_row a)))
    (mat_map (\ aa -> pCons (uminusa aa) zero_polya) a);

char_poly :: forall a. (Field a, Eq a) => Mat a -> Poly a;
char_poly a = det (char_poly_matrix a);

existsM :: forall a b. (a -> Sum b ()) -> [a] -> Sum [b] ();
existsM f [] = Inl [];
existsM f (x : xs) =
  catch_errora (f x)
    (\ e -> catch_errora (existsM f xs) (\ xa -> Inl (e : xa)));

weight ::
  forall a b.
    ((a, Nat) -> Nat) -> Nat -> ((a, Nat) -> Nat -> Nat) -> Term a b -> Nat;
weight w w0 scf (Fun f ts) =
  let {
    n = size_list ts;
    scff = scf (f, n);
  } in plus_nat (w (f, n))
         (listsum
           (map (\ (ti, i) -> times_nat (weight w w0 scf ti) (scff i))
             (zip ts (upt zero_nat n))));
weight w w0 scf (Var x) = w0;

kbo_impl ::
  forall a b.
    (Eq b) => ((a, Nat) -> Nat) ->
                Nat ->
                  ((a, Nat) -> Nat) ->
                    (a -> Bool) ->
                      ((a, Nat) -> Nat -> Nat) ->
                        Term a b -> Term a b -> (Bool, Bool);
kbo_impl w w0 prc least scf s t =
  let {
    wt = weight w w0 scf t;
    ws = weight w w0 scf s;
  } in (if subseteq_mset (vars_term_ms (scf_term scf t))
             (vars_term_ms (scf_term scf s)) &&
             less_eq_nat wt ws
         then (if less_nat wt ws then (True, True)
                else (case s of {
                       Var _ -> (False, (case t of {
  Var _ -> True;
  Fun g ts -> null ts && least g;
}));
                       Fun f ss ->
                         (case t of {
                           Var _ -> (True, True);
                           Fun g ts ->
                             let {
                               pf = prc (f, size_list ss);
                               pg = prc (g, size_list ts);
                             } in (if less_nat pg pf then (True, True)
                                    else (if less_eq_nat pg pf
   then lex_ext_unbounded (kbo_impl w w0 prc least scf) ss ts
   else (False, False)));
                         });
                     }))
         else (False, False));

kbo_strict ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ((a, Nat) -> Nat) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        (a -> Bool) ->
                          ((a, Nat) -> Nat -> Nat) ->
                            (Term a b, Term a b) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
kbo_strict pr w w0 least scf =
  (\ (s, t) ->
    check (fst (kbo_impl w w0 pr least scf s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term zero_nat s .
          shows_string [' ', '>', 'K', 'B', 'O', ' '] .
            shows_prec_term zero_nat t . shows_nl));

list_all2 :: forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool;
list_all2 p (x : xs) (y : ys) = p x y && list_all2 p xs ys;
list_all2 p xs [] = null xs;
list_all2 p [] ys = null ys;

list_diff :: forall a. (Eq a) => [a] -> [a] -> [a];
list_diff [] ys = [];
list_diff (x : xs) ys = let {
                          zs = list_diff xs ys;
                        } in (if membera ys x then zs else x : zs);

single_alist_entry :: forall a b. a -> b -> Alist a b;
single_alist_entry xb xc = Alist [(xb, xc)];

image_mset :: forall a b. (Eq b) => (a -> b) -> Multiset a -> Multiset b;
image_mset f (Bag ms) =
  foldd (\ a n -> plus_multiset (Bag (single_alist_entry (f a) n)))
    zero_multiset ms;

eval :: forall a b c. (a -> [b] -> b) -> (c -> b) -> Term a c -> b;
eval i alpha (Var x) = alpha x;
eval i alpha (Fun f ts) = i f (map (eval i alpha) ts);

poly_vars_list :: forall a b. (Eq a) => [([(a, Nat)], b)] -> [a];
poly_vars_list p = remdups (concatMap (map fst . fst) p);

poly_of ::
  forall a b. (Eq a, Eq b, Comm_semiring_1 b) => Tpoly a b -> [([(a, Nat)], b)];
poly_of (PNum i) = (if i == zeroa then [] else [([], i)]);
poly_of (PVar x) = [([(x, one_nat)], onea)];
poly_of (PSum []) = zero_poly;
poly_of (PSum (p : ps)) = poly_add (poly_of p) (poly_of (PSum ps));
poly_of (PMult []) = one_poly;
poly_of (PMult (p : ps)) = poly_mult (poly_of p) (poly_of (PMult ps));

square_possibilities ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => (a -> [a]) -> [([(b, Nat)], a)] -> [[([(b, Nat)], a)]];
square_possibilities sqrt p =
  let {
    roots =
      map (\ x ->
            map (\ a -> (x, a))
              (sqrt (fst (poly_split [(x, nat_of_integer (2 :: Integer))] p))))
        (poly_vars_list p);
    choices = (if membera roots [] then [] else concat_lists roots);
    polys =
      map (\ xas ->
            poly_of (PSum (map (\ (x, a) -> PMult [PVar x, PNum a]) xas)))
        choices;
  } in polys;

check_poly_eq ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] -> [([(a, Nat)], b)] -> Bool;
check_poly_eq [] q = null q;
check_poly_eq ((m, c) : p) q =
  (case extract (\ nd -> eq_monom (fst nd) m) q of {
    Nothing -> False;
    Just (q1, ((_, d), q2)) -> c == d && check_poly_eq p (q1 ++ q2);
  });

monom_degree :: forall a. [(a, Nat)] -> Nat;
monom_degree xps = listsum (map snd xps);

poly_degree :: forall a b. [([(a, Nat)], b)] -> Nat;
poly_degree p = max_list (map (\ (m, _) -> monom_degree m) p);

check_quadratic ::
  forall a.
    (Eq a,
      Poly_carrier a) => (a -> [a]) ->
                           [([(Nat, Nat)], a)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quadratic sqrt p =
  bindb (check (equal_nat (poly_degree p) (nat_of_integer (2 :: Integer)))
          (shows_prec_list zero_nat
            ['n', 'o', 't', ' ', 'q', 'u', 'a', 'd', 'r', 'a', 't', 'i', 'c']))
    (\ _ ->
      let {
        polys = square_possibilities sqrt p;
      } in check (any (\ q -> check_poly_eq (poly_mult q q) p) polys)
             (shows_prec_list zero_nat
               ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
                 'd', ' ', 'q', 'u', 'a', 'd', 'r', 'a', 't', 'i', 'c', ' ',
                 'p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']));

check_quadratic_ge_const ::
  forall a b c.
    (Eq a, Poly_carrier a,
      Eq c) => (a -> [a]) ->
                 ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                   (Term b c, Term b c) ->
                     Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quadratic_ge_const sq i st =
  let {
    (s, t) = st;
  } in bindb (check (not (is_Var s))
               (shows_prec_list zero_nat
                 ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'n', 'o', 'n', '-',
                   'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's',
                   ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's']))
         (\ _ ->
           let {
             pt = eval_term i t;
             (c, p0) = poly_split [] pt;
           } in bindb (check (p0 == zero_poly)
                        (shows_prec_list zero_nat
                          ['r', 'h', 's', ' ', 'm', 'u', 's', 't', ' ', 'e',
                            'v', 'a', 'l', 'u', 'a', 't', 'e', ' ', 't', 'o',
                            ' ', 'c', 'o', 'n', 's', 't', 'a', 'n', 't']))
                  (\ _ ->
                    let {
                      ps = i (the (root s));
                      (d, psx) = poly_split [] ps;
                    } in bindb (check (less_eq c d)
                                 (shows_prec_list zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                     'n', ' ', 'c', 'o', 'm', 'p', 'a', 'r',
                                     'i', 'n', 'g', ' ', 'c', 'o', 'n', 's',
                                     't', 'a', 'n', 't', 's']))
                           (\ _ -> check_quadratic sq psx)));

check_ns ::
  forall a b c.
    (Showa a, Eq b, Poly_carrier b, Showa b, Eq c,
      Showa c) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                    (Term a c, Term a c) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ns i =
  (\ (s, t) ->
    let {
      p = eval_term i s;
      q = eval_term i t;
    } in check (check_poly_ge p q)
           (shows_string
              ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
                'u', 'r', 'e', ' '] .
             shows_prec_term zero_nat s .
               shows_string [' ', '>', '=', ' '] .
                 shows_prec_term zero_nat t .
                   shows_string
                     [' ', 's', 'i', 'n', 'c', 'e', ' ', 'w', 'e', ' '] .
                     shows_nl .
                       shows_string
                         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e',
                           'n', 's', 'u', 'r', 'e', ' '] .
                         shows_poly p .
                           shows_string [' ', '>', '=', ' '] . shows_poly q));

check_cc ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Showa b, Eq c,
      Showa c) => (a -> [a]) ->
                    (a -> a -> Bool) ->
                      ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                        C_constraint b c ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cc sq gt i (Unconditional_C False st) =
  (if isOK (check_quadratic_ge_const sq i st) then Inr () else check_ns i st);
check_cc sq gt i (Unconditional_C True st) = check_s gt i st;
check_cc sq gt i (Conditional_C True (u, v) (s, t)) =
  let {
    ss = eval_term i s;
    tt = eval_term i t;
    uu = eval_term i u;
    vv = eval_term i v;
  } in (if check_poly_gt gt ss tt then Inr ()
         else check (check_poly_ge (poly_add ss vv) (poly_add tt uu))
                (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                     's', 'u', 'r', 'e', ' '] .
                  shows_prec_term zero_nat u .
                    shows_string [' ', '>', ' '] .
                      shows_prec_term zero_nat v .
                        shows_string [' ', '=', '=', '>', ' '] .
                          shows_prec_term zero_nat s .
                            shows_string [' ', '>', ' '] .
                              shows_prec_term zero_nat t));
check_cc sq gt i (Conditional_C False (u, v) (s, t)) =
  (if isOK (check_quadratic_ge_const sq i (s, t)) then Inr ()
    else let {
           ss = eval_term i s;
           tt = eval_term i t;
           uu = eval_term i u;
           vv = eval_term i v;
         } in (if check_poly_ge ss tt then Inr ()
                else check (check_poly_ge (poly_add ss vv) (poly_add tt uu))
                       (shows_string
                          ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                            'e', 'n', 's', 'u', 'r', 'e', ' '] .
                         shows_prec_term zero_nat u .
                           shows_string [' ', '>', '=', ' '] .
                             shows_prec_term zero_nat v .
                               shows_string [' ', '=', '=', '>', ' '] .
                                 shows_prec_term zero_nat s .
                                   shows_string [' ', '>', '=', ' '] .
                                     shows_prec_term zero_nat t)));

is_left_of :: Pos -> Pos -> Bool;
is_left_of Empty q = False;
is_left_of (PCons i p) q =
  (case q of {
    Empty -> False;
    PCons j qa ->
      (if less_nat i j then True
        else (if less_nat j i then False else is_left_of p qa));
  });

pos_prefix :: Pos -> Pos -> Maybe Pos;
pos_prefix Empty q = Just q;
pos_prefix (PCons i p) q =
  (case q of {
    Empty -> Nothing;
    PCons j qa -> (if equal_nat i j then pos_prefix p qa else Nothing);
  });

pos_suffix :: Pos -> Pos -> Maybe Pos;
pos_suffix p q = (case pos_prefix (rev p) (rev q) of {
                   Nothing -> Nothing;
                   Just qa -> Just (rev qa);
                 });

gcd_divisor :: forall a. (Semiring_gcd a, Idom_div a) => Common_divisor a;
gcd_divisor = Abs_common_divisor gcd;

resultant ::
  forall a. (Semiring_gcd a, Eq a, Idom_div a) => Poly a -> Poly a -> a;
resultant x y = resultant_impl gcd_divisor x y;

rules_with ::
  forall a b c.
    (Linorder b) => (a -> Bool) ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        [(Term b c, Term b c)];
rules_with p m =
  map_filter (\ x -> (if (p . fst) x then Just (snd x) else Nothing))
    (values m);

scnp_desc ::
  forall a.
    (Showa a) => [((a, Nat), [(Nat, Nat)])] ->
                   [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
scnp_desc af mu =
  ((((shows_prec_list zero_nat
        ['S', 'C', 'N', 'P', '-', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'w',
          'i', 't', 'h', ' ', 'm', 'u', ' ', '=', ' '] .
       shows_prec_list zero_nat mu) .
      shows_prec_list zero_nat
        [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'l', 'e', 'v', 'e', 'l',
          ' ', 'm', 'a', 'p', 'p', 'i', 'n', 'g', ' ', 'd', 'e', 'f', 'i', 'n',
          'e', 'd', ' ', 'b', 'y', ' ']) .
     shows_nl) .
    shows_sep
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ asa ->
               ((shows_prec_list zero_nat ['p', 'i', '('] .
                  shows_prec zero_nat f) .
                 shows_prec_list zero_nat [')', ' ', '=', ' ']) .
                 showsp_list
                   (\ _ (p, l) ->
                     (((shows_prec_list zero_nat ['('] .
                         (if less_nat p n then shows_prec_nat zero_nat (suc p)
                           else shows_prec_list zero_nat
                                  ['e', 'p', 's', 'i', 'l', 'o', 'n'])) .
                        shows_prec_list zero_nat [',']) .
                       shows_prec_nat zero_nat l) .
                       shows_prec_list zero_nat [')'])
                   zero_nat asa)
          b)
      shows_nl af) .
    shows_nl;

split_rulesb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_rulesb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = split_rules;

delete_R_Rwb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_R_Rwb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = delete_R_Rw;

nfsb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
nfsb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
       rules_map delete_R_Rw split_rules mk nfs more)
  = nfs;

mkc ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      Bool ->
        [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkc (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
      rules_map delete_R_Rw split_rules mk nfs more)
  = mk;

qb :: forall a b c d. Tp_ops_ext a b c d -> a -> [Term b c];
qb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
     delete_R_Rw split_rules mk nfs more)
  = q;

split_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () -> a -> [(Term b c, Term b c)] -> (a, a);
split_tt i tp r_remove = let {
                           (r, rw) = split_rulesb i tp r_remove;
                           tp1 = mkc i (nfsb i tp) (qb i tp) r rw;
                           a = delete_R_Rwb i tp r_remove r_remove;
                         } in (tp1, a);

funs_term_list :: forall a b. Term a b -> [a];
funs_term_list t = add_funs_term t [];

supt_impl :: forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Bool;
supt_impl (Var x) t = False;
supt_impl (Fun f ss) t = membera ss t || any (\ s -> supt_impl s t) ss;

supt_list :: forall a b. Term a b -> [Term a b];
supt_list (Var x) = [];
supt_list (Fun f ts) = concatMap supteq_list ts;

af_inter ::
  forall a.
    ((a, Nat) -> Set Nat) -> ((a, Nat) -> Set Nat) -> (a, Nat) -> Set Nat;
af_inter pi mu f = inf_set (pi f) (mu f);

empty_af :: forall a. (a, Nat) -> Set Nat;
empty_af fn = set_empty (of_phantom set_impl_nat);

r_sym :: forall a b. Ta_rule a b -> (b, Nat);
r_sym (TA_rule f qs q) = (f, size_list qs);

shows_rule ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          (Term a b, Term a b) -> [Prelude.Char] -> [Prelude.Char];
shows_rule fun var arr (l, r) =
  (shows_term fun var l . shows_prec_list zero_nat arr) . shows_term fun var r;

shows_rules ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          [(Term a b, Term a b)] -> [Prelude.Char] -> [Prelude.Char];
shows_rules fun var arr trs =
  shows_list_gen (shows_rule fun var arr) [] [] ['\n'] [] trs . shows_nl;

shows_trs ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          [Prelude.Char] ->
            [(Term a b, Term a b)] -> [Prelude.Char] -> [Prelude.Char];
shows_trs fun var name arr r =
  ((shows_prec_list zero_nat name . shows_nl) . shows_nl) .
    shows_rules fun var arr r;

aarity_term ::
  forall a b. (Eq a) => a -> (a -> Nat -> [a]) -> Term a b -> Maybe Nat;
aarity_term a sm t =
  (case unapp a t of {
    (Var _, _) -> Nothing;
    (Fun f ss, ts) ->
      Just (minus_nat (aarity sm f (size_list ss)) (size_list ts));
  });

map_funs_term_wa :: forall a b c. ((a, Nat) -> b) -> Term a c -> Term b c;
map_funs_term_wa fg (Var x) = Var x;
map_funs_term_wa fg (Fun f ts) =
  Fun (fg (f, size_list ts)) (map (map_funs_term_wa fg) ts);

uncurry_top ::
  forall a b. (Eq a) => a -> Nat -> (a -> Nat -> [a]) -> Term a b -> Term a b;
uncurry_top a n sm (Fun f ts) =
  let {
    mt = map (map_funs_term_wa (\ (fa, na) -> get_symbol sm fa na zero_nat));
    (h, m) = the (root (hda ts));
  } in (if f == a &&
             equal_nat (size_list ts) n &&
               not (is_Var (hda ts)) && not (equal_nat (aarity sm h m) zero_nat)
         then let {
                (Fun g ss) = hda ts;
              } in Fun (get_symbol sm g (size_list ss) one_nat)
                     (mt (ss ++ tla ts))
         else Fun (let {
                     (fa, na) = (f, size_list ts);
                   } in get_symbol sm fa na zero_nat)
                (mt ts));
uncurry_top a n sm (Var x) = Var x;

aABin :: forall a b. (Eq a) => a -> Acterm a b -> Acterm a b -> Acterm a b;
aABin f (AFun g [s, t]) u =
  (if f == g then AFun f [s, aABin f t u] else AFun f [AFun g [s, t], u]);
aABin f (AVar v) t = AFun f [AVar v, t];
aABin f (AFun v []) t = AFun f [AFun v [], t];
aABin f (AFun v [vb]) t = AFun f [AFun v [vb], t];
aABin f (AFun v (vb : vd : vf : vg)) t = AFun f [AFun v (vb : vd : vf : vg), t];
aABin f (AAC v va) t = AFun f [AAC v va, t];

actop :: forall a b. (Eq a, Eq b) => a -> Term a b -> Multiset (Term a b);
actop f (Fun g [s, t]) =
  (if f == g then plus_multiset (actop f s) (actop f t)
    else single (Fun g [s, t]));
actop f (Var v) = single (Var v);
actop f (Fun v []) = single (Fun v []);
actop f (Fun v [vb]) = single (Fun v [vb]);
actop f (Fun v (vb : vd : vf : vg)) = single (Fun v (vb : vd : vf : vg));

aocnf ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Eq b) => Set a -> Set a -> Term a b -> Acterm a b;
aocnf f_A f_C (Fun f (s : t : u : us)) =
  AFun f
    (aocnf f_A f_C s :
      aocnf f_A f_C t : aocnf f_A f_C u : map (aocnf f_A f_C) us);
aocnf f_A f_C (Fun f [t]) = AFun f [aocnf f_A f_C t];
aocnf f_A f_C (Fun f []) = AFun f [];
aocnf f_A f_C (Fun f [s, t]) =
  let {
    a = member f f_A;
    c = member f f_C;
  } in (if a && c
         then AAC f (image_mset (aocnf f_A f_C) (actop f (Fun f [s, t])))
         else (if a then aABin f (aocnf f_A f_C s) (aocnf f_A f_C t)
                else (if c then AAC f (plus_multiset (single (aocnf f_A f_C s))
(single (aocnf f_A f_C t)))
                       else AFun f [aocnf f_A f_C s, aocnf f_A f_C t])));
aocnf f_A f_C (Var x) = AVar x;

arith_fun :: Xml -> Sum_bot [Prelude.Char] ArithFun;
arith_fun xml =
  singleton ['a', 'r', 'i', 't', 'h', 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n']
    (options
      [(['n', 'a', 't', 'u', 'r', 'a', 'l'],
         change (nata ['n', 'a', 't', 'u', 'r', 'a', 'l']) Const),
        (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'],
          change (nata ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'])
            (\ n -> Arg (minus_nat n one_nat))),
        (['s', 'u', 'm'], many ['s', 'u', 'm'] arith_fun Sum),
        (['p', 'r', 'o', 'd', 'u', 'c', 't'],
          many ['p', 'r', 'o', 'd', 'u', 'c', 't'] arith_fun Prod),
        (['m', 'i', 'n'], many ['m', 'i', 'n'] arith_fun Min),
        (['m', 'a', 'x'], many ['m', 'a', 'x'] arith_fun Max),
        (['i', 'f', 'E', 'q', 'u', 'a', 'l'],
          tuple4 ['i', 'f', 'E', 'q', 'u', 'a', 'l'] arith_fun arith_fun
            arith_fun arith_fun IfEqual)])
    id xml;

int_coeff :: Xml -> Sum_bot [Prelude.Char] Int;
int_coeff = int ['i', 'n', 't', 'e', 'g', 'e', 'r'];

vec_coeff ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] (Vec a);
vec_coeff xml2coeff =
  many ['v', 'e', 'c', 't', 'o', 'r']
    (singleton ['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't'] xml2coeff
      id)
    vec_of_list;

mat_coeff ::
  forall a.
    Nat ->
      a -> (Xml -> Sum_bot [Prelude.Char] a) ->
             Xml -> Sum_bot [Prelude.Char] (Mat a);
mat_coeff n ze xml2coeff =
  options
    [(['m', 'a', 't', 'r', 'i', 'x'],
       many ['m', 'a', 't', 'r', 'i', 'x'] (vec_coeff xml2coeff)
         (mat_of_cols n)),
      (['v', 'e', 'c', 't', 'o', 'r'],
        change (vec_coeff xml2coeff)
          (\ v ->
            mat n n
              (\ (i, j) ->
                (if equal_nat j zero_nat then vec_index v i else ze))))];

closed_criterion :: Xml -> Sum_bot [Prelude.Char] (Ta_relation [Prelude.Char]);
closed_criterion =
  singleton ['c', 'r', 'i', 't', 'e', 'r', 'i', 'o', 'n']
    (options
      [(['c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y'],
         leaf ['c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y']
           Id_Relation),
        (['s', 't', 'a', 't', 'e', 'C', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'i',
           'l', 'i', 't', 'y'],
          singleton
            ['s', 't', 'a', 't', 'e', 'C', 'o', 'm', 'p', 'a', 't', 'i', 'b',
              'i', 'l', 'i', 't', 'y']
            (many ['r', 'e', 'l', 'a', 't', 'i', 'o', 'n']
              (pair ['e', 'n', 't', 'r', 'y'] state state (\ a b -> (a, b))) id)
            Some_Relation),
        (['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', 'P', 'r', 'o', 'c', 'e', 'd',
           'u', 'r', 'e'],
          leaf ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', 'P', 'r', 'o', 'c', 'e',
                 'd', 'u', 'r', 'e']
            Decision_Proc),
        (['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', 'P', 'r', 'o', 'c', 'e', 'd',
           'u', 'r', 'e', 'O', 'l', 'd'],
          leaf ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', 'P', 'r', 'o', 'c', 'e',
                 'd', 'u', 'r', 'e', 'O', 'l', 'd']
            Decision_Proc_Old)])
    id;

final_states :: Xml -> Sum_bot [Prelude.Char] [[Prelude.Char]];
final_states =
  many ['f', 'i', 'n', 'a', 'l', 'S', 't', 'a', 't', 'e', 's'] state id;

transition_lhs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Sum a [Prelude.Char]);
transition_lhs xml2lhs =
  choice ['l', 'h', 's']
    [singleton ['l', 'h', 's'] state Inr, change xml2lhs Inl];

transition ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]])) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Sum (Ta_rule [Prelude.Char] a) ([Prelude.Char], [Prelude.Char]));
transition xml2lhs =
  pair ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n']
    (transition_lhs xml2lhs) (singleton ['r', 'h', 's'] state id)
    (\ lhs q -> (case lhs of {
                  Inl (f, qs) -> Inl (TA_rule f qs q);
                  Inr qa -> Inr (qa, q);
                }));

transitions ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]])) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ([Ta_rule [Prelude.Char] a], [([Prelude.Char], [Prelude.Char])]);
transitions xml2lhs =
  many ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 's']
    (transition xml2lhs)
    (\ rls -> let {
                (rules, eps) = partition (\ a -> (case a of {
           Inl _ -> True;
           Inr _ -> False;
         }))
                                 rls;
                ruls = map (\ (Inl r) -> r) rules;
                a = map (\ (Inr e) -> e) eps;
              } in (ruls, a));

tree_automaton ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]])) ->
      Xml -> Sum_bot [Prelude.Char] (Tree_automaton [Prelude.Char] a);
tree_automaton xml2lhs =
  pair ['t', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n']
    final_states (transitions xml2lhs) (\ f (a, b) -> Tree_Automaton f a b);

ta_normal_lhs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]]);
ta_normal_lhs xml2name = many1 ['l', 'h', 's'] xml2name state (\ a b -> (a, b));

not_wn_ta ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Not_wn_ta_prf a [Prelude.Char]);
not_wn_ta xml2name =
  pair ['n', 'o', 't', 'W', 'N', 'T', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm',
         'a', 't', 'o', 'n']
    (tree_automaton (ta_normal_lhs xml2name)) closed_criterion Not_wn_ta_prf;

plain_var :: Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
plain_var x = text ['v', 'a', 'r'] x;

precedence_weight ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Nat -> ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat));
precedence_weight xml2name =
  many ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'W', 'e', 'i', 'g',
         'h', 't']
    (guard (\ x -> equal_nat (num_children x) (nat_of_integer (4 :: Integer)))
      (tuple4
        ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'W', 'e', 'i', 'g',
          'h', 't', 'E', 'n', 't', 'r', 'y']
        xml2name (nata ['a', 'r', 'i', 't', 'y'])
        (nata ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e'])
        (nata ['w', 'e', 'i', 'g', 'h', 't'])
        (\ f a p w -> ((f, a), (p, (w, Nothing)))))
      (tuple5
        ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'W', 'e', 'i', 'g',
          'h', 't', 'E', 'n', 't', 'r', 'y']
        xml2name (nata ['a', 'r', 'i', 't', 'y'])
        (nata ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e'])
        (nata ['w', 'e', 'i', 'g', 'h', 't'])
        (many ['s', 'u', 'b', 't', 'e', 'r', 'm', 'C', 'o', 'e', 'f', 'f', 'i',
                'c', 'i', 'e', 'n', 't', 'E', 'n', 't', 'r', 'i', 'e', 's']
          (nata ['e', 'n', 't', 'r', 'y']) id)
        (\ f a p w e -> ((f, a), (p, (w, Just e))))))
    (\ a b -> (a, b));

xml2to3elements ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> b -> Maybe c -> d) -> Xml -> Sum_bot [Prelude.Char] d;
xml2to3elements tag p1 p2 p3 f (XML name atts cs) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts &&
               less_eq_nat (nat_of_integer (2 :: Integer)) l &&
                 less_eq_nat l (nat_of_integer (3 :: Integer))
         then binda (p1 (nth cs zero_nat))
                (\ x1 ->
                  binda (p2 (nth cs one_nat))
                    (\ x2 ->
                      (if equal_nat l (nat_of_integer (3 :: Integer))
                        then binda (p3 (nth cs (nat_of_integer (2 :: Integer))))
                               (\ x3 -> returna (f x1 x2 (Just x3)))
                        else returna (f x1 x2 Nothing))))
         else fail tag (XML name atts cs));
xml2to3elements tag p1 p2 p3 f (XML_text v) = fail tag (XML_text v);

knuth_bendix_order ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
knuth_bendix_order xml2name =
  xml2to3elements
    ['k', 'n', 'u', 't', 'h', 'B', 'e', 'n', 'd', 'i', 'x', 'O', 'r', 'd', 'e',
      'r']
    (nata ['w', '0']) (precedence_weight xml2name) (afs xml2name)
    (\ w0 prw afo -> let {
                       a = (case afo of {
                             Nothing -> [];
                             Just af -> af;
                           });
                     } in KBO (prw w0) a);

arctic_rat_linear_poly ::
  forall a.
    Interpretation a -> ((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]));
arctic_rat_linear_poly (Arctic_rat_linear_poly x4) = x4;

real_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Real)]);
real_non_linear_poly (Real_non_linear_poly x13) = x13;

rat_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Rat)]);
rat_non_linear_poly (Rat_non_linear_poly x12) = x12;

int_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Int)]);
int_non_linear_poly (Int_non_linear_poly x11) = x11;

arctic_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), (Arctic, [Arctic]));
arctic_linear_poly (Arctic_linear_poly x3) = x3;

arctic_rat_matrix ::
  forall a.
    Interpretation a ->
      ((a, Nat), (Mat (Arctic_delta Rat), [Mat (Arctic_delta Rat)]));
arctic_rat_matrix (Arctic_rat_matrix x9) = x9;

real_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Real, [Real]));
real_linear_poly (Real_linear_poly x5) = x5;

rat_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Rat, [Rat]));
rat_linear_poly (Rat_linear_poly x2) = x2;

int_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Int, [Int]));
int_linear_poly (Int_linear_poly x1) = x1;

arctic_matrix ::
  forall a. Interpretation a -> ((a, Nat), (Mat Arctic, [Mat Arctic]));
arctic_matrix (Arctic_matrix x8) = x8;

real_matrix :: forall a. Interpretation a -> ((a, Nat), (Mat Real, [Mat Real]));
real_matrix (Real_matrix x10) = x10;

rat_matrix :: forall a. Interpretation a -> ((a, Nat), (Mat Rat, [Mat Rat]));
rat_matrix (Rat_matrix x7) = x7;

int_matrix :: forall a. Interpretation a -> ((a, Nat), (Mat Int, [Mat Int]));
int_matrix (Int_matrix x6) = x6;

class_semiring ::
  forall a b.
    (Ceq a, Ccompare a, One a, Plus a, Times a, Zero a,
      Set_impl a) => Itself a ->
                       b -> Partial_object_ext a (Monoid_ext a (Ring_ext a b));
class_semiring uu b =
  Partial_object_ext top_set (Monoid_ext times onea (Ring_ext zeroa plus b));

real_domain :: Xml -> Sum_bot [Prelude.Char] Real;
real_domain =
  singleton
    ['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c', 'N', 'u', 'm', 'b', 'e', 'r',
      's']
    (singleton ['d', 'e', 'l', 't', 'a'] real id) id;

rat_domain :: Xml -> Sum_bot [Prelude.Char] Rat;
rat_domain =
  singleton ['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's']
    (singleton ['d', 'e', 'l', 't', 'a'] rat id) id;

basic_domain :: Xml -> Sum_bot [Prelude.Char] (Nat -> Domain);
basic_domain =
  options
    [(['n', 'a', 't', 'u', 'r', 'a', 'l', 's'],
       leaf ['n', 'a', 't', 'u', 'r', 'a', 'l', 's'] Natural),
      (['i', 'n', 't', 'e', 'g', 'e', 'r', 's'],
        leaf ['i', 'n', 't', 'e', 'g', 'e', 'r', 's'] (\ _ -> Integera)),
      (['a', 'r', 'c', 't', 'i', 'c'],
        singleton ['a', 'r', 'c', 't', 'i', 'c']
          (singleton ['d', 'o', 'm', 'a', 'i', 'n']
            (options
              [(['n', 'a', 't', 'u', 'r', 'a', 'l', 's'],
                 leaf ['n', 'a', 't', 'u', 'r', 'a', 'l', 's'] (\ _ -> Arctic)),
                (['i', 'n', 't', 'e', 'g', 'e', 'r', 's'],
                  leaf ['i', 'n', 't', 'e', 'g', 'e', 'r', 's']
                    (\ _ -> Arctic)),
                (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's'],
                  change rat_domain (\ _ _ -> Arctic_rat))])
            id)
          id),
      (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's'],
        change rat_domain Rational),
      (['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c', 'N', 'u', 'm', 'b', 'e',
         'r', 's'],
        change real_domain Mini_Alg)];

interpretation_type :: Xml -> Sum_bot [Prelude.Char] Domain;
interpretation_type =
  singleton ['t', 'y', 'p', 'e']
    (options
      [(['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l'],
         pair ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']
           (singleton ['d', 'o', 'm', 'a', 'i', 'n']
             (options
               [(['n', 'a', 't', 'u', 'r', 'a', 'l', 's'], basic_domain),
                 (['i', 'n', 't', 'e', 'g', 'e', 'r', 's'], basic_domain),
                 (['a', 'r', 'c', 't', 'i', 'c'], basic_domain),
                 (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's'], basic_domain),
                 (['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c', 'N', 'u', 'm',
                    'b', 'e', 'r', 's'],
                   basic_domain),
                 (['m', 'a', 't', 'r', 'i', 'c', 'e', 's'],
                   triple ['m', 'a', 't', 'r', 'i', 'c', 'e', 's']
                     (nata ['d', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n'])
                     (nata ['s', 't', 'r', 'i', 'c', 't', 'D', 'i', 'm', 'e',
                             'n', 's', 'i', 'o', 'n'])
                     (singleton ['d', 'o', 'm', 'a', 'i', 'n'] basic_domain id)
                     (\ di sd domain d ->
                       (case domain d of {
                         Natural _ -> Int_mat di sd;
                         Integera -> Int_mat di sd;
                         Arctic -> Arctic_mat di;
                         Arctic_rat -> Arctic_rat_mat di;
                         Rational _ _ -> Rat_mat di sd;
                         Mini_Alg _ _ -> Mini_Alg_mat di sd;
                       })))])
             id)
           (nata ['d', 'e', 'g', 'r', 'e', 'e']) (\ typea -> typea)),
        (['m', 'a', 't', 'r', 'i', 'x', 'I', 'n', 't', 'e', 'r', 'p', 'r', 'e',
           't', 'a', 't', 'i', 'o', 'n'],
          triple
            ['m', 'a', 't', 'r', 'i', 'x', 'I', 'n', 't', 'e', 'r', 'p', 'r',
              'e', 't', 'a', 't', 'i', 'o', 'n']
            (singleton ['d', 'o', 'm', 'a', 'i', 'n'] basic_domain id)
            (nata ['d', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n'])
            (nata ['s', 't', 'r', 'i', 'c', 't', 'D', 'i', 'm', 'e', 'n', 's',
                    'i', 'o', 'n'])
            (\ domain di sd -> (case domain zero_nat of {
                                 Natural _ -> Int_mat di sd;
                                 Integera -> Int_mat di sd;
                                 Arctic -> Arctic_mat di;
                                 Arctic_rat -> Arctic_rat_mat di;
                                 Rational _ _ -> Rat_mat di sd;
                                 Mini_Alg _ _ -> Mini_Alg_mat di sd;
                               })))])
    id;

arctic_rat_coeff :: Xml -> Sum_bot [Prelude.Char] (Arctic_delta Rat);
arctic_rat_coeff =
  options
    [(['i', 'n', 't', 'e', 'g', 'e', 'r'], change rat Num_arc_delta),
      (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l'], change rat Num_arc_delta),
      (['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y'],
        leaf ['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y']
          MinInfty_delta)];

arctic_coeff :: Xml -> Sum_bot [Prelude.Char] Arctic;
arctic_coeff =
  options
    [(['i', 'n', 't', 'e', 'g', 'e', 'r'],
       change (int ['i', 'n', 't', 'e', 'g', 'e', 'r']) Num_arc),
      (['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y'],
        leaf ['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y']
          MinInfty)];

polynomial ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Tpoly Nat a);
polynomial xml2coeff x =
  singleton ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']
    (options
      [(['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't'],
         singleton ['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't']
           xml2coeff PNum),
        (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'],
          change (nata ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'])
            (\ n -> PVar (minus_nat n one_nat))),
        (['s', 'u', 'm'], many ['s', 'u', 'm'] (polynomial xml2coeff) PSum),
        (['p', 'r', 'o', 'd', 'u', 'c', 't'],
          many ['p', 'r', 'o', 'd', 'u', 'c', 't'] (polynomial xml2coeff)
            PMult)])
    id x;

fit_length ::
  forall a.
    Partial_object_ext a (Monoid_ext a (Ring_ext a ())) -> Nat -> [a] -> [a];
fit_length c n uu =
  (if equal_nat n zero_nat then []
    else (case uu of {
           [] -> replicate (suc (minus_nat n one_nat)) (zero c);
           b : bs -> b : fit_length c (minus_nat n one_nat) bs;
         }));

interpretation ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
interpretation bi xml2name =
  many1_gen
    ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
    interpretation_type
    (\ a ->
      (case a of {
        Natural deg ->
          (if less_eq_nat deg one_nat && not bi
            then triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial int_coeff x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Int_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial int_coeff x)
                       (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Int_non_linear_poly ((f, aa), poly)));
        Integera ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x -> binda (polynomial int_coeff x) (\ p -> returna (poly_of p)))
            (\ f aa poly -> Int_non_linear_poly ((f, aa), poly));
        Arctic ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial arctic_coeff x)
                (lpoly_of (class_semiring Type ())))
            (\ f aa poly ->
              Arctic_linear_poly
                ((f, aa),
                  (fst poly,
                    fit_length (class_semiring Type ()) aa (snd poly))));
        Arctic_rat ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial arctic_rat_coeff x)
                (lpoly_of (class_semiring Type ())))
            (\ f aa poly ->
              Arctic_rat_linear_poly
                ((f, aa),
                  (fst poly,
                    fit_length (class_semiring Type ()) aa (snd poly))));
        Int_mat n _ ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff n zero_int int_coeff) x)
                (lpoly_of (mat_ring Type n ())))
            (\ f aa poly ->
              Int_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring Type n ()) aa (snd poly))));
        Arctic_mat n ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff n MinInfty arctic_coeff) x)
                (lpoly_of (mat_ring Type n ())))
            (\ f aa poly ->
              Arctic_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring Type n ()) aa (snd poly))));
        Arctic_rat_mat n ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff n MinInfty_delta arctic_rat_coeff) x)
                (lpoly_of (mat_ring Type n ())))
            (\ f aa poly ->
              Arctic_rat_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring Type n ()) aa (snd poly))));
        Rational _ deg ->
          (if less_eq_nat deg one_nat && not bi
            then triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial rat x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Rat_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial rat x) (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Rat_non_linear_poly ((f, aa), poly)));
        Rat_mat n _ ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff n zero_rat rat) x)
                (lpoly_of (mat_ring Type n ())))
            (\ f aa poly ->
              Rat_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring Type n ()) aa (snd poly))));
        Mini_Alg _ deg ->
          (if less_eq_nat deg one_nat && not bi
            then triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial real x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Real_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial real x) (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Real_non_linear_poly ((f, aa), poly)));
        Mini_Alg_mat n _ ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff n zero_real real) x)
                (lpoly_of (mat_ring Type n ())))
            (\ f aa poly ->
              Real_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring Type n ()) aa (snd poly))));
      }))
    (\ typea pi ->
      (case typea of {
        Natural deg ->
          (if less_eq_nat deg one_nat && not bi
            then Int_carrier (map int_linear_poly pi)
            else Int_nl_carrier (map int_non_linear_poly pi));
        Integera -> Int_nl_carrier (map int_non_linear_poly pi);
        Arctic -> Arctic_carrier (map arctic_linear_poly pi);
        Arctic_rat -> Arctic_rat_carrier (map arctic_rat_linear_poly pi);
        Int_mat n sd -> Int_mat_carrier n sd (map int_matrix pi);
        Arctic_mat n -> Arctic_mat_carrier n (map arctic_matrix pi);
        Arctic_rat_mat n -> Arctic_rat_mat_carrier n (map arctic_rat_matrix pi);
        Rational d deg ->
          (if less_eq_nat deg one_nat && not bi
            then Rat_carrier (map rat_linear_poly pi)
            else Rat_nl_carrier d (map rat_non_linear_poly pi));
        Rat_mat n sd -> Rat_mat_carrier n sd (map rat_matrix pi);
        Mini_Alg d deg ->
          (if less_eq_nat deg one_nat && not bi
            then Real_carrier (map real_linear_poly pi)
            else Real_nl_carrier d (map real_non_linear_poly pi));
        Mini_Alg_mat n sd -> Real_mat_carrier n sd (map real_matrix pi);
      }));

wpo_params ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), (Nat, [Nat]))];
wpo_params xml2name =
  many ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'S', 't', 'a', 't',
         'u', 's']
    (tuple4
      ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'S', 't', 'a', 't',
        'u', 's', 'E', 'n', 't', 'r', 'y']
      xml2name (nata ['a', 'r', 'i', 't', 'y'])
      (nata ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e'])
      (many ['s', 't', 'a', 't', 'u', 's'] position id)
      (\ f a p s -> ((f, a), (p, s))))
    id;

status_precedence ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), (Nat, Order_tag))];
status_precedence xml2name =
  many ['s', 't', 'a', 't', 'u', 's', 'P', 'r', 'e', 'c', 'e', 'd', 'e', 'n',
         'c', 'e']
    (tuple4
      ['s', 't', 'a', 't', 'u', 's', 'P', 'r', 'e', 'c', 'e', 'd', 'e', 'n',
        'c', 'e', 'E', 'n', 't', 'r', 'y']
      xml2name (nata ['a', 'r', 'i', 't', 'y'])
      (nata ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e'])
      (options
        [(['l', 'e', 'x'], leaf ['l', 'e', 'x'] Lex),
          (['m', 'u', 'l'], leaf ['m', 'u', 'l'] Mul)])
      (\ f a p s -> ((f, a), (p, s))))
    id;

xml1to2elements ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> Maybe b -> c) -> Xml -> Sum_bot [Prelude.Char] c;
xml1to2elements tag p1 p2 f (XML name atts cs) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts &&
               less_eq_nat one_nat l &&
                 less_eq_nat l (nat_of_integer (2 :: Integer))
         then binda (p1 (nth cs zero_nat))
                (\ x1 ->
                  (if equal_nat l (nat_of_integer (2 :: Integer))
                    then binda (p2 (nth cs one_nat))
                           (\ x2 -> returna (f x1 (Just x2)))
                    else returna (f x1 Nothing)))
         else fail tag (XML name atts cs));
xml1to2elements tag p1 p2 f (XML_text v) = fail tag (XML_text v);

path_order ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
path_order xml2name =
  xml1to2elements ['p', 'a', 't', 'h', 'O', 'r', 'd', 'e', 'r']
    (status_precedence xml2name) (afs xml2name)
    (\ prec_tau afo -> let {
                         a = (case afo of {
                               Nothing -> [];
                               Just af -> af;
                             });
                       } in RPO prec_tau a);

redtriple ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
redtriple bi xml2name x =
  singleton ['r', 'e', 'd', 'P', 'a', 'i', 'r']
    (options
      [(['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n'],
         interpretation bi xml2name),
        (['p', 'a', 't', 'h', 'O', 'r', 'd', 'e', 'r'], path_order xml2name),
        (['k', 'n', 'u', 't', 'h', 'B', 'e', 'n', 'd', 'i', 'x', 'O', 'r', 'd',
           'e', 'r'],
          knuth_bendix_order xml2name),
        (['w', 'e', 'i', 'g', 'h', 't', 'e', 'd', 'P', 'a', 't', 'h', 'O', 'r',
           'd', 'e', 'r'],
          pair ['w', 'e', 'i', 'g', 'h', 't', 'e', 'd', 'P', 'a', 't', 'h', 'O',
                 'r', 'd', 'e', 'r']
            (wpo_params xml2name) (redtriple bi xml2name) WPO)])
    id x;

signature ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [(a, Nat)];
signature = symbols ['s', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e'];

joinable_critical_pairs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(Term a [Prelude.Char],
             ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                       Term a [Prelude.Char]))],
               (Term a [Prelude.Char],
                 [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                          Term a [Prelude.Char]))])))];
joinable_critical_pairs xml2name =
  let {
    rew = rsteps xml2name;
  } in many ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i',
              'c', 'a', 'l', 'P', 'a', 'i', 'r', 's']
         (pair ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i',
                 'c', 'a', 'l', 'P', 'a', 'i', 'r']
           rew rew (\ (s, sseq) (t, tseq) -> (s, (sseq, (t, tseq)))))
         id;

wcr_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Join_info a);
wcr_proof xml2name =
  singleton ['w', 'c', 'r', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i', 'c',
          'a', 'l', 'P', 'a', 'i', 'r', 's'],
         change (joinable_critical_pairs xml2name) Guided),
        (['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i', 'c',
           'a', 'l', 'P', 'a', 'i', 'r', 's', 'B', 'F', 'S'],
          change
            (nata ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't',
                    'i', 'c', 'a', 'l', 'P', 'a', 'i', 'r', 's', 'B', 'F', 'S'])
            Join_BFS),
        (['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i', 'c',
           'a', 'l', 'P', 'a', 'i', 'r', 's', 'A', 'u', 't', 'o'],
          leaf ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i',
                 'c', 'a', 'l', 'P', 'a', 'i', 'r', 's', 'A', 'u', 't', 'o']
            Join_NF)])
    id;

xml2equational_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ([(Term a [Prelude.Char], Term a [Prelude.Char])],
            (Term a [Prelude.Char], Term a [Prelude.Char]));
xml2equational_input xml2name =
  pair ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'a', 's',
         'o', 'n', 'i', 'n', 'g', 'I', 'n', 'p', 'u', 't']
    (singleton ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] (rules xml2name)
      id)
    (pair ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n'] (term xml2name)
      (term xml2name) (\ a b -> (a, b)))
    (\ a b -> (a, b));

complexity_measure ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Complexity_measure a [Prelude.Char]);
complexity_measure xml2name =
  options
    [(['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o',
        'm', 'p', 'l', 'e', 'x', 'i', 't', 'y'],
       singleton
         ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o',
           'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
         (signature xml2name) Derivational_Complexity),
      (['r', 'u', 'n', 't', 'i', 'm', 'e', 'C', 'o', 'm', 'p', 'l', 'e', 'x',
         'i', 't', 'y'],
        pair ['r', 'u', 'n', 't', 'i', 'm', 'e', 'C', 'o', 'm', 'p', 'l', 'e',
               'x', 'i', 't', 'y']
          (signature xml2name) (signature xml2name) Runtime_Complexity)];

complexity_class :: Xml -> Sum_bot [Prelude.Char] Complexity_class;
complexity_class =
  change (nata ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']) Comp_Poly;

forbidden_pattern ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location));
forbidden_pattern xml2name xml =
  binda (triple
          ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e',
            'r', 'n']
          (term xml2name) pos
          (options
            [(['h', 'e', 'r', 'e'], leaf ['h', 'e', 'r', 'e'] H),
              (['a', 'b', 'o', 'v', 'e'], leaf ['a', 'b', 'o', 'v', 'e'] A),
              (['b', 'e', 'l', 'o', 'w'], leaf ['b', 'e', 'l', 'o', 'w'] Ba),
              (['r', 'i', 'g', 'h', 't'], leaf ['b', 'e', 'l', 'o', 'w'] Ra)])
          (\ t p l -> (t, (p, l))) xml)
    (\ (t, (p, l)) ->
      (if in_poss p t then returna (ctxt_of_pos_term p t, (subt_at t p, l))
        else errora
               ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'd', 'o', 'e', 's',
                 ' ', 'n', 'o', 't', ' ', 'e', 'x', 'i', 's', 't', ' ', 'i',
                 'n', ' ', 't', 'e', 'r', 'm']));

forbidden_patterns ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
forbidden_patterns xml2name =
  many ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e',
         'r', 'n', 's']
    (forbidden_pattern xml2name) id;

replacement_map ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), [Nat])];
replacement_map xml2name =
  many ['c', 'o', 'n', 't', 'e', 'x', 't', 'S', 'e', 'n', 's', 'i', 't', 'i',
         'v', 'e']
    (many2
      ['r', 'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', 'M', 'a', 'p',
        'E', 'n', 't', 'r', 'y']
      xml2name (nata ['a', 'r', 'i', 't', 'y']) position
      (\ f a -> (\ b -> ((f, a), b))))
    id;

inn_fp_strategy ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Sum (Strategy a [Prelude.Char]) (Fp_strategy a [Prelude.Char]));
inn_fp_strategy xml2name =
  singleton ['s', 't', 'r', 'a', 't', 'e', 'g', 'y']
    (options
      [(['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'],
         leaf ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'] (Inl Innermost)),
        (['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't'],
          leaf ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't'] (Inr Outermost)),
        (['c', 'o', 'n', 't', 'e', 'x', 't', 'S', 'e', 'n', 's', 'i', 't', 'i',
           'v', 'e'],
          change (replacement_map xml2name) (\ p -> Inr (Context_Sensitive p))),
        (['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e',
           'r', 'n', 's'],
          change (forbidden_patterns xml2name)
            (\ p -> Inr (Forbidden_Patterns p))),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's'],
          change (innermostLhss xml2name) (\ q -> Inl (Innermost_Q q)))])
    id;

xml2pre_trs_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Input a [Prelude.Char]);
xml2pre_trs_input xml2name x =
  let {
    e = fail ['t', 'r', 's', 'I', 'n', 'p', 'u', 't'] x;
  } in binda (case x of {
               XML _ [] [] -> e;
               XML taga [] (c : cs) ->
                 (if less_eq_nat (size_list cs)
                       (nat_of_integer (2 :: Integer)) &&
                       taga == ['t', 'r', 's', 'I', 'n', 'p', 'u', 't']
                   then binda (singleton ['t', 'r', 's'] (rules xml2name) id c)
                          (\ r ->
                            binda (if null cs ||
not (tag (hda cs) == ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'])
                                    then returna (Inl No_Strategy, cs)
                                    else binda
   (inn_fp_strategy xml2name (hda cs)) (\ s -> returna (s, tla cs)))
                              (\ (str, csa) ->
                                binda (if null csa ||
    not (tag (hda csa) ==
          ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'R', 'u', 'l', 'e', 's'])
then returna (Nothing, csa)
else binda (singleton
             ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'R', 'u', 'l', 'e', 's']
             (rules xml2name) id (hda csa))
       (\ s -> returna (Just s, tla csa)))
                                  (\ (s_opt, csb) ->
                                    (if null csb then returna (str, (r, s_opt))
                                      else e))))
                   else e);
               XML _ (_ : _) _ -> e;
               XML_text _ -> e;
             })
         (\ a ->
           (case a of {
             (Inl istrat, (r, so)) -> returna (Inn_TRS_input (istrat, (r, so)));
             (Inr fpstrat, (r, Nothing)) -> returna (FP_TRS_input (fpstrat, r));
             (Inr _, (_, Just _)) ->
               errora
                 ['t', 'h', 'e', ' ', 'c', 'o', 'm', 'b', 'i', 'n', 'a', 't',
                   'i', 'o', 'n', ' ', 'o', 'f', ' ', 'r', 'e', 'l', 'a', 't',
                   'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'w', 'i',
                   't', 'h', ' ', 's', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e',
                   's', ' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 's', 'u',
                   'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'f', 'o', 'r', ' ',
                   'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'];
           }));

xml2trs_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Strategy a [Prelude.Char],
            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
              Maybe [(Term a [Prelude.Char], Term a [Prelude.Char])]));
xml2trs_input xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        Inn_TRS_input aa -> returna aa;
        COMP_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        EQ_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        CPX_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        FP_TRS_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        CTRS_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        TA_input _ _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        AC_input _ _ _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        Unknown_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
      }));

xml2complexity_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Strategy a [Prelude.Char],
            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
              (Maybe [(Term a [Prelude.Char], Term a [Prelude.Char])],
                (Complexity_measure a [Prelude.Char], Complexity_class))));
xml2complexity_input xml2name =
  triple
    ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'I', 'n', 'p', 'u', 't']
    (xml2trs_input xml2name) (complexity_measure xml2name) complexity_class
    (\ (q, (r, s)) cm cc -> (q, (r, (s, (cm, cc)))));

xml2completion_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ([(Term a [Prelude.Char], Term a [Prelude.Char])],
            [(Term a [Prelude.Char], Term a [Prelude.Char])]);
xml2completion_input xml2name =
  pair ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'I', 'n', 'p', 'u',
         't']
    (singleton ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] (rules xml2name)
      id)
    (singleton ['t', 'r', 's'] (rules xml2name) id) (\ a b -> (a, b));

xml2unknown_input :: Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
xml2unknown_input =
  text ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't'];

symbols_no_arity ::
  forall a.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] [a];
symbols_no_arity tagname xml2name = many tagname xml2name id;

xml2ac_tp_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Input a [Prelude.Char]);
xml2ac_tp_input xml2name =
  triple
    ['a', 'c', 'R', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'y', 's', 't', 'e', 'm']
    (singleton ['t', 'r', 's'] (rules xml2name) id)
    (symbols_no_arity ['A', 's', 'y', 'm', 'b', 'o', 'l', 's'] xml2name)
    (symbols_no_arity ['C', 's', 'y', 'm', 'b', 'o', 'l', 's'] xml2name)
    AC_input;

xml2ctrs_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]),
             [(Term a [Prelude.Char], Term a [Prelude.Char])])];
xml2ctrs_input xml2name =
  singleton ['c', 't', 'r', 's', 'I', 'n', 'p', 'u', 't'] (crules xml2name) id;

xml2dp_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Bool,
            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
              (Strategy a [Prelude.Char],
                [(Term a [Prelude.Char], Term a [Prelude.Char])])));
xml2dp_input xml2name =
  guard (\ x -> equal_nat (num_children x) (nat_of_integer (4 :: Integer)))
    (tuple4 ['d', 'p', 'I', 'n', 'p', 'u', 't']
      (singleton ['t', 'r', 's'] (rules xml2name) id)
      (singleton ['d', 'p', 's'] (rules xml2name) id) (strategy xml2name)
      (bool ['m', 'i', 'n', 'i', 'm', 'a', 'l'])
      (\ r p s m -> (m, (p, (s, r)))))
    (triple ['d', 'p', 'I', 'n', 'p', 'u', 't']
      (singleton ['t', 'r', 's'] (rules xml2name) id)
      (singleton ['d', 'p', 's'] (rules xml2name) id)
      (bool ['m', 'i', 'n', 'i', 'm', 'a', 'l'])
      (\ r p m -> (m, (p, (No_Strategy, r)))));

xml2input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Input a [Prelude.Char]);
xml2input xml2name =
  singleton ['i', 'n', 'p', 'u', 't']
    (options
      [(['d', 'p', 'I', 'n', 'p', 'u', 't'],
         change (xml2dp_input xml2name) DP_input),
        (['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'I', 'n', 'p', 'u',
           't'],
          change (xml2completion_input xml2name) COMP_input),
        (['t', 'r', 's', 'I', 'n', 'p', 'u', 't'], xml2pre_trs_input xml2name),
        (['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'a', 's',
           'o', 'n', 'i', 'n', 'g', 'I', 'n', 'p', 'u', 't'],
          change (xml2equational_input xml2name) EQ_input),
        (['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'I', 'n', 'p', 'u',
           't'],
          change (xml2complexity_input xml2name) CPX_input),
        (['c', 't', 'r', 's', 'I', 'n', 'p', 'u', 't'],
          change (xml2ctrs_input xml2name) CTRS_input),
        (['t', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', 'P',
           'r', 'o', 'b', 'l', 'e', 'm'],
          pair ['t', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n',
                 'P', 'r', 'o', 'b', 'l', 'e', 'm']
            (tree_automaton (ta_normal_lhs xml2name))
            (singleton ['t', 'r', 's'] (rules xml2name) id) TA_input),
        (['a', 'c', 'R', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'y', 's', 't', 'e',
           'm'],
          xml2ac_tp_input xml2name),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't'],
          change xml2unknown_input Unknown_input)])
    id;

xml_crule ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => ((Term (Lab a [b]) c, Term (Lab a [b]) c),
                    [(Term (Lab a [b]) c, Term (Lab a [b]) c)]) ->
                    Xml;
xml_crule =
  (\ (c, rs) ->
    XML ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'u', 'l',
          'e']
      [] (map xml_rule (c : rs)));

xml_rules ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => [Prelude.Char] ->
                    [(Term (Lab a [b]) c, Term (Lab a [b]) c)] -> Xml;
xml_rules tag rls =
  XML tag [] [XML ['r', 'u', 'l', 'e', 's'] [] (map xml_rule rls)];

missing ::
  [Prelude.Char] ->
    ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
missing s x =
  shows_string ['t', 'h', 'e', ' '] .
    shows_string s .
      shows_string [' '] .
        x . shows_string
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'];

toomuch ::
  [Prelude.Char] ->
    ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
toomuch s x =
  shows_string ['s', 'u', 'p', 'e', 'r', 'f', 'l', 'u', 'o', 'u', 's', ' '] .
    shows_string s . shows_string [' '] . x . x;

is_NF_subset :: forall a b. (Term a b -> Bool) -> [Term a b] -> Bool;
is_NF_subset is_Q_nf q = all (\ qa -> not (is_Q_nf qa)) q;

icap_impl_gen ::
  forall a.
    (Eq a) => Bool ->
                (Term a [Prelude.Char] -> Bool) ->
                  [Term a [Prelude.Char]] ->
                    [Term a [Prelude.Char]] ->
                      ([Prelude.Char] -> Bool) ->
                        Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char]);
icap_impl_gen nf isQnf ls s sx (Var x) =
  (if nf && sx x then Var (Inr x) else Var (Inl ()));
icap_impl_gen nf isQnf ls s sx (Fun f ts) =
  let {
    t = Fun f (map (icap_impl_gen nf isQnf ls s sx) ts);
  } in (if any (\ l ->
                 (case mgu_class t l of {
                   Nothing -> False;
                   Just mu ->
                     all (\ u ->
                           isQnf (subst_apply_term
                                   (map_term (\ x -> x) (\ a -> 'y' : a) u) mu))
                       (args l) &&
                       all (\ u -> isQnf (subst_apply_term u mu)) s;
                 }))
             ls
         then Var (Inl ()) else t);

ins_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
ins_rm_basic_ops x s = insert x () s;

g_from_list_aux_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> [a] -> Rbt a ();
g_from_list_aux_dflt_basic_oops_rm_basic_ops y [] = y;
g_from_list_aux_dflt_basic_oops_rm_basic_ops accs (x : l) =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops (ins_rm_basic_ops x accs) l;

empty_rm_basic_ops :: forall a. (Linorder a) => () -> Rbt a ();
empty_rm_basic_ops = (\ _ -> empty);

g_from_list_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => [a] -> Rbt a ();
g_from_list_dflt_basic_oops_rm_basic_ops l =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops (empty_rm_basic_ops ()) l;

memb_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Bool;
memb_rm_basic_ops x s = not (is_none (lookup s x));

ceta_set_of :: forall a. (Key a) => [a] -> a -> Bool;
ceta_set_of ps = let {
                   tree = g_from_list_dflt_basic_oops_rm_basic_ops ps;
                 } in (\ a -> memb_rm_basic_ops a tree);

icap_impl ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char]);
icap_impl isnf r =
  let {
    ls = map fst r;
    nf = is_NF_subset isnf ls;
    ic = icap_impl_gen nf isnf ls;
  } in (\ s -> let {
                 sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
                 sx = ceta_set_of (concatMap vars_term_list sa);
               } in (\ t -> ic sa sx (map_term (\ x -> x) (\ a -> 'x' : a) t)));

rep_subst_incr ::
  forall a b. Subst_incr a b -> (b -> Term a b, (Set b, Term a b -> [b]));
rep_subst_incr (Abs_subst_incr x) = x;

si_W :: forall a b. Subst_incr a b -> Term a b -> [b];
si_W xa = snd (snd (rep_subst_incr xa));

kbo_nstrict ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ((a, Nat) -> Nat) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        (a -> Bool) ->
                          ((a, Nat) -> Nat -> Nat) ->
                            (Term a b, Term a b) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
kbo_nstrict pr w w0 least scf =
  (\ (s, t) ->
    check (snd (kbo_impl w w0 pr least scf s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term zero_nat s .
          shows_string [' ', '>', '=', 'K', 'B', 'O', ' '] .
            shows_prec_term zero_nat t . shows_nl));

list_inter :: forall a. (Eq a) => [a] -> [a] -> [a];
list_inter [] bs = [];
list_inter (a : asa) bs =
  (if membera bs a then a : list_inter asa bs else list_inter asa bs);

list_union :: forall a. (Eq a) => [a] -> [a] -> [a];
list_union [] ys = ys;
list_union (x : xs) ys = let {
                           zs = list_union xs ys;
                         } in (if membera zs x then zs else x : zs);

default_I :: forall a. (Poly_carrier a) => a -> Nat -> [([(Nat, Nat)], a)];
default_I def n =
  ([], def) : map (\ i -> ([(i, one_nat)], onea)) (upt zero_nat n);

proper_prefix_list :: Pos -> [Pos];
proper_prefix_list Empty = [];
proper_prefix_list (PCons i p) = Empty : map (PCons i) (proper_prefix_list p);

prefix_list :: Pos -> [Pos];
prefix_list p = p : proper_prefix_list p;

scnp_arity :: forall a. [((a, Nat), [(Nat, Nat)])] -> Nat;
scnp_arity af = max_list (map (\ (_, a) -> size_list a) af);

rules_no_left_vara :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
rules_no_left_vara
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_no_left_var;

rules_mapc ::
  forall a b c d.
    Dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
rules_mapc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_map;

tcapRM_dpp ::
  forall a b c.
    (Eq b, Eq c) => Dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
tcapRM_dpp i dpp = tcapRM (rules_no_left_vara i dpp) (rules_mapc i dpp);

funas_term_list :: forall a b. Term a b -> [(a, Nat)];
funas_term_list (Var uu) = [];
funas_term_list (Fun f ts) = (f, size_list ts) : concatMap funas_term_list ts;

check_supt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Term a b ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_supt s t =
  check (supt_impl s t)
    (shows_prec_term zero_nat t .
      shows_string
        [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r', 'o', 'p',
          'e', 'r', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', ' ', 'o', 'f',
          ' '] .
        shows_prec_term zero_nat s);

compute_trancl ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Set_impl a) => Set a -> Set (a, a) -> Set a;
compute_trancl a r =
  let {
    b = imagea r a;
  } in (if less_eq_set b bot_set then bot_set
         else sup_set b
                (compute_trancl b
                  (filtera
                    (\ ab -> not (member (fst ab) a) && not (member (snd ab) b))
                    r)));

r_lhs_states :: forall a b. Ta_rule a b -> [a];
r_lhs_states (TA_rule x1 x2 x3) = x2;

r_rhs :: forall a b. Ta_rule a b -> a;
r_rhs (TA_rule x1 x2 x3) = x3;

ta_rules :: forall a b c. Ta_ext a b c -> Set (Ta_rule a b);
ta_rules (Ta_ext ta_final ta_rules ta_eps more) = ta_rules;

ta_eps :: forall a b c. Ta_ext a b c -> Set (a, a);
ta_eps (Ta_ext ta_final ta_rules ta_eps more) = ta_eps;

ta_res ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b () -> Term b a -> Set a;
ta_res ta (Fun f ts) =
  let {
    qs = map (ta_res ta) ts;
    g = (f, size_list ts);
  } in sup_set
         (image r_rhs
           (filtera
             (\ r ->
               r_sym r == g &&
                 all (\ qq -> member (snd qq) (fst qq))
                   (zip qs (r_lhs_states r)))
             (ta_rules ta)))
         (compute_trancl
           (image r_rhs
             (filtera
               (\ r ->
                 r_sym r == g &&
                   all (\ qq -> member (snd qq) (fst qq))
                     (zip qs (r_lhs_states r)))
               (ta_rules ta)))
           (ta_eps ta));
ta_res ta (Var q) =
  sup_set (inserta q bot_set) (compute_trancl (inserta q bot_set) (ta_eps ta));

eq_rule_mod_vars ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b, Term a b) -> (Term a b, Term a b) -> Bool;
eq_rule_mod_vars lr st = instance_rule lr st && instance_rule st lr;

is_NF_terms ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> Term a b -> Bool;
is_NF_terms q = is_NF_main (any is_Var q) (null q) (term_map q);

generate_var :: Nat -> [Prelude.Char];
generate_var i = 'x' : shows_prec_nat zero_nat i [];

uncurry_term ::
  forall a b. (Eq a) => a -> (a -> Nat -> [a]) -> Term a b -> Term a b;
uncurry_term a sm t =
  (case unapp a t of {
    (Var x, ts) -> apply_args a (Var x) (map (uncurry_term a sm) ts);
    (Fun f ss, ts) ->
      let {
        n = size_list ss;
        uss = map (uncurry_term a sm) ss;
        uts = map (uncurry_term a sm) ts;
        aa = aarity sm f n;
        m = min (size_list ts) aa;
        fm = get_symbol sm f n m;
      } in apply_args a (Fun fm (uss ++ take m uts)) (drop m uts);
  });

conversion ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                     (Bool, Term a [Prelude.Char])))]);
conversion xml2name =
  many1 ['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n']
    (singleton ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm'] (term xml2name) id)
    (estep xml2name) (\ a b -> (a, b));

plain_name :: Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat]);
plain_name x =
  options
    [(['n', 'a', 'm', 'e'], change (text ['n', 'a', 'm', 'e']) UnLab),
      (['s', 'h', 'a', 'r', 'p'],
        singleton ['s', 'h', 'a', 'r', 'p'] plain_name Sharp),
      (['l', 'a', 'b', 'e', 'l', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l'],
        pair ['l', 'a', 'b', 'e', 'l', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l']
          plain_name
          (options
            [(['n', 'u', 'm', 'b', 'e', 'r', 'L', 'a', 'b', 'e', 'l'],
               many ['n', 'u', 'm', 'b', 'e', 'r', 'L', 'a', 'b', 'e', 'l']
                 (nata ['n', 'u', 'm', 'b', 'e', 'r']) Inl),
              (['s', 'y', 'm', 'b', 'o', 'l', 'L', 'a', 'b', 'e', 'l'],
                many ['s', 'y', 'm', 'b', 'o', 'l', 'L', 'a', 'b', 'e', 'l']
                  plain_name Inr)])
          (\ f a -> (case a of {
                      Inl aa -> Lab f aa;
                      Inr aa -> FunLab f aa;
                    })))]
    x;

rule_pairs ::
  forall a.
    [Prelude.Char] ->
      [Prelude.Char] ->
        (Xml -> Sum_bot [Prelude.Char] a) ->
          Xml ->
            Sum_bot [Prelude.Char]
              [((Term a [Prelude.Char], Term a [Prelude.Char]),
                 (Term a [Prelude.Char], Term a [Prelude.Char]))];
rule_pairs s p xml2name =
  many s (pair p (rule xml2name) (rule xml2name) (\ a b -> (a, b))) id;

xml1or2many_elements ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> Maybe b -> [c] -> d) -> Xml -> Sum_bot [Prelude.Char] d;
xml1or2many_elements tag p1 p2 p3 f (XML name atts cs) =
  (if name == tag && null atts && not (null cs)
    then let {
           (cs0 : tt) = cs;
         } in binda (p1 cs0)
                (\ x ->
                  (case tt of {
                    [] -> returna (f x Nothing []);
                    cs1 : t ->
                      catch_error
                        (binda (p2 cs1)
                          (\ y ->
                            binda (map_sum_bot p3 t)
                              (\ xs -> returna (f x (Just y) xs))))
                        (\ _ ->
                          binda (map_sum_bot p3 tt)
                            (\ xs -> returna (f x Nothing xs)));
                  }))
    else fail tag (XML name atts cs));
xml1or2many_elements tag p1 p2 p3 f (XML_text v) = fail tag (XML_text v);

sl_variant ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Sl_variant a [Prelude.Char]);
sl_variant xml2name =
  singleton ['m', 'o', 'd', 'e', 'l']
    (options
      [(['f', 'i', 'n', 'i', 't', 'e', 'M', 'o', 'd', 'e', 'l'],
         xml1or2many_elements
           ['f', 'i', 'n', 'i', 't', 'e', 'M', 'o', 'd', 'e', 'l']
           (change
             (nata ['c', 'a', 'r', 'r', 'i', 'e', 'r', 'S', 'i', 'z', 'e'])
             (\ n -> minus_nat n one_nat))
           (singleton ['t', 'u', 'p', 'l', 'e', 'O', 'r', 'd', 'e', 'r']
             (leaf ['p', 'o', 'i', 'n', 't', 'W', 'i', 's', 'e'] ()) id)
           (triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
             (nata ['a', 'r', 'i', 't', 'y']) arith_fun
             (\ f a -> (\ b -> ((f, a), b))))
           (\ n model xs ->
             (if is_none model then Finitelab (SL_Inter n xs)
               else QuasiFinitelab (SL_Inter n xs) []))),
        (['r', 'o', 'o', 't', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g'],
          guard (\ x -> equal_nat (num_children x) zero_nat)
            (leaf ['r', 'o', 'o', 't', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
              (Rootlab Nothing))
            (singleton
              ['r', 'o', 'o', 't', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
              xml2name (\ f -> Rootlab (Just (f, one_nat)))))])
    id;

max_tag :: Nat;
max_tag = nat_of_integer (29 :: Integer);

char_matrix :: forall a. (Field a) => Mat a -> a -> Mat a;
char_matrix a e =
  mat_add a (mat_scalar_mult (uminusa e) (mat_one (mat_dim_row a)));

all_interval_nat :: (Nat -> Bool) -> Nat -> Nat -> Bool;
all_interval_nat p i j = less_eq_nat j i || p i && all_interval_nat p (suc i) j;

check_prop_rstep_rule ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      Pos ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstep_rule nfs pa p rule s t =
  bindb (check (in_poss p s)
          (shows_prec_pos zero_nat p .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o', 's',
                'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
              shows_prec_term zero_nat s . shows_nl))
    (\ _ ->
      bindb (check (in_poss p t)
              (shows_prec_pos zero_nat p .
                shows_string
                  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
                    's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                  shows_prec_term zero_nat t . shows_nl))
        (\ _ ->
          let {
            c = ctxt_of_pos_term p s;
            d = ctxt_of_pos_term p t;
            u = subt_at s p;
            v = subt_at t p;
          } in (case match_list Var [(fst rule, u), (snd rule, v)] of {
                 Nothing ->
                   Inl (shows_string
                          ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                         shows_prec_term zero_nat t .
                           shows_string
                             [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                               'r', 'e', 's', 'u', 'l', 't', ' ', 'f', 'r', 'o',
                               'm', ' ', 'a', ' ', 'p', 'r', 'o', 'p', 'e', 'r',
                               ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                               'o', 'n', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e',
                               ' '] .
                             shows_nl .
                               shows_rule (shows_prec zero_nat)
                                 (shows_prec zero_nat) [' ', '-', '>', ' ']
                                 rule .
                                 shows_string
                                   [' ', 'a', 't', ' ', 'p', 'o', 's', 'i', 't',
                                     'i', 'o', 'n', ' '] .
                                   shows_prec_pos zero_nat p . shows_nl);
                 Just tau ->
                   bindb (catch_errora
                           (forallM pa
                             (args u ++
                               (if nfs then map tau (vars_rule_list rule)
                                 else [])))
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       check (equal_ctxt c d)
                         (shows_string
                            ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                           shows_prec_term zero_nat t .
                             shows_string
                               [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't',
                                 ' ', 'r', 'e', 's', 'u', 'l', 't', ' ', 'f',
                                 'r', 'o', 'm', ' ', 'a', ' ', 'p', 'r', 'o',
                                 'p', 'e', 'r', ' ', 'a', 'p', 'p', 'l', 'i',
                                 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
                                 ' ', 'r', 'u', 'l', 'e', ' '] .
                               shows_nl .
                                 shows_rule (shows_prec zero_nat)
                                   (shows_prec zero_nat) [' ', '-', '>', ' ']
                                   rule .
                                   shows_string
                                     [' ', 'a', 't', ' ', 'p', 'o', 's', 'i',
                                       't', 'i', 'o', 'n', ' '] .
                                     shows_prec_pos zero_nat p . shows_nl));
               })));

check_prop_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstep nfs pa r p rule s t =
  check (any (\ ra ->
               eq_rule_mod_vars rule ra &&
                 isOK (check_prop_rstep_rule nfs pa p ra s t))
          r)
    (shows_prec_list zero_nat
       ['t', 'h', 'e', ' ', 's', 't', 'e', 'p', ' ', 'f', 'r', 'o', 'm', ' '] .
      shows_prec_term zero_nat s .
        shows_prec_list zero_nat [' ', 't', 'o', ' '] .
          shows_prec_term zero_nat t .
            shows_prec_list zero_nat
              [' ', 'v', 'i', 'a', ' ', 'r', 'u', 'l', 'e', ' '] .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '-', '>', ' '] rule .
                shows_prec_list zero_nat
                  [' ', 'a', 't', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n',
                    ' '] .
                  shows_prec_pos zero_nat p .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                        'a', 't', 'i', 'c'] .
                      shows_nl);

check_qrstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrstep nf nfs =
  check_prop_rstep nfs
    (\ t ->
      check (nf t)
        (shows_prec_term zero_nat t .
          shows_prec_list zero_nat
            [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'Q', '-',
              'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']));

check_rqrstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rqrstep nf nfs r rule s t = check_qrstep nf nfs r Empty rule s t;

check_qsteps ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qsteps nf nfs p r [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term zero_nat u . shows_nl);
check_qsteps nf nfs p ra ((uu, (r, (True, t))) : prts) s u =
  bindb (check_rqrstep nf nfs p r s t)
    (\ _ -> check_qsteps nf nfs p ra prts t u);
check_qsteps nf nfs pa ra ((p, (r, (False, t))) : prts) s u =
  bindb (check_qrstep nf nfs ra p r s t)
    (\ _ -> check_qsteps nf nfs pa ra prts t u);

check_qrsteps ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrsteps nf nfs r prts s u =
  check_qsteps nf nfs [] r (map (\ (p, (ra, t)) -> (p, (ra, (False, t)))) prts)
    s u;

check_qrstep_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrstep_subst cni nfs =
  let {
    main =
      check_prop_rstep nfs
        (\ t ->
          catch_errora (cni t)
            (\ _ ->
              Inl (shows_prec_term zero_nat t .
                    shows_prec_list zero_nat
                      [' ', 'm', 'u', ' ', '^', '^', ' ', 'i', ' ', 'i', 's',
                        ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'Q', '-', 'n',
                        'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ',
                        'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ', 'i'])));
  } in (\ r p ra s t ->
         bindb (check (not (is_Var (fst ra)))
                 (shows_prec_list zero_nat
                   ['l', 'o', 'o', 'p', ' ', 'c', 'h', 'e', 'c', 'k', ' ', 'r',
                     'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'l', 'h', 's', 's',
                     ' ', 't', 'o', ' ', 'b', 'e', ' ', 'n', 'o', 'n', '-', 'v',
                     'a', 'r', 'i', 'a', 'b', 'l', 'e']))
           (\ _ -> main r p ra s t));

check_rqrstep_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rqrstep_subst cni nfs = (\ r -> check_qrstep_subst cni nfs r Empty);

check_qsteps_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qsteps_subst cni nfs p r [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term zero_nat u . shows_nl);
check_qsteps_subst cni nfs p ra ((uu, (r, (True, t))) : prts) s u =
  bindb (check_rqrstep_subst cni nfs p r s t)
    (\ _ -> check_qsteps_subst cni nfs p ra prts t u);
check_qsteps_subst cni nfs pa ra ((p, (r, (False, t))) : prts) s u =
  bindb (check_qrstep_subst cni nfs ra p r s t)
    (\ _ -> check_qsteps_subst cni nfs pa ra prts t u);

check_qrsteps_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrsteps_subst cni nfs r prts s u =
  check_qsteps_subst cni nfs [] r
    (map (\ (p, (ra, t)) -> (p, (ra, (False, t)))) prts) s u;

si_subst :: forall a b. Subst_incr a b -> b -> Term a b;
si_subst xa = fst (rep_subst_incr xa);

match_prob_of_rp_impl ::
  forall a b.
    (Eq a,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> [(Term a b, Term a b)];
match_prob_of_rp_impl mu (t, Var x) = [(t, Var x)];
match_prob_of_rp_impl mu (t, Fun v va) =
  let {
    sterms = remdups (t : map (si_subst mu) (si_W mu t));
    uterms = concatMap (filter (\ ta -> not (is_Var ta)) . supteq_list) sterms;
  } in map (\ u -> (u, Fun v va)) (remdups uterms);

si_v_incr :: forall a b. Subst_incr a b -> Set b;
si_v_incr xa = fst (snd (rep_subst_incr xa));

simplify_mp ::
  forall a b.
    (Eq a, Ceq b,
      Ccompare b) => Subst_incr a b ->
                       [(Term a b, Term a b)] ->
                         [(Term a b, Term a b)] ->
                           Maybe ([(Term a b, Term a b)], Nat);
simplify_mp mu_incr ((Var x, Fun f ls) : mp) solved =
  bind (guarda (member x (si_v_incr mu_incr)))
    (\ _ ->
      let {
        m = map (\ (s, a) -> (subst_apply_term s (si_subst mu_incr), a));
      } in bind (simplify_mp mu_incr (m ((Var x, Fun f ls) : mp)) (m solved))
             (\ (smp, i) -> Just (smp, suc i)));
simplify_mp mu_incr ((Fun g ts, Fun f ls) : mp) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (zip_option ts ls)
        (\ pairs -> simplify_mp mu_incr (pairs ++ mp) solved));
simplify_mp mu_incr ((s, Var x) : mp) solved =
  simplify_mp mu_incr mp ((s, Var x) : solved);
simplify_mp mu_incr [] solved = Just (solved, zero_nat);

conflicts ::
  forall a b.
    (Eq a,
      Eq b) => (a -> Term b a) ->
                 (Term b a, (Term b a, Nat)) -> [(Term b a, (Term b a, Nat))];
conflicts mu (Fun f ts, (Fun g ss, n)) =
  (if f == g && equal_nat (size_list ts) (size_list ss)
    then concatMap (\ (s, t) -> conflicts mu (s, (t, n))) (zip ts ss)
    else [(Fun f ts, (Fun g ss, n))]);
conflicts mu (Var x, (Fun g ss, n)) = [(Var x, (Fun g ss, n))];
conflicts mu (Fun f ts, (Var y, n)) =
  (if equal_nat n zero_nat then [(Var y, (Fun f ts, zero_nat))]
    else conflicts mu (Fun f ts, (mu y, minus_nat n one_nat)));
conflicts mu (Var x, (Var y, n)) =
  (if equal_nat n zero_nat
    then (if x == y then [] else [(Var x, (Var y, zero_nat))])
    else conflicts mu (Var x, (mu y, minus_nat n one_nat)));

ident_solvea ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b ->
                 Set (Term a b, (Term a b, Nat)) ->
                   (Term a b, (Term a b, Nat)) -> Maybe Nat;
ident_solvea mu_incr cps st =
  let {
    cp = conflicts (si_subst mu_incr) st;
  } in (if any (\ (u, (_, _)) -> not (is_Var u)) cp then Nothing
         else (if any (\ (u, (v, _)) ->
                        member (u, v) (image (\ (ua, (va, _)) -> (ua, va)) cps))
                    cp
                then Nothing
                else bind (mapMa
                            (\ (u, (v, m)) ->
                              ident_solvea mu_incr (inserta (u, (v, m)) cps)
                                (subst_apply_term u (si_subst mu_incr),
                                  (v, suc m)))
                            (conflicts (si_subst mu_incr) st))
                       (\ is -> Just (max_list (map suc is)))));

ident_solve ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Maybe Nat;
ident_solve mu_incr =
  (\ (s, t) ->
    ident_solvea mu_incr
      (set_empty
        (of_phantom
          (set_impl_prod :: Phantom (Term a b, (Term a b, Nat)) Set_impla)))
      (s, (t, zero_nat)));

ident_decision ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
ident_decision sigma ip = not (is_none (ident_solve sigma ip));

ident_prob_of_smp ::
  forall a b. (Eq a, Eq b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)];
ident_prob_of_smp [] = [];
ident_prob_of_smp ((t, l) : other) =
  map_filter
    (\ x -> (if let {
                  (_, s) = x;
                } in equal_term s l
              then Just (let {
                           (s, _) = x;
                         } in (t, s))
              else Nothing))
    other ++
    ident_prob_of_smp other;

gmatch_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> [(Term a b, Term a b)] -> Bool;
gmatch_decision sigma mp =
  not (is_none
        (bind (simplify_mp sigma mp [])
          (\ (smp, _) ->
            guarda (all (ident_decision sigma) (ident_prob_of_smp smp)))));

match_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
match_decision mu mp = gmatch_decision mu [mp];

redex_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
redex_decision mu rp = any (match_decision mu) (match_prob_of_rp_impl mu rp);

new_as :: forall a b. (a -> b -> Bool) -> [a] -> [b] -> [b];
new_as p bs asa = filter (\ a -> any (\ b -> p b a) bs) asa;

the_set_impl_main ::
  forall a b.
    (Eq a, Eq b) => (a -> b -> Bool) -> (b -> [a]) -> [b] -> [b] -> [a] -> [b];
the_set_impl_main p q remain have bs =
  let {
    new = new_as p bs remain;
  } in (if null new then have
         else the_set_impl_main p q (list_diff remain new) (new ++ have)
                (remdups (concatMap q new)));

the_set_impl ::
  forall a b.
    (Eq a, Eq b) => [a] -> (b -> a -> Bool) -> (a -> [b]) -> [b] -> [a];
the_set_impl r p q bs = the_set_impl_main p q r [] bs;

inductive_set_impl ::
  forall a b.
    (Eq a, Eq b) => [a] -> (b -> a -> Bool) -> (a -> [b]) -> [b] -> [a];
inductive_set_impl = the_set_impl;

v_incr_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
v_incr_impl mu =
  inductive_set_impl (map fst mu) (\ a b -> a == b)
    (\ x ->
      concatMap (\ (y, t) -> (if equal_term t (Var x) then [y] else [])) mu)
    (concatMap (\ (y, t) -> (if not (is_Var t) then [y] else [])) mu);

relpow_impl ::
  forall a b.
    ([a] -> [a]) -> ([a] -> b -> b) -> (a -> b -> Bool) -> [a] -> b -> Nat -> b;
relpow_impl succ un memb new have m =
  (if equal_nat m zero_nat then un new have
    else (if null new then have
           else let {
                  maybe = succ new;
                  havea = un new have;
                  newa = filter (\ n -> not (memb n havea)) maybe;
                } in relpow_impl succ un memb newa havea
                       (minus_nat m one_nat)));

rtrancl_impl ::
  forall a b.
    ([(a, a)] -> [a] -> [a]) ->
      ([a] -> b -> b) -> (a -> b -> Bool) -> b -> [(a, a)] -> [a] -> b;
rtrancl_impl gen_succ un memb emp rel =
  let {
    succ = gen_succ rel;
    n = size_list rel;
  } in (\ asa -> relpow_impl succ un memb asa emp n);

rtrancl_list_impl :: forall a. (Eq a) => [(a, a)] -> [a] -> [a];
rtrancl_list_impl =
  rtrancl_impl
    (\ r asa ->
      remdups
        (map_filter
          (\ x -> (if let {
                        (a, _) = x;
                      } in membera asa a
                    then Just (snd x) else Nothing))
          r))
    (\ xs ys -> filter (\ x -> not (membera ys x)) xs ++ ys)
    (\ x xs -> membera xs x) [];

w_impl :: forall a b. (Eq a) => [(a, Term b a)] -> Term b a -> [a];
w_impl d =
  let {
    filt = filter (\ (x, y) -> not (x == y));
    xvs = concatMap (\ (x, t) -> map (\ a -> (x, a)) (vars_term_list t)) d;
    rel = filt xvs;
    rtran = rtrancl_list_impl rel;
  } in (\ t -> rtran (vars_term_list t));

subst_incr ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq b) => [(a, Term b a)] -> Subst_incr b a;
subst_incr xa =
  Abs_subst_incr (let {
                    dom = mk_subst_domain xa;
                  } in (mk_subst Var xa, (set (v_incr_impl dom), w_impl dom)));

redex_rps_decision ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] ->
                 [(Term b a, Term b a)] -> Sum (Term b a, Term b a) ();
redex_rps_decision mu =
  let {
    mua = subst_incr mu;
    main = redex_decision mua;
  } in (\ xs ->
         catch_errora (forallM (\ tl -> check (not (main tl)) tl) xs)
           (\ x -> Inl (snd x)));

check_NF_iteration ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] ->
                 [Term b a] -> Term b a -> Sum (Term b a, Term b a) ();
check_NF_iteration mu = let {
                          dec = redex_rps_decision mu;
                        } in (\ q t -> dec (map (\ a -> (t, a)) q));

check_loop ::
  forall a b.
    (Compare a, Eq a, Showa a, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [Term a b] ->
                    Bool ->
                      Term a b ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          [(b, Term a b)] ->
                            Ctxt a b ->
                              [(Term a b, Term a b)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_loop q nfs s rseq sigma c r =
  bindb (check (not (null rseq))
          (shows_prec_list zero_nat
            ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'e', 'q', 'u', 'e',
              'n', 'c', 'e', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n',
              'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
    (\ _ ->
      (if null q
        then check_qrsteps (\ _ -> True) nfs r rseq s
               (ctxt_apply_term c (subst_apply_term s (mk_subst Var sigma)))
        else check_qrsteps_subst (check_NF_iteration sigma q) nfs r rseq s
               (ctxt_apply_term c (subst_apply_term s (mk_subst Var sigma)))));

delete_value ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> a -> Rbt b [a] -> Rbt b [a];
delete_value key v m = (case key v of {
                         Nothing -> m;
                         Just k -> (case lookup m k of {
                                     Nothing -> m;
                                     Just vs -> insert k (removeAll v vs) m;
                                   });
                       });

insert_value ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> a -> Rbt b [a] -> Rbt b [a];
insert_value key v m = (case key v of {
                         Nothing -> m;
                         Just k -> (case lookup m k of {
                                     Nothing -> insert k [v] m;
                                     Just vs -> insert k (insertb v vs) m;
                                   });
                       });

check_ge_v :: forall a. (Poly_carrier a) => a -> [([(Nat, Nat)], a)] -> Bool;
check_ge_v v p = (case p of {
                   [] -> True;
                   [([], c)] -> less_eq c v;
                   ([], _) : _ : _ -> False;
                   (_ : _, _) : _ -> False;
                 });

check_poly_weak_anti_mono_discrete ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono_discrete p v =
  check_poly_ge p
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p);

check_poly_weak_anti_mono ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Ordered_semiring_0 b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono p v =
  all (\ (m, c) -> less_eq c zeroa || not (member v (image fst (set m)))) p;

check_poly_weak_anti_mono_smart ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Eq b,
      Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono_smart discrete =
  (if discrete then check_poly_weak_anti_mono_discrete
    else check_poly_weak_anti_mono);

check_poly_weak_mono_discrete ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono_discrete p v =
  check_poly_ge
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p)
    p;

check_poly_weak_mono ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Ordered_semiring_0 b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono p v =
  all (\ (m, c) -> less_eq zeroa c || not (member v (image fst (set m)))) p;

check_poly_weak_mono_smart ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Eq b,
      Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono_smart discrete =
  (if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono);

fun_of_map_fun :: forall a b. (a -> Maybe b) -> (a -> b) -> a -> b;
fun_of_map_fun m d a = (case m a of {
                         Nothing -> d a;
                         Just b -> b;
                       });

g_list_to_map_rm_basic_ops ::
  forall a b. (Compare_order a) => [(a, b)] -> Rbt a b;
g_list_to_map_rm_basic_ops l =
  foldl (\ m (k, v) -> insert k v m) empty (reverse l);

ceta_map_of :: forall a b. (Key a) => [(a, b)] -> a -> Maybe b;
ceta_map_of ps = lookup (g_list_to_map_rm_basic_ops ps);

poly_inter_list_to_inter ::
  forall a b.
    (Poly_carrier a,
      Key b) => a -> [((b, Nat), [([(Nat, Nat)], a)])] ->
                       (b, Nat) -> [([(Nat, Nat)], a)];
poly_inter_list_to_inter def i =
  fun_of_map_fun (ceta_map_of i) (\ fn -> default_I def (snd fn));

fun_of_map_funa ::
  forall a b c. (a -> Maybe b) -> (a -> c) -> (b -> c) -> a -> c;
fun_of_map_funa m d f a = (case m a of {
                            Nothing -> d a;
                            Just aa -> f aa;
                          });

create_dep ::
  forall a b.
    (Eq a, Poly_carrier a, Eq b,
      Key b) => Bool ->
                  a -> [((b, Nat), [([(Nat, Nat)], a)])] ->
                         (b, Nat) -> Nat -> Dependance;
create_dep discrete def i =
  let {
    fs = remdups (map fst i);
    ii = poly_inter_list_to_inter def i;
    fsres =
      map (\ fn ->
            let {
              p = ii fn;
              vars = poly_vars_list p;
              is = upt zero_nat (snd fn);
              a = map (\ ia ->
                        (if membera vars ia
                          then (if check_poly_weak_mono_smart discrete p ia
                                 then Increase
                                 else (if check_poly_weak_anti_mono_smart
    discrete p ia
then Decrease else Wild))
                          else Ignore))
                    is;
            } in (fn, a))
        fs;
    iii = fun_of_map_funa (ceta_map_of fsres) (\ _ _ -> Increase) nth;
  } in iii;

eval_monom :: forall a b. (Comm_semiring_1 b) => (a -> b) -> [(a, Nat)] -> b;
eval_monom alpha [] = onea;
eval_monom alpha ((x, p) : m) =
  times (eval_monom alpha m) (binary_power (alpha x) p);

eval_poly ::
  forall a b. (Comm_semiring_1 b) => (a -> b) -> [([(a, Nat)], b)] -> b;
eval_poly alpha [] = zeroa;
eval_poly alpha (mc : p) =
  plus (times (eval_monom alpha (fst mc)) (snd mc)) (eval_poly alpha p);

poly_vars ::
  forall a b. (Ceq a, Ccompare a, Set_impl a) => [([(a, Nat)], b)] -> Set a;
poly_vars p = set (concatMap (map fst . fst) p);

xml_tag :: forall a b c. Cert_problem a b c -> [Prelude.Char];
xml_tag (TRS_Termination_Proof uu uv uw (Just ux) uy) =
  ['<', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm', 'i', 'n',
    'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (TRS_Termination_Proof uz va vb Nothing vc) =
  ['<', 't', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
    'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (Complexity_Proof vd ve vf vg vh vi) =
  ['<', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'P', 'r', 'o', 'o',
    'f', '>'];
xml_tag (TRS_Nontermination_Proof vj vk vl vm) =
  ['<', 't', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
    'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (Outermost_Nontermination_Proof vn vo) =
  ['<', 't', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
    'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (Outermost_Termination_Proof vp vq) =
  ['<', 't', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
    'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (FP_Nontermination_Proof vr vs vt) =
  ['<', 't', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
    'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (FP_Termination_Proof vu vv vw) =
  ['<', 't', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
    'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (CS_Nontermination_Proof vx vy vz) =
  ['<', 't', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
    'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (CS_Termination_Proof wa wb wc) =
  ['<', 't', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
    'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (Relative_TRS_Nontermination_Proof wd we wf wg wh) =
  ['<', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'N', 'o', 'n', 't', 'e', 'r',
    'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (DP_Termination_Proof wi wj wk wl wm wn wo wp) =
  ['<', 'd', 'p', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (DP_Nontermination_Proof wq wr ws wt wu wv) =
  ['<', 'd', 'p', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
    'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (TRS_Confluence_Proof ww wx wy) =
  ['<', 'c', 'r', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (TRS_Non_Confluence_Proof wz xa xb) =
  ['<', 'c', 'r', 'D', 'i', 's', 'p', 'r', 'o', 'o', 'f', '>'];
xml_tag (Completion_Proof xc xd xe) =
  ['<', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o',
    'f', '>'];
xml_tag (Equational_Proof xf xg xh) =
  ['<', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o', 'o',
    'f', '>'];
xml_tag (Equational_Disproof xi xj xk) =
  ['<', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'D', 'i', 's', 'p',
    'r', 'o', 'o', 'f', '>'];
xml_tag (Quasi_Reductive_Proof xl xm) =
  ['<', 'q', 'u', 'a', 's', 'i', 'R', 'e', 'd', 'u', 'c', 't', 'i', 'v', 'e',
    'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (Conditional_CR_Proof xn xo) =
  ['<', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'r', 'P',
    'r', 'o', 'o', 'f', '>'];
xml_tag (Tree_Automata_Closed_Proof xp xq xr) =
  ['<', 't', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', 'C',
    'l', 'o', 's', 'e', 'd', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (AC_Termination_Proof xs xt xu xv) =
  ['<', 'a', 'c', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'P',
    'r', 'o', 'o', 'f', '>'];
xml_tag (Unknown_Proof xw xx) =
  ['<', 'u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't', 'P', 'r',
    'o', 'o', 'f', '>'];
xml_tag (Unknown_Disproof xy xz) =
  ['<', 'u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't', 'P', 'r',
    'o', 'o', 'f', '>'];

enfc_q ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                (Term a [Prelude.Char] -> Bool) ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [Term a [Prelude.Char]] ->
                      [Term a [Prelude.Char]] -> Term a [Prelude.Char] -> Bool;
enfc_q isQnf isRnf r q s (Var x) = True;
enfc_q isQnf isRnf r q s (Fun f ts) =
  all (\ qa ->
        (case mgu_class (Fun f (map (icap_impl isQnf r s) ts)) qa of {
          Nothing -> True;
          Just mu ->
            not (all (\ u ->
                       isQnf (subst_apply_term
                               (map_term (\ x -> x) (\ a -> 'x' : a) u) mu))
                   s &&
                  isRnf (subst_apply_term
                          (map_term (\ x -> x) (\ a -> 'y' : a) qa) mu));
        }))
    q;

delete_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
delete_values uu [] m = m;
delete_values key (v : vs) m = delete_value key v (delete_values key vs m);

delete_rules ::
  forall a b c.
    (Eq a, Compare_order b, Eq b,
      Eq c) => a -> [(Term b c, Term b c)] ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        Rbt (b, Nat) [(a, (Term b c, Term b c))];
delete_rules a rs = delete_values key (map (\ b -> (a, b)) rs);

insert_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
insert_values uu [] m = m;
insert_values key (v : vs) m = insert_value key v (insert_values key vs m);

insert_rules ::
  forall a b c.
    (Eq a, Compare_order b, Eq b,
      Eq c) => a -> [(Term b c, Term b c)] ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        Rbt (b, Nat) [(a, (Term b c, Term b c))];
insert_rules a rs = insert_values key (map (\ b -> (a, b)) rs);

split_rulesc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_rulesc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = split_rules;

split_pairsa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_pairsa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = split_pairs;

delete_R_Rwc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_R_Rwc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = delete_R_Rw;

delete_P_Pwa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_P_Pwa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = delete_P_Pw;

minimal :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
minimal
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = minimal;

nfsc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
nfsc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
       rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
       reverse_rules_map intersect_pairs replace_pair intersect_rules
       delete_P_Pw delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules
       more)
  = nfs;

mkd ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      Bool ->
        Bool ->
          [(Term b c, Term b c)] ->
            [(Term b c, Term b c)] ->
              [Term b c] ->
                [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkd (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = mk;

qc :: forall a b c d. Dpp_ops_ext a b c d -> a -> [Term b c];
qc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = q;

split_proc ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> [(Term b c, Term b c)] ->
                           [(Term b c, Term b c)] -> (a, a);
split_proc i d p_remove r_remove =
  let {
    (p, pw) = split_pairsa i d p_remove;
    (r, rw) = split_rulesc i d r_remove;
    dpp1 = mkd i (nfsc i d) (minimal i d) p pw (qc i d) r rw;
    a = delete_R_Rwc i (delete_P_Pwa i d p_remove p_remove) r_remove r_remove;
  } in (dpp1, a);

rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a ->
      Maybe ((a, Nat) -> [Nat]);
rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
  (Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option x) = x;

sel21 ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a -> Status a;
sel21 xa =
  Abs_status
    (case rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option xa of {
      Nothing -> status (error "undefined");
      Just x2 -> x2;
    });

dis1 ::
  forall a. X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a -> Bool;
dis1 xa =
  (case rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option xa of {
    Nothing -> True;
    Just _ -> False;
  });

rep_isom ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a ->
      Maybe (Status a);
rep_isom x = (if dis1 x then Nothing else Just (sel21 x));

status_of_aux ::
  forall a.
    (Eq a) => [((a, Nat), [Nat])] ->
                X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a;
status_of_aux xa =
  Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
    (if all (\ fidx -> all (\ i -> less_nat i (snd (fst fidx))) (snd fidx)) xa
      then Just (fun_of_map_fun (map_of xa) (\ (_, a) -> upt zero_nat a))
      else Nothing);

status_of :: forall a. (Eq a) => [((a, Nat), [Nat])] -> Maybe (Status a);
status_of x = rep_isom (status_of_aux x);

subst_apply_ctxt :: forall a b c. Ctxt a b -> (b -> Term a c) -> Ctxt a c;
subst_apply_ctxt Hole sigma = Hole;
subst_apply_ctxt (More f ss1 d ss2) sigma =
  More f (map (\ t -> subst_apply_term t sigma) ss1) (subst_apply_ctxt d sigma)
    (map (\ t -> subst_apply_term t sigma) ss2);

shows_ctxt ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Ctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_ctxt fun var Hole = shows_string ['[', ']'];
shows_ctxt fun var (More f ss1 d ss2) =
  fun f .
    shows_string ['('] .
      shows_list_gen (shows_term fun var) [] [] [',', ' '] [',', ' '] ss1 .
        shows_ctxt fun var d .
          shows_list_gen (shows_term fun var) [')'] [',', ' '] [',', ' '] [')']
            ss2;

ta_final :: forall a b c. Ta_ext a b c -> Set a;
ta_final (Ta_ext ta_final ta_rules ta_eps more) = ta_final;

r_states :: forall a b. (Ceq a, Ccompare a, Set_impl a) => Ta_rule a b -> Set a;
r_states = (\ ta_rule -> inserta (r_rhs ta_rule) (set (r_lhs_states ta_rule)));

ta_states ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set a;
ta_states ta =
  sup_set
    (sup_set (sup_seta (image r_states (ta_rules ta)))
      (sup_seta
        (image (\ (q, qa) -> inserta q (inserta qa bot_set)) (ta_eps ta))))
    (ta_final ta);

ta_syms ::
  forall a b.
    (Ccompare a, Eq a, Ceq b, Ccompare b, Eq b,
      Set_impl b) => Ta_ext a b () -> Set (b, Nat);
ta_syms ta = image r_sym (ta_rules ta);

prod_ta ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Set_impl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Ta_ext c b () -> Set (a, c) -> Ta_ext (a, c) b ();
prod_ta tA1 tA2 f =
  Ta_ext f
    (image
      (\ (TA_rule fa qs1 q1, TA_rule _ qs2 q2) ->
        TA_rule fa (zip qs1 qs2) (q1, q2))
      (sup_seta
        (image
          (\ fa ->
            productc (filtera (\ r -> r_sym r == fa) (ta_rules tA1))
              (filtera (\ r -> r_sym r == fa) (ta_rules tA2)))
          (ta_syms tA1))))
    (sup_set
      (image (\ (a, b) -> let {
                            (q, qa) = a;
                          } in (\ p -> ((q, p), (qa, p)))
                            b)
        (productc (ta_eps tA1) (ta_states tA2)))
      (image (\ (p, (q, qa)) -> ((p, q), (p, qa)))
        (productc (ta_states tA1) (ta_eps tA2))))
    ();

productive_relation ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set (a, a);
productive_relation ta =
  sup_set (image (\ (a, b) -> (b, a)) (ta_eps ta))
    (sup_seta
      (image (\ r -> image (\ a -> (r_rhs r, a)) (set (r_lhs_states r)))
        (ta_rules ta)));

ta_productive ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set a;
ta_productive ta =
  sup_set (ta_final ta) (compute_trancl (ta_final ta) (productive_relation ta));

reduced_TA ::
  forall a b c.
    (Ccompare a, Eq a, Ceq b, Ccompare b, Eq b,
      Set_impl b) => a -> Ta_ext b a c -> Set b -> Ta_ext b a ();
reduced_TA f ta q =
  Ta_ext bot_set
    (sup_set
      (image
        (\ (TA_rule fa qs a) ->
          TA_rule fa (filter (\ qa -> not (member qa q)) qs) a)
        (filtera (\ r -> not (member (r_rhs r) q)) (ta_rules ta)))
      (image (\ p -> TA_rule f [] (snd p))
        (filtera (\ p -> member (fst p) q && not (member (snd p) q))
          (ta_eps ta))))
    (filtera (\ p -> not (member (fst p) q) && not (member (snd p) q))
      (ta_eps ta))
    ();

new_reach ::
  forall a b c.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b c -> Set a;
new_reach ta =
  image r_rhs (filtera (\ r -> null (r_lhs_states r)) (ta_rules ta));

ta_reachable ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Default b,
      Eq b) => Ta_ext a b () -> Set a;
ta_reachable ta =
  let {
    q = new_reach ta;
  } in (if less_eq_set q bot_set then bot_set
         else sup_set q (ta_reachable (reduced_TA defaulta ta q)));

ta_restrict ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b c -> Set a -> Ta_ext a b ();
ta_restrict ta q =
  Ta_ext (inf_set (ta_final ta) q)
    (filtera (\ r -> less_eq_set (r_states r) q) (ta_rules ta))
    (inf_set (ta_eps ta) (productc q q)) ();

trim_ta ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Default b, Eq b) => Ta_ext a b () -> Ta_ext a b ();
trim_ta ta =
  ta_restrict (ta_restrict ta (ta_reachable ta))
    (ta_productive (ta_restrict ta (ta_reachable ta)));

check_varcond_no_Var_lhs ::
  forall a b.
    (Showa a,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_varcond_no_Var_lhs =
  (\ xs ->
    catch_errora
      (forallM
        (\ rule ->
          check (not (is_Var (fst rule)))
            ((shows_prec_list zero_nat
                ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'l', 'e', 'f',
                  't', '-', 'h', 'a', 'n', 'd', ' ', 's', 'i', 'd', 'e', ' ',
                  'i', 'n', ' ', 'r', 'u', 'l', 'e', ' '] .
               shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                 [' ', '-', '>', ' '] rule) .
              shows_nl))
        xs)
      (\ x -> Inl (snd x)));

check_subseteq :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_subseteq xs ys =
  catch_errora (forallM (\ x -> (if membera ys x then Inr () else Inl x)) xs)
    (\ x -> Inl (snd x));

check_varcond_subset ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_varcond_subset r =
  catch_errora
    (forallM
      (\ rule ->
        catch_errora
          (check_subseteq (insert_vars_term (snd rule) [])
            (insert_vars_term (fst rule) []))
          (\ x ->
            Inl ((((shows_prec_list zero_nat
                      ['f', 'r', 'e', 'e', ' ', 'v', 'a', 'r', 'i', 'a', 'b',
                        'l', 'e', ' '] .
                     shows_prec zero_nat x) .
                    shows_prec_list zero_nat
                      [' ', 'i', 'n', ' ', 'r', 'i', 'g', 'h', 't', '-', 'h',
                        'a', 'n', 'd', ' ', 's', 'i', 'd', 'e', ' ', 'o', 'f',
                        ' ', 'r', 'u', 'l', 'e', ' ']) .
                   shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                     [' ', '-', '>', ' '] rule) .
                  shows_nl)))
      r)
    (\ x -> Inl (snd x));

check_wf_trs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_trs r =
  catch_errora
    (bindb (check_varcond_no_Var_lhs r) (\ _ -> check_varcond_subset r))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o',
                't', ' ', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e',
                'd'] .
             shows_nl) .
            x));

defined_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
defined_list r =
  concatMap (\ (l, _) -> (if not (is_Var l) then [the (root l)] else [])) r;

generate_f_xs :: forall a. a -> Nat -> Term a [Prelude.Char];
generate_f_xs f n = Fun f (map (\ i -> Var (generate_var i)) (upt zero_nat n));

num_symbs :: forall a b. Term a b -> Nat;
num_symbs (Var x) = one_nat;
num_symbs (Fun f ts) = plus_nat (listsum (map num_symbs ts)) one_nat;

rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Maybe ((a, Nat) -> Af_entry, Set (a, Nat));
rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
  (Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
    x)
  = x;

sel21a ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Afs a;
sel21a xa =
  Abs_afs
    (case rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
            xa
      of {
      Nothing -> rep_afs (error "undefined");
      Just x2 -> x2;
    });

dis1a ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Bool;
dis1a xa =
  (case rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
          xa
    of {
    Nothing -> True;
    Just _ -> False;
  });

rep_isoma ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Maybe (Afs a);
rep_isoma x = (if dis1a x then Nothing else Just (sel21a x));

default_af_entry :: Nat -> Af_entry;
default_af_entry n = AFList (upt zero_nat n);

wf_af_entry :: Nat -> Af_entry -> Bool;
wf_af_entry n (Collapse i) = less_nat i n;
wf_af_entry n (AFList is) = all (\ i -> less_nat i n) is;

afs_of_aux ::
  forall a.
    (Ceq a, Ccompare a, Key a,
      Set_impl a) => [((a, Nat), Af_entry)] ->
                       X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                         a;
afs_of_aux xa =
  Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
    (if all (\ ((_, n), e) -> wf_af_entry n e) xa
      then Just (fun_of_map_fun (ceta_map_of xa)
                   (\ fn -> default_af_entry (snd fn)),
                  set (map fst xa))
      else Nothing);

afs_of ::
  forall a.
    (Ceq a, Ccompare a, Key a,
      Set_impl a) => [((a, Nat), Af_entry)] -> Maybe (Afs a);
afs_of x = rep_isoma (afs_of_aux x);

ta_bounds_lhs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ((a, Nat), [[Prelude.Char]]);
ta_bounds_lhs xml2name =
  many2 ['l', 'h', 's'] xml2name (nata ['h', 'e', 'i', 'g', 'h', 't']) state
    (\ f h -> (\ a -> ((f, h), a)));

bounds_bound :: Xml -> Sum_bot [Prelude.Char] Nat;
bounds_bound = nata ['b', 'o', 'u', 'n', 'd'];

bounds_type :: Xml -> Sum_bot [Prelude.Char] Boundstype;
bounds_type =
  singleton ['t', 'y', 'p', 'e']
    (options
      [(['r', 'o', 'o', 'f'], leaf ['r', 'o', 'o', 'f'] Roof),
        (['m', 'a', 't', 'c', 'h'], leaf ['m', 'a', 't', 'c', 'h'] Match)])
    id;

bounds_info ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Bounds_info a [Prelude.Char]);
bounds_info xml2name =
  guard (\ x -> equal_nat (num_children x) (nat_of_integer (4 :: Integer)))
    (tuple4 ['b', 'o', 'u', 'n', 'd', 's'] bounds_type bounds_bound final_states
      (tree_automaton (ta_bounds_lhs xml2name))
      (\ a b c d -> Bounds_Info a b c d Id_Relation))
    (tuple5 ['b', 'o', 'u', 'n', 'd', 's'] bounds_type bounds_bound final_states
      (tree_automaton (ta_bounds_lhs xml2name)) closed_criterion Bounds_Info);

multiset_af ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), [Nat])];
multiset_af xml2name =
  many ['m', 'u', 'l', 't', 'i', 's', 'e', 't', 'A', 'r', 'g', 'u', 'm', 'e',
         'n', 't', 'F', 'i', 'l', 't', 'e', 'r']
    (triple
      ['m', 'u', 'l', 't', 'i', 's', 'e', 't', 'A', 'r', 'g', 'u', 'm', 'e',
        'n', 't', 'F', 'i', 'l', 't', 'e', 'r', 'E', 'n', 't', 'r', 'y']
      xml2name (nata ['a', 'r', 'i', 't', 'y'])
      (many ['s', 't', 'a', 't', 'u', 's'] position id)
      (\ f a -> (\ b -> ((f, a), b))))
    id;

word_pattern ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ([a], ((Nat, (Nat, [a])), [a]));
word_pattern xml2name =
  let {
    s = string xml2name;
  } in tuple5 ['w', 'o', 'r', 'd', 'P', 'a', 't', 't', 'e', 'r', 'n'] s s
         (nata ['f', 'a', 'c', 't', 'o', 'r'])
         (nata ['c', 'o', 'n', 's', 't', 'a', 'n', 't']) s
         (\ l m f c r -> (l, ((f, (c, m)), r)));

derivation_pattern ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])));
derivation_pattern xml2name =
  pair ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'P', 'a', 't', 't',
         'e', 'r', 'n']
    (word_pattern xml2name) (word_pattern xml2name) (\ a b -> (a, b));

derivation_pattern_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Dp_proof_step a);
derivation_pattern_proof xml2name =
  let {
    oc = oc_srs xml2name;
    dp = derivation_pattern xml2name;
    s = string xml2name;
  } in singleton
         ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'P', 'a', 't', 't',
           'e', 'r', 'n', 'P', 'r', 'o', 'o', 'f']
         (options
           [(['O', 'C', '1'],
              pair ['O', 'C', '1'] oc (bool ['i', 's', 'P', 'a', 'i', 'r'])
                OC1),
             (['O', 'C', '2'], tuple6 ['O', 'C', '2'] oc oc oc s s s OC2),
             (['O', 'C', '2', 'p', 'r', 'i', 'm', 'e'],
               tuple6 ['O', 'C', '2', 'p', 'r', 'i', 'm', 'e'] oc oc oc s s s
                 OC2p),
             (['O', 'C', '3'], tuple5 ['O', 'C', '3'] oc oc oc s s OC3),
             (['O', 'C', '3', 'p', 'r', 'i', 'm', 'e'],
               tuple5 ['O', 'C', '3', 'p', 'r', 'i', 'm', 'e'] oc oc oc s s
                 OC3p),
             (['O', 'C', 'i', 'n', 't', 'o', 'D', 'P', '1'],
               pair ['O', 'C', 'i', 'n', 't', 'o', 'D', 'P', '1'] dp oc OCDP1),
             (['O', 'C', 'i', 'n', 't', 'o', 'D', 'P', '2'],
               pair ['O', 'C', 'i', 'n', 't', 'o', 'D', 'P', '2'] dp oc OCDP2),
             (['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 't'],
               pair ['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 't'] dp dp
                 WPEQ),
             (['l', 'i', 'f', 't'], pair ['l', 'i', 'f', 't'] dp dp Lift),
             (['D', 'P', '_', 'O', 'C', '_', '1', '_', '1'],
               tuple5 ['D', 'P', '_', 'O', 'C', '_', '1', '_', '1'] dp dp oc s s
                 DPOC1_1),
             (['D', 'P', '_', 'O', 'C', '_', '1', '_', '2'],
               tuple6 ['D', 'P', '_', 'O', 'C', '_', '1', '_', '2'] dp dp oc s s
                 s DPOC1_2),
             (['D', 'P', '_', 'O', 'C', '_', '2'],
               tuple5 ['D', 'P', '_', 'O', 'C', '_', '2'] dp dp oc s s DPOC2),
             (['D', 'P', '_', 'O', 'C', '_', '3', '_', '1'],
               tuple5 ['D', 'P', '_', 'O', 'C', '_', '3', '_', '1'] dp dp oc s s
                 DPOC3_1),
             (['D', 'P', '_', 'O', 'C', '_', '3', '_', '2'],
               tuple6 ['D', 'P', '_', 'O', 'C', '_', '3', '_', '2'] dp dp oc s s
                 s DPOC3_2),
             (['D', 'P', '_', 'D', 'P', '_', '1', '_', '1'],
               tuple5 ['D', 'P', '_', 'D', 'P', '_', '1', '_', '1'] dp dp dp s s
                 DPDP1_1),
             (['D', 'P', '_', 'D', 'P', '_', '1', '_', '2'],
               tuple5 ['D', 'P', '_', 'D', 'P', '_', '1', '_', '2'] dp dp dp s s
                 DPDP1_2),
             (['D', 'P', '_', 'D', 'P', '_', '2', '_', '1'],
               tuple5 ['D', 'P', '_', 'D', 'P', '_', '2', '_', '1'] dp dp dp s s
                 DPDP2_1),
             (['D', 'P', '_', 'D', 'P', '_', '2', '_', '2'],
               tuple5 ['D', 'P', '_', 'D', 'P', '_', '2', '_', '2'] dp dp dp s s
                 DPDP2_2)])
         id;

nonloop_srs_reason ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ([Dp_proof_step a] -> Non_loop_srs_proof a);
nonloop_srs_reason xml2name =
  let {
    s = string xml2name;
  } in options
         [(['s', 'e', 'l', 'f', 'E', 'm', 'b', 'e', 'd', 'd', 'i', 'n', 'g',
             'O', 'C'],
            triple
              ['s', 'e', 'l', 'f', 'E', 'm', 'b', 'e', 'd', 'd', 'i', 'n', 'g',
                'O', 'C']
              s s s (\ l m r -> SE_OC (m, l ++ m ++ r) l r)),
           (['s', 'e', 'l', 'f', 'E', 'm', 'b', 'e', 'd', 'd', 'i', 'n', 'g',
              'D', 'P'],
             triple
               ['s', 'e', 'l', 'f', 'E', 'm', 'b', 'e', 'd', 'd', 'i', 'n', 'g',
                 'D', 'P']
               (derivation_pattern xml2name) s s SE_DP)];

nonloop_srs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Non_loop_srs_proof a);
nonloop_srs xml2name =
  pair ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'n', 'g',
         'S', 'R', 'S']
    (many ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'P', 'a', 't', 't',
            'e', 'r', 'n', 's']
      (derivation_pattern_proof xml2name) id)
    (nonloop_srs_reason xml2name) (\ list prf -> prf list);

croots2 :: Poly Complex -> [Complex];
croots2 p =
  let {
    a = coeff p (nat_of_integer (2 :: Integer));
    b = coeff p one_nat;
    c = coeff p zero_nat;
    b2a = divide_complex b (times_complex (numeral (Bit0 One)) a);
    bac = minus_complex (binary_power b2a (nat_of_integer (2 :: Integer)))
            (divide_complex c a);
    e = csqrt bac;
  } in remdups
         [plus_complex (uminus_complex b2a) e,
           minus_complex (uminus_complex b2a) e];

rroots2 :: Poly Real -> [Real];
rroots2 p =
  let {
    a = coeff p (nat_of_integer (2 :: Integer));
    b = coeff p one_nat;
    c = coeff p zero_nat;
    b2a = divide_real b
            (times_real (of_inta (Int_of_integer (2 :: Integer))) a);
    bac = minus_real (binary_power b2a (nat_of_integer (2 :: Integer)))
            (divide_real c a);
  } in (if equal_real bac zero_real then [uminus_real b2a]
         else (if less_real bac zero_real then []
                else let {
                       e = sqrt bac;
                     } in [plus_real (uminus_real b2a) e,
                            minus_real (uminus_real b2a) e]));

nFQ_subset_NF_rulesb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
nFQ_subset_NF_rulesb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = nFQ_subset_NF_rules;

is_QNFb :: forall a b c d. Tp_ops_ext a b c d -> a -> Term b c -> Bool;
is_QNFb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = is_QNF;

rulesd :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulesd
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = rules;

icap_impl_tp ::
  forall a b.
    (Eq b) => Tp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_tp i d =
  let {
    qr = nFQ_subset_NF_rulesb i d;
    qnf = is_QNFb i d;
    r = rulesd i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s -> let {
                 a = ceta_set_of (concatMap vars_term_list s);
               } in ic s a);

label_decomp :: forall a b. Lab a b -> (Lab a b, Sum b [Lab a b]);
label_decomp (Lab f l) = (f, Inl l);
label_decomp (FunLab f l) = (f, Inr l);

is_partition_impl ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => [Set a] -> Maybe (Set a);
is_partition_impl [] = Just bot_set;
is_partition_impl (asa : rest) =
  bind (is_partition_impl rest)
    (\ alla ->
      (if is_empty (inf_set asa alla) then Just (sup_set alla asa)
        else Nothing));

is_partition ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a, Set_impl a) => [Set a] -> Bool;
is_partition asa = not (is_none (is_partition_impl asa));

remdups_sort :: forall a. (Eq a, Linorder a) => [a] -> [a];
remdups_sort xs = remdups_adj (sort_key (\ x -> x) xs);

list_all_rec :: forall a. (a -> Bool) -> [a] -> Bool;
list_all_rec p [] = True;
list_all_rec p (a : l) = p a && list_all_rec p l;

rai_list_hd_intern ::
  [Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))))] ->
    Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))));
rai_list_hd_intern (x : xs) = x;
rai_list_hd_intern [] = Nothing;

rep_rai_list ::
  Rai_list -> [Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))))];
rep_rai_list (Abs_rai_list x) = x;

rai_list_hd :: Rai_list -> Real_alg_intern;
rai_list_hd xa = Abs_real_alg_intern (rai_list_hd_intern (rep_rai_list xa));

rai_list_tl :: Rai_list -> Rai_list;
rai_list_tl xa = Abs_rai_list (tla (rep_rai_list xa));

max_list_non_empty :: forall a. (Linorder a) => [a] -> a;
max_list_non_empty [x] = x;
max_list_non_empty (x : v : va) = max x (max_list_non_empty (v : va));

root_bounds :: Poly Rat -> (Rat, Rat);
root_bounds p =
  let {
    n = degreea p;
    m = times_rat (of_nat n) (max_list_non_empty (map abs_rat (coeffs p)));
    ma = of_int (ceiling m);
  } in (uminus_rat ma, ma);

set_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
set_ext s_ns =
  (\ asa bs ->
    (not (null asa) && all (\ b -> any (\ a -> fst (s_ns a b)) asa) bs,
      all (\ b -> any (\ a -> snd (s_ns a b)) asa) bs));

poly_inf_rat :: Poly Rat -> Rat;
poly_inf_rat p = sgn_rat (coeff p (degreea p));

check_no_var ::
  forall a b.
    (Showa a, Showa b) => Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_var t =
  check (not (is_Var t))
    (shows_string
       ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'f', 'o', 'u', 'n', 'd'] .
      shows_nl);

check_supteq ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Term a b ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_supteq s t =
  check (equal_term s t || supt_impl s t)
    (shows_prec_term zero_nat t .
      shows_string
        [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 't',
          'e', 'r', 'm', ' ', 'o', 'f', ' '] .
        shows_prec_term zero_nat s);

ta_empty ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Default b,
      Eq b) => Ta_ext a b () -> Bool;
ta_empty ta = less_eq_set (inf_set (ta_reachable ta) (ta_final ta)) bot_set;

ta_match ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Eq b, Ceq c,
      Ccompare c) => Ta_ext a b () ->
                       Set a -> Term b c -> Set a -> Set [(c, a)];
ta_match ta qsig (Fun f ts) q =
  let {
    n = size_list ts;
    rls = filtera
            (\ rule ->
              r_sym rule == (f, n) &&
                bex (sup_set (inserta (r_rhs rule) bot_set)
                      (compute_trancl (inserta (r_rhs rule) bot_set)
                        (ta_eps ta)))
                  (\ qa -> member qa q))
            (ta_rules ta);
  } in sup_seta
         (image
           (\ (TA_rule _ qs _) ->
             image concat
               (listset
                 (map (\ (tsi, qsi) ->
                        ta_match ta qsig tsi (inserta qsi bot_set))
                   (zip ts qs))))
           rls);
ta_match ta qsig (Var x) q =
  image (\ qa -> [(x, qa)])
    (filtera (\ qa -> member qa qsig)
      (sup_set q (compute_trancl q (converse (ta_eps ta)))));

generate_listset ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Nat -> Set a -> Set [a];
generate_listset n s =
  (if equal_nat n zero_nat
    then inserta [] (set_empty (of_phantom set_impl_list))
    else set_Cons s (generate_listset (minus_nat n one_nat) s));

minus_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
minus_set a b = inf_set a (uminus_set b);

mergea :: forall a. (Eq a) => Term a () -> Term a () -> Maybe (Term a ());
mergea (Fun fa tsa) (Fun f ts) =
  bind (guarda (fa == f))
    (\ _ ->
      bind (guarda (equal_nat (size_list tsa) (size_list ts)))
        (\ _ ->
          bind (mapMa (\ (a, b) -> mergea a b) (zip tsa ts))
            (\ tsb -> Just (Fun fa tsb))));
mergea (Var ()) x = Just x;
mergea (Fun v va) (Var ()) = Just (Fun v va);

merge_cl :: forall a. (Compare a, Eq a) => Set (Term a ()) -> Set (Term a ());
merge_cl s =
  let {
    new = minus_set (these (image (\ (a, b) -> mergea a b) (productc s s))) s;
  } in (if set_eq new (set_empty (of_phantom set_impl_term)) then s
         else merge_cl (sup_set s new));

subt_merge_cl ::
  forall a b.
    (Compare a, Eq a, Compare b, Eq b) => Set (Term a b) -> Set (Term a ());
subt_merge_cl s =
  merge_cl
    (sup_set (inserta (Var ()) (set_empty (of_phantom set_impl_term)))
      (sup_seta
        (image (\ t -> set (supt_list t))
          (image (map_term (\ x -> x) (\ _ -> ())) s))));

maxa :: forall a. (Ceq a, Ccompare a, Lattice a, Linorder a) => Set a -> a;
maxa a = set_fold1 max_sls a;

matchd :: forall a b. (Eq a) => Term a () -> Term a b -> Bool;
matchd (Var ()) x = True;
matchd (Fun fa tsa) (Fun f ts) = fa == f && list_all2 matchd tsa ts;
matchd (Fun v va) (Var vb) = False;

shrinks ::
  forall a.
    (Compare a, Eq a) => Term a () -> Set (Term a ()) -> Set (Term a ());
shrinks ta t =
  let {
    s = filtera (\ s -> matchd s ta) t;
    max = maxa (image (size_list . funs_term_list) s);
  } in filtera (\ sa -> equal_nat ((size_list . funs_term_list) sa) max) s;

nf_rules_states_impl ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Set (Term a b) ->
                 Set (a, Nat) -> (Set (Ta_rule (Term a ()) a), Set (Term a ()));
nf_rules_states_impl t sig =
  let {
    mcl = subt_merge_cl t;
    states =
      filtera
        (\ q ->
          ball t (\ ta -> not (matchd (map_term (\ x -> x) (\ _ -> ()) ta) q)))
        mcl;
    lhss =
      sup_seta
        (image (\ (f, n) -> image (\ a -> (f, a)) (generate_listset n states))
          sig);
    flhss =
      filtera
        (\ q ->
          ball t
            (\ ta ->
              not (matchd (map_term (\ x -> x) (\ _ -> ()) ta)
                    (Fun (fst q) (snd q)))))
        lhss;
    rules =
      image (\ (f, qs) -> image (TA_rule f qs) (shrinks (Fun f qs) mcl)) flhss;
  } in (sup_seta rules, states);

ta_nf ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Set (Term a b) -> Set (a, Nat) -> Ta_ext (Term a ()) a ();
ta_nf t sig =
  let {
    (rules, states) = nf_rules_states_impl t sig;
  } in Ta_ext states rules
         (set_empty
           (of_phantom
             (set_impl_prod :: Phantom (Term a (), Term a ()) Set_impla)))
         ();

compute_NF :: forall a. (a -> Maybe a) -> a -> Maybe a;
compute_NF f a = (case f a of {
                   Nothing -> Just a;
                   Just aa -> compute_NF f aa;
                 });

first_rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
first_rewrite r s = (case rewrite r s of {
                      [] -> Nothing;
                      t : _ -> Just t;
                    });

compute_rstep_NF ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
compute_rstep_NF r s = compute_NF (first_rewrite r) s;

check_join_NF ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join_NF r s t =
  (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
    (Nothing, _) ->
      Inl (shows_prec_list zero_nat
            ['s', 't', 'r', 'a', 'n', 'g', 'e', ' ', 'e', 'r', 'r', 'o', 'r',
              ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
              'r', 'm', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'a', 't', 'i', 'o',
              'n']);
    (Just _, Nothing) ->
      Inl (shows_prec_list zero_nat
            ['s', 't', 'r', 'a', 'n', 'g', 'e', ' ', 'e', 'r', 'r', 'o', 'r',
              ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
              'r', 'm', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'a', 't', 'i', 'o',
              'n']);
    (Just sa, Just ta) ->
      check (equal_term sa ta)
        (shows_string
           ['t', 'h', 'e', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
             'r', 'm', ' '] .
          shows_prec_term zero_nat sa .
            shows_prec_list zero_nat [' ', 'o', 'f', ' '] .
              shows_prec_term zero_nat s .
                shows_prec_list zero_nat
                  [' ', 'd', 'i', 'f', 'f', 'e', 'r', 's', ' ', 'f', 'r', 'o',
                    'm', ' '] .
                  shows_nl .
                    shows_prec_list zero_nat
                      ['t', 'h', 'e', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ',
                        'f', 'o', 'r', 'm', ' '] .
                      shows_prec_term zero_nat ta .
                        shows_prec_list zero_nat [' ', 'o', 'f', ' '] .
                          shows_prec_term zero_nat t);
  });

in_rstep_impl ::
  forall a b.
    (Compare a, Eq a, Ccompare b, Compare b, Eq b,
      Mapping_impl b) => Term a b ->
                           Term a b -> Set (Term a b, Term a b) -> Bool;
in_rstep_impl s t r =
  any (\ p ->
        in_poss p t &&
          equal_ctxt (ctxt_of_pos_term p s) (ctxt_of_pos_term p t) &&
            let {
              sp = subt_at s p;
              tp = subt_at t p;
            } in bex r (\ lr ->
                         not (is_none
                               (match_list Var [(fst lr, sp), (snd lr, tp)]))))
    (poss_list s);

reverse_rules :: forall a b. [(Term a b, Term a b)] -> [(Term a b, Term a b)];
reverse_rules rs = map swap rs;

wf_rules_impl ::
  forall a b. (Eq b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)];
wf_rules_impl r = filter wf_rule r;

check_pairwise :: forall a b. (a -> a -> Sum b ()) -> [a] -> Sum b ();
check_pairwise c [] = Inr ();
check_pairwise c (x : xs) =
  bindb (catch_errora (forallM (c x) xs) (\ xa -> Inl (snd xa)))
    (\ _ -> check_pairwise c xs);

check_disjoint :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_disjoint xs ys =
  catch_errora
    (forallM (\ x -> (if not (membera ys x) then Inr () else Inl x)) xs)
    (\ x -> Inl (snd x));

check_partition :: forall a. (Eq a) => [[a]] -> Sum a ();
check_partition xss = check_pairwise check_disjoint xss;

check_inj ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Lab a b ->
                    Nat ->
                      [((Lab a b, Nat), [Lab a b])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_inj a nn sml =
  let {
    symbols =
      map (\ (aa, b) ->
            let {
              (_, n) = aa;
            } in (\ fs ->
                   map (\ (g, i) ->
                         (g, plus_nat n (times_nat i (minus_nat nn one_nat))))
                     (zip fs (upt zero_nat (size_list fs))))
              b)
        sml;
    fsymbols = concat symbols;
  } in bindb (catch_errora (check_partition symbols)
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
                       shows_prec_prod zero_nat x .
                         shows_prec_list zero_nat
                           [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 't', 'w',
                             'i', 'c', 'e', ')'])))
         (\ _ ->
           bindb (check (not (membera fsymbols (a, nn)))
                   (shows_prec_list zero_nat
                      ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
                        ' ', 's', 'y', 'm', 'b', 'o', 'l'] .
                     shows_prec_lab zero_nat a .
                       shows_prec_list zero_nat
                         [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'o',
                           'c', 'c', 'u', 'r', ' ', 'a', 's', ' ', 'n', 'e',
                           'w', ' ', 's', 'y', 'm', 'b', 'o', 'l']))
             (\ _ ->
               bindb (check (not (membera (map fst sml) (a, nn)))
                       (shows_prec_list zero_nat
                          ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o',
                            'n', ' ', 's', 'y', 'm', 'b', 'o', 'l'] .
                         shows_prec_lab zero_nat a .
                           shows_prec_list zero_nat
                             [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                               'b', 'e', ' ', 'u', 'n', 'c', 'u', 'r', 'r', 'i',
                               'e', 'd']))
                 (\ _ ->
                   (if less_eq_nat nn one_nat
                     then catch_errora
                            (forallM
                              (check_pairwise
                                (\ gn1 gn2 ->
                                  check (not (gn1 == gn2))
                                    (shows_prec_list zero_nat
                                       ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
                                      shows_prec_prod zero_nat gn1 .
shows_prec_list zero_nat
  [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 't', 'w', 'i', 'c', 'e'])))
                              symbols)
                            (\ x -> Inl (snd x))
                     else Inr ()))));

not_ws_ns :: forall a b c. Redtriple_ext a b c -> Maybe [(a, Nat)];
not_ws_ns (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more)
  = not_ws_ns;

no_complexity_check ::
  forall a b. a -> b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
no_complexity_check =
  (\ _ _ ->
    Inl (shows_prec_list zero_nat
          ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'a', 'n', 'a',
            'l', 'y', 's', 'i', 's', ' ', 'u', 'n', 's', 'u', 'p', 'p', 'o',
            'r', 't', 'e', 'd']));

valid ::
  forall a b c.
    Redtriple_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
valid (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  valid;

desc :: forall a b c. Redtriple_ext a b c -> [Prelude.Char] -> [Prelude.Char];
desc (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  desc;

check_status_ws_info ::
  forall a.
    (Showa a) => Status a ->
                   ((Term a [Prelude.Char], Term a [Prelude.Char]) ->
                     Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                     Maybe [(a, Nat)] ->
                       Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_status_ws_info sigma cns Nothing =
  Inl (shows_prec_list zero_nat
        ['m', 'i', 's', 's', 'i', 'n', 'g', ' ', 'w', 'e', 'a', 'k', '-', 's',
          'u', 'b', 't', 'e', 'r', 'm', ' ', 's', 't', 'a', 't', 'u', 's', ' ',
          'o', 'f', ' ', 'b', 'a', 's', 'e', ' ', 'r', 'e', 'd', 'u', 'c', 't',
          'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r']);
check_status_ws_info sigma cns (Just fs) =
  catch_errora
    (forallM
      (\ f ->
        catch_errora
          (forallM
            (\ i ->
              catch_errora
                (cns (Fun (fst f)
                        (map (\ ia -> Var (shows_prec_nat zero_nat ia []))
                          (upt zero_nat (snd f))),
                       Var (shows_prec_nat zero_nat i [])))
                (\ _ ->
                  Inl (shows_prec_list zero_nat
                         ['a', 'c', 'c', 'o', 'r', 'd', 'i', 'n', 'g', ' ', 't',
                           'o', ' ', 'w', 'e', 'a', 'k', '-', 'm', 'o', 'n',
                           '.', ' ', 'i', 'n', 'f', 'o', 'r', 'm', 'a', 't',
                           'i', 'o', 'n', ' ', 'o', 'f', ' ', 'o', 'r', 'd',
                           'e', 'r', ',', ' ', 'a', 'r', 'g', 'u', 'm', 'e',
                           'n', 't', ' ', '#'] .
                        shows_prec_nat zero_nat (suc i) .
                          shows_prec_list zero_nat
                            [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                              'o', 'c', 'c', 'u', 'r', ' ', 'i', 'n', ' ', 's',
                              't', 'a', 't', 'u', 's', ' ', 'o', 'f', ' '] .
                            shows_prec_prod zero_nat f)))
            (status sigma f))
          (\ x -> Inl (snd x)))
      fs)
    (\ x -> Inl (snd x));

ns :: forall a b c.
        Redtriple_ext a b c ->
          (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
ns (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) = ns;

af :: forall a b c. Redtriple_ext a b c -> (a, Nat) -> Set Nat;
af (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) = af;

s :: forall a b c.
       Redtriple_ext a b c ->
         (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
s (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) = s;

shows_wpo_params ::
  forall a.
    (Showa a) => [((a, Nat), (Nat, [Nat]))] -> [Prelude.Char] -> [Prelude.Char];
shows_wpo_params params =
  shows_prec_list zero_nat
    ['s', 't', 'a', 't', 'u', 's', ' ', 'a', 'n', 'd', ' ', 'p', 'r', 'e', 'c',
      'e', 'd', 'e', 'n', 'c', 'e', ' '] .
    shows_nl .
      shows_sep
        (\ (f, (p, s)) ->
          shows_prec_list zero_nat ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec_prod zero_nat f .
              shows_prec_list zero_nat
                [':', ' ', 'p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e',
                  ' ', '=', ' '] .
                shows_prec_nat zero_nat p .
                  shows_prec_list zero_nat
                    [' ', ' ', ' ', 's', 't', 'a', 't', 'u', 's', ' ', '=',
                      ' '] .
                    shows_prec_list zero_nat s)
        shows_nl params;

faulty_redtriple ::
  forall a b.
    Itself a ->
      Itself b ->
        ([Prelude.Char] -> [Prelude.Char]) ->
          ([Prelude.Char] -> [Prelude.Char]) -> Redtriple_ext a b ();
faulty_redtriple uu uv err desc =
  Redtriple_ext (Inl err) (\ _ -> Inr ()) (\ _ -> Inr ()) (\ _ -> Inr ())
    full_af empty_af (\ _ -> Inr ()) desc Nothing no_complexity_check ();

prl_nat :: forall a. ((a, Nat) -> Nat) -> (a, Nat) -> Bool;
prl_nat pr = (\ f -> equal_nat (pr f) zero_nat);

prc_nat :: forall a. ((a, Nat) -> Nat) -> (a, Nat) -> (a, Nat) -> (Bool, Bool);
prc_nat pr = (\ f g -> let {
                         pf = pr f;
                         pg = pr g;
                       } in (less_nat pg pf, less_eq_nat pg pf));

wpo_redtriple ::
  forall a.
    (Eq a, Key a,
      Showa a) => Redtriple_ext a [Prelude.Char] () ->
                    [((a, Nat), (Nat, [Nat]))] ->
                      Redtriple_ext a [Prelude.Char] ();
wpo_redtriple rt params =
  let {
    stat = map (\ (f, ps) -> (f, snd ps)) params;
    pr = fun_of_map_funa (ceta_map_of params) (\ _ -> zero_nat) fst;
    desca =
      shows_prec_list zero_nat ['W', 'P', 'O', ' ', 'w', 'i', 't', 'h', ' '] .
        shows_wpo_params params .
          shows_nl .
            shows_prec_list zero_nat
              ['o', 'v', 'e', 'r', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                'o', 'w', 'i', 'n', 'g', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i',
                'o', 'n', ' ', 'p', 'a', 'i', 'r', ':'] .
              shows_nl . desc rt;
  } in (case status_of stat of {
         Nothing ->
           faulty_redtriple Type Type
             (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
                 'i', 'n', 'd', 'i', 'c', 'e', 's', ' ', 'i', 'n', ' ', 's',
                 't', 'a', 't', 'u', 's', ' ', 'o', 'f', ' ', 'W', 'P', 'O',
                 '!'])
             desca;
         Just sigma ->
           let {
             sa = (\ sa t -> isOK (s rt (sa, t)));
             nsa = (\ sb t -> isOK (ns rt (sb, t)));
             wpo = wpo_ub (prc_nat pr) (prl_nat pr) sa nsa sigma;
             wpo_s =
               (\ (sb, t) ->
                 check (fst (wpo sb t))
                   (shows_prec_term zero_nat sb .
                     shows_prec_list zero_nat [' ', '>', 'w', 'p', 'o', ' '] .
                       shows_prec_term zero_nat t .
                         shows_prec_list zero_nat
                           [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                             ' ', 'b', 'e', ' ', 'e', 'n', 's', 'u', 'r', 'e',
                             'd']));
             wpo_ns =
               (\ (sb, t) ->
                 check (snd (wpo sb t))
                   (shows_prec_term zero_nat sb .
                     shows_prec_list zero_nat
                       [' ', '>', '=', 'w', 'p', 'o', ' '] .
                       shows_prec_term zero_nat t .
                         shows_prec_list zero_nat
                           [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                             ' ', 'b', 'e', ' ', 'e', 'n', 's', 'u', 'r', 'e',
                             'd']));
           } in Redtriple_ext
                  (bindb (valid rt)
                    (\ _ -> check_status_ws_info sigma (ns rt) (not_ws_ns rt)))
                  wpo_s wpo_ns wpo_ns (af_wpo (af rt) sigma) empty_af
                  (\ _ ->
                    catch_errora
                      (forallM
                        (\ (a, b) ->
                          let {
                            (f, n) = a;
                          } in (\ idx ->
                                 check (eq_set (set idx) (set (upt zero_nat n)))
                                   (shows_prec_list zero_nat
                                      ['f', 'o', 'r', ' ', 'm', 'o', 'n', 'o',
't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ',', ' ', 's', 't', 'a', 't', 'u', 's',
' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 't',
'e', ',', ' ', 'b', 'u', 't', ' ', 's', 't', 'a', 't', 'u', 's', ' ', 'o', 'f',
' '] .
                                     shows_prec_prod zero_nat (f, n) .
                                       shows_prec_list zero_nat
 [' ', 'i', 's', ' '] .
 shows_prec_list zero_nat (map suc idx)))
                            b)
                        stat)
                      (\ x -> Inl (snd x)))
                  desca (Just (map fst stat)) no_complexity_check ();
       });

while :: forall a. (a -> Bool) -> (a -> a) -> a -> a;
while b c s = (if b s then while b c (c s) else s);

apply_af_entry :: forall a b. a -> Af_entry -> [Term a b] -> Term a b;
apply_af_entry uu (Collapse i) ts = nth ts i;
apply_af_entry f (AFList is) ts = Fun f (map (nth ts) is);

afs_term :: forall a b. Afs a -> Term a b -> Term (Filtered a) b;
afs_term pi (Fun f ts) =
  let {
    l = size_list ts;
  } in apply_af_entry (FPair f l) (afsa pi (f, l)) (map (afs_term pi) ts);
afs_term pi (Var x) = Var x;

afs_rule ::
  forall a b.
    Afs a -> (Term a b, Term a b) -> (Term (Filtered a) b, Term (Filtered a) b);
afs_rule pi lr = (afs_term pi (fst lr), afs_term pi (snd lr));

af_rule :: forall a b. Afs a -> (Term a b, Term a b) -> (Term a b, Term a b);
af_rule pi = (\ t -> map_funs_rule filtered_fun (afs_rule pi t));

af_term :: forall a b. Afs a -> Term a b -> Term a b;
af_term pi t = map_term filtered_fun (\ x -> x) (afs_term pi t);

uncurry_info ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (a, ([((a, Nat), [a])],
                ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                  [(Term a [Prelude.Char], Term a [Prelude.Char])])));
uncurry_info xml2name =
  tuple4
    ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'I', 'n', 'f', 'o', 'r', 'm', 'a', 't',
      'i', 'o', 'n']
    xml2name
    (many ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', 'S', 'y', 'm', 'b', 'o',
            'l', 's']
      (many2
        ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', 'S', 'y', 'm', 'b', 'o',
          'l', 'E', 'n', 't', 'r', 'y']
        xml2name (nata ['a', 'r', 'i', 't', 'y']) xml2name
        (\ f n -> (\ a -> ((f, n), a))))
      id)
    (singleton ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'R', 'u', 'l', 'e', 's']
      (rules xml2name) id)
    (singleton ['e', 't', 'a', 'R', 'u', 'l', 'e', 's'] (rules xml2name) id)
    (\ a sml u e -> (a, (sml, (u, e))));

convertible_critical_peaks ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(Term a [Prelude.Char],
             (Term a [Prelude.Char],
               ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                         (Bool, Term a [Prelude.Char])))],
                 ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                           Term a [Prelude.Char]))],
                   ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                             (Bool, Term a [Prelude.Char])))],
                     (Term a [Prelude.Char],
                       ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                                 (Bool, Term a [Prelude.Char])))],
                         ([(Pos, ((Term a [Prelude.Char],
                                    Term a [Prelude.Char]),
                                   Term a [Prelude.Char]))],
                           [(Pos, ((Term a [Prelude.Char],
                                     Term a [Prelude.Char]),
                                    (Bool, Term a [Prelude.Char])))]))))))))];
convertible_critical_peaks xml2name =
  let {
    rew = rsteps xml2name;
    conv = conversion xml2name;
  } in many ['c', 'o', 'n', 'v', 'e', 'r', 't', 'i', 'b', 'l', 'e', 'C', 'r',
              'i', 't', 'i', 'c', 'a', 'l', 'P', 'e', 'a', 'k', 's']
         (triple
           ['c', 'o', 'n', 'v', 'e', 'r', 't', 'i', 'b', 'l', 'e', 'C', 'r',
             'i', 't', 'i', 'c', 'a', 'l', 'P', 'e', 'a', 'k']
           (singleton ['s', 'o', 'u', 'r', 'c', 'e'] (term xml2name) id)
           (triple
             ['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', 'L', 'e', 'f',
               't']
             conv rew conv (\ (s, c1) (_, r) (_, c2) -> (s, (c1, (r, c2)))))
           (triple
             ['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', 'R', 'i', 'g',
               'h', 't']
             conv rew conv (\ (s, c1) (_, r) (_, c2) -> (s, (c1, (r, c2)))))
           (\ s (s1, (cl1, (sl, cl2))) (s2, (cr1, (sr, cr2))) ->
             (s, (s1, (cl1, (sl, (cl2, (s2, (cr1, (sr, cr2))))))))))
         id;

level_mapping ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), [(Nat, Nat)])];
level_mapping xml2name =
  many ['l', 'e', 'v', 'e', 'l', 'M', 'a', 'p', 'p', 'i', 'n', 'g']
    (many2
      ['l', 'e', 'v', 'e', 'l', 'M', 'a', 'p', 'p', 'i', 'n', 'g', 'E', 'n',
        't', 'r', 'y']
      xml2name (nata ['a', 'r', 'i', 't', 'y'])
      (pair ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', 'L', 'e', 'v', 'e', 'l',
              'E', 'n', 't', 'r', 'y']
        (nata ['p', 'o', 's', 'i', 't', 'i', 'o', 'n'])
        (nata ['l', 'e', 'v', 'e', 'l']) (\ a b -> (a, b)))
      (\ f a ps ->
        ((f, a),
          map (\ (p, b) ->
                ((if equal_nat p zero_nat then a else minus_nat p one_nat), b))
            ps)))
    id;

root_redtriple ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Root_redtriple_impl a);
root_redtriple xml2name =
  singleton ['r', 'e', 'd', 'P', 'a', 'i', 'r']
    (triple ['s', 'c', 'n', 'p']
      (singleton ['s', 't', 'a', 't', 'u', 's']
        (options
          [(['m', 's'], leaf ['m', 's'] MS_Ext),
            (['m', 'i', 'n'], leaf ['m', 'i', 'n'] Min_Ext),
            (['d', 'm', 's'], leaf ['d', 'm', 's'] Dms_Ext),
            (['m', 'a', 'x'], leaf ['m', 'a', 'x'] Max_Ext)])
        id)
      (level_mapping xml2name) (redtriple False xml2name) SCNP)
    id;

root_ordering_constraint_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Root_redtriple_impl a);
root_ordering_constraint_proof xml2name =
  singleton
    ['o', 'r', 'd', 'e', 'r', 'i', 'n', 'g', 'C', 'o', 'n', 's', 't', 'r', 'a',
      'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
    (root_redtriple xml2name) id;

ordering_constraint_proof ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
ordering_constraint_proof bi xml2name =
  singleton
    ['o', 'r', 'd', 'e', 'r', 'i', 'n', 'g', 'C', 'o', 'n', 's', 't', 'r', 'a',
      'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
    (redtriple bi xml2name) id;

ordering_constraint_proofa ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml ->
          Sum_bot [Prelude.Char]
            (Sum (Root_redtriple_impl a) (Redtriple_impl a));
ordering_constraint_proofa bi xml2name =
  choice ['r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r']
    [change (ordering_constraint_proof bi xml2name) Inr,
      change (root_ordering_constraint_proof xml2name) Inl];

create_proj :: forall a. (Key a) => ProjL a -> (a, Nat) -> Nat;
create_proj (Projection p) = let {
                               i = ceta_map_of p;
                             } in (\ f -> (case i f of {
    Nothing -> zero_nat;
    Just n -> n;
  }));

xml2cond_constraint ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Cond_constraint a [Prelude.Char]);
xml2cond_constraint xml2name x =
  singleton
    ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o', 'n', 's',
      't', 'r', 'a', 'i', 'n', 't']
    (options
      [(['a', 'l', 'l'],
         pair ['a', 'l', 'l'] (text ['v', 'a', 'r'])
           (xml2cond_constraint xml2name) CC_all),
        (['i', 'm', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n'],
          many1 ['i', 'm', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n']
            (xml2cond_constraint xml2name) (xml2cond_constraint xml2name)
            (\ c cs -> let {
                         ccs = c : cs;
                       } in CC_impl (take (size_list cs) ccs) (last ccs))),
        (['c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't'],
          triple ['c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't']
            (term xml2name)
            (options
              [(['r', 'e', 'w', 'r', 'i', 't', 'e'],
                 leaf ['r', 'e', 'w', 'r', 'i', 't', 'e'] Nothing),
                (['s', 't', 'r', 'i', 'c', 't'],
                  leaf ['s', 't', 'r', 'i', 'c', 't'] (Just True)),
                (['n', 'o', 'n', 'S', 't', 'r', 'i', 'c', 't'],
                  leaf ['n', 'o', 'n', 'S', 't', 'r', 'i', 'c', 't']
                    (Just False))])
            (term xml2name)
            (\ s rel t -> (case rel of {
                            Nothing -> CC_rewr s t;
                            Just stri -> CC_cond stri (s, t);
                          })))])
    id x;

xml2cond_constraint_prf ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Cond_constraint_prf a [Prelude.Char]);
xml2cond_constraint_prf xml2name x =
  let {
    cc = xml2cond_constraint xml2name;
  } in singleton
         ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o', 'n',
           's', 't', 'r', 'a', 'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
         (options
           [(['f', 'i', 'n', 'a', 'l'], leaf ['f', 'i', 'n', 'a', 'l'] Final),
             (['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', 'C', 'o', 'n', 's',
                't', 'r', 'u', 'c', 't', 'o', 'r'],
               singleton
                 ['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', 'C', 'o', 'n',
                   's', 't', 'r', 'u', 'c', 't', 'o', 'r']
                 cc Different_Constructor),
             (['s', 'a', 'm', 'e', 'C', 'o', 'n', 's', 't', 'r', 'u', 'c', 't',
                'o', 'r'],
               triple
                 ['s', 'a', 'm', 'e', 'C', 'o', 'n', 's', 't', 'r', 'u', 'c',
                   't', 'o', 'r']
                 cc cc (xml2cond_constraint_prf xml2name) Same_Constructor),
             (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'E', 'q', 'u', 'a', 't',
                'i', 'o', 'n'],
               tuple4
                 ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'E', 'q', 'u', 'a',
                   't', 'i', 'o', 'n']
                 (text ['v', 'a', 'r']) (term xml2name) cc
                 (xml2cond_constraint_prf xml2name) Variable_Equation),
             (['f', 'u', 'n', 'a', 'r', 'g', 'I', 'n', 't', 'o', 'V', 'a', 'r'],
               tuple5
                 ['f', 'u', 'n', 'a', 'r', 'g', 'I', 'n', 't', 'o', 'V', 'a',
                   'r']
                 cc position (text ['v', 'a', 'r']) cc
                 (xml2cond_constraint_prf xml2name) Funarg_Into_Var),
             (['s', 'i', 'm', 'p', 'l', 'i', 'f', 'y', 'C', 'o', 'n', 'd', 'i',
                't', 'i', 'o', 'n'],
               tuple4
                 ['s', 'i', 'm', 'p', 'l', 'i', 'f', 'y', 'C', 'o', 'n', 'd',
                   'i', 't', 'i', 'o', 'n']
                 cc (substa xml2name) cc (xml2cond_constraint_prf xml2name)
                 Simplify_Condition),
             (['i', 'n', 'd', 'u', 'c', 't', 'i', 'o', 'n'],
               triple ['i', 'n', 'd', 'u', 'c', 't', 'i', 'o', 'n'] cc
                 (many ['c', 'o', 'n', 'j', 'u', 'n', 'c', 't', 's'] cc id)
                 (many ['r', 'u', 'l', 'e', 'C', 'o', 'n', 's', 't', 'r', 'a',
                         'i', 'n', 't', 'P', 'r', 'o', 'o', 'f', 's']
                   (tuple4
                     ['r', 'u', 'l', 'e', 'C', 'o', 'n', 's', 't', 'r', 'a',
                       'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
                     (rule xml2name)
                     (many ['s', 'u', 'b', 't', 'e', 'r', 'm', 'V', 'a', 'r',
                             'E', 'n', 't', 'r', 'i', 'e', 's']
                       (many1
                         ['s', 'u', 'b', 't', 'e', 'r', 'm', 'V', 'a', 'r', 'E',
                           'n', 't', 'r', 'y']
                         (term xml2name) (text ['v', 'a', 'r'])
                         (\ a b -> (a, b)))
                       id)
                     cc (xml2cond_constraint_prf xml2name)
                     (\ lr rys cca p -> (lr, (rys, (cca, p)))))
                   id)
                 Induction),
             (['d', 'e', 'l', 'e', 't', 'e', 'C', 'o', 'n', 'd', 'i', 't', 'i',
                'o', 'n'],
               pair ['d', 'e', 'l', 'e', 't', 'e', 'C', 'o', 'n', 'd', 'i', 't',
                      'i', 'o', 'n']
                 cc (xml2cond_constraint_prf xml2name) Delete_Condition)])
         id x;

xml2cond_red_pair_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Cond_red_pair_prf a [Prelude.Char]);
xml2cond_red_pair_proof xml2name =
  tuple4
    ['c', 'o', 'n', 'd', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'o',
      'f']
    xml2name (nata ['b', 'e', 'f', 'o', 'r', 'e'])
    (nata ['a', 'f', 't', 'e', 'r'])
    (many ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's']
      (triple ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n']
        (xml2cond_constraint xml2name)
        (singleton ['d', 'p', 'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e']
          (rules xml2name) id)
        (xml2cond_constraint_prf xml2name) (\ c s p -> (c, (s, p))))
      id)
    (\ c b a ccs -> Cond_Red_Pair_Prf c ccs b a);

strategy_to_Q ::
  forall a b.
    (Eq a, Eq b) => Strategy a b -> [(Term a b, Term a b)] -> [Term a b];
strategy_to_Q No_Strategy uu = [];
strategy_to_Q Innermost r = remdups (map fst r);
strategy_to_Q (Innermost_Q q) uv = q;

o_to_fp_term :: forall a b. Term a b -> (Ctxt a b, (Term a b, Location));
o_to_fp_term t = (Hole, (t, Ba));

o_to_fp_impl :: forall a b. [Term a b] -> [(Ctxt a b, (Term a b, Location))];
o_to_fp_impl = map o_to_fp_term;

mu_to_fp_impl ::
  forall a.
    (Eq a) => [((a, Nat), [Nat])] ->
                [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
mu_to_fp_impl mu =
  let {
    fs = remdups (map fst mu);
    m = map_of mu;
    a = concatMap
          (\ f ->
            let {
              xs = map Var (fresh_strings_list ['x'] zero_nat [] (snd f));
            } in map (\ i -> (f, (xs, i)))
                   (concatMap
                     (\ i -> (if not (membera (the (m f)) i) then [i] else []))
                     (upt zero_nat (snd f))))
          fs;
  } in concatMap
         (\ ((f, _), (xs, i)) ->
           map (\ loc ->
                 (ctxt_of_pos_term (PCons i Empty) (Fun f xs), (nth xs i, loc)))
             [Ba, H])
         a;

strategy_to_fp ::
  forall a.
    (Eq a) => Fp_strategy a [Prelude.Char] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
strategy_to_fp (Forbidden_Patterns p) r = p;
strategy_to_fp Outermost r = o_to_fp_impl (map fst r);
strategy_to_fp (Context_Sensitive mu) r = mu_to_fp_impl mu;

default_nfs_trs :: Bool;
default_nfs_trs = False;

xml2inn_fp_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Sum (Bool,
                            ([Term (Lab a b) [Prelude.Char]],
                              ([(Term (Lab a b) [Prelude.Char],
                                  Term (Lab a b) [Prelude.Char])],
                                [(Term (Lab a b) [Prelude.Char],
                                   Term (Lab a b) [Prelude.Char])])))
                       ([(Ctxt (Lab a b) [Prelude.Char],
                           (Term (Lab a b) [Prelude.Char], Location))],
                         [(Term (Lab a b) [Prelude.Char],
                            Term (Lab a b) [Prelude.Char])]));
xml2inn_fp_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        Inn_TRS_input (inn, (r, so)) ->
          returna
            (Inl (default_nfs_trs,
                   (strategy_to_Q inn r, (r, (case so of {
       Nothing -> [];
       Just s -> s;
     })))));
        COMP_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        EQ_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        CPX_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        FP_TRS_input (fp, r) -> returna (Inr (strategy_to_fp fp r, r));
        CTRS_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        TA_input _ _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        AC_input _ _ _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        Unknown_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
      }));

default_nfs_nt_dp :: Bool;
default_nfs_nt_dp = False;

default_nfs_dp :: Bool;
default_nfs_dp = True;

xml2dp_inputa ::
  forall a b.
    (Eq a,
      Eq b) => Bool ->
                 (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                   Xml ->
                     Sum_bot [Prelude.Char]
                       (Bool,
                         (Bool,
                           ([(Term (Lab a b) [Prelude.Char],
                               Term (Lab a b) [Prelude.Char])],
                             ([(Term (Lab a b) [Prelude.Char],
                                 Term (Lab a b) [Prelude.Char])],
                               ([Term (Lab a b) [Prelude.Char]],
                                 ([(Term (Lab a b) [Prelude.Char],
                                     Term (Lab a b) [Prelude.Char])],
                                   [(Term (Lab a b) [Prelude.Char],
                                      Term (Lab a b) [Prelude.Char])]))))));
xml2dp_inputa termination xml2name =
  change (xml2dp_input xml2name)
    (\ (m, (p, (q, r))) ->
      ((if termination then default_nfs_dp else default_nfs_nt_dp),
        (m, (p, ([], (strategy_to_Q q r, ([], r)))))));

xml1many2elements_gen ::
  forall a b c d e.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (a -> [b] -> c -> d -> e) -> Xml -> Sum_bot [Prelude.Char] e;
xml1many2elements_gen tag p1 p2 p3 p4 f (XML name atts cs) =
  let {
    ds = reverse cs;
    l = size_list cs;
  } in (if name == tag &&
             null atts && less_eq_nat (nat_of_integer (3 :: Integer)) l
         then binda (p1 (nth cs zero_nat))
                (\ x ->
                  binda (map_sum_bot (p2 x)
                          (tla (take (minus_nat l
                                       (nat_of_integer (2 :: Integer)))
                                 cs)))
                    (\ xs ->
                      binda (p3 (nth ds one_nat))
                        (\ y ->
                          binda (p4 (nth ds zero_nat))
                            (\ z -> returna (f x xs y z)))))
         else fail tag (XML name atts cs));
xml1many2elements_gen tag p1 p2 p3 p4 f (XML_text v) = fail tag (XML_text v);

projected_rseq ::
  forall a.
    (Eq a) => (Xml -> Sum_bot [Prelude.Char] a) ->
                ((a, Nat) -> Nat) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      ((Term a [Prelude.Char], Term a [Prelude.Char]),
                        [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                                 Term a [Prelude.Char]))]);
projected_rseq xml2name pi xml =
  let {
    tag = ['p', 'r', 'o', 'j', 'e', 'c', 't', 'e', 'd', 'R', 'e', 'w', 'r', 'i',
            't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e'];
  } in (case xml of {
         XML name atts cs ->
           (if name == tag &&
                 null atts &&
                   equal_nat (size_list cs) (nat_of_integer (2 :: Integer))
             then binda (rule xml2name (nth cs zero_nat))
                    (\ r -> rseq xml2name pi r (nth cs one_nat))
             else fail tag xml);
         XML_text _ -> fail tag xml;
       });

flat_contexts ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [Ctxt a [Prelude.Char]];
flat_contexts xml2name =
  many ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 's']
    (ctxt xml2name) id;

xml2fp_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     ([(Ctxt (Lab a b) [Prelude.Char],
                         (Term (Lab a b) [Prelude.Char], Location))],
                       [(Term (Lab a b) [Prelude.Char],
                          Term (Lab a b) [Prelude.Char])]);
xml2fp_trs_assm xml2name x =
  binda (xml2inn_fp_trs_assm xml2name x)
    (\ a ->
      (case a of {
        Inl _ ->
          errora
            ['F', 'P', ' ', 'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't',
              'e', 'd', ' ', 'a', 't', ' ', 't', 'h', 'i', 's', ' ', 'p', 'o',
              'i', 'n', 't'];
        Inr aa -> returna aa;
      }));

xml2inn_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Bool,
                       ([Term (Lab a b) [Prelude.Char]],
                         ([(Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char])],
                           [(Term (Lab a b) [Prelude.Char],
                              Term (Lab a b) [Prelude.Char])])));
xml2inn_trs_assm xml2name x =
  binda (xml2inn_fp_trs_assm xml2name x)
    (\ a ->
      (case a of {
        Inl aa -> returna aa;
        Inr _ ->
          errora
            ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', '(', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ')', ' ', 'T', 'R', 'S', ' ', 'e',
              'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'a', 't', ' ', 't', 'h',
              'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
      }));

xml2trs_termination_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Trs_termination_proof a b [Prelude.Char]);
xml2trs_termination_proof xml2name x =
  options
    [(['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
        'P', 'r', 'o', 'o', 'f'],
       singleton
         ['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
           'P', 'r', 'o', 'o', 'f']
         (options
           [(['r', 'I', 's', 'E', 'm', 'p', 't', 'y'],
              leaf ['r', 'I', 's', 'E', 'm', 'p', 't', 'y'] R_is_Empty),
             (['s', 'e', 'm', 'l', 'a', 'b'],
               guard (\ xa ->
                       equal_nat (num_children xa)
                         (nat_of_integer (3 :: Integer)))
                 (triple ['s', 'e', 'm', 'l', 'a', 'b'] (sl_variant xml2name)
                   (singleton ['t', 'r', 's'] (rules xml2name) id)
                   (xml2trs_termination_proof xml2name)
                   (\ sli -> Semlab sli []))
                 (tuple4 ['s', 'e', 'm', 'l', 'a', 'b'] (sl_variant xml2name)
                   (singleton ['t', 'r', 's'] (rules xml2name) id)
                   (innermostLhss xml2name) (xml2trs_termination_proof xml2name)
                   (\ sli lr lq -> Semlab sli lq lr))),
             (['s', 'p', 'l', 'i', 't'],
               triple ['s', 'p', 'l', 'i', 't']
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name)
                 (xml2trs_termination_proof xml2name) Split),
             (['d', 'p', 'T', 'r', 'a', 'n', 's'],
               triple ['d', 'p', 'T', 'r', 'a', 'n', 's']
                 (singleton ['d', 'p', 's'] (rules xml2name) id)
                 (bool ['m', 'a', 'r', 'k', 'e', 'd', 'S', 'y', 'm', 'b', 'o',
                         'l', 's'])
                 (xml2dp_termination_proof xml2name)
                 (\ dps _ -> DP_Trans default_nfs_dp True dps)),
             (['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
               triple ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
                 (ordering_constraint_proof False xml2name)
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) Rule_Removal),
             (['b', 'o', 'u', 'n', 'd', 's'],
               change (bounds_info xml2name) Bounds),
             (['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a',
                'l'],
               pair ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's',
                      'a', 'l']
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) (\ _ -> String_Reversal)),
             (['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U', 'n', 'a',
                'r', 'y'],
               tuple4
                 ['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U', 'n',
                   'a', 'r', 'y']
                 plain_var (renaming xml2name)
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name)
                 (\ v ren s ->
                   Constant_String (Const_string_sound_proof v ren s []))),
             (['r', 'e', 'm', 'o', 'v', 'e', 'N', 'o', 'n', 'A', 'p', 'p', 'l',
                'i', 'c', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's'],
               pair ['r', 'e', 'm', 'o', 'v', 'e', 'N', 'o', 'n', 'A', 'p', 'p',
                      'l', 'i', 'c', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e',
                      's']
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name)
                 Remove_Nonapplicable_Rules),
             (['u', 'n', 'c', 'u', 'r', 'r', 'y'],
               triple ['u', 'n', 'c', 'u', 'r', 'r', 'y']
                 (uncurry_info xml2name)
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) Uncurry),
             (['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C', 'l',
                'o', 's', 'u', 'r', 'e'],
               triple
                 ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C',
                   'l', 'o', 's', 'u', 'r', 'e']
                 (flat_contexts xml2name)
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) Fcc),
             (['s', 'w', 'i', 't', 'c', 'h', 'I', 'n', 'n', 'e', 'r', 'm', 'o',
                's', 't'],
               pair ['s', 'w', 'i', 't', 'c', 'h', 'I', 'n', 'n', 'e', 'r', 'm',
                      'o', 's', 't']
                 (wcr_proof xml2name) (xml2trs_termination_proof xml2name)
                 Switch_Innermost),
             (['p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', 'A', 'r', 'g', 'u',
                'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r'],
               pair ['p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', 'A', 'r', 'g',
                      'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r']
                 (afs xml2name) (xml2trs_termination_proof xml2name)
                 Permuting_AFS),
             (['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'A', 's',
                's', 'u', 'm', 'p', 't', 'i', 'o', 'n'],
               singleton
                 ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'A',
                   's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
                 (xml2inn_trs_assm xml2name) (\ qtrs -> Assume_SN qtrs [])),
             (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
               many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o',
                       'f']
                 (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
                 (xml2inn_trs_assm xml2name)
                 (\ xa ->
                   let {
                     cs = children xa;
                   } in (if not (equal_nat (size_list cs)
                                  (nat_of_integer (2 :: Integer)))
                          then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                          else let {
                                 inp = take (nat_of_integer (2 :: Integer))
 (tag (nth cs one_nat));
                               } in (if inp == ['t', 'r'] || inp == ['r', 'e']
                                      then binda
     (xml2inn_fp_trs_assm xml2name (hda cs))
     (\ io_trs ->
       (case io_trs of {
         Inl qtrs ->
           change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
         Inr fptrs ->
           change (xml2fptrs_termination_proof xml2name)
             (SN_FP_assm_proof fptrs);
       })
         (nth cs one_nat))
                                      else (if inp == ['d', 'p']
     then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
            (xml2dp_inputa True xml2name) (xml2dp_termination_proof xml2name)
            Finite_assm_proof xa
     else (if inp == ['u', 'n']
            then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xml2unknown_input
                   (xml2unknown_proof xml2name) Unknown_assm_proof xa
            else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa)))))
                 (\ _ -> Assume_SN))])
         id),
      (['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm', 'i', 'n',
         'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
        singleton
          ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm', 'i', 'n',
            'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f']
          (options
            [(['r', 'I', 's', 'E', 'm', 'p', 't', 'y'],
               leaf ['r', 'I', 's', 'E', 'm', 'p', 't', 'y'] R_is_Empty),
              (['s', 'I', 's', 'E', 'm', 'p', 't', 'y'],
                singleton ['s', 'I', 's', 'E', 'm', 'p', 't', 'y']
                  (xml2trs_termination_proof xml2name) id),
              (['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
                tuple4 ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
                  (ordering_constraint_proof False xml2name)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ rp one two -> Rule_Removal rp (one ++ two))),
              (['s', 'e', 'm', 'l', 'a', 'b'],
                guard (\ xa ->
                        equal_nat (num_children xa)
                          (nat_of_integer (4 :: Integer)))
                  (tuple4 ['s', 'e', 'm', 'l', 'a', 'b'] (sl_variant xml2name)
                    (singleton ['t', 'r', 's'] (rules xml2name) id)
                    (singleton ['t', 'r', 's'] (rules xml2name) id)
                    (xml2trs_termination_proof xml2name)
                    (\ sli lr lrw -> Semlab sli [] (lr ++ lrw)))
                  (tuple5 ['s', 'e', 'm', 'l', 'a', 'b'] (sl_variant xml2name)
                    (singleton ['t', 'r', 's'] (rules xml2name) id)
                    (singleton ['t', 'r', 's'] (rules xml2name) id)
                    (innermostLhss xml2name)
                    (xml2trs_termination_proof xml2name)
                    (\ sli lr lrw lq -> Semlab sli lq (lr ++ lrw)))),
              (['u', 'n', 'c', 'u', 'r', 'r', 'y'],
                tuple4 ['u', 'n', 'c', 'u', 'r', 'r', 'y']
                  (uncurry_info xml2name)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ i r s -> Uncurry i (r ++ s))),
              (['p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', 'A', 'r', 'g', 'u',
                 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r'],
                pair ['p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', 'A', 'r',
                       'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e',
                       'r']
                  (afs xml2name) (xml2trs_termination_proof xml2name)
                  Permuting_AFS),
              (['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C', 'l',
                 'o', 's', 'u', 'r', 'e'],
                tuple4
                  ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C',
                    'l', 'o', 's', 'u', 'r', 'e']
                  (flat_contexts xml2name)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ fcc r s -> Fcc fcc (r ++ s))),
              (['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a',
                 'l'],
                triple
                  ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's',
                    'a', 'l']
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ _ _ -> String_Reversal)),
              (['e', 'q', 'u', 'a', 'l', 'i', 't', 'y', 'R', 'e', 'm', 'o', 'v',
                 'a', 'l'],
                singleton
                  ['e', 'q', 'u', 'a', 'l', 'i', 't', 'y', 'R', 'e', 'm', 'o',
                    'v', 'a', 'l']
                  (xml2trs_termination_proof xml2name) Drop_Equality),
              (['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U', 'n', 'a',
                 'r', 'y'],
                tuple5
                  ['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U', 'n',
                    'a', 'r', 'y']
                  plain_var (renaming xml2name)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ v ren s sw ->
                    Constant_String (Const_string_sound_proof v ren s sw))),
              (['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm', 'i',
                 'n', 'a', 't', 'i', 'o', 'n', 'A', 's', 's', 'u', 'm', 'p',
                 't', 'i', 'o', 'n'],
                singleton
                  ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm',
                    'i', 'n', 'a', 't', 'i', 'o', 'n', 'A', 's', 's', 'u', 'm',
                    'p', 't', 'i', 'o', 'n']
                  (xml1to2elements ['t', 'r', 's', 'I', 'n', 'p', 'u', 't']
                    (singleton ['t', 'r', 's'] (rules xml2name) id)
                    (singleton
                      ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'R', 'u', 'l',
                        'e', 's']
                      (rules xml2name) id)
                    (\ r a ->
                      (case a of {
                        Nothing ->
                          Assume_SN (default_nfs_trs, ([], (r, []))) [];
                        Just rw ->
                          Assume_SN (default_nfs_trs, ([], (r, rw))) [];
                      })))
                  id),
              (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
                many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o',
                        'f']
                  (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
                  (xml2inn_trs_assm xml2name)
                  (\ xa ->
                    let {
                      cs = children xa;
                    } in (if not (equal_nat (size_list cs)
                                   (nat_of_integer (2 :: Integer)))
                           then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                           else let {
                                  inp = take (nat_of_integer (2 :: Integer))
  (tag (nth cs one_nat));
                                } in (if inp == ['t', 'r'] || inp == ['r', 'e']
                                       then binda
      (xml2inn_fp_trs_assm xml2name (hda cs))
      (\ io_trs ->
        (case io_trs of {
          Inl qtrs ->
            change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
          Inr fptrs ->
            change (xml2fptrs_termination_proof xml2name)
              (SN_FP_assm_proof fptrs);
        })
          (nth cs one_nat))
                                       else (if inp == ['d', 'p']
      then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
             (xml2dp_inputa True xml2name) (xml2dp_termination_proof xml2name)
             Finite_assm_proof xa
      else (if inp == ['u', 'n']
             then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                    xml2unknown_input (xml2unknown_proof xml2name)
                    Unknown_assm_proof xa
             else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa)))))
                  (\ _ -> Assume_SN))])
          id)]
    x;

xml2fptrs_termination_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Fptrs_termination_proof a b [Prelude.Char]);
xml2fptrs_termination_proof xml2name x =
  singleton
    ['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'P',
      'r', 'o', 'o', 'f']
    (options
      [(['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'A', 's', 's',
          'u', 'm', 'p', 't', 'i', 'o', 'n'],
         singleton
           ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'A', 's',
             's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
           (xml2fp_trs_assm xml2name) (\ qtrs -> Assume_FP_SN qtrs [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2fp_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs)
                             (nat_of_integer (2 :: Integer)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (nat_of_integer (2 :: Integer))
                                    (tag (nth cs one_nat));
                          } in (if inp == ['t', 'r'] || inp == ['r', 'e']
                                 then binda
(xml2inn_fp_trs_assm xml2name (hda cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fptrs_termination_proof xml2name) (SN_FP_assm_proof fptrs);
  })
    (nth cs one_nat))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] (xml2dp_inputa True xml2name)
       (xml2dp_termination_proof xml2name) Finite_assm_proof xa
else (if inp == ['u', 'n']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xml2unknown_input
              (xml2unknown_proof xml2name) Unknown_assm_proof xa
       else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa)))))
            (\ _ -> Assume_FP_SN))])
    id x;

xml2dp_termination_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Dp_termination_proof a b [Prelude.Char]);
xml2dp_termination_proof xml2name x =
  singleton ['d', 'p', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['p', 'I', 's', 'E', 'm', 'p', 't', 'y'],
         leaf ['p', 'I', 's', 'E', 'm', 'p', 't', 'y'] P_is_Empty),
        (['d', 'e', 'p', 'G', 'r', 'a', 'p', 'h', 'P', 'r', 'o', 'c'],
          many ['d', 'e', 'p', 'G', 'r', 'a', 'p', 'h', 'P', 'r', 'o', 'c']
            (xml2nd_choice ['c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't']
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              ['r', 'e', 'a', 'l', 'S', 'c', 'c']
              (xml2dp_termination_proof xml2name)
              (\ dps prfOpt -> (prfOpt, dps)))
            Dep_Graph_Proc),
        (['r', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c'],
          triple ['r', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c']
            (ordering_constraint_proofa False xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Redpair_Proc),
        (['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'P', 'r', 'o',
           'c'],
          pair ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'P', 'r',
                 'o', 'c']
            (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Usable_Rules_Proc),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's', 'R',
           'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c'],
          pair ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's',
                 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c']
            (innermostLhss xml2name) (xml2dp_termination_proof xml2name)
            Q_Reduction_Proc),
        (['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o', 'c'],
          guard (\ xa ->
                  equal_nat (num_children xa) (nat_of_integer (3 :: Integer)))
            (triple
              ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o', 'c']
              (rule xml2name) (rstep xml2name)
              (xml2dp_termination_proof xml2name)
              (\ (s, t) (p, (lr, ta)) ->
                Rewriting_Proc Nothing (s, t) (s, ta) (s, ta) lr p))
            (guard
              (\ xa ->
                equal_nat (num_children xa) (nat_of_integer (4 :: Integer)))
              (guard
                (\ xa ->
                  tag (nth (children xa) (nat_of_integer (2 :: Integer))) ==
                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's'])
                (tuple4
                  ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                    'c']
                  (rule xml2name) (rstep xml2name)
                  (singleton
                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                    (rules xml2name) id)
                  (xml2dp_termination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) u ->
                    Rewriting_Proc (Just u) (s, t) (s, ta) (s, ta) lr p))
                (tuple4
                  ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                    'c']
                  (rule xml2name) (rstep xml2name) (rule xml2name)
                  (xml2dp_termination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) st ->
                    Rewriting_Proc Nothing (s, t) (s, ta) st lr p)))
              (tuple5
                ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                  'c']
                (rule xml2name) (rstep xml2name) (rule xml2name)
                (singleton
                  ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                  (rules xml2name) id)
                (xml2dp_termination_proof xml2name)
                (\ (s, t) (p, (lr, ta)) st u ->
                  Rewriting_Proc (Just u) (s, t) (s, ta) st lr p)))),
        (['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 'P', 'r', 'o', 'c'],
          tuple4
            ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 'P', 'r', 'o', 'c']
            (rule xml2name) pos
            (singleton ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Narrowing_Proc),
        (['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n', 'P',
           'r', 'o', 'c'],
          triple
            ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
              'P', 'r', 'o', 'c']
            (rule xml2name)
            (singleton
              ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Instantiation_Proc),
        (['f', 'o', 'r', 'w', 'a', 'r', 'd', 'I', 'n', 's', 't', 'a', 'n', 't',
           'i', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'c'],
          xml3to4elements
            ['f', 'o', 'r', 'w', 'a', 'r', 'd', 'I', 'n', 's', 't', 'a', 'n',
              't', 'i', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'c']
            (rule xml2name)
            (singleton
              ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                's']
              (rules xml2name) id)
            (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Forward_Instantiation_Proc),
        (['s', 'e', 'm', 'l', 'a', 'b', 'P', 'r', 'o', 'c'],
          guard (\ xa ->
                  equal_nat (num_children xa) (nat_of_integer (4 :: Integer)))
            (tuple4 ['s', 'e', 'm', 'l', 'a', 'b', 'P', 'r', 'o', 'c']
              (sl_variant xml2name)
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              (singleton ['t', 'r', 's'] (rules xml2name) id)
              (xml2dp_termination_proof xml2name)
              (\ sli lp -> Semlab_Proc sli lp []))
            (tuple5 ['s', 'e', 'm', 'l', 'a', 'b', 'P', 'r', 'o', 'c']
              (sl_variant xml2name)
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              (singleton ['t', 'r', 's'] (rules xml2name) id)
              (innermostLhss xml2name) (xml2dp_termination_proof xml2name)
              (\ sli lp lr lq -> Semlab_Proc sli lp lq lr))),
        (['s', 'u', 'b', 't', 'e', 'r', 'm', 'P', 'r', 'o', 'c'],
          xml1many2elements_gen
            ['s', 'u', 'b', 't', 'e', 'r', 'm', 'P', 'r', 'o', 'c']
            (options
              [(['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't',
                  'e', 'r'],
                 change (proj xml2name) Inl),
                (['m', 'u', 'l', 't', 'i', 's', 'e', 't', 'A', 'r', 'g', 'u',
                   'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r'],
                  change (multiset_af xml2name) Inr)])
            (\ pi ->
              projected_rseq xml2name (create_proj (case pi of {
             Inl pia -> pia;
             Inr _ -> Projection [];
           })))
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name)
            (\ pi_mpi seq dps prf ->
              (case pi_mpi of {
                Inl pi -> Subterm_Criterion_Proc pi seq dps prf;
                Inr mpi -> Gen_Subterm_Criterion_Proc mpi dps prf;
              }))),
        (['r', 'e', 'd', 'P', 'a', 'i', 'r', 'U', 'r', 'P', 'r', 'o', 'c'],
          tuple4
            ['r', 'e', 'd', 'P', 'a', 'i', 'r', 'U', 'r', 'P', 'r', 'o', 'c']
            (ordering_constraint_proofa False xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Redpair_UR_Proc),
        (['m', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'U', 'r', 'P',
           'r', 'o', 'c'],
          tuple5
            ['m', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'U', 'r',
              'P', 'r', 'o', 'c']
            (ordering_constraint_proof False xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Mono_Redpair_UR_Proc),
        (['m', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o',
           'c'],
          tuple4
            ['m', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r',
              'o', 'c']
            (ordering_constraint_proof False xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Mono_Redpair_Proc),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'M', 'o', 'n', 'o', 'R',
           'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c'],
          triple
            ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'M', 'o', 'n', 'o',
              'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c']
            (ordering_constraint_proof False xml2name)
            (pair ['d', 'e', 'l', 'e', 't', 'e', 'd']
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              (singleton ['t', 'r', 's'] (rules xml2name) id) (\ a b -> (a, b)))
            (xml2dp_termination_proof xml2name)
            (\ rp (a, b) -> Mono_URM_Redpair_Proc rp a b)),
        (['u', 'n', 'c', 'u', 'r', 'r', 'y', 'P', 'r', 'o', 'c'],
          guard (\ xa ->
                  equal_nat (num_children xa) (nat_of_integer (4 :: Integer)))
            (tuple4 ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'P', 'r', 'o', 'c']
              (uncurry_info xml2name)
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              (singleton ['t', 'r', 's'] (rules xml2name) id)
              (xml2dp_termination_proof xml2name) (Uncurry_Proc Nothing))
            (tuple5 ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'P', 'r', 'o', 'c']
              (nata ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'v', 'e', 'T',
                      'o', 'p'])
              (uncurry_info xml2name)
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              (singleton ['t', 'r', 's'] (rules xml2name) id)
              (xml2dp_termination_proof xml2name)
              (\ n -> Uncurry_Proc (Just n)))),
        (['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C', 'l', 'o',
           's', 'u', 'r', 'e', 'P', 'r', 'o', 'c'],
          tuple5
            ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C', 'l',
              'o', 's', 'u', 'r', 'e', 'P', 'r', 'o', 'c']
            (singleton ['f', 'r', 'e', 's', 'h', 'S', 'y', 'm', 'b', 'o', 'l']
              xml2name id)
            (flat_contexts xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Fcc_Proc),
        (['s', 'w', 'i', 't', 'c', 'h', 'I', 'n', 'n', 'e', 'r', 'm', 'o', 's',
           't', 'P', 'r', 'o', 'c'],
          pair ['s', 'w', 'i', 't', 'c', 'h', 'I', 'n', 'n', 'e', 'r', 'm', 'o',
                 's', 't', 'P', 'r', 'o', 'c']
            (wcr_proof xml2name) (xml2dp_termination_proof xml2name)
            Switch_Innermost_Proc),
        (['s', 'p', 'l', 'i', 't', 'P', 'r', 'o', 'c'],
          tuple4 ['s', 'p', 'l', 'i', 't', 'P', 'r', 'o', 'c']
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name)
            (xml2dp_termination_proof xml2name) Split_Proc),
        (['f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', 'A', 's', 's', 'u',
           'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', 'A', 's', 's',
              'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2dp_inputa True xml2name) (\ dpp -> Assume_Finite dpp [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2dp_inputa True xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs)
                             (nat_of_integer (2 :: Integer)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (nat_of_integer (2 :: Integer))
                                    (tag (nth cs one_nat));
                          } in (if inp == ['t', 'r'] || inp == ['r', 'e']
                                 then binda
(xml2inn_fp_trs_assm xml2name (hda cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fptrs_termination_proof xml2name) (SN_FP_assm_proof fptrs);
  })
    (nth cs one_nat))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] (xml2dp_inputa True xml2name)
       (xml2dp_termination_proof xml2name) Finite_assm_proof xa
else (if inp == ['u', 'n']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xml2unknown_input
              (xml2unknown_proof xml2name) Unknown_assm_proof xa
       else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa)))))
            (\ _ -> Assume_Finite)),
        (['s', 'w', 'i', 't', 'c', 'h', 'T', 'o', 'T', 'R', 'S'],
          singleton ['s', 'w', 'i', 't', 'c', 'h', 'T', 'o', 'T', 'R', 'S']
            (xml2trs_termination_proof xml2name) To_Trs_Proc),
        (['u', 'n', 'l', 'a', 'b', 'P', 'r', 'o', 'c'],
          triple ['u', 'n', 'l', 'a', 'b', 'P', 'r', 'o', 'c']
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Unlab_Proc),
        (['g', 'e', 'n', 'e', 'r', 'a', 'l', 'R', 'e', 'd', 'P', 'a', 'i', 'r',
           'P', 'r', 'o', 'c'],
          guard (\ xa ->
                  equal_nat (num_children xa) (nat_of_integer (5 :: Integer)))
            (tuple5
              ['g', 'e', 'n', 'e', 'r', 'a', 'l', 'R', 'e', 'd', 'P', 'a', 'i',
                'r', 'P', 'r', 'o', 'c']
              (ordering_constraint_proof True xml2name)
              (singleton ['s', 't', 'r', 'i', 'c', 't'] (rules xml2name) id)
              (singleton ['b', 'o', 'u', 'n', 'd'] (rules xml2name) id)
              (xml2cond_red_pair_proof xml2name)
              (xml2dp_termination_proof xml2name)
              (\ rp s b c p -> General_Redpair_Proc rp s b c [p]))
            (tuple6
              ['g', 'e', 'n', 'e', 'r', 'a', 'l', 'R', 'e', 'd', 'P', 'a', 'i',
                'r', 'P', 'r', 'o', 'c']
              (ordering_constraint_proof True xml2name)
              (singleton ['s', 't', 'r', 'i', 'c', 't'] (rules xml2name) id)
              (singleton ['b', 'o', 'u', 'n', 'd'] (rules xml2name) id)
              (xml2cond_red_pair_proof xml2name)
              (xml2dp_termination_proof xml2name)
              (xml2dp_termination_proof xml2name)
              (\ rp s b c ps pb -> General_Redpair_Proc rp s b c [ps, pb]))),
        (['c', 'o', 'm', 'p', 'l', 'e', 'x', 'C', 'o', 'n', 's', 't', 'a', 'n',
           't', 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c'],
          triple
            ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'C', 'o', 'n', 's', 't', 'a',
              'n', 't', 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c']
            (term xml2name)
            (many ['r', 'u', 'l', 'e', 'M', 'a', 'p']
              (pair ['r', 'u', 'l', 'e', 'M', 'a', 'p', 'E', 'n', 't', 'r', 'y']
                (rule xml2name) (rule xml2name) (\ a b -> (a, b)))
              id)
            (xml2dp_termination_proof xml2name)
            (\ t rls ->
              Complex_Constant_Removal_Proc
                (Complex_Constant_Removal_Proof t rls))),
        (['s', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'P', 'r', 'o', 'c'],
          many1 ['s', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'P', 'r',
                  'o', 'c']
            (options
              [(['s', 'u', 'b', 't', 'e', 'r', 'm', 'C', 'r', 'i', 't', 'e',
                  'r', 'i', 'o', 'n'],
                 leaf ['s', 'u', 'b', 't', 'e', 'r', 'm', 'C', 'r', 'i', 't',
                        'e', 'r', 'i', 'o', 'n']
                   Nothing),
                (['r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', 'P', 'a', 'i',
                   'r'],
                  xml1to2elements
                    ['r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', 'P', 'a', 'i',
                      'r']
                    (ordering_constraint_proof False xml2name)
                    (singleton
                      ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                      (rules xml2name) id)
                    (\ redp ur -> Just (redp, ur)))])
            (scg xml2name)
            (\ a ->
              (case a of {
                Nothing -> Size_Change_Subterm_Proc;
                Just redp_ur ->
                  Size_Change_Redpair_Proc (fst redp_ur) (snd redp_ur);
              })))])
    id x;

xml2unknown_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char] (Unknown_proof a b [Prelude.Char]);
xml2unknown_proof xml2name x =
  singleton
    ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't', 'P', 'r', 'o',
      'o', 'f']
    (options
      [(['u', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 's', 's', 'u', 'm', 'p', 't',
          'i', 'o', 'n'],
         singleton
           ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 's', 's', 'u', 'm', 'p',
             't', 'i', 'o', 'n']
           xml2unknown_input (\ u -> Assume_Unknown u [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            xml2unknown_input
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs)
                             (nat_of_integer (2 :: Integer)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (nat_of_integer (2 :: Integer))
                                    (tag (nth cs one_nat));
                          } in (if inp == ['t', 'r'] || inp == ['r', 'e']
                                 then binda
(xml2inn_fp_trs_assm xml2name (hda cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fptrs_termination_proof xml2name) (SN_FP_assm_proof fptrs);
  })
    (nth cs one_nat))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] (xml2dp_inputa True xml2name)
       (xml2dp_termination_proof xml2name) Finite_assm_proof xa
else (if inp == ['u', 'n']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xml2unknown_input
              (xml2unknown_proof xml2name) Unknown_assm_proof xa
       else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa)))))
            (\ _ -> Assume_Unknown))])
    id x;

rule_labeling_function ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]), Nat)];
rule_labeling_function xml2name =
  many ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g', 'F', 'u',
         'n', 'c', 't', 'i', 'o', 'n']
    (pair ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g', 'F', 'u',
            'n', 'c', 't', 'i', 'o', 'n', 'E', 'n', 't', 'r', 'y']
      (rule xml2name) (nata ['l', 'a', 'b', 'e', 'l']) (\ a b -> (a, b)))
    id;

add_source_lab_proof ::
  forall a b c.
    Cr_proof a b c ->
      Maybe Nat -> Trs_termination_proof a b c -> Cr_proof a b c;
add_source_lab_proof (Rule_Labeling rl js uu) uv prf =
  Rule_Labeling rl js (Just prf);
add_source_lab_proof (Rule_Labeling_Conv rl cs uw) (Just n) prf =
  Rule_Labeling_Conv rl cs (Just (n, prf));

xml2cr_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char] (Cr_proof a [Nat] [Prelude.Char]);
xml2cr_proof xml2name x =
  singleton ['c', 'r', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['w', 'c', 'r', 'A', 'n', 'd', 'S', 'N'],
         pair ['w', 'c', 'r', 'A', 'n', 'd', 'S', 'N'] (wcr_proof xml2name)
           (xml2trs_termination_proof xml2name) SN_WCR),
        (['o', 'r', 't', 'h', 'o', 'g', 'o', 'n', 'a', 'l'],
          leaf ['o', 'r', 't', 'h', 'o', 'g', 'o', 'n', 'a', 'l']
            Weakly_Orthogonal),
        (['s', 't', 'r', 'o', 'n', 'g', 'l', 'y', 'C', 'l', 'o', 's', 'e', 'd'],
          change
            (nata ['s', 't', 'r', 'o', 'n', 'g', 'l', 'y', 'C', 'l', 'o', 's',
                    'e', 'd'])
            Strongly_Closed),
        (['p', 'a', 'r', 'a', 'l', 'l', 'e', 'l', 'C', 'l', 'o', 's', 'e', 'd'],
          guard (\ xa -> equal_nat (num_children xa) one_nat)
            (change
              (nata ['p', 'a', 'r', 'a', 'l', 'l', 'e', 'l', 'C', 'l', 'o', 's',
                      'e', 'd'])
              (\ n -> Parallel_Closed (Just n)))
            (leaf ['p', 'a', 'r', 'a', 'l', 'l', 'e', 'l', 'C', 'l', 'o', 's',
                    'e', 'd']
              (Parallel_Closed Nothing))),
        (['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g'],
          pair ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
            (rule_labeling_function xml2name) (joinable_critical_pairs xml2name)
            (\ rl js -> Rule_Labeling rl js Nothing)),
        (['d', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n', 'g', 'D', 'i', 'a', 'g',
           'r', 'a', 'm', 's'],
          guard (\ xa ->
                  equal_nat (num_children xa) (nat_of_integer (2 :: Integer)))
            (pair ['d', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n', 'g', 'D', 'i',
                    'a', 'g', 'r', 'a', 'm', 's']
              (xml2trs_termination_proof xml2name)
              (options
                [(['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g'],
                   pair ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n',
                          'g']
                     (rule_labeling_function xml2name)
                     (joinable_critical_pairs xml2name)
                     (\ rl js -> (Rule_Labeling rl js Nothing, Nothing))),
                  (['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g',
                     'C', 'o', 'n', 'v'],
                    triple
                      ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n',
                        'g', 'C', 'o', 'n', 'v']
                      (rule_labeling_function xml2name)
                      (convertible_critical_peaks xml2name)
                      (nata ['n', 'r', 'S', 't', 'e', 'p', 's'])
                      (\ rl cs n ->
                        (Rule_Labeling_Conv rl cs Nothing, Just n)))])
              (\ prf (rljs, n) -> add_source_lab_proof rljs n prf))
            (singleton
              ['d', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n', 'g', 'D', 'i', 'a',
                'g', 'r', 'a', 'm', 's']
              (options
                [(['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g'],
                   pair ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n',
                          'g']
                     (rule_labeling_function xml2name)
                     (joinable_critical_pairs xml2name)
                     (\ rl js -> Rule_Labeling rl js Nothing)),
                  (['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g',
                     'C', 'o', 'n', 'v'],
                    pair ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n',
                           'g', 'C', 'o', 'n', 'v']
                      (rule_labeling_function xml2name)
                      (convertible_critical_peaks xml2name)
                      (\ rl cs -> Rule_Labeling_Conv rl cs Nothing))])
              id)),
        (['r', 'e', 'd', 'u', 'n', 'd', 'a', 'n', 't', 'R', 'u', 'l', 'e', 's'],
          xml3to4elements
            ['r', 'e', 'd', 'u', 'n', 'd', 'a', 'n', 't', 'R', 'u', 'l', 'e',
              's']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (nata ['n', 'r', 'S', 't', 'e', 'p', 's'])
            (many ['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', 's']
              (conversion xml2name) (map snd))
            (xml2cr_proof xml2name)
            (\ trs n convs prf -> (case convs of {
                                    Nothing -> Redundant_Rules trs n [] prf;
                                    Just cs -> Redundant_Rules trs n cs prf;
                                  })))])
    id x;

xml2eq_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Eq_proof a [Prelude.Char]);
xml2eq_proof xml2name x =
  options
    [(['r', 'e', 'f', 'l'],
       singleton ['r', 'e', 'f', 'l'] (term xml2name) Refl),
      (['s', 'y', 'm'], singleton ['s', 'y', 'm'] (xml2eq_proof xml2name) Sym),
      (['t', 'r', 'a', 'n', 's'],
        pair ['t', 'r', 'a', 'n', 's'] (xml2eq_proof xml2name)
          (xml2eq_proof xml2name) Trans),
      (['a', 's', 's', 'm'],
        pair ['a', 's', 's', 'm'] (rule xml2name) (substa xml2name)
          (\ r s -> Assm r (mk_subst Var s))),
      (['c', 'o', 'n', 'g'],
        many1 ['c', 'o', 'n', 'g'] xml2name (xml2eq_proof xml2name) Cong)]
    x;

xml_ac_input ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => [(Term (Lab a [b]) c, Term (Lab a [b]) c)] ->
                    [Lab a [b]] -> [Lab a [b]] -> Xml;
xml_ac_input r a c =
  XML ['a', 'c', 'R', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'y', 's', 't', 'e',
        'm']
    [] [xml_rules ['t', 'r', 's'] r,
         XML ['A', 's', 'y', 'm', 'b', 'o', 'l', 's'] [] (map xml_lab a),
         XML ['C', 's', 'y', 'm', 'b', 'o', 'l', 's'] [] (map xml_lab c)];

xml_repl_map ::
  forall a b. (Showa a, Showa b) => ((Lab a [b], Nat), [Nat]) -> Xml;
xml_repl_map =
  (\ (a, b) ->
    let {
      (f, aa) = a;
    } in (\ l ->
           XML ['r', 'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', 'M', 'a',
                 'p', 'E', 'n', 't', 'r', 'y']
             [] (xml_lab f :
                  XML ['a', 'r', 'i', 't', 'y'] []
                    [XML_text (shows_prec_nat zero_nat aa [])] :
                    map xml_single_pos l))
      b);

xml_forbidden_pattern ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (Ctxt (Lab a [b]) c, (Term (Lab a [b]) c, Location)) -> Xml;
xml_forbidden_pattern =
  (\ (c, (t, l)) ->
    XML ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e',
          'r', 'n']
      [] [xml_term (ctxt_apply_term c t), xml_pos (hole_pos c),
           (case l of {
             H -> XML ['h', 'e', 'r', 'e'] [] [];
             A -> XML ['a', 'b', 'o', 'v', 'e'] [] [];
             Ba -> XML ['b', 'e', 'l', 'o', 'w'] [] [];
             Ra -> XML ['r', 'i', 'g', 'h', 't'] [] [];
           })]);

xml_strategy ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => Sum (Strategy (Lab a [b]) c) (Fp_strategy (Lab a [b]) c) ->
                    [Xml];
xml_strategy (Inl No_Strategy) = [];
xml_strategy (Inl Innermost) =
  [XML ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'] []
     [XML ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'] [] []]];
xml_strategy (Inr Outermost) =
  [XML ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'] []
     [XML ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't'] [] []]];
xml_strategy (Inr (Forbidden_Patterns p)) =
  [XML ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'] []
     [XML ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e',
            'r', 'n', 's']
        [] (map xml_forbidden_pattern p)]];
xml_strategy (Inr (Context_Sensitive mu)) =
  [XML ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'] []
     [XML ['c', 'o', 'n', 't', 'e', 'x', 't', 'S', 'e', 'n', 's', 'i', 't', 'i',
            'v', 'e']
        [] (map xml_repl_map mu)]];
xml_strategy (Inl (Innermost_Q q)) =
  [XML ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'] []
     [XML ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's'] []
        (map xml_term q)]];

xml_ta_input ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => Tree_automaton [Prelude.Char] (Lab a [b]) ->
                    [(Term (Lab a [b]) c, Term (Lab a [b]) c)] -> Xml;
xml_ta_input ta r =
  XML ['t', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', 'P',
        'r', 'o', 'b', 'l', 'e', 'm']
    [] [xml_ta ta, xml_rules ['t', 'r', 's'] r];

mk_cpx ::
  forall a b c d e.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    ([Term (Lab b c) [Prelude.Char]],
                      ([(Term (Lab b c) [Prelude.Char],
                          Term (Lab b c) [Prelude.Char])],
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          (d, e)))) ->
                      (a, (d, e));
mk_cpx i (q, (s, (w, (cm, cc)))) = (mkc i False q s w, (cm, cc));

mk_tp ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      (Bool, ([Term b c], ([(Term b c, Term b c)], [(Term b c, Term b c)]))) ->
        a;
mk_tp i (nfs, (q, (r, rw))) = mkc i nfs q r rw;

nFQ_subset_NF_rulesc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
nFQ_subset_NF_rulesc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = nFQ_subset_NF_rules;

is_QNFc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Term b c -> Bool;
is_QNFc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = is_QNF;

rulese :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulese
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules;

icap_impl_dpp ::
  forall a b.
    (Eq b) => Dpp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_dpp i d =
  let {
    qr = nFQ_subset_NF_rulesc i d;
    qnf = is_QNFc i d;
    r = rulese i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s -> let {
                 a = ceta_set_of (concatMap vars_term_list s);
               } in ic s a);

shows_kbo_repr ::
  forall a.
    (Showa a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                   [Prelude.Char] -> [Prelude.Char];
shows_kbo_repr (prs, w0) =
  ((((((((((((((((((((shows_prec_list zero_nat
                        ['K', 'B', 'O', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h',
                          'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                          ' ', 'p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e',
                          ' ', 'a', 'n', 'd', ' ', 'w', 'e', 'i', 'g', 'h', 't',
                          ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n'] .
                       shows_nl) .
                      foldr (\ (a, b) ->
                              let {
                                (f, n) = a;
                              } in (\ (pr, (_, _)) ->
                                     (((((shows_prec_list zero_nat
    ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', '('] .
   shows_prec zero_nat f) .
  shows_prec_list zero_nat ['[']) .
 shows_prec_nat zero_nat n) .
shows_prec_list zero_nat [']', ')', ' ', '=', ' ']) .
                                       shows_prec_nat zero_nat pr) .
                                       shows_nl)
                                b)
                        prs) .
                     shows_nl) .
                    shows_prec_list zero_nat
                      ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', '(',
                        '_', ')', ' ', '=', ' ', '0']) .
                   shows_nl) .
                  shows_prec_list zero_nat
                    ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                      'o', 'w', 'i', 'n', 'g', ' ', 'w', 'e', 'i', 'g', 'h',
                      't']) .
                 shows_nl) .
                foldr (\ (a, b) ->
                        let {
                          (f, n) = a;
                        } in (\ (_, (w, _)) ->
                               (((((shows_prec_list zero_nat
                                      ['w', 'e', 'i', 'g', 'h', 't', '('] .
                                     shows_prec zero_nat f) .
                                    shows_prec_list zero_nat ['[']) .
                                   shows_prec_nat zero_nat n) .
                                  shows_prec_list zero_nat
                                    [']', ')', ' ', '=', ' ']) .
                                 shows_prec_nat zero_nat w) .
                                 shows_nl)
                          b)
                  prs) .
               shows_nl) .
              shows_prec_list zero_nat
                ['w', 'e', 'i', 'g', 'h', 't', '(', '_', ')', ' ', '=', ' ']) .
             shows_prec_nat zero_nat (suc w0)) .
            shows_nl) .
           shows_prec_list zero_nat ['w', '0', ' ', '=', ' ']) .
          shows_prec_nat zero_nat w0) .
         shows_nl) .
        shows_prec_list zero_nat
          ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w',
            'i', 'n', 'g', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', ' ', 'c',
            'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', ' ', 'f', 'u',
            'n', 'c', 't', 'i', 'o', 'n', 's']) .
       shows_nl) .
      foldr (\ (a, b) ->
              let {
                (f, n) = a;
              } in (\ (_, (_, scf)) ->
                     (((((shows_prec_list zero_nat ['s', 'c', 'f', '('] .
                           shows_prec zero_nat f) .
                          shows_prec_list zero_nat ['[']) .
                         shows_prec_nat zero_nat n) .
                        shows_prec_list zero_nat [']', ')', ' ', '=', ' ']) .
                       (if is_none scf
                         then shows_prec_list zero_nat ['a', 'l', 'l', ' ', '1']
                         else shows_prec_list zero_nat (the scf))) .
                       shows_nl)
                b)
        prs) .
     shows_nl) .
    shows_prec_list zero_nat
      ['s', 'c', 'f', '(', '_', ')', ' ', '=', ' ', 'a', 'l', 'l', ' ', '1']) .
    shows_nl;

roots_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
roots_of_cm (Derivational_Complexity f) = f;
roots_of_cm (Runtime_Complexity c d) = d;

sym_collect :: forall a b. (Term a b -> Bool) -> Term a b -> [a];
sym_collect p (Var x) = [];
sym_collect p (Fun f ts) =
  (if p (Fun f ts) then [f] else []) ++ concatMap (sym_collect p) ts;

upper_triangular :: forall a. (Zero a, Eq a) => Mat a -> Bool;
upper_triangular a =
  all_interval_nat
    (\ i -> all_interval_nat (\ j -> mat_index a (i, j) == zeroa) zero_nat i)
    zero_nat (mat_dim_row a);

pat_of ::
  forall a.
    Dp_proof_step a ->
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])));
pat_of (OC1 rl uu) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC2 rl uv uw ux uy uz) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC2p rl va vb vc vd ve) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC3 rl vf vg vh vi) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC3p rl vj vk vl vm) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OCDP1 p vn) = p;
pat_of (OCDP2 p vo) = p;
pat_of (WPEQ p vp) = p;
pat_of (Lift p vq) = p;
pat_of (DPOC1_1 p vr vs vt vu) = p;
pat_of (DPOC1_2 p vv vw vx vy vz) = p;
pat_of (DPOC2 p wa wb wc wd) = p;
pat_of (DPOC3_1 p we wf wg wh) = p;
pat_of (DPOC3_2 p wi wj wk wl wm) = p;
pat_of (DPDP1_1 p wn wo wp wq) = p;
pat_of (DPDP1_2 p wr ws wt wu) = p;
pat_of (DPDP2_1 p wv ww wx wy) = p;
pat_of (DPDP2_2 p wz xa xb xc) = p;

power :: forall a. (Power a) => a -> Nat -> a;
power a n =
  (if equal_nat n zero_nat then onea
    else times a (power a (minus_nat n one_nat)));

mk_rtrancl_list_main ::
  forall a. (a -> a -> Bool) -> (a -> [a]) -> [a] -> [a] -> [a];
mk_rtrancl_list_main subsumes r todo fin =
  (case todo of {
    [] -> fin;
    a : tod ->
      (if any (\ b -> subsumes b a) fin
        then mk_rtrancl_list_main subsumes r tod fin
        else mk_rtrancl_list_main subsumes r (r a ++ tod) (a : fin));
  });

mk_rtrancl_list :: forall a. (a -> a -> Bool) -> (a -> [a]) -> [a] -> [a];
mk_rtrancl_list subsumes r init = mk_rtrancl_list_main subsumes r init [];

ins_dj_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
ins_dj_rm_basic_ops x s = insert x () s;

mk_rtrancl_set_main ::
  forall a. (Compare_order a) => (a -> [a]) -> [a] -> Rbt a () -> Rbt a ();
mk_rtrancl_set_main r todo fin =
  (case todo of {
    [] -> fin;
    a : tod ->
      (if memb_rm_basic_ops a fin then mk_rtrancl_set_main r tod fin
        else mk_rtrancl_set_main r (r a ++ tod) (ins_dj_rm_basic_ops a fin));
  });

mk_rtrancl_set :: forall a. (Compare_order a) => (a -> [a]) -> [a] -> Rbt a ();
mk_rtrancl_set r init = mk_rtrancl_set_main r init (empty_rm_basic_ops ());

rai_list_nil :: Rai_list -> Bool;
rai_list_nil xa = (case rep_rai_list xa of {
                    [] -> True;
                    _ : _ -> False;
                  });

roots_of_rai_main ::
  Poly Rat ->
    Root_info ->
      (Rat -> Rat -> Nat) ->
        [(Rat, Rat)] ->
          [(Poly_type, (Root_info, (Poly Rat, (Rat, Rat))))] ->
            [(Poly_type, (Root_info, (Poly Rat, (Rat, Rat))))];
roots_of_rai_main p ri cr lrs rais =
  (case lrs of {
    [] -> rais;
    (l, r) : lrsa ->
      let {
        c = cr l r;
      } in (if equal_nat c zero_nat then roots_of_rai_main p ri cr lrsa rais
             else (if equal_nat c one_nat
                    then let {
                           (la, ra) = tighten_poly_bounds_for_x cr zero_rat l r;
                         } in roots_of_rai_main p ri cr lrsa
                                ((Monic_Root_Free, (ri, (p, (la, ra)))) : rais)
                    else let {
                           m = divide_rat (plus_rat l r)
                                 (of_int (Int_of_integer (2 :: Integer)));
                         } in roots_of_rai_main p ri cr ((m, r) : (l, m) : lrsa)
                                rais));
  });

roots_of_rai_intern_monic_irr ::
  Poly Rat -> [Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))))];
roots_of_rai_intern_monic_irr p =
  (if equal_nat (degreea p) one_nat
    then [of_rat_rai_fun (uminus_rat (coeff p zero_nat))]
    else let {
           ri = count_roots_interval_rat p;
           cr = l_r ri;
         } in map (rai_normalize No_Guarantee . Just)
                (roots_of_rai_main p ri cr [root_bounds p] []));

roots_of_rai_intern ::
  Poly Rat -> [Maybe (Poly_type, (Root_info, (Poly Rat, (Rat, Rat))))];
roots_of_rai_intern p =
  concatMap roots_of_rai_intern_monic_irr
    (concatMap (factors_of_rat_poly Check_Root_Free)
      (factors_of_rat_poly Uncertified_Factorization p));

roots_of_rai_list :: Poly Rat -> Rai_list;
roots_of_rai_list xa = Abs_rai_list (roots_of_rai_intern xa);

rai_list_convert :: Rai_list -> [Real_alg_intern];
rai_list_convert xs =
  (if rai_list_nil xs then []
    else rai_list_hd xs : rai_list_convert (rai_list_tl xs));

roots_of_rai_impl :: Poly Rat -> [Real_alg_intern];
roots_of_rai_impl p = rai_list_convert (roots_of_rai_list p);

roots_of_rai :: Poly Rat -> [Real_alg_intern];
roots_of_rai p = roots_of_rai_impl p;

eval_polya ::
  forall a b. (Zero a, Comm_semiring_1 b) => (a -> b) -> Poly a -> b -> b;
eval_polya h p x = fold_coeffs (\ a b -> plus (h a) (times x b)) p zeroa;

eq_rules_no_left_vara :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> Bool;
eq_rules_no_left_vara
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = eq_rules_no_left_var;

eq_rules_map ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
eq_rules_map
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = eq_rules_map;

tcapRM_ac_dpp ::
  forall a b c.
    (Eq b, Eq c) => Ac_dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
tcapRM_ac_dpp i dpp = tcapRM (eq_rules_no_left_vara i dpp) (eq_rules_map i dpp);

subst_compose_impl ::
  forall a b.
    (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> [(a, Term b a)];
subst_compose_impl sigma tau =
  let {
    sigmaa = mk_subst_domain sigma;
    taua = mk_subst_domain tau;
    d_sigma = map fst sigmaa;
  } in map (\ (x, t) -> (x, subst_apply_term t (mk_subst Var taua))) sigmaa ++
         filter (\ (x, _) -> not (membera d_sigma x)) taua;

commutes_impl ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> Bool;
commutes_impl sigma mu =
  subst_eq (subst_compose_impl sigma mu) (subst_compose_impl mu sigma);

mk_subst_case ::
  forall a b.
    (Eq a,
      Eq b) => [a] -> (a -> Term b a) -> [(a, Term b a)] -> [(a, Term b a)];
mk_subst_case xs sigma tau =
  subst_compose_impl (map (\ x -> (x, sigma x)) xs) tau;

ta_matcha ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Eq b, Ceq c,
      Ccompare c) => Ta_ext a b () -> Set a -> Term b c -> Set [(c, a)];
ta_matcha ta q t = ta_match ta q t q;

adapt_vars :: forall a b c. Term a b -> Term a c;
adapt_vars (Fun f ts) = Fun f (map adapt_vars ts);

ta_member ::
  forall a b c.
    (Ccompare a, Eq a, Cenum c, Ceq c, Ccompare c, Eq c,
      Set_impl c) => Term a b -> Ta_ext c a () -> Bool;
ta_member t ta =
  ground t &&
    not (less_eq_set (inf_set (ta_final ta) (ta_res ta (adapt_vars t)))
          bot_set);

rhs_eps_cl_memo ::
  forall a b c.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Set_impl b, Ccompare c,
      Eq c) => (a -> Set b) -> Set (Ta_rule a c) -> Set b;
rhs_eps_cl_memo memo rules = sup_seta (image (memo . r_rhs) rules);

list_intera :: forall a. (Ceq a, Ccompare a, Set_impl a) => [Set a] -> Set a;
list_intera [] = top_set;
list_intera [x] = x;
list_intera (x : v : va) = inf_set x (list_intera (v : va));

ps_states_cons_impl ::
  forall a b c d e.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Set_impl b, Ceq c,
      Ccompare c, Ccompare d,
      Eq d) => (a -> Set b) ->
                 Set (c, (Nat, Set (Ta_rule a d))) ->
                   e -> Set (Set a) -> Set (Set b);
ps_states_cons_impl meps parts rules q =
  let {
    lhs_nth_in_Q =
      (\ (n, rs) ->
        map (\ i ->
              minus_set
                (image
                  (\ p -> filtera (\ r -> member (nth (r_lhs_states r) i) p) rs)
                  q)
                (inserta (set_empty (of_phantom set_impl_ta_rule))
                  (set_empty (of_phantom set_impl_set))))
          (upt zero_nat n));
  } in sup_seta
         (image
           (\ (_, nrs) ->
             minus_set
               (image (\ rs -> rhs_eps_cl_memo meps (list_intera rs))
                 (listset (lhs_nth_in_Q nrs)))
               (inserta bot_set (set_empty (of_phantom set_impl_set))))
           parts);

r_root :: forall a b. Ta_rule a b -> b;
r_root (TA_rule x1 x2 x3) = x1;

ps_states_nil_impl ::
  forall a b c.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Set_impl b, Ceq c, Ccompare c, Eq c,
      Set_impl c) => (a -> Set b) -> Set (Ta_rule a c) -> Set (Set b);
ps_states_nil_impl meps rules =
  let {
    rsz = filtera (\ r -> null (r_lhs_states r)) rules;
  } in image (\ f -> rhs_eps_cl_memo meps (filtera (\ r -> r_root r == f) rsz))
         (image r_root rsz);

ps_rules_cons_impl ::
  forall a b c d.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Ccompare c,
      Eq c) => (a -> Set a) ->
                 Set (b, (Nat, Set (Ta_rule a c))) ->
                   d -> Set (Set a) -> Set (Ta_rule (Set a) b);
ps_rules_cons_impl meps parts rules q =
  let {
    lhs_nth =
      (\ (n, rs) ->
        map (\ i ->
              filtera
                (\ x ->
                  not (set_eq (snd x)
                        (set_empty (of_phantom set_impl_ta_rule))))
                (image
                  (\ p ->
                    (p, filtera (\ r -> member (nth (r_lhs_states r) i) p) rs))
                  q))
          (upt zero_nat n));
  } in sup_seta
         (image
           (\ (f, nrs) ->
             filtera (\ r -> not (is_empty (r_rhs r)))
               (image
                 (\ rs ->
                   TA_rule f (map fst rs)
                     (rhs_eps_cl_memo meps (list_intera (map snd rs))))
                 (listset (lhs_nth nrs))))
           parts);

ps_rules_nil_impl ::
  forall a b c.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b,
      Set_impl b, Ceq c, Ccompare c, Eq c,
      Set_impl c) => (a -> Set b) ->
                       Set (Ta_rule a c) -> Set (Ta_rule (Set b) c);
ps_rules_nil_impl meps rules =
  let {
    rsz = filtera (\ r -> null (r_lhs_states r)) rules;
  } in image (\ f ->
               TA_rule f []
                 (rhs_eps_cl_memo meps (filtera (\ r -> r_root r == f) rsz)))
         (image r_root rsz);

memo_list_rtrancl_set ::
  forall a. (Ceq a, Ccompare a, Eq a, Set_impl a) => [(a, a)] -> a -> Set a;
memo_list_rtrancl_set r =
  let {
    tr = rtrancl_list_impl r;
    rm = map_of (map (\ a -> (a, set (tr [a]))) ((remdups . map fst) r));
  } in (\ a -> (case rm a of {
                 Nothing -> inserta a bot_set;
                 Just asa -> asa;
               }));

memo_rtrancl ::
  forall a. (Ceq a, Ccompare a, Eq a, Set_impl a) => Set (a, a) -> a -> Set a;
memo_rtrancl (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "memo_rtrancl RBT_set: ccompare = None"
        (\ _ -> memo_rtrancl (RBT_set rbt));
    Just _ -> memo_list_rtrancl_set (keysa rbt);
  });
memo_rtrancl (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "memo_rtrancl DList_set: ceq = None"
        (\ _ -> memo_rtrancl (DList_set dxs));
    Just _ -> memo_list_rtrancl_set (list_of_dlista dxs);
  });
memo_rtrancl (Set_Monad xs) = memo_list_rtrancl_set xs;

sym_parts ::
  forall a b.
    (Ccompare a, Eq a, Ceq b, Ccompare b, Eq b,
      Set_impl b) => Set (Ta_rule a b) -> Set (b, (Nat, Set (Ta_rule a b)));
sym_parts rules =
  image (\ (f, n) -> (f, (n, filtera (\ r -> r_sym r == (f, n)) rules)))
    (image r_sym rules);

ps_ta ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Set_impl b) => Ta_ext a b () -> Ta_ext (Set a) b ();
ps_ta ta =
  let {
    eps = ta_eps ta;
    rules = ta_rules ta;
  } in (if finite eps && finite rules
         then let {
                meps = memo_rtrancl eps;
                parts =
                  sym_parts
                    (filtera (\ r -> not (null (r_lhs_states r))) rules);
                qinit = ps_states_nil_impl meps rules;
                q = fst (while (\ (qold, qnew) -> not (less_eq_set qnew qold))
                          (\ (_, qnew) ->
                            (qnew,
                              sup_set qinit
                                (ps_states_cons_impl meps parts rules qnew)))
                          (set_empty (of_phantom set_impl_set), qinit));
                final =
                  filtera (\ qa -> not (is_empty (inf_set qa (ta_final ta)))) q;
                rulesa =
                  sup_set (ps_rules_nil_impl meps rules)
                    (ps_rules_cons_impl meps parts rules q);
              } in Ta_ext final rulesa
                     (set_empty
                       (of_phantom
                         (set_impl_prod :: Phantom (Set a, Set a) Set_impla)))
                     ()
         else ps_ta ta);

add_funas_args_term :: forall a b. Term a b -> [(a, Nat)] -> [(a, Nat)];
add_funas_args_term t fs = foldr add_funas_term (args t) fs;

add_funas_args_rule ::
  forall a b. (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
add_funas_args_rule r fs =
  add_funas_args_term (fst r) (add_funas_args_term (snd r) fs);

funas_args_trs_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
funas_args_trs_list trs = foldr add_funas_args_rule trs [];

rwc :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwc (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
      rules_map delete_R_Rw split_rules mk nfs more)
  = rw;

rc :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rc (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
     delete_R_Rw split_rules mk nfs more)
  = r;

uncurry_of_sig_list ::
  forall a.
    a -> [((a, Nat), [a])] ->
           (a -> Nat -> [a]) ->
             [(Term a [Prelude.Char], Term a [Prelude.Char])];
uncurry_of_sig_list a sml sm =
  concatMap
    (\ (b, c) ->
      let {
        (f, n) = b;
      } in (\ _ ->
             let {
               g = get_symbol sm f n;
             } in map (\ i ->
                        (Fun a [generate_f_xs (g i) (plus_nat n i),
                                 Var (generate_var (plus_nat n i))],
                          generate_f_xs (g (suc i)) (plus_nat n (suc i))))
                    (upt zero_nat (aarity sm f n)))
        c)
    sml;

sig_list_to_sig_map ::
  forall a.
    (Eq a) => a -> [((a, Nat), [a])] ->
                     ([((a, Nat), [a])] -> a -> Nat -> a) -> a -> Nat -> [a];
sig_list_to_sig_map a sml fmap =
  let {
    fm = fmap sml;
  } in (\ f n -> (case map_of sml (f, n) of {
                   Nothing -> [fm f n];
                   Just xs -> (if null xs then [fm f n] else xs);
                 }));

uncurry_eta_split ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             ([(Term a b, Term a b)], [(Term a b, Term a b)]);
uncurry_eta_split eboth rtest =
  let {
    test =
      (\ (l, r) ->
        less_nat zero_nat (size_list (args l)) &&
          less_nat zero_nat (size_list (args r)) &&
            any (eq_rule_mod_vars (hda (args l), hda (args r))) rtest);
  } in partition test eboth;

insert_vars_rule :: forall a b. (Eq b) => (Term a b, Term a b) -> [b] -> [b];
insert_vars_rule r xs = insert_vars_term (fst r) (insert_vars_term (snd r) xs);

eta_closed_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => a -> (a -> Nat -> [a]) ->
                         [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
eta_closed_rules a sm ra r =
  catch_errora
    (forallM
      (\ (l, raa) ->
        (case aarity_term a sm l of {
          Nothing -> Inr ();
          Just ab ->
            (if equal_nat ab zero_nat then Inr ()
              else check (any (\ (lll, rrr) ->
                                (case (lll, rrr) of {
                                  (Var _, _) -> False;
                                  (Fun _ [], _) -> False;
                                  (Fun _ [_], _) -> False;
                                  (Fun _ [_, Var _], Var _) -> False;
                                  (Fun _ [_, Var _], Fun _ []) -> False;
                                  (Fun _ [_, Var _], Fun _ [_]) -> False;
                                  (Fun f [ll, Var x], Fun g [rr, Var y]) ->
                                    f == a &&
                                      g == a &&
x == y &&
  not (membera (insert_vars_rule (ll, rr) []) x) &&
    instance_rule (l, raa) (ll, rr);
                                  (Fun _ [_, Var _], Fun _ (_ : Var _ : _ : _))
                                    -> False;
                                  (Fun _ [_, Var _], Fun _ (_ : Fun _ _ : _)) ->
                                    False;
                                  (Fun _ (_ : Var _ : _ : _), _) -> False;
                                  (Fun _ (_ : Fun _ _ : _), _) -> False;
                                }))
                           r)
                     ((shows_prec_list zero_nat
                         ['e', 't', 'a', ' ', 'e', 'x', 'p', 'a', 'n', 's', 'i',
                           'o', 'n', ' ', 'o', 'f', ' '] .
                        shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                          [' ', '-', '>', ' '] (l, raa)) .
                       shows_prec_list zero_nat
                         [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']));
        }))
      ra)
    (\ x -> Inl (snd x));

uncurry_rules ::
  forall a b.
    (Eq a) => a -> (a -> Nat -> [a]) ->
                     [(Term a b, Term a b)] -> [(Term a b, Term a b)];
uncurry_rules a sm =
  map (\ (l, r) -> (uncurry_term a sm l, uncurry_term a sm r));

check_CS_subseteq ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Sum (Term a b, Term a b) ();
check_CS_subseteq r s =
  catch_errora
    (forallM (\ (l, ra) -> check (any (instance_rule (l, ra)) s) (l, ra)) r)
    (\ x -> Inl (snd x));

uncurry_tt ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_tt i info r tp =
  let {
    (a, (sml, (u, eb))) = info;
    ra = rc i tp;
    rw = rwc i tp;
    (e, ew) = uncurry_eta_split eb ra;
    r_eta = e ++ ra;
    rw_eta = ew ++ rw;
    rb_eta = r_eta ++ rw_eta;
    fmap = (\ _ f _ -> f);
    sm = sig_list_to_sig_map a sml fmap;
    uR = uncurry_rules a sm r_eta;
    uRw = uncurry_rules a sm rw_eta;
  } in (case let {
               s = uncurry_of_sig_list a sml sm;
             } in bindb (catch_errora
                          (forallM
                            (\ (l, _) ->
                              check (hvf_term a l)
                                (shows_prec_list zero_nat
                                   ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i',
                                     'a', 'b', 'l', 'e', ' ', 'i', 'n', ' ',
                                     'l', 'h', 's', ' '] .
                                  shows_term (shows_prec zero_nat)
                                    (shows_prec_list zero_nat) l .
                                    shows_prec_list zero_nat
                                      [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l',
'o', 'w', 'e', 'd']))
                            r_eta)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (catch_errora
                              (forallM
                                (\ (l, _) ->
                                  check (hvf_term a l)
                                    (shows_prec_list zero_nat
                                       ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r',
 'i', 'a', 'b', 'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                                      shows_term (shows_prec zero_nat)
(shows_prec_list zero_nat) l .
shows_prec_list zero_nat
  [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                                rw_eta)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          bindb (eta_closed_rules a sm r_eta r_eta)
                            (\ _ ->
                              bindb (eta_closed_rules a sm rb_eta rb_eta)
                                (\ _ ->
                                  bindb (catch_errora
  (forallM
    (\ (l, rb) ->
      check (not (is_Var l))
        (shows_prec_list zero_nat
           ['l', 'h', 's', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
             'b', 'e', ' ', 'a', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
             ' ', 'i', 'n', ' ', 'r', 'u', 'l', 'e', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
            [' ', '-', '>', ' '] (l, rb)))
    rw_eta)
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora (check_subseteq uR r)
  (\ x ->
    Inl (shows_prec_list zero_nat
           ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l',
             'e', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
            [' ', '-', '>', ' '] x .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
(\ _ ->
  bindb (catch_errora (check_subseteq uRw r)
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u',
                     'l', 'e', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                    [' ', '-', '>', ' '] x .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
    (\ _ ->
      bindb (catch_errora (check_CS_subseteq s u)
              (\ x ->
                Inl (shows_prec_list zero_nat
                       ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l',
                         'e', ' '] .
                      shows_rule (shows_prec zero_nat)
                        (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                        shows_prec_list zero_nat
                          [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                            'g'])))
        (\ _ ->
          catch_errora (check_subseteq u r)
            (\ x ->
              Inl (shows_prec_list zero_nat
                     ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l',
                       'e', ' '] .
                    shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                      [' ', '-', '>', ' '] x .
                      shows_prec_list zero_nat
                        [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g',
                          ' ', 'i', 'n', ' ', 'n', 'e', 'w', ' ', 'T', 'R',
                          'S']))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkc i (nfsb i tp) [] uR (uRw ++ u));
       });

shows_eq ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        (Term a b, Term a b) -> [Prelude.Char] -> [Prelude.Char];
shows_eq fun var = shows_rule fun var [' ', '-', '>', '*', ' '];

shows_conditions ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [(Term a b, Term a b)] -> [Prelude.Char] -> [Prelude.Char];
shows_conditions fun var =
  shows_sep (shows_eq fun var) (shows_prec_list zero_nat [',', ' ']);

shows_crule ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        ((Term a b, Term a b), [(Term a b, Term a b)]) ->
          [Prelude.Char] -> [Prelude.Char];
shows_crule fun var cr =
  (shows_rule fun var [' ', '-', '>', ' '] (fst cr) .
    (if null (snd cr) then id else shows_prec_list zero_nat [' ', '|', ' '])) .
    shows_conditions fun var (snd cr);

check_prefix_equivalent ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prefix_equivalent rhoa rho n =
  catch_errora
    (bindb
      (check (less_nat n (size_list (snd rhoa)))
        (shows_string
           ['T', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 'f', 'e', 'w',
             'e', 'r', ' ', 't', 'h', 'a', 'n', ' '] .
          shows_prec_nat zero_nat n .
            shows_string
              [' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ', 'i',
                'n', ' '] .
              shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rhoa))
      (\ _ ->
        bindb (check (less_nat n (size_list (snd rho)))
                (shows_string
                   ['T', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 'f', 'e',
                     'w', 'e', 'r', ' ', 't', 'h', 'a', 'n', ' '] .
                  shows_prec_nat zero_nat n .
                    shows_string
                      [' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's',
                        ' ', 'i', 'n', ' '] .
                      shows_crule (shows_prec zero_nat) (shows_prec zero_nat)
                        rho))
          (\ _ ->
            bindb (check (equal_term (fst (fst rhoa)) (fst (fst rho)))
                    (shows_prec_list zero_nat
                      ['L', 'e', 'f', 't', '-', 'h', 'a', 'n', 'd', ' ', 's',
                        'i', 'd', 'e', 's', ' ', 'a', 'r', 'e', ' ', 'd', 'i',
                        'f', 'f', 'e', 'r', 'e', 'n', 't', '.']))
              (\ _ ->
                bindb (catch_errora
                        (forallM
                          (\ i ->
                            check (equal_term (snd (nth (snd rhoa) i))
                                    (snd (nth (snd rho) i)))
                              (shows_string
                                 ['R', 'h', 's', ' ', 'o', 'f', ' ', 'c', 'o',
                                   'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ',
                                   'a', 'r', 'e', ' ', 'd', 'i', 'f', 'f', 'e',
                                   'r', 'e', 'n', 't', ' '] .
                                shows_nl))
                          (upt zero_nat n))
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    catch_errora
                      (forallM
                        (\ i ->
                          check (equal_term (fst (nth (snd rhoa) i))
                                  (fst (nth (snd rho) i)))
                            (shows_string
                               ['L', 'h', 's', ' ', 'o', 'f', ' ', 'c', 'o',
                                 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ',
                                 'a', 'r', 'e', ' ', 'd', 'i', 'f', 'f', 'e',
                                 'r', 'e', 'n', 't', ' '] .
                              shows_nl))
                        (upt zero_nat (suc n)))
                      (\ x -> Inl (snd x)))))))
    (\ x ->
      Inl (shows_string ['R', 'u', 'l', 'e', 's'] .
            shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rhoa .
              shows_string [' ', 'a', 'n', 'd', ' '] .
                shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rho .
                  shows_string [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' '] .
                    shows_prec_nat zero_nat n .
                      shows_string
                        [' ', 'e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 't',
                          '.'] .
                        shows_nl . x));

check_f ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    Nat ->
                      a -> [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                             (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                               Nat -> Ctxt a b) ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_f cr j f crs u =
  catch_errora
    (forallM
      (\ cra ->
        catch_errora
          (forallM
            (\ i ->
              (case u cra i of {
                Hole -> Inr ();
                More g _ _ _ ->
                  (if f == g
                    then catch_errora
                           (bindb
                             (check (equal_nat i j)
                               (shows_string
                                  ['S', 'a', 'm', 'e', ' ', 's', 'y', 'm', 'b',
                                    'o', 'l', ' ', 'o', 'c', 'c', 'u', 'r', 's',
                                    ' ', 'a', 't', ' ', 'd', 'i', 'f', 'f', 'e',
                                    'r', 'e', 'n', 't', ' ', 'l', 'e', 'v', 'e',
                                    'l', 's'] .
                                 shows_nl))
                             (\ _ ->
                               bindb (catch_errora
                                       (forallM
 (\ k ->
   check (equal_ctxt (u cra k) (u cr k))
     (shows_string
        ['C', 'o', 'n', 't', 'e', 'x', 't', 's', ' ', 'a', 'r', 'e', ' ', 'd',
          'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', ' '] .
       shows_nl))
 (upt zero_nat (suc j)))
                                       (\ x -> Inl (snd x)))
                                 (\ _ -> check_prefix_equivalent cra cr j)))
                           (\ x ->
                             Inl (shows_string ['R', 'u', 'l', 'e', 's'] .
                                   shows_crule (shows_prec zero_nat)
                                     (shows_prec zero_nat) cra .
                                     shows_string [' ', 'a', 'n', 'd', ' '] .
                                       shows_crule (shows_prec zero_nat)
 (shows_prec zero_nat) cr .
 shows_string
   [' ', 's', 'h', 'a', 'r', 'e', ' ', 'a', ' ', 's', 'y', 'm', 'b', 'o', 'l',
     '.'] .
   shows_nl . x))
                    else Inr ());
              }))
            (upt zero_nat (size_list (snd cra))))
          (\ x -> Inl (snd x)))
      crs)
    (\ x -> Inl (snd x));

af_rules ::
  forall a b. Afs a -> [(Term a b, Term a b)] -> [(Term a b, Term a b)];
af_rules pi r = map (af_rule pi) r;

afs_syms :: forall a. Afs a -> Set (a, Nat);
afs_syms xa = snd (rep_afs xa);

mono_af_entry :: Nat -> Af_entry -> Bool;
mono_af_entry n (Collapse i) = less_eq_nat n one_nat;
mono_af_entry n (AFList ids) = all_interval_nat (membera ids) zero_nat n;

mono_afs :: forall a. (Ceq a, Ccompare a) => Afs a -> Bool;
mono_afs pi = ball (afs_syms pi) (\ (f, n) -> mono_af_entry n (afsa pi (f, n)));

compatible_ta ::
  forall a.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml ->
          Sum_bot [Prelude.Char]
            (Tree_automaton [Prelude.Char] a, Ta_relation [Prelude.Char]);
compatible_ta tag xml2name =
  guard (\ x -> equal_nat (num_children x) one_nat)
    (singleton tag (tree_automaton (ta_normal_lhs xml2name))
      (\ ta -> (ta, Id_Relation)))
    (pair tag (tree_automaton (ta_normal_lhs xml2name)) closed_criterion
      (\ a b -> (a, b)));

doc_of_stringa :: [Prelude.Char] -> Sum [Prelude.Char] Xmldoc;
doc_of_stringa =
  debug ['0']
    ['p', 'a', 'r', 's', 'i', 'n', 'g', ' ', 't', 'x', 't', ' ', 't', 'o', ' ',
      'x', 'm', 'l']
    doc_of_string;

default_grd_fun ::
  forall a.
    Term (Lab [Prelude.Char] a) [Prelude.Char] ->
      Term (Lab [Prelude.Char] a) [Prelude.Char] ->
        [Prelude.Char] -> Term (Lab [Prelude.Char] a) [Prelude.Char];
default_grd_fun s t =
  let {
    f = funs_rule_list (s, t);
    m = fold (\ fa m -> (case fa of {
                          Lab _ _ -> m;
                          FunLab _ _ -> m;
                          UnLab _ -> m;
                          Sharp (Lab _ _) -> m;
                          Sharp (FunLab _ _) -> m;
                          Sharp (UnLab g) -> max (size_list g) m;
                          Sharp (Sharp _) -> m;
                        }))
          f zero_nat;
    suffix = replicate (suc m) 'a';
  } in (\ x -> Fun (Sharp (UnLab (x ++ suffix))) []);

xml2non_join_info ::
  (Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat])) ->
    Xml ->
      Sum_bot [Prelude.Char]
        (Non_join_info (Lab [Prelude.Char] [Nat]) [Prelude.Char]
          [Prelude.Char]);
xml2non_join_info xml2name x =
  options
    [(['d', 'i', 's', 't', 'i', 'n', 'c', 't', 'N', 'o', 'r', 'm', 'a', 'l',
        'F', 'o', 'r', 'm', 's'],
       leaf ['d', 'i', 's', 't', 'i', 'n', 'c', 't', 'N', 'o', 'r', 'm', 'a',
              'l', 'F', 'o', 'r', 'm', 's']
         Diff_NFs),
      (['c', 'a', 'p', 'N', 'o', 't', 'U', 'n', 'i', 'f'],
        leaf ['c', 'a', 'p', 'N', 'o', 't', 'U', 'n', 'i', 'f']
          (Tcap_Non_Unif default_grd_fun)),
      (['s', 'u', 'b', 't', 'e', 'r', 'm'],
        pair ['s', 'u', 'b', 't', 'e', 'r', 'm'] pos
          (xml2non_join_info xml2name) Subterm_NJ),
      (['g', 'r', 'o', 'u', 'n', 'd', 'i', 'n', 'g'],
        pair ['g', 'r', 'o', 'u', 'n', 'd', 'i', 'n', 'g'] (substa xml2name)
          (xml2non_join_info xml2name) Grounding),
      (['e', 'm', 'p', 't', 'y', 'T', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm',
         'a', 't', 'a', 'I', 'n', 't', 'e', 'r', 's', 'e', 'c', 't', 'i', 'o',
         'n'],
        pair ['e', 'm', 'p', 't', 'y', 'T', 'r', 'e', 'e', 'A', 'u', 't', 'o',
               'm', 'a', 't', 'a', 'I', 'n', 't', 'e', 'r', 's', 'e', 'c', 't',
               'i', 'o', 'n']
          (compatible_ta
            ['f', 'i', 'r', 's', 't', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o',
              'n']
            xml2name)
          (compatible_ta
            ['s', 'e', 'c', 'o', 'n', 'd', 'A', 'u', 't', 'o', 'm', 'a', 't',
              'o', 'n']
            xml2name)
          (\ (ta1, rel1) (a, b) -> Tree_Aut_Intersect_Empty ta1 rel1 a b)),
      (['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', 'I', 'n', 't', 'e', 'r',
         'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n'],
        singleton
          ['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', 'I', 'n', 't', 'e', 'r',
            'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
          (sl_variant xml2name) Finite_Model_Gt),
      (['s', 't', 'r', 'i', 'c', 't', 'D', 'e', 'c', 'r', 'e', 'a', 's', 'e'],
        singleton
          ['s', 't', 'r', 'i', 'c', 't', 'D', 'e', 'c', 'r', 'e', 'a', 's', 'e']
          (ordering_constraint_proof False xml2name) Reduction_Pair_Gt),
      (['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r',
         'N', 'o', 'n', 'J', 'o', 'i', 'n'],
        pair ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e',
               'r', 'N', 'o', 'n', 'J', 'o', 'i', 'n']
          (afs xml2name) (xml2non_join_info xml2name) Argument_Filter_NJ),
      (['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'N', 'o', 'n',
         'J', 'o', 'i', 'n'],
        guard (\ xa -> equal_nat (num_children xa) one_nat)
          (singleton
            ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'N', 'o',
              'n', 'J', 'o', 'i', 'n']
            (xml2non_join_info xml2name) Usable_Rules_Reach_NJ)
          (triple
            ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'N', 'o',
              'n', 'J', 'o', 'i', 'n']
            (options
              [(['l', 'e', 'f', 't'], leaf ['l', 'e', 'f', 't'] True),
                (['r', 'i', 'g', 'h', 't'],
                  leaf ['r', 'i', 'g', 'h', 't'] False)])
            (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
              (rules xml2name) id)
            (xml2non_join_info xml2name)
            (\ left u ->
              Usable_Rules_Reach_Unif_NJ (if left then Inl u else Inr u))))]
    x;

xml2ncr_proof ::
  (Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat])) ->
    Xml ->
      Sum_bot [Prelude.Char]
        (Ncr_proof [Prelude.Char] [Nat] [Prelude.Char] [Prelude.Char]);
xml2ncr_proof xml2name x =
  let {
    rew = rsteps xml2name;
  } in singleton ['c', 'r', 'D', 'i', 's', 'p', 'r', 'o', 'o', 'f']
         (options
           [(['n', 'o', 'n', 'W', 'c', 'r', 'A', 'n', 'd', 'S', 'N'],
              pair ['n', 'o', 'n', 'W', 'c', 'r', 'A', 'n', 'd', 'S', 'N']
                (\ _ -> returna ()) (xml2trs_termination_proof xml2name)
                (\ _ -> SN_NWCR)),
             (['n', 'o', 'n', 'J', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'F', 'o',
                'r', 'k'],
               triple
                 ['n', 'o', 'n', 'J', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'F',
                   'o', 'r', 'k']
                 rew rew (xml2non_join_info xml2name)
                 (\ (s, seq1) (_, a) -> Non_Join s seq1 a)),
             (['m', 'o', 'd', 'u', 'l', 'a', 'r', 'i', 't', 'y', 'D', 'i', 's',
                'j', 'o', 'i', 'n', 't'],
               pair ['m', 'o', 'd', 'u', 'l', 'a', 'r', 'i', 't', 'y', 'D', 'i',
                      's', 'j', 'o', 'i', 'n', 't']
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2ncr_proof xml2name) NCR_Disj_Subtrs),
             (['r', 'e', 'd', 'u', 'n', 'd', 'a', 'n', 't', 'R', 'u', 'l', 'e',
                's'],
               triple
                 ['r', 'e', 'd', 'u', 'n', 'd', 'a', 'n', 't', 'R', 'u', 'l',
                   'e', 's']
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (nata ['n', 'r', 'S', 't', 'e', 'p', 's'])
                 (xml2ncr_proof xml2name) NCR_Redundant_Rules)])
         id x;

xml2state_map ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ([Prelude.Char] -> Term a [Prelude.Char]);
xml2state_map xml2name =
  many ['s', 't', 'a', 't', 'e', 'M', 'a', 'p']
    (pair ['e', 'n', 't', 'r', 'y'] state (term xml2name) (\ a b -> (a, b)))
    (\ xs x -> the (map_of xs x));

xml_signature :: forall a b. (Showa a, Showa b) => [(Lab a [b], Nat)] -> Xml;
xml_signature fs =
  XML ['s', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e'] []
    (map (\ (f, n) ->
           XML ['s', 'y', 'm', 'b', 'o', 'l'] []
             [xml_lab f,
               XML ['a', 'r', 'i', 't', 'y'] []
                 [XML_text (shows_prec_nat zero_nat n [])]])
      fs);

xml_trs_input ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => Sum (Strategy (Lab a [b]) c) (Fp_strategy (Lab a [b]) c) ->
                    [(Term (Lab a [b]) c, Term (Lab a [b]) c)] ->
                      Maybe [(Term (Lab a [b]) c, Term (Lab a [b]) c)] -> Xml;
xml_trs_input strat r Nothing =
  XML ['t', 'r', 's', 'I', 'n', 'p', 'u', 't'] []
    ([xml_rules ['t', 'r', 's'] r] ++ xml_strategy strat);
xml_trs_input strat r (Just s) =
  XML ['t', 'r', 's', 'I', 'n', 'p', 'u', 't'] []
    (xml_rules ['t', 'r', 's'] r :
      xml_strategy strat ++
        [xml_rules
           ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'R', 'u', 'l', 'e', 's']
           s]);

mgu_var_disjoint_generic ::
  forall a b c d.
    (Eq b,
      Eq d) => (a -> b) ->
                 (c -> b) ->
                   Term d a -> Term d c -> Maybe (a -> Term d b, c -> Term d b);
mgu_var_disjoint_generic vu wu s t =
  (case mgu (map_term (\ x -> x) vu s) (map_term (\ x -> x) wu t) of {
    Nothing -> Nothing;
    Just gamma -> Just (gamma . vu, gamma . wu);
  });

critical_pairs_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Bool, (Term a [Prelude.Char], Term a [Prelude.Char]))];
critical_pairs_impl p r =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ pa ->
          let {
            c = ctxt_of_pos_term pa l;
            la = subt_at l pa;
            b = equal_ctxt c Hole;
          } in (if is_Var la then []
                 else concatMap
                        (\ (laa, rb) ->
                          (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                                  (\ a -> 'y' : a) la laa
                            of {
                            Nothing -> [];
                            Just (sigma, tau) ->
                              [(b, (subst_apply_term ra sigma,
                                     ctxt_apply_term (subst_apply_ctxt c sigma)
                                       (subst_apply_term rb tau)))];
                          }))
                        r))
        (poss_list l))
    p;

check_linear_trs ::
  forall a b.
    (Showa a, Ceq b, Ccompare b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_linear_trs r =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (l, ra) = x;
              } in linear_term l && linear_term ra
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ _ ->
      Inl (((shows_prec_list zero_nat r . shows_nl) .
             shows_prec_list zero_nat
               ['i', 's', ' ', 'n', 'o', 't', ' ', 'l', 'i', 'n', 'e', 'a',
                 'r']) .
            shows_nl));

indent ::
  ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
indent p s = concatMap (\ c -> (if c == '\n' then ['\n', ' '] else [c])) (p s);

reachable_terms ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Nat -> [Term a b];
reachable_terms r s n =
  (if equal_nat n zero_nat then [s]
    else let {
           ts = reachable_terms r s (minus_nat n one_nat);
         } in remdups (ts ++ concatMap (rewrite r) ts));

check_strongly_closed ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strongly_closed r n =
  catch_errora
    (bindb (check_linear_trs r)
      (\ _ ->
        catch_errora
          (forallM
            (\ (_, (s, t)) ->
              check (not (is_none
                           (find (membera (reachable_terms r s n))
                             (reachable_terms r t (suc zero_nat)))) &&
                      not (is_none
                            (find (membera (reachable_terms r t n))
                              (reachable_terms r s (suc zero_nat)))))
                (shows_prec_list zero_nat
                   ['t', 'h', 'e', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l',
                     ' ', 'p', 'a', 'i', 'r', ' '] .
                  shows_term (shows_prec zero_nat) (shows_prec_list zero_nat)
                    s .
                    shows_prec_list zero_nat
                      [' ', '<', '-', ' ', '.', ' ', '-', '>', ' '] .
                      shows_term (shows_prec zero_nat)
                        (shows_prec_list zero_nat) t .
                        shows_prec_list zero_nat
                          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 't',
                            'r', 'o', 'n', 'g', 'l', 'y', ' ', 'c', 'l', 'o',
                            's', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n',
                            ' '] .
                          shows_prec_nat zero_nat n .
                            shows_prec_list zero_nat
                              [' ', 's', 't', 'e', 'p', 's', '.']))
            (critical_pairs_impl r r))
          (\ x -> Inl (snd x))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list zero_nat
                   ['h', 'e', 'n', 'c', 'e', ' ', 't', 'h', 'e', ' ', 'f', 'o',
                     'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'T', 'R', 'S', ' ',
                     'i', 's', ' ', 'n', 'o', 't', ' ', 's', 't', 'r', 'o', 'n',
                     'g', 'l', 'y', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' '] .
                   shows_nl .
                     shows_trs (shows_prec zero_nat) (shows_prec_list zero_nat)
                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                         't', 'e', 'm', ':']
                       [' ', '-', '>', ' '] r .
                       indent x));

showsp_option ::
  forall a.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      Nat -> Maybe a -> [Prelude.Char] -> [Prelude.Char];
showsp_option show_a p (Just x) =
  (((shows_pl p . shows_string ['S', 'o', 'm', 'e']) . shows_space) .
    show_a one_nat x) .
    shows_pr p;
showsp_option show_a p Nothing = shows_string ['N', 'o', 'n', 'e'];

shows_prec_option ::
  forall a. (Showa a) => Nat -> Maybe a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_option = showsp_option shows_prec;

root_rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
root_rewrite r s =
  concatMap (\ (l, ra) -> (case match s l of {
                            Nothing -> [];
                            Just sigma -> [subst_apply_term ra sigma];
                          }))
    r;

parallel_rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
parallel_rewrite r (Var x) = [Var x];
parallel_rewrite r (Fun f ss) =
  remdups
    (root_rewrite r (Fun f ss) ++
      map (Fun f) (product_lists (map (parallel_rewrite r) ss)));

is_root_step ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Term a b -> Bool;
is_root_step r s t =
  any (\ (l, ra) -> (case match s l of {
                      Nothing -> False;
                      Just sigma -> equal_term (subst_apply_term ra sigma) t;
                    }))
    r;

is_par_rstep ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Term a b -> Bool;
is_par_rstep r (Var x) (Var y) = x == y;
is_par_rstep r (Fun f ss) (Fun g ts) =
  equal_term (Fun f ss) (Fun g ts) ||
    (is_root_step r (Fun f ss) (Fun g ts) ||
      (if f == g && equal_nat (size_list ss) (size_list ts)
        then list_all2 (is_par_rstep r) ss ts else False));
is_par_rstep r (Fun v va) (Var vb) = is_root_step r (Fun v va) (Var vb);
is_par_rstep r (Var vb) (Fun v va) = is_root_step r (Var vb) (Fun v va);

is_parallel_closed_cp ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Maybe Nat -> (Bool, (Term a b, Term a b)) -> Bool;
is_parallel_closed_cp r uu (False, (s, t)) = is_par_rstep r t s;
is_parallel_closed_cp r (Just n) (True, (s, t)) =
  not (is_none (find (is_par_rstep r t) (reachable_terms r s n)));
is_parallel_closed_cp r Nothing (True, (s, t)) =
  not (is_none (find (is_par_rstep r t) (parallel_rewrite r s)));

check_left_linear_trs ::
  forall a b.
    (Showa a, Ceq b, Ccompare b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_left_linear_trs trs =
  catch_errora
    (catch_errora
      (forallM (\ x -> (if linear_term (fst x) then Inr () else Inl x)) trs)
      (\ x -> Inl (snd x)))
    (\ _ ->
      Inl (((shows_prec_list zero_nat trs . shows_nl) .
             shows_prec_list zero_nat
               ['i', 's', ' ', 'n', 'o', 't', ' ', 'l', 'e', 'f', 't', '-', 'l',
                 'i', 'n', 'e', 'a', 'r']) .
            shows_nl));

check_parallel_closed ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Maybe Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_parallel_closed r n =
  catch_errora
    (bindb (check_left_linear_trs r)
      (\ _ ->
        catch_errora
          (forallM
            (\ (b, (s, t)) ->
              check (is_parallel_closed_cp r n (b, (s, t)))
                (shows_prec_list zero_nat
                   ['t', 'h', 'e', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l',
                     ' ', 'p', 'a', 'i', 'r', ' '] .
                  shows_term (shows_prec zero_nat) (shows_prec_list zero_nat)
                    s .
                    shows_prec_list zero_nat
                      [' ', '<', '-', ' ', '.', ' ', '-', '>', ' '] .
                      shows_term (shows_prec zero_nat)
                        (shows_prec_list zero_nat) t .
                        shows_prec_list zero_nat
                          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', '(', 'a',
                            'l', 'm', 'o', 's', 't', ')', ' ', 'p', 'a', 'r',
                            'a', 'l', 'l', 'e', 'l', ' ', 'c', 'l', 'o', 's',
                            'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' '] .
                          shows_prec_option zero_nat n .
                            shows_prec_list zero_nat
                              [' ', 's', 't', 'e', 'p', 's', '.']))
            (critical_pairs_impl r r))
          (\ x -> Inl (snd x))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list zero_nat
                   ['h', 'e', 'n', 'c', 'e', ' ', 't', 'h', 'e', ' ', 'f', 'o',
                     'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'T', 'R', 'S', ' ',
                     'i', 's', ' ', 'n', 'o', 't', ' ', '(', 'a', 'l', 'm', 'o',
                     's', 't', ')', ' ', 'p', 'a', 'r', 'a', 'l', 'l', 'e', 'l',
                     ' ', 'c', 'l', 'o', 's', 'e', 'd', ' '] .
                   shows_nl .
                     shows_trs (shows_prec zero_nat) (shows_prec_list zero_nat)
                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                         't', 'e', 'm', ':']
                       [' ', '-', '>', ' '] r .
                       indent x));

applicable_rule_impl ::
  forall a b. (Term a b -> Bool) -> (Term a b, Term a b) -> Bool;
applicable_rule_impl isNF = (\ (l, _) -> all isNF (args l));

check_non_applicable_rules ::
  forall a b.
    (Term a b -> Bool) -> [(Term a b, Term a b)] -> Sum (Term a b, Term a b) ();
check_non_applicable_rules isNF r =
  catch_errora
    (forallM
      (\ x -> (if not (applicable_rule_impl isNF x) then Inr () else Inl x)) r)
    (\ x -> Inl (snd x));

rule_match_impl ::
  forall a b.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                (b -> Term a (Sum () [Prelude.Char])) ->
                  [Term a [Prelude.Char]] ->
                    a -> [b] -> Term a [Prelude.Char] -> Bool;
rule_match_impl nfq e_cap s f ts l =
  (case mgu_class (Fun f (map e_cap ts)) l of {
    Nothing -> False;
    Just mu ->
      all (\ u ->
            nfq (subst_apply_term (map_term (\ x -> x) (\ a -> 'y' : a) u) mu))
        (args l) &&
        all (\ u -> nfq (subst_apply_term u mu)) s;
  });

is_ur_closed_term_af_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   ((a, Nat) -> Set Nat) ->
                     [(Term a [Prelude.Char], c)] ->
                       [(Term a [Prelude.Char], c)] ->
                         [Term a [Prelude.Char]] -> Term a b -> Bool;
is_ur_closed_term_af_impl nfq e_cap pi r u s (Var x) = True;
is_ur_closed_term_af_impl nfq e_cap pi r u s (Fun f ts) =
  let {
    n = size_list ts;
    pi_f = pi (f, n);
  } in all (\ (i, t) ->
             (if member i pi_f
               then is_ur_closed_term_af_impl nfq e_cap pi r u s t else True))
         (zip (upt zero_nat n) ts) &&
         all (\ (l, ra) ->
               membera u (l, ra) || not (rule_match_impl nfq e_cap s f ts l))
           r;

is_ur_closed_af_impl_dpp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Term b [Prelude.Char] -> Bool;
is_ur_closed_af_impl_dpp_mv i d pi =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulese i d;
    urc = (\ s -> is_ur_closed_term_af_impl qnf (ic s) pi r);
  } in (\ u s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_term (\ x -> x) (\ a -> 'x' : a) t)));

wwf_rulesa :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
wwf_rulesa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = wwf_rules;

q_emptyc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
q_emptyc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = q_empty;

matchCapRMBelow ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                 Term a b -> Term a b -> Bool;
matchCapRMBelow rm l (Fun f ts) = matchb (GCFun f (map (tcapRM2 rm) ts)) l;

forallM_index_aux ::
  forall a b. (a -> Nat -> Sum b ()) -> Nat -> [a] -> Sum ((a, Nat), b) ();
forallM_index_aux p i [] = Inr ();
forallM_index_aux p i (x : xs) =
  bindb (catch_errora (p x i) (\ xa -> Inl ((x, i), xa)))
    (\ _ -> forallM_index_aux p (suc i) xs);

forallM_index ::
  forall a b. (a -> Nat -> Sum b ()) -> [a] -> Sum ((a, Nat), b) ();
forallM_index p xs = forallM_index_aux p zero_nat xs;

check_ur_closed_term_rm_af ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                    [(Term a b, Term a b)] ->
                      ((a, Nat) -> Set Nat) ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ur_closed_term_rm_af uu uv uw (Var x) = Inr ();
check_ur_closed_term_rm_af rm ur pi (Fun f ts) =
  let {
    n = size_list ts;
    pia = pi (f, n);
  } in bindb (catch_errora
               (forallM_index
                 (\ t i ->
                   (if member i pia then check_ur_closed_term_rm_af rm ur pi t
                     else Inr ()))
                 ts)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ lr ->
                 check (membera ur lr ||
                         not (matchCapRMBelow rm (fst lr) (Fun f ts)))
                   (shows_string
                      ['d', 'u', 'e', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ',
                        's', 'u', 'b', 't', 'e', 'r', 'm', ' '] .
                     shows_prec_term zero_nat (Fun f ts) .
                       shows_string
                         [' ', 'o', 'f', ' ', 's', 'o', 'm', 'e', ' ', 'u', 's',
                           'a', 'b', 'l', 'e', ' ', 'r', 'h', 's', ',', ' ',
                           'r', 'u', 'l', 'e', ' '] .
                         shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                           [' ', '-', '>', ' '] lr .
                           shows_string
                             [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e',
                               ' ', 'u', 's', 'a', 'b', 'l', 'e', '.']))
               (rm (f, n)))
             (\ x -> Inl (snd x)));

check_ur_P_closed_rm_af ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                    [(Term a b, Term a b)] ->
                      ((a, Nat) -> Set Nat) ->
                        [(Term a b, Term a b)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ur_P_closed_rm_af rm ur pi p =
  bindb (catch_errora
          (catch_errora
            (forallM (\ lr -> check_ur_closed_term_rm_af rm ur pi (snd lr)) ur)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (shows_string
                   ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
                     'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'c', 'l', 'o', 's',
                     'u', 'r', 'e', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'i',
                     'e', 's', ' ', 'o', 'f', ' ', 'r', 'h', 's', ' ', 'o', 'f',
                     ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                     's'] .
                  shows_nl . x)))
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM (\ st -> check_ur_closed_term_rm_af rm ur pi (snd st)) p)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_string
                 ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
                   'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'c', 'l', 'o', 's',
                   'u', 'r', 'e', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'i',
                   'e', 's', ' ', 'o', 'f', ' ', 'r', 'h', 's', ' ', 'o', 'f',
                   ' ', 'D', 'P', 's'] .
                shows_nl . x)));

smart_usable_rules_checker_impl ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           Maybe [(Term b [Prelude.Char],
                                    Term b [Prelude.Char])] ->
                             [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                               Sum ([Prelude.Char] -> [Prelude.Char])
                                 [(Term b [Prelude.Char],
                                    Term b [Prelude.Char])];
smart_usable_rules_checker_impl i d pi u_opt sts =
  let {
    nfs = nfsc i d;
    m = minimal i d;
    wwf = wwf_rulesa i d;
    qempty = q_emptyc i d;
  } in (case u_opt of {
         Nothing -> Inr (rulese i d);
         Just u ->
           (if nFQ_subset_NF_rulesc i d &&
                 (nfs || isOK (check_varcond_subset sts)) && (nfs || (m || wwf))
             then let {
                    urc = is_ur_closed_af_impl_dpp_mv i d pi u;
                    check_urc =
                      (\ s t ->
                        check (urc s t)
                          (shows_prec_list zero_nat ['t', 'e', 'r', 'm', ' '] .
                            shows_prec_term zero_nat t .
                              shows_prec_list zero_nat
                                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c',
                                  'l', 'o', 's', 'e', 'd', ' ', 'u', 'n', 'd',
                                  'e', 'r', ' ', 'u', 's', 'a', 'b', 'l', 'e',
                                  ' ', 'r', 'u', 'l', 'e', 's']));
                  } in bindb (catch_errora
                               (forallM (\ (s, a) -> check_urc [s] a) sts)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM (\ (l, a) -> check_urc (args l) a)
                                     u)
                                   (\ x -> Inl (snd x)))
                             (\ _ -> Inr u))
             else bindb (check (m && (if nfs then qempty || wwf else True))
                          (shows_prec_list zero_nat
                            ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                              ' ', 'a', 'n', 'd', ' ', 'w', 'e', 'l', 'l', ' ',
                              'f', 'o', 'r', 'm', 'e', 'd', 'n', 'e', 's', 's',
                              ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                    (\ _ ->
                      bindb (catch_errora
                              (forallM
                                (\ (l, _) ->
                                  check (not (is_Var l))
                                    (shows_prec_list zero_nat
                                      ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
's', ' ', 'a', 's', ' ', 'l', 'h', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l',
'l', 'o', 'w', 'e', 'd']))
                                (rulese i d))
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          let {
                            rm = rules_mapc i d;
                          } in bindb (check_ur_P_closed_rm_af rm u pi sts)
                                 (\ _ -> Inr u))));
       });

root_aft_to_entry ::
  forall a b c. a -> Term b c -> ((b, Nat) -> Set Nat) -> [(a, Term b c)];
root_aft_to_entry s t pi =
  let {
    rt = the (root t);
    pi_t = pi rt;
    ts = args t;
  } in map_filter
         (\ x -> (if member x pi_t then Just (s, nth ts x) else Nothing))
         (upt zero_nat (snd rt));

check_no_defined_root ::
  forall a b.
    (Showa a,
      Showa b) => ((a, Nat) -> Bool) ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_defined_root isdef t =
  check (not (isdef (the (root t))))
    (shows_string ['t', 'h', 'e', ' ', 'r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
      shows_prec_term zero_nat t .
        shows_string [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd']);

pairsb :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pairsb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = pairs;

valida ::
  forall a b c.
    Root_redtriple_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
valida (Root_redtriple_ext valid s ns nst af aft desc more) = valid;

descb ::
  forall a b c. Root_redtriple_ext a b c -> [Prelude.Char] -> [Prelude.Char];
descb (Root_redtriple_ext valid s ns nst af aft desc more) = desc;

nsta ::
  forall a b c.
    Root_redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsta (Root_redtriple_ext valid s ns nst af aft desc more) = nst;

aft :: forall a b c. Root_redtriple_ext a b c -> (a, Nat) -> Set Nat;
aft (Root_redtriple_ext valid s ns nst af aft desc more) = aft;

nsa ::
  forall a b c.
    Root_redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsa (Root_redtriple_ext valid s ns nst af aft desc more) = ns;

afa :: forall a b c. Root_redtriple_ext a b c -> (a, Nat) -> Set Nat;
afa (Root_redtriple_ext valid s ns nst af aft desc more) = af;

sa :: forall a b c.
        Root_redtriple_ext a b c ->
          (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sa (Root_redtriple_ext valid s ns nst af aft desc more) = s;

generic_ur_af_root_redtriple_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Root_redtriple_ext b [Prelude.Char] () ->
                      Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_ur_af_root_redtriple_proc i rp u_opt premove dpp =
  (case catch_errora
          (bindb (valida rp)
            (\ _ ->
              let {
                (ps, pns) = split_pairsa i dpp premove;
                p = pairsb i dpp;
                pi = afa rp;
                pia = aft rp;
                is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
              } in bindb (catch_errora
                           (forallM
                             (\ (l, r) ->
                               bindb (check_no_var l)
                                 (\ _ ->
                                   bindb (check_no_var r)
                                     (\ _ -> check_no_defined_root is_def r)))
                             p)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulese i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (smart_usable_rules_checker_impl i dpp pi u_opt
                                   (concatMap
                                     (\ (s, t) -> root_aft_to_entry s t pia) p))
                             (\ u ->
                               bindb (catch_errora
                                       (catch_errora (forallM (nsa rp) u)
 (\ x -> Inl (snd x)))
                                       (\ x ->
 Inl (shows_string
        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
          'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', '(', 'u', 's', 'a', 'b',
          'l', 'e', ')', ' ', 'r', 'u', 'l', 'e', 's'] .
       shows_nl . x)))
                                 (\ _ ->
                                   bindb (catch_errora
   (catch_errora (forallM (nsta rp) pns) (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
              'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
           shows_nl . x)))
                                     (\ _ ->
                                       catch_errora
 (catch_errora (forallM (sa rp) ps) (\ x -> Inl (snd x)))
 (\ x ->
   Inl (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
            'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
         shows_nl . x)))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e',
                     'r', 'i', 'c', ' ', 'r', 'o', 'o', 't', ' ', 'r', 'e', 'd',
                     'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ',
                     'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i',
                     't', 'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o',
                     'w', 'i', 'n', 'g'] .
                  shows_nl . descb rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp premove premove);
  });

nst ::
  forall a b c.
    Redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nst (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  nst;

generic_ur_af_redtriple_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_ur_af_redtriple_proc i rp u_opt premove dpp =
  (case catch_errora
          (bindb (valid rp)
            (\ _ ->
              let {
                (ps, pns) = split_pairsa i dpp premove;
                p = pairsb i dpp;
              } in bindb (smart_usable_rules_checker_impl i dpp (af rp) u_opt p)
                     (\ u ->
                       bindb (catch_errora
                               (catch_errora (forallM (ns rp) u)
                                 (\ x -> Inl (snd x)))
                               (\ x ->
                                 Inl (shows_string
['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r', 'i',
  'e', 'n', 't', 'i', 'n', 'g', ' ', '(', 'u', 's', 'a', 'b', 'l', 'e', ')',
  ' ', 'r', 'u', 'l', 'e', 's'] .
                                       shows_nl . x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (catch_errora (forallM (nst rp) pns)
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (shows_string
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
      'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
   shows_nl . x)))
                             (\ _ ->
                               catch_errora
                                 (catch_errora (forallM (s rp) ps)
                                   (\ x -> Inl (snd x)))
                                 (\ x ->
                                   Inl (shows_string
  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
    'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
 shows_nl . x)))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e',
                     'r', 'i', 'c', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o',
                     'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e',
                     's', 's', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h',
                     'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp premove premove);
  });

is_ur_closed_term_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   [(Term a [Prelude.Char], c)] ->
                     [(Term a [Prelude.Char], c)] ->
                       [Term a [Prelude.Char]] -> Term a b -> Bool;
is_ur_closed_term_impl nfq e_cap r u s (Var x) = True;
is_ur_closed_term_impl nfq e_cap r u s (Fun f ts) =
  all (is_ur_closed_term_impl nfq e_cap r u s) ts &&
    all (\ (l, ra) ->
          membera u (l, ra) || not (rule_match_impl nfq e_cap s f ts l))
      r;

is_ur_closed_impl_dpp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                           [Term b [Prelude.Char]] ->
                             Term b [Prelude.Char] -> Bool;
is_ur_closed_impl_dpp_mv i d =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulese i d;
    urc = (\ s -> is_ur_closed_term_impl qnf (ic s) r);
  } in (\ u s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_term (\ x -> x) (\ a -> 'x' : a) t)));

intersect_rulesb ::
  forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_rulesb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = intersect_rules;

usable_rules_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_proc i u dpp =
  (case bindb (check (nFQ_subset_NF_rulesc i dpp)
                (shows_prec_list zero_nat
                  ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e',
                    'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'r', 'e', 'q', 'u',
                    'i', 'r', 'e', 'd']))
          (\ _ ->
            bindb (check (nfsc i dpp || (minimal i dpp || wwf_rulesa i dpp))
                    (shows_prec_list zero_nat
                      ['n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm',
                        ' ', 's', 'u', 'b', 's', 't', ',', ' ', 'm', 'i', 'n',
                        'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'o', 'r', ' ',
                        'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd',
                        'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                        'e', 'd']))
              (\ _ ->
                let {
                  p = pairsb i dpp;
                  urc = is_ur_closed_impl_dpp_mv i dpp u;
                  check_urc =
                    (\ s t ->
                      check (urc s t)
                        (shows_prec_list zero_nat ['t', 'e', 'r', 'm', ' '] .
                          shows_prec_term zero_nat t .
                            shows_prec_list zero_nat
                              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l',
                                'o', 's', 'e', 'd', ' ', 'u', 'n', 'd', 'e',
                                'r', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                                'r', 'u', 'l', 'e', 's']));
                  nfs = nfsc i dpp;
                } in bindb (catch_errora
                             (forallM
                               (\ (l, r) ->
                                 bindb (if nfs then Inr ()
 else catch_errora (check_subseteq (vars_term_list r) (vars_term_list l))
        (\ _ ->
          Inl (shows_prec_list zero_nat
                ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'n',
                  'd', 'i', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'P', ' ',
                  'v', 'i', 'o', 'l', 'a', 't', 'e', 'd'])))
                                   (\ _ -> check_urc [l] r))
                               p)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         catch_errora
                           (forallM (\ (l, a) -> check_urc (args l) a) u)
                           (\ x -> Inl (snd x)))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (intersect_rulesb i dpp u);
  });

mono ::
  forall a b c.
    Redtriple_ext a b c ->
      [(Term a b, Term a b)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
mono (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  mono;

mono_inn_usable_rules_ce_proc ::
  forall a b.
    (Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_inn_usable_rules_ce_proc i rp premove rremove ur dpp =
  (case catch_errora
          (bindb (usable_rules_proc i ur dpp)
            (\ _ ->
              let {
                p = pairsb i dpp;
                us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
                filt =
                  (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
                (pms, pns) = split_pairsa i dpp premove;
                (ps, pnwf) = partition filt pms;
                (urms, urns) = partition (membera rremove) ur;
                (urs, urnwf) = partition filt urms;
              } in bindb (valid rp)
                     (\ _ ->
                       bindb (mono rp
                               (ps ++ urs ++ urns ++ urnwf ++ pns ++ pnwf))
                         (\ _ ->
                           bindb (catch_errora
                                   (catch_errora
                                     (forallM (ns rp) (urns ++ urnwf))
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (shows_string
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
      'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
      'r', 'u', 'l', 'e', 's'] .
   shows_nl . x)))
                             (\ _ ->
                               bindb (catch_errora
                                       (catch_errora (forallM (s rp) urs)
 (\ x -> Inl (snd x)))
                                       (\ x ->
 Inl (shows_string
        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
          'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l',
          'e', ' ', 'r', 'u', 'l', 'e', 's'] .
       shows_nl . x)))
                                 (\ _ ->
                                   bindb (catch_errora
   (catch_errora (forallM (ns rp) (pns ++ pnwf)) (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
              'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
           shows_nl . x)))
                                     (\ _ ->
                                       catch_errora
 (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
 (\ x ->
   Inl (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
            'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
         shows_nl . x)))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'i', 'n', 'n', 'e',
                     'r', 'm', 'o', 's', 't', ' ', 'u', 's', 'a', 'b', 'l', 'e',
                     ' ', 'r', 'u', 'l', 'e', 's', ' ', 'r', 'e', 'd', 'u', 'c',
                     't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r',
                     'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't', 'h',
                     ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i',
                     'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

mono_ur_redpair_proc ::
  forall a b c.
    (Ceq b, Ccompare b, Eq b, Set_impl b, Showa b, Eq c,
      Showa c) => Dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          [(Term b c, Term b c)] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_ur_redpair_proc i rp premove rremove ur dpp =
  (case catch_errora
          (bindb
            (check (minimal i dpp)
              (shows_prec_list zero_nat
                ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'r',
                  'e', 'q', 'u', 'i', 'r', 'e', 'd']))
            (\ _ ->
              bindb (check
                      (if nfsc i dpp
                        then (if not (q_emptyc i dpp) then wwf_rulesa i dpp
                               else True)
                        else True)
                      (shows_prec_list zero_nat
                        ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e', 'd',
                          'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                          'e', 'd']))
                (\ _ ->
                  let {
                    p = pairsb i dpp;
                    us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
                    filt =
                      (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
                    (pms, pns) = split_pairsa i dpp premove;
                    (ps, pnwf) = partition filt pms;
                    (urms, urns) = partition (membera rremove) ur;
                    (urs, urnwf) = partition filt urms;
                    rm = rules_mapc i dpp;
                  } in bindb (valid rp)
                         (\ _ ->
                           bindb (mono rp
                                   (ps ++ urs ++ urns ++ urnwf ++ pns ++ pnwf))
                             (\ _ ->
                               bindb (check_ur_P_closed_rm_af rm ur full_af p)
                                 (\ _ ->
                                   bindb (catch_errora
   (forallM
     (\ (l, _) ->
       check (not (is_Var l))
         (shows_prec_list zero_nat
           ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ',
             'l', 'h', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
             'w', 'e', 'd']))
     (rulese i dpp))
   (\ x -> Inl (snd x)))
                                     (\ _ ->
                                       bindb
 (catch_errora
   (catch_errora (forallM (ns rp) (urns ++ urnwf)) (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
              'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a',
              'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
           shows_nl . x)))
 (\ _ ->
   bindb (catch_errora (catch_errora (forallM (s rp) urs) (\ x -> Inl (snd x)))
           (\ x ->
             Inl (shows_string
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                      ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ',
                      'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                      's'] .
                   shows_nl . x)))
     (\ _ ->
       bindb (catch_errora
               (catch_errora (forallM (ns rp) (pns ++ pnwf))
                 (\ x -> Inl (snd x)))
               (\ x ->
                 Inl (shows_string
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                          'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                          ' ', 'D', 'P', 's'] .
                       shows_nl . x)))
         (\ _ ->
           catch_errora (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
             (\ x ->
               Inl (shows_string
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                        'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                        ' ', 'D', 'P', 's'] .
                     shows_nl . x))))))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'n', 'o',
                     't', 'o', 'n', 'i', 'c', ' ', 'r', 'e', 'd', 'u', 'c', 't',
                     'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o',
                     'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ',
                     't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n',
                     'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

generic_mono_ur_redpair_proc ::
  forall a b.
    (Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_mono_ur_redpair_proc i rp premove rremove ur dpp =
  (if nFQ_subset_NF_rulesc i dpp
    then mono_inn_usable_rules_ce_proc i rp premove rremove ur dpp
    else bindb (check (minimal i dpp)
                 (shows_prec_list zero_nat
                   ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'o',
                     'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ',
                     'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ', 'f', 'o', 'r',
                     ' ', 'm', 'o', 'n', '.', ' ', 'r', 'e', 'd', '.', ' ', 'p',
                     'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', '.', ' ', 'w', 'i',
                     't', 'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u',
                     'l', 'e', 's']))
           (\ _ -> mono_ur_redpair_proc i rp premove rremove ur dpp));

compat_roota :: forall a b. (Eq a) => Term a b -> Maybe (a, Nat) -> Bool;
compat_roota uu Nothing = False;
compat_roota (Var uv) (Just v) = False;
compat_roota (Fun va vb) (Just v) = root (Fun va vb) == Just v;

usable_rules_gen2 ::
  forall a b.
    (Eq a) => [(Term a b, Term a b)] ->
                (Maybe (a, Nat), Bool) -> [(Term a b, Term a b)];
usable_rules_gen2 r (fn, b) =
  let {
    rr = concatMap (\ (l, ra) -> (if compat_roota l fn then [(l, ra)] else []))
           r;
  } in (if b then rr else map (\ (l, ra) -> (ra, l)) rr);

rel_dep_prod :: Bool -> Dependance -> [Bool];
rel_dep_prod uu Ignore = [];
rel_dep_prod b Increase = [b];
rel_dep_prod b Decrease = [not b];
rel_dep_prod uv Wild = [True, False];

compat_root :: forall a b c. (Eq a) => Term a b -> Term a c -> Bool;
compat_root uu (Var uv) = False;
compat_root (Var uw) (Fun v va) = False;
compat_root (Fun vb vc) (Fun v va) = root (Fun vb vc) == root (Fun v va);

usable_rules_gen1 ::
  forall a b.
    (Eq a) => ((a, Nat) -> Nat -> Dependance) ->
                [(Term a b, Term a b)] ->
                  (Term a b, Bool) -> [(Term a b, Bool)];
usable_rules_gen1 pi r (Var uu, uv) = [];
usable_rules_gen1 pi r (Fun f ts, b) =
  let {
    n = size_list ts;
  } in concatMap
         (\ (l, ra) -> (if compat_root l (Fun f ts) then [(ra, b)] else []))
         r ++
         concatMap
           (\ i -> map (\ a -> (nth ts i, a)) (rel_dep_prod b (pi (f, n) i)))
           (upt zero_nat n);

usable_rules_gen ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> Nat -> Dependance) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] -> [(Term a b, Term a b)];
usable_rules_gen pi r p =
  concatMap (usable_rules_gen2 r)
    (remdups
      (map (\ (t, a) -> (root t, a))
        (mk_rtrancl_list (\ a b -> a == b) (usable_rules_gen1 pi r)
          (map (\ (_, t) -> (t, True)) p))));

generate_lists :: forall a. Nat -> [a] -> [[a]];
generate_lists n xs = concat_lists (map (\ _ -> xs) (upt zero_nat n));

initial_conditions_gen_impl ::
  forall a. (a -> a -> Bool) -> Nat -> Nat -> [a] -> a -> [[a]];
initial_conditions_gen_impl pa bef_len aft_len p st =
  let {
    pairs = (\ n -> generate_lists n p);
    a = concatMap (\ bef -> map (\ aft -> bef ++ st : aft) (pairs aft_len))
          (pairs bef_len);
  } in filter
         (\ bef_st_aft ->
           all_interval_nat
             (\ i -> pa (nth bef_st_aft i) (nth bef_st_aft (suc i))) zero_nat
             (plus_nat bef_len aft_len))
         a;

disjoint_variant ::
  forall a b.
    (Compare a, Eq a, Card_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Mapping_impl b,
      Set_impl b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Bool;
disjoint_variant sts uvs =
  equal_nat (size_list sts) (size_list uvs) &&
    all_interval_nat (\ i -> eq_rule_mod_vars (nth sts i) (nth uvs i)) zero_nat
      (size_list sts) &&
      is_partition (map vars_rule uvs);

condition_of ::
  forall a b.
    a -> Condition_type -> (Term a b, Term a b) -> Cond_constraint a b;
condition_of c Bound (s, uu) = CC_cond False (s, Fun c []);
condition_of c Strict st = CC_cond True st;
condition_of c Non_Strict st = CC_cond False st;

constraint_of ::
  forall a b.
    a -> Condition_type -> [(Term a b, Term a b)] -> Nat -> Cond_constraint a b;
constraint_of c ctype uvs bef =
  CC_impl
    (map (\ i -> CC_rewr (snd (nth uvs i)) (fst (nth uvs (suc i))))
      (upt zero_nat (minus_nat (size_list uvs) one_nat)))
    (condition_of c ctype (nth uvs bef));

the_set_impl_main_lazy ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Eq b) => (a -> [b]) -> (b -> [a]) -> [a] -> Set a -> [b] -> [a];
the_set_impl_main_lazy q gen_as have_asa have_as bs =
  let {
    new_as =
      concatMap
        (\ b ->
          concatMap (\ a -> (if not (member a have_as) then [a] else []))
            (gen_as b))
        bs;
  } in (if null new_as then have_asa
         else the_set_impl_main_lazy q gen_as (new_as ++ have_asa)
                (sup_set (set new_as) have_as) (remdups (concatMap q new_as)));

the_set_impl_lazy ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Eq b) => (a -> [b]) -> (b -> [a]) -> [b] -> [a];
the_set_impl_lazy q gen_as bs = the_set_impl_main_lazy q gen_as [] bot_set bs;

inductive_set_impl_lazy ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Set_impl b) => (a -> [b]) -> (b -> [a]) -> [a] -> [b];
inductive_set_impl_lazy q p = the_set_impl_lazy p q;

ur_term_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   [(Term a [Prelude.Char], c)] ->
                     ((a, Nat) -> Set Nat) ->
                       [Term a [Prelude.Char]] ->
                         Term a b -> [(Term a [Prelude.Char], c)];
ur_term_impl nfq e_cap r pi s (Var x) = [];
ur_term_impl nfq e_cap r pi s (Fun f ts) =
  let {
    n = size_list ts;
    rec = map (ur_term_impl nfq e_cap r pi s) ts;
  } in remdups
         (concatMap (\ (i, urs) -> (if member i (pi (f, n)) then urs else []))
            (zip (upt zero_nat n) rec) ++
           filter (\ (l, _) -> rule_match_impl nfq e_cap s f ts l) r);

precompute_fun :: forall a b. (Key a) => (a -> b) -> [a] -> a -> b;
precompute_fun f asa =
  fun_of_map_fun (ceta_map_of (map (\ a -> (a, f a)) asa)) f;

usable_rules_calc_impl ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  ([Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      [([Term a [Prelude.Char]], Term a [Prelude.Char])] ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])];
usable_rules_calc_impl nfq e_cap r =
  let {
    urt = (\ (s, t) ->
            let {
              sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
            } in ur_term_impl nfq (e_cap sa) r full_af sa
                   (map_term (\ x -> x) (\ a -> 'x' : a) t));
    urules = map (\ (l, a) -> (args l, a)) r;
    ufun = precompute_fun urt urules;
  } in inductive_set_impl_lazy ufun (\ (l, ra) -> [(args l, ra)]);

ur_calc_singleton ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  ([Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      ([Term a [Prelude.Char]], Term a [Prelude.Char]) ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])];
ur_calc_singleton nfq e_cap r st = usable_rules_calc_impl nfq e_cap r [st];

inn_usable_rules_pair ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                         [(Term b [Prelude.Char], Term b [Prelude.Char])];
inn_usable_rules_pair i d =
  let {
    inn = nFQ_subset_NF_rulesc i d;
    r = rulese i d;
    qnf = is_QNFc i d;
    ic = icap_impl_dpp i d;
    calc = ur_calc_singleton qnf ic r;
    nfs = nfsc i d;
    wwf = wwf_rulesa i d;
    m = minimal i d;
  } in (\ (s, t) ->
         (if inn &&
               (nfs || subset (vars_term t) (vars_term s)) &&
                 (nfs || (m || wwf))
           then calc ([s], t) else r));

icap_impl_dpp_mv ::
  forall a b.
    (Eq b) => Dpp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_dpp_mv i d =
  let {
    qr = nFQ_subset_NF_rulesc i d;
    qnf = is_QNFc i d;
    r = rulese i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s -> let {
                 sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
                 sx = ceta_set_of (concatMap vars_term_list sa);
               } in (\ t -> ic sa sx (map_term (\ x -> x) (\ a -> 'x' : a) t)));

is_iedg_edge_dpp ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                           Term b [Prelude.Char] -> Bool;
is_iedg_edge_dpp i d =
  let {
    qnf = is_QNFc i d;
    ic = icap_impl_dpp_mv i d;
    _ = rulese i d;
    urules = inn_usable_rules_pair i d;
  } in (\ (s, t) ->
         let {
           cst = ic [s] t;
           urls = reverse_rules (urules (s, t));
           ica = icap_impl (is_NF_terms []) urls;
         } in (\ u ->
                (case mgu_class cst u of {
                  Nothing -> False;
                  Just mu ->
                    qnf (subst_apply_term
                          (map_term (\ x -> x) (\ a -> 'x' : a) s) mu) &&
                      qnf (subst_apply_term
                            (map_term (\ x -> x) (\ a -> 'y' : a) u) mu);
                }) &&
                  let {
                    cu = ica [] u;
                  } in (case mgu_class cu t of {
                         Nothing -> False;
                         Just mu ->
                           qnf (subst_apply_term
                                 (map_term (\ x -> x) (\ a -> 'y' : a) s) mu);
                       })));

deep_normalize_cca :: forall a b. Cond_constraint a b -> Cond_constraint a b;
deep_normalize_cca (CC_impl [] c) = deep_normalize_cca c;
deep_normalize_cca (CC_impl (v : va) c) =
  CC_impl (map deep_normalize_cca (v : va)) (deep_normalize_cca c);
deep_normalize_cca (CC_cond s c) = CC_cond s c;
deep_normalize_cca (CC_all s c) = CC_all s (deep_normalize_cca c);
deep_normalize_cca (CC_rewr s c) = CC_rewr s c;

vars_cc_list :: forall a b. (Eq b) => Cond_constraint a b -> [b];
vars_cc_list (CC_cond ct (s, t)) = vars_term_list s ++ vars_term_list t;
vars_cc_list (CC_rewr s t) = vars_term_list s ++ vars_term_list t;
vars_cc_list (CC_impl c1 c2) = concatMap vars_cc_list c1 ++ vars_cc_list c2;
vars_cc_list (CC_all x c) =
  concatMap (\ y -> (if not (y == x) then [y] else [])) (vars_cc_list c);

cc_subst_apply ::
  forall a b.
    (Eq a) => ([a] -> a) ->
                Cond_constraint b a ->
                  (a -> Term b a, [a]) -> Cond_constraint b a;
cc_subst_apply fresh (CC_all x c) (sigma, vs) =
  let {
    y = fresh (vs ++ vars_cc_list (CC_all x c));
  } in CC_all y (cc_subst_apply fresh c (fun_upd sigma x (Var y), y : vs));
cc_subst_apply fresh (CC_impl c1 c2) sigma =
  CC_impl (map (\ c -> cc_subst_apply fresh c sigma) c1)
    (cc_subst_apply fresh c2 sigma);
cc_subst_apply fresh (CC_rewr s t) (sigma, uv) =
  CC_rewr (subst_apply_term s sigma) (subst_apply_term t sigma);
cc_subst_apply fresh (CC_cond ct (s, t)) (sigma, uu) =
  CC_cond ct (subst_apply_term s sigma, subst_apply_term t sigma);

normalize_alpha ::
  forall a b.
    (Eq a) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a;
normalize_alpha fresh c = cc_subst_apply fresh c (Var, []);

deep_normalize_cc ::
  forall a b.
    (Eq a) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a;
deep_normalize_cc fresh c = normalize_alpha fresh (deep_normalize_cca c);

check_subsumesa ::
  forall a b.
    (Eq a, Eq b) => Cond_constraint a b -> Cond_constraint a b -> Bool;
check_subsumesa (CC_impl cs c) (CC_impl ds d) =
  check_subsumesa c d &&
    all (\ ca -> any (\ da -> check_subsumesa da ca) ds) cs;
check_subsumesa (CC_cond v va) (CC_impl ds d) =
  check_subsumesa (CC_cond v va) d;
check_subsumesa (CC_rewr v va) (CC_impl ds d) =
  check_subsumesa (CC_rewr v va) d;
check_subsumesa (CC_all v va) (CC_impl ds d) = check_subsumesa (CC_all v va) d;
check_subsumesa (CC_all x c) (CC_all y d) = x == y && check_subsumesa c d;
check_subsumesa (CC_cond v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_cond vb vc);
check_subsumesa (CC_cond v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_rewr vb vc);
check_subsumesa (CC_cond v va) (CC_all vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_all vb vc);
check_subsumesa (CC_rewr v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_cond vb vc);
check_subsumesa (CC_rewr v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_rewr vb vc);
check_subsumesa (CC_rewr v va) (CC_all vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_all vb vc);
check_subsumesa (CC_all v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_all v va) (CC_cond vb vc);
check_subsumesa (CC_all v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_all v va) (CC_rewr vb vc);
check_subsumesa c (CC_cond v va) = equal_cond_constraint c (CC_cond v va);
check_subsumesa c (CC_rewr v va) = equal_cond_constraint c (CC_rewr v va);
check_subsumesa (CC_impl vb vc) (CC_all v va) =
  equal_cond_constraint (CC_impl vb vc) (CC_all v va);

check_subsumes ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a -> Bool;
check_subsumes fresh c d = let {
                             n = deep_normalize_cc fresh;
                           } in check_subsumesa (n c) (n d);

check_constraint_present ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> b -> [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                                Nat ->
                                  Nat ->
                                    [(Cond_constraint b [Prelude.Char],
                                       [(Term b [Prelude.Char],
  Term b [Prelude.Char])])] ->
                                      Condition_type ->
(Term b [Prelude.Char], Term b [Prelude.Char]) ->
  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_constraint_present i dpp constant p bef aft ccs =
  let {
    edg = is_iedg_edge_dpp i dpp;
    init_conds =
      initial_conditions_gen_impl (\ st uv -> edg st (fst uv)) bef aft p;
  } in (\ ct st ->
         catch_errora
           (forallM
             (\ sts ->
               check (any (\ (c, uvs) ->
                            disjoint_variant sts uvs &&
                              check_subsumes (fresh_string ['x', 'x']) c
                                (constraint_of constant ct uvs bef))
                       ccs)
                 (shows_prec_list zero_nat
                    ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
                      ' '] .
                   shows_prec_list zero_nat
                     (case ct of {
                       Bound -> ['b', 'o', 'u', 'n', 'd'];
                       Strict -> ['s', 't', 'r', 'i', 'c', 't'];
                       Non_Strict ->
                         ['n', 'o', 'n', '-', 's', 't', 'r', 'i', 'c', 't'];
                     }) .
                     shows_prec_list zero_nat
                       [' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't',
                         ' ', 'f', 'o', 'r', ' ', 's', 'e', 'q', 'u', 'e', 'n',
                         'c', 'e', ' '] .
                       shows_rules (shows_prec zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] sts))
             (init_conds st))
           (\ x -> Inl (snd x)));

check_weakly_orthogonal ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_weakly_orthogonal r =
  catch_errora
    (bindb (check_left_linear_trs r)
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ (l, _) ->
                    check (not (is_Var l))
                      (shows_prec_list zero_nat
                        ['t', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'h', 'a', 's',
                          ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ',
                          'a', 's', ' ', 'l', 'e', 'f', 't', '-', 'h', 'a', 'n',
                          'd', ' ', 's', 'i', 'd', 'e', 's']))
                  r)
                (\ x -> Inl (snd x)))
          (\ _ ->
            catch_errora
              (forallM
                (\ (_, (s, t)) ->
                  check (equal_term s t)
                    (shows_prec_list zero_nat
                       ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', ' ',
                         'n', 'o', 'n', '-', 't', 'r', 'i', 'v', 'i', 'a', 'l',
                         ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p',
                         'a', 'i', 'r', ':', ' '] .
                      shows_term (shows_prec zero_nat)
                        (shows_prec_list zero_nat) s .
                        shows_prec_list zero_nat
                          [' ', '<', '-', ' ', '.', ' ', '-', '>', ' '] .
                          shows_term (shows_prec zero_nat)
                            (shows_prec_list zero_nat) t))
                (critical_pairs_impl r r))
              (\ x -> Inl (snd x)))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list zero_nat
                   ['h', 'e', 'n', 'c', 'e', ',', ' ', 't', 'h', 'e', ' ', 'f',
                     'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'T', 'R', 'S',
                     ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'w', 'e', 'a', 'k',
                     'l', 'y', ' ', 'o', 'r', 't', 'h', 'o', 'g', 'o', 'n', 'a',
                     'l', ' '] .
                   shows_nl .
                     shows_trs (shows_prec zero_nat) (shows_prec_list zero_nat)
                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                         't', 'e', 'm', ':']
                       [' ', '-', '>', ' '] r .
                       indent x));

validb ::
  forall a b c.
    Non_inf_order_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
validb (Non_inf_order_ext valid ns cc af desc more) = valid;

descc ::
  forall a b c. Non_inf_order_ext a b c -> [Prelude.Char] -> [Prelude.Char];
descc (Non_inf_order_ext valid ns cc af desc more) = desc;

nsb ::
  forall a b c.
    Non_inf_order_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsb (Non_inf_order_ext valid ns cc af desc more) = ns;

cc :: forall a b c.
        Non_inf_order_ext a b c ->
          C_constraint a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
cc (Non_inf_order_ext valid ns cc af desc more) = cc;

afb :: forall a b c. Non_inf_order_ext a b c -> (a, Nat) -> Nat -> Dependance;
afb (Non_inf_order_ext valid ns cc af desc more) = af;

range_vars_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
range_vars_impl sigma = let {
                          a = mk_subst_domain sigma;
                        } in concatMap (vars_term_list . snd) a;

cc_bound :: forall a b. [a] -> Cond_constraint b a -> Cond_constraint b a;
cc_bound [] c = c;
cc_bound (x : xs) c = CC_all x (cc_bound xs c);

cc_ih_prems ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) ->
                 b -> Term b a ->
                        [a] ->
                          [Cond_constraint b a] ->
                            Cond_constraint b a ->
                              [(Term b a, [a])] -> [Cond_constraint b a];
cc_ih_prems fresh f q xs phi psi rs_ys_list =
  map (\ (r, ys) ->
        let {
          rs = args r;
          mu = mk_subst Var (zip xs rs);
          vs = range_vars_impl (zip xs rs);
          mua = (\ c -> cc_subst_apply fresh c (mu, vs));
          a = CC_impl (CC_rewr r (subst_apply_term q mu) : map mua phi)
                (mua psi);
        } in cc_bound ys a)
    rs_ys_list;

cc_rule_constraint ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) ->
                 b -> [Term b a] ->
                        Term b a ->
                          Term b a ->
                            [a] ->
                              [Cond_constraint b a] ->
                                Cond_constraint b a ->
                                  [(Term b a, [a])] -> Cond_constraint b a;
cc_rule_constraint fresh f ls r q xs phi psi rs_ys_list =
  let {
    sigma = mk_subst Var (zip xs ls);
    vs = range_vars_impl (zip xs ls);
    rew = CC_rewr r (subst_apply_term q sigma);
    phi_sig = map (\ c -> cc_subst_apply fresh c (sigma, vs)) phi;
    psi_sig = cc_subst_apply fresh psi (sigma, vs);
    ihs = cc_ih_prems fresh f q xs phi psi rs_ys_list;
  } in CC_impl (rew : phi_sig ++ ihs) psi_sig;

cc_unbound :: forall a b. Cond_constraint a b -> ([b], Cond_constraint a b);
cc_unbound (CC_all x c) = let {
                            (xs, a) = cc_unbound c;
                          } in (x : xs, a);
cc_unbound (CC_cond v va) = ([], CC_cond v va);
cc_unbound (CC_rewr v va) = ([], CC_rewr v va);
cc_unbound (CC_impl v va) = ([], CC_impl v va);

funas_args_term_list :: forall a b. Term a b -> [(a, Nat)];
funas_args_term_list t = concatMap funas_term_list (args t);

check_rys ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> Bool) ->
                    Maybe (a, Nat) ->
                      Term a b ->
                        (Term a b, [b]) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rys d rt r rys =
  let {
    (ra, ys) = rys;
  } in bindb (check (root ra == rt)
               (shows_string ['r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
                 shows_prec_term zero_nat ra .
                   shows_string [' ', 'i', 's', ' ', 'n', 'o', 't', ' '] .
                     shows_prec_prod zero_nat (the rt)))
         (\ _ ->
           bindb (check (equal_term r ra || supt_impl r ra)
                   (shows_prec_term zero_nat ra .
                     shows_string
                       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's',
                         'u', 'b', 't', 'e', 'r', 'm', ' ', 'o', 'f', ' '] .
                       shows_prec_term zero_nat r))
             (\ _ ->
               bindb (catch_errora
                       (forallM
                         (\ f ->
                           check (not (d f))
                             (shows_string
                                ['t', 'h', 'e', ' ', 'd', 'e', 'f', 'i', 'n',
                                  'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l',
                                  ' '] .
                               shows_prec_prod zero_nat f .
                                 shows_string
                                   [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 'i',
                                     'n', ' ', 't', 'h', 'e', ' ', 's', 'u',
                                     'b', 't', 'e', 'r', 'm', ' '] .
                                   shows_prec_term zero_nat ra .
                                     shows_prec_list zero_nat
                                       [' ', 'o', 'f', ' ', 't', 'h', 'e', ' ',
 'r', 'h', 's']))
                         (funas_args_term_list ra))
                       (\ x -> Inl (snd x)))
                 (\ _ ->
                   catch_errora (check_disjoint ys (vars_term_list r))
                     (\ x ->
                       Inl (shows_prec zero_nat x .
                             shows_string
                               [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 'i',
                                 'n', ' '] .
                               shows_prec_term zero_nat r)))));

shows_cc_aux ::
  forall a b.
    (Showa a,
      Showa b) => Bool ->
                    Cond_constraint a b -> [Prelude.Char] -> [Prelude.Char];
shows_cc_aux b (CC_rewr s t) =
  shows_prec_term zero_nat s .
    shows_prec_list zero_nat [' ', '=', ' '] . shows_prec_term zero_nat t;
shows_cc_aux b (CC_cond stri (s, t)) =
  shows_prec_term zero_nat s .
    shows_prec_list zero_nat
      (if stri then [' ', '>', ' '] else [' ', '>', '=', ' ']) .
      shows_prec_term zero_nat t;
shows_cc_aux b (CC_all x c) =
  let {
    s = shows_prec_list zero_nat ['A', 'L', 'L', ' '] .
          shows_prec zero_nat x .
            shows_prec_list zero_nat ['.', ' '] . shows_cc_aux False c;
  } in (if b then shows_prec_list zero_nat ['('] .
                    s . shows_prec_list zero_nat [')']
         else s);
shows_cc_aux b (CC_impl cs c2) =
  shows_string ['('] .
    shows_list_gen (shows_cc_aux True) ['T', 'r', 'u', 'e'] []
      [' ', 'a', 'n', 'd', ' '] [] cs .
      shows_prec_list zero_nat [' ', '=', '>', ' '] .
        shows_cc_aux True c2 . shows_prec_list zero_nat [')'];

shows_cc ::
  forall a b.
    (Showa a,
      Showa b) => Cond_constraint a b -> [Prelude.Char] -> [Prelude.Char];
shows_cc = shows_cc_aux False;

prems_of :: forall a b. Cond_constraint a b -> [Cond_constraint a b];
prems_of (CC_impl c1 c2) = c1;
prems_of (CC_cond v va) = [];
prems_of (CC_rewr v va) = [];
prems_of (CC_all v va) = [];

concl_of :: forall a b. Cond_constraint a b -> Cond_constraint a b;
concl_of (CC_impl c1 c2) = c2;
concl_of (CC_cond v va) = CC_cond v va;
concl_of (CC_rewr v va) = CC_rewr v va;
concl_of (CC_all v va) = CC_all v va;

normalize_cc :: forall a b. Cond_constraint a b -> Cond_constraint a b;
normalize_cc c = CC_impl (prems_of c) (concl_of c);

check_cc_prf ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ((a, Nat) -> Bool) ->
                      [(a, Nat)] ->
                        Bool ->
                          Cond_constraint a [Prelude.Char] ->
                            Cond_constraint_prf a [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char])
                                [C_constraint a [Prelude.Char]];
check_cc_prf r d f m_ortho cc Final =
  (case normalize_cc cc of {
    CC_cond _ _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_rewr _ _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_cond stri st) -> Inr [Unconditional_C stri st];
    CC_impl [] (CC_rewr _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_impl _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_all _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond stri uv] (CC_cond stria st) ->
      (if stri == stria then Inr [Conditional_C stri uv st]
        else Inl (shows_prec_list zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f',
                      'i', 'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r',
                      'a', 'i', 'n', 't', ':', ' ', 'd', 'i', 'f', 'f', 'e',
                      'r', 'e', 'n', 't', ' ', 'r', 'e', 'l', 'a', 't', 'i',
                      'o', 'n', 's', ' ', 'f', 'o', 'r', ' ', 'f', 'i', 'n',
                      'a', 'l', 'i', 'z', 'i', 'n', 'g', ' '] .
                   shows_cc cc));
    CC_impl [CC_cond _ _] (CC_rewr _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond _ _] (CC_impl _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond _ _] (CC_all _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_cond _ _ : _ : _) _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_rewr _ _ : _) _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_impl _ _ : _) _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_all _ _ : _) _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_all _ _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
  });
check_cc_prf r da f m_ortho c (Delete_Condition d prf) =
  bindb (check (check_subsumes (fresh_string ['x', 'x']) d c)
          (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'd', 'e',
               'l', 'e', 't', 'e', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'w', 'i', 't', 'c',
               'h', 'i', 'n', 'g', ' ', 'f', 'r', 'o', 'm', ' '] .
            shows_nl .
              shows_cc c .
                shows_string [' ', 't', 'o', ' '] . shows_nl . shows_cc d))
    (\ _ -> check_cc_prf r da f m_ortho d prf);
check_cc_prf r da f m_ortho c (Different_Constructor d) =
  let {
    (CC_impl cs _) = normalize_cc c;
  } in catch_errora
         (bindb
           (check (membera cs d)
             (shows_cc d .
               shows_nl .
                 shows_string
                   ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r', 'e',
                     'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                   shows_cc c))
           (\ _ ->
             (case d of {
               CC_cond _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_rewr (Var _) _ ->
                 Inl (shows_cc d .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_rewr (Fun _ _) (Var _) ->
                 Inl (shows_cc d .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_rewr (Fun fa ss) (Fun g ts) ->
                 bindb (check (not (da (fa, size_list ss)))
                         (shows_prec zero_nat fa .
                           shows_prec_list zero_nat
                             [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e',
                               'd']))
                   (\ _ ->
                     bindb (check
                             (not ((fa, size_list ss) == (g, size_list ts)))
                             (shows_string
                                ['t', 'h', 'e', ' ', 'r', 'o', 'o', 't', ' '] .
                               shows_prec zero_nat fa .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'i', 'd', 'e', 'n', 't',
                                     'i', 'c', 'a', 'l', ' ', 'o', 'n', ' ',
                                     'b', 'o', 't', 'h', ' ', 's', 'i', 'd',
                                     'e', 's']))
                       (\ _ -> Inr []));
               CC_impl _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_all _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
             })))
         (\ x ->
           Inl (shows_string
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'D',
                    'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', ' ', 'C', 'o', 'n',
                    's', 't', 'r', 'u', 'c', 't', 'o', 'r', ' ', 'w', 'i', 't',
                    'h', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o',
                    'n', 'd', 'i', 't', 'i', 'o', 'n', ' '] .
                 shows_cc d .
                   shows_nl .
                     shows_string
                       ['o', 'n', ' ', 'i', 'n', 'p', 'u', 't', ' ', 'c', 'o',
                         'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' '] .
                       shows_nl . shows_cc c . shows_nl . x));
check_cc_prf r da f m_ortho ca (Same_Constructor d c p) =
  let {
    (CC_impl cs con) = normalize_cc ca;
  } in bindb (catch_errora
               (bindb
                 (check (membera cs d)
                   (shows_cc d .
                     shows_nl .
                       shows_string
                         ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r',
                           'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_cc ca))
                 (\ _ ->
                   (case d of {
                     CC_cond _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_rewr (Var _) _ ->
                       Inl (shows_cc d .
                             shows_prec_list zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_rewr (Fun _ _) (Var _) ->
                       Inl (shows_cc d .
                             shows_prec_list zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_rewr (Fun fa ss) (Fun g ts) ->
                       bindb (check (not (da (fa, size_list ss)))
                               (shows_prec zero_nat fa .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n',
                                     'e', 'd']))
                         (\ _ ->
                           bindb (check
                                   ((fa, size_list ss) == (g, size_list ts))
                                   (shows_prec zero_nat fa .
                                     shows_string [' ', 'a', 'n', 'd', ' '] .
                                       shows_prec zero_nat g .
 shows_prec_list zero_nat
   [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i',
     'c', 'a', 'l']))
                             (\ _ ->
                               let {
                                 ds = cs ++
map (\ (a, b) -> CC_rewr a b) (zip ss ts);
                                 db = CC_impl ds con;
                               } in check (check_subsumes
    (fresh_string ['x', 'x']) c db)
                                      (shows_string
 ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ',
   'i', 's', ' '] .
shows_cc c .
  shows_nl .
    shows_string
      ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'w',
        'a', 's', ' '] .
      shows_cc db)));
                     CC_impl _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_all _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                   })))
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'S', 'a', 'm', 'e', ' ', 'C', 'o', 'n', 's', 't', 'r',
                          'u', 'c', 't', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ',
                          'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                          'd', 'i', 't', 'i', 'o', 'n', ' '] .
                       shows_cc d .
                         shows_nl .
                           shows_string
                             [' ', 'w', 'h', 'e', 'n', ' ', 's', 'w', 'i', 't',
                               'c', 'h', 'i', 'n', 'g', ' ', 'f', 'r', 'o', 'm',
                               ' '] .
                             shows_nl .
                               shows_cc ca .
                                 shows_string [' ', 't', 'o', ' '] .
                                   shows_nl . shows_cc c . shows_nl . x)))
         (\ _ -> check_cc_prf r da f m_ortho c p);
check_cc_prf r da f m_ortho c (Variable_Equation x t d p) =
  let {
    (CC_impl cs _) = normalize_cc c;
  } in bindb (catch_errora
               (bindb
                 (check
                   (membera cs (CC_rewr (Var x) t) ||
                     membera cs (CC_rewr t (Var x)) &&
                       ball (funas_term t) (\ fa -> not (da fa)))
                   (shows_string
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                        'i', 'n', 'd', ' '] .
                     shows_cc (CC_rewr (Var x) t) .
                       shows_string
                         [' ', 'o', 'r', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'e',
                           'd', ' ', 'a', 's', ' ', 'a', ' ', 'p', 'r', 'e',
                           'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_nl . shows_cc c))
                 (\ _ ->
                   let {
                     ca = cc_subst_apply (fresh_string ['x', 'x']) c
                            (fun_upd Var x t, vars_term_list t);
                   } in check (check_subsumes (fresh_string ['x', 'x']) d ca)
                          (shows_string
                             ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r',
                               'a', 'i', 'n', 't', ' ', 'i', 's', ' '] .
                            shows_cc d .
                              shows_nl .
                                shows_string
                                  ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c',
                                    't', 'e', 'd', ' ', 'w', 'a', 's', ' '] .
                                  shows_cc ca)))
               (\ xa ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'V', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'E', 'q',
                          'u', 'a', 't', 'i', 'o', 'n', ' ', 'w', 'i', 't', 'h',
                          ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i',
                          'o', 'n', ' '] .
                       shows_prec_list zero_nat x .
                         shows_prec_list zero_nat ['/'] .
                           shows_prec_term zero_nat t .
                             shows_string
                               [' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c',
                                 'h', ' ', 'f', 'r', 'o', 'm'] .
                               shows_nl .
                                 shows_cc c .
                                   shows_nl .
                                     shows_string ['t', 'o'] .
                                       shows_nl . shows_cc d . shows_nl . xa)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho ca (Funarg_Into_Var c i x d p) =
  let {
    (CC_impl cs con) = normalize_cc ca;
  } in bindb (catch_errora
               (bindb
                 (check (membera cs c)
                   (shows_cc c .
                     shows_nl .
                       shows_string
                         ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r',
                           'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_cc ca))
                 (\ _ ->
                   bindb (check (not (membera (vars_cc_list ca) x))
                           (shows_string
                              ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                             shows_prec_list zero_nat x .
                               shows_prec_list zero_nat
                                 [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f',
                                   'r', 'e', 's', 'h']))
                     (\ _ ->
                       (case c of {
                         CC_cond _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Var _) _ ->
                           Inl (shows_cc c .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Fun fa ss) q ->
                           bindb (check (less_nat i (size_list ss))
                                   (shows_prec_list zero_nat
                                     ['i', 'n', 'v', 'a', 'l', 'i', 'd', ' ',
                                       'p', 'o', 's', 'i', 't', 'i', 'o', 'n']))
                             (\ _ ->
                               let {
                                 (bef, (pa, aft)) =
                                   (take i ss, (nth ss i, drop (suc i) ss));
                               } in bindb (catch_errora
    (check_subseteq (funas_term_list pa) f)
    (\ xa ->
      Inl (shows_string
             ['f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 's', 'y', 'm', 'b',
               'o', 'l', ' '] .
            shows_prec_prod zero_nat xa .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
                  'w', 'e', 'd', ' ', 'i', 'n', ' ', 'a', 'r', 'g', 'u', 'm',
                  'e', 'n', 't'])))
                                      (\ _ ->
let {
  px = CC_rewr pa (Var x);
  fq = CC_rewr (Fun fa (bef ++ Var x : aft)) q;
  ds = px : fq : cs;
  daa = CC_impl ds con;
} in check (check_subsumes (fresh_string ['x', 'x']) d daa)
       (shows_string
          ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't',
            ' ', 'i', 's', ' '] .
         shows_cc d .
           shows_nl .
             shows_string
               ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ',
                 'w', 'a', 's', ' '] .
               shows_cc daa)));
                         CC_impl _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_all _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                       }))))
               (\ xa ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'i', 'n', 't', 'r', 'o', 'd', 'u', 'c', 'i', 'n', 'g',
                          ' ', 'f', 'r', 'e', 's', 'h', ' ', 'v', 'a', 'r', 'i',
                          'a', 'b', 'l', 'e', ' '] .
                       shows_prec_list zero_nat x .
                         shows_string [' ', 'o', 'n', ' '] .
                           shows_prec_nat zero_nat (suc i) .
                             shows_string
                               ['-', 't', 'h', ' ', 'a', 'r', 'g', 'u', 'm',
                                 'e', 'n', 't', ' ', 'o', 'f', ' ', 'l', 'h',
                                 's', ' ', 'o', 'f', ' '] .
                               shows_cc c .
                                 shows_string
                                   [' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c',
                                     'h', ' ', 'f', 'r', 'o', 'm', ' '] .
                                   shows_cc ca .
                                     shows_string ['t', 'o'] .
                                       shows_nl . shows_cc d . shows_nl . xa)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho c (Simplify_Condition bc sigma d p) =
  let {
    (CC_impl cs psi) = normalize_cc c;
  } in bindb (catch_errora
               (bindb
                 (check (membera cs bc)
                   (shows_cc bc .
                     shows_nl .
                       shows_string
                         ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r',
                           'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_cc c))
                 (\ _ ->
                   let {
                     (ys, cc) = cc_unbound bc;
                     (phi, psia) = let {
                                     (CC_impl a b) = normalize_cc cc;
                                   } in (a, b);
                     dom_ran = mk_subst_domain sigma;
                   } in bindb (catch_errora
                                (check_subseteq (map fst dom_ran) ys)
                                (\ x ->
                                  Inl (shows_prec_list zero_nat x .
shows_prec_list zero_nat
  [' ', 'i', 's', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'd', 'o', 'm', 'a',
    'i', 'n', ' ', 'o', 'f', ' ', 's', 'i', 'g', 'm', 'a', ',', ' ', 'b', 'u',
    't', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'b', 'o', 'u', 'n', 'd', ' ', 'v',
    'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '])))
                          (\ _ ->
                            bindb (catch_errora
                                    (forallM
                                      (\ fn ->
bindb (check (not (da fn))
        (shows_string ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
          shows_prec_prod zero_nat fn .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                'e', 'd', ' ', 'i', 'n', ' ', 'r', 'a', 'n', 'g', 'e', ' ', 'o',
                'f', ' ', 's', 'i', 'g', 'm', 'a', ',', ' ', 'a', 's', ' ', 'i',
                't', ' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd']))
  (\ _ ->
    check (membera f fn)
      (shows_string ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
        shows_prec_prod zero_nat fn .
          shows_prec_list zero_nat
            [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
              'e', 'd', ' ', 'i', 'n', ' ', 'r', 'a', 'n', 'g', 'e', ' ', 'o',
              'f', ' ', 's', 'i', 'g', 'm', 'a', ',', ' ', 'a', 's', ' ', 'i',
              't', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ',
              'F'])))
                                      (concatMap
(\ x_t -> funas_term_list (snd x_t)) dom_ran))
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                let {
                                  vs = remdups
 (concatMap (\ x_t -> vars_term_list (snd x_t)) dom_ran);
                                  sigmaa =
                                    (\ ca ->
                                      cc_subst_apply (fresh_string ['x', 'x'])
ca (mk_subst Var sigma, vs));
                                } in bindb (catch_errora
     (forallM
       (\ ca ->
         check (any (\ caa ->
                      check_subsumes (fresh_string ['x', 'x']) caa (sigmaa ca))
                 cs)
           (shows_cc (sigmaa ca) .
             shows_nl .
               shows_prec_list zero_nat
                 ['i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'n', 't', 'a',
                   'i', 'n', 'e', 'd', ' ', 'a', 's', ' ', 'p', 'r', 'e', 'm',
                   'i', 's', 'e', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'i',
                   'n', 'p', 'u', 't', ' ', 'i', 'm', 'p', 'l', 'i', 'c', 'a',
                   't', 'i', 'o', 'n']))
       phi)
     (\ x -> Inl (snd x)))
                                       (\ _ ->
 let {
   daa = CC_impl (sigmaa psia : cs) psi;
 } in check (check_subsumes (fresh_string ['x', 'x']) d daa)
        (shows_string
           ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
             't', ' ', 'i', 's', ' '] .
          shows_cc d .
            shows_nl .
              shows_string
                ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
                  ' ', 'w', 'a', 's', ' '] .
                shows_cc daa))))))
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'S', 'i', 'm', 'p', 'l', 'i', 'f', 'y', ' ', 'C', 'o',
                          'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'w', 'i', 't',
                          'h', ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't',
                          'i', 'o', 'n', ' '] .
                       shows_prec_list zero_nat sigma .
                         shows_string [' ', 'o', 'n', ' ', 'I', 'H'] .
                           shows_nl .
                             shows_cc bc .
                               shows_nl .
                                 shows_string
                                   ['t', 'o', ' ', 's', 'w', 'i', 't', 'c', 'h',
                                     ' ', 'f', 'r', 'o', 'm'] .
                                   shows_nl .
                                     shows_cc c .
                                       shows_nl .
 shows_string ['t', 'o'] . shows_nl . shows_cc d . shows_nl . x)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho c (Induction d ccs ihs) =
  let {
    (CC_impl cs ca) = normalize_cc c;
  } in bindb (catch_errora
               (bindb
                 (check m_ortho
                   (shows_prec_list zero_nat
                     ['C', 'R', ' ', 'o', 'r', ' ', 'm', 'i', 'n', 'i', 'm',
                       'a', 'l', 'i', 't', 'y', ' ', 'r', 'e', 'q', 'u', 'i',
                       'r', 'e', 'd']))
                 (\ _ ->
                   bindb (catch_errora
                           (forallM
                             (\ cc ->
                               check (membera cs cc)
                                 (shows_cc cc .
                                   shows_nl .
                                     shows_string
                                       ['i', 's', ' ', 'n', 'o', 't', ' ', 'a',
 ' ', 'p', 'r', 'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                                       shows_cc c))
                             (d : ccs))
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       (case d of {
                         CC_cond _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Var _) _ ->
                           Inl (shows_cc d .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Fun fa xs) q ->
                           let {
                             csa = vars_cc_list
                                     (CC_impl (CC_rewr (Fun fa xs) q : ccs) ca);
                           } in bindb (check
(all is_Var xs && distinct (map the_Var xs))
(shows_prec_list zero_nat
   ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ' ', 'o', 'f', ' '] .
  shows_prec_term zero_nat (Fun fa xs) .
    shows_prec_list zero_nat
      [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'i', 'f', 'f', 'e',
        'r', 'e', 'n', 't', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
                                  (\ _ ->
                                    let {
                                      xsa = map the_Var xs;
                                      rt = root (Fun fa xs);
                                    } in bindb
   (check (is_none (mgu (Fun fa xs) q))
     (shows_prec_list zero_nat
       ['l', 'h', 's', ' ', 'a', 'n', 'd', ' ', 'r', 'h', 's', ' ', 'u', 'n',
         'i', 'f', 'y']))
   (\ _ ->
     bindb (catch_errora
             (forallM
               (\ lr ->
                 check (if root (fst lr) == rt
                         then any (\ lra ->
                                    eq_rule_mod_vars lr lra &&
                                      isOK
(check_disjoint csa (vars_rule_list lra)))
                                (map (\ (ra, _) -> ra) ihs)
                         else True)
                   (shows_prec_list zero_nat
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                        'i', 'n', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
                        'e', ' ', 'r', 'e', 'n', 'a', 'm', 'e', 'd', ' ', 'v',
                        'e', 'r', 's', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 'r',
                        'u', 'l', 'e', ' '] .
                     shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                       [' ', '-', '>', ' '] lr))
               r)
             (\ x -> Inl (snd x)))
       (\ _ ->
         catch_errora
           (forallM
             (\ (a, b) ->
               let {
                 (l, ra) = a;
               } in (\ (rys, (cc, _)) ->
                      catch_errora
                        (let {
                           cca = cc_rule_constraint (fresh_string ['x', 'x']) fa
                                   (args l) ra q xsa ccs ca rys;
                         } in bindb (catch_errora
                                      (forallM (check_rys da rt ra) rys)
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  check (check_subsumes
  (fresh_string ['x', 'x']) cc cca)
                                    (shows_string
                                       ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's',
 't', 'r', 'a', 'i', 'n', 't', ' ', 'i', 's', ' '] .
                                      shows_cc cc .
shows_nl .
  shows_string
    ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'a',
      's', ' '] .
    shows_cc cca)))
                        (\ x ->
                          Inl (shows_string
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                   'n', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a',
                                   'i', 'n', 't', ' ', 'f', 'o', 'r', ' ', 'r',
                                   'u', 'l', 'e', ' '] .
                                shows_rule (shows_prec zero_nat)
                                  (shows_prec_list zero_nat)
                                  [' ', '-', '>', ' '] (l, ra) .
                                  shows_nl . x)))
                 b)
             ihs)
           (\ x -> Inl (snd x)))));
                         CC_impl _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_all _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                       }))))
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'I', 'n', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'r',
                          'u', 'l', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'r', 'e',
                          'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n', 'd', 'i',
                          't', 'i', 'o', 'n', ' '] .
                       shows_cc d .
                         shows_string
                           [' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c', 'h',
                             ' ', 'f', 'r', 'o', 'm'] .
                           shows_nl .
                             shows_cc c .
                               shows_nl .
                                 shows_string ['t', 'o'] .
                                   shows_nl .
                                     shows_list_gen
                                       (\ (_, (_, (cb, _))) ->
 shows_cc cb . shows_nl)
                                       [] [] [] [] ihs .
                                       x)))
         (\ _ ->
           bindb (mapM (\ (_, a) -> let {
                                      (_, aa) = a;
                                      (ab, b) = aa;
                                    } in check_cc_prf r da f m_ortho ab b)
                   ihs)
             (\ fcss -> Inr (concat fcss)));

check_cc_prfs ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ((a, Nat) -> Bool) ->
                      [(a, Nat)] ->
                        Bool ->
                          [(Cond_constraint a [Prelude.Char],
                             (b, Cond_constraint_prf a [Prelude.Char]))] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              [C_constraint a [Prelude.Char]];
check_cc_prfs r d f m_ortho [] = Inr [];
check_cc_prfs r d f m_ortho ((c, (uu, prf)) : cpfs) =
  bindb (check_cc_prf r d f m_ortho c prf)
    (\ l1 -> bindb (check_cc_prfs r d f m_ortho cpfs) (\ l2 -> Inr (l1 ++ l2)));

conditional_general_reduction_pair_proc ::
  forall a b.
    (Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    ([(b, Nat)] -> Non_inf_order_ext b [Prelude.Char] ()) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          Cond_red_pair_prf b [Prelude.Char] ->
                            Bool ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) [a];
conditional_general_reduction_pair_proc i grp pstrict pbound prof merge dpp =
  let {
    (Cond_Red_Pair_Prf c ccs bef aft) = prof;
    p = pairsb i dpp;
    r = rulese i dpp;
    f = remdups
          (funas_trs_list r ++
            funas_args_trs_list p ++ concatMap funas_term_list (qc i dpp));
    rp = grp f;
  } in (case catch_errora
               (bindb (validb rp)
                 (\ _ ->
                   bindb (check (wwf_rulesa i dpp)
                           (shows_prec_list zero_nat
                             ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'w', 'e',
                               'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd', 'n',
                               'e', 's', 's', ' ', 'o', 'f', ' ', 'T', 'R',
                               'S']))
                     (\ _ ->
                       let {
                         is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
                       } in bindb (check_varcond_subset p)
                              (\ _ ->
                                bindb (catch_errora
(forallM
  (\ (l, ra) ->
    bindb (check_no_var l)
      (\ _ -> bindb (check_no_var ra) (\ _ -> check_no_defined_root is_def ra)))
  p)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    let {
                                      ccsa =
map (\ (ca, (uvs, _)) -> (ca, uvs)) ccs;
                                      check_present =
check_constraint_present i dpp c p bef aft ccsa;
                                      (ps, pns) = split_pairsa i dpp pstrict;
                                      (pb, _) = split_pairsa i dpp pbound;
                                      pi = afb rp;
                                      us = usable_rules_gen pi r p;
                                    } in bindb
   (catch_errora (forallM (check_present Strict) ps) (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (catch_errora (forallM (check_present Non_Strict) pns)
             (\ x -> Inl (snd x)))
       (\ _ ->
         bindb (catch_errora (forallM (check_present Bound) pb)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             bindb (check (nFQ_subset_NF_rulesc i dpp)
                     (shows_prec_list zero_nat
                       ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r',
                         'e', 'q', 'u', 'i', 'r', 'e', 'd']))
               (\ _ ->
                 bindb (catch_errora
                         (catch_errora (forallM (nsb rp) us)
                           (\ x -> Inl (snd x)))
                         (\ x ->
                           Inl (shows_string
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                    'h', 'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n',
                                    't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b',
                                    'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
                                 shows_nl . x)))
                   (\ _ ->
                     let {
                       m = minimal i dpp;
                       ortho = isOK (check_weakly_orthogonal r);
                     } in bindb (catch_errora
                                  (check_cc_prfs r
                                    (\ fn -> not (null (rules_mapc i dpp fn))) f
                                    (m || ortho) ccs)
                                  (\ x ->
                                    Inl (shows_string
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'i',
     'm', 'p', 'l', 'i', 'f', 'y', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 'd', 'i',
     't', 'i', 'o', 'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i',
     'n', 't', 's'] .
  shows_nl . x)))
                            (\ fcs ->
                              catch_errora
                                (catch_errora (forallM (cc rp) fcs)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'f', 'i', 'n', 'a', 'l', ' ', '(',
   'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', ')', ' ', 'c', 'o',
   'n', 's', 't', 'r', 'a', 'i', 'n', 't', 's', ' ', 'f', 'o', 'r', ' ', 'p',
   'a', 'i', 'r', 's'] .
shows_nl . x)))))))))))))
               (\ x ->
                 Inl (shows_string
                        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a',
                          'p', 'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'b', 'o',
                          'u', 'n', 'd', 'e', 'd', ' ', 'i', 'n', 'c', 'r', 'e',
                          'a', 's', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                          'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'e',
                          ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g'] .
                       shows_nl . descc rp . shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (if merge
                 then [delete_P_Pwa i dpp (list_inter pstrict pbound)
                         (list_inter pstrict pbound)]
                 else [delete_P_Pwa i dpp pstrict pstrict,
                        delete_P_Pwa i dpp pbound pbound]);
       });

critical_pairs_top_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])];
critical_pairs_top_impl p r =
  concatMap
    (\ (l, ra) ->
      (if is_Var l then []
        else concatMap
               (\ (la, rb) ->
                 (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                         (\ a -> 'y' : a) l la
                   of {
                   Nothing -> [];
                   Just (sigma, tau) ->
                     [(subst_apply_term ra sigma, subst_apply_term rb tau)];
                 }))
               r))
    p;

show_crit_pair ::
  forall a b.
    (Showa a,
      Showa b) => (Term a b, Term a b) -> [Prelude.Char] -> [Prelude.Char];
show_crit_pair lr =
  shows_prec_list zero_nat ['('] .
    shows_prec_term zero_nat (fst lr) .
      shows_prec_list zero_nat [',', ' '] .
        shows_prec_term zero_nat (snd lr) . shows_prec_list zero_nat [')'];

check_critical_pairs_innermost ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_innermost r =
  catch_errora
    (forallM
      (\ (l, ra) ->
        check (equal_term l ra)
          (shows_prec_list zero_nat
             ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', ' ', 'n', 'o',
               'n', '-', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ', 'c', 'r', 'i',
               't', 'i', 'c', 'a', 'l', ' ', 'p', 'a', 'i', 'r', ' '] .
            show_crit_pair (l, ra)))
      (critical_pairs_top_impl r r))
    (\ x -> Inl (snd x));

extract_fresh_var ::
  forall a b.
    [((Term a b, Term a b), (Term a b, Term a b))] ->
      Sum ([Prelude.Char] -> [Prelude.Char]) b;
extract_fresh_var sts =
  (case (case sts of {
          [] -> Nothing;
          (_, (Var _, _)) : _ -> Nothing;
          (_, (Fun _ ss, _)) : _ ->
            (if null ss then Nothing else (case last ss of {
    Var a -> Just a;
    Fun _ _ -> Nothing;
  }));
        })
    of {
    Nothing ->
      Inl (shows_prec_list zero_nat
            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't',
              'r', 'a', 'c', 't', ' ', 'f', 'r', 'e', 's', 'h', ' ', 'v', 'a',
              'r', 'i', 'a', 'b', 'l', 'e', ' ', '(', 'a', 's', ' ', 'l', 'a',
              's', 't', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f',
              'r', 'o', 'm', ' ', 's', 'o', 'm', 'e', ' ', 'l', 'h', 's', ' ',
              'o', 'f', ' ', 'n', 'e', 'w', ' ', 'p', 'a', 'i', 'r', 's', ')']);
    Just a -> Inr a;
  });

extract_ren ::
  forall a b.
    (Eq a) => [((Term a b, Term a b), (Term a b, Term a b))] ->
                Sum ([Prelude.Char] -> [Prelude.Char]) ((a, Nat) -> a);
extract_ren ps_ps =
  bindb (check
          (all (\ (a, b) ->
                 let {
                   (s, t) = a;
                 } in (\ (sa, ta) ->
                        not (is_Var s) &&
                          not (is_Var t) && not (is_Var sa) && not (is_Var ta))
                   b)
            ps_ps)
          (shows_prec_list zero_nat
            ['a', 'l', 'l', ' ', 'l', 'h', 's', 's', ' ', 'a', 'n', 'd', ' ',
              'r', 'h', 's', 's', ' ', 'o', 'f', ' ', 'p', 'a', 'i', 'r', 's',
              ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n', '-',
              'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
    (\ _ ->
      let {
        rt = (\ t -> the (root t));
        pair = (\ s sa -> (rt s, fst (rt sa)));
        pairs =
          (\ (st, sta) -> [pair (fst st) (fst sta), pair (snd st) (snd sta)]);
        ren = map_of (remdups (concatMap pairs ps_ps));
        a = (\ fn -> (case ren fn of {
                       Nothing -> fst fn;
                       Just f -> f;
                     }));
      } in Inr a);

check_drop ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> Term b a ->
                         ((b, Nat) -> b) ->
                           ((Term b a, Term b a), (Term b a, Term b a)) ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_drop x c ren st_st =
  let {
    ((s, t), (sa, ta)) = st_st;
    (Fun f ss) = s;
    (Fun g ts) = t;
  } in bindb (check
               (equal_term sa (Fun (ren (f, size_list ss)) (ss ++ [Var x])))
               (shows_prec_list zero_nat
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'r', 'e',
                    'l', 'a', 't', 'e', ' '] .
                 shows_prec_term zero_nat s .
                   shows_prec_list zero_nat [' ', 'w', 'i', 't', 'h', ' '] .
                     shows_prec_term zero_nat sa))
         (\ _ ->
           let {
             tsa = args ta;
             tsaa = take (minus_nat (size_list tsa) one_nat) tsa;
           } in check (equal_term ta
                         (Fun (ren (g, size_list ts)) (tsaa ++ [Var x])) &&
                        ts == map (\ tb -> subst_apply_term tb (subst x c))
                                tsaa)
                  (shows_prec_list zero_nat
                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'r',
                       'e', 'l', 'a', 't', 'e', ' '] .
                    shows_prec_term zero_nat t .
                      shows_prec_list zero_nat [' ', 'w', 'i', 't', 'h', ' '] .
                        shows_prec_term zero_nat ta));

rwd :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwd (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = rw;

pwb :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pwb (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = pw;

rd :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rd (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = r;

pb :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pb (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = p;

complex_constant_removal_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Complex_constant_removal_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
complex_constant_removal_proc i (Complex_Constant_Removal_Proof c ps) dpp =
  catch_errora
    (let {
       p = pb i dpp;
       pw = pwb i dpp;
       r = rwd i dpp;
       q = qc i dpp;
       pairs = pairsb i dpp;
     } in bindb (extract_fresh_var ps)
            (\ x ->
              bindb (extract_ren ps)
                (\ ren ->
                  let {
                    is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
                    rQs = remdups (map root q);
                  } in bindb (catch_errora
                               (forallM
                                 (\ (s, t) ->
                                   bindb (check_no_var s)
                                     (\ _ ->
                                       bindb (check_no_var t)
 (\ _ ->
   bindb (check_no_defined_root is_def t)
     (\ _ ->
       bindb (check (not (membera (vars_rule_list (s, t)) x))
               (shows_prec_list zero_nat x .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's',
                     'h', ' ', 'f', 'o', 'r', ' ', 'p', 'a', 'i', 'r', ' '] .
                   shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                     [' ', '-', '>', ' '] (s, t)))
         (\ _ ->
           let {
             f = the (root s);
             fa = (ren f, suc (snd f));
           } in bindb (check (not (membera rQs (Just fa)))
                        (shows_prec_list zero_nat
                          ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', ' ', 'd',
                            'e', 'l', 'i', 'v', 'e', 'r', 's', ' ', 'd', 'e',
                            'f', 'i', 'n', 'e', 'd', ' ', 's', 'y', 'm', 'b',
                            'o', 'l', ' ', 'o', 'f', ' ', 'Q']))
                  (\ _ ->
                    check (not (is_def fa))
                      (shows_prec_list zero_nat
                        ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', ' ', 'd', 'e',
                          'l', 'i', 'v', 'e', 'r', 's', ' ', 'd', 'e', 'f', 'i',
                          'n', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ',
                          'o', 'f', ' ', 'R'])))))))
                                 pairs)
                               (\ xa -> Inl (snd xa)))
                         (\ _ ->
                           let {
                             pps = filter (\ st_st -> membera p (fst st_st)) ps;
                             pwps =
                               filter (\ st_st -> membera pw (fst st_st)) ps;
                           } in bindb (catch_errora
(forallM
  (\ st ->
    check (membera (map fst pps) st)
      (shows_prec_list zero_nat
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
           ' ', 'e', 'n', 't', 'r', 'y', ' ', 'f', 'o', 'r', ' ', 'p', 'a', 'i',
           'r', ' '] .
        shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
          [' ', '-', '>', ' '] st))
  p)
(\ xa -> Inl (snd xa)))
                                  (\ _ ->
                                    bindb (catch_errora
    (forallM
      (\ st ->
        check (membera (map fst pwps) st)
          (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
               'd', ' ', 'e', 'n', 't', 'r', 'y', ' ', 'f', 'o', 'r', ' ', 'p',
               'a', 'i', 'r', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
              [' ', '-', '>', ' '] st))
      pw)
    (\ xa -> Inl (snd xa)))
                                      (\ _ ->
bindb (check (ground c)
        (shows_prec_list zero_nat
           ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
          shows_prec_term zero_nat c .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'g', 'r', 'o', 'u', 'n',
                'd']))
  (\ _ ->
    bindb (check (nFQ_subset_NF_rulesc i dpp)
            (shows_prec_list zero_nat
              ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e', 'q',
                'u', 'i', 'r', 'e', 'd']))
      (\ _ ->
        bindb (check (null (rd i dpp))
                (shows_prec_list zero_nat
                  ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's',
                    ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
                    'd']))
          (\ _ ->
            bindb (check (rules_no_left_vara i dpp)
                    (shows_prec_list zero_nat
                      ['r', 'u', 'l', 'e', 's', ' ', 'm', 'a', 'y', ' ', 'n',
                        'o', 't', ' ', 'h', 'a', 'v', 'e', ' ', 'v', 'a', 'r',
                        'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ', 'l',
                        'h', 's', 's']))
              (\ _ ->
                bindb (if is_NF_trs r c then Inr ()
                        else catch_errora (check_critical_pairs_innermost r)
                               (\ xa ->
                                 Inl (shows_prec_list zero_nat
['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's', 'u', 'r', 'e',
  ' ', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e'] .
                                       shows_nl . xa)))
                  (\ _ ->
                    bindb (catch_errora
                            (forallM
                              (\ st_st ->
                                catch_errora (check_drop x c ren st_st)
                                  (\ xa ->
                                    Inl (shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i', 'n', 'd',
     'i', 'n', 'g', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd', 'e',
     'n', 'c', 'e', ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', 'r', 'u', 'l',
     'e', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] (fst st_st) .
    shows_prec_list zero_nat
      [' ', 'a', 'n', 'd', ' ', 'r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
        [' ', '-', '>', ' '] (snd st_st) .
        shows_nl . xa)))
                              ps)
                            (\ xa -> Inl (snd xa)))
                      (\ _ ->
                        Inr (mkd i (nfsc i dpp) (minimal i dpp) (map snd pps)
                              (map snd pwps) q [] r)))))))))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'o',
               'm', 'p', 'l', 'e', 'x', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n',
               't', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'p', 'r', 'o',
               'c', ':', ' '] .
            shows_nl . x));

fun_of_default :: forall a b. (Eq a) => [(a, b)] -> b -> a -> b;
fun_of_default m d = let {
                       mm = map_of m;
                     } in (\ i -> (case mm i of {
                                    Nothing -> d;
                                    Just e -> e;
                                  }));

get_arg :: forall a b. Term a b -> Nat -> Term a b;
get_arg t n =
  (if equal_nat n zero_nat then t else nth (args t) (minus_nat n one_nat));

iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops ::
  forall a b.
    (Linorder a) => Rbt a () -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s =
  (\ c f -> rm_iterateoi (impl_of s) c (f . fst));

g_ball_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> (a -> Bool) -> Bool;
g_ball_dflt_basic_oops_rm_basic_ops s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ c -> c)
    (\ x _ -> p x) True;

subtract_list_sorted :: forall a. (Eq a, Linorder a) => [a] -> [a] -> [a];
subtract_list_sorted (x : xs) (y : ys) =
  (if x == y then subtract_list_sorted xs (y : ys)
    else (if less x y then x : subtract_list_sorted xs (y : ys)
           else subtract_list_sorted (x : xs) ys));
subtract_list_sorted [] ys = [];
subtract_list_sorted (v : va) [] = v : va;

comp :: forall a. (Eq a, Linorder a) => [(a, a)] -> [(a, a)] -> [(a, a)];
comp esa es =
  remdups_sort
    (concatMap
      (\ (x, y) ->
        concatMap (\ (ya, z) -> (if y == ya then [(x, z)] else [])) es)
      esa);

scg_comp ::
  forall a b.
    (Eq b, Linorder b) => (a -> a -> Bool) -> Scg a b -> Scg a b -> Scg a b;
scg_comp conn (Scg pa qa stra wka) (Scg p q str wk) =
  (if not (conn qa p) then Null
    else let {
           strs = remdups_sort (comp stra str ++ comp stra wk ++ comp wka str);
           a = subtract_list_sorted (remdups_sort (comp wka wk)) strs;
         } in Scg pa q strs a);
scg_comp conn Null g = Null;
scg_comp conn (Scg v va vb vc) Null = Null;

generate_scgs ::
  forall a b.
    (Eq a, Eq b,
      Linorder b) => (a -> a -> Bool) -> [Scg a b] -> Scg a b -> [Scg a b];
generate_scgs conn base g =
  filter (\ ga -> not (equal_scg ga Null)) (map (scg_comp conn g) base);

subsumes :: forall a b. (Eq a, Eq b) => Scg a b -> Scg a b -> Bool;
subsumes (Scg pa qa stra wka) (Scg p q str wk) =
  pa == p && qa == q && all (membera str) stra && all (membera (str ++ wk)) wka;
subsumes g Null = True;
subsumes Null (Scg v va vb vc) = False;

in_situ :: forall a b. (Eq b) => Scg a b -> Bool;
in_situ Null = True;
in_situ (Scg p q str wk) = any (\ (a, b) -> a == b) str;

union_list_sorted :: forall a. (Eq a, Ord a) => [a] -> [a] -> [a];
union_list_sorted (x : xs) (y : ys) =
  (if x == y then x : union_list_sorted xs ys
    else (if less x y then x : union_list_sorted xs (y : ys)
           else y : union_list_sorted (x : xs) ys));
union_list_sorted [] ys = ys;
union_list_sorted (v : va) [] = v : va;

combinea :: forall a b. (Eq b, Linorder b) => Scg a b -> Scg a b -> Scg a b;
combinea (Scg pa qa stra wka) (Scg p q str wk) =
  Scg pa qa (union_list_sorted stra str) (union_list_sorted wka wk);
combinea Null s = Null;
combinea (Scg v va vb vc) Null = Null;

sagiv ::
  forall a b. (Eq a, Eq b, Linorder b) => (a -> a -> Bool) -> Scg a b -> Bool;
sagiv conn g =
  (if in_situ g then True
    else let {
           gg = scg_comp conn g g;
         } in (if subsumes gg g then False else sagiv conn (combinea g gg)));

check_SCT ::
  forall a b.
    (Compare_order a, Eq a, Compare_order b,
      Eq b) => (a -> a -> Bool) -> [Scg a b] -> Bool;
check_SCT conn gs =
  g_ball_dflt_basic_oops_rm_basic_ops
    (mk_rtrancl_set (generate_scgs conn gs) gs) (sagiv conn);

sct_subterm_precise_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_precise_proc i gs dpp =
  catch_errora
    (let {
       p = pairsb i dpp;
       is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
       eidg = is_iedg_edge_dpp i dpp;
     } in bindb (catch_errora (check_subseteq p (map fst gs))
                  (\ x ->
                    Inl (shows_string
                           ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n',
                             'o', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a',
                             'n', 'g', 'e', ' ', 'g', 'r', 'a', 'p', 'h', ' ',
                             'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                             'i', 'r', ' '] .
                          shows_rule (shows_prec zero_nat)
                            (shows_prec_list zero_nat) [' ', '-', '>', ' '] x)))
            (\ _ ->
              let {
                gGs = filter (\ g -> membera p (fst g)) gs;
              } in bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                           (shows_prec_list zero_nat
                             ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                               ' ', 'o', 'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                               'o', 's', 't', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                               'e', 'd']))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulese i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ (a, b) ->
                                       let {
 (s, t) = a;
                                       } in
 (\ (stri, nstri) ->
   catch_errora
     (bindb (check_no_var s)
       (\ _ ->
         bindb (check_no_var t)
           (\ _ ->
             bindb (check_no_defined_root is_def t)
               (\ _ ->
                 let {
                   m = size_list (args t);
                   n = size_list (args s);
                 } in bindb (catch_errora
                              (forallM
                                (\ (ia, j) ->
                                  check (less_eq_nat ia n &&
  less_eq_nat j m && isOK (check_supt (get_arg s ia) (get_arg t j)))
                                    (shows_string
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
 'w', 'i', 't', 'h', ' ', 'e', 'd', 'g', 'e', ' '] .
                                      shows_prec_nat zero_nat ia .
shows_string [' ', '|', '>', ' '] . shows_prec_nat zero_nat j . shows_nl))
                                stri)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          catch_errora
                            (forallM
                              (\ (ia, j) ->
                                check (less_eq_nat ia n &&
less_eq_nat j m && isOK (check_supteq (get_arg s ia) (get_arg t j)))
                                  (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'e', 'd', 'g',
                                       'e', ' '] .
                                    shows_prec_nat zero_nat ia .
                                      shows_string [' ', '|', '>', '=', ' '] .
shows_prec_nat zero_nat j . shows_nl))
                              nstri)
                            (\ x -> Inl (snd x)))))))
     (\ x ->
       Inl (shows_string
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
                'p', 'a', 'i', 'r', ' '] .
             shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
               [' ', '-', '>', ' '] (s, t) .
               shows_nl . x)))
 b)
                                     gGs)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               let {
                                 n = size_list p;
                                 nums = upt zero_nat n;
                                 numPs = zip p nums;
                                 num_of = fun_of_default numPs n;
                               } in check (check_SCT
    (\ (_, succs) (uv, _) -> membera succs uv)
    (map (\ (st, (stri, nstri)) ->
           let {
             eidg_st = eidg st;
             ia = num_of st;
             e = (ia, map_filter
                        (\ x ->
                          (if ((eidg_st . fst) . fst) x then Just (snd x)
                            else Nothing))
                        numPs);
           } in Scg e e (remdups_sort stri) (remdups_sort nstri))
      gGs))
                                      (shows_string
 ['s', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'a', 'n', 'a',
   'l', 'y', 's', 'i', 's', ' ', 'f', 'a', 'i', 'l', 'e', 'd'] .
shows_nl))))))
    (\ x ->
      Inl (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
               'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'i', 'z', 'e', '-', 'c',
               'h', 'a', 'n', 'g', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
               'o', 'r', ' ', 'b', 'a', 's', 'e', 'd', ' ', 'o', 'n', ' ', 't',
               'h', 'e', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', '-', 'r', 'e',
               'l', 'a', 't', 'i', 'o', 'n'] .
            shows_nl . x));

sct_subterm_approx_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_approx_proc i gs dpp =
  catch_errora
    (let {
       p = pairsb i dpp;
       is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
     } in bindb (catch_errora (check_subseteq p (map fst gs))
                  (\ x ->
                    Inl (shows_string
                           ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n',
                             'o', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a',
                             'n', 'g', 'e', ' ', 'g', 'r', 'a', 'p', 'h', ' ',
                             'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                             'i', 'r', ' '] .
                          shows_rule (shows_prec zero_nat)
                            (shows_prec_list zero_nat) [' ', '-', '>', ' '] x)))
            (\ _ ->
              let {
                gGs = filter (\ g -> membera p (fst g)) gs;
              } in bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                           (shows_prec_list zero_nat
                             ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                               ' ', 'o', 'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                               'o', 's', 't', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                               'e', 'd']))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulese i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ (a, b) ->
                                       let {
 (s, t) = a;
                                       } in
 (\ (stri, nstri) ->
   catch_errora
     (bindb (check_no_var s)
       (\ _ ->
         bindb (check_no_var t)
           (\ _ ->
             bindb (check_no_defined_root is_def t)
               (\ _ ->
                 let {
                   m = size_list (args t);
                   n = size_list (args s);
                 } in bindb (catch_errora
                              (forallM
                                (\ (ia, j) ->
                                  check (less_eq_nat ia n &&
  less_eq_nat j m && isOK (check_supt (get_arg s ia) (get_arg t j)))
                                    (shows_string
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
 'w', 'i', 't', 'h', ' ', 'e', 'd', 'g', 'e', ' '] .
                                      shows_prec_nat zero_nat ia .
shows_string [' ', '|', '>', ' '] . shows_prec_nat zero_nat j . shows_nl))
                                stri)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          catch_errora
                            (forallM
                              (\ (ia, j) ->
                                check (less_eq_nat ia n &&
less_eq_nat j m && isOK (check_supteq (get_arg s ia) (get_arg t j)))
                                  (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'e', 'd', 'g',
                                       'e', ' '] .
                                    shows_prec_nat zero_nat ia .
                                      shows_string [' ', '|', '>', '=', ' '] .
shows_prec_nat zero_nat j . shows_nl))
                              nstri)
                            (\ x -> Inl (snd x)))))))
     (\ x ->
       Inl (shows_string
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
                'p', 'a', 'i', 'r', ' '] .
             shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
               [' ', '-', '>', ' '] (s, t) .
               shows_nl . x)))
 b)
                                     gGs)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               check (check_SCT (\ (_, g) (h, _) -> g == h)
                                       (remdups
 (map (\ (st, (stri, nstri)) ->
        let {
          e = (the (root (fst st)), the (root (snd st)));
        } in Scg e e (remdups_sort stri) (remdups_sort nstri))
   gGs)))
                                 (shows_string
                                    ['s', 'i', 'z', 'e', '-', 'c', 'h', 'a',
                                      'n', 'g', 'e', ' ', 'a', 'n', 'a', 'l',
                                      'y', 's', 'i', 's', ' ', 'f', 'a', 'i',
                                      'l', 'e', 'd'] .
                                   shows_nl))))))
    (\ x ->
      Inl (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
               'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'i', 'z', 'e', '-', 'c',
               'h', 'a', 'n', 'g', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
               'o', 'r', ' ', 'b', 'a', 's', 'e', 'd', ' ', 'o', 'n', ' ', 't',
               'h', 'e', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', '-', 'r', 'e',
               'l', 'a', 't', 'i', 'o', 'n'] .
            shows_nl . x));

sct_subterm_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_proc i gs dpp =
  (if isOK (sct_subterm_approx_proc i gs dpp) then Inr ()
    else sct_subterm_precise_proc i gs dpp);

sct_entry_to_sts ::
  forall a b c d. a -> Term b c -> [(d, Nat)] -> [(d, Nat)] -> [(a, Term b c)];
sct_entry_to_sts s t stri nstri = let {
                                    a = remdups (map snd (stri ++ nstri));
                                  } in map (\ j -> (s, get_arg t j)) a;

check_sct_entry ::
  forall a b c d e f.
    (Showa a,
      Showa b) => ((a, Nat) -> Bool) ->
                    ((Term a b, Term a b) -> Sum c d) ->
                      ((Term a b, Term a b) -> Sum e f) ->
                        Term a b ->
                          Term a b ->
                            [(Nat, Nat)] ->
                              [(Nat, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sct_entry is_def sa nst s t stri nstri =
  catch_errora
    (bindb (check_no_var s)
      (\ _ ->
        bindb (check_no_var t)
          (\ _ ->
            bindb (check_no_defined_root is_def t)
              (\ _ ->
                let {
                  m = size_list (args t);
                  n = size_list (args s);
                } in bindb (catch_errora
                             (forallM
                               (\ i ->
                                 check (less_eq_nat i n)
                                   (shows_string
                                      ['l', 'e', 'f', 't', '-', 'i', 'n', 'd',
'e', 'x', ' ', 't', 'o', ' ', 'l', 'a', 'r', 'g', 'e'] .
                                     shows_prec_nat zero_nat i . shows_nl))
                               (remdups (map fst (stri ++ nstri))))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM
                                   (\ j ->
                                     check (less_eq_nat j m)
                                       (shows_string
  ['r', 'i', 'g', 'h', 't', '-', 'i', 'n', 'd', 'e', 'x', ' ', 't', 'o', ' ',
    'l', 'a', 'r', 'g', 'e', ' ', 'o', 'r', ' ', 'a', 'r', 'g', 'u', 'm', 'e',
    'n', 't', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 'u', 's', 'a',
    'b', 'l', 'e', '-', 'r', 'u', 'l', 'e', 's', ' ', 'c', 'o', 'n', 'd', 'i',
    't', 'i', 'o', 'n'] .
 shows_prec_nat zero_nat j))
                                   (remdups (map snd (stri ++ nstri))))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             let {
                               _ = args s;
                               _ = args t;
                             } in bindb (catch_errora
  (forallM
    (\ (i, j) ->
      check (isOK (sa (get_arg s i, get_arg t j)))
        (shows_string
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
             'e', 'd', 'g', 'e', ' '] .
          shows_prec_nat zero_nat i .
            shows_string [' ', '-', 'S', '-', '>', ' '] .
              shows_prec_nat zero_nat j))
    stri)
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      catch_errora
(forallM
  (\ (i, j) ->
    check (isOK (nst (get_arg s i, get_arg t j)))
      (shows_string
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 'e',
           'd', 'g', 'e', ' '] .
        shows_prec_nat zero_nat i .
          shows_string [' ', '-', 'N', 'S', '-', '>', ' '] .
            shows_prec_nat zero_nat j))
  nstri)
(\ x -> Inl (snd x)))))))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', 's', ' ', 'w', 'i', 't', 'h',
               ' ', 'D', 'P', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] (s, t) .
              shows_nl . x));

sct_ur_af_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [((Term b [Prelude.Char], Term b [Prelude.Char]),
                         ([(Nat, Nat)], [(Nat, Nat)]))] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_ur_af_proc i rp gs u_opt dpp =
  catch_errora
    (bindb (valid rp)
      (\ _ ->
        let {
          is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
          pi = af rp;
          sa = s rp;
          nsa = ns rp;
          nsta = nst rp;
          p = pairsb i dpp;
          gGs = filter (\ g -> membera p (fst g)) gs;
        } in bindb (catch_errora
                     (forallM (\ (l, _) -> check_no_var l) (rulese i dpp))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (catch_errora
                         (forallM
                           (\ (a, b) ->
                             let {
                               (saa, t) = a;
                             } in (\ (aa, ba) ->
                                    check_sct_entry is_def sa nsta saa t aa ba)
                               b)
                           gGs)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     let {
                       sts = concatMap
                               (\ (a, b) ->
                                 let {
                                   (sb, t) = a;
                                 } in (\ (aa, ba) ->
sct_entry_to_sts sb t aa ba)
                                   b)
                               gGs;
                     } in bindb (smart_usable_rules_checker_impl i dpp pi u_opt
                                  sts)
                            (\ u ->
                              bindb (catch_errora
                                      (catch_errora (forallM nsa u)
(\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
         'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l',
         'e', ' ', 'r', 'u', 'l', 'e', 's'] .
      shows_nl . x)))
                                (\ _ ->
                                  let {
                                    eidg = is_iedg_edge_dpp i dpp;
                                  } in bindb
 (catch_errora (check_subseteq p (map fst gs))
   (\ x ->
     Inl (shows_string
            ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n', 'o', ' ', 's',
              'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'g', 'r',
              'a', 'p', 'h', ' ', 'f', 'o', 'r', ' ', 'D', 'P', ' '] .
           shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
             [' ', '-', '>', ' '] x)))
 (\ _ ->
   let {
     n = size_list p;
     nums = upt zero_nat n;
     numPs = zip p nums;
     num_of = fun_of_default numPs n;
   } in check (check_SCT (\ (_, succs) (uv, _) -> membera succs uv)
                (map (\ (st, (stri, nstri)) ->
                       let {
                         eidg_st = eidg st;
                         ia = num_of st;
                         e = (ia, map_filter
                                    (\ x ->
                                      (if ((eidg_st . fst) . fst) x
then Just (snd x) else Nothing))
                                    numPs);
                       } in Scg e e stri nstri)
                  gGs))
          (shows_string
             ['s', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'a',
               'n', 'a', 'l', 'y', 's', 'i', 's', ' ', 'f', 'a', 'i', 'l', 'e',
               'd'] .
            shows_nl))))))))
    (\ x ->
      Inl (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
               'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'i', 'z', 'e', '-', 'c',
               'h', 'a', 'n', 'g', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
               'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'e', ' ', 'f',
               'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' '] .
            shows_nl .
              desc rp .
                shows_nl .
                  shows_string
                    ['f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                      'o', 'w', 'i', 'n', 'g', ' ', 'r', 'e', 'a', 's', 'o',
                      'n'] .
                    shows_nl . x));

proj_terma ::
  forall a b.
    (Ceq a, Ccompare a, Eq a,
      Eq b) => Status a -> Set (a, Nat) -> Term a b -> Multiset (Term a b);
proj_terma proj f (Var x) = single (Var x);
proj_terma proj fa (Fun f ts) =
  (if member (f, size_list ts) fa
    then msetsum
           (mset (map (\ i -> proj_terma proj fa (nth ts i))
                   (status proj (f, size_list ts))))
    else single (Fun f ts));

subtract_entries_raw ::
  forall a b. (Eq a, Minus b) => [(a, b)] -> [(a, b)] -> [(a, b)];
subtract_entries_raw xs ys =
  foldr (\ (k, v) -> map_entry k (\ va -> minus va v)) ys xs;

subtract_entries ::
  forall a b. (Eq a, Minus b) => Alist a b -> Alist a b -> Alist a b;
subtract_entries xb xc =
  Alist (subtract_entries_raw (impl_ofa xb) (impl_ofa xc));

minus_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
minus_multiset (Bag xs) (Bag ys) = Bag (subtract_entries xs ys);

inf_subset_mset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
inf_subset_mset a b = minus_multiset a (minus_multiset a b);

multeqp ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Set_impl a) => (a -> a -> Bool) -> Multiset a -> Multiset a -> Bool;
multeqp p n m = let {
                  z = inf_subset_mset m n;
                  x = minus_multiset m z;
                  y = minus_multiset n z;
                } in ball (set_mset y) (\ ya -> bex (set_mset x) (p ya));

weak_supt_mul ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Status a -> Set (a, Nat) -> Term a b -> Term a b -> Bool;
weak_supt_mul =
  (\ proj f s t ->
    multeqp (\ x y -> supt_impl y x) (proj_terma proj f t)
      (proj_terma proj f s));

check_supteqproj_pred ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Showa a, Compare b, Eq b,
      Showa b) => Status a ->
                    Set (a, Nat) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_supteqproj_pred pi f lr =
  check (let {
           (a, b) = lr;
         } in weak_supt_mul pi f a b)
    ((shows_prec_list zero_nat
        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
          'n', 't', ' ', 'r', 'u', 'l', 'e', ' '] .
       shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
         [' ', '-', '>', ' '] lr) .
      shows_prec_list zero_nat
        [' ', 'b', 'y', ' ', 's', 'u', 'p', 't', 'e', 'q', '^', 'm', 'u', 'l']);

strict_supt_mul ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Status a -> Set (a, Nat) -> Term a b -> Term a b -> Bool;
strict_supt_mul =
  (\ proj f s t ->
    multeqp (\ x y -> supt_impl y x) (proj_terma proj f t)
      (proj_terma proj f s) &&
      not (equal_multiset (proj_terma proj f s) (proj_terma proj f t)));

check_suptproj_pred ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Showa a, Compare b, Eq b,
      Showa b) => Status a ->
                    Set (a, Nat) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_suptproj_pred pi f lr =
  check (let {
           (a, b) = lr;
         } in strict_supt_mul pi f a b)
    ((shows_prec_list zero_nat
        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
          'n', 't', ' ', 'r', 'u', 'l', 'e', ' '] .
       shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
         [' ', '-', '>', ' '] lr) .
      shows_prec_list zero_nat
        [' ', 'b', 'y', ' ', 's', 'u', 'p', 't', '^', 'm', 'u', 'l']);

generalized_subterm_proc ::
  forall a b c.
    (Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b, Compare c, Eq c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [((b, Nat), [Nat])] ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generalized_subterm_proc i pi p_remove dpp =
  (case catch_errora
          (let {
             p = pairsb i dpp;
             r = rulese i dpp;
             f = map fst pi;
             ff = set f;
             pi_opt = status_of pi;
           } in bindb (check (null (qc i dpp))
                        (shows_prec_list zero_nat
                          ['c', 'u', 'r', 'r', 'e', 'n', 't', 'l', 'y', ' ',
                            'g', 'e', 'n', 'e', 'r', 'a', 'l', 'i', 'z', 'e',
                            'd', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', ' ',
                            'c', 'r', 'i', 't', 'e', 'r', 'i', 'o', 'n', ' ',
                            'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 's',
                            'u', 'p', 'p', 'o', 'r', 't', ' ', 's', 't', 'r',
                            'a', 't', 'e', 'g', 'i', 'e', 's']))
                  (\ _ ->
                    bindb (check (minimal i dpp)
                            (shows_prec_list zero_nat
                              ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                                ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                      (\ _ ->
                        bindb (check (not (is_none pi_opt))
                                (shows_prec_list zero_nat
                                  ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ',
                                    'f', 'i', 'l', 't', 'e', 'r', ' ', 'l', 'i',
                                    's', 't', 's', ' ', 'i', 'n', 'v', 'a', 'l',
                                    'i', 'd', ' ', 'p', 'o', 's', 'i', 't', 'i',
                                    'o', 'n', 's']))
                          (\ _ ->
                            let {
                              pia = the pi_opt;
                              premove = set p_remove;
                              (ps, pns) =
                                partition (\ lr -> member lr premove) p;
                            } in bindb (catch_errora
 (forallM
   (\ fa ->
     check (not (null (status pia fa)))
       ((shows_prec_list zero_nat
           ['s', 't', 'a', 't', 'u', 's', ' ', 'o', 'f', ' ', 's', 'y', 'm',
             'b', 'o', 'l', ' '] .
          shows_prec_prod zero_nat fa) .
         shows_prec_list zero_nat
           [' ', 'i', 'n', ' ', 'F', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e',
             ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
   f)
 (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (catch_errora
     (forallM
       (\ (l, _) ->
         check (not (is_Var l))
           (shows_prec_list zero_nat
             ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ',
               'l', 'h', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
               'w', 'e', 'd']))
       r)
     (\ x -> Inl (snd x)))
                                       (\ _ ->
 bindb (catch_errora
         (catch_errora
           (forallM (check_supteqproj_pred pia ff)
             (filter (\ lr -> member (the (root (fst lr))) ff) r))
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                    ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'r',
                    'u', 'l', 'e', 's', ' ', 'w', 'i', 't', 'h', ' ', 'r', 'o',
                    'o', 't', ' ', 'i', 'n', ' ', 'F', '\n'] .
                 x)))
   (\ _ ->
     bindb (catch_errora
             (catch_errora (forallM (check_supteqproj_pred pia ff) pns)
               (\ x -> Inl (snd x)))
             (\ x ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                        'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                        ' ', 'D', 'P', 's', '\n'] .
                     x)))
       (\ _ ->
         catch_errora
           (catch_errora (forallM (check_suptproj_pred pia ff) ps)
             (\ x -> Inl (snd x)))
           (\ x ->
             Inl (shows_prec_list zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                      ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ',
                      'D', 'P', 's', '\n'] .
                   x))))))))))
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'u', 'b', 't',
                     'e', 'r', 'm', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                     'r', '\n'] .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp p_remove p_remove);
  });

filter_prec_weight_repr ::
  forall a.
    ((a, Nat) -> Af_entry) ->
      ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
        ([((Filtered a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat);
filter_prec_weight_repr pi (prw, w0) =
  let {
    fprw = filter (\ (fn, _) -> (case pi fn of {
                                  Collapse _ -> False;
                                  AFList _ -> True;
                                }))
             prw;
    mprw =
      map (\ (a, b) ->
            let {
              (f, n) = a;
            } in (\ aa -> ((FPair f n, (case pi (f, n) of {
 Collapse _ -> zero_nat;
 AFList ab -> size_list ab;
                                       })),
                            aa))
              b)
        fprw;
  } in (mprw, w0);

prec_repr_to_status ::
  forall a.
    (Key a) => [((a, Nat), (Nat, Order_tag))] -> (Filtered a, Nat) -> Order_tag;
prec_repr_to_status prs = let {
                            m = ceta_map_of prs;
                          } in (\ (FPair f a, _) -> (case m (f, a) of {
              Nothing -> Lex;
              Just aa -> snd aa;
            }));

prec_repr_to_pr ::
  forall a.
    (Key a) => [((a, Nat), (Nat, Order_tag))] -> (Filtered a, Nat) -> Nat;
prec_repr_to_pr prs = let {
                        m = ceta_map_of prs;
                      } in (\ (FPair f a, _) -> (case m (f, a) of {
          Nothing -> zero_nat;
          Just aa -> fst aa;
        }));

plus_single_mono ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      Bool;
plus_single_mono
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = plus_single_mono;

check_complexity ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_complexity
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = check_complexity;

maxb ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      a -> a -> a;
maxb (Partial_object_ext carrier
       (Monoid_ext mult one
         (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = max;

poly_c_max_inter_bcoeff_strict ::
  forall a b c.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      [(c, Nat)] -> ((c, Nat) -> (a, [a])) -> a;
poly_c_max_inter_bcoeff_strict r f pi =
  foldr (maxb r) (concatMap (\ fn -> snd (pi fn)) f) (zero r);

geq ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      a -> a -> Bool;
geq (Partial_object_ext carrier
      (Monoid_ext mult one
        (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = geq;

poly_c_max_inter_bcoeff ::
  forall a b c.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      [(c, Nat)] -> ((c, Nat) -> (a, [a])) -> a;
poly_c_max_inter_bcoeff r f pi =
  foldr (maxb r)
    (concatMap (\ fn -> filter (\ b -> not (geq r (one r) b)) (snd (pi fn))) f)
    (zero r);

convert_lpoly_complexity ::
  forall a b c d.
    (Eq a) => Partial_object_ext a
                (Monoid_ext a
                  (Ring_ext a
                    (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
                ((c, Nat) -> (a, [a])) ->
                  Complexity_measure c d ->
                    Complexity_class ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
convert_lpoly_complexity r pi cm (Comp_Poly deg) =
  let {
    f = (case cm of {
          Derivational_Complexity f -> f;
          Runtime_Complexity c _ -> c;
        });
    bc = poly_c_max_inter_bcoeff r f pi;
    bca = poly_c_max_inter_bcoeff_strict r f pi;
  } in bindb (check (less_nat zero_nat deg || bca == zero r)
               (shows_prec_list zero_nat
                 ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'c', 'o', 'm',
                   'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'n', 'o', 't', ' ',
                   'f', 'u', 'l', 'l', 'y', ' ', 's', 'u', 'p', 'p', 'o', 'r',
                   't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'l', 'i', 'n', 'e',
                   'a', 'r', ' ', '(', 'p', 'o', 'l', 'y', '/', 'm', 'a', 't',
                   'r', 'i', 'x', ')', '-', 'i', 'n', 't', 'e', 'r', 'p', 'r',
                   'e', 't', 'a', 't', 'i', 'o', 'n', 's']))
         (\ _ -> check_complexity r bc (minus_nat deg one_nat));

check_poly_mono_npsm ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [(c, Nat)] ->
                      [((c, Nat), (a, [a]))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_poly_mono_npsm r f pi =
  bindb (catch_errora
          (forallM
            (\ (a, b) ->
              let {
                (fa, n) = a;
              } in (\ (c, cs) ->
                     catch_errora
                       (bindb
                         (check
                           (if equal_nat n (suc zero_nat) then c == zero r
                             else True)
                           (shows_string
                              ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'p',
                                'a', 'r', 't', ' '] .
                             shows_prec zero_nat c .
                               shows_string
                                 [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ',
                                   '0', ' '] .
                                 shows_nl))
                         (\ _ ->
                           bindb (check (equal_nat n (size_list cs))
                                   (shows_string
                                      ['t', 'h', 'e', ' ', 'a', 'r', 'i', 't',
'y', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 't', 'h', 'e', ' ', 's', 'a', 'm',
'e', ' ', 'a', 's', ' ', 't', 'h', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ',
'o', 'f', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's'] .
                                     shows_nl))
                             (\ _ ->
                               check (less_eq_nat n (suc zero_nat))
                                 (shows_string
                                    ['s', 'y', 'm', 'b', 'o', 'l', ' ', 'h',
                                      'a', 's', ' ', 'a', 'r', 'i', 't', 'y',
                                      ' ', 'l', 'a', 'r', 'g', 'e', 'r', ' ',
                                      't', 'h', 'a', 'n', ' ', '1'] .
                                   shows_nl))))
                       (\ x ->
                         Inl (shows_string
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                  'i', 't', 'h', ' ', 'm', 'o', 'n', 'o', 't',
                                  'o', 'n', 'i', 'c', 'i', 't', 'y', ' ', 'd',
                                  'u', 'e', ' ', 't', 'o', ' ', 'i', 'n', 't',
                                  'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i',
                                  'o', 'n', ' ', 'o', 'f', ' '] .
                               shows_prec zero_nat fa .
                                 shows_string ['/'] .
                                   shows_prec_nat zero_nat n . shows_nl . x)))
                b)
            pi)
          (\ x -> Inl (snd x)))
    (\ _ ->
      catch_errora (check_subseteq f (map fst pi))
        (\ x ->
          Inl (shows_string
                 ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'i', 'n', 't', 'e',
                   'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'f',
                   'o', 'r', ' '] .
                shows_prec_prod zero_nat x . shows_nl)));

arcpos ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Bool;
arcpos
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = arcpos;

carrier :: forall a b. Partial_object_ext a b -> Set a;
carrier (Partial_object_ext carrier more) = carrier;

check_lpoly_coeffs ::
  forall a b c.
    (Ceq a, Ccompare a, Showa a,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [((c, Nat), (a, [a]))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_coeffs r i =
  catch_errora
    (forallM
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ (c, cs) ->
               catch_errora
                 (bindb
                   (check (member c (carrier r))
                     (shows_string
                        ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'p', 'a',
                          'r', 't', ' '] .
                       shows_prec zero_nat c .
                         shows_string
                           [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'w', 'e',
                             'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd'] .
                           shows_nl))
                   (\ _ ->
                     bindb (check (less_eq_nat (size_list cs) n)
                             (shows_string
                                ['n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f',
                                  ' ', 'c', 'o', 'e', 'f', 'f', 'i', 'c', 'i',
                                  'e', 'n', 't', 's', ' ', 'e', 'x', 'c', 'e',
                                  'e', 'd', 's', ' ', 'a', 'r', 'i', 't', 'y',
                                  ' ', 'o', 'f', ' ', 's', 'y', 'm', 'b', 'o',
                                  'l', ' '] .
                               shows_prec zero_nat f))
                       (\ _ ->
                         bindb (check (arcpos r c || any (arcpos r) cs)
                                 (shows_string
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 'f', 'i', 'n', 'd', ' ', 'p',
                                      'o', 's', 'i', 't', 'i', 'v', 'e', ' ',
                                      'e', 'n', 't', 'r', 'y', ' ', 'w', 'h',
                                      'i', 'c', 'h', ' ', 'i', 's', ' ', 'r',
                                      'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ',
                                      'f', 'o', 'r', ' ', 'a', 'r', 'c', 't',
                                      'i', 'c', ' ', 'i', 'n', 't', 'e', 'r',
                                      'p', 'r', 'e', 't', 'a', 't', 'i', 'o',
                                      'n', 's'] .
                                   shows_nl))
                           (\ _ ->
                             catch_errora
                               (forallM
                                 (\ aa ->
                                   check (geq r aa (zero r) &&
   member aa (carrier r))
                                     (shows_string
['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', ' '] .
                                       shows_prec zero_nat aa .
 shows_string
   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd'] .
   shows_nl))
                                 cs)
                               (\ x -> Inl (snd x))))))
                 (\ x ->
                   Inl (shows_string
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                            't', 'h', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r',
                            'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
                            ' '] .
                         shows_prec zero_nat f .
                           shows_string ['/'] .
                             shows_prec_nat zero_nat n . shows_nl . x)))
          b)
      i)
    (\ x -> Inl (snd x));

description ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      [Prelude.Char];
description
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = description;

defaultb ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a;
defaultb
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = defaulta;

to_lpoly_inter ::
  forall a b c.
    (Key c) => Partial_object_ext a
                 (Monoid_ext a
                   (Ring_ext a
                     (Ordered_semiring_ext a
                       (Lpoly_order_semiring_ext a b)))) ->
                 [((c, Nat), (a, [a]))] -> (c, Nat) -> (a, [a]);
to_lpoly_inter r i =
  fun_of_map_fun (ceta_map_of i)
    (\ fn -> (defaultb r, replicate (snd fn) (one r)));

show_pvars ::
  forall a b c.
    (Eq a, Showa a,
      Showa c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                    [(c, a)] -> [[Prelude.Char]];
show_pvars r [] = [];
show_pvars r ((x, c) : vas) =
  (if c == one r then id else shows_prec zero_nat c)
    (shows_prec zero_nat x []) :
    show_pvars r vas;

shows_lpoly ::
  forall a b c.
    (Eq a, Showa a,
      Showa c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                    L_poly c a -> [Prelude.Char] -> [Prelude.Char];
shows_lpoly r (LPoly c cs) =
  (case show_pvars r cs of {
    [] -> shows_prec zero_nat c;
    a : list ->
      (if c == zero r then id
        else shows_prec zero_nat c . shows_string [' ', '+', ' ']) .
        shows_list_gen (shows_prec_list zero_nat) [] [] [' ', '+', ' '] []
          (a : list);
  });

add_var ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 c -> a -> [(c, a)] -> [(c, a)];
add_var r x a [] = [(x, a)];
add_var r x a ((y, b) : vas) =
  (if x == y then let {
                    s = add r a b;
                  } in (if s == zero r then vas else (x, s) : vas)
    else (y, b) : add_var r x a vas);

sum_pvars ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 [(c, a)] -> [(c, a)] -> [(c, a)];
sum_pvars r [] vbs = vbs;
sum_pvars r ((x, a) : vas) vbs =
  (if a == zero r then sum_pvars r vas vbs
    else sum_pvars r vas (add_var r x a vbs));

sum_lpolya ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 L_poly c a -> L_poly c a -> L_poly c a;
sum_lpolya r (LPoly a vas) (LPoly b vbs) =
  LPoly (add r a b) (sum_pvars r vas vbs);

mul_pvars ::
  forall a b c.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                a -> [(c, a)] -> [(c, a)];
mul_pvars r a [] = [];
mul_pvars r a ((x, b) : vas) = let {
                                 p = mult r a b;
                                 res = mul_pvars r a vas;
                               } in (if p == zero r then res else (x, p) : res);

mul_lpoly ::
  forall a b c.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                a -> L_poly c a -> L_poly c a;
mul_lpoly r a (LPoly b vas) = LPoly (mult r a b) (mul_pvars r a vas);

list_prod :: forall a b. Partial_object_ext a (Monoid_ext a b) -> [a] -> a;
list_prod r [] = one r;
list_prod r (x : xs) = mult r x (list_prod r xs);

wf_pvars ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Partial_object_ext a b -> [(c, a)] -> Bool;
wf_pvars r vas = less_eq_set (set (map snd vas)) (carrier r);

wf_lpoly ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Partial_object_ext a b -> L_poly c a -> Bool;
wf_lpoly r (LPoly a vas) = member a (carrier r) && wf_pvars r vas;

pleftI ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq d) => Partial_object_ext a
                 (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                 ((c, Nat) -> (a, [a])) -> Term c d -> L_poly d a;
pleftI r pi (Var x) = LPoly (zero r) [(x, one r)];
pleftI r pi (Fun f ts) =
  let {
    (c, asa) = pi (f, size_list ts);
  } in (case sum_lpolya r (LPoly c [])
               (list_prod
                 (Partial_object_ext (collect (wf_lpoly r))
                   (Monoid_ext (sum_lpolya r) (LPoly (zero r) []) ()))
                 (map (\ at -> mul_lpoly r (fst at) (pleftI r pi (snd at)))
                   (zip asa ts)))
         of {
         LPoly d [] -> LPoly (maxb r (zero r) d) [];
         LPoly d (ab : lista) -> LPoly d (ab : lista);
       });

create_lpoly_repr ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b, Key b,
      Showa b) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a ())))) ->
                    [((b, Nat), (a, [a]))] -> [Prelude.Char] -> [Prelude.Char];
create_lpoly_repr c i =
  let {
    pi = to_lpoly_inter c i;
  } in shows_string
         ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n', 't',
           'e', 'r', 'p', 'r', 'e', 't', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'o',
           'v', 'e', 'r', ' '] .
         shows_string (description c) .
           shows_nl .
             shows_sep
               (\ (f, n) ->
                 let {
                   t = Fun f (map Var
                               (fresh_strings_list ['x', '_'] one_nat [] n));
                 } in shows_string ['P', 'o', 'l', '('] .
                        shows_prec_term zero_nat t .
                          shows_string [')', ' ', '=', ' '] .
                            shows_lpoly c (pleftI c pi t))
               shows_nl (remdups (map fst i));

checkmono ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Bool;
checkmono
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = checkmono;

check_poly_mono ::
  forall a b c.
    (Showa a,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [((c, Nat), (a, [a]))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_poly_mono r =
  (\ xs ->
    catch_errora
      (forallM
        (\ (a, b) ->
          let {
            (f, n) = a;
          } in (\ (c, cs) ->
                 catch_errora
                   (bindb
                     (check (geq r c (zero r))
                       (shows_string
                          ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'p',
                            'a', 'r', 't', ' '] .
                         shows_prec zero_nat c .
                           shows_string
                             [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a',
                               't', ' ', 'l', 'e', 'a', 's', 't', ' '] .
                             shows_prec zero_nat (zero r) . shows_nl))
                     (\ _ ->
                       bindb (check (less_eq_nat n (size_list cs))
                               (shows_string
                                  ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ',
                                    'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ',
                                    'i', 's', ' ', 'i', 'g', 'n', 'o', 'r', 'e',
                                    'd'] .
                                 shows_nl))
                         (\ _ ->
                           catch_errora
                             (forallM
                               (\ d ->
                                 check (checkmono r d)
                                   (shows_string
                                      ['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i',
'e', 'n', 't', ' '] .
                                     shows_prec zero_nat d .
                                       shows_string
 [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd'] .
 shows_nl))
                               cs)
                             (\ x -> Inl (snd x)))))
                   (\ x ->
                     Inl (shows_string
                            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                              't', 'h', ' ', 'm', 'o', 'n', 'o', 't', 'o', 'n',
                              'i', 'c', 'i', 't', 'y', ' ', 'd', 'u', 'e', ' ',
                              't', 'o', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r',
                              'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
                              ' '] .
                           shows_prec zero_nat f .
                             shows_string ['/'] .
                               shows_prec_nat zero_nat n . shows_nl . x)))
            b)
        xs)
      (\ x -> Inl (snd x)));

create_mono_af ::
  forall a b c.
    (Eq a,
      Key c) => Partial_object_ext a
                  (Monoid_ext a
                    (Ring_ext a
                      (Ordered_semiring_ext a
                        (Lpoly_order_semiring_ext a b)))) ->
                  [((c, Nat), (a, [a]))] -> (c, Nat) -> Set Nat;
create_mono_af r i =
  (if plus_single_mono r
    then fun_of_map_funa (ceta_map_of i) (\ (_, n) -> set (upt zero_nat n))
           (\ (c, coeffs) ->
             set (if geq r c (zero r)
                   then concatMap
                          (\ (ca, ia) ->
                            (if ca == one r || checkmono r ca then [ia]
                              else []))
                          (zip coeffs (upt zero_nat (size_list coeffs)))
                   else []))
    else empty_af);

lookup_rest :: forall a b. (Eq a) => a -> [(a, b)] -> Maybe (b, [(a, b)]);
lookup_rest x [] = Nothing;
lookup_rest x ((y, c) : ycs) =
  (if x == y then Just (c, ycs)
    else (case lookup_rest x ycs of {
           Nothing -> Nothing;
           Just (d, yccs) -> Just (d, (y, c) : yccs);
         }));

check_pvars ::
  forall a b c.
    (Showa a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 (a -> a -> Bool) -> [(c, a)] -> [(c, a)] -> Sum c ();
check_pvars r rel vas [] =
  catch_errora (forallM (\ va -> check (rel (snd va) (zero r)) (fst va)) vas)
    (\ x -> Inl (snd x));
check_pvars r rel vas ((x, b) : vbs) =
  let {
    a = (case lookup_rest x vas of {
          Nothing -> (zero r, vas);
          Just a -> let {
                      (aa, ba) = a;
                    } in (aa, ba);
        });
    (aa, vasa) = a;
  } in bindb (check (rel aa b) x) (\ _ -> check_pvars r rel vasa vbs);

check_lpoly_ns ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                    L_poly c a ->
                      L_poly c a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_ns r (LPoly a vas) (LPoly b vbs) =
  catch_errora
    (bindb
      (check (geq r a b)
        (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
            'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 's',
            't', 'a', 'n', 't', ' ', 'p', 'a', 'r', 't', 's']))
      (\ _ ->
        catch_errora (check_pvars r (geq r) vas vbs)
          (\ x ->
            Inl (shows_string
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c',
                     'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', 's', ' ',
                     'o', 'f', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
                     ' '] .
                  shows_prec zero_nat x))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' '] .
            shows_lpoly r (LPoly a vas) .
              shows_string [' ', '>', '=', ' '] .
                shows_lpoly r (LPoly b vbs) . shows_nl . x));

prightI ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq d) => Partial_object_ext a
                 (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                 ((c, Nat) -> (a, [a])) -> Term c d -> L_poly d a;
prightI r pi (Var x) = LPoly (zero r) [(x, one r)];
prightI r pi (Fun f ts) =
  let {
    (c, asa) = pi (f, size_list ts);
    (LPoly d a) =
      sum_lpolya r (LPoly c [])
        (list_prod
          (Partial_object_ext (collect (wf_lpoly r))
            (Monoid_ext (sum_lpolya r) (LPoly (zero r) []) ()))
          (map (\ at -> mul_lpoly r (fst at) (prightI r pi (snd at)))
            (zip asa ts)));
  } in LPoly (maxb r (zero r) d) a;

check_polo_ns ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Showa c, Eq d,
      Showa d) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    ((c, Nat) -> (a, [a])) ->
                      (Term c d, Term c d) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_polo_ns r pi (s, t) =
  let {
    left = pleftI r pi s;
    right = prightI r pi t;
  } in catch_errora (check_lpoly_ns r left right)
         (\ x ->
           Inl (shows_string
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                    's', 'u', 'r', 'e', ' '] .
                 shows_prec_term zero_nat s .
                   shows_string [' ', '>', '=', ' '] .
                     shows_prec_term zero_nat t . shows_nl . x));

gt :: forall a b.
        Partial_object_ext a
          (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
          a -> a -> Bool;
gt (Partial_object_ext carrier
     (Monoid_ext mult one
       (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = gt;

check_lpoly_s ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    L_poly c a ->
                      L_poly c a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_s r (LPoly a vas) (LPoly b vbs) =
  catch_errora
    (bindb
      (check (gt r a b)
        (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
            'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 's',
            't', 'a', 'n', 't', ' ', 'p', 'a', 'r', 't']))
      (\ _ ->
        catch_errora
          (check_pvars r (if plus_single_mono r then geq r else gt r) vas vbs)
          (\ x ->
            Inl (shows_string
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c',
                     'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', 's', ' ',
                     'o', 'f', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
                     ' '] .
                  shows_prec zero_nat x))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' '] .
            shows_lpoly r (LPoly a vas) .
              shows_string [' ', '>', ' '] .
                shows_lpoly r (LPoly b vbs) . shows_nl . x));

check_polo_s ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Showa c, Eq d,
      Showa d) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    ((c, Nat) -> (a, [a])) ->
                      (Term c d, Term c d) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_polo_s r pi (s, t) =
  let {
    left = pleftI r pi s;
    right = prightI r pi t;
  } in catch_errora (check_lpoly_s r left right)
         (\ x ->
           Inl (shows_string
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                    's', 'u', 'r', 'e', ' '] .
                 shows_prec_term zero_nat s .
                   shows_string [' ', '>', ' '] .
                     shows_prec_term zero_nat t . shows_nl . x));

create_af ::
  forall a b c.
    (Eq a,
      Key c) => Partial_object_ext a
                  (Monoid_ext a
                    (Ring_ext a
                      (Ordered_semiring_ext a
                        (Lpoly_order_semiring_ext a b)))) ->
                  [((c, Nat), (a, [a]))] -> (c, Nat) -> Set Nat;
create_af r i =
  fun_of_map_funa (ceta_map_of i) (\ (_, n) -> set (upt zero_nat n))
    (\ (_, coeffs) ->
      set (concatMap (\ (c, ia) -> (if not (c == zero r) then [ia] else []))
            (zip coeffs (upt zero_nat (size_list coeffs)))));

create_poly_redtriple ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b, Key b,
      Showa b, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a ())))) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                      [((b, Nat), (a, [a]))] -> Redtriple_ext b c ();
create_poly_redtriple c cI i =
  let {
    pi = to_lpoly_inter c i;
    ns = check_polo_ns c pi;
  } in Redtriple_ext (bindb cI (\ _ -> check_lpoly_coeffs c i))
         (check_polo_s c pi) ns ns (create_af c i) (create_mono_af c i)
         (\ s_ns_nst ->
           (if plus_single_mono c then check_poly_mono c i
             else check_poly_mono_npsm c (funas_trs_list s_ns_nst) i))
         (create_lpoly_repr c i) (Just (map fst i))
         (if plus_single_mono c then convert_lpoly_complexity c pi
           else no_complexity_check)
         ();

weak_gt_arctic_delta ::
  forall a. (Floor_ceiling a) => Arctic_delta a -> Arctic_delta a -> Bool;
weak_gt_arctic_delta uu MinInfty_delta = True;
weak_gt_arctic_delta MinInfty_delta (Num_arc_delta uv) = False;
weak_gt_arctic_delta (Num_arc_delta x) (Num_arc_delta y) = less y x;

check_poly_strict_mono_discrete ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => (a -> a -> Bool) -> [([(b, Nat)], a)] -> b -> Bool;
check_poly_strict_mono_discrete gt p v =
  check_poly_gt gt
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p)
    p;

check_monom_strict_mono :: forall a. (Eq a) => Bool -> [(a, Nat)] -> a -> Bool;
check_monom_strict_mono pm m v =
  not (null m) &&
    null (tla m) &&
      fst (hda m) == v &&
        (if pm then less_eq_nat one_nat (snd (hda m))
          else equal_nat (snd (hda m)) one_nat);

check_poly_strict_mono ::
  forall a b. (Eq a, Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_strict_mono pm p v =
  any (\ (m, c) -> less_eq onea c && check_monom_strict_mono pm m v) p;

check_poly_strict_mono_smart ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => Bool ->
                 Bool -> (a -> a -> Bool) -> [([(b, Nat)], a)] -> b -> Bool;
check_poly_strict_mono_smart discrete pm gt p v =
  (if discrete then check_poly_strict_mono_discrete gt p v
    else check_poly_strict_mono pm p v);

check_poly_weak_mono_all ::
  forall a b. (Ordered_semiring_0 b) => [([(a, Nat)], b)] -> Bool;
check_poly_weak_mono_all p = all (\ (_, a) -> less_eq zeroa a) p;

check_poly_weak_mono_and_pos ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> Bool;
check_poly_weak_mono_and_pos discrete p =
  (if discrete
    then all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&
           less_eq zeroa (eval_poly (\ _ -> zeroa) p)
    else check_poly_weak_mono_all p);

poly_inter_to_mono_af ::
  forall a b.
    (Eq a, Poly_carrier a,
      Key b) => Bool ->
                  Bool ->
                    (a -> a -> Bool) ->
                      [((b, Nat), [([(Nat, Nat)], a)])] -> (b, Nat) -> Set Nat;
poly_inter_to_mono_af discrete power_mono gt i =
  fun_of_map_fun
    (ceta_map_of
      (map (\ (a, b) ->
             let {
               (f, n) = a;
             } in (\ e ->
                    ((f, n),
                      set (filter
                            (\ ia ->
                              check_poly_weak_mono_and_pos discrete e &&
                                check_poly_strict_mono_smart discrete power_mono
                                  gt e ia)
                            (upt zero_nat n))))
               b)
        i))
    (\ fn -> set (upt zero_nat (snd fn)));

check_poly_inter_list ::
  forall a b.
    (Eq a, Eq b,
      Poly_carrier b) => Bool ->
                           [((a, Nat), [([(Nat, Nat)], b)])] ->
                             Sum (Sum ([Prelude.Char] -> [Prelude.Char])
                                   (a, [([(Nat, Nat)], b)]))
                               ();
check_poly_inter_list discrete i =
  bindb (check (distinct (map fst i))
          (Inl (shows_prec_list zero_nat
                 ['s', 'o', 'm', 'e', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ',
                   'h', 'a', 's', ' ', 't', 'w', 'o', ' ', 'i', 'n', 't', 'e',
                   'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', 's'])))
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM
            (\ x ->
              (if let {
                    (_, a) = x;
                  } in check_poly_weak_mono_and_pos discrete a
                then Inr () else Inl x))
            i)
          (\ x -> Inl (snd x)))
        (\ x -> Inl (let {
                       (a, b) = x;
                     } in let {
                            (f, _) = a;
                          } in (\ p -> Inr (f, p))
                            b)));

less_eq_complexity_class :: Complexity_class -> Complexity_class -> Bool;
less_eq_complexity_class x y = less_eq_nat (degree x) (degree y);

strongly_linear ::
  forall a. (Poly_carrier a) => Nat -> [([(Nat, Nat)], a)] -> a -> Bool;
strongly_linear x p v =
  (if equal_nat x zero_nat then check_ge_v v p
    else let {
           a = poly_split [(minus_nat x one_nat, suc zero_nat)] p;
           (aa, pa) = a;
         } in less_eq aa onea && strongly_linear (minus_nat x one_nat) pa v);

sl_complexity_sig_check ::
  forall a b.
    (Poly_carrier b) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                          b -> [(a, Nat)] -> Sum (a, Nat) ();
sl_complexity_sig_check i v f =
  catch_errora
    (forallM (\ (fa, n) -> check (strongly_linear n (i (fa, n)) v) (fa, n)) f)
    (\ x -> Inl (snd x));

sl_complexity_check ::
  forall a b.
    (Poly_carrier a,
      Showa b) => a -> ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                         [(b, Nat)] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
sl_complexity_check v i f =
  let {
    w = max_v v i f;
  } in catch_errora (sl_complexity_sig_check i w f)
         (\ x ->
           Inl (let {
                  (fa, _) = x;
                } in shows_string ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
                       shows_prec zero_nat fa .
                         shows_prec_list zero_nat
                           [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                             'p', 'o', 's', 's', 'e', 's', 's', ' ', 'a', ' ',
                             's', 't', 'r', 'o', 'n', 'g', 'l', 'y', ' ', 'l',
                             'i', 'n', 'e', 'a', 'r', ' ', 'i', 'n', 't', 'e',
                             'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o',
                             'n']));

nl_complexity_check ::
  forall a b c.
    (Showa a,
      Poly_carrier b) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                           Complexity_measure a c ->
                             Complexity_class ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
nl_complexity_check i (Derivational_Complexity f) cc =
  bindb (sl_complexity_check zeroa i f)
    (\ _ ->
      check (less_eq_complexity_class (Comp_Poly one_nat) cc)
        (shows_prec_list zero_nat
          ['c', 'a', 'n', 'n', 'o', 't', ' ', 'd', 'e', 'd', 'u', 'c', 'e', ' ',
            'c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'c', 'o', 'm', 'p',
            'l', 'e', 'x', 'i', 't', 'y', ' ', 'f', 'o', 'r', ' ', 'd', 'e',
            'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'c', 'o',
            'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']));
nl_complexity_check i (Runtime_Complexity c d) (Comp_Poly deg) =
  bindb (sl_complexity_check onea i c)
    (\ _ ->
      catch_errora
        (forallM
          (\ f ->
            check (less_eq_nat (poly_degree (i f)) deg)
              ((shows_prec_list zero_nat
                  ['d', 'e', 'g', 'r', 'e', 'e', ' ', 'o', 'f', ' ', 'i', 'n',
                    't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n',
                    ' ', 'f', 'o', 'r', ' '] .
                 shows_prec_prod zero_nat f) .
                shows_prec_list zero_nat
                  [' ', 'e', 'x', 'c', 'e', 'e', 'd', 's', ' ', 'b', 'o', 'u',
                    'n', 'd', ' ']))
          d)
        (\ x -> Inl (snd x)));

poly_inter_to_af ::
  forall a b.
    (Key a) => [((a, Nat), [([(Nat, Nat)], b)])] -> (a, Nat) -> Set Nat;
poly_inter_to_af i =
  fun_of_map_fun (ceta_map_of (map (\ (fn, e) -> (fn, poly_vars e)) i))
    (\ fn -> set (upt zero_nat (snd fn)));

create_nlpoly_redtriple ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                    a -> (a -> a -> Bool) ->
                           Bool ->
                             Bool ->
                               [((b, Nat), [([(Nat, Nat)], a)])] ->
                                 Redtriple_ext b c ();
create_nlpoly_redtriple cI def gt power_mono discrete i =
  let {
    j = poly_inter_list_to_inter def i;
    x = poly_subst
          (\ n -> poly_of (PVar (['x', '_'] ++ shows_prec_nat zero_nat n [])));
  } in Redtriple_ext
         (bindb cI
           (\ _ ->
             catch_errora (check_poly_inter_list discrete i)
               (\ xa ->
                 Inl (case xa of {
                       Inl a -> id a;
                       Inr (f, p) ->
                         shows_string
                           ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a',
                             't', 'i', 'o', 'n', ' '] .
                           shows_poly (x p) .
                             shows_string [' ', 'o', 'f', ' '] .
                               shows_prec zero_nat f .
                                 shows_string
                                   [' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd',
                                     ' '];
                     }))))
         (check_s gt j) (check_ns j) (check_ns j) (poly_inter_to_af i)
         (poly_inter_to_mono_af discrete power_mono gt i)
         (\ _ ->
           catch_errora
             (catch_errora
               (forallM
                 (\ xa ->
                   (if let {
                         (a, b) = xa;
                       } in let {
                              (_, n) = a;
                            } in (\ p ->
                                   all_interval_nat
                                     (check_poly_strict_mono_smart discrete
                                       power_mono gt p)
                                     zero_nat n)
                              b
                     then Inr () else Inl xa))
                 i)
               (\ xa -> Inl (snd xa)))
             (\ xa ->
               Inl (let {
                      (a, b) = xa;
                    } in let {
                           (f, _) = a;
                         } in (\ p ->
                                shows_string
                                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                    ' ', 'e', 'n', 's', 'u', 'r', 'e', ' ', 'm',
                                    'o', 'n', 'o', 't', 'o', 'n', 'i', 'c', 't',
                                    'y', ' ', 'o', 'f', ' '] .
                                  shows_poly (x p) .
                                    shows_string
                                      [' ', 'a', 's', ' ', 'i', 'n', 't', 'e',
'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                                      shows_prec zero_nat f)
                           b)))
         (shows_string
            ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n',
              't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n'] .
           shows_nl .
             shows_sep
               (\ (a, b) ->
                 let {
                   (f, n) = a;
                 } in (\ p ->
                        shows_string ['P', 'o', 'l', '('] .
                          shows_prec zero_nat f .
                            shows_string ['/'] .
                              shows_prec_nat zero_nat n .
                                shows_string [')', ' ', '=', ' '] .
                                  shows_poly (x p))
                   b)
               shows_nl i)
         (Just (map fst i)) (nl_complexity_check j) ();

pos_arctic_delta :: forall a. (Floor_ceiling a) => Arctic_delta a -> Bool;
pos_arctic_delta MinInfty_delta = False;
pos_arctic_delta (Num_arc_delta n) = less_eq zeroa n;

class_ordered_semiring ::
  forall a b.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => Itself a ->
                       (a -> a -> Bool) ->
                         b -> Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a (Ordered_semiring_ext a b)));
class_ordered_semiring a gt b =
  class_semiring a (Ordered_semiring_ext (\ x y -> less_eq y x) gt max b);

class_arc_complexity ::
  forall a. a -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
class_arc_complexity a deg =
  Inl (shows_prec_list zero_nat
        ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'f', 'o', 'r',
          ' ', 'a', 'r', 'c', 't', 'i', 'c', ' ', 's', 'e', 'm', 'i', 'r', 'i',
          'n', 'g', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r',
          't', 'e', 'd']);

class_arc_lpoly_order ::
  forall a.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => a -> (a -> Bool) ->
                            (a -> a -> Bool) ->
                              Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a
                                    (Ordered_semiring_ext a
                                      (Lpoly_order_semiring_ext a ()))));
class_arc_lpoly_order def apos gt =
  class_ordered_semiring Type gt
    (Lpoly_order_semiring_ext False def apos (\ _ -> False) (\ _ -> zero_nat)
      class_arc_complexity
      ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n', 't',
        'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'v',
        'e', 'r', ' ', 'a', 'r', 'c', 't', 'i', 'c', ' ', 's', 'e', 'm', 'i',
        'r', 'i', 'n', 'g']
      ());

mat_max :: forall a. (Ord a) => Mat a -> Mat a -> Mat a;
mat_max a b =
  mat (mat_dim_row a) (mat_dim_col a)
    (\ ij -> max (mat_index a ij) (mat_index b ij));

mat_ge :: forall a. (Ord a) => Mat a -> Mat a -> Bool;
mat_ge a b =
  all_interval_nat
    (\ i ->
      all_interval_nat
        (\ j -> less_eq (mat_index b (i, j)) (mat_index a (i, j))) zero_nat
        (mat_dim_col a))
    zero_nat (mat_dim_row a);

mat_comp_all :: forall a. (a -> a -> Bool) -> Mat a -> Mat a -> Bool;
mat_comp_all r a b =
  all_interval_nat
    (\ i ->
      all_interval_nat (\ j -> r (mat_index a (i, j)) (mat_index b (i, j)))
        zero_nat (mat_dim_col a))
    zero_nat (mat_dim_row a);

mat_both_ordered_semiring ::
  forall a b.
    (Ordered_semiring_1 a) => Nat ->
                                (a -> a -> Bool) ->
                                  b -> Partial_object_ext (Mat a)
 (Monoid_ext (Mat a) (Ring_ext (Mat a) (Ordered_semiring_ext (Mat a) b)));
mat_both_ordered_semiring n gt b =
  mat_ring Type n (Ordered_semiring_ext mat_ge (mat_comp_all gt) mat_max b);

mat_default :: forall a. (Zero a) => a -> Nat -> Mat a;
mat_default d n = mat n n (\ (i, j) -> (if equal_nat i j then d else zeroa));

mat_arc_complexity ::
  forall a. a -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
mat_arc_complexity m deg =
  Inl (shows_prec_list zero_nat
        ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'f', 'o', 'r',
          ' ', 'a', 'r', 'c', 't', 'i', 'c', ' ', 'm', 'a', 't', 'r', 'i', 'c',
          'e', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
          'e', 'd']);

mat_arc_posI :: forall a. (a -> Bool) -> Mat a -> Bool;
mat_arc_posI ap a = ap (mat_index a (zero_nat, zero_nat));

mat_arc_lpoly_order ::
  forall a.
    (Ordered_semiring_1 a) => Nat ->
                                a -> (a -> Bool) ->
                                       (a -> a -> Bool) ->
 Partial_object_ext (Mat a)
   (Monoid_ext (Mat a)
     (Ring_ext (Mat a)
       (Ordered_semiring_ext (Mat a) (Lpoly_order_semiring_ext (Mat a) ()))));
mat_arc_lpoly_order n def apos gt =
  mat_both_ordered_semiring n gt
    (Lpoly_order_semiring_ext False (mat_default def n) (mat_arc_posI apos)
      (\ _ -> False) (\ _ -> zero_nat) mat_arc_complexity
      ['a', 'r', 'c', 't', 'i', 'c', ' ', 'm', 'a', 't', 'r', 'i', 'x', ' ',
        'i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
      ());

check_arc_dimension :: Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_arc_dimension n =
  check (less_nat zero_nat n)
    (shows_prec_list zero_nat
      ['d', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n', ' ', 'm', 'u', 's', 't',
        ' ', 'b', 'e', ' ', 'a', 't', ' ', 'l', 'e', 'a', 's', 't', ' ', '1']);

class_complexity ::
  forall a.
    (Ordered_semiring_1 a) => a -> Nat ->
                                     Sum ([Prelude.Char] -> [Prelude.Char]) ();
class_complexity a deg =
  check (less_eq a onea)
    (shows_prec_list zero_nat
      ['v', 'a', 'l', 'u', 'e', ' ', 'i', 's', ' ', 'l', 'a', 'r', 'g', 'e',
        'r', ' ', 't', 'h', 'a', 'n', ' ', '1']);

class_lpoly_order ::
  forall a.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => a -> (a -> Bool) ->
                            (a -> a -> Bool) ->
                              Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a
                                    (Ordered_semiring_ext a
                                      (Lpoly_order_semiring_ext a ()))));
class_lpoly_order def mon gt =
  class_ordered_semiring Type gt
    (Lpoly_order_semiring_ext True def (\ _ -> True) mon (\ _ -> zero_nat)
      class_complexity
      ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n', 't',
        'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
      ());

scf_repr_to_scf ::
  forall a. ((a, Nat) -> Maybe [Nat]) -> (a, Nat) -> Nat -> Nat;
scf_repr_to_scf scf fn i = (case scf fn of {
                             Nothing -> one_nat;
                             Just xs -> nth xs i;
                           });

check_scf_entry ::
  forall a.
    (Showa a) => (a, Nat) ->
                   Maybe [Nat] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_scf_entry fn Nothing = Inr ();
check_scf_entry (f, n) (Just es) =
  catch_errora
    (bindb
      (check (equal_nat (size_list es) n)
        (shows_prec_list zero_nat
           ['n', 'r', ' ', 'o', 'f', ' ', 'e', 'n', 't', 'r', 'i', 'e', 's',
             ' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e', ' '] .
          shows_prec_nat zero_nat n))
      (\ _ ->
        check (all (less_nat zero_nat) es)
          (shows_prec_list zero_nat
            ['a', 'l', 'l', ' ', 'e', 'n', 't', 'r', 'i', 'e', 's', ' ', 'm',
              'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n', '-', 'z', 'e',
              'r', 'o'])))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
               's', 'u', 'b', 't', 'e', 'r', 'm', ' ', 'c', 'o', 'e', 'f', 'f',
               'i', 'c', 'i', 'e', 'n', 't', 's', ' ', 'f', 'o', 'r', ' '] .
            shows_prec_prod zero_nat (f, n) .
              shows_prec_list zero_nat [':', ' '] . x . shows_nl));

prec_weight_repr_to_prec_weight ::
  forall a.
    (Eq a, Key a,
      Showa a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    (Sum ([Prelude.Char] -> [Prelude.Char]) (),
                      ((a, Nat) -> Nat,
                        ((a, Nat) -> Nat,
                          (Nat, (a -> Bool, (a, Nat) -> Nat -> Nat)))));
prec_weight_repr_to_prec_weight prw_w0 =
  let {
    (prw, w0) = prw_w0;
    prwm = ceta_map_of prw;
    w_fun = fun_of_map_funa prwm (\ _ -> suc w0) (fst . snd);
    p_fun = fun_of_map_funa prwm (\ _ -> zero_nat) fst;
    scf_fun = fun_of_map_funa prwm (\ _ -> Nothing) (snd . snd);
    fs = map fst prw;
    p_max = max_list (map p_fun fs);
    cw_okay =
      catch_errora
        (forallM
          (\ fn ->
            check (if equal_nat (snd fn) zero_nat then less_eq_nat w0 (w_fun fn)
                    else True)
              (shows_prec_list zero_nat
                 ['w', 'e', 'i', 'g', 'h', 't', ' ', 'o', 'f', ' ', 'c', 'o',
                   'n', 's', 't', 'a', 'n', 't', ' '] .
                shows_prec zero_nat (fst fn) .
                  shows_prec_list zero_nat
                    [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', 't', ' ',
                      'l', 'e', 'a', 's', 't', ' ', 'w', '0']))
          (map fst prw))
        (\ x -> Inl (snd x));
    adm = catch_errora
            (forallM
              (\ fn ->
                check (if equal_nat (snd fn) one_nat
                        then (if equal_nat (w_fun fn) zero_nat
                               then equal_nat (p_fun fn) p_max else True)
                        else True)
                  (shows_prec_list zero_nat
                     ['u', 'n', 'a', 'r', 'y', ' ', 's', 'y', 'm', 'b', 'o',
                       'l', ' '] .
                    shows_prec zero_nat (fst fn) .
                      shows_prec_list zero_nat
                        [' ', 'w', 'i', 't', 'h', ' ', 'w', 'e', 'i', 'g', 'h',
                          't', ' ', '0', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o',
                          't', ' ', 'h', 'a', 'v', 'e', ' ', 'm', 'a', 'x', 'i',
                          'm', 'a', 'l', ' ', 'p', 'r', 'e', 'c', 'e', 'd', 'e',
                          'n', 'c', 'e']))
              (map fst prw))
            (\ x -> Inl (snd x));
    scf_ok =
      catch_errora
        (forallM (\ fn -> check_scf_entry fn (scf_fun fn)) (map fst prw))
        (\ x -> Inl (snd x));
    cs = map_filter
           (\ x ->
             (if equal_nat (snd x) zero_nat && equal_nat (w_fun x) w0
               then Just (fst x) else Nothing))
           fs;
    p_min = min_list (map (\ c -> p_fun (c, zero_nat)) cs);
    lcs = filter (\ c -> equal_nat (p_fun (c, zero_nat)) p_min) cs;
    least = membera lcs;
    ok = bindb (check (less_nat zero_nat w0)
                 (shows_prec_list zero_nat
                   ['w', '0', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'l',
                     'a', 'r', 'g', 'e', 'r', ' ', 't', 'h', 'a', 'n', ' ',
                     '0']))
           (\ _ -> bindb adm (\ _ -> bindb cw_okay (\ _ -> scf_ok)));
  } in (ok, (p_fun, (w_fun, (w0, (least, scf_repr_to_scf scf_fun)))));

create_KBO_redtriple ::
  forall a b c.
    (Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => (([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    ([((b, Nat), (Nat, (Nat, Maybe [Nat])))], Nat)) ->
                    ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                      Redtriple_ext b c ();
create_KBO_redtriple f_to_g pr =
  let {
    (ch, (p, (w, (w0, (least, scf))))) =
      prec_weight_repr_to_prec_weight (f_to_g pr);
    ns = kbo_nstrict p w w0 least scf;
    s = kbo_strict p w w0 least scf;
  } in Redtriple_ext ch s ns ns full_af full_af (\ _ -> Inr ())
         (shows_kbo_repr pr) (Just []) no_complexity_check ();

check_dimensions ::
  Nat ->
    Nat ->
      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dimensions n sd c =
  bindb c
    (\ _ ->
      check (less_eq_nat sd n && less_nat zero_nat sd)
        (shows_prec_list zero_nat
          ['s', 't', 'r', 'i', 'c', 't', ' ', 'd', 'i', 'm', 'e', 'n', 's', 'i',
            'o', 'n', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', 't',
            ' ', 'l', 'e', 'a', 's', 't', ' ', '1', ' ', 'a', 'n', 'd', ' ',
            'l', 'e', 's', 's', ' ', 't', 'h', 'a', 'n', ' ', 't', 'o', 't',
            'a', 'l', ' ', 'd', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n']));

fpair_f :: forall a. Filtered a -> a;
fpair_f (FPair x1 x2) = x1;

check_mono_afs ::
  forall a.
    (Ceq a, Ccompare a) => Afs a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_mono_afs pi =
  check (mono_afs pi)
    (shows_prec_list zero_nat
      ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f', 'i', 'l', 't', 'e',
        'r', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'm', 'o', 'n', 'o', 't',
        'o', 'n', 'e']);

shows_afs ::
  forall a.
    (Showa a) => [((a, Nat), Af_entry)] -> [Prelude.Char] -> [Prelude.Char];
shows_afs af =
  foldr (\ (a, b) ->
          let {
            (f, n) = a;
          } in (\ e ->
                 (((((shows_prec_list zero_nat ['p', 'i', '('] .
                       shows_prec zero_nat f) .
                      shows_prec_list zero_nat ['/']) .
                     shows_prec_nat zero_nat n) .
                    shows_prec_list zero_nat [')', ' ', '=', ' ']) .
                   (case e of {
                     Collapse i -> shows_prec_nat zero_nat (suc i);
                     AFList ids -> shows_prec_list zero_nat (map suc ids);
                   })) .
                   shows_nl)
            b)
    af;

afs_to_af :: forall a. (Key a) => Afs a -> (a, Nat) -> Set Nat;
afs_to_af pi fn =
  (case afsa pi fn of {
    Collapse j -> inserta j (set_empty (of_phantom set_impl_nat));
    AFList a -> set a;
  });

afs_check ::
  forall a b.
    (Showa a,
      Showa b) => ([Prelude.Char] -> [Prelude.Char]) ->
                    Afs a ->
                      ((Term (Filtered a) b, Term (Filtered a) b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
afs_check r pi g lr =
  let {
    pl = afs_term pi (fst lr);
    pr = afs_term pi (snd lr);
  } in catch_errora (g (pl, pr))
         (\ x ->
           Inl (shows_string
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r',
                    'i', 'e', 'n', 't', ' '] .
                 shows_prec_term zero_nat (fst lr) .
                   shows_string [' '] .
                     r . shows_string [' '] .
                           shows_prec_term zero_nat (snd lr) .
                             shows_nl .
                               shows_string ['p', 'i', '(', ' '] .
                                 shows_prec_term zero_nat (fst lr) .
                                   shows_string [' ', ')', ' ', '=', ' '] .
                                     shows_prec_term zero_nat pl .
                                       shows_nl .
 shows_string ['p', 'i', '(', ' '] .
   shows_prec_term zero_nat (snd lr) .
     shows_string [' ', ')', ' ', '=', ' '] .
       shows_prec_term zero_nat pr . shows_nl . x));

af_redtriple ::
  forall a b.
    (Ceq a, Ccompare a, Key a, Set_impl a, Showa a,
      Showa b) => [((a, Nat), Af_entry)] ->
                    Redtriple_ext (Filtered a) b () -> Redtriple_ext a b ();
af_redtriple pi rp =
  let {
    afso = afs_of pi;
    afs = the afso;
    af = afs_to_af afs;
  } in Redtriple_ext
         (bindb
           (check (not (is_none afso))
             (shows_prec_list zero_nat
               ['i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'p', 'o', 's', 'i', 't',
                 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ', 'a', 'r', 'g', 'u',
                 'm', 'e', 'n', 't', ' ', 'f', 'i', 'l', 't', 'e', 'r']))
           (\ _ -> valid rp))
         (afs_check (shows_prec_list zero_nat ['>']) afs (s rp))
         (afs_check (shows_prec_list zero_nat ['>', '=']) afs (ns rp))
         (afs_check (shows_prec_list zero_nat ['>', '=']) afs (nst rp)) af
         empty_af
         (\ cs ->
           bindb (check_mono_afs afs) (\ _ -> mono rp (map (afs_rule afs) cs)))
         ((((shows_prec_list zero_nat
               ['A', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'F', 'i', 'l', 't',
                 'e', 'r', ':', ' '] .
              shows_nl) .
             shows_afs pi) .
            shows_nl) .
           desc rp)
         (map_option (\ fs -> map fst pi ++ map (\ (f, a) -> (fpair_f f, a)) fs)
           (not_ws_ns rp))
         no_complexity_check ();

pos_arctic :: Arctic -> Bool;
pos_arctic MinInfty = False;
pos_arctic (Num_arc n) = less_eq_int zero_int n;

delta_mono :: forall a. (Floor_ceiling a) => a -> Bool;
delta_mono x = less_eq onea x;

mat_gt ::
  forall a. (Ord a) => (a -> a -> Bool) -> Nat -> Mat a -> Mat a -> Bool;
mat_gt gt sd a b =
  mat_ge a b &&
    not (all_interval_nat
          (not .
            (\ i ->
              not (all_interval_nat
                    (not .
                      (\ j -> gt (mat_index a (i, j)) (mat_index b (i, j))))
                    zero_nat sd)))
          zero_nat sd);

mat_ordered_semiring ::
  forall a b.
    (Ordered_semiring_1 a) => Nat ->
                                Nat ->
                                  (a -> a -> Bool) ->
                                    b -> Partial_object_ext (Mat a)
   (Monoid_ext (Mat a) (Ring_ext (Mat a) (Ordered_semiring_ext (Mat a) b)));
mat_ordered_semiring n sd gt b =
  mat_ring Type n (Ordered_semiring_ext mat_ge (mat_gt gt sd) mat_max b);

gauss_jordan_main ::
  forall a. (Field a, Eq a) => Mat a -> Mat a -> Nat -> Nat -> (Mat a, Mat a);
gauss_jordan_main a b i j =
  let {
    nr = mat_dim_row a;
    nc = mat_dim_col a;
  } in (if less_nat i nr && less_nat j nc
         then let {
                aij = mat_index a (i, j);
              } in (if aij == zeroa
                     then (case concatMap
                                  (\ ia ->
                                    (if not (mat_index a (ia, j) == zeroa)
                                      then [ia] else []))
                                  (upt (suc i) nr)
                            of {
                            [] -> gauss_jordan_main a b i (suc j);
                            ia : _ ->
                              gauss_jordan_main (mat_swaprows i ia a)
                                (mat_swaprows i ia b) i j;
                          })
                     else (if aij == onea
                            then let {
                                   is = filter (\ ia -> not (equal_nat ia i))
  (upt zero_nat nr);
                                 } in gauss_jordan_main
(eliminate_entries_gen plus times uminusa zeroa a a i j is)
(eliminate_entries_gen plus times uminusa zeroa a b i j is) (suc i) (suc j)
                            else let {
                                   iaij = inverse aij;
                                 } in gauss_jordan_main
(mat_multrow_gen times i iaij a) (mat_multrow_gen times i iaij b) i j))
         else (a, b));

gauss_jordan :: forall a. (Field a, Eq a) => Mat a -> Mat a -> (Mat a, Mat a);
gauss_jordan a b = gauss_jordan_main a b zero_nat zero_nat;

gauss_jordan_single :: forall a. (Field a, Eq a) => Mat a -> Mat a;
gauss_jordan_single a =
  fst (gauss_jordan a (mat_zero (mat_dim_row a) zero_nat));

kernel_dim :: forall a. (Field a, Eq a) => Mat a -> Nat;
kernel_dim a =
  minus_nat (mat_dim_col a)
    (size_list (pivot_positions_gen zeroa (gauss_jordan_single a)));

dim_gen_eigenspace :: forall a. (Field a, Eq a) => Mat a -> a -> Nat -> Nat;
dim_gen_eigenspace a ev k = kernel_dim (mat_pow (char_matrix a ev) k);

compute_set_of_jordan_blocks ::
  forall a. (Field a, Eq a) => Mat a -> a -> [(Nat, a)];
compute_set_of_jordan_blocks a ev =
  let {
    k = order ev (char_poly a);
    asa = map (dim_gen_eigenspace a ev) (upt zero_nat (suc (suc k)));
    aa = map (\ ka ->
               (ka, minus_nat
                      (minus_nat
                        (times_nat (nat_of_integer (2 :: Integer)) (nth asa ka))
                        (nth asa (minus_nat ka one_nat)))
                      (nth asa (suc ka))))
           (upt one_nat (suc k));
  } in map_filter
         (\ x ->
           (if let {
                 (_, c) = x;
               } in not (equal_nat c zero_nat)
             then Just (let {
                          (ka, _) = x;
                        } in (ka, ev))
             else Nothing))
         aa;

is_norm_le_1 :: Complex -> Bool;
is_norm_le_1 z =
  less_eq_real
    (plus_real (binary_power (re z) (nat_of_integer (2 :: Integer)))
      (binary_power (im z) (nat_of_integer (2 :: Integer))))
    one_real;

is_norm_1 :: Complex -> Bool;
is_norm_1 z =
  equal_real
    (plus_real (binary_power (re z) (nat_of_integer (2 :: Integer)))
      (binary_power (im z) (nat_of_integer (2 :: Integer))))
    one_real;

analyse_evs ::
  Nat -> Mat Complex -> [Complex] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
analyse_evs d a evs =
  catch_errora
    (forallM
      (\ e ->
        bindb (check (is_norm_le_1 e)
                (shows_prec_list zero_nat
                   ['d', 'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'e', 'i', 'g',
                     'e', 'n', 'v', 'a', 'l', 'u', 'e', ' ', 'w', 'i', 't', 'h',
                     ' ', 'n', 'o', 'r', 'm', ' ', '>', ' ', '1', ':', ' '] .
                  shows_prec_complex zero_nat e))
          (\ _ ->
            (if is_norm_1 e
              then catch_errora
                     (forallM
                       (\ (n, _) ->
                         check (less_eq_nat n d)
                           (((shows_prec_list zero_nat
                                ['d', 'e', 't', 'e', 'c', 't', 'e', 'd', ' ',
                                  'J', 'o', 'r', 'd', 'a', 'n', '-', 'B', 'l',
                                  'o', 'c', 'k', ' ', 'o', 'f', ' ', 's', 'i',
                                  'z', 'e', ' '] .
                               shows_prec_nat zero_nat n) .
                              shows_prec_list zero_nat
                                [' ', 'f', 'o', 'r', ' ', 'e', 'i', 'g', 'e',
                                  'n', 'v', 'a', 'l', 'u', 'e', ' ']) .
                             shows_prec_complex zero_nat e))
                       (compute_set_of_jordan_blocks a e))
                     (\ x -> Inl (snd x))
              else Inr ())))
      evs)
    (\ x -> Inl (snd x));

to_rat_radt :: Real_alg_dt -> Maybe Rat;
to_rat_radt (Rationala r) = Just r;
to_rat_radt (Irrational rai) =
  let {
    (p, _) = info_rai (normalize_rai Root_Free rai);
  } in (if equal_nat (degreea p) one_nat
         then Just (uminus_rat (coeff p zero_nat)) else Nothing);

to_rat_radtc :: Real_alg_dtc -> Maybe Rat;
to_rat_radtc xa = to_rat_radt (rep_real_alg_dtc xa);

to_rat_real_alg_main :: Real_alg -> Maybe Rat;
to_rat_real_alg_main (Abstr_real_alg xa) = to_rat_radtc xa;

is_rat_real_alg :: Real_alg -> Bool;
is_rat_real_alg x = (case to_rat_real_alg_main x of {
                      Nothing -> False;
                      Just _ -> True;
                    });

is_rat_real :: Real -> Bool;
is_rat_real (Real_of x) = is_rat_real_alg x;

is_rat_complex :: Complex -> Bool;
is_rat_complex x = is_rat_real (re x) && equal_real (im x) zero_real;

poly_adda ::
  forall a. (Field a, Eq a, Idom_div a) => Poly a -> Poly a -> Poly a;
poly_adda p q = resultant (poly_x_minus_y p) (poly_lift q);

root_poly_Re :: Poly Rat -> Poly Rat;
root_poly_Re p =
  poly_mult_rat (divide_rat one_rat (of_int (Int_of_integer (2 :: Integer))))
    (poly_adda p p);

poly_1_2i :: Poly Rat;
poly_1_2i =
  pCons (inverse_rat (of_int (Int_of_integer (4 :: Integer))))
    (pCons zero_rat (pCons one_rat zero_polya));

poly_multb ::
  forall a. (Field a, Eq a, Idom_div a) => Poly a -> Poly a -> Poly a;
poly_multb p q = resultant (poly_x_div_y p) (poly_lift q);

poly_multa ::
  forall a. (Field a, Eq a, Idom_div a) => Poly a -> Poly a -> Poly a;
poly_multa p q =
  poly_multb (eliminate_zero_divisors p) (eliminate_zero_divisors q);

root_poly_Im :: Poly Rat -> [Poly Rat];
root_poly_Im p =
  let {
    fs = factors_of_rat_poly Uncertified_Factorization
           (poly_adda p (poly_uminus p));
  } in remdups
         (if any (\ f -> equal_rat (coeff f zero_nat) zero_rat) fs
           then [pCons zero_rat (pCons one_rat zero_polya)] else []) ++
         map (poly_multa poly_1_2i) fs;

radtc_of_rai :: Real_alg_intern -> Real_alg_dtc;
radtc_of_rai xa = Abs_real_alg_dtc (real_alg_dt xa);

roots_of_radtc :: Poly Rat -> [Real_alg_dtc];
roots_of_radtc p = map radtc_of_rai (roots_of_rai p);

roots_of_real_alg :: Poly Rat -> [Real_alg];
roots_of_real_alg x = map Abstr_real_alg (roots_of_radtc x);

real_roots_of_rat_poly3 :: Poly Rat -> [Real];
real_roots_of_rat_poly3 p = map Real_of (roots_of_real_alg p);

real_roots_of_rat_poly_all :: Poly Rat -> [Real];
real_roots_of_rat_poly_all p =
  let {
    n = degreea p;
  } in (if less_eq_nat (nat_of_integer (3 :: Integer)) n
         then real_roots_of_rat_poly3 p
         else (if equal_nat n one_nat then [roots1 (map_poly of_rat p)]
                else (if equal_nat n (nat_of_integer (2 :: Integer))
                       then rroots2 (map_poly of_rat p) else [])));

real_roots_of_rat_poly :: Poly Rat -> [Real];
real_roots_of_rat_poly p =
  let {
    a = (if less_eq_nat (nat_of_integer (3 :: Integer)) (degreea p)
          then factors_of_rat_poly Uncertified_Factorization p else [p]);
  } in concatMap real_roots_of_rat_poly_all a;

sign_changes_inf_rat :: [Poly Rat] -> Nat;
sign_changes_inf_rat ps =
  minus_nat
    (size_list
      (remdups_adj
        (filter (\ x -> not (equal_rat x zero_rat)) (map poly_inf_rat ps))))
    one_nat;

count_roots_rat :: Poly Rat -> Nat;
count_roots_rat p =
  (if (equal_poly :: Poly Real -> Poly Real -> Bool)
        ((map_poly :: (Rat -> Real) -> Poly Rat -> Poly Real)
          (of_rat :: Rat -> Real) p)
        (zero_polya :: Poly Real)
    then zero_nat
    else let {
           ps = sturm_squarefree_rat p;
         } in minus_nat (sign_changes_neg_inf_rat ps)
                (sign_changes_inf_rat ps));

complex_roots_of_rat_poly3 :: Poly Rat -> [Complex];
complex_roots_of_rat_poly3 p =
  let {
    n = degreea p;
    rr = count_roots_rat p;
    rrts = real_roots_of_rat_poly3 p;
    rrtsa = (if equal_nat (size_list rrts) rr then rrts else remdups rrts);
    crts = map (\ r -> Complex r zero_real) rrtsa;
  } in (if equal_nat n rr then crts
         else (if equal_nat (minus_nat n rr) (nat_of_integer (2 :: Integer))
                then let {
                       pp = divide_poly (map_poly of_rat p)
                              (listprod
                                (map (\ x ->
                                       pCons (uminus_real x)
 (pCons one_real zero_polya))
                                  rrtsa));
                       cpp = map_poly (\ r -> Complex r zero_real) pp;
                     } in crts ++ croots2 cpp
                else let {
                       rp = root_poly_Re p;
                       ip = root_poly_Im p;
                       rxs = real_roots_of_rat_poly rp;
                       ixs = remdups
                               (filter (less_real zero_real)
                                 (concatMap real_roots_of_rat_poly ip));
                       rts = concatMap (\ rx -> map (Complex rx) ixs) rxs;
                       crtsa =
                         filter
                           (\ c ->
                             equal_complex (eval_polya of_rat p c) zero_complex)
                           rts;
                     } in crts ++ crtsa ++ map cnj crtsa));

complex_roots_of_rat_poly_all :: Poly Rat -> [Complex];
complex_roots_of_rat_poly_all p =
  let {
    n = degreea p;
  } in (if less_eq_nat (nat_of_integer (3 :: Integer)) n
         then complex_roots_of_rat_poly3 p
         else (if equal_nat n one_nat then [roots1 (map_poly of_rat p)]
                else (if equal_nat n (nat_of_integer (2 :: Integer))
                       then croots2 (map_poly of_rat p) else [])));

complex_roots_of_rat_poly :: Poly Rat -> [Complex];
complex_roots_of_rat_poly p =
  let {
    a = (if less_eq_nat (nat_of_integer (3 :: Integer)) (degreea p)
          then factors_of_rat_poly Uncertified_Factorization p else [p]);
  } in concatMap complex_roots_of_rat_poly_all a;

to_rat_real_alg :: Real_alg -> Rat;
to_rat_real_alg x = (case to_rat_real_alg_main x of {
                      Nothing -> zero_rat;
                      Just q -> q;
                    });

to_rat_real :: Real -> Rat;
to_rat_real (Real_of x) = to_rat_real_alg x;

to_rat_complex :: Complex -> Rat;
to_rat_complex x =
  (if is_rat_real (re x) && equal_real (im x) zero_real then to_rat_real (re x)
    else zero_rat);

roots_of_complex_main :: Poly Complex -> [Complex];
roots_of_complex_main p =
  let {
    n = degreea p;
  } in (if equal_nat n zero_nat then []
         else (if equal_nat n one_nat then [roots1 p]
                else (if equal_nat n (nat_of_integer (2 :: Integer))
                       then croots2 p
                       else complex_roots_of_rat_poly
                              (map_poly to_rat_complex p))));

roots_of_complex_poly :: Poly Complex -> Maybe [Complex];
roots_of_complex_poly p =
  let {
    (c, pis) = yun_factorization gcd_poly p;
  } in (if not (equal_complex c zero_complex) &&
             all (\ (pa, _) ->
                   less_eq_nat (degreea pa) (nat_of_integer (2 :: Integer)) ||
                     all is_rat_complex (coeffs pa))
               pis
         then Just (concatMap (roots_of_complex_main . fst) pis) else Nothing);

approximate_jordan_blocks_complex_mat ::
  Nat -> Mat Complex -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
approximate_jordan_blocks_complex_mat d a =
  let {
    _ = mat_dim_row a;
    cp = char_poly a;
    evso = roots_of_complex_poly cp;
  } in catch_errora
         (bindb
           (check (not (is_none evso))
             (shows_prec_list zero_nat
               ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'd', 'e', 't',
                 'e', 'r', 'm', 'i', 'n', 'e', ' ', 'E', 'i', 'g', 'e', 'n',
                 'v', 'a', 'l', 'u', 'e', 's']))
           (\ _ -> analyse_evs d a (the evso)))
         (\ x ->
           Inl (((((shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'e', 's', 't', 'i', 'm', 'a', 't', 'i', 'n', 'g', ' ',
                        'g', 'r', 'o', 'w', 't', 'h', ' ', 'r', 'a', 't', 'e',
                        ' ', 'o', 'f', ' ', 'm', 'a', 't', 'r', 'i', 'x',
                        '\n'] .
                     shows_prec_mat zero_nat a) .
                    shows_prec_list zero_nat
                      ['\n', 'w', 'i', 't', 'h', ' ', 'c', 'h', 'a', 'r', 'a',
                        'c', 't', 'e', 'r', 'i', 's', 't', 'i', 'c', ' ', 'p',
                        'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ']) .
                   shows_prec_poly zero_nat cp) .
                  shows_nl) .
                 x));

count_ones_check :: Mat Real -> Nat -> Bool;
count_ones_check a d =
  upper_triangular a &&
    let {
      diag = mat_diag a;
    } in all (\ aa ->
               less_eq_real (abs_real aa) one_real &&
                 (if equal_real (abs_real aa) one_real
                   then less_eq_nat (size_list (filter (equal_real aa) diag)) d
                   else True))
           diag;

of_real :: forall a. (Real_algebra_1 a) => Real -> a;
of_real r = scaleR r onea;

approximate_jordan_blocks_real_mat ::
  [Complex] ->
    [Poly Complex] ->
      Nat -> Mat Real -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
approximate_jordan_blocks_real_mat csamples cpsamples d a =
  (if count_ones_check a d then Inr ()
    else approximate_jordan_blocks_complex_mat d (mat_map of_real a));

mat_estimate_complexity_jb ::
  forall a.
    (Large_real_ordered_semiring_1 a) => Nat ->
   Mat a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
mat_estimate_complexity_jb d a =
  let {
    b = mat_map real_of a;
  } in bindb (check (equal_nat (mat_dim_row a) (mat_dim_col a))
               (shows_prec_list zero_nat
                  ['e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 's', 'q', 'u',
                    'a', 'r', 'e', ' ', 'm', 'a', 't', 'r', 'i', 'x', ' ', 'b',
                    'u', 't', ' ', 'g', 'o', 't', ' ', '\n'] .
                 shows_prec_mat zero_nat b))
         (\ _ -> approximate_jordan_blocks_real_mat [] [] d b);

mat_complexity ::
  forall a.
    (Large_real_ordered_semiring_1 a) => Nat ->
   Mat a -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
mat_complexity n m d = mat_estimate_complexity_jb (suc d) m;

mat_mono :: forall a. (a -> Bool) -> Nat -> Mat a -> Bool;
mat_mono mon sd a =
  all_interval_nat
    (\ j ->
      not (all_interval_nat (not . (\ i -> mon (mat_index a (i, j)))) zero_nat
            sd))
    zero_nat sd;

mat_lpoly_order ::
  forall a.
    (Large_real_ordered_semiring_1 a) => Nat ->
   Nat ->
     a -> (a -> Bool) ->
            (a -> a -> Bool) ->
              Partial_object_ext (Mat a)
                (Monoid_ext (Mat a)
                  (Ring_ext (Mat a)
                    (Ordered_semiring_ext (Mat a)
                      (Lpoly_order_semiring_ext (Mat a) ()))));
mat_lpoly_order n sd def mon gt =
  mat_ordered_semiring n sd gt
    (Lpoly_order_semiring_ext True (mat_default def n) (\ _ -> True)
      (mat_mono mon sd) (\ _ -> zero_nat) (mat_complexity n)
      ['m', 'a', 't', 'r', 'i', 'x', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r',
        'e', 't', 'a', 't', 'i', 'o', 'n']
      ());

int_mono :: Int -> Bool;
int_mono x = less_eq_int (Int_of_integer (1 :: Integer)) x;

delta_gt :: forall a. (Floor_ceiling a) => a -> a -> a -> Bool;
delta_gt delta = (\ x y -> less_eq delta (minus x y));

check_def_pos ::
  forall a. (Zero a, Ord a) => a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_def_pos d =
  check (less zeroa d)
    (shows_prec_list zero_nat
      ['d', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'v', 'a', 'l', 'u', 'e', ' ',
        'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'p', 'o', 's', 'i', 't', 'i',
        'v', 'e']);

rpo_nstrict_unbounded ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                    ((a, Nat) -> Order_tag) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
rpo_nstrict_unbounded pr c =
  (\ (s, t) ->
    check (snd (rpo_unbounded pr c s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term zero_nat s .
          shows_string [' ', '>', '=', 'R', 'P', 'O', ' '] .
            shows_prec_term zero_nat t . shows_nl));

rpo_strict_unbounded ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                    ((a, Nat) -> Order_tag) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
rpo_strict_unbounded pr c =
  (\ (s, t) ->
    check (fst (rpo_unbounded pr c s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term zero_nat s .
          shows_string [' ', '>', 'R', 'P', 'O', ' '] .
            shows_prec_term zero_nat t . shows_nl));

create_RPO_redtriple ::
  forall a b c.
    (Showa a, Eq b, Showa b, Eq c,
      Showa c) => ([((a, Nat), (Nat, Order_tag))] ->
                    ((b, Nat) -> Nat, (b, Nat) -> Order_tag)) ->
                    [((a, Nat), (Nat, Order_tag))] -> Redtriple_ext b c ();
create_RPO_redtriple prec_repr_to_pr pr =
  let {
    (p, tau) = prec_repr_to_pr pr;
    ns = rpo_nstrict_unbounded (prc_nat p, prl_nat p) tau;
  } in Redtriple_ext (Inr ()) (rpo_strict_unbounded (prc_nat p, prl_nat p) tau)
         ns ns full_af full_af (\ _ -> Inr ()) (shows_rpo_repr pr) (Just [])
         no_complexity_check ();

get_redtriple ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => Redtriple_impl a -> Redtriple_ext a [Prelude.Char] ();
get_redtriple (Int_carrier i) =
  create_poly_redtriple
    (class_lpoly_order (Int_of_integer (1 :: Integer)) int_mono
      (\ x y -> less_int y x))
    (Inr ()) i;
get_redtriple (Int_nl_carrier i) =
  create_nlpoly_redtriple (Inr ()) (Int_of_integer (1 :: Integer))
    (\ x y -> less_int y x) True True i;
get_redtriple (Rat_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_rat delta_mono (\ x y -> less_rat y x))
    (check_def_pos one_rat) i;
get_redtriple (Rat_nl_carrier d i) =
  create_nlpoly_redtriple (check_def_pos d) d (delta_gt d)
    (less_eq_rat one_rat d) False i;
get_redtriple (Real_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_real delta_mono (\ x y -> less_real y x))
    (check_def_pos one_real) i;
get_redtriple (Real_nl_carrier d i) =
  create_nlpoly_redtriple (check_def_pos d) d (delta_gt d)
    (less_eq_real one_real d) False i;
get_redtriple (Arctic_carrier i) =
  create_poly_redtriple
    (class_arc_lpoly_order one_arctic pos_arctic (\ x y -> less_arctic y x))
    (Inr ()) i;
get_redtriple (Arctic_rat_carrier i) =
  create_poly_redtriple
    (class_arc_lpoly_order one_arctic_delta pos_arctic_delta
      weak_gt_arctic_delta)
    (Inr ()) i;
get_redtriple (Int_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd (Int_of_integer (1 :: Integer)) int_mono
      (\ x y -> less_int y x))
    (check_dimensions n sd (Inr ())) i;
get_redtriple (Rat_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_rat delta_mono (\ x y -> less_rat y x))
    (check_dimensions n sd (check_def_pos one_rat)) i;
get_redtriple (Real_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_real delta_mono (\ x y -> less_real y x))
    (check_dimensions n sd (check_def_pos one_real)) i;
get_redtriple (Arctic_mat_carrier n i) =
  create_poly_redtriple
    (mat_arc_lpoly_order n one_arctic pos_arctic (\ x y -> less_arctic y x))
    (check_arc_dimension n) i;
get_redtriple (Arctic_rat_mat_carrier n i) =
  create_poly_redtriple
    (mat_arc_lpoly_order n one_arctic_delta pos_arctic_delta
      weak_gt_arctic_delta)
    (check_arc_dimension n) i;
get_redtriple (RPO prec_tau pi) =
  af_redtriple pi
    (create_RPO_redtriple (\ pr -> (prec_repr_to_pr pr, prec_repr_to_status pr))
      prec_tau);
get_redtriple (KBO precw pi) =
  af_redtriple pi
    (create_KBO_redtriple
      (filter_prec_weight_repr
        (fun_of_map_fun (ceta_map_of pi) (\ fn -> default_af_entry (snd fn))))
      precw);
get_redtriple (WPO params rp) = wpo_redtriple (get_redtriple rp) params;

list_ext_name :: List_order_type -> [Prelude.Char];
list_ext_name MS_Ext = ['M', 'S'];
list_ext_name Dms_Ext = ['D', 'M', 'S'];
list_ext_name Min_Ext = ['M', 'I', 'N'];
list_ext_name Max_Ext = ['M', 'A', 'X'];

lifta :: (Bool, Bool) -> (Bool, Bool);
lifta (uu, b) = (b, b);

or2 :: (Bool, Bool) -> (Bool, Bool) -> (Bool, Bool);
or2 (b1, b2) (b3, b4) = (b1 || b3, b2 || b4);

mul_ext_impl ::
  forall a. (Eq a) => (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
mul_ext_impl f [] [] = (False, True);
mul_ext_impl f [] (v : va) = (False, False);
mul_ext_impl f (v : va) [] = (True, True);
mul_ext_impl f (v : va) (y : ys) = ex_dominating f y (v : va) (v : va) ys;

ex_dominating ::
  forall a.
    (Eq a) => (a -> a -> (Bool, Bool)) ->
                a -> [a] -> [a] -> [a] -> (Bool, Bool);
ex_dominating f y [] uw ux = (False, False);
ex_dominating f y (b : bs) xs ys =
  (case f b y of {
    (True, _) ->
      or2 (lifta
            (mul_ext_impl f (remove1 b xs)
              (filter (\ ya -> not (fst (f b ya))) ys)))
        (ex_dominating f y bs xs ys);
    (False, True) ->
      or2 (mul_ext_impl f (remove1 b xs) ys) (ex_dominating f y bs xs ys);
    (False, False) -> ex_dominating f y bs xs ys;
  });

dms_preprocess :: [[(Nat, (Bool, Bool))]] -> [[(Nat, (Bool, Bool))]];
dms_preprocess p = map (filter (\ (_, a) -> let {
      (aa, b) = a;
    } in aa || b))
                     p;

dms_simplify ::
  Bool -> [Nat] -> [[(Nat, (Bool, Bool))]] -> [[(Nat, (Bool, Bool))]];
dms_simplify stri is p = (if any (\ i -> null (nth p i)) is then [[]] else p);

dms_decide_singletons :: Bool -> Nat -> [(Nat, (Bool, Bool))] -> Bool;
dms_decide_singletons stri n p =
  all_interval_nat
    (\ i ->
      let {
        (j, (s, ns)) = nth p i;
      } in s && not (membera (drop (suc i) p) (j, (False, True))) ||
             ns && not (membera (map fst (drop (suc i) p)) j))
    zero_nat (size_list p) &&
    (if stri
      then not (all_interval_nat
                 (not . (\ j -> not (membera p (j, (False, True))))) zero_nat n)
      else True);

dms_select :: Bool -> [[(Nat, (Bool, Bool))]] -> Nat;
dms_select stri p =
  snd (hda (sort_key fst
             (filter (\ (l, _) -> less_nat one_nat l)
               (zip (map size_list p) (upt zero_nat (size_list p))))));

dms_solve_or_select :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Sum Bool Nat;
dms_solve_or_select stri n p =
  (if all (\ jsns -> less_eq_nat (size_list jsns) one_nat) p
    then Inl (if membera p [] then False
               else dms_decide_singletons stri n (map hda p))
    else Inr (dms_select stri p));

dms_solve :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_solve stri n p =
  (case dms_solve_or_select stri n p of {
    Inl res -> res;
    Inr k ->
      let {
        ksns = nth p k;
      } in dms_solve stri n
             (dms_simplify stri [k] (list_update p k [hda ksns])) ||
             dms_solve stri n
               (dms_simplify stri [k] (list_update p k (tla ksns)));
  });

dms_bool_ex_idx_impl :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_bool_ex_idx_impl stri n p =
  dms_solve stri n
    (dms_simplify stri (upt zero_nat (size_list p)) (dms_preprocess p));

dms_bool_ex_idx :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_bool_ex_idx = dms_bool_ex_idx_impl;

dms_convert ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> [[(Nat, (Bool, Bool))]];
dms_convert f asa bs = let {
                         jbs = zip (upt zero_nat (size_list bs)) bs;
                       } in map (\ a -> map (\ (j, b) -> (j, f a b)) jbs) asa;

dms_order_ext ::
  forall a. Nat -> (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
dms_order_ext n f asa bs =
  let {
    p = dms_convert f asa bs;
    lts = size_list bs;
    len = less_eq_nat lts n || equal_nat (size_list asa) lts;
  } in (len && dms_bool_ex_idx True lts p, len && dms_bool_ex_idx False lts p);

min_set_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
min_set_ext s_ns =
  (\ asa bs ->
    (not (null bs) && all (\ a -> any (\ b -> fst (s_ns a b)) bs) asa,
      all (\ a -> any (\ b -> snd (s_ns a b)) bs) asa));

list_ext ::
  forall a.
    (Eq a) => Nat ->
                List_order_type ->
                  (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
list_ext uu MS_Ext = mul_ext_impl;
list_ext uv Max_Ext = set_ext;
list_ext uw Min_Ext = min_set_ext;
list_ext n Dms_Ext = dms_order_ext n;

label_s_ns_impl ::
  forall a b.
    (Showa a,
      Showa b) => ((Term a b, Term a b) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    ((Term a b, Term a b) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool);
label_s_ns_impl cS cNS s t =
  let {
    (sa, i) = s;
    (ta, j) = t;
  } in (if isOK (cS (sa, ta)) then (True, True)
         else (if isOK (cNS (sa, ta)) then (less_nat j i, less_eq_nat j i)
                else (False, False)));

nST_label_mul_impl ::
  forall a b.
    (Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    ((a, Nat) -> [(Nat, Nat)]) ->
                      ((Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        ((Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Term a b, Term a b) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
nST_label_mul_impl list_ext af cS cNS st =
  (case st of {
    (Var _, _) ->
      Inl (shows_prec_list zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun _ _, Var _) ->
      Inl (shows_prec_list zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun f ss, Fun g ts) ->
      check (snd (list_ext (label_s_ns_impl cS cNS) (lterms af (Fun f ss))
                   (lterms af (Fun g ts))))
        (shows_prec_list zero_nat
           ['c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e', 'n', 't',
             ' ', 'p', 'a', 'i', 'r', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] st .
            shows_prec_list zero_nat [' ', 'w', 'e', 'a', 'k', 'l', 'y', ':'] .
              shows_nl .
                shows_prec_list zero_nat (lterms af (Fun f ss)) .
                  shows_prec_list zero_nat [' ', '>', '=', 'm', 'u', ' '] .
                    shows_prec_list zero_nat (lterms af (Fun g ts)) .
                      shows_prec_list zero_nat
                        [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                          'b', 'e', ' ', 'e', 'n', 's', 'u', 'r', 'e', 'd']);
  });

s_label_mul_impl ::
  forall a b.
    (Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    ((a, Nat) -> [(Nat, Nat)]) ->
                      ((Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        ((Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Term a b, Term a b) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
s_label_mul_impl list_ext af cS cNS st =
  (case st of {
    (Var _, _) ->
      Inl (shows_prec_list zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun _ _, Var _) ->
      Inl (shows_prec_list zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun f ss, Fun g ts) ->
      check (fst (list_ext (label_s_ns_impl cS cNS) (lterms af (Fun f ss))
                   (lterms af (Fun g ts))))
        (shows_prec_list zero_nat
           ['c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e', 'n', 't',
             ' ', 'p', 'a', 'i', 'r', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] st .
            shows_prec_list zero_nat
              [' ', 's', 't', 'r', 'i', 'c', 't', 'l', 'y', ':'] .
              shows_nl .
                shows_prec_list zero_nat (lterms af (Fun f ss)) .
                  shows_prec_list zero_nat [' ', '>', 'm', 'u', ' '] .
                    shows_prec_list zero_nat (lterms af (Fun g ts)) .
                      shows_prec_list zero_nat
                        [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                          'b', 'e', ' ', 'e', 'n', 's', 'u', 'r', 'e', 'd']);
  });

generate_scnp_rp ::
  forall a b c.
    (Key a, Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    [Prelude.Char] ->
                      [((a, Nat), [(Nat, Nat)])] ->
                        (c -> Redtriple_ext a b ()) ->
                          c -> Root_redtriple_ext a b ();
generate_scnp_rp list_ext list_ext_name afa rti x =
  let {
    rt = rti x;
    afaa = fun_of_map (ceta_map_of afa) [];
    pi = af rt;
    cS = s rt;
    cNS = ns rt;
  } in Root_redtriple_ext (valid rt) (s_label_mul_impl list_ext afaa cS cNS)
         (ns rt) (nST_label_mul_impl list_ext afaa cS cNS) pi
         (scnp_af_to_af afaa pi) (scnp_desc afa list_ext_name . desc rt) ();

get_root_redtriple ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => Root_redtriple_impl a ->
                    Root_redtriple_ext a [Prelude.Char] ();
get_root_redtriple (SCNP typea af rp) =
  generate_scnp_rp (list_ext (scnp_arity af) typea) (list_ext_name typea) af
    get_redtriple rp;

faulty_non_inf_order ::
  forall a b c.
    (Showa b, Showa c) => [Prelude.Char] -> a -> Non_inf_order_ext b c ();
faulty_non_inf_order s f =
  Non_inf_order_ext (Inl (shows_string s)) (\ _ -> Inr ()) (\ _ -> Inr ())
    (\ _ _ -> Wild) id ();

sqrt_real :: Real -> [Real];
sqrt_real x =
  (if less_eq_real zero_real x then let {
                                      y = sqrt x;
                                    } in remdups [y, uminus_real y]
    else []);

check_non_inf_poly_inter_list ::
  forall a b.
    (Eq a, Eq b,
      Poly_carrier b) => Bool ->
                           [(a, Nat)] ->
                             [((a, Nat), [([(Nat, Nat)], b)])] ->
                               Sum (a, [([(Nat, Nat)], b)]) ();
check_non_inf_poly_inter_list discrete f i =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (_, a) = x;
              } in check_poly_weak_mono_and_pos discrete a
            then Inr () else Inl x))
        (filter (\ (fn, _) -> membera f fn) i))
      (\ x -> Inl (snd x)))
    (\ x -> Inl (let {
                   (a, b) = x;
                 } in let {
                        (fa, _) = a;
                      } in (\ aa -> (fa, aa))
                        b));

create_nlpoly_non_inf_order ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                    a -> (a -> a -> Bool) ->
                           Bool ->
                             Bool ->
                               (a -> [a]) ->
                                 [((b, Nat), [([(Nat, Nat)], a)])] ->
                                   [(b, Nat)] -> Non_inf_order_ext b c ();
create_nlpoly_non_inf_order cI def gt power_mono discrete sqrt i f =
  let {
    j = poly_inter_list_to_inter def i;
    x = poly_subst
          (\ n -> poly_of (PVar (['x', '_'] ++ shows_prec_nat zero_nat n [])));
  } in Non_inf_order_ext
         (bindb cI
           (\ _ ->
             catch_errora (check_non_inf_poly_inter_list discrete f i)
               (\ xa ->
                 Inl (let {
                        (fa, p) = xa;
                      } in shows_string
                             ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a',
                               't', 'i', 'o', 'n', ' '] .
                             shows_poly (x p) .
                               shows_string [' ', 'o', 'f', ' '] .
                                 shows_prec zero_nat fa .
                                   shows_string
                                     [' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd',
                                       ' ']))))
         (check_ns j) (check_cc sqrt gt j) (create_dep discrete def i)
         (shows_string
            ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n',
              't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n'] .
           shows_nl .
             shows_sep
               (\ (a, b) ->
                 let {
                   (fa, n) = a;
                 } in (\ p ->
                        shows_string ['P', 'o', 'l', '('] .
                          shows_prec zero_nat fa .
                            shows_string ['/'] .
                              shows_prec_nat zero_nat n .
                                shows_string [')', ' ', '=', ' '] .
                                  shows_poly (x p))
                   b)
               shows_nl i)
         ();

get_non_inf_order ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b,
      Showa b) => Redtriple_impl a -> [(a, Nat)] -> Non_inf_order_ext a b ();
get_non_inf_order (Int_nl_carrier i) =
  create_nlpoly_non_inf_order (Inr ()) (Int_of_integer (1 :: Integer))
    (\ x y -> less_int y x) True True sqrt_int i;
get_non_inf_order (Rat_nl_carrier d i) =
  create_nlpoly_non_inf_order (check_def_pos d) d (delta_gt d)
    (less_eq_rat one_rat d) False sqrt_rat i;
get_non_inf_order (Real_nl_carrier d i) =
  create_nlpoly_non_inf_order (check_def_pos d) d (delta_gt d)
    (less_eq_real one_real d) False sqrt_real i;
get_non_inf_order (Int_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Rat_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Real_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_rat_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Int_mat_carrier v va vb) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Rat_mat_carrier v va vb) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Real_mat_carrier v va vb) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_mat_carrier v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_rat_mat_carrier v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (RPO v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (KBO v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (WPO v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];

check_strict_one_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b, Term a b) ->
                      Maybe [(Pos, ((Term a b, Term a b), Term a b))]) ->
                      ((a, Nat) -> Nat) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strict_one_rstep ra rseqm p r =
  let {
    s = proj_term p (fst r);
    t = proj_term p (snd r);
  } in (case rseqm r of {
         Nothing -> check_supt s t;
         Just [] ->
           Inl (shows_string
                 ['m', 'o', 'r', 'e', ' ', 't', 'h', 'a', 'n', ' ', 'a', ' ',
                   's', 'i', 'n', 'g', 'l', 'e', ' ', 'r', 'e', 'w', 'r', 'i',
                   't', 'e', ' ', 's', 't', 'e', 'p', ' ', 'i', 's', ' ', 'n',
                   'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']);
         Just [(pos, (rule, u))] ->
           bindb (check_qrstep (\ _ -> True) False ra pos rule s u)
             (\ _ -> check_supteq u t);
         Just ((_, (_, _)) : _ : _) ->
           Inl (shows_string
                 ['m', 'o', 'r', 'e', ' ', 't', 'h', 'a', 'n', ' ', 'a', ' ',
                   's', 'i', 'n', 'g', 'l', 'e', ' ', 'r', 'e', 'w', 'r', 'i',
                   't', 'e', ' ', 's', 't', 'e', 'p', ' ', 'i', 's', ' ', 'n',
                   'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']);
       });

check_rsteps ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), Term a b))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rsteps = check_qrsteps (\ _ -> True) False;

rseq_last ::
  forall a b. Term a b -> [(Pos, ((Term a b, Term a b), Term a b))] -> Term a b;
rseq_last s steps = last (s : map (\ (_, (_, sa)) -> sa) steps);

check_rsteps_last ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      [(Pos, ((Term a b, Term a b), Term a b))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rsteps_last = (\ r s steps -> check_rsteps r steps s (rseq_last s steps));

check_strict_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b, Term a b) ->
                      Maybe [(Pos, ((Term a b, Term a b), Term a b))]) ->
                      ((a, Nat) -> Nat) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strict_rstep ra rseqm p r =
  let {
    s = proj_term p (fst r);
    t = proj_term p (snd r);
  } in (case rseqm r of {
         Nothing -> check_supt s t;
         Just rseq ->
           (if equal_nat (size_list rseq) zero_nat then check_supt s t
             else bindb (check_rsteps_last ra s rseq)
                    (\ _ -> check_supteq (rseq_last s rseq) t));
       });

create_rseq_map ::
  forall a b.
    (Key a,
      Key b) => [((Term a b, Term a b),
                   [(Pos, ((Term a b, Term a b), Term a b))])] ->
                  (Term a b, Term a b) ->
                    Maybe [(Pos, ((Term a b, Term a b), Term a b))];
create_rseq_map rseqs = ceta_map_of rseqs;

check_weak ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> Nat) ->
                    (Term a b, Term a b) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_weak p r =
  catch_errora
    (check (equal_term (proj_term p (fst r)) (proj_term p (snd r)))
      (shows_string
         ['t', 'h', 'e', ' ', 'p', 'r', 'o', 'j', 'e', 'c', 't', 'e', 'd', ' ',
           'l', 'h', 's', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'q', 'u',
           'a', 'l', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'j',
           'e', 'c', 't', 'e', 'd', ' ', 'r', 'h', 's'] .
        shows_nl))
    (\ x ->
      Inl (shows_string
             ['C', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i',
               'e', 'n', 't', ' ', 'r', 'u', 'l', 'e', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] r .
              shows_string [',', ' ', 's', 'i', 'n', 'c', 'e'] .
                shows_nl .
                  shows_prec_term zero_nat (proj_term p (fst r)) .
                    shows_string [' ', '!', '=', ' '] .
                      shows_prec_term zero_nat (proj_term p (snd r)) .
                        shows_nl . x));

subterm_criterion_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Ccompare c, Eq c, Key c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    ProjL b ->
                      [((Term b c, Term b c),
                         [(Pos, ((Term b c, Term b c), Term b c))])] ->
                        [(Term b c, Term b c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
subterm_criterion_proc i pL rseqmL prm dpp =
  (case let {
          p = create_proj pL;
          rseqm = create_rseq_map rseqmL;
          pa = pairsb i dpp;
          _ = nfsc i dpp;
          r = rulese i dpp;
          pb = snd (split_pairsa i dpp prm);
          wfR = wf_rules_impl r;
        } in bindb (catch_errora
                     (forallM
                       (\ (l, ra) ->
                         bindb (check_no_var l)
                           (\ _ ->
                             bindb (check_no_var ra)
                               (\ _ ->
                                 check_no_defined_root
                                   (\ fn -> not (null (rules_mapc i dpp fn)))
                                   ra)))
                       pa)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                         (shows_prec_list zero_nat
                           ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                             ' ', 'o', 'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                             'o', 's', 't', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                             'e', 'd']))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM (\ (l, _) -> check_no_var l) r)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (if q_emptyc i dpp
                                 then catch_errora
(forallM (check_strict_rstep r rseqm p) prm) (\ x -> Inl (snd x))
                                 else catch_errora
(forallM (check_strict_one_rstep wfR rseqm p) prm) (\ x -> Inl (snd x)))
                           (\ _ ->
                             catch_errora (forallM (check_weak p) pb)
                               (\ x -> Inl (snd x))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp prm prm);
  });

replace_paira ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> (Term b c, Term b c) -> [(Term b c, Term b c)] -> a;
replace_paira
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = replace_pair;

forward_instantiation_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
forward_instantiation_proc i st sts u_opt dpp =
  (case let {
          isnf = is_QNFc i dpp;
          (s, t) = st;
          iedg = is_iedg_edge_dpp i dpp (s, t);
          sy = map_term (\ x -> x) (\ a -> 'y' : a) s;
          ty = map_term (\ x -> x) (\ a -> 'y' : a) t;
          u = (case u_opt of {
                Nothing -> rulese i dpp;
                Just u -> u;
              });
        } in bindb (if is_none u_opt then Inr ()
                     else let {
                            urc = is_ur_closed_impl_dpp_mv i dpp u;
                            check_urc =
                              (\ sa ta ->
                                check (urc sa ta)
                                  (shows_prec_list zero_nat
                                     ['t', 'e', 'r', 'm', ' '] .
                                    shows_prec_term zero_nat ta .
                                      shows_prec_list zero_nat
[' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'u',
  'n', 'd', 'e', 'r', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
  'e', 's']));
                          } in bindb (check (nfsc i dpp || minimal i dpp)
                                       (shows_prec_list zero_nat
 ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'o', 'r', ' ', 'n',
   'o', 'r', 'm', 'a', 'l', ' ', 's', 'u', 'b', 's', 't', ' ', 'r', 'e', 'q',
   'u', 'i', 'r', 'e', 'd']))
                                 (\ _ ->
                                   bindb (check (nFQ_subset_NF_rulesc i dpp)
   (shows_prec_list zero_nat
     ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e', 'w', 'r', 'i',
       't', 'i', 'n', 'g', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                                     (\ _ ->
                                       bindb
 (catch_errora (forallM (\ (l, a) -> check_urc (args l) a) u)
   (\ x -> Inl (snd x)))
 (\ _ ->
   bindb (check_urc [s] t)
     (\ _ ->
       (if nfsc i dpp then Inr ()
         else catch_errora
                (check_subseteq (vars_term_list t) (vars_term_list s))
                (\ _ ->
                  Inl (shows_prec_list zero_nat
                        ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'c', 'o',
                          'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ',
                          'p', 'a', 'i', 'r', ' ', 'v', 'i', 'o', 'l', 'a', 't',
                          'e', 'd']))))))))
               (\ _ ->
                 let {
                   ur = map (\ (l, r) -> (r, l)) u;
                   ic = icap_impl (is_NF_terms []) ur [];
                 } in catch_errora
                        (forallM
                          (\ (ua, v) ->
                            (case mgu_class (ic ua) t of {
                              Nothing -> Inr ();
                              Just mu ->
                                check (not (isnf (subst_apply_term sy mu)) ||
(not (isnf (subst_apply_term (map_term (\ x -> x) (\ a -> 'x' : a) ua) mu)) ||
  any (\ sta ->
        instance_rule sta st &&
          instance_rule (subst_apply_term sy mu, subst_apply_term ty mu) sta)
    sts))
                                  (shows_prec_list zero_nat
                                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                       't', ' ', 'f', 'i', 'n', 'd', ' ', 'i',
                                       'n', 's', 't', 'a', 'n', 'c', 'e', ' ',
                                       'o', 'f', ' ', 'p', 'a', 'i', 'r', ' '] .
                                    shows_rule (shows_prec zero_nat)
                                      (shows_prec_list zero_nat)
                                      [' ', '-', '>', ' ']
                                      (subst_apply_term sy mu,
subst_apply_term ty mu) .
                                      shows_nl .
shows_prec_list zero_nat
  ['w', 'h', 'i', 'c', 'h', ' ', 'r', 'e', 's', 'u', 'l', 't', 'e', 'd', ' ',
    'f', 'r', 'o', 'm', ' ', 'D', 'P', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] (ua, v));
                            }))
                          (filter (\ (ua, _) -> iedg ua) (pairsb i dpp)))
                        (\ x -> Inl (snd x)))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

check_join ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      [(Pos, ((Term a b, Term a b), Term a b))] ->
                        Term a b ->
                          [(Pos, ((Term a b, Term a b), Term a b))] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join r s sseq t tseq =
  let {
    chk = check_rsteps_last r;
  } in bindb (chk s sseq)
         (\ _ ->
           bindb (chk t tseq)
             (\ _ ->
               let {
                 u = rseq_last s sseq;
                 v = rseq_last t tseq;
               } in check (equal_term u v)
                      (shows_prec_list zero_nat
                         ['t', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                           ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 's',
                           ' ', 'e', 'n', 'd', ' ', 'i', 'n', ' ', 'd', 'i',
                           'f', 'f', 'e', 'r', 'e', 'n', 't', ' ', 't', 'e',
                           'r', 'm', 's', ' '] .
                        shows_prec_term zero_nat u .
                          shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                            shows_prec_term zero_nat v)));

check_critical_pairs_guided ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Bool, (Term a b, Term a b))] ->
                      [(Term a b,
                         ([(Pos, ((Term a b, Term a b), Term a b))],
                           (Term a b,
                             [(Pos, ((Term a b, Term a b), Term a b))])))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_guided r cp joins =
  bindb (catch_errora
          (forallM (\ (s, a) -> let {
                                  (sseq, aa) = a;
                                  (ab, b) = aa;
                                } in check_join r s sseq ab b)
            joins)
          (\ x -> Inl (snd x)))
    (\ _ ->
      let {
        cpa = map (\ (s, (_, (t, _))) -> (s, t)) joins;
      } in catch_errora
             (forallM
               (\ (_, (s, t)) ->
                 check (equal_term s t ||
                         any (\ st ->
                               instance_rule (s, t) st ||
                                 instance_rule (t, s) st)
                           cpa)
                   (shows_prec_list zero_nat
                      ['c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'a',
                        'i', 'r', ' '] .
                     show_crit_pair (s, t) .
                       shows_prec_list zero_nat
                         [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']))
               cp)
             (\ x -> Inl (snd x)));

iterative_join_search_main ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Nat -> Nat -> Bool;
iterative_join_search_main r s t i n =
  (if less_eq_nat i n
    then not (null (list_inter (reachable_terms r s i)
                     (reachable_terms r t i))) ||
           iterative_join_search_main r s t (suc i) n
    else False);

iterative_join_search ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Nat -> Bool;
iterative_join_search r s t n = iterative_join_search_main r s t zero_nat n;

check_join_BFS_limit ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Nat ->
                    [(Term a b, Term a b)] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join_BFS_limit n r s t =
  check (iterative_join_search r s t n)
    (shows_prec_list zero_nat
       ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
         ' ', 'a', ' ', 'j', 'o', 'i', 'n', 'i', 'n', 'g', ' ', 's', 'e', 'q',
         'u', 'e', 'n', 'c', 'e', ' ', 'o', 'f', ' ', 'l', 'e', 'n', 'g', 't',
         'h', ' ', 'a', 't', ' ', 'm', 'o', 's', 't', ' '] .
      shows_prec_nat zero_nat n .
        shows_prec_list zero_nat
          [' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm', 's',
            ' '] .
          shows_prec_term zero_nat s .
            shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
              shows_prec_term zero_nat t . shows_nl);

check_critical_pairs_BFS ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Nat ->
                    [(Term a b, Term a b)] ->
                      [(Bool, (Term a b, Term a b))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_BFS n r cp =
  catch_errora
    (forallM
      (\ (_, (s, t)) ->
        (if equal_term s t then Inr ()
          else catch_errora (check_join_BFS_limit n r s t)
                 (\ x ->
                   Inl (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h',
                            'e', 'n', ' ', 'j', 'o', 'i', 'n', 'i', 'n', 'g',
                            ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ',
                            'p', 'a', 'i', 'r', ' '] .
                         show_crit_pair (s, t) . shows_nl . x))))
      cp)
    (\ x -> Inl (snd x));

check_critical_pairs_NF ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Bool, (Term a b, Term a b))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_NF r cp =
  catch_errora
    (forallM
      (\ (_, (s, t)) ->
        (if equal_term s t then Inr ()
          else catch_errora (check_join_NF r s t)
                 (\ x ->
                   Inl (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h',
                            'e', 'n', ' ', 'j', 'o', 'i', 'n', 'i', 'n', 'g',
                            ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ',
                            'p', 'a', 'i', 'r', ' '] .
                         show_crit_pair (s, t) . shows_nl . x))))
      cp)
    (\ x -> Inl (snd x));

check_critical_pairs ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Bool, (Term a [Prelude.Char], Term a [Prelude.Char]))] ->
                      Join_info a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs r cp join_info =
  (case join_info of {
    Guided a -> check_critical_pairs_guided r cp a;
    Join_NF -> check_critical_pairs_NF r cp;
    Join_BFS n -> check_critical_pairs_BFS n r cp;
  });

switch_innermost_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_innermost_proc i joins_i dpp =
  let {
    r = rwd i dpp;
    p = pb i dpp;
    pw = pwb i dpp;
    nfs = nfsc i dpp;
  } in (case bindb (catch_errora
                     (forallM
                       (\ (l, _) ->
                         check (not (is_Var l))
                           (shows_prec_list zero_nat
                             ['l', 'e', 'f', 't', ' ', 'v', 'a', 'r', 'i', 'a',
                               'b', 'l', 'e', 's', ' ', 'i', 'n', ' ', 'R', ' ',
                               'f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n']))
                       (if nfs then r else []))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check (minimal i dpp)
                         (shows_prec_list zero_nat
                           ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                             ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                   (\ _ ->
                     bindb (check (null (qc i dpp))
                             (shows_prec_list zero_nat
                               ['n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y',
                                 ' ', 'Q', ' ', 'n', 'o', 't', ' ', 'y', 'e',
                                 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
                                 'e', 'd']))
                       (\ _ ->
                         bindb (check (null (rd i dpp))
                                 (shows_prec_list zero_nat
                                   ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u',
                                     'l', 'e', 's', ' ', 'n', 'o', 't', ' ',
                                     'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                           (\ _ ->
                             bindb (check
                                     (null (critical_pairs_impl (p ++ pw) r))
                                     (shows_prec_list zero_nat
                                       ['o', 'v', 'e', 'r', 'l', 'a', 'p', 's',
 ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', 'P', ' ', 'a', 'n', 'd', ' ', 'R',
 ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                               (\ _ ->
                                 check_critical_pairs r
                                   (critical_pairs_impl r r) joins_i)))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i nfs True p pw (map fst r) [] r);
       });

mk_dpp ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      (Bool,
        (Bool,
          ([(Term b c, Term b c)],
            ([(Term b c, Term b c)],
              ([Term b c],
                ([(Term b c, Term b c)], [(Term b c, Term b c)])))))) ->
        a;
mk_dpp i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkd i nfs m p pw q r rw;

check_assma ::
  forall a b c d e f g.
    (Countable b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      (a -> d -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (c -> e -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (([(Ctxt (Lab b [Nat]) [Prelude.Char],
                               (Term (Lab b [Nat]) [Prelude.Char], Location))],
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])]) ->
                            f -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([Prelude.Char] ->
                              g -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              Generic_assm_proof b [Nat] [Prelude.Char] d e f ()
                                g ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assma j i tp_check dp_check fptp_check unk_check (SN_assm_proof t prf) =
  tp_check (mk_tp j t) prf;
check_assma j i tp_check dp_check fptp_check unk_check (Finite_assm_proof t prf)
  = dp_check (mk_dpp i t) prf;
check_assma j i tp_check dp_check fptp_check unk_check
  (Unknown_assm_proof t prf) = unk_check t prf;
check_assma j i tp_check dp_check fptp_check unk_check (SN_FP_assm_proof t prf)
  = fptp_check t prf;
check_assma j i uu uv uw ux (Not_SN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assma j i uu uv uw ux (Infinite_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assma j i uu uv uw ux (Not_RelSN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assma j i uu uv uw ux (Not_SN_FP_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assma j i uu uv uw ux (Complexity_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);

quasi_splitter ::
  forall a b c.
    (Compare a, Eq a, Compare c,
      Eq c) => (a -> (a, b)) ->
                 [(Term a c, Term a c)] ->
                   Set (Term a c, Term a c) ->
                     ([(Term a c, Term a c)],
                       ([(Term a c, Term a c)], [(Term a c, Term a c)]));
quasi_splitter ld lAll uRw =
  let {
    unlab = (\ lf -> fst (ld lf));
    la = map (\ r -> (r, map_funs_rule unlab r)) lAll;
    (d, nD) =
      partition
        (\ (r, ur) ->
          equal_term (fst ur) (snd ur) && not (equal_term (fst r) (snd r)))
        la;
    (rw, r) = partition (\ (_, ur) -> member ur uRw) nD;
  } in (map fst r, (map fst rw, map fst d));

model_splitter ::
  forall a b c.
    (Compare a, Eq a, Compare c,
      Eq c) => (a -> (a, b)) ->
                 [(Term a c, Term a c)] ->
                   Set (Term a c, Term a c) ->
                     ([(Term a c, Term a c)],
                       ([(Term a c, Term a c)], [(Term a c, Term a c)]));
model_splitter ld lAll uRw =
  let {
    unlab = (\ lf -> fst (ld lf));
    la = map (\ r -> (r, map_funs_rule unlab r)) lAll;
    (rw, r) = partition (\ (_, ur) -> member ur uRw) la;
  } in (map fst r, (map fst rw, []));

check_sl_Q ::
  forall a b c.
    (Eq a, Showa a, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => (a -> (a, b)) ->
                    [Term a c] ->
                      [Term a c] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_Q ld lQ q =
  let {
    u = (\ l -> fst (ld l));
  } in catch_errora
         (forallM
           (\ lq ->
             check (let {
                      mlq = map_term u (\ x -> x) lq;
                    } in any (\ qa -> matches mlq qa && matches qa mlq) q)
               (shows_prec_list zero_nat
                  ['u', 'n', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ' '] .
                 shows_term (shows_prec zero_nat) (shows_prec zero_nat) lq .
                   shows_prec_list zero_nat
                     [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 'a', ' ', 't',
                       'e', 'r', 'm', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ',
                       'Q']))
           lQ)
         (\ x -> Inl (snd x));

sem_lab_quasi_root_proc ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ceq d, Ccompare d, Compare d, Eq d,
      Mapping_impl d, Set_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([(Term a d, Term a d)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          ([(Term a d, Term a d)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([Term a d] ->
                              [Term a d] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                ([(Term a d, Term a d)] ->
                                  [(Term a d, Term a d)] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char])
                                      ()) ->
                                  (Set (Term a d, Term a d) ->
                                    [(Term a d, Term a d)] ->
                                      Sum ([Prelude.Char] -> [Prelude.Char])
()) ->
                                    [(Term a d, Term a d)] ->
                                      [Term a d] ->
[(Term a d, Term a d)] -> c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_quasi_root_proc ld i valid check_decra check_decr check_lhss_more
  check_lab_all check_lab_all_trs check_model_lab lPAll lQ lRAll dpp =
  let {
    r = rd i dpp;
    rw = rwd i dpp;
    pw = pwb i dpp;
    p = pb i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll (set pw);
    (lR, (lRw, d)) = quasi_splitter ld lRAll (set rw);
    qempty = q_emptyc i dpp;
  } in (case bindb valid
               (\ _ ->
                 bindb (check
                         (if nfs
                           then (if not qempty then wwf_rulesa i dpp else True)
                           else True)
                         (shows_prec_list zero_nat
                           ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e',
                             'd', 'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u',
                             'i', 'r', 'e', 'd']))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM
                               (\ (l, ra) ->
                                 bindb (check_no_var l)
                                   (\ _ ->
                                     bindb (check_no_var ra)
                                       (\ _ ->
 check_no_defined_root (\ fn -> not (null (rules_mapc i dpp fn))) ra)))
                               (pairsb i dpp))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM (\ (l, _) -> check_no_var l)
                                   (rulese i dpp))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             let {
                               q = qc i dpp;
                             } in bindb (if nfs && not qempty
  then check_wf_trs d else Inr ())
                                    (\ _ ->
                                      bindb (check_decra d)
(\ _ ->
  bindb (check_decr d)
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ qa ->
                  check (linear_term qa)
                    (shows_prec_list zero_nat
                      ['Q', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                        'c', 'o', 'n', 't', 'a', 'i', 'n', ' ', 'n', 'o', 'n',
                        '-', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 't', 'e', 'r',
                        'm', 's']))
                q)
              (\ x -> Inl (snd x)))
        (\ _ ->
          catch_errora
            (bindb (check_lhss_more lQ q)
              (\ _ ->
                bindb (check_sl_Q ld lQ q)
                  (\ _ ->
                    bindb (check_lab_all (set lP) p)
                      (\ _ ->
                        bindb (check_lab_all (set lPw) pw)
                          (\ _ ->
                            bindb (check_model_lab (set lR) r)
                              (\ _ ->
                                bindb (check_model_lab (set lRw) rw)
                                  (\ _ ->
                                    bindb (check_lab_all_trs lR r)
                                      (\ _ -> check_lab_all_trs lRw rw))))))))
            (\ x ->
              Inl (shows_string
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'd', 'u', 'r',
                       'i', 'n', 'g', ' ', 'l', 'a', 'b', 'e', 'l', 'i', 'n',
                       'g', ':'] .
                    shows_nl . x))))))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i nfs m lP lPw lQ lR (lRw ++ d));
       });

eval_lab ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> Nat -> c -> d) -> (e -> b) -> Term a e -> (b, Term d e);
eval_lab i l lc alpha (Var x) = (alpha x, Var x);
eval_lab i l lc alpha (Fun f ts) =
  let {
    clts = map (eval_lab i l lc alpha) ts;
    cs = map fst clts;
    c = i f cs;
    lts = map snd clts;
  } in (c, Fun (lc f (size_list ts) (l f cs)) lts);

check_sl_rule_ass ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => Bool ->
                    (a -> [b] -> b) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          (b -> b -> Bool) ->
                            Set (Term d e, Term d e) ->
                              (e -> b) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_ass mc i la lc cge lR alpha (l, r) =
  let {
    cl_ll = eval_lab i la lc alpha l;
    cr_lr = eval_lab i la lc alpha r;
  } in bindb (check (if mc then cge (fst cl_ll) (fst cr_lr) else True)
               (shows_string ['r', 'u', 'l', 'e', ' '] .
                 shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                   [' ', '-', '>', ' '] (l, r) .
                   shows_string
                     [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 't',
                       'h', 'e', ' ', 'm', 'o', 'd', 'e', 'l', ' ', 'c', 'o',
                       'n', 'd', 'i', 't', 'i', 'o', 'n', ',', ' ', '[', 'l',
                       'h', 's', ']', ' ', '=', ' '] .
                     shows_prec zero_nat (fst cl_ll) .
                       shows_string
                         [',', ' ', '[', 'r', 'h', 's', ']', ' ', '=', ' '] .
                         shows_prec zero_nat (fst cr_lr)))
         (\ _ ->
           check (member (snd cl_ll, snd cr_lr) lR)
             (shows_string
                ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                  ' '] .
               shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                 [' ', '-', '>', ' '] (snd cl_ll, snd cr_lr) .
                 shows_string [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']));

check_sl_rule ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> d) ->
                        [b] ->
                          (b -> b -> Bool) ->
                            Bool ->
                              Set (Term d e, Term d e) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule i l lc c cge mc lR lr =
  catch_errora
    (forallM (\ alpha -> check_sl_rule_ass mc i l lc cge lR alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_model_lab_trs_set ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_model_lab_trs_set i l c cge labl lR r =
  catch_errora (forallM (check_sl_rule i l labl c cge True lR) r)
    (\ x -> Inl (snd x));

check_sl_model_lab_trs ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_model_lab_trs i l c cge labl lR r =
  check_sl_model_lab_trs_set i l c cge labl lR r;

check_NF_vars_subset ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_vars_subset qa q =
  catch_errora (forallM (\ qaa -> check (any (matches qaa) q) qaa) qa)
    (\ x -> Inl (snd x));

flatten_term_enum :: forall a b. Term [a] b -> [Term a b];
flatten_term_enum (Var x) = [Var x];
flatten_term_enum (Fun fs ts) = let {
                                  lts = map flatten_term_enum ts;
                                  ss = concat_lists lts;
                                } in concatMap (\ f -> map (Fun f) ss) fs;

lab_lhss_more_impl ::
  forall a b c d.
    (a -> Nat -> b -> c) -> (a -> Nat -> [b]) -> [Term a d] -> [Term c d];
lab_lhss_more_impl lc lS_gen q =
  let {
    f_all = (\ (f, n) -> map (lc f n) (lS_gen f n));
  } in concatMap (\ qa -> flatten_term_enum (map_funs_term_wa f_all qa)) q;

check_sl_lab_lhss_more ::
  forall a b c.
    (Eq a, Showa a, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => (a -> Nat -> b -> a) ->
                    (a -> Nat -> [b]) ->
                      [Term a c] ->
                        [Term a c] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_lhss_more lc lS_gen lQ q =
  catch_errora (check_NF_vars_subset (lab_lhss_more_impl lc lS_gen q) lQ)
    (\ x ->
      Inl (shows_term (shows_prec zero_nat) (shows_prec zero_nat) x .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i',
                'n', ' ', 'l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'Q']));

sl_check_decr ::
  forall a b c d e.
    Sl_ops_ext a b c d e ->
      [(Term a d, Term a d)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sl_check_decr
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_check_decr;

lab_root ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> [b] -> c) ->
          (a -> Nat -> c -> d) -> (e -> b) -> Term a e -> Term d e;
lab_root i la l lc alpha (Fun f ts) = let {
clts = map (eval_lab i la lc alpha) ts;
cs = map fst clts;
a = map snd clts;
                                      } in Fun (lc f (size_list ts) (l f cs)) a;
lab_root uu uv uw ux uy (Var x) = Var x;

check_sl_rule_all_ass ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          (c -> [c]) ->
                            Set (Term d e, Term d e) ->
                              (e -> b) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_all_ass i lb la lc gen_smaller lR alpha (l, Fun f ts) =
  let {
    ll = lab_root i lb la lc alpha l;
    clts = map (eval_lab i lb lc alpha) ts;
    lts = map snd clts;
    ld = la f (map fst clts);
    n = size_list ts;
    small = gen_smaller ld;
  } in catch_errora
         (forallM
           (\ le ->
             check (member (ll, Fun (lc f n le) lts) lR)
               (shows_string
                  ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                    ' '] .
                 shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                   [' ', '-', '>', ' '] (ll, Fun (lc f n le) lts) .
                   shows_string [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']))
           small)
         (\ x -> Inl (snd x));
check_sl_rule_all_ass i lb la lc gen_smaller lR alpha (l, Var x) =
  let {
    ll = lab_root i lb la lc alpha l;
    lr = lab_root i lb la lc alpha (Var x);
  } in check (member (ll, lr) lR)
         (shows_string
            ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e', ' '] .
           shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] (ll, lr) .
             shows_string [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']);

check_sl_rule_all ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          [b] ->
                            (c -> [c]) ->
                              Set (Term d e, Term d e) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_all i la l lc c gen_smaller lR lr =
  catch_errora
    (forallM
      (\ alpha -> check_sl_rule_all_ass i la l lc gen_smaller lR alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_lab_all_trs ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        [b] ->
                          (c -> [c]) ->
                            (a -> Nat -> c -> d) ->
                              Set (Term d e, Term d e) ->
                                [(Term a e, Term a e)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_all_trs i la l c gen labl lP p =
  catch_errora (forallM (check_sl_rule_all i la l labl c gen lP) p)
    (\ x -> Inl (snd x));

check_wf_sym_F_all ::
  forall a b c.
    (Eq c,
      Showa c) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        (c, Nat) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_sym_F_all lc ld ls =
  (\ (lf, n) ->
    let {
      (f, l) = ld lf;
    } in check (ls f n l && lf == lc f n l)
           (shows_prec_list zero_nat
              ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o',
                'l', ' '] .
             shows_prec zero_nat lf .
               shows_prec_list zero_nat
                 [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']));

insert_funas_term :: forall a b. (Eq a) => Term a b -> [(a, Nat)] -> [(a, Nat)];
insert_funas_term (Var x) fs = fs;
insert_funas_term (Fun f ts) fs =
  insertb (f, size_list ts) (foldr insert_funas_term ts fs);

check_wf_terms_F_all ::
  forall a b c d.
    (Eq c,
      Showa c) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        Term c d -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_terms_F_all lc ld ls lt =
  let {
    lfs = insert_funas_term lt [];
  } in catch_errora (forallM (check_wf_sym_F_all lc ld ls) lfs)
         (\ x -> Inl (snd x));

check_Lab_all_trs ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        [(Term a c, Term a c)] ->
                          [(Term a c, Term a c)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_Lab_all_trs lc ld ls lR r =
  catch_errora
    (forallM
      (\ (l, ra) ->
        catch_errora
          (bindb (check_wf_terms_F_all lc ld ls ra)
            (\ _ ->
              check (membera r (map_funs_rule (\ lf -> fst (ld lf)) (l, ra)))
                (shows_prec_list zero_nat
                  ['u', 'n', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ' ', 'o',
                    'f', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' ', 'd',
                    'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'y', 'i', 'e', 'l',
                    'd', ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 'r',
                    'u', 'l', 'e'])))
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h',
                     ' ', 'l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l',
                     'e'] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '-', '>', ' '] (l, ra) .
                    shows_nl . x)))
      lR)
    (\ x -> Inl (snd x));

sl_LS_gen :: forall a b c d e. Sl_ops_ext a b c d e -> a -> Nat -> [c];
sl_LS_gen
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_LS_gen;

sl_lgen :: forall a b c d e. Sl_ops_ext a b c d e -> c -> [c];
sl_lgen
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_lgen;

lge_to_lgr ::
  forall a b.
    (Eq b) => (a -> Nat -> b -> b -> Bool) ->
                (a -> Nat -> b -> Bool) -> a -> Nat -> b -> b -> Bool;
lge_to_lgr lge ls f n =
  let {
    lSfn = ls f n;
    lgefn = lge f n;
  } in (\ l la -> not (l == la) && lSfn l && lSfn la && lgefn l la);

check_sl_decr_rule ::
  forall a b c d.
    (Eq a, Eq b, Eq c,
      Eq d) => (a -> Nat -> b -> c) ->
                 (c -> (a, b)) ->
                   (a -> Nat -> b -> Bool) ->
                     (a -> Nat -> b -> b -> Bool) ->
                       (Term c d, Term c d) -> Bool;
check_sl_decr_rule lc ld ls lge (Fun lf ts, Fun lg us) =
  let {
    (f, l1) = ld lf;
    (g, l2) = ld lg;
    n = size_list ts;
  } in f == g &&
         ts == us &&
           lf == lc f n l1 &&
             lg == lc f n l2 &&
               ls f n l1 && ls f n l2 && lge_to_lgr lge ls f n l1 l2;
check_sl_decr_rule uu uv uw ux (Var vb, va) = False;
check_sl_decr_rule uu uv uw ux (v, Var vb) = False;

check_sl_decr ::
  forall a b c d.
    (Eq a, Eq b, Eq c, Showa c, Eq d,
      Showa d) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        (a -> Nat -> b -> b -> Bool) ->
                          [(Term c d, Term c d)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_decr lc ld ls lge d =
  catch_errora
    (forallM
      (\ lr ->
        check (check_sl_decr_rule lc ld ls lge lr)
          (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] lr .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'd', 'e', 'c',
                'r', 'e', 'a', 's', 'i', 'n', 'g', ' ', 'r', 'u', 'l', 'e']))
      d)
    (\ x -> Inl (snd x));

sl_LS :: forall a b c d e. Sl_ops_ext a b c d e -> a -> Nat -> c -> Bool;
sl_LS (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
        sl_LS_gen more)
  = sl_LSa;

sl_La :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> c;
sl_La (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
        sl_LS_gen more)
  = sl_L;

sl_L :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> c;
sl_L (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_La;

sl_I :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> b;
sl_I (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_I;

sl_C :: forall a b c d e. Sl_ops_ext a b c d e -> [b];
sl_C (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_C;

insert_funas_args_term ::
  forall a b. (Eq a) => Term a b -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_term t fs = foldr insert_funas_term (args t) fs;

insert_funas_args_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_rule r fs =
  insert_funas_args_term (fst r) (insert_funas_args_term (snd r) fs);

insert_funas_args_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_trs trs = foldr insert_funas_args_rule trs;

option_to_list :: forall a. Maybe a -> [a];
option_to_list (Just a) = [a];
option_to_list Nothing = [];

insert_roots_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_roots_rule r fs =
  foldr insertb (option_to_list (root (fst r)) ++ option_to_list (root (snd r)))
    fs;

insert_roots_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_roots_trs trs = foldr insert_roots_rule trs;

insert_funas_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_funas_rule r fs =
  insert_funas_term (fst r) (insert_funas_term (snd r) fs);

insert_funas_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_funas_trs trs = foldr insert_funas_rule trs;

sem_lab_fin_quasi_root_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Eq b, Showa c, Ceq e, Ccompare e, Compare e,
      Eq e, Mapping_impl e, Set_impl e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      (c -> c -> Bool) ->
                        (a -> Nat -> b -> b -> Bool) ->
                          Dpp_ops_ext d a e () ->
                            ([(a, Nat)] ->
                              [(a, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char])
                                  (Sl_ops_ext a c b e ())) ->
                              [(Term a e, Term a e)] ->
                                [Term a e] ->
                                  [(Term a e, Term a e)] ->
                                    d -> Sum ([Prelude.Char] -> [Prelude.Char])
   d;
sem_lab_fin_quasi_root_proc lc ld cge lge i gen lPAll lQ lRAll dp =
  let {
    pairs = pairsb i dp;
  } in bindb (gen (list_union (insert_funas_trs (rulese i dp) [])
                    (insert_funas_args_trs pairs []))
               (insert_roots_trs pairs []))
         (\ ops ->
           let {
             check_d = sl_check_decr ops;
             check_da = check_sl_decr lc ld (sl_LS ops) lge;
             check_q = check_sl_lab_lhss_more lc (sl_LS_gen ops);
             check_ml =
               check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) cge lc;
             check_l =
               check_sl_lab_all_trs (sl_I ops) (sl_L ops) (sl_La ops) (sl_C ops)
                 (sl_lgen ops) lc;
             check_la = check_Lab_all_trs lc ld (sl_LS ops);
           } in sem_lab_quasi_root_proc ld i (Inr ()) check_d check_da check_q
                  check_l check_la check_ml lPAll lQ lRAll dp);

check_sl_rule_root ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          [b] ->
                            Set (Term d e, Term d e) ->
                              (Term a e, Term a e) ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_root i la l lc c lR lr =
  catch_errora
    (forallM
      (\ alpha ->
        let {
          laa = lab_root i la l lc alpha;
          lb = laa (fst lr);
          r = laa (snd lr);
        } in check (member (lb, r) lR)
               (shows_prec_list zero_nat
                  ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                    ' '] .
                 shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                   [' ', '-', '>', ' '] (lb, r) .
                   shows_prec_list zero_nat
                     [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g']))
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_lab_root_trs ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        [b] ->
                          (a -> Nat -> c -> d) ->
                            Set (Term d e, Term d e) ->
                              [(Term a e, Term a e)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_root_trs i la l c labl lP p =
  catch_errora (forallM (check_sl_rule_root i la l labl c lP) p)
    (\ x -> Inl (snd x));

sem_lab_root_proc ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([Term a d] ->
                          [Term a d] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Set (Term a d, Term a d) ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                [(Term a d, Term a d)] ->
                                  [Term a d] ->
                                    [(Term a d, Term a d)] ->
                                      c ->
Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_root_proc ld i valid check_Q check_laba check_lab check_model_lab lPAll
  lQ lRAll dpp =
  let {
    r = rd i dpp;
    rw = rwd i dpp;
    pw = pwb i dpp;
    p = pb i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll (set pw);
    (lR, (lRw, _)) = model_splitter ld lRAll (set rw);
  } in (case bindb valid
               (\ _ ->
                 bindb (catch_errora
                         (forallM
                           (\ (l, ra) ->
                             bindb (check_no_var l)
                               (\ _ ->
                                 bindb (check_no_var ra)
                                   (\ _ ->
                                     check_no_defined_root
                                       (\ fn ->
 not (null (rules_mapc i dpp fn)))
                                       ra)))
                           (pairsb i dpp))
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM (\ (l, _) -> check_no_var l)
                               (rulese i dpp))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         let {
                           q = qc i dpp;
                         } in catch_errora
                                (bindb
                                  (check
                                    (if nfs
                                      then (if not (q_emptyc i dpp)
     then wwf_rulesa i dpp else True)
                                      else True)
                                    (shows_prec_list zero_nat
                                      ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r',
'm', 'e', 'd', 'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e',
'd']))
                                  (\ _ ->
                                    bindb (check_Q lQ q)
                                      (\ _ ->
bindb (check_sl_Q ld lQ q)
  (\ _ ->
    bindb (check_laba (set lP) p)
      (\ _ ->
        bindb (check_laba (set lPw) pw)
          (\ _ ->
            bindb (check_model_lab (set lR) r)
              (\ _ ->
                bindb (check_model_lab (set lRw) rw)
                  (\ _ ->
                    bindb (check_lab lR r) (\ _ -> check_lab lRw rw)))))))))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'd', 'u', 'r', 'i', 'n', 'g', ' ',
   'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ':'] .
shows_nl . x)))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i nfs m lP lPw lQ lR lRw);
       });

lab_rule_ass ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> Nat -> c -> d) ->
          (e -> b) -> (Term a e, Term a e) -> (Term d e, Term d e);
lab_rule_ass i l lc alpha rule =
  (snd (eval_lab i l lc alpha (fst rule)),
    snd (eval_lab i l lc alpha (snd rule)));

lab_rule_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) ->
                    [b] -> (Term a e, Term a e) -> [(Term d e, Term d e)];
lab_rule_list i l lc c lr =
  map (\ alpha -> lab_rule_ass i l lc alpha lr)
    (map fun_of (enum_vectors c (insert_vars_rule lr [])));

lab_trs_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) ->
                    [b] -> [(Term a e, Term a e)] -> [(Term d e, Term d e)];
lab_trs_list i l lc c r = concatMap (lab_rule_list i l lc c) r;

check_sl_lab ::
  forall a b c d.
    (Eq a, Showa a, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> a) ->
                        [b] ->
                          [(Term a d, Term a d)] ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab i l lc c lR r =
  bindb (check (not (null c))
          (shows_prec_list zero_nat
            ['c', 'a', 'r', 'r', 'i', 'e', 'r', ' ', 'm', 'u', 's', 't', ' ',
              'b', 'e', ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
    (\ _ ->
      catch_errora (check_subseteq lR (lab_trs_list i l lc c r))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                   ' '] .
                shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                  [' ', '-', '>', ' '] x .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
                      'w', 'e', 'd'])));

lab_lhs_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) -> [b] -> Term a e -> [Term d e];
lab_lhs_list i l lc c t =
  map (\ alpha -> snd (eval_lab i l lc alpha t))
    (map fun_of (enum_vectors c (insert_vars_term t [])));

lab_lhss_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) -> [b] -> [Term a e] -> [Term d e];
lab_lhss_list i l lc c q = concatMap (lab_lhs_list i l lc c) q;

check_sl_Qa ::
  forall a b c d.
    (Eq a, Showa a, Ccompare d, Eq d, Mapping_impl d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> a) ->
                        [b] ->
                          [Term a d] ->
                            [Term a d] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_Qa i l lc c lQ q =
  bindb (check (not (null c))
          (shows_prec_list zero_nat
            ['c', 'a', 'r', 'r', 'i', 'e', 'r', ' ', 'm', 'u', 's', 't', ' ',
              'b', 'e', ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
    (\ _ ->
      catch_errora (check_NF_vars_subset (lab_lhss_list i l lc c q) lQ)
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 't', 'e', 'r', 'm',
                   ' '] .
                shows_term (shows_prec zero_nat) (shows_prec zero_nat) x .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])));

sem_lab_fin_root_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d, Eq e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      Dpp_ops_ext c a d () ->
                        ([(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              (Sl_ops_ext a e b d ())) ->
                          [(Term a d, Term a d)] ->
                            [Term a d] ->
                              [(Term a d, Term a d)] ->
                                c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_fin_root_proc lc ld i gen lPAll lQ lRAll dp =
  let {
    pairs = pairsb i dp;
  } in bindb (gen (list_union (insert_funas_trs (rulese i dp) [])
                    (insert_funas_args_trs pairs []))
               (insert_roots_trs pairs []))
         (\ ops ->
           let {
             check_q = check_sl_Qa (sl_I ops) (sl_L ops) lc (sl_C ops);
             check_ml =
               check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops)
                 (\ a b -> a == b) lc;
             check_l =
               check_sl_lab_root_trs (sl_I ops) (sl_L ops) (sl_La ops)
                 (sl_C ops) lc;
             check_la = check_sl_lab (sl_I ops) (sl_L ops) lc (sl_C ops);
           } in sem_lab_root_proc ld i (Inr ()) check_q check_l check_la
                  check_ml lPAll lQ lRAll dp);

slm_La :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> c;
slm_La (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_L;

slm_c :: forall a b c d. Slm_ops_ext a b c d -> b;
slm_c (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_c;

slm_L :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> c;
slm_L (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_La;

slm_I :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> b;
slm_I (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_I;

slm_C :: forall a b c d. Slm_ops_ext a b c d -> [b];
slm_C (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_C;

slm_to_sl :: forall a b c d. Slm_ops_ext a b c () -> Sl_ops_ext a b c d ();
slm_to_sl ops =
  Sl_ops_ext (slm_L ops) (\ _ _ _ -> True) (slm_I ops) (slm_C ops) (slm_c ops)
    (\ _ -> Inr ()) (slm_La ops) (\ _ _ _ -> True) (\ l -> [l]) (\ _ _ -> [])
    ();

slm_gen_to_sl_gen ::
  forall a b c d.
    ([(a, Nat)] ->
      [(a, Nat)] ->
        Sum ([Prelude.Char] -> [Prelude.Char]) (Slm_ops_ext a b c ())) ->
      [(a, Nat)] ->
        [(a, Nat)] ->
          Sum ([Prelude.Char] -> [Prelude.Char]) (Sl_ops_ext a b c d ());
slm_gen_to_sl_gen gen =
  (\ f g -> bindb (gen f g) (\ ops -> Inr (slm_to_sl ops)));

check_sl_lab_trs_set ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_trs_set i l c cge labl lP p =
  catch_errora (forallM (check_sl_rule i l labl c cge False lP) p)
    (\ x -> Inl (snd x));

check_sl_lab_trs ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_trs i l c cge labl lP p = check_sl_lab_trs_set i l c cge labl lP p;

sem_lab_proc ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([Term a d] ->
                          [Term a d] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Set (Term a d, Term a d) ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                [(Term a d, Term a d)] ->
                                  [Term a d] ->
                                    [(Term a d, Term a d)] ->
                                      c ->
Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_proc ld i valid check_Q check_laba check_lab check_model_lab lPAll lQ
  lRAll dpp =
  let {
    r = rd i dpp;
    rw = rwd i dpp;
    pw = pwb i dpp;
    p = pb i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll (set pw);
    (lR, (lRw, _)) = model_splitter ld lRAll (set rw);
  } in (case bindb valid
               (\ _ ->
                 let {
                   q = qc i dpp;
                 } in catch_errora
                        (bindb
                          (check
                            (if nfs
                              then (if not (q_emptyc i dpp)
                                     then wwf_rulesa i dpp else True)
                              else True)
                            (shows_prec_list zero_nat
                              ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e',
                                'd', 'n', 'e', 's', 's', ' ', 'r', 'e', 'q',
                                'u', 'i', 'r', 'e', 'd']))
                          (\ _ ->
                            bindb (check_Q lQ q)
                              (\ _ ->
                                bindb (check_sl_Q ld lQ q)
                                  (\ _ ->
                                    bindb (check_laba (set lP) p)
                                      (\ _ ->
bindb (check_laba (set lPw) pw)
  (\ _ ->
    bindb (check_model_lab (set lR) r)
      (\ _ ->
        bindb (check_model_lab (set lRw) rw)
          (\ _ -> bindb (check_lab lR r) (\ _ -> check_lab lRw rw)))))))))
                        (\ x ->
                          Inl (shows_string
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'd',
                                   'u', 'r', 'i', 'n', 'g', ' ', 'l', 'a', 'b',
                                   'e', 'l', 'i', 'n', 'g', ':'] .
                                shows_nl . x)))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i nfs m lP lPw lQ lR lRw);
       });

sem_lab_fin_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d, Eq e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      Dpp_ops_ext c a d () ->
                        ([(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              (Sl_ops_ext a e b d ())) ->
                          [(Term a d, Term a d)] ->
                            [Term a d] ->
                              [(Term a d, Term a d)] ->
                                c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_fin_proc lc ld i gen lPAll lQ lRAll dp =
  bindb (gen (list_union (insert_funas_trs (rulese i dp) [])
               (insert_funas_args_trs (pairsb i dp) []))
          [])
    (\ ops ->
      let {
        check_q = check_sl_Qa (sl_I ops) (sl_L ops) lc (sl_C ops);
        check_ml =
          check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops)
            (\ a b -> a == b) lc;
        check_l =
          check_sl_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) (\ a b -> a == b)
            lc;
        check_la = check_sl_lab (sl_I ops) (sl_L ops) lc (sl_C ops);
      } in sem_lab_proc ld i (Inr ()) check_q check_l check_la check_ml lPAll lQ
             lRAll dp);

get_largest_element :: forall a. Sl_inter a -> Nat;
get_largest_element (SL_Inter n uu) = n;

take_default :: forall a. a -> [a] -> Nat -> a;
take_default def [] uu = def;
take_default uv (x : xs) i =
  (if equal_nat i zero_nat then x
    else take_default uv xs (minus_nat i one_nat));

eval_arithFun :: Nat -> [Nat] -> ArithFun -> Nat;
eval_arithFun c nats f = mod_nat (eval_arithFun_unbound c nats f) c;

eval_arithFun_unbound :: Nat -> [Nat] -> ArithFun -> Nat;
eval_arithFun_unbound c nats (Arg i) = take_default zero_nat nats i;
eval_arithFun_unbound c nats (Const n) = n;
eval_arithFun_unbound c nats (Sum []) = zero_nat;
eval_arithFun_unbound c nats (Sum (f : fs)) =
  plus_nat (eval_arithFun c nats f) (eval_arithFun c nats (Sum fs));
eval_arithFun_unbound c nats (Prod []) = one_nat;
eval_arithFun_unbound c nats (Prod (f : fs)) =
  times_nat (eval_arithFun c nats f) (eval_arithFun c nats (Prod fs));
eval_arithFun_unbound c nats (Max [f]) = eval_arithFun c nats f;
eval_arithFun_unbound c nats (Max (f : v : va)) =
  max (eval_arithFun c nats f) (eval_arithFun c nats (Max (v : va)));
eval_arithFun_unbound c nats (Min [f]) = eval_arithFun c nats f;
eval_arithFun_unbound c nats (Min (f : v : va)) =
  min (eval_arithFun c nats f) (eval_arithFun c nats (Min (v : va)));
eval_arithFun_unbound c nats (IfEqual f1 f2 ft fe) =
  (if equal_nat (eval_arithFun c nats f1) (eval_arithFun c nats f2)
    then eval_arithFun c nats ft else eval_arithFun c nats fe);

sl_inter_to_inter :: forall a. (Eq a) => Sl_inter a -> a -> [Nat] -> Nat;
sl_inter_to_inter (SL_Inter c ls) fl cs =
  (case map_of ls (fl, size_list cs) of {
    Nothing -> zero_nat;
    Just a -> eval_arithFun (suc c) cs a;
  });

sli_to_slm ::
  forall a.
    (Eq a) => Sl_inter (Lab a [Nat]) ->
                Slm_ops_ext (Lab a [Nat]) Nat (Sum [Nat] [Lab a [Nat]]) ();
sli_to_slm sli =
  let {
    c = get_largest_element sli;
  } in Slm_ops_ext (\ _ -> Inl) (sl_inter_to_inter sli) (upt zero_nat (suc c)) c
         (\ _ -> Inl) ();

enum_vectors_nat :: forall a. [a] -> Nat -> [[a]];
enum_vectors_nat c n =
  (if equal_nat n zero_nat then [[]]
    else let {
           a = enum_vectors_nat c (minus_nat n one_nat);
         } in concatMap (\ vec -> map (\ ca -> ca : vec) c) a);

qmodel_check_interpretation ::
  ArithFun -> Nat -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_interpretation f n c =
  let {
    ca = upt zero_nat (suc c);
    css = enum_vectors_nat ca n;
  } in catch_errora
         (forallM
           (\ cs ->
             catch_errora
               (forallM
                 (\ i ->
                   catch_errora
                     (forallM
                       (\ l ->
                         check (less_eq_nat (eval_arithFun (suc c) cs f)
                                 (eval_arithFun (suc c) (list_update cs i l) f))
                           (shows_prec_list zero_nat
                              ['n', 'o', 't', ' ', 'm', 'o', 'n', 'o', 't', 'o',
                                'n', 'e', ' ', 'i', 'n', ' '] .
                             shows_prec_nat zero_nat (suc i) .
                               shows_prec_list zero_nat
                                 ['.', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n',
                                   't']))
                       (upt (nth cs i) (suc c)))
                     (\ x -> Inl (snd x)))
                 (upt zero_nat n))
               (\ x -> Inl (snd x)))
           css)
         (\ x -> Inl (snd x));

qmodel_check_valid ::
  forall a.
    (Showa a) => Sl_inter a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_valid (SL_Inter c ls) =
  catch_errora
    (forallM
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ g ->
               catch_errora (qmodel_check_interpretation g n c)
                 (\ x ->
                   Inl (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n',
                            ' ', 'w', 'e', 'a', 'k', '-', 'm', 'o', 'n', 'o',
                            't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ' ', 'o',
                            'f', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r', 'e',
                            't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                         shows_prec zero_nat f . shows_nl . x)))
          b)
      ls)
    (\ x -> Inl (snd x));

check_decr_present_aux_1 ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a (b, Nat), Term a (b, Nat))] ->
                           b -> a -> a -> Nat ->
    Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present_aux_1 r v f1 f2 n =
  let {
    vs = map (\ na -> Var (v, na)) (upt zero_nat n);
    rule = (Fun f1 vs, Fun f2 vs);
  } in check (not (is_none (find (instance_rule rule) r))) rule;

check_decr_present_aux_2 ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           b -> [(a, (a, Nat))] ->
                                  Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present_aux_2 r v req =
  let {
    add_nats = map_term (\ x -> x) (\ va -> (va, zero_nat));
    ra = map (\ (l, ra) -> (add_nats l, add_nats ra)) r;
  } in catch_errora
         (forallM (\ (f1, a) -> let {
                                  (aa, b) = a;
                                } in check_decr_present_aux_1 ra v f1 aa b)
           req)
         (\ x -> Inl (snd x));

check_decr_present ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(a, Nat)] ->
                           (a -> [Nat] -> a) ->
                             b -> Nat ->
                                    [(Term a b, Term a b)] ->
                                      Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present sig l v c r =
  let {
    ca = upt zero_nat (suc c);
    ls = (\ (f, n) ->
           concatMap
             (\ cs ->
               concatMap
                 (\ i ->
                   let {
                     ci = nth cs i;
                   } in (if less_nat ci c
                          then [(l f (list_update cs i (suc ci)), (l f cs, n))]
                          else []))
                 (upt zero_nat n))
             (enum_vectors_nat ca n));
  } in check_decr_present_aux_2 r v (concatMap ls sig);

qmodel_check_decr ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b,
      Mapping_impl b) => [(Lab a [Nat], Nat)] ->
                           b -> Nat ->
                                  [(Term (Lab a [Nat]) b,
                                     Term (Lab a [Nat]) b)] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_decr sig v c =
  (\ lR ->
    catch_errora (check_decr_present sig Lab v c lR)
      (\ x ->
        Inl (let {
               display =
                 map_term (\ xa -> xa)
                   (\ (_, n) ->
                     (shows_prec_list zero_nat ['x'] .
                       shows_prec_nat zero_nat n)
                       []);
             } in shows_prec_list zero_nat
                    ['d', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n', 'g', ' ', 'r',
                      'u', 'l', 'e', ' '] .
                    shows_rule (shows_prec_lab zero_nat)
                      (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                      (display (fst x), display (snd x)) .
                      shows_prec_list zero_nat
                        [' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])));

qmodel_LS_gen ::
  forall a b c. (Eq a) => [(a, Nat)] -> [b] -> a -> Nat -> [Sum [b] c];
qmodel_LS_gen sig ls =
  (\ f n ->
    (if membera sig (f, n) then map Inl (enum_vectors_nat ls n) else [Inl []]));

pointwise_lgen :: [Nat] -> [[Nat]];
pointwise_lgen ns = concat_lists (map (\ n -> upt zero_nat (suc n)) ns);

qmodel_lgen :: forall a. Sum [Nat] a -> [Sum [Nat] a];
qmodel_lgen l = (case l of {
                  Inl ns -> map Inl (pointwise_lgen ns);
                  Inr _ -> [];
                });

qmodel_LSa :: forall a. Lab a [Nat] -> Nat -> Sum [Nat] [Lab a [Nat]] -> Bool;
qmodel_LSa = (\ _ _ a -> (case a of {
                           Inl _ -> True;
                           Inr _ -> False;
                         }));

qmodel_LS ::
  forall a b c.
    (Eq a, Eq b, Eq c) => [(a, Nat)] -> [b] -> a -> Nat -> Sum [b] c -> Bool;
qmodel_LS sig ls = (\ f n -> membera (qmodel_LS_gen sig ls f n));

qmodel_L ::
  forall a b c d.
    (Eq a, Eq b) => [(Lab a b, Nat)] -> Lab a b -> [c] -> Sum [c] d;
qmodel_L sig =
  (\ f cs -> (if membera sig (f, size_list cs) then Inl cs else Inl []));

qsli_to_sl_unsafe ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Showa b) => a -> [(Lab b [Nat], Nat)] ->
                         [(Lab b [Nat], Nat)] ->
                           Sl_inter (Lab b [Nat]) ->
                             Sl_ops_ext (Lab b [Nat]) Nat
                               (Sum [Nat] [Lab b [Nat]]) a ();
qsli_to_sl_unsafe v f g sli =
  let {
    c = get_largest_element sli;
    ca = upt zero_nat (suc c);
  } in Sl_ops_ext (qmodel_L f) (qmodel_LS f ca) (sl_inter_to_inter sli) ca c
         (qmodel_check_decr f v c) (qmodel_L g) qmodel_LSa qmodel_lgen
         (qmodel_LS_gen f ca) ();

qsli_to_sl ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Showa b) => a -> [(Lab b [Nat], Nat)] ->
                         [(Lab b [Nat], Nat)] ->
                           Sl_inter (Lab b [Nat]) ->
                             Sum ([Prelude.Char] -> [Prelude.Char])
                               (Sl_ops_ext (Lab b [Nat]) Nat
                                 (Sum [Nat] [Lab b [Nat]]) a ());
qsli_to_sl v f g sli =
  bindb (qmodel_check_valid sli) (\ _ -> Inr (qsli_to_sl_unsafe v f g sli));

pointwise_ext ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
pointwise_ext f [] [] = (False, True);
pointwise_ext f (uu : uv) [] = (False, False);
pointwise_ext f [] (uw : ux) = (False, False);
pointwise_ext f (a : asa) (b : bs) =
  (case f a b of {
    (stri, True) -> (case pointwise_ext f asa bs of {
                      (strir, True) -> (stri || strir, True);
                      (_, False) -> (False, False);
                    });
    (_, False) -> (False, False);
  });

qmodel_lge :: forall a b c d. a -> b -> Sum [Nat] c -> Sum [Nat] d -> Bool;
qmodel_lge f n =
  (\ l r ->
    (case (l, r) of {
      (Inl cs1, Inl cs2) ->
        snd (pointwise_ext (\ x y -> (less_nat y x, less_eq_nat y x)) cs1 cs2);
      (Inl _, Inr _) -> False;
      (Inr _, _) -> False;
    }));

qmodel_cge :: Nat -> Nat -> Bool;
qmodel_cge = (\ x y -> less_eq_nat y x);

rl_slm ::
  forall a b.
    (Eq a,
      Eq b) => Maybe (Lab a b, Nat) ->
                 [(Lab a b, Nat)] ->
                   [(Lab a b, Nat)] ->
                     Sum ([Prelude.Char] -> [Prelude.Char])
                       (Slm_ops_ext (Lab a b) (Lab a b) (Sum b [Lab a b]) ());
rl_slm delt_opt pre_fs g =
  let {
    fs = (if is_none delt_opt then pre_fs
           else filter (\ f -> not (f == the delt_opt)) pre_fs);
  } in bindb (check (not (null fs))
               (shows_string
                  ['r', 'o', 'o', 't', '-', 'l', 'a', 'b', 'e', 'l', 'i', 'n',
                    'g', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'a',
                    't', ' ', 'l', 'e', 'a', 's', 't', ' ', 'o', 'n', 'e', ' ',
                    'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 's', 'y', 'm',
                    'b', 'o', 'l', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 's',
                    'i', 'g', 'n', 'a', 't', 'u', 'r', 'e'] .
                 shows_nl))
         (\ _ ->
           let {
             f = fst (hda fs);
           } in Inr (Slm_ops_ext (\ _ -> Inr)
                      (\ ga cs ->
                        (if membera fs (ga, size_list cs) then ga else f))
                      (map fst fs) f
                      (if is_none delt_opt then (\ _ -> Inr)
                        else (\ _ gs ->
                               Inr (replicate (size_list gs)
                                     (fst (the delt_opt)))))
                      ()));

semlab_fin_proc ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a (Lab b [Nat]) c () ->
                    Sl_variant (Lab b [Nat]) c ->
                      [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                        [Term (Lab b [Nat]) c] ->
                          [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
semlab_fin_proc j (Rootlab Nothing) =
  sem_lab_fin_proc label label_decomp j (slm_gen_to_sl_gen (rl_slm Nothing));
semlab_fin_proc j (Rootlab (Just d)) =
  sem_lab_fin_root_proc label label_decomp j
    (slm_gen_to_sl_gen (rl_slm (Just d)));
semlab_fin_proc j (Finitelab sli) =
  sem_lab_fin_proc label label_decomp j
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli)));
semlab_fin_proc j (QuasiFinitelab sli v) =
  sem_lab_fin_quasi_root_proc label label_decomp qmodel_cge qmodel_lge j
    (\ f g -> qsli_to_sl v f g sli);

all_terms_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    [([Term a [Prelude.Char]], Term a [Prelude.Char])];
all_terms_impl rr initt =
  remdups
    (map (\ (ss, (t, _)) -> (ss, t)) initt ++ map (\ (l, a) -> (args l, a)) rr);

all_subterms_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    [([Term a [Prelude.Char]], Term a [Prelude.Char])];
all_subterms_impl rr initt =
  remdups
    (concatMap (\ (ss, s) -> map (\ a -> (ss, a)) (supteq_list s))
      (all_terms_impl rr initt));

everything_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    [Sum ([Term a [Prelude.Char]],
                           (Term a [Prelude.Char],
                             (Term a [Prelude.Char], Term a [Prelude.Char])))
                       ((a, Nat), Nat)];
everything_impl rr initt =
  map Inl
    (concatMap
      (\ (ss, t) ->
        map (\ lr -> (ss, (t, lr))) (remdups (map (snd . snd) initt)))
      (all_subterms_impl rr initt)) ++
    remdups
      (map Inr
        (concatMap
          (\ t ->
            (if not (is_Var t)
              then concatMap
                     (\ (f, ts) ->
                       map (\ a -> ((f, size_list ts), a))
                         (upt zero_nat (size_list ts)))
                     (let {
                        (Fun f ts) = t;
                      } in [(f, ts)])
              else []))
          (remdups (map snd (all_subterms_impl rr initt)))));

generate_impl ::
  forall a b c d.
    (Eq a, Key a, Eq b,
      Eq c) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                 (Term a [Prelude.Char] -> Bool) ->
                   ([Term a [Prelude.Char]] ->
                     Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                     ([Term a [Prelude.Char]] ->
                       Term a [Prelude.Char] -> [(b, c)]) ->
                       Sum ([Term a [Prelude.Char]],
                             (Term a [Prelude.Char], (b, c)))
                         d ->
                         [Sum ([Term a [Prelude.Char]],
                                (Term a [Prelude.Char], (b, c)))
                            ((a, Nat), Nat)];
generate_impl rr nfq e_cap uu (Inr v) = [];
generate_impl rr nfq e_cap uu (Inl (va, (Var ve, vd))) = [];
generate_impl rr nfq e_cap uu (Inl (ss, (Fun f ts, (l, r)))) =
  concatMap
    (\ i ->
      (if membera (uu ss (nth ts i)) (l, r)
        then map (\ u -> u)
               [Inl (ss, (nth ts i, (l, r))), Inr ((f, size_list ts), i)]
        else []))
    (upt zero_nat (size_list ts)) ++
    concatMap
      (\ (la, ra) ->
        concatMap
          (\ mss ->
            (if rule_match_impl nfq (e_cap mss) mss f
                  (map (map_term (\ x -> x) (\ a -> 'x' : a)) ts) la
              then (if membera (uu (args la) ra) (l, r)
                     then [Inl (args la, (ra, (l, r)))] else [])
              else []))
          [map (map_term (\ x -> x) (\ a -> 'x' : a)) ss])
      rr;

mu_approx_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])]) ->
                      (Term a [Prelude.Char] -> Bool) ->
                        ([Term a [Prelude.Char]] ->
                          Term a [Prelude.Char] ->
                            Term a (Sum () [Prelude.Char])) ->
                          ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
mu_approx_impl rr initt u_impl nfq e_cap =
  let {
    uu = precompute_fun (\ (a, b) -> u_impl a b) (all_subterms_impl rr initt);
    uua = (\ s t -> uu (s, t));
    fis = remdups
            (concatMap (\ entry -> map (\ fi -> fi) (case entry of {
              Inl _ -> [];
              Inr fi -> [fi];
            }))
              (inductive_set_impl (everything_impl rr initt) equal_sum
                (generate_impl rr nfq e_cap uua) (map Inl initt)));
    fs = remdups (map fst fis);
    mu = (\ f ->
           set (map_filter
                 (\ x -> (if let {
                               (g, _) = x;
                             } in g == f
                           then Just (snd x) else Nothing))
                 fis));
  } in (fs, (precompute_fun mu fs,
              ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'U', 'R', 'M',
                ' ', 'w', 'r', 't', '.', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i',
                'c', ' ', 'r', 'u', 'l', 'e', 's']));

inn_usable_rules_wf ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  ([Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      Bool ->
                        ([Term a [Prelude.Char]], Term a [Prelude.Char]) ->
                          [(Term a [Prelude.Char], Term a [Prelude.Char])];
inn_usable_rules_wf nfq e_cap r nfs =
  (\ (ss, t) ->
    (if nfs ||
          all (\ x -> any (contains_var_term x) ss) (remdups (vars_term_list t))
      then ur_calc_singleton nfq e_cap r (ss, t) else r));

inn_usable_rules_wf_dpp ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> Bool ->
                         ([Term b [Prelude.Char]], Term b [Prelude.Char]) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])];
inn_usable_rules_wf_dpp i d nfs =
  inn_usable_rules_wf (is_QNFc i d) (icap_impl_dpp i d) (rulese i d) nfs;

get_innermost_strict_repl_map_dpp ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                         ([(b, Nat)], ((b, Nat) -> Set Nat, [Prelude.Char]));
get_innermost_strict_repl_map_dpp i d s =
  let {
    r = rulese i d;
    p = pairsb i d;
    isNF = is_QNFc i d;
    u = inn_usable_rules_wf_dpp i d True;
    a = icap_impl_dpp i d;
  } in mu_approx_impl r
         (concatMap (\ (sa, t) -> map (\ lr -> ([sa], (t, lr))) s) p)
         (\ ss t -> u (ss, t)) isNF a;

show_position_set ::
  forall a. (a, Nat) -> Set Nat -> [Prelude.Char] -> [Prelude.Char];
show_position_set f s =
  shows_list_nat
    (concatMap (\ i -> (if member i s then [suc i] else []))
      (upt zero_nat (snd f)));

mono_af :: forall a b c. Redtriple_ext a b c -> (a, Nat) -> Set Nat;
mono_af (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  mono_af;

mono_urm_redpair_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_urm_redpair_proc i rp premove rremove dpp =
  (case catch_errora
          (let {
             (ps, pns) = split_pairsa i dpp premove;
             (rs, rns) = split_rulesc i dpp rremove;
             r = rulese i dpp;
             _ = qc i dpp;
             p = pairsb i dpp;
           } in bindb (check_wf_trs p)
                  (\ _ ->
                    bindb (check_wf_trs r)
                      (\ _ ->
                        bindb (check (nFQ_subset_NF_rulesc i dpp)
                                (shows_prec_list zero_nat
                                  ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't',
                                    ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e',
                                    'd']))
                          (\ _ ->
                            let {
                              (fs, (mu, info)) =
                                get_innermost_strict_repl_map_dpp i dpp rs;
                            } in bindb (valid rp)
                                   (\ _ ->
                                     let {
                                       mua = mono_af rp;
                                     } in bindb
    (catch_errora
      (catch_errora
        (forallM
          (\ f ->
            check (subset (mu f) (mua f))
              (shows_string
                 ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'm', 'o', 'n',
                   'o', 't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ':', ' ', 's',
                   't', 'r', 'i', 'c', 't', ' ', 'o', 'r', 'd', 'e', 'r', ' ',
                   'f', 'o', 'r', ' '] .
                shows_prec_prod zero_nat f .
                  shows_string
                    [' ', 'e', 'n', 's', 'u', 'r', 'e', 's', ' ', 'm', 'o', 'n',
                      'o', 't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ' ', 'i',
                      'n', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n', 's',
                      ' '] .
                    show_position_set f (mua f) .
                      shows_string
                        ['\n', 'b', 'u', 't', ' ', 'u', 's', 'a', 'b', 'l', 'e',
                          ' ', 'r', 'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n',
                          't', ' ', 'm', 'a', 'p', ' ', 'i', 's', ' '] .
                        show_position_set f (mu f)))
          fs)
        (\ x -> Inl (snd x)))
      (\ x ->
        Inl (x . shows_string
                   ['\n', 't', 'h', 'e', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'e',
                     'd', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'e', 'p',
                     'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ' ', 'm', 'a', 'p',
                     ' ', '('] .
                   shows_string info .
                     shows_string [')', ' ', 'i', 's', '\n'] .
                       shows_sep
                         (\ f ->
                           shows_prec_list zero_nat ['m', 'u', '('] .
                             shows_prec_prod zero_nat f .
                               shows_prec_list zero_nat [')', ' ', '=', ' '] .
                                 show_position_set f (mu f))
                         shows_nl fs .
                         shows_prec_list zero_nat
                           ['\n', 'a', 'n', 'd', ' ', 'm', 'u', '(', 'f', ')',
                             ' ', '=', ' ', '{', '}', ' ', 'f', 'o', 'r', ' ',
                             'a', 'l', 'l', ' ', 'o', 't', 'h', 'e', 'r', ' ',
                             's', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'f'])))
    (\ _ ->
      bindb (catch_errora
              (catch_errora (forallM (ns rp) rns) (\ x -> Inl (snd x)))
              (\ x ->
                Inl (shows_string
                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                         'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                         ' ', 'T', 'R', 'S'] .
                      shows_nl . x)))
        (\ _ ->
          bindb (catch_errora
                  (catch_errora (forallM (s rp) rs) (\ x -> Inl (snd x)))
                  (\ x ->
                    Inl (shows_string
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h',
                             'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i',
                             'n', 'g', ' ', 'T', 'R', 'S'] .
                          shows_nl . x)))
            (\ _ ->
              bindb (catch_errora
                      (catch_errora (forallM (ns rp) pns) (\ x -> Inl (snd x)))
                      (\ x ->
                        Inl (shows_string
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n',
                                 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
                              shows_nl . x)))
                (\ _ ->
                  catch_errora
                    (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
                    (\ x ->
                      Inl (shows_string
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h',
                               'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i',
                               'n', 'g', ' ', 'D', 'P', 's'] .
                            shows_nl . x)))))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'd', 'u',
                     'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                     'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'e', 'p',
                     'l', '.', ' ', 'm', 'a', 'p', 's', ' ', 'a', 'n', 'd', ' ',
                     't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n',
                     'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

partition_rules ::
  forall a b.
    (Eq a,
      Eq b) => [Ctxt a b] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     ([(Term a b, Term a b)], [(Term a b, Term a b)]);
partition_rules cs r =
  partition
    (\ lr ->
      any (\ (u, v) ->
            any (\ c -> lr == (ctxt_apply_term c u, ctxt_apply_term c v))
              (Hole : cs))
        r);

strip_unary_root :: forall a b. (Eq a) => a -> Term a b -> Term a b;
strip_unary_root f (Fun g [t]) = (if f == g then t else Fun g [t]);
strip_unary_root f (Var v) = Var v;
strip_unary_root f (Fun v []) = Fun v [];
strip_unary_root f (Fun v (vb : vd : ve)) = Fun v (vb : vd : ve);

has_unary_root :: forall a b. (Eq a) => a -> Term a b -> Bool;
has_unary_root f (Fun g [t]) = f == g;
has_unary_root f (Var v) = False;
has_unary_root f (Fun v []) = False;
has_unary_root f (Fun v (vb : vd : ve)) = False;

unblock_term :: forall a b. (Eq a) => a -> Term a b -> Term a b;
unblock_term f (Fun g ts) =
  (if all (has_unary_root f) ts then Fun g (map (strip_unary_root f) ts)
    else Fun g ts);
unblock_term f (Var v) = Var v;

unblock_rule ::
  forall a b. (Eq a) => a -> (Term a b, Term a b) -> (Term a b, Term a b);
unblock_rule f r = (unblock_term f (fst r), unblock_term f (snd r));

partition_pairs ::
  forall a b.
    (Eq a,
      Eq b) => a -> [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]);
partition_pairs f p = partition (\ r -> membera p (unblock_rule f r));

check_no_defined_root_defined ::
  forall a b.
    (Eq a, Showa a,
      Showa b) => [(a, Nat)] ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_defined_root_defined f t =
  check (not (membera f (the (root t))))
    (shows_string ['t', 'h', 'e', ' ', 'r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
      shows_prec_term zero_nat t .
        shows_string [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd']);

block_term :: forall a b. a -> Term a b -> Term a b;
block_term f (Var x) = Var x;
block_term f (Fun g ts) = Fun g (map (\ t -> Fun f [t]) ts);

block_rule :: forall a b. a -> (Term a b, Term a b) -> (Term a b, Term a b);
block_rule f r = (block_term f (fst r), block_term f (snd r));

check_superset_of_blocked ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> [(Term a b, Term a b)] ->
                         [(Term a b, Term a b)] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_superset_of_blocked f pa p =
  catch_errora
    (catch_errora
      (catch_errora
        (forallM
          (\ x -> (if membera pa (block_rule f x) then Inr () else Inl x)) p)
        (\ x -> Inl (snd x)))
      (\ x ->
        Inl (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '-', '>', ' '] (block_rule f x) .
                shows_string
                  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'] .
                  shows_nl)))
    (\ x ->
      Inl (shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
             ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't', 'e',
               'm', ':']
             [' ', '-', '>', ' '] p .
            shows_string
              ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 's',
                'e', 't', ' ', 'o', 'f'] .
              shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't',
                  'e', 'm', ':']
                [' ', '-', '>', ' '] pa .
                x . shows_nl));

hole_at :: forall a b. (Eq a) => Nat -> Nat -> a -> Ctxt a b -> Bool;
hole_at n i f (More g ss1 Hole ss2) =
  g == f &&
    equal_nat (size_list ss1) i &&
      equal_nat (size_list ss2) (minus_nat (minus_nat n i) one_nat);
hole_at n i f Hole = False;
hole_at n i f (More v va (More vd ve vf vg) vc) = False;

check_flat_ctxt_complete ::
  forall a b.
    (Eq a, Showa a,
      Showa b) => [Ctxt a b] ->
                    (a, Nat) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_flat_ctxt_complete fcs fa =
  check (all_interval_nat (\ i -> any (hole_at (snd fa) i (fst fa)) fcs)
          zero_nat (snd fa))
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'i', 's', 't', ' ', 'o', 'f', ' ', 'f', 'l',
         'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', 's', ' ', 'i', 's',
         ' ', 'i', 'n', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'e'] .
      shows_nl);

check_rule_reflecting ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [Ctxt a b] ->
                    [(Term a b, Term a b)] ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_reflecting fcs rs rule =
  check (any (\ (l, r) ->
               any (\ c ->
                     equal_term (fst rule) (ctxt_apply_term c l) &&
                       equal_term (snd rule) (ctxt_apply_term c r))
                 (Hole : fcs))
          rs)
    (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] rule .
        shows_string
          [' ', 'i', 's', ' ', 'n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'c', 'o',
            'n', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h',
            'e', ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 's', 'e',
            't', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'n', 'o',
            'r', ' ', 'o', 'b', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'b', 'y',
            ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'a', ' ', 'f',
            'l', 'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
          shows_nl);

check_rule_preserving ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [Ctxt a b] ->
                    [(Term a b, Term a b)] ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_preserving fcs rs rule =
  check (any (instance_rule rule) rs ||
          all (\ c ->
                any (instance_rule
                      (ctxt_apply_term c (fst rule),
                        ctxt_apply_term c (snd rule)))
                  rs)
            fcs)
    (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] rule .
        shows_string
          [' ', 'i', 's', ' ', 'n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'c', 'o',
            'n', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h',
            'e', ' ', 'r', 'e', 's', 'u', 'l', 't', 'i', 'n', 'g', ' ', 's',
            'e', 't', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'n',
            'o', 'r', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'u', 'n', 'd',
            'e', 'r', ' ', 'a', 'l', 'l', ' ', 'f', 'l', 'a', 't', ' ', 'c',
            'o', 'n', 't', 'e', 'x', 't', 's'] .
          shows_nl);

is_flat_ctxt_list ::
  forall a b. (Eq a, Eq b) => [a] -> [(b, Nat)] -> Ctxt b a -> Bool;
is_flat_ctxt_list vs fas (More f ss1 Hole ss2) =
  let {
    ss = ss1 ++ ss2;
  } in membera fas (f, suc (size_list ss)) &&
         all is_Var ss && distinct ss && null (list_inter (map the_Var ss) vs);
is_flat_ctxt_list vs fas Hole = False;
is_flat_ctxt_list vs fas (More v va (More vd ve vf vg) vc) = False;

shows_prec_ctxt ::
  forall a b.
    (Showa a, Showa b) => Nat -> Ctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_ctxt p c = shows_ctxt (shows_prec zero_nat) (shows_prec zero_nat) c;

check_is_flat_ctxt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [a] ->
                    [(b, Nat)] ->
                      Ctxt b a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_is_flat_ctxt vs fas c =
  check (is_flat_ctxt_list vs fas c)
    (shows_prec_ctxt zero_nat c .
      shows_string
        [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'f', 'l', 'a', 't',
          ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
        shows_nl);

check_flat_ctxt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [a] -> Ctxt b a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_flat_ctxt vs c =
  (case c of {
    Hole ->
      Inl (shows_prec_ctxt zero_nat c .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'f', 'l', 'a',
                't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
              shows_nl);
    More _ ss1 Hole ss2 ->
      let {
        ss = ss1 ++ ss2;
      } in bindb (check (distinct ss)
                   (shows_prec_ctxt zero_nat c .
                     shows_string
                       [' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'd',
                         'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', ' ', 'v', 'a',
                         'r', 'i', 'a', 'b', 'l', 'e', 's'] .
                       shows_nl))
             (\ _ ->
               bindb (check (all is_Var ss)
                       (shows_prec_ctxt zero_nat c .
                         shows_string
                           [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'l',
                             'a', 't', ',', ' ', 'i', '.', 'e', '.', ',', ' ',
                             'h', 'a', 's', ' ', 'd', 'e', 'p', 't', 'h', ' ',
                             'g', 'r', 'e', 'a', 't', 'e', 'r', ' ', 't', 'h',
                             'a', 'n', ' ', 'o', 'n', 'e'] .
                           shows_nl))
                 (\ _ ->
                   check (all (\ t -> not (membera vs (the_Var t)))
                           (ss1 ++ ss2))
                     (shows_prec_ctxt zero_nat c .
                       shows_string
                         [' ', 'h', 'a', 's', ' ', 't', 'o', ' ', 'c', 'o', 'n',
                           't', 'a', 'i', 'n', ' ', 'o', 'n', 'l', 'y', ' ',
                           'f', 'r', 'e', 's', 'h', ' ', 'v', 'a', 'r', 'i',
                           'a', 'b', 'l', 'e', 's'] .
                         shows_nl)));
    More _ _ (More _ _ _ _) _ ->
      Inl (shows_prec_ctxt zero_nat c .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'f', 'l', 'a',
                't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
              shows_nl);
  });

shows_terms ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] -> [Term a b] -> [Prelude.Char] -> [Prelude.Char];
shows_terms fun var name ts =
  ((shows_prec_list zero_nat name . shows_nl) .
    shows_list_gen (shows_term fun var) [] [] ['\n'] [] ts) .
    shows_nl;

shows_dpp ::
  forall a b c.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Dpp_ops_ext c a b () -> c -> [Prelude.Char] -> [Prelude.Char];
shows_dpp fun var i d =
  let {
    m = minimal i d;
    nfs = nfsc i d;
    p = pb i d;
    pw = pwb i d;
    r = rd i d;
    rw = rwd i d;
    q = qc i d;
  } in shows_trs fun var ['p', 'a', 'i', 'r', 's', ':'] [' ', '-', '>', ' '] p .
         (if null pw then id
           else shows_trs fun var
                  ['w', 'e', 'a', 'k', ' ', 'p', 'a', 'i', 'r', 's', ':']
                  [' ', '-', '>', '=', ' '] pw) .
           (if null r then id
             else shows_trs fun var
                    ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's',
                      ':']
                    [' ', '-', '>', '!', ' '] r) .
             shows_trs fun var ['r', 'u', 'l', 'e', 's', ':']
               [' ', '-', '>', ' '] rw .
               (if null q then id
                 else shows_terms fun var
                        ['Q', '-', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't',
                          ':']
                        q) .
                 (if m then shows_nl .
                              shows_prec_list zero_nat
                                ['(', 'm', 'i', 'n', 'i', 'm', 'a', 'l', ')']
                   else id) .
                   (if nfs && not (null q)
                     then shows_nl .
                            shows_prec_list zero_nat
                              ['(', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
                                'r', 'm', ' ', 's', 'u', 'b', 's', 't', 'i',
                                't', 'u', 't', 'i', 'o', 'n', 's', ')']
                     else id);

fcc_proc_cond ::
  forall a b c.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               [(Term b c, Term b c)] ->
                                 [(Term b c, Term b c)] ->
                                   a -> Sum ([Prelude.Char] -> [Prelude.Char])
  a;
fcc_proc_cond i f fcs p pw r rw dpp =
  let {
    pa = pb i dpp;
    pwa = pwb i dpp;
    ra = rd i dpp;
    rwa = rwd i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    new_dpp = mkd i nfs m p pw [] r rw;
  } in (case catch_errora
               (let {
                  pba = list_union pa pwa;
                  rb = list_union ra rwa;
                  rba = list_union r rw;
                  fa = (f, one_nat);
                  cf = More f [] Hole [];
                  fcsa = cf : fcs;
                  vs = vars_trs_list rb;
                  fs = list_union (funas_trs_list rb) (funas_args_trs_list pba);
                  fas = fa : fs;
                  ds = defined_list rb;
                } in bindb (check (not (membera ds fa))
                             (shows_prec zero_nat f .
                               shows_string
                                 ['i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r',
                                   'e', 's', 'h'] .
                                 shows_nl))
                       (\ _ ->
                         bindb (check_wf_trs rb)
                           (\ _ ->
                             bindb (catch_errora
                                     (forallM
                                       (\ rc ->
 bindb (check_no_var (fst rc))
   (\ _ ->
     bindb (check_no_var (snd rc))
       (\ _ -> check_no_defined_root_defined ds (snd rc))))
                                       pba)
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 bindb (catch_errora
 (forallM (check_flat_ctxt vs) fcsa) (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (catch_errora
     (forallM (check_is_flat_ctxt vs fas) fcsa) (\ x -> Inl (snd x)))
                                       (\ _ ->
 bindb (catch_errora (forallM (check_flat_ctxt_complete fcsa) fas)
         (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (catch_errora (forallM (check_rule_preserving fcsa r) ra)
             (\ x -> Inl (snd x)))
       (\ _ ->
         bindb (catch_errora (forallM (check_rule_preserving fcsa rba) rwa)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             bindb (catch_errora (forallM (check_rule_reflecting fcsa rb) rba)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check_superset_of_blocked f p pa)
                   (\ _ -> check_superset_of_blocked f pw pwa)))))))))))
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                          'n', ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ',
                          'f', 'l', 'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x',
                          't', ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e', ' ', 'c',
                          'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ', 't',
                          'o', ' ', 's', 'w', 'i', 't', 'c', 'h', ' ', 'f', 'r',
                          'o', 'm', ' '] .
                       shows_nl .
                         shows_dpp (shows_prec zero_nat) (shows_prec zero_nat) i
                           dpp .
                           shows_nl .
                             shows_prec_list zero_nat
                               ['t', 'o', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                                 ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                               shows_nl .
                                 shows_dpp (shows_prec zero_nat)
                                   (shows_prec zero_nat) i new_dpp .
                                   shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr new_dpp;
       });

g_to_list_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> [a];
g_to_list_dflt_basic_oops_rm_basic_ops s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ _ -> True)
    (\ a b -> a : b) [];

delete_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
delete_rm_basic_ops x s = delete x s;

ceta_list_diff :: forall a. (Key a) => [a] -> [a] -> [a];
ceta_list_diff xs ys =
  g_to_list_dflt_basic_oops_rm_basic_ops
    (foldl (\ a b -> delete_rm_basic_ops b a)
      (g_from_list_dflt_basic_oops_rm_basic_ops xs) ys);

fcc_split_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Ceq c, Ccompare c, Eq c, Key c, Mapping_impl c,
      Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               [(Term b c, Term b c)] ->
                                 [(Term b c, Term b c)] ->
                                   a -> Sum ([Prelude.Char] -> [Prelude.Char])
  (a, a);
fcc_split_proc i f fcs pba rb ps rs dpp =
  let {
    p = pb i dpp;
    pw = pwb i dpp;
    r = rd i dpp;
    rw = rwd i dpp;
    q = qc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    pbaa = list_union p pw;
    rba = rw;
    pns = ceta_list_diff pbaa ps;
    rns = ceta_list_diff rba rs;
    (pa, pwa) = partition_pairs f ps pba;
    (ra, rwa) = partition_rules (More f [] Hole [] : fcs) rs rb;
    two = mkd i nfs m (ceta_list_diff p ps) (ceta_list_diff pw ps) [] [] rns;
    dpp_mid = mkd i nfs m ps pns [] rs rns;
  } in bindb (bindb
               (catch_errora (check_subseteq ps pbaa)
                 (\ x ->
                   Inl (shows_prec_list zero_nat ['p', 'a', 'i', 'r', ' '] .
                         shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                           [' ', '-', '>', ' '] x .
                           shows_prec_list zero_nat
                             [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e',
                               ' ', 'd', 'e', 'l', 'e', 't', 'e', 'd', ' ', 'b',
                               'u', 't', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                               'p', 'r', 'e', 's', 'e', 'n', 't'])))
               (\ _ ->
                 bindb (catch_errora (check_subseteq rs rba)
                         (\ x ->
                           Inl (shows_prec_list zero_nat
                                  ['r', 'u', 'l', 'e', ' '] .
                                 shows_rule (shows_prec zero_nat)
                                   (shows_prec zero_nat) [' ', '-', '>', ' ']
                                   x .
                                   shows_prec_list zero_nat
                                     [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ',
                                       'b', 'e', ' ', 'd', 'e', 'l', 'e', 't',
                                       'e', 'd', ' ', 'b', 'u', 't', ' ', 'i',
                                       's', ' ', 'n', 'o', 't', ' ', 'p', 'r',
                                       'e', 's', 'e', 'n', 't'])))
                   (\ _ ->
                     bindb (check (null q)
                             (shows_string
                                ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                                  'e', 'm', 'p', 't', 'y'] .
                               shows_nl))
                       (\ _ ->
                         bindb (check (null r)
                                 (shows_prec_list zero_nat
                                   ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u',
                                     'l', 'e', 's', ' ', 'n', 'o', 't', ' ',
                                     'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                           (\ _ ->
                             bindb (check_left_linear_trs rw)
                               (\ _ ->
                                 fcc_proc_cond i f fcs pa pwa ra rwa
                                   dpp_mid))))))
         (\ one -> Inr (one, two));

mono_redpair_proc ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_redpair_proc i rp premove rremove dpp =
  (case catch_errora
          (let {
             (ps, pns) = split_pairsa i dpp premove;
             (rs, rns) = split_rulesc i dpp rremove;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (catch_errora (mono rp (ps ++ rs ++ pns ++ rns))
                            (\ x ->
                              Inl (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'm', 'o', 'n',
                                       'o', 't', 'o', 'n', 'i', 'c', 'i', 't',
                                       'y', ' ', 'o', 'f', ' ', 's', 't', 'r',
                                       'i', 'c', 't', ' ', 'o', 'r', 'd', 'e',
                                       'r'] .
                                    shows_nl . x)))
                      (\ _ ->
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T', 'R', 'S'] .
shows_nl . x)))
                          (\ _ ->
                            bindb (catch_errora
                                    (catch_errora (forallM (s rp) rs)
                                      (\ x -> Inl (snd x)))
                                    (\ x ->
                                      Inl
(shows_string
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
     'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T', 'R', 'S'] .
  shows_nl . x)))
                              (\ _ ->
                                bindb (catch_errora
(catch_errora (forallM (ns rp) pns) (\ x -> Inl (snd x)))
(\ x ->
  Inl (shows_string
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
           'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
        shows_nl . x)))
                                  (\ _ ->
                                    catch_errora
                                      (catch_errora (forallM (s rp) ps)
(\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
         'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
      shows_nl . x))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'd', 'u',
                     'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                     'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w',
                     'i', 'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

instantiation_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
instantiation_proc i st sts dpp =
  (case let {
          ic = icap_impl_dpp_mv i dpp;
          isnf = is_QNFc i dpp;
          (s, t) = st;
          sy = map_term (\ x -> x) (\ a -> 'y' : a) s;
          ty = map_term (\ x -> x) (\ a -> 'y' : a) t;
          iedg = is_iedg_edge_dpp i dpp;
        } in catch_errora
               (forallM
                 (\ (u, v) ->
                   (case mgu_class (ic [u] v) s of {
                     Nothing -> Inr ();
                     Just mu ->
                       check (not (isnf (subst_apply_term sy mu)) ||
                               (not (isnf (subst_apply_term
    (map_term (\ x -> x) (\ a -> 'x' : a) u) mu)) ||
                                 any (\ sta ->
                                       instance_rule sta st &&
 instance_rule (subst_apply_term sy mu, subst_apply_term ty mu) sta)
                                   sts))
                         (shows_prec_list zero_nat
                            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                              'f', 'i', 'n', 'd', ' ', 'i', 'n', 's', 't', 'a',
                              'n', 'c', 'e', ' ', 'o', 'f', ' ', 'p', 'a', 'i',
                              'r', ' '] .
                           shows_rule (shows_prec zero_nat)
                             (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                             (subst_apply_term sy mu, subst_apply_term ty mu) .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['w', 'h', 'i', 'c', 'h', ' ', 'r', 'e', 's',
                                   'u', 'l', 't', 'e', 'd', ' ', 'f', 'r', 'o',
                                   'm', ' ', 'D', 'P', ' '] .
                                 shows_rule (shows_prec zero_nat)
                                   (shows_prec_list zero_nat)
                                   [' ', '-', '>', ' '] (u, v));
                   }))
                 (filter (\ (u, v) -> iedg (u, v) s) (pairsb i dpp)))
               (\ x -> Inl (snd x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

intersect_pairsb ::
  forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_pairsb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = intersect_pairs;

graph_approx_rt_sym_main ::
  forall a b c.
    (Ccompare a, Eq a) => Multimap (Maybe (a, Nat)) b -> Gctxt a c -> [b];
graph_approx_rt_sym_main m (GCFun f ts) =
  lookupc m Nothing ++ lookupc m (Just (f, size_list ts));
graph_approx_rt_sym_main m GCHole = valuesa m;

graph_approx_rt_sym ::
  forall a b c d e f.
    (Ccompare a,
      Eq a) => Multimap (Maybe (a, Nat)) b -> (c, (d, (Gctxt a e, f))) -> [b];
graph_approx_rt_sym m (uu, (uv, (ct, uw))) = graph_approx_rt_sym_main m ct;

rules_non_collapsinga :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
rules_non_collapsinga
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_non_collapsing;

reverse_rules_mapb ::
  forall a b c d.
    Dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
reverse_rules_mapb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = reverse_rules_map;

reverse_tcapRM_dpp ::
  forall a b c.
    (Eq b, Eq c) => Dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
reverse_tcapRM_dpp i dpp =
  tcapRM (rules_non_collapsinga i dpp) (reverse_rules_mapb i dpp);

check_no_back_edges ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> a -> [a]) ->
        (a -> b -> b) ->
          ((a, a) -> Bool) ->
            b -> [[a]] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_back_edges ss candidates add_index g i [] = Inr ();
check_no_back_edges ss candidates add_index g i (asa : cs) =
  bindb (catch_errora
          (forallM
            (\ a ->
              catch_errora (forallM (check_no_edge ss g a) (candidates i a))
                (\ x -> Inl (snd x)))
            asa)
          (\ x -> Inl (snd x)))
    (\ _ ->
      check_no_back_edges ss candidates add_index g (foldr add_index asa i) cs);

check_graph_decomp ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      b -> (b -> a -> [a]) ->
             (a -> b -> b) ->
               ((a, a) -> Bool) ->
                 [(Bool, [a])] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_graph_decomp ss empty_index candidates add_index g rcs =
  bindb (check_no_back_edges ss candidates add_index g empty_index
          (map snd rcs))
    (\ _ ->
      catch_errora
        (forallM (\ c -> check_edges ss g c c)
          (map_filter (\ x -> (if not (fst x) then Just (snd x) else Nothing))
            rcs))
        (\ x -> Inl (snd x)));

check_dep_graph_proc ::
  forall a b c.
    (Ccompare b, Eq b, Key b, Mapping_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dep_graph_proc i dpp dps =
  let {
    c = tcapRM_dpp i dpp;
    rc = reverse_tcapRM_dpp i dpp;
    iedg = is_iedg_edge_dpp i dpp;
    p = pairsb i dpp;
  } in bindb (catch_errora (check_subseteq p (concatMap snd dps))
               (\ x ->
                 Inl (shows_string
                        ['D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ',
                          'P', 'a', 'i', 'r', ' '] .
                       shows_rule (shows_prec zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                         shows_string
                           [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                             'g', ' ', 'i', 'n', ' ', 'd', 'e', 'c', 'o', 'm',
                             'p', 'o', 's', 'i', 't', 'i', 'o', 'n'] .
                           shows_nl)))
         (\ _ ->
           catch_errora
             (check_graph_decomp (shows_prec_prod zero_nat . fst)
               (emptye ((root . fst) . fst)) graph_approx_rt_sym inserte
               (\ (a, b) ->
                 let {
                   (aa, ba) = a;
                 } in let {
                        (_, t) = aa;
                      } in (\ (_, (ct, ict)) (ab, bb) ->
                             let {
                               (u, _) = ab;
                             } in (\ (cu, (_, _)) ->
                                    matchb ct u && matchb cu t && ict u)
                               bb)
                        ba
                   b)
               (map (\ (real, cs) ->
                      (not (is_none real),
                        map (\ (s, t) -> ((s, t), (rc s, (c t, iedg (s, t)))))
                          cs))
                 dps))
             (\ x ->
               Inl (shows_string
                      ['o', 'u', 'r', ' ', 'e', 's', 't', 'i', 'm', 'a', 't',
                        'i', 'o', 'n', ' ', '(', 'E', 'D', 'G', '*', '*', '*',
                        ' ', '+', ' ', 'I', 'E', 'D', 'G', '*', '*', '*', ')',
                        ' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                        's', 'h', 'o', 'w', ' ', 't', 'h', 'a', 't', ' ', 'y',
                        'o', 'u', ' ', 'h', 'a', 'v', 'e', ' ', 'a', ' ', 'v',
                        'a', 'l', 'i', 'd', ' ', 'd', 'e', 'c', 'o', 'm', 'p',
                        'o', 's', 'i', 't', 'i', 'o', 'n', ' '] .
                     shows_string
                       ['d', 'u', 'e', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ',
                         'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'r',
                         'e', 'a', 's', 'o', 'n'] .
                       shows_nl . x)));

dep_graph_proc ::
  forall a b c.
    (Ccompare b, Eq b, Key b, Mapping_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) [(c, a)];
dep_graph_proc i d dps =
  (case check_dep_graph_proc i d dps of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (map_filter
            (\ x ->
              (if not (is_none (fst x))
                then Just (the (fst x), intersect_pairsb i d (snd x))
                else Nothing))
            dps);
  });

check_NF_terms_subset ::
  forall a b. (Term a b -> Bool) -> [Term a b] -> Sum (Term a b) ();
check_NF_terms_subset is_Q_nf =
  (\ q ->
    catch_errora
      (forallM (\ x -> (if not (is_Q_nf x) then Inr () else Inl x)) q)
      (\ x -> Inl (snd x)));

check_NF_terms_eq ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_terms_eq qa q =
  bindb (check_NF_terms_subset (is_NF_terms qa) q)
    (\ _ -> check_NF_terms_subset (is_NF_terms q) qa);

check_dpp_subsumes ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c, Showa c, Ccompare d, Eq d,
      Mapping_impl d,
      Showa d) => Dpp_ops_ext a (Lab b c) d () ->
                    (Bool,
                      (Bool,
                        ([(Term (Lab b c) d, Term (Lab b c) d)],
                          ([(Term (Lab b c) d, Term (Lab b c) d)],
                            ([Term (Lab b c) d],
                              ([(Term (Lab b c) d, Term (Lab b c) d)],
                                [(Term (Lab b c) d, Term (Lab b c) d)])))))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dpp_subsumes i (nfs, (m, (p, (pw, (q, (r, rw)))))) d =
  catch_errora
    (let {
       pa = pb i d;
       pwa = pwb i d;
       qa = qc i d;
       ra = rd i d;
       rwa = rwd i d;
       nfsa = nfsc i d;
       ma = minimal i d;
       pba = p ++ pw;
       rb = ra ++ rwa;
       rba = r ++ rw;
     } in bindb (check (ma == m)
                  (shows_prec_list zero_nat
                    ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e',
                      ' ', 'm', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                      ' ', 'f', 'l', 'a', 'g', 's']))
            (\ _ ->
              bindb (check (nfsa == nfs)
                      (shows_prec_list zero_nat
                        ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l',
                          'e', ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't',
                          'i', 'o', 'n', 's', '-', 'i', 'n', '-', 'n', 'o', 'r',
                          'm', 'a', 'l', '-', 'f', 'o', 'r', 'm', ' ', 'f', 'l',
                          'a', 'g', 's']))
                (\ _ ->
                  bindb (catch_errora (check_subseteq pa p)
                          (\ x ->
                            Inl (toomuch ['p', 'a', 'i', 'r']
                                  (shows_rule (shows_prec_lab zero_nat)
                                    (shows_prec zero_nat) [' ', '-', '>', ' ']
                                    x))))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq pwa pba)
                              (\ x ->
                                Inl (toomuch
                                      ['w', 'e', 'a', 'k', ' ', 'p', 'a', 'i',
'r']
                                      (shows_rule (shows_prec_lab zero_nat)
(shows_prec zero_nat) [' ', '-', '>', ' '] x))))
                        (\ _ ->
                          bindb (catch_errora (check_NF_terms_eq qa q)
                                  (\ x ->
                                    Inl (shows_prec_list zero_nat
   ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f', 'f', 'e', 'r', 's', ' ', 'd',
     'u', 'e', ' ', 't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
  shows_term (shows_prec_lab zero_nat) (shows_prec zero_nat) x)))
                            (\ _ ->
                              bindb (catch_errora (check_subseteq ra r)
                                      (\ x ->
Inl (toomuch ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e']
      (shows_rule (shows_prec_lab zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] x))))
                                (\ _ ->
                                  bindb (catch_errora (check_subseteq rb rba)
  (\ x ->
    Inl (toomuch
          ['s', 't', 'r', 'i', 'c', 't', '/', 'w', 'e', 'a', 'k', ' ', 'r', 'u',
            'l', 'e']
          (shows_rule (shows_prec_lab zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] x))))
                                    (\ _ ->
                                      bindb
(catch_errora (check_subseteq rba rb)
  (\ x ->
    Inl (missing
          ['s', 't', 'r', 'i', 'c', 't', '/', 'w', 'e', 'a', 'k', ' ', 'r', 'u',
            'l', 'e']
          (shows_rule (shows_prec_lab zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] x))))
(\ _ -> Inr ())))))))))
    (\ x ->
      Inl (shows_string
             ['f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'o', 'f',
               ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
            shows_nl .
              shows_dpp (shows_prec_lab zero_nat) (shows_prec zero_nat) i d .
                shows_nl .
                  shows_string
                    ['m', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'c',
                      'o', 'n', 'c', 'l', 'u', 'd', 'e', 'd', ' ', 'f', 'r',
                      'o', 'm', ' ', 'a', 's', 's', 'u', 'm', 'i', 'n', 'g',
                      ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's',
                      ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o',
                      'b', 'l', 'e', 'm'] .
                    shows_nl .
                      shows_dpp (shows_prec_lab zero_nat) (shows_prec zero_nat)
                        i (mkd i nfs m p pw q r rw) .
                        shows_nl . x . shows_nl));

fcc_proc ::
  forall a b c.
    (Eq b, Showa b, Ceq c, Ccompare c, Eq c, Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
fcc_proc i f fcs pba rw dpp =
  let {
    p = pb i dpp;
    q = qc i dpp;
    r = rd i dpp;
    (pa, pw) = partition_pairs f p pba;
  } in bindb (check (null q)
               (shows_string
                  ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p',
                    't', 'y'] .
                 shows_nl))
         (\ _ ->
           bindb (check (null r)
                   (shows_prec_list zero_nat
                     ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e',
                       's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                       'e', 'd']))
             (\ _ ->
               bindb (check_left_linear_trs (rwd i dpp))
                 (\ _ -> fcc_proc_cond i f fcs pa pw [] rw dpp)));

q_reduction_proc_non_min ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc_non_min i q dpp =
  (case catch_errora
          (bindb
            (catch_errora (check_NF_terms_subset (is_QNFc i dpp) q)
              (\ x ->
                Inl (shows_prec_list zero_nat
                       ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                      shows_prec_term zero_nat x .
                        shows_prec_list zero_nat
                          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l',
                            'l', 'o', 'w', 'e', 'd', ' ', 'i', 'n', ' ', 'Q',
                            '\'', ' '])))
            (\ _ -> Inr ()))
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'r', 'e', 'd', 'u', 'c', 'i', 'n', 'g', ' ', 'Q', ' ',
                     'i', 'n', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r',
                     'o', 'b', 'l', 'e', 'm', ' '] .
                  shows_nl .
                    shows_dpp (shows_prec zero_nat) (shows_prec zero_nat) i
                      dpp .
                      shows_nl .
                        shows_prec_list zero_nat
                          ['t', 'o', ' ', 't', 'h', 'e', ' ', 's', 'e', 't',
                            ' '] .
                          shows_nl .
                            shows_terms (shows_prec zero_nat)
                              (shows_prec zero_nat) ['Q', '\'', ':'] q .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (mkd i (nfsc i dpp) False (pb i dpp) (pwb i dpp) q (rd i dpp)
            (rwd i dpp));
  });

q_reduction_proc_min_inn ::
  forall a b c.
    (Eq b, Key b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc_min_inn i q dpp =
  let {
    pba = pairsb i dpp;
    rb = rulese i dpp;
    f = map Just (funas_trs_list (pba ++ rb));
    qa = qc i dpp;
    isnf = is_QNFc i dpp;
    qq = filter (\ qb -> all isnf (args qb)) qa;
    rQ = filter (\ qb -> membera f (root qb)) qq;
  } in (case catch_errora
               (bindb
                 (check (nFQ_subset_NF_rulesc i dpp)
                   (shows_prec_list zero_nat
                     ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r',
                       'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'r', 'e',
                       'q', 'u', 'i', 'r', 'e', 'd']))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       bindb (catch_errora
                               (check_NF_terms_subset (is_NF_terms q) rQ)
                               (\ x ->
                                 Inl (shows_prec_list zero_nat
['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                                       shows_prec_term zero_nat x .
 shows_prec_list zero_nat
   [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 'n', ' ',
     'Q', '\'', ' '])))
                         (\ _ ->
                           bindb (catch_errora
                                   (check_NF_terms_subset (is_NF_terms qq) q)
                                   (\ x ->
                                     Inl (shows_prec_list zero_nat
    ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
   shows_prec_term zero_nat x .
     shows_prec_list zero_nat
       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
         'd', ' ', 'i', 'n', ' ', 'Q', '\'', ' '])))
                             (\ _ ->
                               (if nfsc i dpp then Inr ()
                                 else check_varcond_subset pba))))))
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                          'n', ' ', 'r', 'e', 'd', 'u', 'c', 'i', 'n', 'g', ' ',
                          'Q', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                          ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                       shows_nl .
                         shows_dpp (shows_prec zero_nat) (shows_prec zero_nat) i
                           dpp .
                           shows_nl .
                             shows_prec_list zero_nat
                               ['t', 'o', ' ', 't', 'h', 'e', ' ', 's', 'e',
                                 't', ' '] .
                               shows_nl .
                                 shows_terms (shows_prec zero_nat)
                                   (shows_prec zero_nat) ['Q', '\'', ':'] q .
                                   shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (mkd i (nfsc i dpp) (minimal i dpp) (pb i dpp) (pwb i dpp) q
                 (rd i dpp) (rwd i dpp));
       });

q_reduction_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc i q dpp = (case q_reduction_proc_min_inn i q dpp of {
                             Inl _ -> q_reduction_proc_non_min i q dpp;
                             Inr a -> Inr a;
                           });

get_fcc_option ::
  forall a b c.
    Dp_termination_proof a b c ->
      Maybe (Lab a b,
              ([Ctxt (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  ([(Term (Lab a b) c, Term (Lab a b) c)],
                    Dp_termination_proof a b c))));
get_fcc_option (Fcc_Proc f fcs pb rb prf) = Just (f, (fcs, (pb, (rb, prf))));
get_fcc_option P_is_Empty = Nothing;
get_fcc_option (Subterm_Criterion_Proc v va vb vc) = Nothing;
get_fcc_option (Gen_Subterm_Criterion_Proc v va vb) = Nothing;
get_fcc_option (Redpair_Proc v va vb) = Nothing;
get_fcc_option (Redpair_UR_Proc v va vb vc) = Nothing;
get_fcc_option (Usable_Rules_Proc v va) = Nothing;
get_fcc_option (Dep_Graph_Proc v) = Nothing;
get_fcc_option (Mono_Redpair_Proc v va vb vc) = Nothing;
get_fcc_option (Mono_URM_Redpair_Proc v va vb vc) = Nothing;
get_fcc_option (Mono_Redpair_UR_Proc v va vb vc vd) = Nothing;
get_fcc_option (Size_Change_Subterm_Proc v) = Nothing;
get_fcc_option (Size_Change_Redpair_Proc v va vb) = Nothing;
get_fcc_option (Uncurry_Proc v va vb vc vd) = Nothing;
get_fcc_option (Split_Proc v va vb vc) = Nothing;
get_fcc_option (Semlab_Proc v va vb vc vd) = Nothing;
get_fcc_option (Switch_Innermost_Proc v va) = Nothing;
get_fcc_option (Rewriting_Proc v va vb vc vd ve vf) = Nothing;
get_fcc_option (Instantiation_Proc v va vb) = Nothing;
get_fcc_option (Forward_Instantiation_Proc v va vb vc) = Nothing;
get_fcc_option (Narrowing_Proc v va vb vc) = Nothing;
get_fcc_option (Assume_Finite v va) = Nothing;
get_fcc_option (Unlab_Proc v va vb) = Nothing;
get_fcc_option (Q_Reduction_Proc v va) = Nothing;
get_fcc_option (Complex_Constant_Removal_Proc v va) = Nothing;
get_fcc_option (General_Redpair_Proc v va vb vc vd) = Nothing;
get_fcc_option (To_Trs_Proc v) = Nothing;

uncurry_of_top_sig_list ::
  forall a.
    a -> Nat ->
           [((a, Nat), [a])] ->
             (a -> Nat -> [a]) ->
               [(Term a [Prelude.Char], Term a [Prelude.Char])];
uncurry_of_top_sig_list a m sml sm =
  concatMap
    (\ (b, c) ->
      let {
        (f, n) = b;
      } in (\ _ ->
             let {
               g = get_symbol sm f n;
             } in map (\ i ->
                        (Fun a (generate_f_xs (g i) (plus_nat n i) :
                                 map (\ ia -> Var (generate_var ia))
                                   (upt (plus_nat n i)
                                     (plus_nat (plus_nat n i)
                                       (minus_nat m one_nat)))),
                          generate_f_xs (g (suc i))
                            (plus_nat (plus_nat n i) (minus_nat m one_nat))))
                    (upt zero_nat (aarity sm f n)))
        c)
    sml;

eta_closed_top_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => a -> Nat ->
                         (a -> Nat -> [a]) ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
eta_closed_top_rules a n sm r p =
  catch_errora
    (forallM
      (\ (l, ra) ->
        (case l of {
          Var _ -> Inr ();
          Fun ff ls ->
            check (equal_nat (aarity sm ff (size_list ls)) zero_nat ||
                    any (\ (lll, rrr) ->
                          (case (lll, rrr) of {
                            (Var _, _) -> False;
                            (Fun _ [], _) -> False;
                            (Fun _ (_ : _), Var _) -> False;
                            (Fun _ (_ : _), Fun _ []) -> False;
                            (Fun f (ll : yy), Fun g (rr : zz)) ->
                              f == a &&
                                g == a &&
                                  zz == yy &&
                                    equal_nat (size_list yy)
                                      (minus_nat n one_nat) &&
                                      distinct yy &&
all is_Var yy &&
  null (list_inter (map the_Var yy) (insert_vars_rule (ll, rr) [])) &&
    instance_rule (l, ra) (ll, rr);
                          }))
                      p)
              ((shows_prec_list zero_nat
                  ['e', 't', 'a', ' ', 'e', 'x', 'p', 'a', 'n', 's', 'i', 'o',
                    'n', ' ', 'o', 'f', ' '] .
                 shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                   [' ', '-', '>', ' '] (l, ra)) .
                shows_prec_list zero_nat
                  [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']);
        }))
      r)
    (\ x -> Inl (snd x));

uncurry_top_rules ::
  forall a b.
    (Eq a) => a -> Nat ->
                     (a -> Nat -> [a]) ->
                       [(Term a b, Term a b)] -> [(Term a b, Term a b)];
uncurry_top_rules a n sm =
  map (\ (l, r) -> (uncurry_top a n sm l, uncurry_top a n sm r));

map_funs_rules_wa ::
  forall a b c.
    ((a, Nat) -> b) -> [(Term a c, Term a c)] -> [(Term b c, Term b c)];
map_funs_rules_wa fg r =
  map (\ (l, ra) -> (map_funs_term_wa fg l, map_funs_term_wa fg ra)) r;

uncurry_top_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      Nat ->
                        ([((b, Nat), [b])] -> b -> Nat -> b) ->
                          (b -> Nat ->
                                  [((b, Nat), [b])] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char])
                                      ()) ->
                            [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                              [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                                a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_top_proc i info n fmap check_inj p r dpp =
  let {
    (a, (sml, (u, eb))) = info;
    pa = pb i dpp;
    pw = pwb i dpp;
    ra = rd i dpp;
    rw = rwd i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (e, ew) = uncurry_eta_split eb ra;
    sm = sig_list_to_sig_map a sml fmap;
    p_eta = e ++ pa;
    pw_eta = ew ++ pw;
    uP = uncurry_top_rules a n sm p_eta;
    uPw = uncurry_top_rules a n sm pw_eta;
    uR = map_funs_rules_wa (\ (f, na) -> get_symbol sm f na zero_nat) ra;
    uRw = map_funs_rules_wa (\ (f, na) -> get_symbol sm f na zero_nat) rw;
  } in (case bindb (check (null (qc i dpp))
                     (shows_prec_list zero_nat
                       ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'c', 'u',
                         'r', 'r', 'e', 'n', 't', 'l', 'y', ' ', 'u', 'n', 's',
                         'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
               (\ _ ->
                 bindb (check (not (equal_nat n zero_nat))
                         (shows_prec_list zero_nat
                           ['t', 'h', 'e', ' ', 'a', 'r', 'i', 't', 'y', ' ',
                             'o', 'f', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c',
                             'u', 'r', 'r', 'i', 'e', 'd', ' ', 's', 'y', 'm',
                             'b', 'o', 'l', ' ', 'm', 'u', 's', 't', ' ', 'b',
                             'e', ' ', 'a', 't', ' ', 'l', 'e', 'a', 's', 't',
                             ' ', '1']))
                   (\ _ ->
                     bindb (check_inj a n sml)
                       (\ _ ->
                         let {
                           pba = pairsb i dpp;
                           is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
                           rm = rules_mapc i dpp;
                         } in bindb (catch_errora
                                      (forallM
(\ (l, _) ->
  check (not (is_Var l))
    (shows_prec_list zero_nat
      ['l', 'h', 's', ' ', 'a', 's', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
        'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
        'e', 'd']))
(ra ++ rw))
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  bindb (catch_errora
  (forallM
    (\ (l, rb) ->
      bindb (check (hvf_top a n l)
              (shows_prec_list zero_nat
                 ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
                   'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                shows_term (shows_prec zero_nat) (shows_prec_list zero_nat) l .
                  shows_prec_list zero_nat
                    [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
                      'd']))
        (\ _ -> check_no_var rb))
    (pw_eta ++ p_eta))
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora
  (forallM
    (\ (_, rb) ->
      check (not (is_def (the (root rb))))
        (shows_prec_list zero_nat ['r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
          shows_term (shows_prec zero_nat) (shows_prec_list zero_nat) rb .
            shows_prec_list zero_nat
              [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ',
                'd', 'e', 'f', 'i', 'n', 'e', 'd']))
    pba)
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (check (not (is_def (a, n)))
          (shows_prec_list zero_nat
             ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 's',
               'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec zero_nat a .
              shows_prec_list zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e',
                  ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ',
                  'R']))
    (\ _ ->
      bindb (if any (\ (_, rb) ->
                      the (root rb) == (a, n) &&
                        equal_gctxt (tcapRM2 rm (hda (args rb))) GCHole)
                  pba
              then bindb (catch_errora
                           (check_CS_subseteq
                             (uncurry_of_top_sig_list a n sml sm) u)
                           (\ x ->
                             Inl (shows_prec_list zero_nat
                                    ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'i',
                                      'n', 'g', ' ', 'p', 'a', 'i', 'r', ' '] .
                                   shows_rule (shows_prec zero_nat)
                                     (shows_prec_list zero_nat)
                                     [' ', '-', '>', ' '] x .
                                     shows_prec_list zero_nat
                                       [' ', 'i', 's', ' ', 'm', 'i', 's', 's',
 'i', 'n', 'g', ' ', 'i', 'n'] .
                                       shows_nl .
 shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] u)))
                     (\ _ ->
                       bindb (eta_closed_top_rules a n sm ra p_eta)
                         (\ _ -> eta_closed_top_rules a n sm rw pw_eta))
              else Inr ())
        (\ _ ->
          bindb (catch_errora (check_subseteq uP p)
                  (\ x ->
                    Inl (shows_prec_list zero_nat
                           ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ',
                             'p', 'a', 'i', 'r', ' '] .
                          shows_rule (shows_prec zero_nat)
                            (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                            shows_prec_list zero_nat
                              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                                'g'])))
            (\ _ ->
              bindb (catch_errora (check_subseteq uPw p)
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd',
                                 ' ', 'p', 'a', 'i', 'r', ' '] .
                              shows_rule (shows_prec zero_nat)
                                (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                x .
                                shows_prec_list zero_nat
                                  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i',
                                    'n', 'g'])))
                (\ _ ->
                  bindb (catch_errora (check_subseteq u p)
                          (\ x ->
                            Inl (shows_prec_list zero_nat
                                   ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'i', 'n',
                                     'g', ' ', 'p', 'a', 'i', 'r', ' '] .
                                  shows_rule (shows_prec zero_nat)
                                    (shows_prec_list zero_nat)
                                    [' ', '-', '>', ' '] x .
                                    shows_prec_list zero_nat
                                      [' ', 'i', 's', ' ', 'm', 'i', 's', 's',
'i', 'n', 'g', ' ', 'i', 'n', ' ', 'n', 'e', 'w', ' ', 'p', 'a', 'i', 'r',
's'])))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq uR r)
                              (\ x ->
                                Inl (shows_prec_list zero_nat
                                       ['r', 'u', 'l', 'e', ' '] .
                                      shows_rule (shows_prec zero_nat)
(shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
shows_prec_list zero_nat
  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 'n', ' ',
    'n', 'e', 'w', ' ', 'r', 'u', 'l', 'e', 's'])))
                        (\ _ ->
                          catch_errora (check_subseteq uRw r)
                            (\ x ->
                              Inl (shows_prec_list zero_nat
                                     ['r', 'u', 'l', 'e', ' '] .
                                    shows_rule (shows_prec zero_nat)
                                      (shows_prec_list zero_nat)
                                      [' ', '-', '>', ' '] x .
                                      shows_prec_list zero_nat
[' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 'n', ' ', 'n',
  'e', 'w', ' ', 'r', 'u', 'l', 'e', 's']))))))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkd i nfs m uP (uPw ++ u) [] uR uRw);
       });

only_eta_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
only_eta_rules e r_eta =
  catch_errora
    (forallM
      (\ (l, r) ->
        check (case (l, r) of {
                (Var _, _) -> False;
                (Fun _ _, Var _) -> False;
                (Fun f ls, Fun g rs) ->
                  f == g &&
                    equal_nat (size_list ls) (nat_of_integer (2 :: Integer)) &&
                      equal_nat (size_list rs)
                        (nat_of_integer (2 :: Integer)) &&
                        equal_term (nth ls one_nat) (nth rs one_nat) &&
                          any (\ (la, ra) ->
                                instance_rule (hda ls, hda rs) (la, ra))
                            r_eta;
              })
          (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] (l, r) .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', '(',
                  'e', 't', 'a', '-', 'e', 'x', 'p', 'a', 'n', 'd', 'e', 'd',
                  ')', ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 'r',
                  'u', 'l', 'e']))
      e)
    (\ x -> Inl (snd x));

uncurry_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      ([((b, Nat), [b])] -> b -> Nat -> b) ->
                        (b -> Nat ->
                                [((b, Nat), [b])] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_proc i info fmap check_inj p r dpp =
  let {
    (a, (sml, (u, eb))) = info;
    pa = pb i dpp;
    pw = pwb i dpp;
    ra = rd i dpp;
    rw = rwd i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (e, ew) = uncurry_eta_split eb ra;
    sm = sig_list_to_sig_map a sml fmap;
    uP = uncurry_rules a sm pa;
    uPw = uncurry_rules a sm pw;
    r_eta = e ++ ra;
    rw_eta = ew ++ rw;
    uR = uncurry_rules a sm r_eta;
    uRw = uncurry_rules a sm rw_eta;
  } in (case let {
               s = uncurry_of_sig_list a sml sm;
             } in bindb (check (null (qc i dpp))
                          (shows_prec_list zero_nat
                            ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'n',
                              'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
                              'e', 'd', ' ', 'f', 'o', 'r', ' ', 'u', 'n', 'c',
                              'u', 'r', 'r', 'y', 'i', 'n', 'g']))
                    (\ _ ->
                      bindb (only_eta_rules e r_eta)
                        (\ _ ->
                          bindb (only_eta_rules ew rw_eta)
                            (\ _ ->
                              bindb (check_inj a (nat_of_integer (2 :: Integer))
                                      sml)
                                (\ _ ->
                                  bindb (catch_errora
  (forallM
    (\ (l, _) ->
      check (not (is_Var l))
        (shows_prec_list zero_nat
          ['l', 'h', 's', ' ', 'a', 's', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
            'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
            'w', 'e', 'd']))
    (ra ++ rw))
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora
  (forallM
    (\ (l, _) ->
      check (hvf_term a l)
        (shows_prec_list zero_nat
           ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
             ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
          shows_term (shows_prec zero_nat) (shows_prec_list zero_nat) l .
            shows_prec_list zero_nat
              [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
    pa)
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (catch_errora
          (forallM
            (\ (l, _) ->
              check (hvf_term a l)
                (shows_prec_list zero_nat
                   ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
                     'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                  shows_term (shows_prec zero_nat) (shows_prec_list zero_nat)
                    l .
                    shows_prec_list zero_nat
                      [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
                        'd']))
            pw)
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ (l, _) ->
                  check (hvf_term a l)
                    (shows_prec_list zero_nat
                       ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b',
                         'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                      shows_term (shows_prec zero_nat)
                        (shows_prec_list zero_nat) l .
                        shows_prec_list zero_nat
                          [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                            'e', 'd']))
                r_eta)
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (catch_errora
                  (forallM
                    (\ (l, _) ->
                      check (hvf_term a l)
                        (shows_prec_list zero_nat
                           ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a',
                             'b', 'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's',
                             ' '] .
                          shows_term (shows_prec zero_nat)
                            (shows_prec_list zero_nat) l .
                            shows_prec_list zero_nat
                              [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                                'e', 'd']))
                    rw_eta)
                  (\ x -> Inl (snd x)))
            (\ _ ->
              bindb (eta_closed_rules a sm r_eta r_eta)
                (\ _ ->
                  bindb (eta_closed_rules a sm rw_eta rw_eta)
                    (\ _ ->
                      bindb (catch_errora (check_subseteq uP p)
                              (\ x ->
                                Inl (shows_prec_list zero_nat
                                       ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e',
 'd', ' ', 'p', 'a', 'i', 'r', ' '] .
                                      shows_rule (shows_prec zero_nat)
(shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
shows_prec_list zero_nat
  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                        (\ _ ->
                          bindb (catch_errora (check_subseteq uPw p)
                                  (\ x ->
                                    Inl (shows_prec_list zero_nat
   ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'p', 'a', 'i', 'r', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] x .
    shows_prec_list zero_nat
      [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                            (\ _ ->
                              bindb (catch_errora (check_subseteq uR r)
                                      (\ x ->
Inl (shows_prec_list zero_nat
       ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
         ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
        [' ', '-', '>', ' '] x .
        shows_prec_list zero_nat
          [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                                (\ _ ->
                                  bindb (catch_errora (check_subseteq uRw r)
  (\ x ->
    Inl (shows_prec_list zero_nat
           ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l',
             'e', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
            [' ', '-', '>', ' '] x .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                                    (\ _ ->
                                      bindb
(catch_errora (check_CS_subseteq s u)
  (\ x ->
    Inl (shows_prec_list zero_nat
           ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l', 'e', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
            [' ', '-', '>', ' '] x .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
(\ _ ->
  bindb (catch_errora (check_CS_subseteq u s)
          (\ x ->
            Inl (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                    [' ', '-', '>', ' '] x .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ',
                        'u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l',
                        'e'])))
    (\ _ ->
      catch_errora (check_subseteq u r)
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l', 'e',
                   ' '] .
                shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                  [' ', '-', '>', ' '] x .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ',
                      'i', 'n', ' ', 'n', 'e', 'w', ' ', 'T', 'R',
                      'S'])))))))))))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkd i nfs m uP uPw [] uR (uRw ++ u));
       });

uncurry_proc_both ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Dpp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Maybe Nat ->
                      (Lab b c,
                        ([((Lab b c, Nat), [Lab b c])],
                          ([(Term (Lab b c) [Prelude.Char],
                              Term (Lab b c) [Prelude.Char])],
                            [(Term (Lab b c) [Prelude.Char],
                               Term (Lab b c) [Prelude.Char])]))) ->
                        [(Term (Lab b c) [Prelude.Char],
                           Term (Lab b c) [Prelude.Char])] ->
                          [(Term (Lab b c) [Prelude.Char],
                             Term (Lab b c) [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_proc_both i Nothing (a, (sml, (u, eb))) =
  uncurry_proc i (a, (sml, (u, eb))) (fmap a (nat_of_integer (2 :: Integer)))
    check_inj;
uncurry_proc_both i (Just n) (a, (sml, (u, eb))) =
  uncurry_top_proc i (a, (sml, (u, eb))) n (fmap a n) check_inj;

check_rewrite_common_preconditions ::
  forall a b c d.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      (Term b [Prelude.Char], Term c [Prelude.Char]) ->
                        [Term b [Prelude.Char]] ->
                          [Term b [Prelude.Char]] ->
                            d -> (Term b [Prelude.Char],
                                   Term b [Prelude.Char]) ->
                                   Pos ->
                                     Bool ->
                                       a ->
 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rewrite_common_preconditions i u_opt st ss ts t lr p sound dpp =
  let {
    r = rulese i dpp;
    s = fst st;
    ta = snd st;
    tp = subt_at ta p;
    u = (case u_opt of {
          Nothing -> concatMap (\ tb -> inn_usable_rules_pair i dpp (s, tb)) ts;
          Just u -> u;
        });
  } in bindb (catch_errora (check_subseteq u r)
               (\ x ->
                 Inl (shows_rule (shows_prec zero_nat)
                        (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'u', 'l', 'e', ' ', 'o', 'f', ' ', 't', 'h', 'e',
                           ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                           'y', 's', 't', 'e', 'm', ' '])))
         (\ _ ->
           let {
             urc = is_ur_closed_impl_dpp_mv i dpp u;
             check_urc =
               (\ sa tb ->
                 check (urc sa tb)
                   (shows_prec_list zero_nat ['t', 'e', 'r', 'm', ' '] .
                     shows_prec_term zero_nat tb .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l', 'o',
                           's', 'e', 'd', ' ', 'u', 'n', 'd', 'e', 'r', ' ',
                           'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                           'e', 's']));
             nfs = nfsc i dpp;
           } in bindb (catch_errora
                        (forallM
                          (\ (l, _) ->
                            check (not (is_Var l))
                              (shows_prec_list zero_nat
                                ['l', 'h', 's', 's', ' ', 'm', 'u', 's', 't',
                                  ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'v',
                                  'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
                          u)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    bindb (check (wf_rule lr)
                            (shows_rule (shows_prec zero_nat)
                               (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                               lr .
                              shows_prec_list zero_nat
                                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                  ' ', 'w', 'e', 'l', 'l', ' ', 'f', 'o', 'r',
                                  'm', 'e', 'd', ' ', 'r', 'u', 'l', 'e']))
                      (\ _ ->
                        bindb (if nfs && sound then Inr ()
                                else catch_errora
                                       (check_subseteq (vars_term_list tp)
 (vars_term_list s))
                                       (\ _ ->
 Inl (shows_prec_list zero_nat
       ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'n', 'd', 'i',
         't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'v',
         'i', 'o', 'l', 'a', 't', 'e', 'd'])))
                          (\ _ ->
                            bindb (catch_errora (forallM (check_urc ss) ts)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (catch_errora
(forallM (\ (l, a) -> check_urc (args l) a) u) (\ x -> Inl (snd x)))
                                  (\ _ ->
                                    bindb (catch_errora
    (check_critical_pairs_innermost u)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's', 'h',
               'o', 'w', 'i', 'n', 'g', ' ', 'U', 'N', 'F', ' ', 'o', 'f', ' ',
               'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
            shows_nl . x)))
                                      (\ _ ->
catch_errora
  (forallM
    (\ (_, (sa, tb)) ->
      check (equal_term sa tb)
        (shows_prec_list zero_nat
          ['n', 'o', 'n', '-', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ', 'c', 'r',
            'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'a', 'i', 'r', ' ', 'b',
            'e', 't', 'w', 'e', 'e', 'n', ' ', 'r', 'u', 'l', 'e', ' ', 't',
            'o', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 'a', 'n', 'd',
            ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']))
    (critical_pairs_impl [lr] u))
  (\ x -> Inl (snd x)))))))));

check_prop_rstepa ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstepa nfs pa r p rule s t =
  bindb (check (membera r rule)
          (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] rule .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r', 'u', 'l',
                'e', ' ', 'o', 'f'] .
              shows_nl .
                shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                  ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't',
                    'e', 'm', ':']
                  [' ', '-', '>', ' '] r .
                  shows_nl))
    (\ _ -> check_prop_rstep_rule nfs pa p rule s t);

check_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Pos ->
                      (Term a b, Term a b) ->
                        Term a b ->
                          Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rstep = check_prop_rstepa False (\ _ -> Inr ());

rewriting_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                        (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                          (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                            (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                              Pos ->
                                a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rewriting_proc i u stb sta st lr p dpp =
  (case let {
          s = fst stb;
          t = snd sta;
        } in bindb (check_rstep (rulese i dpp) p lr (snd stb) t)
               (\ _ ->
                 bindb (check (nFQ_subset_NF_rulesc i dpp)
                         (shows_prec_list zero_nat
                           ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ',
                             'r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                             'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                   (\ _ ->
                     bindb (check_rewrite_common_preconditions i u stb [s]
                             [subt_at (snd stb) p] t lr p True dpp)
                       (\ _ ->
                         bindb (check (eq_rule_mod_vars sta st)
                                 (shows_prec_list zero_nat
                                    ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                                      ' '] .
                                   shows_rule (shows_prec zero_nat)
                                     (shows_prec_list zero_nat)
                                     [' ', '-', '>', ' '] sta .
                                     shows_prec_list zero_nat
                                       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
 'a', ' ', 'r', 'e', 'n', 'a', 'm', 'e', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'n',
 't', ' ', 'o', 'f', ' '] .
                                       shows_rule (shows_prec zero_nat)
 (shows_prec_list zero_nat) [' ', '-', '>', ' '] st))
                           (\ _ ->
                             bindb (check (equal_term s (fst sta))
                                     (shows_prec_list zero_nat
                                       ['l', 'e', 'f', 't', '-', 'h', 'a', 'n',
 'd', ' ', 's', 'i', 'd', 'e', 's', ' ', 'o', 'f', ' ', 'o', 'l', 'd', ' ', 'a',
 'n', 'd', ' ', 'n', 'e', 'w', ' ', 'p', 'a', 'i', 'r', ' ', 'd', 'i', 'f', 'f',
 'e', 'r']))
                               (\ _ ->
                                 bindb (check
 (membera (pb i dpp) stb || null (rd i dpp))
 (shows_prec_list zero_nat
   ['s', 't', 'r', 'i', 'c', 't', ' ', 'D', 'P', ' ', 'o', 'r', ' ', 'n', 'o',
     ' ', 's', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'r',
     'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                                   (\ _ ->
                                     check (nfsc i dpp || wwf_rulesa i dpp)
                                       (shows_prec_list zero_nat
 ['w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd', ' ', 'r', 'u', 'l',
   'e', 's', ' ', 'o', 'r', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 's', 'u',
   'b', 's', 't', '.', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'])))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp stb [st]);
  });

nF_subst_impl ::
  forall a b.
    (Term a b -> Bool) ->
      Bool -> (Term a b, Term a b) -> (b -> Term a b) -> Bool;
nF_subst_impl nf nfs r sigma =
  (if nfs then all (\ x -> nf (sigma x)) (vars_rule_list r) else True);

qnarrows_impl ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                Bool ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Term a [Prelude.Char] ->
                      [(Term a [Prelude.Char],
                         [Prelude.Char] -> Term a [Prelude.Char])];
qnarrows_impl isnf nfs r t =
  concatMap
    (\ p ->
      let {
        tp = subt_at t p;
      } in (if not (is_Var tp)
             then concatMap
                    (\ (l, ra) ->
                      concatMap
                        (\ (mu_1, mu_2) ->
                          (if nF_subst_impl isnf nfs (l, ra) mu_2
                            then (if all isnf (args (subst_apply_term l mu_2))
                                   then [(ctxt_apply_term
    (ctxt_of_pos_term p (subst_apply_term t mu_1)) (subst_apply_term ra mu_2),
   mu_1)]
                                   else [])
                            else []))
                        (option_to_list
                          (mgu_var_disjoint_generic (\ a -> 'x' : a)
                            (\ a -> 'y' : a) tp l)))
                    r
             else []))
    (poss_list t);

narrowing_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      Pos ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
narrowing_proc i st p sts dpp =
  (case let {
          (s, t) = st;
          q = qc i dpp;
        } in bindb (check
                     (nFQ_subset_NF_rulesc i dpp || null q && linear_term t)
                     (shows_prec_list zero_nat
                       ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'o',
                         'r', ' ', 'f', 'u', 'l', 'l', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'r', 'e', 'q', 'u', 'i',
                         'r', 'e', 'd', ' ', '(', 'a', 'n', 'd', ' ', 'l', 'i',
                         'n', 'e', 'a', 'r', 'i', 't', 'y', ' ', 'o', 'f', ' ',
                         't', ' ', 'i', 'n', ' ', 'f', 'u', 'l', 'l', ' ', 'r',
                         'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'c', 'a',
                         's', 'e', ')']))
               (\ _ ->
                 let {
                   ic = icap_impl_dpp_mv i dpp;
                   isnf = is_QNFc i dpp;
                   pairs = pairsb i dpp;
                 } in bindb (check (membera (poss_list t) p)
                              (shows_prec_list zero_nat
                                 ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ',
                                   'n', 'o', 't', ' ', 'c', 'o', 'n', 't', 'a',
                                   'i', 'n', 'e', 'd', ' ', 'i', 'n', ' '] .
                                shows_prec_term zero_nat t))
                        (\ _ ->
                          let {
                            tp = subt_at t p;
                            nftp = isnf tp;
                          } in bindb (check
                                       (membera (poss_list (ic [s] t)) p ||
 not nftp)
                                       (shows_prec_list zero_nat
 ['n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'i', 's', ' ', 'p', 'o', 's', 'i',
   't', 'i', 'o', 'n', ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 'e', 'd', ' ',
   'i', 'n', ' ', 'c', 'a', 'p', 'p', 'e', 'd', ' ', 't', 'e', 'r', 'm', ' ',
   'o', 'f', ' ', 't', ',', ' ', 'n', 'o', 'r', ' ', 'i', 's', ' ', 't', '|',
   '_', 'p', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'Q', '-', 'n', 'o', 'r',
   'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']))
                                 (\ _ ->
                                   let {
                                     nfs = nfsc i dpp;
                                     narrows =
                                       qnarrows_impl isnf nfs (rulese i dpp) tp;
                                     stsa =
                                       filter (\ (smu, _) -> isnf smu)
 (map (\ (ta, mu) ->
        (subst_apply_term s mu,
          ctxt_apply_term (ctxt_of_pos_term p (subst_apply_term t mu)) ta))
   narrows);
                                   } in bindb
  (catch_errora
    (forallM
      (\ new ->
        check (any (\ sta ->
                     instance_rule new sta &&
                       (not nfs || (null q || wf_rule sta)))
                sts)
          (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
               'd', ' ', 'n', 'a', 'r', 'r', 'o', 'w', 'e', 'd', ' ', 'p', 'a',
               'i', 'r', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
              [' ', '-', '>', ' '] new))
      stsa)
    (\ x -> Inl (snd x)))
  (\ _ ->
    let {
      iedg = is_iedg_edge_dpp i dpp (s, t);
    } in bindb (catch_errora
                 (check_subseteq (vars_term_list tp) (vars_term_list s))
                 (\ x ->
                   Inl (shows_prec_list zero_nat
                         (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] ++
                           x ++ [' ', 'o', 'n', 'l', 'y', ' ', 'o', 'c', 'c',
                                  'u', 'r', 's', ' ', 'o', 'n', ' ', 'r', 'h',
                                  's', ' ', 'o', 'f', ' ', 'p', 'a', 'i',
                                  'r']))))
           (\ _ ->
             bindb (check (membera (pb i dpp) st || null (rd i dpp))
                     (shows_prec_list zero_nat
                       ['s', 't', 'r', 'i', 'c', 't', ' ', 'D', 'P', ' ', 'o',
                         'r', ' ', 'n', 'o', ' ', 's', 't', 'r', 'i', 'c', 't',
                         ' ', 'r', 'u', 'l', 'e', 's', ' ', 'r', 'e', 'q', 'u',
                         'i', 'r', 'e', 'd']))
               (\ _ ->
                 (if nftp
                   then catch_errora
                          (forallM
                            (\ (u, v) ->
                              bindb (check (membera (poss_list u) p)
                                      (shows_prec_list zero_nat
 ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'c', 'o',
   'n', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' ',
   'o', 'f', ' ', 'p', 'a', 'i', 'r', ' '] .
shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat) [' ', '-', '>', ' ']
  (u, v)))
                                (\ _ ->
                                  (case mgu_var_disjoint_generic
  (\ a -> 'x' : a) (\ a -> 'y' : a) tp (subt_at u p)
                                    of {
                                    Nothing -> Inr ();
                                    Just (mu_1, mu_2) ->
                                      check
(not (isnf (subst_apply_term s mu_1)) || not (isnf (subst_apply_term u mu_2)))
(shows_prec_list zero_nat
   ['t', ' ', '|', '_', ' ', 'p', ' ', 'a', 'n', 'd', ' ', 'u', ' ', '|', '_',
     ' ', 'p', ' ', 'u', 'n', 'i', 'f', 'y', ' ', 'a', 'n', 'd', ' ', 's', 'a',
     't', 'i', 's', 'f', 'y', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ',
     'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'p',
     'a', 'i', 'r', ' ', '(', 'u', ',', 'v', ')', ' ', '=', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] (u, v));
                                  })))
                            (filter (\ (u, _) -> iedg u) pairs))
                          (\ x -> Inl (snd x))
                   else Inr ())))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

extract_renamings :: forall a. (Eq a) => [(a, a)] -> (a -> a, a -> a);
extract_renamings old_new =
  (fun_of_map_fun (map_of old_new) id,
    fun_of_map_fun (map_of (map swap old_new)) id);

extract_components ::
  forall a. (Eq a) => [(a, Nat)] -> [(a, a)] -> (a -> a, (a -> a, [a]));
extract_components mu old_new =
  let {
    (d, da) = extract_renamings old_new;
    c = map_filter
          (\ x -> (if let {
                        (_, a) = x;
                      } in equal_nat a zero_nat
                    then Just (fst x) else Nothing))
          mu;
    nu = map d c;
  } in (d, (da, nu));

check_components ::
  forall a.
    (Eq a,
      Showa a) => [(a, Nat)] ->
                    (a -> a, (a -> a, [a])) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_components mu ddNU =
  let {
    (d, (da, nu)) = ddNU;
  } in bindb (catch_errora
               (forallM
                 (\ f ->
                   bindb (check (not (membera mu (f, one_nat)))
                           (shows_prec_list zero_nat
                              ['n', 'e', 'w', ' ', 'u', 'n', 'a', 'r', 'y', ' ',
                                's', 'y', 'm', 'b', 'o', 'l', ' '] .
                             shows_prec zero_nat f .
                               shows_prec_list zero_nat
                                 [' ', 'c', 'l', 'a', 's', 'h', 'e', 's', ' ',
                                   'w', 'i', 't', 'h', ' ', 'o', 'l', 'd', ' ',
                                   's', 'y', 'm', 'b', 'o', 'l']))
                     (\ _ ->
                       bindb (check (d (da f) == f)
                               (shows_prec_list zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                    'i', 't', 'h', ' ', 'b', 'i', 'j', 'e', 'c',
                                    't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ',
                                    'r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', ' ',
                                    'o', 'f', ' '] .
                                 shows_prec zero_nat f))
                         (\ _ ->
                           check (membera mu (da f, zero_nat))
                             (shows_prec_list zero_nat
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                  'i', 't', 'h', ' ', 'i', 'n', 'v', 'e', 'r',
                                  's', 'e', ' ', 'r', 'e', 'n', 'a', 'm', 'i',
                                  'n', 'g', ' ', 'o', 'f', ' '] .
                               shows_prec zero_nat f))))
                 nu)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ (f, n) ->
                 bindb (check (less_eq_nat n one_nat)
                         (shows_prec_list zero_nat
                            ['a', 'r', 'i', 't', 'y', ' ', '>', ' ', '1', ' ',
                              'f', 'o', 'r', ' ', 's', 'y', 'm', 'b', 'o', 'l',
                              ' '] .
                           shows_prec zero_nat f))
                   (\ _ ->
                     check (if equal_nat n zero_nat
                             then membera nu (d f) && da (d f) == f else True)
                       (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                            't', 'h', ' ', 'b', 'i', 'j', 'e', 'c', 't', 'i',
                            'o', 'n', ' ', 'f', 'o', 'r', ' ', 'r', 'e', 'n',
                            'a', 'm', 'i', 'n', 'g', ' ', 'o', 'f', ' ', 'c',
                            'o', 'n', 's', 't', 'a', 'n', 't', ' '] .
                         shows_prec zero_nat f)))
               mu)
             (\ x -> Inl (snd x)));

str :: forall a b. (a -> a) -> b -> Term a b -> Term a b;
str d x (Fun f (v : vb : vc)) = Fun (d f) [Var x];
str d x (Fun f []) = Fun (d f) [Var x];
str d x (Fun f [t]) = Fun f [str d x t];
str d uu (Var x) = Var x;

choose_var :: forall a b. a -> Term b a -> a;
choose_var x l = hda (vars_term_list l ++ [x]);

check_to_srs_sound ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showa a, Compare b, Eq b,
      Showa b) => a -> [(b, b)] ->
                         [(Term b a, Term b a)] ->
                           [(Term b a, Term b a)] ->
                             [(Term b a, Term b a)] ->
                               [(Term b a, Term b a)] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_to_srs_sound v old_new r s rw sw =
  let {
    mu = funas_trs_list (r ++ rw);
    (d, (da, nu)) = extract_components mu old_new;
  } in bindb (check_components mu (d, (da, nu)))
         (\ _ ->
           bindb (check_varcond_subset r)
             (\ _ ->
               bindb (check_varcond_subset rw)
                 (\ _ ->
                   let {
                     checka =
                       (\ ra sa ->
                         catch_errora
                           (forallM
                             (\ (l, rb) ->
                               let {
                                 y = choose_var v l;
                                 stra = str d y;
                                 slr = (stra l, stra rb);
                               } in check (less_eq_set (vars_term l)
     (inserta y bot_set) &&
    membera sa slr)
                                      (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 'n', 'e',
   'w', ' ', 'r', 'u', 'l', 'e', ' '] .
shows_rule (shows_prec zero_nat) (shows_prec zero_nat) [' ', '-', '>', ' ']
  slr))
                             ra)
                           (\ x -> Inl (snd x)));
                   } in bindb (checka r s) (\ _ -> checka rw sw))));

const_to_string_sound_tt ::
  forall a b c.
    (Compare a, Eq a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => Const_string_sound_proof a b ->
                    Tp_ops_ext c a b () ->
                      c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
const_to_string_sound_tt (Const_string_sound_proof v old_new s sw) i tp =
  bindb (check_to_srs_sound v old_new (rc i tp) s (rwc i tp) sw)
    (\ _ -> Inr (mkc i False [] s sw));

dP_list ::
  forall a b.
    (Eq a,
      Eq b) => (a -> a) ->
                 [(Term a b, Term a b)] -> [(a, Nat)] -> [(Term a b, Term a b)];
dP_list shp r d_list =
  concatMap
    (\ lr ->
      let {
        l = fst lr;
        s = sharp_term shp l;
      } in map_filter
             (\ x ->
               (if not (supt_impl l x) &&
                     not (is_Var x) && membera d_list (the (root x))
                 then Just (s, sharp_term shp x) else Nothing))
             (supteq_list (snd lr)))
    r;

dependency_pairs_tt ::
  forall a b c d.
    (Compare a, Eq a, Linorder a, Showa a, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Linorder c,
      Showa c) => (a -> a) ->
                    Tp_ops_ext b a c () ->
                      Dpp_ops_ext d a c () ->
                        b -> Bool ->
                               Bool ->
                                 [(Term a c, Term a c)] ->
                                   Sum ([Prelude.Char] -> [Prelude.Char]) d;
dependency_pairs_tt shp i j tp nfs m p =
  let {
    r = rulesd i tp;
    q = qb i tp;
    iQ = is_QNFb i tp;
    u = filter (applicable_rule_impl iQ) r;
  } in (case catch_errora
               (bindb
                 (if isOK (check_wf_trs u) then Inr ()
                   else check (nfs &&
                                nfsb i tp &&
                                  nFQ_subset_NF_rulesb i tp &&
                                    all (\ l -> not (is_Var l)) (map fst r))
                          (shows_prec_list zero_nat
                            ['n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'i', 's',
                              ' ', 't', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'w',
                              'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd',
                              ',', ' ', 'n', 'o', 'r', ' ', 'i', 's', ' ', 't',
                              'h', 'e', ' ', 'r', 'e', 's', 't', 'r', 'i', 'c',
                              't', 'i', 'o', 'n', ' ', 't', 'o', ' ', 'i', 'n',
                              'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'w', 'i',
                              't', 'h', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ',
                              'f', 'o', 'r', 'm', ' ', 's', 'u', 'b', 's', 't',
                              'i', 't', 'u', 't', 'i', 'o', 'n', 's', ' ', 'p',
                              'r', 'e', 's', 'e', 'n', 't']))
                 (\ _ ->
                   bindb (catch_errora (forallM check_no_var q)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       let {
                         qr = map (\ (Fun f ss) -> (f, size_list ss)) q;
                         d = defined_list u;
                       } in bindb (catch_errora
                                    (forallM
                                      (\ (f, n) ->
check (not (membera d (shp f, n)))
  (shows_string ['s', 'h', 'a', 'r', 'p', 'i', 'n', 'g', ' '] .
    shows_prec zero_nat f .
      shows_string
        [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 't', 'h', 'e', ' ', 'd', 'e',
          'f', 'i', 'n', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' '] .
        shows_prec zero_nat (shp f)))
                                      d)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (catch_errora
(forallM
  (\ (f, n) ->
    check (not (membera qr (shp f, n)))
      (shows_string ['s', 'h', 'a', 'r', 'p', 'i', 'n', 'g', ' '] .
        shows_prec zero_nat f .
          shows_string
            [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 't', 'h', 'e', ' ', 's',
              'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec zero_nat (shp f) .
              shows_string
                [' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'a', ' ',
                  'r', 'o', 'o', 't', ' ', 'o', 'f', ' ', 'Q']))
  d)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    let {
                                      pa = set p;
                                    } in catch_errora
   (catch_errora
     (forallM
       (\ x ->
         (if member x pa || any (eq_rule_mod_vars x) p then Inr () else Inl x))
       (dP_list shp u d))
     (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string ['t', 'h', 'e', ' ', 'D', 'P', ' '] .
           shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] x .
             shows_string
               [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
                 'e', 'a', 'r', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'D',
                 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
               shows_nl)))))))
               (\ x ->
                 Inl (shows_string
                        ['t', 'h', 'e', ' ', 'D', 'P', '-', 't', 'r', 'a', 'n',
                          's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', ' ',
                          'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p', 'l',
                          'i', 'e', 'd', ' ', 'c', 'o', 'r', 'r', 'e', 'c', 't',
                          'l', 'y', '.'] .
                       shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd j nfs m p [] q [] r);
       });

switch_innermost_tt ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_innermost_tt i joins_i trs =
  let {
    r = rulesd i trs;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list zero_nat
                                  ['r', 'u', 'l', 'e', 's', ' ', 'a', 'r', 'e',
                                    ' ', 'n', 'o', 't', ' ', 'o', 'v', 'e', 'r',
                                    'l', 'a', 'y']))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_critical_pairs r cp joins_i)
                        (\ _ -> check_wf_trs r))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i True (map fst r) r []);
       });

unary_term :: forall a b. Term a b -> Bool;
unary_term (Var x) = True;
unary_term (Fun f [t]) = unary_term t;
unary_term (Fun v []) = False;
unary_term (Fun v (vb : vd : ve)) = False;

check_unary_signature ::
  forall a b.
    (Showa a,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unary_signature r =
  catch_errora
    (catch_errora
      (forallM
        (\ x -> (if let {
                      (l, ra) = x;
                    } in unary_term l && unary_term ra
                  then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
            shows_nl .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '-', '>', ' '] x .
                shows_nl .
                  shows_string
                    ['v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 't', 'h', 'e',
                      ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', ' ',
                      't', 'h', 'a', 't', ' ', 'a', 'l', 'l', ' ', 'f', 'u',
                      'n', 'c', 't', 'i', 'o', 'n', ' ', 's', 'y', 'm', 'b',
                      'o', 'l', 's'] .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['h', 'a', 'v', 'e', ' ', 't', 'o', ' ', 'b', 'e', ' ',
                          'u', 'n', 'a', 'r', 'y']));

rev_term :: forall a b. Ctxt a b -> Term a b -> Term a b;
rev_term c (Var x) = ctxt_apply_term c (Var x);
rev_term c (Fun f [t]) = rev_term (More f [] c []) t;

rev_rule :: forall a b. (Term a b, Term a b) -> (Term a b, Term a b);
rev_rule (l, r) = (rev_term Hole l, rev_term Hole r);

string_reversal_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_tt i trs =
  let {
    rs = rulesd i trs;
    r = rc i trs;
    s = rwc i trs;
  } in (case check_unary_signature rs of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (mkc i default_nfs_trs [] (map rev_rule r) (map rev_rule s));
       });

q_emptyb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
q_emptyb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = q_empty;

sem_lab_rel_tt ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ccompare b, Compare b, Eq b, Mapping_impl b,
      Showa b) => ([(Term a b, Term a b)] ->
                    Set (Term a b, Term a b) ->
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]))) ->
                    (a -> (a, c)) ->
                      Tp_ops_ext d a b () ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                          ([(Term a b, Term a b)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            (Set (Term a b, Term a b) ->
                              [(Term a b, Term a b)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              [Term a b] ->
                                [(Term a b, Term a b)] ->
                                  d -> Sum ([Prelude.Char] -> [Prelude.Char]) d;
sem_lab_rel_tt splitter ld i valid check_decr check_model_lab lQ lAll tp =
  let {
    r = rc i tp;
    rw = rwc i tp;
    nfs = nfsb i tp;
    (lR, (lRw, d)) = splitter lAll (set rw);
  } in (case bindb valid
               (\ _ ->
                 let {
                   q = qb i tp;
                 } in catch_errora
                        (bindb
                          (if nfs && not (q_emptyb i tp) then check_wf_trs d
                            else Inr ())
                          (\ _ ->
                            bindb (check_decr d)
                              (\ _ ->
                                bindb (check_sl_Q ld lQ q)
                                  (\ _ ->
                                    bindb (check_model_lab (set lR) r)
                                      (\ _ -> check_model_lab (set lRw) rw)))))
                        (\ x ->
                          Inl (shows_string
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                   'i', 't', 'h', ' ', 'l', 'a', 'b', 'e', 'l',
                                   'e', 'd', ' ', 'T', 'R', 'S', ':'] .
                                shows_nl . x)))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs lQ lR (lRw ++ d));
       });

sem_lab_fin_tt ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Ccompare b, Compare b, Eq b, Mapping_impl b,
      Showa b,
      Showa d) => ([(Term a b, Term a b)] ->
                    Set (Term a b, Term a b) ->
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]))) ->
                    (a -> Nat -> c -> a) ->
                      (a -> (a, c)) ->
                        (d -> d -> Bool) ->
                          Tp_ops_ext e a b () ->
                            ([(a, Nat)] ->
                              [(a, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char])
                                  (Sl_ops_ext a d c b ())) ->
                              [Term a b] ->
                                [(Term a b, Term a b)] ->
                                  e -> Sum ([Prelude.Char] -> [Prelude.Char]) e;
sem_lab_fin_tt splitter lc ld cge i gen lQ lAll tp =
  bindb (gen (insert_funas_trs (rulesd i tp) []) [])
    (\ ops ->
      let {
        check_ml =
          check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) cge lc;
        check_d = sl_check_decr ops;
      } in sem_lab_rel_tt splitter ld i (Inr ()) check_d check_ml lQ lAll tp);

semlab_fin_tt ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a (Lab b [Nat]) c () ->
                    Sl_variant (Lab b [Nat]) c ->
                      [Term (Lab b [Nat]) c] ->
                        [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
semlab_fin_tt j (Rootlab uu) =
  sem_lab_fin_tt (model_splitter label_decomp) label label_decomp equal_lab j
    (slm_gen_to_sl_gen (rl_slm Nothing));
semlab_fin_tt j (Finitelab sli) =
  sem_lab_fin_tt (model_splitter label_decomp) label label_decomp equal_nat j
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli)));
semlab_fin_tt j (QuasiFinitelab sli v) =
  sem_lab_fin_tt (quasi_splitter label_decomp) label label_decomp qmodel_cge j
    (\ f g -> qsli_to_sl v f g sli);

permutation_afs :: forall a. (Ceq a, Ccompare a) => Afs a -> Bool;
permutation_afs pi =
  ball (afs_syms pi)
    (\ (f, n) ->
      (case afsa pi (f, n) of {
        Collapse _ -> False;
        AFList xs -> eq_set (set xs) (set (upt zero_nat n)) && distinct xs;
      }));

argument_filter_tt ::
  forall a b c.
    (Ceq b, Ccompare b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b c () ->
                    [((b, Nat), Af_entry)] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
argument_filter_tt i pi tp =
  (case afs_of pi of {
    Nothing ->
      Inl (shows_prec_list zero_nat
            ['i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'a', 'r', 'g', 'u', 'm',
              'e', 'n', 't', ' ', 'f', 'i', 'l', 't', 'e', 'r']);
    Just af ->
      bindb (check (permutation_afs af)
              (shows_prec_list zero_nat
                ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f', 'i', 'l',
                  't', 'e', 'r', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                  ' ', 'p', 'e', 'r', 'm', 'u', 't', 'a', 't', 'i', 'o', 'n']))
        (\ _ ->
          let {
            pia = af_rules af;
          } in Inr (mkc i default_nfs_trs [] (pia (rc i tp)) (pia (rwc i tp))));
  });

rule_removal_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_tt i rp rremove trs =
  (case catch_errora
          (let {
             (rs, rns) = split_rulesb i trs rremove;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (catch_errora (mono rp (rs ++ rns))
                            (\ x ->
                              Inl (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'm', 'o', 'n',
                                       'o', 't', 'o', 'n', 'i', 'c', 'i', 't',
                                       'y', ' ', 'o', 'f', ' ', 's', 't', 'r',
                                       'i', 'c', 't', ' ', 'o', 'r', 'd', 'e',
                                       'r'] .
                                    shows_nl . x)))
                      (\ _ ->
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T', 'R', 'S'] .
shows_nl . x)))
                          (\ _ ->
                            catch_errora
                              (catch_errora (forallM (s rp) rs)
                                (\ x -> Inl (snd x)))
                              (\ x ->
                                Inl (shows_string
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
 'w', 'h', 'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T',
 'R', 'S'] .
                                      shows_nl . x))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'd', 'u',
                     'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                     'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w',
                     'i', 'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_R_Rwb i trs rremove rremove);
  });

check_wwf_qtrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => (Term a b -> Bool) ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wwf_qtrs nf r =
  catch_errora
    (catch_errora
      (forallM
        (\ ra ->
          (if applicable_rule_impl nf ra
            then catch_errora
                   (bindb
                     (check (not (is_Var (fst ra)))
                       (shows_string
                         ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'l', 'e',
                           'f', 't', '-', 'h', 'a', 'n', 'd', ' ', 's', 'i',
                           'd', 'e', ' ', 'i', 'n']))
                     (\ _ ->
                       catch_errora
                         (check_subseteq (vars_term_list (snd ra))
                           (vars_term_list (fst ra)))
                         (\ x ->
                           Inl (shows_string
                                  ['f', 'r', 'e', 'e', ' ', 'v', 'a', 'r', 'i',
                                    'a', 'b', 'l', 'e', ' '] .
                                 shows_prec zero_nat x .
                                   shows_string
                                     [' ', 'i', 'n', ' ', 'r', 'i', 'g', 'h',
                                       't', '-', 'h', 'a', 'n', 'd', ' ', 's',
                                       'i', 'd', 'e', ' ', 'o', 'f']))))
                   (\ x ->
                     Inl (x . shows_string [' ', 'r', 'u', 'l', 'e', ' '] .
                                shows_rule (shows_prec zero_nat)
                                  (shows_prec zero_nat) [' ', '-', '>', ' ']
                                  ra .
                                  shows_nl))
            else Inr ()))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string
             ['t', 'h', 'e', ' ', 'Q', '-', 'T', 'R', 'S', ' ', 'i', 's', ' ',
               'n', 'o', 't', ' ', 'w', 'e', 'a', 'k', 'l', 'y', ' ', 'w', 'e',
               'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd'] .
            shows_nl . x));

check_compatible_nfs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => Bool ->
                    (Term a b -> Bool) ->
                      [(Term a b, Term a b)] -> Bool -> [Term a b] -> Bool;
check_compatible_nfs nfs1 nf1 r1 nfs2 q2 =
  nfs1 == nfs2 || (null q2 || isOK (check_wwf_qtrs nf1 r1));

shows_tp ::
  forall a b c.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Tp_ops_ext c a b () -> c -> [Prelude.Char] -> [Prelude.Char];
shows_tp fun var i t =
  let {
    nfs = nfsb i t;
    r = rc i t;
    rw = rwc i t;
    q = qb i t;
  } in shows_trs fun var ['r', 'u', 'l', 'e', 's', ':'] [' ', '-', '>', ' '] r .
         (if null rw then id
           else shows_trs fun var
                  ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l',
                    'e', 's', ':']
                  [' ', '-', '>', '=', ' '] rw) .
           (if null q then id
             else shows_terms fun var
                    ['Q', '-', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', ':']
                    q) .
             (if nfs
               then shows_string
                      ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o',
                        'n', 's', ' ', 'a', 'r', 'e', ' ', 'a', 's', 's', 'u',
                        'm', 'e', 'd', ' ', 't', 'o', ' ', 'b', 'e', ' ', 'i',
                        'n', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
                        'r', 'm'] .
                      shows_nl
               else id);

check_tp_subsumes ::
  forall a b c d.
    (Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => Tp_ops_ext a (Lab b c) d () ->
                    (Bool,
                      ([Term (Lab b c) d],
                        ([(Term (Lab b c) d, Term (Lab b c) d)],
                          [(Term (Lab b c) d, Term (Lab b c) d)]))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_tp_subsumes i (nfs, (q, (r, rw))) tp =
  catch_errora
    (let {
       nfsa = nfsb i tp;
       qa = is_QNFb i tp;
       ra = rc i tp;
       rwa = rwc i tp;
       rb = r ++ rw;
       nf1 = is_QNFb i tp;
     } in bindb (check (check_compatible_nfs nfsa nf1 (ra ++ rwa) nfs q)
                  (shows_prec_list zero_nat
                    ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e',
                      ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i',
                      'o', 'n', 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm',
                      'a', 'l', '-', 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a',
                      'g', 's']))
            (\ _ ->
              bindb (catch_errora (check_NF_terms_subset qa q)
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' ', 'i', 'n', 'n', 'e', 'r',
                                 'm', 'o', 's', 't', ' ', 's', 't', 'r', 'a',
                                 't', 'e', 'g', 'y', ' ', 'd', 'u', 'e', ' ',
                                 't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
                              shows_term (shows_prec_lab zero_nat)
                                (shows_prec zero_nat) x)))
                (\ _ ->
                  bindb (catch_errora (check_subseteq ra r)
                          (\ x ->
                            Inl (toomuch ['r', 'u', 'l', 'e']
                                  (shows_rule (shows_prec_lab zero_nat)
                                    (shows_prec zero_nat) [' ', '-', '>', ' ']
                                    x))))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq rwa rb)
                              (\ x ->
                                Inl (toomuch
                                      ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e',
' ', 'r', 'u', 'l', 'e']
                                      (shows_rule (shows_prec_lab zero_nat)
(shows_prec zero_nat) [' ', '-', '>', ' '] x))))
                        (\ _ -> Inr ())))))
    (\ x ->
      Inl (shows_string
             ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
               'f', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'b', 'l', 'e',
               'm'] .
            shows_nl .
              shows_tp (shows_prec_lab zero_nat) (shows_prec zero_nat) i tp .
                shows_nl .
                  shows_string
                    ['m', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'c',
                      'o', 'n', 'c', 'l', 'u', 'd', 'e', 'd', ' ', 'f', 'r',
                      'o', 'm', ' ', 'a', 's', 's', 'u', 'm', 'i', 'n', 'g',
                      ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                      'n', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'p', 'r',
                      'o', 'b', 'l', 'e', 'm'] .
                    shows_nl .
                      shows_tp (shows_prec_lab zero_nat) (shows_prec zero_nat) i
                        (mkc i nfs q r rw) .
                        shows_nl . x . shows_nl));

fcc_tt ::
  forall a b c.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    [Ctxt b c] ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
fcc_tt i fcs cRb tp =
  let {
    r = rc i tp;
    rw = rwc i tp;
    nfs = nfsb i tp;
    rb = r ++ rw;
    (cR, cRw) = partition_rules fcs r cRb;
    _ = qb i tp;
    vs = vars_trs_list rb;
    fas = funas_trs_list rb;
  } in (case bindb (check (not (null fcs))
                     (shows_string
                        ['a', 't', ' ', 'l', 'e', 'a', 's', 't', ' ', 'o', 'n',
                          'e', ' ', 'f', 'l', 'a', 't', ' ', 'c', 'o', 'n', 't',
                          'e', 'x', 't', ' ', 'i', 's', ' ', 'r', 'e', 'q', 'u',
                          'i', 'r', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'f', 'l',
                          'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', ' ',
                          'c', 'l', 'o', 's', 'u', 'r', 'e'] .
                       shows_nl))
               (\ _ ->
                 bindb (catch_errora (forallM (check_flat_ctxt vs) fcs)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM (check_is_flat_ctxt vs fas) fcs)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM (check_flat_ctxt_complete fcs) fas)
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             bindb (catch_errora
                                     (forallM (check_rule_preserving fcs cR) r)
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 catch_errora
                                   (forallM (check_rule_preserving fcs cRb) rw)
                                   (\ x -> Inl (snd x)))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs [] cR cRw);
       });

g_isEmpty_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> Bool;
g_isEmpty_dflt_basic_oops_rm_basic_ops s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ c -> c)
    (\ _ _ -> False) True;

ta_rhs_states_set :: forall a b. Ta_impl a b -> Rbt a ();
ta_rhs_states_set (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x4;

ta_rules_impla :: forall a b. Ta_impl a b -> Rbt (b, Nat) [Ta_rule_impl a b];
ta_rules_impla (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x2;

r_lhs_states_impl :: forall a b. Ta_rule_impl a b -> [a];
r_lhs_states_impl (TA_rule_impl f qsa q qs) = qsa;

rm_set_lookup :: forall a b. (Compare_order a) => Rbt a [b] -> a -> [b];
rm_set_lookup rm = (\ a -> (case lookup rm a of {
                             Nothing -> [];
                             Just rules -> rules;
                           }));

g_union_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Rbt a ();
g_union_dflt_basic_oops_rm_basic_ops s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s1 (\ _ -> True)
    ins_rm_basic_ops s2;

rs_Union :: forall a. (Compare_order a) => [Rbt a ()] -> Rbt a ();
rs_Union = foldl g_union_dflt_basic_oops_rm_basic_ops (empty_rm_basic_ops ());

rqss_impl :: forall a b. Ta_rule_impl a b -> Rbt a ();
rqss_impl (TA_rule_impl f qsa q qs) = qs;

ta_res_impl_all ::
  forall a b c.
    (Compare_order a,
      Compare_order b) => Rbt a () ->
                            Rbt (b, Nat) [Ta_rule_impl a b] ->
                              Term b c -> Rbt a ();
ta_res_impl_all q ta (Var uu) = q;
ta_res_impl_all q ta (Fun f ts) =
  let {
    rec = map (ta_res_impl_all q ta) ts;
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    arules =
      filter
        (\ rule ->
          let {
            qs = r_lhs_states_impl rule;
          } in all_interval_nat
                 (\ i -> memb_rm_basic_ops (nth qs i) (nth rec i)) zero_nat n)
        rules;
    a = map rqss_impl arules;
  } in rs_Union a;

rule_state_compatible_heuristic ::
  forall a b c.
    (Compare_order a, Compare_order b,
      Linorder c) => Ta_impl a b -> Term b c -> Bool;
rule_state_compatible_heuristic ta l =
  g_isEmpty_dflt_basic_oops_rm_basic_ops
    (ta_res_impl_all (ta_rhs_states_set ta) (ta_rules_impla ta) l);

ta_rules_implb :: forall a b. Tree_automaton a b -> [Ta_rule a b];
ta_rules_implb (Tree_Automaton x1 x2 x3) = x2;

check_state_raise_consistent ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Linorder a, Set_impl a, Showa a, Eq b,
      Showa b) => Tree_automaton a (b, Nat) ->
                    [(a, a)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_state_raise_consistent ta rel =
  let {
    rels = set rel;
    rls = ta_rules_implb ta;
  } in catch_errora
         (forallM
           (\ r1 ->
             let {
               (TA_rule (f1, i1) qs1 q1) = r1;
             } in catch_errora
                    (forallM
                      (\ r2 ->
                        let {
                          (TA_rule (f2, i2) qs2 q2) = r2;
                        } in (if f1 == f2 && less_nat i1 i2 && qs1 == qs2
                               then check (member (q1, q2) rels)
                                      (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 'r', 'a',
   'i', 's', 'e', ' ', 'c', 'o', 'n', 's', 'i', 's', 't', 'e', 'n', 'c', 'y',
   ' ', 'b', 'e', 'c', 'a', 'u', 's', 'e', ' ', 'o', 'f', ' ', 'a', 'u', 't',
   'o', 'm', 'a', 't', 'o', 'n', '-', 'r', 'u', 'l', 'e', 's', ' '] .
shows_nl .
  shows_prec_ta_rule zero_nat r1 .
    shows_nl .
      shows_prec_ta_rule zero_nat r2 .
        shows_nl .
          shows_prec zero_nat q1 .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', '>', '>', '^', '*',
                ' '] .
              shows_prec zero_nat q2)
                               else Inr ()))
                      rls)
                    (\ x -> Inl (snd x)))
           rls)
         (\ x -> Inl (snd x));

ta_epsrs_impl :: forall a b. Ta_impl a b -> a -> Rbt a ();
ta_epsrs_impl (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x7;

ta_epss_impl :: forall a b. Ta_impl a b -> a -> Rbt a ();
ta_epss_impl (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x6;

g_inter_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Rbt a ();
g_inter_dflt_basic_oops_rm_basic_ops s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s1 (\ _ -> True)
    (\ x s -> (if memb_rm_basic_ops x s2 then ins_dj_rm_basic_ops x s else s))
    (empty_rm_basic_ops ());

ta_match_impl ::
  forall a b c.
    (Compare_order a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                 Rbt b () ->
                   (b -> Rbt b ()) -> Term a c -> [b] -> Rbt [(c, b)] ();
ta_match_impl ta qsig eps (Var x) q =
  g_from_list_dflt_basic_oops_rm_basic_ops
    (map (\ qa -> [(x, qa)])
      (g_to_list_dflt_basic_oops_rm_basic_ops
        (g_inter_dflt_basic_oops_rm_basic_ops (rs_Union (map eps q)) qsig)));
ta_match_impl ta qsig eps (Fun f ts) q =
  let {
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    ep = rs_Union (map eps q);
    fa = (\ rule ->
           g_from_list_dflt_basic_oops_rm_basic_ops
             (let {
                (TA_rule_impl _ qs qa _) = rule;
              } in (if memb_rm_basic_ops qa ep
                     then let {
                            rec = map (\ (tsi, qsi) ->
g_to_list_dflt_basic_oops_rm_basic_ops (ta_match_impl ta qsig eps tsi [qsi]))
                                    (zip ts qs);
                          } in map concat (concat_lists rec)
                     else [])));
  } in rs_Union (map fa rules);

ta_match_impla ::
  forall a b c.
    (Compare_order a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                 Rbt b () ->
                   (b -> Rbt b ()) -> [b] -> Term a c -> Rbt [(c, b)] ();
ta_match_impla ta qsig eps rhs t = ta_match_impl ta qsig eps t rhs;

ta_res_impl ::
  forall a b.
    (Compare_order a,
      Compare_order b) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                            (b -> Rbt b ()) -> Term a b -> Rbt b ();
ta_res_impl ta eps (Var q) = eps q;
ta_res_impl ta eps (Fun f ts) =
  let {
    rec = map (ta_res_impl ta eps) ts;
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    arules =
      filter
        (\ rule ->
          let {
            qs = r_lhs_states_impl rule;
          } in all_interval_nat
                 (\ i -> memb_rm_basic_ops (nth qs i) (nth rec i)) zero_nat n)
        rules;
    a = map rqss_impl arules;
  } in rs_Union a;

rule_state_compatible_eff_list ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => Ta_impl a b ->
                 (Rbt a () -> Rbt a () -> Maybe a) ->
                   (Term b c, Term b c) -> Sum ((Term b a, Term b a), a) ();
rule_state_compatible_eff_list ta rel (l, r) =
  let {
    rm = ta_rules_impla ta;
    eps = ta_epss_impl ta;
    epsa = ta_epsrs_impl ta;
    ta_res = ta_res_impl rm eps;
    rhs_rbt = ta_rhs_states_set ta;
    rhs = g_to_list_dflt_basic_oops_rm_basic_ops rhs_rbt;
  } in catch_errora
         (forallM (\ sigma -> let {
                                sigmaa = fun_of sigma;
                                l_sigma = map_term (\ x -> x) sigmaa l;
                                r_sigma = map_term (\ x -> x) sigmaa r;
                                qsl = ta_res l_sigma;
                                qsr = ta_res r_sigma;
                              } in (case rel qsl qsr of {
                                     Nothing -> Inr ();
                                     Just q -> Inl ((l_sigma, r_sigma), q);
                                   }))
           (g_to_list_dflt_basic_oops_rm_basic_ops
             (ta_match_impla rm rhs_rbt epsa rhs l)))
         (\ x -> Inl (snd x));

state_compatible_eff_list ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => Ta_impl a b ->
                 (Rbt a () -> Rbt a () -> Maybe a) ->
                   [(Term b c, Term b c)] ->
                     Sum ((Term b c, Term b c), ((Term b a, Term b a), a)) ();
state_compatible_eff_list ta rel r =
  let {
    check = rule_state_compatible_eff_list ta rel;
  } in catch_errora
         (forallM (\ lr -> catch_errora (check lr) (\ x -> Inl (lr, x))) r)
         (\ x -> Inl (snd x));

ta_final_impla :: forall a b. Ta_impl a b -> Rbt a ();
ta_final_impla (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x1;

flatten_term_enum_filter ::
  forall a b. (Term a b -> Bool) -> Term [a] b -> [Term a b];
flatten_term_enum_filter f (Var x) = let {
                                       tx = Var x;
                                     } in (if f tx then [tx] else []);
flatten_term_enum_filter f (Fun fs ts) =
  let {
    lts = map (flatten_term_enum_filter f) ts;
  } in (if any null lts then []
         else let {
                ss = concat_lists lts;
              } in filter f (concatMap (\ fa -> map (Fun fa) ss) fs));

inverse_base_term_filter ::
  forall a b. (Term (a, Nat) b -> Bool) -> Term a b -> Nat -> [Term (a, Nat) b];
inverse_base_term_filter filt l c =
  let {
    hs = upt zero_nat (suc c);
  } in flatten_term_enum_filter filt
         (map_term (\ f -> map (\ h -> lift h f) hs) (\ x -> x) l);

size_multiset :: forall a. Multiset a -> Nat;
size_multiset (Bag ms) = foldd (\ _ -> plus_nat) zero_nat ms;

compute_height ::
  forall a b.
    (Eq a,
      Eq b) => Relation_kind ->
                 Term a b -> Term a b -> Term (a, Nat) b -> Nat -> Nat;
compute_height (Weak_TRS Nothing) bl br =
  (if less_eq_nat (size_multiset (funs_term_ms br))
        (size_multiset (funs_term_ms bl))
    then (\ l x ->
           (if equal_term (map_term (lift x) (\ xa -> xa) bl) l then x
             else suc x))
    else (\ _ -> suc));
compute_height (Weak_TRS (Just c)) bl br =
  (if less_eq_nat (size_multiset (funs_term_ms br))
        (size_multiset (funs_term_ms bl))
    then (\ l x ->
           (if equal_term (map_term (lift x) (\ xa -> xa) bl) l then min c x
             else min c (suc x)))
    else (\ _ x -> min c (suc x)));
compute_height Strict_TRS bl br = (\ _ -> suc);

cover_bound_list_filter ::
  forall a b.
    (Eq a,
      Eq b) => (Term (a, Nat) b -> Bool) ->
                 ((Term a b, Term a b) -> Term a b -> Bool) ->
                   Relation_kind ->
                     Nat ->
                       [(Term a b, Term a b)] ->
                         [(Term (a, Nat) b, Term (a, Nat) b)];
cover_bound_list_filter filt ff gg c r =
  concatMap
    (\ (l, ra) ->
      let {
        ch = compute_height gg l ra;
        ee = ff (l, ra);
      } in map (\ la ->
                 (la, map_term
                        (lift (ch la
                                (min_list
                                  (map height
                                    (sym_collect
                                      (\ t -> ee (map_term base (\ x -> x) t))
                                      la)))))
                        (\ x -> x) ra))
             (inverse_base_term_filter filt l c))
    r;

g_bex_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> (a -> Bool) -> Bool;
g_bex_dflt_basic_oops_rm_basic_ops s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s not (\ x _ -> p x)
    False;

ta_contains_aux_impl ::
  forall a b.
    (Compare_order a, Ceq b, Ccompare b, Eq b,
      Linorder b) => [(a, Nat)] ->
                       [b] -> Ta_impl b a -> Set b -> Sum (Term a b) ();
ta_contains_aux_impl f qs ta q =
  let {
    _ = ta_final_impla ta;
    look = rm_set_lookup (ta_rules_impla ta);
    _ = ta_epss_impl ta;
  } in catch_errora
         (forallM
           (\ (fa, n) ->
             let {
               rules = look (fa, n);
             } in catch_errora
                    (catch_errora
                      (forallM
                        (\ x ->
                          (if any (\ rule ->
                                    r_lhs_states_impl rule == x &&
                                      let {
qq = rqss_impl rule;
                                      } in
g_bex_dflt_basic_oops_rm_basic_ops qq (\ qa -> member qa q))
                                rules
                            then Inr () else Inl x))
                        (concat_lists (replicate n qs)))
                      (\ x -> Inl (snd x)))
                    (\ x -> Inl (Fun fa (map Var x))))
           f)
         (\ x -> Inl (snd x));

alpha_rm_basic_ops :: forall a. (Cenum a, Compare_order a) => Rbt a () -> Set a;
alpha_rm_basic_ops s = dom (lookup s);

ta_contains_impl ::
  forall a b.
    (Compare_order a, Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b,
      Set_impl b) => [(a, Nat)] ->
                       [(a, Nat)] -> Ta_impl b a -> [b] -> Sum (Term a b) ();
ta_contains_impl f g ta qs =
  bindb (ta_contains_aux_impl f qs ta (set qs))
    (\ _ ->
      ta_contains_aux_impl g qs ta (alpha_rm_basic_ops (ta_final_impla ta)));

check_coherent_rule ::
  forall a b.
    (Compare_order a, Eq a, Showa a, Eq b,
      Showa b) => (a -> [a]) ->
                    Rbt (a, a) () ->
                      [Ta_rule a b] ->
                        Ta_rule a b ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_coherent_rule iter rel rules (TA_rule f qs q) =
  catch_errora
    (forallM
      (\ i ->
        let {
          qi = nth qs i;
        } in catch_errora
               (forallM
                 (\ qia ->
                   let {
                     qsa = list_update qs i qia;
                   } in check (not (null (filter
   (\ (TA_rule g qsb qa) ->
     f == g && qsa == qsb && memb_rm_basic_ops (q, qa) rel)
   rules)))
                          (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                            shows_prec zero_nat f .
                              shows_prec_list zero_nat ['('] .
                                shows_prec_list zero_nat qs .
                                  shows_prec_list zero_nat
                                    [')', ' ', '-', '>', ' '] .
                                    shows_prec zero_nat q .
                                      shows_prec_list zero_nat
[' ', 'w', 'i', 't', 'h', ' '] .
shows_prec_nat zero_nat (suc i) .
  shows_prec_list zero_nat
    ['.', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'd', 'e', 'c', 'r',
      'e', 'a', 's', 'e', 'd', ' ', 't', 'o', ' '] .
    shows_prec zero_nat qia .
      shows_prec_list zero_nat
        [' ', 'h', 'a', 's', ' ', 'n', 'o', ' ', 'c', 'o', 'u', 'n', 't', 'e',
          'r', 'p', 'a', 'r', 't']))
                 (iter qi))
               (\ x -> Inl (snd x)))
      (upt zero_nat (size_list qs)))
    (\ x -> Inl (snd x));

ntrancl ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Nat -> Set (a, a) -> Set (a, a);
ntrancl n r =
  (if equal_nat n zero_nat then r else let {
 ra = ntrancl (minus_nat n one_nat) r;
                                       } in sup_set ra (relcomp ra r));

trancl ::
  forall a.
    (Card_UNIV a, Ceq a, Ccompare a, Set_impl a) => Set (a, a) -> Set (a, a);
trancl a =
  (if finite a then ntrancl (minus_nat (card a) one_nat) a
    else (error :: forall a. String -> (() -> a) -> a) "trancl: infinite set"
           (\ _ -> trancl a));

check_coherent ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showa a, Eq b,
      Showa b) => Tree_automaton a b ->
                    Ta_relation a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_coherent (Tree_Automaton fin rules eps) (Some_Relation rel) =
  let {
    iter =
      (\ q ->
        map_filter (\ x -> (if let {
                                 (a, _) = x;
                               } in a == q
                             then Just (snd x) else Nothing))
          rel);
    rs = g_from_list_dflt_basic_oops_rm_basic_ops rel;
    ep = set eps;
    rell = converse (set rel);
  } in bindb (catch_errora (check_subseteq (concatMap iter fin) fin)
               (\ x ->
                 Inl (shows_prec zero_nat x .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'i', 'n', ' ', 'r', 'e', 'l', 'a',
                           't', 'i', 'o', 'n', ' ', 't', 'o', ' ', 'a', ' ',
                           'f', 'i', 'n', 'a', 'l', ' ', 's', 't', 'a', 't',
                           'e', ',', ' ', 'b', 'u', 't', ' ', 'n', 'o', 't',
                           ' ', 'a', ' ', 'f', 'i', 'n', 'a', 'l', ' ', 's',
                           't', 'a', 't', 'e', ' ', 'i', 't', 's', 'e', 'l',
                           'f'])))
         (\ _ ->
           bindb (catch_errora
                   (forallM (check_coherent_rule iter rs rules) rules)
                   (\ x -> Inl (snd x)))
             (\ _ ->
               check (less_eq_set (relcomp rell ep)
                       (sup_set (relcomp (trancl ep) rell) rell))
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c',
                     'o', 'h', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 'o', 'f', ' ',
                     'e', 'p', 's', 'i', 'l', 'o', 'n', ' ', 'r', 'u', 'l', 'e',
                     's'])));
check_coherent uu Decision_Proc_Old = Inr ();
check_coherent uu Decision_Proc = Inr ();
check_coherent uu Id_Relation = Inr ();

rtrancl_rbt_impl :: forall a. (Compare_order a) => [(a, a)] -> [a] -> Rbt a ();
rtrancl_rbt_impl =
  rtrancl_impl
    (\ r ->
      let {
        rm = elem_list_to_rm fst r;
      } in (\ asa ->
             g_to_list_dflt_basic_oops_rm_basic_ops
               (rs_Union
                 (map (\ a ->
                        g_from_list_dflt_basic_oops_rm_basic_ops
                          (map snd (rm_set_lookup rm a)))
                   asa))))
    (\ asa bs ->
      g_union_dflt_basic_oops_rm_basic_ops bs
        (g_from_list_dflt_basic_oops_rm_basic_ops asa))
    memb_rm_basic_ops (empty_rm_basic_ops ());

memo_rbt_rtrancl :: forall a. (Compare_order a) => [(a, a)] -> a -> Rbt a ();
memo_rbt_rtrancl r =
  let {
    tr = rtrancl_rbt_impl r;
    rm = g_list_to_map_rm_basic_ops
           (map (\ a -> (a, tr [a]))
             (((g_to_list_dflt_basic_oops_rm_basic_ops .
                 g_from_list_dflt_basic_oops_rm_basic_ops) .
                map fst)
               r));
  } in (\ a -> (case lookup rm a of {
                 Nothing -> g_from_list_dflt_basic_oops_rm_basic_ops [a];
                 Just asa -> asa;
               }));

conv_ta_rule :: forall a b. (a -> Rbt a ()) -> Ta_rule a b -> Ta_rule_impl a b;
conv_ta_rule eps (TA_rule f qs q) = TA_rule_impl f qs q (eps q);

r_sym_impl :: forall a b. Ta_rule_impl a b -> (b, Nat);
r_sym_impl (TA_rule_impl f qsa q qs) = (f, size_list qsa);

generate_ta ::
  forall a b.
    (Compare_order a, Compare_order b) => Tree_automaton a b -> Ta_impl a b;
generate_ta (Tree_Automaton fin rules eps) =
  let {
    ep = memo_rbt_rtrancl eps;
    epr = memo_rbt_rtrancl (map (\ (q, qa) -> (qa, q)) eps);
    rqs_rs = rs_Union (map (\ rule -> ep (r_rhs rule)) rules);
    rrules = map (conv_ta_rule ep) rules;
  } in TA_Impl (g_from_list_dflt_basic_oops_rm_basic_ops fin)
         (elem_list_to_rm r_sym_impl rrules)
         (g_to_list_dflt_basic_oops_rm_basic_ops rqs_rs) rqs_rs eps ep epr;

generate_ta_cond ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showa a, Compare_order b, Eq b,
      Showa b) => Tree_automaton a b ->
                    Ta_relation a ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) (Ta_impl a b);
generate_ta_cond ta rel =
  bindb (catch_errora (check_coherent ta rel)
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ', 'i', 's',
                     ' ', 'n', 'o', 't', ' ', 'c', 'o', 'h', 'e', 'r', 'e', 'n',
                     't', ' ', 'w', '.', 'r', '.', 't', '.', ' ', 'r', 'e', 'l',
                     'a', 't', 'i', 'o', 'n'] .
                  shows_nl . x)))
    (\ _ -> Inr (generate_ta ta));

relation_as_list ::
  forall a. Ta_relation a -> Sum ([Prelude.Char] -> [Prelude.Char]) [(a, a)];
relation_as_list (Some_Relation rel) = Inr rel;
relation_as_list Id_Relation = Inr [];
relation_as_list Decision_Proc =
  Inl (shows_prec_list zero_nat
        ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e',
          'd', 'u', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l',
          'a', 'b', 'l', 'e', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'l',
          'e', 'f', 't', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'T', 'R', 'S',
          's']);
relation_as_list Decision_Proc_Old =
  Inl (shows_prec_list zero_nat
        ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e',
          'd', 'u', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l',
          'a', 'b', 'l', 'e', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'l',
          'e', 'f', 't', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'T', 'R', 'S',
          's']);

check_ta_bounded ::
  forall a b.
    (Linorder b,
      Showa b) => Ta_impl a (b, Nat) ->
                    Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ta_bounded ta c =
  catch_errora
    (catch_errora
      (forallM
        (\ x -> (if let {
                      (f, _) = x;
                    } in less_eq_nat (height f) c
                  then Inr () else Inl x))
        (map fst (g_to_list_rm_basic_ops (ta_rules_impla ta))))
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (let {
             (f, _) = x;
           } in shows_prec_prod zero_nat f .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ', 'i',
                      'n', ' ', 'T', 'A', ' ', 'w', 'i', 't', 'h', ' ', 'h',
                      'e', 'i', 'g', 'h', 't', ' ', 'l', 'a', 'r', 'g', 'e',
                      'r', ' ', 't', 'h', 'a', 'n', ' ', 'c', ' ', '=', ' '] .
                    shows_prec_nat zero_nat c));

bounds_condition ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => Boundstype ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_condition Roof uu = Inr ();
bounds_condition Match r =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (l, ra) = x;
              } in subseteq_mset (vars_term_ms ra) (vars_term_ms l)
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (let {
             (l, ra) = x;
           } in shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '-', '>', ' '] (l, ra) .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'd', 'u', 'p', 'l', 'i', 'c', 'a',
                        't', 'i', 'n', 'g']));

non_collapsing_impl :: forall a b c. [(a, Term b c)] -> Bool;
non_collapsing_impl r = all ((\ t -> not (is_Var t)) . snd) r;

construct_c_opt :: forall a b. Nat -> [(Term a b, Term a b)] -> Maybe Nat;
construct_c_opt c r = (if non_collapsing_impl r then Just c else Nothing);

boundstype_fun ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => Boundstype -> (Term a b, Term a b) -> Term a b -> Bool;
boundstype_fun Roof = roof;
boundstype_fun Match = matcha;

iteratei_set_op_list_it_rs_ops ::
  forall a b.
    (Linorder a) => Rbt a () -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_set_op_list_it_rs_ops s =
  (\ c f -> rm_iterateoi (impl_of s) c (f . fst));

rs_subset :: forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Maybe a;
rs_subset asa bs =
  iteratei_set_op_list_it_rs_ops asa (\ a -> (case a of {
       Nothing -> True;
       Just _ -> False;
     }))
    (\ a _ -> (if memb_rm_basic_ops a bs then Nothing else Just a)) Nothing;

rel_checker ::
  forall a.
    (Compare_order a, Eq a) => Ta_relation a -> Rbt a () -> Rbt a () -> Maybe a;
rel_checker (Some_Relation rel) =
  (\ lhs rhs ->
    let {
      rlist = g_to_list_dflt_basic_oops_rm_basic_ops rhs;
    } in (case catch_errora
                 (forallM
                   (\ l -> check (any (\ r -> membera rel (l, r)) rlist) l)
                   (g_to_list_dflt_basic_oops_rm_basic_ops lhs))
                 (\ x -> Inl (snd x))
           of {
           Inl a -> Just a;
           Inr _ -> Nothing;
         }));
rel_checker Id_Relation = rs_subset;
rel_checker Decision_Proc = rs_subset;
rel_checker Decision_Proc_Old = rs_subset;

check_det ::
  forall a b.
    (Eq a,
      Eq b) => Tree_automaton a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_det (Tree_Automaton fin rules eps) =
  catch_errora
    (bindb
      (check (null eps)
        (shows_prec_list zero_nat
          ['e', 'p', 's', 'i', 'l', 'o', 'n', ' ', 't', 'r', 'a', 'n', 's', 'i',
            't', 'i', 'o', 'n', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l',
            'o', 'w', 'e', 'd']))
      (\ _ ->
        check (distinct (map (\ (TA_rule f qs _) -> (f, qs)) (remdups rules)))
          (shows_prec_list zero_nat
            ['s', 'o', 'm', 'e', ' ', 'l', 'h', 's', ' ', 'o', 'c', 'c', 'u',
              'r', 's', ' ', 't', 'w', 'i', 'c', 'e'])))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'e', 'n', 's', 'u', 'r', 'i', 'n', 'g', ' ', 'd', 'e', 't', 'e',
               'r', 'm', 'i', 'n', 'i', 's', 'm', ' ', 'o', 'f', ' ', 'a', 'u',
               't', 'o', 'm', 'a', 't', 'a'] .
            shows_nl . x));

check_bounds_generic ::
  forall a b c.
    (Compare_order a, Eq a, Showa a, Card_UNIV b, Cenum b, Ceq b, Ccompare b,
      Compare_order b, Eq b, Set_impl b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c,
      Showa c) => Bounds_info a b ->
                    [(Term a c, Term a c)] ->
                      [(Term a c, Term a c)] ->
                        [(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_bounds_generic (Bounds_Info typea c qfin preTA rel) r s f g =
  let {
    c_opt = construct_c_opt c r;
    rs = r ++ s;
  } in bindb (generate_ta_cond preTA rel)
         (\ ta ->
           let {
             rell = rel_checker rel;
           } in bindb (check_wf_trs rs)
                  (\ _ ->
                    bindb (check
                            (less_eq_set (set qfin)
                              (alpha_rm_basic_ops (ta_final_impla ta)))
                            (shows_prec_list zero_nat
                              ['e', 'x', 'p', 'l', 'i', 'c', 'i', 't', 'l', 'y',
                                ' ', 'm', 'e', 'n', 't', 'i', 'o', 'n', 'e',
                                'd', ' ', 'f', 'i', 'n', 'a', 'l', ' ', 's',
                                't', 'a', 't', 'e', 's', ' ', 'm', 'u', 's',
                                't', ' ', 'b', 'e', ' ', 'f', 'i', 'n', 'a',
                                'l']))
                      (\ _ ->
                        bindb (if isOK (check_left_linear_trs rs) then Inr ()
                                else bindb (catch_errora (check_det preTA)
     (\ x ->
       Inl (shows_prec_list zero_nat
              ['f', 'o', 'r', ' ', 'n', 'o', 'n', ' ', 'l', 'e', 'f', 't', '-',
                'l', 'i', 'n', 'e', 'a', 'r', ' ', 'T', 'R', 'S', ' ', 'w', 'e',
                ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'd', 'e', 't', '.',
                ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n'] .
             shows_nl . x)))
                                       (\ _ ->
 bindb (relation_as_list rel) (check_state_raise_consistent preTA)))
                          (\ _ ->
                            bindb (bounds_condition typea rs)
                              (\ _ ->
                                bindb (check_ta_bounded ta c)
                                  (\ _ ->
                                    bindb (check
    (any (\ q -> memb_rm_basic_ops q (ta_rhs_states_set ta)) qfin)
    (shows_prec_list zero_nat
      ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 'm',
        'e', 'n', 't', 'i', 'o', 'n', 'e', 'd', ' ', 'f', 'i', 'n', 'a', 'l',
        ' ', 's', 't', 'a', 't', 'e', ' ', 'i', 'n', ' ', 'T', 'A']))
                                      (\ _ ->
bindb (catch_errora
        (ta_contains_impl (map (\ (fa, a) -> (lift zero_nat fa, a)) f)
          (map (\ (fa, a) -> (lift zero_nat fa, a)) g) ta qfin)
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['i', 't', ' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                   ' ', 'b', 'e', ' ', 'g', 'u', 'a', 'r', 'a', 'n', 't', 'e',
                   'e', 'd', ' ', 't', 'h', 'a', 't', ' ', 'l', 'i', 'f', 't',
                   '0', '(', 'T', '(', 'S', 'i', 'g', 'm', 'a', ')', ')', ' ',
                   'i', 's', ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', ' ',
                   'b', 'y', ' ', 'T', 'A'] .
                shows_nl .
                  shows_prec_list zero_nat
                    ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n', 'o', ' ',
                      't', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' ',
                      'f', 'r', 'o', 'm', ' '] .
                    shows_prec_term zero_nat x .
                      shows_prec_list zero_nat
                        [' ', 't', 'o', ' ', 'a', ' ', 'f', 'i', 'n', 'a', 'l',
                          ' ', 's', 't', 'a', 't', 'e'])))
  (\ _ ->
    bindb (catch_errora
            (state_compatible_eff_list ta rell
              (cover_bound_list_filter
                (\ l -> not (rule_state_compatible_heuristic ta l))
                (boundstype_fun typea) Strict_TRS c r))
            (\ x ->
              Inl (let {
                     (lr, (lr_rhs, q)) = x;
                   } in shows_prec_list zero_nat
                          ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                            'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e',
                            ' ', 'w', 'i', 't', 'h', ' ', 'T', 'R', 'S'] .
                          shows_nl .
                            shows_prec_list zero_nat
                              ['f', 'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
                              shows_rule (shows_prec_prod zero_nat)
                                (shows_prec zero_nat) [' ', '-', '>', ' '] lr .
                                shows_nl .
                                  shows_prec_list zero_nat
                                    ['w', 'h', 'i', 'c', 'h', ' ', 'i', 's',
                                      ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                                      'i', 'a', 't', 'e', 'd', ' ', 'b', 'y',
                                      ' ', 's', 't', 'a', 't', 'e', 's', ' ',
                                      't', 'o', ' '] .
                                    shows_rule (shows_prec_prod zero_nat)
                                      (shows_prec zero_nat) [' ', '-', '>', ' ']
                                      lr_rhs .
                                      shows_nl .
shows_prec_list zero_nat ['t', 'h', 'e', ' ', 's', 't', 'a', 't', 'e', ' '] .
  shows_prec zero_nat q .
    shows_prec_list zero_nat
      [' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'r', 'e', 'a', 'c', 'h',
        'a', 'b', 'l', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ',
        'l', 'h', 's'] .
      shows_nl)))
      (\ _ ->
        catch_errora
          (state_compatible_eff_list ta rell
            (cover_bound_list_filter
              (\ l -> not (rule_state_compatible_heuristic ta l)) matcha
              (Weak_TRS c_opt) c s))
          (\ x ->
            Inl (let {
                   (lr, (lr_rhs, q)) = x;
                 } in shows_prec_list zero_nat
                        ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c',
                          'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ', 'w',
                          'i', 't', 'h', ' ', 'r', 'e', 'l', 'a', 't', 'i', 'v',
                          'e', ' ', 'T', 'R', 'S'] .
                        shows_nl .
                          shows_prec_list zero_nat
                            ['f', 'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
                            shows_rule (shows_prec_prod zero_nat)
                              (shows_prec zero_nat) [' ', '-', '>', ' '] lr .
                              shows_nl .
                                shows_prec_list zero_nat
                                  ['w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ',
                                    'i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a',
                                    't', 'e', 'd', ' ', 'b', 'y', ' ', 's', 't',
                                    'a', 't', 'e', 's', ' ', 't', 'o', ' '] .
                                  shows_rule (shows_prec_prod zero_nat)
                                    (shows_prec zero_nat) [' ', '-', '>', ' ']
                                    lr_rhs .
                                    shows_nl .
                                      shows_prec_list zero_nat
['t', 'h', 'e', ' ', 's', 't', 'a', 't', 'e', ' '] .
shows_prec zero_nat q .
  shows_prec_list zero_nat
    [' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'r', 'e', 'a', 'c', 'h', 'a',
      'b', 'l', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ', 'l', 'h',
      's'] .
    shows_nl)))))))))));

bounds_tt ::
  forall a b c d.
    (Compare_order b, Eq b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showa c,
      Card_UNIV d, Cenum d, Ceq d, Ccompare d, Compare_order d, Eq d,
      Set_impl d,
      Showa d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_tt i info tp = let {
                        r = rulesd i tp;
                        f = funas_trs_list r;
                      } in check_bounds_generic info r [] f f;

check_trs_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_termination_proof_main j ia assms i tp R_is_Empty =
  debug (i []) ['R', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y']
    (if null (rc j tp) then Inr ()
      else Inl (i . shows_string
                      [':', ' ', 'R', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                        'e', 'm', 'p', 't', 'y', ' ', 'i', 'n', ' ', 't', 'h',
                        'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                        ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                        'n', '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                      shows_nl .
                        shows_tp (shows_prec_lab zero_nat)
                          (shows_prec_list zero_nat) j tp));
check_trs_termination_proof_main j ia assms i tp (Rule_Removal redp rR prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (let {
       r = rulesd j tp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora (rule_removal_tt j (get_redtriple redp) rr tp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'r',
                                 'u', 'l', 'e', ' ', 'r', 'e', 'm', 'o', 'v',
                                 'a', 'l', ' ', 't', 'e', 'c', 'h', 'n', 'i',
                                 'q', 'u', 'e', ' ', 'o', 'n', ' '] .
                               shows_nl .
                                 shows_tp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) j tp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
 'v', 'e', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] rr .
   shows_nl . x)))
            (\ tpa ->
              catch_errora
                (check_trs_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) tpa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u',
                               'l', 'e', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l',
                               ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u',
                               'e'] .
                             shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (DP_Trans nfs m p prf) =
  debug (i []) ['D', 'P', ' ', 't', 'r', 'a', 'n', 's']
    (bindb
      (catch_errora (dependency_pairs_tt Sharp j ia tp nfs m p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g',
                       ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ', 'T',
                       'R', 'S'] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl .
                           shows_string
                             ['t', 'o', ' ', 't', 'h', 'e', ' ', 'i', 'n', 'i',
                               't', 'i', 'a', 'l', ' ', 'D', 'P', ' ', 'p', 'r',
                               'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h',
                               ' ', 'p', 'a', 'i', 'r', 's', ' '] .
                             shows_nl .
                               shows_rules (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                 p .
                                 shows_nl . x)))
      (\ dpp ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dpp prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 's', 'w', 'i', 't', 'c', 'h', ' ', 't',
                         'o', ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c',
                         'y', ' ', 'p', 'a', 'i', 'r', 's'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (String_Reversal prf) =
  debug (i [])
    ['S', 't', 'r', 'i', 'n', 'g', ' ', 'R', 'e', 'v', 'e', 'r', 's', 'a', 'l']
    (bindb
      (catch_errora (string_reversal_tt j tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 't', 'r', 'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e',
                       'r', 's', 'a', 'l', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 't', 'r', 'i',
                         'n', 'g', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'a', 'l',
                         ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Constant_String p prf) =
  debug (i [])
    ['C', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 't', 'o', ' ', 'U', 'n', 'a',
      'r', 'y']
    (bindb
      (catch_errora (const_to_string_sound_tt p j tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 't', 'u', 'r', 'n', 'i', 'n', 'g', ' ', 'c',
                       'o', 'n', 's', 't', 'a', 'n', 't', 's', ' ', 'i', 'n',
                       't', 'o', ' ', 'u', 'n', 'a', 'r', 'y', ' ', 's', 'y',
                       'm', 'b', 'o', 'l', 's', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 's',
                         't', 'a', 'n', 't', ' ', 't', 'o', ' ', 'u', 'n', 'a',
                         'r', 'y', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u',
                         'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Semlab sli lQ lAll prf) =
  debug (i []) ['S', 'e', 'm', 'l', 'a', 'b']
    (bindb
      (catch_errora (semlab_fin_tt j sli lQ lAll tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 'e', 'm', 'a', 'n', 't', 'i', 'c', ' ', 'l', 'a',
                       'b', 'e', 'l', 'l', 'i', 'n', 'g', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'e', 'm', '.',
                         'l', 'a', 'b', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q',
                         'u', 'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Bounds info) =
  debug (i []) ['B', 'o', 'u', 'n', 'd', 's']
    (catch_errora (bounds_tt j info tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'b', 'o',
                     'u', 'n', 'd', 's', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ',
                     't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                     'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                   shows_nl .
                     shows_tp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) j tp .
                       shows_nl . x)));
check_trs_termination_proof_main j ia assms i tp (Uncurry u_info rR prf) =
  debug (i []) ['U', 'n', 'c', 'u', 'r', 'r', 'y']
    (bindb
      (catch_errora (uncurry_tt j u_info rR tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       'c', 'u', 'r', 'r', 'y', 'i', 'n', 'g', ' ', 't', 'r',
                       'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o',
                       'n'] .
                     shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c', 'u',
                         'r', 'r', 'y', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Fcc fcs r prf) =
  debug (i []) ['F', 'c', 'c']
    (bindb
      (catch_errora (fcc_tt j fcs r tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       'f', 'l', 'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x',
                       't', ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e'] .
                     shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 'f', 'l', 'a', 't', ' ', 'c', 'o', 'n',
                         't', 'e', 'x', 't', ' ', 'c', 'l', 'o', 's', 'u', 'r',
                         'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Split rrem prf1 prf2) =
  debug (i []) ['S', 'p', 'l', 'i', 't']
    (let {
       (tp1, tp2) = split_tt j tp rrem;
     } in bindb (catch_errora
                  (check_trs_termination_proof_main j ia assms
                    (i . shows_string ['.', '1']) tp1 prf1)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                 'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                 's', 'p', 'l', 'i', 't', 't', 'i', 'n', 'g'] .
                               shows_nl . indent x)))
            (\ _ ->
              catch_errora
                (check_trs_termination_proof_main j ia assms
                  (i . shows_string ['.', '2']) tp2 prf2)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'p',
                               'l', 'i', 't', 't', 'i', 'n', 'g'] .
                             shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Switch_Innermost joins prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', ' ', 'I', 'n', 'n', 'e', 'r', 'm', 'o', 's',
      't']
    (bindb
      (catch_errora (switch_innermost_tt j joins tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g',
                       ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r', 'm', 'o',
                       's', 't', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'w', 'i', 't',
                         'c', 'h', ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r',
                         'm', 'o', 's', 't'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Drop_Equality prf) =
  debug (i []) ['D', 'r', 'o', 'p', ' ', 'E', 'q', 'u', 'a', 'l', 'i', 't', 'y']
    (let {
       tpa = mkc j (nfsb j tp) (qb j tp) (rc j tp)
               (filter (\ (l, r) -> not (equal_term l r)) (rwc j tp));
     } in catch_errora
            (check_trs_termination_proof_main j ia assms
              (i . shows_string ['.', '1']) tpa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 'd', 'r', 'o', 'p', 'p', 'i', 'n',
                           'g', ' ', 'e', 'q', 'u', 'a', 'l', 'i', 't', 'y',
                           ' ', 'r', 'u', 'l', 'e', 's'] .
                         shows_nl . indent x)));
check_trs_termination_proof_main j ia assms i tp
  (Remove_Nonapplicable_Rules r prf) =
  debug (i [])
    ['R', 'e', 'm', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a', 'p',
      'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']
    (let {
       _ = rc j tp;
     } in bindb (catch_errora (check_non_applicable_rules (is_QNFb j tp) r)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'r', 'e', 'm', 'o', 'v',
                                 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a',
                                 'p', 'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e',
                                 ' ', 'r', 'u', 'l', 'e', 's'] .
                               shows_nl .
                                 indent
                                   (shows_rule (shows_prec_lab zero_nat)
                                      (shows_prec_list zero_nat)
                                      [' ', '-', '>', ' '] x .
                                     shows_prec_list zero_nat
                                       [' ', 'i', 's', ' ', 'a', 'p', 'p', 'l',
 'i', 'c', 'a', 'b', 'l', 'e']))))
            (\ _ ->
              let {
                tpa = delete_R_Rwb j tp r r;
              } in catch_errora
                     (check_trs_termination_proof_main j ia assms
                       (i . shows_string ['.', '1']) tpa prf)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                    'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                    'n', 'o', 'n', '-', 'a', 'p', 'p', 'l', 'i',
                                    'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                                    'e', 's', ' ', 'r', 'e', 'm', 'o', 'v', 'a',
                                    'l'] .
                                  shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Permuting_AFS pi prf) =
  debug (i [])
    ['P', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', ' ', 's', 'o', 'm', 'e', ' ',
      'r', 'u', 'l', 'e', 's']
    (bindb
      (catch_errora (argument_filter_tt j pi tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g',
                       ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ' ',
                       'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'p', 'e', 'r', 'm',
                         'u', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                         'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tpa (Assume_SN tp ass) =
  debug (i [])
    ['T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'A', 's', 's',
      'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n',
      'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora (check_tp_subsumes j tp tpa)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a',
                                  't', 'i', 'o', 'n', ' ', 'a', 's', 's', 'u',
                                  'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r',
                                  ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ',
                                  'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_fptrs_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b [Nat]) [Prelude.Char],
                              (Term (Lab b [Nat]) [Prelude.Char], Location))],
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])]) ->
                            Fptrs_termination_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fptrs_termination_proof_main j ia assms i tpa (Assume_FP_SN tp ass) =
  debug (i [])
    ['O', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 'T', 'e', 'r', 'm', 'i',
      'n', 'a', 't', 'i', 'o', 'n', ' ', 'A', 's', 's', 'u', 'm', 'p', 't', 'i',
      'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'P',
      'r', 'o', 'o', 'f']
    (if assms
      then bindb (check (tpa == tp)
                   (shows_prec_list zero_nat
                     ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 'a',
                       's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'd',
                       'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                       'c', 'h', ' ', 'c', 'u', 'r', 'r', 'e', 'n', 't', ' ',
                       'g', 'o', 'a', 'l']))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_dp_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          c -> Dp_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_termination_proof_main j ia assms i dpp P_is_Empty =
  debug (i []) ['P', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y']
    (if null (pb ia dpp) && (null (pwb ia dpp) || null (rd ia dpp)) then Inr ()
      else Inl (i . shows_string
                      [':', ' ', 'P', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                        'e', 'm', 'p', 't', 'y', ' ', 'i', 'n', ' ', 't', 'h',
                        'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                        ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                        ' '] .
                      shows_nl .
                        shows_dpp (shows_prec_lab zero_nat)
                          (shows_prec_list zero_nat) ia dpp));
check_dp_termination_proof_main j ia assms i dpp
  (Subterm_Criterion_Proc p rseq rP prf) =
  debug (i [])
    ['S', 'u', 'b', 't', 'e', 'r', 'm', '_', 'C', 'r', 'i', 't', 'e', 'r', 'i',
      'o', 'n', '_', 'P', 'r', 'o', 'c']
    (let {
       pa = pairsb ia dpp;
       pr = ceta_list_diff pa rP;
     } in bindb (catch_errora (subterm_criterion_proc ia p rseq pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 's',
                                 'u', 'b', 't', 'e', 'r', 'm', ' ', 'c', 'r',
                                 'i', 't', 'e', 'r', 'i', 'o', 'n', ' ', 't',
                                 'o', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ',
                                 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       ['a', 'n', 'd', ' ', 't', 'r', 'y', 'i',
 'n', 'g', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o', 'v', 'e', ' ', 't', 'h', 'e',
 ' ', 'p', 'a', 'i', 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'u',
                               'b', 't', 'e', 'r', 'm', ' ', 'c', 'r', 'i', 't',
                               'e', 'r', 'i', 'o', 'n'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Gen_Subterm_Criterion_Proc p pr prf) =
  debug (i [])
    ['G', 'e', 'n', '_', 'S', 'u', 'b', 't', 'e', 'r', 'm', '_', 'C', 'r', 'i',
      't', 'e', 'r', 'i', 'o', 'n', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (generalized_subterm_proc ia p pr dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r', 'a', 'l',
                       'i', 'z', 'e', 'd', ' ', 's', 'u', 'b', 't', 'e', 'r',
                       'm', ' ', 'c', 'r', 'i', 't', 'e', 'r', 'i', 'o', 'n',
                       ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ',
                       'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl .
                           shows_string
                             ['a', 'n', 'd', ' ', 't', 'r', 'y', 'i', 'n', 'g',
                               ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o', 'v', 'e',
                               ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', 's',
                               ' '] .
                             shows_nl .
                               shows_rules (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                 pr .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e',
                         'r', 'a', 'l', 'i', 'z', 'e', 'd', ' ', 's', 'u', 'b',
                         't', 'e', 'r', 'm', ' ', 'c', 'r', 'i', 't', 'e', 'r',
                         'i', 'o', 'n'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Redpair_Proc redp rP prf) =
  debug (i []) ['R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'P', 'r', 'o', 'c']
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       proc =
         (case redp of {
           Inl rrp ->
             generic_ur_af_root_redtriple_proc ia (get_root_redtriple rrp)
               Nothing;
           Inr rp -> generic_ur_af_redtriple_proc ia (get_redtriple rp) Nothing;
         });
     } in bindb (catch_errora (proc pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'r',
                                 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ',
                                 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c',
                                 'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ',
                                 'r', 'e', 'm', 'o', 'v', 'e', ' ', 'f', 'r',
                                 'o', 'm', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                                 ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e',
                               'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                               'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                               'o', 'r'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Usable_Rules_Proc u prf) =
  debug (i [])
    ['U', 's', 'a', 'b', 'l', 'e', '_', 'R', 'u', 'l', 'e', 's', '_', 'P', 'r',
      'o', 'c']
    (bindb
      (catch_errora (usable_rules_proc ia u dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                       'r', 'u', 'l', 'e', 's', ' ', 'p', 'r', 'o', 'c', 'e',
                       's', 's', 'o', 'r', ' ', 't', 'o', ' ', 'r', 'e', 's',
                       't', 'r', 'i', 'c', 't', ' ', 't', 'h', 'e', ' ', 'D',
                       'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'u', 's',
                               'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's',
                               ' '] .
                             shows_nl .
                               shows_rules (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                 u .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 's', 'a', 'b',
                         'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'p', 'r',
                         'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Q_Reduction_Proc q prf) =
  debug (i [])
    ['Q', '_', 'R', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', '_', 'P', 'r', 'o',
      'c']
    (bindb
      (catch_errora (q_reduction_proc ia q dpp)
        (\ x ->
          Inl (i . shows_prec_list zero_nat
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'Q', '-', 'r', 'e', 'd', 'u', 'c',
                       't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                       's', 'o', 'r'] .
                     shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', '-', 'r', 'e',
                         'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o',
                         'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_Redpair_Proc redp rP rR prf) =
  debug (i [])
    ['M', 'o', 'n', 'o', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'P', 'r',
      'o', 'c']
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       r = rulese ia dpp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora
                  (mono_redpair_proc ia (get_redtriple redp) pr rr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'm',
                                 'o', 'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c',
                                 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r',
                                 ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                                 'r', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
                                 'v', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't',
                                 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o',
                                 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl .
     shows_string
       [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's',
         ' '] .
       shows_nl .
         shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
           [' ', '-', '>', ' '] rr .
           shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o',
                               'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i',
                               'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r',
                               'o', 'c', 'e', 's', 's', 'o', 'r'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_URM_Redpair_Proc redp pr rr prf) =
  debug (i [])
    ['M', 'o', 'n', 'o', '_', 'U', 'R', 'M', '_', 'R', 'e', 'd', 'p', 'a', 'i',
      'r', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (mono_urm_redpair_proc ia (get_redtriple redp) pr rr dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'm', 'o', 'n', 'o', ' ', 'r', 'e',
                       'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i',
                       'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r',
                       ' ', 'w', 'i', 't', 'h', ' ', 'u', 's', 'a', 'b', 'l',
                       'e', ' ', 'r', 'e', 'p', 'l', '.', ' ', 'm', 'a', 'p',
                       ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o', 'v', 'e', ' ',
                       'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                       ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl .
                           shows_string
                             [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', 's',
                               ' '] .
                             shows_nl .
                               shows_rules (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                 pr .
                                 shows_nl .
                                   shows_string
                                     [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e',
                                       ' ', 'r', 'u', 'l', 'e', 's', ' '] .
                                     shows_nl .
                                       shows_rules (shows_prec_lab zero_nat)
 (shows_prec_list zero_nat) [' ', '-', '>', ' '] rr .
 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'n', 'o',
                         ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ',
                         'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                         's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Dep_Graph_Proc edpts) =
  debug (i [])
    ['D', 'e', 'p', '_', 'G', 'r', 'a', 'p', 'h', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (dep_graph_proc ia dpp edpts)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i',
                       'l', 'e', ' ', 't', 'r', 'y', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'p', 'e', 'r', 'f', 'o', 'r', 'm', ' ', 'S',
                       'C', 'C', '-', 'd', 'e', 'c', 'o', 'm', 'p', 'o', 's',
                       'i', 't', 'i', 'o', 'n', ' ', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ pdpps ->
        catch_errora
          (catch_errora
            (forallM_index
              (\ (prof, dppa) ja ->
                check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.'] . shows_prec_nat zero_nat (suc ja))
                  dppa prof)
              pdpps)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'd', 'e', 'p', 'e',
                         'n', 'd', 'e', 'n', 'c', 'y', ' ', 'g', 'r', 'a', 'p',
                         'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                         'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Redpair_UR_Proc redp rP ur prf) =
  debug (i [])
    ['R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'U', 'R', '_', 'P', 'r', 'o', 'c']
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       proc =
         (case redp of {
           Inl rrp ->
             generic_ur_af_root_redtriple_proc ia (get_root_redtriple rrp)
               (Just ur);
           Inr rp ->
             generic_ur_af_redtriple_proc ia (get_redtriple rp) (Just ur);
         });
     } in bindb (catch_errora (proc pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'r',
                                 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ',
                                 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c',
                                 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                                 'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                                 'r', 'u', 'l', 'e', 's', ' ', 't', 'o', ' ',
                                 'r', 'e', 'm', 'o', 'v', 'e', ' ', 'f', 'r',
                                 'o', 'm', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                                 ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e',
                               'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                               'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                               'o', 'r'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_Redpair_UR_Proc redp rP rR ur prf) =
  debug (i [])
    ['M', 'o', 'n', 'o', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'U', 'R',
      '_', 'P', 'r', 'o', 'c']
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       r = rulese ia dpp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora
                  (generic_mono_ur_redpair_proc ia (get_redtriple redp) pr rr ur
                    dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'm',
                                 'o', 'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c',
                                 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r',
                                 ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                                 'r', ' ', 'w', 'i', 't', 'h', ' ', 'u', 's',
                                 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                                 's', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
                                 'v', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't',
                                 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o',
                                 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl .
     shows_string
       [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's',
         ' '] .
       shows_nl .
         shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
           [' ', '-', '>', ' '] rr .
           shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o',
                               'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i',
                               'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r',
                               'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i',
                               't', 'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                               'r', 'u', 'l', 'e', 's'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Uncurry_Proc mode u_info p r prf) =
  debug (i []) ['U', 'n', 'c', 'u', 'r', 'r', 'y', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (uncurry_proc_both ia mode u_info p r dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'u', 'n', 'c', 'u', 'r', 'r', 'y',
                       'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'D',
                       'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c', 'u',
                         'r', 'r', 'y', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c',
                         'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Size_Change_Subterm_Proc graphs) =
  debug (i [])
    ['S', 'i', 'z', 'e', '_', 'C', 'h', 'a', 'n', 'g', 'e', '_', 'S', 'u', 'b',
      't', 'e', 'r', 'm', '_', 'P', 'r', 'o', 'c']
    (catch_errora (sct_subterm_proc ia graphs dpp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 't', 'h',
                     'e', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g',
                     'e', ' ', '(', 's', 'u', 'b', 't', 'e', 'r', 'm', ')', ' ',
                     'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'o', 'n',
                     ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b',
                     'l', 'e', 'm'] .
                   shows_nl .
                     shows_dpp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) ia dpp .
                       shows_nl . x)));
check_dp_termination_proof_main j ia assms i dpp
  (Size_Change_Redpair_Proc redp u_opt graphs) =
  debug (i [])
    ['S', 'i', 'z', 'e', '_', 'C', 'h', 'a', 'n', 'g', 'e', '_', 'R', 'e', 'd',
      'p', 'a', 'i', 'r', '_', 'P', 'r', 'o', 'c']
    (catch_errora (sct_ur_af_proc ia (get_redtriple redp) graphs u_opt dpp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 't', 'h',
                     'e', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g',
                     'e', ' ', '(', 'r', 'e', 'd', 'p', 'a', 'i', 'r', ')', ' ',
                     'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'o', 'n',
                     ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b',
                     'l', 'e', 'm'] .
                   shows_nl .
                     shows_dpp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) ia dpp .
                       shows_nl . x)));
check_dp_termination_proof_main j ia assms i dpp (Fcc_Proc f fcs pb r prf) =
  debug (i []) ['F', 'c', 'c', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (fcc_proc ia f fcs pb r dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'f', 'l', 'a', 't', ' ', 'c', 'o',
                       'n', 't', 'e', 'x', 't', ' ', 'c', 'l', 'o', 's', 'u',
                       'r', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                       ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'f', 'l', 'a', 't',
                         ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', ' ', 'c', 'l',
                         'o', 's', 'u', 'r', 'e', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Split_Proc prem rrem prf1 prf2) =
  debug (i []) ['S', 'p', 'l', 'i', 't', '_', 'P', 'r', 'o', 'c']
    (case get_fcc_option prf1 of {
      Nothing ->
        let {
          (dpp1, dpp2) = split_proc ia dpp prem rrem;
        } in bindb (catch_errora
                     (check_dp_termination_proof_main j ia assms
                       (i . shows_string ['.', '1']) dpp1 prf1)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                    'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                    's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o',
                                    'c', 'e', 's', 's', 'o', 'r'] .
                                  shows_nl . indent x)))
               (\ _ ->
                 catch_errora
                   (check_dp_termination_proof_main j ia assms
                     (i . shows_string ['.', '2']) dpp2 prf2)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                  's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o',
                                  'c', 'e', 's', 's', 'o', 'r'] .
                                shows_nl . indent x)));
      Just (f, (fcs, (pb, (rb, prf1a)))) ->
        debug (i [])
          ['S', 'p', 'l', 'i', 't', '_', 'P', 'r', 'o', 'c', 'F', 'c', 'c']
          (bindb (fcc_split_proc ia f fcs pb rb prem rrem dpp)
            (\ (dpp1, dpp2) ->
              bindb (catch_errora
                      (check_dp_termination_proof_main j ia assms
                        (i . shows_string ['.', '1', '.', '1']) dpp1 prf1a)
                      (\ x ->
                        Inl (i . shows_string
                                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                     'e', 'l', 'o', 'w', ' ', 't', 'h', 'e',
                                     ' ', 's', 'p', 'l', 'i', 't', ' ', 'a',
                                     'n', 'd', ' ', 'f', 'c', 'c', ' ', 'p',
                                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                                   shows_nl . indent x)))
                (\ _ ->
                  catch_errora
                    (check_dp_termination_proof_main j ia assms
                      (i . shows_string ['.', '2']) dpp2 prf2)
                    (\ x ->
                      Inl (i . shows_string
                                 [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                   'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                   's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o',
                                   'c', 'e', 's', 's', 'o', 'r'] .
                                 shows_nl . indent x)))));
    });
check_dp_termination_proof_main j ia assms i dpp (Semlab_Proc sli lP lQ lR prf)
  = debug (i []) ['S', 'e', 'm', 'l', 'a', 'b', '_', 'P', 'r', 'o', 'c']
      (bindb
        (catch_errora (semlab_fin_proc ia sli lP lQ lR dpp)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         't', 'h', 'e', ' ', 's', 'e', 'm', 'l', 'a', 'b', ' ',
                         'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'o',
                         'n', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r',
                         'o', 'b', 'l', 'e', 'm'] .
                       shows_nl .
                         shows_dpp (shows_prec_lab zero_nat)
                           (shows_prec_list zero_nat) ia dpp .
                           shows_nl . x)))
        (\ dppa ->
          catch_errora
            (check_dp_termination_proof_main j ia assms
              (i . shows_string ['.', '1']) dppa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'e', 'm',
                           'l', 'a', 'b', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                           's', 'o', 'r'] .
                         shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Switch_Innermost_Proc joins prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', '_', 'I', 'n', 'n', 'e', 'r', 'm', 'o', 's',
      't', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (switch_innermost_proc ia joins dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c',
                       'h', ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                       'o', 's', 't', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ',
                       'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'w', 'i', 't',
                         'c', 'h', ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r',
                         'm', 'o', 's', 't', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                         's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dppa (Assume_Finite dpp ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora (check_dpp_subsumes ia dpp dppa)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n',
                                  'e', 's', 's', ' ', 'a', 's', 's', 'u', 'm',
                                  'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ',
                                  'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                                  'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assma j ia
                         (check_trs_termination_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_dp_termination_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_fptrs_termination_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_unknown_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's',
                        ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
                        ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n',
                        ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));
check_dp_termination_proof_main j ia assms i dpp
  (Rewriting_Proc u_opt stb sta st lr p prf) =
  debug (i [])
    ['R', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (rewriting_proc ia u_opt stb sta st lr p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r', ' ', 't', 'o', ' ', 'r', 'e', 'w', 'r', 'i', 't',
                       'e', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', ' '] .
                     shows_nl .
                       shows_rule (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] stb .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                               'i', 'r', ' '] .
                             shows_nl .
                               shows_rule (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                 st .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Narrowing_Proc st p sts prf) =
  debug (i [])
    ['N', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (narrowing_proc ia st p sts dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'n', 'a', 'r', 'r', 'o', 'w', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r', ' ', 't', 'o', ' ', 'n', 'a', 'r', 'r', 'o', 'w',
                       ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', ' '] .
                     shows_nl .
                       shows_rule (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] st .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                               'i', 'r', 's', ' '] .
                             shows_nl .
                               shows_trs (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat)
                                 ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                   'y', 's', 't', 'e', 'm', ':']
                                 [' ', '-', '>', ' '] sts .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'n', 'a', 'r', 'r',
                         'o', 'w', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Instantiation_Proc st sts prf)
  = debug (i [])
      ['I', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n', '_',
        'P', 'r', 'o', 'c']
      (bindb
        (catch_errora (instantiation_proc ia st sts dpp)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         't', 'h', 'e', ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                         'i', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c',
                         'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ', 'i', 'n',
                         's', 't', 'a', 'n', 't', 'i', 'a', 't', 'e', ' ', 't',
                         'h', 'e', ' ', 'p', 'a', 'i', 'r', ' '] .
                       shows_nl .
                         shows_rule (shows_prec_lab zero_nat)
                           (shows_prec_list zero_nat) [' ', '-', '>', ' '] st .
                           shows_nl .
                             shows_string
                               [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p',
                                 'a', 'i', 'r', 's', ' '] .
                               shows_nl .
                                 shows_trs (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat)
                                   ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                     'y', 's', 't', 'e', 'm', ':']
                                   [' ', '-', '>', ' '] sts .
                                   shows_nl . x)))
        (\ dppa ->
          catch_errora
            (check_dp_termination_proof_main j ia assms
              (i . shows_string ['.', '1']) dppa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 't', 'h', 'e', ' ', 'i', 'n', 's',
                           't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                           ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                         shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Forward_Instantiation_Proc st sts u_opt prf) =
  debug (i [])
    ['F', 'o', 'r', 'w', 'a', 'r', 'd', '_', 'I', 'n', 's', 't', 'a', 'n', 't',
      'i', 'a', 't', 'i', 'o', 'n', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (forward_instantiation_proc ia st sts u_opt dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'f', 'o', 'r', 'w', 'a', 'r', 'd',
                       '_', 'i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't',
                       'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 't', 'o', ' ', 'i', 'n', 's', 't', 'a',
                       'n', 't', 'i', 'a', 't', 'e', ' ', 't', 'h', 'e', ' ',
                       'p', 'a', 'i', 'r', ' '] .
                     shows_nl .
                       shows_rule (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] st .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                               'i', 'r', 's', ' '] .
                             shows_nl .
                               shows_trs (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat)
                                 ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                   'y', 's', 't', 'e', 'm', ':']
                                 [' ', '-', '>', ' '] sts .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'r', 'w',
                         'a', 'r', 'd', ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                         'i', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c',
                         'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Unlab_Proc p r prf) =
  debug (i []) ['U', 'n', 'l', 'a', 'b', '_', 'P', 'r', 'o', 'c']
    (Inl (shows_prec_list zero_nat
           ['u', 'n', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ' ', 'p', 'r',
             'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'n', 'o', 't', ' ', 's',
             'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']));
check_dp_termination_proof_main j ia assms i dpp
  (General_Redpair_Proc rp ps pb prof prfs) =
  debug (i [])
    ['G', 'e', 'n', 'e', 'r', 'a', 'l', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r',
      '_', 'P', 'r', 'o', 'c', 'P', 'r', 'o', 'c']
    (let {
       n = size_list prfs;
     } in bindb (check (less_nat zero_nat n)
                  (shows_prec_list zero_nat
                    ['a', 't', ' ', 'l', 'e', 'a', 's', 't', ' ', 'o', 'n', 'e',
                      ' ', 's', 'u', 'b', 'p', 'r', 'o', 'o', 'f', ' ', 'i',
                      's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
            (\ _ ->
              let {
                merge = equal_nat n one_nat;
              } in bindb (catch_errora
                           (conditional_general_reduction_pair_proc ia
                             (get_non_inf_order rp) ps pb prof merge dpp)
                           (\ x ->
                             Inl (i . shows_string
[':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'a', 'p', 'p',
  'l', 'y', 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r',
  'i', 'c', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
  'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 't', 'o',
  ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
shows_nl .
  shows_dpp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) ia dpp .
    shows_nl . x)))
                     (\ dpps ->
                       bindb (catch_errora
                               (check_dp_termination_proof_main j ia assms
                                 (i . shows_string ['.', '1'])
                                 (nth dpps zero_nat) (nth prfs zero_nat))
                               (\ x ->
                                 Inl (i . shows_string
    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l', 'o', 'w', ' ', 't',
      'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r', 'i', 'c', ' ', 'r', 'e', 'd', 'u',
      'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c',
      'e', 's', 's', 'o', 'r'] .
    shows_nl . indent x)))
                         (\ _ ->
                           (if merge then Inr ()
                             else catch_errora
                                    (check_dp_termination_proof_main j ia assms
                                      (i . shows_string ['.', '2'])
                                      (nth dpps one_nat) (nth prfs one_nat))
                                    (\ x ->
                                      Inl
(i . shows_string
       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l', 'o', 'w', ' ',
         't', 'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r', 'i', 'c', ' ', 'r', 'e',
         'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
       shows_nl . indent x)))))));
check_dp_termination_proof_main j ia assms i dpp
  (Complex_Constant_Removal_Proc p prf) =
  debug (i [])
    ['C', 'o', 'm', 'p', 'l', 'e', 'x', '_', 'C', 'o', 'n', 's', 't', 'a', 'n',
      't', '_', 'R', 'e', 'm', 'o', 'v', 'a', 'l', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (complex_constant_removal_proc ia p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x',
                       ' ', 'c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'r',
                       'e', 'm', 'o', 'v', 'a', 'l', ' ', 'p', 'r', 'o', 'c',
                       'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ', 't', 'h',
                       'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e',
                       'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'm', 'p',
                         'l', 'e', 'x', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n',
                         't', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'p',
                         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (To_Trs_Proc prf) =
  debug (i []) ['T', 'o', '_', 'T', 'r', 's', '_', 'P', 'r', 'o', 'c']
    (catch_errora
      (check_trs_termination_proof_main j ia assms (i . shows_string ['.', '1'])
        (mk_tp j
          (nfsc ia dpp,
            (qc ia dpp, (pb ia dpp ++ rd ia dpp, pwb ia dpp ++ rwd ia dpp))))
        prf)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l', 'o',
                     'w', ' ', 't', 'h', 'e', ' ', 'T', 'o', '-', 'T', 'r', 's',
                     ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                   shows_nl . indent x)));

check_unknown_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Unknown_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_proof_main j ia assms i tpa (Assume_Unknown tp ass) =
  debug (i []) ['U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora
                   (check (tpa == tp)
                     (shows_prec_list zero_nat
                        ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o',
                          'b', 'l', 'e', 'm', 's', ' ', 'a', 'r', 'e', ' ', 'n',
                          'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i', 'c', 'a',
                          'l', ':', ' '] .
                       shows_nl .
                         shows_prec_list zero_nat tpa .
                           shows_nl .
                             shows_prec_list zero_nat [' ', 'v', 's', ' '] .
                               shows_nl . shows_prec_list zero_nat tp))
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a',
                                  't', 'i', 'o', 'n', ' ', 'a', 's', 's', 'u',
                                  'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r',
                                  ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ',
                                  'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                        'r', 'o', 'o', 'f'] .
                      shows_nl));

map_assm_proof ::
  forall a b c d e f g.
    (a -> a) ->
      (b -> b) ->
        (c -> c) ->
          (d -> d) ->
            Generic_assm_proof e f g a b c () d ->
              Generic_assm_proof e f g a b c () d;
map_assm_proof tp dpp fptp unk (SN_assm_proof r p) = SN_assm_proof r (tp p);
map_assm_proof tp dpp fptp unk (Finite_assm_proof d p) =
  Finite_assm_proof d (dpp p);
map_assm_proof tp dpp fptp unk (SN_FP_assm_proof r p) =
  SN_FP_assm_proof r (fptp p);
map_assm_proof tp dpp fptp unk (Unknown_assm_proof u p) =
  Unknown_assm_proof u (unk p);
map_assm_proof tp dpp fptp unk (Not_SN_assm_proof v va) =
  Not_SN_assm_proof v va;
map_assm_proof tp dpp fptp unk (Infinite_assm_proof v va) =
  Infinite_assm_proof v va;
map_assm_proof tp dpp fptp unk (Not_RelSN_assm_proof v va) =
  Not_RelSN_assm_proof v va;
map_assm_proof tp dpp fptp unk (Not_SN_FP_assm_proof v va) =
  Not_SN_FP_assm_proof v va;
map_assm_proof tp dpp fptp unk (Complexity_assm_proof v va) =
  Complexity_assm_proof v va;

no_decr ::
  forall a b c.
    (Eq a, Eq b,
      Eq c) => [(Term (Lab a b) c, Term (Lab a b) c)] ->
                 [(Term (Lab a b) c, Term (Lab a b) c)];
no_decr =
  filter
    (\ (l, r) ->
      not (not (equal_term l r) &&
            equal_term (map_term unlab (\ x -> x) l)
              (map_term unlab (\ x -> x) r)));

unlab_of_trs ::
  forall a b c.
    (Eq a, Eq b,
      Eq c) => [(Term (Lab a b) c, Term (Lab a b) c)] ->
                 [(Term (Lab a b) c, Term (Lab a b) c)];
unlab_of_trs r = map (map_funs_rule unlab) (no_decr r);

updatec :: forall a b c. (a -> b) -> (a, c) -> (b, c);
updatec p_to_p (p, info) = (p_to_p p, info);

unlab_to_split_trs ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Trs_termination_proof a b c -> Trs_termination_proof a b c;
unlab_to_split_trs (DP_Trans a1 a2 a3 p) =
  DP_Trans a1 a2 a3 (fst (unlab_to_split_dp p));
unlab_to_split_trs (Rule_Removal a1 a2 p) =
  Rule_Removal a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (String_Reversal p) = String_Reversal (unlab_to_split_trs p);
unlab_to_split_trs (Constant_String a1 p) =
  Constant_String a1 (unlab_to_split_trs p);
unlab_to_split_trs (Bounds a) = Bounds a;
unlab_to_split_trs (Uncurry a1 a2 p) = Uncurry a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (Semlab a1 a2 a3 p) = Semlab a1 a2 a3 (unlab_to_split_trs p);
unlab_to_split_trs R_is_Empty = R_is_Empty;
unlab_to_split_trs (Fcc a1 a2 p) = Fcc a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (Split a1 p q) =
  Split a1 (unlab_to_split_trs p) (unlab_to_split_trs q);
unlab_to_split_trs (Switch_Innermost a1 p) =
  Switch_Innermost a1 (unlab_to_split_trs p);
unlab_to_split_trs (Drop_Equality p) = Drop_Equality (unlab_to_split_trs p);
unlab_to_split_trs (Remove_Nonapplicable_Rules a1 p) =
  Remove_Nonapplicable_Rules a1 (unlab_to_split_trs p);
unlab_to_split_trs (Permuting_AFS a1 p) =
  Permuting_AFS a1 (unlab_to_split_trs p);
unlab_to_split_trs (Assume_SN a p) =
  Assume_SN a
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_unknown ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Unknown_proof a b c -> Unknown_proof a b c;
unlab_to_split_unknown (Assume_Unknown a1 p) =
  Assume_Unknown a1
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_otrs ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Fptrs_termination_proof a b c -> Fptrs_termination_proof a b c;
unlab_to_split_otrs (Assume_FP_SN a p) =
  Assume_FP_SN a
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_dp ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Dp_termination_proof a b c ->
                  (Dp_termination_proof a b c,
                    [([(Term (Lab a b) c, Term (Lab a b) c)],
                       ([(Term (Lab a b) c, Term (Lab a b) c)],
                         Dp_termination_proof a b c))]);
unlab_to_split_dp P_is_Empty = (P_is_Empty, []);
unlab_to_split_dp (Dep_Graph_Proc ps) =
  (Dep_Graph_Proc
     (map (\ (po, a) -> (map_option (fst . unlab_to_split_dp) po, a)) ps),
    []);
unlab_to_split_dp (Subterm_Criterion_Proc a1 a2 a3 p) =
  updatec (Subterm_Criterion_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Gen_Subterm_Criterion_Proc a1 a2 p) =
  updatec (Gen_Subterm_Criterion_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Redpair_Proc a1 a2 p) =
  updatec (Redpair_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Redpair_UR_Proc a1 a2 a3 p) =
  updatec (Redpair_UR_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Usable_Rules_Proc a1 p) =
  updatec (Usable_Rules_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Q_Reduction_Proc a1 p) =
  updatec (Q_Reduction_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_Redpair_Proc a1 a2 a3 p) =
  updatec (Mono_Redpair_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_URM_Redpair_Proc a1 a2 a3 p) =
  updatec (Mono_URM_Redpair_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_Redpair_UR_Proc a1 a2 a3 a4 p) =
  updatec (Mono_Redpair_UR_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Size_Change_Subterm_Proc a1) =
  (Size_Change_Subterm_Proc a1, []);
unlab_to_split_dp (Size_Change_Redpair_Proc a1 a2 a3) =
  (Size_Change_Redpair_Proc a1 a2 a3, []);
unlab_to_split_dp (Uncurry_Proc a1 a2 a3 a4 p) =
  updatec (Uncurry_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Fcc_Proc a1 a2 a3 a4 p) =
  updatec (Fcc_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Switch_Innermost_Proc a1 p) =
  updatec (Switch_Innermost_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Rewriting_Proc a1 a2 a3 a4 a5 a6 p) =
  updatec (Rewriting_Proc a1 a2 a3 a4 a5 a6) (unlab_to_split_dp p);
unlab_to_split_dp (Narrowing_Proc a1 a2 a3 p) =
  updatec (Narrowing_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Instantiation_Proc a1 a2 p) =
  updatec (Instantiation_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Forward_Instantiation_Proc a1 a2 a3 p) =
  updatec (Forward_Instantiation_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Assume_Finite d p) =
  (Assume_Finite d
     (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
            unlab_to_split_otrs unlab_to_split_unknown)
       p),
    []);
unlab_to_split_dp (To_Trs_Proc p) = (To_Trs_Proc (unlab_to_split_trs p), []);
unlab_to_split_dp (Unlab_Proc pa r p) = let {
  (pb, list) = unlab_to_split_dp p;
} in (P_is_Empty, (pa, (r, pb)) : list);
unlab_to_split_dp (Split_Proc a1 a2 p q) =
  (Split_Proc a1 a2 (fst (unlab_to_split_dp p)) (fst (unlab_to_split_dp q)),
    []);
unlab_to_split_dp (Semlab_Proc a1 lP a2 lR p) =
  let {
    (pa, list) = unlab_to_split_dp p;
    sl = Semlab_Proc a1 lP a2 lR pa;
  } in (case list of {
         [] -> (sl, list);
         (pb, (r, prof)) : lista -> let {
                                      ulP = unlab_of_trs lP;
                                      ulR = unlab_of_trs lR;
                                      pr = ceta_list_diff ulP pb;
                                      rr = ceta_list_diff ulR r;
                                    } in (Split_Proc pr rr sl prof, lista);
       });
unlab_to_split_dp (General_Redpair_Proc a1 a2 a3 a4 ps) =
  (General_Redpair_Proc a1 a2 a3 a4 ps, []);
unlab_to_split_dp (Complex_Constant_Removal_Proc a1 p) =
  updatec (Complex_Constant_Removal_Proc a1) (unlab_to_split_dp p);

check_trs_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_termination_proof ia j a i tp prf =
  check_trs_termination_proof_main ia j a i tp (unlab_to_split_trs prf);

rule_lab_repr_to_lab ::
  forall a b.
    (Key a,
      Key b) => [((Term a b, Term a b), Nat)] -> (Term a b, Term a b) -> Nat;
rule_lab_repr_to_lab ps = fun_of_map (ceta_map_of ps) zero_nat;

critical_peaks_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Bool,
                     ((Term a [Prelude.Char],
                        ((Term a [Prelude.Char], Term a [Prelude.Char]),
                          (Pos, ([Prelude.Char] -> Term a [Prelude.Char],
                                  (Bool, Term a [Prelude.Char]))))),
                       (Term a [Prelude.Char],
                         ((Term a [Prelude.Char], Term a [Prelude.Char]),
                           (Pos, ([Prelude.Char] -> Term a [Prelude.Char],
                                   (Bool, Term a [Prelude.Char])))))))];
critical_peaks_impl p r =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ pa ->
          let {
            c = ctxt_of_pos_term pa l;
            la = subt_at l pa;
            b = equal_ctxt c Hole;
          } in (if is_Var la then []
                 else concatMap
                        (\ (lb, rb) ->
                          (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                                  (\ a -> 'y' : a) la lb
                            of {
                            Nothing -> [];
                            Just (sigma, tau) ->
                              [(b, ((subst_apply_term l sigma,
                                      ((l, ra),
(Empty, (sigma, (True, subst_apply_term ra sigma))))),
                                     (subst_apply_term l sigma,
                                       ((lb, rb),
 (pa, (tau, (True,
              ctxt_apply_term (subst_apply_ctxt c sigma)
                (subst_apply_term rb tau))))))))];
                          }))
                        r))
        (poss_list l))
    p;

check_rstepsa ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), Term a b))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rstepsa r [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term zero_nat u . shows_nl);
check_rstepsa r ((p, (lr, t)) : rs) s u =
  bindb (check_rstep r p lr s t) (\ _ -> check_rstepsa r rs t u);

check_estep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Pos ->
                      (Term a b, Term a b) ->
                        Bool ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_estep e p rule l_to_r s t =
  bindb (check (membera e rule)
          (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] rule .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'e', 'q',
                'u', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f'] .
              shows_nl .
                shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                  ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 's',
                    'y', 's', 't', 'e', 'm', ':']
                  [' ', '=', ' '] e .
                  shows_nl))
    (\ _ ->
      bindb (check (in_poss p s)
              (shows_prec_pos zero_nat p .
                shows_string
                  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
                    's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                  shows_prec_term zero_nat s . shows_nl))
        (\ _ ->
          bindb (check (in_poss p t)
                  (shows_prec_pos zero_nat p .
                    shows_string
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p',
                        'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                      shows_prec_term zero_nat t . shows_nl))
            (\ _ ->
              let {
                c = ctxt_of_pos_term p s;
                d = ctxt_of_pos_term p t;
                u = subt_at s p;
                v = subt_at t p;
                rrule = (if l_to_r then rule else (snd rule, fst rule));
                err = shows_string
                        ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                        shows_prec_term zero_nat t .
                          shows_string
                            [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                              'r', 'e', 's', 'u', 'l', 't', ' ', 'f', 'r', 'o',
                              'm', ' ', 'a', ' ', 'p', 'r', 'o', 'p', 'e', 'r',
                              ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                              'o', 'n', ' ', 'o', 'f', ' ', 't', 'e', 'r', 'm',
                              ' '] .
                            shows_prec_term zero_nat s .
                              shows_string
                                [' ', 'u', 's', 'i', 'n', 'g', ' ', 'e', 'q',
                                  'u', 'a', 't', 'i', 'o', 'n', ' '] .
                                shows_nl .
                                  shows_rule (shows_prec zero_nat)
                                    (shows_prec zero_nat) [' ', '=', ' ']
                                    rrule .
                                    shows_string
                                      [' ', 'a', 't', ' ', 'p', 'o', 's', 'i',
't', 'i', 'o', 'n', ' '] .
                                      shows_prec_pos zero_nat p . shows_nl;
              } in (case match_list Var [(fst rrule, u), (snd rrule, v)] of {
                     Nothing -> Inl err;
                     Just _ -> check (equal_ctxt c d) err;
                   }))));

check_conversion ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conversion e [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's',
         'i', 'o', 'n', ' '] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term zero_nat u . shows_nl);
check_conversion e ((p, (r, (l_to_r, t))) : c) s u =
  bindb (check_estep e p r l_to_r s t) (\ _ -> check_conversion e c t u);

check_ELD_1_nat ::
  Nat ->
    Nat -> [Nat] -> [Nat] -> [Nat] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3 =
  bindb (catch_errora
          (forallM
            (\ x ->
              check (less_nat x beta)
                (shows_prec_list zero_nat
                  [' ', 'l', 'a', 'b', 'e', 'l', 's', ' ', 'a', 'r', 'e', ' ',
                    'n', 'o', 't', ' ', 'd', 'e', 'c', 'r', 'e', 'a', 's', 'i',
                    'n', 'g']))
            sigma_1)
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ x ->
                  check (less_eq_nat x alpha)
                    (shows_prec_list zero_nat
                      [' ', 'l', 'a', 'b', 'e', 'l', 's', ' ', 'a', 'r', 'e',
                        ' ', 'n', 'o', 't', ' ', 'd', 'e', 'c', 'r', 'e', 'a',
                        's', 'i', 'n', 'g']))
                sigma_2)
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (check (less_eq_nat (size_list sigma_2) one_nat)
                  (shows_prec_list zero_nat
                    [' ', 'l', 'e', 'n', 'g', 't', 'h', ' ', 'o', 'f', ' ', 'm',
                      'i', 'd', 'd', 'l', 'e', ' ', 's', 'e', 'q', 'u', 'e',
                      'n', 'c', 'e', ' ', 'i', 's', ' ', 'g', 'r', 'e', 'a',
                      't', 'e', 'r', ' ', '1', ' ']))
            (\ _ ->
              catch_errora
                (forallM
                  (\ x ->
                    check (less_nat x alpha || less_nat x beta)
                      (shows_prec_list zero_nat
                        [' ', 'l', 'a', 'b', 'e', 'l', 's', ' ', 'a', 'r', 'e',
                          ' ', 'n', 'o', 't', ' ', 'd', 'e', 'c', 'r', 'e', 'a',
                          's', 'i', 'n', 'g']))
                  sigma_3)
                (\ x -> Inl (snd x)))));

rule_labeling ::
  forall a b.
    ((Term a b, Term a b) -> Nat) ->
      (Term a b,
        ((Term a b, Term a b), (Pos, (b -> Term a b, (Bool, Term a b))))) ->
        Nat;
rule_labeling i (s, (rl, (p, (sigma, t)))) = i rl;

eseq_to_step_list ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b ->
                           [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                             [(Term a b,
                                ((Term a b, Term a b),
                                  (Pos, (b -> Term a b, (Bool, Term a b)))))];
eseq_to_step_list s [] = [];
eseq_to_step_list s ((p, (lr, (b, t))) : steps) =
  let {
    u = subt_at s p;
    v = subt_at t p;
  } in (if b then let {
                    sigma =
                      let {
                        (Just tau) = match_list Var [(fst lr, u), (snd lr, v)];
                      } in tau;
                  } in (s, (lr, (p, (sigma, (b, t))))) :
                         eseq_to_step_list t steps
         else let {
                sigma =
                  let {
                    (Just tau) = match_list Var [(snd lr, u), (fst lr, v)];
                  } in tau;
              } in (t, (lr, (p, (sigma, (b, s))))) : eseq_to_step_list t steps);

eseq_to_ddconv ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b,
                           [(Pos, ((Term a b, Term a b), (Bool, Term a b)))]) ->
                           (Term a b,
                             [(Term a b,
                                ((Term a b, Term a b),
                                  (Pos, (b -> Term a b, (Bool, Term a b)))))]);
eseq_to_ddconv (s, eseq) = (s, eseq_to_step_list s eseq);

cpeak_instance ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b ->
                           (Term a b, Term a b) ->
                             Term a b -> (Term a b, Term a b) -> Bool;
cpeak_instance sa cpa s cp =
  not (is_none
        (match_list (\ _ -> sa)
          [(sa, s), (fst cpa, fst cp), (snd cpa, snd cp)]));

rseq_to_step_list ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b ->
                           [(Pos, ((Term a b, Term a b), Term a b))] ->
                             [(Term a b,
                                ((Term a b, Term a b),
                                  (Pos, (b -> Term a b, (Bool, Term a b)))))];
rseq_to_step_list s [] = [];
rseq_to_step_list s ((p, (lr, t)) : steps) =
  let {
    u = subt_at s p;
    v = subt_at t p;
    sigma = let {
              (Just tau) = match_list Var [(fst lr, u), (snd lr, v)];
            } in tau;
  } in (s, (lr, (p, (sigma, (True, t))))) : rseq_to_step_list t steps;

rseq_to_ddseq ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b,
                           [(Pos, ((Term a b, Term a b), Term a b))]) ->
                           (Term a b,
                             [(Term a b,
                                ((Term a b, Term a b),
                                  (Pos, (b -> Term a b, (Bool, Term a b)))))]);
rseq_to_ddseq (s, rseq) = (s, rseq_to_step_list s rseq);

get_source ::
  forall a b.
    (Term a b,
      ((Term a b, Term a b), (Pos, (b -> Term a b, (Bool, Term a b))))) ->
      Term a b;
get_source s = fst s;

eseq_last ::
  forall a b.
    Term a b -> [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] -> Term a b;
eseq_last s steps = last (s : map (\ (_, (_, (_, sa))) -> sa) steps);

check_cpeak_eldc ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b,
                       ((Term a b, Term a b),
                         (Pos, (b -> Term a b, (Bool, Term a b))))),
                      (Term a b,
                        ((Term a b, Term a b),
                          (Pos, (b -> Term a b, (Bool, Term a b)))))) ->
                      Term a b ->
                        (Term a b, Term a b) ->
                          [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                            [(Pos, ((Term a b, Term a b), Term a b))] ->
                              [(Pos, ((Term a b, Term a b),
                                       (Bool, Term a b)))] ->
                                [(Pos, ((Term a b, Term a b),
 (Bool, Term a b)))] ->
                                  [(Pos, ((Term a b, Term a b), Term a b))] ->
                                    [(Pos, ((Term a b, Term a b),
     (Bool, Term a b)))] ->
                                      ((Term a b, Term a b) -> Nat) ->
Maybe Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cpeak_eldc r p s cp cl_1 sl cl_2 cr_1 sr cr_2 lab n =
  let {
    ((s1, (r1, (_, (_, (True, t1))))), (_, (r2, (_, (_, (True, t2)))))) = p;
  } in bindb (check (cpeak_instance s cp s1 (t1, t2))
               (shows_prec_list zero_nat
                 [' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'e',
                   'a', 'k', 's', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'm',
                   'a', 't', 'c', 'h', ' ']))
         (\ _ ->
           let {
             u_1 = eseq_last (fst cp) cl_1;
             v_1 = eseq_last (snd cp) cr_1;
             u_2 = rseq_last u_1 sl;
             v_2 = rseq_last v_1 sr;
             u_3 = eseq_last u_2 cl_2;
             v_3 = eseq_last v_2 cr_2;
           } in bindb (check_conversion r cl_1 (fst cp) u_1)
                  (\ _ ->
                    bindb (check_rstepsa r sl u_1 u_2)
                      (\ _ ->
                        bindb (check_conversion r cl_2 u_2 u_3)
                          (\ _ ->
                            bindb (check_conversion r cr_1 (snd cp) v_1)
                              (\ _ ->
                                bindb (check_rstepsa r sr v_1 v_2)
                                  (\ _ ->
                                    bindb (check_conversion r cr_2 v_2 v_3)
                                      (\ _ ->
bindb (check (equal_term u_3 v_3)
        (shows_prec_list zero_nat
           ['t', 'h', 'e', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o',
             'n', 's', ' ', 'e', 'n', 'd', ' ', 'i', 'n', ' ', 'd', 'i', 'f',
             'f', 'e', 'r', 'e', 'n', 't', ' ', 't', 'e', 'r', 'm', 's', ' '] .
          shows_prec_term zero_nat u_3 .
            shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
              shows_prec_term zero_nat v_3))
  (\ _ ->
    let {
      alpha = lab r1;
      beta = lab r2;
      cl_1a = snd (eseq_to_ddconv (fst cp, cl_1));
      sla = snd (rseq_to_ddseq (u_1, sl));
      cl_2a = snd (eseq_to_ddconv (u_2, cl_2));
      cr_1a = snd (eseq_to_ddconv (snd cp, cr_1));
      sra = snd (rseq_to_ddseq (v_1, sr));
      cr_2a = snd (eseq_to_ddconv (v_2, cr_2));
      tau_1 = map (rule_labeling lab) cl_1a;
      tau_2 = map (rule_labeling lab) sla;
      tau_3 = map (rule_labeling lab) cl_2a;
      sigma_1 = map (rule_labeling lab) cr_1a;
      sigma_2 = map (rule_labeling lab) sra;
      sigma_3 = map (rule_labeling lab) cr_2a;
    } in bindb (check_ELD_1_nat alpha beta tau_1 tau_2 tau_3)
           (\ _ ->
             bindb (check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3)
               (\ _ ->
                 (case n of {
                   Nothing -> Inr ();
                   Just na ->
                     let {
                       check_reachable =
                         (\ t ->
                           check (membera (reachable_terms r s na) t)
                             (shows_prec_list zero_nat
                                ['t', 'e', 'r', 'm', ' '] .
                               shows_prec_term zero_nat t .
                                 shows_prec_list zero_nat
                                   [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's',
                                     ' ', 'f', 'a', 'n']));
                     } in bindb (catch_errora
                                  (forallM check_reachable
                                    (map get_source cl_1a))
                                  (\ x -> Inl (snd x)))
                            (\ _ ->
                              bindb (catch_errora
                                      (forallM check_reachable
(map get_source sla))
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  bindb (catch_errora
  (forallM check_reachable (map get_source cl_2a)) (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora (forallM check_reachable (map get_source cr_1a))
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (catch_errora (forallM check_reachable (map get_source sra))
          (\ x -> Inl (snd x)))
    (\ _ ->
      catch_errora (forallM check_reachable (map get_source cr_2a))
        (\ x -> Inl (snd x)))))));
                 })))))))))));

check_rule_labeling_eldc ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]), Nat)] ->
                      [(Term a [Prelude.Char],
                         (Term a [Prelude.Char],
                           ([(Pos, ((Term a [Prelude.Char],
                                      Term a [Prelude.Char]),
                                     (Bool, Term a [Prelude.Char])))],
                             ([(Pos, ((Term a [Prelude.Char],
Term a [Prelude.Char]),
                                       Term a [Prelude.Char]))],
                               ([(Pos, ((Term a [Prelude.Char],
  Term a [Prelude.Char]),
 (Bool, Term a [Prelude.Char])))],
                                 (Term a [Prelude.Char],
                                   ([(Pos, ((Term a [Prelude.Char],
      Term a [Prelude.Char]),
     (Bool, Term a [Prelude.Char])))],
                                     ([(Pos,
 ((Term a [Prelude.Char], Term a [Prelude.Char]), Term a [Prelude.Char]))],
                                       [(Pos,
  ((Term a [Prelude.Char], Term a [Prelude.Char]),
    (Bool, Term a [Prelude.Char])))]))))))))] ->
                        Maybe Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_labeling_eldc r lab cs n =
  let {
    cps = critical_peaks_impl r r;
    l = rule_lab_repr_to_lab lab;
    convs =
      cs ++ map (\ (s, (u, (cl_1, (sl, (cl_2, (v, (cr_1, (sr, cr_2)))))))) ->
                  (s, (v, (cr_1, (sr, (cr_2, (u, (cl_1, (sl, cl_2)))))))))
              cs;
  } in catch_errora
         (forallM
           (\ (_, a) ->
             let {
               (aa, b) = a;
             } in let {
                    (s1, (r1, (p1, (sigma_1, (_, t1))))) = aa;
                  } in (\ (s2, (r2, (p2, (sigma_2, (true, t2))))) ->
                         catch_errora
                           (check (equal_term t1 t2)
                             (shows_prec_list zero_nat
                               [' ', 'p', 'a', 'i', 'r', ' ', 'n', 'o', 'n',
                                 '-', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ']))
                           (\ _ ->
                             catch_errora
                               (existsM
                                 (\ (s, (u,
  (cl_1, (sl, (cl_2, (v, (cr_1, (sr, cr_2))))))))
                                   -> check_cpeak_eldc r
((s1, (r1, (p1, (sigma_1, (true, t1))))),
  (s2, (r2, (p2, (sigma_2, (true, t2))))))
s (u, v) cl_1 sl cl_2 cr_1 sr cr_2 l n)
                                 convs)
                               (\ _ ->
                                 Inl (shows_rule (shows_prec zero_nat)
(shows_prec_list zero_nat) [' ', '-', '>', ' '] (t1, t2) .
                                       shows_prec_list zero_nat
 [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'j',
   'o', 'i', 'n', 'e', 'd', ' ', 'd', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n',
   'g', 'l', 'y', ' ']))))
                    b)
           cps)
         (\ x -> Inl (snd x));

split_seq :: Nat -> Nat -> [Nat] -> ([Nat], ([Nat], [Nat]));
split_seq alpha beta ss =
  let {
    (ssa, r) = span (\ n -> less_nat n alpha) ss;
  } in (case r of {
         [] -> (ssa, ([], []));
         h : t ->
           (if less_eq_nat h beta then (ssa, ([h], t)) else (ssa, ([], r)));
       });

check_cpeak_eld ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b,
                       ((Term a b, Term a b),
                         (Pos, (b -> Term a b, (Bool, Term a b))))),
                      (Term a b,
                        ((Term a b, Term a b),
                          (Pos, (b -> Term a b, (Bool, Term a b)))))) ->
                      (Term a b, Term a b) ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          [(Pos, ((Term a b, Term a b), Term a b))] ->
                            ((Term a b, Term a b) -> Nat) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cpeak_eld r p cp j1 j2 lab =
  let {
    ((_, (r1, (_, (_, (True, t1))))), (_, (r2, (_, (_, (True, t2)))))) = p;
  } in bindb (check (instance_rule (t1, t2) cp)
               (shows_prec_list zero_nat
                 [' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'e',
                   'a', 'k', ' ', 'a', 'n', 'd', ' ', 'p', 'a', 'i', 'r', ' ',
                   'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h',
                   ' ']))
         (\ _ ->
           let {
             u = rseq_last (fst cp) j1;
             v = rseq_last (snd cp) j2;
           } in bindb (check_rstepsa r j1 (fst cp) u)
                  (\ _ ->
                    bindb (check_rstepsa r j2 (snd cp) v)
                      (\ _ ->
                        bindb (check (equal_term u v)
                                (shows_prec_list zero_nat
                                   ['t', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i',
                                     't', 'e', ' ', 's', 'e', 'q', 'u', 'e',
                                     'n', 'c', 'e', 's', ' ', 'e', 'n', 'd',
                                     ' ', 'i', 'n', ' ', 'd', 'i', 'f', 'f',
                                     'e', 'r', 'e', 'n', 't', ' ', 't', 'e',
                                     'r', 'm', 's', ' '] .
                                  shows_prec_term zero_nat u .
                                    shows_prec_list zero_nat
                                      [' ', 'a', 'n', 'd', ' '] .
                                      shows_prec_term zero_nat v))
                          (\ _ ->
                            let {
                              alpha = lab r1;
                              beta = lab r2;
                              tau = map (rule_labeling lab)
                                      (snd (rseq_to_ddseq (t1, j1)));
                              sigma =
                                map (rule_labeling lab)
                                  (snd (rseq_to_ddseq (t2, j2)));
                              (tau_1, (tau_2, tau_3)) =
                                split_seq alpha beta tau;
                              (sigma_1, (sigma_2, sigma_3)) =
                                split_seq beta alpha sigma;
                            } in bindb (check_ELD_1_nat alpha beta tau_1 tau_2
 tau_3)
                                   (\ _ ->
                                     check_ELD_1_nat beta alpha sigma_1 sigma_2
                                       sigma_3)))));

check_rule_labeling_eld ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]), Nat)] ->
                      [(Term a [Prelude.Char],
                         ([(Pos, ((Term a [Prelude.Char],
                                    Term a [Prelude.Char]),
                                   Term a [Prelude.Char]))],
                           (Term a [Prelude.Char],
                             [(Pos, ((Term a [Prelude.Char],
                                       Term a [Prelude.Char]),
                                      Term a [Prelude.Char]))])))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_labeling_eld r lab js =
  let {
    cps = critical_peaks_impl r r;
    l = rule_lab_repr_to_lab lab;
    joins = js ++ map (\ (u, (j1, (v, j2))) -> (v, (j2, (u, j1)))) js;
  } in catch_errora
         (forallM
           (\ (_, a) ->
             let {
               (aa, b) = a;
             } in let {
                    (s1, (r1, (p1, (sigma_1, (_, t1))))) = aa;
                  } in (\ (s2, (r2, (p2, (sigma_2, (true, t2))))) ->
                         catch_errora
                           (check (equal_term t1 t2)
                             (shows_prec_list zero_nat
                               [' ', 'p', 'a', 'i', 'r', ' ', 'n', 'o', 'n',
                                 '-', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ']))
                           (\ _ ->
                             catch_errora
                               (existsM
                                 (\ (u, (j1, (v, j2))) ->
                                   check_cpeak_eld r
                                     ((s1, (r1, (p1, (sigma_1, (true, t1))))),
                                       (s2, (r2, (p2, (sigma_2, (true, t2))))))
                                     (u, v) j1 j2 l)
                                 joins)
                               (\ _ ->
                                 Inl (shows_rule (shows_prec zero_nat)
(shows_prec_list zero_nat) [' ', '-', '>', ' '] (t1, t2) .
                                       shows_prec_list zero_nat
 [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'j',
   'o', 'i', 'n', 'e', 'd', ' ', 'd', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n',
   'g', 'l', 'y', ' ']))))
                    b)
           cps)
         (\ x -> Inl (snd x));

check_estepa ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Pos ->
                      (Term a b, Term a b) ->
                        Bool ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_estepa e p rule l_to_r s t =
  bindb (check (any (eq_rule_mod_vars rule) e)
          (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] rule .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'e', 'q',
                'u', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f'] .
              shows_nl .
                shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                  ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 's',
                    'y', 's', 't', 'e', 'm', ':']
                  [' ', '=', ' '] e .
                  shows_nl))
    (\ _ ->
      bindb (check (in_poss p s)
              (shows_prec_pos zero_nat p .
                shows_string
                  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
                    's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                  shows_prec_term zero_nat s . shows_nl))
        (\ _ ->
          bindb (check (in_poss p t)
                  (shows_prec_pos zero_nat p .
                    shows_string
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p',
                        'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                      shows_prec_term zero_nat t . shows_nl))
            (\ _ ->
              let {
                c = ctxt_of_pos_term p s;
                d = ctxt_of_pos_term p t;
                u = subt_at s p;
                v = subt_at t p;
                rrule = (if l_to_r then rule else (snd rule, fst rule));
                err = shows_string
                        ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                        shows_prec_term zero_nat t .
                          shows_string
                            [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                              'r', 'e', 's', 'u', 'l', 't', ' ', 'f', 'r', 'o',
                              'm', ' ', 'a', ' ', 'p', 'r', 'o', 'p', 'e', 'r',
                              ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                              'o', 'n', ' ', 'o', 'f', ' ', 't', 'e', 'r', 'm',
                              ' '] .
                            shows_prec_term zero_nat s .
                              shows_string
                                [' ', 'u', 's', 'i', 'n', 'g', ' ', 'e', 'q',
                                  'u', 'a', 't', 'i', 'o', 'n', ' '] .
                                shows_nl .
                                  shows_rule (shows_prec zero_nat)
                                    (shows_prec zero_nat) [' ', '=', ' ']
                                    rrule .
                                    shows_string
                                      [' ', 'a', 't', ' ', 'p', 'o', 's', 'i',
't', 'i', 'o', 'n', ' '] .
                                      shows_prec_pos zero_nat p . shows_nl;
              } in (case match_list Var [(fst rrule, u), (snd rrule, v)] of {
                     Nothing -> Inl err;
                     Just _ -> check (equal_ctxt c d) err;
                   }))));

check_conversiona ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conversiona e [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's',
         'i', 'o', 'n', ' '] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term zero_nat u . shows_nl);
check_conversiona e ((p, (r, (l_to_r, t))) : c) s u =
  bindb (check_estepa e p r l_to_r s t) (\ _ -> check_conversiona e c t u);

check_redundant_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Nat ->
                        [[(Pos, ((Term a b, Term a b), (Bool, Term a b)))]] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_redundant_rules ra r n convs =
  let {
    s = list_diff r ra;
    t = list_diff ra r;
  } in bindb (catch_errora
               (forallM
                 (\ (l, rb) ->
                   check (membera (reachable_terms ra l n) rb)
                     (shows_prec_list zero_nat
                        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 's',
                          'i', 'm', 'u', 'l', 'a', 't', 'e', ' ', 'r', 'u', 'l',
                          'e', ' '] .
                       shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                         [' ', '-', '>', ' '] (l, rb)))
                 s)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ (l, raa) ->
                 catch_errora
                   (existsM (\ conv -> check_conversiona r conv l raa) convs)
                   (\ _ -> check_join_BFS_limit n r l raa))
               t)
             (\ x -> Inl (snd x)));

check_cr_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            Cr_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cr_proof a ia i j r (SN_WCR joins_i prf) =
  debug (ia []) ['S', 'N', '_', 'W', 'C', 'R']
    (let {
       tp = mkc i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a
                    (ia . shows_string ['.', '1']) tp prf)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 's', 't', 'r', 'o',
                                  'n', 'g', ' ', 'n', 'o', 'r', 'm', 'a', 'l',
                                  'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', '+',
                                  ' ', 'w', 'c', 'r'] .
                                shows_nl . indent x)))
            (\ _ ->
              catch_errora
                (check_critical_pairs r (critical_pairs_impl r r) joins_i)
                (\ x ->
                  Inl (ia . shows_prec_list zero_nat
                              ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                                ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ',
                                'l', 'o', 'c', 'a', 'l', ' ', 'c', 'o', 'n',
                                'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'o',
                                'f', ' '] .
                              shows_tp (shows_prec_lab zero_nat)
                                (shows_prec_list zero_nat) i tp .
                                shows_nl . indent x))));
check_cr_proof a ia i j r Weakly_Orthogonal =
  debug (ia [])
    ['W', 'e', 'a', 'k', 'l', 'y', ' ', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
      'a', 'l']
    (catch_errora (check_weakly_orthogonal r)
      (\ x ->
        Inl (ia . shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                      'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'w', 'e', 'a',
                      'k', 'l', 'y', ' ', 'o', 'r', 't', 'h', 'o', 'g', 'o',
                      'n', 'a', 'l', ' ', 's', 'y', 's', 't', 'e', 'm', ' ',
                      'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'T', 'R', 'S'] .
                    shows_nl .
                      shows_trs (shows_prec_lab zero_nat)
                        (shows_prec_list zero_nat)
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                          't', 'e', 'm', ':']
                        [' ', '-', '>', ' '] r .
                        indent x)));
check_cr_proof a ia i j r (Strongly_Closed n) =
  debug (ia [])
    ['S', 't', 'r', 'o', 'n', 'g', 'l', 'y', ' ', 'C', 'l', 'o', 's', 'e', 'd']
    (catch_errora (check_strongly_closed r n)
      (\ x ->
        Inl (ia . shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                      'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 's', 't', 'r',
                      'o', 'n', 'g', ' ', 'c', 'l', 'o', 's', 'e', 'd', 'n',
                      'e', 's', 's', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e',
                      ' ', 'T', 'R', 'S'] .
                    shows_nl .
                      shows_trs (shows_prec_lab zero_nat)
                        (shows_prec_list zero_nat)
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                          't', 'e', 'm', ':']
                        [' ', '-', '>', ' '] r .
                        indent x)));
check_cr_proof a ia i j r (Rule_Labeling rl joins prf) =
  debug (ia [])
    ['R', 'u', 'l', 'e', ' ', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
    (bindb
      (case prf of {
        Nothing -> check_linear_trs r;
        Just prfa ->
          bindb (check_left_linear_trs r)
            (\ _ ->
              let {
                (rnd, rd) = partition (\ lr -> linear_term (snd lr)) r;
                tp = mkc i False [] rd rnd;
              } in catch_errora
                     (check_trs_termination_proof i j a
                       (ia . shows_string ['.', '1']) tp prfa)
                     (\ x ->
                       Inl (ia . shows_string
                                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                     'e', 'l', 'o', 'w', ' ', 'r', 'e', 'l',
                                     'a', 't', 'i', 'v', 'e', ' ', 't', 'e',
                                     'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                                     'n', ' ', 'f', 'o', 'r', ' ', 'r', 'u',
                                     'l', 'e', ' ', 'l', 'a', 'b', 'e', 'l',
                                     'i', 'n', 'g'] .
                                   shows_nl . indent x)));
      })
      (\ _ ->
        catch_errora (check_rule_labeling_eld r rl joins)
          (\ x ->
            Inl (ia . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                          'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'd', 'e',
                          'c', 'r', 'e', 'a', 's', 'i', 'n', 'g', 'n', 'e', 's',
                          's', ' ', 'o', 'f', ' ', 'C', 'P', 's', ' ', 'u', 's',
                          'i', 'n', 'g', ' ', 'r', 'u', 'l', 'e', ' ', 'l', 'a',
                          'b', 'e', 'l', 'i', 'n', 'g', ' ', 'f', 'o', 'r', ' ',
                          't', 'h', 'e', ' ', 'T', 'R', 'S'] .
                        shows_nl .
                          shows_trs (shows_prec_lab zero_nat)
                            (shows_prec_list zero_nat)
                            ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                              's', 't', 'e', 'm', ':']
                            [' ', '-', '>', ' '] r .
                            indent x))));
check_cr_proof a ia i j r (Rule_Labeling_Conv rl convs nprf) =
  debug (ia [])
    ['R', 'u', 'l', 'e', ' ', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
    (case nprf of {
      Nothing ->
        bindb (check_linear_trs r)
          (\ _ ->
            catch_errora (check_rule_labeling_eldc r rl convs Nothing)
              (\ x ->
                Inl (ia . shows_prec_list zero_nat
                            [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n',
                              ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ',
                              'd', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n', 'g',
                              'n', 'e', 's', 's', ' ', 'o', 'f', ' ', 'C', 'P',
                              's', ' ', 'u', 's', 'i', 'n', 'g', ' ', 'r', 'u',
                              'l', 'e', ' ', 'l', 'a', 'b', 'e', 'l', 'i', 'n',
                              'g', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ',
                              'T', 'R', 'S'] .
                            shows_nl .
                              shows_trs (shows_prec_lab zero_nat)
                                (shows_prec_list zero_nat)
                                ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                  'y', 's', 't', 'e', 'm', ':']
                                [' ', '-', '>', ' '] r .
                                indent x)));
      Just (n, prf) ->
        bindb (check_left_linear_trs r)
          (\ _ ->
            let {
              (rnd, rd) = partition (\ lr -> linear_term (snd lr)) r;
              tp = mkc i False [] rd rnd;
            } in bindb (catch_errora
                         (check_trs_termination_proof i j a
                           (ia . shows_string ['.', '1']) tp prf)
                         (\ x ->
                           Inl (ia . shows_string
                                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ',
 'b', 'e', 'l', 'o', 'w', ' ', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 't',
 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'r',
 'u', 'l', 'e', ' ', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g'] .
                                       shows_nl . indent x)))
                   (\ _ ->
                     catch_errora (check_rule_labeling_eldc r rl convs (Just n))
                       (\ x ->
                         Inl (ia . shows_prec_list zero_nat
                                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ',
                                       'i', 'n', ' ', 'c', 'h', 'e', 'c', 'k',
                                       'i', 'n', 'g', ' ', 'd', 'e', 'c', 'r',
                                       'e', 'a', 's', 'i', 'n', 'g', 'n', 'e',
                                       's', 's', ' ', 'o', 'f', ' ', 'C', 'P',
                                       's', ' ', 'u', 's', 'i', 'n', 'g', ' ',
                                       'r', 'u', 'l', 'e', ' ', 'l', 'a', 'b',
                                       'e', 'l', 'i', 'n', 'g', ' ', 'f', 'o',
                                       'r', ' ', 't', 'h', 'e', ' ', 'T', 'R',
                                       'S'] .
                                     shows_nl .
                                       shows_trs (shows_prec_lab zero_nat)
 (shows_prec_list zero_nat)
 ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't', 'e', 'm', ':']
 [' ', '-', '>', ' '] r .
 indent x))));
    });
check_cr_proof a ia i j r (Redundant_Rules rs n convs prf) =
  debug (ia [])
    ['R', 'e', 'd', 'u', 'n', 'd', 'a', 'n', 't', ' ', 'R', 'u', 'l', 'e', 's']
    (bindb
      (catch_errora (check_cr_proof a (ia . shows_string ['.', '1']) i j rs prf)
        (\ x ->
          Inl (ia . shows_prec_list zero_nat
                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                        'o', 'w', ' ', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n',
                        'c', 'e', ' ', 'o', 'f', ' ', 'm', 'o', 'd', 'i', 'f',
                        'i', 'e', 'd', ' ', 'T', 'R', 'S'] .
                      shows_nl .
                        shows_trs (shows_prec_lab zero_nat)
                          (shows_prec_list zero_nat)
                          ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                            's', 't', 'e', 'm', ':']
                          [' ', '-', '>', ' '] rs .
                          indent x)))
      (\ _ ->
        catch_errora (check_redundant_rules r rs n convs)
          (\ x ->
            Inl (ia . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                          'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'r', 'e',
                          'd', 'u', 'n', 'd', 'a', 'n', 't', ' ', 'r', 'u', 'l',
                          'e', 's', ' ', 't', 'r', 'a', 'n', 's', 'f', 'o', 'r',
                          'm', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 't',
                          'h', 'e', ' ', 'T', 'R', 'S'] .
                        shows_nl .
                          shows_trs (shows_prec_lab zero_nat)
                            (shows_prec_list zero_nat)
                            ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                              's', 't', 'e', 'm', ':']
                            [' ', '-', '>', ' '] r .
                            shows_prec_list zero_nat
                              ['t', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'e',
                                'd', ' ', 't', 'o'] .
                              shows_nl .
                                shows_trs (shows_prec_lab zero_nat)
                                  (shows_prec_list zero_nat)
                                  ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                    'y', 's', 't', 'e', 'm', ':']
                                  [' ', '-', '>', ' '] rs .
                                  indent x))));
check_cr_proof a ia i j r (Parallel_Closed n) =
  debug (ia [])
    ['P', 'a', 'r', 'a', 'l', 'l', 'e', 'l', ' ', 'C', 'l', 'o', 's', 'e', 'd']
    (catch_errora (check_parallel_closed r n)
      (\ x ->
        Inl (ia . shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                      'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'p', 'a', 'r',
                      'a', 'l', 'l', 'e', 'l', ' ', 'c', 'l', 'o', 's', 'e',
                      'd', 'n', 'e', 's', 's', ' ', 'f', 'o', 'r', ' ', 't',
                      'h', 'e', ' ', 'T', 'R', 'S'] .
                    shows_nl .
                      shows_trs (shows_prec_lab zero_nat)
                        (shows_prec_list zero_nat)
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                          't', 'e', 'm', ':']
                        [' ', '-', '>', ' '] r .
                        indent x)));

dlist_iteratei :: forall a b. Dlist a -> (b -> Bool) -> (a -> b -> b) -> b -> b;
dlist_iteratei xs = foldli (list_of_dlist xs);

pos_gctxt :: forall a b. (Compare a, Eq a, Compare b) => Gctxt a b -> Set Pos;
pos_gctxt GCHole = inserta Empty (set_empty (of_phantom set_impl_pos));
pos_gctxt (GCFun f cs) =
  sup_set (inserta Empty (set_empty (of_phantom set_impl_pos)))
    (sup_seta
      (image (\ (c, i) -> image (PCons i) (pos_gctxt c))
        (set (zip cs (upt zero_nat (size_list cs))))));

unifiable :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Bool;
unifiable s t = not (is_none (merge s t));

check_dp_loop ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> Dp_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_loop i dpp (DP_loop_prf s prseq sigma c) =
  let {
    p = pairsb i dpp;
    r = rulese i dpp;
    nfs = nfsc i dpp;
    q = qc i dpp;
  } in (if equal_ctxt c Hole
         then bindb (check (not (null prseq))
                      (shows_prec_list zero_nat
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'e', 'q',
                          'u', 'e', 'n', 'c', 'e', ' ', 'm', 'u', 's', 't', ' ',
                          'b', 'e', ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't',
                          'y']))
                (\ _ ->
                  (if null q
                    then check_qsteps (\ _ -> True) nfs p r prseq s
                           (subst_apply_term s (mk_subst Var sigma))
                    else check_qsteps_subst (check_NF_iteration sigma q) nfs p r
                           prseq s (subst_apply_term s (mk_subst Var sigma))))
         else check_loop q nfs s (map (\ (x, (y, (_, z))) -> (x, (y, z))) prseq)
                sigma c r);

check_rel_seq ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                        Term a b ->
                          Term a b ->
                            Bool -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_seq r sa [] s u True =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_string
            (shows_nl
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm']) .
            shows_nl . shows_prec_term zero_nat u . shows_nl);
check_rel_seq r sa [] s u False =
  Inl (shows_prec_list zero_nat
        ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 's',
          't', 'r', 'i', 'c', 't', ' ', 's', 't', 'e', 'p', ' ', 'i', 'n', ' ',
          'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n',
          'c', 'e']);
check_rel_seq ra sa ((p, (r, (True, t))) : prts) s u b =
  bindb (check_qrstep (\ _ -> True) False ra p r s t)
    (\ _ -> check_rel_seq ra sa prts t u True);
check_rel_seq ra sa ((p, (r, (False, t))) : prts) s u b =
  bindb (check_qrstep (\ _ -> True) False sa p r s t)
    (\ _ -> check_rel_seq ra sa prts t u b);

pat_dv_impl ::
  forall a b.
    (Eq a, Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) -> [b];
pat_dv_impl p =
  let {
    (_, (sigma, mu)) = p;
  } in remdups (map fst (mk_subst_domain sigma ++ mk_subst_domain mu));

shows_exp ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_exp (f, c) =
  shows_prec zero_nat f .
    shows_prec_list zero_nat ['n', '+', ' '] . shows_prec zero_nat c;

shows_p ::
  forall a b c d e.
    (Showa a, Showa b, Showa c, Showa d,
      Showa e) => (a, ((b, (c, d)), e)) -> [Prelude.Char] -> [Prelude.Char];
shows_p (b, ((f, (c, m)), a)) =
  shows_prec zero_nat b .
    shows_prec zero_nat m .
      shows_prec_list zero_nat [' ', '^', ' ', '('] .
        shows_exp (f, c) .
          shows_prec_list zero_nat [')'] . shows_prec zero_nat a;

set_option :: forall a. (Ceq a, Ccompare a, Set_impl a) => Maybe a -> Set a;
set_option Nothing = bot_set;
set_option (Just x2) = inserta x2 bot_set;

enfc_cand ::
  forall a b.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  b -> ([Term a [Prelude.Char]], Term a [Prelude.Char]) ->
                         [([Term a [Prelude.Char]], Term a [Prelude.Char])];
enfc_cand isQnf r q (uu, Var uv) = [];
enfc_cand isQnf r q (s, Fun f ts) =
  map (\ a -> (s, a)) ts ++
    concatMap
      (\ (l, ra) ->
        (if (case mgu_class (Fun f (map (icap_impl isQnf r s) ts)) l of {
              Nothing -> False;
              Just mu ->
                all (\ u ->
                      isQnf (subst_apply_term
                              (map_term (\ x -> x) (\ a -> 'y' : a) u) mu))
                  (args l) &&
                  all (\ u ->
                        isQnf (subst_apply_term
                                (map_term (\ x -> x) (\ a -> 'x' : a) u) mu))
                    s;
            })
          then [(args l, ra)] else []))
      r;

enfc_impl ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                (Term a [Prelude.Char] -> Bool) ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [Term a [Prelude.Char]] ->
                      [Term a [Prelude.Char]] -> Term a [Prelude.Char] -> Bool;
enfc_impl isQnf isRnf r q s t =
  all (\ (a, b) -> enfc_q isQnf isRnf r q a b)
    (mk_rtrancl_list (\ a b -> a == b) (enfc_cand isQnf r q) [(s, t)]);

check_nfc ::
  forall a.
    (Eq a, Key a,
      Showa a) => Bool ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      [Term a [Prelude.Char]] ->
                        (Term a [Prelude.Char] -> Bool) ->
                          [Term a [Prelude.Char]] ->
                            Bool ->
                              Term a [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_nfc inn r q isQnf ss nfs t =
  bindb (check_wf_trs r)
    (\ _ ->
      (if inn then Inr ()
        else catch_errora
               (forallM
                 (\ ta ->
                   check (enfc_impl isQnf (is_NF_trs r) r q ss ta)
                     (shows_prec_list zero_nat
                        [' ', 'n', 'f', 'c', ' ', 'n', 'o', 't', ' ', 's', 'a',
                          't', 'i', 's', 'f', 'i', 'e', 'd', ' ', 'f', 'o', 'r',
                          ' '] .
                       shows_prec_term zero_nat ta))
                 (supteq_list t))
               (\ x -> Inl (snd x))));

intersect_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
intersect_values key vs m = foldr (aux key m) vs empty;

intersect_rules ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 Rbt (a, Nat) [(Bool, (Term a b, Term a b))] ->
                   Rbt (a, Nat) [(Bool, (Term a b, Term a b))];
intersect_rules rs =
  intersect_values key
    (map (\ a -> (True, a)) rs ++ map (\ a -> (False, a)) rs);

coherent_rule ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b,
      Eq b) => Set (a, a) ->
                 Set (Ta_rule a b) -> Ta_rule a b -> Set (a, Maybe a);
coherent_rule rel rules (TA_rule f qs q) =
  foldr (sup_set .
          (\ i ->
            let {
              qi = nth qs i;
              qi_s = image snd (filtera (\ qq -> fst qq == qi) rel);
              a = sup_seta
                    (image
                      (\ qia ->
                        let {
                          qsa = list_update qs i qia;
                          rls = filtera
                                  (\ (TA_rule g qsaa _) ->
                                    g == f && qsaa == qsa)
                                  rules;
                        } in (if less_eq_set rls
                                   (set_empty (of_phantom set_impl_ta_rule))
                               then inserta Nothing bot_set
                               else image (Just . r_rhs) rls))
                      qi_s);
            } in image (\ aa -> (q, aa)) a))
    (upt zero_nat (size_list qs)) bot_set;

new_states ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set (a, a) -> Set (a, Maybe a);
new_states ta rel = let {
                      rules = ta_rules ta;
                    } in sup_seta (image (coherent_rule rel rules) rules);

check_wf_reltrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ([(Term a b, Term a b)], [(Term a b, Term a b)]) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_reltrs (r, s) =
  bindb (check_wf_trs r)
    (\ _ -> (if null r then Inr () else check_varcond_subset s));

create_ctxts :: forall a b. [(Term a b, Term a b)] -> Maybe (Nat -> Ctxt a b);
create_ctxts r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      bind (mapMa (\ a -> (case a of {
                            (Var _, _) -> Nothing;
                            (Fun _ [], _) -> Nothing;
                            (Fun u (_ : ts), _) -> Just (More u [] Hole ts);
                          }))
             rr)
        (\ cs ->
          let {
            _ = size_list cs;
          } in Just (\ i ->
                      (if less_nat i (size_list cs) then nth cs i else Hole)));
  });

create_U ::
  forall a b.
    (Eq a,
      Eq b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                  [(Term a b, Term a b)])] ->
                 Maybe (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                         Nat -> Ctxt a b);
create_U c_rs =
  bind (mapMa
         (\ (cr, rs) ->
           bind (guarda (equal_nat (size_list rs) (suc (size_list (snd cr)))))
             (\ _ -> bind (create_ctxts rs) (\ ctxt -> Just (cr, ctxt))))
         c_rs)
    (\ cr_ctxts -> let {
                     m = map_of cr_ctxts;
                   } in Just (\ cr -> (case m cr of {
Nothing -> (\ _ -> Hole);
Just ctxt -> ctxt;
                                      })));

create_zs :: forall a b. [(Term a b, Term a b)] -> Maybe (Nat -> [b]);
create_zs r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      bind (mapMa (\ a -> (case a of {
                            (Var _, _) -> Nothing;
                            (Fun _ [], _) -> Nothing;
                            (Fun _ (_ : ts), _) -> Just (map the_Var ts);
                          }))
             rr)
        (\ cs ->
          Just (\ i -> (if less_nat i (size_list cs) then nth cs i else [])));
  });

create_Z ::
  forall a b.
    (Eq a,
      Eq b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                  [(Term a b, Term a b)])] ->
                 Maybe (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                         Nat -> [b]);
create_Z c_rs =
  bind (mapMa (\ (cr, rs) -> bind (create_zs rs) (\ zs -> Just (cr, zs))) c_rs)
    (\ cr_zs -> let {
                  mc = map_of cr_zs;
                } in Just (\ cr -> (case mc cr of {
                                     Nothing -> (\ _ -> []);
                                     Just zs -> zs;
                                   })));

xml_ctrs_input ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => [((Term (Lab a [b]) c, Term (Lab a [b]) c),
                     [(Term (Lab a [b]) c, Term (Lab a [b]) c)])] ->
                    Xml;
xml_ctrs_input ctrs =
  XML ['c', 't', 'r', 's', 'I', 'n', 'p', 'u', 't'] []
    [XML ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'u', 'l',
           'e', 's']
       [] (map xml_crule ctrs)];

starts_with :: [Prelude.Char] -> [Prelude.Char] -> Bool;
starts_with t s = take (size_list s) (trim t) == s;

check_redundant_rules_ncr ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_redundant_rules_ncr ra r n =
  bindb (catch_errora (check_subseteq ra r)
          (\ _ ->
            Inl (shows_prec_list zero_nat
                  ['o', 'l', 'd', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                    'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 's', 'y', 's', 't',
                    'e', 'm', ' ', 'o', 'f', ' ', 'g', 'i', 'v', 'e', 'n', ' ',
                    'T', 'R', 'S'])))
    (\ _ ->
      let {
        s = list_diff r ra;
        t = list_diff ra r;
      } in bindb (catch_errora
                   (forallM
                     (\ (l, rb) ->
                       check (membera (reachable_terms ra l n) rb)
                         (shows_prec_list zero_nat
                            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                              's', 'i', 'm', 'u', 'l', 'a', 't', 'e', ' ', 'r',
                              'u', 'l', 'e', ' '] .
                           shows_rule (shows_prec zero_nat)
                             (shows_prec zero_nat) [' ', '-', '>', ' ']
                             (l, rb)))
                     s)
                   (\ x -> Inl (snd x)))
             (\ _ ->
               catch_errora
                 (forallM
                   (\ (l, raa) ->
                     check (membera (reachable_terms r l n) raa)
                       (shows_prec_list zero_nat
                          ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                            's', 'i', 'm', 'u', 'l', 'a', 't', 'e', ' ', 'r',
                            'u', 'l', 'e', ' '] .
                         shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                           [' ', '-', '>', ' '] (l, raa)))
                   t)
                 (\ x -> Inl (snd x))));

check_modularity_ncr ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_modularity_ncr ra r =
  bindb (catch_errora (check_subseteq r ra)
          (\ _ ->
            Inl (shows_prec_list zero_nat
                  ['n', 'e', 'w', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                    'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 's', 'y', 's', 't',
                    'e', 'm', ' ', 'o', 'f', ' ', 'g', 'i', 'v', 'e', 'n', ' ',
                    'T', 'R', 'S'])))
    (\ _ ->
      let {
        s = list_diff ra r;
        f = funas_trs_list r;
        g = funas_trs_list s;
      } in bindb (check (less_eq_set (inf_set (set f) (set g)) bot_set)
                   (shows_prec_list zero_nat
                     ['s', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', 's', ' ',
                       'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'i', 's',
                       'j', 'o', 'i', 'n', 't']))
             (\ _ ->
               bindb (check_varcond_subset r)
                 (\ _ ->
                   catch_errora
                     (catch_errora
                       (forallM
                         (\ x ->
                           (if let {
                                 (l, _) = x;
                               } in not (is_Var l)
                             then Inr () else Inl x))
                         s)
                       (\ x -> Inl (snd x)))
                     (\ _ ->
                       Inl (shows_prec_list zero_nat
                             ['l', 'h', 's', 's', ' ', 'm', 'u', 's', 't', ' ',
                               'n', 'o', 't', ' ', 'b', 'e', ' ', 'v', 'a', 'r',
                               'i', 'a', 'b', 'l', 'e', 's'])))));

shows_gctxt ::
  forall a b. (Showa a) => Gctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_gctxt GCHole = shows_string ['_'];
shows_gctxt (GCFun f ts) =
  shows_prec zero_nat f .
    shows_list_gen id [] ['('] [',', ' '] [')'] (map shows_gctxt ts);

shows_prec_gctxt ::
  forall a b. (Showa a) => Nat -> Gctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_gctxt p c = shows_gctxt c;

gctxts_to_terms_intern ::
  forall a b. (Nat -> a) -> Nat -> [Gctxt b a] -> (Nat, [Term b a]);
gctxts_to_terms_intern iv i (GCFun f ts : cs) =
  let {
    (i1, res1) = gctxts_to_terms_intern iv i ts;
    (i2, res2) = gctxts_to_terms_intern iv i1 cs;
  } in (i2, Fun f res1 : res2);
gctxts_to_terms_intern iv i (GCHole : cs) =
  let {
    (ia, res) = gctxts_to_terms_intern iv (plus_nat i one_nat) cs;
  } in (ia, Var (iv i) : res);
gctxts_to_terms_intern iv i [] = (i, []);

gc_matcher ::
  forall a.
    (Eq a) => Gctxt a [Prelude.Char] ->
                Term a [Prelude.Char] ->
                  Maybe ([Prelude.Char] -> Term a [Prelude.Char]);
gc_matcher c l =
  map_option fst
    (mgu_var_disjoint_generic (\ a -> 'x' : a) (\ a -> 'y' : a) l
      (hda (snd (gctxts_to_terms_intern
                  (\ i -> 'x' : shows_prec_nat zero_nat i []) zero_nat [c]))));

check_contains_U0 ::
  forall a.
    (Compare a, Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Set (Term a [Prelude.Char], Term a [Prelude.Char]) ->
                      Term a [Prelude.Char] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_contains_U0 r u s =
  catch_errora
    (forallM
      (\ fts ->
        (case fts of {
          Var _ -> Inr ();
          Fun f ts ->
            let {
              tcapb = GCFun f (map (tcap u) ts);
            } in catch_errora
                   (forallM
                     (\ lr ->
                       (case gc_matcher tcapb (fst lr) of {
                         Nothing -> Inr ();
                         Just sigma ->
                           let {
                             irule =
                               (subst_apply_term (fst lr) sigma,
                                 subst_apply_term (snd lr) sigma);
                           } in check (in_rstep_impl (fst irule) (snd irule) u)
                                  (shows_prec_list zero_nat
                                     ['W', 'h', 'e', 'n', ' ', 'c', 'o', 'n',
                                       's', 'i', 'd', 'e', 'r', 'i', 'n', 'g',
                                       ' ', 't', 'h', 'e', ' ', 's', 'u', 'b',
                                       't', 'e', 'r', 'm', ' '] .
                                    shows_prec_term zero_nat fts .
                                      shows_nl .
shows_prec_list zero_nat
  ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] lr .
    shows_nl .
      shows_prec_list zero_nat
        ['t', 'h', 'e', ' ', 'c', 'a', 'p', 'p', 'e', 'd', ' ', 's', 'u', 'b',
          't', 'e', 'r', 'm', ' ', 'i', 's', ' '] .
        shows_prec_gctxt zero_nat tcapb .
          shows_nl .
            shows_prec_list zero_nat
              ['l', 'e', 'a', 'd', 'i', 'n', 'g', ' ', 't', 'o', ' ', 't', 'h',
                'e', ' ', 'm', 'g', 'u', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h',
                'e', ' ', 'l', 'h', 's', ':', ' '] .
              shows_prec_list zero_nat
                (map (\ x -> (x, sigma x)) (vars_term_list (fst lr))) .
                shows_nl .
                  shows_prec_list zero_nat
                    ['T', 'h', 'e', ' ', 'i', 'n', 's', 't', 'a', 'n', 't', 'i',
                      'a', 't', 'e', 'd', ' ', 'r', 'u', 'l', 'e', ' '] .
                    shows_prec_prod zero_nat irule .
                      shows_nl .
                        shows_prec_list zero_nat
                          ['c', 'a', 'n', 'n', 'o', 't', ' ', 'b', 'e', ' ',
                            's', 'i', 'm', 'u', 'l', 'a', 't', 'e', 'd', ' ',
                            'b', 'y', ' ', 't', 'h', 'e', ' ', 'g', 'i', 'v',
                            'e', 'n', ' ', 's', 'e', 't', ' ', 'o', 'f', ' ',
                            'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                            'e', 's']);
                       }))
                     r)
                   (\ x -> Inl (snd x));
        }))
      (supteq_list s))
    (\ x -> Inl (snd x));

check_usable_instantiation ::
  forall a.
    (Compare a, Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      Term a [Prelude.Char] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_usable_instantiation r u s =
  let {
    uu = set u;
  } in bindb (catch_errora (check_contains_U0 r uu s)
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['U', ' ', '<', '=', ' ', 'U', '0', '(', 'R', ',', 's',
                          ')', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'] .
                       shows_nl . x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ ra ->
                 catch_errora (check_contains_U0 r uu ra)
                   (\ x ->
                     Inl (shows_prec_list zero_nat
                            ['U', ' ', '<', '=', ' ', 'U', '0', '(', 'R', ',',
                              'r', ')', ' ', 'f', 'o', 'r', ' ', 'r', 'h', 's',
                              ' ', 'r', ' ', '=', ' '] .
                           shows_prec_term zero_nat ra .
                             shows_prec_list zero_nat
                               [' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'] .
                               shows_nl . x)))
               (map snd u))
             (\ x -> Inl (snd x)));

check_usable_rules_unif ::
  forall a.
    (Compare a, Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      Term a [Prelude.Char] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_usable_rules_unif r u s =
  catch_errora
    (bindb
      (check (ground s || all (\ l -> not (is_Var l)) (map fst r))
        (shows_string ['s', 'i', 'n', 'c', 'e', ' '] .
          shows_prec_term zero_nat s .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'g', 'r', 'o', 'u', 'n',
                'd', ',', ' ', 'l', 'e', 'f', 't', '-', 'h', 'a', 'n', 'd', ' ',
                's', 'i', 'd', 'e', 's', ' ', 'o', 'f', ' ', 'R', ' ', 'm', 'u',
                's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'v', 'a', 'r',
                'i', 'a', 'b', 'l', 'e', 's']))
      (\ _ ->
        bindb (check_varcond_subset u)
          (\ _ ->
            catch_errora (check_usable_instantiation r u s)
              (\ x ->
                Inl (shows_string
                       ['c', 'l', 'o', 's', 'u', 'r', 'e', ' ', 'p', 'r', 'o',
                         'p', 'e', 'r', 't', 'i', 'e', 's', ' ', 'o', 'f', ' ',
                         'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                         's', ' ', 'n', 'o', 't', ' ', 's', 'a', 't', 'i', 's',
                         'f', 'i', 'e', 'd'] .
                      shows_nl . x)))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'v', 'a', 'l', 'i', 'd', 'i',
               't', 'y', ' ', 'o', 'f', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
               'r', 'u', 'l', 'e', 's', ' ', 'U', ' ', '=', ' '] .
            shows_nl .
              shows_trs (shows_prec zero_nat) (shows_prec_list zero_nat)
                ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't',
                  'e', 'm', ':']
                [' ', '-', '>', ' '] u .
                shows_nl .
                  shows_prec_list zero_nat
                    ['f', 'o', 'r', ' ', 't', 'e', 'r', 'm', ' '] .
                    shows_prec_term zero_nat s .
                      shows_nl .
                        shows_string
                          ['w', 'r', 't', ' ', 'T', 'R', 'S', ' ', 'R', ' ',
                            '=', ' '] .
                          shows_nl .
                            shows_trs (shows_prec zero_nat)
                              (shows_prec_list zero_nat)
                              ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                                's', 't', 'e', 'm', ':']
                              [' ', '-', '>', ' '] r .
                              shows_nl . x));

sl_c :: forall a b c d e. Sl_ops_ext a b c d e -> b;
sl_c (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_c;

check_qmodel_rule_ass ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (a -> [b] -> b) ->
                    (b -> b -> Bool) ->
                      (c -> b) ->
                        (Term a c, Term a c) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel_rule_ass i cge alpha (l, r) =
  let {
    cl = eval i alpha l;
    cr = eval i alpha r;
  } in check (cge cl cr)
         (shows_string ['r', 'u', 'l', 'e', ' '] .
           shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] (l, r) .
             shows_string
               [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 't', 'h', 'e',
                 ' ', 'm', 'o', 'd', 'e', 'l', ' ', 'c', 'o', 'n', 'd', 'i',
                 't', 'i', 'o', 'n', ',', ' ', '[', 'l', 'h', 's', ']', ' ',
                 '=', ' '] .
               shows_prec zero_nat cl .
                 shows_string
                   [',', ' ', '[', 'r', 'h', 's', ']', ' ', '=', ' '] .
                   shows_prec zero_nat cr);

check_qmodel_rule ::
  forall a b c.
    (Showa a, Showa b, Eq c,
      Showa c) => (a -> [b] -> b) ->
                    [b] ->
                      (b -> b -> Bool) ->
                        (Term a c, Term a c) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel_rule i c cge lr =
  catch_errora
    (forallM (\ alpha -> check_qmodel_rule_ass i cge alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_qmodel ::
  forall a b c.
    (Showa a, Showa b, Eq c,
      Showa c) => (a -> [b] -> b) ->
                    [b] ->
                      (b -> b -> Bool) ->
                        [(Term a c, Term a c)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel i c cge r =
  catch_errora (forallM (check_qmodel_rule i c cge) r) (\ x -> Inl (snd x));

check_non_join_model ::
  forall a b c d.
    (Showa a, Showa b, Eq d,
      Showa d) => (a -> a -> Bool) ->
                    ([(b, Nat)] ->
                      [(b, Nat)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char])
                          (Sl_ops_ext b a c d ())) ->
                      [(Term b d, Term b d)] ->
                        [(Term b d, Term b d)] ->
                          Term b d ->
                            Term b d ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_model cge gen rs rt s t =
  catch_errora
    (bindb (gen (funas_trs_list (rs ++ rt)) [])
      (\ ops ->
        let {
          i = sl_I ops;
          e = eval i (\ _ -> sl_c ops);
          es = e s;
          et = e t;
        } in bindb (check (not (cge et es))
                     (shows_prec_list zero_nat
                        ['t', 'h', 'e', ' ', 'i', 'n', 'e', 'q', 'u', 'a', 'l',
                          'i', 't', 'y', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o',
                          't', ' ', 'h', 'o', 'l', 'd', ':', ' ', '['] .
                       shows_prec_term zero_nat t .
                         shows_prec_list zero_nat [']', ' ', '=', ' '] .
                           shows_prec zero_nat et .
                             shows_prec_list zero_nat [' ', '>', '=', ' '] .
                               shows_prec zero_nat es .
                                 shows_prec_list zero_nat [' ', '=', ' ', '['] .
                                   shows_prec_term zero_nat s .
                                     shows_prec_list zero_nat [']']))
               (\ _ -> check_qmodel i (sl_C ops) cge (reverse_rules rs ++ rt))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'd', 'i',
               's', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-',
               'j', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'v',
               'i', 'a', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a',
               't', 'i', 'o', 'n', 's'] .
            shows_nl . x));

check_non_join_finite_model ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Sl_variant (Lab a [Nat]) b ->
                    [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                      [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                        Term (Lab a [Nat]) b ->
                          Term (Lab a [Nat]) b ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_finite_model (Rootlab x) rs rt s t =
  check_non_join_model equal_lab (slm_gen_to_sl_gen (rl_slm x)) rs rt s t;
check_non_join_finite_model (Finitelab sli) rs rt s t =
  check_non_join_model equal_nat
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli))) rs rt s t;
check_non_join_finite_model (QuasiFinitelab sli v) rs rt s t =
  check_non_join_model qmodel_cge (\ f g -> qsli_to_sl v f g sli) rs rt s t;

match_tcap_below_impl ::
  forall a b.
    (Eq a, Eq b) => Term a b -> [(Term a b, Term a b)] -> Term a b -> Bool;
match_tcap_below_impl l r (Fun f ts) = matchb (GCFun f (map (tcapI r) ts)) l;
match_tcap_below_impl l r (Var x) = False;

usable_rules_reach_U0_impl ::
  forall a b.
    (Eq a,
      Eq b) => [(Term a b, Term a b)] -> Term a b -> [(Term a b, Term a b)];
usable_rules_reach_U0_impl r t =
  inductive_set_impl r
    (\ ta (l, _) ->
      is_Var l ||
        any (\ u -> not (is_Var u) && match_tcap_below_impl l r u)
          (supteq_list ta))
    (\ lr -> [snd lr]) [t];

usable_rules_reach_impl ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       Term a b -> [(Term a b, Term a b)];
usable_rules_reach_impl r t =
  let {
    u0t = usable_rules_reach_U0_impl r t;
  } in (if all (\ (l, ra) -> less_eq_set (vars_term ra) (vars_term l)) u0t
         then u0t else r);

check_non_join_redpair ::
  forall a b.
    (Key a, Showa a,
      Showa b) => Redtriple_ext a b () ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        Term a b ->
                          Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_redpair rp rs rt sa t =
  catch_errora
    (bindb (valid rp)
      (\ _ ->
        bindb (catch_errora (forallM (ns rp) (reverse_rules rs ++ rt))
                (\ x -> Inl (snd x)))
          (\ _ -> s rp (sa, t))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'd', 'i',
               's', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-',
               'j', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'v',
               'i', 'a', ' ', 'd', 'i', 's', 'c', 'r', 'i', 'm', 'i', 'n', 'a',
               't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', 's'] .
            shows_nl . x));

show_ta ::
  forall a b.
    (Showa a,
      Showa b) => Tree_automaton a b -> [Prelude.Char] -> [Prelude.Char];
show_ta (Tree_Automaton fin rules eps) =
  (((((((shows_prec_list zero_nat ['f', 'i', 'n', 'a', 'l', ':', ' '] .
          shows_prec_list zero_nat fin) .
         shows_nl) .
        shows_prec_list zero_nat ['r', 'u', 'l', 'e', 's', ':', ' ']) .
       shows_lines rules) .
      shows_nl) .
     shows_prec_list zero_nat ['e', 'p', 's', 'i', 'l', 'o', 'n', ':', ' ']) .
    shows_prec_list zero_nat eps) .
    shows_nl;

shows_prec_tree_automaton ::
  forall a b.
    (Showa a,
      Showa b) => Nat -> Tree_automaton a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_tree_automaton d r = show_ta r;

g_filter_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => (a -> Bool) -> Rbt a () -> Rbt a ();
g_filter_dflt_basic_oops_rm_basic_ops p s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ _ -> True)
    (\ x sigma -> (if p x then ins_dj_rm_basic_ops x sigma else sigma))
    (empty_rm_basic_ops ());

image_rs_code ::
  forall a b. (Linorder a, Compare_order b) => Rbt a () -> (a -> b) -> Rbt b ();
image_rs_code s f =
  iteratei_set_op_list_it_rs_ops s (\ _ -> True) (\ x -> ins_rm_basic_ops (f x))
    (empty_rm_basic_ops ());

ta_idx_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> e;
ta_idx_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = idx;

list_eq :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
list_eq eq [] [] = True;
list_eq eq (aa : la) (a : l) = (if eq aa a then list_eq eq la l else False);
list_eq uu (v : va) [] = False;
list_eq uu [] (v : va) = False;

rule_filter_opt_code ::
  forall a b.
    (Compare_order a, Eq a,
      Compare_order b) => (Rbt a (),
                            (Rbt (Ta_rule a b) (),
                              (Dlist (a, a),
                                (Rbt a (),
                                  (Rbt (b, Nat) (Rbt ([a], a) ()),
                                    (Bool,
                                      (a -> Rbt a (), a -> Rbt a ()))))))) ->
                            b -> [a] -> Rbt a ();
rule_filter_opt_code =
  (\ x xa xb ->
    (case lookup (ta_idx_impl x) (xa, size_list xb) of {
      Nothing -> empty_rm_basic_ops ();
      Just xc ->
        image_rs_code
          (g_filter_dflt_basic_oops_rm_basic_ops
            (\ (xd, _) -> list_eq (\ a b -> a == b) xd xb) xc)
          snd;
    }));

g_sel_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> (a -> Bool) -> Maybe a;
g_sel_dflt_basic_oops_rm_basic_ops s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s is_none
    (\ x _ -> (if p x then Just x else Nothing)) Nothing;

ta_rhs_states_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> d;
ta_rhs_states_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = rhs;

update_all_code ::
  forall a b. (Compare_order a) => Rbt a b -> Rbt a () -> b -> Rbt a b;
update_all_code m s v =
  iteratei_set_op_list_it_rs_ops s (\ _ -> True) (\ x -> insert x v) m;

update_all2_code ::
  forall a b c.
    (Compare_order a,
      Compare_order b) => Rbt a (Rbt b c) ->
                            Rbt a () -> Rbt b () -> c -> Rbt a (Rbt b c);
update_all2_code m s1 s2 v =
  iteratei_set_op_list_it_rs_ops s1 (\ _ -> True)
    (\ x sigma -> let {
                    xa = update_all_code (case lookup sigma x of {
   Nothing -> empty;
   Just a -> id a;
 })
                           s2 v;
                  } in insert x xa sigma)
    m;

g_sng_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => a -> Rbt a ();
g_sng_dflt_basic_oops_rm_basic_ops x =
  ins_rm_basic_ops x (empty_rm_basic_ops ());

g_disjoint_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Bool;
g_disjoint_dflt_basic_oops_rm_basic_ops s1 s2 =
  g_ball_dflt_basic_oops_rm_basic_ops s1 (\ x -> not (memb_rm_basic_ops x s2));

ta_eps_cl_impl ::
  forall a b c d e f g h i. (a, (b, (c, (d, (e, (f, (g -> h, i))))))) -> g -> h;
ta_eps_cl_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) q = efcl q;

ta_match_var_ref_code ::
  forall a b c.
    (Compare_order a, Eq a, Compare b, Linorder b, Compare_order c,
      Eq c) => (Rbt a (),
                 (Rbt (Ta_rule a b) (),
                   (Dlist (a, a),
                     (Rbt a (),
                       (Rbt (b, Nat) (Rbt ([a], a) ()),
                         (Bool, (a -> Rbt a (), a -> Rbt a ()))))))) ->
                 Rbt a () -> c -> Rbt a () -> Rbt [(c, a)] ();
ta_match_var_ref_code ta qsig x q =
  iteratei_set_op_list_it_rs_ops qsig (\ _ -> True)
    (\ xa sigma ->
      (if not (g_disjoint_dflt_basic_oops_rm_basic_ops (ta_eps_cl_impl ta xa) q)
        then ins_rm_basic_ops [(x, xa)] sigma else sigma))
    (empty_rm_basic_ops ());

union_image_rs_code ::
  forall a b.
    (Linorder a, Compare_order b) => Rbt a () -> (a -> Rbt b ()) -> Rbt b ();
union_image_rs_code s f =
  iteratei_set_op_list_it_rs_ops s (\ _ -> True)
    (\ x -> g_union_dflt_basic_oops_rm_basic_ops (f x)) (empty_rm_basic_ops ());

set_App_code ::
  forall a. (Compare_order a, Eq a) => Rbt [a] () -> Rbt [a] () -> Rbt [a] ();
set_App_code x xs =
  iteratei_set_op_list_it_rs_ops x (\ _ -> True)
    (\ xa ->
      iteratei_set_op_list_it_rs_ops xs (\ _ -> True)
        (\ xaa -> ins_rm_basic_ops (xa ++ xaa)))
    (empty_rm_basic_ops ());

concat_listset_code ::
  forall a. (Compare_order a, Eq a) => [Rbt [a] ()] -> Rbt [a] ();
concat_listset_code =
  rec_list (ins_dj_rm_basic_ops [] (empty_rm_basic_ops ()))
    (\ x _ -> set_App_code x);

ta_match_fun_code ::
  forall a b c d.
    (Compare_order a, Eq a, Compare_order b, Compare_order c, Eq c,
      Compare_order d,
      Eq d) => (Rbt a (),
                 (Rbt (Ta_rule a b) (),
                   (Dlist (a, a),
                     (Rbt a (),
                       (Rbt (b, Nat) (Rbt ([a], a) ()),
                         (Bool, (a -> Rbt a (), a -> Rbt a ()))))))) ->
                 b -> Nat ->
                        Rbt a () ->
                          ([a] -> [Rbt [(c, d)] ()]) -> Rbt [(c, d)] ();
ta_match_fun_code =
  (\ x xa xb xc xd ->
    (case lookup (ta_idx_impl x) (xa, xb) of {
      Nothing -> empty_rm_basic_ops ();
      Just xe ->
        union_image_rs_code xe
          (\ (xf, xg) ->
            (if not (g_disjoint_dflt_basic_oops_rm_basic_ops
                      (ta_eps_cl_impl x xg) xc)
              then concat_listset_code (xd xf) else empty_rm_basic_ops ()));
    }));

map2 :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c];
map2 f [] ys = [];
map2 f (v : va) [] = [];
map2 f (x : xs) (y : ys) = f x y : map2 f xs ys;

ta_match_code ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => (Rbt a (),
                 (Rbt (Ta_rule a b) (),
                   (Dlist (a, a),
                     (Rbt a (),
                       (Rbt (b, Nat) (Rbt ([a], a) ()),
                         (Bool, (a -> Rbt a (), a -> Rbt a ()))))))) ->
                 Rbt a () -> Term b c -> Rbt a () -> Rbt [(c, a)] ();
ta_match_code ta qsig (Var x) q = ta_match_var_ref_code ta qsig x q;
ta_match_code ta qsig (Fun f ts) q =
  ta_match_fun_code ta f (size_list ts) q
    (map2 (\ t qa ->
            ta_match_code ta qsig t (g_sng_dflt_basic_oops_rm_basic_ops qa))
      ts);

ta_res_args_aux_code ::
  forall a b.
    (Compare_order a, Eq a,
      Compare_order b) => (Rbt a (),
                            (Rbt (Ta_rule a b) (),
                              (Dlist (a, a),
                                (Rbt a (),
                                  (Rbt (b, Nat) (Rbt ([a], a) ()),
                                    (Bool,
                                      (a -> Rbt a (), a -> Rbt a ()))))))) ->
                            b -> [Rbt a ()] -> Rbt a ();
ta_res_args_aux_code =
  (\ x xa xb ->
    (case lookup (ta_idx_impl x) (xa, size_list xb) of {
      Nothing -> empty_rm_basic_ops ();
      Just xc ->
        union_image_rs_code xc
          (\ (xd, xe) ->
            (if list_all2 memb_rm_basic_ops xd xb then ta_eps_cl_impl x xe
              else empty_rm_basic_ops ()));
    }));

ta_res_code ::
  forall a b.
    (Compare_order a, Eq a,
      Compare_order b) => (Rbt a (),
                            (Rbt (Ta_rule a b) (),
                              (Dlist (a, a),
                                (Rbt a (),
                                  (Rbt (b, Nat) (Rbt ([a], a) ()),
                                    (Bool,
                                      (a -> Rbt a (), a -> Rbt a ()))))))) ->
                            Term b a -> Rbt a ();
ta_res_code =
  (\ x xa ->
    rec_term (\ xb xc -> ta_eps_cl_impl xc xb)
      (\ xb xc xd -> let {
                       a = map (\ xe -> snd xe xd) xc;
                     } in ta_res_args_aux_code xd xb a)
      xa x);

is_compatible_code ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => (Rbt a (),
                 (Rbt (Ta_rule a b) (),
                   (Dlist (a, a),
                     (Rbt a (),
                       (Rbt (b, Nat) (Rbt ([a], a) ()),
                         (Bool, (a -> Rbt a (), a -> Rbt a ()))))))) ->
                 Rbt (Term b c, Term b c) () ->
                   Sum (a, (Term b a, Term b a))
                     (Rbt a (Rbt a (Term b a, Term b a)));
is_compatible_code ta r =
  iteratei_set_op_list_it_rs_ops r isOK
    (\ x sigma ->
      let {
        (a, b) = x;
        xa = ta_match_code ta (ta_rhs_states_impl ta) a (ta_rhs_states_impl ta);
      } in iteratei_set_op_list_it_rs_ops xa isOK
             (\ xb sigmaa ->
               let {
                 xc = map_term (\ xh -> xh) (fun_of xb) a;
                 xd = ta_res_code ta xc;
               } in (if g_isEmpty_dflt_basic_oops_rm_basic_ops xd then sigmaa
                      else let {
                             xe = map_term (\ xj -> xj) (fun_of xb) b;
                             xf = ta_res_code ta xe;
                           } in (if g_isEmpty_dflt_basic_oops_rm_basic_ops xf
                                  then let {
 xg = the (g_sel_dflt_basic_oops_rm_basic_ops xd (\ _ -> True));
                                       } in Inl (xg, (xc, xe))
                                  else let {
 aa = update_all2_code (projr sigmaa) xd xf (xc, xe);
                                       } in Inr aa)))
             sigma)
    (Inr empty);

iteratei_map_op_list_it_rm_ops ::
  forall a b c.
    (Linorder a) => Rbt a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
iteratei_map_op_list_it_rm_ops s = rm_iterateoi (impl_of s);

ta_rules_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> b;
ta_rules_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = r;

ta_final_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> a;
ta_final_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = f;

ta_idx_rhs_init_code ::
  forall a b.
    (Compare_order a, Eq a,
      Compare_order b) => Bool ->
                            Rbt (Ta_rule a b) () ->
                              (a -> Rbt a ()) ->
                                (Rbt (b, Nat) (Rbt ([a], a) ()),
                                  (Bool, Rbt a ()));
ta_idx_rhs_init_code det rs efcl =
  iteratei_set_op_list_it_rs_ops rs (\ _ -> True)
    (\ x (a, (aa, ba)) ->
      let {
        (TA_rule xg xh xi) = x;
        xj = size_list xh;
      } in (case lookup a (xg, xj) of {
             Nothing ->
               (insert (xg, xj)
                  (ins_dj_rm_basic_ops (xh, xi) (empty_rm_basic_ops ())) a,
                 (aa, g_union_dflt_basic_oops_rm_basic_ops (efcl xi) ba));
             Just xk ->
               (insert (xg, xj) (ins_rm_basic_ops (xh, xi) xk) a,
                 ((if aa
                    then g_ball_dflt_basic_oops_rm_basic_ops xk
                           (\ (xl, _) ->
                             not (list_eq (\ ab b -> ab == b) xh xl))
                    else False),
                   g_union_dflt_basic_oops_rm_basic_ops (efcl xi) ba));
           }))
    (empty, (det, empty_rm_basic_ops ()));

iteratei_bset_op_list_it_ls_basic_ops ::
  forall a b. Dlist a -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_bset_op_list_it_ls_basic_ops s = dlist_iteratei s;

g_isEmpty_ls_basic_ops :: forall a. Dlist a -> Bool;
g_isEmpty_ls_basic_ops s =
  iteratei_bset_op_list_it_ls_basic_ops s (\ c -> c) (\ _ _ -> False) True;

memo_rbt_rtrancl_opt ::
  forall a. (Compare_order a) => Dlist (a, a) -> a -> Rbt a ();
memo_rbt_rtrancl_opt e =
  (if g_isEmpty_ls_basic_ops e then g_sng_dflt_basic_oops_rm_basic_ops
    else memo_rbt_rtrancl (list_of_dlist e));

iteratei_set_op_list_it_ls_ops ::
  forall a b. Dlist a -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_set_op_list_it_ls_ops s = dlist_iteratei s;

image_ls_code :: forall a b. (Eq b) => Dlist a -> (a -> b) -> Dlist b;
image_ls_code s f =
  iteratei_set_op_list_it_ls_ops s (\ _ -> True) (\ x -> insertc (f x)) emptya;

ta_make_code ::
  forall a b c.
    (Linorder a, Compare_order b, Eq b,
      Compare_order c) => Rbt a () ->
                            Rbt (Ta_rule b c) () ->
                              Dlist (b, b) ->
                                (Rbt a (),
                                  (Rbt (Ta_rule b c) (),
                                    (Dlist (b, b),
                                      (Rbt b (),
(Rbt (c, Nat) (Rbt ([b], b) ()), (Bool, (b -> Rbt b (), b -> Rbt b ())))))));
ta_make_code f r e =
  let {
    x = memo_rbt_rtrancl_opt e;
    a = ta_idx_rhs_init_code (g_isEmpty_ls_basic_ops e) r x;
    (ab, (aa, ba)) = a;
  } in (f, (r, (e, (ba, (ab, (aa, (x, memo_rbt_rtrancl_opt
(image_ls_code e (\ xd -> (snd xd, fst xd))))))))));

ta_eps_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> c;
ta_eps_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = e;

g_filter_ls_basic_ops :: forall a. (Eq a) => (a -> Bool) -> Dlist a -> Dlist a;
g_filter_ls_basic_ops p s =
  iteratei_bset_op_list_it_ls_basic_ops s (\ _ -> True)
    (\ x sigma -> (if p x then insertc x sigma else sigma)) emptya;

is_None :: forall a. Maybe a -> Bool;
is_None a = (case a of {
              Nothing -> True;
              Just _ -> False;
            });

ta_only_res_wits_code ::
  forall a b c d.
    (Compare_order a, Eq a,
      Compare_order b) => (Rbt a (),
                            (Rbt (Ta_rule a b) (),
                              (Dlist (a, a),
                                (Rbt a (),
                                  (Rbt (b, Nat) (Rbt ([a], a) ()),
                                    (Bool,
                                      (a -> Rbt a (), a -> Rbt a ()))))))) ->
                            Rbt a (Term c d) ->
                              (Rbt a (),
                                (Rbt (Ta_rule a b) (),
                                  (Dlist (a, a),
                                    (Rbt a (),
                                      (Rbt (b, Nat) (Rbt ([a], a) ()),
(Bool, (a -> Rbt a (), a -> Rbt a ())))))));
ta_only_res_wits_code =
  (\ x xa ->
    let {
      xb = g_filter_dflt_basic_oops_rm_basic_ops
             (\ xb -> not (is_None (lookup xa xb))) (ta_final_impl x);
      xc = g_filter_dflt_basic_oops_rm_basic_ops
             (\ xc ->
               list_all_rec (\ xd -> not (is_None (lookup xa xd)))
                 (r_lhs_states xc))
             (ta_rules_impl x);
      a = g_filter_ls_basic_ops (\ xd -> not (is_None (lookup xa (fst xd))))
            (ta_eps_impl x);
    } in ta_make_code xb xc a);

ta_only_prs_wits_code ::
  forall a b c d.
    (Compare_order a, Eq a,
      Compare_order b) => (Rbt a (),
                            (Rbt (Ta_rule a b) (),
                              (Dlist (a, a),
                                (Rbt a (),
                                  (Rbt (b, Nat) (Rbt ([a], a) ()),
                                    (Bool,
                                      (a -> Rbt a (), a -> Rbt a ()))))))) ->
                            Rbt a (Ctxt c d) ->
                              (Rbt a (),
                                (Rbt (Ta_rule a b) (),
                                  (Dlist (a, a),
                                    (Rbt a (),
                                      (Rbt (b, Nat) (Rbt ([a], a) ()),
(Bool, (a -> Rbt a (), a -> Rbt a ())))))));
ta_only_prs_wits_code =
  (\ x xa ->
    let {
      xb = g_filter_dflt_basic_oops_rm_basic_ops
             (\ xb -> not (is_None (lookup xa xb))) (ta_final_impl x);
      xc = g_filter_dflt_basic_oops_rm_basic_ops
             (\ xc -> not (is_None (lookup xa (r_rhs xc)))) (ta_rules_impl x);
      a = g_filter_ls_basic_ops (\ xd -> not (is_None (lookup xa (snd xd))))
            (ta_eps_impl x);
    } in ta_make_code xb xc a);

next_res_wit_code ::
  forall a b c.
    (Compare_order a,
      Compare b) => Rbt (Ta_rule a b) () ->
                      Rbt a (Term b c) -> Maybe (a, Term b c);
next_res_wit_code r m =
  iteratei_set_op_list_it_rs_ops r is_None
    (\ x _ -> let {
                (TA_rule xb xc xd) = x;
              } in bind (mapMa (lookup m) xc) (\ xe -> Just (xd, Fun xb xe)))
    Nothing;

res_wits_code ::
  forall a b c.
    (Compare_order a, Compare b,
      Linorder b) => (Rbt a (),
                       (Rbt (Ta_rule a b) (),
                         (Dlist (a, a),
                           (Rbt a (),
                             (Rbt (b, Nat) (Rbt ([a], a) ()),
                               (Bool, (a -> Rbt a (), a -> Rbt a ()))))))) ->
                       Rbt a (Term b c);
res_wits_code tAi =
  let {
    x = (ta_rules_impl tAi, empty);
    (_, b) =
      while (\ (xc, _) -> not (g_isEmpty_dflt_basic_oops_rm_basic_ops xc))
        (\ (a, b) ->
          (case next_res_wit_code a b of {
            Nothing -> (empty_rm_basic_ops (), b);
            Just (aa, ba) ->
              let {
                xd = ta_eps_cl_impl tAi aa;
                xe = update_all_code b xd ba;
                xf = g_filter_dflt_basic_oops_rm_basic_ops
                       (\ xi -> not (memb_rm_basic_ops (r_rhs xi) xd)) a;
              } in (xf, xe);
          }))
        x;
  } in b;

ta_eps_icl_impl ::
  forall a b c d e f g h i. (a, (b, (c, (d, (e, (f, (g, h -> i))))))) -> h -> i;
ta_eps_icl_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) q = eicl q;

prs_wits_code ::
  forall a b.
    (Compare_order a, Compare b,
      Linorder b) => (Rbt a (),
                       (Rbt (Ta_rule a b) (),
                         (Dlist (a, a),
                           (Rbt a (),
                             (Rbt (b, Nat) (Rbt ([a], a) ()),
                               (Bool, (a -> Rbt a (), a -> Rbt a ()))))))) ->
                       Rbt a (Ctxt b a);
prs_wits_code tAi =
  let {
    x = update_all_code empty
          (union_image_rs_code (ta_final_impl tAi) (ta_eps_icl_impl tAi)) Hole;
    xa = (False, (ta_rules_impl tAi, x));
    (_, (_, ba)) =
      while (\ (xd, (_, _)) -> not xd)
        (\ (_, (aa, ba)) ->
          iteratei_set_op_list_it_rs_ops aa (\ _ -> True)
            (\ xc (ab, (ac, bc)) ->
              (case lookup bc (r_rhs xc) of {
                Nothing -> (ab, (ins_rm_basic_ops xc ac, bc));
                Just xd ->
                  (False,
                    (ac, let {
                           (TA_rule xl xm _) = xc;
                         } in rec_list (\ _ xp _ _ _ -> xp)
                                (\ xo xp xq xr xs xt xu xv ->
                                  let {
                                    xw = update_all_code xs
   (ta_eps_icl_impl xr (the_Var xo)) (ctxt_compose xt (More xu xv Hole xp));
                                  } in xq xr xw xt xu (xv ++ [xo]))
                                (map Var xm) tAi bc xd xl []));
              }))
            (True, (empty_rm_basic_ops (), ba)))
        xa;
  } in ba;

trim_ta_wits_code ::
  forall a b c.
    (Compare_order a, Eq a,
      Compare_order b) => (Rbt a (),
                            (Rbt (Ta_rule a b) (),
                              (Dlist (a, a),
                                (Rbt a (),
                                  (Rbt (b, Nat) (Rbt ([a], a) ()),
                                    (Bool,
                                      (a -> Rbt a (), a -> Rbt a ()))))))) ->
                            ((Rbt a (),
                               (Rbt (Ta_rule a b) (),
                                 (Dlist (a, a),
                                   (Rbt a (),
                                     (Rbt (b, Nat) (Rbt ([a], a) ()),
                                       (Bool,
 (a -> Rbt a (), a -> Rbt a ()))))))),
                              (Rbt a (Term b c), Rbt a (Ctxt b a)));
trim_ta_wits_code tAi = let {
                          x = res_wits_code tAi;
                          xa = ta_only_res_wits_code tAi x;
                          xb = prs_wits_code xa;
                          xc = ta_only_prs_wits_code xa xb;
                        } in (xc, (x, xb));

is_coh_final_code ::
  forall a b c d e.
    (Compare_order a) => Rbt a () ->
                           Rbt a (Rbt a (Term b c, Term d e)) ->
                             Maybe (Term b c, Term d e);
is_coh_final_code fin rel =
  iteratei_map_op_list_it_rm_ops rel is_None
    (\ x _ ->
      let {
        (a, b) = x;
      } in (if memb_rm_basic_ops a fin
             then iteratei_map_op_list_it_rm_ops b is_None
                    (\ xa _ ->
                      let {
                        (aa, (ab, bb)) = xa;
                      } in (if memb_rm_basic_ops aa fin then Nothing
                             else Just (ab, bb)))
                    Nothing
             else Nothing))
    Nothing;

map_add2_code ::
  forall a b c.
    (Compare_order a,
      Compare_order b) => Rbt a (Rbt b c) -> Rbt a (Rbt b c) -> Rbt a (Rbt b c);
map_add2_code m1 m2 =
  iteratei_map_op_list_it_rm_ops m2 (\ _ -> True)
    (\ x sigma -> let {
                    (a, b) = x;
                  } in (case lookup sigma a of {
                         Nothing -> insert a b sigma;
                         Just xc -> insert a (union xc b) sigma;
                       }))
    m1;

g_size_abort_rm_basic_ops :: forall a b. (Linorder a) => Nat -> Rbt a b -> Nat;
g_size_abort_rm_basic_ops b m =
  iteratei_bmap_op_list_it_rm_basic_ops m (\ s -> less_nat s b) (\ _ -> suc)
    zero_nat;

g_isEmpty_rm_basic_ops :: forall a b. (Linorder a) => Rbt a b -> Bool;
g_isEmpty_rm_basic_ops m =
  equal_nat (g_size_abort_rm_basic_ops one_nat m) zero_nat;

ta_check_comcoh_code ::
  forall a b c d.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => (Rbt a (),
                 (Rbt (Ta_rule a b) (),
                   (Dlist (a, a),
                     (Rbt a (),
                       (Rbt (b, Nat) (Rbt ([a], a) ()),
                         (Bool, (a -> Rbt a (), a -> Rbt a ()))))))) ->
                 Rbt (Term b c, Term b c) () -> Maybe (Term b d, Term b d);
ta_check_comcoh_code ta r =
  let {
    a = trim_ta_wits_code ta;
    (ab, (aa, ba)) = a;
    xa = is_compatible_code ab r;
    xb = (\ xf xg ->
           subst_apply_term (ctxt_apply_term (the (lookup ba xf)) xg)
             (\ xh -> the (lookup aa xh)));
  } in (case xa of {
         Inl (aba, (ac, bc)) -> Just (xb aba ac, xb aba bc);
         Inr ra ->
           (case let {
                   (aba, bb) =
                     while (\ ac ->
                             (case ac of {
                               (Inl _, _) -> False;
                               (Inr xk, _) -> not (g_isEmpty_rm_basic_ops xk);
                             }))
                       (\ (aba, bb) ->
                         let {
                           xd = iteratei_set_op_list_it_rs_ops
                                  (ta_rules_impl ab) isOK
                                  (\ xd sigma ->
                                    let {
                                      (TA_rule xe y z) = xd;
                                    } in foldli (upt zero_nat (size_list y))
   isOK
   (\ xf s ->
     let {
       xg = nth y xf;
     } in (case lookup (projr aba) xg of {
            Nothing -> s;
            Just xh ->
              iteratei_map_op_list_it_rm_ops xh isOK
                (\ xi sigmaa ->
                  let {
                    (ac, (ad, bd)) = xi;
                    xj = map Var (take xf y);
                    xk = map Var (drop (suc xf) y);
                    xl = Fun xe (xj ++ ad : xk);
                    xm = Fun xe (xj ++ bd : xk);
                    xn = list_update y xf ac;
                    xo = rule_filter_opt_code ab xe xn;
                  } in (if g_isEmpty_dflt_basic_oops_rm_basic_ops xo
                         then Inl (z, (xl, xm))
                         else let {
                                xp = g_filter_dflt_basic_oops_rm_basic_ops
                                       (\ yd ->
 is_None (bind (lookup bb z) (\ m -> lookup m yd)))
                                       xo;
                              } in (if g_isEmpty_dflt_basic_oops_rm_basic_ops xp
                                     then sigmaa
                                     else Inr
    (update_all2_code (projr sigmaa)
      (ins_dj_rm_basic_ops z (empty_rm_basic_ops ())) xp (xl, xm)))))
                s;
          }))
   sigma)
                                  (Inr empty);
                         } in (if is_Inr xd
                                then (xd, map_add2_code bb (projr xd))
                                else (xd, bb)))
                       (Inr ra, ra);
                 } in (if is_Inr aba then Inr bb else aba)
             of {
             Inl (aba, (ac, bc)) -> Just (xb aba ac, xb aba bc);
             Inr raa ->
               (case is_coh_final_code (ta_final_impl ab) raa of {
                 Nothing -> Nothing;
                 Just (aba, bb) ->
                   Just (subst_apply_term aba (\ xk -> the (lookup aa xk)),
                          subst_apply_term bb (\ xk -> the (lookup aa xk)));
               });
           });
       });

rep_ta_code ::
  forall b a.
    (Compare_order b,
      Compare_order a) => Ta_code b a ->
                            (Rbt b (),
                              (Rbt (Ta_rule b a) (),
                                (Dlist (b, b),
                                  (Rbt b (),
                                    (Rbt (a, Nat) (Rbt ([b], b) ()),
                                      (Bool,
(b -> Rbt b (), b -> Rbt b ())))))));
rep_ta_code (Abs_ta_code x) = x;

check_comcoh_wit ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => Ta_code a b ->
                 Rbt (Term b c, Term b c) () -> Maybe (Term b c, Term b c);
check_comcoh_wit x = ta_check_comcoh_code (rep_ta_code x);

check_comcoh_wit_ls ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => Ta_code a b ->
                 [(Term b c, Term b c)] -> Maybe (Term b c, Term b c);
check_comcoh_wit_ls ta r =
  check_comcoh_wit ta (g_from_list_dflt_basic_oops_rm_basic_ops r);

g_from_list_aux_ls_basic_ops :: forall a. (Eq a) => Dlist a -> [a] -> Dlist a;
g_from_list_aux_ls_basic_ops accs (x : l) =
  g_from_list_aux_ls_basic_ops (insertc x accs) l;
g_from_list_aux_ls_basic_ops y [] = y;

g_from_list_ls_basic_ops :: forall a. (Eq a) => [a] -> Dlist a;
g_from_list_ls_basic_ops l = g_from_list_aux_ls_basic_ops emptya l;

make ::
  forall a b.
    (Compare_order a, Eq a,
      Compare_order b) => Rbt a () ->
                            Rbt (Ta_rule a b) () -> Dlist (a, a) -> Ta_code a b;
make x xa xb = Abs_ta_code (ta_make_code x xa xb);

make_ls ::
  forall a b.
    (Compare_order a, Eq a,
      Compare_order b) => [a] -> [Ta_rule a b] -> [(a, a)] -> Ta_code a b;
make_ls f r e =
  make (g_from_list_dflt_basic_oops_rm_basic_ops f)
    (g_from_list_dflt_basic_oops_rm_basic_ops r) (g_from_list_ls_basic_ops e);

ta_code_make_impl ::
  forall a b.
    (Compare_order a, Eq a,
      Compare_order b) => Tree_automaton a b -> Ta_code a b;
ta_code_make_impl (Tree_Automaton fin rs eps) = make_ls fin rs eps;

ta_rhs_states ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b () -> Set a;
ta_rhs_states ta =
  sup_set (image r_rhs (ta_rules ta))
    (compute_trancl (image r_rhs (ta_rules ta)) (ta_eps ta));

initial_rel ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) -> Set (a, Set a);
initial_rel ta r =
  let {
    rhs = ta_rhs_states ta;
    match = ta_matcha ta rhs;
    analyze_rule =
      (\ (l, ra) ->
        let {
          _ = vars_term l;
        } in sup_seta
               (image
                 (\ sigma ->
                   let {
                     qr = ta_res ta (map_term (\ x -> x) (fun_of sigma) ra);
                   } in image (\ q -> (q, qr))
                          (ta_res ta (map_term (\ x -> x) (fun_of sigma) l)))
                 (match l)));
  } in sup_seta (image analyze_rule r);

initial_relation ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) -> Maybe (Set (a, a));
initial_relation ta r =
  let {
    q_qs = initial_rel ta r;
  } in (if member bot_set (image snd q_qs) then Nothing
         else Just (sup_seta
                     (image (\ (q, a) -> image (\ aa -> (q, aa)) a) q_qs)));

decide_coherent_compatible_main ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) ->
                         (Maybe (Set (a, a)) -> Maybe (Set (a, a))) -> Bool;
decide_coherent_compatible_main ta r normalizer =
  (case normalizer (initial_relation ta r) of {
    Nothing -> False;
    Just rel -> less_eq_set (imagea rel (ta_final ta)) (ta_final ta);
  });

normalize_main ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b,
      Eq b) => Ta_ext a b () -> Set (a, a) -> Set (a, a) -> Maybe (Set (a, a));
normalize_main ta rel accu =
  let {
    new = new_states ta rel;
  } in (if member Nothing (image snd new) then Nothing
         else let {
                new_rel = image (\ (x, y) -> (x, the y)) new;
                new_accu = sup_set accu rel;
                todo = minus_set new_rel new_accu;
              } in (if less_eq_set todo bot_set then Just new_accu
                     else normalize_main ta todo new_accu));

normalizea ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b,
      Eq b) => Ta_ext a b () -> Maybe (Set (a, a)) -> Maybe (Set (a, a));
normalizea ta (Just rel) = normalize_main ta rel bot_set;
normalizea ta Nothing = Nothing;

decide_coherent_compatible ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
decide_coherent_compatible ta r =
  decide_coherent_compatible_main ta r (normalizea ta);

closed_under_rewriting ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Default b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
closed_under_rewriting ta r = decide_coherent_compatible (trim_ta ta) r;

ta_det_impl :: forall a b c d e f g. (a, (b, (c, (d, (e, (f, g)))))) -> f;
ta_det_impl (f, (r, (e, (rhs, (idx, (det, x)))))) = det;

deta :: forall a b. (Compare_order a, Compare_order b) => Ta_code a b -> Bool;
deta x = ta_det_impl (rep_ta_code x);

sorted_list_of_set ::
  forall a. (Ceq a, Ccompare a, Eq a, Linorder a) => Set a -> [a];
sorted_list_of_set (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "sorted_list_of_set RBT_set: ccompare = None"
        (\ _ -> sorted_list_of_set (RBT_set rbt));
    Just _ -> sort_key (\ x -> x) (keysa rbt);
  });
sorted_list_of_set (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "sorted_list_of_set DList_set: ceq = None"
        (\ _ -> sorted_list_of_set (DList_set dxs));
    Just _ -> sort_key (\ x -> x) (list_of_dlista dxs);
  });
sorted_list_of_set (Set_Monad xs) = sort_key (\ x -> x) (remdups xs);

sorted_ps_ta ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Linorder a, Set_impl a, Ceq b, Ccompare b, Compare b, Eq b,
      Set_impl b) => Ta_ext a b () -> Tree_automaton [a] b;
sorted_ps_ta ta =
  Tree_Automaton
    (sorted_list_of_set (image sorted_list_of_set (ta_final (ps_ta ta))))
    (sorted_list_of_set
      (image
        (\ (TA_rule g qs q) ->
          TA_rule g (map sorted_list_of_set qs) (sorted_list_of_set q))
        (ta_rules (ps_ta ta))))
    [];

ta_of_ta ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Tree_automaton a b -> Ta_ext a b ();
ta_of_ta (Tree_Automaton fin rules eps) =
  Ta_ext (set fin) (set rules) (set eps) ();

tree_aut_trs_closed ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a, Showa a, Ceq b, Ccompare b, Compare_order b, Default b, Eq b,
      Set_impl b, Showa b, Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c,
      Compare_order c, Eq c, Set_impl c,
      Showa c) => Tree_automaton a b ->
                    Ta_relation a ->
                      [(Term b c, Term b c)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
tree_aut_trs_closed ta rel r =
  bindb (check_varcond_subset r)
    (\ _ ->
      catch_errora
        (case rel of {
          Decision_Proc_Old ->
            bindb (catch_errora (check_det ta)
                    (\ x ->
                      Inl (shows_prec_list zero_nat
                             ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', ' ', 'p',
                               'r', 'o', 'c', 'e', 'd', 'u', 'r', 'e', ' ', 'r',
                               'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'd', 'e',
                               't', '.', ' ', 'T', 'A', ' ', 'a', 's', ' ', 'i',
                               'n', 'p', 'u', 't'] .
                            shows_nl . x)))
              (\ _ ->
                check (closed_under_rewriting (ta_of_ta ta) (set r))
                  (shows_prec_list zero_nat
                    ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l',
                      'o', 's', 'e', 'd', ' ', 'u', 'n', 'd', 'e', 'r', ' ',
                      'r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g']));
          Decision_Proc ->
            let {
              tc = ta_code_make_impl ta;
            } in (if deta tc
                   then (case check_comcoh_wit_ls tc r of {
                          Nothing -> Inr ();
                          Just (wl, wr) ->
                            Inl (shows_prec_list zero_nat
                                   ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't',
                                     ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ',
                                     'u', 'n', 'd', 'e', 'r', ' ', 'r', 'e',
                                     'w', 'r', 'i', 't', 'i', 'n', 'g'] .
                                  shows_nl .
                                    shows_term (shows_prec zero_nat)
                                      (shows_prec zero_nat) wl .
                                      shows_prec_list zero_nat
[' ', 'i', 's', ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', ' ', 'b', 'y', ' ',
  'T', 'A', ' ', 'a', 'n', 'd', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', 's',
  ' ', 't', 'o'] .
shows_nl .
  shows_term (shows_prec zero_nat) (shows_prec zero_nat) wr .
    shows_prec_list zero_nat
      [' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
        'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'T', 'A']);
                        })
                   else let {
                          tca = ta_code_make_impl
                                  (sorted_ps_ta (trim_ta (ta_of_ta ta)));
                        } in (case check_comcoh_wit_ls tca r of {
                               Nothing -> Inr ();
                               Just (wl, wr) ->
                                 Inl (shows_prec_list zero_nat
['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd',
  ' ', 'u', 'n', 'd', 'e', 'r', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'i', 'n',
  'g'] .
                                       shows_nl .
 shows_term (shows_prec zero_nat) (shows_prec zero_nat) wl .
   shows_prec_list zero_nat
     [' ', 'i', 's', ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', ' ', 'b', 'y',
       ' ', 'T', 'A', ' ', 'a', 'n', 'd', ' ', 'r', 'e', 'w', 'r', 'i', 't',
       'e', 's', ' ', 't', 'o'] .
     shows_nl .
       shows_term (shows_prec zero_nat) (shows_prec zero_nat) wr .
         shows_prec_list zero_nat
           [' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'n', 'o', 't',
             ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', ' ', 'b', 'y', ' ',
             'T', 'A']);
                             }));
          Id_Relation ->
            bindb (generate_ta_cond ta rel)
              (\ taa ->
                bindb (catch_errora
                        (if isOK (check_left_linear_trs r) then Inr ()
                          else check_det ta)
                        (\ x ->
                          Inl (shows_prec_list zero_nat
                                 ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                   ' ', 'e', 'n', 's', 'u', 'r', 'e', ' ', 'l',
                                   'e', 'f', 't', '-', 'l', 'i', 'n', 'e', 'a',
                                   'r', 'i', 't', 'y', ' ', 'o', 'r', ' ', 'd',
                                   'e', 't', 'e', 'r', 'm', 'i', 'n', 'i', 's',
                                   'm'] .
                                shows_nl . x)))
                  (\ _ ->
                    catch_errora
                      (state_compatible_eff_list taa (rel_checker rel) r)
                      (\ x ->
                        Inl (let {
                               (lr, (lrq, q)) = x;
                             } in shows_prec_list zero_nat
                                    ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o',
                                      't', ' ', 'c', 'o', 'm', 'p', 'a', 't',
                                      'i', 'b', 'l', 'e', ' ', 'w', 'i', 't',
                                      'h', ' ', 'R'] .
                                    shows_nl .
                                      shows_prec_list zero_nat
['f', 'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
shows_rule (shows_prec zero_nat) (shows_prec zero_nat) [' ', '-', '>', ' '] lr .
  shows_nl .
    shows_prec_list zero_nat
      ['w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'i', 'n', 's', 't', 'a',
        'n', 't', 'i', 'a', 't', 'e', 'd', ' ', 'b', 'y', ' ', 's', 't', 'a',
        't', 'e', 's', ' ', 't', 'o', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] lrq .
        shows_nl .
          shows_prec_list zero_nat
            ['t', 'h', 'e', ' ', 's', 't', 'a', 't', 'e', ' '] .
            shows_prec zero_nat q .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'r', 'e', 'a',
                  'c', 'h', 'a', 'b', 'l', 'e', ' ', 'f', 'r', 'o', 'm', ' ',
                  't', 'h', 'e', ' ', 'l', 'h', 's'] .
                shows_nl))));
          Some_Relation _ ->
            bindb (generate_ta_cond ta rel)
              (\ taa ->
                bindb (catch_errora
                        (if isOK (check_left_linear_trs r) then Inr ()
                          else check_det ta)
                        (\ x ->
                          Inl (shows_prec_list zero_nat
                                 ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                   ' ', 'e', 'n', 's', 'u', 'r', 'e', ' ', 'l',
                                   'e', 'f', 't', '-', 'l', 'i', 'n', 'e', 'a',
                                   'r', 'i', 't', 'y', ' ', 'o', 'r', ' ', 'd',
                                   'e', 't', 'e', 'r', 'm', 'i', 'n', 'i', 's',
                                   'm'] .
                                shows_nl . x)))
                  (\ _ ->
                    catch_errora
                      (state_compatible_eff_list taa (rel_checker rel) r)
                      (\ x ->
                        Inl (let {
                               (lr, (lrq, q)) = x;
                             } in shows_prec_list zero_nat
                                    ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o',
                                      't', ' ', 'c', 'o', 'm', 'p', 'a', 't',
                                      'i', 'b', 'l', 'e', ' ', 'w', 'i', 't',
                                      'h', ' ', 'R'] .
                                    shows_nl .
                                      shows_prec_list zero_nat
['f', 'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
shows_rule (shows_prec zero_nat) (shows_prec zero_nat) [' ', '-', '>', ' '] lr .
  shows_nl .
    shows_prec_list zero_nat
      ['w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'i', 'n', 's', 't', 'a',
        'n', 't', 'i', 'a', 't', 'e', 'd', ' ', 'b', 'y', ' ', 's', 't', 'a',
        't', 'e', 's', ' ', 't', 'o', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] lrq .
        shows_nl .
          shows_prec_list zero_nat
            ['t', 'h', 'e', ' ', 's', 't', 'a', 't', 'e', ' '] .
            shows_prec zero_nat q .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'r', 'e', 'a',
                  'c', 'h', 'a', 'b', 'l', 'e', ' ', 'f', 'r', 'o', 'm', ' ',
                  't', 'h', 'e', ' ', 'l', 'h', 's'] .
                shows_nl))));
        })
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                   ' ', 'e', 'n', 's', 'u', 'r', 'i', 'n', 'g', ' ', '(', 's',
                   't', 'a', 't', 'e', '-', ')', 'c', 'o', 'm', 'p', 'a', 't',
                   'i', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'o', 'f', ' ', 'T',
                   'R', 'S', ' ', 'w', 'i', 't', 'h', ' ', 'T', 'A', ' '] .
                shows_nl .
                  shows_prec_tree_automaton zero_nat ta . shows_nl . x)));

intersect_ta ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Set_impl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Eq c,
      Set_impl c) => Ta_ext a b () -> Ta_ext c b () -> Ta_ext (a, c) b ();
intersect_ta tA1 tA2 = prod_ta tA1 tA2 (productc (ta_final tA1) (ta_final tA2));

non_join_with_ta ::
  forall a b c d e f g.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a, Showa a, Ceq b, Ccompare b, Compare_order b, Default b, Eq b,
      Set_impl b, Showa b, Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c,
      Compare_order c, Eq c, Set_impl c, Showa c, Showa d, Card_UNIV e, Cenum e,
      Ceq e, Cproper_interval e, Compare_order e, Eq e, Set_impl e, Showa e,
      Finite_UNIV f, Cenum f, Ceq f, Cproper_interval f, Compare_order f, Eq f,
      Set_impl f, Showa f,
      Showa g) => Tree_automaton a b ->
                    Ta_relation a ->
                      [(Term b c, Term b c)] ->
                        Term b d ->
                          Tree_automaton e b ->
                            Ta_relation e ->
                              [(Term b f, Term b f)] ->
                                Term b g ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
non_join_with_ta ta1 rel1 r1 t1 ta2 rel2 r2 t2 =
  let {
    tA1 = ta_of_ta ta1;
    tA2 = ta_of_ta ta2;
  } in bindb (check (ta_member t1 tA1)
               (shows_prec_term zero_nat t1 .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e',
                     'p', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'f', 'i', 'r', 's',
                     't', ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n']))
         (\ _ ->
           bindb (check (ta_member t2 tA2)
                   (shows_prec_term zero_nat t2 .
                     shows_prec_list zero_nat
                       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                         'e', 'p', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'f', 'i',
                         'r', 's', 't', ' ', 'a', 'u', 't', 'o', 'm', 'a', 't',
                         'o', 'n']))
             (\ _ ->
               bindb (check (ta_empty (intersect_ta tA1 tA2))
                       (shows_prec_list zero_nat
                         ['i', 'n', 't', 'e', 'r', 's', 'e', 'c', 't', 'i', 'o',
                           'n', ' ', 'o', 'f', ' ', 'a', 'u', 't', 'o', 'm',
                           'a', 't', 'a', ' ', 'i', 's', ' ', 'n', 'o', 'n',
                           '-', 'e', 'm', 'p', 't', 'y']))
                 (\ _ ->
                   bindb (catch_errora (tree_aut_trs_closed ta1 rel1 r1)
                           (\ x ->
                             Inl (shows_prec_list zero_nat
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 'e', 'n', 's', 'u', 'r', 'e',
                                      ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e',
                                      ' ', 'u', 'n', 'd', 'e', 'r', ' ', 'r',
                                      'e', 'w', 'r', 'i', 't', 'i', 'n', 'g',
                                      ' ', 'f', 'o', 'r', ' ', 'f', 'i', 'r',
                                      's', 't', ' ', 'a', 'u', 't', 'o', 'm',
                                      'a', 't', 'o', 'n'] .
                                   shows_nl . x)))
                     (\ _ ->
                       catch_errora (tree_aut_trs_closed ta2 rel2 r2)
                         (\ x ->
                           Inl (shows_prec_list zero_nat
                                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                    ' ', 'e', 'n', 's', 'u', 'r', 'e', ' ', 'c',
                                    'l', 'o', 's', 'u', 'r', 'e', ' ', 'u', 'n',
                                    'd', 'e', 'r', ' ', 'r', 'e', 'w', 'r', 'i',
                                    't', 'i', 'n', 'g', ' ', 'f', 'o', 'r', ' ',
                                    's', 'e', 'c', 'o', 'n', 'd', ' ', 'a', 'u',
                                    't', 'o', 'm', 'a', 't', 'o', 'n'] .
                                 shows_nl . x))))));

check_non_join ::
  forall a b.
    (Default a, Eq a, Key a, Showa a, Card_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b,
      Showa b) => [(Term (Lab a [Nat]) [Prelude.Char],
                     Term (Lab a [Nat]) [Prelude.Char])] ->
                    [(Term (Lab a [Nat]) [Prelude.Char],
                       Term (Lab a [Nat]) [Prelude.Char])] ->
                      Term (Lab a [Nat]) [Prelude.Char] ->
                        Term (Lab a [Nat]) [Prelude.Char] ->
                          Non_join_info (Lab a [Nat]) [Prelude.Char] b ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join rs rt s t Diff_NFs =
  bindb (check (not (equal_term s t))
          (shows_prec_list zero_nat
             ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', 's', ' '] .
            shows_prec_term zero_nat s .
              shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term zero_nat t .
                  shows_prec_list zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'i', 'd', 'e', 'n', 't', 'i', 'c',
                      'a', 'l']))
    (\ _ ->
      let {
        chknf =
          (\ sa r ->
            check (is_NF_trs r sa)
              (shows_prec_list zero_nat
                 ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                shows_term (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
                  sa .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'n',
                      'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']));
      } in bindb (chknf s rs) (\ _ -> chknf t rt));
check_non_join rs rt s t (Grounding sigma prf) =
  let {
    sigmaa = mk_subst Var sigma;
  } in check_non_join rs rt (subst_apply_term s sigmaa)
         (subst_apply_term t sigmaa) prf;
check_non_join rs rt s t (Subterm_NJ p prf) =
  bindb (check (member p (pos_gctxt (tcapI rs s)))
          (shows_prec_list zero_nat
             ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' '] .
            shows_prec_pos zero_nat p .
              shows_prec_list zero_nat
                [' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'c', 'a', 'p', 'p',
                  'e', 'd', ' ', 't', 'e', 'r', 'm', ' ', ' ', 'o', 'f', ' '] .
                shows_prec_term zero_nat s))
    (\ _ ->
      bindb (check (member p (pos_gctxt (tcapI rt t)))
              (shows_prec_list zero_nat
                 ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' '] .
                shows_prec_pos zero_nat p .
                  shows_prec_list zero_nat
                    [' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'c', 'a', 'p', 'p',
                      'e', 'd', ' ', 't', 'e', 'r', 'm', ' ', ' ', 'o', 'f',
                      ' '] .
                    shows_prec_term zero_nat t))
        (\ _ -> check_non_join rs rt (subt_at s p) (subt_at t p) prf));
check_non_join rs rt s t (Tcap_Non_Unif grd_subst) =
  let {
    sigma = grd_subst s t;
    cs = tcapI rs (subst_apply_term s sigma);
    ct = tcapI rt (subst_apply_term t sigma);
  } in check (is_none (merge cs ct))
         (shows_prec_list zero_nat
            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
              'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
           shows_prec_term zero_nat s .
             shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
               shows_prec_term zero_nat t .
                 shows_prec_list zero_nat
                   [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                     'n', 'a', 'b', 'l', 'e']);
check_non_join rs rt s t (Tree_Aut_Intersect_Empty ta1 rel1 ta2 rel2) =
  catch_errora (non_join_with_ta ta1 rel1 rs s ta2 rel2 rt t)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
               'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
            shows_prec_term zero_nat s .
              shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term zero_nat t .
                  shows_prec_list zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                      'n', 'a', 'b', 'l', 'e'] .
                    shows_nl . x));
check_non_join rs rt s t (Finite_Model_Gt i) =
  catch_errora (check_non_join_finite_model i rs rt s t)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
               'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
            shows_prec_term zero_nat s .
              shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term zero_nat t .
                  shows_prec_list zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                      'n', 'a', 'b', 'l', 'e'] .
                    shows_nl . x));
check_non_join rs rt s t (Reduction_Pair_Gt rp) =
  catch_errora (check_non_join_redpair (get_redtriple rp) rs rt s t)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
               'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
            shows_prec_term zero_nat s .
              shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term zero_nat t .
                  shows_prec_list zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                      'n', 'a', 'b', 'l', 'e'] .
                    shows_nl . x));
check_non_join rs rt s t (Usable_Rules_Reach_NJ prf) =
  check_non_join (usable_rules_reach_impl rs s) (usable_rules_reach_impl rt t) s
    t prf;
check_non_join rs rt s t (Usable_Rules_Reach_Unif_NJ u_sum prf) =
  (case u_sum of {
    Inl u ->
      bindb (check_usable_rules_unif rs u s)
        (\ _ -> check_non_join u rt s t prf);
    Inr u ->
      bindb (check_usable_rules_unif rt u t)
        (\ _ -> check_non_join rs u s t prf);
  });
check_non_join rs rt s t (Argument_Filter_NJ pi prf) =
  (case afs_of pi of {
    Nothing ->
      Inl (shows_prec_list zero_nat
            ['i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'a', 'r', 'g', 'u', 'm',
              'e', 'n', 't', ' ', 'f', 'i', 'l', 't', 'e', 'r']);
    Just pia -> let {
                  af = af_term pia;
                  afs = af_rules pia;
                } in check_non_join (afs rs) (afs rt) (af s) (af t) prf;
  });

check_non_cr ::
  forall a b.
    (Default a, Eq a, Key a, Showa a, Card_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b,
      Showa b) => [(Term (Lab a [Nat]) [Prelude.Char],
                     Term (Lab a [Nat]) [Prelude.Char])] ->
                    Term (Lab a [Nat]) [Prelude.Char] ->
                      [(Pos, ((Term (Lab a [Nat]) [Prelude.Char],
                                Term (Lab a [Nat]) [Prelude.Char]),
                               Term (Lab a [Nat]) [Prelude.Char]))] ->
                        [(Pos, ((Term (Lab a [Nat]) [Prelude.Char],
                                  Term (Lab a [Nat]) [Prelude.Char]),
                                 Term (Lab a [Nat]) [Prelude.Char]))] ->
                          Non_join_info (Lab a [Nat]) [Prelude.Char] b ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_cr r s seq1 seq2 reason =
  let {
    chk = check_rsteps_last r s;
  } in bindb (chk seq1)
         (\ _ ->
           bindb (chk seq2)
             (\ _ ->
               check_non_join r r (rseq_last s seq1) (rseq_last s seq2)
                 reason));

check_ncr_proof ::
  forall a b c.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            Ncr_proof b [Nat] [Prelude.Char] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ncr_proof a ia i j r (SN_NWCR prf) =
  debug (ia []) ['S', 'N', '_', 'N', 'W', 'C', 'R']
    (let {
       tp = mkc i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a
                    (ia . shows_string ['.', '1']) tp prf)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 's', 't', 'r', 'o',
                                  'n', 'g', ' ', 'n', 'o', 'r', 'm', 'a', 'l',
                                  'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', '+',
                                  ' ', 'w', 'c', 'r'] .
                                shows_nl . indent x)))
            (\ _ ->
              catch_errora
                (check
                  (not (isOK (check_critical_pairs_NF r
                               (critical_pairs_impl r r))))
                  (shows_prec_list zero_nat
                    ['a', 'l', 'l', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l',
                      ' ', 'p', 'a', 'i', 'r', 's', ' ', 'a', 'r', 'e', ' ',
                      'j', 'o', 'i', 'n', 'a', 'b', 'l', 'e']))
                (\ x ->
                  Inl (ia . shows_prec_list zero_nat
                              ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                                ' ', 'd', 'i', 's', 'p', 'r', 'o', 'v', 'i',
                                'n', 'g', ' ', 'l', 'o', 'c', 'a', 'l', ' ',
                                'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c',
                                'e', ' ', 'o', 'f', ' '] .
                              shows_tp (shows_prec_lab zero_nat)
                                (shows_prec_list zero_nat) i tp .
                                shows_nl . indent x))));
check_ncr_proof a ia i j r (Non_Join s seq1 seq2 prf) =
  debug (ia []) ['N', 'o', 'n', '_', 'J', 'o', 'i', 'n']
    (catch_errora (check_non_cr r s seq1 seq2 prf)
      (\ x ->
        Inl (ia . shows_prec_list zero_nat
                    ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'd',
                      'i', 's', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'C',
                      'R', ' ', 'o', 'f', ' '] .
                    shows_trs (shows_prec_lab zero_nat)
                      (shows_prec_list zero_nat)
                      ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                        't', 'e', 'm', ':']
                      [' ', '-', '>', ' '] r .
                      shows_nl . indent x)));
check_ncr_proof a ia i j ra (NCR_Disj_Subtrs r prf) =
  debug (ia []) ['M', 'o', 'd', 'u', 'l', 'a', 'r', 'i', 't', 'y']
    (bindb
      (catch_errora (check_modularity_ncr ra r)
        (\ x ->
          Inl (ia . shows_prec_list zero_nat
                      ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                        'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'm', 'o',
                        'd', 'u', 'l', 'a', 'r', 'i', 't', 'y', ' ', 't', 'o',
                        ' ', 's', 'w', 'i', 't', 'c', 'h', ' ', 't', 'o', ' '] .
                      shows_trs (shows_prec_lab zero_nat)
                        (shows_prec_list zero_nat)
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                          't', 'e', 'm', ':']
                        [' ', '-', '>', ' '] r .
                        shows_nl . indent x)))
      (\ _ ->
        catch_errora
          (check_ncr_proof a (ia . shows_string ['.', '1']) i j r prf)
          (\ x ->
            Inl (ia . shows_string
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'd', 'u',
                          'l', 'a', 'r', ' ', 'd', 'e', 'c', 'o', 'm', 'p', 'o',
                          's', 'i', 't', 'i', 'o', 'n'] .
                        shows_nl . indent x))));
check_ncr_proof a ia i j r (NCR_Redundant_Rules rs n prf) =
  debug (ia [])
    ['R', 'e', 'd', 'u', 'n', 'd', 'a', 'n', 't', ' ', 'R', 'u', 'l', 'e', 's']
    (bindb
      (catch_errora
        (check_ncr_proof a (ia . shows_string ['.', '1']) i j rs prf)
        (\ x ->
          Inl (ia . shows_prec_list zero_nat
                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                        'n', ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'n',
                        'o', 'n', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c',
                        'e', ' ', 'o', 'f', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
                        'e', 'd', ' ', 'T', 'R', 'S'] .
                      shows_nl .
                        shows_trs (shows_prec_lab zero_nat)
                          (shows_prec_list zero_nat)
                          ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                            's', 't', 'e', 'm', ':']
                          [' ', '-', '>', ' '] rs .
                          indent x)))
      (\ _ ->
        catch_errora (check_redundant_rules_ncr r rs n)
          (\ x ->
            Inl (ia . shows_prec_list zero_nat
                        ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c', 'h',
                          'e', 'c', 'k', 'i', 'n', 'g', ' ', 'r', 'e', 'd', 'u',
                          'n', 'd', 'a', 'n', 't', ' ', 'r', 'u', 'l', 'e', 's',
                          ' ', 't', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a',
                          't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 't', 'h', 'e',
                          ' ', 'T', 'R', 'S'] .
                        shows_nl .
                          shows_trs (shows_prec_lab zero_nat)
                            (shows_prec_list zero_nat)
                            ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                              's', 't', 'e', 'm', ':']
                            [' ', '-', '>', ' '] r .
                            indent x))));

check_rel_loop ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Term a b ->
                    [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                      [(b, Term a b)] ->
                        Ctxt a b ->
                          [(Term a b, Term a b)] ->
                            [(Term a b, Term a b)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_loop sa rseq sigma c r s =
  check_rel_seq r s rseq sa
    (ctxt_apply_term c (subst_apply_term sa (mk_subst Var sigma))) False;

check_trs_loop ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Trs_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_loop i tp (TRS_loop_prf s rseq sigma c) =
  check_loop (qb i tp) (nfsb i tp) s rseq sigma c (rulesd i tp);

prems_ofa ::
  forall a.
    Dp_proof_step a ->
      [(([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))];
prems_ofa step =
  (case step of {
    OC1 _ _ -> [];
    OC2 _ p pa _ _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OC2p _ p pa _ _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OC3 _ p pa _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OC3p _ p pa _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OCDP1 _ p ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p)))];
    OCDP2 _ p ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p)))];
    WPEQ _ p -> [p];
    Lift _ p -> [p];
    DPOC1_1 _ p rl _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC1_2 _ p rl _ _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC2 _ p rl _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC3_1 _ p rl _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC3_2 _ p rl _ _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPDP1_1 _ p1 p2 _ _ -> [p1, p2];
    DPDP1_2 _ p1 p2 _ _ -> [p1, p2];
    DPDP2_1 _ p1 p2 _ _ -> [p1, p2];
    DPDP2_2 _ p1 p2 _ _ -> [p1, p2];
  });

shows_oc ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_oc (l, r) =
  shows_prec zero_nat l .
    shows_prec_list zero_nat [' ', '-', '>', '+', ' '] . shows_prec zero_nat r;

vars_subst_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
vars_subst_impl sigma =
  let {
    sigmaa = mk_subst_domain sigma;
  } in map fst sigmaa ++ concatMap (vars_term_list . snd) sigmaa;

unraveling_info ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(((Term a [Prelude.Char], Term a [Prelude.Char]),
              [(Term a [Prelude.Char], Term a [Prelude.Char])]),
             [(Term a [Prelude.Char], Term a [Prelude.Char])])];
unraveling_info xml2name =
  many ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', 'I', 'n', 'f', 'o',
         'r', 'm', 'a', 't', 'i', 'o', 'n']
    (many1
      ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', 'E', 'n', 't', 'r',
        'y']
      (crule xml2name) (rule xml2name) (\ a b -> (a, b)))
    id;

check_same_set :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_same_set xs ys =
  bindb (check_subseteq xs ys) (\ _ -> check_subseteq ys xs);

mk_tpa ::
  forall a b c d.
    Tp_ops_ext a b c d -> (Bool, ([Term b c], [(Term b c, Term b c)])) -> a;
mk_tpa i (nfs, (q, r)) = mkc i nfs q r [];

show_pat_term ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                    [Prelude.Char] -> [Prelude.Char];
show_pat_term p =
  let {
    (s, (sigma, tau)) = p;
  } in shows_prec_prod zero_nat
         (s, (mk_subst_domain sigma, mk_subst_domain tau));

show_pat_rule ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                    ((Term a b, ([(b, Term a b)], [(b, Term a b)])), Bool)) ->
                    [Prelude.Char] -> [Prelude.Char];
show_pat_rule pr =
  let {
    (p1, (p2, _)) = pr;
  } in show_pat_term p1 .
         shows_string [' ', '-', '-', '>', ' '] . show_pat_term p2;

term_to_string :: forall a b. Term a b -> [a];
term_to_string (Fun f [t]) = f : term_to_string t;
term_to_string (Var v) = [];
term_to_string (Fun v []) = [];
term_to_string (Fun v (vb : vd : ve)) = [];

normalize_wp ::
  forall a.
    (Eq a) => ([a], ((Nat, (Nat, [a])), [a])) ->
                ([a], ((Nat, (Nat, [a])), [a]));
normalize_wp x =
  let {
    (l, (aa, r)) = x;
    (f, aaa) = aa;
  } in (if equal_nat f zero_nat
         then let {
                (aab, m) = aaa;
              } in (if equal_nat aab zero_nat
                     then ([], ((zero_nat, (zero_nat, [])), l ++ r))
                     else normalize_wp
                            (l ++ concat
                                    (replicate (suc (minus_nat aab one_nat)) m),
                              ((zero_nat, (zero_nat, m)), r)))
         else (if equal_nat (minus_nat f one_nat) zero_nat
                then let {
                       (aab, m) = aaa;
                     } in (if equal_nat aab zero_nat
                            then (case m of {
                                   [] -> ([],
   ((zero_nat, (zero_nat, [])), l ++ r));
                                   a : ma ->
                                     (case r of {
                                       [] ->
 (l, ((suc zero_nat, (zero_nat, a : ma)), []));
                                       b : ra ->
 (if a == b
   then normalize_wp (l ++ [b], ((suc zero_nat, (zero_nat, ma ++ [b])), ra))
   else (l, ((suc zero_nat, (zero_nat, a : ma)), b : ra)));
                                     });
                                 })
                            else normalize_wp
                                   (l ++ concat
   (replicate (suc (minus_nat aab one_nat)) m),
                                     ((suc zero_nat, (zero_nat, m)), r)))
                else let {
                       (aab, m) = aaa;
                     } in (if equal_nat aab zero_nat
                            then (case m of {
                                   [] -> ([],
   ((zero_nat, (zero_nat, [])), l ++ r));
                                   vb : vba ->
                                     normalize_wp
                                       (l,
 ((suc zero_nat,
    (zero_nat,
      concat
        (replicate (suc (suc (minus_nat (minus_nat f one_nat) one_nat)))
          (vb : vba)))),
   r));
                                 })
                            else normalize_wp
                                   (l ++ concat
   (replicate (suc (minus_nat aab one_nat)) m),
                                     ((suc
 (suc (minus_nat (minus_nat f one_nat) one_nat)),
(zero_nat, m)),
                                       r)))));

word_pat_equiv ::
  forall a.
    (Eq a) => ([a], ((Nat, (Nat, [a])), [a])) ->
                ([a], ((Nat, (Nat, [a])), [a])) -> Bool;
word_pat_equiv wp1 wp2 = wp1 == wp2 || normalize_wp wp1 == normalize_wp wp2;

shows_pat ::
  forall a b c d e f g h i j.
    (Showa a, Showa b, Showa c, Showa d, Showa e, Showa f, Showa g, Showa h,
      Showa i,
      Showa j) => ((a, ((b, (c, d)), e)), (f, ((g, (h, i)), j))) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_pat (p1, p2) =
  shows_p p1 . shows_prec_list zero_nat [' ', '-', '>', '+', ' '] . shows_p p2;

bounded_postfixes :: Pos -> [Pos] -> [Pos];
bounded_postfixes p ps =
  map_filter (\ x -> (if not (is_none x) then Just (the x) else Nothing))
    (map (pos_prefix p) ps);

rel_rules_of ::
  forall a b. Maybe [(Term a b, Term a b)] -> [(Term a b, Term a b)];
rel_rules_of Nothing = [];
rel_rules_of (Just r) = r;

subst_power_impl ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> Nat -> [(a, Term b a)];
subst_power_impl sigma n =
  (if equal_nat n zero_nat then []
    else subst_compose_impl sigma
           (subst_power_impl sigma (minus_nat n one_nat)));

impl_ofc ::
  forall b a.
    (Key b,
      Key a) => Tp b a ->
                  (Bool,
                    ([Term b a],
                      (Bool,
                        ([(Term b a, Term b a)],
                          ([(Term b a, Term b a)],
                            (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                              Term b a -> Bool))))));
impl_ofc (TP x) = x;

q_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      [Term a b];
q_impl (uu, (q, uv)) = q;

q :: forall a b. (Key a, Key b) => Tp a b -> [Term a b];
q tp = q_impl (impl_ofc tp);

r_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)];
r_impl (uu, (uv, (uw, (vR, (ux, (m, uy)))))) = vR ++ rules_with id m;

r :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
r tp = r_impl (impl_ofc tp);

rhs_n ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Term a b;
rhs_n u (lr, cs) n =
  (if less_nat n (size_list cs)
    then ctxt_apply_term (u (lr, cs) n) (fst (nth cs n)) else snd lr);

lhs_n ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Term a b;
lhs_n u (lr, cs) n =
  (if equal_nat n zero_nat then fst lr
    else ctxt_apply_term (u (lr, cs) (minus_nat n one_nat))
           (snd (nth cs (minus_nat n one_nat))));

rules_impl ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> [(Term a b, Term a b)];
rules_impl u cr =
  map (\ i -> (lhs_n u cr i, rhs_n u cr i))
    (upt zero_nat (suc (size_list (snd cr))));

default_nfs_nt_trs :: Bool;
default_nfs_nt_trs = False;

xml2inn_rel_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Bool,
                       ([Term (Lab a b) [Prelude.Char]],
                         ([(Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char])],
                           [(Term (Lab a b) [Prelude.Char],
                              Term (Lab a b) [Prelude.Char])])));
xml2inn_rel_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Inn_TRS_input (inn, (r, so)) ->
          returna
            (default_nfs_nt_trs, (strategy_to_Q inn r, (r, (case so of {
                     Nothing -> [];
                     Just s -> s;
                   }))));
        COMP_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        EQ_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        CPX_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        FP_TRS_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        CTRS_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        TA_input _ _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        AC_input _ _ _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Unknown_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
      }));

xml2inn_fp_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Sum (Bool,
                            ([Term (Lab a b) [Prelude.Char]],
                              [(Term (Lab a b) [Prelude.Char],
                                 Term (Lab a b) [Prelude.Char])]))
                       ([(Ctxt (Lab a b) [Prelude.Char],
                           (Term (Lab a b) [Prelude.Char], Location))],
                         [(Term (Lab a b) [Prelude.Char],
                            Term (Lab a b) [Prelude.Char])]));
xml2inn_fp_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Inn_TRS_input (inn, (r, Nothing)) ->
          returna (Inl (default_nfs_nt_trs, (strategy_to_Q inn r, r)));
        Inn_TRS_input (_, (_, Just _)) ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        COMP_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        EQ_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        CPX_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        FP_TRS_input (fp, r) -> returna (Inr (strategy_to_fp fp r, r));
        CTRS_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        TA_input _ _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        AC_input _ _ _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Unknown_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
      }));

xml2fp_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     ([(Ctxt (Lab a b) [Prelude.Char],
                         (Term (Lab a b) [Prelude.Char], Location))],
                       [(Term (Lab a b) [Prelude.Char],
                          Term (Lab a b) [Prelude.Char])]);
xml2fp_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        Inn_TRS_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        COMP_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        EQ_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        CPX_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        FP_TRS_input (fp, r) -> returna (strategy_to_fp fp r, r);
        CTRS_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        TA_input _ _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        AC_input _ _ _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        Unknown_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
      }));

xml2inn_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Bool,
                       ([Term (Lab a b) [Prelude.Char]],
                         [(Term (Lab a b) [Prelude.Char],
                            Term (Lab a b) [Prelude.Char])]));
xml2inn_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Inn_TRS_input (inn, (r, Nothing)) ->
          returna (default_nfs_nt_trs, (strategy_to_Q inn r, r));
        Inn_TRS_input (_, (_, Just _)) ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        COMP_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        EQ_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        CPX_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        FP_TRS_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        CTRS_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        TA_input _ _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        AC_input _ _ _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Unknown_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
      }));

xml2reltrs_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Reltrs_nontermination_proof a b [Prelude.Char]);
xml2reltrs_nontermination_proof xml2name x =
  singleton
    ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'N', 'o', 'n', 't', 'e', 'r', 'm',
      'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i', 't',
          'i', 'o', 'n', 'V', 'i', 'o', 'l', 'a', 't', 'e', 'd'],
         leaf ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i',
                't', 'i', 'o', 'n', 'V', 'i', 'o', 'l', 'a', 't', 'e', 'd']
           Rel_Not_Well_Formed),
        (['l', 'o', 'o', 'p'],
          change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              Rel_Loop (Rel_trs_loop_prf s rseq sigma c))),
        (['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
           'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
          change (xml2trs_nontermination_proof xml2name) Rel_R_Not_SN),
        (['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
          triple ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
            (singleton ['t', 'r', 's'] (rules xml2name) Just)
            (singleton ['t', 'r', 's'] (rules xml2name) Just)
            (xml2reltrs_nontermination_proof xml2name)
            (\ r s -> Rel_Rule_Removal (Rule_removal_nonterm_reltrs_prf r s))),
        (['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a', 'l'],
          triple
            ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a',
              'l']
            (singleton ['t', 'r', 's'] (rules xml2name) Just)
            (singleton ['t', 'r', 's'] (rules xml2name) Just)
            (xml2reltrs_nontermination_proof xml2name)
            (\ _ _ -> Rel_TRS_String_Reversal)),
        (['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
           'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
              'n', 'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2inn_rel_nt_trs_assm xml2name)
            (\ qtrs -> Rel_TRS_Assume_Not_SN qtrs [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2inn_rel_nt_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs)
                             (nat_of_integer (2 :: Integer)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (nat_of_integer (2 :: Integer))
                                    (tag (nth cs one_nat));
                          } in (if inp == ['t', 'r']
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hda cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs one_nat))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
       (xml2dp_inputa False xml2name) (xml2dp_nontermination_proof xml2name)
       Infinite_assm_proof xa
else (if inp == ['r', 'e']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == ['u', 'n']
              then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                     xml2unknown_input (xml2unknown_disproof xml2name)
                     Unknown_assm_proof xa
              else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa))))))
            (\ _ -> Rel_TRS_Assume_Not_SN))])
    id x;

xml2trs_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Trs_nontermination_proof a b [Prelude.Char]);
xml2trs_nontermination_proof xml2name x =
  singleton
    ['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
      'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i', 't',
          'i', 'o', 'n', 'V', 'i', 'o', 'l', 'a', 't', 'e', 'd'],
         leaf ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i',
                't', 'i', 'o', 'n', 'V', 'i', 'o', 'l', 'a', 't', 'e', 'd']
           TRS_Not_Well_Formed),
        (['l', 'o', 'o', 'p'],
          change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              TRS_Loop
                (TRS_loop_prf s (map (\ (xa, (y, (_, z))) -> (xa, (y, z))) rseq)
                  sigma c))),
        (['n', 'o', 'n', 'L', 'o', 'o', 'p'],
          change (nonloop xml2name) TRS_Nonloop),
        (['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'n', 'g',
           'S', 'R', 'S'],
          change (nonloop_srs xml2name) TRS_Nonloop_SRS),
        (['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
          pair ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ r -> TRS_Rule_Removal (Rule_removal_nonterm_trs_prf r))),
        (['d', 'p', 'T', 'r', 'a', 'n', 's'],
          triple ['d', 'p', 'T', 'r', 'a', 'n', 's']
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (bool ['m', 'a', 'r', 'k', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l',
                    's'])
            (xml2dp_nontermination_proof xml2name)
            (\ p _ -> TRS_DP_Trans (DP_trans_nontermination_tt_prf p))),
        (['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a', 'l'],
          pair ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a',
                 'l']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ _ -> TRS_String_Reversal)),
        (['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U', 'n', 'a', 'r',
           'y'],
          tuple4
            ['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U', 'n', 'a',
              'r', 'y']
            plain_var (renaming xml2name)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ v ren s ->
              TRS_Constant_String (Const_string_complete_proof v ren s))),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's', 'I',
           'n', 'c', 'r', 'e', 'a', 's', 'e'],
          pair ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's',
                 'I', 'n', 'c', 'r', 'e', 'a', 's', 'e']
            (innermostLhss xml2name) (xml2trs_nontermination_proof xml2name)
            (\ q -> TRS_Q_Increase (Q_increase_nonterm_trs_prf q))),
        (['s', 'w', 'i', 't', 'c', 'h', 'F', 'u', 'l', 'l', 'S', 't', 'r', 'a',
           't', 'e', 'g', 'y'],
          pair ['s', 'w', 'i', 't', 'c', 'h', 'F', 'u', 'l', 'l', 'S', 't', 'r',
                 'a', 't', 'e', 'g', 'y']
            (wcr_proof xml2name) (xml2trs_nontermination_proof xml2name)
            TRS_Termination_Switch),
        (['u', 'n', 'c', 'u', 'r', 'r', 'y'],
          triple ['u', 'n', 'c', 'u', 'r', 'r', 'y'] (uncurry_info xml2name)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ i r -> TRS_Uncurry (Uncurry_nt_proof i r))),
        (['n', 'o', 't', 'W', 'N', 'T', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm',
           'a', 't', 'o', 'n'],
          change (not_wn_ta xml2name) TRS_Not_WN_Tree_Automaton),
        (['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
           'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
              'n', 'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2inn_nt_trs_assm xml2name)
            (\ qtrs -> TRS_Assume_Not_SN qtrs [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2inn_nt_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs)
                             (nat_of_integer (2 :: Integer)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (nat_of_integer (2 :: Integer))
                                    (tag (nth cs one_nat));
                          } in (if inp == ['t', 'r']
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hda cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs one_nat))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
       (xml2dp_inputa False xml2name) (xml2dp_nontermination_proof xml2name)
       Infinite_assm_proof xa
else (if inp == ['r', 'e']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == ['u', 'n']
              then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                     xml2unknown_input (xml2unknown_disproof xml2name)
                     Unknown_assm_proof xa
              else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa))))))
            (\ _ -> TRS_Assume_Not_SN))])
    id x;

xml2fp_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Fp_nontermination_proof a b [Prelude.Char]);
xml2fp_nontermination_proof xml2name x =
  singleton
    ['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
      'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['l', 'o', 'o', 'p'],
         change (loop xml2name)
           (\ (s, (rseq, (sigma, c))) ->
             FPTRS_Loop
               (FP_loop_prf c sigma s
                 (map (\ (xa, (y, (_, z))) -> (xa, (y, z))) rseq)))),
        (['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
          pair ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2fp_nontermination_proof xml2name)
            (\ r -> FPTRS_Rule_Removal (Rule_removal_nonterm_trs_prf r))),
        (['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
           'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
              'n', 'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2fp_nt_trs_assm xml2name)
            (\ qtrs -> FPTRS_Assume_Not_SN qtrs [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2fp_nt_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs)
                             (nat_of_integer (2 :: Integer)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (nat_of_integer (2 :: Integer))
                                    (tag (nth cs one_nat));
                          } in (if inp == ['t', 'r']
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hda cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs one_nat))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
       (xml2dp_inputa False xml2name) (xml2dp_nontermination_proof xml2name)
       Infinite_assm_proof xa
else (if inp == ['r', 'e']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == ['u', 'n']
              then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                     xml2unknown_input (xml2unknown_disproof xml2name)
                     Unknown_assm_proof xa
              else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa))))))
            (\ _ -> FPTRS_Assume_Not_SN))])
    id x;

xml2dp_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Dp_nontermination_proof a b [Prelude.Char]);
xml2dp_nontermination_proof xml2name x =
  singleton
    ['d', 'p', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
      'n', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
         guard (\ xa ->
                 equal_nat (num_children xa) (nat_of_integer (3 :: Integer)))
           (triple
             ['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
             (singleton ['d', 'p', 's'] (rules xml2name) Just)
             (singleton ['t', 'r', 's'] (rules xml2name) Just)
             (xml2dp_nontermination_proof xml2name)
             (\ p r -> DP_Rule_Removal (Rule_removal_nonterm_dp_prf p r)))
           (choice
             ['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
             [pair ['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a',
                     'l']
                (singleton ['t', 'r', 's'] (rules xml2name) Just)
                (xml2dp_nontermination_proof xml2name)
                (\ r ->
                  DP_Rule_Removal (Rule_removal_nonterm_dp_prf Nothing r)),
               pair ['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a',
                      'l']
                 (singleton ['d', 'p', 's'] (rules xml2name) Just)
                 (xml2dp_nontermination_proof xml2name)
                 (\ p ->
                   DP_Rule_Removal (Rule_removal_nonterm_dp_prf p Nothing))])),
        (['l', 'o', 'o', 'p'],
          change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              DP_Loop (DP_loop_prf s rseq sigma c))),
        (['n', 'o', 'n', 'L', 'o', 'o', 'p'],
          change (nonloop xml2name) DP_Nonloop),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's', 'R',
           'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c'],
          pair ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's',
                 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c']
            (innermostLhss xml2name) (xml2dp_nontermination_proof xml2name)
            (\ q -> DP_Q_Reduction (DP_q_reduction_nonterm_prf q))),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's', 'I',
           'n', 'c', 'r', 'e', 'a', 's', 'e', 'P', 'r', 'o', 'c'],
          pair ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's',
                 'I', 'n', 'c', 'r', 'e', 'a', 's', 'e', 'P', 'r', 'o', 'c']
            (innermostLhss xml2name) (xml2dp_nontermination_proof xml2name)
            (\ q -> DP_Q_Increase (Q_increase_nonterm_dp_prf q))),
        (['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n', 'P',
           'r', 'o', 'c'],
          pair ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                 'P', 'r', 'o', 'c']
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (xml2dp_nontermination_proof xml2name)
            (\ p -> DP_Instantiation (Instantiation_complete_proc_prf p))),
        (['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 'P', 'r', 'o', 'c'],
          tuple4
            ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 'P', 'r', 'o', 'c']
            (rule xml2name) pos
            (singleton ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 's']
              (rules xml2name) id)
            (xml2dp_nontermination_proof xml2name)
            (\ st po p -> DP_Narrowing (Narrowing_complete_proc_prf st po p))),
        (['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o', 'c'],
          guard (\ xa ->
                  equal_nat (num_children xa) (nat_of_integer (3 :: Integer)))
            (triple
              ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o', 'c']
              (rule xml2name) (rstep xml2name)
              (xml2dp_nontermination_proof xml2name)
              (\ (s, t) (p, (lr, ta)) ->
                DP_Rewriting
                  (Rewriting_complete_proc_prf Nothing (s, t) (s, ta) (s, ta) lr
                    p)))
            (guard
              (\ xa ->
                equal_nat (num_children xa) (nat_of_integer (4 :: Integer)))
              (guard
                (\ xa ->
                  tag (nth (children xa) (nat_of_integer (2 :: Integer))) ==
                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's'])
                (tuple4
                  ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                    'c']
                  (rule xml2name) (rstep xml2name)
                  (singleton
                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                    (rules xml2name) id)
                  (xml2dp_nontermination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) u ->
                    DP_Rewriting
                      (Rewriting_complete_proc_prf (Just u) (s, t) (s, ta)
                        (s, ta) lr p)))
                (tuple4
                  ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                    'c']
                  (rule xml2name) (rstep xml2name) (rule xml2name)
                  (xml2dp_nontermination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) st ->
                    DP_Rewriting
                      (Rewriting_complete_proc_prf Nothing (s, t) (s, ta) st lr
                        p))))
              (tuple5
                ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                  'c']
                (rule xml2name) (rstep xml2name) (rule xml2name)
                (singleton
                  ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                  (rules xml2name) id)
                (xml2dp_nontermination_proof xml2name)
                (\ (s, t) (p, (lr, ta)) st u ->
                  DP_Rewriting
                    (Rewriting_complete_proc_prf (Just u) (s, t) (s, ta) st lr
                      p))))),
        (['s', 'w', 'i', 't', 'c', 'h', 'F', 'u', 'l', 'l', 'S', 't', 'r', 'a',
           't', 'e', 'g', 'y', 'P', 'r', 'o', 'c'],
          pair ['s', 'w', 'i', 't', 'c', 'h', 'F', 'u', 'l', 'l', 'S', 't', 'r',
                 'a', 't', 'e', 'g', 'y', 'P', 'r', 'o', 'c']
            (wcr_proof xml2name) (xml2dp_nontermination_proof xml2name)
            DP_Termination_Switch),
        (['i', 'n', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', 'A', 's',
           's', 'u', 'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['i', 'n', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', 'A',
              's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2dp_inputa False xml2name)
            (\ qdp -> DP_Assume_Infinite qdp [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2dp_inputa False xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs)
                             (nat_of_integer (2 :: Integer)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (nat_of_integer (2 :: Integer))
                                    (tag (nth cs one_nat));
                          } in (if inp == ['t', 'r']
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hda cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs one_nat))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
       (xml2dp_inputa False xml2name) (xml2dp_nontermination_proof xml2name)
       Infinite_assm_proof xa
else (if inp == ['r', 'e']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == ['u', 'n']
              then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                     xml2unknown_input (xml2unknown_disproof xml2name)
                     Unknown_assm_proof xa
              else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa))))))
            (\ _ -> DP_Assume_Infinite))])
    id x;

xml2unknown_disproof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Neg_unknown_proof a b [Prelude.Char]);
xml2unknown_disproof xml2name x =
  singleton
    ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't', 'P', 'r', 'o',
      'o', 'f']
    (options
      [(['u', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 's', 's', 'u', 'm', 'p', 't',
          'i', 'o', 'n'],
         singleton
           ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 's', 's', 'u', 'm', 'p',
             't', 'i', 'o', 'n']
           xml2unknown_input (\ u -> Assume_NT_Unknown u [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            xml2unknown_input
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs)
                             (nat_of_integer (2 :: Integer)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (nat_of_integer (2 :: Integer))
                                    (tag (nth cs one_nat));
                          } in (if inp == ['t', 'r']
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hda cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs one_nat))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
       (xml2dp_inputa False xml2name) (xml2dp_nontermination_proof xml2name)
       Infinite_assm_proof xa
else (if inp == ['r', 'e']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == ['u', 'n']
              then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                     xml2unknown_input (xml2unknown_disproof xml2name)
                     Unknown_assm_proof xa
              else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa))))))
            (\ _ -> Assume_NT_Unknown))])
    id x;

xml2quasi_reductive_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Quasi_reductive_proof a [Nat] [Prelude.Char]);
xml2quasi_reductive_proof xml2name =
  singleton
    ['q', 'u', 'a', 's', 'i', 'R', 'e', 'd', 'u', 'c', 't', 'i', 'v', 'e', 'P',
      'r', 'o', 'o', 'f']
    (options
      [(['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g'],
         pair ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g']
           (unraveling_info xml2name) (xml2trs_termination_proof xml2name)
           Unravel)])
    id;

map_r_states :: forall a b c. (a -> b) -> Ta_rule a c -> Ta_rule b c;
map_r_states f r = TA_rule (r_root r) (map f (r_lhs_states r)) (f (r_rhs r));

map_states_impl ::
  forall a b c. (a -> b) -> Tree_automaton a c -> Tree_automaton b c;
map_states_impl f (Tree_Automaton qs ts eps) =
  Tree_Automaton (map f qs) (map (map_r_states f) ts)
    (map (\ (p, q) -> (f p, f q)) eps);

xml2nonreachable_etac_info ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Nonreachability_proof a [Prelude.Char]);
xml2nonreachable_etac_info xml2name =
  tuple5
    ['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'E', 't', 'a',
      'c']
    (signature xml2name) xml2name xml2name
    (tree_automaton (ta_normal_lhs xml2name)) (xml2state_map xml2name)
    (\ f a c aa m -> Nonreachable_ETAC f a c (map_states_impl m aa));

xml2nonreachability_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Nonreachability_proof a [Prelude.Char]);
xml2nonreachability_proof xml2name x =
  singleton
    ['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'i', 'l', 'i', 't', 'y',
      'P', 'r', 'o', 'o', 'f']
    (options
      [(['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'T', 'c',
          'a', 'p'],
         leaf ['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'T',
                'c', 'a', 'p']
           Nonreachable_Tcap),
        (['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'E', 't',
           'a', 'c'],
          xml2nonreachable_etac_info xml2name),
        (['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'S', 'u',
           'b', 's', 't', 'A', 'p', 'p', 'r', 'o', 'x'],
          pair ['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'S',
                 'u', 'b', 's', 't', 'A', 'p', 'p', 'r', 'o', 'x']
            (rules xml2name) (xml2nonreachability_proof xml2name)
            Nonreachable_Subst_Approx),
        (['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'R', 'e',
           'v', 'e', 'r', 's', 'e'],
          singleton
            ['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'R',
              'e', 'v', 'e', 'r', 's', 'e']
            (xml2nonreachability_proof xml2name) Nonreachable_Reverse)])
    id x;

xml2nonjoinability_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Nonjoinability_proof a [Prelude.Char]);
xml2nonjoinability_proof xml2name =
  singleton
    ['n', 'o', 'n', 'j', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't', 'y', 'P',
      'r', 'o', 'o', 'f']
    (options
      [(['n', 'o', 'n', 'j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'T', 'c', 'a',
          'p'],
         leaf ['n', 'o', 'n', 'j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'T', 'c',
                'a', 'p']
           Nonjoinable_Tcap),
        (['n', 'o', 'n', 'j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'G', 'r', 'o',
           'u', 'n', 'd', 'N', 'F'],
          change (xml2nonreachability_proof xml2name) Nonjoinable_Ground_NF)])
    id;

xml2infeasibility_proof ::
  forall a.
    (Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Infeasibility_proof (Lab a [Nat]) [Prelude.Char]);
xml2infeasibility_proof xml2name x =
  singleton
    ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'i', 'l', 'i', 't', 'y', 'P', 'r',
      'o', 'o', 'f']
    (options
      [(['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'o', 'm', 'p',
          'o', 'u', 'n', 'd', 'C', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's'],
         pair ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'o', 'm',
                'p', 'o', 'u', 'n', 'd', 'C', 'o', 'n', 'd', 'i', 't', 'i', 'o',
                'n', 's']
           xml2name (xml2nonreachability_proof xml2name)
           Infeasible_Compound_Conditions),
        (['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'E', 'q', 'u', 'a',
           't', 'i', 'o', 'n'],
          pair ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'E', 'q', 'u',
                 'a', 't', 'i', 'o', 'n']
            (rule xml2name) (xml2nonreachability_proof xml2name)
            (\ (a, b) -> Infeasible_Equation a b)),
        (['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'S', 'u', 'b', 's',
           'e', 't'],
          pair ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'S', 'u', 'b',
                 's', 'e', 't']
            (rules xml2name) (xml2infeasibility_proof xml2name)
            Infeasible_Subset),
        (['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'R', 'h', 's', 's',
           'E', 'q', 'u', 'a', 'l'],
          tuple4
            ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'R', 'h', 's',
              's', 'E', 'q', 'u', 'a', 'l']
            (term xml2name) (term xml2name) (term xml2name)
            (xml2nonjoinability_proof xml2name) Infeasible_Rhss_Equal)])
    id x;

xml2ao_infeasibility_proof ::
  forall a.
    (Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Ao_infeasibility_proof (Lab a [Nat]) [Prelude.Char]);
xml2ao_infeasibility_proof xml2name =
  singleton
    ['a', 'o', 'I', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'i', 'l', 'i', 't', 'y',
      'P', 'r', 'o', 'o', 'f']
    (options
      [(['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'i', 'l', 'i', 't', 'y', 'P',
          'r', 'o', 'o', 'f'],
         change (xml2infeasibility_proof xml2name) AO_Infeasibility_Proof),
        (['a', 'o', 'L', 'h', 's', 's', 'E', 'q', 'u', 'a', 'l'],
          tuple4 ['a', 'o', 'L', 'h', 's', 's', 'E', 'q', 'u', 'a', 'l']
            (term xml2name) (term xml2name) (term xml2name)
            (xml2nonjoinability_proof xml2name) AO_Lhss_Equal)])
    id;

xml2ao_infeasible_conds ::
  forall a.
    (Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     [([(Term (Lab a [Nat]) [Prelude.Char],
                          Term (Lab a [Nat]) [Prelude.Char])],
                        ([(Term (Lab a [Nat]) [Prelude.Char],
                            Term (Lab a [Nat]) [Prelude.Char])],
                          Ao_infeasibility_proof (Lab a [Nat])
                            [Prelude.Char]))];
xml2ao_infeasible_conds xml2name =
  many ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'o', 'n', 'd',
         'i', 't', 'i', 'o', 'n', 's']
    (triple
      ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'o', 'n', 'd',
        'i', 't', 'i', 'o', 'n']
      (rules xml2name) (rules xml2name) (xml2ao_infeasibility_proof xml2name)
      (\ cs_1 cs_2 p -> (cs_1, (cs_2, p))))
    id;

xml2conditional_cr_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Conditional_cr_proof a [Nat] [Prelude.Char]);
xml2conditional_cr_proof xml2name =
  singleton
    ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'r', 'P', 'r',
      'o', 'o', 'f']
    (options
      [(['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g'],
         pair ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g']
           (unraveling_info xml2name) (xml2cr_proof xml2name) Unravel_CR),
        (['a', 'l', 'm', 'o', 's', 't', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
           'a', 'l'],
          leaf ['a', 'l', 'm', 'o', 's', 't', 'O', 'r', 't', 'h', 'o', 'g', 'o',
                 'n', 'a', 'l']
            Almost_Orthogonal_CR),
        (['a', 'l', 'm', 'o', 's', 't', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
           'a', 'l', 'M', 'o', 'd', 'u', 'l', 'o', 'I', 'n', 'f', 'e', 'a', 's',
           'i', 'b', 'i', 'l', 'i', 't', 'y'],
          singleton
            ['a', 'l', 'm', 'o', 's', 't', 'O', 'r', 't', 'h', 'o', 'g', 'o',
              'n', 'a', 'l', 'M', 'o', 'd', 'u', 'l', 'o', 'I', 'n', 'f', 'e',
              'a', 's', 'i', 'b', 'i', 'l', 'i', 't', 'y']
            (xml2ao_infeasible_conds xml2name)
            Almost_Orthogonal_Modulo_Infeasibility_CRa)])
    id;

xml2ac_dp_termination_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Ac_dp_termination_proof a [Prelude.Char]);
xml2ac_dp_termination_proof xml2name x =
  singleton
    ['a', 'c', 'D', 'P', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
      'P', 'r', 'o', 'o', 'f']
    (options
      [(['a', 'c', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c'],
         tuple4
           ['a', 'c', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c']
           (ordering_constraint_proof False xml2name)
           (singleton ['d', 'p', 's'] (rules xml2name) id)
           (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
             (rules xml2name) id)
           (xml2ac_dp_termination_proof xml2name) AC_Redpair_UR_Proc),
        (['a', 'c', 'S', 'u', 'b', 't', 'e', 'r', 'm', 'P', 'r', 'o', 'c'],
          triple
            ['a', 'c', 'S', 'u', 'b', 't', 'e', 'r', 'm', 'P', 'r', 'o', 'c']
            (multiset_af xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (xml2ac_dp_termination_proof xml2name) AC_Subterm_Proc),
        (['a', 'c', 'T', 'r', 'i', 'v', 'i', 'a', 'l', 'P', 'r', 'o', 'c'],
          leaf ['a', 'c', 'T', 'r', 'i', 'v', 'i', 'a', 'l', 'P', 'r', 'o', 'c']
            AC_P_is_Empty),
        (['a', 'c', 'M', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P',
           'r', 'o', 'c'],
          tuple5
            ['a', 'c', 'M', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r',
              'P', 'r', 'o', 'c']
            (ordering_constraint_proof False xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
              (rules xml2name) id)
            (xml2ac_dp_termination_proof xml2name) AC_Mono_Redpair_UR_Proc),
        (['a', 'c', 'D', 'e', 'p', 'G', 'r', 'a', 'p', 'h', 'P', 'r', 'o', 'c'],
          many ['a', 'c', 'D', 'e', 'p', 'G', 'r', 'a', 'p', 'h', 'P', 'r', 'o',
                 'c']
            (xml2nd_choice ['c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't']
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              ['r', 'e', 'a', 'l', 'S', 'c', 'c']
              (xml2ac_dp_termination_proof xml2name)
              (\ dps prfOpt -> (prfOpt, dps)))
            AC_Dep_Graph_Proc)])
    id x;

xml2ac_termination_proof ::
  forall a b.
    (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
      Xml -> Sum_bot [Prelude.Char] (Ac_termination_proof a b [Prelude.Char]);
xml2ac_termination_proof xml2name x =
  singleton
    ['a', 'c', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r',
      'o', 'o', 'f']
    (options
      [(['a', 'c', 'D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', 'P', 'a',
          'i', 'r', 's'],
         guard (\ xa ->
                 equal_nat (num_children xa) (nat_of_integer (6 :: Integer)))
           (tuple6
             ['a', 'c', 'D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', 'P',
               'a', 'i', 'r', 's']
             (singleton ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's']
               (rules xml2name) id)
             (singleton ['d', 'p', 'E', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's']
               (rules xml2name) id)
             (singleton ['d', 'p', 's'] (rules xml2name) id)
             (singleton ['e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', 's']
               (rules xml2name) id)
             (xml2ac_dp_termination_proof xml2name)
             (xml2ac_dp_termination_proof xml2name)
             (\ e dpe dp rext ->
               AC_DP_Trans (AC_dependency_pairs_proof e dp dpe rext)))
           (tuple5
             ['a', 'c', 'D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', 'P',
               'a', 'i', 'r', 's']
             (singleton ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's']
               (rules xml2name) id)
             (singleton ['d', 'p', 'E', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's']
               (rules xml2name) id)
             (singleton ['d', 'p', 's'] (rules xml2name) id)
             (singleton ['e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', 's']
               (rules xml2name) id)
             (xml2ac_dp_termination_proof xml2name)
             (\ e dpe dp rext ->
               AC_DP_Trans_Single (AC_dependency_pairs_proof e dp dpe rext)))),
        (['a', 'c', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
          triple
            ['a', 'c', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
            (ordering_constraint_proof False xml2name)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2ac_termination_proof xml2name) AC_Rule_Removal),
        (['a', 'c', 'R', 'I', 's', 'E', 'm', 'p', 't', 'y'],
          leaf ['a', 'c', 'R', 'I', 's', 'E', 'm', 'p', 't', 'y']
            AC_R_is_Empty)])
    id x;

subsumption_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]),
             [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                      (Bool, Term a [Prelude.Char])))])];
subsumption_proof xml2name =
  many ['s', 'u', 'b', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 'P', 'r', 'o',
         'o', 'f']
    (pair ['r', 'u', 'l', 'e', 'S', 'u', 'b', 's', 'u', 'm', 'p', 't', 'i', 'o',
            'n', 'P', 'r', 'o', 'o', 'f']
      (rule xml2name) (conversion xml2name) (\ r (_, a) -> (r, a)))
    id;

xml2completion_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Completion_proof a [Nat] [Prelude.Char]);
xml2completion_proof xml2name =
  triple
    ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (wcr_proof xml2name) (xml2trs_termination_proof xml2name)
    (xml1to2elements
      ['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e', 'P', 'r', 'o',
        'o', 'f']
      (subsumption_proof xml2name) (subsumption_proof xml2name)
      (\ a b -> (a, b)))
    (\ w t (a, b) -> SN_WCR_Eq w t a b);

xml2equational_disproof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Equational_disproof a [Nat] [Prelude.Char]);
xml2equational_disproof xml2name =
  singleton
    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'D', 'i', 's', 'p', 'r',
      'o', 'o', 'f']
    (options
      [(['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'A', 'n', 'd', 'N',
          'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n'],
         pair ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'A', 'n', 'd',
                'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n']
           (singleton ['t', 'r', 's'] (rules xml2name) id)
           (xml2completion_proof xml2name)
           Completion_and_Normalization_Different)])
    id;

xml2equational_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Equational_proof a [Nat] [Prelude.Char]);
xml2equational_proof xml2name =
  singleton
    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o', 'o',
          'f', 'T', 'r', 'e', 'e'],
         singleton
           ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o',
             'o', 'f', 'T', 'r', 'e', 'e']
           (xml2eq_proof xml2name) Equational_Proof_Tree),
        (['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n'],
          change (conversion xml2name) (\ (_, a) -> Conversion a)),
        (['s', 'u', 'b', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 'P', 'r', 'o',
           'o', 'f'],
          change (subsumption_proof xml2name) Conversion_With_History),
        (['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'A', 'n', 'd', 'N',
           'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n'],
          pair ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'A', 'n', 'd',
                 'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o',
                 'n']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2completion_proof xml2name) Completion_and_Normalization)])
    id;

xml2complexity_inputa ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     ([Term (Lab a b) [Prelude.Char]],
                       ([(Term (Lab a b) [Prelude.Char],
                           Term (Lab a b) [Prelude.Char])],
                         ([(Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char])],
                           (Complexity_measure (Lab a b) [Prelude.Char],
                             Complexity_class))));
xml2complexity_inputa xml2name =
  change (xml2complexity_input xml2name)
    (\ (q, (s, (w, (cm, cc)))) ->
      (strategy_to_Q q (s ++ rel_rules_of w), (s, (rel_rules_of w, (cm, cc)))));

xml2complexity_proof ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char] (Complexity_proof a b [Prelude.Char]);
xml2complexity_proof xml2name x =
  singleton
    ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['r', 'u', 'l', 'e', 'S', 'h', 'i', 'f', 't', 'i', 'n', 'g'],
         guard (\ xa ->
                 equal_nat (num_children xa) (nat_of_integer (3 :: Integer)))
           (triple ['r', 'u', 'l', 'e', 'S', 'h', 'i', 'f', 't', 'i', 'n', 'g']
             (ordering_constraint_proof True xml2name)
             (singleton ['t', 'r', 's'] (rules xml2name) id)
             (xml2complexity_proof xml2name)
             (\ rp del -> Rule_Shift_Complexity rp del Nothing))
           (tuple4 ['r', 'u', 'l', 'e', 'S', 'h', 'i', 'f', 't', 'i', 'n', 'g']
             (ordering_constraint_proof True xml2name)
             (singleton ['t', 'r', 's'] (rules xml2name) id)
             (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
               (rules xml2name) Just)
             (xml2complexity_proof xml2name) Rule_Shift_Complexity)),
        (['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's'],
          pair ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
            (singleton
              ['n', 'o', 'n', 'U', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e',
                's']
              (rules xml2name) id)
            (xml2complexity_proof xml2name) Usable_Rules_Complexity),
        (['s', 'p', 'l', 'i', 't'],
          triple ['s', 'p', 'l', 'i', 't']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2complexity_proof xml2name) (xml2complexity_proof xml2name)
            Split_Complexity),
        (['r', 'e', 'm', 'o', 'v', 'e', 'N', 'o', 'n', 'A', 'p', 'p', 'l', 'i',
           'c', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's'],
          pair ['r', 'e', 'm', 'o', 'v', 'e', 'N', 'o', 'n', 'A', 'p', 'p', 'l',
                 'i', 'c', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2complexity_proof xml2name)
            Remove_Nonapplicable_Rules_Complexity),
        (['b', 'o', 'u', 'n', 'd', 's'],
          change (bounds_info xml2name) Matchbounds_Complexity),
        (['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'B', 'o', 'u', 'n', 'd', 's'],
          triple
            ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'B', 'o', 'u', 'n', 'd',
              's']
            (bounds_info xml2name)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2complexity_proof xml2name) Matchbounds_Rel_Complexity),
        (['r', 'I', 's', 'E', 'm', 'p', 't', 'y'],
          leaf ['r', 'I', 's', 'E', 'm', 'p', 't', 'y'] RisEmpty_Complexity),
        (['d', 't', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
           'o', 'n'],
          tuple4
            ['d', 't', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't',
              'i', 'o', 'n']
            (rule_pairs ['s', 't', 'r', 'i', 'c', 't', 'D', 'T', 's']
              ['r', 'u', 'l', 'e', 'W', 'i', 't', 'h', 'D', 'T'] xml2name)
            (rule_pairs ['w', 'e', 'a', 'k', 'D', 'T', 's']
              ['r', 'u', 'l', 'e', 'W', 'i', 't', 'h', 'D', 'T'] xml2name)
            (innermostLhss xml2name) (xml2complexity_proof xml2name)
            (\ s w inn -> DT_Transformation (DT_Transformation_Info s w inn))),
        (['w', 'd', 'p', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't',
           'i', 'o', 'n'],
          tuple5
            ['w', 'd', 'p', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a',
              't', 'i', 'o', 'n']
            (symbols
              ['c', 'o', 'm', 'p', 'o', 'u', 'n', 'd', 'S', 'y', 'm', 'b', 'o',
                'l', 's']
              xml2name)
            (rule_pairs ['s', 't', 'r', 'i', 'c', 't', 'W', 'D', 'P', 's']
              ['r', 'u', 'l', 'e', 'W', 'i', 't', 'h', 'W', 'D', 'P'] xml2name)
            (rule_pairs ['w', 'e', 'a', 'k', 'W', 'D', 'P', 's']
              ['r', 'u', 'l', 'e', 'W', 'i', 't', 'h', 'W', 'D', 'P'] xml2name)
            (innermostLhss xml2name) (xml2complexity_proof xml2name)
            (\ comp s w q ->
              WDP_Transformation (WDP_Trans_Info (set comp) s w q))),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2complexity_inputa xml2name)
            (pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2complexity_inputa xml2name) (xml2complexity_proof xml2name)
              Complexity_assm_proof)
            (\ _ -> Complexity_Assumption)),
        (['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'A', 's', 's', 'u',
           'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'A', 's', 's',
              'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2complexity_inputa xml2name)
            (\ p -> Complexity_Assumption p []))])
    id x;

xml2cert_problem ::
  (Xml -> Sum_bot [Prelude.Char] [Prelude.Char]) ->
    (Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat])) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Cert_problem [Prelude.Char] [Nat] [Prelude.Char]);
xml2cert_problem xml2uname xml2name (XML name egal cs) =
  (if name ==
        ['c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'P',
          'r', 'o', 'b', 'l', 'e', 'm'] &&
        less_eq_nat (nat_of_integer (3 :: Integer)) (size_list cs)
    then binda (xml2input xml2name (nth cs zero_nat))
           (\ inp ->
             binda (text ['c', 'p', 'f', 'V', 'e', 'r', 's', 'i', 'o', 'n']
                     (nth cs one_nat))
               (\ _ ->
                 (case inp of {
                   DP_input (m, (p, (q, r))) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['d', 'p', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2dp_termination_proof xml2name)
                              (DP_Termination_Proof default_nfs_dp m p [] q []
                                r)),
                           (['d', 'p', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i',
                              'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o',
                              'f'],
                             change (xml2dp_nontermination_proof xml2name)
                               (DP_Nontermination_Proof default_nfs_nt_dp m p q
                                 r))])
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   Inn_TRS_input (q, (r, Nothing)) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a',
                             't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2trs_termination_proof xml2name)
                              (TRS_Termination_Proof default_nfs_trs q r
                                Nothing)),
                           (['c', 'r', 'P', 'r', 'o', 'o', 'f'],
                             (if null (strategy_to_Q q r)
                               then change (xml2cr_proof xml2name)
                                      (TRS_Confluence_Proof False r)
                               else (\ _ ->
                                      errora
['s', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ', 'f', 'o', 'r', ' ', 'c',
  'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'u', 'n', 's', 'u', 'p',
  'p', 'o', 'r', 't', 'e', 'd']))),
                           (['c', 'r', 'D', 'i', 's', 'p', 'r', 'o', 'o', 'f'],
                             (if null (strategy_to_Q q r)
                               then change (xml2ncr_proof xml2name)
                                      (TRS_Non_Confluence_Proof False r)
                               else (\ _ ->
                                      errora
['s', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ', 'f', 'o', 'r', ' ', 'c',
  'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'u', 'n', 's', 'u', 'p',
  'p', 'o', 'r', 't', 'e', 'd']))),
                           (['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm',
                              'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o',
                              'o', 'f'],
                             change (xml2trs_nontermination_proof xml2name)
                               (TRS_Nontermination_Proof default_nfs_trs q r))])
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   Inn_TRS_input (q, (r, Just s)) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e',
                             'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'P',
                             'r', 'o', 'o', 'f'],
                            change (xml2trs_termination_proof xml2name)
                              (TRS_Termination_Proof default_nfs_trs q r
                                (Just s))),
                           (['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'N', 'o',
                              'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                              'o', 'n', 'P', 'r', 'o', 'o', 'f'],
                             change (xml2reltrs_nontermination_proof xml2name)
                               (Relative_TRS_Nontermination_Proof
                                 default_nfs_trs q r s))])
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   COMP_input (e, r) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n',
                             'P', 'r', 'o', 'o', 'f'],
                            change (xml2completion_proof xml2name)
                              (Completion_Proof e r))])
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   EQ_input (eqs, eq) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l',
                             'P', 'r', 'o', 'o', 'f'],
                            change (xml2equational_proof xml2name)
                              (Equational_Proof eqs eq)),
                           (['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l',
                              'D', 'i', 's', 'p', 'r', 'o', 'o', 'f'],
                             change (xml2equational_disproof xml2name)
                               (Equational_Disproof eqs eq))])
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   CPX_input (q, (r, (s, (cm, cc)))) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (change (xml2complexity_proof xml2name)
                         (Complexity_Proof q r s cm cc))
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   FP_TRS_input (Outermost, r) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a',
                             't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2fptrs_termination_proof xml2name)
                              (Outermost_Termination_Proof r)),
                           (['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm',
                              'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o',
                              'o', 'f'],
                             change (xml2fp_nontermination_proof xml2name)
                               (Outermost_Nontermination_Proof r))])
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   FP_TRS_input (Context_Sensitive mu, r) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a',
                             't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2fptrs_termination_proof xml2name)
                              (CS_Termination_Proof mu r)),
                           (['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm',
                              'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o',
                              'o', 'f'],
                             change (xml2fp_nontermination_proof xml2name)
                               (CS_Nontermination_Proof mu r))])
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   FP_TRS_input (Forbidden_Patterns p, r) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a',
                             't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2fptrs_termination_proof xml2name)
                              (FP_Termination_Proof p r)),
                           (['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm',
                              'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o',
                              'o', 'f'],
                             change (xml2fp_nontermination_proof xml2name)
                               (FP_Nontermination_Proof p r))])
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   CTRS_input ctrs ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['q', 'u', 'a', 's', 'i', 'R', 'e', 'd', 'u', 'c',
                             't', 'i', 'v', 'e', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2quasi_reductive_proof xml2name)
                              (Quasi_Reductive_Proof ctrs)),
                           (['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a',
                              'l', 'C', 'r', 'P', 'r', 'o', 'o', 'f'],
                             change (xml2conditional_cr_proof xml2name)
                               (Conditional_CR_Proof ctrs))])
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   TA_input ta r ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (singleton
                         ['t', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't',
                           'o', 'n', 'C', 'l', 'o', 's', 'e', 'd', 'P', 'r',
                           'o', 'o', 'f']
                         closed_criterion (Tree_Automata_Closed_Proof ta r))
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   AC_input r a c ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (change (xml2ac_termination_proof xml2name)
                         (AC_Termination_Proof r a c))
                       id (nth cs (nat_of_integer (2 :: Integer)));
                   Unknown_input u ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (choice
                         ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u',
                           't']
                         [change (xml2unknown_proof xml2name) (Unknown_Proof u),
                           change (xml2unknown_disproof xml2name)
                             (Unknown_Disproof u)])
                       id (nth cs (nat_of_integer (2 :: Integer)));
                 })))
    else errora
           (['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'p', 'a', 'r',
              's', 'e', ' ', 'r', 'o', 'o', 't', ' ', 'e', 'l', 'e', 'm', 'e',
              'n', 't', ' ', '<'] ++
             name ++ ['>']));
xml2cert_problem uu uv (XML_text v) =
  fail ['c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'P',
         'r', 'o', 'b', 'l', 'e', 'm']
    (XML_text v);

xml_complexity_measure ::
  forall a b c. (Showa a, Showa b) => Complexity_measure (Lab a [b]) c -> Xml;
xml_complexity_measure (Derivational_Complexity f) =
  XML ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o',
        'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
    [] [xml_signature f];
xml_complexity_measure (Runtime_Complexity c d) =
  XML ['r', 'u', 'n', 't', 'i', 'm', 'e', 'C', 'o', 'm', 'p', 'l', 'e', 'x',
        'i', 't', 'y']
    [] [xml_signature c, xml_signature d];

xml_complexity_class :: Complexity_class -> Xml;
xml_complexity_class (Comp_Poly n) =
  XML ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l'] []
    [XML_text (shows_prec_nat zero_nat n [])];

xml_cert_problem ::
  forall a b c. (Showa a, Showa b, Showa c) => Cert_problem a [b] c -> Xml;
xml_cert_problem (TRS_Termination_Proof nfs q r s_o uu) =
  xml_trs_input (Inl q) r s_o;
xml_cert_problem (TRS_Nontermination_Proof nfs q r uv) =
  xml_trs_input (Inl q) r Nothing;
xml_cert_problem (Outermost_Nontermination_Proof r uw) =
  xml_trs_input (Inr Outermost) r Nothing;
xml_cert_problem (Outermost_Termination_Proof r ux) =
  xml_trs_input (Inr Outermost) r Nothing;
xml_cert_problem (FP_Nontermination_Proof p r uy) =
  xml_trs_input (Inr (Forbidden_Patterns p)) r Nothing;
xml_cert_problem (FP_Termination_Proof p r uz) =
  xml_trs_input (Inr (Forbidden_Patterns p)) r Nothing;
xml_cert_problem (CS_Nontermination_Proof mu r va) =
  xml_trs_input (Inr (Context_Sensitive mu)) r Nothing;
xml_cert_problem (CS_Termination_Proof mu r vb) =
  xml_trs_input (Inr (Context_Sensitive mu)) r Nothing;
xml_cert_problem (Relative_TRS_Nontermination_Proof nfs q r s vc) =
  xml_trs_input (Inl q) r (Just s);
xml_cert_problem (DP_Termination_Proof nfs m p pw q r rw vd) =
  XML ['d', 'p', 'I', 'n', 'p', 'u', 't'] []
    (xml_rules ['t', 'r', 's'] rw :
      xml_rules ['d', 'p', 's'] p :
        xml_strategy (Inl q) ++
          [XML ['m', 'i', 'n', 'i', 'm', 'a', 'l'] []
             [XML_text
                (if m then ['t', 'r', 'u', 'e']
                  else ['f', 'a', 'l', 's', 'e'])]]);
xml_cert_problem (DP_Nontermination_Proof nfs m p q r ve) =
  XML ['d', 'p', 'I', 'n', 'p', 'u', 't'] []
    (xml_rules ['t', 'r', 's'] r :
      xml_rules ['d', 'p', 's'] p :
        xml_strategy (Inl q) ++
          [XML ['m', 'i', 'n', 'i', 'm', 'a', 'l'] []
             [XML_text
                (if m then ['t', 'r', 'u', 'e']
                  else ['f', 'a', 'l', 's', 'e'])]]);
xml_cert_problem (TRS_Confluence_Proof nfs r vf) =
  xml_trs_input (Inl No_Strategy) r Nothing;
xml_cert_problem (TRS_Non_Confluence_Proof nfs r vg) =
  xml_trs_input (Inl No_Strategy) r Nothing;
xml_cert_problem (Completion_Proof e r vh) =
  XML ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'I', 'n', 'p', 'u',
        't']
    [] [xml_rules ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] e,
         xml_rules ['t', 'r', 's'] r];
xml_cert_problem (Equational_Proof e eq vi) =
  XML ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'a', 's',
        'o', 'n', 'i', 'n', 'g', 'I', 'n', 'p', 'u', 't']
    [] [xml_rules ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] e,
         XML ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n'] []
           [xml_term (fst eq), xml_term (snd eq)]];
xml_cert_problem (Equational_Disproof e eq vj) =
  XML ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'a', 's',
        'o', 'n', 'i', 'n', 'g', 'I', 'n', 'p', 'u', 't']
    [] [xml_rules ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] e,
         XML ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n'] []
           [xml_term (fst eq), xml_term (snd eq)]];
xml_cert_problem (Complexity_Proof q r s cm cc vk) =
  XML ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'I', 'n', 'p', 'u',
        't']
    [] [xml_trs_input (Inl q) r s, xml_complexity_measure cm,
         xml_complexity_class cc];
xml_cert_problem (Quasi_Reductive_Proof ctrs vl) = xml_ctrs_input ctrs;
xml_cert_problem (Conditional_CR_Proof ctrs vm) = xml_ctrs_input ctrs;
xml_cert_problem (Tree_Automata_Closed_Proof ta r vn) = xml_ta_input ta r;
xml_cert_problem (AC_Termination_Proof r a c vo) = xml_ac_input r a c;
xml_cert_problem (Unknown_Proof u vp) =
  XML ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't'] []
    [XML_text u];
xml_cert_problem (Unknown_Disproof u vq) =
  XML ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't'] []
    [XML_text u];

impl_ofe ::
  forall b a.
    (Key b) => Ac_dpp b a ->
                 ([(Term b a, Term b a)],
                   ([(Term b a, Term b a)],
                     ([(Term b a, Term b a)],
                       ([(Term b a, Term b a)],
                         ([(Term b a, Term b a)],
                           Rbt (b, Nat) [((), (Term b a, Term b a))])))));
impl_ofe (AC_DPP x) = x;

rw_implb ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
rw_implb (p, (pw, (r, (rw, (e, uu))))) = rw;

rwb :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
rwb xa = rw_implb (impl_ofe xa);

r_implb ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
r_implb (p, (pw, (r, (rw, (e, uu))))) = r;

rb :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
rb xa = r_implb (impl_ofe xa);

e_impl ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
e_impl (p, (pw, (r, (rw, (e, uu))))) = e;

e :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
e xa = e_impl (impl_ofe xa);

eq_rules_non_collapsing :: forall a b. (Key a) => Ac_dpp a b -> Bool;
eq_rules_non_collapsing d = let {
                              t = all (\ (_, r) -> not (is_Var r));
                            } in t (rb d) && t (rwb d) && t (e d);

eq_rules_no_left_var :: forall a b. (Key a) => Ac_dpp a b -> Bool;
eq_rules_no_left_var d = let {
                           t = all (\ (l, _) -> not (is_Var l));
                         } in t (rb d) && t (rwb d) && t (e d);

mk_implb ::
  forall a b.
    (Eq a, Key a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     [(Term a b, Term a b)] ->
                       [(Term a b, Term a b)] ->
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   Rbt (a, Nat)
                                     [((), (Term a b, Term a b))])))));
mk_implb p pw r rw e =
  (p, (pw, (r, (rw, (e, insert_rules () (r ++ rw ++ e) empty)))));

delete_pairs_rules_impl ::
  forall a b.
    (Eq a, Key a,
      Eq b) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               Rbt (a, Nat) [((), (Term a b, Term a b))])))));
delete_pairs_rules_impl (p, (pw, (r, (rw, (e, m))))) pd rd =
  (if null rd then (list_diff p pd, (list_diff pw pd, (r, (rw, (e, m)))))
    else mk_implb (list_diff p pd) (list_diff pw pd) (list_diff r rd)
           (list_diff rw rd) e);

delete_pairs_rules ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Ac_dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Ac_dpp a b;
delete_pairs_rules xc xd xe =
  AC_DPP (delete_pairs_rules_impl (impl_ofe xc) xd xe);

reverse_rules_mapa ::
  forall a b. (Eq a, Key a) => Ac_dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_mapa d fn =
  concatMap (\ (l, r) -> (if root r == Just fn then [(r, l)] else []))
    (rb d ++ rwb d ++ e d);

intersect_pairs_impla ::
  forall a b.
    (Eq a, Key a,
      Eq b) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             Rbt (a, Nat) [((), (Term a b, Term a b))])))));
intersect_pairs_impla (p, (pw, (r, (rw, (e, m))))) pd =
  (list_inter p pd, (list_inter pw pd, (r, (rw, (e, m)))));

intersect_pairsa ::
  forall a b.
    (Eq a, Key a, Eq b) => Ac_dpp a b -> [(Term a b, Term a b)] -> Ac_dpp a b;
intersect_pairsa xb xc = AC_DPP (intersect_pairs_impla (impl_ofe xb) xc);

rules_map_implb ::
  forall a b.
    (Key a) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
rules_map_implb (p, (pw, (r, (rw, (e, m))))) fn = (case lookup m fn of {
            Nothing -> [];
            Just a -> map snd a;
          });

rules_mapb ::
  forall a b. (Key a) => Ac_dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_mapb xa = rules_map_implb (impl_ofe xa);

ac_dpp_impl ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 (Set (Term a b, Term a b),
                   (Set (Term a b, Term a b),
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b), Set (Term a b, Term a b)))));
ac_dpp_impl (p, (pw, (r, (rw, (e, uu))))) =
  (set p, (set pw, (set r, (set rw, set e))));

ac_dpp ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => Ac_dpp a b ->
                 (Set (Term a b, Term a b),
                   (Set (Term a b, Term a b),
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b), Set (Term a b, Term a b)))));
ac_dpp xa = ac_dpp_impl (impl_ofe xa);

rules_implc ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
rules_implc (p, (pw, (r, (rw, (e, uu))))) = r ++ rw;

rulesc :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
rulesc xa = rules_implc (impl_ofe xa);

pairs_impla ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
pairs_impla (p, (pw, (r, (rw, (e, uu))))) = p ++ pw;

pairsa :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
pairsa xa = pairs_impla (impl_ofe xa);

mkb ::
  forall a b.
    (Eq a, Key a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     [(Term a b, Term a b)] ->
                       [(Term a b, Term a b)] -> Ac_dpp a b;
mkb xc xd xe xf xg = AC_DPP (mk_implb xc xd xe xf xg);

pw_impla ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
pw_impla (p, (pw, (r, (rw, (e, uu))))) = pw;

pwa :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
pwa xa = pw_impla (impl_ofe xa);

p_impla ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
p_impla (p, (pw, (r, (rw, (e, uu))))) = p;

pa :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
pa xa = p_impla (impl_ofe xa);

ac_dpp_rbt_impl ::
  forall a b.
    (Eq a, Key a, Compare b, Eq b) => Ac_dpp_ops_ext (Ac_dpp a b) a b ();
ac_dpp_rbt_impl =
  Ac_dpp_ops_ext ac_dpp pa pwa pairsa rb rwb rulesc e mkb rules_mapb
    reverse_rules_mapa delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairsa ();

c_rules_impl ::
  forall a. [a] -> [(Term a [Prelude.Char], Term a [Prelude.Char])];
c_rules_impl c = let {
                   x = Var ['x'];
                   y = Var ['y'];
                 } in map (\ f -> (Fun f [x, y], Fun f [y, x])) c;

a_trs_impl :: forall a. [a] -> [(Term a [Prelude.Char], Term a [Prelude.Char])];
a_trs_impl a =
  let {
    x = Var ['x'];
    y = Var ['y'];
    z = Var ['z'];
  } in map (\ f -> (Fun f [Fun f [x, y], z], Fun f [x, Fun f [y, z]])) a ++
         map (\ f -> (Fun f [x, Fun f [y, z]], Fun f [Fun f [x, y], z])) a;

aC_trs_impl ::
  forall a. [a] -> [a] -> [(Term a [Prelude.Char], Term a [Prelude.Char])];
aC_trs_impl a c = a_trs_impl a ++ c_rules_impl c;

ac_tp_list_impl ::
  forall a.
    (Ceq a, Ccompare a, Compare a, Eq a,
      Set_impl a) => Ac_tp_ops_ext
                       ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                         ([a], [a]))
                       a [Prelude.Char] ();
ac_tp_list_impl =
  Ac_tp_ops_ext (\ (r, a) -> let {
                               (aa, c) = a;
                             } in (set r, (set aa, set c)))
    (\ (r, (_, _)) -> r) (\ (_, a) -> let {
(aa, _) = a;
                                      } in aa)
    (\ (_, (_, c)) -> c) (\ r a c -> (r, (a, c)))
    (\ (r, a) -> let {
                   (aa, c) = a;
                 } in (\ dr -> (list_diff r dr, (aa, c))))
    (\ (_, a) -> let {
                   (aa, b) = a;
                 } in aC_trs_impl aa b)
    ();

rules_non_collapsing_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
rules_non_collapsing_impl (uu, (uv, (uw, (ux, (uy, (uz, (nc, va))))))) = nc;

impl_ofd ::
  forall b a.
    (Key b) => Dpp b a ->
                 (Bool,
                   (Bool,
                     ([(Term b a, Term b a)],
                       ([(Term b a, Term b a)],
                         ([Term b a],
                           (Bool,
                             (Bool,
                               ([(Term b a, Term b a)],
                                 ([(Term b a, Term b a)],
                                   (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                                     (Rbt (b, Nat)
[(Bool, (Term b a, Term b a))],
                                       (Bool, Term b a -> Bool))))))))))));
impl_ofd (DPP x) = x;

rules_non_collapsing :: forall a b. (Key a) => Dpp a b -> Bool;
rules_non_collapsing d = rules_non_collapsing_impl (impl_ofd d);

nFQ_subset_NF_rules_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
nFQ_subset_NF_rules_impla (uu, (uv, (uw, (ux, (uy, (b, uz)))))) = b;

nFQ_subset_NF_rulesa :: forall a b. (Key a) => Dpp a b -> Bool;
nFQ_subset_NF_rulesa d = nFQ_subset_NF_rules_impla (impl_ofd d);

rules_no_left_var_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
rules_no_left_var_impl (uu, (uv, (uw, (ux, (uy, (uz, (va, ([], ([], vb)))))))))
  = True;
rules_no_left_var_impl (v, (vb, (ve, (vg, (vi, (vk, (vm, (vq : vr, vp)))))))) =
  False;
rules_no_left_var_impl
  (v, (vb, (ve, (vg, (vi, (vk, (vm, (vo, (vs : vt, vr))))))))) = False;

rules_no_left_var :: forall a b. (Key a) => Dpp a b -> Bool;
rules_no_left_var d = rules_no_left_var_impl (impl_ofd d);

reverse_rules_map_impl ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_map_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (m, ve))))))))))) fn =
  (case lookup m fn of {
    Nothing -> [];
    Just a -> map snd a;
  });

reverse_rules_map ::
  forall a b. (Key a) => Dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_map d = reverse_rules_map_impl (impl_ofd d);

is_NF_trs_subset ::
  forall a b. (Term a b -> Bool) -> [(Term a b, Term a b)] -> Bool;
is_NF_trs_subset is_Q_nf r = is_NF_subset is_Q_nf (map fst r);

wwf_qtrs_impl ::
  forall a b. (Eq b) => (Term a b -> Bool) -> [(Term a b, Term a b)] -> Bool;
wwf_qtrs_impl nf r =
  all (\ ra -> wf_rule ra || not (applicable_rule_impl nf ra)) r;

intersect_rules_impl ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   (Bool,
                     (Bool,
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([Term a b],
                             (Bool,
                               (Bool,
                                 ([(Term a b, Term a b)],
                                   ([(Term a b, Term a b)],
                                     (Rbt (a, Nat)
[(Bool, (Term a b, Term a b))],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Bool, Term a b -> Bool))))))))))));
intersect_rules_impl d ri =
  let {
    (nfs, (mi, (p, (pw, (q, (nfq, (nc, (vR,
 (vRw, (m, (rm, (wwf, isnf))))))))))))
      = d;
    (vri, ria) = partition (is_Var . fst) ri;
    vr = list_inter vR vri;
    vrw = list_inter vRw vri;
    ma = intersect_rules ria m;
    rma = intersect_rules (reverse_rules ri) rm;
    rs = vr ++ vrw ++ map snd (values ma);
  } in (nfs, (mi, (p, (pw, (q, (nfq || is_NF_trs_subset isnf rs,
                                 (nc || all (\ r -> not (is_Var (snd r))) rs,
                                   (vr, (vrw,
  (ma, (rma, (wwf || wwf_qtrs_impl isnf rs, isnf))))))))))));

intersect_rulesa ::
  forall a b.
    (Eq a, Key a, Eq b) => Dpp a b -> [(Term a b, Term a b)] -> Dpp a b;
intersect_rulesa d rs = DPP (intersect_rules_impl (impl_ofd d) rs);

intersect_pairs_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   (Bool,
                     (Bool,
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([Term a b],
                             (Bool,
                               (Bool,
                                 ([(Term a b, Term a b)],
                                   ([(Term a b, Term a b)],
                                     (Rbt (a, Nat)
[(Bool, (Term a b, Term a b))],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Bool, Term a b -> Bool))))))))))));
intersect_pairs_impl (nfs, (mi, (p, (pw, rest)))) ps =
  (nfs, (mi, (list_inter p ps, (list_inter pw ps, rest))));

intersect_pairs ::
  forall a b.
    (Eq a, Key a, Eq b) => Dpp a b -> [(Term a b, Term a b)] -> Dpp a b;
intersect_pairs d ps = DPP (intersect_pairs_impl (impl_ofd d) ps);

replace_pair_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (Term a b, Term a b) ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
replace_pair_impl (nfs, (mi, (p, (pw, rest)))) pair ps =
  (nfs, (mi, (replace_impl pair ps p, (replace_impl pair ps pw, rest))));

replace_pair ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 (Term a b, Term a b) -> [(Term a b, Term a b)] -> Dpp a b;
replace_pair d pair ps = DPP (replace_pair_impl (impl_ofd d) pair ps);

rules_implb ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)];
rules_implb (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vrw, (m, vb)))))))))) =
  vr ++ vrw ++ map snd (values m);

split_rules_impla ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules_impla d rs = partition (membera rs) (rules_implb d);

split_rulesa ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rulesa d = split_rules_impla (impl_ofd d);

pairs_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
pairs_impl (uu, (uv, (p, (pw, uw)))) = p ++ pw;

split_pairs_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_pairs_impl d ps = partition (membera ps) (pairs_impl d);

split_pairs ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_pairs d = split_pairs_impl (impl_ofd d);

delete_R_Rw_impla ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
delete_R_Rw_impla d r rw =
  let {
    (nfs, (mi, (p, (pw, (q, (nfq, (nc, (vR,
 (vRw, (m, (rm, (wwf, isnf))))))))))))
      = d;
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    vra = list_diff vR vr;
    vrwa = list_diff vRw vrw;
    ma = delete_rules True ra (delete_rules False rwa m);
    rma = delete_rules True (reverse_rules r)
            (delete_rules False (reverse_rules rw) rm);
    rs = vra ++ vrwa ++ map snd (values ma);
  } in (nfs, (mi, (p, (pw, (q, (nfq || is_NF_trs_subset isnf rs,
                                 (nc || all (\ rb -> not (is_Var (snd rb))) rs,
                                   (vra, (vrwa,
   (ma, (rma, (wwf || wwf_qtrs_impl isnf rs, isnf))))))))))));

delete_R_Rwa ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Dpp a b;
delete_R_Rwa d r rw = DPP (delete_R_Rw_impla (impl_ofd d) r rw);

delete_P_Pw_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
delete_P_Pw_impl (nfs, (mi, (p, (pw, rest)))) pd pwd =
  (nfs, (mi, (list_diff p pd, (list_diff pw pwd, rest))));

delete_P_Pw ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Dpp a b;
delete_P_Pw d p pw = DPP (delete_P_Pw_impl (impl_ofd d) p pw);

rules_map_impla ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
rules_map_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (m, vd)))))))))) fn
  = (case lookup m fn of {
      Nothing -> [];
      Just a -> map snd a;
    });

rules_mapa ::
  forall a b. (Key a) => Dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_mapa d = rules_map_impla (impl_ofd d);

wwf_rules_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
wwf_rules_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, (wwf, vf)))))))))))) =
  wwf;

wwf_rules :: forall a b. (Key a) => Dpp a b -> Bool;
wwf_rules d = wwf_rules_impl (impl_ofd d);

q_empty_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
q_empty_impla (uu, (uv, (uw, (ux, (q, uy))))) = null q;

q_emptya :: forall a b. (Key a) => Dpp a b -> Bool;
q_emptya d = q_empty_impla (impl_ofd d);

is_QNF_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Term a b -> Bool;
is_QNF_impla
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, (vf, isnf)))))))))))) =
  isnf;

is_QNFa :: forall a b. (Key a) => Dpp a b -> Term a b -> Bool;
is_QNFa d = is_QNF_impla (impl_ofd d);

rulesb :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
rulesb d = rules_implb (impl_ofd d);

pairs :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
pairs d = pairs_impl (impl_ofd d);

dpp_impl ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (Bool,
                   (Bool,
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b),
                         (Set (Term a b),
                           (Set (Term a b, Term a b),
                             Set (Term a b, Term a b)))))));
dpp_impl (nfs, (mi, (p, (pw, (q, (uu, (uv, (vr, (vrw, (m, uw)))))))))) =
  (nfs, (mi, (set p,
               (set pw,
                 (set q,
                   (set (vr ++ rules_with id m),
                     set (vrw ++ rules_with not m)))))));

dpp ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => Dpp a b ->
                 (Bool,
                   (Bool,
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b),
                         (Set (Term a b),
                           (Set (Term a b, Term a b),
                             Set (Term a b, Term a b)))))));
dpp d = dpp_impl (impl_ofd d);

nfs_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
nfs_impla (nfs, uu) = nfs;

nfsa :: forall a b. (Key a) => Dpp a b -> Bool;
nfsa d = nfs_impla (impl_ofd d);

mk_impla ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 [Term a b] ->
                                   [(Term a b, Term a b)] ->
                                     [(Term a b, Term a b)] ->
                                       (Bool,
 (Bool,
   ([(Term a b, Term a b)],
     ([(Term a b, Term a b)],
       ([Term a b],
         (Bool,
           (Bool,
             ([(Term a b, Term a b)],
               ([(Term a b, Term a b)],
                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                     (Bool, Term a b -> Bool))))))))))));
mk_impla nfs mi p pw q r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    rs = r ++ rw;
    isnf = is_NF_terms q;
  } in (nfs, (mi, (p, (pw, (q, (is_NF_trs_subset isnf rs,
                                 (all (\ rb -> not (is_Var (snd rb))) rs,
                                   (vr, (vrw,
  (insert_rules True ra (insert_rules False rwa empty),
    (insert_rules True (reverse_rules r)
       (insert_rules False (reverse_rules rw) empty),
      (wwf_qtrs_impl isnf rs, isnf))))))))))));

mka ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 [Term a b] ->
                                   [(Term a b, Term a b)] ->
                                     [(Term a b, Term a b)] -> Dpp a b;
mka nfs mi p pw q r rw = DPP (mk_impla nfs mi p pw q r rw);

rw_impla ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)];
rw_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vrw, (m, vc)))))))))) =
  vrw ++ rules_with not m;

rwa :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
rwa d = rw_impla (impl_ofd d);

pw_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
pw_impl (uu, (uv, (uw, (pw, ux)))) = pw;

pw :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
pw d = pw_impl (impl_ofd d);

r_impla ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)];
r_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vb, (m, vc)))))))))) =
  vr ++ rules_with id m;

ra :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
ra d = r_impla (impl_ofd d);

q_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [Term a b];
q_impla (uu, (uv, (uw, (ux, (q, uy))))) = q;

qa :: forall a b. (Key a) => Dpp a b -> [Term a b];
qa d = q_impla (impl_ofd d);

p_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
p_impl (uu, (uv, (p, uw))) = p;

p :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
p d = p_impl (impl_ofd d);

m_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
m_impl (uu, (mi, uv)) = mi;

m :: forall a b. (Key a) => Dpp a b -> Bool;
m d = m_impl (impl_ofd d);

dpp_rbt_impl ::
  forall a b.
    (Eq a, Key a, Ccompare b, Compare b, Eq b,
      Mapping_impl b) => Dpp_ops_ext (Dpp a b) a b ();
dpp_rbt_impl =
  Dpp_ops_ext dpp p pw pairs qa ra rwa rulesb q_emptya rules_no_left_var
    rules_non_collapsing is_QNFa nFQ_subset_NF_rulesa rules_mapa
    reverse_rules_map intersect_pairs replace_pair intersect_rulesa delete_P_Pw
    delete_R_Rwa split_pairs split_rulesa mka m nfsa wwf_rules ();

nFQ_subset_NF_rules_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Bool;
nFQ_subset_NF_rules_impl (uu, (uv, (b, uw))) = b;

nFQ_subset_NF_rules :: forall a b. (Key a, Key b) => Tp a b -> Bool;
nFQ_subset_NF_rules tp = nFQ_subset_NF_rules_impl (impl_ofc tp);

rules_impla ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)];
rules_impla (uu, (uv, (uw, (vR, (vRw, (m, ux)))))) =
  vR ++ vRw ++ map snd (values m);

split_rules_impl ::
  forall a b.
    (Key a,
      Key b) => (Bool,
                  ([Term a b],
                    (Bool,
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)],
                          (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                            Term a b -> Bool)))))) ->
                  [(Term a b, Term a b)] ->
                    ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules_impl tp rs = let {
                           m = ceta_set_of rs;
                         } in partition m (rules_impla tp);

split_rules ::
  forall a b.
    (Key a,
      Key b) => Tp a b ->
                  [(Term a b, Term a b)] ->
                    ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules tp = split_rules_impl (impl_ofc tp);

delete_R_Rw_impl ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       ([Term a b],
                         (Bool,
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                 Term a b -> Bool))))));
delete_R_Rw_impl (nfs, (q, (uu, (vR, (vRw, (m, isnf)))))) r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    vra = list_diff vR vr;
    vrwa = list_diff vRw vrw;
    ma = delete_rules True ra (delete_rules False rwa m);
  } in (nfs, (q, (is_NF_trs_subset isnf (vra ++ vrwa ++ map snd (values ma)),
                   (vra, (vrwa, (ma, isnf))))));

delete_R_Rw ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => Tp a b ->
                  [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Tp a b;
delete_R_Rw tp r rw = TP (delete_R_Rw_impl (impl_ofc tp) r rw);

rules_map_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
rules_map_impl (uu, (uv, (uw, (ux, (uy, (m, uz)))))) fn =
  (case lookup m fn of {
    Nothing -> [];
    Just a -> map snd a;
  });

rules_map ::
  forall a b. (Key a, Key b) => Tp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_map tp = rules_map_impl (impl_ofc tp);

qreltrs_impl ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 (Bool,
                   (Set (Term a b),
                     (Set (Term a b, Term a b), Set (Term a b, Term a b))));
qreltrs_impl (nfs, (q, (uu, (vR, (vRw, (m, isnf)))))) =
  (nfs, (set q, (set (vR ++ rules_with id m), set (vRw ++ rules_with not m))));

qreltrs ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => Tp a b ->
                  (Bool,
                    (Set (Term a b),
                      (Set (Term a b, Term a b), Set (Term a b, Term a b))));
qreltrs tp = qreltrs_impl (impl_ofc tp);

q_empty_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Bool;
q_empty_impl (uu, (q, uv)) = null q;

q_empty :: forall a b. (Key a, Key b) => Tp a b -> Bool;
q_empty tp = q_empty_impl (impl_ofc tp);

is_QNF_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Term a b -> Bool;
is_QNF_impl (uu, (uv, (uw, (ux, (uy, (uz, isnf)))))) = isnf;

is_QNF :: forall a b. (Key a, Key b) => Tp a b -> Term a b -> Bool;
is_QNF tp = is_QNF_impl (impl_ofc tp);

rulesa :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
rulesa tp = rules_impla (impl_ofc tp);

nfs_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 Bool;
nfs_impl (nfs, uu) = nfs;

nfs :: forall a b. (Key a, Key b) => Tp a b -> Bool;
nfs tp = nfs_impl (impl_ofc tp);

mk_impl ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           [Term a b] ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 (Bool,
                                   ([Term a b],
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Term a b -> Bool))))));
mk_impl nfs q r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    isnf = is_NF_terms q;
  } in (nfs, (q, (is_NF_trs_subset isnf (r ++ rw),
                   (vr, (vrw, (insert_rules True ra
                                 (insert_rules False rwa empty),
                                isnf))))));

mk :: forall a b.
        (Eq a, Key a, Ccompare b, Eq b, Key b,
          Mapping_impl b) => Bool ->
                               [Term a b] ->
                                 [(Term a b, Term a b)] ->
                                   [(Term a b, Term a b)] -> Tp a b;
mk nfs q r rw = TP (mk_impl nfs q r rw);

rw_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)];
rw_impl (uu, (uv, (uw, (ux, (vRw, (m, uy)))))) = vRw ++ rules_with not m;

rw :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
rw tp = rw_impl (impl_ofc tp);

tp_rbt_impl ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b, Key b,
      Mapping_impl b) => Tp_ops_ext (Tp a b) a b ();
tp_rbt_impl =
  Tp_ops_ext qreltrs q r rw rulesa q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs ();

string_reversal_complete_rel_tt ::
  forall a b c d.
    (Showa b,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_complete_rel_tt i tp =
  bindb (check (q_emptyb i tp)
          (shows_prec_list zero_nat
            ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't',
              'y']))
    (\ _ ->
      bindb (check_unary_signature (rulesd i tp))
        (\ _ ->
          Inr (mkc i default_nfs_nt_trs [] (map rev_rule (rc i tp))
                (map rev_rule (rwc i tp)))));

check_to_srs_complete ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> [(b, b)] ->
                         [(Term b a, Term b a)] ->
                           [(Term b a, Term b a)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_to_srs_complete v old_new r s =
  let {
    mu = funas_trs_list r;
    (d, (da, nu)) = extract_components mu old_new;
  } in bindb (check_components mu (d, (da, nu)))
         (\ _ ->
           bindb (check_varcond_subset s)
             (\ _ ->
               catch_errora
                 (forallM
                   (\ slr ->
                     let {
                       y = choose_var v (fst slr);
                       stra = str d y;
                       to_slr = (\ (l, ra) -> (stra l, stra ra));
                     } in check (any (\ lr -> to_slr lr == slr) r)
                            (shows_prec_list zero_nat
                               ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                 ' ', 'f', 'i', 'n', 'd', ' ', 'o', 'r', 'i',
                                 'g', 'i', 'n', 'a', 'l', ' ', 'r', 'u', 'l',
                                 'e', ' ', 'f', 'o', 'r', ' '] .
                              shows_rule (shows_prec zero_nat)
                                (shows_prec zero_nat) [' ', '-', '>', ' '] slr))
                   s)
                 (\ x -> Inl (snd x))));

const_to_string_complete_tt ::
  forall a b c d.
    (Eq b, Showa b, Eq c,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Const_string_complete_proof b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
const_to_string_complete_tt i tp (Const_string_complete_proof v old_new s) =
  bindb (check (q_emptyb i tp)
          (shows_prec_list zero_nat
            ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't',
              'y']))
    (\ _ ->
      bindb (check_to_srs_complete v old_new (rulesd i tp) s)
        (\ _ -> Inr (mkc i False [] s [])));

check_NF_trs_subset ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [Term a b] -> Sum (Term a b) ();
check_NF_trs_subset r = check_NF_terms_subset (is_NF_trs r);

switch_termination_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_termination_proc i joins_i dpp =
  let {
    p = pairsb i dpp;
    r = rulese i dpp;
    q = qc i dpp;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list zero_nat
                                  ['r', 'u', 'l', 'e', 's', ' ', 'a', 'r', 'e',
                                    ' ', 'n', 'o', 't', ' ', 'o', 'v', 'e', 'r',
                                    'l', 'a', 'y']))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_wf_trs r)
                        (\ _ ->
                          bindb (check_critical_pairs r cp joins_i)
                            (\ _ ->
                              bindb (check (null (critical_pairs_impl p r))
                                      (shows_prec_list zero_nat
['t', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
  'p', 's', ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', 'P', ' ', 'a', 'n',
  'd', ' ', 'R']))
                                (\ _ ->
                                  catch_errora (check_NF_trs_subset r q)
                                    (\ x ->
                                      Inl
(shows_prec_term zero_nat x .
  shows_prec_list zero_nat
    [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm',
      'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ', 'w', '.', 'r', '.', 't', '.', ' ',
      'R']))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i (nfsc i dpp) False p [] [] [] r);
       });

check_instance ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_instance pa p =
  catch_errora
    (forallM
      (\ st ->
        check (any (instance_rule st) pa)
          (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] st .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'i', 'n',
                's', 't', 'a', 'n', 'c', 'e', ' ', 'o', 'f', ' ', 'a', 'n', 'y',
                ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 'p', 'a', 'i',
                'r']))
      p)
    (\ x -> Inl (snd x));

instantiation_complete_proc ::
  forall a b c d.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Instantiation_complete_proc_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
instantiation_complete_proc i dpp (Instantiation_complete_proc_prf p) =
  let {
    pa = pairsb i dpp;
    q = qc i dpp;
    r = rulese i dpp;
    nfs = nfsc i dpp;
  } in bindb (check (not nfs || null q)
               (shows_prec_list zero_nat
                 ['n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ',
                   's', 'u', 'b', 's', 't', '.', ' ', 'c', 'u', 'r', 'r', 'e',
                   'n', 't', 'l', 'y', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p',
                   'p', 'o', 'r', 't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'i',
                   'n', 'n', 'e', 'r', 'm', 'o', 's', 't']))
         (\ _ ->
           bindb (check_instance pa p)
             (\ _ -> Inr (mkd i nfs False p [] q [] r)));

rule_removal_nonterm_dp ::
  forall a b c.
    (Key b, Showa b, Key c,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_dp_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_dp i dpp (Rule_removal_nonterm_dp_prf p r) =
  let {
    prm = (if is_none p then [] else ceta_list_diff (pairsb i dpp) (the p));
    rrm = (if is_none r then [] else ceta_list_diff (rulese i dpp) (the r));
  } in Inr (delete_R_Rwc i (delete_P_Pwa i dpp prm prm) rrm rrm);

mk_rel_tp ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      (Bool, ([Term b c], ([(Term b c, Term b c)], [(Term b c, Term b c)]))) ->
        a;
mk_rel_tp i (nfs, (q, (r, rw))) = mkc i nfs q r rw;

mk_dppa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      (Bool,
        (Bool,
          ([(Term b c, Term b c)],
            ([(Term b c, Term b c)],
              ([Term b c],
                ([(Term b c, Term b c)], [(Term b c, Term b c)])))))) ->
        a;
mk_dppa i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkd i nfs m p pw q r rw;

check_assmb ::
  forall a b c d e f g h i.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      (a -> e -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (d -> f -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (a -> g -> Sum ([Prelude.Char] -> [Prelude.Char])
                                       ()) ->
                            (([(Ctxt (Lab b c) [Prelude.Char],
                                 (Term (Lab b c) [Prelude.Char], Location))],
                               [(Term (Lab b c) [Prelude.Char],
                                  Term (Lab b c) [Prelude.Char])]) ->
                              h -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              ([Prelude.Char] ->
                                i -> Sum ([Prelude.Char] -> [Prelude.Char])
                                       ()) ->
                                Generic_assm_proof b c [Prelude.Char] e f g h
                                  i ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_SN_assm_proof t prf) = tp_check (mk_tpa i t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_RelSN_assm_proof t prf) = rtp_check (mk_rel_tp i t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Infinite_assm_proof t prf) = dp_check (mk_dppa j t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_SN_FP_assm_proof t prf) = fptp_check t prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Unknown_assm_proof t prf) = unk_check t prf;
check_assmb i j uu uv uw ux uy (SN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assmb i j uu uv uw ux uy (Finite_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assmb i j uu uv uw ux uy (SN_FP_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assmb i j uu uv uw ux uy (Complexity_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);

q_increase_nonterm_dp ::
  forall a b c.
    (Eq b,
      Eq c) => Dpp_ops_ext a b c () ->
                 a -> Q_increase_nonterm_dp_prf b c ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_increase_nonterm_dp i dpp (Q_increase_nonterm_dp_prf q) =
  let {
    p = pairsb i dpp;
    r = rulese i dpp;
    qa = qc i dpp;
    nfs = nfsc i dpp;
  } in Inr (mkd i nfs False p [] (list_union qa q) [] r);

dp_q_reduction_nonterm ::
  forall a b c d.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b, Showa b, Ccompare c,
      Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Dp_q_reduction_nonterm_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
dp_q_reduction_nonterm i dpp (DP_q_reduction_nonterm_prf q) =
  let {
    p = pairsb i dpp;
    r = rulese i dpp;
    qa = qc i dpp;
    nfs = nfsc i dpp;
    f = set (funas_trs_list (p ++ r));
    rQ = filter (\ qb -> less_eq_set (funas_term qb) f) qa;
  } in bindb (catch_errora (check_NF_terms_subset (is_NF_terms q) rQ)
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                       shows_prec_term zero_nat x .
                         shows_prec_list zero_nat
                           [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                             'g', ' ', 'i', 'n', ' ', 'Q', '\'', ' '])))
         (\ _ -> Inr (mkd i nfs False p [] q [] r));

check_dpp_subsumesa ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Dpp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      (Bool,
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          ([(Term (Lab b c) [Prelude.Char],
                              Term (Lab b c) [Prelude.Char])],
                            ([Term (Lab b c) [Prelude.Char]],
                              ([(Term (Lab b c) [Prelude.Char],
                                  Term (Lab b c) [Prelude.Char])],
                                [(Term (Lab b c) [Prelude.Char],
                                   Term (Lab b c) [Prelude.Char])])))))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dpp_subsumesa j dp dpp =
  let {
    (nfsa, (_, (p, (pw, (q, (r, rw)))))) = dp;
    pairsa = p ++ pw;
    rulesa = r ++ rw;
    nfs = nfsc j dpp;
    pairs = pairsb j dpp;
    rules = rulese j dpp;
    qa = qc j dpp;
  } in catch_errora
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list zero_nat
               ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ',
                 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
                 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm', 'a', 'l', '-',
                 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a', 'g', 's']))
           (\ _ ->
             bindb (catch_errora (check_subseteq pairsa pairs)
                     (\ x ->
                       Inl (toomuch ['p', 'a', 'i', 'r']
                             (shows_rule (shows_prec_lab zero_nat)
                               (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                               x))))
               (\ _ ->
                 bindb (catch_errora (check_subseteq rulesa rules)
                         (\ x ->
                           Inl (toomuch ['r', 'u', 'l', 'e']
                                 (shows_rule (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat)
                                   [' ', '-', '>', ' '] x))))
                   (\ _ ->
                     catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                       (\ x ->
                         Inl (shows_prec_list zero_nat
                                ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f',
                                  'f', 'e', 'r', 's', ' ', 'd', 'u', 'e', ' ',
                                  't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
                               shows_term (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) x))))))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 's', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

rewriting_complete_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Rewriting_complete_proc_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rewriting_complete_proc i (Rewriting_complete_proc_prf u_opt stb sta st lr p)
  dpp =
  (case catch_errora
          (let {
             s = fst stb;
             t = snd stb;
             ta = snd sta;
             r = rulese i dpp;
           } in bindb (check_rstep r p lr t ta)
                  (\ _ ->
                    bindb (check (nFQ_subset_NF_rulesc i dpp)
                            (shows_prec_list zero_nat
                              ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ',
                                'r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g',
                                ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                      (\ _ ->
                        bindb (check_rewrite_common_preconditions i u_opt stb
                                (args s) (args (subt_at t p)) ta lr p False dpp)
                          (\ _ ->
                            bindb (check (not (is_Var s))
                                    (shows_prec_list zero_nat
                                      ['l', 'h', 's', ' ', 'o', 'f', ' ', 'p',
'a', 'i', 'r', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ',
'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']))
                              (\ _ ->
                                bindb (check (eq_rule_mod_vars sta st)
(shows_prec_list zero_nat ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] sta .
    shows_prec_list zero_nat
      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r', 'e', 'n', 'a',
        'm', 'e', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'n', 't', ' ', 'o', 'f',
        ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
        [' ', '-', '>', ' '] st))
                                  (\ _ ->
                                    bindb (check (equal_term s (fst sta))
    (shows_prec_list zero_nat
      ['l', 'e', 'f', 't', '-', 'h', 'a', 'n', 'd', ' ', 's', 'i', 'd', 'e',
        's', ' ', 'o', 'f', ' ', 'o', 'l', 'd', ' ', 'a', 'n', 'd', ' ', 'n',
        'e', 'w', ' ', 'p', 'a', 'i', 'r', ' ', 'd', 'i', 'f', 'f', 'e', 'r']))
                                      (\ _ ->
let {
  q = qc i dpp;
  inn = isOK (check_NF_trs_subset r q);
} in bindb (check_nfc inn r q (is_QNFc i dpp) (args s) (nfsc i dpp)
             (subt_at t p))
       (\ _ ->
         bindb (catch_errora
                 (forallM
                   (\ (l, _) ->
                     check (not (is_Var l))
                       (shows_prec_list zero_nat
                         ['l', 'h', 's', 's', ' ', 'm', 'u', 's', 't', ' ', 'n',
                           'o', 't', ' ', 'b', 'e', ' ', 'v', 'a', 'r', 'i',
                           'a', 'b', 'l', 'e', 's']))
                   r)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             (if not (is_Var t)
               then check (not (not (null (rules_mapc i dpp (the (root t))))))
                      (shows_prec_list zero_nat
                         ['r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
                        shows_prec_term zero_nat t .
                          shows_prec_list zero_nat
                            [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                              'b', 'e', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd'])
               else Inr ()))))))))))
          (\ x ->
            Inl (shows_string
                   ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'r',
                     'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 't', 'h', 'e',
                     ' ', 'p', 'a', 'i', 'r', ' '] .
                  shows_nl .
                    shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                      [' ', '-', '>', ' '] stb .
                      shows_nl .
                        shows_string
                          [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                            'i', 'r', ' '] .
                          shows_nl .
                            shows_rule (shows_prec zero_nat)
                              (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                              st .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp stb [st]);
  });

less_eq_pos :: Pos -> Pos -> Bool;
less_eq_pos (PCons i q1) (PCons j q2) = equal_nat i j && less_eq_pos q1 q2;
less_eq_pos (PCons i q1) Empty = False;
less_eq_pos Empty p = True;

rstep_enum_impl ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b ->
                             Term a b ->
                               Pos ->
                                 [((Term a b, Term a b), (b -> Term a b, Pos))];
rstep_enum_impl r ta t p =
  concat
    (map_filter
      (\ x ->
        (if less_eq_pos p x
          then Just (let {
                       tp = subt_at ta x;
                     } in (if membera (poss_list t) x
                            then (if equal_ctxt (ctxt_of_pos_term x ta)
                                       (ctxt_of_pos_term x t)
                                   then concatMap
  (\ tpa ->
    concatMap
      (\ (l, ra) ->
        map (\ mu -> ((l, ra), (mu, x)))
          (option_to_list (match_list Var [(l, tp), (ra, tpa)])))
      r)
  [subt_at t x]
                                   else [])
                            else []))
          else Nothing))
      (poss_list ta));

narrow_enum_impl ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           (Term a b, Term a b) ->
                             (Term a b, Term a b) ->
                               Pos ->
                                 [(b -> Term a b,
                                    ((Term a b, Term a b),
                                      (Pos, b -> Term a b)))];
narrow_enum_impl r sta st p =
  let {
    (s, t) = sta;
    (sa, ta) = st;
  } in concatMap
         (\ mu ->
           concatMap (\ (lr, (tau, q)) -> [(mu, (lr, (q, tau)))])
             (rstep_enum_impl r (subst_apply_term t mu) ta p))
         (option_to_list (match sa s));

check_narrow ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Bool ->
                    Dpp_ops_ext a b [Prelude.Char] () ->
                      a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Bool ->
                                 (Term b [Prelude.Char],
                                   Term b [Prelude.Char]) ->
                                   (Term b [Prelude.Char],
                                     Term b [Prelude.Char]) ->
                                     ([Prelude.Char] -> Term b [Prelude.Char],
                                       ((Term b [Prelude.Char],
  Term b [Prelude.Char]),
 (Pos, [Prelude.Char] -> Term b [Prelude.Char]))) ->
                                       Sum ([Prelude.Char] -> [Prelude.Char])
 ();
check_narrow inn i dpp r q nfs sta st quad =
  let {
    ((_, t), ((s, ta), (mu, (lr, (p, _))))) = (sta, (st, quad));
  } in bindb (check_nfc inn r q (is_QNFc i dpp) (args s) nfs
               (subt_at (subst_apply_term t mu) p))
         (\ _ ->
           check_rewrite_common_preconditions i Nothing
             (s, subst_apply_term t mu) (args s)
             (args (subt_at (subst_apply_term t mu) p)) ta lr p False dpp);

narrowing_complete_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Narrowing_complete_proc_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
narrowing_complete_proc i (Narrowing_complete_proc_prf st p sts) dpp =
  (case catch_errora
          (let {
             (s, t) = st;
             q = qc i dpp;
             nfs = nfsc i dpp;
             rules = rulese i dpp;
             check_ndef =
               check_no_defined_root (\ fn -> not (null (rules_mapc i dpp fn)));
             inn = isOK (check_NF_trs_subset rules q);
             cnarrow = check_narrow inn i dpp rules q nfs st;
           } in bindb (check (null q || nFQ_subset_NF_rulesc i dpp)
                        (shows_prec_list zero_nat
                          ['f', 'u', 'l', 'l', ' ', 'o', 'r', ' ', 'i', 'n',
                            'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e',
                            'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'r', 'e',
                            'q', 'u', 'i', 'r', 'e', 'd']))
                  (\ _ ->
                    bindb (if null q then Inr ()
                            else bindb (check_no_var s)
                                   (\ _ ->
                                     bindb (check_no_var t)
                                       (\ _ ->
 bindb (check_ndef t)
   (\ _ ->
     (if nfs
       then bindb (catch_errora (forallM (\ (l, _) -> check_no_var l) rules)
                    (\ x -> Inl (snd x)))
              (\ _ ->
                check (wf_rule (s, t))
                  (shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                     [' ', '-', '>', ' '] (s, t) .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'w', 'e', 'l',
                        'l', ' ', 'f', 'o', 'r', 'm', 'e', 'd']))
       else Inr ())))))
                      (\ _ ->
                        catch_errora
                          (forallM
                            (\ sta ->
                              let {
                                quads = narrow_enum_impl rules st sta p;
                              } in catch_errora
                                     (existsM
                                       (\ quad ->
 catch_errora
   (check (null q)
     (shows_prec_list zero_nat
       ['q', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't', 'y']))
   (\ _ -> cnarrow sta quad))
                                       quads)
                                     (\ x ->
                                       Inl
 (shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] sta .
   shows_prec_list zero_nat
     (case quads of {
       [] -> [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 's', 'e', 'e',
               'm', ' ', 't', 'o', ' ', 'b', 'e', ' ', 'n', 'a', 'r', 'r', 'o',
               'w', 'e', 'd', ' ', 'p', 'a', 'i', 'r'];
       _ : _ ->
         [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 's', 'i', 'd', 'e',
           ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ', 'f', 'o',
           'r', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'e', 'n', 'e', 's',
           's'];
     }) .
     shows_list_gen id [] [] [] [] x)))
                            sts)
                          (\ x -> Inl (snd x)))))
          (\ x ->
            Inl (shows_string
                   ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'n',
                     'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', ' '] .
                  shows_nl .
                    shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                      [' ', '-', '>', ' '] st .
                      shows_nl .
                        shows_string
                          [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                            'i', 'r', 's', ' '] .
                          shows_nl .
                            shows_trs (shows_prec zero_nat)
                              (shows_prec_list zero_nat)
                              ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                                's', 't', 'e', 'm', ':']
                              [' ', '-', '>', ' '] sts .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

inverse_var_renaming_impl ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)];
inverse_var_renaming_impl sigma = let {
                                    a = mk_subst_domain sigma;
                                  } in map (\ (x, y) -> (the_Var y, Var x)) a;

vars_pat_term_impl ::
  forall a b.
    (Eq a, Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) -> [b];
vars_pat_term_impl p =
  let {
    (s, (sigma, mu)) = p;
  } in remdups
         (vars_term_list s ++ vars_subst_impl sigma ++ vars_subst_impl mu);

var_renaming_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> Bool;
var_renaming_impl sigma = let {
                            sigmaa = map snd (mk_subst_domain sigma);
                          } in all is_Var sigmaa && distinct sigmaa;

pat_dom_renaming_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                 [(b, Term a b)] -> Bool;
pat_dom_renaming_impl p rho =
  let {
    rhoa = mk_subst_domain rho;
    xs = map Var (vars_pat_term_impl p);
  } in var_renaming_impl rho &&
         all (membera (pat_dv_impl p)) (map fst rhoa) &&
           all (\ t -> not (membera xs t)) (map snd rhoa);

check_pat_eqv_prf ::
  forall a b.
    (Compare a, Eq a, Showa a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Set_impl b,
      Showa b) => Pat_eqv_prf a b ->
                    (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Term a b, ([(b, Term a b)], [(b, Term a b)]));
check_pat_eqv_prf (Pat_Irrelevant sigmaa mua) (t, (sigma, mu)) =
  let {
    w = w_impl (mk_subst_domain sigma) t;
    sig = mk_subst Var sigma;
    siga = mk_subst Var sigmaa;
    mub = mk_subst Var mu;
    muba = mk_subst Var mua;
  } in bindb (catch_errora
               (catch_errora
                 (forallM
                   (\ x ->
                     bindb (check (equal_term (sig x) (siga x))
                             (x, (sig x,
                                   (siga x,
                                     ['p', 'u', 'm', 'p', 'i', 'n', 'g']))))
                       (\ _ ->
                         check (equal_term (mub x) (muba x))
                           (x, (mub x,
                                 (muba x,
                                   ['c', 'l', 'o', 's', 'i', 'n', 'g'])))))
                   w)
                 (\ x -> Inl (snd x)))
               (\ x ->
                 Inl (let {
                        (xa, (tb, (ta, sub))) = x;
                      } in shows_string
                             ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'e',
                               'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e',
                               ' ', '(', 'i', 'r', 'r', 'e', 'l', 'e', 'v', 'a',
                               'n', 't', ')', ':', ' ', 'f', 'o', 'r', ' ', 'v',
                               'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                             shows_prec zero_nat xa .
                               shows_string
                                 [' ', 'o', 'b', 't', 'a', 'i', 'n', ' ', 'd',
                                   'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', ' ',
                                   'v', 'a', 'l', 'u', 'e', 's', ' ', 'f', 'o',
                                   'r', ' '] .
                                 shows_prec_list zero_nat sub .
                                   shows_string
                                     [' ', 's', 'u', 'b', 's', 't', 'i', 't',
                                       'u', 't', 'i', 'o', 'n', ':', ' '] .
                                     shows_prec_term zero_nat tb .
                                       shows_string [' ', '!', '=', ' '] .
 shows_prec_term zero_nat ta)))
         (\ _ -> Inr (t, (sigmaa, mua)));
check_pat_eqv_prf (Pat_Simplify mu_1 mu_2) (t, (sigma, mu)) =
  bindb (check (subst_eq mu (subst_compose_impl mu_1 mu_2))
          (shows_prec_list zero_nat
            ['m', 'u', ' ', '!', '=', ' ', 'm', 'u', '1', ' ', 'm', 'u', '2']))
    (\ _ ->
      bindb (check (commutes_impl mu_1 sigma)
              (shows_prec_list zero_nat
                ['s', 'i', 'g', 'm', 'a', ' ', 'a', 'n', 'd', ' ', 'm', 'u',
                  '1', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm',
                  'm', 'u', 't', 'e']))
        (\ _ -> Inr (subst_apply_term t (mk_subst Var mu_1), (sigma, mu_2))));
check_pat_eqv_prf (Pat_Dom_Renaming rho) (t, (sigma, mu)) =
  bindb (check (pat_dom_renaming_impl (t, (sigma, mu)) rho)
          (shows_prec_list zero_nat
            ['r', 'h', 'o', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ',
              'd', 'o', 'm', 'a', 'i', 'n', ' ', 'r', 'e', 'n', 'a', 'm', 'i',
              'n', 'g', ' ', 'f', 'o', 'r', ' ', 'p']))
    (\ _ ->
      let {
        i_rho = inverse_var_renaming_impl rho;
        sigmaa =
          mk_subst_case
            (map (the_Var . mk_subst Var rho) (map fst (mk_subst_domain sigma)))
            (\ x ->
              subst_apply_term
                (subst_apply_term
                  (subst_apply_term (Var x) (mk_subst Var i_rho))
                  (mk_subst Var sigma))
                (mk_subst Var rho))
            [];
        mua = mk_subst_case
                (map (the_Var . mk_subst Var rho)
                  (map fst (mk_subst_domain mu)))
                (\ x ->
                  subst_apply_term
                    (subst_apply_term (Var x) (mk_subst Var i_rho))
                    (mk_subst Var mu))
                i_rho;
      } in Inr (subst_apply_term t (mk_subst Var rho), (sigmaa, mua)));

subst_compose_impla ::
  forall a b.
    (Eq a, Eq b) => [(a, Term b a)] -> (a -> Term b a) -> [(a, Term b a)];
subst_compose_impla sigma rho =
  map (\ (x, s) -> (x, subst_apply_term s rho)) (mk_subst_domain sigma);

subst_replace_impl ::
  forall a b. (Eq a) => [(a, Term b a)] -> a -> Term b a -> [(a, Term b a)];
subst_replace_impl sigma x t = (x, t) : filter (\ (y, _) -> not (y == x)) sigma;

check_pat_rule_prf ::
  forall a b.
    (Compare a, Eq a, Showa a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Pat_rule_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char])
                          ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                            ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                              Bool));
check_pat_rule_prf ra p (Pat_OrigRule (l, r) isPair) =
  (if isPair
    then bindb (check (membera p (l, r))
                 (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '-', '>', ' '] (l, r) .
                   shows_prec_list zero_nat
                     [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p',
                       'a', 'i', 'r']))
           (\ _ -> Inr ((l, ([], [])), ((r, ([], [])), isPair)))
    else bindb (check (membera ra (l, r))
                 (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '-', '>', ' '] (l, r) .
                   shows_prec_list zero_nat
                     [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                       'u', 'l', 'e']))
           (\ _ -> Inr ((l, ([], [])), ((r, ([], [])), isPair))));
check_pat_rule_prf r p (Pat_InitPump pat sigma theta) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sig, tau)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (siga, taua)) = aa;
             } in (\ bb ->
                    catch_errora
                      (bindb
                        (check (null (sig ++ tau ++ siga ++ taua))
                          (shows_prec_list zero_nat
                            ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i',
                              'o', 'n', 's', ' ', 'm', 'u', 's', 't', ' ', 'b',
                              'e', ' ', 'e', 'm', 'p', 't', 'y']))
                        (\ _ ->
                          bindb (check
                                  (equal_term
                                    (subst_apply_term s (mk_subst Var theta))
                                    (subst_apply_term t (mk_subst Var sigma)))
                                  (shows_prec_list zero_nat
                                    ['s', ' ', 't', 'h', 'e', 't', 'a', ' ',
                                      '!', '=', ' ', 't', ' ', 's', 'i', 'g',
                                      'm', 'a']))
                            (\ _ ->
                              bindb (check (commutes_impl theta sigma)
                                      (shows_prec_list zero_nat
['s', 'i', 'g', 'm', 'a', ' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', 't', 'a', ' ',
  'd', 'o', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm', 'm', 'u', 't', 'e']))
                                (\ _ ->
                                  Inr ((s, (sigma, [])),
((t, (theta, [])), bb))))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['i', 'n', 'i', 't', 'i', 'a', 'l', ' ', 'p',
                                  'u', 'm', 'p', 'i', 'n', 'g'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sig, tau)),
((t, (siga, taua)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r pa (Pat_InitPumpCtxt pat sigma p z) =
  bindb (check_pat_rule_prf r pa pat)
    (\ (a, b) ->
      let {
        (s, (sig, tau)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (siga, taua)) = aa;
             } in (\ bb ->
                    catch_errora
                      (bindb
                        (check (not bb)
                          (shows_prec_list zero_nat
                            ['p', 'a', 'i', 'r', 's', ' ', 'n', 'o', 't', ' ',
                              'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'i', 'n',
                              ' ', 'i', 'n', 'i', 't', ' ', 'p', 'u', 'm', 'p',
                              ' ', 'c', 't', 'x', 't']))
                        (\ _ ->
                          bindb (check (null (sig ++ tau ++ siga ++ taua))
                                  (shows_prec_list zero_nat
                                    ['s', 'u', 'b', 's', 't', 'i', 't', 'u',
                                      't', 'i', 'o', 'n', 's', ' ', 'm', 'u',
                                      's', 't', ' ', 'b', 'e', ' ', 'e', 'm',
                                      'p', 't', 'y']))
                            (\ _ ->
                              bindb (check (in_poss p t)
                                      (shows_prec_list zero_nat
['p', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'v', 'a', 'l', 'i', 'd',
  ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n']))
                                (\ _ ->
                                  bindb (check
  (equal_term s (subst_apply_term (subt_at t p) (mk_subst Var sigma)))
  (shows_prec_list zero_nat
    ['s', ' ', '!', '=', ' ', 't', ' ', '|', '_', ' ', 'p', ' ', 's', 'i', 'g',
      'm', 'a']))
                                    (\ _ ->
                                      bindb
(check
  (not (membera (vars_term_list s ++ vars_term_list t ++ vars_subst_impl sigma)
         z))
  (shows_prec_list zero_nat
    ['z', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's', 'h']))
(\ _ ->
  let {
    tz = ctxt_apply_term (ctxt_of_pos_term p t) (Var z);
  } in Inr ((s, (sigma, [])),
             ((tz, ((z, tz) : sigma, [(z, subt_at t p)])), bb))))))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['i', 'n', 'i', 't', 'i', 'a', 'l', ' ', 'p',
                                  'u', 'm', 'p', 'i', 'n', 'g', ' ', '(', 'w',
                                  'i', 't', 'h', ' ', 'c', 't', 'x', 't', ')',
                                  ' '] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sig, tau)),
((t, (siga, taua)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Equiv pat left eqv) =
  bindb (check_pat_rule_prf r p pat)
    (\ (pleft, (pright, b)) ->
      catch_errora
        (bindb (check_pat_eqv_prf eqv (if left then pleft else pright))
          (\ pnew ->
            Inr (if left then (pnew, (pright, b)) else (pleft, (pnew, b)))))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h',
                   ' '] .
                shows_prec_list zero_nat
                  ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'e', 'q', 'u', 'i',
                    'v', 'a', 'l', 'e', 'n', 'c', 'e'] .
                  shows_prec_list zero_nat
                    [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e', 'r', 'i', 'v',
                      'i', 'n', 'g', ' ', 'c', 'o', 'r', 'r', 'e', 'c', 't',
                      ' ', 'p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r', 'u',
                      'l', 'e', ' '] .
                    shows_nl . show_pat_rule (pleft, (pright, b)) . x)));
check_pat_rule_prf r pa (Pat_Narrow pat1 pat2 p) =
  bindb (check_pat_rule_prf r pa pat1)
    (\ (a, b) ->
      let {
        (s, (sigma, mu)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sig, mua)) = aa;
             } in (\ b1 ->
                    bindb (check_pat_rule_prf r pa pat2)
                      (\ (ab, bb) ->
                        let {
                          (u, (sig1, mu1)) = ab;
                        } in (\ (ac, bc) ->
                               let {
                                 (v, (sig2, mu2)) = ac;
                               } in (\ b2 ->
                                      catch_errora
(bindb
  (check
    (subst_eq sig sigma &&
      subst_eq sig1 sigma &&
        subst_eq sig2 sigma &&
          subst_eq mua mu && subst_eq mu1 mu && subst_eq mu2 mu)
    (shows_prec_list zero_nat
      ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n', 's', ' ',
        'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i',
        'c', 'a', 'l']))
  (\ _ ->
    bindb (check (in_poss p t)
            (shows_prec_list zero_nat
              ['p', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'v', 'a',
                'l', 'i', 'd', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n']))
      (\ _ ->
        bindb (check (equal_term (subt_at t p) u)
                (shows_prec_list zero_nat
                  ['t', ' ', '|', '_', ' ', 'p', ' ', '!', '=', ' ', 'u']))
          (\ _ ->
            bindb (check (if b2 then equal_pos p Empty else True)
                    (shows_prec_list zero_nat
                      ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', ' ',
                        'P', ' ', 's', 't', 'e', 'p', ',', ' ', 's', 'o', ' ',
                        'p', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'e',
                        'p', 's', 'i', 'l', 'o', 'n']))
              (\ _ ->
                Inr ((s, (sigma, mu)),
                      ((ctxt_apply_term (ctxt_of_pos_term p t) v, (sigma, mu)),
                        b1 || b2)))))))
(\ x ->
  Inl (shows_prec_list zero_nat
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' '] .
        shows_prec_list zero_nat
          ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'n', 'a', 'r', 'r', 'o', 'w',
            'i', 'n', 'g'] .
          shows_prec_list zero_nat
            [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e', 'r', 'i', 'v', 'i',
              'n', 'g', ' ', 'c', 'o', 'r', 'r', 'e', 'c', 't', ' ', 'p', 'a',
              't', 't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e', 's', ' '] .
            shows_nl .
              show_pat_rule ((s, (sigma, mu)), ((t, (sig, mua)), b1)) .
                shows_nl .
                  shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                    shows_nl .
                      show_pat_rule ((u, (sig1, mu1)), ((v, (sig2, mu2)), b2)) .
                        x)))
                                 bc)
                          bb))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Base) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         xs = map fst
                                (mk_subst_domain sigma_s ++
                                  mk_subst_domain mu_s ++
                                    mk_subst_domain sigma_t ++
                                      mk_subst_domain mu_t);
                       } in bindb (catch_errora
                                    (forallM
                                      (\ x ->
check (not (membera xs x))
  (shows_prec_list zero_nat
    ['d', 'o', 'm', 'a', 'i', 'n', 's', ' ', 'n', 'o', 't', ' ', 'd', 'i', 's',
      'j', 'o', 'i', 'n', 't']))
                                      (vars_subst_impl rho))
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                let {
                                  rhoa = mk_subst Var rho;
                                } in Inr ((subst_apply_term s rhoa,
    (subst_compose_impla sigma_s rhoa, subst_compose_impla mu_s rhoa)),
   ((subst_apply_term t rhoa,
      (subst_compose_impla sigma_t rhoa, subst_compose_impla mu_t rhoa)),
     bb))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'i',
                                  'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't',
                                  'i', 'o', 'n', ' ', '(', 'b', 'a', 's', 'e',
                                  ')'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Pump) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (bindb
                        (check (commutes_impl rho sigma_s)
                          (shows_prec_list zero_nat
                            ['r', 'h', 'o', ' ', 'd', 'o', 'e', 's', ' ', 'n',
                              'o', 't', ' ', 'c', 'o', 'm', 'm', 'u', 't', 'e',
                              ' ', 'w', 'i', 't', 'h', ' ', 's', 'i', 'g', 'm',
                              'a', '_', 's']))
                        (\ _ ->
                          bindb (check (commutes_impl rho mu_s)
                                  (shows_prec_list zero_nat
                                    ['r', 'h', 'o', ' ', 'd', 'o', 'e', 's',
                                      ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm',
                                      'm', 'u', 't', 'e', ' ', 'w', 'i', 't',
                                      'h', ' ', 'm', 'u', '_', 's']))
                            (\ _ ->
                              bindb (check (commutes_impl rho sigma_t)
                                      (shows_prec_list zero_nat
['r', 'h', 'o', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm',
  'm', 'u', 't', 'e', ' ', 'w', 'i', 't', 'h', ' ', 's', 'i', 'g', 'm', 'a',
  '_', 't']))
                                (\ _ ->
                                  bindb (check (commutes_impl rho mu_t)
  (shows_prec_list zero_nat
    ['r', 'h', 'o', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o',
      'm', 'm', 'u', 't', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'm', 'u', '_',
      't']))
                                    (\ _ ->
                                      Inr
((s, (subst_compose_impl sigma_s rho, mu_s)),
  ((t, (subst_compose_impl sigma_t rho, mu_t)), bb)))))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'i',
                                  'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't',
                                  'i', 'o', 'n', ' ', '(', 'p', 'u', 'm', 'p',
                                  'i', 'n', 'g', ')'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Close) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    Inr ((s, (sigma_s, subst_compose_impl mu_s rho)),
                          ((t, (sigma_t, subst_compose_impl mu_t rho)), bb)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Base uu) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check (equal_term t ta)
                                    (shows_prec_list zero_nat
                                      ['t', 'e', 'r', 'm', 's', ' ', 't', ' ',
'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h']))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((tb, (sigma_t, mu_t)), bb)))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r',
                                  'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                                  '(', 'b', 'a', 's', 'e', ')'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Pump x) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check
                                    (equal_term (mk_subst Var sigma_t x) ta)
                                    (shows_prec_list zero_nat
                                      ['s', 'i', 'g', 'm', 'a', '_', 't', ' ',
'x', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h',
' ', 's', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ', 't', 'e', 'r', 'm']))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((t, (subst_replace_impl sigma_t x tb, mu_t)), bb)))))
                      (\ xa ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r',
                                  'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                                  '(', 'p', 'u', 'm', 'p', 'i', 'n', 'g', ')'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      xa)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Close x) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check (equal_term (mk_subst Var mu_t x) ta)
                                    (shows_prec_list zero_nat
                                      ['s', 'i', 'g', 'm', 'a', '_', 't', ' ',
'x', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h',
' ', 's', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ', 't', 'e', 'r', 'm']))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((t, (sigma_t, subst_replace_impl mu_t x tb)), bb)))))
                      (\ xa ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r',
                                  'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                                  '(', 'c', 'l', 'o', 's', 'i', 'n', 'g', ')'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      xa)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Exp_Sigma pat k) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    Inr ((subst_apply_term s
                            (mk_subst Var (subst_power_impl sigma_s k)),
                           (sigma_s, mu_s)),
                          ((subst_apply_term t
                              (mk_subst Var (subst_power_impl sigma_t k)),
                             (sigma_t, mu_t)),
                            bb)))
               ba)
        b);

check_non_loop_prf ::
  forall a b.
    (Compare a, Eq a, Showa a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Non_loop_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_prf r pa (Non_loop_prf pat sigma mu m b p) =
  bindb (check_pat_rule_prf r pa pat)
    (\ (a, c) ->
      let {
        (s, (sigmaa, mua)) = a;
      } in (\ (aa, ca) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ is_pair ->
                    catch_errora
                      (bindb
                        (check (if is_pair then equal_pos p Empty else True)
                          (shows_prec_list zero_nat
                            ['p', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ',
                              'e', 'm', 'p', 't', 'y', ',', ' ', 's', 'i', 'n',
                              'c', 'e', ' ', 'p', 'a', 'i', 'r', 's', ' ', 'a',
                              'r', 'e', ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n',
                              'e', 'd']))
                        (\ _ ->
                          bindb (check (commutes_impl sigmaa sigma)
                                  (shows_prec_list zero_nat
                                    ['s', 'i', 'g', 'm', 'a', ' ', 'a', 'n',
                                      'd', ' ', 's', 'i', 'g', 'm', 'a', '\'',
                                      ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ',
                                      'c', 'o', 'm', 'm', 'u', 't', 'e']))
                            (\ _ ->
                              bindb (check (commutes_impl mua sigma)
                                      (shows_prec_list zero_nat
['m', 'u', ' ', 'a', 'n', 'd', ' ', 's', 'i', 'g', 'm', 'a', '\'', ' ', 'd',
  'o', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm', 'm', 'u', 't', 'e']))
                                (\ _ ->
                                  bindb (check
  (subst_eq sigma_t (subst_compose_impl (subst_power_impl sigmaa m) sigma))
  (shows_prec_list zero_nat
    ['s', 'i', 'g', 'm', 'a', '_', 't', ' ', '!', '=', ' ', 's', 'i', 'g', 'm',
      'a', '^', 'm', ' ', 's', 'i', 'g', 'm', 'a', '\'', ' ']))
                                    (\ _ ->
                                      bindb
(check (subst_eq mu_t (subst_compose_impl mua mu))
  (shows_prec_list zero_nat
    ['m', 'u', '_', 't', ' ', '!', '=', ' ', 'm', 'u', ' ', 'm', 'u', '\'',
      ' ']))
(\ _ ->
  bindb (check (in_poss p t)
          (shows_prec_list zero_nat
            ['p', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
              's', 'i', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 't']))
    (\ _ ->
      check (equal_term
              (subst_apply_term s (mk_subst Var (subst_power_impl sigmaa b)))
              (subt_at t p))
        (shows_prec_list zero_nat
          ['s', ' ', 's', 'i', 'g', 'm', 'a', '^', 'b', ' ', '!', '=', ' ', 't',
            ' ', '|', '_', ' ', 'p']))))))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                                  'o', 'n', ' ', 'c', 'o', 'n', 'd', 'i', 't',
                                  'i', 'o', 'n', ' ', 'o', 'f', ' ', 'n', 'o',
                                  'n', '-', 'l', 'o', 'o', 'p', ' ', 't', 'h',
                                  'e', 'o', 'r', 'e', 'm'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigmaa, mua)),
((t, (sigma_t, mu_t)), is_pair)) .
                                      x)))
               ca)
        c);

check_non_loop_dp_prf ::
  forall a b c d.
    (Compare b, Eq b, Showa b, Cenum c, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Non_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_dp_prf i dpp prf =
  let {
    p = pairsb i dpp;
    r = rulese i dpp;
  } in bindb (check (null (qc i dpp))
               (shows_prec_list zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'f', 'o', 'r',
                   ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p', 's', ' ', 'u',
                   'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
         (\ _ -> check_non_loop_prf r p prf);

rule_removal_nonterm_trs ::
  forall a b c.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_trs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_trs i tp (Rule_removal_nonterm_trs_prf r) =
  let {
    ra = rulesd i tp;
    rrm = ceta_list_diff ra r;
  } in Inr (delete_R_Rwb i tp rrm rrm);

shows_prec_location :: Nat -> Location -> [Prelude.Char] -> [Prelude.Char];
shows_prec_location uu A = shows_prec_list zero_nat ['a', 'b', 'o', 'v', 'e'];
shows_prec_location uv Ba = shows_prec_list zero_nat ['b', 'e', 'l', 'o', 'w'];
shows_prec_location uw H = shows_prec_list zero_nat ['h', 'e', 'r', 'e'];
shows_prec_location ux Ra = shows_prec_list zero_nat ['r', 'i', 'g', 'h', 't'];

shows_pattern ::
  forall a b.
    (Showa a,
      Showa b) => (Ctxt a b, (Term a b, Location)) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_pattern (c, (s, p)) =
  shows_prec_list zero_nat ['('] .
    shows_prec_term zero_nat (ctxt_apply_term c s) .
      shows_prec_list zero_nat [',', ' '] .
        shows_prec_pos zero_nat (hole_pos c) .
          shows_prec_list zero_nat [',', ' '] .
            shows_prec_location zero_nat p . shows_prec_list zero_nat [')'];

fp_R_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_R_decide mu l oo q c t =
  not (bex (let {
              h = hole_pos c;
              q_s = filter (\ qa -> is_left_of qa q) (poss_list t);
              m1 = map (\ qa -> (subt_at t qa, l)) q_s;
              sterms =
                remdups
                  (map (si_subst mu)
                    (remdups (concatMap (\ qa -> si_W mu (subt_at t qa)) q_s)));
              uterms = concatMap supteq_list sterms;
              m2 = map (\ u -> (u, l)) (remdups uterms);
              p_s = filter (\ qa -> is_left_of qa h)
                      (poss_list (ctxt_apply_term c t));
              m3 = map (\ p -> (subt_at (ctxt_apply_term c t) p, l)) p_s;
              stermsa =
                remdups
                  (map (si_subst mu)
                    (remdups
                      (concatMap
                        (\ p -> si_W mu (subt_at (ctxt_apply_term c t) p))
                        p_s)));
              utermsa = concatMap supteq_list stermsa;
              m4 = map (\ u -> (u, l)) (remdups utermsa);
            } in set (m1 ++ m2 ++ m3 ++ m4))
        (match_decision mu));

size_pos :: Pos -> Nat;
size_pos Empty = zero_nat;
size_pos (PCons x21 x22) = plus_nat (size_pos x22) (suc zero_nat);

pos_dec :: Pos -> Pos -> Pos -> Maybe (Nat, Pos);
pos_dec p q oo =
  (if equal_pos p Empty then (case pos_suffix oo q of {
                               Nothing -> Nothing;
                               Just r -> Just (zero_nat, r);
                             })
    else let {
           n0 = nat (ceiling
                      (divide_rat
                        (of_nat (minus_nat (size_pos oo) (size_pos q)))
                        (of_nat (size_pos p))));
         } in (case pos_suffix oo (append (power p n0) q) of {
                Nothing -> Nothing;
                Just r -> Just (n0, r);
              }));

ctxt_subst ::
  forall a b. Ctxt a b -> (b -> Term a b) -> Nat -> Term a b -> Term a b;
ctxt_subst uu uv n t =
  (if equal_nat n zero_nat then t
    else ctxt_apply_term uu
           (subst_apply_term (ctxt_subst uu uv (minus_nat n one_nat) t) uv));

h_match_probs ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => (a -> Term b a) ->
                 Term b a ->
                   Pos ->
                     Pos -> Ctxt b a -> Term b a -> Set (Term b a, Term b a);
h_match_probs mu l oo q c t =
  (case pos_dec (hole_pos c) q oo of {
    Nothing ->
      set_empty
        (of_phantom (set_impl_prod :: Phantom (Term b a, Term b a) Set_impla));
    Just (n, o) ->
      inserta (subt_at (ctxt_subst c mu n t) o, l)
        (set_empty
          (of_phantom
            (set_impl_prod :: Phantom (Term b a, Term b a) Set_impla)));
  });

fp_H_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_H_decide mu l oo q c t =
  not (bex (h_match_probs (si_subst mu) l oo q c t) (match_decision mu));

decompositions :: Pos -> [(Pos, Pos)];
decompositions p = map (\ pa -> (pa, the (pos_prefix pa p))) (prefix_list p);

simplify_emp_main ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b,
                   (Term a b,
                     (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                   [(Term a b, Term a b)] ->
                     Maybe (Maybe (Ctxt a b,
                                    (Term a b,
                                      (Ctxt a b,
(Term a b, [(Term a b, Term a b)])))));
simplify_emp_main mu_incr (Hole, (Fun g ls, (c, (t, [])))) solved =
  (if gmatch_decision mu_incr ((t, Fun g ls) : solved) then Just Nothing
    else (if equal_ctxt c Hole then Nothing
           else simplify_emp_main mu_incr
                  (c, (Fun g ls,
                        (subst_apply_ctxt c (si_subst mu_incr),
                          (subst_apply_term t (si_subst mu_incr), []))))
                  solved));
simplify_emp_main mu_incr (More f bef d aft, (Fun g ls, (c, (t, [])))) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (guarda
             (equal_nat (size_list ls)
               (suc (plus_nat (size_list bef) (size_list aft)))))
        (\ _ ->
          let {
            pairs_bef = zip bef (take (size_list bef) ls);
            pairs_aft = zip aft (drop (suc (size_list bef)) ls);
          } in simplify_emp_main mu_incr
                 (d, (nth ls (size_list bef), (c, (t, pairs_bef ++ pairs_aft))))
                 solved));
simplify_emp_main mu_incr (d, (Var x, (c, (t, [])))) solved =
  Just (Just (d, (Var x, (c, (t, solved)))));
simplify_emp_main mu_incr (d, (l, (c, (t, (Var x, Fun f ls) : mp)))) solved =
  bind (guarda (member x (si_v_incr mu_incr)))
    (\ _ ->
      let {
        m = map (\ (s, a) -> (subst_apply_term s (si_subst mu_incr), a));
      } in simplify_emp_main mu_incr
             (subst_apply_ctxt d (si_subst mu_incr),
               (l, (subst_apply_ctxt c (si_subst mu_incr),
                     (subst_apply_term t (si_subst mu_incr),
                       m ((Var x, Fun f ls) : mp)))))
             (m solved));
simplify_emp_main mu_incr (d, (l, (c, (t, (Fun g ts, Fun f ls) : mp)))) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (zip_option ts ls)
        (\ pairs ->
          simplify_emp_main mu_incr (d, (l, (c, (t, pairs ++ mp)))) solved));
simplify_emp_main mu_incr (d, (l, (c, (t, (s, Var x) : mp)))) solved =
  simplify_emp_main mu_incr (d, (l, (c, (t, mp)))) ((s, Var x) : solved);

simplify_emp ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) ->
                   Sum (Ctxt a b,
                         (Term a b,
                           (Ctxt a b, (Term a b, [(Term a b, Term a b)]))))
                     Bool;
simplify_emp mu_incr emp =
  let {
    (d, (l, (c, t))) = emp;
  } in (case simplify_emp_main mu_incr (d, (l, (c, (t, [])))) [] of {
         Nothing -> Inr False;
         Just a -> (case a of {
                     Nothing -> Inr True;
                     Just aa -> Inl aa;
                   });
       });

eident_prob_to_ident_prob ::
  forall a b.
    (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) -> (Term a b, Term a b);
eident_prob_to_ident_prob (d, (si, (c, t))) = (ctxt_apply_term d t, si);

eident_prob_of_semp ::
  forall a b.
    (Eq a,
      Eq b) => (Ctxt a b,
                 (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                 Maybe (Ctxt a b, (Term a b, (Ctxt a b, Term a b)));
eident_prob_of_semp (d, (l, (c, (t, mp)))) =
  bind (map_of (reverse_rules mp) l) (\ si -> Just (d, (si, (c, t))));

ident_prob_of_semp ::
  forall a b.
    (Eq a,
      Eq b) => (Ctxt a b,
                 (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                 [(Term a b, Term a b)];
ident_prob_of_semp (d, (l, (c, (t, mp)))) = ident_prob_of_smp mp;

ident_prob_of_emp ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) ->
                   Maybe [(Term a b, Term a b)];
ident_prob_of_emp mu_incr emp =
  (case simplify_emp mu_incr emp of {
    Inl semp ->
      Just (map eident_prob_to_ident_prob
              (option_to_list (eident_prob_of_semp semp)) ++
             ident_prob_of_semp semp);
    Inr True -> Just [];
    Inr False -> Nothing;
  });

n0b :: Pos -> Pos -> Pos -> Nat;
n0b p q oo =
  nat (ceiling
        (divide_rat (of_nat (minus_nat (suc (size_pos oo)) (size_pos q)))
          (of_nat (size_pos p))));

less_pos :: Pos -> Pos -> Bool;
less_pos p q = less_eq_pos p q && not (equal_pos p q);

fp_B_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_B_decide mu l oo q c t =
  not (bex (foldr (sup_set . (\ qa -> h_match_probs (si_subst mu) l oo qa c t))
             (proper_prefix_list q)
             (set_empty
               (of_phantom
                 (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla))))
        (match_decision mu)) &&
    not (bex (let {
                p = hole_pos c;
                n = (\ pa -> n0b p pa oo);
                ps = filter
                       (\ (pa, pb) ->
                         less_pos oo (append pb (power p (n pb))) &&
                           less_pos pa p)
                       (remdups (decompositions p));
              } in set (map (\ (pb, pa) ->
                              (subt_at_ctxt c pb,
                                (l, (subst_apply_ctxt c (si_subst mu),
                                      subst_apply_term
(ctxt_subst c (si_subst mu) (n pa) t) (si_subst mu)))))
                         (remdups ps)))
          (\ ep ->
            bex (set_option (ident_prob_of_emp mu ep))
              (all (ident_decision mu))));

n0 :: Pos -> Pos -> Pos -> Nat;
n0 p q oo =
  nat (ceiling
        (divide_rat (of_nat (minus_nat (size_pos oo) (size_pos q)))
          (of_nat (size_pos p))));

fp_A_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_A_decide mu l oo q c t =
  not (bex (case subt_at t q of {
             Var _ ->
               set_empty
                 (of_phantom
                   (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla));
             Fun _ _ ->
               let {
                 h = hole_pos c;
                 n = n0 h q oo;
                 hn = power h n;
                 cs = ctxt_subst c (si_subst mu) n t;
                 q_s = bounded_postfixes q (poss_list t);
                 qoo_s =
                   concatMap
                     (\ qa ->
                       map (\ a -> (qa, a))
                         (prefix_list (append hn (append q qa))))
                     q_s;
                 qoo_sf =
                   filter
                     (\ qoo -> less_pos (append hn q) (append (snd qoo) oo))
                     qoo_s;
                 m1 = map (\ qoo -> (subt_at cs (snd qoo), l)) qoo_sf;
                 sterms = remdups (map (si_subst mu) (si_W mu (subt_at t q)));
                 uterms =
                   concatMap (filter (\ ta -> not (is_Var ta)) . supteq_list)
                     sterms;
                 m2 = map (\ u -> (u, l)) (remdups uterms);
               } in set (m1 ++ m2);
           })
        (match_decision mu));

fp_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Pos, (Ctxt a b, Term a b)) ->
                   (Ctxt a b, (Term a b, Location)) -> Bool;
fp_decide mu =
  (\ (q, (c, t)) (l, (la, loc)) ->
    (if equal_location loc H
      then fp_H_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
      else True) &&
      (if equal_location loc A
        then fp_A_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
        else True) &&
        (if equal_location loc Ba
          then fp_B_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
          else True) &&
          (if equal_location loc Ra
            then fp_R_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
            else True));

fp_valid ::
  forall a b c.
    (Compare a, Eq a, Compare b, Eq b, Ceq c,
      Ccompare c) => Set (Ctxt a b, (Term a b, c)) -> Bool;
fp_valid p = ball p (\ (l, (la, _)) -> not (is_Var (ctxt_apply_term l la)));

check_fploop ::
  forall a b.
    (Compare a, Eq a, Showa a, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Ctxt a b, (Term a b, Location))] ->
                      Fp_loop_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fploop r p (FP_loop_prf c sigma t seq) =
  let {
    mu = subst_incr sigma;
    mua = si_subst mu;
  } in bindb (check (not (null seq))
               (shows_prec_list zero_nat
                 ['l', 'o', 'o', 'p', 'i', 'n', 'g', ' ', 'r', 'e', 'd', 'u',
                   'c', 't', 'i', 'o', 'n', ' ', 'm', 'u', 's', 't', ' ', 'n',
                   'o', 't', ' ', 'b', 'e', ' ', 'e', 'm', 'p', 't', 'y']))
         (\ _ ->
           bindb (check
                   (equal_term (let {
                                  (_, (_, ta)) = last seq;
                                } in ta)
                     (ctxt_apply_term c (subst_apply_term t mua)))
                   (shows_prec_list zero_nat
                     ['l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ', 'i',
                       'n', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ' ',
                       'i', 's', ' ', 'n', 'o', 't', ' ', 'C', '[', 't', ' ',
                       's', 'i', 'g', 'm', 'a', ']']))
             (\ _ ->
               bindb (check (fp_valid (set p))
                       (shows_prec_list zero_nat
                         ['l', 'h', 's', 's', ' ', 'i', 'n', ' ', 'f', 'o', 'r',
                           'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a', 't',
                           't', 'e', 'r', 'n', 's', ' ', 'm', 'u', 's', 't',
                           ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'v', 'a',
                           'r', 'i', 'a', 'b', 'l', 'e', 's']))
                 (\ _ ->
                   bindb (catch_errora
                           (forallM
                             (\ (l, _) ->
                               check (not (is_Var l))
                                 (shows_prec_list zero_nat
                                   ['l', 'h', 's', 's', ' ', 'o', 'f', ' ', 'T',
                                     'R', 'S', ' ', 'm', 'u', 's', 't', ' ',
                                     'n', 'o', 't', ' ', 'b', 'e', ' ', 'v',
                                     'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
                             r)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       let {
                         seqa = zip (t : map (\ (_, (_, ta)) -> ta) seq) seq;
                       } in catch_errora
                              (forallM
                                (\ (ta, (q, (ra, s))) ->
                                  bindb (check_rstep r q ra ta s)
                                    (\ _ ->
                                      let {
check_fpstep = fp_decide mu (q, (c, ta));
                                      } in
catch_errora
  (forallM
    (\ pt ->
      check (check_fpstep pt)
        (shows_prec_list zero_nat
           ['i', 't', 'e', 'r', 'a', 't', 'i', 'n', 'g', ' ', 'r', 'e', 'd',
             'u', 'c', 't', 'i', 'o', 'n', ' '] .
          shows_prec_term zero_nat ta .
            shows_prec_list zero_nat [' ', '-', '-', '>'] .
              shows_prec_pos zero_nat q .
                shows_prec_list zero_nat [' '] .
                  shows_prec_term zero_nat s .
                    shows_prec_list zero_nat
                      [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'r',
                        'e', 's', 'p', 'e', 'c', 't', ' ', 'f', 'o', 'r', 'b',
                        'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a', 't', 't', 'e',
                        'r', 'n', ' '] .
                      shows_pattern pt))
    p)
  (\ x -> Inl (snd x))))
                                seqa)
                              (\ x -> Inl (snd x))))));

check_fp_tp_subsumes ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ([(Ctxt (Lab a b) [Prelude.Char],
                      (Term (Lab a b) [Prelude.Char], Location))],
                    [(Term (Lab a b) [Prelude.Char],
                       Term (Lab a b) [Prelude.Char])]) ->
                    ([(Ctxt (Lab a b) [Prelude.Char],
                        (Term (Lab a b) [Prelude.Char], Location))],
                      [(Term (Lab a b) [Prelude.Char],
                         Term (Lab a b) [Prelude.Char])]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fp_tp_subsumes ta t =
  let {
    ((p, r), (pa, ra)) = (ta, t);
  } in catch_errora
         (bindb
           (check (p == pa)
             (shows_prec_list zero_nat
               ['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 'i', 'n',
                 ' ', 'f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p',
                 'a', 't', 't', 'e', 'r', 'n', 's', ' ', 's', 't', 'r', 'a',
                 't', 'e', 'g', 'y']))
           (\ _ ->
             catch_errora (check_subseteq r ra)
               (\ x ->
                 Inl (toomuch ['r', 'u', 'l', 'e']
                       (shows_rule (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] x)))))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

string_reversal_complete_tt ::
  forall a b c d.
    (Showa b,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_complete_tt i tp =
  let {
    r = rulesd i tp;
  } in bindb (check (q_emptyb i tp)
               (shows_prec_list zero_nat
                 ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p',
                   't', 'y']))
         (\ _ ->
           bindb (check_unary_signature r)
             (\ _ -> Inr (mkc i default_nfs_nt_trs [] (map rev_rule r) [])));

ta_contains_nf ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare b, Default b,
      Eq b, Set_impl b, Compare c,
      Eq c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
ta_contains_nf ta r =
  not (ta_empty (intersect_ta (ta_nf (image fst r) (ta_syms ta)) ta));

check_trs_not_wn ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b, Showa b,
      Card_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare_order c, Eq c,
      Set_impl c,
      Showa c) => [(Term a b, Term a b)] ->
                    Not_wn_ta_prf a c ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_not_wn r (Not_wn_ta_prf ta rel) =
  bindb (check_varcond_subset r)
    (\ _ ->
      bindb (check_left_linear_trs r)
        (\ _ ->
          let {
            tA_trim = trim_ta (ta_of_ta ta);
          } in bindb (check (not (ta_empty tA_trim))
                       (shows_prec_list zero_nat
                         ['T', 'A', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't',
                           'y']))
                 (\ _ ->
                   bindb (tree_aut_trs_closed ta rel r)
                     (\ _ ->
                       check (not (ta_contains_nf tA_trim (set r)))
                         (shows_prec_list zero_nat
                           ['T', 'A', ' ', 'a', 'c', 'c', 'e', 'p', 't', 's',
                             ' ', 's', 'o', 'm', 'e', ' ', 'n', 'o', 'r', 'm',
                             'a', 'l', ' ', 'f', 'o', 'r', 'm'])))));

check_not_wn_ta_prf ::
  forall a b c d e.
    (Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare_order b,
      Default b, Eq b, Set_impl b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showa c,
      Card_UNIV e, Cenum e, Ceq e, Cproper_interval e, Compare_order e, Eq e,
      Set_impl e,
      Showa e) => Tp_ops_ext a b c d ->
                    a -> Not_wn_ta_prf b e ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_not_wn_ta_prf i tp prf =
  let {
    r = rulesd i tp;
  } in bindb (check (null (qb i tp))
               (shows_prec_list zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'i', 's', ' ',
                   'u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ',
                   'f', 'o', 'r', ' ', 't', 'r', 'e', 'e', ' ', 'a', 'u', 't',
                   'o', 'm', 'a', 't', 'a', ' ', 'b', 'a', 's', 'e', 'd', ' ',
                   'n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                   'o', 'n']))
         (\ _ -> check_trs_not_wn r prf);

check_dps ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (a -> a) ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] -> Sum (Term a b, Term a b) ();
check_dps unshp r p =
  let {
    d = defined_list r;
  } in catch_errora
         (forallM
           (\ x ->
             (if let {
                   (ll, rr) = x;
                 } in not (is_Var rr) &&
                        not (membera d (the (root rr))) &&
                          any (\ (l, ra) ->
                                equal_term l (sharp_term unshp ll) &&
                                  (equal_term ra (sharp_term unshp rr) ||
                                    supt_impl ra (sharp_term unshp rr)))
                            r
               then Inr () else Inl x))
           p)
         (\ x -> Inl (snd x));

unsharp :: forall a b. Lab a b -> Lab a b;
unsharp (Sharp f) = f;
unsharp (Lab v va) = Lab v va;
unsharp (FunLab v va) = FunLab v va;
unsharp (UnLab v) = UnLab v;

dp_trans_nontermination_tt ::
  forall a b c d e f g.
    (Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => Tp_ops_ext a (Lab b c) d e ->
                    Dpp_ops_ext f (Lab b c) d g ->
                      a -> Dp_trans_nontermination_tt_prf b c d ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) f;
dp_trans_nontermination_tt i j tp (DP_trans_nontermination_tt_prf p) =
  let {
    r = rulesd i tp;
    q = qb i tp;
  } in bindb (check (null q || not (nfsb i tp))
               (shows_prec_list zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ', 'a',
                   'n', 'd', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
                   'r', 'm', ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't',
                   'i', 'o', 'n', 's', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm']))
         (\ _ ->
           bindb (catch_errora (check_dps unsharp r p)
                   (\ x ->
                     Inl (shows_prec_list zero_nat
                            ['p', 'r', 'o', 'b', 'l', 'e', 'm', 'a', 't', 'i',
                              'c', ' ', 'r', 'u', 'l', 'e', ':', ' '] .
                           shows_rule (shows_prec_lab zero_nat)
                             (shows_prec zero_nat) [' ', '-', '>', ' '] x)))
             (\ _ -> Inr (mkd j False False p [] q [] r)));

switch_termination_tt ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_termination_tt i joins_i tp =
  let {
    r = rulesd i tp;
    q = qb i tp;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list zero_nat
                                  ['r', 'u', 'l', 'e', 's', ' ', 'a', 'r', 'e',
                                    ' ', 'n', 'o', 't', ' ', 'o', 'v', 'e', 'r',
                                    'l', 'a', 'y']))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_wf_trs r)
                        (\ _ ->
                          bindb (check_critical_pairs r cp joins_i)
                            (\ _ ->
                              catch_errora (check_NF_trs_subset r q)
                                (\ x ->
                                  Inl (shows_prec_term zero_nat x .
shows_prec_list zero_nat
  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm',
    'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ', 'w', '.', 'r', '.', 't', '.', ' ',
    'R'])))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsb i tp) [] r []);
       });

q_increase_nonterm_trs ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Q_increase_nonterm_trs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_increase_nonterm_trs i dpp (Q_increase_nonterm_trs_prf q) =
  let {
    r = rulesd i dpp;
    qa = qb i dpp;
    nfs = nfsb i dpp;
  } in Inr (mkc i nfs (list_union qa q) r []);

shows_srs_rule ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_srs_rule (l, r) =
  shows_prec zero_nat l .
    shows_prec_list zero_nat [' ', '-', '>', ' '] . shows_prec zero_nat r;

check_step ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Dp_proof_step a ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_step r step =
  (case step of {
    OC1 uv _ ->
      check (member uv r)
        (shows_srs_rule uv .
          shows_prec_list zero_nat
            [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'o', 'r',
              'i', 'g', 'i', 'n', 'a', 'l', ' ', 'r', 'u', 'l', 'e']);
    OC2 oc_new oc1 oc2 t x l ->
      let {
        (wl, tr) = oc_new;
        (w, tx) = oc1;
        (xl, ra) = oc2;
      } in catch_errora
             (bindb
               (check (xl == x ++ l)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x', 'l', ' ',
                     '!', '=', ' ', 'x', ' ', 'l']))
               (\ _ ->
                 bindb (check (tx == t ++ x)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                             'x', ' ', '!', '=', ' ', 't', ' ', 'x']))
                   (\ _ ->
                     bindb (check (wl == w ++ l)
                             (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'w', 'l', ' ', '!', '=', ' ', 'w', ' ', 'l']))
                       (\ _ ->
                         check (tr == t ++ ra)
                           (shows_prec_list zero_nat
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                               'r', ' ', '!', '=', ' ', 't', ' ', 'r'])))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '2', ' ', 'o',
                        'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC2p oc_new oc1 oc2 x t l ->
      let {
        (lw, rt) = oc_new;
        (w, xt) = oc1;
        (lx, ra) = oc2;
      } in catch_errora
             (bindb
               (check (lx == l ++ x)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'x', ' ',
                     '!', '=', ' ', 'l', ' ', 'x']))
               (\ _ ->
                 bindb (check (lw == l ++ w)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l',
                             'w', ' ', '!', '=', ' ', 'l', ' ', 'w']))
                   (\ _ ->
                     bindb (check (rt == ra ++ t)
                             (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'r', 't', ' ', '!', '=', ' ', 'r', ' ', 't']))
                       (\ _ ->
                         check (xt == x ++ t)
                           (shows_prec_list zero_nat
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x',
                               't', ' ', '!', '=', ' ', 'x', ' ', 't'])))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '2', '\'', ' ',
                        'o', 'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC3 oc_new oc1 oc2 t1 t2 ->
      let {
        (w, t1rt2) = oc_new;
        (wa, t1xt2) = oc1;
        (x, ra) = oc2;
      } in catch_errora
             (bindb
               (check (t1rt2 == t1 ++ ra ++ t2)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't', '1', '_',
                     'r', '_', 't', '2', ' ', '!', '=', ' ', 't', '1', ' ', 'r',
                     ' ', 't', '2']))
               (\ _ ->
                 bindb (check (t1xt2 == t1 ++ x ++ t2)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                             '1', '_', 'x', '_', 't', '2', ' ', '!', '=', ' ',
                             't', '1', ' ', 'x', ' ', 't', '2']))
                   (\ _ ->
                     check (w == wa)
                       (shows_prec_list zero_nat
                         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'w', ' ',
                           'd', 'i', 'f', 'f', 'e', 'r', 's']))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '3', ' ', 'o',
                        'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC3p oc_new oc1 oc2 t1 t2 ->
      let {
        (t1wt2, ra) = oc_new;
        (t1xt2, raa) = oc1;
        (w, x) = oc2;
      } in catch_errora
             (bindb
               (check (t1wt2 == t1 ++ w ++ t2)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't', '1', '_',
                     'w', '_', 't', '2', ' ', '!', '=', ' ', 't', '1', ' ', 'w',
                     ' ', 't', '2']))
               (\ _ ->
                 bindb (check (t1xt2 == t1 ++ x ++ t2)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                             '1', '_', 'x', '_', 't', '2', ' ', '!', '=', ' ',
                             't', '1', ' ', 'x', ' ', 't', '2']))
                   (\ _ ->
                     check (ra == raa)
                       (shows_prec_list zero_nat
                         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ',
                           'd', 'i', 'f', 'f', 'e', 'r', 's']))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '3', '\'', ' ',
                        'o', 'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OCDP1 p oc1 ->
      let {
        (lc, cr) = oc1;
        a = p;
        (aa, b) = a;
      } in let {
             (e1, ab) = aa;
             (ac, ba) = ab;
           } in let {
                  (f, (d, l)) = ac;
                } in (\ c1 (c2, ad) ->
                       let {
                         (ae, bb) = ad;
                       } in let {
                              (fa, (da, ra)) = ae;
                            } in (\ e2 ->
                                   catch_errora
                                     (bindb
                                       (check (null e1)
 (shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'e', '1', ' ', 'n', 'o', 't',
     ' ', 'e', 'm', 'p', 't', 'y']))
                                       (\ _ ->
 bindb (check (null e2)
         (shows_prec_list zero_nat
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'e', '2', ' ', 'n',
             'o', 't', ' ', 'e', 'm', 'p', 't', 'y']))
   (\ _ ->
     bindb (check (c1 == c2)
             (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', ' ', 'n', 'o',
                 't', ' ', 'e', 'q', 'u', 'a', 'l']))
       (\ _ ->
         bindb (check
                 (equal_nat f one_nat &&
                   equal_nat fa one_nat &&
                     equal_nat d zero_nat && equal_nat da zero_nat)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', '0', ' ', 'a',
                     'n', 'd', ' ', '1', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                     'o', 'n', 's', ' ', 'n', 'o', 't', ' ', 'm', 'e', 't']))
           (\ _ ->
             bindb (check (lc == l ++ c1)
                     (shows_prec_list zero_nat
                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'c',
                         ' ', '!', '=', ' ', 'l', ' ', 'c']))
               (\ _ ->
                 check (cr == c1 ++ ra)
                   (shows_prec_list zero_nat
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'r',
                       ' ', '!', '=', ' ', 'c', ' ', 'r'])))))))
                                     (\ x ->
                                       Inl
 (shows_prec_list zero_nat
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
      'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C',
      'D', 'P', '1', ' ', 'o', 'f', ' '] .
   shows_nl .
     shows_oc oc1 .
       shows_nl .
         shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
           shows_nl . shows_pat p . shows_nl . x)))
                              bb)
                  ba
             b;
    OCDP2 p oc1 ->
      let {
        (cl, rc) = oc1;
        a = p;
        (aa, b) = a;
      } in let {
             (c1, ab) = aa;
             (ac, ba) = ab;
           } in let {
                  (f, (d, l)) = ac;
                } in (\ e1 (e2, ad) ->
                       let {
                         (ae, bb) = ad;
                       } in let {
                              (fa, (da, ra)) = ae;
                            } in (\ c2 ->
                                   catch_errora
                                     (bindb
                                       (check (null e1 && null e2)
 (shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'e', '1', ' ', 'o', 'r', ' ',
     'e', '2', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't', 'y']))
                                       (\ _ ->
 bindb (check (c1 == c2)
         (shows_prec_list zero_nat
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', ' ', 'n', 'o',
             't', ' ', 'e', 'q', 'u', 'a', 'l']))
   (\ _ ->
     bindb (check
             (equal_nat f one_nat &&
               equal_nat fa one_nat &&
                 equal_nat d zero_nat && equal_nat da zero_nat)
             (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', '0', ' ', 'a', 'n',
                 'd', ' ', '1', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
                 'n', 's', ' ', 'n', 'o', 't', ' ', 'm', 'e', 't']))
       (\ _ ->
         bindb (check (cl == c1 ++ l)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'c', ' ',
                     '!', '=', ' ', 'l', ' ', 'c']))
           (\ _ ->
             check (rc == ra ++ c1)
               (shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'r', ' ',
                   '!', '=', ' ', 'c', ' ', 'r']))))))
                                     (\ x ->
                                       Inl
 (shows_prec_list zero_nat
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
      'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C',
      'D', 'P', '1', ' ', 'o', 'f', ' '] .
   shows_nl .
     shows_oc oc1 .
       shows_nl .
         shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
           shows_nl . shows_pat p . shows_nl . x)))
                              bb)
                  ba
             b;
    WPEQ p_new p ->
      let {
        (left, right) = p;
        (lefta, righta) = p_new;
      } in catch_errora
             (bindb
               (check (word_pat_equiv left lefta)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'h', 's',
                     's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'e', 'q',
                     'u', 'i', 'v', 'a', 'l', 'e', 'n', 't']))
               (\ _ ->
                 check (word_pat_equiv right righta)
                   (shows_prec_list zero_nat
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', 'h',
                       's', 's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ',
                       'e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 't'])))
             (\ x ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'e', 'q',
                        'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e', ' ', 'o',
                        'f', ' '] .
                     shows_nl .
                       shows_pat p .
                         shows_nl .
                           shows_prec_list zero_nat ['a', 'n', 'd'] .
                             shows_nl . shows_pat p_new . shows_nl . x));
    Lift p_new p ->
      let {
        a = p;
        (aa, b) = a;
      } in let {
             (l1, ab) = aa;
             (ac, ba) = ab;
           } in let {
                  (f1, (c1, m1)) = ac;
                } in (\ r1 (l2, ad) ->
                       let {
                         (ae, bb) = ad;
                       } in let {
                              (f2, (c2, m2)) = ae;
                            } in (\ r2 ->
                                   let {
                                     af = p_new;
                                     (ag, bc) = af;
                                   } in let {
  (l1a, ah) = ag;
  (ai, bd) = ah;
} in let {
       (f1a, (c1a, m1a)) = ai;
     } in (\ r1a (l2a, aj) ->
            let {
              (ak, be) = aj;
            } in let {
                   (f2a, (c2a, m2a)) = ak;
                 } in (\ r2a ->
                        catch_errora
                          (bindb
                            (check (l1 == l1a && l2 == l2a)
                              (shows_prec_list zero_nat
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                  'l', ' ', 'a', 'n', 'd', ' ', 'l', '\'', ' ',
                                  'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a',
                                  't', 'c', 'h']))
                            (\ _ ->
                              bindb (check (r1 == r1a && r2 == r2a)
                                      (shows_prec_list zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ', 'a', 'n', 'd', ' ', 'r',
  '\'', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h']))
                                (\ _ ->
                                  bindb (check
  (equal_nat f1 f1a && equal_nat f2 f2a)
  (shows_prec_list zero_nat
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'f', ' ', 'a', 'n', 'd', ' ',
      'f', '\'', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c',
      'h']))
                                    (\ _ ->
                                      bindb
(check (m1 == m1a && m2 == m2a)
  (shows_prec_list zero_nat
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', ' ', 'a', 'n', 'd', ' ',
      'm', '\'', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c',
      'h']))
(\ _ ->
  bindb (check (equal_nat c1a (plus_nat c1 f1))
          (shows_prec_list zero_nat
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'o', 'n', 's',
              't', 'a', 'n', 't', ' ', 'f', 'a', 'c', 't', 'o', 'r', ' ', 'o',
              'n', ' ', 't', 'h', 'e', ' ', 'l', 'e', 'f', 't', ' ', 'n', 'o',
              't', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 'l', 'y', ' ', 'i', 'n',
              'c', 'r', 'e', 'a', 's', 'e', 'd']))
    (\ _ ->
      check (equal_nat c2a (plus_nat c2 f2))
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'o', 'n', 's', 't',
            'a', 'n', 't', ' ', 'f', 'a', 'c', 't', 'o', 'r', ' ', 'o', 'n',
            ' ', 't', 'h', 'e', ' ', 'r', 'i', 'g', 'h', 't', ' ', 'n', 'o',
            't', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 'l', 'y', ' ', 'i', 'n',
            'c', 'r', 'e', 'a', 's', 'e', 'd'])))))))
                          (\ x ->
                            Inl (shows_prec_list zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                     'n', ' ', 'c', 'h', 'e', 'c', 'k', 'i',
                                     'n', 'g', ' ', 'l', 'i', 'f', 't', 'i',
                                     'n', 'g', ' ', 'o', 'f', ' '] .
                                  shows_nl .
                                    shows_pat p .
                                      shows_nl .
shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
  shows_nl . shows_pat p_new . shows_nl . x)))
                   be)
       bd
  bc)
                              bb)
                  ba
             b;
    DPOC1_1 p_new p1 oc1 l ra ->
      let {
        (left, (lxr, (m2, r2))) = p1;
        (x, v) = oc1;
        (lefta, (lvr, (m2a, r2a))) = p_new;
      } in catch_errora
             (bindb
               (check (left == lefta)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'h', 's',
                     's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'e', 'q',
                     'u', 'a', 'l']))
               (\ _ ->
                 bindb (check (m2 == m2a)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                             '2', ' ', 'a', 'n', 'd', ' ', 'm', '2', '\'', ' ',
                             'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                             'c', 'h']))
                   (\ _ ->
                     bindb (check (r2 == r2a)
                             (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'r', '2', ' ', 'a', 'n', 'd', ' ', 'r', '2',
                                 '\'', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ',
                                 'm', 'a', 't', 'c', 'h']))
                       (\ _ ->
                         bindb (check (lxr == l ++ x ++ ra)
                                 (shows_prec_list zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                     'l', '_', 'x', '_', 'r', ' ', '!', '=',
                                     ' ', 'l', ' ', '@', ' ', 'x', ' ', '@',
                                     ' ', 'r']))
                           (\ _ ->
                             check (lvr == l ++ v ++ ra)
                               (shows_prec_list zero_nat
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                   'l', '_', 'v', '_', 'r', ' ', '!', '=', ' ',
                                   'l', ' ', '@', ' ', 'v', ' ', '@', ' ',
                                   'r']))))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P', 'O', 'C', '1',
                        '_', '1', ' ', 'o', 'f', ' '] .
                     shows_nl .
                       shows_pat p1 .
                         shows_nl .
                           shows_oc oc1 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_pat p_new . shows_nl . xa));
    DPOC1_2 p_new p1 oc1 l ra x ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (m1, r1)) = aa;
           } in (\ (xr, (m2, r2)) ->
                  let {
                    (lx, v) = oc1;
                    ab = p_new;
                    (ac, ba) = ab;
                  } in let {
                         (ll1, (m1a, r1a)) = ac;
                       } in (\ (vr, (m2a, r2a)) ->
                              catch_errora
                                (bindb
                                  (check (m1 == m1a && m2 == m2a)
                                    (shows_prec_list zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
'd', 'i', 'f', 'i', 'e', 'd']))
                                  (\ _ ->
                                    bindb (check (r1 == r1a && r2 == r2a)
    (shows_prec_list zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ', 'c', 'o', 'm',
        'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
        'e', 'd']))
                                      (\ _ ->
bindb (check (ll1 == l ++ l1)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '1', ' ',
            '!', '=', ' ', 'l', ' ', '@', ' ', 'l', 'l', '1']))
  (\ _ ->
    bindb (check (xr == x ++ ra)
            (shows_prec_list zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x', '_', 'r', ' ',
                '!', '=', ' ', 'x', ' ', '@', ' ', 'r']))
      (\ _ ->
        bindb (check (lx == l ++ x)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'x',
                    ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'x']))
          (\ _ ->
            check (vr == v ++ ra)
              (shows_prec_list zero_nat
                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'v', '_', 'r',
                  ' ', '!', '=', ' ', 'v', ' ', '@', ' ', 'r'])))))))
                                (\ xa ->
                                  Inl (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P',
   'O', 'C', '1', '_', '2', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPOC2 p_new p1 oc1 l ra ->
      let {
        a = p1;
        (left, aa) = a;
        (l2, ab) = aa;
        (ac, b) = ab;
      } in let {
             (f2, (c2, lxr)) = ac;
           } in (\ r2 ->
                  let {
                    (x, v) = oc1;
                    ad = p_new;
                    (lefta, ae) = ad;
                    (l2a, af) = ae;
                    (ag, ba) = af;
                  } in let {
                         (f2a, (c2a, lvr)) = ag;
                       } in (\ r2a ->
                              catch_errora
                                (bindb
                                  (check (left == lefta)
                                    (shows_prec_list zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'l', 'e', 'f', 't', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                                  (\ _ ->
                                    bindb (check (equal_nat f2 f2a)
    (shows_prec_list zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'f', ' ', 'c', 'o', 'm',
        'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
        'e', 'd']))
                                      (\ _ ->
bindb (check (equal_nat c2 c2a)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', ' ', 'c', 'o', 'm',
            'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f',
            'i', 'e', 'd']))
  (\ _ ->
    bindb (check (l2 == l2a)
            (shows_prec_list zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', ' ', 'c', 'o',
                'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
                'f', 'i', 'e', 'd']))
      (\ _ ->
        bindb (check (r2 == r2a)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ', 'c',
                    'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
                    'd', 'i', 'f', 'i', 'e', 'd']))
          (\ _ ->
            bindb (check (lxr == l ++ x ++ ra)
                    (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_',
                        'x', '_', 'r', ' ', '!', '=', ' ', 'l', ' ', '@', ' ',
                        'x', ' ', '@', ' ', 'r']))
              (\ _ ->
                check (lvr == l ++ v ++ ra)
                  (shows_prec_list zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'v',
                      '_', 'r', ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'v',
                      ' ', '@', ' ', 'r']))))))))
                                (\ xa ->
                                  Inl (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P',
   'O', 'C', '2', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPOC3_1 p_new p1 oc1 l ra ->
      let {
        (left, (l2, (m2, lxr))) = p1;
        (x, v) = oc1;
        (lefta, (l2a, (m2a, lvr))) = p_new;
      } in catch_errora
             (bindb
               (check (left == lefta)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'e', 'f',
                     't', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
                     ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
               (\ _ ->
                 bindb (check (m2 == m2a)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                             ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't',
                             's', ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                   (\ _ ->
                     bindb (check (l2 == l2a)
                             (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'l', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e',
                                 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f',
                                 'i', 'e', 'd']))
                       (\ _ ->
                         bindb (check (lxr == l ++ x ++ ra)
                                 (shows_prec_list zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                     'l', '_', 'x', '_', 'r', ' ', '!', '=',
                                     ' ', 'l', ' ', '@', ' ', 'x', ' ', '@',
                                     ' ', 'r']))
                           (\ _ ->
                             check (lvr == l ++ v ++ ra)
                               (shows_prec_list zero_nat
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                   'l', '_', 'v', '_', 'r', ' ', '!', '=', ' ',
                                   'l', ' ', '@', ' ', 'v', ' ', '@', ' ',
                                   'r']))))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P', 'O', 'C', '3',
                        '_', '1', ' ', 'o', 'f', ' '] .
                     shows_nl .
                       shows_pat p1 .
                         shows_nl .
                           shows_oc oc1 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_pat p_new . shows_nl . xa));
    DPOC3_2 p_new p1 oc1 l ra x ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (m1, r1)) = aa;
           } in (\ (l2, (m2, lx)) ->
                  let {
                    (xr, v) = oc1;
                    ab = p_new;
                    (ac, ba) = ab;
                  } in let {
                         (l1a, (m1a, r1r)) = ac;
                       } in (\ (l2a, (m2a, lv)) ->
                              catch_errora
                                (bindb
                                  (check (m2 == m2a && m1 == m1a)
                                    (shows_prec_list zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
'd', 'i', 'f', 'i', 'e', 'd']))
                                  (\ _ ->
                                    bindb (check (l1 == l1a)
    (shows_prec_list zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', ' ', 'c', 'o', 'm',
        'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
        'e', 'd']))
                                      (\ _ ->
bindb (check (l2 == l2a)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '2', ' ', 'c', 'o',
            'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
            'f', 'i', 'e', 'd']))
  (\ _ ->
    bindb (check (lx == l ++ x)
            (shows_prec_list zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'x', ' ',
                '!', '=', ' ', 'l', ' ', '@', ' ', 'x']))
      (\ _ ->
        bindb (check (xr == x ++ ra)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x', '_', 'r',
                    ' ', '!', '=', ' ', 'x', ' ', '@', ' ', 'r']))
          (\ _ ->
            bindb (check (r1r == r1 ++ ra)
                    (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '1',
                        '_', 'r', ' ', '!', '=', ' ', 'r', '1', ' ', '@', ' ',
                        'r']))
              (\ _ ->
                check (lv == l ++ v)
                  (shows_prec_list zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'v',
                      ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'v']))))))))
                                (\ xa ->
                                  Inl (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P',
   'O', 'C', '3', '_', '2', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPDP1_1 p_new p1 p2 l ra ->
      let {
        (left, (ll2, (mm, r2r))) = p1;
        a = p2;
        (aa, b) = a;
      } in let {
             (l2, (mma, r2)) = aa;
           } in (\ (l2a, (mm2, r2a)) ->
                  let {
                    (lefta, (ll2a, (mm2a, r2pr))) = p_new;
                  } in catch_errora
                         (bindb
                           (check (left == lefta)
                             (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'l', 'e', 'f', 't', ' ', 'c', 'o', 'm', 'p',
                                 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
                                 'd', 'i', 'f', 'i', 'e', 'd']))
                           (\ _ ->
                             bindb (check (mm == mma)
                                     (shows_prec_list zero_nat
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
 ' ', 'm', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm',
 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                               (\ _ ->
                                 bindb (check (mm2 == mm2a)
 (shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm', '2', ' ', 'c', 'o',
     'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
     'e', 'd']))
                                   (\ _ ->
                                     bindb (check (ll2 == l ++ l2)
     (shows_prec_list zero_nat
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '2', ' ',
         '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '2']))
                                       (\ _ ->
 bindb (check (r2r == r2 ++ ra)
         (shows_prec_list zero_nat
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', '_', 'r',
             ' ', '!', '=', ' ', 'r', '2', ' ', '@', ' ', 'r']))
   (\ _ ->
     bindb (check (r2pr == r2a ++ ra)
             (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', 'p', 'r',
                 ' ', '!', '=', ' ', 'r', '2', '\'', ' ', '@', ' ', 'r']))
       (\ _ ->
         check (ll2a == l ++ l2a)
           (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '2',
               ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '2', ' ']))))))))
                         (\ x ->
                           Inl (shows_prec_list zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                    'n', ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n',
                                    'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p',
                                    ' ', 'D', 'P', 'D', 'P', '1', '_', '1', ' ',
                                    'o', 'f', ' '] .
                                 shows_nl .
                                   shows_pat p1 .
                                     shows_nl .
                                       shows_pat p2 .
 shows_nl .
   shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
     shows_nl . shows_pat p_new . shows_nl . x)))
             b;
    DPDP1_2 p_new p1 p2 l ra ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (mm1, r1)) = aa;
           } in (\ (ll2, (mm, r1a)) ->
                  let {
                    ab = p2;
                    (ac, ba) = ab;
                  } in let {
                         (l2, (mm2, r1r)) = ac;
                       } in (\ (l2a, (mm2a, r2)) ->
                              let {
                                ad = p_new;
                                (ae, bb) = ad;
                              } in let {
                                     (l3, (mm3, r1pr)) = ae;
                                   } in (\ (ll2a, (mm3a, r3)) ->
  catch_errora
    (bindb
      (check (l1 == l3)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '1', '\'', ' ',
            'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
            'd', 'i', 'f', 'i', 'e', 'd']))
      (\ _ ->
        bindb (check (mm1 == mm3)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm', '1',
                    '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
                    ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
          (\ _ ->
            bindb (check (mm == mm2)
                    (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm',
                        ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
                        ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
              (\ _ ->
                bindb (check (mm2a == mm3a)
                        (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                            'm', '2', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                            'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f',
                            'i', 'e', 'd']))
                  (\ _ ->
                    bindb (check (r2 == r3)
                            (shows_prec_list zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r',
                                '2', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                                'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
                                'f', 'i', 'e', 'd']))
                      (\ _ ->
                        bindb (check (ll2 == l ++ l2)
                                (shows_prec_list zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                    'l', '_', 'l', '2', ' ', '!', '=', ' ', 'l',
                                    ' ', '@', ' ', 'l', '2']))
                          (\ _ ->
                            bindb (check (r1pr == r1 ++ ra)
                                    (shows_prec_list zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'r', '1', '\'', 'r', ' ', '!', '=', ' ', 'r', '1', '\'', ' ', '@', ' ',
'r']))
                              (\ _ ->
                                bindb (check (r1r == r1a ++ ra)
(shows_prec_list zero_nat
  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '1', 'r', ' ', '!', '=',
    ' ', 'r', '1', ' ', '@', ' ', 'r']))
                                  (\ _ ->
                                    check (ll2a == l ++ l2a)
                                      (shows_prec_list zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '2', ' ', '!', '=',
  ' ', 'l', ' ', '@', ' ', 'l', '2', ' ']))))))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
               'p', ' ', 'D', 'P', 'D', 'P', '1', '_', '2', ' ', 'o', 'f',
               ' '] .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
    DPDP2_1 p_new p1 p2 l ra ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (mm1, r1)) = aa;
           } in (\ (l1a, (mm, r2r)) ->
                  let {
                    ab = p2;
                    (ac, ba) = ab;
                  } in let {
                         (ll1, (mm2, r2)) = ac;
                       } in (\ (l2, (mm2a, r2a)) ->
                              let {
                                ad = p_new;
                                (ae, bb) = ad;
                              } in let {
                                     (ll1a, (mm3, r3)) = ae;
                                   } in (\ (l3, (mm3a, r2pr)) ->
  catch_errora
    (bindb
      (check (r2r == r2 ++ ra)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', 'r', ' ', '!',
            '=', ' ', 'r', '2', ' ', '@', ' ', 'r']))
      (\ _ ->
        bindb (check (ll1 == l ++ l1a)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l',
                    '1', ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '1']))
          (\ _ ->
            bindb (check (ll1a == l ++ l1)
                    (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_',
                        'l', '1', '\'', ' ', '!', '=', ' ', 'l', ' ', '@', ' ',
                        'l', '1', '\'', ' ']))
              (\ _ ->
                bindb (check (mm1 == mm3)
                        (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                            'm', '1', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                            'e', 'n', 't', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
                            'e', 'd']))
                  (\ _ ->
                    bindb (check (r1 == r3)
                            (shows_prec_list zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r',
                                '1', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                                'e', 'n', 't', ' ', 'm', 'o', 'd', 'i', 'f',
                                'i', 'e', 'd']))
                      (\ _ ->
                        bindb (check (l2 == l3)
                                (shows_prec_list zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                    'l', '2', '\'', ' ', 'c', 'o', 'm', 'p',
                                    'o', 'n', 'e', 'n', 't', ' ', 'm', 'o', 'd',
                                    'i', 'f', 'i', 'e', 'd']))
                          (\ _ ->
                            bindb (check (mm2a == mm3a)
                                    (shows_prec_list zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'm', 'm', '2', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                              (\ _ ->
                                bindb (check (mm == mm2)
(shows_prec_list zero_nat
  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm', ' ', 'c', 'o', 'm',
    'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e',
    'd']))
                                  (\ _ ->
                                    check (r2pr == r2a ++ ra)
                                      (shows_prec_list zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', '\'', 'r', ' ', '!',
  '=', ' ', 'r', '2', '\'', ' ', '@', ' ', 'r']))))))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
               'p', ' ', 'D', 'P', 'D', 'P', '2', '_', '1', ' ', 'o', 'f',
               ' '] .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
    DPDP2_2 p_new p1 p2 l ra ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (mm1, r1)) = aa;
           } in (\ (l1a, (mm1a, r1a)) ->
                  let {
                    ab = p2;
                    (ac, ba) = ab;
                  } in let {
                         (ll1, (mm2, r1r)) = ac;
                       } in (\ right ->
                              let {
                                ad = p_new;
                                (ae, bb) = ad;
                              } in let {
                                     (ll1a, (mm3, r1pr)) = ae;
                                   } in (\ righta ->
  catch_errora
    (bindb
      (check (r1r == r1a ++ ra)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '1', 'r', ' ', '!',
            '=', ' ', 'r', '1', ' ', '@', ' ', 'r']))
      (\ _ ->
        bindb (check (ll1 == l ++ l1a)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l',
                    '1', ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '1']))
          (\ _ ->
            bindb (check (ll1a == l ++ l1)
                    (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_',
                        'l', '1', '\'', ' ', '!', '=', ' ', 'l', ' ', '@', ' ',
                        'l', '1', '\'', ' ']))
              (\ _ ->
                bindb (check (r1pr == r1 ++ ra)
                        (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r',
                            '1', '\'', '_', 'r', ' ', '!', '=', ' ', 'r', '1',
                            '\'', ' ', '@', ' ', 'r', ' ']))
                  (\ _ ->
                    bindb (check (mm1 == mm3)
                            (shows_prec_list zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                                'm', '1', '\'', ' ', 'c', 'o', 'm', 'p', 'o',
                                'n', 'e', 'n', 't', ' ', 'm', 'o', 'd', 'i',
                                'f', 'i', 'e', 'd']))
                      (\ _ ->
                        bindb (check (mm1a == mm2)
                                (shows_prec_list zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                    'm', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                                    'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
                                    'f', 'i', 'e', 'd']))
                          (\ _ ->
                            check (right == righta)
                              (shows_prec_list zero_nat
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                  'r', 'i', 'g', 'h', 't', ' ', 'c', 'o', 'm',
                                  'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm',
                                  'o', 'd', 'i', 'f', 'i', 'e', 'd']))))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
               'p', ' ', 'D', 'P', 'D', 'P', '2', '_', ' ', 'o', 'f', ' '] .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
  });

check_proof ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Set (([a], ((Nat, (Nat, [a])), [a])),
                          ([a], ((Nat, (Nat, [a])), [a]))) ->
                      [Dp_proof_step a] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_proof r delta (p : ps) =
  bindb (check_step r p)
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ pa ->
                  check (member pa delta)
                    (shows_prec_list zero_nat
                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'n', 'o',
                         't', 'h', 'i', 'n', 'g', ' ', 'k', 'n', 'o', 'w', 'n',
                         ' ', 'a', 'b', 'o', 'u', 't', ' ', 'p', 'r', 'e', 'm',
                         'i', 's', 'e', ' '] .
                      shows_pat pa))
                (prems_ofa p))
              (\ x -> Inl (snd x)))
        (\ _ ->
          check_proof r
            (sup_set delta
              (inserta (pat_of p)
                (set_empty
                  (of_phantom
                    (set_impl_prod ::
                      Phantom
                        (([a], ((Nat, (Nat, [a])), [a])),
                          ([a], ((Nat, (Nat, [a])), [a])))
                        Set_impla)))))
            ps));
check_proof r delta [] = Inr ();

check_non_loop_srs_proof ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Non_loop_srs_proof a ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_srs_proof ra (SE_OC (m, lmr) l r steps) =
  bindb (check
          (membera (map pat_of steps)
            (([], ((zero_nat, (zero_nat, [])), m)),
              ([], ((zero_nat, (zero_nat, [])), lmr))))
          (shows_prec_list zero_nat
            ['o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'c', 'l', 'o', 's', 'u',
              'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'e', 'r', 'i', 'v', 'e',
              'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'p', 'r', 'o', 'o',
              'f']))
    (\ _ ->
      bindb (check (lmr == l ++ m ++ r)
              (shows_prec_list zero_nat
                ['n', 'o', ' ', 's', 'e', 'l', 'f', 'o', 'v', 'e', 'r', 'l',
                  'a', 'p']))
        (\ _ ->
          check_proof ra
            (set_empty
              (of_phantom
                (set_impl_prod ::
                  Phantom
                    (([a], ((Nat, (Nat, [a])), [a])),
                      ([a], ((Nat, (Nat, [a])), [a])))
                    Set_impla)))
            steps));
check_non_loop_srs_proof ra (SE_DP (left, right) l r steps) =
  bindb (check (membera (map pat_of steps) (left, right))
          (shows_prec_list zero_nat
            ['o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'c', 'l', 'o', 's', 'u',
              'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'e', 'r', 'i', 'v', 'e',
              'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'p', 'r', 'o', 'o',
              'f']))
    (\ _ ->
      let {
        a = left;
        (l1, aa) = a;
        (ab, b) = aa;
      } in let {
             (f1, (c1, m1)) = ab;
           } in (\ r1 ->
                  let {
                    ac = right;
                    (l2, ad) = ac;
                    (ae, ba) = ad;
                  } in let {
                         (f2, (c2, m2)) = ae;
                       } in (\ r2 ->
                              bindb (check
                                      (m1 == m2 &&
l2 == l ++ l1 && r2 == r1 ++ r)
                                      (shows_prec_list zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 's', 'e', 'l',
  'f', 'o', 'v', 'e', 'r', 'l', 'a', 'p']))
                                (\ _ ->
                                  bindb (check
  (less_eq_nat f1 f2 &&
    equal_nat (mod_nat (max (minus_nat c2 c1) (minus_nat c1 c2)) f1) zero_nat &&
      (if less_nat f1 f2 then equal_nat (mod_nat f2 f1) zero_nat else True) &&
        (if equal_nat f1 f2 then less_eq_nat c1 c2 else True))
  (shows_prec_list zero_nat
    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's', 'u', 'r',
      'e', ' ', 'f', 'i', 't', 't', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 'd', 'i',
      't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 's', 'e', 'l', 'f', 'o', 'v',
      'e', 'r', 'l', 'a', 'p']))
                                    (\ _ ->
                                      check_proof ra
(set_empty
  (of_phantom
    (set_impl_prod ::
      Phantom (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
        Set_impla)))
steps)))
                         ba)
             b);

srs_of_trs_impl :: forall a b. [(Term a b, Term a b)] -> [([a], [a])];
srs_of_trs_impl r =
  concatMap
    (\ (l, ra) ->
      (if unary_term l
        then (if unary_term ra then [(term_to_string l, term_to_string ra)]
               else [])
        else []))
    r;

check_non_loop_srs_prf ::
  forall a b c d.
    (Ceq b, Ccompare b, Eq b,
      Showa b) => Tp_ops_ext a b c d ->
                    a -> Non_loop_srs_proof b ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_srs_prf i tp prf =
  let {
    r = rulesd i tp;
    s = set (srs_of_trs_impl r);
  } in bindb (check (null (qb i tp))
               (shows_prec_list zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'f', 'o', 'r',
                   ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p', 's', ' ', 'u',
                   'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
         (\ _ -> check_non_loop_srs_proof s prf);

check_not_wwf_qtrs ::
  forall a b c.
    (Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_not_wwf_qtrs i tp =
  bindb (check (null (qb i tp) || not (nfsb i tp))
          (shows_prec_list zero_nat
            ['s', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ', 'a', 'n',
              'd', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm',
              ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
              's', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm']))
    (\ _ ->
      check (not (isOK (check_wwf_qtrs (is_QNFb i tp) (rulesd i tp))))
        (shows_string
           ['T', 'h', 'e', ' ', 'Q', '-', 'T', 'R', 'S', ' ', 'i', 's', ' ',
             'w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e', 'd'] .
          shows_nl));

check_tp_subsumesa ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      ([Term (Lab b c) [Prelude.Char]],
                        [(Term (Lab b c) [Prelude.Char],
                           Term (Lab b c) [Prelude.Char])])) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_tp_subsumesa i t tp =
  let {
    (nfsa, (q, rulesa)) = t;
    nfs = nfsb i tp;
    rules = rulesd i tp;
    qa = qb i tp;
  } in catch_errora
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list zero_nat
               ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ',
                 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
                 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm', 'a', 'l', '-',
                 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a', 'g', 's']))
           (\ _ ->
             bindb (catch_errora (check_subseteq rulesa rules)
                     (\ x ->
                       Inl (toomuch ['r', 'u', 'l', 'e']
                             (shows_rule (shows_prec_lab zero_nat)
                               (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                               x))))
               (\ _ ->
                 catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                   (\ x ->
                     Inl (shows_prec_list zero_nat
                            ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f', 'f',
                              'e', 'r', 's', ' ', 'd', 'u', 'e', ' ', 't', 'o',
                              ' ', 't', 'e', 'r', 'm', ' '] .
                           shows_term (shows_prec_lab zero_nat)
                             (shows_prec_list zero_nat) x)))))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

check_non_loop_trs_prf ::
  forall a b c d.
    (Compare b, Eq b, Showa b, Cenum c, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Non_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_trs_prf i tp prf =
  let {
    r = rulesd i tp;
  } in bindb (check (null (qb i tp))
               (shows_prec_list zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'f', 'o', 'r',
                   ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p', 's', ' ', 'u',
                   'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
         (\ _ -> check_non_loop_prf r [] prf);

uncurry_nonterm_tt_check ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      ([((b, Nat), [b])] -> b -> Nat -> b) ->
                        (b -> Nat ->
                                [((b, Nat), [b])] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_nonterm_tt_check i info fmap check_inj r dpp =
  let {
    (a, (sml, (u, e))) = info;
    ra = rulesd i dpp;
    nfs = nfsb i dpp;
    sm = sig_list_to_sig_map a sml fmap;
    r_eta = e ++ ra;
    uR = uncurry_rules a sm r_eta;
  } in (case bindb (check (null (qb i dpp))
                     (shows_prec_list zero_nat
                       ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'n', 'o',
                         't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd',
                         ' ', 'f', 'o', 'r', ' ', 'u', 'n', 'c', 'u', 'r', 'r',
                         'y', 'i', 'n', 'g']))
               (\ _ ->
                 let {
                   s = uncurry_of_sig_list a sml sm;
                 } in bindb (only_eta_rules e r_eta)
                        (\ _ ->
                          bindb (check_inj a (nat_of_integer (2 :: Integer))
                                  sml)
                            (\ _ ->
                              bindb (catch_errora (check_CS_subseteq u s)
                                      (\ x ->
Inl (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
        [' ', '-', '>', ' '] x .
        shows_prec_list zero_nat
          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'u', 'n', 'c',
            'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l', 'e'])))
                                (\ _ ->
                                  catch_errora (check_subseteq r (u ++ uR))
                                    (\ x ->
                                      Inl
(shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] x .
    shows_prec_list zero_nat
      [' ', 'i', 's', ' ', 'n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'u', 'n',
        'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l', 'e', 's', ' ',
        'n', 'o', 'r', ' ', 'u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u',
        'l', 'e']))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkc i nfs [] r []);
       });

uncurry_nonterm_tt ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Uncurry_nt_proof b c [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_nonterm_tt i (Uncurry_nt_proof (a, (sml, (u, e))) r) tp =
  uncurry_nonterm_tt_check i (a, (sml, (u, e)))
    (fmap a (nat_of_integer (2 :: Integer))) check_inj r tp;

rule_removal_nonterm_reltrs ::
  forall a b c.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_reltrs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_reltrs i tp (Rule_removal_nonterm_reltrs_prf r s) =
  let {
    rrm = (if is_none r then [] else ceta_list_diff (rc i tp) (the r));
    srm = (if is_none s then [] else ceta_list_diff (rwc i tp) (the s));
  } in Inr (delete_R_Rwb i tp rrm srm);

check_rel_tp_subsumes ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      ([Term (Lab b c) [Prelude.Char]],
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          [(Term (Lab b c) [Prelude.Char],
                             Term (Lab b c) [Prelude.Char])]))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_tp_subsumes i t tp =
  let {
    (nfsa, (q, (r, rw))) = t;
    nfs = nfsb i tp;
    rules = rulesd i tp;
    ra = rc i tp;
    qa = qb i tp;
  } in catch_errora
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list zero_nat
               ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ',
                 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
                 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm', 'a', 'l', '-',
                 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a', 'g', 's']))
           (\ _ ->
             bindb (catch_errora (check_subseteq rw rules)
                     (\ x ->
                       Inl (toomuch ['r', 'u', 'l', 'e']
                             (shows_rule (shows_prec_lab zero_nat)
                               (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                               x))))
               (\ _ ->
                 bindb (catch_errora (check_subseteq r ra)
                         (\ x ->
                           Inl (toomuch ['r', 'u', 'l', 'e']
                                 (shows_rule (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat)
                                   [' ', '-', '>', ' '] x))))
                   (\ _ ->
                     catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                       (\ x ->
                         Inl (shows_prec_list zero_nat
                                ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f',
                                  'f', 'e', 'r', 's', ' ', 'd', 'u', 'e', ' ',
                                  't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
                               shows_term (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) x))))))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

check_not_wf_reltrs ::
  forall a b c.
    (Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_not_wf_reltrs i tp =
  bindb (check (q_emptyb i tp)
          (shows_prec_list zero_nat
            ['c', 'u', 'r', 'r', 'e', 'n', 't', 'l', 'y', ' ', 'o', 'n', 'l',
              'y', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'Q', ' ', 'i', 's', ' ',
              's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
    (\ _ ->
      check (not (isOK (check_wf_reltrs (rc i tp, rwc i tp))))
        (shows_string
           ['T', 'h', 'e', ' ', 'T', 'R', 'S', 's', ' ', 'R', ' ', 'a', 'n',
             'd', ' ', 'S', ' ', 'a', 'r', 'e', ' ', 'w', 'e', 'l', 'l', ' ',
             'f', 'o', 'r', 'm', 'e', 'd'] .
          shows_nl));

reltrs_as_trs ::
  forall a b c.
    Tp_ops_ext a b c () -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
reltrs_as_trs i tp = let {
                       q = qb i tp;
                       r = rc i tp;
                       nfs = nfsb i tp;
                       a = mkc i nfs q r [];
                     } in Inr a;

check_rel_trs_loop ::
  forall a b c.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rel_trs_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_trs_loop i tp (Rel_trs_loop_prf s rseq sigma c) =
  bindb (check (q_emptyb i tp)
          (shows_prec_list zero_nat
            ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't',
              'y']))
    (\ _ -> check_rel_loop s rseq sigma c (rc i tp) (rwc i tp));

check_reltrs_nontermination_proof ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Reltrs_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_reltrs_nontermination_proof ia j assms i tp (Rel_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catch_errora (check_rel_trs_loop ia tp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'l',
                     'o', 'o', 'p', ' ', 'p', 'r', 'o', 'o', 'f'] .
                   shows_nl . x)));
check_reltrs_nontermination_proof ia j assms i tp (Rel_R_Not_SN prf) =
  bindb (reltrs_as_trs ia tp)
    (\ tpa ->
      catch_errora
        (check_trs_nontermination_proof ia j assms (i . shows_string ['.', '1'])
          tpa prf)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                       'o', 'w', ' ', 't', 'h', 'e', ' ', 'n', 'o', 'n', 't',
                       'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                       'p', 'r', 'o', 'o', 'f', ' ', 'f', 'o', 'r', ' ', 'R'] .
                     shows_nl . indent x)));
check_reltrs_nontermination_proof ia j assms i tp Rel_Not_Well_Formed =
  debug (i [])
    ['N', 'o', 't', ' ', 'W', 'e', 'l', 'l', '-', 'F', 'o', 'r', 'm', 'e', 'd']
    (catch_errora (check_not_wf_reltrs ia tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'n',
                     'o', 't', '-', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm',
                     'e', 'd', ' ', 'p', 'r', 'o', 'o', 'f'] .
                   shows_nl . x)));
check_reltrs_nontermination_proof ia j assms i tp (Rel_TRS_String_Reversal prf)
  = debug (i [])
      ['S', 't', 'r', 'i', 'n', 'g', ' ', 'R', 'e', 'v', 'e', 'r', 's', 'a',
        'l']
      (bindb
        (catch_errora (string_reversal_complete_rel_tt ia tp)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         's', 't', 'r', 'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e',
                         'r', 's', 'a', 'l', ' ', 'o', 'n'] .
                       shows_nl .
                         shows_tp (shows_prec_lab zero_nat)
                           (shows_prec_list zero_nat) ia tp .
                           shows_nl . x)))
        (\ tpa ->
          catch_errora
            (check_reltrs_nontermination_proof ia j assms
              (i . shows_string ['.', '1']) tpa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 't', 'r',
                           'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e', 'r', 's',
                           'a', 'l', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q',
                           'u', 'e'] .
                         shows_nl . indent x))));
check_reltrs_nontermination_proof ia j assms i tp (Rel_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_reltrs ia tp p)
      (\ tpa ->
        catch_errora
          (check_reltrs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_reltrs_nontermination_proof ia j assms i tp (Rel_TRS_Assume_Not_SN t ass)
  = debug (i [])
      ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's',
        'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k',
        'n', 'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
      (if assms
        then bindb (catch_errora (check_rel_tp_subsumes ia t tp)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                    'n', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r',
                                    'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                                    'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                                    'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n',
                                    'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o',
                                    'f'] .
                                  shows_nl . x . shows_nl)))
               (\ _ ->
                 catch_errora
                   (catch_errora
                     (forallM_index
                       (\ asa ja ->
                         check_assmb ia j
                           (check_trs_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat zero_nat (suc ja)))
                           (check_dp_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat zero_nat (suc ja)))
                           (check_reltrs_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat zero_nat (suc ja)))
                           (check_fp_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat zero_nat (suc ja)))
                           (check_unknown_disproof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat zero_nat (suc ja)))
                           asa)
                       ass)
                     (\ x -> Inl (snd x)))
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n',
                                  'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . indent x)))
        else Inl (i . shows_string
                        [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                          ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                          'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                          'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                          'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                        shows_nl));

check_trs_nontermination_proof ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_nontermination_proof ia j assms i tp (TRS_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catch_errora (check_trs_loop ia tp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'l', 'o',
                     'o', 'p', ' ', 'o', 'f', ' '] .
                   shows_nl .
                     shows_tp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) ia tp .
                       shows_nl . indent x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Nonloop p) =
  debug (i []) ['N', 'o', 'n', 'l', 'o', 'o', 'p']
    (catch_errora (check_non_loop_trs_prf ia tp p)
      (\ x ->
        Inl (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
                 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'p', 'o', 's', 's', 'i',
                 'b', 'l', 'y', ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p',
                 'i', 'n', 'g', ' ', 'i', 'n', 'f', 'i', 'n', 'i', 't', 'e',
                 ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'f',
                 'o', 'r', ' '] .
              shows_nl .
                shows_tp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) ia
                  tp .
                  indent x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Nonloop_SRS p) =
  debug (i []) ['N', 'o', 'n', 'l', 'o', 'o', 'p', ' ', 'S', 'R', 'S']
    (catch_errora (check_non_loop_srs_prf ia tp p)
      (\ x ->
        Inl (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
                 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'p', 'o', 's', 's', 'i',
                 'b', 'l', 'y', ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p',
                 'i', 'n', 'g', ' ', 'i', 'n', 'f', 'i', 'n', 'i', 't', 'e',
                 ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'f',
                 'o', 'r', ' '] .
              shows_nl .
                shows_tp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) ia
                  tp .
                  indent x)));
check_trs_nontermination_proof ia j assms i tp TRS_Not_Well_Formed =
  debug (i [])
    ['N', 'o', 't', ' ', 'W', 'e', 'l', 'l', '-', 'F', 'o', 'r', 'm', 'e', 'd']
    (catch_errora (check_not_wwf_qtrs ia tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'n',
                     'o', 't', ' ', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm',
                     'e', 'd', ' ', 'p', 'r', 'o', 'o', 'f'] .
                   shows_nl . x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Termination_Switch p prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', ' ', 't', 'o', ' ', 'T', 'e', 'r', 'm', 'i',
      'n', 'a', 't', 'i', 'o', 'n']
    (bindb
      (catch_errora (switch_termination_tt ia p tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'f', 'u', 'l', 'l', ' ', 's', 't', 'r', 'a',
                       't', 'e', 'g', 'y', ' ', 'f', 'o', 'r', ' ', 't', 'h',
                       'e', ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e',
                       'm', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . indent x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm',
                         'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 's', 'w', 'i',
                         't', 'c', 'h', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q',
                         'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_trs ia tp p)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_String_Reversal prf) =
  debug (i [])
    ['S', 't', 'r', 'i', 'n', 'g', ' ', 'R', 'e', 'v', 'e', 'r', 's', 'a', 'l']
    (bindb
      (catch_errora (string_reversal_complete_tt ia tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 't', 'r', 'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e',
                       'r', 's', 'a', 'l', ' ', 'o', 'n'] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 't', 'r', 'i',
                         'n', 'g', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'a', 'l',
                         ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Constant_String p prf) =
  debug (i [])
    ['C', 'o', 'n', 's', 't', 'a', 'n', 't', 's', ' ', 'i', 'n', 't', 'o', ' ',
      'U', 'n', 'a', 'r', 'y']
    (bindb
      (catch_errora (const_to_string_complete_tt ia tp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 't', 'u', 'r', 'n', 'i', 'n', 'g', ' ', 'c',
                       'o', 'n', 's', 't', 'a', 'n', 't', 's', ' ', 'i', 'n',
                       't', 'o', ' ', 's', 't', 'r', 'i', 'n', 'g', 's', ' ',
                       'o', 'n'] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 's',
                         't', 'a', 'n', 't', 's', ' ', 'i', 'n', 't', 'o', ' ',
                         's', 't', 'r', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_DP_Trans p prf) =
  debug (i [])
    ['D', 'P', ' ', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
      'o', 'n']
    (bindb
      (catch_errora (dp_trans_nontermination_tt ia j tp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       'D', 'P', ' ', 't', 'r', 'a', 'n', 's', 'f', 'o', 'r',
                       'm', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'n'] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ dpp ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dpp prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 't',
                         'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
                         'o', 'n'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Q_Increase p prf) =
  debug (i []) ['Q', ' ', 'i', 'n', 'c', 'r', 'e', 'a', 's', 'e']
    (bindb (q_increase_nonterm_trs ia tp p)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', ' ', 'i', 'n',
                         'c', 'r', 'e', 'a', 's', 'e', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Uncurry p prf) =
  debug (i []) ['U', 'n', 'c', 'u', 'r', 'r', 'y', 'i', 'n', 'g']
    (bindb (uncurry_nonterm_tt ia p tp)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c', 'u',
                         'r', 'r', 'y', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Not_WN_Tree_Automaton prf) =
  catch_errora (check_not_wn_ta_prf ia tp prf)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 't', 'r', 'e', 'e',
               ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ', 'b', 'a',
               's', 'e', 'd', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i',
               'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f', ' ',
               'f', 'o', 'r', ' '] .
            shows_nl .
              shows_tp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) ia
                tp .
                indent x));
check_trs_nontermination_proof ia j assms i tp (TRS_Assume_Not_SN t ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora (check_tp_subsumesa ia t tp)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r',
                                  'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                                  'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                                  'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n',
                                  'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_unknown_disproof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_fp_nontermination_proof ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b c) [Prelude.Char],
                              (Term (Lab b c) [Prelude.Char], Location))],
                            [(Term (Lab b c) [Prelude.Char],
                               Term (Lab b c) [Prelude.Char])]) ->
                            Fp_nontermination_proof b c [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fp_nontermination_proof ia j assms i (pa, r) (FPTRS_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catch_errora (check_fploop r pa p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'f', 'o',
                     'r', 'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a', 't', 't',
                     'e', 'r', 'n', ' ', 'l', 'o', 'o', 'p'] .
                   shows_nl . indent x)));
check_fp_nontermination_proof ia j assms i (pa, r) (FPTRS_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_trs ia (mkc ia False [] r []) p)
      (\ tp ->
        catch_errora
          (check_fp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) (pa, rulesd ia tp) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_fp_nontermination_proof ia j assms i tp (FPTRS_Assume_Not_SN t ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora (check_fp_tp_subsumes t tp)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r',
                                  'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                                  'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                                  'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n',
                                  'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_unknown_disproof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_dp_nontermination_proof ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          d -> Dp_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_nontermination_proof ia j assms i dpp (DP_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catch_errora (check_dp_loop j dpp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                     'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'l', 'o', 'o', 'p',
                     ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l',
                     'l', 'o', 'w', 'i', 'n', 'g', ' ', 'D', 'P', '-', 'p', 'r',
                     'o', 'b', 'l', 'e', 'm', ' '] .
                   shows_nl .
                     shows_dpp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) j dpp .
                       shows_nl . indent x)));
check_dp_nontermination_proof ia j assms i dpp (DP_Nonloop p) =
  debug (i []) ['N', 'o', 'n', 'l', 'o', 'o', 'p']
    (catch_errora (check_non_loop_dp_prf j dpp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                     'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'n', 'o', 'n', 'l',
                     'o', 'o', 'p', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ',
                     'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'D', 'P',
                     '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                   shows_nl .
                     shows_dpp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) j dpp .
                       shows_nl . indent x)));
check_dp_nontermination_proof ia j assms i dpp (DP_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_dp j dpp p)
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r',
                         ' ', 'a', 'n', 'd', ' ', 'r', 'u', 'l', 'e', ' ', 'r',
                         'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Q_Reduction p prf) =
  debug (i []) ['Q', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n']
    (bindb
      (catch_errora (dp_q_reduction_nonterm j dpp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       'r', 'e', 'd', 'u', 'c', 'i', 'n', 'g', ' ', 't', 'h',
                       'e', ' ', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't',
                       ' ', 'l', 'h', 's', 's', ' ', 'i', 'n', ' ', 't', 'h',
                       'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                       ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                       ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', ' ', 'r', 'e',
                         'd', 'u', 'c', 't', 'i', 'o', 'n'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Q_Increase p prf) =
  debug (i []) ['Q', ' ', 'i', 'n', 'c', 'r', 'e', 'a', 's', 'e']
    (bindb (q_increase_nonterm_dp j dpp p)
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', ' ', 'i', 'n',
                         'c', 'r', 'e', 'a', 's', 'e'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Termination_Switch p prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', ' ', 't', 'o', ' ', 'T', 'e', 'r', 'm', 'i',
      'n', 'a', 't', 'i', 'o', 'n']
    (bindb
      (catch_errora (switch_termination_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'f', 'u', 'l', 'l', ' ', 's', 't', 'r', 'a',
                       't', 'e', 'g', 'y', ' ', 'f', 'o', 'r', ' ', 't', 'h',
                       'e', ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e',
                       'm', ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm',
                         'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 's', 'w', 'i',
                         't', 'c', 'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                         'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Instantiation p prf) =
  debug (i []) ['I', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n']
    (bindb
      (catch_errora (instantiation_complete_proc j dpp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                       'i', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c',
                       'e', 's', 's', 'o', 'r', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'i', 'n', 's', 't',
                         'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n', ' ', 'p',
                         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Rewriting p prf) =
  debug (i []) ['R', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g']
    (bindb
      (catch_errora (rewriting_complete_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r'] .
                     shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Narrowing p prf) =
  debug (i []) ['N', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g']
    (bindb
      (catch_errora (narrowing_complete_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'n', 'a', 'r', 'r', 'o', 'w', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r'] .
                     shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Assume_Infinite dp ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora (check_dpp_subsumesa j dp dpp)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n',
                                  'e', 's', 's', ' ', 'a', 's', 's', 'u', 'm',
                                  'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ',
                                  'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                                  'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_unknown_disproof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_unknown_disproof ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Neg_unknown_proof b c [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_disproof ia j assms i tpa (Assume_NT_Unknown tp ass) =
  debug (i []) ['U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora
                   (check (tpa == tp)
                     (shows_prec_list zero_nat
                        ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o',
                          'b', 'l', 'e', 'm', 's', ' ', 'a', 'r', 'e', ' ', 'n',
                          'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i', 'c', 'a',
                          'l', ':', ' '] .
                       shows_nl .
                         shows_prec_list zero_nat tpa .
                           shows_nl .
                             shows_prec_list zero_nat [' ', 'v', 's', ' '] .
                               shows_nl . shows_prec_list zero_nat tp))
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'n', 'o', 'n', 't', 'e', 'r', 'm',
                                  'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
                                  's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
                                  ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o',
                                  'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assmb ia j
                       (check_trs_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_dp_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_reltrs_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_fp_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_unknown_disproof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                        'r', 'o', 'o', 'f'] .
                      shows_nl));

check_unraveling ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                     [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        [(Term a b, Term a b)];
check_unraveling c_rs ctrs =
  catch_errora
    (bindb
      (catch_errora (check_subseteq ctrs (map fst c_rs))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
                   ' ', 'r', 'u', 'l', 'e', ' '] .
                shows_crule (shows_prec zero_nat) (shows_prec zero_nat) x .
                  shows_nl)))
      (\ _ ->
        bindb (case create_U c_rs of {
                Nothing ->
                  Inl (shows_prec_list zero_nat
                        ['u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'e',
                          'x', 't', 'r', 'a', 'c', 't', ' ', 'u', 'n', 'r', 'a',
                          'v', 'e', 'l', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 't',
                          'e', 'x', 't', 's']);
                Just a -> Inr a;
              })
          (\ u ->
            bindb (catch_errora
                    (forallM
                      (\ (c, rs) ->
                        check (rules_impl u c == rs)
                          (shows_prec_list zero_nat
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                               't', 'h', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'o',
                               'f', ' '] .
                            shows_crule (shows_prec zero_nat)
                              (shows_prec zero_nat) c .
                              shows_nl))
                      c_rs)
                    (\ x -> Inl (snd x)))
              (\ _ -> Inr (concatMap snd c_rs)))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'u', 'n',
               'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', ' '] .
            shows_nl . x));

check_quasi_reductive_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [((Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]),
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])])] ->
                            Quasi_reductive_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quasi_reductive_proof a ia i j ctrs (Unravel u_info prf) =
  debug (ia []) ['U', 'n', 'r', 'a', 'v', 'e', 'l']
    (bindb
      (catch_errora (check_unraveling u_info ctrs)
        (\ x ->
          Inl (ia . shows_string
                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                        'u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g'] .
                      shows_nl . indent x)))
      (\ r ->
        let {
          tp = mkc i False [] r [];
        } in catch_errora
               (check_trs_termination_proof i j a (ia . shows_string ['.', '1'])
                 tp prf)
               (\ x ->
                 Inl (ia . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 's', 't', 'r', 'o', 'n', 'g',
                               ' ', 'n', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a',
                               't', 'i', 'o', 'n', ' ', '+', ' ', 'w', 'c',
                               'r'] .
                             shows_nl . indent x))));

check_subsumptions_guided ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [((Term a b, Term a b),
                       [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumptions_guided e [] = Inr ();
check_subsumptions_guided ea ((e, seq) : convs) =
  bindb (catch_errora (check_conversiona ea seq (fst e) (snd e))
          (\ x ->
            Inl (shows_string
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c',
                     'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'f', 'o',
                     'r', ' ', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '=', ' '] e .
                    shows_nl . x)))
    (\ _ -> check_subsumptions_guided (e : ea) convs);

check_subsumption_guided ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption_guided ea e convs =
  bindb (catch_errora (check_subseteq ea (map fst convs))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i',
                     'n', 'd', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o',
                     'n', ' ', 'f', 'o', 'r', ' ', 'e', 'q', 'u', 'a', 't', 'i',
                     'o', 'n', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '=', ' '] x)))
    (\ _ -> check_subsumptions_guided e convs);

check_subsumption_NF ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption_NF e r =
  catch_errora
    (forallM
      (\ ea ->
        catch_errora (check_join_NF r (fst ea) (snd ea))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'j', 'o',
                     'i', 'n', ' ', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
                     ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '=', ' '] ea .
                    shows_nl . x)))
      e)
    (\ x -> Inl (snd x));

check_subsumption ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Maybe [((Term a b, Term a b),
                               [(Pos, ((Term a b, Term a b),
(Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption e r convs_o = (case convs_o of {
                                  Nothing -> check_subsumption_NF e r;
                                  Just a -> check_subsumption_guided e r a;
                                });

check_completion_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])] ->
                              Completion_proof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_completion_proof a ia i j e r (SN_WCR_Eq joins_i prf conv1 conv2) =
  debug (ia []) ['S', 'N', '_', 'W', 'C', 'R', '_', 'E', 'q']
    (let {
       tp = mkc i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a
                    (ia . shows_string ['.', '1']) tp prf)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 's', 't', 'r', 'o',
                                  'n', 'g', ' ', 'n', 'o', 'r', 'm', 'a', 'l',
                                  'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', '+',
                                  ' ', 'w', 'c', 'r'] .
                                shows_nl . indent x)))
            (\ _ ->
              bindb (catch_errora (check_subsumption_guided r e conv1)
                      (\ x ->
                        Inl (ia . shows_prec_list zero_nat
                                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ',
                                      'w', 'h', 'e', 'n', ' ', 's', 'h', 'o',
                                      'w', 'i', 'n', 'g', ' ', 't', 'h', 'a',
                                      't', ' ', 'r', 'e', 'w', 'r', 'i', 't',
                                      'e', ' ', 'r', 'e', 'l', 'a', 't', 'i',
                                      'o', 'n', ' ', 'c', 'a', 'n', ' ', 'b',
                                      'e', ' ', 's', 'i', 'm', 'u', 'l', 'a',
                                      't', 'e', 'd', ' ', 'b', 'y', ' ', 'e',
                                      'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] .
                                    shows_nl . indent x)))
                (\ _ ->
                  bindb (catch_errora (check_subsumption e r conv2)
                          (\ x ->
                            Inl (ia . shows_prec_list zero_nat
[':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'h', 'o',
  'w', 'i', 'n', 'g', ' ', 't', 'h', 'a', 't', ' ', 'e', 'q', 'u', 'a', 't',
  'i', 'o', 'n', 's', ' ', 'c', 'a', 'n', ' ', 'b', 'e', ' ', 's', 'i', 'm',
  'u', 'l', 'a', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'r', 'e', 'w', 'r', 'i',
  't', 'e', ' ', 's', 'y', 's', 't', 'e', 'm'] .
shows_nl . indent x)))
                    (\ _ ->
                      catch_errora
                        (check_critical_pairs r (critical_pairs_impl r r)
                          joins_i)
                        (\ x ->
                          Inl (ia . shows_prec_list zero_nat
                                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ',
'w', 'h', 'e', 'n', ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'l', 'o', 'c',
'a', 'l', ' ', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'o', 'f',
' '] .
                                      shows_nl .
shows_tp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) i tp .
  shows_nl . indent x))))));

check_equational_disproof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            (Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]) ->
                              Equational_disproof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_equational_disproof a ia i j e eq
  (Completion_and_Normalization_Different r p) =
  debug (ia [])
    ['C', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', '_', 'a', 'n', 'd', '_',
      'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n']
    (bindb (check_completion_proof a ia i j e r p)
      (\ _ ->
        let {
          s = fst eq;
          t = snd eq;
        } in (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
               (Nothing, _) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab zero_nat)
                             (shows_prec_list zero_nat) t);
               (Just _, Nothing) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab zero_nat)
                             (shows_prec_list zero_nat) t);
               (Just sa, Just ta) ->
                 (if not (equal_term sa ta) then Inr ()
                   else Inl (shows_term (shows_prec_lab zero_nat)
                               (shows_prec_list zero_nat) s .
                              shows_string [' ', 'a', 'n', 'd', ' '] .
                                shows_term (shows_prec_lab zero_nat)
                                  (shows_prec_list zero_nat) t .
                                  shows_string
                                    [' ', 'h', 'a', 'v', 'e', ' ', 's', 'a',
                                      'm', 'e', ' ', 'n', 'o', 'r', 'm', 'a',
                                      'l', ' ', 'f', 'o', 'r', 'm', ' '] .
                                    shows_term (shows_prec_lab zero_nat)
                                      (shows_prec_list zero_nat) sa));
             })));

shows_overlap ::
  forall a b c d e.
    (Showa a, Showa b, Showa c, Showa d,
      Showa e) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    ((Term c d, Term c d), [(Term c d, Term c d)]) ->
                      e -> [Prelude.Char] -> [Prelude.Char];
shows_overlap rho_1 rho_2 p =
  ((((shows_prec_list zero_nat
        ['t', 'h', 'e', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'o', 'f',
          ' ', 'r', 'u', 'l', 'e', ' '] .
       shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rho_1) .
      shows_prec_list zero_nat
        [' ', 'w', 'i', 't', 'h', ' ', 'r', 'u', 'l', 'e', ' ']) .
     shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rho_2) .
    shows_prec_list zero_nat
      [' ', 'a', 't', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ']) .
    shows_prec zero_nat p;

match_crule ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                           ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                             Maybe (b -> Term a b);
match_crule rho_1 rho_2 =
  bind (zip_option
         (fst (fst rho_2) :
           snd (fst rho_2) : map fst (snd rho_2) ++ map snd (snd rho_2))
         (fst (fst rho_1) :
           snd (fst rho_1) : map fst (snd rho_1) ++ map snd (snd rho_1)))
    (match_list Var);

check_overlap ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Infinite a, Showa a, Eq b,
      Showa b) => (a -> a) ->
                    (a -> a) ->
                      ([((Term b a, Term b a), [(Term b a, Term b a)])] ->
                        [(Term b a, Term b a)] ->
                          [(Term b a, Term b a)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        [((Term b a, Term b a), [(Term b a, Term b a)])] ->
                          ((Term b a, Term b a), [(Term b a, Term b a)]) ->
                            ((Term b a, Term b a), [(Term b a, Term b a)]) ->
                              Pos -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_overlap xvar yvar check_infeasible r rho_1 rho_2 p =
  catch_errora
    (case mgu_var_disjoint_generic xvar yvar (subt_at (fst (fst rho_1)) p)
            (fst (fst rho_2))
      of {
      Nothing -> Inr ();
      Just (sigma_1, sigma_2) ->
        catch_errora
          (choicea
            [check (equal_pos p Empty &&
                     equal_term (subst_apply_term (snd (fst rho_1)) sigma_1)
                       (subst_apply_term (snd (fst rho_2)) sigma_2))
               (shows_prec_list zero_nat
                 ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 't', 'r', 'i',
                   'v', 'i', 'a', 'l', ' ', 'r', 'o', 'o', 't', '-', 'o', 'v',
                   'e', 'r', 'l', 'a', 'p']),
              check (equal_pos p Empty &&
                      not (is_none (match_crule rho_1 rho_2)) &&
                        not (is_none (match_crule rho_2 rho_1)))
                (shows_prec_list zero_nat
                  ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r', 'o', 'o',
                    't', '-', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'o', 'f',
                    ' ', 'v', 'a', 'r', 'i', 'a', 'n', 't', 's', ' ', 'o', 'f',
                    ' ', 't', 'h', 'e', ' ', 's', 'a', 'm', 'e', ' ', 'r', 'u',
                    'l', 'e']),
              catch_errora
                (check_infeasible r (subst_list sigma_1 (snd rho_1))
                  (subst_list sigma_2 (snd rho_2)))
                (\ x ->
                  Inl ((shows_prec_list zero_nat
                          ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                            'b', 'e', ' ', 's', 'h', 'o', 'w', 'n', ' ', 't',
                            'o', ' ', 'b', 'e', ' ', 'i', 'n', 'f', 'e', 'a',
                            's', 'i', 'b', 'l', 'e'] .
                         shows_nl) .
                        x))])
          (\ x -> Inl (shows_sep id shows_nl x));
    })
    (\ x -> Inl ((shows_overlap rho_1 rho_2 p . shows_nl) . x));

check_ao ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Mapping_impl a, Infinite a, Set_impl a, Showa a,
      Eq b,
      Showa b) => (a -> a) ->
                    (a -> a) ->
                      ([((Term b a, Term b a), [(Term b a, Term b a)])] ->
                        [(Term b a, Term b a)] ->
                          [(Term b a, Term b a)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        [((Term b a, Term b a), [(Term b a, Term b a)])] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ao xvar yvar check_infeasible r =
  bindb (check_left_linear_trs (map fst r))
    (\ _ ->
      catch_errora
        (forallM
          (\ rho_1 ->
            let {
              l_1 = fst (fst rho_1);
            } in catch_errora
                   (forallM
                     (\ rho_2 ->
                       catch_errora
                         (forallM
                           (check_overlap xvar yvar check_infeasible r rho_1
                             rho_2)
                           (funposs_list l_1))
                         (\ x -> Inl (snd x)))
                     r)
                   (\ x -> Inl (snd x)))
          r)
        (\ x -> Inl (snd x)));

check_rules_subseteq ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [Ta_rule a b] ->
                    Tree_automaton a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rules_subseteq rs a =
  catch_errora (check_subseteq rs (ta_rules_implb a))
    (\ x ->
      Inl ((shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
             shows_prec_ta_rule zero_nat x) .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g']));

ta_inter_eps_empty ::
  forall a b c d.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ceq b, Ccompare b, Eq b, Set_impl b,
      Ceq c, Ccompare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Ta_ext c b d -> Ta_ext (a, c) b ();
ta_inter_eps_empty ta t =
  Ta_ext (productc (ta_final ta) (ta_final t))
    (image (\ (TA_rule f ps p, TA_rule _ qs q) -> TA_rule f (zip ps qs) (p, q))
      (sup_seta
        (image
          (\ f ->
            productc (filtera (\ r -> r_sym r == f) (ta_rules ta))
              (filtera (\ r -> r_sym r == f) (ta_rules t)))
          (ta_syms ta))))
    bot_set ();

add_rule_states :: forall a b. (Eq a) => [Ta_rule a b] -> [a] -> [a];
add_rule_states rs ss =
  fold (\ r ssa -> let {
                     (TA_rule _ qs q) = r;
                   } in insertb q (fold insertb qs ssa))
    rs ss;

sig_rules ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Ccompare b,
      Eq b) => Set (a, Nat) -> b -> Set (Ta_rule b a);
sig_rules f c = image (\ (fa, n) -> TA_rule fa (replicate n c) c) f;

star :: forall a b. a -> Term a b -> Term a b;
star c (Var x) = Fun c [];
star c (Fun f ts) = Fun f (map (star c) ts);

ground_instances_rules ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Set (a, Nat) -> a -> Term a b -> Set (Ta_rule (Term a b) a);
ground_instances_rules f c (Var x) = sig_rules f (Fun c []);
ground_instances_rules fa c (Fun f ts) =
  sup_set
    (inserta (TA_rule f (map (star c) ts) (star c (Fun f ts)))
      (set_empty (of_phantom set_impl_ta_rule)))
    (sup_seta (image (ground_instances_rules fa c) (set ts)));

ground_instances_ta ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Set (a, Nat) -> a -> Term a b -> Ta_ext (Term a b) a ();
ground_instances_ta f c t =
  Ta_ext (inserta (star c t) (set_empty (of_phantom set_impl_term)))
    (ground_instances_rules f c t)
    (set_empty
      (of_phantom (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla)))
    ();

sig_rules_list :: forall a b. [(a, Nat)] -> b -> [Ta_rule b a];
sig_rules_list f c = map (\ (fa, n) -> TA_rule fa (replicate n c) c) f;

gi_rules_list ::
  forall a b. [(a, Nat)] -> a -> Term a b -> [Ta_rule (Term a b) a];
gi_rules_list f c (Var x) = sig_rules_list f (Fun c []);
gi_rules_list fa c (Fun f ts) =
  TA_rule f (map (star c) ts) (star c (Fun f ts)) :
    concatMap (gi_rules_list fa c) ts;

growing_rule ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Bool;
growing_rule (l, r) =
  ball (vars_term r)
    (\ x ->
      ball (varposs l)
        (\ p ->
          (if equal_term (Var x) (subt_at l p)
            then less_eq_nat (size_pos p) one_nat else True)));

growing ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => Set (Term a b, Term a b) -> Bool;
growing r = ball r growing_rule;

check_growing ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_growing r =
  check (growing (set r))
    (shows_prec_list zero_nat
      ['T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'g', 'r', 'o',
        'w', 'i', 'n', 'g']);

combs :: forall a b. [a] -> [b] -> [[(a, b)]];
combs [] ys = [[]];
combs (x : xs) ys = concatMap (\ l -> map (\ y -> (x, y) : l) ys) (combs xs ys);

state_substs :: forall a b. [a] -> [b] -> [[(a, b)]];
state_substs v q = combs v q;

lhss_impl :: forall a b. (Eq a) => [(a, b)] -> [a];
lhss_impl r = remdups (map fst r);

mp_ta_rules ::
  forall a b c.
    (Eq a,
      Eq b) => [(Term a b, c)] -> [(a, Nat)] -> a -> [Ta_rule (Term a b) a];
mp_ta_rules r f c = concatMap (gi_rules_list f c) (lhss_impl r);

reachable_states ::
  forall a b c.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Set (Ta_rule a b) -> Term (Sum b a) c -> Set a;
reachable_states delta (Fun (Inr q) []) = inserta q bot_set;
reachable_states delta (Fun (Inl f) ts) =
  image r_rhs
    (filtera
      (\ r ->
        r_root r == f &&
          equal_nat (size_list (r_lhs_states r)) (size_list ts) &&
            all_interval_nat
              (\ i ->
                member (nth (r_lhs_states r) i)
                  (reachable_states delta (nth ts i)))
              zero_nat (size_list ts))
      delta);
reachable_states delta (Var v) = bot_set;
reachable_states delta (Fun (Inr va) (vb : vc)) = bot_set;

qi :: forall a b.
        (Eq b) => a -> Term a b -> (b -> Term a b) -> Term a b -> Term a b;
qi c t g (Var x) = (if contains_var_term x t then g x else star c (Var x));
qi c t g (Fun f ts) = star c (Fun f ts);

inf_step ::
  forall a b.
    (Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => a -> [(Term a b, Term a b)] ->
                      [[(b, Term a b)]] ->
                        Set (Ta_rule (Term a b) a) ->
                          Set (Ta_rule (Term a b) a);
inf_step c r s delta =
  foldr (sup_set .
          (\ (a, b) ->
            let {
              (l, ra) = a;
            } in (\ theta ->
                   let {
                     (Fun f ls) = l;
                   } in image (TA_rule f (map (qi c ra (fun_of theta)) ls))
                          ((reachable_states ::
                             Set (Ta_rule (Term a b) a) ->
                               Term (Sum a (Term a b)) b -> Set (Term a b))
                            delta
                            (subst_apply_term (map_term Inl (\ x -> x) ra)
                              ((\ fa -> Fun (Inr fa) []) . fun_of theta))))
              b))
    (product r s) (set_empty (of_phantom set_impl_ta_rule));

funas_ta_rule ::
  forall a b. (Ceq b, Ccompare b, Set_impl b) => Ta_rule a b -> Set (b, Nat);
funas_ta_rule r = inserta (r_root r, size_list (r_lhs_states r)) bot_set;

funas_ta ::
  forall a b.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b,
      Set_impl b) => Ta_ext a b () -> Set (b, Nat);
funas_ta a = sup_seta (image funas_ta_rule (ta_rules a));

check_etac_nonreachable ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Default a,
      Eq a, Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => [(a, Nat)] ->
                    a -> a -> Tree_automaton (Term a b) a ->
                                [(Term a b, Term a b)] ->
                                  Term a b ->
                                    Term a b ->
                                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_etac_nonreachable f aa c a r s t =
  let {
    fa = set f;
  } in bindb (check (member (aa, zero_nat) fa)
               ((shows_prec_list zero_nat
                   ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' '] .
                  shows_prec zero_nat aa) .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 's',
                     'i', 'g', 'n', 'a', 't', 'u', 'r', 'e']))
         (\ _ ->
           bindb (check (not (member (c, zero_nat) fa))
                   (shows_prec_list zero_nat
                     ['s', 't', 'a', 'r', '-', 's', 'y', 'm', 'b', 'o', 'l',
                       ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e',
                       's', 'h', ' ', 'w', '.', 'r', '.', 't', '.', ' ', 's',
                       'i', 'g', 'n', 'a', 't', 'u', 'r', 'e']))
             (\ _ ->
               bindb (catch_errora (check_subseteq (insert_funas_term s []) f)
                       (\ _ ->
                         Inl (shows_prec_list zero_nat
                               ['l', 'h', 's', ' ', 'v', 'i', 'o', 'l', 'a',
                                 't', 'e', 's', ' ', 's', 'i', 'g', 'n', 'a',
                                 't', 'u', 'r', 'e'])))
                 (\ _ ->
                   bindb (catch_errora
                           (check_subseteq (insert_funas_term t []) f)
                           (\ _ ->
                             Inl (shows_prec_list zero_nat
                                   ['r', 'h', 's', ' ', 'v', 'i', 'o', 'l', 'a',
                                     't', 'e', 's', ' ', 's', 'i', 'g', 'n',
                                     'a', 't', 'u', 'r', 'e'])))
                     (\ _ ->
                       let {
                         fs = insert_funas_trs r [];
                       } in bindb (catch_errora (check_subseteq fs f)
                                    (\ _ ->
                                      Inl
(shows_prec_list zero_nat
  ['T', 'R', 'S', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 's', 'i',
    'g', 'n', 'a', 't', 'u', 'r', 'e'])))
                              (\ _ ->
                                bindb (check_varcond_no_Var_lhs r)
                                  (\ _ ->
                                    bindb (check_linear_trs r)
                                      (\ _ ->
bindb (check_growing r)
  (\ _ ->
    let {
      aaa = ta_of_ta a;
    } in bindb (check
                 (set_eq (ta_eps aaa)
                   (set_empty
                     (of_phantom
                       (set_impl_prod ::
                         Phantom (Term a b, Term a b) Set_impla))))
                 (shows_prec_list zero_nat
                   ['n', 'o', ' ', 'e', 'p', 's', 'i', 'l', 'o', 'n', ' ', 't',
                     'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 's', ' ', 'a',
                     'l', 'l', 'o', 'w', 'e', 'd']))
           (\ _ ->
             bindb (check (member (star c t) (ta_final aaa))
                     ((shows_prec_list zero_nat
                         ['f', 'i', 'n', 'a', 'l', ' ', 's', 't', 'a', 't', 'e',
                           ' ', 'f', 'o', 'r', ' '] .
                        shows_prec_term zero_nat t) .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                           'g']))
               (\ _ ->
                 bindb (check (less_eq_set (funas_ta aaa) fa)
                         (shows_prec_list zero_nat
                           ['t', 'h', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ',
                             'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ',
                             'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'r',
                             'e', 's', 'p', 'e', 'c', 't', ' ', 't', 'h', 'e',
                             ' ', 's', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e']))
                   (\ _ ->
                     let {
                       ts = gi_rules_list f c t;
                       ms = mp_ta_rules r f c;
                     } in bindb (check_rules_subseteq ts a)
                            (\ _ ->
                              bindb (check_rules_subseteq ms a)
                                (\ _ ->
                                  let {
                                    q = add_rule_states ts
  (add_rule_states ms []);
                                    ss = state_substs
   (remdups (concatMap (vars_term_list . snd) r)) q;
                                    d = set (ta_rules_implb a);
                                    da = inf_step c r ss d;
                                  } in bindb
 (check (less_eq_set da d)
   (shows_prec_list zero_nat
     ['t', 'h', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ', 't', 'r', 'e', 'e', ' ',
       'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ', 'i', 's', ' ', 'n',
       'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'u', 'n', 'd', 'e',
       'r', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', ' ', 'r',
       'u', 'l', 'e', 's']))
 (\ _ ->
   check (ta_empty (ta_inter_eps_empty aaa (ground_instances_ta fa c s)))
     (shows_prec_list zero_nat
       ['t', 'h', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ', 't', 'r', 'e', 'e',
         ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ', 'd', 'o', 'e',
         's', ' ', 'n', 'o', 't', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'y', ' ',
         'n', 'o', 'n', '-', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'i', 'l', 'i',
         't', 'y'])))))))))))))));

is_instance_rule ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b, Term a b) -> (Term a b, Term a b) -> Bool;
is_instance_rule ra r =
  (case match_list Var [(fst r, fst ra), (snd r, snd ra)] of {
    Nothing -> False;
    Just _ -> True;
  });

check_subst_overapproximation ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subst_overapproximation ra r =
  catch_errora
    (catch_errora
      (forallM
        (\ raa ->
          catch_errora (existsM (\ rb -> check (is_instance_rule raa rb) id) r)
            (\ _ ->
              Inl (((shows_prec_list zero_nat
                       ['g', 'r', 'o', 'w', 'i', 'n', 'g', ' ', 'r', 'u', 'l',
                         'e', ' ', 'f', 'o', 'r', ' '] .
                      shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                        [' ', '-', '>', ' '] raa) .
                     shows_prec_list zero_nat
                       [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                         'g']) .
                    shows_nl)))
        ra)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((((((shows_prec_list zero_nat r . shows_nl) .
                shows_prec_list zero_nat
                  ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'o', 'v',
                    'e', 'r', 'a', 'p', 'p', 'r', 'o', 'x', 'i', 'm', 'a', 't',
                    'i', 'o', 'n', ' ', 'o', 'f']) .
               shows_nl) .
              shows_prec_list zero_nat ra) .
             shows_nl) .
            x));

check_nonreachable ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Default a,
      Eq a, Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      Term a b ->
                        Nonreachability_proof a b ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_nonreachable r s t Nonreachable_Tcap =
  check (not (matchb (tcapI r s) t))
    (shows_prec_list zero_nat
      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 's', 'h', 'o', 'w',
        ' ', 'n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'i', 'l', 'i',
        't', 'y', ' ', 'v', 'i', 'a', ' ', 't', 'c', 'a', 'p']);
check_nonreachable r s t (Nonreachable_ETAC f aa c a) =
  check_etac_nonreachable f aa c a r s t;
check_nonreachable ra s t (Nonreachable_Subst_Approx r p) =
  bindb (check_subst_overapproximation ra r)
    (\ _ -> check_nonreachable r s t p);
check_nonreachable r s t (Nonreachable_Reverse p) =
  check_nonreachable (map (\ (x, y) -> (y, x)) r) t s p;

check_nonjoinable ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      Term a b ->
                        Nonjoinability_proof a b ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_nonjoinable r s t Nonjoinable_Tcap =
  check (not (unifiable (tcapI r s) (tcapI r t)))
    (shows_prec_list zero_nat
      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 's', 'h', 'o', 'w',
        ' ', 'n', 'o', 'n', 'j', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't',
        'y', ' ', 'v', 'i', 'a', ' ', 't', 'c', 'a', 'p']);
check_nonjoinable r s t (Nonjoinable_Ground_NF p) =
  (if is_NF_trs r s && ground s then check_nonreachable r t s p
    else (if is_NF_trs r t && ground t then check_nonreachable r s t p
           else Inl (shows_prec_list zero_nat ['n', 'o', 'n', ' ', 'N', 'F'])));

check_infeasiblea ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Mapping_impl b, Set_impl b,
      Showa b) => [((Term a b, Term a b), c)] ->
                    [(Term a b, Term a b)] ->
                      Infeasibility_proof a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_infeasiblea r cs (Infeasible_Compound_Conditions f p) =
  check_nonreachable (map fst r) (Fun f (map fst cs)) (Fun f (map snd cs)) p;
check_infeasiblea r cs (Infeasible_Equation s t p) =
  bindb (check (membera cs (s, t))
          (((shows_prec_list zero_nat
               ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
              shows_eq (shows_prec zero_nat) (shows_prec zero_nat) (s, t)) .
             shows_prec_list zero_nat
               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'l', 'i',
                 's', 't', ' ', 'o', 'f', ' ', 'c', 'o', 'n', 'd', 'i', 't',
                 'i', 'o', 'n', 's']) .
            shows_nl))
    (\ _ -> check_nonreachable (map fst r) s t p);
check_infeasiblea r csa (Infeasible_Subset cs p) =
  bindb (catch_errora (check_subseteq cs csa)
          (\ x ->
            Inl (((shows_prec_list zero_nat
                     ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
                    shows_eq (shows_prec zero_nat) (shows_prec zero_nat) x) .
                   shows_prec_list zero_nat
                     [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ',
                       'l', 'i', 's', 't', ' ', 'o', 'f', ' ', 'c', 'o', 'n',
                       'd', 'i', 't', 'i', 'o', 'n', 's']) .
                  shows_nl)))
    (\ _ -> check_infeasiblea r cs p);
check_infeasiblea r cs (Infeasible_Rhss_Equal s t u p) =
  bindb (check (membera cs (s, u))
          (((shows_prec_list zero_nat
               ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
              shows_eq (shows_prec zero_nat) (shows_prec zero_nat) (s, u)) .
             shows_prec_list zero_nat
               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'l', 'i',
                 's', 't', ' ', 'o', 'f', ' ', 'c', 'o', 'n', 'd', 'i', 't',
                 'i', 'o', 'n', 's']) .
            shows_nl))
    (\ _ ->
      bindb (check (membera cs (t, u))
              (((shows_prec_list zero_nat
                   ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
                  shows_eq (shows_prec zero_nat) (shows_prec zero_nat) (t, u)) .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'l',
                     'i', 's', 't', ' ', 'o', 'f', ' ', 'c', 'o', 'n', 'd', 'i',
                     't', 'i', 'o', 'n', 's']) .
                shows_nl))
        (\ _ -> check_nonjoinable (map fst r) s t p));

check_ao_infeasiblea ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Mapping_impl b, Set_impl b,
      Showa b) => [((Term a b, Term a b), c)] ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        Ao_infeasibility_proof a b ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ao_infeasiblea r cs_1 cs_2 (AO_Infeasibility_Proof p) =
  check_infeasiblea r (cs_1 ++ cs_2) p;
check_ao_infeasiblea r cs_1 cs_2 (AO_Lhss_Equal s t u p) =
  bindb (check (membera cs_1 (s, t))
          ((shows_eq (shows_prec zero_nat) (shows_prec zero_nat) (s, t) .
             shows_prec_list zero_nat
               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'e', 'q',
                 'u', 'a', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ']) .
            shows_conditions (shows_prec zero_nat) (shows_prec zero_nat) cs_1))
    (\ _ ->
      bindb (check (membera cs_2 (s, u))
              ((shows_eq (shows_prec zero_nat) (shows_prec zero_nat) (s, u) .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'e',
                     'q', 'u', 'a', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ']) .
                shows_conditions (shows_prec zero_nat) (shows_prec zero_nat)
                  cs_2))
        (\ _ -> check_nonjoinable (map fst r) t u p));

match_rules ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] -> Maybe (b -> Term a b);
match_rules rs_1 rs_2 =
  bind (zip_option (map fst rs_2 ++ map snd rs_2)
         (map fst rs_1 ++ map snd rs_1))
    (match_list Var);

check_ao_infeasible ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Mapping_impl b, Set_impl b,
      Showa b) => [([(Term a b, Term a b)],
                     ([(Term a b, Term a b)], Ao_infeasibility_proof a b))] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ao_infeasible css r cs_1 cs_2 =
  catch_errora
    (existsM
      (\ (cs_1a, (cs_2a, p)) ->
        let {
          cs = cs_1 ++ cs_2;
          csa = cs_1a ++ cs_2a;
        } in bindb (check
                     (equal_nat (size_list cs_1a) (size_list cs_1) &&
                       equal_nat (size_list cs_2a) (size_list cs_2))
                     (shows_prec_list zero_nat
                       ['l', 'e', 'n', 'g', 't', 'h', 's', ' ', 'd', 'i', 'f',
                         'f', 'e', 'r']))
               (\ _ ->
                 bindb (check
                         (not (is_none (match_rules csa cs)) &&
                           not (is_none (match_rules cs csa)))
                         id)
                   (\ _ -> check_ao_infeasiblea r cs_1a cs_2a p)))
      css)
    (\ x -> Inl (shows_sep id shows_nl x));

check_almost_orthogonal_modulo_infeasibilitya ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a,
      Showa a) => [([(Term a [Prelude.Char], Term a [Prelude.Char])],
                     ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                       Ao_infeasibility_proof a [Prelude.Char]))] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]),
                       [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_almost_orthogonal_modulo_infeasibilitya css r =
  check_ao (\ a -> 'x' : a) (\ a -> 'y' : a) (check_ao_infeasible css) r;

x_vars ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                       Nat -> Set b;
x_vars rho i =
  sup_set (vars_term (fst (fst rho)))
    (sup_seta (image vars_term (image snd (set (take i (snd rho))))));

extended_properly_oriented ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => Set ((Term a b, Term a b), [(Term a b, Term a b)]) -> Bool;
extended_properly_oriented r =
  ball r
    (\ rho ->
      less_eq_set (vars_term (snd (fst rho))) (vars_term (fst (fst rho))) ||
        not (all_interval_nat
              (not .
                (\ m ->
                  all_interval_nat
                    (\ i ->
                      less_eq_set (vars_term (fst (nth (snd rho) i)))
                        (x_vars rho i))
                    zero_nat m &&
                    all_interval_nat
                      (\ i ->
                        less_eq_set
                          (inf_set (vars_term (snd (fst rho)))
                            (vars_rule (nth (snd rho) i)))
                          (x_vars rho m))
                      m (size_list (snd rho))))
              zero_nat (suc (size_list (snd rho)))));

check_extended_properly_oriented ::
  forall a b.
    (Compare a, Eq a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_extended_properly_oriented r =
  check (extended_properly_oriented (set r))
    (shows_prec_list zero_nat
       ['t', 'h', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ', 'C', 'T', 'R', 'S',
         ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't', 'e', 'n', 'd',
         'e', 'd', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 'l', 'y', ' ', 'o', 'r',
         'i', 'e', 'n', 't', 'e', 'd'] .
      shows_nl);

funas_crule ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => ((Term a b, Term a b), [(Term a b, Term a b)]) -> Set (a, Nat);
funas_crule rho = sup_set (funas_rule (fst rho)) (funas_trs (set (snd rho)));

funas_ctrs ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Set ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                 Set (a, Nat);
funas_ctrs r = sup_seta (image funas_crule r);

check_constructor_term ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showa a, Compare b, Eq b,
      Showa b) => Term a b ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_constructor_term s r =
  check (less_eq_set (funas_term s)
          (minus_set (funas_ctrs (set r)) (set (defined_list (map fst r)))))
    (((shows_prec_list zero_nat ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
        shows_term (shows_prec zero_nat) (shows_prec zero_nat) s) .
       shows_prec_list zero_nat
         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'c', 'o', 'n', 's',
           't', 'r', 'u', 'c', 't', 'o', 'r', ' ', 't', 'e', 'r', 'm']) .
      shows_nl);

check_Ru_NF ::
  forall a b.
    (Eq a, Key a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Term a b ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_Ru_NF s r =
  check (is_NF_trs (map fst r) s)
    (((shows_prec_list zero_nat ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
        shows_term (shows_prec zero_nat) (shows_prec zero_nat) s) .
       shows_prec_list zero_nat
         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'R', 'u', ' ',
           'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']) .
      shows_nl);

check_linear_term ::
  forall a b.
    (Showa a, Ceq b, Ccompare b, Set_impl b,
      Showa b) => Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_linear_term s =
  check (linear_term s)
    (((shows_prec_list zero_nat ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
        shows_term (shows_prec zero_nat) (shows_prec zero_nat) s) .
       shows_prec_list zero_nat
         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'l', 'i', 'n', 'e', 'a',
           'r']) .
      shows_nl);

check_ground_term ::
  forall a b.
    (Showa a, Showa b) => Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ground_term s =
  check (ground s)
    (((shows_prec_list zero_nat ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
        shows_term (shows_prec zero_nat) (shows_prec zero_nat) s) .
       shows_prec_list zero_nat
         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'g', 'r', 'o', 'u',
           'n', 'd', ' ', 't', 'e', 'r', 'm']) .
      shows_nl);

check_right_stable ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Key a, Set_impl a,
      Showa a, Ceq b, Ccompare b, Compare b, Eq b, Mapping_impl b, Set_impl b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_right_stable r =
  catch_errora
    (catch_errora
      (forallM
        (\ ra ->
          catch_errora
            (forallM
              (\ i ->
                let {
                  t_i = snd (nth (snd ra) i);
                } in bindb (catch_errora
                             (check_disjoint
                               (vars_term_list (fst (fst ra)) ++
                                 concatMap (\ (s, _) -> vars_term_list s)
                                   (take (suc i) (snd ra)) ++
                                   concatMap (\ (_, a) -> vars_term_list a)
                                     (take i (snd ra)))
                               (vars_term_list t_i))
                             (\ x ->
                               Inl (((((shows_prec_list zero_nat
  ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
 shows_prec zero_nat x) .
shows_prec_list zero_nat
  [' ', 'i', 'n', ' ', 'r', 'h', 's', ' ', 'o', 'f', ' ', 'c', 'o', 'n', 'd',
    'i', 't', 'i', 'o', 'n', ' ']) .
                                       shows_prec_nat zero_nat i) .
                                      shows_prec_list zero_nat
[' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's', 'h']) .
                                     shows_nl)))
                       (\ _ ->
                         catch_errora
                           (choicea
                             [bindb (check_linear_term t_i)
                                (\ _ -> check_constructor_term t_i r),
                               bindb (check_ground_term t_i)
                                 (\ _ -> check_Ru_NF t_i r)])
                           (\ x -> Inl (shows_sep id shows_nl x))))
              (upt zero_nat (size_list (snd ra))))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                'o', 't', ' ', 'r', 'i', 'g', 'h', 't', ' ', 's', 't', 'a', 'b',
                'l', 'e'] .
             shows_nl) .
            x));

check_type3 ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_type3 r =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (check_subseteq (vars_term_list (snd (fst cr)))
              (vars_term_list (fst (fst cr)) ++ vars_trs_list (snd cr)))
            (\ x ->
              Inl ((((shows_prec_list zero_nat
                        ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                       shows_prec zero_nat x) .
                      shows_prec_list zero_nat
                        [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 'o', 'n', 'l',
                          'y', ' ', 'i', 'n', ' ', 'r', 'i', 'g', 'h', 't', '-',
                          'h', 'a', 'n', 'd', ' ', 's', 'i', 'd', 'e', ' ', 'o',
                          'f', ' ', 'r', 'u', 'l', 'e', ' ']) .
                     shows_crule (shows_prec zero_nat) (shows_prec zero_nat)
                       cr) .
                    shows_nl)))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                'o', 't', ' ', 'o', 'f', ' ', 't', 'y', 'p', 'e', ' ', '3'] .
             shows_nl) .
            x));

check_level_confluence_modulo_infeasibilitya ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a,
      Showa a) => [([(Term a [Prelude.Char], Term a [Prelude.Char])],
                     ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                       Ao_infeasibility_proof a [Prelude.Char]))] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]),
                       [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_level_confluence_modulo_infeasibilitya css r =
  bindb (check_varcond_no_Var_lhs (map fst r))
    (\ _ ->
      bindb (check_type3 r)
        (\ _ ->
          bindb (check_extended_properly_oriented r)
            (\ _ ->
              bindb (check_right_stable r)
                (\ _ -> check_almost_orthogonal_modulo_infeasibilitya css r))));

trancl_impl ::
  forall a b.
    ([(a, a)] -> [a] -> [a]) ->
      ([a] -> b -> b) -> (a -> b -> Bool) -> b -> [(a, a)] -> [a] -> b;
trancl_impl gen_succ un memb emp rel =
  let {
    succ = gen_succ rel;
    n = size_list rel;
  } in (\ asa -> relpow_impl succ un memb (succ asa) emp n);

trancl_list_impl :: forall a. (Eq a) => [(a, a)] -> [a] -> [a];
trancl_list_impl =
  trancl_impl
    (\ r asa ->
      remdups
        (map_filter
          (\ x -> (if let {
                        (a, _) = x;
                      } in membera asa a
                    then Just (snd x) else Nothing))
          r))
    (\ xs ys -> filter (\ x -> not (membera ys x)) xs ++ ys)
    (\ x xs -> membera xs x) [];

trancl_of_list :: forall a. (Eq a) => [(a, a)] -> [(a, a)];
trancl_of_list xs =
  concatMap (\ x -> map (\ a -> (x, a)) (trancl_list_impl xs [x])) (map fst xs);

check_infeasible ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Mapping_impl b, Set_impl b,
      Showa b) => [([(Term a b, Term a b)], Infeasibility_proof a b)] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_infeasible css r cs_1 cs_2 =
  catch_errora
    (existsM
      (\ (cs, p) ->
        let {
          csa = cs_1 ++ cs_2;
        } in bindb (check
                     (not (is_none (match_rules cs csa)) &&
                       not (is_none (match_rules csa cs)))
                     id)
               (\ _ -> check_infeasiblea r (trancl_of_list cs) p))
      css)
    (\ x -> Inl (shows_sep id shows_nl x));

check_almost_orthogonal_modulo_infeasibility ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a,
      Showa a) => [([(Term a [Prelude.Char], Term a [Prelude.Char])],
                     Infeasibility_proof a [Prelude.Char])] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]),
                       [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_almost_orthogonal_modulo_infeasibility css r =
  check_ao (\ a -> 'x' : a) (\ a -> 'y' : a) (check_infeasible css) r;

check_level_confluence_modulo_infeasibility ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a,
      Showa a) => [([(Term a [Prelude.Char], Term a [Prelude.Char])],
                     Infeasibility_proof a [Prelude.Char])] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]),
                       [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_level_confluence_modulo_infeasibility css r =
  bindb (check_varcond_no_Var_lhs (map fst r))
    (\ _ ->
      bindb (check_type3 r)
        (\ _ ->
          bindb (check_extended_properly_oriented r)
            (\ _ ->
              bindb (check_right_stable r)
                (\ _ -> check_almost_orthogonal_modulo_infeasibility css r))));

check_almost_orthogonal ::
  forall a.
    (Eq a,
      Showa a) => [((Term a [Prelude.Char], Term a [Prelude.Char]),
                     [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_almost_orthogonal r =
  check_ao (\ a -> 'x' : a) (\ a -> 'y' : a)
    (\ _ _ _ ->
      Inl (shows_string
            ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'i', 'l', 'i', 't', 'y',
              ' ', 'c', 'h', 'e', 'c', 'k', ' ', 'n', 'o', 't', ' ', 's', 'u',
              'p', 'p', 'o', 'r', 't', 'e', 'd']))
    r;

check_level_confluence ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Key a, Set_impl a,
      Showa a) => [((Term a [Prelude.Char], Term a [Prelude.Char]),
                     [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_level_confluence r =
  bindb (check_varcond_no_Var_lhs (map fst r))
    (\ _ ->
      bindb (check_type3 r)
        (\ _ ->
          bindb (check_extended_properly_oriented r)
            (\ _ ->
              bindb (check_right_stable r)
                (\ _ -> check_almost_orthogonal r))));

funs_crule_list ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> [a];
funs_crule_list r = add_funs_rule (fst r) (funs_trs_list (snd r));

funs_ctrs_list ::
  forall a b. [((Term a b, Term a b), [(Term a b, Term a b)])] -> [a];
funs_ctrs_list trs = concatMap funs_crule_list trs;

x_impl ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> [b];
x_impl cr i =
  concat
    (vars_term_list (fst (fst cr)) :
      map (vars_term_list . snd) (take i (snd cr)));

check_dctrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dctrs r =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                catch_errora
                  (check_subseteq (vars_term_list (fst (nth (snd cr) i)))
                    (x_impl cr i))
                  (\ x ->
                    Inl (((((((shows_prec_list zero_nat
                                 ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                                shows_prec zero_nat x) .
                               shows_prec_list zero_nat
                                 [' ', 'i', 'n', ' ', 'c', 'o', 'n', 'd', 'i',
                                   't', 'i', 'o', 'n', ' ']) .
                              shows_rule (shows_prec zero_nat)
                                (shows_prec zero_nat) [' ', '-', '>', ' ']
                                (nth (snd cr) i)) .
                             shows_prec_list zero_nat
                               [' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', ' ']) .
                            shows_crule (shows_prec zero_nat)
                              (shows_prec zero_nat) cr) .
                           shows_prec_list zero_nat
                             ['v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 'D',
                               'C', 'T', 'R', 'S', ' ', 'c', 'o', 'n', 'd', 'i',
                               't', 'i', 'o', 'n']) .
                          shows_nl)))
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                'o', 't', ' ', 'd', 'e', 't', 'e', 'r', 'm', 'i', 'n', 'i', 's',
                't', 'i', 'c'] .
             shows_nl) .
            x));

check_wf_ctrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_ctrs r =
  catch_errora
    (bindb (check_varcond_no_Var_lhs (map fst r))
      (\ _ -> bindb (check_dctrs r) (\ _ -> check_type3 r)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                'o', 't', ' ', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e',
                'd'] .
             shows_nl) .
            x));

check_source_preserving ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> [b]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_source_preserving crs zv =
  catch_errora
    (forallM
      (\ cr ->
        catch_errora
          (forallM
            (\ i ->
              catch_errora
                (catch_errora
                  (check_subseteq (vars_term_list (fst (fst cr))) (zv cr i))
                  (\ _ ->
                    Inl (shows_prec_list zero_nat
                           ['S', 'o', 'm', 'e', ' ', 'v', 'a', 'r', 'i', 'a',
                             'b', 'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's',
                             ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                             'o', 'c', 'c', 'u', 'r', ' ', 'i', 'n', ' ', 'Z',
                             '_'] .
                          shows_prec_nat zero_nat i .
                            shows_prec_list zero_nat ['.', ' ', '\n'])))
                (\ x ->
                  Inl (shows_string
                         ['T', 'h', 'e', ' ', 'u', 'n', 'r', 'a', 'v', 'e', 'l',
                           'i', 'n', 'g', ' ', 'i', 's', ' ', 'n', 'o', 't',
                           ' ', 's', 'o', 'u', 'r', 'c', 'e', ' ', 'p', 'r',
                           'e', 's', 'e', 'r', 'v', 'i', 'n', 'g', ' ', 'f',
                           'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
                        shows_crule (shows_prec zero_nat) (shows_prec zero_nat)
                          cr .
                          shows_nl . x)))
            (upt zero_nat (size_list (snd cr))))
          (\ x -> Inl (snd x)))
      crs)
    (\ x -> Inl (snd x));

y_impl ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> [b];
y_impl cr i =
  vars_term_list (snd (fst cr)) ++
    vars_term_list (snd (nth (snd cr) i)) ++
      vars_trs_list (drop (suc i) (snd cr));

check_Z_vars ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> [b]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_Z_vars crs z =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                catch_errora
                  (bindb
                    (catch_errora
                      (check_subseteq (list_inter (x_impl cr i) (y_impl cr i))
                        (z cr i))
                      (\ x ->
                        Inl (shows_string
                               ['V', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                              shows_prec zero_nat x .
                                shows_string
                                  [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't',
                                    ' ', 'o', 'c', 'c', 'u', 'r', ' ', 'i', 'n',
                                    ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
                                    ' ', 'l', 'i', 's', 't', ' ', 'o', 'f',
                                    ' '] .
                                  shows_prec_nat zero_nat (suc i) .
                                    shows_string
                                      ['.', ' ', 'U', '-', 's', 'y', 'm', 'b',
'o', 'l'] .
                                      shows_nl)))
                    (\ _ ->
                      check (distinct (z cr i))
                        (shows_string
                           [' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's',
                             ' ', 'i', 'n', ' ', 'a', 'd', 'd', 'i', 't', 'i',
                             'o', 'n', 'a', 'l', ' ', 'a', 'r', 'g', 'u', 'm',
                             'e', 'n', 't', 's', ' ', 'o', 'f', ' ', 'U', '-',
                             's', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'a', 'r',
                             'e', ' ', 'n', 'o', 't', ' ', 'd', 'i', 's', 't',
                             'i', 'n', 'c', 't', '.', ' '] .
                          shows_nl)))
                  (\ x ->
                    Inl (shows_string
                           ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's',
                             ' ', 'f', 'o', 'r', ' ', 'v', 'a', 'r', 'i', 'a',
                             'b', 'l', 'e', '-', 'l', 'i', 's', 't', 's', ' ',
                             'i', 'n', ' ', 'U', '-', 's', 'y', 'm', 'b', 'o',
                             'l', 's', ' ', 'f', 'o', 'r', ' '] .
                          shows_crule (shows_prec zero_nat)
                            (shows_prec zero_nat) cr .
                            shows_string
                              [' ', 'a', 'r', 'e', ' ', 'v', 'i', 'o', 'l', 'a',
                                't', 'e', 'd', '.'] .
                              shows_nl . x)))
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        crs)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string
             ['T', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'd', 'o', 'e', 's',
               ' ', 'n', 'o', 't', ' ', 'f', 'u', 'l', 'f', 'i', 'l', 'l', ' ',
               't', 'h', 'e', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
               ' ', 'o', 'n', ' ', 'Z', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
               'e', 's', '.', ' '] .
            shows_nl . x));

check_U_cond ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    Nat -> Ctxt a b) ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [a] ->
                        (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                          Nat -> [b]) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_U_cond u crs f z =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                (case u cr i of {
                  Hole ->
                    Inl (shows_prec_list zero_nat
                          [' ', 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e',
                            'd', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'c', 'o',
                            'n', 't', 'e', 'x', 't', '.']);
                  More fa [] Hole aft ->
                    catch_errora
                      (bindb
                        (catch_errora (check_disjoint [fa] f)
                          (\ _ ->
                            Inl (shows_string
                                   ['T', 'h', 'e', ' ', 'f', 'u', 'n', 'c', 't',
                                     'i', 'o', 'n', ' ', 's', 'y', 'm', 'b',
                                     'o', 'l', ' '] .
                                  shows_string (shows_prec zero_nat fa []) .
                                    shows_string
                                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
'f', 'r', 'e', 's', 'h', '.', ' '] .
                                      shows_nl)))
                        (\ _ ->
                          bindb (check (aft == map Var (z cr i))
                                  (shows_prec_list zero_nat
                                    [' ', 'U', ' ', 'd', 'o', 'e', 's', ' ',
                                      'n', 'o', 't', ' ', 'm', 'a', 'p', ' ',
                                      't', 'o', ' ', 'Z', ' ', 'v', 'a', 'r',
                                      's', ' ']))
                            (\ _ -> check_f cr i fa crs u)))
                      (\ x ->
                        Inl (shows_string
                               ['C', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 's', ' ', 'f', 'o', 'r', ' '] .
                              shows_crule (shows_prec zero_nat)
                                (shows_prec zero_nat) cr .
                                shows_string [' ', 'a', 't', ' ', ' '] .
                                  shows_prec_nat zero_nat i .
                                    shows_string
                                      [' ', 'a', 'r', 'e', ' ', 'v', 'i', 'o',
'l', 'a', 't', 'e', 'd', '.'] .
                                      shows_nl . x));
                  More _ [] (More _ _ _ _) _ ->
                    Inl (shows_prec_list zero_nat
                          [' ', 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e',
                            'd', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'c', 'o',
                            'n', 't', 'e', 'x', 't', '.']);
                  More _ (_ : _) _ _ ->
                    Inl (shows_prec_list zero_nat
                          [' ', 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e',
                            'd', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'c', 'o',
                            'n', 't', 'e', 'x', 't', '.']);
                }))
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        crs)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string
             ['T', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'd', 'o', 'e', 's',
               ' ', 'n', 'o', 't', ' ', 'f', 'u', 'l', 'f', 'i', 'l', 'l', ' ',
               't', 'h', 'e', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
               ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'U', ' ', 's', 'y', 'm',
               'b', 'o', 'l', 's', '.'] .
            shows_nl . x));

create_Umap_cr ::
  forall a b.
    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
      [(Term a b, Term a b)] ->
        Maybe [(a, (((Term a b, Term a b), [(Term a b, Term a b)]), Nat))];
create_Umap_cr cr r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      mapMa (\ (a, b) -> let {
                           (l, _) = a;
                         } in (\ i -> (case l of {
Var _ -> Nothing;
Fun _ [] -> Nothing;
Fun u (_ : _) -> Just (u, (cr, i));
                                      }))
                           b)
        (zip rr (upt zero_nat (size_list rr)));
  });

create_Umap ::
  forall a b.
    (Eq a) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                 [(Term a b, Term a b)])] ->
                a -> Maybe (((Term a b, Term a b), [(Term a b, Term a b)]),
                             Nat);
create_Umap c_rs = (case mapMa (\ (a, b) -> create_Umap_cr a b) c_rs of {
                     Nothing -> (\ _ -> Nothing);
                     Just u -> map_of (concat u);
                   });

check_sp_unraveling ::
  forall a b.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Set_impl b,
      Showa b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                     [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        [(Term a b, Term a b)];
check_sp_unraveling c_rs ctrs =
  catch_errora
    (bindb
      (catch_errora (check_same_set ctrs (map fst c_rs))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
                   ' ', 'r', 'u', 'l', 'e', ' '] .
                shows_crule (shows_prec zero_nat) (shows_prec zero_nat) x .
                  shows_nl)))
      (\ _ ->
        bindb (case create_U c_rs of {
                Nothing ->
                  Inl (shows_prec_list zero_nat
                        ['u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'e',
                          'x', 't', 'r', 'a', 'c', 't', ' ', 'u', 'n', 'r', 'a',
                          'v', 'e', 'l', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 't',
                          'e', 'x', 't', 's']);
                Just a -> Inr a;
              })
          (\ u ->
            bindb (case create_Z c_rs of {
                    Nothing ->
                      Inl (shows_prec_list zero_nat
                            ['u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ',
                              'e', 'x', 't', 'r', 'a', 'c', 't', ' ', 'Z', ' ',
                              'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']);
                    Just a -> Inr a;
                  })
              (\ z ->
                bindb (Inr (create_Umap c_rs))
                  (\ _ ->
                    bindb (check_U_cond u ctrs (funs_ctrs_list ctrs) z)
                      (\ _ ->
                        bindb (check_Z_vars ctrs z)
                          (\ _ ->
                            bindb (check_dctrs ctrs)
                              (\ _ ->
                                bindb (check_type3 ctrs)
                                  (\ _ ->
                                    bindb (catch_errora
    (forallM
      (\ (c, rs) ->
        check (rules_impl u c == rs)
          (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
               'r', 'u', 'l', 'e', 's', ' ', 'o', 'f', ' '] .
            shows_crule (shows_prec zero_nat) (shows_prec zero_nat) c .
              shows_nl))
      c_rs)
    (\ x -> Inl (snd x)))
                                      (\ _ ->
bindb (catch_errora (check_left_linear_trs (concatMap snd c_rs))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['t', 'h', 'e', ' ', 'u', 'n', 'r', 'a', 'v', 'e', 'l', 'e',
                   'd', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o', 't',
                   ' ', 'l', 'e', 'f', 't', '-', 'l', 'i', 'n', 'e', 'a', 'r',
                   ' '] .
                shows_nl . x)))
  (\ _ ->
    bindb (catch_errora (check_wf_ctrs ctrs)
            (\ x ->
              Inl (shows_prec_list zero_nat
                     ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's',
                       ' ', 'n', 'o', 't', ' ', 'w', 'e', 'l', 'l', '-', 'f',
                       'o', 'r', 'm', 'e', 'd', ' '] .
                    shows_nl . x)))
      (\ _ ->
        bindb (catch_errora (check_source_preserving ctrs z)
                (\ x ->
                  Inl (shows_prec_list zero_nat
                         ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', ' ',
                           'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'o', 'u',
                           'r', 'c', 'e', ' ', 'p', 'r', 'e', 's', 'e', 'r',
                           'v', 'i', 'n', 'g', ' '] .
                        shows_nl . x)))
          (\ _ -> Inr (concatMap snd c_rs))))))))))))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'e', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's',
               ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'r', 'a', 'v',
               'e', 'l', 'i', 'n', 'g', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't',
               ' ', 's', 'a', 't', 'i', 's', 'f', 'i', 'e', 'd'] .
            shows_nl . x));

check_conditional_cr_proof ::
  forall a b c.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [((Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]),
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])])] ->
                            Conditional_cr_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conditional_cr_proof a ia i j ctrs (Unravel_CR u_info prf) =
  debug (ia []) ['U', 'n', 'r', 'a', 'v', 'e', 'l']
    (bindb
      (catch_errora (check_sp_unraveling u_info ctrs)
        (\ x ->
          Inl (((ia . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                          'u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g']) .
                 shows_nl) .
                indent x)))
      (\ r ->
        catch_errora (check_cr_proof a (ia . shows_string ['.', '1']) i j r prf)
          (\ x ->
            Inl (((ia . shows_prec_list zero_nat
                          [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                            'l', 'o', 'w', ' ', 'c', 'o', 'n', 'f', 'l', 'u',
                            'e', 'n', 'c', 'e', ' ', 'p', 'r', 'o', 'o', 'f']) .
                   shows_nl) .
                  indent x))));
check_conditional_cr_proof a ia i j ctrs Almost_Orthogonal_CR =
  debug (ia [])
    ['A', 'l', 'm', 'o', 's', 't', '-', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
      'a', 'l']
    (check_level_confluence ctrs);
check_conditional_cr_proof a ia i j ctrs
  (Almost_Orthogonal_Modulo_Infeasibility_CR cps) =
  debug (ia [])
    ['A', 'l', 'm', 'o', 's', 't', '-', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
      'a', 'l', ' ', 'm', 'o', 'd', 'u', 'l', 'o', ' ', 'I', 'n', 'f', 'e', 'a',
      's', 'i', 'b', 'i', 'l', 'i', 't', 'y']
    (check_level_confluence_modulo_infeasibility cps ctrs);
check_conditional_cr_proof a ia i j ctrs
  (Almost_Orthogonal_Modulo_Infeasibility_CRa cps) =
  debug (ia [])
    ['A', 'l', 'm', 'o', 's', 't', '-', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
      'a', 'l', ' ', 'm', 'o', 'd', 'u', 'l', 'o', ' ', 'I', 'n', 'f', 'e', 'a',
      's', 'i', 'b', 'i', 'l', 'i', 't', 'y', ' ', '+', ' ', 'm', 'e', 'e', 't',
      '-', 't', 'o', '-', 'j', 'o', 'i', 'n']
    (check_level_confluence_modulo_infeasibilitya cps ctrs);

check_fptrs_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b [Nat]) [Prelude.Char],
                              (Term (Lab b [Nat]) [Prelude.Char], Location))],
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])]) ->
                            Fptrs_termination_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fptrs_termination_proof ia j a i tp prf =
  check_fptrs_termination_proof_main ia j a i tp (unlab_to_split_otrs prf);

check_E_reachable ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Term a b -> Bool;
check_E_reachable e s t =
  membera (mk_rtrancl_list equal_term (rewrite e) [s]) t;

check_AC_rule ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq b) => (Term a b, Term a b) -> Bool;
check_AC_rule lr =
  let {
    (l, r) = lr;
  } in (if is_Var l then False
         else let {
                f = fst (the (root l));
              } in set_eq (funas_term l)
                     (inserta (f, nat_of_integer (2 :: Integer)) bot_set) &&
                     set_eq (funas_term r)
                       (inserta (f, nat_of_integer (2 :: Integer)) bot_set) &&
                       vars_term_ms l == vars_term_ms r &&
                         funs_term_ms l == funs_term_ms r);

check_AC_theory ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_AC_theory e =
  catch_errora
    (forallM
      (\ lr ->
        check (check_AC_rule lr)
          ((shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
             shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
               [' ', '-', '>', ' '] lr) .
            shows_prec_list zero_nat
              [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 'A', 'C', '-',
                'p', 'r', 'o', 'p', 'e', 'r', 't', 'y']))
      e)
    (\ x -> Inl (snd x));

check_symmetric_AC_theory ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Ccompare b, Eq b,
      Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_symmetric_AC_theory e =
  bindb (check_AC_theory e)
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM
            (\ (l, r) ->
              check (check_E_reachable e r l)
                (((shows_prec_list zero_nat ['r', 'h', 's', ' '] .
                    shows_prec_term zero_nat r) .
                   shows_prec_list zero_nat
                     [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'r',
                       'e', 'w', 'r', 'i', 't', 'e', ' ', 't', 'o', ' ', 'l',
                       'h', 's', ' ']) .
                  shows_prec_term zero_nat l))
            e)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['t', 'h', 'e', 'o', 'r', 'y', ' ', 'i', 's', ' ', 'n', 'o',
                   't', ' ', 's', 'y', 'm', 'm', 'e', 't', 'r', 'i', 'c',
                   '\n'] .
                x)));

rf :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rf (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = r;

c :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [b];
c (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = c;

a :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [b];
a (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = a;

check_only_C_rule ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Eq b) => Set a -> (Term a b, Term a b) -> Bool;
check_only_C_rule oc lr =
  (case lr of {
    (Var _, _) -> True;
    (Fun _ [], _) -> True;
    (Fun _ [_], _) -> True;
    (Fun f [s, t], r) ->
      (if member f oc then equal_term r (Fun f [t, s]) else True);
    (Fun _ (_ : _ : _ : _), _) -> True;
  });

check_only_C_theory ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Showa a, Eq b,
      Showa b) => Set a ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_only_C_theory oc e =
  catch_errora
    (forallM
      (\ lr ->
        check (check_only_C_rule oc lr)
          ((shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
             shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
               [' ', '-', '>', ' '] lr) .
            shows_prec_list zero_nat
              [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 'o', 'n', 'l',
                'y', '-', 'C', '-', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'y']))
      e)
    (\ x -> Inl (snd x));

check_AC_same_as_E ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Showa a, Ceq b, Ccompare b, Eq b,
      Set_impl b,
      Showa b) => a -> a -> a -> [b] ->
                                   [b] ->
                                     [(Term b a, Term b a)] ->
                                       Sum ([Prelude.Char] -> [Prelude.Char])
 ();
check_AC_same_as_E x y z a c e =
  catch_errora
    (let {
       xa = Var x;
       ya = Var y;
       za = Var z;
     } in bindb (catch_errora
                  (catch_errora
                    (forallM
                      (\ f ->
                        check (check_E_reachable e (Fun f [xa, ya])
                                (Fun f [ya, xa]))
                          f)
                      c)
                    (\ xb -> Inl (snd xb)))
                  (\ xb ->
                    Inl ((shows_prec_list zero_nat
                            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                              's', 'i', 'm', 'u', 'l', 'a', 't', 'e', ' ', 'C',
                              '-', 'r', 'u', 'l', 'e', 's', ' ', 'f', 'o', 'r',
                              ' '] .
                           shows_prec zero_nat xb) .
                          shows_prec_list zero_nat [' ', 'b', 'y', ' ', 'E'])))
            (\ _ ->
              bindb (catch_errora
                      (catch_errora
                        (forallM
                          (\ f ->
                            check (check_E_reachable e
                                    (Fun f [xa, Fun f [ya, za]])
                                    (Fun f [Fun f [xa, ya], za]))
                              f)
                          a)
                        (\ xb -> Inl (snd xb)))
                      (\ xb ->
                        Inl ((shows_prec_list zero_nat
                                ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                  ' ', 's', 'i', 'm', 'u', 'l', 'a', 't', 'e',
                                  ' ', 'A', '-', 'r', 'u', 'l', 'e', 's', ' ',
                                  'f', 'o', 'r', ' '] .
                               shows_prec zero_nat xb) .
                              shows_prec_list zero_nat
                                [' ', 'b', 'y', ' ', 'E'])))
                (\ _ ->
                  bindb (catch_errora
                          (catch_errora
                            (forallM
                              (\ f ->
                                check (check_E_reachable e
(Fun f [Fun f [xa, ya], za]) (Fun f [xa, Fun f [ya, za]]))
                                  f)
                              a)
                            (\ xb -> Inl (snd xb)))
                          (\ xb ->
                            Inl ((shows_prec_list zero_nat
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 's', 'i', 'm', 'u', 'l', 'a',
                                      't', 'e', ' ', 'A', '-', 'r', 'u', 'l',
                                      'e', 's', ' ', 'f', 'o', 'r', ' '] .
                                   shows_prec zero_nat xb) .
                                  shows_prec_list zero_nat
                                    [' ', 'b', 'y', ' ', 'E'])))
                    (\ _ ->
                      catch_errora
                        (catch_errora
                          (forallM
                            (\ (l, r) ->
                              check (equal_acterm (aocnf (set a) (set c) l)
                                      (aocnf (set a) (set c) r))
                                (l, r))
                            e)
                          (\ xb -> Inl (snd xb)))
                        (\ xb ->
                          Inl ((shows_prec_list zero_nat
                                  ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
                                    ' '] .
                                 shows_rule (shows_prec zero_nat)
                                   (shows_prec zero_nat) [' ', '-', '>', ' ']
                                   xb) .
                                shows_prec_list zero_nat
                                  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'A',
                                    'C', '-', 'e', 'q', 'u', 'i', 'v', 'a', 'l',
                                    'e', 'n', 't']))))))
    (\ xa ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
               'u', 'r', 'e', ' ', 't', 'h', 'a', 't', ' ', 'e', 'q', 'u', 'a',
               't', 'i', 'o', 'n', 's', ' ', 's', 'i', 'm', 'u', 'l', 'a', 't',
               'e', ' ', 'A', 'C', '-', 'e', 'q', 'u', 'i', 'v', 'a', 'l', 'e',
               'n', 'c', 'e', '\n'] .
            xa));

check_ext_rule3 ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Eq b) => (Term a b, Term a b) ->
                 a -> Set b -> (Term a b, Term a b) -> Bool;
check_ext_rule3 (la, ra) f xb
  (Fun ga [Fun ha [Var xa, l], Var ya], Fun g [Fun h [Var x, r], Var y]) =
  (la, (ra, (f, (f, (f, (f, (xa, ya))))))) ==
    (l, (r, (ga, (g, (ha, (h, (x, y))))))) &&
    not (x == y) && not (member x xb) && not (member y xb);
check_ext_rule3 uu uv uw (Var vb, va) = False;
check_ext_rule3 uu uv uw (Fun vb [], va) = False;
check_ext_rule3 uu uv uw (Fun vb (Var vf : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf [] : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf (Fun vj vk : vi) : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf [vh] : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf (vh : vj : vl : vm) : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb [vd], va) = False;
check_ext_rule3 uu uv uw (Fun vb (vd : Fun vh vi : vg), va) = False;
check_ext_rule3 uu uv uw (Fun vb (vd : vf : vh : vi), va) = False;
check_ext_rule3 uu uv uw (v, Var vb) = False;
check_ext_rule3 uu uv uw (v, Fun vb []) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Var vf : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf [] : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf (Fun vj vk : vi) : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf [vh] : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf (vh : vj : vl : vm) : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb [vd]) = False;
check_ext_rule3 uu uv uw (v, Fun vb (vd : Fun vh vi : vg)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (vd : vf : vh : vi)) = False;

check_ext_rule2 ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Eq b) => (Term a b, Term a b) ->
                 a -> Set b -> (Term a b, Term a b) -> Bool;
check_ext_rule2 (la, ra) f xb (Fun ga [Var xa, l], Fun g [Var x, r]) =
  (la, (ra, (f, (f, xa)))) == (l, (r, (ga, (g, x)))) && not (member xa xb);
check_ext_rule2 uu uv uw (Var vb, va) = False;
check_ext_rule2 uu uv uw (Fun vb [], va) = False;
check_ext_rule2 uu uv uw (Fun vb (Fun vf vg : ve), va) = False;
check_ext_rule2 uu uv uw (Fun vb [vd], va) = False;
check_ext_rule2 uu uv uw (Fun vb (vd : vf : vh : vi), va) = False;
check_ext_rule2 uu uv uw (v, Var vb) = False;
check_ext_rule2 uu uv uw (v, Fun vb []) = False;
check_ext_rule2 uu uv uw (v, Fun vb (Fun vf vg : ve)) = False;
check_ext_rule2 uu uv uw (v, Fun vb [vd]) = False;
check_ext_rule2 uu uv uw (v, Fun vb (vd : vf : vh : vi)) = False;

check_ext_rule1 ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Eq b) => (Term a b, Term a b) ->
                 a -> Set b -> (Term a b, Term a b) -> Bool;
check_ext_rule1 (la, ra) f xb (Fun ga [l, Var xa], Fun g [r, Var x]) =
  (la, (ra, (f, (f, xa)))) == (l, (r, (ga, (g, x)))) && not (member xa xb);
check_ext_rule1 uu uv uw (Var vb, va) = False;
check_ext_rule1 uu uv uw (Fun vb [], va) = False;
check_ext_rule1 uu uv uw (Fun vb [vd], va) = False;
check_ext_rule1 uu uv uw (Fun vb (vd : Fun vh vi : vg), va) = False;
check_ext_rule1 uu uv uw (Fun vb (vd : vf : vh : vi), va) = False;
check_ext_rule1 uu uv uw (v, Var vb) = False;
check_ext_rule1 uu uv uw (v, Fun vb []) = False;
check_ext_rule1 uu uv uw (v, Fun vb [vd]) = False;
check_ext_rule1 uu uv uw (v, Fun vb (vd : Fun vh vi : vg)) = False;
check_ext_rule1 uu uv uw (v, Fun vb (vd : vf : vh : vi)) = False;

check_ext_rule ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       Set a -> Set a -> (Term a b, Term a b) -> Bool;
check_ext_rule rext a c lr =
  let {
    (l, _) = lr;
  } in (if is_Var l ||
             (not (equal_nat (size_list (args l))
                    (nat_of_integer (2 :: Integer))) ||
               not (member (fst (the (root l))) a))
         then True
         else let {
                f = fst (the (root l));
                x = vars_rule lr;
              } in any (check_ext_rule1 lr f x) rext &&
                     (if not (member f c)
                       then any (check_ext_rule2 lr f x) rext &&
                              any (check_ext_rule3 lr f x) rext
                       else True));

check_ext_trs ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Showa a, Finite_UNIV b,
      Cenum b, Ceq b, Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [a] ->
                      [a] ->
                        [(Term a b, Term a b)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ext_trs r a c rext =
  let {
    aa = set a;
    ca = set c;
  } in catch_errora
         (catch_errora
           (forallM
             (\ lr ->
               check (check_ext_rule rext aa ca lr)
                 (((shows_prec_list zero_nat
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                        'i', 'n', 'd', ' ', 'e', 'x', 't', 'e', 'n', 'd', 'e',
                        'd', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'f', 'o', 'r',
                        ' ', 'r', 'u', 'l', 'e', ' ', 'l', ' ', '-', '>', ' ',
                        'r', ':', '\n', ' ', ' '] .
                     shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                       [' ', '-', '>', ' '] lr) .
                    shows_prec_list zero_nat
                      ['\n', ' ', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'i', 'n',
                        'g', ' ', 'r', 'u', 'l', 'e', ' ', 'f', '(', 'l', ',',
                        'x', ')', ' ', '-', '>', ' ', 'f', '(', 'r', ',', 'x',
                        ')', ' ', 'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ', 'A',
                        ' ', 'a', 'n', 'd', ' ', 'A', 'C', ' ', 's', 'y', 'm',
                        'b', 'o', 'l', 's', ',', '\n']) .
                   shows_prec_list zero_nat
                     ['a', 'n', 'd', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'f',
                       '(', 'x', ',', 'l', ')', ' ', '-', '>', ' ', 'f', '(',
                       'x', ',', 'r', ')', ' ', 'a', 'n', 'd', ' ', 'f', '(',
                       'f', '(', 'x', ',', 'l', ')', ',', 'y', ')', ' ', '-',
                       '>', ' ', 'f', '(', 'f', '(', 'x', ',', 'r', ')', ',',
                       'y', ')', ' ', 'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ',
                       'A', ' ', 's', 'y', 'm', 'b', 'o', 'l', 's']))
             r)
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                    's', 'u', 'r', 'e', ' ', 'v', 'a', 'l', 'i', 'd', 'i', 't',
                    'y', ' ', 'o', 'f', ' ', 'A', 'C', '-', 'e', 'x', 't', 'e',
                    'n', 'd', 'e', 'd', ' ', 's', 'y', 's', 't', 'e', 'm',
                    '\n'] .
                 x));

ac_dependency_pairs_checks ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Ac_tp_ops_ext a b c () ->
                    (b -> b) ->
                      c -> c -> c -> Ac_dependency_pairs_proof b c ->
                                       a ->
 Sum ([Prelude.Char] -> [Prelude.Char]) ();
ac_dependency_pairs_checks i shp x y z
  (AC_dependency_pairs_proof e dpr dpe rext) tp =
  catch_errora
    (let {
       aa = a i tp;
       ca = c i tp;
       r = rf i tp;
       oc = list_diff ca aa;
       d = defined_list r;
       _ = set d;
       da = defined_list (r ++ e);
     } in bindb (catch_errora
                  (forallM
                    (\ (f, n) ->
                      check (not (membera da (shp f, n)))
                        (shows_string
                           ['s', 'h', 'a', 'r', 'p', 'i', 'n', 'g', ' '] .
                          shows_prec zero_nat f .
                            shows_string
                              [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 't', 'h',
                                'e', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd',
                                ' ', 's', 'y', 'm', 'b', 'o', 'l', ' '] .
                              shows_prec zero_nat (shp f)))
                    da)
                  (\ xa -> Inl (snd xa)))
            (\ _ ->
              bindb (catch_errora (check_wf_trs (r ++ e))
                      (\ xa ->
                        Inl (shows_prec_list zero_nat
                               ['T', 'R', 'S', ' ', 'o', 'r', ' ', 'e', 'q',
                                 'u', 'a', 't', 'i', 'o', 'n', 's', ' ', 'a',
                                 'r', 'e', ' ', 'n', 'o', 't', ' ', 'w', 'e',
                                 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd'] .
                              xa)))
                (\ _ ->
                  bindb (catch_errora (check_symmetric_AC_theory e)
                          (\ xa ->
                            Inl (shows_prec_list zero_nat
                                   ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's',
                                     ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ',
                                     'f', 'o', 'r', 'm', ' ', 'a', ' ', 's',
                                     'y', 'm', 'm', 'e', 't', 'r', 'i', 'c',
                                     ' ', 'A', 'C', '-', 't', 'h', 'e', 'o',
                                     'r', 'y', '\n'] .
                                  xa)))
                    (\ _ ->
                      bindb (catch_errora (check_only_C_theory (set oc) e)
                              (\ xa ->
                                Inl (shows_prec_list zero_nat
                                       ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
 's', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'r', 'm', ' ', 'A', 'C',
 '_', 'C', '-', 't', 'h', 'e', 'o', 'r', 'y', '\n'] .
                                      xa)))
                        (\ _ ->
                          bindb (catch_errora
                                  (check_subseteq (funs_trs_list e) (aa ++ ca))
                                  (\ xa ->
                                    Inl ((shows_prec_list zero_nat
    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's', ' ', 'c', 'o', 'n', 't', 'a',
      'i', 'n', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' '] .
   shows_prec zero_nat xa) .
  shows_prec_list zero_nat
    [' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'A',
      'C', '-', 's', 'y', 'm', 'b', 'o', 'l'])))
                            (\ _ ->
                              bindb (catch_errora
                                      (check_AC_same_as_E x y z aa ca e)
                                      (\ xa ->
Inl (shows_prec_list zero_nat
       ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's', 'u',
         'r', 'e', ' ', 't', 'h', 'a', 't', ' ', 'e', 'q', 'u', 'a', 't', 'i',
         'o', 'n', 's', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd',
         ' ', 't', 'o', ' ', 'A', 'C', ' ', 'e', 'q', 'u', 'i', 'v', 'a', 'l',
         'e', 'n', 'c', 'e', '\n'] .
      xa)))
                                (\ _ ->
                                  bindb (catch_errora
  (check_subseteq (dP_list shp r d) dpr)
  (\ xa ->
    Inl (shows_prec_list zero_nat
           ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
             'd', ' ', 'D', 'P', ' ', 'f', 'o', 'r', ' ', 'R', ':', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] xa)))
                                    (\ _ ->
                                      bindb
(catch_errora (check_subseteq (dP_list shp e d) dpe)
  (\ xa ->
    Inl (shows_prec_list zero_nat
           ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
             'd', ' ', 'D', 'P', ' ', 'f', 'o', 'r', ' ', 'E', ':', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] xa)))
(\ _ ->
  catch_errora (check_ext_trs r aa ca rext)
    (\ xa ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
               'u', 'r', 'e', ' ', 'v', 'a', 'l', 'i', 'd', 'i', 't', 'y', ' ',
               'o', 'f', ' ', 'e', 'x', 't', 'e', 'n', 'd', 'e', 'd', ' ', 'T',
               'R', 'S', ' ', 'R', '_', 'e', 'x', 't', '\n'] .
            xa)))))))))))
    (\ xa ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'a', 'p',
               'p', 'l', 'y', 'i', 'n', 'g', ' ', 'A', 'C', '-', 'd', 'e', 'p',
               'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p', 'a', 'i', 'r', 's',
               '\n'] .
            xa));

mkf ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d ->
      [(Term b c, Term b c)] ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] ->
            [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkf (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
      reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
      eq_rules_non_collapsing intersect_pairs more)
  = mk;

ac_dependency_pairs_proc_simple ::
  forall a b c d.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Ac_tp_ops_ext a b c () ->
                    Ac_dpp_ops_ext d b c () ->
                      (b -> b) ->
                        c -> c -> c -> Ac_dependency_pairs_proof b c ->
 a -> Sum ([Prelude.Char] -> [Prelude.Char]) d;
ac_dependency_pairs_proc_simple i j shp x y z
  (AC_dependency_pairs_proof e dpr dpe rext) tp =
  bindb (ac_dependency_pairs_checks i shp x y z
          (AC_dependency_pairs_proof e dpr dpe rext) tp)
    (\ _ ->
      let {
        r = rf i tp;
      } in Inr (mkf j
                 (dpr ++
                   map (\ (l, ra) -> (sharp_term shp l, sharp_term shp ra))
                     rext)
                 dpe [] r e));

delete_pairs_rulesa ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_pairs_rulesa
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = delete_pairs_rules;

rulesf :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulesf
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = rules;

pairsc :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pairsc
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = pairs;

rwe :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwe (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
      reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
      eq_rules_non_collapsing intersect_pairs more)
  = rw;

rg :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rg (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
     reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
     eq_rules_non_collapsing intersect_pairs more)
  = r;

eb :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
eb (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
     reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
     eq_rules_non_collapsing intersect_pairs more)
  = e;

ac_mono_ur_redpair_proc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showa c) => Ac_dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          [(Term b c, Term b c)] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
ac_mono_ur_redpair_proc i rp p_remove r_remove ur dpp =
  (case catch_errora
          (let {
             p = pairsc i dpp;
             _ = rulesf i dpp;
             e = eb i dpp;
             premove = set p_remove;
             rremove = set r_remove;
             us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
             filt = (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
             (ps, pns) = partition (\ lr -> member lr premove && filt lr) p;
             (urs, urns) = partition (\ lr -> member lr rremove && filt lr) ur;
             rm = eq_rules_map i dpp;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (mono rp (ps ++ urs ++ urns ++ pns))
                      (\ _ ->
                        bindb (catch_errora (check_symmetric_AC_theory e)
                                (\ x ->
                                  Inl (shows_prec_list zero_nat
 ['u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'd', 'e',
   'm', 'a', 'n', 'd', ' ', 's', 'y', 'm', 'm', 'e', 't', 'r', 'i', 'c', ' ',
   'A', 'C', ' ', 't', 'h', 'e', 'o', 'r', 'y', '\n'] .
x)))
                          (\ _ ->
                            bindb (catch_errora
                                    (forallM
                                      (\ (l, _) ->
check (not (is_Var l))
  (shows_prec_list zero_nat
    ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ', 'l', 'h',
      's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                                      (rg i dpp ++ rwe i dpp))
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (check_ur_P_closed_rm_af rm ur full_af p)
                                  (\ _ ->
                                    bindb (catch_errora
    (catch_errora (forallM (ns rp) urns) (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a',
               'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', '\n'] .
            x)))
                                      (\ _ ->
bindb (catch_errora (catch_errora (forallM (s rp) urs) (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                   ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u',
                   's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's',
                   '\n'] .
                x)))
  (\ _ ->
    bindb (catch_errora
            (catch_errora (forallM (ns rp) pns) (\ x -> Inl (snd x)))
            (\ x ->
              Inl (shows_prec_list zero_nat
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                       'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                       ' ', 'D', 'P', 's', '\n'] .
                    x)))
      (\ _ ->
        catch_errora (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D',
                     'P', 's', '\n'] .
                  x)))))))))))
          (\ x ->
            Inl (((shows_prec_list zero_nat
                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a',
                       'p', 'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'm', 'o',
                       'n', 'o', 't', 'o', 'n', 'i', 'c', ' ', 'A', 'C', ' ',
                       'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p',
                       'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 'u', 's', 'a',
                       'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'a',
                       'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                       'o', 'w', 'i', 'n', 'g', '\n'] .
                    desc rp) .
                   shows_nl) .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_pairs_rulesa i dpp p_remove r_remove);
  });

pwc :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pwc (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
      reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
      eq_rules_non_collapsing intersect_pairs more)
  = pw;

pc :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pc (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
     reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
     eq_rules_non_collapsing intersect_pairs more)
  = p;

ac_dpp_trivial_check ::
  forall a b c.
    Ac_dpp_ops_ext a b c () -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
ac_dpp_trivial_check i dpp =
  bindb (check (null (pc i dpp))
          (shows_prec_list zero_nat
            ['t', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 's', 't', 'r',
              'i', 'c', 't', ' ', 'p', 'a', 'i', 'r', 's']))
    (\ _ ->
      check (null (pwc i dpp) || null (rg i dpp))
        (shows_prec_list zero_nat
          ['t', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 'w', 'e', 'a', 'k',
            ' ', 'p', 'a', 'i', 'r', 's', ' ', 'a', 'n', 'd', ' ', 's', 't',
            'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's']));

ac_ur_redpair_proc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showa c) => Ac_dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
ac_ur_redpair_proc i rp p_remove ur dpp =
  (case catch_errora
          (let {
             p = pairsc i dpp;
             _ = rulesf i dpp;
             e = eb i dpp;
             premove = set p_remove;
             (ps, pns) = partition (\ lr -> member lr premove) p;
             rm = eq_rules_map i dpp;
             pi = af rp;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (catch_errora (check_symmetric_AC_theory e)
                            (\ x ->
                              Inl (shows_prec_list zero_nat
                                     ['u', 's', 'a', 'b', 'l', 'e', ' ', 'r',
                                       'u', 'l', 'e', 's', ' ', 'd', 'e', 'm',
                                       'a', 'n', 'd', ' ', 's', 'y', 'm', 'm',
                                       'e', 't', 'r', 'i', 'c', ' ', 'A', 'C',
                                       ' ', 't', 'h', 'e', 'o', 'r', 'y',
                                       '\n'] .
                                    x)))
                      (\ _ ->
                        bindb (catch_errora
                                (forallM
                                  (\ (l, _) ->
                                    check (not (is_Var l))
                                      (shows_prec_list zero_nat
['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ', 'l', 'h', 's',
  's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                                  (rg i dpp ++ rwe i dpp))
                                (\ x -> Inl (snd x)))
                          (\ _ ->
                            bindb (check_ur_P_closed_rm_af rm ur pi p)
                              (\ _ ->
                                bindb (catch_errora
(catch_errora (forallM (ns rp) ur) (\ x -> Inl (snd x)))
(\ x ->
  Inl (shows_prec_list zero_nat
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
           'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l',
           'e', ' ', 'r', 'u', 'l', 'e', 's', '\n'] .
        x)))
                                  (\ _ ->
                                    bindb (catch_errora
    (catch_errora (forallM (nst rp) pns) (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's',
               '\n'] .
            x)))
                                      (\ _ ->
catch_errora (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
  (\ x ->
    Inl (shows_prec_list zero_nat
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
             'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's',
             '\n'] .
          x)))))))))
          (\ x ->
            Inl (((shows_prec_list zero_nat
                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a',
                       'p', 'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'A', 'C',
                       ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ',
                       'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                       's', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 'u', 's',
                       'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
                       'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l',
                       'l', 'o', 'w', 'i', 'n', 'g', '\n'] .
                    desc rp) .
                   shows_nl) .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_pairs_rulesa i dpp p_remove []);
  });

check_size_preserving_trs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_size_preserving_trs e =
  catch_errora
    (catch_errora
      (forallM
        (\ (l, r) ->
          check (equal_nat (num_symbs l) (num_symbs r) &&
                  vars_term_ms l == vars_term_ms r)
            ((shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
               shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                 [' ', '-', '>', ' '] (l, r)) .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'i', 'z', 'e',
                  ' ', 'p', 'r', 'e', 's', 'e', 'r', 'v', 'i', 'n', 'g']))
        e)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'i',
               'z', 'e', '-', 'p', 'r', 'e', 's', 'e', 'r', 'v', 'i', 'n', 'g',
               '\n'] .
            x));

ac_subterm_proc ::
  forall a b c.
    (Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b, Compare c, Eq c,
      Showa c) => Ac_dpp_ops_ext a b c () ->
                    [((b, Nat), [Nat])] ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
ac_subterm_proc i pi p_remove dpp =
  (case catch_errora
          (let {
             p = pairsc i dpp;
             r = rulesf i dpp;
             e = eb i dpp;
             re = r ++ e;
             f = map fst pi;
             ff = set f;
             pi_opt = status_of pi;
           } in bindb (check (not (is_none pi_opt))
                        (shows_prec_list zero_nat
                          ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f',
                            'i', 'l', 't', 'e', 'r', ' ', 'l', 'i', 's', 't',
                            's', ' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd', ' ',
                            'p', 'o', 's', 'i', 't', 'i', 'o', 'n', 's']))
                  (\ _ ->
                    let {
                      pia = the pi_opt;
                      premove = set p_remove;
                      (ps, pns) = partition (\ lr -> member lr premove) p;
                    } in bindb (catch_errora
                                 (forallM
                                   (\ fa ->
                                     check (not (null (status pia fa)))
                                       ((shows_prec_list zero_nat
   ['s', 't', 'a', 't', 'u', 's', ' ', 'o', 'f', ' ', 's', 'y', 'm', 'b', 'o',
     'l', ' '] .
  shows_prec_prod zero_nat fa) .
 shows_prec_list zero_nat
   [' ', 'i', 'n', ' ', 'F', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n',
     'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
                                   f)
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             bindb (catch_errora (check_size_preserving_trs e)
                                     (\ x ->
                                       Inl
 (shows_prec_list zero_nat
    ['E', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'i', 'z', 'e', ' ', 'p',
      'r', 'e', 's', 'e', 'r', 'v', 'i', 'n', 'g', '\n'] .
   x)))
                               (\ _ ->
                                 bindb (catch_errora
 (forallM
   (\ (l, _) ->
     check (not (is_Var l))
       (shows_prec_list zero_nat
         ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ', 'l',
           'h', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
           'd']))
   re)
 (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (catch_errora
     (catch_errora
       (forallM (check_supteqproj_pred pia ff)
         (filter (\ lr -> member (the (root (fst lr))) ff) re))
       (\ x -> Inl (snd x)))
     (\ x ->
       Inl (shows_prec_list zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
                'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'r', 'u', 'l',
                'e', 's', ' ', 'w', 'i', 't', 'h', ' ', 'r', 'o', 'o', 't', ' ',
                'i', 'n', ' ', 'F', '\n'] .
             x)))
                                       (\ _ ->
 bindb (catch_errora
         (catch_errora (forallM (check_supteqproj_pred pia ff) pns)
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                    ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D',
                    'P', 's', '\n'] .
                 x)))
   (\ _ ->
     catch_errora
       (catch_errora (forallM (check_suptproj_pred pia ff) ps)
         (\ x -> Inl (snd x)))
       (\ x ->
         Inl (shows_prec_list zero_nat
                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                  ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D',
                  'P', 's', '\n'] .
               x)))))))))
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'A', 'C', ' ', 's',
                     'u', 'b', 't', 'e', 'r', 'm', ' ', 'p', 'r', 'o', 'c', 'e',
                     's', 's', 'o', 'r', '\n'] .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_pairs_rulesa i dpp p_remove []);
  });

intersect_pairsc ::
  forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_pairsc
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = intersect_pairs;

graph_approx_edg_rt_sym ::
  forall a b c d e.
    (Ccompare a,
      Eq a) => Multimap (Maybe (a, Nat)) b -> (c, (d, Gctxt a e)) -> [b];
graph_approx_edg_rt_sym m (uu, (uv, ct)) = graph_approx_rt_sym_main m ct;

eq_rules_non_collapsinga :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> Bool;
eq_rules_non_collapsinga
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = eq_rules_non_collapsing;

reverse_eq_rules_map ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
reverse_eq_rules_map
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = reverse_eq_rules_map;

reverse_tcapRM_ac_dpp ::
  forall a b c.
    (Eq b, Eq c) => Ac_dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
reverse_tcapRM_ac_dpp i dpp =
  tcapRM (eq_rules_non_collapsinga i dpp) (reverse_eq_rules_map i dpp);

check_ac_dep_graph_proc ::
  forall a b c.
    (Ccompare b, Eq b, Key b, Mapping_impl b,
      Showa b) => Ac_dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ac_dep_graph_proc i dpp dps =
  let {
    c = tcapRM_ac_dpp i dpp;
    rc = reverse_tcapRM_ac_dpp i dpp;
    p = pairsc i dpp;
  } in bindb (catch_errora (check_subseteq p (concatMap snd dps))
               (\ x ->
                 Inl (shows_string
                        ['D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ',
                          'P', 'a', 'i', 'r', ' '] .
                       shows_rule (shows_prec zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                         shows_string
                           [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                             'g', ' ', 'i', 'n', ' ', 'd', 'e', 'c', 'o', 'm',
                             'p', 'o', 's', 'i', 't', 'i', 'o', 'n'] .
                           shows_nl)))
         (\ _ ->
           catch_errora
             (check_graph_decomp (shows_prec_prod zero_nat . fst)
               (emptye ((root . fst) . fst)) graph_approx_edg_rt_sym inserte
               (\ (a, b) ->
                 let {
                   (aa, ba) = a;
                 } in let {
                        (_, t) = aa;
                      } in (\ (_, ct) (ab, bb) ->
                             let {
                               (u, _) = ab;
                             } in (\ (cu, _) -> matchb ct u && matchb cu t)
                               bb)
                        ba
                   b)
               (map (\ (real, cs) ->
                      (not (is_none real),
                        map (\ (s, t) -> ((s, t), (rc s, c t))) cs))
                 dps))
             (\ x ->
               Inl (shows_string
                      ['o', 'u', 'r', ' ', 'e', 's', 't', 'i', 'm', 'a', 't',
                        'i', 'o', 'n', ' ', '(', 'E', 'D', 'G', '*', '*', '*',
                        ')', ' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                        ' ', 's', 'h', 'o', 'w', ' ', 't', 'h', 'a', 't', ' ',
                        'y', 'o', 'u', ' ', 'h', 'a', 'v', 'e', ' ', 'a', ' ',
                        'v', 'a', 'l', 'i', 'd', ' ', 'd', 'e', 'c', 'o', 'm',
                        'p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' '] .
                     shows_string
                       ['d', 'u', 'e', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ',
                         'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'r',
                         'e', 'a', 's', 'o', 'n'] .
                       shows_nl . x)));

ac_dep_graph_proc ::
  forall a b c.
    (Ccompare b, Eq b, Key b, Mapping_impl b,
      Showa b) => Ac_dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) [(c, a)];
ac_dep_graph_proc i d dps =
  (case check_ac_dep_graph_proc i d dps of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (map_filter
            (\ x ->
              (if not (is_none (fst x))
                then Just (the (fst x), intersect_pairsc i d (snd x))
                else Nothing))
            dps);
  });

shows_ac_dpp ::
  forall a b c.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Ac_dpp_ops_ext c a b () -> c -> [Prelude.Char] -> [Prelude.Char];
shows_ac_dpp fun var i d =
  let {
    p = pc i d;
    pw = pwc i d;
    r = rg i d;
    rw = rwe i d;
    e = eb i d;
  } in ((((if null p then id
            else shows_trs fun var ['p', 'a', 'i', 'r', 's', ':']
                   [' ', '-', '>', ' '] p) .
           (if null pw then id
             else shows_trs fun var
                    ['w', 'e', 'a', 'k', ' ', 'p', 'a', 'i', 'r', 's', ':']
                    [' ', '-', '>', '=', ' '] pw)) .
          (if null r then id
            else shows_trs fun var
                   ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's',
                     ':']
                   [' ', '-', '>', '!', ' '] r)) .
         (if null rw then id
           else shows_trs fun var ['r', 'u', 'l', 'e', 's', ':']
                  [' ', '-', '>', ' '] rw)) .
         (if null e then id
           else shows_trs fun var
                  ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's', ':']
                  [' ', '-', '>', ' '] e);

check_ac_dp_termination_proof ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => Ac_dpp_ops_ext a b [Prelude.Char] () ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      a -> Ac_dp_termination_proof b [Prelude.Char] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ac_dp_termination_proof ia i dpp AC_P_is_Empty =
  debug (i []) ['P', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y']
    (catch_errora (ac_dpp_trivial_check ia dpp)
      (\ x ->
        Inl (((i . shows_prec_list zero_nat
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                       'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 't', 'r',
                       'i', 'v', 'i', 'a', 'l', ' ', 'c', 'h', 'e', 'c', 'k',
                       ' ', 'o', 'n', '\n']) .
               shows_ac_dpp (shows_prec zero_nat) (shows_prec_list zero_nat) ia
                 dpp) .
              x)));
check_ac_dp_termination_proof ia i dpp (AC_Redpair_UR_Proc redp del_p ur prf) =
  debug (i [])
    ['A', 'C', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'U', 'R', '_', 'P',
      'r', 'o', 'c']
    (bindb
      (catch_errora (ac_ur_redpair_proc ia (get_redtriple redp) del_p ur dpp)
        (\ x ->
          Inl ((((((i . shows_prec_list zero_nat
                          [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h',
                            'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n',
                            'g', ' ', 't', 'h', 'e', ' ', 'a', 'c', '-', 'r',
                            'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p',
                            'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                            's', 'o', 'r', ' ', 't', 'o', ' ', 'r', 'e', 'm',
                            'o', 'v', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't',
                            'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b',
                            'l', 'e', 'm', '\n']) .
                    shows_ac_dpp (shows_prec zero_nat)
                      (shows_prec_list zero_nat) ia dpp) .
                   shows_prec_list zero_nat
                     ['\n', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', 's',
                       '\n']) .
                  shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
                    [' ', '-', '>', ' '] del_p) .
                 shows_nl) .
                x)))
      (\ dppa ->
        catch_errora
          (check_ac_dp_termination_proof ia
            (i . shows_prec_list zero_nat ['.', '1']) dppa prf)
          (\ x ->
            Inl ((i . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'a', 'c', '-', 'r',
                          'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                          'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                          'r', '\n']) .
                  indent x))));
check_ac_dp_termination_proof ia i dpp (AC_Subterm_Proc pi del_p prf) =
  debug (i [])
    ['A', 'C', '_', 'S', 'u', 'b', 't', 'e', 'r', 'm', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (ac_subterm_proc ia pi del_p dpp)
        (\ x ->
          Inl ((((((i . shows_prec_list zero_nat
                          [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h',
                            'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n',
                            'g', ' ', 't', 'h', 'e', ' ', 'a', 'c', '-', 's',
                            'u', 'b', 't', 'e', 'r', 'm', ' ', 'p', 'r', 'o',
                            'c', 'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ',
                            'r', 'e', 'm', 'o', 'v', 'e', ' ', 'f', 'r', 'o',
                            'm', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p',
                            'r', 'o', 'b', 'l', 'e', 'm', '\n']) .
                    shows_ac_dpp (shows_prec zero_nat)
                      (shows_prec_list zero_nat) ia dpp) .
                   shows_prec_list zero_nat
                     ['\n', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', 's',
                       '\n']) .
                  shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
                    [' ', '-', '>', ' '] del_p) .
                 shows_nl) .
                x)))
      (\ dppa ->
        catch_errora
          (check_ac_dp_termination_proof ia
            (i . shows_prec_list zero_nat ['.', '1']) dppa prf)
          (\ x ->
            Inl ((i . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'a', 'c', '-', 'r',
                          'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                          'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                          'r', '\n']) .
                  indent x))));
check_ac_dp_termination_proof ia i dpp
  (AC_Mono_Redpair_UR_Proc redp del_p del_r ur prf) =
  debug (i [])
    ['A', 'C', '_', 'M', 'o', 'n', 'o', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r',
      '_', 'U', 'R', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora
        (ac_mono_ur_redpair_proc ia (get_redtriple redp) del_p del_r ur dpp)
        (\ x ->
          Inl ((((((((i . shows_prec_list zero_nat
                            [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h',
                              'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n',
                              'g', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'n', 'o',
                              't', 'o', 'n', 'e', ' ', 'a', 'c', '-', 'r', 'e',
                              'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                              'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                              'o', 'r', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
                              'v', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h',
                              'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l',
                              'e', 'm', '\n']) .
                      shows_ac_dpp (shows_prec zero_nat)
                        (shows_prec_list zero_nat) ia dpp) .
                     shows_prec_list zero_nat
                       ['\n', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', 's',
                         '\n']) .
                    shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
                      [' ', '-', '>', ' '] del_p) .
                   shows_prec_list zero_nat
                     ['\n', ' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'r',
                       'u', 'l', 'e', 's', '\n']) .
                  shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
                    [' ', '-', '>', ' '] del_r) .
                 shows_nl) .
                x)))
      (\ dppa ->
        catch_errora
          (check_ac_dp_termination_proof ia
            (i . shows_prec_list zero_nat ['.', '1']) dppa prf)
          (\ x ->
            Inl ((i . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'n', 'o',
                          't', 'o', 'n', 'e', ' ', 'a', 'c', '-', 'r', 'e', 'd',
                          'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r',
                          ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r',
                          '\n']) .
                  indent x))));
check_ac_dp_termination_proof ia i dpp (AC_Dep_Graph_Proc edpts) =
  debug (i [])
    ['D', 'e', 'p', '_', 'G', 'r', 'a', 'p', 'h', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (ac_dep_graph_proc ia dpp edpts)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i',
                       'l', 'e', ' ', 't', 'r', 'y', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'p', 'e', 'r', 'f', 'o', 'r', 'm', ' ', 'S',
                       'C', 'C', '-', 'd', 'e', 'c', 'o', 'm', 'p', 'o', 's',
                       'i', 't', 'i', 'o', 'n', ' ', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_ac_dpp (shows_prec zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ pdpps ->
        catch_errora
          (catch_errora
            (forallM_index
              (\ (prof, dppa) j ->
                check_ac_dp_termination_proof ia
                  (i . shows_string ['.'] . shows_prec_nat zero_nat (suc j))
                  dppa prof)
              pdpps)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'd', 'e', 'p', 'e',
                         'n', 'd', 'e', 'n', 'c', 'y', ' ', 'g', 'r', 'a', 'p',
                         'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                         'r'] .
                       shows_nl . indent x))));

ac_dependency_pairs_proc ::
  forall a b c d.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Ac_tp_ops_ext a b c () ->
                    Ac_dpp_ops_ext d b c () ->
                      (b -> b) ->
                        c -> c -> c -> Ac_dependency_pairs_proof b c ->
 a -> Sum ([Prelude.Char] -> [Prelude.Char]) (d, d);
ac_dependency_pairs_proc i j shp x y z
  (AC_dependency_pairs_proof e dpr dpe rext) tp =
  bindb (ac_dependency_pairs_checks i shp x y z
          (AC_dependency_pairs_proof e dpr dpe rext) tp)
    (\ _ ->
      let {
        r = rf i tp;
      } in Inr (mkf j dpr dpe [] r e,
                 mkf j (map (\ (l, ra) -> (sharp_term shp l, sharp_term shp ra))
                         rext)
                   dpe [] r e));

delete_rulesa ::
  forall a b c d. Ac_tp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
delete_rulesa (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = delete_rules;

ea :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
ea (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = e;

ac_rule_removal ::
  forall a b c.
    (Compare b, Eq b, Showa b, Compare c, Eq c,
      Showa c) => Ac_tp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
ac_rule_removal i rp r_remove tp =
  (case catch_errora
          (let {
             r = rf i tp;
             e = ea i tp;
             rremove = set r_remove;
             rns = filter (\ lr -> not (member lr rremove)) r;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (mono rp (r_remove ++ rns ++ e))
                      (\ _ ->
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'w', 'e', 'a', 'k', ' ', 'r', 'u',
   'l', 'e', 's', '\n'] .
x)))
                          (\ _ ->
                            bindb (catch_errora
                                    (catch_errora (forallM (ns rp) e)
                                      (\ x -> Inl (snd x)))
                                    (\ x ->
                                      Inl
(shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
     'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'e', 'q', 'u', 'a', 't', 'i', 'o',
     'n', 's', '\n'] .
  x)))
                              (\ _ ->
                                catch_errora
                                  (catch_errora (forallM (s rp) r_remove)
                                    (\ x -> Inl (snd x)))
                                  (\ x ->
                                    Inl (shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
     'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 's', 't', 'r', 'i', 'c', 't', ' ',
     'r', 'u', 'l', 'e', 's', '\n'] .
  x)))))))
          (\ x ->
            Inl (((shows_prec_list zero_nat
                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a',
                       'p', 'p', 'l', 'y', ' ', 'A', 'C', ' ', 'r', 'u', 'l',
                       'e', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'w',
                       'i', 't', 'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l',
                       'l', 'o', 'w', 'i', 'n', 'g', '\n'] .
                    desc rp) .
                   shows_nl) .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_rulesa i tp r_remove);
  });

shows_ac_tp ::
  forall a b c.
    (Showa b,
      Showa c) => Ac_tp_ops_ext a b c () ->
                    a -> [Prelude.Char] -> [Prelude.Char];
shows_ac_tp i t =
  let {
    r = rf i t;
    aa = a i t;
    ca = c i t;
  } in (shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
          ['r', 'u', 'l', 'e', 's', ':'] [' ', '-', '>', ' '] r .
         (if null aa then id
           else (shows_prec_list zero_nat
                   ['A', '-', 's', 'y', 'm', 'b', 'o', 'l', 's', ':', ' '] .
                  shows_prec_list zero_nat aa) .
                  shows_nl)) .
         (if null ca then id
           else (shows_prec_list zero_nat
                   ['C', '-', 's', 'y', 'm', 'b', 'o', 'l', 's', ':', ' '] .
                  shows_prec_list zero_nat ca) .
                  shows_nl);

check_ac_termination_proof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Ac_dpp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Ac_tp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      ([Prelude.Char] -> [Prelude.Char]) ->
                        d -> Ac_termination_proof b c [Prelude.Char] ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ac_termination_proof ia j i tp (AC_DP_Trans info prf1 prf2) =
  debug (i [])
    ['A', 'C', ' ', 'D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 'P',
      'a', 'i', 'r', 's']
    (bindb
      (catch_errora
        (ac_dependency_pairs_proc j ia Sharp ['x'] ['y'] ['z'] info tp)
        (\ x ->
          Inl (((i . shows_prec_list zero_nat
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         't', 'h', 'e', ' ', 'a', 'c', '-', 'd', 'e', 'p', 'e',
                         'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p', 'a', 'i', 'r',
                         ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ',
                         'o', 'n', '\n']) .
                 shows_ac_tp j tp) .
                x)))
      (\ (dp1, dp2) ->
        bindb (catch_errora
                (check_ac_dp_termination_proof ia
                  (i . shows_prec_list zero_nat ['.', '1']) dp1 prf1)
                (\ x ->
                  Inl ((i . shows_prec_list zero_nat
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'a',
                                'c', '-', 'd', 'e', 'p', 'e', 'n', 'd', 'e',
                                'n', 'c', 'y', ' ', 'p', 'a', 'i', 'r', ' ',
                                'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r',
                                '\n']) .
                        indent x)))
          (\ _ ->
            catch_errora
              (check_ac_dp_termination_proof ia
                (i . shows_prec_list zero_nat ['.', '2']) dp2 prf2)
              (\ x ->
                Inl ((i . shows_prec_list zero_nat
                            [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                              'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'a', 'c',
                              '-', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c',
                              'y', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o',
                              'c', 'e', 's', 's', 'o', 'r', '\n']) .
                      indent x)))));
check_ac_termination_proof ia j i tp (AC_DP_Trans_Single info prf1) =
  debug (i [])
    ['A', 'C', ' ', 'D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 'P',
      'a', 'i', 'r', 's']
    (bindb
      (catch_errora
        (ac_dependency_pairs_proc_simple j ia Sharp ['x'] ['y'] ['z'] info tp)
        (\ x ->
          Inl (((i . shows_prec_list zero_nat
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         't', 'h', 'e', ' ', 'a', 'c', '-', 'd', 'e', 'p', 'e',
                         'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p', 'a', 'i', 'r',
                         ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ',
                         'o', 'n', '\n']) .
                 shows_ac_tp j tp) .
                x)))
      (\ dp1 ->
        catch_errora
          (check_ac_dp_termination_proof ia
            (i . shows_prec_list zero_nat ['.', '1']) dp1 prf1)
          (\ x ->
            Inl ((i . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'a', 'c', '-', 'd',
                          'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p',
                          'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                          'o', 'r', '\n']) .
                  indent x))));
check_ac_termination_proof ia j i tp (AC_Rule_Removal redp del_r prf) =
  debug (i [])
    ['A', 'C', '_', 'M', 'o', 'n', 'o', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r',
      '_', 'U', 'R', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (ac_rule_removal j (get_redtriple redp) del_r tp)
        (\ x ->
          Inl ((((((i . shows_prec_list zero_nat
                          [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h',
                            'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n',
                            'g', ' ', 'a', 'c', '-', 'r', 'u', 'l', 'e', ' ',
                            'r', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 't', 'o',
                            ' ', 'r', 'e', 'm', 'o', 'v', 'e', ' ', 'f', 'r',
                            'o', 'm', ' ', 't', 'h', 'e', ' ', 'A', 'C', ' ',
                            't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                            'n', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                            '\n']) .
                    shows_ac_tp j tp) .
                   shows_prec_list zero_nat
                     ['\n', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's',
                       '\n']) .
                  shows_rules (shows_prec_lab zero_nat)
                    (shows_prec_list zero_nat) [' ', '-', '>', ' '] del_r) .
                 shows_nl) .
                x)))
      (\ tpa ->
        catch_errora
          (check_ac_termination_proof ia j
            (i . shows_prec_list zero_nat ['.', '1']) tpa prf)
          (\ x ->
            Inl ((i . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 'a', 'c', '-', 'r', 'u', 'l', 'e', ' ',
                          'r', 'e', 'm', 'o', 'v', 'a', 'l', '\n']) .
                  indent x))));
check_ac_termination_proof ia j i tp AC_R_is_Empty =
  debug (i []) ['A', 'C', '_', 'R', '_', 'i', 's', '_', 'E', 'm', 'p', 't', 'y']
    (catch_errora
      (check (null (rf j tp))
        (shows_prec_list zero_nat
          ['T', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o', 't',
            ' ', 'e', 'm', 'p', 't', 'y']))
      (\ x ->
        Inl ((((i . shows_prec_list zero_nat
                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                        'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                        't', 'h', 'e', ' ', 'R', '-', 'i', 's', '-', 'E', 'm',
                        'p', 't', 'y', ' ', 'c', 'h', 'e', 'c', 'k', ' ', 'o',
                        'n', ' ', 't', 'h', 'e', ' ', 'A', 'C', ' ', 't', 'e',
                        'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p',
                        'r', 'o', 'b', 'l', 'e', 'm', '\n']) .
                shows_ac_tp j tp) .
               shows_nl) .
              x)));

check_single_subsumption ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b, Term a b) ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_single_subsumption eq e convs =
  bindb (check (membera (map fst convs) eq)
          (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
               'd', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ',
               'f', 'o', 'r', ' ', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
               ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '=', ' '] eq))
    (\ _ -> check_subsumptions_guided e convs);

eq_proof_lines ::
  forall a b.
    (Showa a,
      Showa b) => Eq_proof a b ->
                    Nat ->
                      ([Prelude.Char] -> [Prelude.Char],
                        (Nat, (Term a b, Term a b)));
eq_proof_lines (Refl s) i =
  ((shows_nl . shows_prec_nat zero_nat (suc i) . shows_string [':', ' ']) .
     shows_rule (shows_prec zero_nat) (shows_prec zero_nat) [' ', '=', ' ']
       (s, s) .
       shows_string [' ', '[', 'r', 'e', 'f', 'l', ']'],
    (suc i, (s, s)));
eq_proof_lines (Sym p) i =
  let {
    (s, (ia, (l, r))) = eq_proof_lines p i;
  } in (s . (shows_nl .
              shows_prec_nat zero_nat (suc ia) . shows_string [':', ' ']) .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '=', ' '] (r, l) .
                shows_string [' ', '[', 's', 'y', 'm', ' '] .
                  shows_prec_nat zero_nat ia . shows_string [']'],
         (suc ia, (r, l)));
eq_proof_lines (Trans p1 p2) i =
  let {
    (s1, (i1, (s, _))) = eq_proof_lines p1 i;
    (s2, (i2, (_, v))) = eq_proof_lines p2 i1;
  } in (s1 . s2 . (shows_nl .
                    shows_prec_nat zero_nat (suc i2) .
                      shows_string [':', ' ']) .
                    shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                      [' ', '=', ' '] (s, v) .
                      shows_string [' ', '[', 't', 'r', 'a', 'n', 's', ' '] .
                        shows_prec_nat zero_nat i1 .
                          shows_string [',', ' '] .
                            shows_prec_nat zero_nat i2 . shows_string [']'],
         (suc i2, (s, v)));
eq_proof_lines (Assm (l, r) sigma) i =
  let {
    eq = (subst_apply_term l sigma, subst_apply_term r sigma);
  } in ((shows_nl . shows_prec_nat zero_nat (suc i) . shows_string [':', ' ']) .
          shows_rule (shows_prec zero_nat) (shows_prec zero_nat) [' ', '=', ' ']
            eq .
            shows_string [' ', '[', 'a', 's', 's', 'm', ' '] .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '=', ' '] (l, r) .
                shows_string [']'],
         (suc i, eq));
eq_proof_lines (Cong f ps) i =
  let {
    (s, (is, (ls, rs))) = eq_proofs_lines ps i;
    eq = (Fun f ls, Fun f rs);
    ia = last is;
    isa = butlast is;
  } in (s . (shows_nl .
              shows_prec_nat zero_nat (suc ia) . shows_string [':', ' ']) .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '=', ' '] eq .
                shows_list_gen (shows_prec_nat zero_nat)
                  [' ', '[', 'c', 'o', 'n', 'g', ']']
                  [' ', '[', 'c', 'o', 'n', 'g', ' '] [',', ' '] [']'] isa,
         (suc ia, eq));

eq_proofs_lines ::
  forall a b.
    (Showa a,
      Showa b) => [Eq_proof a b] ->
                    Nat ->
                      ([Prelude.Char] -> [Prelude.Char],
                        ([Nat], ([Term a b], [Term a b])));
eq_proofs_lines [] i = (id, ([i], ([], [])));
eq_proofs_lines (p : ps) i = let {
                               (s1, (ia, (l, r))) = eq_proof_lines p i;
                               (s2, (is, (ls, rs))) = eq_proofs_lines ps ia;
                             } in (s1 . s2, (ia : is, (l : ls, r : rs)));

check_proves ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Eq_proof a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Term a b, Term a b);
check_proves e (Refl s) = Inr (s, s);
check_proves e (Sym p) = bindb (check_proves e p) (\ (s, t) -> Inr (t, s));
check_proves e (Trans p1 p2) =
  bindb (check_proves e p1)
    (\ (s, t) ->
      bindb (check_proves e p2)
        (\ (ta, u) ->
          (if equal_term t ta then Inr (s, u)
            else Inl (shows_string
                        ['t', 'h', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o',
                          'c', 'c', 'u', 'r', 's', ' ', 'i', 'n', ' ', 't', 'h',
                          'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                          ' ', 'p', 'a', 'r', 't', ' '] .
                       shows_nl .
                         fst (eq_proof_lines (Trans p1 p2) zero_nat) .
                           shows_nl .
                             shows_nl .
                               shows_prec_term zero_nat t .
                                 shows_string
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e',
                                     'q', 'u', 'a', 'l', ' ', 't', 'o', ' '] .
                                   shows_prec_term zero_nat ta))));
check_proves e (Assm (l, r) sigma) =
  (if membera e (l, r)
    then Inr (subst_apply_term l sigma, subst_apply_term r sigma)
    else Inl (shows_string
                ['t', 'h', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o', 'c',
                  'c', 'u', 'r', 's', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ',
                  'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'p', 'a',
                  'r', 't', ' '] .
               shows_nl .
                 fst (eq_proof_lines (Assm (l, r) sigma) zero_nat) .
                   shows_nl .
                     shows_nl .
                       shows_eq (shows_prec zero_nat) (shows_prec zero_nat)
                         (l, r) .
                         shows_string
                           [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n',
                             ' ', 't', 'h', 'e', ' '] .
                           shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                             ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l',
                               ' ', 's', 'y', 's', 't', 'e', 'm', ':']
                             [' ', '=', ' '] e));
check_proves e (Cong f ps) =
  bindb (mapM (check_proves e) ps)
    (\ sts -> Inr (Fun f (map fst sts), Fun f (map snd sts)));

check_eq_proof ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Eq_proof a b ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_eq_proof e p eq =
  catch_errora
    (bindb (check_proves e p)
      (\ eqa ->
        (if eq == eqa then Inr ()
          else Inl (shows_string
                     ['t', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'd',
                       'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'f', 'i', 't',
                       ' ', 't', 'h', 'e', ' ', 'g', 'o', 'a', 'l']))))
    (\ x ->
      Inl (shows_string
             ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', 'n', ' ', 'e',
               'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'e',
               'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'l', 'o', 'g',
               'i', 'c', ' ', 'p', 'r', 'o', 'o', 'f'] .
            shows_nl .
              fst (eq_proof_lines p zero_nat) .
                shows_nl .
                  shows_nl .
                    shows_string
                      ['f', 'o', 'r', ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g',
                        ' ', 't', 'h', 'e', ' ', 'e', 'q', 'u', 'a', 't', 'i',
                        'o', 'n'] .
                      shows_nl .
                        shows_nl .
                          shows_eq (shows_prec zero_nat) (shows_prec zero_nat)
                            eq .
                            shows_nl .
                              shows_nl .
                                shows_string
                                  ['u', 's', 'i', 'n', 'g', ' ', 't', 'h', 'e',
                                    ' '] .
                                  shows_trs (shows_prec zero_nat)
                                    (shows_prec zero_nat)
                                    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
                                      'a', 'l', ' ', 's', 'y', 's', 't', 'e',
                                      'm', ':']
                                    [' ', '=', ' '] e .
                                    shows_nl . x));

check_equational_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            (Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]) ->
                              Equational_proof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_equational_proof a ia i j e eq (Equational_Proof_Tree p) =
  debug (ia [])
    ['E', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', '_', 'P', 'r', 'o', 'o',
      'f', '_', 'T', 'r', 'e', 'e']
    (check_eq_proof e p eq);
check_equational_proof a ia i j e eq (Conversion eseq) =
  debug (ia []) ['C', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n']
    (check_conversiona e eseq (fst eq) (snd eq));
check_equational_proof a ia i j e eq (Conversion_With_History convs) =
  debug (ia [])
    ['C', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'w', 'i', 't', 'h',
      ' ', 'H', 'i', 's', 't', 'o', 'r', 'y']
    (check_single_subsumption eq e convs);
check_equational_proof a ia i j e eq (Completion_and_Normalization r p) =
  debug (ia [])
    ['C', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', '_', 'a', 'n', 'd', '_',
      'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n']
    (bindb (check_completion_proof a ia i j e r p)
      (\ _ ->
        let {
          s = fst eq;
          t = snd eq;
        } in (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
               (Nothing, _) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab zero_nat)
                             (shows_prec_list zero_nat) t);
               (Just _, Nothing) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab zero_nat)
                             (shows_prec_list zero_nat) t);
               (Just sa, Just ta) ->
                 (if equal_term sa ta then Inr ()
                   else Inl (shows_term (shows_prec_lab zero_nat)
                               (shows_prec_list zero_nat) s .
                              shows_string [' ', 'a', 'n', 'd', ' '] .
                                shows_term (shows_prec_lab zero_nat)
                                  (shows_prec_list zero_nat) t .
                                  shows_string
                                    [' ', 'h', 'a', 'v', 'e', ' ', 'd', 'i',
                                      'f', 'f', 'e', 'r', 'e', 'n', 't', ' ',
                                      'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f',
                                      'o', 'r', 'm', 's']));
             })));

check_dp_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          c -> Dp_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_termination_proof ia j a i dpp prf =
  check_dp_termination_proof_main ia j a i dpp (fst (unlab_to_split_dp prf));

mke ::
  forall a b c d.
    Ac_tp_ops_ext a b c d -> [(Term b c, Term b c)] -> [b] -> [b] -> a;
mke (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = mk;

get_args_impl :: forall a b. Bool -> Term a b -> [Term a b];
get_args_impl True t = args t;
get_args_impl False t = [t];

innermost_repl_map_impl ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                        [((a, Nat), Nat)];
innermost_repl_map_impl r ecap p =
  remdups
    (concatMap
      (\ ((l, ra), b) ->
        concatMap
          (\ u ->
            (if not (is_Var u)
              then concatMap
                     (\ rs ->
                       concatMap
                         (\ f ->
                           concatMap
                             (\ n ->
                               concatMap
                                 (\ i ->
                                   (if contains_var_term (Inl ())
 (ecap (get_args_impl b l) (nth rs i))
                                     then [(f, i)] else []))
                                 (upt zero_nat n))
                             [snd f])
                         [the (root u)])
                     [args u]
              else []))
          (supteq_list ra))
      (map (\ lr -> (lr, True)) r ++ map (\ st -> (st, False)) p));

mu_i_P_impl ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                        ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
mu_i_P_impl r ecap p =
  let {
    fis = innermost_repl_map_impl r ecap p;
    fs = remdups (map fst fis);
    mu = (\ f ->
           set (map_filter
                 (\ x -> (if let {
                               (g, _) = x;
                             } in g == f
                           then Just (snd x) else Nothing))
                 fis));
  } in (fs, (precompute_fun mu fs,
              ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'U', 'R',
                'M']));

mu_i_impl ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
mu_i_impl r ecap = mu_i_P_impl r ecap [];

default_fs ::
  forall a.
    (Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(a, Nat)];
default_fs r = funas_trs_list r;

full_empty ::
  forall a.
    (Eq a) => [(a, Nat)] -> ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
full_empty fs =
  let {
    fsa = filter (\ (_, n) -> not (equal_nat n zero_nat)) fs;
  } in (fsa, ((\ f ->
                (if membera fsa f then full_af f
                  else set_empty (of_phantom set_impl_nat))),
               ['f', 'u', 'l', 'l', ' ', 'A', 'F']));

get_fs_mu ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      Bool ->
                        Complexity_measure a [Prelude.Char] ->
                          ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
get_fs_mu r ecap inn (Runtime_Complexity c d) =
  (if inn && less_eq_set (inf_set (set c) (set (defined_list r))) bot_set
    then mu_i_impl r ecap else full_empty (remdups (c ++ d ++ default_fs r)));
get_fs_mu r ecap inn (Derivational_Complexity f) =
  full_empty (remdups (f ++ default_fs r));

is_Fsharp_term ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Set (a, Nat) -> Set (a, Nat) -> Term a b -> Bool;
is_Fsharp_term uu uv (Var uw) = False;
is_Fsharp_term fs fa (Fun f ts) =
  member (f, size_list ts) fs &&
    less_eq_set (set (concatMap funas_term_list ts)) fa;

funas_mctxt_list :: forall a b. Mctxt a b -> [(a, Nat)];
funas_mctxt_list (MFun f cs) =
  (f, size_list cs) : concatMap funas_mctxt_list cs;
funas_mctxt_list (MVar v) = [];
funas_mctxt_list MHole = [];

split_term ::
  forall a b. (Term a b -> Bool) -> Term a b -> (Mctxt a b, [Term a b]);
split_term p (Var x) = (if p (Var x) then (MHole, [Var x]) else (MVar x, []));
split_term p (Fun f ts) =
  (if p (Fun f ts) then (MHole, [Fun f ts])
    else let {
           us = map (split_term p) ts;
         } in (MFun f (map fst us), concatMap snd us));

split_DP ::
  forall a b.
    (Ceq a,
      Ccompare a) => Set (a, Nat) ->
                       (Term a b, Term a b) -> (Mctxt a b, [Term a b]);
split_DP fs =
  (\ r ->
    split_term (\ t -> not (is_Var t) && member (the (root t)) fs) (snd r));

check_DP_complexity ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Showa a,
      Showa b) => [(Term a b, Term a b)] ->
                    Complexity_measure a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        ([(Term a b, Term a b)],
                          ([(Term a b, Term a b)],
                            ([(a, Nat)], ([(a, Nat)], [(a, Nat)]))));
check_DP_complexity p (Derivational_Complexity uu) =
  Inl (shows_prec_list zero_nat
        ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'r', 'u', 'n', 't', 'i', 'm',
          'e', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']);
check_DP_complexity p (Runtime_Complexity c fs) =
  let {
    fsa = set fs;
    (rs, r) = partition (\ lr -> member (the (root (fst lr))) fsa) p;
    cs_ts = map (split_DP fsa) rs;
    cp = remdups (concatMap (funas_mctxt_list . fst) cs_ts);
    cpa = set cp;
    f = remdups
          (c ++ funas_trs_list r ++
                  concat
                    (concatMap (\ (fsb, _) -> map funas_term_list (args fsb))
                      rs) ++
                    concat
                      (concatMap
                        (\ (_, a) ->
                          concatMap (\ t -> map funas_term_list (args t)) a)
                        cs_ts));
    fa = set f;
  } in bindb (check
               (is_empty (inf_set fa fsa) &&
                 is_empty (inf_set fa cpa) && is_empty (inf_set fsa cpa))
               (shows_prec_list zero_nat
                 ['s', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'a', 'r', 'e', ' ',
                   'n', 'o', 't', ' ', 'd', 'i', 's', 'j', 'o', 'i', 'n', 't']))
         (\ _ ->
           bindb (check (all (\ lr -> is_Fsharp_term fsa fa (fst lr)) rs)
                   (shows_prec_list zero_nat
                     ['l', 'h', 's', 's', ' ', 'o', 'f', ' ', 'R', 'S', ' ',
                       'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 's', 'h', 'a',
                       'r', 'p', ' ', 't', 'e', 'r', 'm', 's']))
             (\ _ -> Inr (rs, (r, (cp, (fs, f))))));

get_fs_mu_DP ::
  forall a.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Key a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      Bool ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                          Complexity_measure a [Prelude.Char] ->
                            ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
get_fs_mu_DP r ecap inn s cm =
  let {
    (fs, (mu, info)) = get_fs_mu r ecap inn cm;
  } in (case check_DP_complexity r cm of {
         Inl _ -> (fs, (mu, info));
         Inr (rs, (_, (cp, (_, _)))) ->
           (if all (membera rs) s
             then (list_inter fs cp,
                    ((\ f ->
                       (if membera cp f then mu f
                         else set_empty (of_phantom set_impl_nat))),
                      info ++ [' ', 'w', 'i', 't', 'h', ' ', 'D', 'P', 's']))
             else (fs, (mu, info)));
       });

shows_prec_complexity_class ::
  Nat -> Complexity_class -> [Prelude.Char] -> [Prelude.Char];
shows_prec_complexity_class d c =
  (if equal_nat (degree c) zero_nat
    then shows_prec_list zero_nat ['O', '(', '1', ')']
    else (if equal_nat (degree c) one_nat
           then shows_prec_list zero_nat ['O', '(', 'n', ')']
           else shows_string ['O', '(', 'n', '^'] .
                  shows_prec_nat zero_nat (degree c) .
                    shows_prec_list zero_nat [')']));

is_ur_closed_af_impl_tp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Term b [Prelude.Char] -> Bool;
is_ur_closed_af_impl_tp_mv i d pi =
  let {
    ic = icap_impl_tp i d;
    qnf = is_QNFb i d;
    r = rulesd i d;
    urc = (\ s -> is_ur_closed_term_af_impl qnf (ic s) pi r);
  } in (\ u s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_term (\ x -> x) (\ a -> 'x' : a) t)));

extract_rt_C_D ::
  forall a b.
    Complexity_measure a b ->
      Sum ([Prelude.Char] -> [Prelude.Char]) ([(a, Nat)], [(a, Nat)]);
extract_rt_C_D (Runtime_Complexity c d) = Inr (c, d);
extract_rt_C_D (Derivational_Complexity v) =
  Inl (shows_prec_list zero_nat
        ['r', 'u', 'n', 't', 'i', 'm', 'e', ' ', 'c', 'o', 'm', 'p', 'l', 'e',
          'x', 'i', 't', 'y', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']);

cpx ::
  forall a b c.
    Redtriple_ext a b c ->
      Complexity_measure a b ->
        Complexity_class -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
cpx (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  cpx;

rule_shift_complexity_urm_ur_tt ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          Complexity_measure b [Prelude.Char] ->
                            Complexity_class ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_shift_complexity_urm_ur_tt i rp rdelete ur cm cc tp =
  let {
    rb = rulesd i tp;
    r = rc i tp;
    rw = rwc i tp;
    r2 = ceta_list_diff r rdelete;
    rremain = rw ++ r2;
    isnf = is_QNFb i tp;
    inn = nFQ_subset_NF_rulesb i tp;
  } in (case catch_errora
               (bindb
                 (catch_errora (check_subseteq rdelete rb)
                   (\ x ->
                     Inl (shows_string ['r', 'u', 'l', 'e', ' '] .
                           shows_rule (shows_prec zero_nat)
                             (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                             shows_prec_list zero_nat
                               [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b',
                                 'e', ' ', 'd', 'e', 'l', 'e', 't', 'e', 'd',
                                 ',', ' ', 'b', 'u', 't', ' ', 'd', 'o', 'e',
                                 's', ' ', 'n', 'o', 't', ' ', 'o', 'c', 'c',
                                 'u', 'r', ' ', 'i', 'n', ' ', 'p', 'r', 'o',
                                 'b', 'l', 'e', 'm'])))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       bindb (check (nFQ_subset_NF_rulesb i tp)
                               (shows_prec_list zero_nat
                                 ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't',
                                   ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e',
                                   'd']))
                         (\ _ ->
                           let {
                             (fs, (mu, info)) =
                               get_fs_mu_DP rb (icap_impl isnf rb) inn rdelete
                                 cm;
                             (_, (pi, _)) =
                               get_fs_mu_DP rb (icap_impl isnf rb) inn rremain
                                 cm;
                           } in bindb (extract_rt_C_D cm)
                                  (\ (cl, dl) ->
                                    let {
                                      c = set cl;
                                      d = set dl;
                                    } in bindb
   (check (null (list_inter cl (defined_list rb)))
     (shows_prec_list zero_nat
        ['c', 'o', 'n', 's', 't', 'r', 'u', 'c', 't', 'o', 'r', 's', ' '] .
       shows_prec_list zero_nat cl .
         shows_prec_list zero_nat
           [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ',
             'd', 'e', 'f', 'i', 'n', 'e', 'd']))
   (\ _ ->
     bindb (valid rp)
       (\ _ ->
         bindb (catch_errora
                 (forallM
                   (\ (l, ra) ->
                     check (not (member (the (root l)) d &&
                                  less_eq_set
                                    (foldr (sup_set . funas_term) (args l)
                                      bot_set)
                                    c))
                       (shows_rule (shows_prec zero_nat)
                          (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                          (l, ra) .
                         shows_prec_list zero_nat
                           [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e',
                             ' ', 'u', 's', 'a', 'b', 'l', 'e']))
                   (list_diff rb ur))
                 (\ x -> Inl (snd x)))
           (\ _ ->
             let {
               is_urc = is_ur_closed_af_impl_tp_mv i tp mu ur;
               pia = af_inter (af rp) pi;
               is_urc_pi = is_ur_closed_af_impl_tp_mv i tp pia ur;
             } in bindb (catch_errora
                          (forallM
                            (\ (l, ra) ->
                              check (is_urc (args l) ra &&
                                      is_urc_pi (args l) ra)
                                (shows_prec_list zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                     'i', 't', 'h', ' ', 'c', 'l', 'o', 's',
                                     'u', 'r', 'e', ' ', 'p', 'r', 'o', 'p',
                                     'e', 'r', 't', 'i', 'e', 's', ' ', 'o',
                                     'f', ' ', 'u', 's', 'a', 'b', 'l', 'e',
                                     ' ', 'r', 'u', 'l', 'e', ' '] .
                                  shows_rule (shows_prec zero_nat)
                                    (shows_prec_list zero_nat)
                                    [' ', '-', '>', ' '] (l, ra) .
                                    shows_prec_list zero_nat
                                      [':', ' ', 'r', 'h', 's', ' ', 'i', 's',
' ', 'n', 'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'u', 'n', 'd', 'e',
'r', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']))
                            ur)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (catch_errora
                              (catch_errora
                                (forallM
                                  (\ f ->
                                    check (subset (mu f) (mono_af rp f))
                                      (shows_string
 ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'm', 'o', 'n', 'o', 't', 'o',
   'n', 'i', 'c', 'i', 't', 'y', ':', ' ', 's', 't', 'r', 'i', 'c', 't', ' ',
   'o', 'r', 'd', 'e', 'r', ' ', 'f', 'o', 'r', ' '] .
shows_prec_prod zero_nat f .
  shows_string
    [' ', 'e', 'n', 's', 'u', 'r', 'e', 's', ' ', 'm', 'o', 'n', 'o', 't', 'o',
      'n', 'i', 'c', 'i', 't', 'y', ' ', 'i', 'n', ' ', 'p', 'o', 's', 'i', 't',
      'i', 'o', 'n', 's', ' '] .
    show_position_set f (mono_af rp f) .
      shows_string
        ['\n', 'b', 'u', 't', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'e',
          'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ' ', 'm', 'a', 'p', ' ',
          'i', 's', ' '] .
        show_position_set f (mu f)))
                                  fs)
                                (\ x -> Inl (snd x)))
                              (\ x ->
                                Inl (x . shows_string
   ['\n', 't', 'h', 'e', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'e', 'd', ' ', 'u',
     's', 'a', 'b', 'l', 'e', ' ', 'r', 'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e',
     'n', 't', ' ', 'm', 'a', 'p', ' ', '('] .
   shows_string info .
     shows_string [')', ' ', 'i', 's', '\n'] .
       shows_sep
         (\ f ->
           shows_prec_list zero_nat ['m', 'u', '('] .
             shows_prec_prod zero_nat f .
               shows_prec_list zero_nat [')', ' ', '=', ' '] .
                 show_position_set f (mu f))
         shows_nl fs .
         shows_prec_list zero_nat
           ['\n', 'a', 'n', 'd', ' ', 'm', 'u', '(', 'f', ')', ' ', '=', ' ',
             '{', '}', ' ', 'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ', 'o', 't',
             'h', 'e', 'r', ' ', 's', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'f'])))
                        (\ _ ->
                          bindb (catch_errora
                                  (catch_errora
                                    (forallM (s rp) (list_inter rdelete ur))
                                    (\ x -> Inl (snd x)))
                                  (\ x ->
                                    Inl (shows_string
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
     'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 's', 't', 'r', 'i', 'c', 't', ' ',
     'T', 'R', 'S', '\n'] .
  x)))
                            (\ _ ->
                              bindb (catch_errora
                                      (catch_errora
(forallM (ns rp) (list_inter rremain ur)) (\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
         'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 's',
         't', 'r', 'i', 'c', 't', ' ', 'T', 'R', 'S', '\n'] .
      x)))
                                (\ _ ->
                                  catch_errora (cpx rp cm cc)
                                    (\ x ->
                                      Inl
(shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'e', 'n',
     's', 'u', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i',
     't', 'y', ' ', 'o', 'f', ' ', 'o', 'r', 'd', 'e', 'r', '\n'] .
  x))))))))))))))
               (\ x ->
                 Inl (shows_string
                        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'd',
                          'e', 'r', 'i', 'v', 'e', ' ', 't', 'h', 'e', ' ', 'i',
                          'n', 't', 'e', 'n', 'd', 'e', 'd', ' ', 'c', 'o', 'm',
                          'p', 'l', 'e', 'x', 'i', 't', 'y', ' '] .
                       shows_prec_complexity_class zero_nat cc .
                         shows_string
                           [' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ',
                             'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                             '\n'] .
                           desc rp .
                             shows_nl .
                               x . shows_string
                                     ['\n', 'w', 'i', 't', 'h', ' ', 'u', 's',
                                       'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                                       'e', 's', '\n'] .
                                     shows_trs (shows_prec zero_nat)
                                       (shows_prec_list zero_nat)
                                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
 's', 'y', 's', 't', 'e', 'm', ':']
                                       [' ', '-', '>', ' '] ur))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsb i tp) (qb i tp) r2 (list_union rw rdelete));
       });

inn_usable_rules_wf_tp ::
  forall a b.
    (Eq b,
      Key b) => Tp_ops_ext a b [Prelude.Char] () ->
                  a -> Bool ->
                         ([Term b [Prelude.Char]], Term b [Prelude.Char]) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])];
inn_usable_rules_wf_tp i d nfs =
  inn_usable_rules_wf (is_QNFb i d) (icap_impl_tp i d) (rulesd i d) nfs;

x_1_to_x_n :: Nat -> [[Prelude.Char]];
x_1_to_x_n = fresh_strings_list ['x'] one_nat [];

get_innermost_strict_repl_map_rc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                           Complexity_measure b c ->
                             ([(b, Nat)],
                               ((b, Nat) -> Set Nat, [Prelude.Char]));
get_innermost_strict_repl_map_rc i d s (Derivational_Complexity f) =
  full_empty (remdups (f ++ default_fs (rulesd i d)));
get_innermost_strict_repl_map_rc i da s (Runtime_Complexity c d) =
  let {
    r = rulesd i da;
  } in (if nFQ_subset_NF_rulesb i da &&
             less_eq_set (inf_set (set c) (set (defined_list r))) bot_set
         then let {
                isNF = is_QNFb i da;
                u = inn_usable_rules_wf_tp i da True;
                a = icap_impl_tp i da;
              } in mu_approx_impl r
                     (concatMap
                       (\ (f, n) ->
                         concatMap
                           (\ xs -> map (\ lr -> (xs, (Fun f xs, lr))) s)
                           [map Var (x_1_to_x_n n)])
                       d)
                     (\ ss t -> u (ss, t)) isNF a
         else full_empty (remdups (c ++ d ++ default_fs r)));

get_innermost_strict_repl_map_rc_DP ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                           Complexity_measure b [Prelude.Char] ->
                             ([(b, Nat)],
                               ((b, Nat) -> Set Nat, [Prelude.Char]));
get_innermost_strict_repl_map_rc_DP i d s t =
  let {
    (fs, (mu, info)) = get_innermost_strict_repl_map_rc i d s t;
  } in (case check_DP_complexity (rulesd i d) t of {
         Inl _ -> (fs, (mu, info));
         Inr (rs, (_, (cp, (_, _)))) ->
           (if all (membera rs) s
             then (list_inter fs cp,
                    ((\ f ->
                       (if membera cp f then mu f
                         else set_empty (of_phantom set_impl_nat))),
                      info ++ [' ', 'w', 'i', 't', 'h', ' ', 'D', 'P', 's']))
             else (fs, (mu, info)));
       });

rule_shift_complexity_urm_tt ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        Complexity_measure b [Prelude.Char] ->
                          Complexity_class ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_shift_complexity_urm_tt i rp rdelete cm cc tp =
  let {
    rb = rulesd i tp;
    r = rc i tp;
    rw = rwc i tp;
    r2 = ceta_list_diff r rdelete;
    _ = qb i tp;
  } in (case catch_errora
               (bindb
                 (catch_errora (check_subseteq rdelete rb)
                   (\ x ->
                     Inl (shows_string ['r', 'u', 'l', 'e', ' '] .
                           shows_rule (shows_prec zero_nat)
                             (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                             shows_prec_list zero_nat
                               [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b',
                                 'e', ' ', 'd', 'e', 'l', 'e', 't', 'e', 'd',
                                 ',', ' ', 'b', 'u', 't', ' ', 'd', 'o', 'e',
                                 's', ' ', 'n', 'o', 't', ' ', 'o', 'c', 'c',
                                 'u', 'r', ' ', 'i', 'n', ' ', 'p', 'r', 'o',
                                 'b', 'l', 'e', 'm'])))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       let {
                         (fs, (mu, info)) =
                           get_innermost_strict_repl_map_rc_DP i tp rdelete cm;
                       } in bindb (valid rp)
                              (\ _ ->
                                bindb (catch_errora
(catch_errora
  (forallM
    (\ f ->
      check (subset (mu f) (mono_af rp f))
        (((((shows_prec_list zero_nat
               ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'm', 'o', 'n', 'o',
                 't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ':', ' ', 's', 't',
                 'r', 'i', 'c', 't', ' ', 'o', 'r', 'd', 'e', 'r', ' ', 'f',
                 'o', 'r', ' '] .
              shows_prec_prod zero_nat f) .
             shows_prec_list zero_nat
               [' ', 'e', 'n', 's', 'u', 'r', 'e', 's', ' ', 'm', 'o', 'n', 'o',
                 't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ' ', 'i', 'n', ' ',
                 'p', 'o', 's', 'i', 't', 'i', 'o', 'n', 's', ' ']) .
            show_position_set f (mono_af rp f)) .
           shows_prec_list zero_nat
             ['\n', 'b', 'u', 't', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r',
               'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ' ', 'm', 'a',
               'p', ' ', 'i', 's', ' ']) .
          show_position_set f (mu f)))
    fs)
  (\ x -> Inl (snd x)))
(\ x ->
  Inl (((((x . shows_prec_list zero_nat
                 ['\n', 't', 'h', 'e', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'e',
                   'd', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'e', 'p',
                   'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ' ', 'm', 'a', 'p',
                   ' ', '(']) .
           shows_prec_list zero_nat info) .
          shows_prec_list zero_nat [')', ' ', 'i', 's', '\n']) .
         shows_sep
           (\ f ->
             ((shows_prec_list zero_nat ['m', 'u', '('] .
                shows_prec_prod zero_nat f) .
               shows_prec_list zero_nat [')', ' ', '=', ' ']) .
               show_position_set f (mu f))
           shows_nl fs) .
        shows_prec_list zero_nat
          ['\n', 'a', 'n', 'd', ' ', 'm', 'u', '(', 'f', ')', ' ', '=', ' ',
            '{', '}', ' ', 'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ', 'o', 't',
            'h', 'e', 'r', ' ', 's', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'f'])))
                                  (\ _ ->
                                    bindb (catch_errora
    (catch_errora (forallM (s rp) rdelete) (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 's', 't', 'r',
               'i', 'c', 't', ' ', 'T', 'R', 'S', '\n'] .
            x)))
                                      (\ _ ->
bindb (catch_errora
        (catch_errora (forallM (ns rp) (rw ++ r2)) (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                   ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'n',
                   'o', 'n', '-', 's', 't', 'r', 'i', 'c', 't', ' ', 'T', 'R',
                   'S', '\n'] .
                x)))
  (\ _ ->
    catch_errora (cpx rp cm cc)
      (\ x ->
        Inl (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
                 'e', 'n', 's', 'u', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'm',
                 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'o', 'f', ' ', 'o',
                 'r', 'd', 'e', 'r', '\n'] .
              x)))))))))
               (\ x ->
                 Inl (((((shows_prec_list zero_nat
                            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                              'd', 'e', 'r', 'i', 'v', 'e', ' ', 't', 'h', 'e',
                              ' ', 'i', 'n', 't', 'e', 'n', 'd', 'e', 'd', ' ',
                              'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                              ' '] .
                           shows_prec_complexity_class zero_nat cc) .
                          shows_prec_list zero_nat
                            [' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ',
                              'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                              '\n']) .
                         desc rp) .
                        shows_nl) .
                       x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsb i tp) (qb i tp) r2 (list_union rw rdelete));
       });

smart_rule_shift_complexity ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          Complexity_measure b [Prelude.Char] ->
                            Complexity_class ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
smart_rule_shift_complexity i rp rdelete (Just ur) cm cc tp =
  rule_shift_complexity_urm_ur_tt i rp rdelete ur cm cc tp;
smart_rule_shift_complexity i rp rdelete Nothing cm cc tp =
  rule_shift_complexity_urm_tt i rp rdelete cm cc tp;

usable_rules_complexity_innermost ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      Complexity_measure b [Prelude.Char] ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_complexity_innermost i nUr cm cc cp =
  catch_errora
    (let {
       s = rc i cp;
       w = rwc i cp;
       r = s ++ w;
     } in bindb (check (nFQ_subset_NF_rulesb i cp)
                  (shows_prec_list zero_nat
                    ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e',
                      'q', 'u', 'i', 'r', 'e', 'd']))
            (\ _ ->
              bindb (check_wf_trs r)
                (\ _ ->
                  bindb (extract_rt_C_D cm)
                    (\ (cl, dl) ->
                      let {
                        c = set cl;
                        d = set dl;
                        isnf = is_QNFb i cp;
                      } in bindb (check (null (list_inter cl (defined_list r)))
                                   (shows_prec_list zero_nat
                                      ['c', 'o', 'n', 's', 't', 'r', 'u', 'c',
't', 'o', 'r', 's', ' '] .
                                     shows_prec_list zero_nat cl .
                                       shows_prec_list zero_nat
 [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'd', 'e',
   'f', 'i', 'n', 'e', 'd']))
                             (\ _ ->
                               bindb (catch_errora (check_subseteq nUr r)
                                       (\ _ ->
 Inl (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
       shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
         [' ', '-', '>', ' '] nUr .
         shows_prec_list zero_nat
           [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'o', 'c', 'c',
             'u', 'r', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'])))
                                 (\ _ ->
                                   let {
                                     ur = list_diff r nUr;
                                   } in bindb
  (catch_errora
    (forallM
      (\ (l, ra) ->
        check (not (member (the (root l)) d &&
                     less_eq_set (foldr (sup_set . funas_term) (args l) bot_set)
                       c))
          (shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
             [' ', '-', '>', ' '] (l, ra) .
            shows_prec_list zero_nat
              [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e', ' ', 'u', 's',
                'a', 'b', 'l', 'e']))
      nUr)
    (\ x -> Inl (snd x)))
  (\ _ ->
    let {
      (_, (mu, _)) = get_fs_mu r (icap_impl isnf r) True cm;
      is_urc = is_ur_closed_af_impl_tp_mv i cp mu ur;
    } in bindb (catch_errora
                 (forallM
                   (\ (l, ra) ->
                     check (is_urc (args l) ra)
                       (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                            't', 'h', ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e',
                            ' ', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e',
                            's', ' ', 'o', 'f', ' ', 'u', 's', 'a', 'b', 'l',
                            'e', ' ', 'r', 'u', 'l', 'e', ' '] .
                         shows_rule (shows_prec zero_nat)
                           (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                           (l, ra) .
                           shows_prec_list zero_nat
                             [':', ' ', 'r', 'h', 's', ' ', 'i', 's', ' ', 'n',
                               'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ',
                               'u', 'n', 'd', 'e', 'r', ' ', 'u', 's', 'a', 'b',
                               'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']))
                   ur)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             Inr (mkc i (nfsb i cp) (qb i cp) (list_diff s nUr)
                   (list_diff w nUr))))))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'r', 'e',
               's', 't', 'r', 'i', 'c', 't', 'i', 'n', 'g', ' ', 't', 'o', ' ',
               'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'u', 's', 'a',
               'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
            shows_nl . x));

get_signature_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
get_signature_of_cm (Derivational_Complexity f) = f;
get_signature_of_cm (Runtime_Complexity c d) = c ++ d;

usable_rules_complexity_usymbols ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Compare c, Eq c,
      Showa c) => Tp_ops_ext a b c () ->
                    [(Term b c, Term b c)] ->
                      Complexity_measure b c ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_complexity_usymbols i nUr cm cc cp =
  catch_errora
    (let {
       s = rc i cp;
       w = rwc i cp;
       r = s ++ w;
     } in bindb (catch_errora (check_subseteq nUr r)
                  (\ _ ->
                    Inl (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                          shows_rules (shows_prec zero_nat)
                            (shows_prec zero_nat) [' ', '-', '>', ' '] nUr .
                            shows_prec_list zero_nat
                              [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                                'o', 'c', 'c', 'u', 'r', ' ', 'i', 'n', ' ',
                                'p', 'r', 'o', 'b', 'l', 'e', 'm'])))
            (\ _ ->
              let {
                ur = list_diff r nUr;
                us = set (concatMap (funas_term_list . snd) ur ++
                           get_signature_of_cm cm);
                urs = set ur;
              } in bindb (check_varcond_subset ur)
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ lr ->
                                   check (if less_eq_set (funas_term (fst lr))
       us
   then member lr urs else True)
                                     (shows_prec_list zero_nat
['r', 'u', 'l', 'e', ' '] .
                                       shows_rule (shows_prec zero_nat)
 (shows_prec zero_nat) [' ', '-', '>', ' '] lr .
 shows_prec_list zero_nat
   [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e', ' ', 'u', 's', 'a', 'b',
     'l', 'e']))
                                 r)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           Inr (mkc i (nfsb i cp) (qb i cp) (list_diff s nUr)
                                 (list_diff w nUr))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'r', 'e',
               's', 't', 'r', 'i', 'c', 't', 'i', 'n', 'g', ' ', 't', 'o', ' ',
               'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
               'w', '.', 'r', '.', 't', '.', ' ', 'u', 's', 'a', 'b', 'l', 'e',
               ' ', 's', 'y', 'm', 'b', 'o', 'l', 's'] .
            shows_nl . x));

usable_rules_complexity ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      Complexity_measure b [Prelude.Char] ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_complexity i nUr cm cc cp =
  (case usable_rules_complexity_usymbols i nUr cm cc cp of {
    Inl e ->
      (case usable_rules_complexity_innermost i nUr cm cc cp of {
        Inl ea ->
          Inl (shows_prec_list zero_nat
                 ['n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'o', 'f', ' ', 't',
                   'h', 'e', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u',
                   'l', 'e', 's', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                   'r', 's', ' ', 'i', 's', ' ', 'a', 'p', 'p', 'l', 'i', 'c',
                   'a', 'b', 'l', 'e', ':', ' '] .
                shows_nl .
                  shows_prec_list zero_nat
                    ['t', 'h', 'e', ' ', 'o', 'n', 'e', ' ', 'v', 'i', 'a', ' ',
                      'u', 's', 'a', 'b', 'l', 'e', ' ', 's', 'y', 'm', 'b',
                      'o', 'l', 's', ' ', 'c', 'o', 'm', 'p', 'l', 'a', 'i',
                      'n', 's', ' ', 'a', 's', ' ', 'f', 'o', 'l', 'l', 'o',
                      'w', 's'] .
                    shows_nl .
                      e . shows_nl .
                            shows_nl .
                              shows_prec_list zero_nat
                                ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'o',
                                  'n', 'e', ' ', 'v', 'i', 'a', ' ', 'i', 'c',
                                  'a', 'p', ' ', 'a', 'n', 'd', ' ', 'i', 'n',
                                  'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 's',
                                  'a', 'y', 's', ' '] .
                                shows_nl . ea);
        Inr a -> Inr a;
      });
    Inr a -> Inr a;
  });

split_proc_complexity ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Tp_ops_ext a b c () ->
                    [(Term b c, Term b c)] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) (a, a);
split_proc_complexity i s1 cp =
  catch_errora
    (let {
       s = rc i cp;
       w = rwc i cp;
       nfs = nfsb i cp;
       q = qb i cp;
     } in bindb (catch_errora (check_subseteq s1 s)
                  (\ x ->
                    Inl (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                            [' ', '-', '>', ' '] x .
                            shows_prec_list zero_nat
                              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ',
                                's', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u',
                                'l', 'e'])))
            (\ _ ->
              let {
                s2 = list_diff s s1;
              } in Inr (mkc i nfs q s1 (s2 ++ w), mkc i nfs q s2 (s1 ++ w))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'p',
               'l', 'i', 't', 't', 'i', 'n', 'g', ' ', 'c', 'o', 'm', 'p', 'l',
               'e', 'x', 'i', 't', 'y', ' ', 'p', 'r', 'o', 'b', 'l', 'e',
               'm'] .
            shows_nl . x));

shows_complexity_measure ::
  forall a b.
    (Linorder a,
      Showa a) => Complexity_measure a b -> [Prelude.Char] -> [Prelude.Char];
shows_complexity_measure (Runtime_Complexity c d) =
  shows_prec_list zero_nat
    ['b', 'a', 's', 'i', 'c', ' ', 't', 'e', 'r', 'm', 's', ' ', 'f', '(', 'c',
      '1', ',', '.', '.', ',', 'c', 'n', ')', ' ', 'w', 'h', 'e', 'r', 'e', ' ',
      'f', ' ', 'i', 'n', ' '] .
    shows_nl .
      shows_prec_list zero_nat (sort_key (\ x -> x) d) .
        shows_nl .
          shows_prec_list zero_nat
            [' ', 'a', 'n', 'd', ' ', 'c', 'i', ' ', 'i', 's', ' ', 't', 'e',
              'r', 'm', ' ', 'o', 'v', 'e', 'r', ' ', 's', 'i', 'g', 'n', 'a',
              't', 'u', 'r', 'e', ' '] .
            shows_nl .
              shows_prec_list zero_nat (sort_key (\ x -> x) c) . shows_nl;
shows_complexity_measure (Derivational_Complexity f) =
  shows_prec_list zero_nat
    ['a', 'l', 'l', ' ', 't', 'e', 'r', 'm', 's', ' ', 'o', 'v', 'e', 'r', ' ',
      's', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', ' '] .
    shows_nl . shows_prec_list zero_nat (sort_key (\ x -> x) f) . shows_nl;

shows_complexityLL ::
  forall a b c.
    (Key a, Showa a, Key b, Showa b, Key c,
      Showa c) => ([Term (Lab a b) c],
                    ([(Term (Lab a b) c, Term (Lab a b) c)],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        (Complexity_measure (Lab a b) c, Complexity_class)))) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_complexityLL (q, (s, (w, (cm, cc)))) =
  shows_prec_list zero_nat
    ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's'] .
    shows_nl .
      shows_rules (shows_prec_lab zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] (sort_key (\ x -> x) s) .
        shows_nl .
          shows_nl .
            shows_prec_list zero_nat
              ['w', 'e', 'a', 'k', ' ', 'r', 'u', 'l', 'e', 's'] .
              shows_nl .
                shows_rules (shows_prec_lab zero_nat) (shows_prec zero_nat)
                  [' ', '-', '>', ' '] (sort_key (\ x -> x) w) .
                  shows_nl .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'l',
                          'h', 's', 's', ' ', '(', 'Q', ')'] .
                        shows_nl .
                          shows_lines (sort_key (\ x -> x) q) .
                            shows_nl .
                              shows_nl .
                                shows_prec_list zero_nat
                                  ['s', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ',
                                    't', 'e', 'r', 'm', 's', ':', ' '] .
                                  shows_complexity_measure cm .
                                    shows_nl .
                                      shows_prec_list zero_nat
['i', 'n', 't', 'e', 'n', 'd', 'e', 'd', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x',
  'i', 't', 'y', ':', ' '] .
shows_prec_complexity_class zero_nat cc . shows_nl;

check_terms_of_main ::
  forall a b.
    (Eq a,
      Showa a) => Complexity_measure a b ->
                    Complexity_measure a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_terms_of_main (Derivational_Complexity f) (Derivational_Complexity g) =
  catch_errora (check_subseteq f g)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'n', 's', 'i', 'd', 'e', 'r', ' ', 'o', 'f', ' ', 's',
               'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec_prod zero_nat x));
check_terms_of_main (Runtime_Complexity f h) (Derivational_Complexity g) =
  catch_errora (check_subseteq (f ++ h) g)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'n', 's', 'i', 'd', 'e', 'r', ' ', 'o', 'f', ' ', 's',
               'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec_prod zero_nat x));
check_terms_of_main (Runtime_Complexity f h) (Runtime_Complexity f1 h1) =
  bindb (catch_errora (check_subseteq f f1)
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['c', 'o', 'n', 's', 'i', 'd', 'e', 'r', ' ', 's', 'y', 'm',
                     'b', 'o', 'l', ' '] .
                  shows_prec_prod zero_nat x)))
    (\ _ ->
      catch_errora (check_subseteq h h1)
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['c', 'o', 'n', 's', 'i', 'd', 'e', 'r', ' ', 's', 'y', 'm',
                   'b', 'o', 'l', ' '] .
                shows_prec_prod zero_nat x)));
check_terms_of_main (Derivational_Complexity g) (Runtime_Complexity f1 h1) =
  Inl (shows_prec_list zero_nat
        ['m', 'i', 'x', 'i', 'n', 'g', ' ', 'r', 'u', 'n', 't', 'i', 'm', 'e',
          ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'a', 'n',
          'd', ' ', 'd', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l',
          ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']);

check_terms_of_nat ::
  forall a b.
    (Eq a,
      Showa a) => Complexity_measure a b ->
                    Complexity_measure a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_terms_of_nat cm1 cm2 =
  catch_errora (check_terms_of_main cm1 cm2)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'm', 'p', 'a', 'r', 'i',
               'n', 'g', ' ', 's', 't', 'a', 'r', 't', ' ', 't', 'e', 'r', 'm',
               's'] .
            shows_nl . x));

check_complexity_subsumes ::
  forall a b c.
    (Eq a, Key a, Showa a, Eq b, Key b, Showa b, Ccompare c, Eq c, Key c,
      Mapping_impl c,
      Showa c) => ([Term (Lab a b) c],
                    ([(Term (Lab a b) c, Term (Lab a b) c)],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        (Complexity_measure (Lab a b) c, Complexity_class)))) ->
                    ([Term (Lab a b) c],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        ([(Term (Lab a b) c, Term (Lab a b) c)],
                          (Complexity_measure (Lab a b) c,
                            Complexity_class)))) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_complexity_subsumes (q1, (s1, (w1, (cm1, cc1))))
  (q2, (s2, (w2, (cm2, cc2)))) =
  catch_errora
    (bindb
      (catch_errora (check_subseteq s2 s1)
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', ' '] .
                shows_rule (shows_prec_lab zero_nat) (shows_prec zero_nat)
                  [' ', '-', '>', ' '] x .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
      (\ _ ->
        bindb (catch_errora (check_subseteq w2 w1)
                (\ x ->
                  Inl (shows_prec_list zero_nat
                         ['w', 'e', 'a', 'k', ' ', 'r', 'u', 'l', 'e', ' '] .
                        shows_rule (shows_prec_lab zero_nat)
                          (shows_prec zero_nat) [' ', '-', '>', ' '] x .
                          shows_prec_list zero_nat
                            [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                              'g'])))
          (\ _ ->
            bindb (catch_errora (check_NF_terms_subset (is_NF_terms q2) q1)
                    (\ x ->
                      Inl (shows_prec_list zero_nat
                             ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f', 'f',
                               'e', 'r', 's', ' ', 'd', 'u', 'e', ' ', 't', 'o',
                               ' ', 't', 'e', 'r', 'm', ' '] .
                            shows_prec_term zero_nat x)))
              (\ _ ->
                bindb (check (less_eq_complexity_class cc1 cc2)
                        (shows_prec_list zero_nat
                          ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                            ' ', 'c', 'l', 'a', 's', 's', 'e', 's', ' ', 'd',
                            'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c',
                            'h']))
                  (\ _ -> check_terms_of_nat cm2 cm1)))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
               'u', 'r', 'e', ' ', 't', 'h', 'a', 't', ' ', 'a', 's', 's', 'u',
               'm', 'p', 't', 'i', 'o', 'n', ' ', 'm', 'a', 't', 'c', 'h', 'e',
               's', ' ', 'c', 'u', 'r', 'r', 'e', 'n', 't', ' ', 'c', 'o', 'm',
               'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'p', 'r', 'o', 'b', 'l',
               'e', 'm'] .
            shows_nl .
              x . shows_nl .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', ' ',
                          'i', 's', ' '] .
                        shows_nl .
                          shows_complexityLL (q1, (s1, (w1, (cm1, cc1)))) .
                            shows_nl .
                              shows_nl .
                                shows_prec_list zero_nat
                                  ['c', 'u', 'r', 'r', 'e', 'n', 't', ' ', 'p',
                                    'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 's',
                                    ' '] .
                                  shows_nl .
                                    shows_complexityLL
                                      (q2, (s2, (w2, (cm2, cc2))))));

check_tup :: forall a b. (Ceq a, Ccompare a) => Set a -> Term a b -> Bool;
check_tup t (Var x) = False;
check_tup t (Fun f ts) = member f t;

dPos_impl ::
  forall a b.
    (Ceq a,
      Ccompare a) => (a -> a) -> Set (a, Nat) -> Term a b -> [(Pos, Term a b)];
dPos_impl shp d (Var x) = [];
dPos_impl shp d (Fun f ts) =
  let {
    n = size_list ts;
  } in (if member (f, n) d then (\ a -> (Empty, Fun (shp f) ts) : a) else id)
         (concatMap
           (\ (i, ti) -> map (\ (p, a) -> (PCons i p, a)) (dPos_impl shp d ti))
           (zip (upt zero_nat n) ts));

check_rule_dt ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Showa a, Eq b,
      Showa b) => (a -> a) ->
                    Set (a, Nat) ->
                      Set a ->
                        ((Term a b, Term a b), (Term a b, Term a b)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_dt shp d ds =
  (\ (a, b) ->
    let {
      (l, r) = a;
    } in (\ (dl, dr) ->
           catch_errora
             (let {
                sl = sharp_term shp l;
              } in bindb (check (equal_term sl dl)
                           (shows_string
                              ['w', 'r', 'o', 'n', 'g', ' ', 'l', 'h', 's', ',',
                                ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
                                ' '] .
                             shows_prec_term zero_nat sl .
                               shows_string
                                 [' ', 'b', 'u', 't', ' ', 'g', 'o', 't', ' '] .
                                 shows_prec_term zero_nat dl))
                     (\ _ ->
                       let {
                         pts = dPos_impl shp d r;
                         spts = map snd pts;
                         (_, dts) = split_term (check_tup ds) dr;
                       } in check (equal_multiset (mset dts) (mset spts))
                              (shows_prec_list zero_nat
                                ['m', 'u', 'l', 't', 'i', 's', 'e', 't', ' ',
                                  'o', 'f', ' ', 's', 'u', 'b', 't', 'e', 'r',
                                  'm', 's', ' ', 'w', 'i', 't', 'h', ' ', 'd',
                                  'e', 'f', 'i', 'n', 'e', 'd', ' ', 'r', 'o',
                                  'o', 't', 's', ' ', 'd', 'i', 'f', 'f', 'e',
                                  'r', 's'])))
             (\ x ->
               Inl (shows_string
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e',
                        'n', 's', 'u', 'r', 'e', ' ', 't', 'h', 'a', 't', ' '] .
                     shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                       [' ', '-', '>', ' '] (dl, dr) .
                       shows_string
                         [' ', 'i', 's', ' ', 'a', ' ', 'v', 'a', 'l', 'i', 'd',
                           ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c',
                           'y', ' ', 't', 'u', 'p', 'l', 'e', ' ', 'f', 'o',
                           'r', ' '] .
                         shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                           [' ', '-', '>', ' '] (l, r) .
                           shows_nl . x)))
      b);

dt_transformation ::
  forall a b c.
    (Card_UNIV a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Showa a,
      Ccompare c, Eq c, Mapping_impl c,
      Showa c) => (a -> a) ->
                    Tp_ops_ext b a c () ->
                      Dt_transformation_info a c ->
                        Complexity_measure a c ->
                          Complexity_class ->
                            b -> Sum ([Prelude.Char] -> [Prelude.Char])
                                   (Complexity_measure a c, b);
dt_transformation shp i info cm cc cp =
  catch_errora
    (let {
       (DT_Transformation_Info s_DT_s w_DT_w q) = info;
     } in (case cm of {
            Derivational_Complexity _ ->
              Inl (shows_prec_list zero_nat
                    ['o', 'n', 'l', 'y', ' ', 'r', 'u', 'n', 't', 'i', 'm', 'e',
                      ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                      ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ',
                      'f', 'o', 'r', ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e',
                      'n', 'c', 'y', ' ', 't', 'u', 'p', 'l', 'e', 's']);
            Runtime_Complexity c d ->
              let {
                s = rc i cp;
                w = rwc i cp;
                sa = map fst s_DT_s;
                wa = map fst w_DT_w;
                r = sa ++ wa;
                dd = defined_list r;
                dda = set d;
              } in bindb (catch_errora
                           (forallM
                             (\ lr ->
                               check (any (eq_rule_mod_vars lr) sa)
                                 (shows_prec_list zero_nat
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 'f', 'i', 'n', 'd', ' ', 'D',
                                      'T', ' ', 'f', 'o', 'r', ' ', 's', 't',
                                      'r', 'i', 'c', 't', ' ', 'r', 'u', 'l',
                                      'e', ' '] .
                                   shows_prec_prod zero_nat lr))
                             s)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ lr ->
                                   check (any (eq_rule_mod_vars lr) wa)
                                     (shows_prec_list zero_nat
['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 'D',
  'T', ' ', 'f', 'o', 'r', ' ', 'w', 'e', 'a', 'k', ' ', 'r', 'u', 'l', 'e',
  ' '] .
                                       shows_prec_prod zero_nat lr))
                                 w)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ f ->
                                       check (member f dda)
 (shows_prec_list zero_nat
    ['d', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l',
      ' '] .
   shows_prec_prod zero_nat f .
     shows_prec_list zero_nat
       [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'o', 'c', 'c', 'u',
         'r', ' ', 'i', 'n', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's',
         'y', 'm', 'b', 'o', 'l', 's', ' ', 'f', 'r', 'o', 'm', ' ', 'R', 'C']))
                                     dd)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               let {
                                 dTs = map snd s_DT_s;
                                 dTw = map snd w_DT_w;
                                 da = set dd;
                                 shpf = (\ (f, a) -> (shp f, a));
                                 ds = image shpf da;
                                 ddd = image (shp . fst) da;
                                 f = funas_trs_list r ++ c ++ d;
                                 fs = set f;
                               } in bindb (catch_errora
    (forallM
      (\ qa ->
        check (not (is_Var qa) && not (member (the (root qa)) fs))
          (shows_prec_list zero_nat
             ['n', 'e', 'w', ' ', 'Q', '-', 't', 'e', 'r', 'm', ' '] .
            shows_prec_term zero_nat qa .
              shows_prec_list zero_nat
                [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
      q)
    (\ x -> Inl (snd x)))
                                      (\ _ ->
bindb (check_wf_trs r)
  (\ _ ->
    bindb (catch_errora (check_NF_terms_subset (is_QNFb i cp) (map fst r))
            (\ _ ->
              Inl (shows_prec_list zero_nat
                    ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e',
                      'q', 'u', 'i', 'r', 'e', 'd'])))
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ fa ->
                    check (not (member fa ds))
                      (shows_prec_prod zero_nat fa .
                        shows_prec_list zero_nat
                          [' ', 'a', 's', ' ', 's', 'h', 'a', 'r', 'p', 'e',
                            'd', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ', 'i',
                            's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's',
                            'h']))
                  f)
                (\ x -> Inl (snd x)))
          (\ _ ->
            bindb (check (is_empty (inf_set (set c) da))
                    (shows_prec_list zero_nat
                      ['c', 'o', 'n', 's', 't', 'r', 'u', 'c', 't', 'o', 'r',
                        's', ' ', 'o', 'f', ' ', 'R', 'C', ' ', 'a', 'n', 'd',
                        ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'y',
                        'm', 'b', 'o', 'l', 's', ' ', 'o', 'f', ' ', 'T', 'R',
                        'S', 's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ',
                        'd', 'i', 's', 'j', 'o', 'i', 'n', 't']))
              (\ _ ->
                bindb (catch_errora (forallM (check_rule_dt shp da ddd) s_DT_s)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    bindb (catch_errora
                            (forallM (check_rule_dt shp da ddd) w_DT_w)
                            (\ x -> Inl (snd x)))
                      (\ _ ->
                        Inr (Runtime_Complexity c (map shpf d),
                              mkc i False (qb i cp ++ q) dTs
                                (r ++ dTw))))))))))));
          }))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'w',
               'i', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't', 'o', ' ', 'd', 'e',
               'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 't', 'u', 'p', 'l',
               'e', 's'] .
            shows_nl . x));

shows_mctxt ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Mctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_mctxt fun var MHole = shows_string ['[', ']'];
shows_mctxt fun var (MVar x) = var x;
shows_mctxt fun var (MFun f cs) =
  fun f .
    shows_list_gen id [] ['('] [',', ' '] [')'] (map (shows_mctxt fun var) cs);

shows_prec_mctxt ::
  forall a b.
    (Showa a, Showa b) => Nat -> Mctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_mctxt p c =
  shows_mctxt (shows_prec zero_nat) (shows_prec zero_nat) c;

ground_mctxt :: forall a b. Mctxt a b -> Bool;
ground_mctxt (MVar uu) = False;
ground_mctxt MHole = True;
ground_mctxt (MFun f cs) = all ground_mctxt cs;

funas_mctxt ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Mctxt a b -> Set (a, Nat);
funas_mctxt (MFun f cs) =
  sup_set (inserta (f, size_list cs) bot_set)
    (sup_seta (image funas_mctxt (set cs)));
funas_mctxt (MVar v) = bot_set;
funas_mctxt MHole = bot_set;

is_compound_context ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Set (a, Nat) -> Mctxt a b -> Bool;
is_compound_context cComp c =
  ground_mctxt c && less_eq_set (funas_mctxt c) cComp;

if_Fun_in_set ::
  forall a b. (Ceq a, Ccompare a) => Set (a, Nat) -> Term a b -> Bool;
if_Fun_in_set f = (\ t -> is_Var t || member (the (root t)) f);

uncap_till :: forall a b. (Term a b -> Bool) -> Term a b -> [Term a b];
uncap_till p (Var x) = (if p (Var x) then [Var x] else []);
uncap_till p (Fun f ts) =
  (if p (Fun f ts) then [Fun f ts] else concatMap (uncap_till p) ts);

check_rule_wdp ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showa a, Compare b, Eq b,
      Showa b) => (a -> a) ->
                    Set (a, Nat) ->
                      ((Term a b, Term a b), (Term a b, Term a b)) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_wdp shp cComp =
  (\ (a, b) ->
    let {
      (l, r) = a;
    } in (\ (p, q) ->
           catch_errora
             (let {
                la = sharp_term shp l;
              } in bindb (check (equal_term la p)
                           (shows_string
                              ['w', 'r', 'o', 'n', 'g', ' ', 'l', 'h', 's', ',',
                                ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
                                ' '] .
                             shows_prec_term zero_nat la .
                               shows_string
                                 [' ', 'b', 'u', 't', ' ', 'g', 'o', 't', ' '] .
                                 shows_prec_term zero_nat p))
                     (\ _ ->
                       let {
                         us = uncap_till (if_Fun_in_set (uminus_set cComp)) r;
                         (c, usa) =
                           split_term (if_Fun_in_set (uminus_set cComp)) q;
                       } in bindb (check (map (sharp_term shp) us == usa)
                                    (shows_prec_list zero_nat
                                      ['l', 'i', 's', 't', 's', ' ', 'o', 'f',
' ', 'm', 'a', 'x', 'i', 'm', 'a', 'l', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm',
's', ' ', 'w', 'i', 't', 'h', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'r',
'o', 'o', 't', ' ', 'd', 'i', 'f', 'f', 'e', 'r']))
                              (\ _ ->
                                check (is_compound_context cComp c)
                                  (shows_prec_mctxt zero_nat c .
                                    shows_string
                                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
'a', ' ', 'p', 'r', 'o', 'p', 'e', 'r', ' ', 'c', 'o', 'm', 'p', 'o', 'u', 'n',
'd', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', ' ', 'o', 'f', ' '] .
                                      shows_prec_term zero_nat q))))
             (\ x ->
               Inl (shows_string
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e',
                        'n', 's', 'u', 'r', 'e', ' ', 't', 'h', 'a', 't', ' '] .
                     shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                       [' ', '-', '>', ' '] (p, q) .
                       shows_string
                         [' ', 'i', 's', ' ', 'a', ' ', 'v', 'a', 'l', 'i', 'd',
                           ' ', 'w', 'e', 'a', 'k', ' ', 'd', 'e', 'p', 'e',
                           'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p', 'a', 'i',
                           'r', ' ', 'f', 'o', 'r', ' '] .
                         shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                           [' ', '-', '>', ' '] (l, r) .
                           shows_nl . x)))
      b);

check_wdp_trans ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showa a, Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showa c) => (a -> a) ->
                    Tp_ops_ext b a c () ->
                      Wdp_trans_info a c ->
                        Complexity_measure a c ->
                          Complexity_class ->
                            b -> Sum ([Prelude.Char] -> [Prelude.Char])
                                   (Complexity_measure a c, b);
check_wdp_trans shp i info cm cc cp =
  catch_errora
    (let {
       (WDP_Trans_Info compa s_wdps w_wdps q) = info;
     } in (case cm of {
            Derivational_Complexity _ ->
              Inl (shows_prec_list zero_nat
                    ['o', 'n', 'l', 'y', ' ', 'r', 'u', 'n', 't', 'i', 'm', 'e',
                      ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                      ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ',
                      'f', 'o', 'r', ' ', 'w', 'e', 'a', 'k', ' ', 'd', 'e',
                      'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p', 'a',
                      'i', 'r', 's']);
            Runtime_Complexity c d ->
              let {
                s = rc i cp;
                w = rwc i cp;
                sa = map fst s_wdps;
                wa = map fst w_wdps;
                r = sa ++ wa;
                fs = funas_trs_list r;
                ds = defined_list r;
              } in bindb (catch_errora
                           (forallM
                             (\ ra ->
                               check (any (eq_rule_mod_vars ra) sa)
                                 (shows_prec_list zero_nat
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 'f', 'i', 'n', 'd', ' ', 'w',
                                      'e', 'a', 'k', ' ', 'd', 'e', 'p', 'e',
                                      'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p',
                                      'a', 'i', 'r', ' ', 'f', 'o', 'r', ' ',
                                      's', 't', 'r', 'i', 'c', 't', ' ', 'r',
                                      'u', 'l', 'e', ' '] .
                                   shows_prec_prod zero_nat ra))
                             s)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ ra ->
                                   check (any (eq_rule_mod_vars ra) wa)
                                     (shows_prec_list zero_nat
['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 'w',
  'e', 'a', 'k', ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ',
  'p', 'a', 'i', 'r', ' ', 'f', 'o', 'r', ' ', 'w', 'e', 'a', 'k', ' ', 'r',
  'u', 'l', 'e', ' '] .
                                       shows_prec_prod zero_nat ra))
                                 w)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           let {
                             wDP_S = map snd s_wdps;
                             wDP_W = map snd w_wdps;
                             shpf = (\ (f, a) -> (shp f, a));
                             f = fs ++ c ++ d;
                             f_sharps = map shpf f;
                             _ = image (\ (fa, a) -> (shp fa, a)) (set f);
                             cComp =
                               sup_set
                                 (minus_set
                                   (minus_set (set fs) (set (defined_list r)))
                                   (set d))
                                 compa;
                           } in bindb (catch_errora
(forallM
  (\ qa ->
    check (not (is_Var qa) && not (membera f (the (root qa))))
      (shows_prec_list zero_nat
         ['n', 'e', 'w', ' ', 'Q', '-', 't', 'e', 'r', 'm', ' '] .
        shows_prec_term zero_nat qa .
          shows_prec_list zero_nat
            [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
  q)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    bindb (check_wf_trs r)
                                      (\ _ ->
bindb (catch_errora
        (forallM
          (\ fa ->
            check (not (member fa cComp))
              (shows_prec_prod zero_nat fa .
                shows_prec_list zero_nat
                  [' ', 'c', 'l', 'a', 's', 'h', 'e', 's', ' ', 'w', 'i', 't',
                    'h', ' ', 's', 'h', 'a', 'r', 'p', ' ', 's', 'y', 'm', 'b',
                    'o', 'l', 's']))
          f_sharps)
        (\ x -> Inl (snd x)))
  (\ _ ->
    bindb (catch_errora
            (forallM
              (\ fa ->
                check (not (member fa cComp))
                  (shows_prec_prod zero_nat fa .
                    shows_prec_list zero_nat
                      [' ', 'c', 'l', 'a', 's', 'h', 'e', 's', ' ', 'w', 'i',
                        't', 'h', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ',
                        's', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'o', 'f', ' ',
                        'R', 'C']))
              d)
            (\ x -> Inl (snd x)))
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ fa ->
                    check (not (member fa cComp))
                      (shows_prec_prod zero_nat fa .
                        shows_prec_list zero_nat
                          [' ', 'c', 'l', 'a', 's', 'h', 'e', 's', ' ', 'w',
                            'i', 't', 'h', ' ', 'd', 'e', 'f', 'i', 'n', 'e',
                            'd', ' ', 's', 'y', 'm', 'b', 'o', 'l', 's']))
                  ds)
                (\ x -> Inl (snd x)))
          (\ _ ->
            bindb (catch_errora (forallM (check_rule_wdp shp cComp) s_wdps)
                    (\ x -> Inl (snd x)))
              (\ _ ->
                bindb (catch_errora (forallM (check_rule_wdp shp cComp) w_wdps)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    Inr (Runtime_Complexity c (map shpf d),
                          mkc i (nfsb i cp) (qb i cp ++ q) (wDP_S ++ sa)
                            (wDP_W ++ wa)))))))))));
          }))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'w',
               'i', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't', 'o', ' ', 'w', 'e',
               'a', 'k', ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y',
               ' ', 'p', 'a', 'i', 'r', 's'] .
            shows_nl . x));

equal_boundstype :: Boundstype -> Boundstype -> Bool;
equal_boundstype Roof Match = False;
equal_boundstype Match Roof = False;
equal_boundstype Match Match = True;
equal_boundstype Roof Roof = True;

boundstype :: forall a b. Bounds_info a b -> Boundstype;
boundstype (Bounds_Info x1 x2 x3 x4 x5) = x1;

stackable_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
stackable_of_cm (Derivational_Complexity f) = f;
stackable_of_cm (Runtime_Complexity c d) = c;

bounds_complexity_rel ::
  forall a b c d.
    (Eq b, Key b, Showa b, Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c,
      Eq c, Key c, Set_impl c, Showa c, Card_UNIV d, Cenum d, Ceq d, Ccompare d,
      Compare_order d, Eq d, Set_impl d,
      Showa d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      [(Term b c, Term b c)] ->
                        Complexity_measure b c ->
                          Complexity_class ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
bounds_complexity_rel i info rdelete cm cc tp =
  catch_errora
    (let {
       r = rc i tp;
       rw = rwc i tp;
       r2 = ceta_list_diff r rdelete;
     } in bindb (catch_errora (check_subseteq rdelete (rulesd i tp))
                  (\ x ->
                    Inl (shows_prec_list zero_nat
                           ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                             'f', 'i', 'n', 'd', ' ', 'r', 'u', 'l', 'e', ' '] .
                          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                            [' ', '-', '>', ' '] x .
                            shows_prec_list zero_nat
                              [' ', 'i', 'n', ' ', 'c', 'u', 'r', 'r', 'e', 'n',
                                't', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x',
                                'i', 't', 'y', ' ', 'p', 'r', 'o', 'b', 'l',
                                'e', 'm'])))
            (\ _ ->
              bindb (check (less_eq_complexity_class (Comp_Poly one_nat) cc)
                      (shows_prec_list zero_nat
                        ['c', 'a', 'n', ' ', 'o', 'n', 'l', 'y', ' ', 'e', 'n',
                          's', 'u', 'r', 'e', ' ', 'l', 'i', 'n', 'e', 'a', 'r',
                          ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
                          'y']))
                (\ _ ->
                  bindb (check (equal_boundstype (boundstype info) Match)
                          (shows_prec_list zero_nat
                            ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                              ' ', 'a', 'n', 'a', 'l', 'y', 's', 'i', 's', ' ',
                              'r', 'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'b',
                              'o', 'u', 'n', 'd', 's', 't', 'y', 'p', 'e', ' ',
                              'm', 'a', 't', 'c', 'h']))
                    (\ _ ->
                      let {
                        _ = rulesd i tp;
                      } in bindb (check_bounds_generic info rdelete (rw ++ r2)
                                   (stackable_of_cm cm) (roots_of_cm cm))
                             (\ _ ->
                               Inr (mkc i (nfsb i tp) (qb i tp) r2
                                     (list_union rw rdelete)))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'e', 'n',
               's', 'u', 'r', 'i', 'n', 'g', ' ', 'm', 'a', 't', 'c', 'h', '-',
               'R', 'T', ' ', 'b', 'o', 'u', 'n', 'd', 'e', 'd', 'n', 'e', 's',
               's', ' ', 'o', 'f', ' '] .
            shows_nl .
              shows_tp (shows_prec zero_nat) (shows_prec zero_nat) i tp .
                shows_nl .
                  shows_prec_list zero_nat
                    ['w', 'i', 't', 'h', ' ', 'd', 'e', 'l', 'e', 't', 'i', 'o',
                      'n', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', 's'] .
                    shows_nl .
                      shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                          't', 'e', 'm', ':']
                        [' ', '-', '>', ' '] rdelete .
                        x));

bounds_complexity ::
  forall a b c d.
    (Compare_order b, Eq b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showa c,
      Card_UNIV d, Cenum d, Ceq d, Ccompare d, Compare_order d, Eq d,
      Set_impl d,
      Showa d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      Complexity_measure b c ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_complexity i info cm cc tp =
  catch_errora
    (bindb
      (check (less_eq_complexity_class (Comp_Poly one_nat) cc)
        (shows_prec_list zero_nat
          ['c', 'a', 'n', ' ', 'o', 'n', 'l', 'y', ' ', 'e', 'n', 's', 'u', 'r',
            'e', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'c', 'o', 'm', 'p',
            'l', 'e', 'x', 'i', 't', 'y']))
      (\ _ ->
        bindb (check (equal_boundstype (boundstype info) Match)
                (shows_prec_list zero_nat
                  ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'a',
                    'n', 'a', 'l', 'y', 's', 'i', 's', ' ', 'r', 'e', 'q', 'u',
                    'i', 'r', 'e', 's', ' ', 'b', 'o', 'u', 'n', 'd', 's', 't',
                    'y', 'p', 'e', ' ', 'm', 'a', 't', 'c', 'h']))
          (\ _ ->
            check_bounds_generic info (rulesd i tp) [] (stackable_of_cm cm)
              (roots_of_cm cm))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'e', 'n',
               's', 'u', 'r', 'i', 'n', 'g', ' ', 'm', 'a', 't', 'c', 'h', ' ',
               'b', 'o', 'u', 'n', 'd', 'e', 'd', 'n', 'e', 's', 's', ' ', 'o',
               'f', ' '] .
            shows_nl .
              shows_tp (shows_prec zero_nat) (shows_prec zero_nat) i tp .
                shows_nl . x));

check_assm ::
  forall a b c d.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    ((a, (Complexity_measure (Lab b c) [Prelude.Char],
                           Complexity_class)) ->
                      d -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      Generic_assm_proof b c [Prelude.Char] d () () () () ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assm i cpx_check (Complexity_assm_proof cp prf) =
  cpx_check (mk_cpx i cp) prf;
check_assm i uu (SN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Finite_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (SN_FP_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Not_SN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Infinite_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Not_RelSN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Not_SN_FP_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Unknown_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);

check_complexity_proof ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Bool ->
                      ([Prelude.Char] -> [Prelude.Char]) ->
                        (a, (Complexity_measure (Lab b c) [Prelude.Char],
                              Complexity_class)) ->
                          Complexity_proof b c [Prelude.Char] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_complexity_proof ia assms i (tp, (cm, cc))
  (Rule_Shift_Complexity redp rdelete ur_opt prf) =
  debug (i [])
    ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'C', 'o',
      'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
    (bindb
      (catch_errora
        (smart_rule_shift_complexity ia (get_redtriple redp) rdelete ur_opt cm
          cc tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' ', 's', 'h',
                       'i', 'f', 't', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                       'n', 'i', 'q', 'u', 'e', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ['.', '1'])
            (tpa, (cm, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 's', 'h', 'i', 'f', 't', 'i', 'n', 'g', ' ', 'p',
                         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) RisEmpty_Complexity =
  debug (i [])
    ['R', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'f', 'o', 'r', ' ',
      'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
    (check (null (rc ia tp))
      (i . shows_string
             [':', ' ', 'R', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm',
               'p', 't', 'y', ' ', 'i', 'n', ' '] .
             shows_nl .
               shows_tp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) ia
                 tp));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Remove_Nonapplicable_Rules_Complexity r prf) =
  debug (i [])
    ['R', 'e', 'm', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a', 'p',
      'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']
    (let {
       _ = rc ia tp;
     } in bindb (catch_errora (check_non_applicable_rules (is_QNFb ia tp) r)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'r', 'e', 'm', 'o', 'v',
                                 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a',
                                 'p', 'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e',
                                 ' ', 'r', 'u', 'l', 'e', 's'] .
                               shows_nl .
                                 indent
                                   (shows_rule (shows_prec_lab zero_nat)
                                      (shows_prec_list zero_nat)
                                      [' ', '-', '>', ' '] x .
                                     shows_prec_list zero_nat
                                       [' ', 'i', 's', ' ', 'a', 'p', 'p', 'l',
 'i', 'c', 'a', 'b', 'l', 'e']))))
            (\ _ ->
              let {
                tpa = delete_R_Rwb ia tp r r;
              } in catch_errora
                     (check_complexity_proof ia assms
                       (i . shows_string ['.', '1']) (tpa, (cm, cc)) prf)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                    'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                    'n', 'o', 'n', '-', 'a', 'p', 'p', 'l', 'i',
                                    'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                                    'e', 's', ' ', 'r', 'e', 'm', 'o', 'v', 'a',
                                    'l'] .
                                  shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (Matchbounds_Complexity info) =
  debug (i []) ['M', 'a', 't', 'c', 'h', 'b', 'o', 'u', 'n', 'd', 's']
    (catch_errora (bounds_complexity ia info cm cc tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'm', 'a',
                     't', 'c', 'h', 'b', 'o', 'u', 'n', 'd', 's'] .
                   shows_nl . indent x)));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Matchbounds_Rel_Complexity info rdel prf) =
  debug (i [])
    ['M', 'a', 't', 'c', 'h', 'b', 'o', 'u', 'n', 'd', 's', '-', 'R', 'e', 'l']
    (bindb
      (catch_errora (bounds_complexity_rel ia info rdel cm cc tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'm', 'a',
                       't', 'c', 'h', 'b', 'o', 'u', 'n', 'd', 's'] .
                     shows_nl . indent x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ['.', '1'])
            (tpa, (cm, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g',
                         ' ', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'm',
                         'a', 't', 'c', 'h', 'b', 'o', 'u', 'n', 'd', 's'] .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (DT_Transformation info prf) =
  debug (i [])
    ['D', 'T', ' ', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
      'o', 'n']
    (bindb
      (catch_errora (dt_transformation Sharp ia info cm cc tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'D', 'T', ' ', 't', 'r', 'a', 'n',
                       's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', ' ',
                       'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ (cma, tpa) ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ['.', '1'])
            (tpa, (cma, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'D', 'T', ' ', 't',
                         'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
                         'o', 'n'] .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (WDP_Transformation info prf) =
  debug (i [])
    ['W', 'D', 'P', ' ', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't',
      'i', 'o', 'n']
    (bindb
      (catch_errora (check_wdp_trans Sharp ia info cm cc tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'W', 'D', 'P', ' ', 't', 'r', 'a',
                       'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n',
                       ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ (cma, tpa) ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ['.', '1'])
            (tpa, (cma, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'W', 'D', 'P', ' ',
                         't', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't',
                         'i', 'o', 'n'] .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Usable_Rules_Complexity ur prf) =
  debug (i []) ['U', 's', 'a', 'b', 'l', 'e', ' ', 'R', 'u', 'l', 'e', 's']
    (bindb
      (catch_errora (usable_rules_complexity ia ur cm cc tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                       's'] .
                     shows_nl . indent x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ['.', '1'])
            (tpa, (cm, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g',
                         ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                         'e', 's'] .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (Complexity_Assumption a ass) =
  debug (i [])
    ['C', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n']
    (if assms
      then bindb (catch_errora
                   (check_complexity_subsumes a
                     (qb ia tp, (rc ia tp, (rwc ia tp, (cm, cc)))))
                   (\ x ->
                     Inl (i . shows_prec_list zero_nat
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x',
                                  'i', 't', 'y', ' ', 'a', 's', 's', 'u', 'm',
                                  'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ',
                                  'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                                  'r', 'o', 'o', 'f'] .
                                shows_nl . x)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa j ->
                       check_assm ia
                         (check_complexity_proof ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc j)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (shows_prec_list zero_nat
                 ['t', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'c', 'o',
                   'n', 't', 'a', 'i', 'n', 's', ' ', 'a', 'n', ' ', 'a', 's',
                   's', 'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ',
                   'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o',
                   'f', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'h', 'a', 'v', 'e',
                   ' ', 't', 'o', ' ', 'b', 'e', ' ', 'm', 'a', 'n', 'u', 'a',
                   'l', 'l', 'y', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Split_Complexity info prf1 prf2) =
  debug (i []) ['S', 'p', 'l', 'i', 't']
    (bindb
      (catch_errora (split_proc_complexity ia info tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o', 'c', 'e',
                       's', 's', 'o', 'r'] .
                     shows_nl . indent x)))
      (\ (tp1, tp2) ->
        bindb (catch_errora
                (check_complexity_proof ia assms (i . shows_string ['.', '1'])
                  (tp1, (cm, cc)) prf1)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 'a', 'p', 'p', 'l', 'y', 'i',
                               'n', 'g', ' ', 's', 'p', 'l', 'i', 't', ' ', 'p',
                               'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                             shows_nl . indent x)))
          (\ _ ->
            catch_errora
              (check_complexity_proof ia assms (i . shows_string ['.', '2'])
                (tp2, (cm, cc)) prf2)
              (\ x ->
                Inl (i . shows_string
                           [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                             'l', 'o', 'w', ' ', 'a', 'p', 'p', 'l', 'y', 'i',
                             'n', 'g', ' ', 's', 'p', 'l', 'i', 't', ' ', 'p',
                             'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                           shows_nl . indent x)))));

check_unknown_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Unknown_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_proof ia j a i u prf =
  check_unknown_proof_main ia j a i u (unlab_to_split_unknown prf);

certify_cert_problem ::
  forall a b c d e.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Ac_tp_ops_ext d (Lab b [Nat]) [Prelude.Char] () ->
                        Ac_dpp_ops_ext e (Lab b [Nat]) [Prelude.Char] () ->
                          Bool ->
                            Cert_problem b [Nat] [Prelude.Char] -> Cert_result;
certify_cert_problem i j k l a (TRS_Termination_Proof nfs q r Nothing prf) =
  (case check_trs_termination_proof i j a (shows_string ['1'])
          (mkc i nfs (strategy_to_Q q r) r []) prf
    of {
    Inl err ->
      Error ((shows_string
                ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                  'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c',
                  'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Termination_Proof nfs q r Nothing prf));
  });
certify_cert_problem i j k l a (TRS_Termination_Proof nfs q r (Just s) prf) =
  (case check_trs_termination_proof i j a (shows_string ['1'])
          (mkc i nfs (strategy_to_Q q r) r s) prf
    of {
    Inl err ->
      Error ((shows_string
                ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 't', 'e', 'r',
                  'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o',
                  'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e', 'p',
                  't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Termination_Proof nfs q r (Just s) prf));
  });
certify_cert_problem i j k l a (Complexity_Proof q r s_o cm cc prf) =
  (case check_complexity_proof i a (shows_string ['1'])
          (mkc i True (strategy_to_Q q (r ++ rel_rules_of s_o)) r
             (rel_rules_of s_o),
            (cm, cc))
          prf
    of {
    Inl err ->
      Error ((shows_string
                ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Complexity_Proof q r s_o cm cc prf));
  });
certify_cert_problem i j k l a (TRS_Nontermination_Proof nfs q r prf) =
  (case check_trs_nontermination_proof i j a (shows_string ['1'])
          (mkc i nfs (strategy_to_Q q r) r []) prf
    of {
    Inl err ->
      Error ((shows_string
                ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                  'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't',
                  ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Nontermination_Proof nfs q r prf));
  });
certify_cert_problem i j k l a (Outermost_Nontermination_Proof r prf) =
  (case check_fp_nontermination_proof i j a (shows_string ['1'])
          (o_to_fp_impl (map fst r), r) prf
    of {
    Inl err ->
      Error ((shows_string
                ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 'n', 'o',
                  'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
                  ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a',
                  'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Outermost_Nontermination_Proof r prf));
  });
certify_cert_problem i j k l a (Outermost_Termination_Proof r prf) =
  (case check_fptrs_termination_proof i j a (shows_string ['1'])
          (o_to_fp_impl (map fst r), r) prf
    of {
    Inl err ->
      Error ((shows_string
                ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 't', 'e',
                  'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r',
                  'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e',
                  'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Outermost_Termination_Proof r prf));
  });
certify_cert_problem i j k l a (CS_Nontermination_Proof mu r prf) =
  (case check_fp_nontermination_proof i j a (shows_string ['1'])
          (mu_to_fp_impl mu, r) prf
    of {
    Inl err ->
      Error ((shows_string
                ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 'n', 'o',
                  'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
                  ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a',
                  'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (CS_Nontermination_Proof mu r prf));
  });
certify_cert_problem i j k l a (CS_Termination_Proof mu r prf) =
  (case check_fptrs_termination_proof i j a (shows_string ['1'])
          (mu_to_fp_impl mu, r) prf
    of {
    Inl err ->
      Error ((shows_string
                ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 't', 'e',
                  'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r',
                  'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e',
                  'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (CS_Termination_Proof mu r prf));
  });
certify_cert_problem i j k l a (FP_Termination_Proof p r prf) =
  (case check_fptrs_termination_proof i j a (shows_string ['1']) (p, r) prf of {
    Inl err ->
      Error ((shows_string
                ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a',
                  't', 't', 'e', 'r', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n',
                  'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f', ' ',
                  'n', 'o', 't', ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (FP_Termination_Proof p r prf));
  });
certify_cert_problem i j k l a (FP_Nontermination_Proof p r prf) =
  (case check_fp_nontermination_proof i j a (shows_string ['1']) (p, r) prf of {
    Inl err ->
      Error ((shows_string
                ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a',
                  't', 't', 'e', 'r', 'n', ' ', 'n', 'o', 'n', 't', 'e', 'r',
                  'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o',
                  'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e', 'p',
                  't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (FP_Nontermination_Proof p r prf));
  });
certify_cert_problem i j k l a (Relative_TRS_Nontermination_Proof nfs q r s prf)
  = (case check_reltrs_nontermination_proof i j a (shows_string ['1'])
            (mkc i nfs (strategy_to_Q q r) r s) prf
      of {
      Inl err ->
        Error ((shows_string
                  ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'n', 'o', 'n',
                    't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                    'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c',
                    'c', 'e', 'p', 't', 'e', 'd'] .
                 shows_nl . err)
                []);
      Inr _ ->
        Certified (xml_tag (Relative_TRS_Nontermination_Proof nfs q r s prf));
    });
certify_cert_problem i j k l a (DP_Termination_Proof nfs m p pw q r rw prf) =
  (case check_dp_termination_proof i j a (shows_string ['1'])
          (mkd j nfs m p pw (strategy_to_Q q (r ++ rw)) r rw) prf
    of {
    Inl err ->
      Error ((shows_string
                ['f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (DP_Termination_Proof nfs m p pw q r rw prf));
  });
certify_cert_problem i j k l a (DP_Nontermination_Proof nfs m p q r prf) =
  (case check_dp_nontermination_proof i j a (shows_string ['1'])
          (mkd j nfs m p [] (strategy_to_Q q r) [] r) prf
    of {
    Inl err ->
      Error ((shows_string
                ['i', 'n', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's',
                  ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a',
                  'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (DP_Nontermination_Proof nfs m p q r prf));
  });
certify_cert_problem i j k l a (TRS_Confluence_Proof nfs r prf) =
  (case check_cr_proof a (shows_string ['1']) i j r prf of {
    Inl err ->
      Error ((shows_string
                ['c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Confluence_Proof nfs r prf));
  });
certify_cert_problem i j k l a (TRS_Non_Confluence_Proof nfs r prf) =
  (case check_ncr_proof a (shows_string ['1']) i j r prf of {
    Inl err ->
      Error ((shows_string
                ['c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'd',
                  'i', 's', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ',
                  'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Non_Confluence_Proof nfs r prf));
  });
certify_cert_problem i j k l a (Completion_Proof e r prf) =
  (case check_completion_proof a (shows_string ['1']) i j e r prf of {
    Inl err ->
      Error ((shows_string
                ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Completion_Proof e r prf));
  });
certify_cert_problem i j k l a (Equational_Proof e eq prf) =
  (case check_equational_proof a (shows_string ['1']) i j e eq prf of {
    Inl err ->
      Error ((shows_string
                ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Equational_Proof e eq prf));
  });
certify_cert_problem i j k l a (Equational_Disproof e eq prf) =
  (case check_equational_disproof a (shows_string ['1']) i j e eq prf of {
    Inl err ->
      Error ((shows_string
                ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'd',
                  'i', 's', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ',
                  'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Equational_Disproof e eq prf));
  });
certify_cert_problem i j k l a (Quasi_Reductive_Proof ctrs prf) =
  (case check_quasi_reductive_proof a (shows_string ['1']) i j ctrs prf of {
    Inl err ->
      Error ((shows_string
                ['q', 'u', 'a', 's', 'i', ' ', 'r', 'e', 'd', 'u', 'c', 't',
                  'i', 'v', 'e', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o',
                  't', ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Quasi_Reductive_Proof ctrs prf));
  });
certify_cert_problem i j k l a (Conditional_CR_Proof ctrs prf) =
  (case check_conditional_cr_proof a (shows_string ['1']) i j ctrs prf of {
    Inl err ->
      Error ((shows_string
                ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', ' ',
                  'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Conditional_CR_Proof ctrs prf));
  });
certify_cert_problem i j k l a (Tree_Automata_Closed_Proof ta r prf) =
  (case tree_aut_trs_closed ta prf r of {
    Inl err ->
      Error ((shows_string
                ['t', 'r', 'e', 'e', ' ', 'a', 'u', 't', 'o', 'm', 'a', 't',
                  'o', 'n', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'p', 'r',
                  'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e',
                  'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Tree_Automata_Closed_Proof ta r prf));
  });
certify_cert_problem i j k l aa (AC_Termination_Proof r a c prf) =
  (case check_ac_termination_proof l k (shows_string ['1']) (mke k r a c) prf of
    {
    Inl err ->
      Error ((shows_string
                ['A', 'C', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                  'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't',
                  ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (AC_Termination_Proof r a c prf));
  });
certify_cert_problem i j k l a (Unknown_Proof up prf) =
  (case check_unknown_proof i j a (shows_string ['1']) up prf of {
    Inl err ->
      Error ((shows_string
                ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o',
                  'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e', 'p', 't',
                  'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Unknown_Proof up prf));
  });
certify_cert_problem i j k l a (Unknown_Disproof up prf) =
  (case check_unknown_disproof i j a (shows_string ['1']) up prf of {
    Inl err ->
      Error ((shows_string
                ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o',
                  'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e', 'p', 't',
                  'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Unknown_Disproof up prf));
  });

find_ctxt_len ::
  [Prelude.Char] ->
    [Prelude.Char] -> Nat -> Maybe ([Prelude.Char], [Prelude.Char]);
find_ctxt_len [] ys n = Nothing;
find_ctxt_len (v : va) ys n =
  (if take n (v : va) == ys then Just ([], drop n (v : va))
    else bind (find_ctxt_len (tla (v : va)) ys n)
           (\ (us, vs) -> Just (hda (v : va) : us, vs)));

extract_input_proof ::
  [Prelude.Char] -> Maybe ([Prelude.Char], ([Prelude.Char], [Prelude.Char]));
extract_input_proof s =
  bind (find_ctxt_len
         (filter (\ c -> not (membera [' ', '\n', '\t', '\r'] c)) s)
         ['<', 'i', 'n', 'p', 'u', 't', '>']
         (size_list ['<', 'i', 'n', 'p', 'u', 't', '>']))
    (\ (_, minput) ->
      bind (find_ctxt_len minput ['<', '/', 'i', 'n', 'p', 'u', 't', '>']
             (size_list ['<', '/', 'i', 'n', 'p', 'u', 't', '>']))
        (\ (input, sa) ->
          bind (find_ctxt_len sa ['<', 'p', 'r', 'o', 'o', 'f', '>']
                 (size_list ['<', 'p', 'r', 'o', 'o', 'f', '>']))
            (\ (version, proof) -> Just (input, (version, proof)))));

eval_list_haskell :: forall a. [a] -> Sum_bot [Prelude.Char] [a];
eval_list_haskell (x : xs) =
  binda (eval_list_haskell xs) (\ ys -> returna (x : ys));
eval_list_haskell [] = returna [];

xmldoc2cert_problem ::
  Xmldoc ->
    Sum_bot [Prelude.Char] (Cert_problem [Prelude.Char] [Nat] [Prelude.Char]);
xmldoc2cert_problem (XMLDOC header xml) =
  debug ['0']
    ['p', 'a', 'r', 's', 'i', 'n', 'g', ' ', 'x', 'm', 'l', ' ', 't', 'o', ' ',
      'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'p',
      'r', 'o', 'b', 'l', 'e', 'm']
    (xml2cert_problem (text ['n', 'a', 'm', 'e']) plain_name xml);

parse_cert_problem ::
  [Prelude.Char] ->
    Sum_bot [Prelude.Char] (Cert_problem [Prelude.Char] [Nat] [Prelude.Char]);
parse_cert_problem s = (case doc_of_stringa s of {
                         Inl a -> errora a;
                         Inr a -> xmldoc2cert_problem a;
                       });

eq_white_space :: [Prelude.Char] -> [Prelude.Char] -> Bool;
eq_white_space s1 s2 =
  debug ['0']
    ['c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'w', 'h', 'e', 't', 'h',
      'e', 'r', ' ', 'p', 'a', 'r', 's', 'e', 'd', ' ', 'i', 'n', 'p', 'u', 't',
      ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd', 's', ' ', 't', 'o',
      ' ', 'r', 'e', 'a', 'l', ' ', 'i', 'n', 'p', 'u', 't']
    (filter (\ c -> not (membera [' ', '\n', '\t', '\r'] c)) s1 == s2);

certify_proof :: Bool -> [Prelude.Char] -> Sum_bot [Prelude.Char] Cert_result;
certify_proof a s =
  catch_error
    (case extract_input_proof s of {
      Nothing ->
        returna
          (Unsupported
            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't',
              'r', 'a', 'c', 't', ' ', 'i', 'n', 'p', 'u', 't', ' ', 'a', 'n',
              'd', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'f', 'r', 'o', 'm', ' ',
              'g', 'i', 'v', 'e', 'n', ' ', 's', 't', 'r', 'i', 'n', 'g']);
      Just (the_input, (_, the_proof)) ->
        binda (eval_list_haskell (take max_tag (trim the_proof)))
          (\ short_prf ->
            binda (parse_cert_problem s)
              (\ cp ->
                returna
                  (if eq_white_space
                        (shows_prec_xml zero_nat (xml_cert_problem cp) [])
                        the_input
                    then (case certify_cert_problem tp_rbt_impl dpp_rbt_impl
                                 ac_tp_list_impl ac_dpp_rbt_impl a cp
                           of {
                           Certified tag ->
                             (if starts_with short_prf tag then Certified tag
                               else Error (['p', 'r', 'o', 'v', 'e', 'n', ' ',
     'p', 'r', 'o', 'p', 'e', 'r', 't', 'y', ' '] ++
    tag ++
      [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
        'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 'p', 'r', 'o', 'o',
        'f', ' ', 'i', 'n', ' ', 'i', 'n', 'p', 'u', 't', ' ', 's', 't', 'r',
        'i', 'n', 'g', ':', ' '] ++
        short_prf));
                           Unsupported aa -> Unsupported aa;
                           Error aa -> Error aa;
                         })
                    else Unsupported
                           (concat
                             [['p', 'a', 'r', 's', 'e', 'd', ' ', 'p', 'r', 'o',
                                'b', 'l', 'e', 'm', ' ', 'd', 'o', 'e', 's',
                                ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o',
                                ' ', 'i', 'n', 'p', 'u', 't'],
                               ['\n'], ['i', 'n', 'p', 'u', 't', ':'], ['\n'],
                               filter
                                 (\ c ->
                                   not (membera [' ', '\n', '\t', '\r'] c))
                                 the_input,
                               ['\n'], ['\n'],
                               ['p', 'a', 'r', 's', 'e', 'd', ':'], ['\n'],
                               filter
                                 (\ c ->
                                   not (membera [' ', '\n', '\t', '\r'] c))
                                 (shows_prec_xml zero_nat (xml_cert_problem cp)
                                   []),
                               ['\n']]))));
    })
    (\ err ->
      returna
        (Unsupported
          (['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i', 'l', 'e', ' ', 'p',
             'a', 'r', 's', 'i', 'n', 'g'] ++
            ['\n'] ++ err)));

}
