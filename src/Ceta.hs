{-# LANGUAGE EmptyDataDecls, RankNTypes, ScopedTypeVariables #-}

module
  Ceta(Num, Nat, nat_of_integer, Term, Sum(..), Lab, Xml, Xml_error, Claim(..),
        Input, Sum_bot(..), Proof, Cert_result(..), Tp, Dpp, Ac_dpp, Tp_ops_ext,
        Dpp_ops_ext, Ac_tp_ops_ext, Ac_dpp_ops_ext, version, certify_proof)
  where {

import Prelude ((==), (/=), (<), (<=), (>=), (>), (+), (-), (*), (/), (**),
  (>>=), (>>), (=<<), (&&), (||), (^), (^^), (.), ($), ($!), (++), (!!), Eq,
  error, id, return, not, fst, snd, map, filter, concat, concatMap, reverse,
  zip, null, takeWhile, dropWhile, all, any, Integer, negate, abs, divMod,
  String, Bool(True, False), Maybe(Nothing, Just));
import qualified Prelude;
import qualified Uint;
import qualified Array;
import qualified IArray;
import qualified Uint32;
import qualified Data_Bits;

newtype Int = Int_of_integer Integer;

integer_of_int :: Int -> Integer;
integer_of_int (Int_of_integer k) = k;

times_int :: Int -> Int -> Int;
times_int k l = Int_of_integer (integer_of_int k * integer_of_int l);

zero_int :: Int;
zero_int = Int_of_integer (0 :: Integer);

data Num = One | Bit0 Num | Bit1 Num;

one_int :: Int;
one_int = Int_of_integer (1 :: Integer);

class Times a where {
  times :: a -> a -> a;
};

apsnd :: forall a b c. (a -> b) -> (c, a) -> (c, b);
apsnd f (x, y) = (x, f y);

divmod_integer :: Integer -> Integer -> (Integer, Integer);
divmod_integer k l =
  (if k == (0 :: Integer) then ((0 :: Integer), (0 :: Integer))
    else (if (0 :: Integer) < l
           then (if (0 :: Integer) < k then divMod ( k ) ( l )
                  else let {
                         (r, s) = divMod ( (negate k) ) ( l );
                       } in (if s == (0 :: Integer)
                              then (negate r, (0 :: Integer))
                              else (negate r - (1 :: Integer), l - s)))
           else (if l == (0 :: Integer) then ((0 :: Integer), k)
                  else apsnd negate
                         (if k < (0 :: Integer)
                           then divMod ( (negate k) ) ( (negate l) )
                           else let {
                                  (r, s) = divMod ( k ) ( (negate l) );
                                } in (if s == (0 :: Integer)
                                       then (negate r, (0 :: Integer))
                                       else (negate r - (1 :: Integer),
      negate l - s))))));

divide_integer :: Integer -> Integer -> Integer;
divide_integer k l = fst (divmod_integer k l);

lcm_integer :: Integer -> Integer -> Integer;
lcm_integer a b =
  divide_integer (Prelude.abs a * Prelude.abs b) (Prelude.gcd a b);

lcm_inta :: Int -> Int -> Int;
lcm_inta (Int_of_integer x) (Int_of_integer y) =
  Int_of_integer (lcm_integer x y);

gcd_inta :: Int -> Int -> Int;
gcd_inta (Int_of_integer x) (Int_of_integer y) =
  Int_of_integer (Prelude.gcd x y);

data Color = R | B;

data Rbta a b = Emptya | Branch Color (Rbta a b) a b (Rbta a b);

data Ordera = Eqa | Lt | Gt;

class Ccompare a where {
  ccompare :: Maybe (a -> a -> Ordera);
};

newtype Mapping_rbt b a = Mapping_RBTa (Rbta b a);

class Ceq a where {
  ceq :: Maybe (a -> a -> Bool);
};

newtype Set_dlist a = Abs_dlist [a];

data Set a = Collect_set (a -> Bool) | DList_set (Set_dlist a)
  | RBT_set (Mapping_rbt a ()) | Set_Monad [a] | Complement (Set a);

lcm_int :: Set Int -> Int;
lcm_int = dummy_Lcm;

dummy_Lcm :: Set Int -> Int;
dummy_Lcm x =
  (error :: forall a. String -> (() -> a) -> a) "Lcm on int" (\ _ -> lcm_int x);

gcd_int :: Set Int -> Int;
gcd_int = dummy_Gcd;

dummy_Gcd :: Set Int -> Int;
dummy_Gcd x =
  (error :: forall a. String -> (() -> a) -> a) "Gcd on int" (\ _ -> gcd_int x);

class Zero a where {
  zerob :: a;
};

class One a where {
  onea :: a;
};

class (Times a) => Dvd a where {
};

class (One a, Zero a, Dvd a) => Gcda a where {
  gcda :: a -> a -> a;
  lcma :: a -> a -> a;
};

class (Gcda a) => Gcd a where {
  gcd :: Set a -> a;
  lcm :: Set a -> a;
};

instance Zero Int where {
  zerob = zero_int;
};

instance One Int where {
  onea = one_int;
};

instance Times Int where {
  times = times_int;
};

instance Dvd Int where {
};

instance Gcda Int where {
  gcda = gcd_inta;
  lcma = lcm_inta;
};

instance Gcd Int where {
  gcd = gcd_int;
  lcm = lcm_int;
};

equal_int :: Int -> Int -> Bool;
equal_int k l = integer_of_int k == integer_of_int l;

instance Eq Int where {
  a == b = equal_int a b;
};

uminus_int :: Int -> Int;
uminus_int k = Int_of_integer (negate (integer_of_int k));

modulo_integer :: Integer -> Integer -> Integer;
modulo_integer k l = snd (divmod_integer k l);

newtype Nat = Nat Integer;

integer_of_nat :: Nat -> Integer;
integer_of_nat (Nat x) = x;

modulo_nat :: Nat -> Nat -> Nat;
modulo_nat m n = Nat (modulo_integer (integer_of_nat m) (integer_of_nat n));

divide_nat :: Nat -> Nat -> Nat;
divide_nat m n = Nat (divide_integer (integer_of_nat m) (integer_of_nat n));

equal_nat :: Nat -> Nat -> Bool;
equal_nat m n = integer_of_nat m == integer_of_nat n;

class Ord a where {
  less_eq :: a -> a -> Bool;
  less :: a -> a -> Bool;
};

max :: forall a. (Ord a) => a -> a -> a;
max a b = (if less_eq a b then b else a);

instance Ord Integer where {
  less_eq = (\ a b -> a <= b);
  less = (\ a b -> a < b);
};

nat_of_integer :: Integer -> Nat;
nat_of_integer k = Nat (max (0 :: Integer) k);

zero_nat :: Nat;
zero_nat = Nat (0 :: Integer);

one_nat :: Nat;
one_nat = Nat (1 :: Integer);

string_of_digit :: Nat -> [Prelude.Char];
string_of_digit n =
  (if equal_nat n zero_nat then ['0']
    else (if equal_nat n one_nat then ['1']
           else (if equal_nat n (nat_of_integer (2 :: Integer)) then ['2']
                  else (if equal_nat n (nat_of_integer (3 :: Integer))
                         then ['3']
                         else (if equal_nat n (nat_of_integer (4 :: Integer))
                                then ['4']
                                else (if equal_nat n
   (nat_of_integer (5 :: Integer))
                                       then ['5']
                                       else (if equal_nat n
          (nat_of_integer (6 :: Integer))
      then ['6']
      else (if equal_nat n (nat_of_integer (7 :: Integer)) then ['7']
             else (if equal_nat n (nat_of_integer (8 :: Integer)) then ['8']
                    else ['9'])))))))));

less_nat :: Nat -> Nat -> Bool;
less_nat m n = integer_of_nat m < integer_of_nat n;

shows_string :: [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
shows_string = (\ a b -> a ++ b);

showsp_nat :: Nat -> Nat -> [Prelude.Char] -> [Prelude.Char];
showsp_nat p n =
  (if less_nat n (nat_of_integer (10 :: Integer))
    then shows_string (string_of_digit n)
    else showsp_nat p (divide_nat n (nat_of_integer (10 :: Integer))) .
           shows_string
             (string_of_digit (modulo_nat n (nat_of_integer (10 :: Integer)))));

less_int :: Int -> Int -> Bool;
less_int k l = integer_of_int k < integer_of_int l;

nat :: Int -> Nat;
nat k = Nat (max (0 :: Integer) (integer_of_int k));

showsp_int :: Nat -> Int -> [Prelude.Char] -> [Prelude.Char];
showsp_int p i =
  (if less_int i zero_int
    then shows_string ['-'] . showsp_nat p (nat (uminus_int i))
    else showsp_nat p (nat i));

shows_prec_int :: Nat -> Int -> [Prelude.Char] -> [Prelude.Char];
shows_prec_int = showsp_int;

shows_sep ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ([Prelude.Char] -> [Prelude.Char]) ->
        [a] -> [Prelude.Char] -> [Prelude.Char];
shows_sep s sep [] = shows_string [];
shows_sep s sep [x] = s x;
shows_sep s sep (x : v : va) = (s x . sep) . shows_sep s sep (v : va);

shows_list_gen ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      [Prelude.Char] ->
        [Prelude.Char] ->
          [Prelude.Char] ->
            [Prelude.Char] -> [a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_gen showsx e l s r xs =
  (if null xs then shows_string e
    else (shows_string l . shows_sep showsx (shows_string s) xs) .
           shows_string r);

showsp_list ::
  forall a.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      Nat -> [a] -> [Prelude.Char] -> [Prelude.Char];
showsp_list s p xs =
  shows_list_gen (s zero_nat) ['[', ']'] ['['] [',', ' '] [']'] xs;

shows_list_int :: [Int] -> [Prelude.Char] -> [Prelude.Char];
shows_list_int = showsp_list shows_prec_int zero_nat;

class Showa a where {
  shows_prec :: Nat -> a -> [Prelude.Char] -> [Prelude.Char];
  shows_list :: [a] -> [Prelude.Char] -> [Prelude.Char];
};

instance Showa Int where {
  shows_prec = shows_prec_int;
  shows_list = shows_list_int;
};

abs_int :: Int -> Int;
abs_int i = (if less_int i zero_int then uminus_int i else i);

class Abs a where {
  absa :: a -> a;
};

instance Abs Int where {
  absa = abs_int;
};

sgn_int :: Int -> Int;
sgn_int i =
  (if equal_int i zero_int then zero_int
    else (if less_int zero_int i then Int_of_integer (1 :: Integer)
           else uminus_int (Int_of_integer (1 :: Integer))));

class Sgn a where {
  sgn :: a -> a;
};

instance Sgn Int where {
  sgn = sgn_int;
};

minus_int :: Int -> Int -> Int;
minus_int k l = Int_of_integer (integer_of_int k - integer_of_int l);

plus_int :: Int -> Int -> Int;
plus_int k l = Int_of_integer (integer_of_int k + integer_of_int l);

class Uminus a where {
  uminus :: a -> a;
};

class Minus a where {
  minus :: a -> a -> a;
};

class Plus a where {
  plus :: a -> a -> a;
};

class (Plus a) => Semigroup_add a where {
};

class (Semigroup_add a) => Cancel_semigroup_add a where {
};

class (Semigroup_add a) => Ab_semigroup_add a where {
};

class (Ab_semigroup_add a, Cancel_semigroup_add a,
        Minus a) => Cancel_ab_semigroup_add a where {
};

class (Semigroup_add a, Zero a) => Monoid_add a where {
};

class (Ab_semigroup_add a, Monoid_add a) => Comm_monoid_add a where {
};

class (Cancel_ab_semigroup_add a,
        Comm_monoid_add a) => Cancel_comm_monoid_add a where {
};

class (Times a, Zero a) => Mult_zero a where {
};

class (Times a) => Semigroup_mult a where {
};

class (Ab_semigroup_add a, Semigroup_mult a) => Semiring a where {
};

class (Comm_monoid_add a, Mult_zero a, Semiring a) => Semiring_0 a where {
};

class (Cancel_comm_monoid_add a, Semiring_0 a) => Semiring_0_cancel a where {
};

class (Semigroup_mult a) => Ab_semigroup_mult a where {
};

class (Ab_semigroup_mult a, Semiring a) => Comm_semiring a where {
};

class (Comm_semiring a, Semiring_0 a) => Comm_semiring_0 a where {
};

class (Comm_semiring_0 a,
        Semiring_0_cancel a) => Comm_semiring_0_cancel a where {
};

class (One a, Times a) => Power a where {
};

class (Semigroup_mult a, Power a) => Monoid_mult a where {
};

class (One a, Semigroup_add a) => Numeral a where {
};

class (Monoid_mult a, Numeral a, Semiring a) => Semiring_numeral a where {
};

class (One a, Zero a) => Zero_neq_one a where {
};

class (Semiring_numeral a, Semiring_0 a, Zero_neq_one a) => Semiring_1 a where {
};

class (Semiring_0_cancel a, Semiring_1 a) => Semiring_1_cancel a where {
};

class (Ab_semigroup_mult a, Monoid_mult a, Dvd a) => Comm_monoid_mult a where {
};

class (Comm_monoid_mult a, Comm_semiring_0 a,
        Semiring_1 a) => Comm_semiring_1 a where {
};

class (Comm_semiring_0_cancel a, Comm_semiring_1 a,
        Semiring_1_cancel a) => Comm_semiring_1_cancel a where {
};

class (Comm_semiring_1_cancel a) => Comm_semiring_1_cancel_crossproduct a where {
};

class (Semiring_0 a) => Semiring_no_zero_divisors a where {
};

class (Semiring_1 a,
        Semiring_no_zero_divisors a) => Semiring_1_no_zero_divisors a where {
};

class (Semiring_no_zero_divisors a) => Semiring_no_zero_divisors_cancel a where {
};

class (Cancel_semigroup_add a, Minus a, Monoid_add a,
        Uminus a) => Group_add a where {
};

class (Cancel_comm_monoid_add a, Group_add a) => Ab_group_add a where {
};

class (Ab_group_add a, Semiring_0_cancel a) => Ring a where {
};

class (Ring a,
        Semiring_no_zero_divisors_cancel a) => Ring_no_zero_divisors a where {
};

class (Group_add a, Numeral a) => Neg_numeral a where {
};

class (Neg_numeral a, Ring a, Semiring_1_cancel a) => Ring_1 a where {
};

class (Ring_1 a, Ring_no_zero_divisors a,
        Semiring_1_no_zero_divisors a) => Ring_1_no_zero_divisors a where {
};

class (Comm_semiring_0_cancel a, Ring a) => Comm_ring a where {
};

class (Comm_ring a, Comm_semiring_1_cancel a, Ring_1 a) => Comm_ring_1 a where {
};

class (Comm_semiring_1_cancel a,
        Semiring_1_no_zero_divisors a) => Semidom a where {
};

class (Comm_ring_1 a, Ring_1_no_zero_divisors a, Semidom a,
        Comm_semiring_1_cancel_crossproduct a) => Idom a where {
};

instance Plus Int where {
  plus = plus_int;
};

instance Semigroup_add Int where {
};

instance Cancel_semigroup_add Int where {
};

instance Ab_semigroup_add Int where {
};

instance Minus Int where {
  minus = minus_int;
};

instance Cancel_ab_semigroup_add Int where {
};

instance Monoid_add Int where {
};

instance Comm_monoid_add Int where {
};

instance Cancel_comm_monoid_add Int where {
};

instance Mult_zero Int where {
};

instance Semigroup_mult Int where {
};

instance Semiring Int where {
};

instance Semiring_0 Int where {
};

instance Semiring_0_cancel Int where {
};

instance Ab_semigroup_mult Int where {
};

instance Comm_semiring Int where {
};

instance Comm_semiring_0 Int where {
};

instance Comm_semiring_0_cancel Int where {
};

instance Power Int where {
};

instance Monoid_mult Int where {
};

instance Numeral Int where {
};

instance Semiring_numeral Int where {
};

instance Zero_neq_one Int where {
};

instance Semiring_1 Int where {
};

instance Semiring_1_cancel Int where {
};

instance Comm_monoid_mult Int where {
};

instance Comm_semiring_1 Int where {
};

instance Comm_semiring_1_cancel Int where {
};

instance Comm_semiring_1_cancel_crossproduct Int where {
};

instance Semiring_no_zero_divisors Int where {
};

instance Semiring_1_no_zero_divisors Int where {
};

instance Semiring_no_zero_divisors_cancel Int where {
};

instance Uminus Int where {
  uminus = uminus_int;
};

instance Group_add Int where {
};

instance Ab_group_add Int where {
};

instance Ring Int where {
};

instance Ring_no_zero_divisors Int where {
};

instance Neg_numeral Int where {
};

instance Ring_1 Int where {
};

instance Ring_1_no_zero_divisors Int where {
};

instance Comm_ring Int where {
};

instance Comm_ring_1 Int where {
};

instance Semidom Int where {
};

instance Idom Int where {
};

unit_factor_int :: Int -> Int;
unit_factor_int = sgn_int;

normalize_int :: Int -> Int;
normalize_int = abs_int;

class Divide a where {
  divide :: a -> a -> a;
};

class (Divide a, Semidom a,
        Semiring_no_zero_divisors_cancel a) => Semidom_divide a where {
};

class (Semidom_divide a) => Algebraic_semidom a where {
};

class (Algebraic_semidom a) => Normalization_semidom a where {
  normalizeb :: a -> a;
  unit_factor :: a -> a;
};

divide_int :: Int -> Int -> Int;
divide_int k l =
  Int_of_integer (divide_integer (integer_of_int k) (integer_of_int l));

class (Gcda a, Normalization_semidom a) => Semiring_gcd a where {
};

class (Semiring_gcd a, Comm_ring_1 a) => Ring_gcd a where {
};

instance Divide Int where {
  divide = divide_int;
};

instance Semidom_divide Int where {
};

instance Algebraic_semidom Int where {
};

instance Normalization_semidom Int where {
  normalizeb = normalize_int;
  unit_factor = unit_factor_int;
};

instance Semiring_gcd Int where {
};

instance Ring_gcd Int where {
};

less_eq_int :: Int -> Int -> Bool;
less_eq_int k l = integer_of_int k <= integer_of_int l;

class (Abs a, Minus a, Uminus a, Zero a, Ord a) => Abs_if a where {
};

instance Ord Int where {
  less_eq = less_eq_int;
  less = less_int;
};

instance Abs_if Int where {
};

modulo_int :: Int -> Int -> Int;
modulo_int k l =
  Int_of_integer (modulo_integer (integer_of_int k) (integer_of_int l));

class (Divide a, Dvd a) => Modulo a where {
  modulo :: a -> a -> a;
};

instance Modulo Int where {
  modulo = modulo_int;
};

class (Semiring_1 a) => Semiring_char_0 a where {
};

class (Semiring_char_0 a, Ring_1 a) => Ring_char_0 a where {
};

instance Semiring_char_0 Int where {
};

instance Ring_char_0 Int where {
};

class (Ord a) => Quasi_order a where {
};

class (Quasi_order a) => Weak_order a where {
};

class (Ord a) => Preorder a where {
};

class (Preorder a, Weak_order a) => Order a where {
};

instance Quasi_order Int where {
};

instance Weak_order Int where {
};

instance Preorder Int where {
};

instance Order Int where {
};

class (Gcd a, Semiring_gcd a) => Semiring_Gcd a where {
};

instance Semiring_Gcd Int where {
};

ceq_int :: Maybe (Int -> Int -> Bool);
ceq_int = Just equal_int;

instance Ceq Int where {
  ceq = ceq_int;
};

class (Idom a, Semidom_divide a) => Idom_divide a where {
};

instance Idom_divide Int where {
};

newtype Phantom a b = Phantom b;

data Set_impla = Set_Choose | Set_Collect | Set_DList | Set_RBT | Set_Monada;

set_impl_int :: Phantom Int Set_impla;
set_impl_int = Phantom Set_RBT;

class Set_impl a where {
  set_impl :: Phantom a Set_impla;
};

instance Set_impl Int where {
  set_impl = set_impl_int;
};

class (Order a) => Linorder a where {
};

instance Linorder Int where {
};

class (Abs a, Sgn a, Idom a) => Idom_abs_sgn a where {
};

instance Idom_abs_sgn Int where {
};

class (Ab_semigroup_add a, Order a) => Ordered_ab_semigroup_add a where {
};

class (Ordered_ab_semigroup_add a) => Strict_ordered_ab_semigroup_add a where {
};

class (Cancel_ab_semigroup_add a,
        Strict_ordered_ab_semigroup_add a) => Ordered_cancel_ab_semigroup_add a where {
};

class (Comm_monoid_add a,
        Ordered_ab_semigroup_add a) => Ordered_comm_monoid_add a where {
};

class (Ordered_comm_monoid_add a, Semiring a) => Ordered_semiring a where {
};

class (Ordered_semiring a, Semiring_0 a) => Ordered_semiring_0 a where {
};

class (Ordered_cancel_ab_semigroup_add a, Ordered_semiring_0 a,
        Semiring_0_cancel a) => Ordered_cancel_semiring a where {
};

class (Ordered_cancel_ab_semigroup_add a) => Ordered_ab_semigroup_add_imp_le a where {
};

class (Comm_monoid_add a,
        Strict_ordered_ab_semigroup_add a) => Strict_ordered_comm_monoid_add a where {
};

class (Ordered_cancel_ab_semigroup_add a, Ordered_comm_monoid_add a,
        Strict_ordered_comm_monoid_add a) => Ordered_cancel_comm_monoid_add a where {
};

class (Cancel_comm_monoid_add a, Ordered_ab_semigroup_add_imp_le a,
        Ordered_cancel_comm_monoid_add a) => Ordered_ab_semigroup_monoid_add_imp_le a where {
};

class (Ab_group_add a,
        Ordered_ab_semigroup_monoid_add_imp_le a) => Ordered_ab_group_add a where {
};

class (Ordered_ab_group_add a, Ordered_cancel_semiring a,
        Ring a) => Ordered_ring a where {
};

instance Ordered_ab_semigroup_add Int where {
};

instance Strict_ordered_ab_semigroup_add Int where {
};

instance Ordered_cancel_ab_semigroup_add Int where {
};

instance Ordered_comm_monoid_add Int where {
};

instance Ordered_semiring Int where {
};

instance Ordered_semiring_0 Int where {
};

instance Ordered_cancel_semiring Int where {
};

instance Ordered_ab_semigroup_add_imp_le Int where {
};

instance Strict_ordered_comm_monoid_add Int where {
};

instance Ordered_cancel_comm_monoid_add Int where {
};

instance Ordered_ab_semigroup_monoid_add_imp_le Int where {
};

instance Ordered_ab_group_add Int where {
};

instance Ordered_ring Int where {
};

class (One a, Zero a, Order a) => Zero_less_one a where {
};

instance Zero_less_one Int where {
};

class (Comm_semiring_1_cancel a, Modulo a) => Semiring_modulo a where {
};

class (Algebraic_semidom a, Semiring_modulo a) => Semiring_div a where {
};

instance Semiring_modulo Int where {
};

instance Semiring_div Int where {
};

cEnum_int :: Maybe ([Int], ((Int -> Bool) -> Bool, (Int -> Bool) -> Bool));
cEnum_int = Nothing;

class Cenum a where {
  cEnum :: Maybe ([a], ((a -> Bool) -> Bool, (a -> Bool) -> Bool));
};

instance Cenum Int where {
  cEnum = cEnum_int;
};

class (Ordered_ab_semigroup_add a,
        Linorder a) => Linordered_ab_semigroup_add a where {
};

class (Linordered_ab_semigroup_add a,
        Ordered_ab_semigroup_add_imp_le a) => Linordered_cancel_ab_semigroup_add a where {
};

class (Linordered_cancel_ab_semigroup_add a,
        Ordered_ab_semigroup_monoid_add_imp_le a,
        Ordered_cancel_semiring a) => Linordered_semiring a where {
};

class (Linordered_semiring a) => Linordered_semiring_strict a where {
};

class (Linordered_semiring a, Semiring_1 a) => Linordered_semiring_1 a where {
};

class (Linordered_semiring_1 a,
        Linordered_semiring_strict a) => Linordered_semiring_1_strict a where {
};

class (Abs a, Ordered_ab_group_add a) => Ordered_ab_group_add_abs a where {
};

class (Linordered_cancel_ab_semigroup_add a,
        Ordered_ab_group_add a) => Linordered_ab_group_add a where {
};

class (Linordered_ab_group_add a, Ordered_ab_group_add_abs a, Abs_if a,
        Linordered_semiring a, Ordered_ring a) => Linordered_ring a where {
};

class (Linordered_ring a, Linordered_semiring_strict a,
        Ring_no_zero_divisors a) => Linordered_ring_strict a where {
};

class (Comm_semiring_0 a, Ordered_semiring a) => Ordered_comm_semiring a where {
};

class (Comm_semiring_0_cancel a, Ordered_cancel_semiring a,
        Ordered_comm_semiring a) => Ordered_cancel_comm_semiring a where {
};

class (Linordered_semiring_strict a,
        Ordered_cancel_comm_semiring a) => Linordered_comm_semiring_strict a where {
};

class (Linorder a, Comm_semiring_1 a, Ordered_comm_semiring a,
        Zero_less_one a) => Linordered_nonzero_semiring a where {
};

class (Semiring_char_0 a, Linordered_comm_semiring_strict a,
        Linordered_nonzero_semiring a,
        Semidom a) => Linordered_semidom a where {
};

class (Comm_ring a, Ordered_cancel_comm_semiring a,
        Ordered_ring a) => Ordered_comm_ring a where {
};

class (Ordered_ab_group_add_abs a, Ordered_ring a) => Ordered_ring_abs a where {
};

class (Ring_char_0 a, Idom_abs_sgn a, Linordered_ring_strict a,
        Linordered_semidom a, Linordered_semiring_1_strict a,
        Ordered_comm_ring a, Ordered_ring_abs a) => Linordered_idom a where {
};

instance Linordered_ab_semigroup_add Int where {
};

instance Linordered_cancel_ab_semigroup_add Int where {
};

instance Linordered_semiring Int where {
};

instance Linordered_semiring_strict Int where {
};

instance Linordered_semiring_1 Int where {
};

instance Linordered_semiring_1_strict Int where {
};

instance Ordered_ab_group_add_abs Int where {
};

instance Linordered_ab_group_add Int where {
};

instance Linordered_ring Int where {
};

instance Linordered_ring_strict Int where {
};

instance Ordered_comm_semiring Int where {
};

instance Ordered_cancel_comm_semiring Int where {
};

instance Linordered_comm_semiring_strict Int where {
};

instance Linordered_nonzero_semiring Int where {
};

instance Linordered_semidom Int where {
};

instance Ordered_comm_ring Int where {
};

instance Ordered_ring_abs Int where {
};

instance Linordered_idom Int where {
};

class (Ord a) => Non_strict_order a where {
};

class (Ab_semigroup_add a, Monoid_add a,
        Non_strict_order a) => Ordered_ab_semigroup a where {
};

class (Semiring_0 a, Ordered_ab_semigroup a) => Ordered_semiring_0a a where {
};

class (Semiring_1 a, Ordered_semiring_0a a) => Ordered_semiring_1 a where {
};

class (Comm_semiring_1 a, Ordered_semiring_1 a) => Poly_carrier a where {
};

instance Non_strict_order Int where {
};

instance Ordered_ab_semigroup Int where {
};

instance Ordered_semiring_0a Int where {
};

instance Ordered_semiring_1 Int where {
};

instance Poly_carrier Int where {
};

comparator_of :: forall a. (Eq a, Linorder a) => a -> a -> Ordera;
comparator_of x y = (if less x y then Lt else (if x == y then Eqa else Gt));

compare_int :: Int -> Int -> Ordera;
compare_int = comparator_of;

ccompare_int :: Maybe (Int -> Int -> Ordera);
ccompare_int = Just compare_int;

instance Ccompare Int where {
  ccompare = ccompare_int;
};

numeral :: forall a. (Numeral a) => Num -> a;
numeral (Bit1 n) = let {
                     m = numeral n;
                   } in plus (plus m m) onea;
numeral (Bit0 n) = let {
                     m = numeral n;
                   } in plus m m;
numeral One = onea;

of_inta :: forall a. (Ring_1 a) => Int -> a;
of_inta k =
  (if equal_int k zero_int then zerob
    else (if less_int k zero_int then uminus (of_inta (uminus_int k))
           else let {
                  l = times (numeral (Bit0 One))
                        (of_inta
                          (divide_int k (Int_of_integer (2 :: Integer))));
                  j = modulo_int k (Int_of_integer (2 :: Integer));
                } in (if equal_int j zero_int then l else plus l onea)));

newtype Rat = Frct (Int, Int);

data Root_info = Root_Info (Rat -> Rat -> Nat) (Rat -> Nat);

newtype Poly a = Poly [a];

newtype Real_alg_intern = Abs_real_alg_intern
  (Maybe (Root_info, (Poly Rat, (Rat, Rat))));

data Real_alg_dt = Rationala Rat | Irrational Real_alg_intern;

newtype Real_alg_dtc = Abs_real_alg_dtc Real_alg_dt;

newtype Real_alg = Abstr_real_alg Real_alg_dtc;

newtype Real = Real_of Real_alg;

rep_real_alg_dtc :: Real_alg_dtc -> Real_alg_dt;
rep_real_alg_dtc (Abs_real_alg_dtc x) = x;

rep_real_alg_intern ::
  Real_alg_intern -> Maybe (Root_info, (Poly Rat, (Rat, Rat)));
rep_real_alg_intern (Abs_real_alg_intern x) = x;

quotient_of :: Rat -> (Int, Int);
quotient_of (Frct x) = x;

equal_rat :: Rat -> Rat -> Bool;
equal_rat a b = quotient_of a == quotient_of b;

zero_rat :: Rat;
zero_rat = Frct (zero_int, Int_of_integer (1 :: Integer));

sgn_rat :: Rat -> Rat;
sgn_rat p = Frct (sgn_int (fst (quotient_of p)), Int_of_integer (1 :: Integer));

coeffs :: forall a. (Zero a) => Poly a -> [a];
coeffs (Poly x) = x;

foldr :: forall a b. (a -> b -> b) -> [a] -> b -> b;
foldr f [] = id;
foldr f (x : xs) = f x . foldr f xs;

fold_coeffs :: forall a b. (Zero a) => (a -> b -> b) -> Poly a -> b -> b;
fold_coeffs f p = foldr f (coeffs p);

polya :: forall a. (Comm_semiring_0 a) => Poly a -> a -> a;
polya p = fold_coeffs (\ a f x -> plus a (times x (f x))) p (\ _ -> zerob);

normalize :: (Int, Int) -> (Int, Int);
normalize p =
  (if less_int zero_int (snd p)
    then let {
           a = gcd_inta (fst p) (snd p);
         } in (divide_int (fst p) a, divide_int (snd p) a)
    else (if equal_int (snd p) zero_int
           then (zero_int, Int_of_integer (1 :: Integer))
           else let {
                  a = uminus_int (gcd_inta (fst p) (snd p));
                } in (divide_int (fst p) a, divide_int (snd p) a)));

times_rat :: Rat -> Rat -> Rat;
times_rat p q = Frct (let {
                        a = quotient_of p;
                        (aa, c) = a;
                        b = quotient_of q;
                        (ba, d) = b;
                      } in normalize (times_int aa ba, times_int c d));

plus_rat :: Rat -> Rat -> Rat;
plus_rat p q =
  Frct (let {
          a = quotient_of p;
          (aa, c) = a;
          b = quotient_of q;
          (ba, d) = b;
        } in normalize
               (plus_int (times_int aa d) (times_int ba c), times_int c d));

instance Times Rat where {
  times = times_rat;
};

instance Semigroup_mult Rat where {
};

instance Ab_semigroup_mult Rat where {
};

instance Plus Rat where {
  plus = plus_rat;
};

instance Semigroup_add Rat where {
};

instance Ab_semigroup_add Rat where {
};

instance Semiring Rat where {
};

instance Comm_semiring Rat where {
};

instance Zero Rat where {
  zerob = zero_rat;
};

instance Monoid_add Rat where {
};

instance Comm_monoid_add Rat where {
};

instance Mult_zero Rat where {
};

instance Semiring_0 Rat where {
};

instance Comm_semiring_0 Rat where {
};

le_rat_in_interval :: Poly Rat -> Rat -> Rat -> Bool;
le_rat_in_interval p y r =
  let {
    ri = polya p y;
  } in equal_rat ri zero_rat ||
         not (equal_rat (sgn_rat ri) (sgn_rat (polya p r)));

divide_rat :: Rat -> Rat -> Rat;
divide_rat p q = Frct (let {
                         a = quotient_of p;
                         (aa, c) = a;
                         b = quotient_of q;
                         (ba, d) = b;
                       } in normalize (times_int aa d, times_int c ba));

of_int :: Int -> Rat;
of_int a = Frct (a, Int_of_integer (1 :: Integer));

tighten_poly_bounds :: Poly Rat -> Rat -> Rat -> (Rat, Rat);
tighten_poly_bounds p l r =
  let {
    m = divide_rat (plus_rat l r) (of_int (Int_of_integer (2 :: Integer)));
  } in (if le_rat_in_interval p m r then (m, r) else (l, m));

less_eq_rat :: Rat -> Rat -> Bool;
less_eq_rat p q = let {
                    a = quotient_of p;
                    (aa, c) = a;
                    b = quotient_of q;
                    (ba, d) = b;
                  } in less_eq_int (times_int aa d) (times_int c ba);

minus_rat :: Rat -> Rat -> Rat;
minus_rat p q =
  Frct (let {
          a = quotient_of p;
          (aa, c) = a;
          b = quotient_of q;
          (ba, d) = b;
        } in normalize
               (minus_int (times_int aa d) (times_int ba c), times_int c d));

tighten_poly_bounds_epsilon :: Poly Rat -> Rat -> Rat -> Rat -> (Rat, Rat);
tighten_poly_bounds_epsilon p x l r =
  (if less_eq_rat (minus_rat r l) x then (l, r)
    else let {
           (a, b) = tighten_poly_bounds p l r;
         } in tighten_poly_bounds_epsilon p x a b);

less_rat :: Rat -> Rat -> Bool;
less_rat p q = let {
                 a = quotient_of p;
                 (aa, c) = a;
                 b = quotient_of q;
                 (ba, d) = b;
               } in less_int (times_int aa d) (times_int c ba);

tighten_poly_bounds_for_x :: Poly Rat -> Rat -> Rat -> Rat -> (Rat, Rat);
tighten_poly_bounds_for_x p x l r =
  (if less_rat x l || less_rat r x then (l, r)
    else let {
           (a, b) = tighten_poly_bounds p l r;
         } in tighten_poly_bounds_for_x p x a b);

floor_rat :: Rat -> Int;
floor_rat p = let {
                a = quotient_of p;
                (aa, b) = a;
              } in divide_int aa b;

rai_normalize_bounds_flat ::
  Rat ->
    (Root_info, (Poly Rat, (Rat, Rat))) -> (Root_info, (Poly Rat, (Rat, Rat)));
rai_normalize_bounds_flat eps rai =
  let {
    (ri, (p, (l, r))) = rai;
    (la, ra) = tighten_poly_bounds_epsilon p eps l r;
    fr = of_int (floor_rat ra);
  } in (if less_eq_rat la fr && equal_rat (polya p fr) zero_rat
         then (ri, (p, (fr, fr)))
         else let {
                (lb, rb) = tighten_poly_bounds_for_x p fr la ra;
              } in (ri, (p, (lb, rb))));

inverse_rat :: Rat -> Rat;
inverse_rat p =
  Frct (let {
          a = quotient_of p;
          (aa, b) = a;
        } in (if equal_int aa zero_int
               then (zero_int, Int_of_integer (1 :: Integer))
               else (times_int (sgn_int aa) b, abs_int aa)));

real_alg_precision :: Rat;
real_alg_precision = inverse_rat (of_int (Int_of_integer (8 :: Integer)));

map_option :: forall a b. (a -> b) -> Maybe a -> Maybe b;
map_option f Nothing = Nothing;
map_option f (Just x2) = Just (f x2);

rai_normalize_bounds ::
  Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat)));
rai_normalize_bounds =
  map_option (rai_normalize_bounds_flat real_alg_precision);

normalize_bounds_rai :: Real_alg_intern -> Real_alg_intern;
normalize_bounds_rai xa =
  Abs_real_alg_intern (rai_normalize_bounds (rep_real_alg_intern xa));

zero_polya :: forall a. (Zero a) => Poly a;
zero_polya = Poly [];

uminus_rat :: Rat -> Rat;
uminus_rat p = Frct (let {
                       a = quotient_of p;
                       (aa, b) = a;
                     } in (uminus_int aa, b));

one_rat :: Rat;
one_rat = Frct (Int_of_integer (1 :: Integer), Int_of_integer (1 :: Integer));

cCons :: forall a. (Zero a, Eq a) => a -> [a] -> [a];
cCons x xs = (if null xs && x == zerob then [] else x : xs);

pCons :: forall a. (Zero a, Eq a) => a -> Poly a -> Poly a;
pCons a p = Poly (cCons a (coeffs p));

instance Eq Rat where {
  a == b = equal_rat a b;
};

poly_rat :: Rat -> Poly Rat;
poly_rat x = pCons (uminus_rat x) (pCons one_rat zero_polya);

poly_of_rai :: Maybe (Root_info, (Poly Rat, (Rat, Rat))) -> Poly Rat;
poly_of_rai rai = (case rai of {
                    Nothing -> poly_rat zero_rat;
                    Just (_, (p, (_, _))) -> p;
                  });

poly_rai :: Real_alg_intern -> Poly Rat;
poly_rai xa = poly_of_rai (rep_real_alg_intern xa);

plus_nat :: Nat -> Nat -> Nat;
plus_nat m n = Nat (integer_of_nat m + integer_of_nat n);

suc :: Nat -> Nat;
suc n = plus_nat n one_nat;

gen_length :: forall a. Nat -> [a] -> Nat;
gen_length n (x : xs) = gen_length (suc n) xs;
gen_length n [] = n;

size_list :: forall a. [a] -> Nat;
size_list = gen_length zero_nat;

minus_nat :: Nat -> Nat -> Nat;
minus_nat m n = Nat (max (0 :: Integer) (integer_of_nat m - integer_of_nat n));

degreea :: forall a. (Zero a) => Poly a -> Nat;
degreea p = minus_nat (size_list (coeffs p)) one_nat;

real_alg_dt :: Real_alg_intern -> Real_alg_dt;
real_alg_dt rai =
  let {
    raia = normalize_bounds_rai rai;
    p = poly_rai raia;
  } in (if equal_nat (degreea p) one_nat
         then Rationala (uminus_rat (case coeffs p of {
                                      [] -> zero_rat;
                                      x : _ -> x;
                                    }))
         else Irrational raia);

poly_rat_root_info :: Rat -> Root_info;
poly_rat_root_info x =
  Root_Info
    (\ a b ->
      (if less_eq_rat a x && less_eq_rat x b then one_nat else zero_nat))
    (\ a -> (if less_eq_rat x a then one_nat else zero_nat));

of_rat_rai_fun :: Rat -> Maybe (Root_info, (Poly Rat, (Rat, Rat)));
of_rat_rai_fun =
  (\ x ->
    (if equal_rat x zero_rat then Nothing
      else Just (poly_rat_root_info x, (poly_rat x, (x, x)))));

of_rat_rai :: Rat -> Real_alg_intern;
of_rat_rai xa = Abs_real_alg_intern (of_rat_rai_fun xa);

rai_of_radt :: Real_alg_dt -> Real_alg_intern;
rai_of_radt (Rationala r) = of_rat_rai r;
rai_of_radt (Irrational rai) = rai;

plus_coeffs :: forall a. (Comm_monoid_add a, Eq a) => [a] -> [a] -> [a];
plus_coeffs xs [] = xs;
plus_coeffs [] (v : va) = v : va;
plus_coeffs (x : xs) (y : ys) = cCons (plus x y) (plus_coeffs xs ys);

plus_poly :: forall a. (Comm_monoid_add a, Eq a) => Poly a -> Poly a -> Poly a;
plus_poly p q = Poly (plus_coeffs (coeffs p) (coeffs q));

smult ::
  forall a.
    (Eq a, Comm_semiring_0 a,
      Semiring_no_zero_divisors a) => a -> Poly a -> Poly a;
smult a p = Poly (if a == zerob then [] else map (times a) (coeffs p));

times_poly ::
  forall a.
    (Eq a, Comm_semiring_0 a,
      Semiring_no_zero_divisors a) => Poly a -> Poly a -> Poly a;
times_poly p q =
  fold_coeffs (\ a pa -> plus_poly (smult a q) (pCons zerob pa)) p zero_polya;

pcompose ::
  forall a.
    (Eq a, Comm_semiring_0 a,
      Semiring_no_zero_divisors a) => Poly a -> Poly a -> Poly a;
pcompose p q =
  fold_coeffs (\ a c -> plus_poly (pCons a zero_polya) (times_poly q c)) p
    zero_polya;

class (Divide a) => Inverse a where {
  inverse :: a -> a;
};

class (Inverse a, Ring_1_no_zero_divisors a) => Division_ring a where {
};

class (Division_ring a, Idom_divide a) => Field a where {
};

class (Field a, Ring_char_0 a) => Field_char_0 a where {
};

poly_uminus :: forall a. (Field_char_0 a, Eq a) => Poly a -> Poly a;
poly_uminus p = pcompose p (pCons zerob (pCons (uminus onea) zero_polya));

nth :: forall a. [a] -> Nat -> a;
nth (x : xs) n =
  (if equal_nat n zero_nat then x else nth xs (minus_nat n one_nat));

nth_default :: forall a. a -> [a] -> Nat -> a;
nth_default dflt xs n = (if less_nat n (size_list xs) then nth xs n else dflt);

coeff :: forall a. (Zero a) => Poly a -> Nat -> a;
coeff p = nth_default zerob (coeffs p);

monic_poly :: forall a. (Field a, Eq a) => Poly a -> Poly a;
monic_poly p = let {
                 a = coeff p (degreea p);
               } in (if a == onea then p else smult (inverse a) p);

dvd :: forall a. (Semiring_div a, Eq a) => a -> a -> Bool;
dvd a b = modulo b a == zerob;

times_nat :: Nat -> Nat -> Nat;
times_nat m n = Nat (integer_of_nat m * integer_of_nat n);

instance Plus Nat where {
  plus = plus_nat;
};

instance Semigroup_add Nat where {
};

instance Ab_semigroup_add Nat where {
};

instance Zero Nat where {
  zerob = zero_nat;
};

instance Monoid_add Nat where {
};

instance Comm_monoid_add Nat where {
};

instance Times Nat where {
  times = times_nat;
};

instance Mult_zero Nat where {
};

instance Semigroup_mult Nat where {
};

instance Semiring Nat where {
};

instance Semiring_0 Nat where {
};

instance Semiring_no_zero_divisors Nat where {
};

instance Semiring_no_zero_divisors_cancel Nat where {
};

instance One Nat where {
  onea = one_nat;
};

instance Power Nat where {
};

instance Monoid_mult Nat where {
};

instance Numeral Nat where {
};

instance Semiring_numeral Nat where {
};

instance Zero_neq_one Nat where {
};

instance Semiring_1 Nat where {
};

instance Semiring_1_no_zero_divisors Nat where {
};

instance Cancel_semigroup_add Nat where {
};

instance Minus Nat where {
  minus = minus_nat;
};

instance Cancel_ab_semigroup_add Nat where {
};

instance Cancel_comm_monoid_add Nat where {
};

instance Semiring_0_cancel Nat where {
};

instance Ab_semigroup_mult Nat where {
};

instance Comm_semiring Nat where {
};

instance Comm_semiring_0 Nat where {
};

instance Comm_semiring_0_cancel Nat where {
};

instance Semiring_1_cancel Nat where {
};

instance Dvd Nat where {
};

instance Comm_monoid_mult Nat where {
};

instance Comm_semiring_1 Nat where {
};

instance Comm_semiring_1_cancel Nat where {
};

instance Semidom Nat where {
};

instance Divide Nat where {
  divide = divide_nat;
};

instance Semidom_divide Nat where {
};

instance Algebraic_semidom Nat where {
};

instance Modulo Nat where {
  modulo = modulo_nat;
};

instance Semiring_modulo Nat where {
};

instance Semiring_div Nat where {
};

instance Eq Nat where {
  a == b = equal_nat a b;
};

poly_neg_inf_rat :: Poly Rat -> Rat;
poly_neg_inf_rat p =
  (if dvd (nat_of_integer (2 :: Integer)) (degreea p)
    then sgn_rat (coeff p (degreea p))
    else uminus_rat (sgn_rat (coeff p (degreea p))));

remdups_adj :: forall a. (Eq a) => [a] -> [a];
remdups_adj [] = [];
remdups_adj [x] = [x];
remdups_adj (x : y : xs) =
  (if x == y then remdups_adj (x : xs) else x : remdups_adj (y : xs));

sign_changes_neg_inf_rat :: [Poly Rat] -> Nat;
sign_changes_neg_inf_rat ps =
  minus_nat
    (size_list
      (remdups_adj
        (filter (\ x -> not (equal_rat x zero_rat)) (map poly_neg_inf_rat ps))))
    one_nat;

sign_changes_rat :: [Poly Rat] -> Rat -> Nat;
sign_changes_rat ps x =
  minus_nat
    (size_list
      (remdups_adj
        (filter (\ xa -> not (equal_rat xa zero_rat))
          (map (\ p -> sgn_rat (polya p x)) ps))))
    one_nat;

uminus_poly :: forall a. (Ab_group_add a) => Poly a -> Poly a;
uminus_poly p = Poly (map uminus (coeffs p));

minus_poly_rev_list :: forall a. (Group_add a) => [a] -> [a] -> [a];
minus_poly_rev_list (x : xs) (y : ys) = minus x y : minus_poly_rev_list xs ys;
minus_poly_rev_list xs [] = xs;
minus_poly_rev_list [] (y : ys) = [];

tla :: forall a. [a] -> [a];
tla [] = [];
tla (x21 : x22) = x22;

hda :: forall a. [a] -> a;
hda (x21 : x22) = x21;

mod_poly_one_main_list ::
  forall a. (Eq a, Comm_ring_1 a) => [a] -> [a] -> Nat -> [a];
mod_poly_one_main_list r d n =
  (if equal_nat n zero_nat then r
    else let {
           a = hda r;
           rr = tla (if a == zerob then r
                      else minus_poly_rev_list r (map (times a) d));
         } in mod_poly_one_main_list rr d (minus_nat n one_nat));

strip_while :: forall a. (a -> Bool) -> [a] -> [a];
strip_while p = (reverse . dropWhile p) . reverse;

poly_of_list :: forall a. (Comm_monoid_add a, Eq a) => [a] -> Poly a;
poly_of_list asa = Poly (strip_while (\ a -> zerob == a) asa);

last :: forall a. [a] -> a;
last (x : xs) = (if null xs then x else last xs);

modulo_poly :: forall a. (Field a, Eq a) => Poly a -> Poly a -> Poly a;
modulo_poly f g =
  let {
    cg = coeffs g;
  } in (if null cg then f
         else let {
                cf = coeffs f;
                ilc = inverse (last cg);
                ch = map (times ilc) cg;
                r = mod_poly_one_main_list (reverse cf) (reverse ch)
                      (minus_nat (plus_nat one_nat (size_list cf))
                        (size_list cg));
              } in poly_of_list (reverse r));

instance Cancel_semigroup_add Rat where {
};

instance Minus Rat where {
  minus = minus_rat;
};

instance Cancel_ab_semigroup_add Rat where {
};

instance Cancel_comm_monoid_add Rat where {
};

instance Uminus Rat where {
  uminus = uminus_rat;
};

instance Group_add Rat where {
};

instance Ab_group_add Rat where {
};

instance Semiring_no_zero_divisors Rat where {
};

instance One Rat where {
  onea = one_rat;
};

instance Power Rat where {
};

instance Monoid_mult Rat where {
};

instance Numeral Rat where {
};

instance Semiring_numeral Rat where {
};

instance Zero_neq_one Rat where {
};

instance Semiring_1 Rat where {
};

instance Semiring_1_no_zero_divisors Rat where {
};

instance Semiring_no_zero_divisors_cancel Rat where {
};

instance Semiring_0_cancel Rat where {
};

instance Ring Rat where {
};

instance Ring_no_zero_divisors Rat where {
};

instance Semiring_1_cancel Rat where {
};

instance Neg_numeral Rat where {
};

instance Ring_1 Rat where {
};

instance Ring_1_no_zero_divisors Rat where {
};

instance Divide Rat where {
  divide = divide_rat;
};

instance Inverse Rat where {
  inverse = inverse_rat;
};

instance Division_ring Rat where {
};

instance Comm_semiring_0_cancel Rat where {
};

instance Dvd Rat where {
};

instance Comm_monoid_mult Rat where {
};

instance Comm_semiring_1 Rat where {
};

instance Comm_semiring_1_cancel Rat where {
};

instance Semidom Rat where {
};

instance Semidom_divide Rat where {
};

instance Comm_semiring_1_cancel_crossproduct Rat where {
};

instance Comm_ring Rat where {
};

instance Comm_ring_1 Rat where {
};

instance Idom Rat where {
};

instance Idom_divide Rat where {
};

instance Field Rat where {
};

sturm_aux_rat :: Poly Rat -> Poly Rat -> [Poly Rat];
sturm_aux_rat p q =
  (if equal_nat (degreea q) zero_nat then [p, q]
    else p : sturm_aux_rat q (uminus_poly (modulo_poly p q)));

pderiv_coeffs_code ::
  forall a.
    (Eq a, Comm_semiring_1 a, Semiring_no_zero_divisors a) => a -> [a] -> [a];
pderiv_coeffs_code f (x : xs) =
  cCons (times f x) (pderiv_coeffs_code (plus f onea) xs);
pderiv_coeffs_code f [] = [];

pderiv_coeffs ::
  forall a.
    (Eq a, Comm_semiring_1 a, Semiring_no_zero_divisors a) => [a] -> [a];
pderiv_coeffs xs = pderiv_coeffs_code onea (tla xs);

pderiv ::
  forall a.
    (Eq a, Comm_semiring_1 a, Semiring_no_zero_divisors a) => Poly a -> Poly a;
pderiv p = Poly (pderiv_coeffs (coeffs p));

sturm_rat :: Poly Rat -> [Poly Rat];
sturm_rat p = sturm_aux_rat p (pderiv p);

count_roots_interval_rat :: Poly Rat -> Root_info;
count_roots_interval_rat p =
  let {
    ps = sturm_rat p;
  } in Root_Info
         (\ a b ->
           plus_nat (minus_nat (sign_changes_rat ps a) (sign_changes_rat ps b))
             (if equal_rat (polya p a) zero_rat then one_nat else zero_nat))
         (\ a ->
           minus_nat (sign_changes_neg_inf_rat ps) (sign_changes_rat ps a));

instance Semiring_char_0 Rat where {
};

instance Ring_char_0 Rat where {
};

instance Field_char_0 Rat where {
};

uminus_rai_fun ::
  Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat)));
uminus_rai_fun =
  map_option
    (\ (_, (p, (l, r))) ->
      let {
        pa = monic_poly (poly_uminus p);
      } in (count_roots_interval_rat pa, (pa, (uminus_rat r, uminus_rat l))));

uminus_rai :: Real_alg_intern -> Real_alg_intern;
uminus_rai xa = Abs_real_alg_intern (uminus_rai_fun (rep_real_alg_intern xa));

uminus_radt :: Real_alg_dt -> Real_alg_dt;
uminus_radt (Rationala r) = Rationala (uminus_rat r);
uminus_radt (Irrational v) =
  real_alg_dt (uminus_rai (rai_of_radt (Irrational v)));

uminus_radtc :: Real_alg_dtc -> Real_alg_dtc;
uminus_radtc xa = Abs_real_alg_dtc (uminus_radt (rep_real_alg_dtc xa));

uminus_real_alg :: Real_alg -> Real_alg;
uminus_real_alg (Abstr_real_alg x) = Abstr_real_alg (uminus_radtc x);

uminus_real :: Real -> Real;
uminus_real (Real_of x) = Real_of (uminus_real_alg x);

poly_mult_rat :: Rat -> Poly Rat -> Poly Rat;
poly_mult_rat r p =
  pcompose p (pCons zero_rat (pCons (inverse_rat r) zero_polya));

l_r :: Root_info -> Rat -> Rat -> Nat;
l_r (Root_Info x1 x2) = x1;

mult_rat_rai_fun_pos ::
  Rat ->
    (Root_info, (Poly Rat, (Rat, Rat))) -> (Root_info, (Poly Rat, (Rat, Rat)));
mult_rat_rai_fun_pos r1 (ri2, (p2, (l2, r2))) =
  let {
    p = monic_poly (poly_mult_rat r1 p2);
    ri = count_roots_interval_rat p;
    _ = l_r ri;
    (l, r) = (times_rat l2 r1, times_rat r2 r1);
  } in (ri, (p, (l, r)));

mult_rat_rai_fun ::
  Rat ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
      Maybe (Root_info, (Poly Rat, (Rat, Rat)));
mult_rat_rai_fun x (Just y) =
  (if less_rat x zero_rat
    then uminus_rai_fun (Just (mult_rat_rai_fun_pos (uminus_rat x) y))
    else (if equal_rat x zero_rat then Nothing
           else Just (mult_rat_rai_fun_pos x y)));
mult_rat_rai_fun x Nothing = Nothing;

mult_rat_rai :: Rat -> Real_alg_intern -> Real_alg_intern;
mult_rat_rai xb xc =
  Abs_real_alg_intern (mult_rat_rai_fun xb (rep_real_alg_intern xc));

mult_rat_radt :: Rat -> Real_alg_dt -> Real_alg_dt;
mult_rat_radt x y = real_alg_dt (mult_rat_rai x (rai_of_radt y));

select_correct_factor_main ::
  forall a.
    (a -> a) ->
      (a -> (Rat, Rat)) ->
        a -> [(Poly Rat, Root_info)] ->
               [(Poly Rat, Root_info)] ->
                 Rat -> Rat -> Nat -> ((Poly Rat, Root_info), (Rat, Rat));
select_correct_factor_main bnd_update bnd_get bnd todo old l r n =
  (case todo of {
    [] -> (if equal_nat n one_nat then (hda old, (l, r))
            else let {
                   bnda = bnd_update bnd;
                   (la, ra) = bnd_get bnda;
                 } in select_correct_factor_main bnd_update bnd_get bnda old []
                        la ra zero_nat);
    (p, ri) : todoa ->
      let {
        m = l_r ri l r;
      } in (if equal_nat m zero_nat
             then select_correct_factor_main bnd_update bnd_get bnd todoa old l
                    r n
             else select_correct_factor_main bnd_update bnd_get bnd todoa
                    ((p, ri) : old) l r (plus_nat n m));
  });

select_correct_factor ::
  forall a.
    (a -> a) ->
      (a -> (Rat, Rat)) ->
        a -> [(Poly Rat, Root_info)] -> ((Poly Rat, Root_info), (Rat, Rat));
select_correct_factor bnd_update bnd_get init polys =
  let {
    (l, r) = bnd_get init;
  } in select_correct_factor_main bnd_update bnd_get init polys [] l r zero_nat;

equal_poly :: forall a. (Zero a, Eq a) => Poly a -> Poly a -> Bool;
equal_poly p q = coeffs p == coeffs q;

map_poly :: forall a b. (Zero a, Zero b, Eq b) => (a -> b) -> Poly a -> Poly b;
map_poly f p = fold_coeffs (\ c -> pCons (f c)) p zero_polya;

list_lcm :: forall a. (Semiring_gcd a) => [a] -> a;
list_lcm xs = foldr lcma xs onea;

common_denom :: [Rat] -> (Int, [Int]);
common_denom xs = let {
                    nds = map quotient_of xs;
                    denom = list_lcm (map snd nds);
                    a = map (\ (n, a) -> divide_int (times_int n denom) a) nds;
                  } in (denom, a);

rat_to_int_poly :: Poly Rat -> (Int, Poly Int);
rat_to_int_poly p =
  let {
    ais = coeffs p;
    d = fst (common_denom ais);
  } in (d, map_poly (\ x -> let {
                              (pa, a) = quotient_of x;
                            } in divide_int (times_int pa d) a)
             p);

div_poly :: forall a. (Semiring_div a, Eq a) => a -> Poly a -> Poly a;
div_poly a p = map_poly (\ c -> divide c a) p;

list_gcd :: forall a. (Semiring_gcd a) => [a] -> a;
list_gcd xs = foldr gcda xs zerob;

content :: forall a. (Semiring_gcd a) => Poly a -> a;
content p = list_gcd (coeffs p);

rat_to_normalized_int_poly :: Poly Rat -> (Rat, Poly Int);
rat_to_normalized_int_poly p =
  (if equal_poly p zero_polya then (one_rat, zero_polya)
    else let {
           (s, q) = rat_to_int_poly p;
           c = content q;
         } in (divide_rat (of_int c) (of_int s), div_poly c q));

divide_poly_main_list ::
  forall a. (Eq a, Idom_divide a) => a -> [a] -> [a] -> [a] -> Nat -> [a];
divide_poly_main_list lc q r d n =
  (if equal_nat n zero_nat then q
    else let {
           cr = hda r;
         } in (if cr == zerob
                then divide_poly_main_list lc (cCons cr q) (tla r) d
                       (minus_nat n one_nat)
                else let {
                       a = divide cr lc;
                       qq = cCons a q;
                       rr = minus_poly_rev_list r (map (times a) d);
                     } in (if hda rr == zerob
                            then divide_poly_main_list lc qq (tla rr) d
                                   (minus_nat n one_nat)
                            else [])));

divide_poly_list ::
  forall a. (Eq a, Idom_divide a) => Poly a -> Poly a -> Poly a;
divide_poly_list f g =
  let {
    cg = coeffs g;
  } in (if null cg then g
         else let {
                cf = coeffs f;
                cgr = reverse cg;
              } in poly_of_list
                     (divide_poly_main_list (hda cgr) [] (reverse cf) cgr
                       (minus_nat (plus_nat one_nat (size_list cf))
                         (size_list cg))));

divide_polya :: forall a. (Eq a, Idom_divide a) => Poly a -> Poly a -> Poly a;
divide_polya f g = divide_poly_list f g;

minus_poly :: forall a. (Ab_group_add a, Eq a) => Poly a -> Poly a -> Poly a;
minus_poly p q = plus_poly p (uminus_poly q);

one_polya :: forall a. (Comm_semiring_1 a) => Poly a;
one_polya = Poly [onea];

class (Normalization_semidom a) => Factorial_semiring a where {
};

class (Factorial_semiring a, Semiring_Gcd a) => Factorial_semiring_gcd a where {
};

class (Factorial_semiring_gcd a, Ring_gcd a,
        Idom_divide a) => Factorial_ring_gcd a where {
};

instance (Zero a, Eq a) => Eq (Poly a) where {
  a == b = equal_poly a b;
};

yun_factorization_main ::
  forall a.
    (Factorial_ring_gcd a,
      Eq a) => (Poly a -> Poly a -> Poly a) ->
                 Poly a -> Poly a -> Nat -> [(Poly a, Nat)] -> [(Poly a, Nat)];
yun_factorization_main gcd bn cn i sqr =
  (if bn == one_polya then sqr
    else let {
           dn = minus_poly cn (pderiv bn);
           an = gcd bn dn;
         } in yun_factorization_main gcd (divide_polya bn an)
                (divide_polya dn an) (suc i) ((an, i) : sqr));

yun_monic_factorization ::
  forall a.
    (Factorial_ring_gcd a,
      Eq a) => (Poly a -> Poly a -> Poly a) -> Poly a -> [(Poly a, Nat)];
yun_monic_factorization gcd p =
  let {
    pp = pderiv p;
    u = gcd p pp;
    b0 = divide_polya p u;
    c0 = divide_polya pp u;
  } in filter (\ (a, _) -> not (a == one_polya))
         (yun_factorization_main gcd b0 c0 zero_nat []);

data Arith_ops_record a =
  Arith_Ops_Record a a (a -> a -> a) (a -> a -> a) (a -> a -> a) (a -> a)
    (a -> a -> a) (a -> a) (a -> a -> a) (a -> a) (a -> a) (Int -> a) (a -> Int)
    (a -> Bool);

modulo_uint32 :: Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32;
modulo_uint32 x y = (if y == (0 :: Uint32.Word32) then x else Prelude.mod x y);

mult_p32 :: Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32;
mult_p32 p x y = modulo_uint32 (x * y) p;

power_p32 :: Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32;
power_p32 p x n =
  (if n == (0 :: Uint32.Word32) then (1 :: Uint32.Word32)
    else let {
           rec = power_p32 p (mult_p32 p x x)
                   (Data_Bits.shiftrBounded n (1 :: Integer));
         } in (if n Data_Bits..&. (1 :: Uint32.Word32) == (0 :: Uint32.Word32)
                then rec else mult_p32 p rec x));

inverse_p32 :: Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32;
inverse_p32 p x =
  (if x == (0 :: Uint32.Word32) then (0 :: Uint32.Word32)
    else power_p32 p x
           (p - (Prelude.fromInteger (2 :: Integer) :: Uint32.Word32)));

uminus_p32 :: Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32;
uminus_p32 p x =
  (if x == (0 :: Uint32.Word32) then (0 :: Uint32.Word32) else p - x);

divide_p32 :: Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32;
divide_p32 p x y = mult_p32 p x (inverse_p32 p y);

minus_p32 :: Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32;
minus_p32 p x y = (if y <= x then x - y else x + p - y);

plus_p32 :: Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32 -> Uint32.Word32;
plus_p32 p x y = let {
                   z = x + y;
                 } in (if p <= z then z - p else z);

uint32_of_int :: Int -> Uint32.Word32;
uint32_of_int i = (Prelude.fromInteger (integer_of_int i) :: Uint32.Word32);

int_of_uint32 :: Uint32.Word32 -> Int;
int_of_uint32 x = Int_of_integer (Prelude.toInteger x);

finite_field_ops32 :: Uint32.Word32 -> Arith_ops_record Uint32.Word32;
finite_field_ops32 p =
  Arith_Ops_Record (0 :: Uint32.Word32) (1 :: Uint32.Word32) (plus_p32 p)
    (mult_p32 p) (minus_p32 p) (uminus_p32 p) (divide_p32 p) (inverse_p32 p)
    (\ x y -> (if y == (0 :: Uint32.Word32) then x else (0 :: Uint32.Word32)))
    (\ x ->
      (if x == (0 :: Uint32.Word32) then (0 :: Uint32.Word32)
        else (1 :: Uint32.Word32)))
    (\ x -> x) uint32_of_int int_of_uint32
    (\ x -> (0 :: Uint32.Word32) <= x && x < p);

mod_nonneg_pos_int :: Int -> Int -> Int;
mod_nonneg_pos_int x y =
  Int_of_integer (Prelude.mod ( (integer_of_int x) ) ( (integer_of_int y) ));

mult_p :: Int -> Int -> Int -> Int;
mult_p p x y = mod_nonneg_pos_int (times_int x y) p;

map_prod :: forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d);
map_prod f g (a, b) = (f a, g b);

divmod_nat :: Nat -> Nat -> (Nat, Nat);
divmod_nat m n =
  let {
    k = integer_of_nat m;
    l = integer_of_nat n;
  } in map_prod nat_of_integer nat_of_integer
         (if k == (0 :: Integer) then ((0 :: Integer), (0 :: Integer))
           else (if l == (0 :: Integer) then ((0 :: Integer), k)
                  else divMod ( k ) ( l )));

power_p :: Int -> Int -> Nat -> Int;
power_p p x n =
  (if equal_nat n zero_nat then Int_of_integer (1 :: Integer)
    else let {
           (d, r) = divmod_nat n (nat_of_integer (2 :: Integer));
           rec = power_p p (mult_p p x x) d;
         } in (if equal_nat r zero_nat then rec else mult_p p rec x));

inverse_p :: Int -> Int -> Int;
inverse_p p x =
  (if equal_int x zero_int then zero_int
    else power_p p x (nat (minus_int p (Int_of_integer (2 :: Integer)))));

uminus_p :: Int -> Int -> Int;
uminus_p p x = (if equal_int x zero_int then zero_int else minus_int p x);

divide_p :: Int -> Int -> Int -> Int;
divide_p p x y = mult_p p x (inverse_p p y);

minus_p :: Int -> Int -> Int -> Int;
minus_p p x y =
  (if less_eq_int y x then minus_int x y else minus_int (plus_int x p) y);

plus_p :: Int -> Int -> Int -> Int;
plus_p p x y = let {
                 z = plus_int x y;
               } in (if less_eq_int p z then minus_int z p else z);

finite_field_ops :: Int -> Arith_ops_record Int;
finite_field_ops p =
  Arith_Ops_Record zero_int (Int_of_integer (1 :: Integer)) (plus_p p)
    (mult_p p) (minus_p p) (uminus_p p) (divide_p p) (inverse_p p)
    (\ x y -> (if equal_int y zero_int then x else zero_int))
    (\ x ->
      (if equal_int x zero_int then zero_int
        else Int_of_integer (1 :: Integer)))
    (\ x -> x) (\ x -> x) (\ x -> x)
    (\ x -> less_eq_int zero_int x && less_int x p);

of_intb :: forall a. Arith_ops_record a -> Int -> a;
of_intb (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x12;

of_int_poly_i :: forall a. Arith_ops_record a -> Poly Int -> [a];
of_int_poly_i ops f = map (of_intb ops) (coeffs f);

oneb :: forall a. Arith_ops_record a -> a;
oneb (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x2;

normalizec :: forall a. Arith_ops_record a -> a -> a;
normalizec (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) =
  x10;

moduloa :: forall a. Arith_ops_record a -> a -> a -> a;
moduloa (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x9;

zeroc :: forall a. Arith_ops_record a -> a;
zeroc (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x1;

gcd_eucl_i :: forall a. (Eq a) => Arith_ops_record a -> a -> a -> a;
gcd_eucl_i ops a b =
  (if b == zeroc ops then normalizec ops a
    else gcd_eucl_i ops b (moduloa ops a b));

uminusa :: forall a. Arith_ops_record a -> a -> a;
uminusa (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x6;

unit_factora :: forall a. Arith_ops_record a -> a -> a;
unit_factora (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) =
  x11;

lead_coeff_i :: forall a. Arith_ops_record a -> [a] -> a;
lead_coeff_i ops pp = (case pp of {
                        [] -> zeroc ops;
                        _ : _ -> last pp;
                      });

cCons_i :: forall a. (Eq a) => Arith_ops_record a -> a -> [a] -> [a];
cCons_i ops x xs = (if null xs && x == zeroc ops then [] else x : xs);

unit_factor_poly_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> [a];
unit_factor_poly_i ops xs =
  cCons_i ops (unit_factora ops (lead_coeff_i ops xs)) [];

inversea :: forall a. Arith_ops_record a -> a -> a;
inversea (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x8;

timesa :: forall a. Arith_ops_record a -> a -> a -> a;
timesa (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x4;

smult_i :: forall a. (Eq a) => Arith_ops_record a -> a -> [a] -> [a];
smult_i ops a pp = (if a == zeroc ops then [] else map (timesa ops a) pp);

normalize_poly_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> [a];
normalize_poly_i ops xs =
  smult_i ops (inversea ops (unit_factora ops (lead_coeff_i ops xs))) xs;

minusa :: forall a. Arith_ops_record a -> a -> a -> a;
minusa (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x5;

minus_poly_rev_list_i :: forall a. Arith_ops_record a -> [a] -> [a] -> [a];
minus_poly_rev_list_i ops (x : xs) (y : ys) =
  minusa ops x y : minus_poly_rev_list_i ops xs ys;
minus_poly_rev_list_i ops xs [] = xs;
minus_poly_rev_list_i ops [] (y : ys) = [];

mod_poly_one_main_i ::
  forall a. (Eq a) => Arith_ops_record a -> [a] -> [a] -> Nat -> [a];
mod_poly_one_main_i ops r d n =
  (if equal_nat n zero_nat then r
    else let {
           a = hda r;
           rr = tla (if a == zeroc ops then r
                      else minus_poly_rev_list_i ops r (map (timesa ops a) d));
         } in mod_poly_one_main_i ops rr d (minus_nat n one_nat));

poly_of_list_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> [a];
poly_of_list_i ops = strip_while (\ a -> zeroc ops == a);

mod_field_poly_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> [a] -> [a];
mod_field_poly_i ops cf cg =
  (if null cg then cf
    else let {
           ilc = inversea ops (last cg);
           ch = map (timesa ops ilc) cg;
           r = mod_poly_one_main_i ops (reverse cf) (reverse ch)
                 (minus_nat (plus_nat one_nat (size_list cf)) (size_list cg));
         } in poly_of_list_i ops (reverse r));

divmod_poly_one_main_i ::
  forall a.
    (Eq a) => Arith_ops_record a -> [a] -> [a] -> [a] -> Nat -> ([a], [a]);
divmod_poly_one_main_i ops q r d n =
  (if equal_nat n zero_nat then (q, r)
    else let {
           a = hda r;
           qqq = cCons_i ops a q;
           rr = tla (if a == zeroc ops then r
                      else minus_poly_rev_list_i ops r (map (timesa ops a) d));
         } in divmod_poly_one_main_i ops qqq rr d (minus_nat n one_nat));

div_field_poly_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> [a] -> [a];
div_field_poly_i ops cf cg =
  (if null cg then []
    else let {
           ilc = inversea ops (last cg);
           ch = map (timesa ops ilc) cg;
           q = fst (divmod_poly_one_main_i ops [] (reverse cf) (reverse ch)
                     (minus_nat (plus_nat one_nat (size_list cf))
                       (size_list cg)));
         } in poly_of_list_i ops (map (timesa ops ilc) q));

karatsuba_lower_bound :: Nat;
karatsuba_lower_bound = nat_of_integer (7 :: Integer);

coeffs_minus_i :: forall a. Arith_ops_record a -> [a] -> [a] -> [a];
coeffs_minus_i ops (x : xs) (y : ys) =
  minusa ops x y : coeffs_minus_i ops xs ys;
coeffs_minus_i ops xs [] = xs;
coeffs_minus_i ops [] (v : va) = map (uminusa ops) (v : va);

replicate :: forall a. Nat -> a -> [a];
replicate n x =
  (if equal_nat n zero_nat then [] else x : replicate (minus_nat n one_nat) x);

monom_mult_i :: forall a. Arith_ops_record a -> Nat -> [a] -> [a];
monom_mult_i ops n xs = (if null xs then xs else replicate n (zeroc ops) ++ xs);

minus_poly_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> [a] -> [a];
minus_poly_i ops (x : xs) (y : ys) =
  cCons_i ops (minusa ops x y) (minus_poly_i ops xs ys);
minus_poly_i ops xs [] = xs;
minus_poly_i ops [] (v : va) = map (uminusa ops) (v : va);

plusa :: forall a. Arith_ops_record a -> a -> a -> a;
plusa (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x3;

plus_poly_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> [a] -> [a];
plus_poly_i ops (x : xs) (y : ys) =
  cCons_i ops (plusa ops x y) (plus_poly_i ops xs ys);
plus_poly_i ops xs [] = xs;
plus_poly_i ops [] (v : va) = v : va;

split_at :: forall a. Nat -> [a] -> ([a], [a]);
split_at n (x : xs) =
  (if equal_nat n zero_nat then ([], x : xs)
    else let {
           (bef, a) = split_at (minus_nat n one_nat) xs;
         } in (x : bef, a));
split_at n [] = ([], []);

less_eq_nat :: Nat -> Nat -> Bool;
less_eq_nat m n = integer_of_nat m <= integer_of_nat n;

karatsuba_main_i ::
  forall a. (Eq a) => Arith_ops_record a -> [a] -> Nat -> [a] -> Nat -> [a];
karatsuba_main_i ops f n g m =
  (if less_eq_nat n karatsuba_lower_bound || less_eq_nat m karatsuba_lower_bound
    then let {
           ff = poly_of_list_i ops f;
         } in foldr (\ a p ->
                      plus_poly_i ops (smult_i ops a ff)
                        (cCons_i ops (zeroc ops) p))
                g []
    else let {
           n2 = divide_nat n (nat_of_integer (2 :: Integer));
         } in (if less_nat n2 m
                then let {
                       (f0, f1) = split_at n2 f;
                       (g0, g1) = split_at n2 g;
                       p1 = karatsuba_main_i ops f1 (minus_nat n n2) g1
                              (minus_nat m n2);
                       p2 = karatsuba_main_i ops (coeffs_minus_i ops f1 f0) n2
                              (coeffs_minus_i ops g1 g0) n2;
                       p3 = karatsuba_main_i ops f0 n2 g0 n2;
                     } in plus_poly_i ops (monom_mult_i ops (plus_nat n2 n2) p1)
                            (plus_poly_i ops
                              (monom_mult_i ops n2
                                (plus_poly_i ops (minus_poly_i ops p1 p2) p3))
                              p3)
                else let {
                       (f0, f1) = split_at n2 f;
                       p1 = karatsuba_main_i ops f1 (minus_nat n n2) g m;
                       a = karatsuba_main_i ops f0 n2 g m;
                     } in plus_poly_i ops (monom_mult_i ops n2 p1) a));

times_poly_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> [a] -> [a];
times_poly_i ops f g =
  let {
    n = size_list f;
    m = size_list g;
  } in (if less_eq_nat n karatsuba_lower_bound ||
             less_eq_nat m karatsuba_lower_bound
         then (if less_eq_nat n m
                then foldr (\ a p ->
                             plus_poly_i ops (smult_i ops a g)
                               (cCons_i ops (zeroc ops) p))
                       f []
                else foldr (\ a p ->
                             plus_poly_i ops (smult_i ops a f)
                               (cCons_i ops (zeroc ops) p))
                       g [])
         else (if less_eq_nat n m then karatsuba_main_i ops g m f n
                else karatsuba_main_i ops f n g m));

dp :: forall a. Arith_ops_record a -> a -> Bool;
dp (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x14;

is_poly :: forall a. (Eq a) => Arith_ops_record a -> [a] -> Bool;
is_poly ops xs = all (dp ops) xs && (null xs || not (last xs == zeroc ops));

poly_ops :: forall a. (Eq a) => Arith_ops_record a -> Arith_ops_record [a];
poly_ops ops =
  Arith_Ops_Record [] [oneb ops] (plus_poly_i ops) (times_poly_i ops)
    (minus_poly_i ops) (map (uminusa ops)) (div_field_poly_i ops) (\ _ -> [])
    (mod_field_poly_i ops) (normalize_poly_i ops) (unit_factor_poly_i ops)
    (\ i -> (if equal_int i zero_int then [] else [of_intb ops i]))
    (\ _ -> zero_int) (is_poly ops);

gcd_poly_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> [a] -> [a];
gcd_poly_i ops = gcd_eucl_i (poly_ops ops);

pderiv_main_i :: forall a. (Eq a) => Arith_ops_record a -> a -> [a] -> [a];
pderiv_main_i ops f (x : xs) =
  cCons_i ops (timesa ops f x) (pderiv_main_i ops (plusa ops f (oneb ops)) xs);
pderiv_main_i ops f [] = [];

pderiv_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> [a];
pderiv_i ops xs = pderiv_main_i ops (oneb ops) (tla xs);

square_free_i :: forall a. (Eq a) => Arith_ops_record a -> [a] -> Bool;
square_free_i ops xs = gcd_poly_i ops xs (pderiv_i ops xs) == [oneb ops];

m :: Int -> Int -> Int;
m m x = modulo_int x m;

mp :: Int -> Poly Int -> Poly Int;
mp ma = map_poly (m ma);

square_free_impl_main ::
  forall a. (Eq a) => Int -> Arith_ops_record a -> Poly Int -> Bool;
square_free_impl_main p ff_ops f =
  square_free_i ff_ops (of_int_poly_i ff_ops (mp p f));

square_free_impl :: Int -> Poly Int -> Bool;
square_free_impl p =
  (if less_eq_int p (Int_of_integer (65535 :: Integer))
    then square_free_impl_main p (finite_field_ops32 (uint32_of_int p))
    else square_free_impl_main p (finite_field_ops p));

lead_coeff :: forall a. (Zero a) => Poly a -> a;
lead_coeff f = let {
                 xs = coeffs f;
               } in (case xs of {
                      [] -> zerob;
                      _ : _ -> last xs;
                    });

find :: forall a. (a -> Bool) -> [a] -> Maybe a;
find uu [] = Nothing;
find p (x : xs) = (if p x then Just x else find p xs);

square_free_heuristic :: Poly Int -> Maybe Int;
square_free_heuristic f =
  let {
    lc = lead_coeff f;
  } in find (\ p ->
              equal_int (gcd_inta lc p) (Int_of_integer (1 :: Integer)) &&
                square_free_impl p f)
         [Int_of_integer (2 :: Integer), Int_of_integer (3 :: Integer),
           Int_of_integer (5 :: Integer), Int_of_integer (7 :: Integer),
           Int_of_integer (11 :: Integer), Int_of_integer (13 :: Integer),
           Int_of_integer (17 :: Integer), Int_of_integer (19 :: Integer),
           Int_of_integer (23 :: Integer)];

map_polya :: forall b a. (Zero b, Zero a, Eq a) => (b -> a) -> Poly b -> Poly a;
map_polya f p = Poly (strip_while (\ a -> zerob == a) (map f (coeffs p)));

normalize_poly ::
  forall a. (Eq a, Idom_divide a, Normalization_semidom a) => Poly a -> Poly a;
normalize_poly p = map_polya (\ x -> divide x (unit_factor (lead_coeff p))) p;

coprime_approx_main ::
  forall a. (Eq a) => Int -> Arith_ops_record a -> Poly Int -> Poly Int -> Bool;
coprime_approx_main p ff_ops f g =
  gcd_poly_i ff_ops (of_int_poly_i ff_ops (mp p f))
    (of_int_poly_i ff_ops (mp p g)) ==
    [oneb ff_ops];

gcd_primes :: [Int];
gcd_primes =
  [Int_of_integer (383 :: Integer), Int_of_integer (467 :: Integer),
    Int_of_integer (811 :: Integer), Int_of_integer (983 :: Integer),
    Int_of_integer (997 :: Integer)];

is_none :: forall a. Maybe a -> Bool;
is_none (Just x) = False;
is_none Nothing = True;

coprime_heuristic :: Poly Int -> Poly Int -> Bool;
coprime_heuristic f g =
  let {
    lcf = lead_coeff f;
    lcg = lead_coeff g;
  } in not (is_none
             (find (\ p ->
                     (equal_int (gcd_inta lcf p)
                        (Int_of_integer (1 :: Integer)) ||
                       equal_int (gcd_inta lcg p)
                         (Int_of_integer (1 :: Integer))) &&
                       coprime_approx_main p
                         (finite_field_ops32 (uint32_of_int p)) f g)
               gcd_primes));

foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a;
foldl f a [] = a;
foldl f a (x : xs) = foldl f (f a x) xs;

contenta :: forall a. (Semiring_Gcd a) => Poly a -> a;
contenta p = foldl gcda zerob (coeffs p);

primitive_part ::
  forall a. (Semiring_Gcd a, Eq a, Idom_divide a) => Poly a -> Poly a;
primitive_part p =
  (if (case coeffs p of {
        [] -> True;
        _ : _ -> False;
      })
    then zero_polya else map_polya (\ x -> divide x (contenta p)) p);

pseudo_mod_main_list ::
  forall a. (Eq a, Comm_ring_1 a) => a -> [a] -> [a] -> Nat -> [a];
pseudo_mod_main_list lc r d n =
  (if equal_nat n zero_nat then r
    else let {
           rr = map (times lc) r;
           a = hda r;
           rrr = tla (if a == zerob then rr
                       else minus_poly_rev_list rr (map (times a) d));
         } in pseudo_mod_main_list lc rrr d (minus_nat n one_nat));

pseudo_mod_list :: forall a. (Eq a, Comm_ring_1 a) => [a] -> [a] -> [a];
pseudo_mod_list p q =
  (if null q then p
    else let {
           rq = reverse q;
           a = pseudo_mod_main_list (hda rq) (reverse p) rq
                 (minus_nat (plus_nat one_nat (size_list p)) (size_list q));
         } in reverse a);

pseudo_mod ::
  forall a.
    (Eq a, Comm_ring_1 a,
      Semiring_1_no_zero_divisors a) => Poly a -> Poly a -> Poly a;
pseudo_mod f g = poly_of_list (pseudo_mod_list (coeffs f) (coeffs g));

gcd_poly_code_aux ::
  forall a. (Factorial_ring_gcd a, Eq a) => Poly a -> Poly a -> Poly a;
gcd_poly_code_aux p q =
  (if (case coeffs q of {
        [] -> True;
        _ : _ -> False;
      })
    then normalize_poly p
    else gcd_poly_code_aux q (primitive_part (pseudo_mod p q)));

instance Factorial_semiring Int where {
};

instance Factorial_semiring_gcd Int where {
};

instance Factorial_ring_gcd Int where {
};

gcd_int_polya :: Poly Int -> Poly Int -> Poly Int;
gcd_int_polya f g =
  (if equal_poly f zero_polya then normalize_poly g
    else (if equal_poly g zero_polya then normalize_poly f
           else let {
                  ct = gcd_inta (contenta f) (contenta g);
                  ff = primitive_part f;
                  gg = primitive_part g;
                } in (if coprime_heuristic ff gg then pCons ct zero_polya
                       else smult ct (gcd_poly_code_aux ff gg))));

square_free_factorization_int_main :: Poly Int -> [(Poly Int, Nat)];
square_free_factorization_int_main f =
  (case square_free_heuristic f of {
    Nothing -> yun_monic_factorization gcd_int_polya f;
    Just _ -> [(f, zero_nat)];
  });

square_free_factorization_inta :: Poly Int -> (Int, [(Poly Int, Nat)]);
square_free_factorization_inta f =
  (if equal_nat (degreea f) zero_nat then (lead_coeff f, [])
    else let {
           c = content f;
           d = times_int (sgn_int (lead_coeff f)) c;
           g = div_poly d f;
         } in (d, square_free_factorization_int_main g));

x_split :: forall a. (Eq a, Semiring_0 a) => Poly a -> (Nat, Poly a);
x_split f =
  let {
    fs = coeffs f;
    zs = takeWhile (\ a -> zerob == a) fs;
  } in (case zs of {
         [] -> (zero_nat, f);
         _ : _ ->
           (size_list zs, poly_of_list (dropWhile (\ a -> zerob == a) fs));
       });

monom :: forall a. (Zero a, Eq a) => a -> Nat -> Poly a;
monom a n = Poly (if a == zerob then [] else replicate n zerob ++ [a]);

square_free_factorization_int :: Poly Int -> (Int, [(Poly Int, Nat)]);
square_free_factorization_int f =
  let {
    (n, g) = x_split f;
    (d, fs) = square_free_factorization_inta g;
  } in (if equal_nat n zero_nat then (d, fs)
         else (d, (monom (Int_of_integer (1 :: Integer)) one_nat,
                    minus_nat n one_nat) :
                    fs));

power_poly_f_mod_i ::
  forall a. (Eq a) => Arith_ops_record a -> ([a] -> [a]) -> [a] -> Nat -> [a];
power_poly_f_mod_i ff_ops modulus a n =
  (if equal_nat n zero_nat then modulus [oneb ff_ops]
    else let {
           (d, r) = divmod_nat n (nat_of_integer (2 :: Integer));
           rec = power_poly_f_mod_i ff_ops modulus
                   (modulus (times_poly_i ff_ops a a)) d;
         } in (if equal_nat r zero_nat then rec
                else modulus (times_poly_i ff_ops rec a)));

degree_i :: forall a. [a] -> Nat;
degree_i pp = minus_nat (size_list pp) one_nat;

dist_degree_factorize_main_i ::
  forall a.
    (Eq a) => Int ->
                Arith_ops_record a ->
                  a -> a -> Nat ->
                              [a] -> [a] -> Nat -> [(Nat, [a])] -> [(Nat, [a])];
dist_degree_factorize_main_i p ff_ops ze on dv v w d res =
  (if v == [on] then res
    else (if less_nat dv (plus_nat d d) then (dv, v) : res
           else let {
                  wa = power_poly_f_mod_i ff_ops
                         (\ f -> mod_field_poly_i ff_ops f v) w (nat p);
                  da = suc d;
                  gd = gcd_poly_i ff_ops (minus_poly_i ff_ops wa [ze, on]) v;
                } in (if gd == [on]
                       then dist_degree_factorize_main_i p ff_ops ze on dv v wa
                              da res
                       else let {
                              va = div_field_poly_i ff_ops v gd;
                            } in dist_degree_factorize_main_i p ff_ops ze on
                                   (degree_i va) va
                                   (mod_field_poly_i ff_ops wa va) da
                                   ((da, gd) : res))));

distinct_degree_factorization_i ::
  forall a. (Eq a) => Int -> Arith_ops_record a -> [a] -> [(Nat, [a])];
distinct_degree_factorization_i p ff_ops f =
  let {
    ze = zeroc ff_ops;
    on = oneb ff_ops;
  } in (if equal_nat (degree_i f) one_nat then [(one_nat, f)]
         else dist_degree_factorize_main_i p ff_ops ze on (degree_i f) f
                [ze, on] zero_nat []);

int_of_nat :: Nat -> Int;
int_of_nat n = Int_of_integer (integer_of_nat n);

partition :: forall a. (a -> Bool) -> [a] -> ([a], [a]);
partition p [] = ([], []);
partition p (x : xs) = let {
                         (yes, no) = partition p xs;
                       } in (if p x then (x : yes, no) else (yes, x : no));

upt :: Nat -> Nat -> [Nat];
upt i j = (if less_nat i j then i : upt (suc i) j else []);

berlekamp_factorization_main_i ::
  forall a.
    (Eq a) => Int ->
                Arith_ops_record a ->
                  a -> a -> Nat -> [[a]] -> [[a]] -> Nat -> [[a]];
berlekamp_factorization_main_i p ff_ops ze on d divs (v : vs) n =
  (if v == [on] then berlekamp_factorization_main_i p ff_ops ze on d divs vs n
    else (if equal_nat (size_list divs) n then divs
           else let {
                  of_int = of_intb ff_ops;
                  facts =
                    filter (\ w -> not (w == [on]))
                      (concatMap
                        (\ u ->
                          map (\ s ->
                                gcd_poly_i ff_ops u
                                  (minus_poly_i ff_ops v
                                    (if equal_nat s zero_nat then []
                                      else [of_int (int_of_nat s)])))
                            (upt zero_nat (nat p)))
                        divs);
                  (lin, nonlin) =
                    partition (\ q -> equal_nat (degree_i q) d) facts;
                } in lin ++
                       berlekamp_factorization_main_i p ff_ops ze on d nonlin vs
                         (minus_nat n (size_list lin))));
berlekamp_factorization_main_i p ff_ops ze on d divs [] n = divs;

power_polys_i ::
  forall a. (Eq a) => Arith_ops_record a -> [a] -> [a] -> [a] -> Nat -> [[a]];
power_polys_i ff_ops mul_p u curr_p i =
  (if equal_nat i zero_nat then []
    else curr_p :
           power_polys_i ff_ops mul_p u
             (mod_field_poly_i ff_ops (times_poly_i ff_ops curr_p mul_p) u)
             (minus_nat i one_nat));

newtype X_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option a =
  Abs_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option
  (Maybe (Nat, (Nat, IArray.IArray (IArray.IArray a))));

rep_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option ::
  forall a.
    X_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option a ->
      Maybe (Nat, (Nat, IArray.IArray (IArray.IArray a)));
rep_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option
  (Abs_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option x) =
  x;

newtype Mat_impl a = Abs_mat_impl (Nat, (Nat, IArray.IArray (IArray.IArray a)));

rep_mat_impl ::
  forall a. Mat_impl a -> (Nat, (Nat, IArray.IArray (IArray.IArray a)));
rep_mat_impl (Abs_mat_impl x) = x;

sel21a ::
  forall a.
    X_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option a ->
      Mat_impl a;
sel21a xa =
  Abs_mat_impl
    (case rep_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option
            xa
      of {
      Nothing -> rep_mat_impl (error "undefined");
      Just x2 -> x2;
    });

dis1a ::
  forall a.
    X_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option a ->
      Bool;
dis1a xa =
  (case rep_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option
          xa
    of {
    Nothing -> True;
    Just _ -> False;
  });

rep_isoma ::
  forall a.
    X_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option a ->
      Maybe (Mat_impl a);
rep_isoma x = (if dis1a x then Nothing else Just (sel21a x));

mat_of_rows_list_impl_aux ::
  forall a.
    Nat ->
      [[a]] ->
        X_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option a;
mat_of_rows_list_impl_aux xb xc =
  Abs_x_a_mat_impl_option_x_x_x_a_iarray_iarray_nat_prod_nat_prod_option
    (if all (\ r -> equal_nat (size_list r) xb) xc
      then Just (size_list xc,
                  (xb, IArray.listIArray (map IArray.listIArray xc)))
      else Nothing);

mat_of_rows_list_impl :: forall a. Nat -> [[a]] -> Maybe (Mat_impl a);
mat_of_rows_list_impl x1 x2 = rep_isoma (mat_of_rows_list_impl_aux x1 x2);

newtype Mat a = Mat_impl (Mat_impl a);

newtype Vec_impl a = Abs_vec_impl (Nat, IArray.IArray a);

rep_vec_impl :: forall a. Vec_impl a -> (Nat, IArray.IArray a);
rep_vec_impl (Abs_vec_impl x) = x;

sub :: forall a. IArray.IArray a -> Nat -> a;
sub asa n = IArray.sub (asa, integer_of_nat n);

vec_index_impl :: forall a. Vec_impl a -> Nat -> a;
vec_index_impl xa = let {
                      (_, a) = rep_vec_impl xa;
                    } in sub a;

newtype Vec a = Vec_impl (Vec_impl a);

vec_index :: forall a. Vec a -> Nat -> a;
vec_index (Vec_impl v) i = vec_index_impl v i;

of_fun :: forall a. (Nat -> a) -> Nat -> IArray.IArray a;
of_fun f n =
  (let x = (integer_of_nat n,
             f . nat_of_integer) in (IArray.array (snd x) (fst x)));

mat_of_fun :: forall a. Nat -> Nat -> ((Nat, Nat) -> a) -> Mat_impl a;
mat_of_fun xc xd xe =
  Abs_mat_impl (xc, (xd, of_fun (\ i -> of_fun (\ j -> xe (i, j)) xd) xc));

mat :: forall a. Nat -> Nat -> ((Nat, Nat) -> a) -> Mat a;
mat nr nc f = Mat_impl (mat_of_fun nr nc f);

mat_of_rows :: forall a. Nat -> [Vec a] -> Mat a;
mat_of_rows n rs = mat (size_list rs) n (\ (i, a) -> vec_index (nth rs i) a);

vec_of_fun :: forall a. Nat -> (Nat -> a) -> Vec_impl a;
vec_of_fun xb xc = Abs_vec_impl (xb, of_fun xc xb);

vec :: forall a. Nat -> (Nat -> a) -> Vec a;
vec n f = Vec_impl (vec_of_fun n f);

mat_of_rows_list :: forall a. Nat -> [[a]] -> Mat a;
mat_of_rows_list nc vs =
  (case mat_of_rows_list_impl nc vs of {
    Nothing -> mat_of_rows nc (map (\ v -> vec nc (nth v)) vs);
    Just a -> Mat_impl a;
  });

berlekamp_mat_i ::
  forall a. (Eq a) => Int -> Arith_ops_record a -> [a] -> Mat a;
berlekamp_mat_i p ff_ops u =
  let {
    n = degree_i u;
    ze = zeroc ff_ops;
    on = oneb ff_ops;
    mul_p =
      power_poly_f_mod_i ff_ops (\ v -> mod_field_poly_i ff_ops v u) [ze, on]
        (nat p);
    xks = power_polys_i ff_ops mul_p u [on] n;
  } in mat_of_rows_list n
         (map (\ cs -> cs ++ replicate (minus_nat n (size_list cs)) ze) xks);

eliminate_entries_i2 ::
  forall a.
    (Eq a) => a -> (a -> a -> a) ->
                     (a -> a -> a) ->
                       (Integer -> a) -> Mat_impl a -> Integer -> Mat_impl a;
eliminate_entries_i2 xc xe xg xh xi xj =
  Abs_mat_impl
    (let {
       (nr, a) = rep_mat_impl xi;
       (nc, aa) = a;
     } in (\ i ->
            (nr, (nc, let {
                        ai = (IArray.!) aa i;
                      } in IArray.array
                             (\ ia ->
                               let {
                                 aia = (IArray.!) aa ia;
                               } in (if ia == i then aia
                                      else let {
     vi_j = xh ia;
   } in (if vi_j == xc then aia
          else IArray.array
                 (\ j -> xe ((IArray.!) aia j) (xg vi_j ((IArray.!) ai j)))
                 (integer_of_nat nc))))
                             (integer_of_nat nr))))
      xj);

mat_dim_row_impl :: forall a. Mat_impl a -> Nat;
mat_dim_row_impl xa = fst (rep_mat_impl xa);

eliminate_entries_gen_zero ::
  forall a.
    (Eq a) => (a -> a -> a) ->
                (a -> a -> a) ->
                  a -> (Integer -> a) -> Mat a -> Nat -> Nat -> Mat a;
eliminate_entries_gen_zero mm tt z v (Mat_impl m) i j =
  (if less_nat i (mat_dim_row_impl m)
    then Mat_impl (eliminate_entries_i2 z mm tt v m (integer_of_nat i))
    else (error :: forall a. String -> (() -> a) -> a)
           "index out of range in eliminate_entries"
           (\ _ -> eliminate_entries_gen_zero mm tt z v (Mat_impl m) i j));

eliminate_entries_i ::
  forall a.
    (Eq a) => Arith_ops_record a ->
                (Integer -> a) -> Mat a -> Nat -> Nat -> Mat a;
eliminate_entries_i ops =
  eliminate_entries_gen_zero (minusa ops) (timesa ops) (zeroc ops);

list_update :: forall a. [a] -> Nat -> a -> [a];
list_update [] i y = [];
list_update (x : xs) i y =
  (if equal_nat i zero_nat then y : xs
    else x : list_update xs (minus_nat i one_nat) y);

length :: forall a. IArray.IArray a -> Nat;
length asa = nat_of_integer (IArray.lengthIArray asa);

list_of :: forall a. IArray.IArray a -> [a];
list_of asa = map (sub asa) (upt zero_nat (length asa));

mat_swaprows_impl :: forall a. Nat -> Nat -> Mat_impl a -> Mat_impl a;
mat_swaprows_impl xc xd xe =
  Abs_mat_impl
    (let {
       (nr, a) = rep_mat_impl xe;
       (nc, aa) = a;
     } in (if less_nat xc nr && less_nat xd nr
            then let {
                   ai = sub aa xc;
                   aj = sub aa xd;
                   arows = list_of aa;
                   ab = IArray.listIArray
                          (list_update (list_update arows xc aj) xd ai);
                 } in (nr, (nc, ab))
            else (nr, (nc, aa))));

mat_swaprows :: forall a. Nat -> Nat -> Mat a -> Mat a;
mat_swaprows k l (Mat_impl a) =
  let {
    nr = mat_dim_row_impl a;
  } in (if less_nat l nr && less_nat k nr
         then Mat_impl (mat_swaprows_impl k l a)
         else (error :: forall a. String -> (() -> a) -> a)
                "index out of bounds in mat_swaprows"
                (\ _ -> mat_swaprows k l (Mat_impl a)));

mat_multrow_gen_impl ::
  forall a. (a -> a -> a) -> Nat -> a -> Mat_impl a -> Mat_impl a;
mat_multrow_gen_impl xc xd xe xf =
  Abs_mat_impl (let {
                  (nr, a) = rep_mat_impl xf;
                  (nc, aa) = a;
                  ak = sub aa xd;
                  arows = list_of aa;
                  aka = IArray.listIArray (map (xc xe) (list_of ak));
                  ab = IArray.listIArray (list_update arows xd aka);
                } in (nr, (nc, ab)));

mat_multrow_gen :: forall a. (a -> a -> a) -> Nat -> a -> Mat a -> Mat a;
mat_multrow_gen mul k aa (Mat_impl a) =
  Mat_impl (mat_multrow_gen_impl mul k aa a);

multrow_i :: forall a. Arith_ops_record a -> Nat -> a -> Mat a -> Mat a;
multrow_i ops = mat_multrow_gen (timesa ops);

mat_index_impl :: forall a. Mat_impl a -> (Nat, Nat) -> a;
mat_index_impl xa =
  let {
    (nr, (_, m)) = rep_mat_impl xa;
  } in (\ (i, j) ->
         (if less_nat i nr then sub (sub m i) j
           else sub (IArray.listIArray (nth [] (minus_nat i nr))) j));

mat_index :: forall a. Mat a -> (Nat, Nat) -> a;
mat_index (Mat_impl m) ij = mat_index_impl m ij;

gauss_jordan_main_i ::
  forall a.
    (Eq a) => Arith_ops_record a -> Nat -> Nat -> Mat a -> Nat -> Nat -> Mat a;
gauss_jordan_main_i ops nr nc a i j =
  (if less_nat i nr && less_nat j nc
    then let {
           aij = mat_index a (i, j);
         } in (if aij == zeroc ops
                then (case concatMap
                             (\ ia ->
                               (if not (mat_index a (ia, j) == zeroc ops)
                                 then [ia] else []))
                             (upt (suc i) nr)
                       of {
                       [] -> gauss_jordan_main_i ops nr nc a i (suc j);
                       ia : _ ->
                         gauss_jordan_main_i ops nr nc (mat_swaprows i ia a) i
                           j;
                     })
                else (if aij == oneb ops
                       then let {
                              v = (\ ia -> mat_index a (nat_of_integer ia, j));
                            } in gauss_jordan_main_i ops nr nc
                                   (eliminate_entries_i ops v a i j) (suc i)
                                   (suc j)
                       else let {
                              iaij = inversea ops aij;
                              aa = multrow_i ops i iaij a;
                              v = (\ ia -> mat_index aa (nat_of_integer ia, j));
                            } in gauss_jordan_main_i ops nr nc
                                   (eliminate_entries_i ops v aa i j) (suc i)
                                   (suc j)))
    else a);

mat_dim_row :: forall a. Mat a -> Nat;
mat_dim_row (Mat_impl m) = mat_dim_row_impl m;

mat_dim_col_impl :: forall a. Mat_impl a -> Nat;
mat_dim_col_impl xa = fst (snd (rep_mat_impl xa));

mat_dim_col :: forall a. Mat a -> Nat;
mat_dim_col (Mat_impl m) = mat_dim_col_impl m;

gauss_jordan_single_i ::
  forall a. (Eq a) => Arith_ops_record a -> Mat a -> Mat a;
gauss_jordan_single_i ops a =
  gauss_jordan_main_i ops (mat_dim_row a) (mat_dim_col a) a zero_nat zero_nat;

mat_transpose :: forall a. Mat a -> Mat a;
mat_transpose a =
  mat (mat_dim_col a) (mat_dim_row a) (\ (i, j) -> mat_index a (j, i));

berlekamp_resulting_mat_i ::
  forall a. (Eq a) => Int -> Arith_ops_record a -> [a] -> Mat a;
berlekamp_resulting_mat_i p ff_ops u =
  let {
    q = berlekamp_mat_i p ff_ops u;
    n = mat_dim_row q;
    qi = mat n n
           (\ (i, j) ->
             (if equal_nat i j
               then minusa ff_ops (mat_index q (i, j)) (oneb ff_ops)
               else mat_index q (i, j)));
  } in gauss_jordan_single_i ff_ops (mat_transpose qi);

pivot_positions_main_gen ::
  forall a. (Eq a) => a -> Mat a -> Nat -> Nat -> Nat -> Nat -> [(Nat, Nat)];
pivot_positions_main_gen zero a nr nc i j =
  (if less_nat i nr
    then (if less_nat j nc
           then (if mat_index a (i, j) == zero
                  then pivot_positions_main_gen zero a nr nc i (suc j)
                  else (i, j) :
                         pivot_positions_main_gen zero a nr nc (suc i) (suc j))
           else [])
    else []);

pivot_positions_gen :: forall a. (Eq a) => a -> Mat a -> [(Nat, Nat)];
pivot_positions_gen zer a =
  pivot_positions_main_gen zer a (mat_dim_row a) (mat_dim_col a) zero_nat
    zero_nat;

swap :: forall a b. (a, b) -> (b, a);
swap p = (snd p, fst p);

map_of :: forall a b. (Eq a) => [(a, b)] -> a -> Maybe b;
map_of ((l, v) : ps) k = (if l == k then Just v else map_of ps k);
map_of [] k = Nothing;

non_pivot_base_gen ::
  forall a. (a -> a) -> a -> a -> Mat a -> [(Nat, Nat)] -> Nat -> Vec a;
non_pivot_base_gen uminus zero one a pivots =
  let {
    _ = mat_dim_row a;
    nc = mat_dim_col a;
    invers = map_of (map swap pivots);
  } in (\ qj ->
         vec nc
           (\ i ->
             (if equal_nat i qj then one
               else (case invers i of {
                      Nothing -> zero;
                      Just j -> uminus (mat_index a (j, qj));
                    }))));

membera :: forall a. (Eq a) => [a] -> a -> Bool;
membera [] y = False;
membera (x : xs) y = x == y || membera xs y;

find_base_vectors_gen ::
  forall a. (Eq a) => (a -> a) -> a -> a -> Mat a -> [Vec a];
find_base_vectors_gen uminus zero one a =
  let {
    pp = pivot_positions_gen zero a;
    b = filter (\ j -> not (membera (map snd pp) j))
          (upt zero_nat (mat_dim_col a));
  } in map (non_pivot_base_gen uminus zero one a pp) b;

find_base_vectors_i ::
  forall a. (Eq a) => Arith_ops_record a -> Mat a -> [Vec a];
find_base_vectors_i ops a =
  find_base_vectors_gen (uminusa ops) (zeroc ops) (oneb ops) a;

list_of_vec_impl :: forall a. Vec_impl a -> [a];
list_of_vec_impl xa = let {
                        (_, a) = rep_vec_impl xa;
                      } in list_of a;

list_of_vec :: forall a. Vec a -> [a];
list_of_vec (Vec_impl v) = list_of_vec_impl v;

berlekamp_basis_i ::
  forall a. (Eq a) => Int -> Arith_ops_record a -> [a] -> [[a]];
berlekamp_basis_i p ff_ops u =
  map (poly_of_list_i ff_ops . list_of_vec)
    (find_base_vectors_i ff_ops (berlekamp_resulting_mat_i p ff_ops u));

berlekamp_monic_factorization_i ::
  forall a. (Eq a) => Int -> Arith_ops_record a -> Nat -> [a] -> [[a]];
berlekamp_monic_factorization_i p ff_ops d f =
  let {
    vs = berlekamp_basis_i p ff_ops f;
  } in berlekamp_factorization_main_i p ff_ops (zeroc ff_ops) (oneb ff_ops) d
         [f] vs (size_list vs);

exercise_16_finished :: Bool;
exercise_16_finished = False;

finite_field_factorization_i ::
  forall a. (Eq a) => Int -> Arith_ops_record a -> [a] -> (a, [[a]]);
finite_field_factorization_i p ff_ops f =
  (if equal_nat (degree_i f) zero_nat then (lead_coeff_i ff_ops f, [])
    else let {
           a = lead_coeff_i ff_ops f;
           u = smult_i ff_ops (inversea ff_ops a) f;
           gs = (if exercise_16_finished
                  then distinct_degree_factorization_i p ff_ops u
                  else [(one_nat, u)]);
           (irr, hs) = partition (\ (i, fa) -> equal_nat (degree_i fa) i) gs;
         } in (a, map snd irr ++
                    concatMap
                      (\ (aa, b) ->
                        berlekamp_monic_factorization_i p ff_ops aa b)
                      hs));

to_int :: forall a. Arith_ops_record a -> a -> Int;
to_int (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x13;

to_int_poly_i :: forall a. Arith_ops_record a -> [a] -> Poly Int;
to_int_poly_i ops f = poly_of_list (map (to_int ops) f);

finite_field_factorization_main ::
  forall a.
    (Eq a) => Int -> Arith_ops_record a -> Poly Int -> (Int, [Poly Int]);
finite_field_factorization_main p f_ops f =
  let {
    (c, fs) =
      finite_field_factorization_i p f_ops (of_int_poly_i f_ops (mp p f));
  } in (to_int f_ops c, map (to_int_poly_i f_ops) fs);

finite_field_factorization_int :: Int -> Poly Int -> (Int, [Poly Int]);
finite_field_factorization_int p =
  (if less_eq_int p (Int_of_integer (65535 :: Integer))
    then finite_field_factorization_main p
           (finite_field_ops32 (uint32_of_int p))
    else finite_field_factorization_main p (finite_field_ops p));

binary_power :: forall a. (Monoid_mult a) => a -> Nat -> a;
binary_power x n =
  (if equal_nat n zero_nat then onea
    else let {
           (d, r) = divmod_nat n (nat_of_integer (2 :: Integer));
           rec = binary_power (times x x) d;
         } in (if equal_nat r zero_nat then rec else times rec x));

data Sublists_foldr_impl a b c =
  Sublists_Foldr_Impl (b -> [a] -> Nat -> ([b], c)) (c -> ([b], c));

sublists_foldr ::
  forall a b c. Sublists_foldr_impl a b c -> b -> [a] -> Nat -> ([b], c);
sublists_foldr (Sublists_Foldr_Impl x1 x2) = x1;

next_sublists_foldr :: forall a b c. Sublists_foldr_impl a b c -> c -> ([b], c);
next_sublists_foldr (Sublists_Foldr_Impl x1 x2) = x2;

coeffs_minus :: forall a. (Ab_group_add a) => [a] -> [a] -> [a];
coeffs_minus (x : xs) (y : ys) = minus x y : coeffs_minus xs ys;
coeffs_minus xs [] = xs;
coeffs_minus [] (v : va) = map uminus (v : va);

monom_multa :: forall a. (Comm_semiring_1 a) => Nat -> Poly a -> Poly a;
monom_multa n f = Poly (let {
                          xs = coeffs f;
                        } in (if null xs then xs else replicate n zerob ++ xs));

karatsuba_main ::
  forall a.
    (Eq a, Comm_ring_1 a,
      Semiring_no_zero_divisors a) => [a] -> Nat -> [a] -> Nat -> Poly a;
karatsuba_main f n g m =
  (if less_eq_nat n karatsuba_lower_bound || less_eq_nat m karatsuba_lower_bound
    then let {
           ff = poly_of_list f;
         } in foldr (\ a p -> plus_poly (smult a ff) (pCons zerob p)) g
                zero_polya
    else let {
           n2 = divide_nat n (nat_of_integer (2 :: Integer));
         } in (if less_nat n2 m
                then let {
                       (f0, f1) = split_at n2 f;
                       (g0, g1) = split_at n2 g;
                       p1 = karatsuba_main f1 (minus_nat n n2) g1
                              (minus_nat m n2);
                       p2 = karatsuba_main (coeffs_minus f1 f0) n2
                              (coeffs_minus g1 g0) n2;
                       p3 = karatsuba_main f0 n2 g0 n2;
                     } in plus_poly (monom_multa (plus_nat n2 n2) p1)
                            (plus_poly
                              (monom_multa n2 (plus_poly (minus_poly p1 p2) p3))
                              p3)
                else let {
                       (f0, f1) = split_at n2 f;
                       p1 = karatsuba_main f1 (minus_nat n n2) g m;
                       a = karatsuba_main f0 n2 g m;
                     } in plus_poly (monom_multa n2 p1) a));

karatsuba_mult_poly ::
  forall a.
    (Eq a, Comm_ring_1 a,
      Semiring_no_zero_divisors a) => Poly a -> Poly a -> Poly a;
karatsuba_mult_poly f g =
  let {
    ff = coeffs f;
    gg = coeffs g;
    n = size_list ff;
    m = size_list gg;
  } in (if less_eq_nat n karatsuba_lower_bound ||
             less_eq_nat m karatsuba_lower_bound
         then (if less_eq_nat n m
                then foldr (\ a p -> plus_poly (smult a g) (pCons zerob p)) ff
                       zero_polya
                else foldr (\ a p -> plus_poly (smult a f) (pCons zerob p)) gg
                       zero_polya)
         else (if less_eq_nat n m then karatsuba_main gg m ff n
                else karatsuba_main ff n gg m));

prod_list_m :: Int -> [Poly Int] -> Poly Int;
prod_list_m m [] = one_polya;
prod_list_m m (f : fs) = mp m (karatsuba_mult_poly f (prod_list_m m fs));

inv_M2 :: Int -> Int -> Int -> Int;
inv_M2 m m2 = (\ x -> (if less_eq_int x m2 then x else minus_int x m));

normalize_content ::
  forall a. (Semiring_div a, Semiring_gcd a, Eq a) => Poly a -> Poly a;
normalize_content p = div_poly (content p) p;

divmod_int :: Int -> Int -> (Int, Int);
divmod_int m n =
  map_prod Int_of_integer Int_of_integer
    (divmod_integer (integer_of_int m) (integer_of_int n));

div_mod_int_poly :: Poly Int -> Poly Int -> Maybe (Poly Int, Poly Int);
div_mod_int_poly p q =
  (if equal_poly q zero_polya then Nothing
    else let {
           n = degreea q;
           _ = coeff q n;
         } in fold_coeffs
                (\ a b ->
                  (case b of {
                    Nothing -> Nothing;
                    Just (s, r) ->
                      let {
                        ar = pCons a r;
                        (ba, m) =
                          divmod_int (coeff ar (degreea q))
                            (coeff q (degreea q));
                      } in (if equal_int m zero_int
                             then Just (pCons ba s, minus_poly ar (smult ba q))
                             else Nothing);
                  }))
                p (Just (zero_polya, zero_polya)));

div_int_poly :: Poly Int -> Poly Int -> Maybe (Poly Int);
div_int_poly p q =
  (case div_mod_int_poly p q of {
    Nothing -> Nothing;
    Just (d, m) -> (if equal_poly m zero_polya then Just d else Nothing);
  });

dvd_int_poly :: Poly Int -> Poly Int -> Bool;
dvd_int_poly q p =
  (if equal_poly q zero_polya then equal_poly p zero_polya
    else not (is_none (div_int_poly p q)));

remove1 :: forall a. (Eq a) => a -> [a] -> [a];
remove1 x [] = [];
remove1 x (y : xs) = (if x == y then xs else y : remove1 x xs);

fold :: forall a b. (a -> b -> b) -> [a] -> b -> b;
fold f (x : xs) s = fold f xs (f x s);
fold f [] s = s;

reconstruction ::
  forall a.
    Int ->
      Sublists_foldr_impl (Poly Int) (Int, [Poly Int]) a ->
        Int ->
          a -> Poly Int ->
                 Poly Int ->
                   Int ->
                     Nat ->
                       Nat ->
                         [Poly Int] ->
                           [Poly Int] -> [(Int, [Poly Int])] -> [Poly Int];
reconstruction m sl_impl m2 state u luu lu d r vs res cands =
  (case cands of {
    [] -> let {
            da = suc d;
          } in (if less_nat r (plus_nat da da) then u : res
                 else let {
                        (candsa, statea) = next_sublists_foldr sl_impl state;
                      } in reconstruction m sl_impl m2 statea u luu lu da r vs
                             res candsa);
    (lv, ws) : candsa ->
      let {
        lva = inv_M2 m m2 lv;
      } in (if dvd lva (case coeffs luu of {
                         [] -> zero_int;
                         x : _ -> x;
                       })
             then let {
                    vb = map_poly (inv_M2 m m2)
                           (mp m (smult lu (prod_list_m m ws)));
                  } in (if dvd_int_poly vb luu
                         then let {
                                pp_vb = normalize_content vb;
                                ua = divide_polya u pp_vb;
                                ra = minus_nat r (size_list ws);
                                resa = pp_vb : res;
                              } in (if less_nat ra (plus_nat d d) then ua : resa
                                     else let {
    lua = lead_coeff ua;
    vsa = fold remove1 ws vs;
    (candsb, statea) = sublists_foldr sl_impl (lua, []) vsa d;
  } in reconstruction m sl_impl m2 statea ua (smult lua ua) lua d ra vsa resa
         candsb)
                         else reconstruction m sl_impl m2 state u luu lu d r vs
                                res candsa)
             else reconstruction m sl_impl m2 state u luu lu d r vs res candsa);
  });

zassenhaus_reconstruction_generic ::
  forall a.
    Sublists_foldr_impl (Poly Int) (Int, [Poly Int]) a ->
      [Poly Int] -> Int -> Nat -> Poly Int -> [Poly Int];
zassenhaus_reconstruction_generic sl_impl vs p n f =
  let {
    lf = lead_coeff f;
    pn = binary_power p n;
    (_, state) = sublists_foldr sl_impl (lf, []) vs zero_nat;
  } in reconstruction pn sl_impl (divide_int pn (Int_of_integer (2 :: Integer)))
         state f (smult lf f) lf zero_nat (size_list vs) vs [] [];

next_sublists1 ::
  forall a b.
    (a -> b -> b) ->
      a -> IArray.IArray a ->
             [b] ->
               [(Nat, b)] ->
                 [(Nat, b)] -> ([b], (a, (IArray.IArray a, [(Nat, b)])));
next_sublists1 f head tail ret0 ret1 ((i, v) : prevs) =
  next_sublists2 f head tail (f head v : ret0) ret1 prevs v (upt zero_nat i);
next_sublists1 f head tail ret0 ret1 [] = (ret0, (head, (tail, ret1)));

next_sublists2 ::
  forall a b.
    (a -> b -> b) ->
      a -> IArray.IArray a ->
             [b] ->
               [(Nat, b)] ->
                 [(Nat, b)] ->
                   b -> [Nat] -> ([b], (a, (IArray.IArray a, [(Nat, b)])));
next_sublists2 f head tail ret0 ret1 prevs v (j : js) =
  let {
    va = f (sub tail j) v;
  } in next_sublists2 f head tail (va : ret0) ((j, va) : ret1) prevs v js;
next_sublists2 f head tail ret0 ret1 prevs v [] =
  next_sublists1 f head tail ret0 ret1 prevs;

next_sublists ::
  forall a b.
    (a -> b -> b) ->
      (a, (IArray.IArray a, [(Nat, b)])) ->
        ([b], (a, (IArray.IArray a, [(Nat, b)])));
next_sublists f (head, (tail, prevs)) = next_sublists1 f head tail [] [] prevs;

create_sublists ::
  forall a b.
    (a -> b -> b) ->
      b -> [a] -> Nat -> ([b], (a, (IArray.IArray a, [(Nat, b)])));
create_sublists f base elements n =
  (if equal_nat n zero_nat
    then (if null elements
           then ([base], (error "undefined", (IArray.listIArray [], [])))
           else let {
                  head = hda elements;
                  tail = IArray.listIArray (tla elements);
                } in ([base], (head, (tail, [(length tail, base)]))))
    else next_sublists f
           (snd (create_sublists f base elements (minus_nat n one_nat))));

impl ::
  forall a b.
    (a -> b -> b) -> Sublists_foldr_impl a b (a, (IArray.IArray a, [(Nat, b)]));
impl f = Sublists_Foldr_Impl (create_sublists f) (next_sublists f);

mul_const :: Int -> Poly Int -> Int -> Int;
mul_const m p c = modulo_int (times_int (case coeffs p of {
  [] -> zero_int;
  x : _ -> x;
})
                               c)
                    m;

zassenhaus_reconstruction :: [Poly Int] -> Int -> Nat -> Poly Int -> [Poly Int];
zassenhaus_reconstruction vs p n f =
  let {
    mul = mul_const (binary_power p n);
    sl_impl = impl (\ x -> map_prod (mul x) (\ a -> x : a));
  } in zassenhaus_reconstruction_generic sl_impl vs p n f;

find_exponent_main :: Int -> Int -> Nat -> Int -> Nat;
find_exponent_main p pm m bnd =
  (if less_int bnd pm then m
    else find_exponent_main p (times_int pm p) (suc m) bnd);

find_exponent :: Int -> Int -> Nat;
find_exponent p bnd = find_exponent_main p p one_nat bnd;

primes_1000 :: [Nat];
primes_1000 =
  [nat_of_integer (2 :: Integer), nat_of_integer (3 :: Integer),
    nat_of_integer (5 :: Integer), nat_of_integer (7 :: Integer),
    nat_of_integer (11 :: Integer), nat_of_integer (13 :: Integer),
    nat_of_integer (17 :: Integer), nat_of_integer (19 :: Integer),
    nat_of_integer (23 :: Integer), nat_of_integer (29 :: Integer),
    nat_of_integer (31 :: Integer), nat_of_integer (37 :: Integer),
    nat_of_integer (41 :: Integer), nat_of_integer (43 :: Integer),
    nat_of_integer (47 :: Integer), nat_of_integer (53 :: Integer),
    nat_of_integer (59 :: Integer), nat_of_integer (61 :: Integer),
    nat_of_integer (67 :: Integer), nat_of_integer (71 :: Integer),
    nat_of_integer (73 :: Integer), nat_of_integer (79 :: Integer),
    nat_of_integer (83 :: Integer), nat_of_integer (89 :: Integer),
    nat_of_integer (97 :: Integer), nat_of_integer (101 :: Integer),
    nat_of_integer (103 :: Integer), nat_of_integer (107 :: Integer),
    nat_of_integer (109 :: Integer), nat_of_integer (113 :: Integer),
    nat_of_integer (127 :: Integer), nat_of_integer (131 :: Integer),
    nat_of_integer (137 :: Integer), nat_of_integer (139 :: Integer),
    nat_of_integer (149 :: Integer), nat_of_integer (151 :: Integer),
    nat_of_integer (157 :: Integer), nat_of_integer (163 :: Integer),
    nat_of_integer (167 :: Integer), nat_of_integer (173 :: Integer),
    nat_of_integer (179 :: Integer), nat_of_integer (181 :: Integer),
    nat_of_integer (191 :: Integer), nat_of_integer (193 :: Integer),
    nat_of_integer (197 :: Integer), nat_of_integer (199 :: Integer),
    nat_of_integer (211 :: Integer), nat_of_integer (223 :: Integer),
    nat_of_integer (227 :: Integer), nat_of_integer (229 :: Integer),
    nat_of_integer (233 :: Integer), nat_of_integer (239 :: Integer),
    nat_of_integer (241 :: Integer), nat_of_integer (251 :: Integer),
    nat_of_integer (257 :: Integer), nat_of_integer (263 :: Integer),
    nat_of_integer (269 :: Integer), nat_of_integer (271 :: Integer),
    nat_of_integer (277 :: Integer), nat_of_integer (281 :: Integer),
    nat_of_integer (283 :: Integer), nat_of_integer (293 :: Integer),
    nat_of_integer (307 :: Integer), nat_of_integer (311 :: Integer),
    nat_of_integer (313 :: Integer), nat_of_integer (317 :: Integer),
    nat_of_integer (331 :: Integer), nat_of_integer (337 :: Integer),
    nat_of_integer (347 :: Integer), nat_of_integer (349 :: Integer),
    nat_of_integer (353 :: Integer), nat_of_integer (359 :: Integer),
    nat_of_integer (367 :: Integer), nat_of_integer (373 :: Integer),
    nat_of_integer (379 :: Integer), nat_of_integer (383 :: Integer),
    nat_of_integer (389 :: Integer), nat_of_integer (397 :: Integer),
    nat_of_integer (401 :: Integer), nat_of_integer (409 :: Integer),
    nat_of_integer (419 :: Integer), nat_of_integer (421 :: Integer),
    nat_of_integer (431 :: Integer), nat_of_integer (433 :: Integer),
    nat_of_integer (439 :: Integer), nat_of_integer (443 :: Integer),
    nat_of_integer (449 :: Integer), nat_of_integer (457 :: Integer),
    nat_of_integer (461 :: Integer), nat_of_integer (463 :: Integer),
    nat_of_integer (467 :: Integer), nat_of_integer (479 :: Integer),
    nat_of_integer (487 :: Integer), nat_of_integer (491 :: Integer),
    nat_of_integer (499 :: Integer), nat_of_integer (503 :: Integer),
    nat_of_integer (509 :: Integer), nat_of_integer (521 :: Integer),
    nat_of_integer (523 :: Integer), nat_of_integer (541 :: Integer),
    nat_of_integer (547 :: Integer), nat_of_integer (557 :: Integer),
    nat_of_integer (563 :: Integer), nat_of_integer (569 :: Integer),
    nat_of_integer (571 :: Integer), nat_of_integer (577 :: Integer),
    nat_of_integer (587 :: Integer), nat_of_integer (593 :: Integer),
    nat_of_integer (599 :: Integer), nat_of_integer (601 :: Integer),
    nat_of_integer (607 :: Integer), nat_of_integer (613 :: Integer),
    nat_of_integer (617 :: Integer), nat_of_integer (619 :: Integer),
    nat_of_integer (631 :: Integer), nat_of_integer (641 :: Integer),
    nat_of_integer (643 :: Integer), nat_of_integer (647 :: Integer),
    nat_of_integer (653 :: Integer), nat_of_integer (659 :: Integer),
    nat_of_integer (661 :: Integer), nat_of_integer (673 :: Integer),
    nat_of_integer (677 :: Integer), nat_of_integer (683 :: Integer),
    nat_of_integer (691 :: Integer), nat_of_integer (701 :: Integer),
    nat_of_integer (709 :: Integer), nat_of_integer (719 :: Integer),
    nat_of_integer (727 :: Integer), nat_of_integer (733 :: Integer),
    nat_of_integer (739 :: Integer), nat_of_integer (743 :: Integer),
    nat_of_integer (751 :: Integer), nat_of_integer (757 :: Integer),
    nat_of_integer (761 :: Integer), nat_of_integer (769 :: Integer),
    nat_of_integer (773 :: Integer), nat_of_integer (787 :: Integer),
    nat_of_integer (797 :: Integer), nat_of_integer (809 :: Integer),
    nat_of_integer (811 :: Integer), nat_of_integer (821 :: Integer),
    nat_of_integer (823 :: Integer), nat_of_integer (827 :: Integer),
    nat_of_integer (829 :: Integer), nat_of_integer (839 :: Integer),
    nat_of_integer (853 :: Integer), nat_of_integer (857 :: Integer),
    nat_of_integer (859 :: Integer), nat_of_integer (863 :: Integer),
    nat_of_integer (877 :: Integer), nat_of_integer (881 :: Integer),
    nat_of_integer (883 :: Integer), nat_of_integer (887 :: Integer),
    nat_of_integer (907 :: Integer), nat_of_integer (911 :: Integer),
    nat_of_integer (919 :: Integer), nat_of_integer (929 :: Integer),
    nat_of_integer (937 :: Integer), nat_of_integer (941 :: Integer),
    nat_of_integer (947 :: Integer), nat_of_integer (953 :: Integer),
    nat_of_integer (967 :: Integer), nat_of_integer (971 :: Integer),
    nat_of_integer (977 :: Integer), nat_of_integer (983 :: Integer),
    nat_of_integer (991 :: Integer), nat_of_integer (997 :: Integer)];

next_candidates :: Nat -> (Nat, [Nat]);
next_candidates n =
  (if equal_nat n zero_nat then (nat_of_integer (1001 :: Integer), primes_1000)
    else (plus_nat n (nat_of_integer (30 :: Integer)),
           [n, plus_nat n (nat_of_integer (2 :: Integer)),
             plus_nat n (nat_of_integer (6 :: Integer)),
             plus_nat n (nat_of_integer (8 :: Integer)),
             plus_nat n (nat_of_integer (12 :: Integer)),
             plus_nat n (nat_of_integer (18 :: Integer)),
             plus_nat n (nat_of_integer (20 :: Integer)),
             plus_nat n (nat_of_integer (26 :: Integer))]));

all_interval_nat :: (Nat -> Bool) -> Nat -> Nat -> Bool;
all_interval_nat p i j = less_eq_nat j i || p i && all_interval_nat p (suc i) j;

next_primes :: Nat -> (Nat, [Nat]);
next_primes n =
  (if equal_nat n zero_nat then next_candidates zero_nat
    else let {
           (m, ps) = next_candidates n;
         } in (m, filter
                    (\ p ->
                      less_nat one_nat p &&
                        all_interval_nat (\ na -> not (dvd na p)) (suc one_nat)
                          p)
                    ps));

find_prime_main :: (Nat -> Bool) -> Nat -> [Nat] -> Nat;
find_prime_main f np ps =
  (case ps of {
    [] -> let {
            a = next_primes np;
            (aa, b) = a;
          } in find_prime_main f aa b;
    p : psa -> (if f p then p else find_prime_main f np psa);
  });

find_prime :: (Nat -> Bool) -> Nat;
find_prime f = find_prime_main f zero_nat [];

suitable_prime_bz :: Poly Int -> Int;
suitable_prime_bz f =
  let {
    lc = lead_coeff f;
  } in int_of_nat
         (find_prime
           (\ n ->
             let {
               p = int_of_nat n;
             } in equal_int (gcd_inta lc p) (Int_of_integer (1 :: Integer)) &&
                    square_free_impl p f));

prod_list :: forall a. (Monoid_mult a) => [a] -> a;
prod_list xs = foldr times xs onea;

divmod_poly_one_main_list ::
  forall a. (Eq a, Comm_ring_1 a) => [a] -> [a] -> [a] -> Nat -> ([a], [a]);
divmod_poly_one_main_list q r d n =
  (if equal_nat n zero_nat then (q, r)
    else let {
           a = hda r;
           qqq = cCons a q;
           rr = tla (if a == zerob then r
                      else minus_poly_rev_list r (map (times a) d));
         } in divmod_poly_one_main_list qqq rr d (minus_nat n one_nat));

pdivmod_monic ::
  forall a. (Eq a, Comm_ring_1 a) => Poly a -> Poly a -> (Poly a, Poly a);
pdivmod_monic f g =
  let {
    cg = coeffs g;
    cf = coeffs f;
    (q, r) =
      divmod_poly_one_main_list [] (reverse cf) (reverse cg)
        (minus_nat (plus_nat one_nat (size_list cf)) (size_list cg));
  } in (poly_of_list q, poly_of_list (reverse r));

dupe_monic ::
  Int ->
    Poly Int ->
      Poly Int -> Poly Int -> Poly Int -> Poly Int -> (Poly Int, Poly Int);
dupe_monic m d h s t u =
  let {
    (q, r) = pdivmod_monic (mp m (karatsuba_mult_poly t u)) d;
  } in (mp m (plus_poly (karatsuba_mult_poly s u) (karatsuba_mult_poly h q)),
         mp m r);

quadratic_hensel_main ::
  Poly Int ->
    Nat ->
      Int ->
        Poly Int -> Poly Int -> Poly Int -> Poly Int -> (Poly Int, Poly Int);
quadratic_hensel_main c j q s t d h =
  (if equal_nat j zero_nat then (d, h)
    else let {
           u = div_poly q (minus_poly c (karatsuba_mult_poly d h));
         } in (if equal_poly u zero_polya then (d, h)
                else let {
                       ua = mp q u;
                       a = dupe_monic q d h s t ua;
                       (aa, b) = a;
                       da = plus_poly d (smult q b);
                       ha = plus_poly h (smult q aa);
                       ub = div_poly q
                              (minus_poly
                                (plus_poly (karatsuba_mult_poly s da)
                                  (karatsuba_mult_poly t ha))
                                one_polya);
                       uc = mp q ub;
                       ab = dupe_monic q d h s t uc;
                       (ac, ba) = ab;
                       qa = times_int q q;
                       sa = mp qa (minus_poly s (smult q ac));
                       ta = mp qa (minus_poly t (smult q ba));
                     } in quadratic_hensel_main c (minus_nat j one_nat) qa sa ta
                            da ha));

dividea :: forall a. Arith_ops_record a -> a -> a -> a;
dividea (Arith_Ops_Record x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14) = x7;

euclid_ext_aux_i ::
  forall a.
    (Eq a) => Arith_ops_record a -> a -> a -> a -> a -> a -> a -> (a, (a, a));
euclid_ext_aux_i ops ra r sa s ta t =
  (if r == zeroc ops
    then let {
           c = dividea ops (oneb ops) (unit_factora ops ra);
         } in (timesa ops sa c, (timesa ops ta c, normalizec ops ra))
    else let {
           q = dividea ops ra r;
         } in euclid_ext_aux_i ops r (moduloa ops ra r) s
                (minusa ops sa (timesa ops q s)) t
                (minusa ops ta (timesa ops q t)));

euclid_ext_i :: forall a. (Eq a) => Arith_ops_record a -> a -> a -> (a, (a, a));
euclid_ext_i ops a b =
  euclid_ext_aux_i ops a b (oneb ops) (zeroc ops) (zeroc ops) (oneb ops);

euclid_ext_poly_i ::
  forall a. (Eq a) => Arith_ops_record a -> [a] -> [a] -> ([a], ([a], [a]));
euclid_ext_poly_i ops = euclid_ext_i (poly_ops ops);

euclid_ext_poly_no_gcd_i ::
  forall a. (Eq a) => Arith_ops_record a -> [a] -> [a] -> ([a], [a]);
euclid_ext_poly_no_gcd_i ff_ops f g = let {
(a, b) = euclid_ext_poly_i ff_ops f g;
(ba, _) = b;
                                      } in (a, ba);

euclid_ext_poly_mod_main ::
  forall a.
    (Eq a) => Int ->
                Arith_ops_record a ->
                  Poly Int -> Poly Int -> (Poly Int, Poly Int);
euclid_ext_poly_mod_main p ff_ops f g =
  let {
    (a, b) =
      euclid_ext_poly_no_gcd_i ff_ops (of_int_poly_i ff_ops f)
        (of_int_poly_i ff_ops g);
  } in (to_int_poly_i ff_ops a, to_int_poly_i ff_ops b);

euclid_ext_poly_mod :: Int -> Poly Int -> Poly Int -> (Poly Int, Poly Int);
euclid_ext_poly_mod p =
  (if less_eq_int p (Int_of_integer (65535 :: Integer))
    then euclid_ext_poly_mod_main p (finite_field_ops32 (uint32_of_int p))
    else euclid_ext_poly_mod_main p (finite_field_ops p));

quadratic_hensel_binary ::
  Int ->
    Int ->
      Nat -> Bool -> Poly Int -> Poly Int -> Poly Int -> (Poly Int, Poly Int);
quadratic_hensel_binary p pn lg_n two_lg_n_is_n c d h =
  let {
    (s, t) = euclid_ext_poly_mod p d h;
    (da, ha) = quadratic_hensel_main c lg_n p s t d h;
  } in (if two_lg_n_is_n then (da, ha) else let {
      mo = mp pn;
    } in (mo da, mo ha));

take :: forall a. Nat -> [a] -> [a];
take n [] = [];
take n (x : xs) =
  (if equal_nat n zero_nat then [] else x : take (minus_nat n one_nat) xs);

drop :: forall a. Nat -> [a] -> [a];
drop n [] = [];
drop n (x : xs) =
  (if equal_nat n zero_nat then x : xs else drop (minus_nat n one_nat) xs);

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Times (Poly a) where {
  times = times_poly;
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Semigroup_mult (Poly a) where {
};

instance (Comm_semiring_1 a) => One (Poly a) where {
  onea = one_polya;
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Power (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Monoid_mult (Poly a) where {
};

hensel_lifting_main ::
  Int -> Int -> Nat -> Bool -> Poly Int -> [Poly Int] -> [Poly Int];
hensel_lifting_main p pn lg_n two_lg_n_is_n u vs =
  let {
    n = size_list vs;
  } in (if less_eq_nat n one_nat then (if equal_nat n one_nat then [u] else [])
         else let {
                i = divide_nat n (nat_of_integer (2 :: Integer));
                vs_1 = take i vs;
                vs_2 = drop i vs;
                mpa = mp p;
                v = mpa (prod_list vs_1);
                w = mpa (prod_list vs_2);
                (va, wa) =
                  quadratic_hensel_binary p pn lg_n two_lg_n_is_n u v w;
              } in hensel_lifting_main p pn lg_n two_lg_n_is_n va vs_1 ++
                     hensel_lifting_main p pn lg_n two_lg_n_is_n wa vs_2);

newtype Proper_base = Abs_proper_base Int;

into_base :: Int -> Proper_base;
into_base xa =
  Abs_proper_base
    (if less_eq_int (Int_of_integer (2 :: Integer)) xa then xa
      else Int_of_integer (2 :: Integer));

rep_proper_base :: Proper_base -> Int;
rep_proper_base (Abs_proper_base x) = x;

square_base :: Proper_base -> Proper_base;
square_base xa =
  Abs_proper_base (times_int (rep_proper_base xa) (rep_proper_base xa));

get_base :: Proper_base -> Int;
get_base x = rep_proper_base x;

log_main :: Proper_base -> Int -> (Nat, Int);
log_main b x =
  (if less_int x (get_base b) then (zero_nat, Int_of_integer (1 :: Integer))
    else let {
           (z, bz) = log_main (square_base b) x;
           l = times_nat (nat_of_integer (2 :: Integer)) z;
           bz1 = times_int bz (get_base b);
         } in (if less_int x bz1 then (l, bz) else (suc l, bz1)));

log_ceiling :: Int -> Int -> Nat;
log_ceiling b x = let {
                    (y, by) = log_main (into_base b) x;
                  } in (if equal_int x by then y else suc y);

hensel_lifting_monic :: Int -> Nat -> Poly Int -> [Poly Int] -> [Poly Int];
hensel_lifting_monic p n u vs =
  let {
    pn = binary_power p n;
    lg_n = log_ceiling (Int_of_integer (2 :: Integer)) (int_of_nat n);
    two_lg_n_is_n =
      equal_nat (binary_power (nat_of_integer (2 :: Integer)) lg_n) n;
    c = mp pn u;
  } in hensel_lifting_main p pn lg_n two_lg_n_is_n c vs;

class (Factorial_semiring a, Semiring_modulo a) => Euclidean_semiring a where {
  euclidean_size :: a -> Nat;
};

class (Euclidean_semiring a, Idom a) => Euclidean_ring a where {
};

euclid_ext_aux ::
  forall a.
    (Euclidean_ring a, Eq a) => a -> a -> a -> a -> a -> a -> (a, (a, a));
euclid_ext_aux ra r sa s ta t =
  (if r == zerob then let {
                        c = divide onea (unit_factor ra);
                      } in (times sa c, (times ta c, normalizeb ra))
    else let {
           q = divide ra r;
         } in euclid_ext_aux r (modulo ra r) s (minus sa (times q s)) t
                (minus ta (times q t)));

euclid_ext :: forall a. (Euclidean_ring a, Eq a) => a -> a -> (a, (a, a));
euclid_ext a b = euclid_ext_aux a b onea zerob zerob onea;

euclidean_size_int :: Int -> Nat;
euclidean_size_int = nat . abs_int;

instance Euclidean_semiring Int where {
  euclidean_size = euclidean_size_int;
};

instance Euclidean_ring Int where {
};

inverse_mod :: Int -> Int -> Int;
inverse_mod x m = let {
                    (a, (_, _)) = euclid_ext x m;
                  } in a;

hensel_lifting :: Int -> Nat -> Poly Int -> [Poly Int] -> [Poly Int];
hensel_lifting p n f gs = let {
                            lc = lead_coeff f;
                            pn = binary_power p n;
                            ilc = inverse_mod lc pn;
                            g = smult ilc f;
                          } in hensel_lifting_monic p n g gs;

sum_list :: forall a. (Monoid_add a) => [a] -> a;
sum_list xs = foldr plus xs zerob;

root_int_maina :: Nat -> Int -> Int -> Int -> Int -> (Int, Bool);
root_int_maina pm ipm ip x n =
  let {
    xpm = binary_power x pm;
    xp = times_int xpm x;
  } in (if less_eq_int xp n then (x, equal_int xp n)
         else root_int_maina pm ipm ip
                (divide_int (plus_int (divide_int n xpm) (times_int x ipm)) ip)
                n);

of_nat :: forall a. (Semiring_1 a) => Nat -> a;
of_nat n =
  (if equal_nat n zero_nat then zerob
    else let {
           (m, q) = divmod_nat n (nat_of_integer (2 :: Integer));
           ma = times (numeral (Bit0 One)) (of_nat m);
         } in (if equal_nat q zero_nat then ma else plus ma onea));

class (Order a) => Dense_order a where {
};

class (Dense_order a, Linorder a) => Dense_linorder a where {
};

class (Order a) => No_top a where {
};

class (Order a) => No_bot a where {
};

class (Dense_linorder a, No_bot a,
        No_top a) => Unbounded_dense_linorder a where {
};

class (Field a, Idom_abs_sgn a) => Field_abs_sgn a where {
};

class (Field_abs_sgn a, Field_char_0 a, Unbounded_dense_linorder a,
        Linordered_idom a) => Linordered_field a where {
};

class (Linordered_field a) => Archimedean_field a where {
};

class (Poly_carrier a) => Large_ordered_semiring_1 a where {
};

class (Archimedean_field a,
        Large_ordered_semiring_1 a) => Floor_ceiling a where {
  floor :: a -> Int;
};

ceiling :: forall a. (Floor_ceiling a) => a -> Int;
ceiling x = uminus_int (floor (uminus x));

abs_rat :: Rat -> Rat;
abs_rat p = Frct (let {
                    a = quotient_of p;
                    (aa, b) = a;
                  } in (abs_int aa, b));

instance Ord Rat where {
  less_eq = less_eq_rat;
  less = less_rat;
};

instance Quasi_order Rat where {
};

instance Weak_order Rat where {
};

instance Preorder Rat where {
};

instance Order Rat where {
};

instance Dense_order Rat where {
};

instance Linorder Rat where {
};

instance Dense_linorder Rat where {
};

instance No_top Rat where {
};

instance No_bot Rat where {
};

instance Unbounded_dense_linorder Rat where {
};

instance Ordered_ab_semigroup_add Rat where {
};

instance Strict_ordered_ab_semigroup_add Rat where {
};

instance Ordered_cancel_ab_semigroup_add Rat where {
};

instance Ordered_ab_semigroup_add_imp_le Rat where {
};

instance Strict_ordered_comm_monoid_add Rat where {
};

instance Ordered_comm_monoid_add Rat where {
};

instance Ordered_cancel_comm_monoid_add Rat where {
};

instance Ordered_ab_semigroup_monoid_add_imp_le Rat where {
};

instance Linordered_ab_semigroup_add Rat where {
};

instance Linordered_cancel_ab_semigroup_add Rat where {
};

instance Ordered_semiring Rat where {
};

instance Ordered_semiring_0 Rat where {
};

instance Ordered_cancel_semiring Rat where {
};

instance Linordered_semiring Rat where {
};

instance Linordered_semiring_strict Rat where {
};

instance Linordered_semiring_1 Rat where {
};

instance Linordered_semiring_1_strict Rat where {
};

instance Ordered_ab_group_add Rat where {
};

instance Abs Rat where {
  absa = abs_rat;
};

instance Ordered_ab_group_add_abs Rat where {
};

instance Linordered_ab_group_add Rat where {
};

instance Ordered_ring Rat where {
};

instance Abs_if Rat where {
};

instance Linordered_ring Rat where {
};

instance Linordered_ring_strict Rat where {
};

instance Ordered_comm_semiring Rat where {
};

instance Ordered_cancel_comm_semiring Rat where {
};

instance Linordered_comm_semiring_strict Rat where {
};

instance Zero_less_one Rat where {
};

instance Linordered_nonzero_semiring Rat where {
};

instance Linordered_semidom Rat where {
};

instance Ordered_comm_ring Rat where {
};

instance Ordered_ring_abs Rat where {
};

instance Sgn Rat where {
  sgn = sgn_rat;
};

instance Idom_abs_sgn Rat where {
};

instance Linordered_idom Rat where {
};

instance Field_abs_sgn Rat where {
};

instance Linordered_field Rat where {
};

instance Archimedean_field Rat where {
};

instance Non_strict_order Rat where {
};

instance Ordered_ab_semigroup Rat where {
};

instance Ordered_semiring_0a Rat where {
};

instance Ordered_semiring_1 Rat where {
};

instance Poly_carrier Rat where {
};

instance Large_ordered_semiring_1 Rat where {
};

instance Floor_ceiling Rat where {
  floor = floor_rat;
};

start_value :: Int -> Nat -> Int;
start_value n p =
  binary_power (Int_of_integer (2 :: Integer))
    (nat (ceiling
           (divide_rat (of_nat (log_ceiling (Int_of_integer (2 :: Integer)) n))
             (of_nat p))));

root_int_main :: Nat -> Int -> (Int, Bool);
root_int_main p n =
  (if equal_nat p zero_nat
    then (Int_of_integer (1 :: Integer),
           equal_int n (Int_of_integer (1 :: Integer)))
    else let {
           pm = minus_nat p one_nat;
         } in root_int_maina pm (int_of_nat pm) (int_of_nat p) (start_value n p)
                n);

root_int_ceiling_pos :: Nat -> Int -> Int;
root_int_ceiling_pos p x =
  (if equal_nat p zero_nat then zero_int
    else (case root_int_main p x of {
           (y, True) -> y;
           (y, False) -> plus_int y (Int_of_integer (1 :: Integer));
         }));

root_int_floor_pos :: Nat -> Int -> Int;
root_int_floor_pos p x =
  (if equal_nat p zero_nat then zero_int else fst (root_int_main p x));

root_int_floor :: Nat -> Int -> Int;
root_int_floor p x =
  (if less_eq_int zero_int x then root_int_floor_pos p x
    else uminus_int (root_int_ceiling_pos p (uminus_int x)));

mahler_landau_graeffe_approximation :: Nat -> Nat -> Poly Int -> Int;
mahler_landau_graeffe_approximation kk dd f =
  let {
    no = sum_list (map (\ a -> times_int a a) (coeffs f));
  } in root_int_floor kk (times_int (int_of_nat dd) no);

alternate :: forall a. [a] -> ([a], [a]);
alternate (x : y : ys) = let {
                           (evn, od) = alternate ys;
                         } in (x : evn, y : od);
alternate [] = ([], []);
alternate [v] = ([v], []);

poly_even_odd :: forall a. (Eq a, Comm_ring_1 a) => Poly a -> (Poly a, Poly a);
poly_even_odd f = let {
                    (evn, od) = alternate (coeffs f);
                  } in (poly_of_list evn, poly_of_list od);

graeffe_one_step :: forall a. (Eq a, Idom a) => a -> Poly a -> Poly a;
graeffe_one_step c f =
  let {
    (g, h) = poly_even_odd f;
  } in smult c
         (minus_poly (karatsuba_mult_poly g g)
           (karatsuba_mult_poly (karatsuba_mult_poly (monom onea one_nat) h)
             h));

min :: forall a. (Ord a) => a -> a -> a;
min a b = (if less_eq a b then a else b);

mahler_approximation_main ::
  Nat -> Nat -> Int -> Poly Int -> Int -> Nat -> Nat -> Int;
mahler_approximation_main bnd dd c g mm k kk =
  let {
    mmm = mahler_landau_graeffe_approximation kk dd g;
    new_mm = (if equal_nat k zero_nat then mmm else min mm mmm);
  } in (if less_eq_nat bnd k then new_mm
         else mahler_approximation_main bnd (times_nat dd dd) c
                (graeffe_one_step c g) new_mm (suc k)
                (times_nat (nat_of_integer (2 :: Integer)) kk));

mahler_approximation :: Nat -> Nat -> Poly Int -> Int;
mahler_approximation bnd d f =
  mahler_approximation_main bnd (times_nat d d)
    (binary_power (uminus_int (Int_of_integer (1 :: Integer))) (degreea f)) f
    (uminus_int (Int_of_integer (1 :: Integer))) zero_nat
    (nat_of_integer (2 :: Integer));

fold_atLeastAtMost_nat :: forall a. (Nat -> a -> a) -> Nat -> Nat -> a -> a;
fold_atLeastAtMost_nat f a b acc =
  (if less_nat b a then acc
    else fold_atLeastAtMost_nat f (plus_nat a one_nat) b (f a acc));

fact :: forall a. (Semiring_char_0 a) => Nat -> a;
fact n =
  of_nat
    (fold_atLeastAtMost_nat times_nat (nat_of_integer (2 :: Integer)) n
      one_nat);

instance Semiring_char_0 Nat where {
};

binomial :: Nat -> Nat -> Nat;
binomial n k =
  (if less_eq_nat k n
    then divide_nat (fact n) (times_nat (fact k) (fact (minus_nat n k)))
    else zero_nat);

mignotte_bound :: Poly Int -> Nat -> Int;
mignotte_bound f d =
  let {
    da = minus_nat d one_nat;
    d2 = divide_nat da (nat_of_integer (2 :: Integer));
    binom = binomial da d2;
  } in plus_int (mahler_approximation (nat_of_integer (2 :: Integer)) binom f)
         (times_int (int_of_nat binom) (abs_int (lead_coeff f)));

factor_bound :: Poly Int -> Nat -> Int;
factor_bound = mignotte_bound;

sequences :: forall a b. (Linorder b) => (a -> b) -> [a] -> [[a]];
sequences key (a : b : xs) =
  (if less (key b) (key a) then desca key b [a] xs
    else asc key b (\ ba -> a : ba) xs);
sequences key [] = [[]];
sequences key [v] = [[v]];

asc ::
  forall a b. (Linorder b) => (a -> b) -> a -> ([a] -> [a]) -> [a] -> [[a]];
asc key a f (b : bs) =
  (if not (less (key b) (key a)) then asc key b (f . (\ ba -> a : ba)) bs
    else f [a] : sequences key (b : bs));
asc key a f [] = f [a] : sequences key [];

desca :: forall a b. (Linorder b) => (a -> b) -> a -> [a] -> [a] -> [[a]];
desca key a asa (b : bs) =
  (if less (key b) (key a) then desca key b (a : asa) bs
    else (a : asa) : sequences key (b : bs));
desca key a asa [] = (a : asa) : sequences key [];

mergec :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a] -> [a];
mergec key (a : asa) (b : bs) =
  (if less (key b) (key a) then b : mergec key (a : asa) bs
    else a : mergec key asa (b : bs));
mergec key [] bs = bs;
mergec key (v : va) [] = v : va;

merge_pairs :: forall a b. (Linorder b) => (a -> b) -> [[a]] -> [[a]];
merge_pairs key (a : b : xs) = mergec key a b : merge_pairs key xs;
merge_pairs key [] = [];
merge_pairs key [v] = [v];

merge_alla :: forall a b. (Linorder b) => (a -> b) -> [[a]] -> [a];
merge_alla key [] = [];
merge_alla key [x] = x;
merge_alla key (v : vb : vc) = merge_alla key (merge_pairs key (v : vb : vc));

sort_key :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a];
sort_key key = merge_alla key . sequences key;

instance Ord Nat where {
  less_eq = less_eq_nat;
  less = less_nat;
};

instance Quasi_order Nat where {
};

instance Weak_order Nat where {
};

instance Preorder Nat where {
};

instance Order Nat where {
};

instance Linorder Nat where {
};

max_factor_degree :: [Nat] -> Nat;
max_factor_degree degs =
  let {
    ds = sort_key (\ x -> x) degs;
  } in sum_list
         (drop (divide_nat (size_list ds) (nat_of_integer (2 :: Integer))) ds);

degree_bound :: forall a. (Zero a) => [Poly a] -> Nat;
degree_bound vs = max_factor_degree (map degreea vs);

berlekamp_zassenhaus_factorization :: Poly Int -> [Poly Int];
berlekamp_zassenhaus_factorization f =
  let {
    p = suitable_prime_bz f;
    (_, fs) = finite_field_factorization_int p f;
    max_deg = degree_bound fs;
    bnd = times_int
            (times_int (Int_of_integer (2 :: Integer)) (abs_int (lead_coeff f)))
            (factor_bound f max_deg);
    k = find_exponent p bnd;
    vs = hensel_lifting p k f fs;
  } in zassenhaus_reconstruction vs p k f;

factorize_int_poly :: Poly Int -> (Int, [(Poly Int, Nat)]);
factorize_int_poly f =
  let {
    (a, gis) = square_free_factorization_int f;
  } in (a, concatMap
             (\ (g, i) ->
               map (\ fa -> (fa, i)) (berlekamp_zassenhaus_factorization g))
             gis);

factorize_rat_poly :: Poly Rat -> (Rat, [(Poly Rat, Nat)]);
factorize_rat_poly f =
  let {
    (c, g) = rat_to_normalized_int_poly f;
    (d, fs) = factorize_int_poly g;
  } in (times_rat c (of_int d), map (\ (fi, a) -> (map_poly of_int fi, a)) fs);

factors_of_rat_poly :: Poly Rat -> [Poly Rat];
factors_of_rat_poly p = map (monic_poly . fst) (snd (factorize_rat_poly p));

mk_rai_intern ::
  Root_info ->
    Poly Rat -> Rat -> Rat -> Maybe (Root_info, (Poly Rat, (Rat, Rat)));
mk_rai_intern ri p l r =
  (if less_eq_rat l zero_rat &&
        less_eq_rat zero_rat r && equal_rat (case coeffs p of {
      [] -> zero_rat;
      x : _ -> x;
    })
                                    zero_rat
    then Nothing else let {
                        (la, ra) = tighten_poly_bounds_for_x p zero_rat l r;
                      } in Just (ri, (p, (la, ra))));

select_correct_factor_rat_poly ::
  forall a.
    (a -> a) ->
      (a -> (Rat, Rat)) ->
        a -> Poly Rat -> Maybe (Root_info, (Poly Rat, (Rat, Rat)));
select_correct_factor_rat_poly bnd_update bnd_get init p =
  let {
    qs = factors_of_rat_poly p;
    polys = map (\ q -> (q, count_roots_interval_rat q)) qs;
    a = select_correct_factor bnd_update bnd_get init polys;
    (aa, b) = a;
  } in let {
         (q, ri) = aa;
       } in (\ (ab, ba) -> mk_rai_intern ri q ab ba)
         b;

tighten_poly_bounds_binary ::
  Poly Rat -> Poly Rat -> ((Rat, Rat), (Rat, Rat)) -> ((Rat, Rat), (Rat, Rat));
tighten_poly_bounds_binary cr1 cr2 ((l1, r1), (l2, r2)) =
  (tighten_poly_bounds cr1 l1 r1, tighten_poly_bounds cr2 l2 r2);

eliminate_zero_divisors :: forall a. (Eq a, Idom_divide a) => Poly a -> Poly a;
eliminate_zero_divisors p =
  (if (case coeffs p of {
        [] -> zerob;
        x : _ -> x;
      }) ==
        zerob &&
        not (case coeffs p of {
              [] -> True;
              _ : _ -> False;
            })
    then eliminate_zero_divisors
           (divide_polya p (pCons zerob (pCons onea zero_polya)))
    else p);

instance (Zero a) => Zero (Poly a) where {
  zerob = zero_polya;
};

poly_lift :: forall a. (Zero a, Eq a) => Poly a -> Poly (Poly a);
poly_lift = map_poly (\ a -> pCons a zero_polya);

instance (Comm_monoid_add a, Eq a) => Plus (Poly a) where {
  plus = plus_poly;
};

instance (Comm_monoid_add a, Eq a) => Semigroup_add (Poly a) where {
};

instance (Comm_monoid_add a, Eq a) => Ab_semigroup_add (Poly a) where {
};

instance (Comm_monoid_add a, Eq a) => Monoid_add (Poly a) where {
};

instance (Comm_monoid_add a, Eq a) => Comm_monoid_add (Poly a) where {
};

poly_x_div_y :: forall a. (Eq a, Comm_ring_1 a) => Poly a -> Poly (Poly a);
poly_x_div_y p =
  sum_list
    (map (\ i -> monom (monom (coeff p i) i) (minus_nat (degreea p) i))
      (upt zero_nat (suc (degreea p))));

newtype Common_divisor a = Abs_common_divisor (a -> a -> a);

primitive_prs :: Poly Int -> Poly Int -> Poly Int;
primitive_prs f g =
  (if equal_poly g zero_polya then f else let {
    r = pseudo_mod f g;
    a = normalize_content r;
  } in primitive_prs g a);

gcd_int_poly :: Poly Int -> Poly Int -> Poly Int;
gcd_int_poly f g = let {
                     cf = content f;
                     cg = content g;
                     fa = div_poly cf f;
                     ga = div_poly cg g;
                   } in smult (gcd_inta cf cg) (primitive_prs fa ga);

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Mult_zero (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Semiring (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Semiring_0 (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Semiring_no_zero_divisors (Poly
                               a) where {
};

instance (Eq a, Idom a) => Semiring_no_zero_divisors_cancel (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a) => Numeral (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Semiring_numeral (Poly a) where {
};

instance (Comm_semiring_1 a) => Zero_neq_one (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Semiring_1 (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_1_no_zero_divisors a) => Semiring_1_no_zero_divisors (Poly
                                   a) where {
};

instance (Cancel_comm_monoid_add a,
           Eq a) => Cancel_semigroup_add (Poly a) where {
};

instance (Ab_group_add a, Eq a) => Minus (Poly a) where {
  minus = minus_poly;
};

instance (Ab_group_add a, Eq a) => Cancel_ab_semigroup_add (Poly a) where {
};

instance (Ab_group_add a, Eq a) => Cancel_comm_monoid_add (Poly a) where {
};

instance (Ab_group_add a, Eq a, Comm_semiring_0_cancel a,
           Semiring_no_zero_divisors a) => Semiring_0_cancel (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Ab_semigroup_mult (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Comm_semiring (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Comm_semiring_0 (Poly a) where {
};

instance (Ab_group_add a, Eq a, Comm_semiring_0_cancel a,
           Semiring_no_zero_divisors a) => Comm_semiring_0_cancel (Poly
                            a) where {
};

instance (Eq a, Comm_ring_1 a,
           Semiring_no_zero_divisors a) => Semiring_1_cancel (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Dvd (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Comm_monoid_mult (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Comm_semiring_1 (Poly a) where {
};

instance (Eq a, Comm_ring_1 a,
           Semiring_no_zero_divisors a) => Comm_semiring_1_cancel (Poly
                            a) where {
};

instance (Eq a, Idom a) => Semidom (Poly a) where {
};

instance (Eq a, Idom_divide a) => Divide (Poly a) where {
  divide = divide_polya;
};

instance (Eq a, Idom_divide a) => Semidom_divide (Poly a) where {
};

instance (Eq a, Idom a) => Comm_semiring_1_cancel_crossproduct (Poly a) where {
};

instance (Ab_group_add a) => Uminus (Poly a) where {
  uminus = uminus_poly;
};

instance (Ab_group_add a, Eq a) => Group_add (Poly a) where {
};

instance (Ab_group_add a, Eq a) => Ab_group_add (Poly a) where {
};

instance (Eq a, Comm_ring a,
           Semiring_no_zero_divisors a) => Ring (Poly a) where {
};

instance (Eq a, Idom a) => Ring_no_zero_divisors (Poly a) where {
};

instance (Eq a, Comm_ring_1 a) => Neg_numeral (Poly a) where {
};

instance (Eq a, Comm_ring_1 a,
           Semiring_no_zero_divisors a) => Ring_1 (Poly a) where {
};

instance (Eq a, Idom a) => Ring_1_no_zero_divisors (Poly a) where {
};

instance (Eq a, Comm_ring a,
           Semiring_no_zero_divisors a) => Comm_ring (Poly a) where {
};

instance (Eq a, Comm_ring_1 a,
           Semiring_no_zero_divisors a) => Comm_ring_1 (Poly a) where {
};

instance (Eq a, Idom a) => Idom (Poly a) where {
};

instance (Eq a, Idom_divide a) => Idom_divide (Poly a) where {
};

common_divisor_int_poly :: Common_divisor (Poly Int);
common_divisor_int_poly = Abs_common_divisor gcd_int_poly;

rep_common_divisor ::
  forall a. (Idom_divide a) => Common_divisor a -> a -> a -> a;
rep_common_divisor (Abs_common_divisor x) = x;

common_divisor :: forall a. (Idom_divide a) => Common_divisor a -> a -> a -> a;
common_divisor x = rep_common_divisor x;

common_divisor_list ::
  forall a. (Idom_divide a) => Common_divisor a -> [a] -> a;
common_divisor_list f xs = let {
                             cd = common_divisor f;
                           } in foldr cd xs zerob;

divide_poly :: forall a. (Eq a, Idom_divide a) => Poly a -> a -> Poly a;
divide_poly p a = map_poly (\ c -> divide c a) p;

resultant_impl_main ::
  forall a.
    (Eq a,
      Idom_divide a) => Common_divisor a -> Poly a -> Poly a -> Nat -> Nat -> a;
resultant_impl_main cdf f g df dg =
  (if equal_nat dg zero_nat then binary_power (case coeffs g of {
        [] -> zerob;
        x : _ -> x;
      })
                                   df
    else let {
           cd = common_divisor_list cdf (coeffs g);
           pg = divide_poly g cd;
           r = pseudo_mod f pg;
           dr = degreea r;
           c = coeff pg dg;
           e1 = times_nat (minus_nat (suc df) dg) dg;
           e2 = minus_nat df dr;
           rgr = resultant_impl_main cdf pg r dg dr;
           rrg = (if dvd (nat_of_integer (2 :: Integer)) dg ||
                       dvd (nat_of_integer (2 :: Integer)) dr ==
                         dvd (nat_of_integer (2 :: Integer)) e2
                   then rgr else uminus rgr);
         } in times (binary_power cd df)
                (divide rrg (binary_power c (minus_nat e1 e2))));

resultant_impl ::
  forall a. (Eq a, Idom_divide a) => Common_divisor a -> Poly a -> Poly a -> a;
resultant_impl cdf f g =
  let {
    df = degreea f;
    dg = degreea g;
  } in (if less_eq_nat dg df then resultant_impl_main cdf f g df dg
         else let {
                gf = resultant_impl_main cdf g f dg df;
              } in (if dvd (nat_of_integer (2 :: Integer)) df ||
                         dvd (nat_of_integer (2 :: Integer)) dg
                     then gf else uminus gf));

resultant_int_poly :: Poly (Poly Int) -> Poly (Poly Int) -> Poly Int;
resultant_int_poly = resultant_impl common_divisor_int_poly;

poly_mult_inta :: Poly Int -> Poly Int -> Poly Int;
poly_mult_inta p q = resultant_int_poly (poly_x_div_y p) (poly_lift q);

poly_mult_int :: Poly Int -> Poly Int -> Poly Int;
poly_mult_int p q =
  poly_mult_inta (eliminate_zero_divisors p) (eliminate_zero_divisors q);

the :: forall a. Maybe a -> a;
the (Just x2) = x2;

mult_rai_fun_pos ::
  (Root_info, (Poly Rat, (Rat, Rat))) ->
    (Root_info, (Poly Rat, (Rat, Rat))) -> (Root_info, (Poly Rat, (Rat, Rat)));
mult_rai_fun_pos (ri1, (p1, (l1, r1))) (ri2, (p2, (l2, r2))) =
  the (select_correct_factor_rat_poly (tighten_poly_bounds_binary p1 p2)
        (\ (a, b) ->
          let {
            (l1a, r1a) = a;
          } in (\ (l2a, r2a) -> (times_rat l1a l2a, times_rat r1a r2a))
            b)
        ((l1, r1), (l2, r2))
        (map_poly of_int
          (poly_mult_int (snd (rat_to_int_poly p1))
            (snd (rat_to_int_poly p2)))));

mult_rai_fun ::
  Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
      Maybe (Root_info, (Poly Rat, (Rat, Rat)));
mult_rai_fun (Just x) (Just y) =
  let {
    ((_, (_, (_, r1))), (_, (_, (_, r2)))) = (x, y);
  } in (if less_rat zero_rat r1 && less_rat zero_rat r2
         then Just (mult_rai_fun_pos x y)
         else (if less_rat zero_rat r1 && less_rat r2 zero_rat
                then uminus_rai_fun
                       (Just (mult_rai_fun_pos x
                               (the (uminus_rai_fun (Just y)))))
                else (if less_rat r1 zero_rat && less_rat zero_rat r2
                       then uminus_rai_fun
                              (Just (mult_rai_fun_pos
                                      (the (uminus_rai_fun (Just x))) y))
                       else Just (mult_rai_fun_pos
                                   (the (uminus_rai_fun (Just x)))
                                   (the (uminus_rai_fun (Just y)))))));
mult_rai_fun Nothing y = Nothing;
mult_rai_fun (Just v) Nothing = Nothing;

mult_rai :: Real_alg_intern -> Real_alg_intern -> Real_alg_intern;
mult_rai xb xc =
  Abs_real_alg_intern
    (mult_rai_fun (rep_real_alg_intern xb) (rep_real_alg_intern xc));

mult_radt :: Real_alg_dt -> Real_alg_dt -> Real_alg_dt;
mult_radt (Rationala r) (Rationala q) = Rationala (times_rat r q);
mult_radt (Rationala r) (Irrational v) = mult_rat_radt r (Irrational v);
mult_radt (Irrational v) (Rationala q) = mult_rat_radt q (Irrational v);
mult_radt (Irrational v) (Irrational va) =
  real_alg_dt
    (mult_rai (rai_of_radt (Irrational v)) (rai_of_radt (Irrational va)));

mult_radtc :: Real_alg_dtc -> Real_alg_dtc -> Real_alg_dtc;
mult_radtc xb xc =
  Abs_real_alg_dtc (mult_radt (rep_real_alg_dtc xb) (rep_real_alg_dtc xc));

times_real_alg :: Real_alg -> Real_alg -> Real_alg;
times_real_alg (Abstr_real_alg xa) (Abstr_real_alg x) =
  Abstr_real_alg (mult_radtc xa x);

times_real :: Real -> Real -> Real;
times_real (Real_of x) (Real_of y) = Real_of (times_real_alg x y);

poly_add_rat :: Rat -> Poly Rat -> Poly Rat;
poly_add_rat r p = pcompose p (pCons (uminus_rat r) (pCons one_rat zero_polya));

add_rat_rai_fun ::
  Rat ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
      Maybe (Root_info, (Poly Rat, (Rat, Rat)));
add_rat_rai_fun r1 (Just (ri2, (p2, (l2, r2)))) =
  let {
    p = monic_poly (poly_add_rat r1 p2);
    ri = count_roots_interval_rat p;
    _ = l_r ri;
    (l, r) = (plus_rat l2 r1, plus_rat r2 r1);
  } in (if less_eq_rat l zero_rat &&
             less_eq_rat zero_rat r && equal_rat (polya p zero_rat) zero_rat
         then Nothing
         else let {
                (la, ra) = tighten_poly_bounds_for_x p zero_rat l r;
              } in Just (ri, (p, (la, ra))));
add_rat_rai_fun r1 Nothing = of_rat_rai_fun r1;

add_rat_rai :: Rat -> Real_alg_intern -> Real_alg_intern;
add_rat_rai xb xc =
  Abs_real_alg_intern (add_rat_rai_fun xb (rep_real_alg_intern xc));

add_rat_radt :: Rat -> Real_alg_dt -> Real_alg_intern;
add_rat_radt x y = add_rat_rai x (rai_of_radt y);

plus_rat_radt :: Rat -> Real_alg_dt -> Real_alg_dt;
plus_rat_radt x y = real_alg_dt (add_rat_radt x y);

poly_x_minus_y ::
  forall a.
    (Ab_group_add a, Eq a, Comm_semiring_1 a,
      Semiring_no_zero_divisors a) => Poly a -> Poly (Poly a);
poly_x_minus_y p =
  pcompose (poly_lift p)
    (pCons (pCons zerob (pCons onea zero_polya))
      (pCons (uminus_poly one_polya) zero_polya));

poly_add_int :: Poly Int -> Poly Int -> Poly Int;
poly_add_int p q = resultant_int_poly (poly_x_minus_y p) (poly_lift q);

add_rai_fun ::
  Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
      Maybe (Root_info, (Poly Rat, (Rat, Rat)));
add_rai_fun (Just (ri1, (p1, (l1, r1)))) (Just (ri2, (p2, (l2, r2)))) =
  select_correct_factor_rat_poly (tighten_poly_bounds_binary p1 p2)
    (\ (a, b) -> let {
                   (l1a, r1a) = a;
                 } in (\ (l2a, r2a) -> (plus_rat l1a l2a, plus_rat r1a r2a))
                   b)
    ((l1, r1), (l2, r2))
    (map_poly of_int
      (poly_add_int (snd (rat_to_int_poly p1)) (snd (rat_to_int_poly p2))));
add_rai_fun Nothing y = y;
add_rai_fun (Just v) Nothing = Just v;

add_rai :: Real_alg_intern -> Real_alg_intern -> Real_alg_intern;
add_rai xb xc =
  Abs_real_alg_intern
    (add_rai_fun (rep_real_alg_intern xb) (rep_real_alg_intern xc));

plus_radt :: Real_alg_dt -> Real_alg_dt -> Real_alg_dt;
plus_radt (Rationala r) (Rationala q) = Rationala (plus_rat r q);
plus_radt (Rationala r) (Irrational v) = plus_rat_radt r (Irrational v);
plus_radt (Irrational v) (Rationala q) = plus_rat_radt q (Irrational v);
plus_radt (Irrational v) (Irrational va) =
  real_alg_dt
    (add_rai (rai_of_radt (Irrational v)) (rai_of_radt (Irrational va)));

plus_radtc :: Real_alg_dtc -> Real_alg_dtc -> Real_alg_dtc;
plus_radtc xb xc =
  Abs_real_alg_dtc (plus_radt (rep_real_alg_dtc xb) (rep_real_alg_dtc xc));

plus_real_alg :: Real_alg -> Real_alg -> Real_alg;
plus_real_alg (Abstr_real_alg xa) (Abstr_real_alg x) =
  Abstr_real_alg (plus_radtc xa x);

minus_real_alg :: Real_alg -> Real_alg -> Real_alg;
minus_real_alg x y = plus_real_alg x (uminus_real_alg y);

minus_real :: Real -> Real -> Real;
minus_real (Real_of x) (Real_of y) = Real_of (minus_real_alg x y);

of_rat_radtc :: Rat -> Real_alg_dtc;
of_rat_radtc xa = Abs_real_alg_dtc (Rationala xa);

of_rat_real_alg :: Rat -> Real_alg;
of_rat_real_alg x = Abstr_real_alg (of_rat_radtc x);

zero_real_alg :: Real_alg;
zero_real_alg = of_rat_real_alg zero_rat;

zero_real :: Real;
zero_real = Real_of zero_real_alg;

plus_real :: Real -> Real -> Real;
plus_real (Real_of x) (Real_of y) = Real_of (plus_real_alg x y);

one_real_alg :: Real_alg;
one_real_alg = of_rat_real_alg one_rat;

one_real :: Real;
one_real = Real_of one_real_alg;

instance Plus Real where {
  plus = plus_real;
};

instance Semigroup_add Real where {
};

instance Cancel_semigroup_add Real where {
};

instance Ab_semigroup_add Real where {
};

instance Minus Real where {
  minus = minus_real;
};

instance Cancel_ab_semigroup_add Real where {
};

instance Zero Real where {
  zerob = zero_real;
};

instance Monoid_add Real where {
};

instance Comm_monoid_add Real where {
};

instance Cancel_comm_monoid_add Real where {
};

instance Times Real where {
  times = times_real;
};

instance Mult_zero Real where {
};

instance Semigroup_mult Real where {
};

instance Semiring Real where {
};

instance Semiring_0 Real where {
};

instance Semiring_0_cancel Real where {
};

instance One Real where {
  onea = one_real;
};

instance Power Real where {
};

instance Monoid_mult Real where {
};

instance Numeral Real where {
};

instance Semiring_numeral Real where {
};

instance Zero_neq_one Real where {
};

instance Semiring_1 Real where {
};

instance Semiring_1_cancel Real where {
};

instance Uminus Real where {
  uminus = uminus_real;
};

instance Group_add Real where {
};

instance Neg_numeral Real where {
};

instance Ab_group_add Real where {
};

instance Ring Real where {
};

instance Ring_1 Real where {
};

real_of_int :: Int -> Real;
real_of_int x = of_inta x;

class (Linordered_idom a) => Real_embedding a where {
  real_of :: a -> Real;
};

instance Real_embedding Int where {
  real_of = real_of_int;
};

instance Large_ordered_semiring_1 Int where {
};

class (Real_embedding a,
        Large_ordered_semiring_1 a) => Large_real_ordered_semiring_1 a where {
};

instance Large_real_ordered_semiring_1 Int where {
};

shows_prec_nat :: Nat -> Nat -> [Prelude.Char] -> [Prelude.Char];
shows_prec_nat = showsp_nat;

shows_list_nat :: [Nat] -> [Prelude.Char] -> [Prelude.Char];
shows_list_nat = showsp_list shows_prec_nat zero_nat;

instance Showa Nat where {
  shows_prec = shows_prec_nat;
  shows_list = shows_list_nat;
};

inf_nat :: Nat -> Nat -> Nat;
inf_nat = min;

class Inf a where {
  inf :: a -> a -> a;
};

instance Inf Nat where {
  inf = inf_nat;
};

sup_nat :: Nat -> Nat -> Nat;
sup_nat = max;

class Sup a where {
  sup :: a -> a -> a;
};

instance Sup Nat where {
  sup = sup_nat;
};

compare_nat :: Nat -> Nat -> Ordera;
compare_nat = comparator_of;

class Compare a where {
  compare :: a -> a -> Ordera;
};

class (Compare a, Linorder a) => Compare_order a where {
};

class (Compare_order a) => Key a where {
};

instance Compare Nat where {
  compare = compare_nat;
};

instance Compare_order Nat where {
};

instance Key Nat where {
};

class (Sup a, Order a) => Semilattice_sup a where {
};

class (Inf a, Order a) => Semilattice_inf a where {
};

class (Semilattice_inf a, Semilattice_sup a) => Lattice a where {
};

instance Semilattice_sup Nat where {
};

instance Semilattice_inf Nat where {
};

instance Lattice Nat where {
};

ceq_nat :: Maybe (Nat -> Nat -> Bool);
ceq_nat = Just equal_nat;

instance Ceq Nat where {
  ceq = ceq_nat;
};

set_impl_nat :: Phantom Nat Set_impla;
set_impl_nat = Phantom Set_RBT;

instance Set_impl Nat where {
  set_impl = set_impl_nat;
};

finite_UNIV_nat :: Phantom Nat Bool;
finite_UNIV_nat = Phantom False;

card_UNIV_nat :: Phantom Nat Nat;
card_UNIV_nat = Phantom zero_nat;

class Finite_UNIV a where {
  finite_UNIV :: Phantom a Bool;
};

class (Finite_UNIV a) => Card_UNIV a where {
  card_UNIVa :: Phantom a Nat;
};

instance Finite_UNIV Nat where {
  finite_UNIV = finite_UNIV_nat;
};

instance Card_UNIV Nat where {
  card_UNIVa = card_UNIV_nat;
};

cEnum_nat :: Maybe ([Nat], ((Nat -> Bool) -> Bool, (Nat -> Bool) -> Bool));
cEnum_nat = Nothing;

instance Cenum Nat where {
  cEnum = cEnum_nat;
};

ccompare_nat :: Maybe (Nat -> Nat -> Ordera);
ccompare_nat = Just compare_nat;

instance Ccompare Nat where {
  ccompare = ccompare_nat;
};

data Mapping_impla = Mapping_Choose | Mapping_Assoc_List | Mapping_RBT
  | Mapping_Mapping;

mapping_impl_nat :: Phantom Nat Mapping_impla;
mapping_impl_nat = Phantom Mapping_RBT;

class Mapping_impl a where {
  mapping_impl :: Phantom a Mapping_impla;
};

instance Mapping_impl Nat where {
  mapping_impl = mapping_impl_nat;
};

proper_interval_nat :: Maybe Nat -> Maybe Nat -> Bool;
proper_interval_nat no Nothing = True;
proper_interval_nat Nothing (Just x) = less_nat zero_nat x;
proper_interval_nat (Just x) (Just y) = less_nat one_nat (minus_nat y x);

cproper_interval_nat :: Maybe Nat -> Maybe Nat -> Bool;
cproper_interval_nat = proper_interval_nat;

class (Ccompare a) => Cproper_interval a where {
  cproper_interval :: Maybe a -> Maybe a -> Bool;
};

instance Cproper_interval Nat where {
  cproper_interval = cproper_interval_nat;
};

showsp_rat :: Nat -> Rat -> [Prelude.Char] -> [Prelude.Char];
showsp_rat p x =
  let {
    (d, n) = quotient_of x;
  } in (if equal_int n (Int_of_integer (1 :: Integer)) then showsp_int p d
         else (showsp_int p d . shows_string ['/']) . showsp_int p n);

shows_prec_rat :: Nat -> Rat -> [Prelude.Char] -> [Prelude.Char];
shows_prec_rat = showsp_rat;

shows_list_rat :: [Rat] -> [Prelude.Char] -> [Prelude.Char];
shows_list_rat = showsp_list shows_prec_rat zero_nat;

instance Showa Rat where {
  shows_prec = shows_prec_rat;
  shows_list = shows_list_rat;
};

compare_rat :: Rat -> Rat -> Ordera;
compare_rat = comparator_of;

instance Compare Rat where {
  compare = compare_rat;
};

ceq_rat :: Maybe (Rat -> Rat -> Bool);
ceq_rat = Just equal_rat;

instance Ceq Rat where {
  ceq = ceq_rat;
};

set_impl_rat :: Phantom Rat Set_impla;
set_impl_rat = Phantom Set_RBT;

instance Set_impl Rat where {
  set_impl = set_impl_rat;
};

cEnum_rat :: Maybe ([Rat], ((Rat -> Bool) -> Bool, (Rat -> Bool) -> Bool));
cEnum_rat = Nothing;

instance Cenum Rat where {
  cEnum = cEnum_rat;
};

ccompare_rat :: Maybe (Rat -> Rat -> Ordera);
ccompare_rat = Just compare_rat;

instance Ccompare Rat where {
  ccompare = ccompare_rat;
};

of_rat :: forall a. (Field_char_0 a) => Rat -> a;
of_rat p = let {
             a = quotient_of p;
             (aa, b) = a;
           } in divide (of_inta aa) (of_inta b);

poly_inverse :: forall a. (Field a, Eq a) => Poly a -> Poly a;
poly_inverse p = poly_of_list (reverse (coeffs p));

inverse_rai_fun ::
  forall a b c.
    (Inverse b,
      Inverse c) => Maybe (a, (Poly Rat, (b, c))) ->
                      Maybe (Root_info, (Poly Rat, (c, b)));
inverse_rai_fun =
  map_option
    (\ (_, (p, (l, r))) ->
      let {
        pa = monic_poly (poly_inverse p);
      } in (count_roots_interval_rat pa, (pa, (inverse r, inverse l))));

inverse_rai :: Real_alg_intern -> Real_alg_intern;
inverse_rai xa = Abs_real_alg_intern (inverse_rai_fun (rep_real_alg_intern xa));

inverse_radt :: Real_alg_dt -> Real_alg_dt;
inverse_radt (Rationala r) = Rationala (inverse_rat r);
inverse_radt (Irrational v) =
  real_alg_dt (inverse_rai (rai_of_radt (Irrational v)));

inverse_radtc :: Real_alg_dtc -> Real_alg_dtc;
inverse_radtc xa = Abs_real_alg_dtc (inverse_radt (rep_real_alg_dtc xa));

inverse_real_alg :: Real_alg -> Real_alg;
inverse_real_alg (Abstr_real_alg x) = Abstr_real_alg (inverse_radtc x);

inverse_real :: Real -> Real;
inverse_real (Real_of x) = Real_of (inverse_real_alg x);

divide_real_alg :: Real_alg -> Real_alg -> Real_alg;
divide_real_alg x y = times_real_alg x (inverse_real_alg y);

divide_real :: Real -> Real -> Real;
divide_real (Real_of x) (Real_of y) = Real_of (divide_real_alg x y);

instance Semiring_char_0 Real where {
};

instance Ring_char_0 Real where {
};

instance Semiring_no_zero_divisors Real where {
};

instance Semiring_1_no_zero_divisors Real where {
};

instance Semiring_no_zero_divisors_cancel Real where {
};

instance Ring_no_zero_divisors Real where {
};

instance Ring_1_no_zero_divisors Real where {
};

instance Divide Real where {
  divide = divide_real;
};

instance Inverse Real where {
  inverse = inverse_real;
};

instance Division_ring Real where {
};

instance Ab_semigroup_mult Real where {
};

instance Comm_semiring Real where {
};

instance Comm_semiring_0 Real where {
};

instance Comm_semiring_0_cancel Real where {
};

instance Dvd Real where {
};

instance Comm_monoid_mult Real where {
};

instance Comm_semiring_1 Real where {
};

instance Comm_semiring_1_cancel Real where {
};

instance Semidom Real where {
};

instance Semidom_divide Real where {
};

instance Comm_semiring_1_cancel_crossproduct Real where {
};

instance Comm_ring Real where {
};

instance Comm_ring_1 Real where {
};

instance Idom Real where {
};

instance Idom_divide Real where {
};

instance Field Real where {
};

instance Field_char_0 Real where {
};

real_of_rat :: Rat -> Real;
real_of_rat x = of_rat x;

instance Real_embedding Rat where {
  real_of = real_of_rat;
};

instance Large_real_ordered_semiring_1 Rat where {
};

equal_order :: Ordera -> Ordera -> Bool;
equal_order Lt Gt = False;
equal_order Gt Lt = False;
equal_order Eqa Gt = False;
equal_order Gt Eqa = False;
equal_order Eqa Lt = False;
equal_order Lt Eqa = False;
equal_order Gt Gt = True;
equal_order Lt Lt = True;
equal_order Eqa Eqa = True;

newtype Generator a b = Generator (b -> Bool, b -> (a, b));

generator :: forall a b. Generator a b -> (b -> Bool, b -> (a, b));
generator (Generator x) = x;

has_next :: forall a b. Generator a b -> b -> Bool;
has_next g = fst (generator g);

next :: forall a b. Generator a b -> b -> (a, b);
next g = snd (generator g);

sorted_list_subset_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
sorted_list_subset_fusion less eq g1 g2 s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in has_next g2 s2 &&
                let {
                  (y, s2a) = next g2 s2;
                } in (if eq x y
                       then sorted_list_subset_fusion less eq g1 g2 s1a s2a
                       else less y x &&
                              sorted_list_subset_fusion less eq g1 g2 s1 s2a)
    else True);

list_all_fusion :: forall a b. Generator a b -> (a -> Bool) -> b -> Bool;
list_all_fusion g p s =
  (if has_next g s then let {
                          (x, sa) = next g s;
                        } in p x && list_all_fusion g p sa
    else True);

rbt_keys_next ::
  forall a b. ([(a, Rbta a b)], Rbta a b) -> (a, ([(a, Rbta a b)], Rbta a b));
rbt_keys_next ((k, t) : kts, Emptya) = (k, (kts, t));
rbt_keys_next (kts, Branch c l k v r) = rbt_keys_next ((k, r) : kts, l);

rbt_has_next :: forall a b c. ([(a, Rbta b c)], Rbta b c) -> Bool;
rbt_has_next ([], Emptya) = False;
rbt_has_next (vb : vc, va) = True;
rbt_has_next (v, Branch vb vc vd ve vf) = True;

rbt_keys_generator :: forall a b. Generator a ([(a, Rbta a b)], Rbta a b);
rbt_keys_generator = Generator (rbt_has_next, rbt_keys_next);

lt_of_comp :: forall a. (a -> a -> Ordera) -> a -> a -> Bool;
lt_of_comp acomp x y = (case acomp x y of {
                         Eqa -> False;
                         Lt -> True;
                         Gt -> False;
                       });

list_of_dlist :: forall a. (Ceq a) => Set_dlist a -> [a];
list_of_dlist (Abs_dlist x) = x;

dlist_all :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Bool;
dlist_all x xc = all x (list_of_dlist xc);

impl_ofb :: forall b a. (Ccompare b) => Mapping_rbt b a -> Rbta b a;
impl_ofb (Mapping_RBTa x) = x;

rbt_init :: forall a b c. Rbta a b -> ([(c, Rbta a b)], Rbta a b);
rbt_init = (\ a -> ([], a));

init ::
  forall a b c. (Ccompare a) => Mapping_rbt a b -> ([(c, Rbta a b)], Rbta a b);
init xa = rbt_init (impl_ofb xa);

collect :: forall a. (Cenum a) => (a -> Bool) -> Set a;
collect p = (case cEnum of {
              Nothing -> Collect_set p;
              Just (enum, _) -> Set_Monad (filter p enum);
            });

list_member :: forall a. (a -> a -> Bool) -> [a] -> a -> Bool;
list_member equal (x : xs) y = equal x y || list_member equal xs y;
list_member equal [] y = False;

memberc :: forall a. (Ceq a) => Set_dlist a -> a -> Bool;
memberc xa = list_member (the ceq) (list_of_dlist xa);

rbt_comp_lookup :: forall a b. (a -> a -> Ordera) -> Rbta a b -> a -> Maybe b;
rbt_comp_lookup c Emptya k = Nothing;
rbt_comp_lookup c (Branch uu l x y r) k = (case c k x of {
    Eqa -> Just y;
    Lt -> rbt_comp_lookup c l k;
    Gt -> rbt_comp_lookup c r k;
  });

lookupd :: forall a b. (Ccompare a) => Mapping_rbt a b -> a -> Maybe b;
lookupd xa = rbt_comp_lookup (the ccompare) (impl_ofb xa);

memberb :: forall a. (Ccompare a) => Mapping_rbt a () -> a -> Bool;
memberb t x = lookupd t x == Just ();

member :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Bool;
member x (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "member Set_Monad: ceq = None" (\ _ -> member x (Set_Monad xs));
    Just eq -> list_member eq xs x;
  });
member xa (Complement x) = not (member xa x);
member x (RBT_set rbt) = memberb rbt x;
member x (DList_set dxs) = memberc dxs x;
member x (Collect_set a) = a x;

subset_eq :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
subset_eq (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset RBT_set RBT_set: ccompare = None"
        (\ _ -> subset_eq (RBT_set rbt1) (RBT_set rbt2));
    Just c ->
      (case ceq of {
        Nothing ->
          sorted_list_subset_fusion (lt_of_comp c)
            (\ x y -> equal_order (c x y) Eqa) rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
        Just eq ->
          sorted_list_subset_fusion (lt_of_comp c) eq rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
      });
  });
subset_eq (Complement a1) (Complement a2) = subset_eq a2 a1;
subset_eq (Collect_set p) (Complement a) =
  subset_eq a (collect (\ x -> not (p x)));
subset_eq (Set_Monad xs) c = all (\ x -> member x c) xs;
subset_eq (DList_set dxs) c =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset DList_set1: ceq = None" (\ _ -> subset_eq (DList_set dxs) c);
    Just _ -> dlist_all (\ x -> member x c) dxs;
  });
subset_eq (RBT_set rbt) b =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset RBT_set1: ccompare = None" (\ _ -> subset_eq (RBT_set rbt) b);
    Just _ -> list_all_fusion rbt_keys_generator (\ x -> member x b) (init rbt);
  });

less_eq_set :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
less_eq_set = subset_eq;

equal_set ::
  forall a. (Cenum a, Ceq a, Ccompare a, Eq a) => Set a -> Set a -> Bool;
equal_set a b = less_eq_set a b && less_eq_set b a;

instance (Cenum a, Ceq a, Ccompare a, Eq a) => Eq (Set a) where {
  a == b = equal_set a b;
};

uminus_set :: forall a. Set a -> Set a;
uminus_set (Complement b) = b;
uminus_set (Collect_set p) = Collect_set (\ x -> not (p x));
uminus_set a = Complement a;

balance :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance (Branch R a w x b) s t (Branch R c y z d) =
  Branch R (Branch B a w x b) s t (Branch B c y z d);
balance (Branch R (Branch R a w x b) s t c) y z Emptya =
  Branch R (Branch B a w x b) s t (Branch B c y z Emptya);
balance (Branch R (Branch R a w x b) s t c) y z (Branch B va vb vc vd) =
  Branch R (Branch B a w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch R Emptya w x (Branch R b s t c)) y z Emptya =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z Emptya);
balance (Branch R (Branch B va vb vc vd) w x (Branch R b s t c)) y z Emptya =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z Emptya);
balance (Branch R Emptya w x (Branch R b s t c)) y z (Branch B va vb vc vd) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch R (Branch B ve vf vg vh) w x (Branch R b s t c)) y z
  (Branch B va vb vc vd) =
  Branch R (Branch B (Branch B ve vf vg vh) w x b) s t
    (Branch B c y z (Branch B va vb vc vd));
balance Emptya w x (Branch R b s t (Branch R c y z d)) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z d);
balance (Branch B va vb vc vd) w x (Branch R b s t (Branch R c y z d)) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z d);
balance Emptya w x (Branch R (Branch R b s t c) y z Emptya) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z Emptya);
balance Emptya w x (Branch R (Branch R b s t c) y z (Branch B va vb vc vd)) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch B va vb vc vd) w x (Branch R (Branch R b s t c) y z Emptya) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z Emptya);
balance (Branch B va vb vc vd) w x
  (Branch R (Branch R b s t c) y z (Branch B ve vf vg vh)) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t
    (Branch B c y z (Branch B ve vf vg vh));
balance Emptya s t Emptya = Branch B Emptya s t Emptya;
balance Emptya s t (Branch B va vb vc vd) =
  Branch B Emptya s t (Branch B va vb vc vd);
balance Emptya s t (Branch v Emptya vb vc Emptya) =
  Branch B Emptya s t (Branch v Emptya vb vc Emptya);
balance Emptya s t (Branch v (Branch B ve vf vg vh) vb vc Emptya) =
  Branch B Emptya s t (Branch v (Branch B ve vf vg vh) vb vc Emptya);
balance Emptya s t (Branch v Emptya vb vc (Branch B vf vg vh vi)) =
  Branch B Emptya s t (Branch v Emptya vb vc (Branch B vf vg vh vi));
balance Emptya s t
  (Branch v (Branch B ve vj vk vl) vb vc (Branch B vf vg vh vi)) =
  Branch B Emptya s t
    (Branch v (Branch B ve vj vk vl) vb vc (Branch B vf vg vh vi));
balance (Branch B va vb vc vd) s t Emptya =
  Branch B (Branch B va vb vc vd) s t Emptya;
balance (Branch B va vb vc vd) s t (Branch B ve vf vg vh) =
  Branch B (Branch B va vb vc vd) s t (Branch B ve vf vg vh);
balance (Branch B va vb vc vd) s t (Branch v Emptya vf vg Emptya) =
  Branch B (Branch B va vb vc vd) s t (Branch v Emptya vf vg Emptya);
balance (Branch B va vb vc vd) s t
  (Branch v (Branch B vi vj vk vl) vf vg Emptya) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v (Branch B vi vj vk vl) vf vg Emptya);
balance (Branch B va vb vc vd) s t
  (Branch v Emptya vf vg (Branch B vj vk vl vm)) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v Emptya vf vg (Branch B vj vk vl vm));
balance (Branch B va vb vc vd) s t
  (Branch v (Branch B vi vn vo vp) vf vg (Branch B vj vk vl vm)) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v (Branch B vi vn vo vp) vf vg (Branch B vj vk vl vm));
balance (Branch v Emptya vb vc Emptya) s t Emptya =
  Branch B (Branch v Emptya vb vc Emptya) s t Emptya;
balance (Branch v Emptya vb vc (Branch B ve vf vg vh)) s t Emptya =
  Branch B (Branch v Emptya vb vc (Branch B ve vf vg vh)) s t Emptya;
balance (Branch v (Branch B vf vg vh vi) vb vc Emptya) s t Emptya =
  Branch B (Branch v (Branch B vf vg vh vi) vb vc Emptya) s t Emptya;
balance (Branch v (Branch B vf vg vh vi) vb vc (Branch B ve vj vk vl)) s t
  Emptya =
  Branch B (Branch v (Branch B vf vg vh vi) vb vc (Branch B ve vj vk vl)) s t
    Emptya;
balance (Branch v Emptya vf vg Emptya) s t (Branch B va vb vc vd) =
  Branch B (Branch v Emptya vf vg Emptya) s t (Branch B va vb vc vd);
balance (Branch v Emptya vf vg (Branch B vi vj vk vl)) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v Emptya vf vg (Branch B vi vj vk vl)) s t
    (Branch B va vb vc vd);
balance (Branch v (Branch B vj vk vl vm) vf vg Emptya) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v (Branch B vj vk vl vm) vf vg Emptya) s t
    (Branch B va vb vc vd);
balance (Branch v (Branch B vj vk vl vm) vf vg (Branch B vi vn vo vp)) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v (Branch B vj vk vl vm) vf vg (Branch B vi vn vo vp)) s t
    (Branch B va vb vc vd);

rbt_comp_ins ::
  forall a b.
    (a -> a -> Ordera) -> (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_ins c f k v Emptya = Branch R Emptya k v Emptya;
rbt_comp_ins c f k v (Branch B l x y r) =
  (case c k x of {
    Eqa -> Branch B l x (f k y v) r;
    Lt -> balance (rbt_comp_ins c f k v l) x y r;
    Gt -> balance l x y (rbt_comp_ins c f k v r);
  });
rbt_comp_ins c f k v (Branch R l x y r) =
  (case c k x of {
    Eqa -> Branch R l x (f k y v) r;
    Lt -> Branch R (rbt_comp_ins c f k v l) x y r;
    Gt -> Branch R l x y (rbt_comp_ins c f k v r);
  });

paint :: forall a b. Color -> Rbta a b -> Rbta a b;
paint c Emptya = Emptya;
paint c (Branch uu l k v r) = Branch c l k v r;

rbt_comp_insert_with_key ::
  forall a b.
    (a -> a -> Ordera) -> (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_insert_with_key c f k v t = paint B (rbt_comp_ins c f k v t);

rbt_comp_insert ::
  forall a b. (a -> a -> Ordera) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_insert c = rbt_comp_insert_with_key c (\ _ _ nv -> nv);

inserte ::
  forall a b. (Ccompare a) => a -> b -> Mapping_rbt a b -> Mapping_rbt a b;
inserte xc xd xe =
  Mapping_RBTa (rbt_comp_insert (the ccompare) xc xd (impl_ofb xe));

comp_sunion_with ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
comp_sunion_with c f ((ka, va) : asa) ((k, v) : bs) =
  (case c k ka of {
    Eqa -> (ka, f ka va v) : comp_sunion_with c f asa bs;
    Lt -> (k, v) : comp_sunion_with c f ((ka, va) : asa) bs;
    Gt -> (ka, va) : comp_sunion_with c f asa ((k, v) : bs);
  });
comp_sunion_with c f [] bs = bs;
comp_sunion_with c f asa [] = asa;

data Comparea = LT | GT | EQ;

skip_red :: forall a b. Rbta a b -> Rbta a b;
skip_red (Branch R l k v r) = l;
skip_red Emptya = Emptya;
skip_red (Branch B va vb vc vd) = Branch B va vb vc vd;

skip_black :: forall a b. Rbta a b -> Rbta a b;
skip_black t = let {
                 ta = skip_red t;
               } in (case ta of {
                      Emptya -> ta;
                      Branch R _ _ _ _ -> ta;
                      Branch B l _ _ _ -> l;
                    });

compare_height ::
  forall a b. Rbta a b -> Rbta a b -> Rbta a b -> Rbta a b -> Comparea;
compare_height sx s t tx =
  (case (skip_red sx, (skip_red s, (skip_red t, skip_red tx))) of {
    (Emptya, (Emptya, (_, Emptya))) -> EQ;
    (Emptya, (Emptya, (_, Branch _ _ _ _ _))) -> LT;
    (Emptya, (Branch _ _ _ _ _, (Emptya, _))) -> EQ;
    (Emptya, (Branch _ _ _ _ _, (Branch _ _ _ _ _, Emptya))) -> EQ;
    (Emptya, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Branch _ txa _ _ _))) ->
      compare_height Emptya sa ta (skip_black txa);
    (Branch _ _ _ _ _, (Emptya, (Emptya, Emptya))) -> GT;
    (Branch _ _ _ _ _, (Emptya, (Emptya, Branch _ _ _ _ _))) -> LT;
    (Branch _ _ _ _ _, (Emptya, (Branch _ _ _ _ _, Emptya))) -> EQ;
    (Branch _ _ _ _ _, (Emptya, (Branch _ _ _ _ _, Branch _ _ _ _ _))) -> LT;
    (Branch _ _ _ _ _, (Branch _ _ _ _ _, (Emptya, _))) -> GT;
    (Branch _ sxa _ _ _, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Emptya))) ->
      compare_height (skip_black sxa) sa ta Emptya;
    (Branch _ sxa _ _ _,
      (Branch _ sa _ _ _, (Branch _ ta _ _ _, Branch _ txa _ _ _)))
      -> compare_height (skip_black sxa) sa ta (skip_black txa);
  });

apfst :: forall a b c. (a -> b) -> (a, c) -> (b, c);
apfst f (x, y) = (f x, y);

rbtreeify_g :: forall a b. Nat -> [(a, b)] -> (Rbta a b, [(a, b)]);
rbtreeify_g n kvs =
  (if equal_nat n zero_nat || equal_nat n one_nat then (Emptya, kvs)
    else let {
           (na, r) = divmod_nat n (nat_of_integer (2 :: Integer));
         } in (if equal_nat r zero_nat
                then let {
                       (t1, (k, v) : kvsa) = rbtreeify_g na kvs;
                     } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)
                else let {
                       (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                     } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)));

rbtreeify_f :: forall a b. Nat -> [(a, b)] -> (Rbta a b, [(a, b)]);
rbtreeify_f n kvs =
  (if equal_nat n zero_nat then (Emptya, kvs)
    else (if equal_nat n one_nat then let {
((k, v) : kvsa) = kvs;
                                      } in (Branch R Emptya k v Emptya, kvsa)
           else let {
                  (na, r) = divmod_nat n (nat_of_integer (2 :: Integer));
                } in (if equal_nat r zero_nat
                       then let {
                              (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                            } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)
                       else let {
                              (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                            } in apfst (Branch B t1 k v)
                                   (rbtreeify_f na kvsa))));

rbtreeify :: forall a b. [(a, b)] -> Rbta a b;
rbtreeify kvs = fst (rbtreeify_g (suc (size_list kvs)) kvs);

gen_entries :: forall a b. [((a, b), Rbta a b)] -> Rbta a b -> [(a, b)];
gen_entries kvts (Branch c l k v r) = gen_entries (((k, v), r) : kvts) l;
gen_entries ((kv, t) : kvts) Emptya = kv : gen_entries kvts t;
gen_entries [] Emptya = [];

entries :: forall a b. Rbta a b -> [(a, b)];
entries = gen_entries [];

folda :: forall a b c. (a -> b -> c -> c) -> Rbta a b -> c -> c;
folda f (Branch c lt k v rt) x = folda f rt (f k v (folda f lt x));
folda f Emptya x = x;

rbt_comp_union_with_key ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_comp_union_with_key c f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> folda (rbt_comp_insert_with_key c (\ k v w -> f k w v)) t1 t2;
    GT -> folda (rbt_comp_insert_with_key c f) t2 t1;
    EQ -> rbtreeify (comp_sunion_with c f (entries t1) (entries t2));
  });

join ::
  forall a b.
    (Ccompare a) => (a -> b -> b -> b) ->
                      Mapping_rbt a b -> Mapping_rbt a b -> Mapping_rbt a b;
join xc xd xe =
  Mapping_RBTa
    (rbt_comp_union_with_key (the ccompare) xc (impl_ofb xd) (impl_ofb xe));

list_insert :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
list_insert equal x xs = (if list_member equal xs x then xs else x : xs);

insertc :: forall a. (Ceq a) => a -> Set_dlist a -> Set_dlist a;
insertc xb xc = Abs_dlist (list_insert (the ceq) xb (list_of_dlist xc));

foldc :: forall a b. (Ceq a) => (a -> b -> b) -> Set_dlist a -> b -> b;
foldc x xc = fold x (list_of_dlist xc);

union :: forall a. (Ceq a) => Set_dlist a -> Set_dlist a -> Set_dlist a;
union = foldc insertc;

inter_list ::
  forall a. (Ccompare a) => Mapping_rbt a () -> [a] -> Mapping_rbt a ();
inter_list xb xc =
  Mapping_RBTa
    (fold (\ k -> rbt_comp_insert (the ccompare) k ())
      (filter
        (\ x -> not (is_none (rbt_comp_lookup (the ccompare) (impl_ofb xb) x)))
        xc)
      Emptya);

filterc ::
  forall a b.
    (Ccompare a) => ((a, b) -> Bool) -> Mapping_rbt a b -> Mapping_rbt a b;
filterc xb xc = Mapping_RBTa (rbtreeify (filter xb (entries (impl_ofb xc))));

comp_sinter_with ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
comp_sinter_with c f ((ka, va) : asa) ((k, v) : bs) =
  (case c k ka of {
    Eqa -> (ka, f ka va v) : comp_sinter_with c f asa bs;
    Lt -> comp_sinter_with c f ((ka, va) : asa) bs;
    Gt -> comp_sinter_with c f asa ((k, v) : bs);
  });
comp_sinter_with c f [] uu = [];
comp_sinter_with c f uv [] = [];

map_filter :: forall a b. (a -> Maybe b) -> [a] -> [b];
map_filter f [] = [];
map_filter f (x : xs) = (case f x of {
                          Nothing -> map_filter f xs;
                          Just y -> y : map_filter f xs;
                        });

rbt_comp_inter_with_key ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_comp_inter_with_key c f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> rbtreeify
            (map_filter
              (\ (k, v) ->
                map_option (\ w -> (k, f k v w)) (rbt_comp_lookup c t2 k))
              (entries t1));
    GT -> rbtreeify
            (map_filter
              (\ (k, v) ->
                map_option (\ w -> (k, f k w v)) (rbt_comp_lookup c t1 k))
              (entries t2));
    EQ -> rbtreeify (comp_sinter_with c f (entries t1) (entries t2));
  });

meet ::
  forall a b.
    (Ccompare a) => (a -> b -> b -> b) ->
                      Mapping_rbt a b -> Mapping_rbt a b -> Mapping_rbt a b;
meet xc xd xe =
  Mapping_RBTa
    (rbt_comp_inter_with_key (the ccompare) xc (impl_ofb xd) (impl_ofb xe));

filterb :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Set_dlist a;
filterb xb xc = Abs_dlist (filter xb (list_of_dlist xc));

inf_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
inf_set (RBT_set rbt1) (Set_Monad xs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set Set_Monad: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (Set_Monad xs));
    Just _ -> RBT_set (inter_list rbt1 xs);
  });
inf_set (RBT_set rbt) (DList_set dxs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set DList_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "inter RBT_set DList_set: ceq = None"
            (\ _ -> inf_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (inter_list rbt (list_of_dlist dxs));
      });
  });
inf_set (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set RBT_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (RBT_set rbt2));
    Just _ -> RBT_set (meet (\ _ _ -> id) rbt1 rbt2);
  });
inf_set (DList_set dxs1) (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set Set_Monad: ceq = None"
        (\ _ -> inf_set (DList_set dxs1) (Set_Monad xs));
    Just eq -> DList_set (filterb (list_member eq xs) dxs1);
  });
inf_set (DList_set dxs1) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set DList_set: ceq = None"
        (\ _ -> inf_set (DList_set dxs1) (DList_set dxs2));
    Just _ -> DList_set (filterb (memberc dxs2) dxs1);
  });
inf_set (DList_set dxs) (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set RBT_set: ccompare = None"
        (\ _ -> inf_set (DList_set dxs) (RBT_set rbt));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "inter DList_set RBT_set: ceq = None"
            (\ _ -> inf_set (DList_set dxs) (RBT_set rbt));
        Just _ -> RBT_set (inter_list rbt (list_of_dlist dxs));
      });
  });
inf_set (Set_Monad xs1) (Set_Monad xs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad Set_Monad: ceq = None"
        (\ _ -> inf_set (Set_Monad xs1) (Set_Monad xs2));
    Just eq -> Set_Monad (filter (list_member eq xs2) xs1);
  });
inf_set (Set_Monad xs) (DList_set dxs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad DList_set: ceq = None"
        (\ _ -> inf_set (Set_Monad xs) (DList_set dxs2));
    Just eq -> DList_set (filterb (list_member eq xs) dxs2);
  });
inf_set (Set_Monad xs) (RBT_set rbt1) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad RBT_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (Set_Monad xs));
    Just _ -> RBT_set (inter_list rbt1 xs);
  });
inf_set (Complement ba) (Complement b) = Complement (sup_set ba b);
inf_set g (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set2: ccompare = None" (\ _ -> inf_set g (RBT_set rbt2));
    Just _ -> RBT_set (filterc ((\ x -> member x g) . fst) rbt2);
  });
inf_set (RBT_set rbt1) g =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set1: ccompare = None" (\ _ -> inf_set (RBT_set rbt1) g);
    Just _ -> RBT_set (filterc ((\ x -> member x g) . fst) rbt1);
  });
inf_set h (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set2: ceq = None" (\ _ -> inf_set h (DList_set dxs2));
    Just _ -> DList_set (filterb (\ x -> member x h) dxs2);
  });
inf_set (DList_set dxs1) h =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set1: ceq = None" (\ _ -> inf_set (DList_set dxs1) h);
    Just _ -> DList_set (filterb (\ x -> member x h) dxs1);
  });
inf_set i (Set_Monad xs) = Set_Monad (filter (\ x -> member x i) xs);
inf_set (Set_Monad xs) i = Set_Monad (filter (\ x -> member x i) xs);
inf_set j (Collect_set a) = Collect_set (\ x -> a x && member x j);
inf_set (Collect_set a) j = Collect_set (\ x -> a x && member x j);

sup_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
sup_set ba (Complement b) = Complement (inf_set (uminus_set ba) b);
sup_set (Complement ba) b = Complement (inf_set ba (uminus_set b));
sup_set b (Collect_set a) = Collect_set (\ x -> a x || member x b);
sup_set (Collect_set a) b = Collect_set (\ x -> a x || member x b);
sup_set (Set_Monad xs) (Set_Monad ys) = Set_Monad (xs ++ ys);
sup_set (DList_set dxs1) (Set_Monad ws) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set Set_Monad: ceq = None"
        (\ _ -> sup_set (DList_set dxs1) (Set_Monad ws));
    Just _ -> DList_set (fold insertc ws dxs1);
  });
sup_set (Set_Monad ws) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union Set_Monad DList_set: ceq = None"
        (\ _ -> sup_set (Set_Monad ws) (DList_set dxs2));
    Just _ -> DList_set (fold insertc ws dxs2);
  });
sup_set (RBT_set rbt1) (Set_Monad zs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set Set_Monad: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt1) (Set_Monad zs));
    Just _ -> RBT_set (fold (\ k -> inserte k ()) zs rbt1);
  });
sup_set (Set_Monad zs) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union Set_Monad RBT_set: ccompare = None"
        (\ _ -> sup_set (Set_Monad zs) (RBT_set rbt2));
    Just _ -> RBT_set (fold (\ k -> inserte k ()) zs rbt2);
  });
sup_set (DList_set dxs1) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set DList_set: ceq = None"
        (\ _ -> sup_set (DList_set dxs1) (DList_set dxs2));
    Just _ -> DList_set (union dxs1 dxs2);
  });
sup_set (DList_set dxs) (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set RBT_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "union DList_set RBT_set: ceq = None"
            (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (foldc (\ k -> inserte k ()) dxs rbt);
      });
  });
sup_set (RBT_set rbt) (DList_set dxs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set DList_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "union RBT_set DList_set: ceq = None"
            (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (foldc (\ k -> inserte k ()) dxs rbt);
      });
  });
sup_set (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set RBT_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt1) (RBT_set rbt2));
    Just _ -> RBT_set (join (\ _ _ -> id) rbt1 rbt2);
  });

instance (Ceq a, Ccompare a) => Inf (Set a) where {
  inf = inf_set;
};

instance (Ceq a, Ccompare a) => Sup (Set a) where {
  sup = sup_set;
};

less_set :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
less_set a b = less_eq_set a b && not (less_eq_set b a);

instance (Cenum a, Ceq a, Ccompare a) => Ord (Set a) where {
  less_eq = less_eq_set;
  less = less_set;
};

instance (Cenum a, Ceq a, Ccompare a) => Quasi_order (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Weak_order (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Preorder (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Order (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Semilattice_sup (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Semilattice_inf (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Lattice (Set a) where {
};

list_all2_fusion ::
  forall a b c d.
    (a -> b -> Bool) -> Generator a c -> Generator b d -> c -> d -> Bool;
list_all2_fusion p g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 && let {
                             (x, s1a) = next g1 s1;
                             (y, s2a) = next g2 s2;
                           } in p x y && list_all2_fusion p g1 g2 s1a s2a
    else not (has_next g2 s2));

set_eq :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
set_eq (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_eq RBT_set RBT_set: ccompare = None"
        (\ _ -> set_eq (RBT_set rbt1) (RBT_set rbt2));
    Just c ->
      (case ceq of {
        Nothing ->
          list_all2_fusion (\ x y -> equal_order (c x y) Eqa) rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
        Just eq ->
          list_all2_fusion eq rbt_keys_generator rbt_keys_generator (init rbt1)
            (init rbt2);
      });
  });
set_eq (Complement a) (Complement b) = set_eq a b;
set_eq a b = less_eq_set a b && less_eq_set b a;

ceq_set ::
  forall a. (Cenum a, Ceq a, Ccompare a) => Maybe (Set a -> Set a -> Bool);
ceq_set = (case (ceq :: Maybe (a -> a -> Bool)) of {
            Nothing -> Nothing;
            Just _ -> Just set_eq;
          });

instance (Cenum a, Ceq a, Ccompare a) => Ceq (Set a) where {
  ceq = ceq_set;
};

set_impl_set :: forall a. Phantom (Set a) Set_impla;
set_impl_set = Phantom Set_Choose;

instance Set_impl (Set a) where {
  set_impl = set_impl_set;
};

sublists :: forall a. [a] -> [[a]];
sublists [] = [[]];
sublists (x : xs) = let {
                      xss = sublists xs;
                    } in map (\ a -> x : a) xss ++ xss;

of_phantom :: forall a b. Phantom a b -> b;
of_phantom (Phantom x) = x;

emptye :: forall a b. (Ccompare a) => Mapping_rbt a b;
emptye = Mapping_RBTa Emptya;

emptyc :: forall a. (Ceq a) => Set_dlist a;
emptyc = Abs_dlist [];

set_empty_choose :: forall a. (Ceq a, Ccompare a) => Set a;
set_empty_choose = (case (ccompare :: Maybe (a -> a -> Ordera)) of {
                     Nothing -> (case (ceq :: Maybe (a -> a -> Bool)) of {
                                  Nothing -> Set_Monad [];
                                  Just _ -> DList_set emptyc;
                                });
                     Just _ -> RBT_set emptye;
                   });

set_empty :: forall a. (Ceq a, Ccompare a) => Set_impla -> Set a;
set_empty Set_Choose = set_empty_choose;
set_empty Set_Monada = Set_Monad [];
set_empty Set_RBT = RBT_set emptye;
set_empty Set_DList = DList_set emptyc;
set_empty Set_Collect = Collect_set (\ _ -> False);

fun_upda :: forall a b. (a -> a -> Bool) -> (a -> b) -> a -> b -> a -> b;
fun_upda equal f aa b a = (if equal aa a then b else f a);

balance_right :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance_right a k x (Branch R b s y c) = Branch R a k x (Branch B b s y c);
balance_right (Branch B a k x b) s y Emptya =
  balance (Branch R a k x b) s y Emptya;
balance_right (Branch B a k x b) s y (Branch B va vb vc vd) =
  balance (Branch R a k x b) s y (Branch B va vb vc vd);
balance_right (Branch R a k x (Branch B b s y c)) t z Emptya =
  Branch R (balance (paint R a) k x b) s y (Branch B c t z Emptya);
balance_right (Branch R a k x (Branch B b s y c)) t z (Branch B va vb vc vd) =
  Branch R (balance (paint R a) k x b) s y
    (Branch B c t z (Branch B va vb vc vd));
balance_right Emptya k x Emptya = Emptya;
balance_right (Branch R va vb vc Emptya) k x Emptya = Emptya;
balance_right (Branch R va vb vc (Branch R ve vf vg vh)) k x Emptya = Emptya;
balance_right Emptya k x (Branch B va vb vc vd) = Emptya;
balance_right (Branch R ve vf vg Emptya) k x (Branch B va vb vc vd) = Emptya;
balance_right (Branch R ve vf vg (Branch R vi vj vk vl)) k x
  (Branch B va vb vc vd) = Emptya;

balance_left :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance_left (Branch R a k x b) s y c = Branch R (Branch B a k x b) s y c;
balance_left Emptya k x (Branch B a s y b) =
  balance Emptya k x (Branch R a s y b);
balance_left (Branch B va vb vc vd) k x (Branch B a s y b) =
  balance (Branch B va vb vc vd) k x (Branch R a s y b);
balance_left Emptya k x (Branch R (Branch B a s y b) t z c) =
  Branch R (Branch B Emptya k x a) s y (balance b t z (paint R c));
balance_left (Branch B va vb vc vd) k x (Branch R (Branch B a s y b) t z c) =
  Branch R (Branch B (Branch B va vb vc vd) k x a) s y
    (balance b t z (paint R c));
balance_left Emptya k x Emptya = Emptya;
balance_left Emptya k x (Branch R Emptya vb vc vd) = Emptya;
balance_left Emptya k x (Branch R (Branch R ve vf vg vh) vb vc vd) = Emptya;
balance_left (Branch B va vb vc vd) k x Emptya = Emptya;
balance_left (Branch B va vb vc vd) k x (Branch R Emptya vf vg vh) = Emptya;
balance_left (Branch B va vb vc vd) k x
  (Branch R (Branch R vi vj vk vl) vf vg vh) = Emptya;

combine :: forall a b. Rbta a b -> Rbta a b -> Rbta a b;
combine Emptya x = x;
combine (Branch v va vb vc vd) Emptya = Branch v va vb vc vd;
combine (Branch R a k x b) (Branch R c s y d) =
  (case combine b c of {
    Emptya -> Branch R a k x (Branch R Emptya s y d);
    Branch R b2 t z c2 -> Branch R (Branch R a k x b2) t z (Branch R c2 s y d);
    Branch B b2 t z c2 -> Branch R a k x (Branch R (Branch B b2 t z c2) s y d);
  });
combine (Branch B a k x b) (Branch B c s y d) =
  (case combine b c of {
    Emptya -> balance_left a k x (Branch B Emptya s y d);
    Branch R b2 t z c2 -> Branch R (Branch B a k x b2) t z (Branch B c2 s y d);
    Branch B b2 t z c2 ->
      balance_left a k x (Branch B (Branch B b2 t z c2) s y d);
  });
combine (Branch B va vb vc vd) (Branch R b k x c) =
  Branch R (combine (Branch B va vb vc vd) b) k x c;
combine (Branch R a k x b) (Branch B va vb vc vd) =
  Branch R a k x (combine b (Branch B va vb vc vd));

rbt_comp_del :: forall a b. (a -> a -> Ordera) -> a -> Rbta a b -> Rbta a b;
rbt_comp_del c x Emptya = Emptya;
rbt_comp_del c x (Branch uu a y s b) =
  (case c x y of {
    Eqa -> combine a b;
    Lt -> rbt_comp_del_from_left c x a y s b;
    Gt -> rbt_comp_del_from_right c x a y s b;
  });

rbt_comp_del_from_left ::
  forall a b.
    (a -> a -> Ordera) -> a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_del_from_left c x (Branch B lt z v rt) y s b =
  balance_left (rbt_comp_del c x (Branch B lt z v rt)) y s b;
rbt_comp_del_from_left c x Emptya y s b =
  Branch R (rbt_comp_del c x Emptya) y s b;
rbt_comp_del_from_left c x (Branch R va vb vc vd) y s b =
  Branch R (rbt_comp_del c x (Branch R va vb vc vd)) y s b;

rbt_comp_del_from_right ::
  forall a b.
    (a -> a -> Ordera) -> a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_del_from_right c x a y s (Branch B lt z v rt) =
  balance_right a y s (rbt_comp_del c x (Branch B lt z v rt));
rbt_comp_del_from_right c x a y s Emptya =
  Branch R a y s (rbt_comp_del c x Emptya);
rbt_comp_del_from_right c x a y s (Branch R va vb vc vd) =
  Branch R a y s (rbt_comp_del c x (Branch R va vb vc vd));

rbt_comp_delete :: forall a b. (a -> a -> Ordera) -> a -> Rbta a b -> Rbta a b;
rbt_comp_delete c k t = paint B (rbt_comp_del c k t);

deletea :: forall a b. (Ccompare a) => a -> Mapping_rbt a b -> Mapping_rbt a b;
deletea xb xc = Mapping_RBTa (rbt_comp_delete (the ccompare) xb (impl_ofb xc));

list_remove1 :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
list_remove1 equal x (y : xs) =
  (if equal x y then xs else y : list_remove1 equal x xs);
list_remove1 equal x [] = [];

removea :: forall a. (Ceq a) => a -> Set_dlist a -> Set_dlist a;
removea xb xc = Abs_dlist (list_remove1 (the ceq) xb (list_of_dlist xc));

inserta :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Set a;
inserta xa (Complement x) = Complement (remove xa x);
inserta x (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert RBT_set: ccompare = None" (\ _ -> inserta x (RBT_set rbt));
    Just _ -> RBT_set (inserte x () rbt);
  });
inserta x (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert DList_set: ceq = None" (\ _ -> inserta x (DList_set dxs));
    Just _ -> DList_set (insertc x dxs);
  });
inserta x (Set_Monad xs) = Set_Monad (x : xs);
inserta x (Collect_set a) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert Collect_set: ceq = None" (\ _ -> inserta x (Collect_set a));
    Just eq -> Collect_set (fun_upda eq a x True);
  });

remove :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Set a;
remove x (Complement a) = Complement (inserta x a);
remove x (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "remove RBT_set: ccompare = None" (\ _ -> remove x (RBT_set rbt));
    Just _ -> RBT_set (deletea x rbt);
  });
remove x (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "remove DList_set: ceq = None" (\ _ -> remove x (DList_set dxs));
    Just _ -> DList_set (removea x dxs);
  });
remove x (Collect_set a) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "remove Collect: ceq = None"
        (\ _ -> remove x (Collect_set a));
    Just eq -> Collect_set (fun_upda eq a x False);
  });

set_aux :: forall a. (Ceq a, Ccompare a) => Set_impla -> [a] -> Set a;
set_aux Set_Monada = Set_Monad;
set_aux Set_Choose =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing -> (case (ceq :: Maybe (a -> a -> Bool)) of {
                 Nothing -> Set_Monad;
                 Just _ -> foldl (\ s x -> inserta x s) (DList_set emptyc);
               });
    Just _ -> foldl (\ s x -> inserta x s) (RBT_set emptye);
  });
set_aux impl = foldl (\ s x -> inserta x s) (set_empty impl);

set :: forall a. (Ceq a, Ccompare a, Set_impl a) => [a] -> Set a;
set xs = set_aux (of_phantom (set_impl :: Phantom a Set_impla)) xs;

cEnum_set ::
  forall a.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Maybe ([Set a],
                             ((Set a -> Bool) -> Bool,
                               (Set a -> Bool) -> Bool));
cEnum_set =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (_, _)) ->
      Just (map set (sublists enum_a),
             ((\ p -> all p (map set (sublists enum_a))),
               (\ p -> any p (map set (sublists enum_a)))));
  });

instance (Cenum a, Ceq a, Ccompare a, Set_impl a) => Cenum (Set a) where {
  cEnum = cEnum_set;
};

finite_UNIV_set :: forall a. (Finite_UNIV a) => Phantom (Set a) Bool;
finite_UNIV_set = Phantom (of_phantom (finite_UNIV :: Phantom a Bool));

instance (Finite_UNIV a) => Finite_UNIV (Set a) where {
  finite_UNIV = finite_UNIV_set;
};

set_less_eq_aux_Compl_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
set_less_eq_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then let {
                  (x, s1a) = next g1 s1;
                  (y, s2a) = next g2 s2;
                } in (if less x y
                       then proper_interval ao (Just x) ||
                              set_less_eq_aux_Compl_fusion less proper_interval
                                g1 g2 (Just x) s1a s2
                       else (if less y x
                              then proper_interval ao (Just y) ||
                                     set_less_eq_aux_Compl_fusion less
                                       proper_interval g1 g2 (Just y) s1 s2a
                              else proper_interval ao (Just y)))
           else True)
    else True);

compl_set_less_eq_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
compl_set_less_eq_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then not (proper_interval ao (Just x)) &&
                                   compl_set_less_eq_aux_fusion less
                                     proper_interval g1 g2 (Just x) s1a s2
                            else (if less y x
                                   then not (proper_interval ao (Just y)) &&
  compl_set_less_eq_aux_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                   else not (proper_interval ao (Just y))))
                else not (proper_interval ao (Just x)) &&
                       compl_set_less_eq_aux_fusion less proper_interval g1 g2
                         (Just x) s1a s2)
    else (if has_next g2 s2
           then let {
                  (y, s2a) = next g2 s2;
                } in not (proper_interval ao (Just y)) &&
                       compl_set_less_eq_aux_fusion less proper_interval g1 g2
                         (Just y) s1 s2a
           else not (proper_interval ao Nothing)));

set_less_eq_aux_Compl ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
set_less_eq_aux_Compl less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           set_less_eq_aux_Compl less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  set_less_eq_aux_Compl less proper_interval (Just y) (x : xs)
                    ys
           else proper_interval ao (Just y)));
set_less_eq_aux_Compl less proper_interval ao xs [] = True;
set_less_eq_aux_Compl less proper_interval ao [] ys = True;

compl_set_less_eq_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
compl_set_less_eq_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           compl_set_less_eq_aux less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  compl_set_less_eq_aux less proper_interval (Just y) (x : xs)
                    ys
           else not (proper_interval ao (Just y))));
compl_set_less_eq_aux less proper_interval ao (x : xs) [] =
  not (proper_interval ao (Just x)) &&
    compl_set_less_eq_aux less proper_interval (Just x) xs [];
compl_set_less_eq_aux less proper_interval ao [] (y : ys) =
  not (proper_interval ao (Just y)) &&
    compl_set_less_eq_aux less proper_interval (Just y) [] ys;
compl_set_less_eq_aux less proper_interval ao [] [] =
  not (proper_interval ao Nothing);

lexord_eq_fusion ::
  forall a b c.
    (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
lexord_eq_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 &&
           let {
             (x, s1a) = next g1 s1;
             (y, s2a) = next g2 s2;
           } in less x y ||
                  not (less y x) && lexord_eq_fusion less g1 g2 s1a s2a
    else True);

remdups_sorted :: forall a. (a -> a -> Bool) -> [a] -> [a];
remdups_sorted less (x : y : xs) =
  (if less x y then x : remdups_sorted less (y : xs)
    else remdups_sorted less (y : xs));
remdups_sorted less [x] = [x];
remdups_sorted less [] = [];

quicksort_acc :: forall a. (a -> a -> Bool) -> [a] -> [a] -> [a];
quicksort_acc less ac (x : v : va) = quicksort_part less ac x [] [] [] (v : va);
quicksort_acc less ac [x] = x : ac;
quicksort_acc less ac [] = ac;

quicksort_part ::
  forall a. (a -> a -> Bool) -> [a] -> a -> [a] -> [a] -> [a] -> [a] -> [a];
quicksort_part less ac x lts eqs gts (z : zs) =
  (if less x z then quicksort_part less ac x lts eqs (z : gts) zs
    else (if less z x then quicksort_part less ac x (z : lts) eqs gts zs
           else quicksort_part less ac x lts (z : eqs) gts zs));
quicksort_part less ac x lts eqs gts [] =
  quicksort_acc less (eqs ++ x : quicksort_acc less ac gts) lts;

quicksort :: forall a. (a -> a -> Bool) -> [a] -> [a];
quicksort less = quicksort_acc less [];

gen_keys :: forall a b. [(a, Rbta a b)] -> Rbta a b -> [a];
gen_keys kts (Branch c l k v r) = gen_keys ((k, r) : kts) l;
gen_keys ((k, t) : kts) Emptya = k : gen_keys kts t;
gen_keys [] Emptya = [];

keys :: forall a b. Rbta a b -> [a];
keys = gen_keys [];

keysa :: forall a. (Ccompare a) => Mapping_rbt a () -> [a];
keysa xa = keys (impl_ofb xa);

csorted_list_of_set :: forall a. (Ceq a, Ccompare a) => Set a -> [a];
csorted_list_of_set (Set_Monad xs) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set Set_Monad: ccompare = None"
        (\ _ -> csorted_list_of_set (Set_Monad xs));
    Just c -> remdups_sorted (lt_of_comp c) (quicksort (lt_of_comp c) xs);
  });
csorted_list_of_set (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set DList_set: ceq = None"
        (\ _ -> csorted_list_of_set (DList_set dxs));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "csorted_list_of_set DList_set: ccompare = None"
            (\ _ -> csorted_list_of_set (DList_set dxs));
        Just c -> quicksort (lt_of_comp c) (list_of_dlist dxs);
      });
  });
csorted_list_of_set (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set RBT_set: ccompare = None"
        (\ _ -> csorted_list_of_set (RBT_set rbt));
    Just _ -> keysa rbt;
  });

bot_set :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set a;
bot_set = set_empty (of_phantom (set_impl :: Phantom a Set_impla));

top_set :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set a;
top_set = uminus_set bot_set;

le_of_comp :: forall a. (a -> a -> Ordera) -> a -> a -> Bool;
le_of_comp acomp x y = (case acomp x y of {
                         Eqa -> True;
                         Lt -> True;
                         Gt -> False;
                       });

lexordp_eq :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
lexordp_eq less (x : xs) (y : ys) =
  less x y || not (less y x) && lexordp_eq less xs ys;
lexordp_eq less (x : xs) [] = False;
lexordp_eq less xs [] = null xs;
lexordp_eq less [] ys = True;

finite :: forall a. (Finite_UNIV a, Ceq a, Ccompare a) => Set a -> Bool;
finite (Collect_set p) =
  of_phantom (finite_UNIV :: Phantom a Bool) ||
    (error :: forall a. String -> (() -> a) -> a) "finite Collect_set"
      (\ _ -> finite (Collect_set p));
finite (Set_Monad xs) = True;
finite (Complement a) =
  (if of_phantom (finite_UNIV :: Phantom a Bool) then True
    else (if finite a then False
           else (error :: forall a. String -> (() -> a) -> a)
                  "finite Complement: infinite set"
                  (\ _ -> finite (Complement a))));
finite (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "finite RBT_set: ccompare = None" (\ _ -> finite (RBT_set rbt));
    Just _ -> True;
  });
finite (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "finite DList_set: ceq = None" (\ _ -> finite (DList_set dxs));
    Just _ -> True;
  });

set_less_aux_Compl_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
set_less_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then proper_interval ao (Just x) ||
                                   set_less_aux_Compl_fusion less
                                     proper_interval g1 g2 (Just x) s1a s2
                            else (if less y x
                                   then proper_interval ao (Just y) ||
  set_less_aux_Compl_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                   else proper_interval ao (Just y)))
                else proper_interval ao (Just x) ||
                       set_less_aux_Compl_fusion less proper_interval g1 g2
                         (Just x) s1a s2)
    else (if has_next g2 s2
           then let {
                  (y, s2a) = next g2 s2;
                } in proper_interval ao (Just y) ||
                       set_less_aux_Compl_fusion less proper_interval g1 g2
                         (Just y) s1 s2a
           else proper_interval ao Nothing));

compl_set_less_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
compl_set_less_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 &&
    has_next g2 s2 &&
      let {
        (x, s1a) = next g1 s1;
        (y, s2a) = next g2 s2;
      } in (if less x y
             then not (proper_interval ao (Just x)) &&
                    compl_set_less_aux_fusion less proper_interval g1 g2
                      (Just x) s1a s2
             else (if less y x
                    then not (proper_interval ao (Just y)) &&
                           compl_set_less_aux_fusion less proper_interval g1 g2
                             (Just y) s1 s2a
                    else not (proper_interval ao (Just y))));

set_less_aux_Compl ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
set_less_aux_Compl less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           set_less_aux_Compl less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  set_less_aux_Compl less proper_interval (Just y) (x : xs) ys
           else proper_interval ao (Just y)));
set_less_aux_Compl less proper_interval ao (x : xs) [] =
  proper_interval ao (Just x) ||
    set_less_aux_Compl less proper_interval (Just x) xs [];
set_less_aux_Compl less proper_interval ao [] (y : ys) =
  proper_interval ao (Just y) ||
    set_less_aux_Compl less proper_interval (Just y) [] ys;
set_less_aux_Compl less proper_interval ao [] [] = proper_interval ao Nothing;

compl_set_less_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
compl_set_less_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           compl_set_less_aux less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  compl_set_less_aux less proper_interval (Just y) (x : xs) ys
           else not (proper_interval ao (Just y))));
compl_set_less_aux less proper_interval ao xs [] = False;
compl_set_less_aux less proper_interval ao [] ys = False;

lexord_fusion ::
  forall a b c.
    (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
lexord_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then let {
                  (x, s1a) = next g1 s1;
                  (y, s2a) = next g2 s2;
                } in less x y ||
                       not (less y x) && lexord_fusion less g1 g2 s1a s2a
           else False)
    else has_next g2 s2);

lexordp :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
lexordp less (x : xs) (y : ys) =
  less x y || not (less y x) && lexordp less xs ys;
lexordp less xs [] = False;
lexordp less [] ys = not (null ys);

comp_of_ords ::
  forall a. (a -> a -> Bool) -> (a -> a -> Bool) -> a -> a -> Ordera;
comp_of_ords le lt x y = (if lt x y then Lt else (if le x y then Eqa else Gt));

ccompare_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Maybe (Set a -> Set a -> Ordera);
ccompare_set = (case (ccompare :: Maybe (a -> a -> Ordera)) of {
                 Nothing -> Nothing;
                 Just _ -> Just (comp_of_ords cless_eq_set cless_set);
               });

cless_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Set a -> Set a -> Bool;
cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ -> cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        compl_set_less_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set RBT_set (Complement RBT_set): ccompare = None"
        (\ _ -> cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)));
    Just c ->
      (if (finite :: Set a -> Bool) (top_set :: Set a)
        then set_less_aux_Compl_fusion (lt_of_comp c) cproper_interval
               rbt_keys_generator rbt_keys_generator Nothing (init rbt1)
               (init rbt2)
        else True);
  });
cless_set (RBT_set rbta) (RBT_set rbt) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set RBT_set RBT_set: ccompare = None"
        (\ _ -> cless_set (RBT_set rbta) (RBT_set rbt));
    Just c ->
      lexord_fusion (\ x y -> lt_of_comp c y x) rbt_keys_generator
        rbt_keys_generator (init rbta) (init rbt);
  });
cless_set (Complement a) (Complement b) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement Complement: ccompare = None"
        (\ _ -> cless_set (Complement a) (Complement b));
    Just _ -> lt_of_comp (the ccompare_set) b a;
  });
cless_set (Complement a) b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement1: ccompare = None"
        (\ _ -> cless_set (Complement a) b);
    Just c ->
      (if finite a && finite b
        then (finite :: Set a -> Bool) (top_set :: Set a) &&
               compl_set_less_aux (lt_of_comp c) cproper_interval Nothing
                 (csorted_list_of_set a) (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set Complement1: infinite set"
               (\ _ -> cless_set (Complement a) b));
  });
cless_set a (Complement b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement2: ccompare = None"
        (\ _ -> cless_set a (Complement b));
    Just c ->
      (if finite a && finite b
        then (if (finite :: Set a -> Bool) (top_set :: Set a)
               then set_less_aux_Compl (lt_of_comp c) cproper_interval Nothing
                      (csorted_list_of_set a) (csorted_list_of_set b)
               else True)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set Complement2: infinite set"
               (\ _ -> cless_set a (Complement b)));
  });
cless_set a b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "cless_set: ccompare = None"
        (\ _ -> cless_set a b);
    Just c ->
      (if finite a && finite b
        then lexordp (\ x y -> lt_of_comp c y x) (csorted_list_of_set a)
               (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set: infinite set" (\ _ -> cless_set a b));
  });

cless_eq_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Set a -> Set a -> Bool;
cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ -> cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        compl_set_less_eq_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set RBT_set (Complement RBT_set): ccompare = None"
        (\ _ -> cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)));
    Just c ->
      (if (finite :: Set a -> Bool) (top_set :: Set a)
        then set_less_eq_aux_Compl_fusion (lt_of_comp c) cproper_interval
               rbt_keys_generator rbt_keys_generator Nothing (init rbt1)
               (init rbt2)
        else True);
  });
cless_eq_set (RBT_set rbta) (RBT_set rbt) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set RBT_set RBT_set: ccompare = None"
        (\ _ -> cless_eq_set (RBT_set rbta) (RBT_set rbt));
    Just c ->
      lexord_eq_fusion (\ x y -> lt_of_comp c y x) rbt_keys_generator
        rbt_keys_generator (init rbta) (init rbt);
  });
cless_eq_set (Complement a) (Complement b) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement Complement: ccompare = None"
        (\ _ -> le_of_comp (the ccompare_set) (Complement a) (Complement b));
    Just _ -> cless_eq_set b a;
  });
cless_eq_set (Complement a) b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement1: ccompare = None"
        (\ _ -> cless_eq_set (Complement a) b);
    Just c ->
      (if finite a && finite b
        then (finite :: Set a -> Bool) (top_set :: Set a) &&
               compl_set_less_eq_aux (lt_of_comp c) cproper_interval Nothing
                 (csorted_list_of_set a) (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set Complement1: infinite set"
               (\ _ -> cless_eq_set (Complement a) b));
  });
cless_eq_set a (Complement b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement2: ccompare = None"
        (\ _ -> cless_eq_set a (Complement b));
    Just c ->
      (if finite a && finite b
        then (if (finite :: Set a -> Bool) (top_set :: Set a)
               then set_less_eq_aux_Compl (lt_of_comp c) cproper_interval
                      Nothing (csorted_list_of_set a) (csorted_list_of_set b)
               else True)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set Complement2: infinite set"
               (\ _ -> cless_eq_set a (Complement b)));
  });
cless_eq_set a b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set: ccompare = None" (\ _ -> cless_eq_set a b);
    Just c ->
      (if finite a && finite b
        then lexordp_eq (\ x y -> lt_of_comp c y x) (csorted_list_of_set a)
               (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set: infinite set" (\ _ -> cless_eq_set a b));
  });

instance (Finite_UNIV a, Ceq a, Cproper_interval a,
           Set_impl a) => Ccompare (Set a) where {
  ccompare = ccompare_set;
};

fold_fusion :: forall a b c. Generator a b -> (a -> c -> c) -> b -> c -> c;
fold_fusion g f s b =
  (if has_next g s then let {
                          (x, sa) = next g s;
                        } in fold_fusion g f sa (f x b)
    else b);

length_last_fusion :: forall a b. Generator a b -> b -> (Nat, a);
length_last_fusion g s =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in fold_fusion g (\ xa (n, _) -> (plus_nat n one_nat, xa)) sa
                (one_nat, x)
    else (zero_nat, error "undefined"));

gen_length_fusion :: forall a b. Generator a b -> Nat -> b -> Nat;
gen_length_fusion g n s =
  (if has_next g s then gen_length_fusion g (suc n) (snd (next g s)) else n);

length_fusion :: forall a b. Generator a b -> b -> Nat;
length_fusion g = gen_length_fusion g zero_nat;

card_UNIV :: forall a. (Card_UNIV a) => Phantom a Nat;
card_UNIV = card_UNIVa;

proper_interval_set_Compl_aux_fusion ::
  forall a b c.
    (Card_UNIV a) => (a -> a -> Bool) ->
                       (Maybe a -> Maybe a -> Bool) ->
                         Generator a b ->
                           Generator a c -> Maybe a -> Nat -> b -> c -> Bool;
proper_interval_set_Compl_aux_fusion less proper_interval g1 g2 ao n s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then proper_interval ao (Just x) ||
                                   proper_interval_set_Compl_aux_fusion less
                                     proper_interval g1 g2 (Just x)
                                     (plus_nat n one_nat) s1a s2
                            else (if less y x
                                   then proper_interval ao (Just y) ||
  proper_interval_set_Compl_aux_fusion less proper_interval g1 g2 (Just y)
    (plus_nat n one_nat) s1 s2a
                                   else proper_interval ao (Just x) &&
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
  } in not (equal_nat (minus_nat m (length_fusion g2 s2a))
             (nat_of_integer (2 :: Integer))) ||
         not (equal_nat (minus_nat m (length_fusion g1 s1a))
               (nat_of_integer (2 :: Integer)))))
                else let {
                       m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat))
                             n;
                       (len_x, xa) = length_last_fusion g1 s1;
                     } in not (equal_nat m len_x) &&
                            (if equal_nat m (plus_nat len_x one_nat)
                              then not (proper_interval (Just xa) Nothing)
                              else True))
    else (if has_next g2 s2
           then let {
                  (_, _) = next g2 s2;
                  m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                  (len_y, y) = length_last_fusion g2 s2;
                } in not (equal_nat m len_y) &&
                       (if equal_nat m (plus_nat len_y one_nat)
                         then not (proper_interval (Just y) Nothing) else True)
           else less_nat (plus_nat n one_nat)
                  (of_phantom (card_UNIV :: Phantom a Nat))));

proper_interval_Compl_set_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
proper_interval_Compl_set_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 &&
    has_next g2 s2 &&
      let {
        (x, s1a) = next g1 s1;
        (y, s2a) = next g2 s2;
      } in (if less x y
             then not (proper_interval ao (Just x)) &&
                    proper_interval_Compl_set_aux_fusion less proper_interval g1
                      g2 (Just x) s1a s2
             else (if less y x
                    then not (proper_interval ao (Just y)) &&
                           proper_interval_Compl_set_aux_fusion less
                             proper_interval g1 g2 (Just y) s1 s2a
                    else not (proper_interval ao (Just x)) &&
                           (has_next g2 s2a || has_next g1 s1a)));

exhaustive_above_fusion ::
  forall a b. (Maybe a -> Maybe a -> Bool) -> Generator a b -> a -> b -> Bool;
exhaustive_above_fusion proper_interval g y s =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in not (proper_interval (Just y) (Just x)) &&
                exhaustive_above_fusion proper_interval g x sa
    else not (proper_interval (Just y) Nothing));

proper_interval_set_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> b -> c -> Bool;
proper_interval_set_aux_fusion less proper_interval g1 g2 s1 s2 =
  has_next g2 s2 &&
    let {
      (y, s2a) = next g2 s2;
    } in (if has_next g1 s1
           then let {
                  (x, s1a) = next g1 s1;
                } in (if less x y then False
                       else (if less y x
                              then proper_interval (Just y) (Just x) ||
                                     (has_next g2 s2a ||
                                       not
 (exhaustive_above_fusion proper_interval g1 x s1a))
                              else proper_interval_set_aux_fusion less
                                     proper_interval g1 g2 s1a s2a))
           else has_next g2 s2a || proper_interval (Just y) Nothing);

length_last :: forall a. [a] -> (Nat, a);
length_last (x : xs) =
  fold (\ xa (n, _) -> (plus_nat n one_nat, xa)) xs (one_nat, x);
length_last [] = (zero_nat, error "undefined");

proper_interval_set_Compl_aux ::
  forall a.
    (Card_UNIV a) => (a -> a -> Bool) ->
                       (Maybe a -> Maybe a -> Bool) ->
                         Maybe a -> Nat -> [a] -> [a] -> Bool;
proper_interval_set_Compl_aux less proper_interval ao n (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           proper_interval_set_Compl_aux less proper_interval (Just x)
             (plus_nat n one_nat) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  proper_interval_set_Compl_aux less proper_interval (Just y)
                    (plus_nat n one_nat) (x : xs) ys
           else proper_interval ao (Just x) &&
                  let {
                    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                  } in not (equal_nat (minus_nat m (size_list ys))
                             (nat_of_integer (2 :: Integer))) ||
                         not (equal_nat (minus_nat m (size_list xs))
                               (nat_of_integer (2 :: Integer)))));
proper_interval_set_Compl_aux less proper_interval ao n (x : xs) [] =
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
    (len_x, xa) = length_last (x : xs);
  } in not (equal_nat m len_x) &&
         (if equal_nat m (plus_nat len_x one_nat)
           then not (proper_interval (Just xa) Nothing) else True);
proper_interval_set_Compl_aux less proper_interval ao n [] (y : ys) =
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
    (len_y, ya) = length_last (y : ys);
  } in not (equal_nat m len_y) &&
         (if equal_nat m (plus_nat len_y one_nat)
           then not (proper_interval (Just ya) Nothing) else True);
proper_interval_set_Compl_aux less proper_interval ao n [] [] =
  less_nat (plus_nat n one_nat) (of_phantom (card_UNIV :: Phantom a Nat));

proper_interval_Compl_set_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
proper_interval_Compl_set_aux less proper_interval ao uu [] = False;
proper_interval_Compl_set_aux less proper_interval ao [] uv = False;
proper_interval_Compl_set_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           proper_interval_Compl_set_aux less proper_interval (Just x) xs
             (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  proper_interval_Compl_set_aux less proper_interval (Just y)
                    (x : xs) ys
           else not (proper_interval ao (Just x)) &&
                  (if null ys then not (null xs) else True)));

exhaustive_above :: forall a. (Maybe a -> Maybe a -> Bool) -> a -> [a] -> Bool;
exhaustive_above proper_interval x (y : ys) =
  not (proper_interval (Just x) (Just y)) &&
    exhaustive_above proper_interval y ys;
exhaustive_above proper_interval x [] = not (proper_interval (Just x) Nothing);

proper_interval_set_aux ::
  forall a.
    (a -> a -> Bool) -> (Maybe a -> Maybe a -> Bool) -> [a] -> [a] -> Bool;
proper_interval_set_aux less proper_interval (x : xs) (y : ys) =
  (if less x y then False
    else (if less y x
           then proper_interval (Just y) (Just x) ||
                  (not (null ys) || not (exhaustive_above proper_interval x xs))
           else proper_interval_set_aux less proper_interval xs ys));
proper_interval_set_aux less proper_interval [] (y : ys) =
  not (null ys) || proper_interval (Just y) Nothing;
proper_interval_set_aux less proper_interval xs [] = False;

exhaustive_fusion ::
  forall a b. (Maybe a -> Maybe a -> Bool) -> Generator a b -> b -> Bool;
exhaustive_fusion proper_interval g s =
  has_next g s &&
    let {
      (x, sa) = next g s;
    } in not (proper_interval Nothing (Just x)) &&
           exhaustive_above_fusion proper_interval g x sa;

list_remdups :: forall a. (a -> a -> Bool) -> [a] -> [a];
list_remdups equal (x : xs) =
  (if list_member equal xs x then list_remdups equal xs
    else x : list_remdups equal xs);
list_remdups equal [] = [];

lengtha :: forall a. (Ceq a) => Set_dlist a -> Nat;
lengtha xa = size_list (list_of_dlist xa);

card :: forall a. (Card_UNIV a, Ceq a, Ccompare a) => Set a -> Nat;
card (Complement a) =
  let {
    aa = card a;
    s = of_phantom (card_UNIV :: Phantom a Nat);
  } in (if less_nat zero_nat s then minus_nat s aa
         else (if finite a then zero_nat
                else (error :: forall a. String -> (() -> a) -> a)
                       "card Complement: infinite"
                       (\ _ -> card (Complement a))));
card (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "card Set_Monad: ceq = None"
        (\ _ -> card (Set_Monad xs));
    Just eq -> size_list (list_remdups eq xs);
  });
card (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "card RBT_set: ccompare = None" (\ _ -> card (RBT_set rbt));
    Just _ -> size_list (keysa rbt);
  });
card (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "card DList_set: ceq = None"
        (\ _ -> card (DList_set dxs));
    Just _ -> lengtha dxs;
  });

is_UNIV :: forall a. (Card_UNIV a, Ceq a, Cproper_interval a) => Set a -> Bool;
is_UNIV (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_UNIV RBT_set: ccompare = None" (\ _ -> is_UNIV (RBT_set rbt));
    Just _ ->
      of_phantom (finite_UNIV :: Phantom a Bool) &&
        exhaustive_fusion cproper_interval rbt_keys_generator (init rbt);
  });
is_UNIV a =
  let {
    aa = of_phantom (card_UNIV :: Phantom a Nat);
    b = card a;
  } in (if less_nat zero_nat aa then equal_nat aa b
         else (if less_nat zero_nat b then False
                else (error :: forall a. String -> (() -> a) -> a)
                       "is_UNIV called on infinite type and set"
                       (\ _ -> is_UNIV a)));

is_emptya :: forall a b. (Ccompare a) => Mapping_rbt a b -> Bool;
is_emptya xa = (case impl_ofb xa of {
                 Emptya -> True;
                 Branch _ _ _ _ _ -> False;
               });

nulla :: forall a. (Ceq a) => Set_dlist a -> Bool;
nulla xa = null (list_of_dlist xa);

is_empty :: forall a. (Card_UNIV a, Ceq a, Cproper_interval a) => Set a -> Bool;
is_empty (Complement a) = is_UNIV a;
is_empty (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_empty RBT_set: ccompare = None" (\ _ -> is_empty (RBT_set rbt));
    Just _ -> is_emptya rbt;
  });
is_empty (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_empty DList_set: ceq = None" (\ _ -> is_empty (DList_set dxs));
    Just _ -> nulla dxs;
  });
is_empty (Set_Monad xs) = null xs;

cproper_interval_set ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Maybe (Set a) -> Maybe (Set a) -> Bool;
cproper_interval_set (Just (Complement (RBT_set rbt1))) (Just (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (Complement (RBT_set rbt1)))
            (Just (RBT_set rbt2)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_Compl_set_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cproper_interval_set (Just (RBT_set rbt1)) (Just (Complement (RBT_set rbt2))) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval RBT_set (Complement RBT_set): ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (RBT_set rbt1))
            (Just (Complement (RBT_set rbt2))));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_Compl_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing zero_nat (init rbt1)
          (init rbt2);
  });
cproper_interval_set (Just (RBT_set rbt1)) (Just (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval RBT_set RBT_set: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (RBT_set rbt1)) (Just (RBT_set rbt2)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator (init rbt1) (init rbt2);
  });
cproper_interval_set (Just (Complement a)) (Just (Complement b)) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement Complement: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (Complement a)) (Just (Complement b)));
    Just _ -> cproper_interval_set (Just b) (Just a);
  });
cproper_interval_set (Just (Complement a)) (Just b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement1: ccompare = None"
        (\ _ -> cproper_interval_set (Just (Complement a)) (Just b));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_Compl_set_aux (lt_of_comp c) cproper_interval Nothing
          (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) (Just (Complement b)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement2: ccompare = None"
        (\ _ -> cproper_interval_set (Just a) (Just (Complement b)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_Compl_aux (lt_of_comp c) cproper_interval Nothing
          zero_nat (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) (Just b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval: ccompare = None"
        (\ _ -> cproper_interval_set (Just a) (Just b));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_aux (lt_of_comp c) cproper_interval
          (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) Nothing = not (is_UNIV a);
cproper_interval_set Nothing (Just b) = not (is_empty b);
cproper_interval_set Nothing Nothing = True;

instance (Card_UNIV a, Ceq a, Cproper_interval a,
           Set_impl a) => Cproper_interval (Set a) where {
  cproper_interval = cproper_interval_set;
};

ceq_bool :: Maybe (Bool -> Bool -> Bool);
ceq_bool = Just (\ a b -> a == b);

instance Ceq Bool where {
  ceq = ceq_bool;
};

set_impl_bool :: Phantom Bool Set_impla;
set_impl_bool = Phantom Set_DList;

instance Set_impl Bool where {
  set_impl = set_impl_bool;
};

comparator_bool :: Bool -> Bool -> Ordera;
comparator_bool False False = Eqa;
comparator_bool False True = Lt;
comparator_bool True True = Eqa;
comparator_bool True False = Gt;

compare_bool :: Bool -> Bool -> Ordera;
compare_bool = comparator_bool;

ccompare_bool :: Maybe (Bool -> Bool -> Ordera);
ccompare_bool = Just compare_bool;

instance Ccompare Bool where {
  ccompare = ccompare_bool;
};

shows_prec_list ::
  forall a. (Showa a) => Nat -> [a] -> [Prelude.Char] -> [Prelude.Char];
shows_prec_list p xs = shows_list xs;

shows_list_list ::
  forall a. (Showa a) => [[a]] -> [Prelude.Char] -> [Prelude.Char];
shows_list_list xss = showsp_list shows_prec_list zero_nat xss;

instance (Showa a) => Showa [a] where {
  shows_prec = shows_prec_list;
  shows_list = shows_list_list;
};

default_list :: forall a. [a];
default_list = [];

class Default a where {
  defaulta :: a;
};

instance Default [a] where {
  defaulta = default_list;
};

less_eq_list :: forall a. (Eq a, Order a) => [a] -> [a] -> Bool;
less_eq_list (x : xs) (y : ys) = less x y || x == y && less_eq_list xs ys;
less_eq_list [] xs = True;
less_eq_list (x : xs) [] = False;

less_list :: forall a. (Eq a, Order a) => [a] -> [a] -> Bool;
less_list (x : xs) (y : ys) = less x y || x == y && less_list xs ys;
less_list [] (x : xs) = True;
less_list xs [] = False;

instance (Eq a, Order a) => Ord [a] where {
  less_eq = less_eq_list;
  less = less_list;
};

comparator_list :: forall a. (a -> a -> Ordera) -> [a] -> [a] -> Ordera;
comparator_list comp_a (x : xa) (y : ya) =
  (case comp_a x y of {
    Eqa -> comparator_list comp_a xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_list comp_a (x : xa) [] = Gt;
comparator_list comp_a [] (y : ya) = Lt;
comparator_list comp_a [] [] = Eqa;

compare_list :: forall a. (Compare a) => [a] -> [a] -> Ordera;
compare_list = comparator_list compare;

instance (Eq a, Order a) => Quasi_order [a] where {
};

instance (Eq a, Order a) => Weak_order [a] where {
};

instance (Eq a, Order a) => Preorder [a] where {
};

instance (Eq a, Order a) => Order [a] where {
};

instance (Eq a, Linorder a) => Linorder [a] where {
};

instance (Compare a) => Compare [a] where {
  compare = compare_list;
};

instance (Compare_order a, Eq a) => Compare_order [a] where {
};

instance (Eq a, Key a) => Key [a] where {
};

equality_list :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
equality_list eq_a (x : xa) (y : ya) = eq_a x y && equality_list eq_a xa ya;
equality_list eq_a (x : xa) [] = False;
equality_list eq_a [] (y : ya) = False;
equality_list eq_a [] [] = True;

ceq_list :: forall a. (Ceq a) => Maybe ([a] -> [a] -> Bool);
ceq_list = (case ceq of {
             Nothing -> Nothing;
             Just eq_a -> Just (equality_list eq_a);
           });

instance (Ceq a) => Ceq [a] where {
  ceq = ceq_list;
};

class Infinite a where {
};

instance Infinite [a] where {
};

set_impl_list :: forall a. Phantom [a] Set_impla;
set_impl_list = Phantom Set_Choose;

instance Set_impl [a] where {
  set_impl = set_impl_list;
};

class Countable a where {
};

instance (Countable a) => Countable [a] where {
};

finite_UNIV_list :: forall a. Phantom [a] Bool;
finite_UNIV_list = Phantom False;

card_UNIV_list :: forall a. Phantom [a] Nat;
card_UNIV_list = Phantom zero_nat;

instance Finite_UNIV [a] where {
  finite_UNIV = finite_UNIV_list;
};

instance Card_UNIV [a] where {
  card_UNIVa = card_UNIV_list;
};

cEnum_list ::
  forall a. Maybe ([[a]], (([a] -> Bool) -> Bool, ([a] -> Bool) -> Bool));
cEnum_list = Nothing;

instance Cenum [a] where {
  cEnum = cEnum_list;
};

ccompare_list :: forall a. (Ccompare a) => Maybe ([a] -> [a] -> Ordera);
ccompare_list = (case ccompare of {
                  Nothing -> Nothing;
                  Just comp_a -> Just (comparator_list comp_a);
                });

instance (Ccompare a) => Ccompare [a] where {
  ccompare = ccompare_list;
};

mapping_impl_list :: forall a. Phantom [a] Mapping_impla;
mapping_impl_list = Phantom Mapping_Choose;

instance Mapping_impl [a] where {
  mapping_impl = mapping_impl_list;
};

cproper_interval_list ::
  forall a. (Ccompare a) => Maybe [a] -> Maybe [a] -> Bool;
cproper_interval_list xso yso = error "undefined";

instance (Ccompare a) => Cproper_interval [a] where {
  cproper_interval = cproper_interval_list;
};

gcd_eucla :: forall a. (Euclidean_semiring a, Eq a) => a -> a -> a;
gcd_eucla a b = (if b == zerob then normalizeb a else gcd_eucla b (modulo a b));

lcm_eucla :: forall a. (Euclidean_semiring a, Eq a) => a -> a -> a;
lcm_eucla a b = divide (normalizeb (times a b)) (gcd_eucla a b);

unit_factor_field :: forall a. (Field a) => a -> a;
unit_factor_field x = x;

unit_factor_real :: Real -> Real;
unit_factor_real = unit_factor_field;

euclidean_size_field :: forall a. (Field a, Eq a) => a -> Nat;
euclidean_size_field x = (if x == zerob then zero_nat else one_nat);

eq_fun_rai ::
  Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat))) -> Bool;
eq_fun_rai (Just (ri, (p1, (l1, r1)))) (Just (uu, (p2, (l2, r2)))) =
  less_eq_rat l1 r2 &&
    less_eq_rat l2 r1 &&
      equal_poly p1 p2 && let {
                            l = max l1 l2;
                            r = min r1 r2;
                          } in not (equal_nat (l_r ri l r) zero_nat);
eq_fun_rai Nothing Nothing = True;
eq_fun_rai Nothing (Just v) = False;
eq_fun_rai (Just v) Nothing = False;

eq_rai :: Real_alg_intern -> Real_alg_intern -> Bool;
eq_rai xa xc = eq_fun_rai (rep_real_alg_intern xa) (rep_real_alg_intern xc);

equal_radt :: Real_alg_dt -> Real_alg_dt -> Bool;
equal_radt (Rationala r) (Rationala q) = equal_rat r q;
equal_radt (Irrational xx) (Irrational yy) = eq_rai xx yy;
equal_radt (Rationala r) (Irrational yy) = False;
equal_radt (Irrational xx) (Rationala q) = False;

equal_radtc :: Real_alg_dtc -> Real_alg_dtc -> Bool;
equal_radtc xa xc = equal_radt (rep_real_alg_dtc xa) (rep_real_alg_dtc xc);

equal_real_alg :: Real_alg -> Real_alg -> Bool;
equal_real_alg (Abstr_real_alg xc) (Abstr_real_alg xa) = equal_radtc xc xa;

equal_real :: Real -> Real -> Bool;
equal_real (Real_of x) (Real_of y) = equal_real_alg x y;

instance Eq Real where {
  a == b = equal_real a b;
};

euclidean_size_real :: Real -> Nat;
euclidean_size_real = euclidean_size_field;

normalize_field :: forall a. (Field a, Eq a) => a -> a;
normalize_field x = (if x == zerob then zerob else onea);

normalize_real :: Real -> Real;
normalize_real = normalize_field;

mod_field :: forall a. (Field a, Eq a) => a -> a -> a;
mod_field x y = (if y == zerob then x else zerob);

modulo_real :: Real -> Real -> Real;
modulo_real = mod_field;

instance Algebraic_semidom Real where {
};

instance Normalization_semidom Real where {
  normalizeb = normalize_real;
  unit_factor = unit_factor_real;
};

instance Factorial_semiring Real where {
};

instance Modulo Real where {
  modulo = modulo_real;
};

instance Semiring_modulo Real where {
};

instance Euclidean_semiring Real where {
  euclidean_size = euclidean_size_real;
};

lcm_reala :: Real -> Real -> Real;
lcm_reala = lcm_eucla;

gcd_reala :: Real -> Real -> Real;
gcd_reala = gcd_eucla;

lcm_eucl :: forall a. Set a -> a;
lcm_eucl _ = error "Euclidean_Algorithm.euclidean_semiring_class.Lcm_eucl";

lcm_real :: Set Real -> Real;
lcm_real = lcm_eucl;

gcd_eucl :: forall a. Set a -> a;
gcd_eucl _ = error "Euclidean_Algorithm.euclidean_semiring_class.Gcd_eucl";

gcd_real :: Set Real -> Real;
gcd_real = gcd_eucl;

instance Gcda Real where {
  gcda = gcd_reala;
  lcma = lcm_reala;
};

instance Gcd Real where {
  gcd = gcd_real;
  lcm = lcm_real;
};

floor_rai_fun :: Maybe (Root_info, (Poly Rat, (Rat, Rat))) -> Int;
floor_rai_fun Nothing = zero_int;
floor_rai_fun (Just (ri, (p, (l, r)))) =
  let {
    _ = l_r ri;
    (la, ra) =
      tighten_poly_bounds_epsilon p
        (divide_rat one_rat (of_int (Int_of_integer (2 :: Integer)))) l r;
    fr = floor_rat ra;
    fl = floor_rat la;
    fra = of_int fr;
  } in (if equal_int fr fl || equal_rat (polya p fra) zero_rat then fr
         else let {
                (lb, _) = tighten_poly_bounds_for_x p fra la ra;
              } in (if less_rat fra lb then fr else fl));

floor_rai :: Real_alg_intern -> Int;
floor_rai xa = floor_rai_fun (rep_real_alg_intern xa);

floor_radt :: Real_alg_dt -> Int;
floor_radt (Rationala r) = floor_rat r;
floor_radt (Irrational rai) = floor_rai rai;

floor_radtc :: Real_alg_dtc -> Int;
floor_radtc xa = floor_radt (rep_real_alg_dtc xa);

floor_real_alg :: Real_alg -> Int;
floor_real_alg (Abstr_real_alg xa) = floor_radtc xa;

instance Plus Real_alg where {
  plus = plus_real_alg;
};

instance Semigroup_add Real_alg where {
};

instance One Real_alg where {
  onea = one_real_alg;
};

instance Numeral Real_alg where {
};

show_real_alg :: Real_alg -> [Prelude.Char];
show_real_alg x =
  let {
    x1000 =
      floor_real_alg
        (times_real_alg
          (numeral
            (Bit0 (Bit0 (Bit0 (Bit1 (Bit0 (Bit1 (Bit1 (Bit1 (Bit1 One))))))))))
          x);
    (x1000a, s) =
      (if less_int x1000 zero_int then (uminus_int x1000, ['-'])
        else (x1000, []));
    (bef, aft) = divmod_int x1000a (Int_of_integer (1000 :: Integer));
    a = shows_prec_int zero_nat aft [];
    aa = replicate (minus_nat (nat_of_integer (3 :: Integer)) (size_list a))
           '0' ++
           a;
  } in [' ', '~'] ++ s ++ shows_prec_int zero_nat bef [] ++ ['.'] ++ aa;

show_real :: Real -> [Prelude.Char];
show_real (Real_of x) = show_real_alg x;

showsp_real :: Nat -> Real -> [Prelude.Char] -> [Prelude.Char];
showsp_real p x y = show_real x ++ y;

shows_prec_real :: Nat -> Real -> [Prelude.Char] -> [Prelude.Char];
shows_prec_real = showsp_real;

shows_list_real :: [Real] -> [Prelude.Char] -> [Prelude.Char];
shows_list_real = showsp_list shows_prec_real zero_nat;

instance Showa Real where {
  shows_prec = shows_prec_real;
  shows_list = shows_list_real;
};

compare_rat_rai_intern ::
  Rat -> Maybe (Root_info, (Poly Rat, (Rat, Rat))) -> Ordera;
compare_rat_rai_intern x Nothing = compare_rat x zero_rat;
compare_rat_rai_intern x (Just (ri, (p, (l, r)))) =
  (if less_rat x l then Lt
    else (if less_rat r x then Gt
           else (if equal_rat (polya p x) zero_rat then Eqa
                  else (if le_rat_in_interval p x r then Lt else Gt))));

compare_rat_rai :: Rat -> Real_alg_intern -> Ordera;
compare_rat_rai x xc = compare_rat_rai_intern x (rep_real_alg_intern xc);

compare_rai_intern_main ::
  Poly Rat -> Poly Rat -> Rat -> Rat -> Rat -> Rat -> Ordera;
compare_rai_intern_main p1 p2 l1 r1 l2 r2 =
  (if less_rat r1 l2 then Lt
    else (if less_rat r2 l1 then Gt
           else let {
                  (l1a, r1a) = tighten_poly_bounds p1 l1 r1;
                  a = tighten_poly_bounds p2 l2 r2;
                  (aa, b) = a;
                } in compare_rai_intern_main p1 p2 l1a r1a aa b));

compare_rai_intern ::
  Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat))) -> Ordera;
compare_rai_intern (Just x) (Just y) =
  (if eq_fun_rai (Just x) (Just y) then Eqa
    else let {
           (_, (p, (l, r))) = x;
           (_, a) = y;
           (pa, aa) = a;
           (ab, b) = aa;
         } in compare_rai_intern_main p pa l r ab b);
compare_rai_intern (Just (ri, (p, (l, r)))) Nothing =
  (if equal_rat (sgn_rat r) one_rat then Gt else Lt);
compare_rai_intern Nothing (Just (ri, (p, (l, r)))) =
  (if equal_rat (sgn_rat r) one_rat then Lt else Gt);
compare_rai_intern Nothing Nothing = Eqa;

compare_rai :: Real_alg_intern -> Real_alg_intern -> Ordera;
compare_rai xa xc =
  compare_rai_intern (rep_real_alg_intern xa) (rep_real_alg_intern xc);

invert_order :: Ordera -> Ordera;
invert_order Lt = Gt;
invert_order Gt = Lt;
invert_order Eqa = Eqa;

compare_radt :: Real_alg_dt -> Real_alg_dt -> Ordera;
compare_radt (Rationala r) (Rationala q) = compare_rat r q;
compare_radt (Irrational xx) (Irrational yy) = compare_rai xx yy;
compare_radt (Rationala r) (Irrational xx) = compare_rat_rai r xx;
compare_radt (Irrational xx) (Rationala r) =
  invert_order (compare_rat_rai r xx);

compare_radtc :: Real_alg_dtc -> Real_alg_dtc -> Ordera;
compare_radtc xa xc = compare_radt (rep_real_alg_dtc xa) (rep_real_alg_dtc xc);

compare_real_alg :: Real_alg -> Real_alg -> Ordera;
compare_real_alg (Abstr_real_alg xc) (Abstr_real_alg xa) = compare_radtc xc xa;

less_real_alg :: Real_alg -> Real_alg -> Bool;
less_real_alg = lt_of_comp compare_real_alg;

less_real :: Real -> Real -> Bool;
less_real (Real_of x) (Real_of y) = less_real_alg x y;

abs_real_alg :: Real_alg -> Real_alg;
abs_real_alg x =
  (if less_real (Real_of x) zero_real then uminus_real_alg x else x);

abs_real :: Real -> Real;
abs_real (Real_of x) = Real_of (abs_real_alg x);

instance Abs Real where {
  absa = abs_real;
};

sgn_rai :: Real_alg_intern -> Rat;
sgn_rai xa = (case rep_real_alg_intern xa of {
               Nothing -> zero_rat;
               Just a -> let {
                           (_, aa) = a;
                           (_, ab) = aa;
                           (_, ac) = ab;
                         } in sgn_rat ac;
             });

sgn_radt :: Real_alg_dt -> Rat;
sgn_radt (Rationala r) = sgn_rat r;
sgn_radt (Irrational rai) = sgn_rai rai;

sgn_radtc :: Real_alg_dtc -> Rat;
sgn_radtc xa = sgn_radt (rep_real_alg_dtc xa);

sgn_real_alg_rat :: Real_alg -> Rat;
sgn_real_alg_rat (Abstr_real_alg xa) = sgn_radtc xa;

sgn_real_alg :: Real_alg -> Real_alg;
sgn_real_alg x = of_rat_real_alg (sgn_real_alg_rat x);

sgn_real :: Real -> Real;
sgn_real (Real_of x) = Real_of (sgn_real_alg x);

instance Sgn Real where {
  sgn = sgn_real;
};

instance Semiring_gcd Real where {
};

instance Ring_gcd Real where {
};

less_eq_real_alg :: Real_alg -> Real_alg -> Bool;
less_eq_real_alg = le_of_comp compare_real_alg;

less_eq_real :: Real -> Real -> Bool;
less_eq_real (Real_of x) (Real_of y) = less_eq_real_alg x y;

instance Ord Real where {
  less_eq = less_eq_real;
  less = less_real;
};

instance Abs_if Real where {
};

instance Quasi_order Real where {
};

instance Weak_order Real where {
};

instance Preorder Real where {
};

instance Order Real where {
};

instance Semiring_Gcd Real where {
};

instance No_bot Real where {
};

instance No_top Real where {
};

ceq_real :: Maybe (Real -> Real -> Bool);
ceq_real = Just equal_real;

instance Ceq Real where {
  ceq = ceq_real;
};

set_impl_real :: Phantom Real Set_impla;
set_impl_real = Phantom Set_DList;

instance Set_impl Real where {
  set_impl = set_impl_real;
};

instance Linorder Real where {
};

instance Idom_abs_sgn Real where {
};

instance Ordered_ab_semigroup_add Real where {
};

instance Strict_ordered_ab_semigroup_add Real where {
};

instance Ordered_cancel_ab_semigroup_add Real where {
};

instance Ordered_comm_monoid_add Real where {
};

instance Ordered_semiring Real where {
};

instance Ordered_semiring_0 Real where {
};

instance Ordered_cancel_semiring Real where {
};

instance Ordered_ab_semigroup_add_imp_le Real where {
};

instance Strict_ordered_comm_monoid_add Real where {
};

instance Ordered_cancel_comm_monoid_add Real where {
};

instance Ordered_ab_semigroup_monoid_add_imp_le Real where {
};

instance Ordered_ab_group_add Real where {
};

instance Ordered_ring Real where {
};

instance Zero_less_one Real where {
};

instance Field_abs_sgn Real where {
};

cEnum_real :: Maybe ([Real], ((Real -> Bool) -> Bool, (Real -> Bool) -> Bool));
cEnum_real = Nothing;

instance Cenum Real where {
  cEnum = cEnum_real;
};

instance Dense_order Real where {
};

instance Linordered_ab_semigroup_add Real where {
};

instance Linordered_cancel_ab_semigroup_add Real where {
};

instance Linordered_semiring Real where {
};

instance Linordered_semiring_strict Real where {
};

instance Linordered_semiring_1 Real where {
};

instance Linordered_semiring_1_strict Real where {
};

instance Ordered_ab_group_add_abs Real where {
};

instance Linordered_ab_group_add Real where {
};

instance Linordered_ring Real where {
};

instance Linordered_ring_strict Real where {
};

instance Ordered_comm_semiring Real where {
};

instance Ordered_cancel_comm_semiring Real where {
};

instance Linordered_comm_semiring_strict Real where {
};

instance Linordered_nonzero_semiring Real where {
};

instance Linordered_semidom Real where {
};

instance Ordered_comm_ring Real where {
};

instance Ordered_ring_abs Real where {
};

instance Linordered_idom Real where {
};

instance Non_strict_order Real where {
};

instance Ordered_ab_semigroup Real where {
};

instance Ordered_semiring_0a Real where {
};

instance Ordered_semiring_1 Real where {
};

instance Poly_carrier Real where {
};

instance Dense_linorder Real where {
};

instance Unbounded_dense_linorder Real where {
};

instance Linordered_field Real where {
};

dist_real :: Real -> Real -> Real;
dist_real x y = abs_real (minus_real x y);

class Dist a where {
  dist :: a -> a -> Real;
};

instance Dist Real where {
  dist = dist_real;
};

norm_real :: Real -> Real;
norm_real r = abs_real r;

class Norm a where {
  norm :: a -> Real;
};

instance Norm Real where {
  norm = norm_real;
};

open_real :: Set Real -> Bool;
open_real _ = error "Real_Vector_Spaces.open_real_inst.open_real";

class Open a where {
  open :: Set a -> Bool;
};

instance Open Real where {
  open = open_real;
};

compare_real :: Real -> Real -> Ordera;
compare_real (Real_of x) (Real_of y) = compare_real_alg x y;

ccompare_real :: Maybe (Real -> Real -> Ordera);
ccompare_real = Just compare_real;

instance Ccompare Real where {
  ccompare = ccompare_real;
};

scaleR_real :: Real -> Real -> Real;
scaleR_real a x = times_real a x;

class ScaleR a where {
  scaleR :: Real -> a -> a;
};

instance ScaleR Real where {
  scaleR = scaleR_real;
};

class (Open a) => Topological_space a where {
};

class (Topological_space a) => T0_space a where {
};

instance Topological_space Real where {
};

instance T0_space Real where {
};

class (T0_space a) => T1_space a where {
};

instance T1_space Real where {
};

class (T1_space a) => T2_space a where {
};

instance T2_space Real where {
};

class (Monoid_add a, Topological_space a) => Topological_monoid_add a where {
};

class (Group_add a, Topological_monoid_add a) => Topological_group_add a where {
};

instance Topological_monoid_add Real where {
};

instance Topological_group_add Real where {
};

class (Minus a, Dist a, Norm a) => Dist_norm a where {
};

instance Dist_norm Real where {
};

data Filter a = Principal (Set a) | Abstract_filter (() -> Filter a);

uniformity_real :: Filter (Real, Real);
uniformity_real =
  Abstract_filter
    (\ _ ->
      (error :: forall a. String -> (() -> a) -> a)
        "uniformity is not executable" (\ _ -> uniformity_real));

class Uniformity a where {
  uniformity :: Filter (a, a);
};

instance Uniformity Real where {
  uniformity = uniformity_real;
};

class (Ab_group_add a, ScaleR a) => Real_vector a where {
};

instance Real_vector Real where {
};

real_of_real :: Real -> Real;
real_of_real x = x;

instance Real_embedding Real where {
  real_of = real_of_real;
};

floor_real :: Real -> Int;
floor_real (Real_of x) = floor_real_alg x;

instance Archimedean_field Real where {
};

instance Large_ordered_semiring_1 Real where {
};

instance Floor_ceiling Real where {
  floor = floor_real;
};

class (Comm_monoid_add a,
        Topological_monoid_add a) => Topological_comm_monoid_add a where {
};

class (Ab_group_add a, Topological_comm_monoid_add a,
        Topological_group_add a) => Topological_ab_group_add a where {
};

instance Topological_comm_monoid_add Real where {
};

instance Topological_ab_group_add Real where {
};

class (Topological_space a) => First_countable_topology a where {
};

class (Dist a, Uniformity a) => Uniformity_dist a where {
};

class (Open a, Uniformity a) => Open_uniformity a where {
};

class (Open_uniformity a, Topological_space a) => Uniform_space a where {
};

class (Uniformity_dist a, First_countable_topology a, T2_space a,
        Uniform_space a) => Metric_space a where {
};

instance First_countable_topology Real where {
};

instance Uniformity_dist Real where {
};

instance Open_uniformity Real where {
};

instance Uniform_space Real where {
};

instance Metric_space Real where {
};

class (Sgn a, Norm a, ScaleR a) => Sgn_div_norm a where {
};

instance Sgn_div_norm Real where {
};

instance Factorial_semiring_gcd Real where {
};

instance Factorial_ring_gcd Real where {
};

instance Euclidean_ring Real where {
};

class (Topological_ab_group_add a, Dist_norm a, Metric_space a, Real_vector a,
        Sgn_div_norm a) => Real_normed_vector a where {
};

instance Real_normed_vector Real where {
};

class (Euclidean_semiring a,
        Factorial_semiring_gcd a) => Euclidean_semiring_gcd a where {
};

class (Euclidean_ring a, Euclidean_semiring_gcd a,
        Factorial_ring_gcd a) => Euclidean_ring_gcd a where {
};

instance Euclidean_semiring_gcd Real where {
};

instance Euclidean_ring_gcd Real where {
};

instance Large_real_ordered_semiring_1 Real where {
};

data Term a b = Var b | Fun a [Term a b];

data Ctxt a b = Hole | More a [Term a b] (Ctxt a b) [Term a b];

instance (Eq a, Eq b) => Eq (Term a b) where {
  a == b = equal_term a b;
};

equal_term :: forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Bool;
equal_term (Var x1) (Fun x21 x22) = False;
equal_term (Fun x21 x22) (Var x1) = False;
equal_term (Fun x21 x22) (Fun y21 y22) = x21 == y21 && x22 == y22;
equal_term (Var x1) (Var y1) = x1 == y1;

equal_ctxt :: forall a b. (Eq a, Eq b) => Ctxt a b -> Ctxt a b -> Bool;
equal_ctxt Hole (More x21 x22 x23 x24) = False;
equal_ctxt (More x21 x22 x23 x24) Hole = False;
equal_ctxt (More x21 x22 x23 x24) (More y21 y22 y23 y24) =
  x21 == y21 && x22 == y22 && equal_ctxt x23 y23 && x24 == y24;
equal_ctxt Hole Hole = True;

instance (Eq a, Eq b) => Eq (Ctxt a b) where {
  a == b = equal_ctxt a b;
};

ceq_ctxt :: forall a b. (Eq a, Eq b) => Maybe (Ctxt a b -> Ctxt a b -> Bool);
ceq_ctxt = Just equal_ctxt;

instance (Eq a, Eq b) => Ceq (Ctxt a b) where {
  ceq = ceq_ctxt;
};

set_impl_ctxt :: forall a b. Phantom (Ctxt a b) Set_impla;
set_impl_ctxt = Phantom Set_RBT;

instance Set_impl (Ctxt a b) where {
  set_impl = set_impl_ctxt;
};

comparator_term ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Term a b -> Term a b -> Ordera;
comparator_term comp_f comp_v (Fun x xa) (Fun ya yb) =
  (case comp_f x ya of {
    Eqa -> comparator_list (comparator_term comp_f comp_v) xa yb;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_term comp_f comp_v (Fun x xa) (Var y) = Gt;
comparator_term comp_f comp_v (Var x) (Fun ya yb) = Lt;
comparator_term comp_f comp_v (Var x) (Var y) = comp_v x y;

comparator_ctxt ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Ctxt a b -> Ctxt a b -> Ordera;
comparator_ctxt comp_f comp_v (More x xa xb xc) (More y ya yb yc) =
  (case comp_f x y of {
    Eqa ->
      (case comparator_list (comparator_term comp_f comp_v) xa ya of {
        Eqa -> (case comparator_ctxt comp_f comp_v xb yb of {
                 Eqa -> comparator_list (comparator_term comp_f comp_v) xc yc;
                 Lt -> Lt;
                 Gt -> Gt;
               });
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_ctxt comp_f comp_v (More x xa xb xc) Hole = Gt;
comparator_ctxt comp_f comp_v Hole (More y ya yb yc) = Lt;
comparator_ctxt comp_f comp_v Hole Hole = Eqa;

compare_ctxt ::
  forall a b. (Compare a, Compare b) => Ctxt a b -> Ctxt a b -> Ordera;
compare_ctxt = comparator_ctxt compare compare;

ccompare_ctxt ::
  forall a b. (Compare a, Compare b) => Maybe (Ctxt a b -> Ctxt a b -> Ordera);
ccompare_ctxt = Just compare_ctxt;

instance (Compare a, Compare b) => Ccompare (Ctxt a b) where {
  ccompare = ccompare_ctxt;
};

shows_term ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Term a b -> [Prelude.Char] -> [Prelude.Char];
shows_term fun var (Var x) = var x;
shows_term fun var (Fun f ts) =
  fun f .
    shows_list_gen id [] ['('] [',', ' '] [')'] (map (shows_term fun var) ts);

shows_prec_term ::
  forall a b.
    (Showa a, Showa b) => Nat -> Term a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_term d t = shows_term (shows_prec zero_nat) (shows_prec zero_nat) t;

shows_list_term ::
  forall a b.
    (Showa a, Showa b) => [Term a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_term ts = showsp_list shows_prec_term zero_nat ts;

instance (Showa a, Showa b) => Showa (Term a b) where {
  shows_prec = shows_prec_term;
  shows_list = shows_list_term;
};

compare_term ::
  forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Ordera;
compare_term = comparator_term compare compare;

less_eq_term ::
  forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Bool;
less_eq_term = le_of_comp compare_term;

less_term :: forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Bool;
less_term = lt_of_comp compare_term;

instance (Compare a, Compare b) => Ord (Term a b) where {
  less_eq = less_eq_term;
  less = less_term;
};

instance (Compare a, Compare b) => Quasi_order (Term a b) where {
};

instance (Compare a, Compare b) => Weak_order (Term a b) where {
};

instance (Compare a, Compare b) => Preorder (Term a b) where {
};

instance (Compare a, Compare b) => Order (Term a b) where {
};

instance (Compare a, Compare b) => Linorder (Term a b) where {
};

instance (Compare a, Compare b) => Compare (Term a b) where {
  compare = compare_term;
};

instance (Compare a, Compare b) => Compare_order (Term a b) where {
};

instance (Key a, Key b) => Key (Term a b) where {
};

ceq_term :: forall a b. (Eq a, Eq b) => Maybe (Term a b -> Term a b -> Bool);
ceq_term = Just equal_term;

instance (Eq a, Eq b) => Ceq (Term a b) where {
  ceq = ceq_term;
};

set_impl_term :: forall a b. Phantom (Term a b) Set_impla;
set_impl_term = Phantom Set_RBT;

instance Set_impl (Term a b) where {
  set_impl = set_impl_term;
};

cEnum_term ::
  forall a b.
    Maybe ([Term a b],
            ((Term a b -> Bool) -> Bool, (Term a b -> Bool) -> Bool));
cEnum_term = Nothing;

instance Cenum (Term a b) where {
  cEnum = cEnum_term;
};

finite_UNIV_term :: forall a b. Phantom (Term a b) Bool;
finite_UNIV_term = Phantom False;

instance Finite_UNIV (Term a b) where {
  finite_UNIV = finite_UNIV_term;
};

ccompare_term ::
  forall a b. (Compare a, Compare b) => Maybe (Term a b -> Term a b -> Ordera);
ccompare_term = Just compare_term;

instance (Compare a, Compare b) => Ccompare (Term a b) where {
  ccompare = ccompare_term;
};

cproper_interval_term ::
  forall a b.
    (Compare a, Compare b) => Maybe (Term a b) -> Maybe (Term a b) -> Bool;
cproper_interval_term = (\ _ _ -> False);

instance (Compare a, Compare b) => Cproper_interval (Term a b) where {
  cproper_interval = cproper_interval_term;
};

equal_iarray :: forall a. (Eq a) => IArray.IArray a -> IArray.IArray a -> Bool;
equal_iarray asa bs = list_of asa == list_of bs;

mat_equal_impl :: forall a. (Eq a) => Mat_impl a -> Mat_impl a -> Bool;
mat_equal_impl xa xc =
  let {
    (nr1, (nc1, m1)) = rep_mat_impl xa;
  } in (\ (nr2, (nc2, m2)) ->
         equal_nat nr1 nr2 && equal_nat nc1 nc2 && equal_iarray m1 m2)
    (rep_mat_impl xc);

equal_mat :: forall a. (Eq a) => Mat a -> Mat a -> Bool;
equal_mat (Mat_impl m1) (Mat_impl m2) = mat_equal_impl m1 m2;

instance (Eq a) => Eq (Mat a) where {
  a == b = equal_mat a b;
};

mat_to_list :: forall a. Mat a -> [[a]];
mat_to_list a =
  map (\ i -> map (\ j -> mat_index a (i, j)) (upt zero_nat (mat_dim_col a)))
    (upt zero_nat (mat_dim_row a));

shows_mat :: forall a. (Showa a) => Mat a -> [Prelude.Char] -> [Prelude.Char];
shows_mat a = shows_prec_list zero_nat (mat_to_list a);

shows_prec_mat ::
  forall a. (Showa a) => Nat -> Mat a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_mat p a = shows_mat a;

shows_prec_char :: Nat -> Prelude.Char -> [Prelude.Char] -> [Prelude.Char];
shows_prec_char p c = (\ a -> c : a);

shows_list_char :: [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
shows_list_char cs = shows_string cs;

instance Showa Prelude.Char where {
  shows_prec = shows_prec_char;
  shows_list = shows_list_char;
};

shows_list_mat ::
  forall a. (Showa a) => [Mat a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_mat asa =
  shows_sep shows_mat (shows_prec_list zero_nat [',', ' ']) asa;

instance (Showa a) => Showa (Mat a) where {
  shows_prec = shows_prec_mat;
  shows_list = shows_list_mat;
};

ceq_mat :: forall a. (Eq a) => Maybe (Mat a -> Mat a -> Bool);
ceq_mat = Just equal_mat;

instance (Eq a) => Ceq (Mat a) where {
  ceq = ceq_mat;
};

set_impl_mat :: forall a. Phantom (Mat a) Set_impla;
set_impl_mat = Phantom Set_DList;

instance Set_impl (Mat a) where {
  set_impl = set_impl_mat;
};

cEnum_mat ::
  forall a. Maybe ([Mat a], ((Mat a -> Bool) -> Bool, (Mat a -> Bool) -> Bool));
cEnum_mat = Nothing;

instance Cenum (Mat a) where {
  cEnum = cEnum_mat;
};

ccompare_mat :: forall a. Maybe (Mat a -> Mat a -> Ordera);
ccompare_mat = Nothing;

instance Ccompare (Mat a) where {
  ccompare = ccompare_mat;
};

instance Ord Prelude.Char where {
  less_eq = (\ a b -> a <= b);
  less = (\ a b -> a < b);
};

instance Quasi_order Prelude.Char where {
};

instance Weak_order Prelude.Char where {
};

instance Preorder Prelude.Char where {
};

instance Order Prelude.Char where {
};

instance Linorder Prelude.Char where {
};

compare_char :: Prelude.Char -> Prelude.Char -> Ordera;
compare_char = comparator_of;

instance Compare Prelude.Char where {
  compare = compare_char;
};

instance Compare_order Prelude.Char where {
};

instance Key Prelude.Char where {
};

ceq_char :: Maybe (Prelude.Char -> Prelude.Char -> Bool);
ceq_char = Just (\ a b -> a == b);

instance Ceq Prelude.Char where {
  ceq = ceq_char;
};

instance Countable Prelude.Char where {
};

ccompare_char :: Maybe (Prelude.Char -> Prelude.Char -> Ordera);
ccompare_char = Just compare_char;

instance Ccompare Prelude.Char where {
  ccompare = ccompare_char;
};

data Hint a = Default | Base a | Distribute Nat [Hint a] | Erase Nat (Hint a)
  | LexStrict [Hint a] | LexWeak [Hint a];

default_hint :: forall a. (Default a) => Hint a;
default_hint = Default;

instance (Default a) => Default (Hint a) where {
  defaulta = default_hint;
};

data Pos = Empty | PCons Nat Pos;

equal_pos :: Pos -> Pos -> Bool;
equal_pos Empty (PCons x21 x22) = False;
equal_pos (PCons x21 x22) Empty = False;
equal_pos (PCons x21 x22) (PCons y21 y22) =
  equal_nat x21 y21 && equal_pos x22 y22;
equal_pos Empty Empty = True;

instance Eq Pos where {
  a == b = equal_pos a b;
};

shows_pos :: Pos -> [Prelude.Char] -> [Prelude.Char];
shows_pos (PCons i Empty) = shows_prec_nat zero_nat (suc i);
shows_pos (PCons i (PCons v va)) =
  shows_prec_nat zero_nat (suc i) . shows_pos (PCons v va);
shows_pos Empty = shows_string ['e', 'p', 's', 'i', 'l', 'o', 'n'];

shows_prec_pos :: Nat -> Pos -> [Prelude.Char] -> [Prelude.Char];
shows_prec_pos d p = shows_pos p;

shows_list_pos :: [Pos] -> [Prelude.Char] -> [Prelude.Char];
shows_list_pos ps = showsp_list shows_prec_pos zero_nat ps;

instance Showa Pos where {
  shows_prec = shows_prec_pos;
  shows_list = shows_list_pos;
};

one_pos :: Pos;
one_pos = Empty;

instance One Pos where {
  onea = one_pos;
};

append :: Pos -> Pos -> Pos;
append Empty q = q;
append (PCons i p) q = PCons i (append p q);

times_pos :: Pos -> Pos -> Pos;
times_pos p q = append p q;

instance Times Pos where {
  times = times_pos;
};

instance Power Pos where {
};

ceq_pos :: Maybe (Pos -> Pos -> Bool);
ceq_pos = Just equal_pos;

instance Ceq Pos where {
  ceq = ceq_pos;
};

set_impl_pos :: Phantom Pos Set_impla;
set_impl_pos = Phantom Set_RBT;

instance Set_impl Pos where {
  set_impl = set_impl_pos;
};

cEnum_pos :: Maybe ([Pos], ((Pos -> Bool) -> Bool, (Pos -> Bool) -> Bool));
cEnum_pos = Nothing;

instance Cenum Pos where {
  cEnum = cEnum_pos;
};

finite_UNIV_pos :: Phantom Pos Bool;
finite_UNIV_pos = Phantom False;

instance Finite_UNIV Pos where {
  finite_UNIV = finite_UNIV_pos;
};

comparator_pos :: Pos -> Pos -> Ordera;
comparator_pos (PCons x xa) (PCons y ya) = (case comparator_of x y of {
     Eqa -> comparator_pos xa ya;
     Lt -> Lt;
     Gt -> Gt;
   });
comparator_pos (PCons x xa) Empty = Gt;
comparator_pos Empty (PCons y ya) = Lt;
comparator_pos Empty Empty = Eqa;

compare_pos :: Pos -> Pos -> Ordera;
compare_pos = comparator_pos;

ccompare_pos :: Maybe (Pos -> Pos -> Ordera);
ccompare_pos = Just compare_pos;

instance Ccompare Pos where {
  ccompare = ccompare_pos;
};

cproper_interval_pos :: Maybe Pos -> Maybe Pos -> Bool;
cproper_interval_pos = (\ _ _ -> False);

instance Cproper_interval Pos where {
  cproper_interval = cproper_interval_pos;
};

data Sum a b = Inl a | Inr b;

equal_sum :: forall a b. (Eq a, Eq b) => Sum a b -> Sum a b -> Bool;
equal_sum (Inl x1) (Inr x2) = False;
equal_sum (Inr x2) (Inl x1) = False;
equal_sum (Inr x2) (Inr y2) = x2 == y2;
equal_sum (Inl x1) (Inl y1) = x1 == y1;

instance (Eq a, Eq b) => Eq (Sum a b) where {
  a == b = equal_sum a b;
};

shows_space :: [Prelude.Char] -> [Prelude.Char];
shows_space = shows_prec_char zero_nat ' ';

shows_pr :: Nat -> [Prelude.Char] -> [Prelude.Char];
shows_pr p = (if less_nat zero_nat p then shows_prec_char zero_nat ')' else id);

shows_pl :: Nat -> [Prelude.Char] -> [Prelude.Char];
shows_pl p = (if less_nat zero_nat p then shows_prec_char zero_nat '(' else id);

showsp_sum ::
  forall a b.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      (Nat -> b -> [Prelude.Char] -> [Prelude.Char]) ->
        Nat -> Sum a b -> [Prelude.Char] -> [Prelude.Char];
showsp_sum show_a show_b p (Inr x) =
  (((shows_pl p . shows_string ['I', 'n', 'r']) . shows_space) .
    show_b one_nat x) .
    shows_pr p;
showsp_sum show_a show_b p (Inl x) =
  (((shows_pl p . shows_string ['I', 'n', 'l']) . shows_space) .
    show_a one_nat x) .
    shows_pr p;

shows_prec_sum ::
  forall a b.
    (Showa a, Showa b) => Nat -> Sum a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_sum = showsp_sum shows_prec shows_prec;

shows_list_sum ::
  forall a b.
    (Showa a, Showa b) => [Sum a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_sum = showsp_list shows_prec_sum zero_nat;

instance (Showa a, Showa b) => Showa (Sum a b) where {
  shows_prec = shows_prec_sum;
  shows_list = shows_list_sum;
};

data Trans_var a = Pre a | Post a | Intermediate a;

equal_trans_var :: forall a. (Eq a) => Trans_var a -> Trans_var a -> Bool;
equal_trans_var (Post x2) (Intermediate x3) = False;
equal_trans_var (Intermediate x3) (Post x2) = False;
equal_trans_var (Pre x1) (Intermediate x3) = False;
equal_trans_var (Intermediate x3) (Pre x1) = False;
equal_trans_var (Pre x1) (Post x2) = False;
equal_trans_var (Post x2) (Pre x1) = False;
equal_trans_var (Intermediate x3) (Intermediate y3) = x3 == y3;
equal_trans_var (Post x2) (Post y2) = x2 == y2;
equal_trans_var (Pre x1) (Pre y1) = x1 == y1;

instance (Eq a) => Eq (Trans_var a) where {
  a == b = equal_trans_var a b;
};

showsp_trans_var ::
  forall a.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      Nat -> Trans_var a -> [Prelude.Char] -> [Prelude.Char];
showsp_trans_var show_v p (Intermediate x) =
  (((shows_pl p .
      shows_string
        ['I', 'n', 't', 'e', 'r', 'm', 'e', 'd', 'i', 'a', 't', 'e']) .
     shows_space) .
    show_v one_nat x) .
    shows_pr p;
showsp_trans_var show_v p (Post x) =
  (((shows_pl p . shows_string ['P', 'o', 's', 't']) . shows_space) .
    show_v one_nat x) .
    shows_pr p;
showsp_trans_var show_v p (Pre x) =
  (((shows_pl p . shows_string ['P', 'r', 'e']) . shows_space) .
    show_v one_nat x) .
    shows_pr p;

shows_prec_trans_var ::
  forall a. (Showa a) => Nat -> Trans_var a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_trans_var = showsp_trans_var shows_prec;

shows_list_trans_var ::
  forall a. (Showa a) => [Trans_var a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_trans_var = showsp_list shows_prec_trans_var zero_nat;

instance (Showa a) => Showa (Trans_var a) where {
  shows_prec = shows_prec_trans_var;
  shows_list = shows_list_trans_var;
};

comparator_trans_var ::
  forall a. (a -> a -> Ordera) -> Trans_var a -> Trans_var a -> Ordera;
comparator_trans_var comp_v (Intermediate x) (Intermediate yb) = comp_v x yb;
comparator_trans_var comp_v (Intermediate x) (Post ya) = Gt;
comparator_trans_var comp_v (Intermediate x) (Pre y) = Gt;
comparator_trans_var comp_v (Post x) (Intermediate yb) = Lt;
comparator_trans_var comp_v (Post x) (Post ya) = comp_v x ya;
comparator_trans_var comp_v (Post x) (Pre y) = Gt;
comparator_trans_var comp_v (Pre x) (Intermediate yb) = Lt;
comparator_trans_var comp_v (Pre x) (Post ya) = Lt;
comparator_trans_var comp_v (Pre x) (Pre y) = comp_v x y;

compare_trans_var ::
  forall a. (Compare a) => Trans_var a -> Trans_var a -> Ordera;
compare_trans_var = comparator_trans_var compare;

less_eq_trans_var ::
  forall a. (Compare a) => Trans_var a -> Trans_var a -> Bool;
less_eq_trans_var = le_of_comp compare_trans_var;

less_trans_var :: forall a. (Compare a) => Trans_var a -> Trans_var a -> Bool;
less_trans_var = lt_of_comp compare_trans_var;

instance (Compare a) => Ord (Trans_var a) where {
  less_eq = less_eq_trans_var;
  less = less_trans_var;
};

instance (Compare a) => Quasi_order (Trans_var a) where {
};

instance (Compare a) => Weak_order (Trans_var a) where {
};

instance (Compare a) => Preorder (Trans_var a) where {
};

instance (Compare a) => Order (Trans_var a) where {
};

instance (Compare a) => Linorder (Trans_var a) where {
};

ccompare_trans_var ::
  forall a. (Ccompare a) => Maybe (Trans_var a -> Trans_var a -> Ordera);
ccompare_trans_var = (case ccompare of {
                       Nothing -> Nothing;
                       Just comp_v -> Just (comparator_trans_var comp_v);
                     });

instance (Ccompare a) => Ccompare (Trans_var a) where {
  ccompare = ccompare_trans_var;
};

mapping_impl_trans_var :: forall a. Phantom (Trans_var a) Mapping_impla;
mapping_impl_trans_var = Phantom Mapping_RBT;

instance Mapping_impl (Trans_var a) where {
  mapping_impl = mapping_impl_trans_var;
};

data Lab a b = Lab (Lab a b) b | FunLab (Lab a b) [Lab a b] | UnLab a
  | Sharp (Lab a b);

instance (Eq a, Eq b) => Eq (Lab a b) where {
  a == b = equal_lab a b;
};

equal_lab :: forall a b. (Eq a, Eq b) => Lab a b -> Lab a b -> Bool;
equal_lab (UnLab x3) (Sharp x4) = False;
equal_lab (Sharp x4) (UnLab x3) = False;
equal_lab (FunLab x21 x22) (Sharp x4) = False;
equal_lab (Sharp x4) (FunLab x21 x22) = False;
equal_lab (FunLab x21 x22) (UnLab x3) = False;
equal_lab (UnLab x3) (FunLab x21 x22) = False;
equal_lab (Lab x11 x12) (Sharp x4) = False;
equal_lab (Sharp x4) (Lab x11 x12) = False;
equal_lab (Lab x11 x12) (UnLab x3) = False;
equal_lab (UnLab x3) (Lab x11 x12) = False;
equal_lab (Lab x11 x12) (FunLab x21 x22) = False;
equal_lab (FunLab x21 x22) (Lab x11 x12) = False;
equal_lab (Sharp x4) (Sharp y4) = equal_lab x4 y4;
equal_lab (UnLab x3) (UnLab y3) = x3 == y3;
equal_lab (FunLab x21 x22) (FunLab y21 y22) = equal_lab x21 y21 && x22 == y22;
equal_lab (Lab x11 x12) (Lab y11 y12) = equal_lab x11 y11 && x12 == y12;

shows_lab ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Lab a b -> [Prelude.Char] -> [Prelude.Char];
shows_lab fun lab (UnLab f) = fun f;
shows_lab fun lab (Lab f l) =
  shows_lab fun lab f . shows_string ['['] . lab l . shows_string [']'];
shows_lab fun lab (Sharp f) = shows_lab fun lab f . shows_string ['#'];
shows_lab fun lab (FunLab f l) =
  shows_lab fun lab f .
    shows_string ['['] .
      shows_list_gen (shows_lab fun lab) [] [] [] [] l . shows_string [']'];

shows_prec_lab ::
  forall a b.
    (Showa a, Showa b) => Nat -> Lab a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_lab d l = shows_lab (shows_prec zero_nat) (shows_prec zero_nat) l;

shows_list_lab ::
  forall a b.
    (Showa a, Showa b) => [Lab a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_lab fs = showsp_list shows_prec_lab zero_nat fs;

instance (Showa a, Showa b) => Showa (Lab a b) where {
  shows_prec = shows_prec_lab;
  shows_list = shows_list_lab;
};

default_lab :: forall a b. (Default a) => Lab a b;
default_lab = UnLab defaulta;

instance (Default a) => Default (Lab a b) where {
  defaulta = default_lab;
};

comparator_lab ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Lab a b -> Lab a b -> Ordera;
comparator_lab comp_f comp_l (Sharp x) (Sharp ye) =
  comparator_lab comp_f comp_l x ye;
comparator_lab comp_f comp_l (Sharp x) (UnLab yd) = Gt;
comparator_lab comp_f comp_l (Sharp x) (FunLab yb yc) = Gt;
comparator_lab comp_f comp_l (Sharp x) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (UnLab x) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (UnLab x) (UnLab yd) = comp_f x yd;
comparator_lab comp_f comp_l (UnLab x) (FunLab yb yc) = Gt;
comparator_lab comp_f comp_l (UnLab x) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (FunLab x xa) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (FunLab x xa) (UnLab yd) = Lt;
comparator_lab comp_f comp_l (FunLab x xa) (FunLab yb yc) =
  (case comparator_lab comp_f comp_l x yb of {
    Eqa -> comparator_list (comparator_lab comp_f comp_l) xa yc;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_lab comp_f comp_l (FunLab x xa) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (Lab x xa) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (UnLab yd) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (FunLab yb yc) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (Lab y ya) =
  (case comparator_lab comp_f comp_l x y of {
    Eqa -> comp_l xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });

compare_lab ::
  forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Ordera;
compare_lab = comparator_lab compare compare;

less_eq_lab :: forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Bool;
less_eq_lab = le_of_comp compare_lab;

less_lab :: forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Bool;
less_lab = lt_of_comp compare_lab;

instance (Compare a, Compare b) => Ord (Lab a b) where {
  less_eq = less_eq_lab;
  less = less_lab;
};

instance (Compare a, Compare b) => Quasi_order (Lab a b) where {
};

instance (Compare a, Compare b) => Weak_order (Lab a b) where {
};

instance (Compare a, Compare b) => Preorder (Lab a b) where {
};

instance (Compare a, Compare b) => Order (Lab a b) where {
};

instance (Compare a, Compare b) => Linorder (Lab a b) where {
};

instance (Compare a, Compare b) => Compare (Lab a b) where {
  compare = compare_lab;
};

instance (Compare a, Compare b) => Compare_order (Lab a b) where {
};

instance (Key a, Key b) => Key (Lab a b) where {
};

ceq_lab :: forall a b. (Eq a, Eq b) => Maybe (Lab a b -> Lab a b -> Bool);
ceq_lab = Just equal_lab;

instance (Eq a, Eq b) => Ceq (Lab a b) where {
  ceq = ceq_lab;
};

set_impl_lab :: forall a b. Phantom (Lab a b) Set_impla;
set_impl_lab = Phantom Set_RBT;

instance Set_impl (Lab a b) where {
  set_impl = set_impl_lab;
};

finite_UNIV_lab :: forall a b. Phantom (Lab a b) Bool;
finite_UNIV_lab = Phantom False;

card_UNIV_lab :: forall a b. Phantom (Lab a b) Nat;
card_UNIV_lab = Phantom zero_nat;

instance Finite_UNIV (Lab a b) where {
  finite_UNIV = finite_UNIV_lab;
};

instance Card_UNIV (Lab a b) where {
  card_UNIVa = card_UNIV_lab;
};

cEnum_lab ::
  forall a b.
    Maybe ([Lab a b], ((Lab a b -> Bool) -> Bool, (Lab a b -> Bool) -> Bool));
cEnum_lab = Nothing;

instance Cenum (Lab a b) where {
  cEnum = cEnum_lab;
};

ccompare_lab ::
  forall a b. (Compare a, Compare b) => Maybe (Lab a b -> Lab a b -> Ordera);
ccompare_lab = Just compare_lab;

instance (Compare a, Compare b) => Ccompare (Lab a b) where {
  ccompare = ccompare_lab;
};

mapping_impl_lab :: forall a b. Phantom (Lab a b) Mapping_impla;
mapping_impl_lab = Phantom Mapping_RBT;

instance Mapping_impl (Lab a b) where {
  mapping_impl = mapping_impl_lab;
};

cproper_interval_lab ::
  forall a b.
    (Compare a, Compare b) => Maybe (Lab a b) -> Maybe (Lab a b) -> Bool;
cproper_interval_lab = (\ _ _ -> False);

instance (Compare a, Compare b) => Cproper_interval (Lab a b) where {
  cproper_interval = cproper_interval_lab;
};

equality_option :: forall a. (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool;
equality_option eq_a (Just x) (Just y) = eq_a x y;
equality_option eq_a (Just x) Nothing = False;
equality_option eq_a Nothing (Just y) = False;
equality_option eq_a Nothing Nothing = True;

ceq_option :: forall a. (Ceq a) => Maybe (Maybe a -> Maybe a -> Bool);
ceq_option = (case ceq of {
               Nothing -> Nothing;
               Just eq_a -> Just (equality_option eq_a);
             });

instance (Ceq a) => Ceq (Maybe a) where {
  ceq = ceq_option;
};

set_impl_option :: forall a. (Set_impl a) => Phantom (Maybe a) Set_impla;
set_impl_option = Phantom (of_phantom (set_impl :: Phantom a Set_impla));

instance (Set_impl a) => Set_impl (Maybe a) where {
  set_impl = set_impl_option;
};

cEnum_option ::
  forall a.
    (Cenum a) => Maybe ([Maybe a],
                         ((Maybe a -> Bool) -> Bool,
                           (Maybe a -> Bool) -> Bool));
cEnum_option =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (enum_all_a, enum_ex_a)) ->
      Just (Nothing : map Just enum_a,
             ((\ p -> p Nothing && enum_all_a (\ x -> p (Just x))),
               (\ p -> p Nothing || enum_ex_a (\ x -> p (Just x)))));
  });

instance (Cenum a) => Cenum (Maybe a) where {
  cEnum = cEnum_option;
};

finite_UNIV_option :: forall a. (Finite_UNIV a) => Phantom (Maybe a) Bool;
finite_UNIV_option = Phantom (of_phantom (finite_UNIV :: Phantom a Bool));

instance (Finite_UNIV a) => Finite_UNIV (Maybe a) where {
  finite_UNIV = finite_UNIV_option;
};

comparator_option ::
  forall a. (a -> a -> Ordera) -> Maybe a -> Maybe a -> Ordera;
comparator_option comp_a (Just x) (Just y) = comp_a x y;
comparator_option comp_a (Just x) Nothing = Gt;
comparator_option comp_a Nothing (Just y) = Lt;
comparator_option comp_a Nothing Nothing = Eqa;

ccompare_option ::
  forall a. (Ccompare a) => Maybe (Maybe a -> Maybe a -> Ordera);
ccompare_option = (case ccompare of {
                    Nothing -> Nothing;
                    Just comp_a -> Just (comparator_option comp_a);
                  });

instance (Ccompare a) => Ccompare (Maybe a) where {
  ccompare = ccompare_option;
};

mapping_impl_option ::
  forall a. (Mapping_impl a) => Phantom (Maybe a) Mapping_impla;
mapping_impl_option =
  Phantom (of_phantom (mapping_impl :: Phantom a Mapping_impla));

instance (Mapping_impl a) => Mapping_impl (Maybe a) where {
  mapping_impl = mapping_impl_option;
};

cproper_interval_option ::
  forall a. (Cproper_interval a) => Maybe (Maybe a) -> Maybe (Maybe a) -> Bool;
cproper_interval_option Nothing Nothing = True;
cproper_interval_option Nothing (Just x) = not (is_none x);
cproper_interval_option (Just x) Nothing = cproper_interval x Nothing;
cproper_interval_option (Just x) (Just Nothing) = False;
cproper_interval_option (Just x) (Just (Just y)) = cproper_interval x (Just y);

instance (Cproper_interval a) => Cproper_interval (Maybe a) where {
  cproper_interval = cproper_interval_option;
};

data QDelta = QDelta Rat Rat;

equal_QDelta :: QDelta -> QDelta -> Bool;
equal_QDelta (QDelta x1 x2) (QDelta y1 y2) = equal_rat x1 y1 && equal_rat x2 y2;

instance Eq QDelta where {
  a == b = equal_QDelta a b;
};

one_QDelta :: QDelta;
one_QDelta = QDelta one_rat zero_rat;

instance One QDelta where {
  onea = one_QDelta;
};

qdsnd :: QDelta -> Rat;
qdsnd (QDelta a b) = b;

qdfst :: QDelta -> Rat;
qdfst (QDelta a b) = a;

scaleRat_QDelta :: Rat -> QDelta -> QDelta;
scaleRat_QDelta r qd = QDelta (times_rat r (qdfst qd)) (times_rat r (qdsnd qd));

uminus_QDelta :: QDelta -> QDelta;
uminus_QDelta qd = QDelta (uminus_rat (qdfst qd)) (uminus_rat (qdsnd qd));

less_eq_QDelta :: QDelta -> QDelta -> Bool;
less_eq_QDelta qd1 qd2 =
  less_rat (qdfst qd1) (qdfst qd2) ||
    equal_rat (qdfst qd1) (qdfst qd2) && less_eq_rat (qdsnd qd1) (qdsnd qd2);

minus_QDelta :: QDelta -> QDelta -> QDelta;
minus_QDelta qd1 qd2 =
  QDelta (minus_rat (qdfst qd1) (qdfst qd2))
    (minus_rat (qdsnd qd1) (qdsnd qd2));

zero_QDelta :: QDelta;
zero_QDelta = QDelta zero_rat zero_rat;

plus_QDelta :: QDelta -> QDelta -> QDelta;
plus_QDelta qd1 qd2 =
  QDelta (plus_rat (qdfst qd1) (qdfst qd2)) (plus_rat (qdsnd qd1) (qdsnd qd2));

less_QDelta :: QDelta -> QDelta -> Bool;
less_QDelta qd1 qd2 =
  less_rat (qdfst qd1) (qdfst qd2) ||
    equal_rat (qdfst qd1) (qdfst qd2) && less_rat (qdsnd qd1) (qdsnd qd2);

class ScaleRat a where {
  scaleRat :: Rat -> a -> a;
};

class (ScaleRat a, Ab_group_add a) => Rational_vector a where {
};

class (Rational_vector a, Order a) => Ordered_rational_vector a where {
};

class (Ordered_rational_vector a, Ordered_ab_semigroup_add a,
        Linorder a) => Linordered_rational_vector a where {
};

class (Linordered_rational_vector a, One a) => Lrv a where {
};

instance Plus QDelta where {
  plus = plus_QDelta;
};

instance Semigroup_add QDelta where {
};

instance Ab_semigroup_add QDelta where {
};

instance Ord QDelta where {
  less_eq = less_eq_QDelta;
  less = less_QDelta;
};

instance Quasi_order QDelta where {
};

instance Weak_order QDelta where {
};

instance Preorder QDelta where {
};

instance Order QDelta where {
};

instance Ordered_ab_semigroup_add QDelta where {
};

instance Cancel_semigroup_add QDelta where {
};

instance Minus QDelta where {
  minus = minus_QDelta;
};

instance Cancel_ab_semigroup_add QDelta where {
};

instance Zero QDelta where {
  zerob = zero_QDelta;
};

instance Monoid_add QDelta where {
};

instance Comm_monoid_add QDelta where {
};

instance Cancel_comm_monoid_add QDelta where {
};

instance Uminus QDelta where {
  uminus = uminus_QDelta;
};

instance Group_add QDelta where {
};

instance Ab_group_add QDelta where {
};

instance ScaleRat QDelta where {
  scaleRat = scaleRat_QDelta;
};

instance Rational_vector QDelta where {
};

instance Ordered_rational_vector QDelta where {
};

instance Linorder QDelta where {
};

instance Linordered_rational_vector QDelta where {
};

instance Lrv QDelta where {
};

data Complex = Complex Real Real;

re :: Complex -> Real;
re (Complex x1 x2) = x1;

im :: Complex -> Real;
im (Complex x1 x2) = x2;

inverse_complex :: Complex -> Complex;
inverse_complex x =
  Complex
    (divide_real (re x)
      (plus_real (binary_power (re x) (nat_of_integer (2 :: Integer)))
        (binary_power (im x) (nat_of_integer (2 :: Integer)))))
    (divide_real (uminus_real (im x))
      (plus_real (binary_power (re x) (nat_of_integer (2 :: Integer)))
        (binary_power (im x) (nat_of_integer (2 :: Integer)))));

uminus_complex :: Complex -> Complex;
uminus_complex x = Complex (uminus_real (re x)) (uminus_real (im x));

times_complex :: Complex -> Complex -> Complex;
times_complex x y =
  Complex (minus_real (times_real (re x) (re y)) (times_real (im x) (im y)))
    (plus_real (times_real (re x) (im y)) (times_real (im x) (re y)));

divide_complex :: Complex -> Complex -> Complex;
divide_complex x y = times_complex x (inverse_complex y);

minus_complex :: Complex -> Complex -> Complex;
minus_complex x y =
  Complex (minus_real (re x) (re y)) (minus_real (im x) (im y));

zero_complex :: Complex;
zero_complex = Complex zero_real zero_real;

plus_complex :: Complex -> Complex -> Complex;
plus_complex x y = Complex (plus_real (re x) (re y)) (plus_real (im x) (im y));

one_complex :: Complex;
one_complex = Complex one_real zero_real;

instance Plus Complex where {
  plus = plus_complex;
};

instance Semigroup_add Complex where {
};

instance Ab_semigroup_add Complex where {
};

instance Zero Complex where {
  zerob = zero_complex;
};

instance Monoid_add Complex where {
};

instance Comm_monoid_add Complex where {
};

instance Times Complex where {
  times = times_complex;
};

instance Mult_zero Complex where {
};

instance Semigroup_mult Complex where {
};

instance Semiring Complex where {
};

instance Semiring_0 Complex where {
};

instance Semiring_no_zero_divisors Complex where {
};

instance One Complex where {
  onea = one_complex;
};

instance Power Complex where {
};

instance Monoid_mult Complex where {
};

instance Numeral Complex where {
};

instance Semiring_numeral Complex where {
};

instance Zero_neq_one Complex where {
};

instance Semiring_1 Complex where {
};

instance Semiring_1_no_zero_divisors Complex where {
};

instance Semiring_no_zero_divisors_cancel Complex where {
};

instance Cancel_semigroup_add Complex where {
};

instance Minus Complex where {
  minus = minus_complex;
};

instance Cancel_ab_semigroup_add Complex where {
};

instance Cancel_comm_monoid_add Complex where {
};

instance Semiring_0_cancel Complex where {
};

instance Uminus Complex where {
  uminus = uminus_complex;
};

instance Group_add Complex where {
};

instance Ab_group_add Complex where {
};

instance Ring Complex where {
};

instance Ring_no_zero_divisors Complex where {
};

instance Semiring_1_cancel Complex where {
};

instance Neg_numeral Complex where {
};

instance Ring_1 Complex where {
};

instance Ring_1_no_zero_divisors Complex where {
};

instance Divide Complex where {
  divide = divide_complex;
};

instance Inverse Complex where {
  inverse = inverse_complex;
};

instance Division_ring Complex where {
};

instance Ab_semigroup_mult Complex where {
};

instance Comm_semiring Complex where {
};

instance Comm_semiring_0 Complex where {
};

instance Comm_semiring_0_cancel Complex where {
};

instance Dvd Complex where {
};

instance Comm_monoid_mult Complex where {
};

instance Comm_semiring_1 Complex where {
};

instance Comm_semiring_1_cancel Complex where {
};

instance Semidom Complex where {
};

instance Semidom_divide Complex where {
};

instance Comm_semiring_1_cancel_crossproduct Complex where {
};

instance Comm_ring Complex where {
};

instance Comm_ring_1 Complex where {
};

instance Idom Complex where {
};

instance Idom_divide Complex where {
};

instance Field Complex where {
};

unit_factor_complex :: Complex -> Complex;
unit_factor_complex = unit_factor_field;

equal_complex :: Complex -> Complex -> Bool;
equal_complex (Complex x1 x2) (Complex y1 y2) =
  equal_real x1 y1 && equal_real x2 y2;

instance Eq Complex where {
  a == b = equal_complex a b;
};

euclidean_size_complex :: Complex -> Nat;
euclidean_size_complex = euclidean_size_field;

normalize_complex :: Complex -> Complex;
normalize_complex = normalize_field;

modulo_complex :: Complex -> Complex -> Complex;
modulo_complex = mod_field;

instance Algebraic_semidom Complex where {
};

instance Normalization_semidom Complex where {
  normalizeb = normalize_complex;
  unit_factor = unit_factor_complex;
};

instance Factorial_semiring Complex where {
};

instance Modulo Complex where {
  modulo = modulo_complex;
};

instance Semiring_modulo Complex where {
};

instance Euclidean_semiring Complex where {
  euclidean_size = euclidean_size_complex;
};

lcm_complexa :: Complex -> Complex -> Complex;
lcm_complexa = lcm_eucla;

gcd_complexa :: Complex -> Complex -> Complex;
gcd_complexa = gcd_eucla;

lcm_complex :: Set Complex -> Complex;
lcm_complex = lcm_eucl;

gcd_complex :: Set Complex -> Complex;
gcd_complex = gcd_eucl;

instance Gcda Complex where {
  gcda = gcd_complexa;
  lcma = lcm_complexa;
};

instance Gcd Complex where {
  gcd = gcd_complex;
  lcm = lcm_complex;
};

show_complex :: Complex -> [Prelude.Char];
show_complex x =
  let {
    r = re x;
    i = im x;
  } in (if equal_real i zero_real then show_real r
         else (if equal_real r zero_real then show_real i ++ ['i']
                else ['('] ++
                       show_real r ++ ['+'] ++ show_real i ++ ['i', ')']));

showsp_complex :: Nat -> Complex -> [Prelude.Char] -> [Prelude.Char];
showsp_complex p x y = show_complex x ++ y;

shows_prec_complex :: Nat -> Complex -> [Prelude.Char] -> [Prelude.Char];
shows_prec_complex = showsp_complex;

shows_list_complex :: [Complex] -> [Prelude.Char] -> [Prelude.Char];
shows_list_complex = showsp_list shows_prec_complex zero_nat;

instance Showa Complex where {
  shows_prec = shows_prec_complex;
  shows_list = shows_list_complex;
};

instance Semiring_gcd Complex where {
};

instance Ring_gcd Complex where {
};

instance Semiring_char_0 Complex where {
};

instance Ring_char_0 Complex where {
};

instance Semiring_Gcd Complex where {
};

instance Field_char_0 Complex where {
};

scaleR_complex :: Real -> Complex -> Complex;
scaleR_complex r x = Complex (times_real r (re x)) (times_real r (im x));

instance ScaleR Complex where {
  scaleR = scaleR_complex;
};

instance Real_vector Complex where {
};

class (Real_vector a, Ring a) => Real_algebra a where {
};

instance Real_algebra Complex where {
};

instance Factorial_semiring_gcd Complex where {
};

instance Factorial_ring_gcd Complex where {
};

class (Ring_char_0 a, Real_algebra a) => Real_algebra_1 a where {
};

instance Real_algebra_1 Complex where {
};

instance Euclidean_ring Complex where {
};

instance Euclidean_semiring_gcd Complex where {
};

instance Euclidean_ring_gcd Complex where {
};

data Formula a = Atom a | NegAtom a | Conjunction [Formula a]
  | Disjunction [Formula a];

instance (Eq a) => Eq (Formula a) where {
  a == b = equal_formula a b;
};

equal_formula :: forall a. (Eq a) => Formula a -> Formula a -> Bool;
equal_formula (Conjunction x3) (Disjunction x4) = False;
equal_formula (Disjunction x4) (Conjunction x3) = False;
equal_formula (NegAtom x2) (Disjunction x4) = False;
equal_formula (Disjunction x4) (NegAtom x2) = False;
equal_formula (NegAtom x2) (Conjunction x3) = False;
equal_formula (Conjunction x3) (NegAtom x2) = False;
equal_formula (Atom x1) (Disjunction x4) = False;
equal_formula (Disjunction x4) (Atom x1) = False;
equal_formula (Atom x1) (Conjunction x3) = False;
equal_formula (Conjunction x3) (Atom x1) = False;
equal_formula (Atom x1) (NegAtom x2) = False;
equal_formula (NegAtom x2) (Atom x1) = False;
equal_formula (Disjunction x4) (Disjunction y4) = x4 == y4;
equal_formula (Conjunction x3) (Conjunction y3) = x3 == y3;
equal_formula (NegAtom x2) (NegAtom y2) = x2 == y2;
equal_formula (Atom x1) (Atom y1) = x1 == y1;

count_of :: forall a. (Eq a) => [(a, Nat)] -> a -> Nat;
count_of xs x = (case map_of xs x of {
                  Nothing -> zero_nat;
                  Just n -> n;
                });

newtype Alist b a = Alist [(b, a)];

impl_ofa :: forall b a. Alist b a -> [(b, a)];
impl_ofa (Alist x) = x;

newtype Multiset a = Bag (Alist a Nat);

count :: forall a. (Eq a) => Multiset a -> a -> Nat;
count (Bag xs) = count_of (impl_ofa xs);

subseteq_mset :: forall a. (Eq a) => Multiset a -> Multiset a -> Bool;
subseteq_mset (Bag xs) a =
  all (\ (x, n) -> less_eq_nat n (count a x)) (impl_ofa xs);

equal_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Bool;
equal_multiset m1 m2 = subseteq_mset m1 m2 && subseteq_mset m2 m1;

instance (Eq a) => Eq (Multiset a) where {
  a == b = equal_multiset a b;
};

map_default :: forall a b. (Eq a) => a -> b -> (b -> b) -> [(a, b)] -> [(a, b)];
map_default k v f [] = [(k, v)];
map_default k v f (p : ps) =
  (if fst p == k then (k, f (snd p)) : ps else p : map_default k v f ps);

join_raw ::
  forall a b. (Eq a) => (a -> (b, b) -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
join_raw f xs ys =
  foldr (\ (k, v) -> map_default k v (\ va -> f k (va, v))) ys xs;

joina ::
  forall a b.
    (Eq a) => (a -> (b, b) -> b) -> Alist a b -> Alist a b -> Alist a b;
joina xc xd xe = Alist (join_raw xc (impl_ofa xd) (impl_ofa xe));

plus_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
plus_multiset (Bag xs) (Bag ys) =
  Bag (joina (\ _ (a, b) -> plus_nat a b) xs ys);

instance (Eq a) => Plus (Multiset a) where {
  plus = plus_multiset;
};

emptya :: forall a b. Alist a b;
emptya = Alist [];

zero_multiset :: forall a. Multiset a;
zero_multiset = Bag emptya;

instance Zero (Multiset a) where {
  zerob = zero_multiset;
};

instance (Eq a) => Semigroup_add (Multiset a) where {
};

instance (Eq a) => Monoid_add (Multiset a) where {
};

instance (Eq a) => Ab_semigroup_add (Multiset a) where {
};

instance (Eq a) => Comm_monoid_add (Multiset a) where {
};

showsp_prod ::
  forall a b.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      (Nat -> b -> [Prelude.Char] -> [Prelude.Char]) ->
        Nat -> (a, b) -> [Prelude.Char] -> [Prelude.Char];
showsp_prod s1 s2 p (x, y) =
  (((shows_string ['('] . s1 one_nat x) . shows_string [',', ' ']) .
    s2 one_nat y) .
    shows_string [')'];

shows_prec_prod ::
  forall a b.
    (Showa a, Showa b) => Nat -> (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_prec_prod = showsp_prod shows_prec shows_prec;

shows_list_prod ::
  forall a b.
    (Showa a, Showa b) => [(a, b)] -> [Prelude.Char] -> [Prelude.Char];
shows_list_prod = showsp_list shows_prec_prod zero_nat;

instance (Showa a, Showa b) => Showa (a, b) where {
  shows_prec = shows_prec_prod;
  shows_list = shows_list_prod;
};

less_eq_prod :: forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Bool;
less_eq_prod (x1, y1) (x2, y2) = less x1 x2 || less_eq x1 x2 && less_eq y1 y2;

less_prod :: forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Bool;
less_prod (x1, y1) (x2, y2) = less x1 x2 || less_eq x1 x2 && less y1 y2;

instance (Ord a, Ord b) => Ord (a, b) where {
  less_eq = less_eq_prod;
  less = less_prod;
};

comparator_prod ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> (a, b) -> (a, b) -> Ordera;
comparator_prod comp_a comp_b (x, xa) (y, ya) = (case comp_a x y of {
          Eqa -> comp_b xa ya;
          Lt -> Lt;
          Gt -> Gt;
        });

compare_prod ::
  forall a b. (Compare a, Compare b) => (a, b) -> (a, b) -> Ordera;
compare_prod = comparator_prod compare compare;

instance (Order a, Order b) => Quasi_order (a, b) where {
};

instance (Order a, Order b) => Weak_order (a, b) where {
};

instance (Preorder a, Preorder b) => Preorder (a, b) where {
};

instance (Order a, Order b) => Order (a, b) where {
};

instance (Linorder a, Linorder b) => Linorder (a, b) where {
};

instance (Compare a, Compare b) => Compare (a, b) where {
  compare = compare_prod;
};

instance (Compare_order a, Compare_order b) => Compare_order (a, b) where {
};

instance (Key a, Key b) => Key (a, b) where {
};

equality_prod ::
  forall a b. (a -> a -> Bool) -> (b -> b -> Bool) -> (a, b) -> (a, b) -> Bool;
equality_prod eq_a eq_b (x, xa) (y, ya) = eq_a x y && eq_b xa ya;

ceq_prod :: forall a b. (Ceq a, Ceq b) => Maybe ((a, b) -> (a, b) -> Bool);
ceq_prod = (case ceq of {
             Nothing -> Nothing;
             Just eq_a -> (case ceq of {
                            Nothing -> Nothing;
                            Just eq_b -> Just (equality_prod eq_a eq_b);
                          });
           });

instance (Ceq a, Ceq b) => Ceq (a, b) where {
  ceq = ceq_prod;
};

set_impl_choose2 :: Set_impla -> Set_impla -> Set_impla;
set_impl_choose2 Set_Monada Set_Monada = Set_Monada;
set_impl_choose2 Set_RBT Set_RBT = Set_RBT;
set_impl_choose2 Set_DList Set_DList = Set_DList;
set_impl_choose2 Set_Collect Set_Collect = Set_Collect;
set_impl_choose2 x y = Set_Choose;

set_impl_prod ::
  forall a b. (Set_impl a, Set_impl b) => Phantom (a, b) Set_impla;
set_impl_prod =
  Phantom
    (set_impl_choose2 (of_phantom (set_impl :: Phantom a Set_impla))
      (of_phantom (set_impl :: Phantom b Set_impla)));

instance (Set_impl a, Set_impl b) => Set_impl (a, b) where {
  set_impl = set_impl_prod;
};

finite_UNIV_prod ::
  forall a b. (Finite_UNIV a, Finite_UNIV b) => Phantom (a, b) Bool;
finite_UNIV_prod =
  Phantom
    (of_phantom (finite_UNIV :: Phantom a Bool) &&
      of_phantom (finite_UNIV :: Phantom b Bool));

card_UNIV_prod :: forall a b. (Card_UNIV a, Card_UNIV b) => Phantom (a, b) Nat;
card_UNIV_prod =
  Phantom
    (times_nat (of_phantom (card_UNIVa :: Phantom a Nat))
      (of_phantom (card_UNIVa :: Phantom b Nat)));

instance (Finite_UNIV a, Finite_UNIV b) => Finite_UNIV (a, b) where {
  finite_UNIV = finite_UNIV_prod;
};

instance (Card_UNIV a, Card_UNIV b) => Card_UNIV (a, b) where {
  card_UNIVa = card_UNIV_prod;
};

product :: forall a b. [a] -> [b] -> [(a, b)];
product [] uu = [];
product (x : xs) ys = map (\ a -> (x, a)) ys ++ product xs ys;

cEnum_prod ::
  forall a b.
    (Cenum a,
      Cenum b) => Maybe ([(a, b)],
                          (((a, b) -> Bool) -> Bool, ((a, b) -> Bool) -> Bool));
cEnum_prod =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (enum_all_a, enum_ex_a)) ->
      (case cEnum of {
        Nothing -> Nothing;
        Just (enum_b, (enum_all_b, enum_ex_b)) ->
          Just (product enum_a enum_b,
                 ((\ p -> enum_all_a (\ x -> enum_all_b (\ y -> p (x, y)))),
                   (\ p -> enum_ex_a (\ x -> enum_ex_b (\ y -> p (x, y))))));
      });
  });

instance (Cenum a, Cenum b) => Cenum (a, b) where {
  cEnum = cEnum_prod;
};

ccompare_prod ::
  forall a b. (Ccompare a, Ccompare b) => Maybe ((a, b) -> (a, b) -> Ordera);
ccompare_prod =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_a -> (case ccompare of {
                     Nothing -> Nothing;
                     Just comp_b -> Just (comparator_prod comp_a comp_b);
                   });
  });

instance (Ccompare a, Ccompare b) => Ccompare (a, b) where {
  ccompare = ccompare_prod;
};

mapping_impl_choose2 :: Mapping_impla -> Mapping_impla -> Mapping_impla;
mapping_impl_choose2 Mapping_RBT Mapping_RBT = Mapping_RBT;
mapping_impl_choose2 Mapping_Assoc_List Mapping_Assoc_List = Mapping_Assoc_List;
mapping_impl_choose2 Mapping_Mapping Mapping_Mapping = Mapping_Mapping;
mapping_impl_choose2 x y = Mapping_Choose;

mapping_impl_prod ::
  forall a b. (Mapping_impl a, Mapping_impl b) => Phantom (a, b) Mapping_impla;
mapping_impl_prod =
  Phantom
    (mapping_impl_choose2 (of_phantom (mapping_impl :: Phantom a Mapping_impla))
      (of_phantom (mapping_impl :: Phantom b Mapping_impla)));

instance (Mapping_impl a, Mapping_impl b) => Mapping_impl (a, b) where {
  mapping_impl = mapping_impl_prod;
};

cproper_interval_prod ::
  forall a b.
    (Cproper_interval a,
      Cproper_interval b) => Maybe (a, b) -> Maybe (a, b) -> Bool;
cproper_interval_prod Nothing Nothing = True;
cproper_interval_prod Nothing (Just (y1, y2)) =
  cproper_interval Nothing (Just y1) || cproper_interval Nothing (Just y2);
cproper_interval_prod (Just (x1, x2)) Nothing =
  cproper_interval (Just x1) Nothing || cproper_interval (Just x2) Nothing;
cproper_interval_prod (Just (x1, x2)) (Just (y1, y2)) =
  cproper_interval (Just x1) (Just y1) ||
    (lt_of_comp (the ccompare) x1 y1 &&
       (cproper_interval (Just x2) Nothing ||
         cproper_interval Nothing (Just y2)) ||
      not (lt_of_comp (the ccompare) y1 x1) &&
        cproper_interval (Just x2) (Just y2));

instance (Cproper_interval a,
           Cproper_interval b) => Cproper_interval (a, b) where {
  cproper_interval = cproper_interval_prod;
};

comparator_unit :: () -> () -> Ordera;
comparator_unit x y = Eqa;

compare_unit :: () -> () -> Ordera;
compare_unit = comparator_unit;

instance Compare () where {
  compare = compare_unit;
};

data Hints = Hints [Int] | Simplex;

showsp_hints :: Nat -> Hints -> [Prelude.Char] -> [Prelude.Char];
showsp_hints p Simplex = shows_string ['S', 'i', 'm', 'p', 'l', 'e', 'x'];
showsp_hints p (Hints x) =
  (((shows_pl p . shows_string ['H', 'i', 'n', 't', 's']) . shows_space) .
    showsp_list showsp_int one_nat x) .
    shows_pr p;

shows_prec_hints :: Nat -> Hints -> [Prelude.Char] -> [Prelude.Char];
shows_prec_hints = showsp_hints;

shows_list_hints :: [Hints] -> [Prelude.Char] -> [Prelude.Char];
shows_list_hints = showsp_list shows_prec_hints zero_nat;

instance Showa Hints where {
  shows_prec = shows_prec_hints;
  shows_list = shows_list_hints;
};

default_hints :: Hints;
default_hints = Simplex;

instance Default Hints where {
  defaulta = default_hints;
};

data Transition_rule a b c d =
  Transition d d (Formula (Term a (Trans_var b, c)));

equal_transition_rule ::
  forall a b c d.
    (Eq a, Eq b, Eq c,
      Eq d) => Transition_rule a b c d -> Transition_rule a b c d -> Bool;
equal_transition_rule (Transition x1 x2 x3) (Transition y1 y2 y3) =
  x1 == y1 && x2 == y2 && equal_formula x3 y3;

ceq_transition_rule ::
  forall a b c d.
    (Eq a, Eq b, Eq c,
      Eq d) => Maybe (Transition_rule a b c d ->
                       Transition_rule a b c d -> Bool);
ceq_transition_rule = Just equal_transition_rule;

instance (Eq a, Eq b, Eq c, Eq d) => Ceq (Transition_rule a b c d) where {
  ceq = ceq_transition_rule;
};

set_impl_transition_rule ::
  forall a b c d. Phantom (Transition_rule a b c d) Set_impla;
set_impl_transition_rule = Phantom Set_RBT;

instance Set_impl (Transition_rule a b c d) where {
  set_impl = set_impl_transition_rule;
};

comparator_formula ::
  forall a. (a -> a -> Ordera) -> Formula a -> Formula a -> Ordera;
comparator_formula comp_a (Disjunction x) (Disjunction yc) =
  comparator_list (comparator_formula comp_a) x yc;
comparator_formula comp_a (Disjunction x) (Conjunction yb) = Gt;
comparator_formula comp_a (Disjunction x) (NegAtom ya) = Gt;
comparator_formula comp_a (Disjunction x) (Atom y) = Gt;
comparator_formula comp_a (Conjunction x) (Disjunction yc) = Lt;
comparator_formula comp_a (Conjunction x) (Conjunction yb) =
  comparator_list (comparator_formula comp_a) x yb;
comparator_formula comp_a (Conjunction x) (NegAtom ya) = Gt;
comparator_formula comp_a (Conjunction x) (Atom y) = Gt;
comparator_formula comp_a (NegAtom x) (Disjunction yc) = Lt;
comparator_formula comp_a (NegAtom x) (Conjunction yb) = Lt;
comparator_formula comp_a (NegAtom x) (NegAtom ya) = comp_a x ya;
comparator_formula comp_a (NegAtom x) (Atom y) = Gt;
comparator_formula comp_a (Atom x) (Disjunction yc) = Lt;
comparator_formula comp_a (Atom x) (Conjunction yb) = Lt;
comparator_formula comp_a (Atom x) (NegAtom ya) = Lt;
comparator_formula comp_a (Atom x) (Atom y) = comp_a x y;

comparator_transition_rule ::
  forall a b c d.
    (a -> a -> Ordera) ->
      (b -> b -> Ordera) ->
        (c -> c -> Ordera) ->
          (d -> d -> Ordera) ->
            Transition_rule a b c d -> Transition_rule a b c d -> Ordera;
comparator_transition_rule comp_f comp_v comp_t comp_l (Transition x xa xb)
  (Transition y ya yb) =
  (case comp_l x y of {
    Eqa ->
      (case comp_l xa ya of {
        Eqa ->
          comparator_formula
            (comparator_term comp_f
              (comparator_prod (comparator_trans_var comp_v) comp_t))
            xb yb;
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });

ccompare_transition_rule ::
  forall a b c d.
    (Ccompare a, Ccompare b, Ccompare c,
      Ccompare d) => Maybe (Transition_rule a b c d ->
                             Transition_rule a b c d -> Ordera);
ccompare_transition_rule =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_f ->
      (case ccompare of {
        Nothing -> Nothing;
        Just comp_v ->
          (case ccompare of {
            Nothing -> Nothing;
            Just comp_t ->
              (case ccompare of {
                Nothing -> Nothing;
                Just comp_l ->
                  Just (comparator_transition_rule comp_f comp_v comp_t comp_l);
              });
          });
      });
  });

instance (Ccompare a, Ccompare b, Ccompare c,
           Ccompare d) => Ccompare (Transition_rule a b c d) where {
  ccompare = ccompare_transition_rule;
};

data Gctxt a b = GCHole | GCFun a [Gctxt a b];

instance (Eq a) => Eq (Gctxt a b) where {
  a == b = equal_gctxt a b;
};

equal_gctxt :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Bool;
equal_gctxt GCHole (GCFun x21 x22) = False;
equal_gctxt (GCFun x21 x22) GCHole = False;
equal_gctxt (GCFun x21 x22) (GCFun y21 y22) = x21 == y21 && x22 == y22;
equal_gctxt GCHole GCHole = True;

ceq_gctxt :: forall a b. (Eq a) => Maybe (Gctxt a b -> Gctxt a b -> Bool);
ceq_gctxt = Just equal_gctxt;

instance (Eq a) => Ceq (Gctxt a b) where {
  ceq = ceq_gctxt;
};

set_impl_gctxt :: forall a b. Phantom (Gctxt a b) Set_impla;
set_impl_gctxt = Phantom Set_RBT;

instance Set_impl (Gctxt a b) where {
  set_impl = set_impl_gctxt;
};

comparator_gctxt ::
  forall a b. (a -> a -> Ordera) -> Gctxt a b -> Gctxt a b -> Ordera;
comparator_gctxt comp_f (GCFun x xa) (GCFun y ya) =
  (case comp_f x y of {
    Eqa -> comparator_list (comparator_gctxt comp_f) xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_gctxt comp_f (GCFun x xa) GCHole = Gt;
comparator_gctxt comp_f GCHole (GCFun y ya) = Lt;
comparator_gctxt comp_f GCHole GCHole = Eqa;

compare_gctxt :: forall a b. (Compare a) => Gctxt a b -> Gctxt a b -> Ordera;
compare_gctxt = comparator_gctxt compare;

ccompare_gctxt ::
  forall a b.
    (Compare a, Compare b) => Maybe (Gctxt a b -> Gctxt a b -> Ordera);
ccompare_gctxt = Just compare_gctxt;

instance (Compare a, Compare b) => Ccompare (Gctxt a b) where {
  ccompare = ccompare_gctxt;
};

data Acterm a b = AVar b | AFun a [Acterm a b] | AAC a (Multiset (Acterm a b));

instance (Eq a, Eq b) => Eq (Acterm a b) where {
  a == b = equal_acterm a b;
};

equal_acterm :: forall a b. (Eq a, Eq b) => Acterm a b -> Acterm a b -> Bool;
equal_acterm (AFun x21 x22) (AAC x31 x32) = False;
equal_acterm (AAC x31 x32) (AFun x21 x22) = False;
equal_acterm (AVar x1) (AAC x31 x32) = False;
equal_acterm (AAC x31 x32) (AVar x1) = False;
equal_acterm (AVar x1) (AFun x21 x22) = False;
equal_acterm (AFun x21 x22) (AVar x1) = False;
equal_acterm (AAC x31 x32) (AAC y31 y32) = x31 == y31 && equal_multiset x32 y32;
equal_acterm (AFun x21 x22) (AFun y21 y22) = x21 == y21 && x22 == y22;
equal_acterm (AVar x1) (AVar y1) = x1 == y1;

data Ta_rule a b = TA_rule b [a] a;

equal_ta_rule :: forall a b. (Eq a, Eq b) => Ta_rule a b -> Ta_rule a b -> Bool;
equal_ta_rule (TA_rule x1 x2 x3) (TA_rule y1 y2 y3) =
  x1 == y1 && x2 == y2 && x3 == y3;

instance (Eq a, Eq b) => Eq (Ta_rule a b) where {
  a == b = equal_ta_rule a b;
};

show_ta_rule ::
  forall a b.
    (Showa a, Showa b) => Ta_rule a b -> [Prelude.Char] -> [Prelude.Char];
show_ta_rule (TA_rule f qs q) =
  ((shows_prec zero_nat f . shows_prec_list zero_nat qs) .
    shows_prec_list zero_nat [' ', '-', '>', ' ']) .
    shows_prec zero_nat q;

shows_prec_ta_rule ::
  forall a b.
    (Showa a,
      Showa b) => Nat -> Ta_rule a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_ta_rule p r = show_ta_rule r;

shows_list_ta_rule ::
  forall a b.
    (Showa a, Showa b) => [Ta_rule a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_ta_rule ps = showsp_list shows_prec_ta_rule zero_nat ps;

instance (Showa a, Showa b) => Showa (Ta_rule a b) where {
  shows_prec = shows_prec_ta_rule;
  shows_list = shows_list_ta_rule;
};

comparator_ta_rule ::
  forall a b.
    (a -> a -> Ordera) ->
      (b -> b -> Ordera) -> Ta_rule a b -> Ta_rule a b -> Ordera;
comparator_ta_rule comp_q comp_f (TA_rule x xa xb) (TA_rule y ya yb) =
  (case comp_f x y of {
    Eqa -> (case comparator_list comp_q xa ya of {
             Eqa -> comp_q xb yb;
             Lt -> Lt;
             Gt -> Gt;
           });
    Lt -> Lt;
    Gt -> Gt;
  });

compare_ta_rule ::
  forall a b. (Compare a, Compare b) => Ta_rule a b -> Ta_rule a b -> Ordera;
compare_ta_rule = comparator_ta_rule compare compare;

less_eq_ta_rule ::
  forall a b. (Compare a, Compare b) => Ta_rule a b -> Ta_rule a b -> Bool;
less_eq_ta_rule = le_of_comp compare_ta_rule;

less_ta_rule ::
  forall a b. (Compare a, Compare b) => Ta_rule a b -> Ta_rule a b -> Bool;
less_ta_rule = lt_of_comp compare_ta_rule;

instance (Compare a, Compare b) => Ord (Ta_rule a b) where {
  less_eq = less_eq_ta_rule;
  less = less_ta_rule;
};

instance (Compare a, Compare b) => Quasi_order (Ta_rule a b) where {
};

instance (Compare a, Compare b) => Weak_order (Ta_rule a b) where {
};

instance (Compare a, Compare b) => Preorder (Ta_rule a b) where {
};

instance (Compare a, Compare b) => Order (Ta_rule a b) where {
};

ceq_ta_rule ::
  forall a b. (Eq a, Eq b) => Maybe (Ta_rule a b -> Ta_rule a b -> Bool);
ceq_ta_rule = Just equal_ta_rule;

instance (Eq a, Eq b) => Ceq (Ta_rule a b) where {
  ceq = ceq_ta_rule;
};

set_impl_ta_rule :: forall a b. Phantom (Ta_rule a b) Set_impla;
set_impl_ta_rule = Phantom Set_RBT;

instance Set_impl (Ta_rule a b) where {
  set_impl = set_impl_ta_rule;
};

instance (Compare a, Compare b) => Linorder (Ta_rule a b) where {
};

cEnum_ta_rule ::
  forall a b.
    Maybe ([Ta_rule a b],
            ((Ta_rule a b -> Bool) -> Bool, (Ta_rule a b -> Bool) -> Bool));
cEnum_ta_rule = Nothing;

instance Cenum (Ta_rule a b) where {
  cEnum = cEnum_ta_rule;
};

finite_UNIV_ta_rule :: forall a b. Phantom (Ta_rule a b) Bool;
finite_UNIV_ta_rule = Phantom False;

instance Finite_UNIV (Ta_rule a b) where {
  finite_UNIV = finite_UNIV_ta_rule;
};

ccompare_ta_rule ::
  forall a b.
    (Ccompare a, Ccompare b) => Maybe (Ta_rule a b -> Ta_rule a b -> Ordera);
ccompare_ta_rule =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_q -> (case ccompare of {
                     Nothing -> Nothing;
                     Just comp_f -> Just (comparator_ta_rule comp_q comp_f);
                   });
  });

instance (Ccompare a, Ccompare b) => Ccompare (Ta_rule a b) where {
  ccompare = ccompare_ta_rule;
};

cproper_interval_ta_rule ::
  forall a b.
    (Ccompare a,
      Ccompare b) => Maybe (Ta_rule a b) -> Maybe (Ta_rule a b) -> Bool;
cproper_interval_ta_rule = (\ _ _ -> False);

instance (Ccompare a, Ccompare b) => Cproper_interval (Ta_rule a b) where {
  cproper_interval = cproper_interval_ta_rule;
};

data Mctxt a b = MVar b | MHole | MFun a [Mctxt a b];

instance (Eq a, Eq b) => Eq (Mctxt a b) where {
  a == b = equal_mctxt a b;
};

equal_mctxt :: forall a b. (Eq a, Eq b) => Mctxt a b -> Mctxt a b -> Bool;
equal_mctxt MHole (MFun x31 x32) = False;
equal_mctxt (MFun x31 x32) MHole = False;
equal_mctxt (MVar x1) (MFun x31 x32) = False;
equal_mctxt (MFun x31 x32) (MVar x1) = False;
equal_mctxt (MVar x1) MHole = False;
equal_mctxt MHole (MVar x1) = False;
equal_mctxt (MFun x31 x32) (MFun y31 y32) = x31 == y31 && x32 == y32;
equal_mctxt (MVar x1) (MVar y1) = x1 == y1;
equal_mctxt MHole MHole = True;

ceq_mctxt :: forall a b. (Eq a, Eq b) => Maybe (Mctxt a b -> Mctxt a b -> Bool);
ceq_mctxt = Just equal_mctxt;

instance (Eq a, Eq b) => Ceq (Mctxt a b) where {
  ceq = ceq_mctxt;
};

set_impl_mctxt :: forall a b. Phantom (Mctxt a b) Set_impla;
set_impl_mctxt = Phantom Set_RBT;

instance Set_impl (Mctxt a b) where {
  set_impl = set_impl_mctxt;
};

comparator_mctxt ::
  forall a b.
    (a -> a -> Ordera) ->
      (b -> b -> Ordera) -> Mctxt a b -> Mctxt a b -> Ordera;
comparator_mctxt comp_f comp_v (MFun x xa) (MFun ya yb) =
  (case comp_f x ya of {
    Eqa -> comparator_list (comparator_mctxt comp_f comp_v) xa yb;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_mctxt comp_f comp_v (MFun x xa) MHole = Gt;
comparator_mctxt comp_f comp_v (MFun x xa) (MVar y) = Gt;
comparator_mctxt comp_f comp_v MHole (MFun ya yb) = Lt;
comparator_mctxt comp_f comp_v MHole MHole = Eqa;
comparator_mctxt comp_f comp_v MHole (MVar y) = Gt;
comparator_mctxt comp_f comp_v (MVar x) (MFun ya yb) = Lt;
comparator_mctxt comp_f comp_v (MVar x) MHole = Lt;
comparator_mctxt comp_f comp_v (MVar x) (MVar y) = comp_v x y;

compare_mctxt ::
  forall a b. (Compare a, Compare b) => Mctxt a b -> Mctxt a b -> Ordera;
compare_mctxt = comparator_mctxt compare compare;

ccompare_mctxt ::
  forall a b.
    (Compare a, Compare b) => Maybe (Mctxt a b -> Mctxt a b -> Ordera);
ccompare_mctxt = Just compare_mctxt;

instance (Compare a, Compare b) => Ccompare (Mctxt a b) where {
  ccompare = ccompare_mctxt;
};

data Arctic = MinInfty | Num_arc Int;

equal_arctic :: Arctic -> Arctic -> Bool;
equal_arctic MinInfty (Num_arc x2) = False;
equal_arctic (Num_arc x2) MinInfty = False;
equal_arctic (Num_arc x2) (Num_arc y2) = equal_int x2 y2;
equal_arctic MinInfty MinInfty = True;

instance Eq Arctic where {
  a == b = equal_arctic a b;
};

shows_arctic :: Arctic -> [Prelude.Char] -> [Prelude.Char];
shows_arctic (Num_arc i) = shows_prec_int zero_nat i;
shows_arctic MinInfty = shows_prec_list zero_nat ['-', 'i', 'n', 'f'];

shows_prec_arctic :: Nat -> Arctic -> [Prelude.Char] -> [Prelude.Char];
shows_prec_arctic p ai = shows_arctic ai;

shows_list_arctic :: [Arctic] -> [Prelude.Char] -> [Prelude.Char];
shows_list_arctic asa = showsp_list shows_prec_arctic zero_nat asa;

instance Showa Arctic where {
  shows_prec = shows_prec_arctic;
  shows_list = shows_list_arctic;
};

one_arctic :: Arctic;
one_arctic = Num_arc zero_int;

instance One Arctic where {
  onea = one_arctic;
};

plus_arctic :: Arctic -> Arctic -> Arctic;
plus_arctic MinInfty y = y;
plus_arctic (Num_arc v) MinInfty = Num_arc v;
plus_arctic (Num_arc x) (Num_arc y) = Num_arc (max x y);

instance Plus Arctic where {
  plus = plus_arctic;
};

zero_arctic :: Arctic;
zero_arctic = MinInfty;

instance Zero Arctic where {
  zerob = zero_arctic;
};

instance Semigroup_add Arctic where {
};

instance Numeral Arctic where {
};

times_arctic :: Arctic -> Arctic -> Arctic;
times_arctic MinInfty y = MinInfty;
times_arctic (Num_arc v) MinInfty = MinInfty;
times_arctic (Num_arc x) (Num_arc y) = Num_arc (plus_int x y);

instance Times Arctic where {
  times = times_arctic;
};

instance Power Arctic where {
};

less_eq_arctic :: Arctic -> Arctic -> Bool;
less_eq_arctic MinInfty x = True;
less_eq_arctic (Num_arc uu) MinInfty = False;
less_eq_arctic (Num_arc y) (Num_arc x) = less_eq_int y x;

less_arctic :: Arctic -> Arctic -> Bool;
less_arctic MinInfty x = True;
less_arctic (Num_arc uu) MinInfty = False;
less_arctic (Num_arc y) (Num_arc x) = less_int y x;

instance Ord Arctic where {
  less_eq = less_eq_arctic;
  less = less_arctic;
};

instance Ab_semigroup_add Arctic where {
};

instance Semigroup_mult Arctic where {
};

instance Semiring Arctic where {
};

instance Mult_zero Arctic where {
};

instance Monoid_add Arctic where {
};

instance Comm_monoid_add Arctic where {
};

instance Semiring_0 Arctic where {
};

instance Monoid_mult Arctic where {
};

instance Semiring_numeral Arctic where {
};

instance Zero_neq_one Arctic where {
};

instance Semiring_1 Arctic where {
};

ceq_arctic :: Maybe (Arctic -> Arctic -> Bool);
ceq_arctic = Just equal_arctic;

instance Ceq Arctic where {
  ceq = ceq_arctic;
};

set_impl_arctic :: Phantom Arctic Set_impla;
set_impl_arctic = Phantom Set_RBT;

instance Set_impl Arctic where {
  set_impl = set_impl_arctic;
};

cEnum_arctic ::
  Maybe ([Arctic], ((Arctic -> Bool) -> Bool, (Arctic -> Bool) -> Bool));
cEnum_arctic = Nothing;

instance Cenum Arctic where {
  cEnum = cEnum_arctic;
};

comparator_arctic :: Arctic -> Arctic -> Ordera;
comparator_arctic (Num_arc x) (Num_arc y) = comparator_of x y;
comparator_arctic (Num_arc x) MinInfty = Gt;
comparator_arctic MinInfty (Num_arc y) = Lt;
comparator_arctic MinInfty MinInfty = Eqa;

compare_arctic :: Arctic -> Arctic -> Ordera;
compare_arctic = comparator_arctic;

ccompare_arctic :: Maybe (Arctic -> Arctic -> Ordera);
ccompare_arctic = Just compare_arctic;

instance Ccompare Arctic where {
  ccompare = ccompare_arctic;
};

instance Non_strict_order Arctic where {
};

instance Ordered_ab_semigroup Arctic where {
};

instance Ordered_semiring_0a Arctic where {
};

instance Ordered_semiring_1 Arctic where {
};

data Filtered a = FPair a Nat;

equal_filtered :: forall a. (Eq a) => Filtered a -> Filtered a -> Bool;
equal_filtered (FPair x1 x2) (FPair y1 y2) = x1 == y1 && equal_nat x2 y2;

instance (Eq a) => Eq (Filtered a) where {
  a == b = equal_filtered a b;
};

filtered_fun :: forall a. Filtered a -> a;
filtered_fun (FPair f n) = f;

shows_prec_filtered ::
  forall a. (Showa a) => Nat -> Filtered a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_filtered p f = shows_prec zero_nat (filtered_fun f);

shows_list_filtered ::
  forall a. (Showa a) => [Filtered a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_filtered fs = showsp_list shows_prec_filtered zero_nat fs;

instance (Showa a) => Showa (Filtered a) where {
  shows_prec = shows_prec_filtered;
  shows_list = shows_list_filtered;
};

comparator_filtered ::
  forall a. (a -> a -> Ordera) -> Filtered a -> Filtered a -> Ordera;
comparator_filtered comp_f (FPair x xa) (FPair y ya) =
  (case comp_f x y of {
    Eqa -> comparator_of xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });

compare_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Ordera;
compare_filtered = comparator_filtered compare;

less_eq_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Bool;
less_eq_filtered = le_of_comp compare_filtered;

less_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Bool;
less_filtered = lt_of_comp compare_filtered;

instance (Compare a) => Ord (Filtered a) where {
  less_eq = less_eq_filtered;
  less = less_filtered;
};

instance (Compare a) => Quasi_order (Filtered a) where {
};

instance (Compare a) => Weak_order (Filtered a) where {
};

instance (Compare a) => Preorder (Filtered a) where {
};

instance (Compare a) => Order (Filtered a) where {
};

instance (Compare a) => Linorder (Filtered a) where {
};

instance (Compare a) => Compare (Filtered a) where {
  compare = compare_filtered;
};

instance (Compare a) => Compare_order (Filtered a) where {
};

instance (Key a) => Key (Filtered a) where {
};

data Ty = BoolT | IntT;

equal_ty :: Ty -> Ty -> Bool;
equal_ty BoolT IntT = False;
equal_ty IntT BoolT = False;
equal_ty IntT IntT = True;
equal_ty BoolT BoolT = True;

instance Eq Ty where {
  a == b = equal_ty a b;
};

showsp_ty :: Nat -> Ty -> [Prelude.Char] -> [Prelude.Char];
showsp_ty p IntT = shows_string ['I', 'n', 't', 'T'];
showsp_ty p BoolT = shows_string ['B', 'o', 'o', 'l', 'T'];

shows_prec_ty :: Nat -> Ty -> [Prelude.Char] -> [Prelude.Char];
shows_prec_ty = showsp_ty;

shows_list_ty :: [Ty] -> [Prelude.Char] -> [Prelude.Char];
shows_list_ty = showsp_list shows_prec_ty zero_nat;

instance Showa Ty where {
  shows_prec = shows_prec_ty;
  shows_list = shows_list_ty;
};

ceq_ty :: Maybe (Ty -> Ty -> Bool);
ceq_ty = Just equal_ty;

instance Ceq Ty where {
  ceq = ceq_ty;
};

comparator_ty :: Ty -> Ty -> Ordera;
comparator_ty IntT IntT = Eqa;
comparator_ty IntT BoolT = Gt;
comparator_ty BoolT IntT = Lt;
comparator_ty BoolT BoolT = Eqa;

ccompare_ty :: Maybe (Ty -> Ty -> Ordera);
ccompare_ty = Just comparator_ty;

instance Ccompare Ty where {
  ccompare = ccompare_ty;
};

data L_poly a b = LPoly b [(a, b)];

cEnum_l_poly ::
  forall a b.
    Maybe ([L_poly a b],
            ((L_poly a b -> Bool) -> Bool, (L_poly a b -> Bool) -> Bool));
cEnum_l_poly = Nothing;

instance Cenum (L_poly a b) where {
  cEnum = cEnum_l_poly;
};

data Sharp a = Flat a | Sharpa a;

equal_sharp :: forall a. (Eq a) => Sharp a -> Sharp a -> Bool;
equal_sharp (Flat x1) (Sharpa x2) = False;
equal_sharp (Sharpa x2) (Flat x1) = False;
equal_sharp (Sharpa x2) (Sharpa y2) = x2 == y2;
equal_sharp (Flat x1) (Flat y1) = x1 == y1;

instance (Eq a) => Eq (Sharp a) where {
  a == b = equal_sharp a b;
};

showsp_sharp ::
  forall a.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      Nat -> Sharp a -> [Prelude.Char] -> [Prelude.Char];
showsp_sharp show_l p (Sharpa x) =
  (((shows_pl p . shows_string ['S', 'h', 'a', 'r', 'p']) . shows_space) .
    show_l one_nat x) .
    shows_pr p;
showsp_sharp show_l p (Flat x) =
  (((shows_pl p . shows_string ['F', 'l', 'a', 't']) . shows_space) .
    show_l one_nat x) .
    shows_pr p;

shows_prec_sharp ::
  forall a. (Showa a) => Nat -> Sharp a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_sharp = showsp_sharp shows_prec;

shows_list_sharp ::
  forall a. (Showa a) => [Sharp a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_sharp = showsp_list shows_prec_sharp zero_nat;

instance (Showa a) => Showa (Sharp a) where {
  shows_prec = shows_prec_sharp;
  shows_list = shows_list_sharp;
};

comparator_sharp ::
  forall a. (a -> a -> Ordera) -> Sharp a -> Sharp a -> Ordera;
comparator_sharp comp_l (Sharpa x) (Sharpa ya) = comp_l x ya;
comparator_sharp comp_l (Sharpa x) (Flat y) = Gt;
comparator_sharp comp_l (Flat x) (Sharpa ya) = Lt;
comparator_sharp comp_l (Flat x) (Flat y) = comp_l x y;

compare_sharp :: forall a. (Compare a) => Sharp a -> Sharp a -> Ordera;
compare_sharp = comparator_sharp compare;

less_eq_sharp :: forall a. (Compare a) => Sharp a -> Sharp a -> Bool;
less_eq_sharp = le_of_comp compare_sharp;

less_sharp :: forall a. (Compare a) => Sharp a -> Sharp a -> Bool;
less_sharp = lt_of_comp compare_sharp;

instance (Compare a) => Ord (Sharp a) where {
  less_eq = less_eq_sharp;
  less = less_sharp;
};

instance (Compare a) => Quasi_order (Sharp a) where {
};

instance (Compare a) => Weak_order (Sharp a) where {
};

instance (Compare a) => Preorder (Sharp a) where {
};

instance (Compare a) => Order (Sharp a) where {
};

instance (Compare a) => Linorder (Sharp a) where {
};

instance (Compare a) => Compare (Sharp a) where {
  compare = compare_sharp;
};

instance (Compare a) => Compare_order (Sharp a) where {
};

instance (Compare a) => Key (Sharp a) where {
};

ceq_sharp :: forall a. (Eq a) => Maybe (Sharp a -> Sharp a -> Bool);
ceq_sharp = Just equal_sharp;

instance (Eq a) => Ceq (Sharp a) where {
  ceq = ceq_sharp;
};

set_impl_sharp :: forall a. Phantom (Sharp a) Set_impla;
set_impl_sharp = Phantom Set_RBT;

instance Set_impl (Sharp a) where {
  set_impl = set_impl_sharp;
};

cEnum_sharp ::
  forall a.
    Maybe ([Sharp a], ((Sharp a -> Bool) -> Bool, (Sharp a -> Bool) -> Bool));
cEnum_sharp = Nothing;

instance Cenum (Sharp a) where {
  cEnum = cEnum_sharp;
};

ccompare_sharp ::
  forall a. (Ccompare a) => Maybe (Sharp a -> Sharp a -> Ordera);
ccompare_sharp = (case ccompare of {
                   Nothing -> Nothing;
                   Just comp_l -> Just (comparator_sharp comp_l);
                 });

instance (Ccompare a) => Ccompare (Sharp a) where {
  ccompare = ccompare_sharp;
};

mapping_impl_sharp :: forall a. Phantom (Sharp a) Mapping_impla;
mapping_impl_sharp = Phantom Mapping_RBT;

instance Mapping_impl (Sharp a) where {
  mapping_impl = mapping_impl_sharp;
};

data Sig = Less | Lesseq | Sum Nat | Const Int | Mult Nat | Equals;

equal_sig :: Sig -> Sig -> Bool;
equal_sig (Mult x5) Equals = False;
equal_sig Equals (Mult x5) = False;
equal_sig (Const x4) Equals = False;
equal_sig Equals (Const x4) = False;
equal_sig (Const x4) (Mult x5) = False;
equal_sig (Mult x5) (Const x4) = False;
equal_sig (Sum x3) Equals = False;
equal_sig Equals (Sum x3) = False;
equal_sig (Sum x3) (Mult x5) = False;
equal_sig (Mult x5) (Sum x3) = False;
equal_sig (Sum x3) (Const x4) = False;
equal_sig (Const x4) (Sum x3) = False;
equal_sig Lesseq Equals = False;
equal_sig Equals Lesseq = False;
equal_sig Lesseq (Mult x5) = False;
equal_sig (Mult x5) Lesseq = False;
equal_sig Lesseq (Const x4) = False;
equal_sig (Const x4) Lesseq = False;
equal_sig Lesseq (Sum x3) = False;
equal_sig (Sum x3) Lesseq = False;
equal_sig Less Equals = False;
equal_sig Equals Less = False;
equal_sig Less (Mult x5) = False;
equal_sig (Mult x5) Less = False;
equal_sig Less (Const x4) = False;
equal_sig (Const x4) Less = False;
equal_sig Less (Sum x3) = False;
equal_sig (Sum x3) Less = False;
equal_sig Less Lesseq = False;
equal_sig Lesseq Less = False;
equal_sig (Mult x5) (Mult y5) = equal_nat x5 y5;
equal_sig (Const x4) (Const y4) = equal_int x4 y4;
equal_sig (Sum x3) (Sum y3) = equal_nat x3 y3;
equal_sig Equals Equals = True;
equal_sig Lesseq Lesseq = True;
equal_sig Less Less = True;

instance Eq Sig where {
  a == b = equal_sig a b;
};

showsp_sig :: Nat -> Sig -> [Prelude.Char] -> [Prelude.Char];
showsp_sig p Equals = shows_string ['E', 'q', 'u', 'a', 'l', 's'];
showsp_sig p (Mult x) =
  (((shows_pl p . shows_string ['M', 'u', 'l', 't']) . shows_space) .
    showsp_nat one_nat x) .
    shows_pr p;
showsp_sig p (Const x) =
  (((shows_pl p . shows_string ['C', 'o', 'n', 's', 't']) . shows_space) .
    showsp_int one_nat x) .
    shows_pr p;
showsp_sig p (Sum x) =
  (((shows_pl p . shows_string ['S', 'u', 'm']) . shows_space) .
    showsp_nat one_nat x) .
    shows_pr p;
showsp_sig p Lesseq = shows_string ['L', 'e', 's', 's', 'e', 'q'];
showsp_sig p Less = shows_string ['L', 'e', 's', 's'];

shows_prec_sig :: Nat -> Sig -> [Prelude.Char] -> [Prelude.Char];
shows_prec_sig = showsp_sig;

shows_list_sig :: [Sig] -> [Prelude.Char] -> [Prelude.Char];
shows_list_sig = showsp_list shows_prec_sig zero_nat;

instance Showa Sig where {
  shows_prec = shows_prec_sig;
  shows_list = shows_list_sig;
};

comparator_sig :: Sig -> Sig -> Ordera;
comparator_sig Equals Equals = Eqa;
comparator_sig Equals (Mult yb) = Gt;
comparator_sig Equals (Const ya) = Gt;
comparator_sig Equals (Sum y) = Gt;
comparator_sig Equals Lesseq = Gt;
comparator_sig Equals Less = Gt;
comparator_sig (Mult x) Equals = Lt;
comparator_sig (Mult x) (Mult yb) = comparator_of x yb;
comparator_sig (Mult x) (Const ya) = Gt;
comparator_sig (Mult x) (Sum y) = Gt;
comparator_sig (Mult x) Lesseq = Gt;
comparator_sig (Mult x) Less = Gt;
comparator_sig (Const x) Equals = Lt;
comparator_sig (Const x) (Mult yb) = Lt;
comparator_sig (Const x) (Const ya) = comparator_of x ya;
comparator_sig (Const x) (Sum y) = Gt;
comparator_sig (Const x) Lesseq = Gt;
comparator_sig (Const x) Less = Gt;
comparator_sig (Sum x) Equals = Lt;
comparator_sig (Sum x) (Mult yb) = Lt;
comparator_sig (Sum x) (Const ya) = Lt;
comparator_sig (Sum x) (Sum y) = comparator_of x y;
comparator_sig (Sum x) Lesseq = Gt;
comparator_sig (Sum x) Less = Gt;
comparator_sig Lesseq Equals = Lt;
comparator_sig Lesseq (Mult yb) = Lt;
comparator_sig Lesseq (Const ya) = Lt;
comparator_sig Lesseq (Sum y) = Lt;
comparator_sig Lesseq Lesseq = Eqa;
comparator_sig Lesseq Less = Gt;
comparator_sig Less Equals = Lt;
comparator_sig Less (Mult yb) = Lt;
comparator_sig Less (Const ya) = Lt;
comparator_sig Less (Sum y) = Lt;
comparator_sig Less Lesseq = Lt;
comparator_sig Less Less = Eqa;

ccompare_sig :: Maybe (Sig -> Sig -> Ordera);
ccompare_sig = Just comparator_sig;

instance Ccompare Sig where {
  ccompare = ccompare_sig;
};

data Val = Int Int | Boola Bool;

equal_val :: Val -> Val -> Bool;
equal_val (Int x1) (Boola x2) = False;
equal_val (Boola x2) (Int x1) = False;
equal_val (Boola x2) (Boola y2) = x2 == y2;
equal_val (Int x1) (Int y1) = equal_int x1 y1;

ceq_val :: Maybe (Val -> Val -> Bool);
ceq_val = Just equal_val;

instance Ceq Val where {
  ceq = ceq_val;
};

set_impl_val :: Phantom Val Set_impla;
set_impl_val = Phantom Set_DList;

instance Set_impl Val where {
  set_impl = set_impl_val;
};

comparator_val :: Val -> Val -> Ordera;
comparator_val (Boola x) (Boola ya) = comparator_bool x ya;
comparator_val (Boola x) (Int y) = Gt;
comparator_val (Int x) (Boola ya) = Lt;
comparator_val (Int x) (Int y) = comparator_of x y;

ccompare_val :: Maybe (Val -> Val -> Ordera);
ccompare_val = Just comparator_val;

instance Ccompare Val where {
  ccompare = ccompare_val;
};

data Location = H | A | Ba | Ra;

equal_location :: Location -> Location -> Bool;
equal_location Ba Ra = False;
equal_location Ra Ba = False;
equal_location A Ra = False;
equal_location Ra A = False;
equal_location A Ba = False;
equal_location Ba A = False;
equal_location H Ra = False;
equal_location Ra H = False;
equal_location H Ba = False;
equal_location Ba H = False;
equal_location H A = False;
equal_location A H = False;
equal_location Ra Ra = True;
equal_location Ba Ba = True;
equal_location A A = True;
equal_location H H = True;

instance Eq Location where {
  a == b = equal_location a b;
};

ceq_location :: Maybe (Location -> Location -> Bool);
ceq_location = Just equal_location;

instance Ceq Location where {
  ceq = ceq_location;
};

set_impl_location :: Phantom Location Set_impla;
set_impl_location = Phantom Set_RBT;

instance Set_impl Location where {
  set_impl = set_impl_location;
};

comparator_location :: Location -> Location -> Ordera;
comparator_location Ra Ra = Eqa;
comparator_location Ra Ba = Gt;
comparator_location Ra A = Gt;
comparator_location Ra H = Gt;
comparator_location Ba Ra = Lt;
comparator_location Ba Ba = Eqa;
comparator_location Ba A = Gt;
comparator_location Ba H = Gt;
comparator_location A Ra = Lt;
comparator_location A Ba = Lt;
comparator_location A A = Eqa;
comparator_location A H = Gt;
comparator_location H Ra = Lt;
comparator_location H Ba = Lt;
comparator_location H A = Lt;
comparator_location H H = Eqa;

compare_location :: Location -> Location -> Ordera;
compare_location = comparator_location;

ccompare_location :: Maybe (Location -> Location -> Ordera);
ccompare_location = Just compare_location;

instance Ccompare Location where {
  ccompare = ccompare_location;
};

data Scg a b = Null | Scg a a [(b, b)] [(b, b)];

equal_scg :: forall a b. (Eq a, Eq b) => Scg a b -> Scg a b -> Bool;
equal_scg Null (Scg x21 x22 x23 x24) = False;
equal_scg (Scg x21 x22 x23 x24) Null = False;
equal_scg (Scg x21 x22 x23 x24) (Scg y21 y22 y23 y24) =
  x21 == y21 && x22 == y22 && x23 == y23 && x24 == y24;
equal_scg Null Null = True;

instance (Eq a, Eq b) => Eq (Scg a b) where {
  a == b = equal_scg a b;
};

comparator_scg ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Scg a b -> Scg a b -> Ordera;
comparator_scg comp_p_p comp_a_p (Scg x xa xb xc) (Scg y ya yb yc) =
  (case comp_p_p x y of {
    Eqa ->
      (case comp_p_p xa ya of {
        Eqa ->
          (case comparator_list (comparator_prod comp_a_p comp_a_p) xb yb of {
            Eqa -> comparator_list (comparator_prod comp_a_p comp_a_p) xc yc;
            Lt -> Lt;
            Gt -> Gt;
          });
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_scg comp_p_p comp_a_p (Scg x xa xb xc) Null = Gt;
comparator_scg comp_p_p comp_a_p Null (Scg y ya yb yc) = Lt;
comparator_scg comp_p_p comp_a_p Null Null = Eqa;

compare_scg ::
  forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Ordera;
compare_scg = comparator_scg compare compare;

less_eq_scg :: forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Bool;
less_eq_scg = le_of_comp compare_scg;

less_scg :: forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Bool;
less_scg = lt_of_comp compare_scg;

instance (Compare a, Compare b) => Ord (Scg a b) where {
  less_eq = less_eq_scg;
  less = less_scg;
};

instance (Compare a, Compare b) => Compare (Scg a b) where {
  compare = compare_scg;
};

instance (Compare a, Compare b) => Quasi_order (Scg a b) where {
};

instance (Compare a, Compare b) => Weak_order (Scg a b) where {
};

instance (Compare a, Compare b) => Preorder (Scg a b) where {
};

instance (Compare a, Compare b) => Order (Scg a b) where {
};

instance (Compare a, Compare b) => Linorder (Scg a b) where {
};

instance (Compare a, Compare b) => Compare_order (Scg a b) where {
};

data Arctic_delta a = MinInfty_delta | Num_arc_delta a;

equal_arctic_delta ::
  forall a. (Eq a) => Arctic_delta a -> Arctic_delta a -> Bool;
equal_arctic_delta MinInfty_delta (Num_arc_delta x2) = False;
equal_arctic_delta (Num_arc_delta x2) MinInfty_delta = False;
equal_arctic_delta (Num_arc_delta x2) (Num_arc_delta y2) = x2 == y2;
equal_arctic_delta MinInfty_delta MinInfty_delta = True;

instance (Eq a) => Eq (Arctic_delta a) where {
  a == b = equal_arctic_delta a b;
};

shows_arctic_delta ::
  forall a. (Showa a) => Arctic_delta a -> [Prelude.Char] -> [Prelude.Char];
shows_arctic_delta (Num_arc_delta i) = shows_prec zero_nat i;
shows_arctic_delta MinInfty_delta =
  shows_prec_list zero_nat ['-', 'i', 'n', 'f'];

shows_prec_arctic_delta ::
  forall a.
    (Showa a) => Nat -> Arctic_delta a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_arctic_delta d ari = shows_arctic_delta ari;

shows_list_arctic_delta ::
  forall a. (Showa a) => [Arctic_delta a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_arctic_delta ps = showsp_list shows_prec_arctic_delta zero_nat ps;

instance (Showa a) => Showa (Arctic_delta a) where {
  shows_prec = shows_prec_arctic_delta;
  shows_list = shows_list_arctic_delta;
};

one_arctic_delta :: forall a. (Linordered_field a) => Arctic_delta a;
one_arctic_delta = Num_arc_delta zerob;

instance (Linordered_field a) => One (Arctic_delta a) where {
  onea = one_arctic_delta;
};

plus_arctic_delta ::
  forall a.
    (Linordered_field a) => Arctic_delta a -> Arctic_delta a -> Arctic_delta a;
plus_arctic_delta MinInfty_delta y = y;
plus_arctic_delta (Num_arc_delta v) MinInfty_delta = Num_arc_delta v;
plus_arctic_delta (Num_arc_delta x) (Num_arc_delta y) = Num_arc_delta (max x y);

instance (Linordered_field a) => Plus (Arctic_delta a) where {
  plus = plus_arctic_delta;
};

zero_arctic_delta :: forall a. (Linordered_field a) => Arctic_delta a;
zero_arctic_delta = MinInfty_delta;

instance (Linordered_field a) => Zero (Arctic_delta a) where {
  zerob = zero_arctic_delta;
};

instance (Linordered_field a) => Semigroup_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Numeral (Arctic_delta a) where {
};

times_arctic_delta ::
  forall a.
    (Linordered_field a) => Arctic_delta a -> Arctic_delta a -> Arctic_delta a;
times_arctic_delta MinInfty_delta y = MinInfty_delta;
times_arctic_delta (Num_arc_delta v) MinInfty_delta = MinInfty_delta;
times_arctic_delta (Num_arc_delta x) (Num_arc_delta y) =
  Num_arc_delta (plus x y);

instance (Linordered_field a) => Times (Arctic_delta a) where {
  times = times_arctic_delta;
};

instance (Linordered_field a) => Power (Arctic_delta a) where {
};

less_eq_arctic_delta ::
  forall a. (Ord a) => Arctic_delta a -> Arctic_delta a -> Bool;
less_eq_arctic_delta MinInfty_delta x = True;
less_eq_arctic_delta (Num_arc_delta uu) MinInfty_delta = False;
less_eq_arctic_delta (Num_arc_delta y) (Num_arc_delta x) = less_eq y x;

less_arctic_delta ::
  forall a. (Ord a) => Arctic_delta a -> Arctic_delta a -> Bool;
less_arctic_delta MinInfty_delta x = True;
less_arctic_delta (Num_arc_delta uu) MinInfty_delta = False;
less_arctic_delta (Num_arc_delta y) (Num_arc_delta x) = less y x;

instance (Ord a) => Ord (Arctic_delta a) where {
  less_eq = less_eq_arctic_delta;
  less = less_arctic_delta;
};

instance (Linordered_field a) => Ab_semigroup_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Semigroup_mult (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring (Arctic_delta a) where {
};

instance (Linordered_field a) => Mult_zero (Arctic_delta a) where {
};

instance (Linordered_field a) => Monoid_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Comm_monoid_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_0 (Arctic_delta a) where {
};

instance (Linordered_field a) => Monoid_mult (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_numeral (Arctic_delta a) where {
};

instance (Linordered_field a) => Zero_neq_one (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_1 (Arctic_delta a) where {
};

ceq_arctic_delta ::
  forall a. (Eq a) => Maybe (Arctic_delta a -> Arctic_delta a -> Bool);
ceq_arctic_delta = Just equal_arctic_delta;

instance (Eq a) => Ceq (Arctic_delta a) where {
  ceq = ceq_arctic_delta;
};

set_impl_arctic_delta :: forall a. Phantom (Arctic_delta a) Set_impla;
set_impl_arctic_delta = Phantom Set_RBT;

instance Set_impl (Arctic_delta a) where {
  set_impl = set_impl_arctic_delta;
};

cEnum_arctic_delta ::
  forall a.
    Maybe ([Arctic_delta a],
            ((Arctic_delta a -> Bool) -> Bool,
              (Arctic_delta a -> Bool) -> Bool));
cEnum_arctic_delta = Nothing;

instance Cenum (Arctic_delta a) where {
  cEnum = cEnum_arctic_delta;
};

comparator_arctic_delta ::
  forall a. (a -> a -> Ordera) -> Arctic_delta a -> Arctic_delta a -> Ordera;
comparator_arctic_delta comp_a (Num_arc_delta x) (Num_arc_delta y) = comp_a x y;
comparator_arctic_delta comp_a (Num_arc_delta x) MinInfty_delta = Gt;
comparator_arctic_delta comp_a MinInfty_delta (Num_arc_delta y) = Lt;
comparator_arctic_delta comp_a MinInfty_delta MinInfty_delta = Eqa;

compare_arctic_delta ::
  forall a. (Compare a) => Arctic_delta a -> Arctic_delta a -> Ordera;
compare_arctic_delta = comparator_arctic_delta compare;

ccompare_arctic_delta ::
  forall a. (Compare a) => Maybe (Arctic_delta a -> Arctic_delta a -> Ordera);
ccompare_arctic_delta = Just compare_arctic_delta;

instance (Compare a) => Ccompare (Arctic_delta a) where {
  ccompare = ccompare_arctic_delta;
};

instance (Linordered_field a) => Non_strict_order (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_ab_semigroup (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_semiring_0a (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_semiring_1 (Arctic_delta a) where {
};

data Cond_constraint a b = CC_cond Bool (Term a b, Term a b)
  | CC_rewr (Term a b) (Term a b)
  | CC_impl [Cond_constraint a b] (Cond_constraint a b)
  | CC_all b (Cond_constraint a b);

instance (Eq a, Eq b) => Eq (Cond_constraint a b) where {
  a == b = equal_cond_constraint a b;
};

equal_cond_constraint ::
  forall a b.
    (Eq a, Eq b) => Cond_constraint a b -> Cond_constraint a b -> Bool;
equal_cond_constraint (CC_impl x31 x32) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_impl x31 x32) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_impl x31 x32) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_all x41 x42) (CC_all y41 y42) =
  x41 == y41 && equal_cond_constraint x42 y42;
equal_cond_constraint (CC_impl x31 x32) (CC_impl y31 y32) =
  x31 == y31 && equal_cond_constraint x32 y32;
equal_cond_constraint (CC_rewr x21 x22) (CC_rewr y21 y22) =
  equal_term x21 y21 && equal_term x22 y22;
equal_cond_constraint (CC_cond x11 x12) (CC_cond y11 y12) =
  x11 == y11 && x12 == y12;

data Itself a = Type;

newtype Rbt b a = RBT (Rbta b a);

data Xml = XML [Prelude.Char] [([Prelude.Char], [Prelude.Char])] [Xml]
  | XML_text [Prelude.Char];

newtype Fset a = Abs_fset (Set a);

data Xmldoc = XMLDOC [[Prelude.Char]] Xml;

data Lts_impl a b c d e =
  Lts_Impl [d] [(e, Transition_rule a b c d)] [(d, Formula (Term a (b, c)))];

data Atom a = Leq Nat a | Geq Nat a;

data Order_tag = Lex | Mul;

newtype Fmap a b = Fmap_of_list [(a, b)];

data Lts_ext a b c d e =
  Lts_ext (Set d) (Set (Transition_rule a b c d)) (d -> Formula (Term a (b, c)))
    e;

data Mapping a b = Assoc_List_Mapping (Alist a b)
  | RBT_Mapping (Mapping_rbt a b) | Mapping (a -> Maybe b);

data Xml_error a = TagMismatch [[Prelude.Char]] | Fatal a;

data Domain = Natural Nat | Integera | Arctic | Arctic_rat | Int_mat Nat Nat
  | Arctic_mat Nat | Arctic_rat_mat Nat | Rational Rat Nat | Rat_mat Nat Nat
  | Mini_Alg Real Nat | Mini_Alg_mat Nat Nat;

data Enat = Enat Nat | Infinity_enat;

data Tpoly a b = PVar a | PNum b | PSum [Tpoly a b] | PMult [Tpoly a b];

newtype Status a = Abs_status ((a, Nat) -> [Nat]);

data Claim a b = Yes | No | Terminating | Upperbound Nat | Nonterminating
  | Confluent | Nonconfluent | Completed | Anything;

data Tree_automaton a b = Tree_Automaton [a] [Ta_rule a b] [(a, a)];

data Complexity_measure a b = Derivational_Complexity [(a, Nat)]
  | Runtime_Complexity [(a, Nat)] [(a, Nat)];

data Equation_literal a b = Equation (Term a b, Term a b)
  | Inequality (Term a b, Term a b);

newtype Complexity_class = Comp_Poly Nat;

data Fp_strategy a b = Outermost | Context_Sensitive [((a, Nat), [Nat])]
  | Forbidden_Patterns [(Ctxt a b, (Term a b, Location))];

data Start_term = Full | Constructor_Based;

data Strategy a b = No_Strategy | Innermost | Innermost_Q [Term a b];

data Input a b =
  DP_input Bool [(Term a b, Term a b)] (Strategy a b) [(Term a b, Term a b)]
  | Inn_TRS_input (Strategy a b) [(Term a b, Term a b)] [(Term a b, Term a b)]
      Start_term
  | CPX_input (Strategy a b) [(Term a b, Term a b)] [(Term a b, Term a b)]
      (Complexity_measure a b) Complexity_class
  | COMP_input [(Term a b, Term a b)] [(Term a b, Term a b)]
  | EQ_input [(Term a b, Term a b)] (Equation_literal a b)
  | FP_TRS_input (Fp_strategy a b) [(Term a b, Term a b)]
  | CTRS_input [((Term a b, Term a b), [(Term a b, Term a b)])]
  | TA_input (Tree_automaton [Prelude.Char] a) [(Term a b, Term a b)]
  | AC_input [(Term a b, Term a b)] [a] [a]
  | LTS_input (Lts_impl Sig b Ty [Prelude.Char] [Prelude.Char])
  | LTS_safety_input (Lts_impl Sig b Ty [Prelude.Char] [Prelude.Char])
      [[Prelude.Char]]
  | Unknown_input [Prelude.Char];

data Const_string_sound_proof a b =
  Const_string_sound_proof b [(a, a)] [(Term a b, Term a b)]
    [(Term a b, Term a b)];

data Af_entry = Collapse Nat | AFList [Nat];

data Redtriple_impl a = Int_carrier [((a, Nat), (Int, [Int]))]
  | Int_nl_carrier [((a, Nat), [([(Nat, Nat)], Int)])]
  | Rat_carrier [((a, Nat), (Rat, [Rat]))]
  | Rat_nl_carrier Rat [((a, Nat), [([(Nat, Nat)], Rat)])]
  | Real_carrier [((a, Nat), (Real, [Real]))]
  | Real_nl_carrier Real [((a, Nat), [([(Nat, Nat)], Real)])]
  | Arctic_carrier [((a, Nat), (Arctic, [Arctic]))]
  | Arctic_rat_carrier [((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]))]
  | Int_mat_carrier Nat Nat [((a, Nat), (Mat Int, [Mat Int]))]
  | Rat_mat_carrier Nat Nat [((a, Nat), (Mat Rat, [Mat Rat]))]
  | Real_mat_carrier Nat Nat [((a, Nat), (Mat Real, [Mat Real]))]
  | Arctic_mat_carrier Nat [((a, Nat), (Mat Arctic, [Mat Arctic]))]
  | Arctic_rat_mat_carrier Nat
      [((a, Nat), (Mat (Arctic_delta Rat), [Mat (Arctic_delta Rat)]))]
  | RPO [((a, Nat), (Nat, Order_tag))] [((a, Nat), Af_entry)]
  | KBO ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) [((a, Nat), Af_entry)]
  | WPO [((a, Nat), (Nat, [Nat]))] (Redtriple_impl a);

data Complex_constant_removal_prf a b =
  Complex_Constant_Removal_Proof (Term a b)
    [((Term a b, Term a b), (Term a b, Term a b))];

data List_order_type = MS_Ext | Max_Ext | Min_Ext | Dms_Ext;

data Root_redtriple_impl a =
  SCNP List_order_type [((a, Nat), [(Nat, Nat)])] (Redtriple_impl a);

data Cond_constraint_prf a b = Final
  | Delete_Condition (Cond_constraint a b) (Cond_constraint_prf a b)
  | Different_Constructor (Cond_constraint a b)
  | Same_Constructor (Cond_constraint a b) (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Variable_Equation b (Term a b) (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Funarg_Into_Var (Cond_constraint a b) Nat b (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Simplify_Condition (Cond_constraint a b) [(b, Term a b)]
      (Cond_constraint a b) (Cond_constraint_prf a b)
  | Induction (Cond_constraint a b) [Cond_constraint a b]
      [((Term a b, Term a b),
         ([(Term a b, [b])], (Cond_constraint a b, Cond_constraint_prf a b)))];

data Cond_red_pair_prf a b =
  Cond_Red_Pair_Prf a
    [(Cond_constraint a b, ([(Term a b, Term a b)], Cond_constraint_prf a b))]
    Nat Nat;

data ArithFun = Arg Nat | Consta Nat | Suma [ArithFun] | Max [ArithFun]
  | Min [ArithFun] | Prod [ArithFun]
  | IfEqual ArithFun ArithFun ArithFun ArithFun;

data Sl_inter a = SL_Inter Nat [((a, Nat), ArithFun)];

data Sl_variant a b = Rootlab (Maybe (a, Nat)) | Finitelab (Sl_inter a)
  | QuasiFinitelab (Sl_inter a) b;

data Generic_assm_proof a b c d e f g h =
  SN_assm_proof
    (Bool,
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          [(Term (Lab a b) c, Term (Lab a b) c)])))
    d
  | Finite_assm_proof
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      e
  | SN_FP_assm_proof
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      f
  | Not_SN_assm_proof
      (Bool, ([Term (Lab a b) c], [(Term (Lab a b) c, Term (Lab a b) c)])) d
  | Infinite_assm_proof
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      e
  | Not_RelSN_assm_proof
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      f
  | Not_SN_FP_assm_proof
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      g
  | Complexity_assm_proof
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            (Complexity_measure (Lab a b) c, Complexity_class))))
      d
  | Unknown_assm_proof [Prelude.Char] h;

data Join_info a =
  Guided
    [(Term a [Prelude.Char],
       ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                 Term a [Prelude.Char]))],
         (Term a [Prelude.Char],
           [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                    Term a [Prelude.Char]))])))]
  | Join_NF | Join_BFS Nat;

newtype ProjL a = Projection [((a, Nat), Nat)];

data Ta_relation a = Decision_Proc_Old | Decision_Proc | Id_Relation
  | Some_Relation [(a, a)];

data Boundstype = Roof | Match;

data Bounds_info a b =
  Bounds_Info Boundstype Nat [b] (Tree_automaton b (a, Nat)) (Ta_relation b);

data Trs_termination_proof a b c =
  DP_Trans Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
    (Dp_termination_proof a b c)
  | Rule_Removal (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | String_Reversal (Trs_termination_proof a b c)
  | Constant_String (Const_string_sound_proof (Lab a b) c)
      (Trs_termination_proof a b c)
  | Bounds (Bounds_info (Lab a b) c)
  | Uncurry
      (Lab a b,
        ([((Lab a b, Nat), [Lab a b])],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | Semlab (Sl_variant (Lab a b) c) [Term (Lab a b) c]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | R_is_Empty
  | Fcc [Ctxt (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c)
  | Split [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
      (Trs_termination_proof a b c)
  | Switch_Innermost (Join_info (Lab a b)) (Trs_termination_proof a b c)
  | Drop_Equality (Trs_termination_proof a b c)
  | Remove_Nonapplicable_Rules [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c)
  | Permuting_AFS [((Lab a b, Nat), Af_entry)] (Trs_termination_proof a b c)
  | Assume_SN
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [Generic_assm_proof a b c (Trs_termination_proof a b c)
         (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
         (Unknown_proof a b c)];

data Fptrs_termination_proof a b c =
  Assume_FP_SN
    ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
      [(Term (Lab a b) c, Term (Lab a b) c)])
    [Generic_assm_proof a b c (Trs_termination_proof a b c)
       (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
       (Unknown_proof a b c)];

data Dp_termination_proof a b c = P_is_Empty
  | Subterm_Criterion_Proc (ProjL (Lab a b))
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Gen_Subterm_Criterion_Proc [((Lab a b, Nat), [Nat])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Redpair_Proc
      (Sum (Root_redtriple_impl (Lab a b)) (Redtriple_impl (Lab a b)))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Redpair_UR_Proc
      (Sum (Root_redtriple_impl (Lab a b)) (Redtriple_impl (Lab a b)))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Usable_Rules_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_termination_proof a b c)
  | Dep_Graph_Proc
      [(Maybe (Dp_termination_proof a b c),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
  | Mono_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Mono_URM_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Mono_Redpair_UR_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Size_Change_Subterm_Proc
      [((Term (Lab a b) c, Term (Lab a b) c), ([(Nat, Nat)], [(Nat, Nat)]))]
  | Size_Change_Redpair_Proc (Redtriple_impl (Lab a b))
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      [((Term (Lab a b) c, Term (Lab a b) c), ([(Nat, Nat)], [(Nat, Nat)]))]
  | Uncurry_Proc (Maybe Nat)
      (Lab a b,
        ([((Lab a b, Nat), [Lab a b])],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Fcc_Proc (Lab a b) [Ctxt (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Split_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
      (Dp_termination_proof a b c)
  | Semlab_Proc (Sl_variant (Lab a b) c) [(Term (Lab a b) c, Term (Lab a b) c)]
      [Term (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_termination_proof a b c)
  | Switch_Innermost_Proc (Join_info (Lab a b)) (Dp_termination_proof a b c)
  | Rewriting_Proc (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Term (Lab a b) c, Term (Lab a b) c) (Term (Lab a b) c, Term (Lab a b) c)
      (Term (Lab a b) c, Term (Lab a b) c) (Term (Lab a b) c, Term (Lab a b) c)
      Pos (Dp_termination_proof a b c)
  | Instantiation_Proc (Term (Lab a b) c, Term (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Forward_Instantiation_Proc (Term (Lab a b) c, Term (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Dp_termination_proof a b c)
  | Narrowing_Proc (Term (Lab a b) c, Term (Lab a b) c) Pos
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Assume_Finite
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      [Generic_assm_proof a b c (Trs_termination_proof a b c)
         (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
         (Unknown_proof a b c)]
  | Unlab_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Q_Reduction_Proc [Term (Lab a b) c] (Dp_termination_proof a b c)
  | Complex_Constant_Removal_Proc (Complex_constant_removal_prf (Lab a b) c)
      (Dp_termination_proof a b c)
  | General_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Cond_red_pair_prf (Lab a b) c)
      [Dp_termination_proof a b c]
  | To_Trs_Proc (Trs_termination_proof a b c);

data Unknown_proof a b c =
  Assume_Unknown [Prelude.Char]
    [Generic_assm_proof a b c (Trs_termination_proof a b c)
       (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
       (Unknown_proof a b c)];

data Cr_proof a b c = SN_WCR (Join_info (Lab a b)) (Trs_termination_proof a b c)
  | Weakly_Orthogonal | Strongly_Closed Nat
  | Rule_Labeling [((Term (Lab a b) c, Term (Lab a b) c), Nat)]
      [(Term (Lab a b) [Prelude.Char],
         ([(Pos, ((Term (Lab a b) [Prelude.Char],
                    Term (Lab a b) [Prelude.Char]),
                   Term (Lab a b) [Prelude.Char]))],
           (Term (Lab a b) [Prelude.Char],
             [(Pos, ((Term (Lab a b) [Prelude.Char],
                       Term (Lab a b) [Prelude.Char]),
                      Term (Lab a b) [Prelude.Char]))])))]
      (Maybe (Trs_termination_proof a b c))
  | Rule_Labeling_Conv [((Term (Lab a b) c, Term (Lab a b) c), Nat)]
      [(Term (Lab a b) [Prelude.Char],
         (Term (Lab a b) [Prelude.Char],
           ([(Pos, ((Term (Lab a b) [Prelude.Char],
                      Term (Lab a b) [Prelude.Char]),
                     (Bool, Term (Lab a b) [Prelude.Char])))],
             ([(Pos, ((Term (Lab a b) [Prelude.Char],
                        Term (Lab a b) [Prelude.Char]),
                       Term (Lab a b) [Prelude.Char]))],
               ([(Pos, ((Term (Lab a b) [Prelude.Char],
                          Term (Lab a b) [Prelude.Char]),
                         (Bool, Term (Lab a b) [Prelude.Char])))],
                 (Term (Lab a b) [Prelude.Char],
                   ([(Pos, ((Term (Lab a b) [Prelude.Char],
                              Term (Lab a b) [Prelude.Char]),
                             (Bool, Term (Lab a b) [Prelude.Char])))],
                     ([(Pos, ((Term (Lab a b) [Prelude.Char],
                                Term (Lab a b) [Prelude.Char]),
                               Term (Lab a b) [Prelude.Char]))],
                       [(Pos, ((Term (Lab a b) [Prelude.Char],
                                 Term (Lab a b) [Prelude.Char]),
                                (Bool,
                                  Term (Lab a b) [Prelude.Char])))]))))))))]
      (Maybe (Nat, Trs_termination_proof a b c))
  | Redundant_Rules [(Term (Lab a b) c, Term (Lab a b) c)] Nat
      [[(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                (Bool, Term (Lab a b) c)))]]
      (Cr_proof a b c)
  | Parallel_Closed (Maybe Nat)
  | Critical_Pair_Closing_System [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c) Nat;

data Comp_res = LESS | EQUAL | GREATER;

newtype Multimap a b = Abs_multimap (b -> a, (Mapping a [b], [b]));

data Ring_ext a b = Ring_ext a (a -> a -> a) b;

newtype Linear_poly = LinearPoly (Fmap Nat Rat);

data Constraint = LTa Linear_poly Rat | GTa Linear_poly Rat
  | LEQ Linear_poly Rat | GEQ Linear_poly Rat | EQa Linear_poly Rat
  | LTPP Linear_poly Linear_poly | GTPP Linear_poly Linear_poly
  | LEQPP Linear_poly Linear_poly | GEQPP Linear_poly Linear_poly
  | EQPP Linear_poly Linear_poly;

newtype Sum_bot a b = Sumbot (Sum a b);

newtype Afs a = Abs_afs ((a, Nat) -> Af_entry, Set (a, Nat));

data Non_join_info a b c = Diff_NFs
  | Tcap_Non_Unif (Term a b -> Term a b -> b -> Term a b)
  | Tree_Aut_Intersect_Empty (Tree_automaton c a) (Ta_relation c)
      (Tree_automaton c a) (Ta_relation c)
  | Finite_Model_Gt (Sl_variant a b) | Reduction_Pair_Gt (Redtriple_impl a)
  | Usable_Rules_Reach_NJ (Non_join_info a b c)
  | Usable_Rules_Reach_Unif_NJ
      (Sum [(Term a b, Term a b)] [(Term a b, Term a b)]) (Non_join_info a b c)
  | Argument_Filter_NJ [((a, Nat), Af_entry)] (Non_join_info a b c)
  | Grounding [(b, Term a b)] (Non_join_info a b c)
  | Subterm_NJ Pos (Non_join_info a b c);

data Ncr_proof a b c d = SN_NWCR (Trs_termination_proof a b c)
  | Non_Join (Term (Lab a b) c)
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))]
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))]
      (Non_join_info (Lab a b) c d)
  | NCR_Disj_Subtrs [(Term (Lab a b) c, Term (Lab a b) c)] (Ncr_proof a b c d)
  | NCR_Redundant_Rules [(Term (Lab a b) c, Term (Lab a b) c)] Nat
      (Ncr_proof a b c d);

data Rule_removal_nonterm_reltrs_prf a b =
  Rule_removal_nonterm_reltrs_prf (Maybe [(Term a b, Term a b)])
    (Maybe [(Term a b, Term a b)]);

newtype Dp_trans_nontermination_tt_prf a b c = DP_trans_nontermination_tt_prf
  [(Term (Lab a b) c, Term (Lab a b) c)];

data Const_string_complete_proof a b =
  Const_string_complete_proof b [(a, a)] [(Term a b, Term a b)];

newtype Rule_removal_nonterm_trs_prf a b = Rule_removal_nonterm_trs_prf
  [(Term a b, Term a b)];

newtype Q_increase_nonterm_trs_prf a b = Q_increase_nonterm_trs_prf [Term a b];

newtype Instantiation_complete_proc_prf a b = Instantiation_complete_proc_prf
  [(Term a b, Term a b)];

data Rule_removal_nonterm_dp_prf a b =
  Rule_removal_nonterm_dp_prf (Maybe [(Term a b, Term a b)])
    (Maybe [(Term a b, Term a b)]);

newtype Q_increase_nonterm_dp_prf a b = Q_increase_nonterm_dp_prf [Term a b];

newtype Dp_q_reduction_nonterm_prf a b = DP_q_reduction_nonterm_prf [Term a b];

data Rewriting_complete_proc_prf a b =
  Rewriting_complete_proc_prf (Maybe [(Term a b, Term a b)])
    (Term a b, Term a b) (Term a b, Term a b) (Term a b, Term a b)
    (Term a b, Term a b) Pos;

data Narrowing_complete_proc_prf a b =
  Narrowing_complete_proc_prf (Term a b, Term a b) Pos [(Term a b, Term a b)];

data Pat_rule_pos = Pat_Base | Pat_Pump | Pat_Close;

data Pat_eqv_prf a b = Pat_Dom_Renaming [(b, Term a b)]
  | Pat_Irrelevant [(b, Term a b)] [(b, Term a b)]
  | Pat_Simplify [(b, Term a b)] [(b, Term a b)];

data Pat_rule_prf a b = Pat_OrigRule (Term a b, Term a b) Bool
  | Pat_InitPump (Pat_rule_prf a b) [(b, Term a b)] [(b, Term a b)]
  | Pat_InitPumpCtxt (Pat_rule_prf a b) [(b, Term a b)] Pos b
  | Pat_Equiv (Pat_rule_prf a b) Bool (Pat_eqv_prf a b)
  | Pat_Narrow (Pat_rule_prf a b) (Pat_rule_prf a b) Pos
  | Pat_Inst (Pat_rule_prf a b) [(b, Term a b)] Pat_rule_pos
  | Pat_Rewr (Pat_rule_prf a b)
      (Term a b, [(Pos, ((Term a b, Term a b), Term a b))]) Pat_rule_pos b
  | Pat_Exp_Sigma (Pat_rule_prf a b) Nat;

data Non_loop_prf a b =
  Non_loop_prf (Pat_rule_prf a b) [(b, Term a b)] [(b, Term a b)] Nat Nat Pos;

data Dp_loop_prf a b =
  DP_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), (Bool, Term a b)))]
    [(b, Term a b)] (Ctxt a b);

data Not_wn_ta_prf a b = Not_wn_ta_prf (Tree_automaton b a) (Ta_relation b);

data Dp_proof_step a = OC1 ([a], [a]) Bool
  | OC2 ([a], [a]) ([a], [a]) ([a], [a]) [a] [a] [a]
  | OC2p ([a], [a]) ([a], [a]) ([a], [a]) [a] [a] [a]
  | OC3 ([a], [a]) ([a], [a]) ([a], [a]) [a] [a]
  | OC3p ([a], [a]) ([a], [a]) ([a], [a]) [a] [a]
  | OCDP1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a])
  | OCDP2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a])
  | WPEQ (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
  | Lift (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
  | DPOC1_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC1_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a] [a]
  | DPOC2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC3_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC3_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a] [a]
  | DPDP1_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP1_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP2_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP2_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a]
      [a];

data Non_loop_srs_proof a = SE_OC ([a], [a]) [a] [a] [Dp_proof_step a]
  | SE_DP (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a]
      [a] [Dp_proof_step a];

data Uncurry_nt_proof a b c =
  Uncurry_nt_proof
    (Lab a b,
      ([((Lab a b, Nat), [Lab a b])],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          [(Term (Lab a b) c, Term (Lab a b) c)])))
    [(Term (Lab a b) c, Term (Lab a b) c)];

data Trs_loop_prf a b =
  TRS_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), Term a b))]
    [(b, Term a b)] (Ctxt a b);

data Rel_trs_loop_prf a b =
  Rel_trs_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), (Bool, Term a b)))]
    [(b, Term a b)] (Ctxt a b);

data Reltrs_nontermination_proof a b c = Rel_Loop (Rel_trs_loop_prf (Lab a b) c)
  | Rel_TRS_String_Reversal (Reltrs_nontermination_proof a b c)
  | Rel_Not_Well_Formed
  | Rel_Rule_Removal (Rule_removal_nonterm_reltrs_prf (Lab a b) c)
      (Reltrs_nontermination_proof a b c)
  | Rel_R_Not_SN (Trs_nontermination_proof a b c)
  | Rel_TRS_Assume_Not_SN
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Trs_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Trs_nontermination_proof a b c = TRS_Loop (Trs_loop_prf (Lab a b) c)
  | TRS_Not_Well_Formed
  | TRS_Rule_Removal (Rule_removal_nonterm_trs_prf (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_String_Reversal (Trs_nontermination_proof a b c)
  | TRS_Constant_String (Const_string_complete_proof (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_DP_Trans (Dp_trans_nontermination_tt_prf a b c)
      (Dp_nontermination_proof a b c)
  | TRS_Termination_Switch (Join_info (Lab a b))
      (Trs_nontermination_proof a b c)
  | TRS_Nonloop (Non_loop_prf (Lab a b) c)
  | TRS_Nonloop_SRS (Non_loop_srs_proof (Lab a b))
  | TRS_Q_Increase (Q_increase_nonterm_trs_prf (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_Uncurry (Uncurry_nt_proof a b c) (Trs_nontermination_proof a b c)
  | TRS_Not_WN_Tree_Automaton (Not_wn_ta_prf (Lab a b) c)
  | TRS_Assume_Not_SN
      (Bool, ([Term (Lab a b) c], [(Term (Lab a b) c, Term (Lab a b) c)]))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Trs_nontermination_proof a b c) (Neg_unknown_proof a b c)]
  | FPTRS_Assume_Not_SN
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Trs_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Dp_nontermination_proof a b c = DP_Loop (Dp_loop_prf (Lab a b) c)
  | DP_Nonloop (Non_loop_prf (Lab a b) c)
  | DP_Rule_Removal (Rule_removal_nonterm_dp_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Q_Increase (Q_increase_nonterm_dp_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Q_Reduction (Dp_q_reduction_nonterm_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Termination_Switch (Join_info (Lab a b)) (Dp_nontermination_proof a b c)
  | DP_Instantiation (Instantiation_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Rewriting (Rewriting_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Narrowing (Narrowing_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Assume_Infinite
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Trs_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Neg_unknown_proof a b c =
  Assume_NT_Unknown [Prelude.Char]
    [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
       (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
       (Trs_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Quasi_reductive_proof a b c =
  Unravel
    [(((Term (Lab a b) c, Term (Lab a b) c),
        [(Term (Lab a b) c, Term (Lab a b) c)]),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
    (Trs_termination_proof a b c);

data Nonreachability_proof a b = Nonreachable_Tcap | Nonreachable_Gtcap
  | Nonreachable_ETAC [(a, Nat)] a a (Tree_automaton (Term a b) a)
  | Nonreachable_Subst_Approx [(Term a b, Term a b)] (Nonreachability_proof a b)
  | Nonreachable_Reverse (Nonreachability_proof a b);

data Nonjoinability_proof a b = Nonjoinable_Tcap
  | Nonjoinable_Ground_NF (Nonreachability_proof a b);

data Infeasibility_proof a b =
  Infeasible_Compound_Conditions a (Nonreachability_proof a b)
  | Infeasible_Equation (Term a b) (Term a b) (Nonreachability_proof a b)
  | Infeasible_Subset [(Term a b, Term a b)] (Infeasibility_proof a b)
  | Infeasible_Rhss_Equal (Term a b) (Term a b) (Term a b)
      (Nonjoinability_proof a b);

data Ccr_transformation a b c =
  Inline_Conditions_CCRT
    [((Term (Lab a b) c, Term (Lab a b) c),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
    [(((Term (Lab a b) c, Term (Lab a b) c),
        [(Term (Lab a b) c, Term (Lab a b) c)]),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
  | Infeasible_Rule_Removal_CCRT
      [(((Term (Lab a b) c, Term (Lab a b) c),
          [(Term (Lab a b) c, Term (Lab a b) c)]),
         Infeasibility_proof (Lab a b) c)];

data Cstep_proof a b =
  Cstep_step ((Term a b, Term a b), [(Term a b, Term a b)]) Pos (b -> Term a b)
    (Term a b) (Term a b) [[Cstep_proof a b]];

data Conditional_ncr_proof a b c d = Unconditional_CNCR (Ncr_proof a b c d)
  | Transformation_CNCR (Ccr_transformation a b c)
      (Conditional_ncr_proof a b c d)
  | Non_Join_CNCR (Term (Lab a b) c) (Term (Lab a b) c) (Term (Lab a b) c)
      [Cstep_proof (Lab a b) c] [Cstep_proof (Lab a b) c]
      (Non_join_info (Lab a b) c d);

data Completion_proof a b c =
  SN_WCR_Eq (Join_info (Lab a b)) (Trs_termination_proof a b c)
    [((Term (Lab a b) c, Term (Lab a b) c),
       [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                (Bool, Term (Lab a b) c)))])]
    (Maybe [((Term (Lab a b) c, Term (Lab a b) c),
              [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                       (Bool, Term (Lab a b) c)))])]);

data Equational_disproof a b c =
  Completion_and_Normalization_Different [(Term (Lab a b) c, Term (Lab a b) c)]
    (Completion_proof a b c)
  | Convertible_Instance
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                  (Bool, Term (Lab a b) c)))])];

data Ao_infeasibility_proof a b =
  AO_Infeasibility_Proof (Infeasibility_proof a b)
  | AO_Lhss_Equal (Term a b) (Term a b) (Term a b) (Nonjoinability_proof a b);

data Context_joinable_proof a b =
  Contextual_Join (Term a b) [Cstep_proof a b] [Cstep_proof a b];

data Unfeasible_proof a b =
  UnfeasibleOverlap (Term a b) (Term a b) (Term a b) [Cstep_proof a b]
    [Cstep_proof a b] ((Term a b, Term a b), [(Term a b, Term a b)])
    ((Term a b, Term a b), [(Term a b, Term a b)]);

data Conditional_cr_proof a b c = Unconditional_CR (Cr_proof a b c)
  | Unravel_CR
      [(((Term (Lab a b) c, Term (Lab a b) c),
          [(Term (Lab a b) c, Term (Lab a b) c)]),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
      (Cr_proof a b c)
  | Transformation_CR (Ccr_transformation a b c) (Conditional_cr_proof a b c)
  | Almost_Orthogonal_CR
  | Almost_Orthogonal_Modulo_Infeasibility_CR
      [([(Term (Lab a b) c, Term (Lab a b) c)],
         Infeasibility_proof (Lab a b) c)]
  | Almost_Orthogonal_Modulo_Infeasibility_CRa
      [([(Term (Lab a b) c, Term (Lab a b) c)],
         ([(Term (Lab a b) c, Term (Lab a b) c)],
           Ao_infeasibility_proof (Lab a b) c))]
  | AL94_CR (Quasi_reductive_proof a b c)
      [(Term (Lab a b) c,
         (Term (Lab a b) c,
           ([(Term (Lab a b) c, Term (Lab a b) c)],
             Context_joinable_proof (Lab a b) c)))]
      [([(Term (Lab a b) c, Term (Lab a b) c)],
         Infeasibility_proof (Lab a b) c)]
      [(c -> Term (Lab a b) c, Unfeasible_proof (Lab a b) c)];

data Ac_dependency_pairs_proof a b =
  AC_dependency_pairs_proof [(Term a b, Term a b)] [(Term a b, Term a b)]
    [(Term a b, Term a b)] [(Term a b, Term a b)];

data Ac_dp_termination_proof a b = AC_P_is_Empty
  | AC_Subterm_Proc [((a, Nat), [Nat])] [(Term a b, Term a b)]
      (Ac_dp_termination_proof a b)
  | AC_Redpair_UR_Proc (Redtriple_impl a) [(Term a b, Term a b)]
      [(Term a b, Term a b)] (Ac_dp_termination_proof a b)
  | AC_Mono_Redpair_UR_Proc (Redtriple_impl a) [(Term a b, Term a b)]
      [(Term a b, Term a b)] [(Term a b, Term a b)]
      (Ac_dp_termination_proof a b)
  | AC_Dep_Graph_Proc
      [(Maybe (Ac_dp_termination_proof a b), [(Term a b, Term a b)])];

data Ac_termination_proof a b c =
  AC_DP_Trans (Ac_dependency_pairs_proof (Lab a b) c)
    (Ac_dp_termination_proof (Lab a b) c) (Ac_dp_termination_proof (Lab a b) c)
  | AC_DP_Trans_Single (Ac_dependency_pairs_proof (Lab a b) c)
      (Ac_dp_termination_proof (Lab a b) c)
  | AC_Rule_Removal (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Ac_termination_proof a b c)
  | AC_R_is_Empty;

data Fresh_variable_addition_info a b c d =
  Fresh_Variable_Addition_Info b c [(d, Formula (Term a (Trans_var b, c)))];

data Transition_removal_info a b c d e =
  Transition_removal_info (Sharp c -> a) [d] b a (d -> Hint e);

data Location_addition_info a b c d e =
  Location_Addition_Info d d e (Transition_rule a b c d);

data Art_edge_impl a b c = Cover_Edge a c | Children_Edge [(b, (a, c))];

data Art_node_impl a b c d e f g =
  Art_Node e (Formula (Term a (b, c))) d (Art_edge_impl e f g);

data Art_impl_ext a b c d e f g h =
  Art_impl_ext [e] [Art_node_impl a b c d e f g] h;

data Invariant_proof a b c d e f g =
  Impact [(d, Formula (Term a (b, c)))] (Art_impl_ext a b c d e f (Hint g) ());

data Cooperation_proof a b c d e f = Triviala
  | Invariants_Update (Invariant_proof a b c (Sharp d) [Prelude.Char] e f)
      (Cooperation_proof a b c d e f)
  | Location_Addition (Location_addition_info a b c (Sharp d) e)
      (Cooperation_proof a b c d e f)
  | Fresh_Variable_Addition (Fresh_variable_addition_info a b c e)
      (Cooperation_proof a b c d e f)
  | Transition_Removal (Transition_removal_info [Term a (b, c)] c d e f)
      (Cooperation_proof a b c d e f)
  | Scc_Decomp [([Sharp d], Cooperation_proof a b c d e f)]
  | Cut_Transition_Split [([e], Cooperation_proof a b c d e f)];

data Termination_proof a b c d e f = Trivialb
  | Via_Cooperation
      [([(Sharp e, Transition_rule a b c (Sharp d))],
         Cooperation_proof a b c d (Sharp e) f)]
  | Invariants_Update_LTS (Invariant_proof a b c d [Prelude.Char] e f)
      (Termination_proof a b c d e f);

data Eq_proof a b = Refl (Term a b) | Sym (Eq_proof a b)
  | Trans (Eq_proof a b) (Eq_proof a b)
  | Assm (Term a b, Term a b) (b -> Term a b) | Cong a [Eq_proof a b];

data Equational_proof a b c = Equational_Proof_Tree (Eq_proof (Lab a b) c)
  | Completion_and_Normalization [(Term (Lab a b) c, Term (Lab a b) c)]
      (Completion_proof a b c)
  | Conversion
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), (Bool, Term (Lab a b) c)))]
  | Conversion_With_History
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                  (Bool, Term (Lab a b) c)))])];

data Dt_transformation_info a b =
  DT_Transformation_Info [((Term a b, Term a b), (Term a b, Term a b))]
    [((Term a b, Term a b), (Term a b, Term a b))] [Term a b];

data Wdp_trans_info a b =
  WDP_Trans_Info (Set (a, Nat)) [((Term a b, Term a b), (Term a b, Term a b))]
    [((Term a b, Term a b), (Term a b, Term a b))] [Term a b];

data Complexity_proof a b c =
  Rule_Shift_Complexity (Redtriple_impl (Lab a b))
    [(Term (Lab a b) c, Term (Lab a b) c)]
    (Maybe [(Term (Lab a b) c, Term (Lab a b) c)]) (Complexity_proof a b c)
  | RisEmpty_Complexity
  | Remove_Nonapplicable_Rules_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c)
  | Matchbounds_Complexity (Bounds_info (Lab a b) c)
  | Matchbounds_Rel_Complexity (Bounds_info (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Complexity_proof a b c)
  | DT_Transformation (Dt_transformation_info (Lab a b) c)
      (Complexity_proof a b c)
  | WDP_Transformation (Wdp_trans_info (Lab a b) c) (Complexity_proof a b c)
  | Complexity_Assumption
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            (Complexity_measure (Lab a b) c, Complexity_class))))
      [Generic_assm_proof a b c (Complexity_proof a b c) () () () ()]
  | Usable_Rules_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c)
  | Split_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c) (Complexity_proof a b c);

data Safety_proof a b c d e f g = Trivial
  | Invariant_Assertion (Invariant_proof a b c d e f g)
      (Safety_proof a b c d e f g);

data Proof a b c = TRS_Termination_Proof (Trs_termination_proof a b c)
  | Complexity_Proof (Complexity_proof a b c)
  | DP_Termination_Proof (Dp_termination_proof a b c)
  | DP_Nontermination_Proof (Dp_nontermination_proof a b c)
  | TRS_Nontermination_Proof (Trs_nontermination_proof a b c)
  | FP_Termination_Proof (Fptrs_termination_proof a b c)
  | Relative_TRS_Nontermination_Proof (Reltrs_nontermination_proof a b c)
  | TRS_Confluence_Proof (Cr_proof a b c)
  | TRS_Non_Confluence_Proof (Ncr_proof a b c c)
  | Completion_Proof (Completion_proof a b c)
  | Equational_Proof (Equational_proof a b c)
  | Equational_Disproof (Equational_disproof a b c)
  | Quasi_Reductive_Proof (Quasi_reductive_proof a b c)
  | Conditional_CR_Proof (Conditional_cr_proof a b c)
  | Conditional_Non_CR_Proof (Conditional_ncr_proof a b c c)
  | Tree_Automata_Closed_Proof (Ta_relation [Prelude.Char])
  | AC_Termination_Proof (Ac_termination_proof a b c)
  | LTS_Termination_Proof
      (Termination_proof Sig c Ty [Prelude.Char] [Prelude.Char] Hints)
  | LTS_Safety_Proof
      (Safety_proof Sig c Ty [Prelude.Char] [Prelude.Char] [Prelude.Char] Hints)
  | Unknown_Proof (Unknown_proof a b c)
  | Unknown_Disproof (Neg_unknown_proof a b c);

newtype Rai_list = Abs_rai_list [Maybe (Root_info, (Poly Rat, (Rat, Rat)))];

data Ns_constraint a = LEQ_ns Linear_poly a | GEQ_ns Linear_poly a;

newtype Comp_fun_idem b a = Abs_comp_fun_idem (b -> a -> a);

data Logic_ext a b c d =
  Logic_ext (a -> ([b], b)) (b -> Set c) (Set b) (c -> Bool) (a -> [c] -> c) d;

data Monoid_ext a b = Monoid_ext (a -> a -> a) a b;

data State_ext a b =
  State_ext [(Nat, Linear_poly)] (Nat -> Maybe a) (Nat -> Maybe a)
    (Mapping Nat a) Bool b;

data Ta_ext a b c = Ta_ext (Set a) (Set (Ta_rule a b)) (Set (a, a)) c;

data Dependance = Ignore | Increase | Decrease | Wild;

newtype Semilattice_set a = Abs_semilattice_set (a -> a -> a);

data Interpretation a = Int_linear_poly ((a, Nat), (Int, [Int]))
  | Rat_linear_poly ((a, Nat), (Rat, [Rat]))
  | Arctic_linear_poly ((a, Nat), (Arctic, [Arctic]))
  | Arctic_rat_linear_poly ((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]))
  | Real_linear_poly ((a, Nat), (Real, [Real]))
  | Int_matrix ((a, Nat), (Mat Int, [Mat Int]))
  | Rat_matrix ((a, Nat), (Mat Rat, [Mat Rat]))
  | Arctic_matrix ((a, Nat), (Mat Arctic, [Mat Arctic]))
  | Arctic_rat_matrix
      ((a, Nat), (Mat (Arctic_delta Rat), [Mat (Arctic_delta Rat)]))
  | Real_matrix ((a, Nat), (Mat Real, [Mat Real]))
  | Int_non_linear_poly ((a, Nat), [([(Nat, Nat)], Int)])
  | Rat_non_linear_poly ((a, Nat), [([(Nat, Nat)], Rat)])
  | Real_non_linear_poly ((a, Nat), [([(Nat, Nat)], Real)]);

data Relation_kind = Strict_TRS | Weak_TRS (Maybe Nat);

data Cert_result = Certified | Unsupported [Prelude.Char]
  | Error [Prelude.Char];

data Istate_ext a = Istate_ext Nat [(Nat, Linear_poly)] [Atom QDelta] a;

newtype Subst_incr a b = Abs_subst_incr
  (b -> Term a b, (Set b, Term a b -> [b]));

data Art_edge a b c d e = Cover e | Children [(Transition_rule a b c d, e)];

data Memory_ext a b c d =
  Memory_ext (() -> a) (a -> b -> Maybe c) (a -> (b, c) -> a) d;

data Ta_rule_impl a b = TA_rule_impl b [a] a (Rbt a ());

data Ta_impl a b =
  TA_Impl (Rbt a ()) (Rbt (b, Nat) [Ta_rule_impl a b]) [a] (Rbt a ()) [(a, a)]
    (a -> Rbt a ()) (a -> Rbt a ());

newtype Tp b a = TP
  (Bool,
    ([Term b a],
      (Bool,
        ([(Term b a, Term b a)],
          ([(Term b a, Term b a)],
            (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
              Term b a -> Bool))))));

data Art_ext a b c d e f =
  Art_ext [e] [e] (e -> Art_edge a b c d e) (e -> d)
    (e -> Formula (Term a (b, c))) f;

newtype Ta_code b a = Abs_ta_code
  (Rbta b (),
    (Rbta (Ta_rule b a) (),
      ([(b, b)],
        (Rbta b (),
          (Rbta (a, Nat) (Rbta ([b], b) ()),
            (Bool, (b -> Rbta b (), b -> Rbta b ())))))));

data C_constraint a b =
  Conditional_C Bool (Term a b, Term a b) (Term a b, Term a b)
  | Unconditional_C Bool (Term a b, Term a b);

data Direction_ext a b =
  Direction_ext (a -> a -> Bool) (State_ext a () -> Nat -> Maybe a)
    (State_ext a () -> Nat -> Maybe a)
    (((Nat -> Maybe a) -> Nat -> Maybe a) -> State_ext a () -> State_ext a ())
    (Nat -> a -> Atom a) b;

newtype Dpp b a = DPP
  (Bool,
    (Bool,
      ([(Term b a, Term b a)],
        ([(Term b a, Term b a)],
          ([Term b a],
            (Bool,
              (Bool,
                ([(Term b a, Term b a)],
                  ([(Term b a, Term b a)],
                    (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                      (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                        (Bool, Term b a -> Bool))))))))))));

data Poly_constraint a = Poly_Ge [([(a, Nat)], Int)]
  | Poly_Eq [([(a, Nat)], Int)];

data Hinter_ext a b c d e =
  Hinter_ext [c] (b -> [d]) (c -> a) (c -> Maybe [a]) e;

newtype Ac_dpp b a = AC_DPP
  ([(Term b a, Term b a)],
    ([(Term b a, Term b a)],
      ([(Term b a, Term b a)],
        ([(Term b a, Term b a)],
          ([(Term b a, Term b a)],
            Rbt (b, Nat) [((), (Term b a, Term b a))])))));

data Gen_g_impl_ext a b c d = Gen_g_impl_ext a b c d;

data Condition_type = Bound | Strict | Non_Strict;

data Redtriple_ext a b c =
  Redtriple_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Set Nat) ((a, Nat) -> Set Nat)
    ([(Term a b, Term a b)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ([Prelude.Char] -> [Prelude.Char]) (Maybe [(a, Nat)])
    (Complexity_measure a b ->
      Complexity_class -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    c;

data Fp_loop_prf a b =
  FP_loop_prf (Ctxt a b) [(b, Term a b)] (Term a b)
    [(Pos, ((Term a b, Term a b), Term a b))];

data Sl_ops_ext a b c d e =
  Sl_ops_ext (a -> [b] -> c) (a -> Nat -> c -> Bool) (a -> [b] -> b) [b] b
    ([(Term a d, Term a d)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    (a -> [b] -> c) (a -> Nat -> c -> Bool) (c -> [c]) (a -> Nat -> [c]) e;

data Slm_ops_ext a b c d =
  Slm_ops_ext (a -> [b] -> c) (a -> [b] -> b) [b] b (a -> [b] -> c) d;

data Tp_ops_ext a b c d =
  Tp_ops_ext
    (a -> (Bool,
            (Set (Term b c),
              (Set (Term b c, Term b c), Set (Term b c, Term b c)))))
    (a -> [Term b c]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)]) (a -> Bool)
    (a -> Term b c -> Bool) (a -> Bool)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (Bool ->
      [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> Bool) d;

data Partial_object_ext a b = Partial_object_ext (Set a) b;

newtype Cut_transition_split_info a = Cut_Transition_Split_Info [[a]];

data Dpp_ops_ext a b c d =
  Dpp_ops_ext
    (a -> (Bool,
            (Bool,
              (Set (Term b c, Term b c),
                (Set (Term b c, Term b c),
                  (Set (Term b c),
                    (Set (Term b c, Term b c), Set (Term b c, Term b c))))))))
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [Term b c])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> Bool) (a -> Bool) (a -> Bool)
    (a -> Term b c -> Bool) (a -> Bool)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> (b, Nat) -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)] -> a)
    (a -> (Term b c, Term b c) -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (Bool ->
      Bool ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] ->
            [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> Bool) (a -> Bool) (a -> Bool) d;

data Root_redtriple_ext a b c =
  Root_redtriple_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Set Nat) ((a, Nat) -> Set Nat)
    ([Prelude.Char] -> [Prelude.Char]) c;

data Non_inf_order_ext a b c =
  Non_inf_order_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    (C_constraint a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Nat -> Dependance) ([Prelude.Char] -> [Prelude.Char]) c;

data Ac_tp_ops_ext a b c d =
  Ac_tp_ops_ext (a -> (Set (Term b c, Term b c), (Set b, Set b)))
    (a -> [(Term b c, Term b c)]) (a -> [b]) (a -> [b])
    ([(Term b c, Term b c)] -> [b] -> [b] -> a)
    (a -> [(Term b c, Term b c)] -> a) (a -> [(Term b c, Term b c)]) d;

data Ordered_semiring_ext a b =
  Ordered_semiring_ext (a -> a -> Bool) (a -> a -> Bool) (a -> a -> a) b;

data Ac_dpp_ops_ext a b c d =
  Ac_dpp_ops_ext
    (a -> (Set (Term b c, Term b c),
            (Set (Term b c, Term b c),
              (Set (Term b c, Term b c),
                (Set (Term b c, Term b c), Set (Term b c, Term b c))))))
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)])
    ([(Term b c, Term b c)] ->
      [(Term b c, Term b c)] ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a) (a -> Bool)
    (a -> Bool) (a -> [(Term b c, Term b c)] -> a) d;

data Lpoly_order_semiring_ext a b =
  Lpoly_order_semiring_ext Bool a (a -> Bool) (a -> Bool) (a -> Nat)
    (a -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) [Prelude.Char] b;

newtype X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a =
  Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
  (Maybe ((a, Nat) -> [Nat]));

newtype
  X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
    a
  = Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
  (Maybe ((a, Nat) -> Af_entry, Set (a, Nat)));

dom :: forall a b. (Cenum a) => (a -> Maybe b) -> Set a;
dom m = collect (\ a -> not (is_none (m a)));

dlist_ex :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Bool;
dlist_ex x xc = any x (list_of_dlist xc);

rBT_Impl_rbt_ex :: forall a b. (a -> b -> Bool) -> Rbta a b -> Bool;
rBT_Impl_rbt_ex p (Branch c l k v r) =
  p k v || (rBT_Impl_rbt_ex p l || rBT_Impl_rbt_ex p r);
rBT_Impl_rbt_ex p Emptya = False;

ex :: forall a b. (Ccompare a) => (a -> b -> Bool) -> Mapping_rbt a b -> Bool;
ex xb xc = rBT_Impl_rbt_ex xb (impl_ofb xc);

bex :: forall a. (Ceq a, Ccompare a) => Set a -> (a -> Bool) -> Bool;
bex (RBT_set rbt) p =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Bex RBT_set: ccompare = None" (\ _ -> bex (RBT_set rbt) p);
    Just _ -> ex (\ k _ -> p k) rbt;
  });
bex (DList_set dxs) p =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "Bex DList_set: ceq = None"
        (\ _ -> bex (DList_set dxs) p);
    Just _ -> dlist_ex p dxs;
  });
bex (Set_Monad xs) p = any p xs;

tag :: Xml -> [Prelude.Char];
tag (XML name uu uv) = name;
tag (XML_text uw) = [];

rBT_Impl_rbt_all :: forall a b. (a -> b -> Bool) -> Rbta a b -> Bool;
rBT_Impl_rbt_all p (Branch c l k v r) =
  p k v && rBT_Impl_rbt_all p l && rBT_Impl_rbt_all p r;
rBT_Impl_rbt_all p Emptya = True;

alla :: forall a b. (Ccompare a) => (a -> b -> Bool) -> Mapping_rbt a b -> Bool;
alla xb xc = rBT_Impl_rbt_all xb (impl_ofb xc);

ball :: forall a. (Ceq a, Ccompare a) => Set a -> (a -> Bool) -> Bool;
ball (RBT_set rbt) p =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Ball RBT_set: ccompare = None" (\ _ -> ball (RBT_set rbt) p);
    Just _ -> alla (\ k _ -> p k) rbt;
  });
ball (DList_set dxs) p =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "Ball DList_set: ceq = None"
        (\ _ -> ball (DList_set dxs) p);
    Just _ -> dlist_all p dxs;
  });
ball (Set_Monad xs) p = all p xs;

returna :: forall a b. a -> Sum_bot b a;
returna x = Sumbot (Inr x);

errora :: forall a b. a -> Sum_bot a b;
errora x = Sumbot (Inl x);

int_of_digit :: Prelude.Char -> Sum_bot [Prelude.Char] Int;
int_of_digit x =
  (if x == '0' then returna zero_int
    else (if x == '1' then returna (Int_of_integer (1 :: Integer))
           else (if x == '2' then returna (Int_of_integer (2 :: Integer))
                  else (if x == '3' then returna (Int_of_integer (3 :: Integer))
                         else (if x == '4'
                                then returna (Int_of_integer (4 :: Integer))
                                else (if x == '5'
                                       then returna
      (Int_of_integer (5 :: Integer))
                                       else (if x == '6'
      then returna (Int_of_integer (6 :: Integer))
      else (if x == '7' then returna (Int_of_integer (7 :: Integer))
             else (if x == '8' then returna (Int_of_integer (8 :: Integer))
                    else (if x == '9'
                           then returna (Int_of_integer (9 :: Integer))
                           else errora
                                  [x, ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                                    'a', ' ', 'd', 'i', 'g', 'i',
                                    't']))))))))));

binda :: forall a b c. Sum_bot a b -> (b -> Sum_bot a c) -> Sum_bot a c;
binda (Sumbot a) f = (case a of {
                       Inl b -> Sumbot (Inl b);
                       Inr aa -> f aa;
                     });

int_of_string_aux :: Int -> [Prelude.Char] -> Sum_bot [Prelude.Char] Int;
int_of_string_aux n [] = returna n;
int_of_string_aux n (d : s) =
  binda (int_of_digit d)
    (\ m ->
      int_of_string_aux
        (plus_int (times_int (Int_of_integer (10 :: Integer)) n) m) s);

int_of_string :: [Prelude.Char] -> Sum_bot [Prelude.Char] Int;
int_of_string s =
  (if null s
    then errora
           ['c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'o', 'n', 'v', 'e', 'r',
             't', ' ', 'e', 'm', 'p', 't', 'y', ' ', 's', 't', 'r', 'i', 'n',
             'g', ' ', 'i', 'n', 't', 'o', ' ', 'n', 'u', 'm', 'b', 'e', 'r']
    else (if take one_nat s == ['-']
           then binda (int_of_string_aux zero_int (tla s))
                  (\ i -> returna (minus_int zero_int i))
           else int_of_string_aux zero_int s));

shows_attr ::
  ([Prelude.Char], [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_attr av =
  shows_prec_list zero_nat (fst av) .
    shows_string (['=', '\"'] ++ snd av ++ ['\"']);

shows_attrs ::
  [([Prelude.Char], [Prelude.Char])] -> [Prelude.Char] -> [Prelude.Char];
shows_attrs asa = foldr (\ a -> shows_string [' '] . shows_attr a) asa;

shows_XML_indent ::
  [Prelude.Char] -> Nat -> Xml -> [Prelude.Char] -> [Prelude.Char];
shows_XML_indent ind i (XML n a c) =
  shows_string ['\n'] .
    shows_string ind .
      shows_string ['<'] .
        shows_prec_list zero_nat n .
          shows_attrs a .
            (if null c then shows_string ['/', '>']
              else shows_string ['>'] .
                     foldr (shows_XML_indent (replicate i ' ' ++ ind) i) c .
                       shows_string ['\n'] .
                         shows_string ind .
                           shows_string ['<', '/'] .
                             shows_prec_list zero_nat n . shows_string ['>']);
shows_XML_indent ind i (XML_text t) = shows_string t;

shows_prec_xml :: Nat -> Xml -> [Prelude.Char] -> [Prelude.Char];
shows_prec_xml d xml = shows_XML_indent [] (nat_of_integer (2 :: Integer)) xml;

text :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
text tag (XML n atts [XML_text t]) =
  (if n == tag && null atts then returna t
    else errora
           (concat
             [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't',
                'r', 'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r',
                ' '],
               tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
               shows_prec_xml zero_nat (XML n atts [XML_text t]) []]));
text tag (XML v va []) =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't', 'r',
         'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r', ' '],
        tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
        shows_prec_xml zero_nat (XML v va []) []]);
text tag (XML v va (XML ve vf vg : vd)) =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't', 'r',
         'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r', ' '],
        tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
        shows_prec_xml zero_nat (XML v va (XML ve vf vg : vd)) []]);
text tag (XML v va (vc : ve : vf)) =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't', 'r',
         'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r', ' '],
        tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
        shows_prec_xml zero_nat (XML v va (vc : ve : vf)) []]);
text tag (XML_text v) =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't', 'r',
         'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r', ' '],
        tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
        shows_prec_xml zero_nat (XML_text v) []]);

int :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Int;
int tag x = binda (text tag x) int_of_string;

nata :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Nat;
nata tag x =
  binda (text tag x)
    (\ txt -> binda (int_of_string txt) (\ i -> returna (nat i)));

options ::
  forall a.
    [([Prelude.Char], Xml -> Sum_bot [Prelude.Char] a)] ->
      Xml -> Sum_bot [Prelude.Char] a;
options ps x =
  (case map_of ps (tag x) of {
    Nothing ->
      errora
        (concat
          [['e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'o', 'n', 'e', ' ',
             'o', 'f', ':', ' '],
            concatMap (\ p -> fst p ++ [' ']) ps, ['\n'],
            ['b', 'u', 't', ' ', 'f', 'o', 'u', 'n', 'd'], ['\n'],
            shows_prec_xml zero_nat x []]);
    Just p -> p x;
  });

change ::
  forall a b.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      (a -> b) -> Xml -> Sum_bot [Prelude.Char] b;
change p f x = binda (p x) (returna . f);

list2elements :: forall a. [a] -> Maybe (a, a);
list2elements [x, y] = Just (x, y);
list2elements [] = Nothing;
list2elements [v] = Nothing;
list2elements (v : vb : vd : ve) = Nothing;

fail :: forall a. [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] a;
fail tag xml =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 't', 'r', 'a', 'n',
         's', 'f', 'o', 'r', 'm', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
         'o', 'w', 'i', 'n', 'g', ' ', 'x', 'm', 'l', ' ', 'e', 'l', 'e', 'm',
         'e', 'n', 't', ' ', '(', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' '],
        tag, [')'], ['\n'], shows_prec_xml zero_nat xml []]);

pair ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> b -> c) -> Xml -> Sum_bot [Prelude.Char] c;
pair tag p1 p2 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list2elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, cs2) ->
                 binda (p1 cs1)
                   (\ a -> binda (p2 cs2) (\ b -> returna (f a b)));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

rat :: Xml -> Sum_bot [Prelude.Char] Rat;
rat = options
        [(['i', 'n', 't', 'e', 'g', 'e', 'r'],
           change (int ['i', 'n', 't', 'e', 'g', 'e', 'r']) of_int),
          (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l'],
            pair ['r', 'a', 't', 'i', 'o', 'n', 'a', 'l']
              (int ['n', 'u', 'm', 'e', 'r', 'a', 't', 'o', 'r'])
              (int ['d', 'e', 'n', 'o', 'm', 'i', 'n', 'a', 't', 'o', 'r'])
              (\ x y -> divide_rat (of_int x) (of_int y)))];

skol ::
  forall a b. (Ceq a, Ccompare a) => Set a -> Term b a -> Term (Sum b a) a;
skol v (Var x) = (if member x v then Fun (Inr x) [] else Var x);
skol v (Fun f ts) = Fun (Inl f) (map (skol v) ts);

empty :: forall a b. (Linorder a) => Rbt a b;
empty = RBT Emptya;

foldb ::
  forall a b. (Ccompare a) => (a -> b -> b) -> Mapping_rbt a () -> b -> b;
foldb x xc = folda (\ a _ -> x a) (impl_ofb xc);

image ::
  forall a b.
    (Ceq a, Ccompare a, Ceq b, Ccompare b,
      Set_impl b) => (a -> b) -> Set a -> Set b;
image h (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "image RBT_set: ccompare = None" (\ _ -> image h (RBT_set rbt));
    Just _ -> foldb (inserta . h) rbt bot_set;
  });
image g (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "image DList_set: ceq = None" (\ _ -> image g (DList_set dxs));
    Just _ -> foldc (inserta . g) dxs bot_set;
  });
image f (Complement (Complement b)) = image f b;
image f (Collect_set a) =
  (error :: forall a. String -> (() -> a) -> a) "image Collect_set"
    (\ _ -> image f (Collect_set a));
image f (Set_Monad xs) = Set_Monad (map f xs);

bind :: forall a b. Maybe a -> (a -> Maybe b) -> Maybe b;
bind Nothing f = Nothing;
bind (Just x) f = f x;

zip_option :: forall a b. [a] -> [b] -> Maybe [(a, b)];
zip_option [] [] = Just [];
zip_option (x : xs) (y : ys) =
  bind (zip_option xs ys) (\ zs -> Just ((x, y) : zs));
zip_option (x : xs) [] = Nothing;
zip_option [] (y : ys) = Nothing;

guarda :: Bool -> Maybe ();
guarda b = (if b then Just () else Nothing);

match_lista ::
  forall a b. (Eq a) => [(Gctxt a b, Term a b)] -> Maybe [(Gctxt a b, b)];
match_lista ((GCFun f ss, Var x) : ps) =
  bind (match_lista ps) (\ psa -> Just ((GCFun f ss, x) : psa));
match_lista ((GCFun f ss, Fun g ts) : ps) =
  bind (guarda (f == g))
    (\ _ -> bind (zip_option ss ts) (\ psa -> match_lista (psa ++ ps)));
match_lista ((GCHole, t) : ps) = match_lista ps;
match_lista [] = Just [];

merge_lists ::
  forall a b. (Eq a) => [Gctxt a b] -> [Gctxt a b] -> Maybe [Gctxt a b];
merge_lists (c : cs) [] = Nothing;
merge_lists [] (d : ds) = Nothing;
merge_lists (GCFun f ss : cs) (GCFun g ts : ds) =
  bind (guarda (f == g))
    (\ _ ->
      bind (merge_lists ss ts)
        (\ us -> bind (merge_lists cs ds) (\ es -> Just (GCFun f us : es))));
merge_lists (c : cs) (GCHole : ds) =
  bind (merge_lists cs ds) (\ es -> Just (c : es));
merge_lists (GCHole : cs) (d : ds) =
  bind (merge_lists cs ds) (\ es -> Just (d : es));
merge_lists [] [] = Just [];

mergea :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Maybe (Gctxt a b);
mergea c d = bind (merge_lists [c] [d]) (\ es -> Just (nth es zero_nat));

merge_var ::
  forall a b.
    (Eq a,
      Eq b) => a -> Gctxt b a ->
                      [(Gctxt b a, a)] ->
                        Maybe ((Gctxt b a, a), [(Gctxt b a, a)]);
merge_var x c ((d, y) : ps) =
  (if x == y then bind (mergea c d) (\ e -> merge_var x e ps)
    else bind (merge_var x c ps) (\ (b, psa) -> Just (b, (d, y) : psa)));
merge_var x c [] = Just ((c, x), []);

merge_all ::
  forall a b. (Eq a, Eq b) => [(Gctxt a b, b)] -> Maybe [(Gctxt a b, b)];
merge_all [] = Just [];
merge_all ((c, x) : ps) =
  bind (merge_var x c ps)
    (\ (cx, psa) -> bind (merge_all psa) (\ psb -> Just (cx : psb)));

matchc ::
  forall a b. (Eq a, Eq b) => (Gctxt a b, Term a b) -> Maybe [(Gctxt a b, b)];
matchc (c, t) = bind (match_lista [(c, t)]) merge_all;

matchb :: forall a b. (Eq a, Eq b) => Gctxt a b -> Term a b -> Bool;
matchb c t = not (is_none (matchc (c, t)));

tcap ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Set (Term a b, Term a b) -> Term a b -> Gctxt a b;
tcap uu (Var uv) = GCHole;
tcap r (Fun f ts) =
  let {
    h = GCFun f (map (tcap r) ts);
  } in (if bex r (\ ra -> matchb h (fst ra)) then GCHole else h);

root :: forall a b. Term a b -> Maybe (a, Nat);
root (Var x) = Nothing;
root (Fun f ts) = Just (f, size_list ts);

leaf :: forall a. [Prelude.Char] -> a -> Xml -> Sum_bot [Prelude.Char] a;
leaf tag x (XML name atts cs) =
  (if name == tag && null atts && null cs then returna x
    else fail tag (XML name atts cs));
leaf tag x (XML_text v) = fail tag (XML_text v);

map_sum_bot :: forall a b c. (a -> Sum_bot b c) -> [a] -> Sum_bot b [c];
map_sum_bot f [] = returna [];
map_sum_bot f (x : xs) =
  binda (f x) (\ y -> binda (map_sum_bot f xs) (\ ys -> returna (y : ys)));

many ::
  forall a b.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        ([a] -> b) -> Xml -> Sum_bot [Prelude.Char] b;
many tag p f (XML name atts cs) =
  (if name == tag && null atts then binda (map_sum_bot p cs) (returna . f)
    else fail tag (XML name atts cs));
many tag p f (XML_text v) = fail tag (XML_text v);

transitions_impl ::
  forall a b c d e. Lts_impl a b c d e -> [(e, Transition_rule a b c d)];
transitions_impl (Lts_Impl x1 x2 x3) = x2;

initiala :: forall a b c d e. Lts_impl a b c d e -> [d];
initiala (Lts_Impl x1 x2 x3) = x1;

assertion_impl ::
  forall a b c d e. Lts_impl a b c d e -> [(d, Formula (Term a (b, c)))];
assertion_impl (Lts_Impl x1 x2 x3) = x3;

lookupa :: forall a b. (Eq a) => Alist a b -> a -> Maybe b;
lookupa xa = map_of (impl_ofa xa);

lookupb :: forall a b. (Ccompare a, Eq a) => Mapping a b -> a -> Maybe b;
lookupb (RBT_Mapping t) = lookupd t;
lookupb (Assoc_List_Mapping al) = lookupa al;

lookup_default :: forall a b. (Ccompare b, Eq b) => a -> Mapping b a -> b -> a;
lookup_default d m k = (case lookupb m k of {
                         Nothing -> d;
                         Just v -> v;
                       });

update :: forall a b. (Eq a) => a -> b -> [(a, b)] -> [(a, b)];
update k v [] = [(k, v)];
update k v (p : ps) = (if fst p == k then (k, v) : ps else p : update k v ps);

updatea :: forall a b. (Eq a) => a -> b -> Alist a b -> Alist a b;
updatea xc xd xe = Alist (update xc xd (impl_ofa xe));

fun_upd :: forall a b. (Eq a) => (a -> b) -> a -> b -> a -> b;
fun_upd f a b = (\ x -> (if x == a then b else f x));

updateb ::
  forall a b. (Ccompare a, Eq a) => a -> b -> Mapping a b -> Mapping a b;
updateb k v (RBT_Mapping t) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "update RBT_Mapping: ccompare = None"
        (\ _ -> updateb k v (RBT_Mapping t));
    Just _ -> RBT_Mapping (inserte k v t);
  });
updateb k v (Assoc_List_Mapping al) = Assoc_List_Mapping (updatea k v al);
updateb k v (Mapping m) = Mapping (fun_upd m k (Just v));

mapping_empty_choose :: forall a b. (Ccompare a) => Mapping a b;
mapping_empty_choose = (case (ccompare :: Maybe (a -> a -> Ordera)) of {
                         Nothing -> Assoc_List_Mapping emptya;
                         Just _ -> RBT_Mapping emptye;
                       });

mapping_empty :: forall a b. (Ccompare a) => Mapping_impla -> Mapping a b;
mapping_empty Mapping_RBT = RBT_Mapping emptye;
mapping_empty Mapping_Assoc_List = Assoc_List_Mapping emptya;
mapping_empty Mapping_Mapping = Mapping (\ _ -> Nothing);
mapping_empty Mapping_Choose = mapping_empty_choose;

emptyb :: forall a b. (Ccompare a, Mapping_impl a) => Mapping a b;
emptyb = mapping_empty (of_phantom (mapping_impl :: Phantom a Mapping_impla));

of_alist ::
  forall a b. (Ccompare a, Eq a, Mapping_impl a) => [(a, b)] -> Mapping a b;
of_alist xs = foldr (\ (a, b) -> updateb a b) xs emptyb;

map_of_default ::
  forall a b. (Ccompare b, Eq b, Mapping_impl b) => a -> [(b, a)] -> b -> a;
map_of_default d xs = lookup_default d (of_alist xs);

assertion_of ::
  forall a b c d e.
    (Ccompare d, Eq d,
      Mapping_impl d) => Lts_impl a b c d e -> d -> Formula (Term a (b, c));
assertion_of pi = map_of_default (Conjunction []) (assertion_impl pi);

lts_of ::
  forall a b c d e.
    (Ccompare a, Eq a, Ccompare b, Eq b, Ccompare c, Eq c, Ceq d, Ccompare d,
      Eq d, Mapping_impl d, Set_impl d, Ceq e, Ccompare e,
      Set_impl e) => Lts_impl a b c d e -> Lts_ext a b c d ();
lts_of pi =
  Lts_ext (set (initiala pi)) (image snd (set (transitions_impl pi)))
    (assertion_of pi) ();

source :: forall a b c d. Transition_rule a b c d -> d;
source (Transition l uu uv) = l;

target :: forall a b c d. Transition_rule a b c d -> d;
target (Transition uu r uv) = r;

col :: forall a. Mat a -> Nat -> Vec a;
col a j = vec (mat_dim_row a) (\ i -> mat_index a (i, j));

row :: forall a. Mat a -> Nat -> Vec a;
row a i = vec (mat_dim_col a) (\ j -> mat_index a (i, j));

funpow :: forall a. Nat -> (a -> a) -> a -> a;
funpow n f =
  (if equal_nat n zero_nat then id else f . funpow (minus_nat n one_nat) f);

val :: QDelta -> Rat -> Rat;
val qd delta = plus_rat (qdfst qd) (times_rat delta (qdsnd qd));

rbt_del :: forall a b. (Compare_order a) => a -> Rbta a b -> Rbta a b;
rbt_del x (Branch c a y s b) = (case compare x y of {
                                 Eqa -> combine a b;
                                 Lt -> rbt_del_from_left x a y s b;
                                 Gt -> rbt_del_from_right x a y s b;
                               });
rbt_del x Emptya = Emptya;

rbt_del_from_left ::
  forall a b.
    (Compare_order a) => a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_left x (Branch B lt z v rt) y s b =
  balance_left (rbt_del x (Branch B lt z v rt)) y s b;
rbt_del_from_left x Emptya y s b = Branch R (rbt_del x Emptya) y s b;
rbt_del_from_left x (Branch R va vb vc vd) y s b =
  Branch R (rbt_del x (Branch R va vb vc vd)) y s b;

rbt_del_from_right ::
  forall a b.
    (Compare_order a) => a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_right x a y s (Branch B lt z v rt) =
  balance_right a y s (rbt_del x (Branch B lt z v rt));
rbt_del_from_right x a y s Emptya = Branch R a y s (rbt_del x Emptya);
rbt_del_from_right x a y s (Branch R va vb vc vd) =
  Branch R a y s (rbt_del x (Branch R va vb vc vd));

rbt_delete :: forall a b. (Compare_order a) => a -> Rbta a b -> Rbta a b;
rbt_delete k t = paint B (rbt_del k t);

impl_of :: forall b a. (Linorder b) => Rbt b a -> Rbta b a;
impl_of (RBT x) = x;

delete :: forall a b. (Compare_order a) => a -> Rbt a b -> Rbt a b;
delete xb xc = RBT (rbt_delete xb (impl_of xc));

rbt_ins ::
  forall a b.
    (Compare_order a) => (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_ins f k v (Branch R l x y r) = (case compare k x of {
                                     Eqa -> Branch R l x (f k y v) r;
                                     Lt -> Branch R (rbt_ins f k v l) x y r;
                                     Gt -> Branch R l x y (rbt_ins f k v r);
                                   });
rbt_ins f k v (Branch B l x y r) = (case compare k x of {
                                     Eqa -> Branch B l x (f k y v) r;
                                     Lt -> balance (rbt_ins f k v l) x y r;
                                     Gt -> balance l x y (rbt_ins f k v r);
                                   });
rbt_ins f k v Emptya = Branch R Emptya k v Emptya;

rbt_insert_with_key ::
  forall a b.
    (Compare_order a) => (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_insert_with_key f k v t = paint B (rbt_ins f k v t);

rbt_insert :: forall a b. (Compare_order a) => a -> b -> Rbta a b -> Rbta a b;
rbt_insert = rbt_insert_with_key (\ _ _ nv -> nv);

insert :: forall a b. (Compare_order a) => a -> b -> Rbt a b -> Rbt a b;
insert xc xd xe = RBT (rbt_insert xc xd (impl_of xe));

rbt_lookupa :: forall a b. (Compare_order a) => Rbta a b -> a -> Maybe b;
rbt_lookupa (Branch uu l x y r) k = (case compare k x of {
                                      Eqa -> Just y;
                                      Lt -> rbt_lookupa l k;
                                      Gt -> rbt_lookupa r k;
                                    });
rbt_lookupa Emptya k = Nothing;

lookup :: forall a b. (Compare_order a) => Rbt a b -> a -> Maybe b;
lookup x = rbt_lookupa (impl_of x);

proja :: forall a b. Term a b -> Nat -> Term a b;
proja (Fun f ts) i = (if less_nat i (size_list ts) then nth ts i else Fun f ts);

filtera :: forall a. (Ceq a, Ccompare a) => (a -> Bool) -> Set a -> Set a;
filtera p a = inf_set a (Collect_set p);

subst :: forall a b. (Eq a) => a -> Term b a -> a -> Term b a;
subst x t = fun_upd Var x t;

debug :: forall a. [Prelude.Char] -> [Prelude.Char] -> a -> a;
debug i t x = x;

guard ::
  forall a.
    (Xml -> Bool) ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] a;
guard p p1 p2 x = (if p x then p1 x else p2 x);

merge :: forall a b. (Eq a) => [(a, b)] -> [(a, b)] -> [(a, b)];
merge qs ps = foldr (\ (a, b) -> update a b) ps qs;

cnj :: Complex -> Complex;
cnj z = Complex (re z) (uminus_real (im z));

fset :: forall a. Fset a -> Set a;
fset (Abs_fset x) = x;

fimage ::
  forall b a.
    (Ceq b, Ccompare b, Ceq a, Ccompare a,
      Set_impl a) => (b -> a) -> Fset b -> Fset a;
fimage xb xc = Abs_fset (image xb (fset xc));

insertb :: forall a. (Eq a) => a -> [a] -> [a];
insertb x xs = (if membera xs x then xs else x : xs);

lterms ::
  forall a b. ((a, Nat) -> [(Nat, Nat)]) -> Term a b -> [(Term a b, Nat)];
lterms pi =
  (\ (Fun f ts) ->
    map (\ (i, a) -> (proja (Fun f ts) i, a)) (pi (f, size_list ts)));

lhs :: (Nat, Linear_poly) -> Nat;
lhs (l, r) = l;

rhs :: (Nat, Linear_poly) -> Linear_poly;
rhs (l, r) = r;

ground :: forall a b. Term a b -> Bool;
ground (Var x) = False;
ground (Fun f ts) = all ground ts;

insert_vars_term :: forall a b. (Eq b) => Term a b -> [b] -> [b];
insert_vars_term (Var x) xs = insertb x xs;
insert_vars_term (Fun f ts) xs = foldr insert_vars_term ts xs;

is_Var :: forall a b. Term a b -> Bool;
is_Var (Var x1) = True;
is_Var (Fun x21 x22) = False;

wf_rule :: forall a b. (Eq b) => (Term a b, Term a b) -> Bool;
wf_rule r =
  not (is_Var (fst r)) &&
    all (membera (insert_vars_term (fst r) [])) (insert_vars_term (snd r) []);

fun_of :: forall a b. (Eq a) => [(a, b)] -> a -> b;
fun_of vec x = the (map_of vec x);

letters :: [Prelude.Char];
letters =
  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',
    'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', '0', '1', '2', '3', '4', '5', '6',
    '7', '8', '9', '&', ';', ':', '-'];

list3elements :: forall a. [a] -> Maybe (a, (a, a));
list3elements [x, y, z] = Just (x, (y, z));
list3elements [] = Nothing;
list3elements [v] = Nothing;
list3elements [v, vb] = Nothing;
list3elements (v : vb : vd : vf : vg) = Nothing;

triple ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> b -> c -> d) -> Xml -> Sum_bot [Prelude.Char] d;
triple tag p1 p2 p3 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list3elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, (cs2, cs3)) ->
                 binda (p1 cs1)
                   (\ a ->
                     binda (p2 cs2)
                       (\ b -> binda (p3 cs3) (\ c -> returna (f a b c))));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

list4elements :: forall a. [a] -> Maybe (a, (a, (a, a)));
list4elements [x, y, z, u] = Just (x, (y, (z, u)));
list4elements [] = Nothing;
list4elements [v] = Nothing;
list4elements [v, vb] = Nothing;
list4elements [v, vb, vd] = Nothing;
list4elements (v : vb : vd : vf : vh : vi) = Nothing;

tuple4 ::
  forall a b c d e.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (a -> b -> c -> d -> e) -> Xml -> Sum_bot [Prelude.Char] e;
tuple4 tag p1 p2 p3 p4 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list4elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, (cs2, (cs3, cs4))) ->
                 binda (p1 cs1)
                   (\ a ->
                     binda (p2 cs2)
                       (\ b ->
                         binda (p3 cs3)
                           (\ c ->
                             binda (p4 cs4) (\ d -> returna (f a b c d)))));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

hd :: forall a. (Ceq a) => Set_dlist a -> a;
hd xa = hda (list_of_dlist xa);

tl :: forall a. (Ceq a) => Set_dlist a -> Set_dlist a;
tl xa = Abs_dlist (tla (list_of_dlist xa));

foldli :: forall a b. [a] -> (b -> Bool) -> (a -> b -> b) -> b -> b;
foldli [] c f sigma = sigma;
foldli (x : xs) c f sigma =
  (if c sigma then foldli xs c f (f x sigma) else sigma);

scf_list :: forall a. (Nat -> Nat) -> [a] -> [a];
scf_list scf xs =
  concatMap (\ (x, i) -> replicate (scf i) x)
    (zip xs (upt zero_nat (size_list xs)));

scf_term :: forall a b. ((a, Nat) -> Nat -> Nat) -> Term a b -> Term a b;
scf_term scf (Var x) = Var x;
scf_term scf (Fun f ts) =
  Fun f (scf_list (scf (f, size_list ts)) (map (scf_term scf) ts));

butlast :: forall a. [a] -> [a];
butlast [] = [];
butlast (x : xs) = (if null xs then [] else x : butlast xs);

extract :: forall a. (a -> Bool) -> [a] -> Maybe ([a], (a, [a]));
extract p (x : xs) =
  (if p x then Just ([], (x, xs))
    else (case extract p xs of {
           Nothing -> Nothing;
           Just (ys, (y, zs)) -> Just (x : ys, (y, zs));
         }));
extract p [] = Nothing;

productb ::
  forall a b. (Ceq a, Ceq b) => Set_dlist a -> Set_dlist b -> Set_dlist (a, b);
productb dxs1 dxs2 =
  Abs_dlist (foldc (\ a -> foldc (\ c -> (\ b -> (a, c) : b)) dxs2) dxs1 []);

rbt_product ::
  forall a b c d e.
    (a -> b -> c -> d -> e) -> Rbta a b -> Rbta c d -> Rbta (a, c) e;
rbt_product f rbt1 rbt2 =
  rbtreeify
    (reverse
      (folda (\ a b -> folda (\ c d -> (\ e -> ((a, c), f a b c d) : e)) rbt2)
        rbt1 []));

productd ::
  forall a d b e c.
    (Ccompare a,
      Ccompare b) => (a -> d -> b -> e -> c) ->
                       Mapping_rbt a d ->
                         Mapping_rbt b e -> Mapping_rbt (a, b) c;
productd xc xd xe = Mapping_RBTa (rbt_product xc (impl_ofb xd) (impl_ofb xe));

producta ::
  forall a b.
    (Ccompare a,
      Ccompare b) => Mapping_rbt a () ->
                       Mapping_rbt b () -> Mapping_rbt (a, b) ();
producta rbt1 rbt2 = productd (\ _ _ _ _ -> ()) rbt1 rbt2;

productc ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Set a -> Set b -> Set (a, b);
productc (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set RBT_set: ccompare1 = None"
        (\ _ -> productc (RBT_set rbt1) (RBT_set rbt2));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "product RBT_set RBT_set: ccompare2 = None"
            (\ _ -> productc (RBT_set rbt1) (RBT_set rbt2));
        Just _ -> RBT_set (producta rbt1 rbt2);
      });
  });
productc a2 (RBT_set rbt2) =
  (case (ccompare :: Maybe (b -> b -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set: ccompare2 = None" (\ _ -> productc a2 (RBT_set rbt2));
    Just _ -> foldb (\ y -> sup_set (image (\ x -> (x, y)) a2)) rbt2 bot_set;
  });
productc (RBT_set rbt1) b2 =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set: ccompare1 = None" (\ _ -> productc (RBT_set rbt1) b2);
    Just _ -> foldb (\ x -> sup_set (image (\ a -> (x, a)) b2)) rbt1 bot_set;
  });
productc (DList_set dxs) (DList_set dys) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set DList_set: ceq1 = None"
        (\ _ -> productc (DList_set dxs) (DList_set dys));
    Just _ ->
      (case (ceq :: Maybe (b -> b -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "product DList_set DList_set: ceq2 = None"
            (\ _ -> productc (DList_set dxs) (DList_set dys));
        Just _ -> DList_set (productb dxs dys);
      });
  });
productc a1 (DList_set dys) =
  (case (ceq :: Maybe (b -> b -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set2: ceq = None" (\ _ -> productc a1 (DList_set dys));
    Just _ -> foldc (\ y -> sup_set (image (\ x -> (x, y)) a1)) dys bot_set;
  });
productc (DList_set dxs) b1 =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set1: ceq = None" (\ _ -> productc (DList_set dxs) b1);
    Just _ -> foldc (\ x -> sup_set (image (\ a -> (x, a)) b1)) dxs bot_set;
  });
productc (Set_Monad xs) (Set_Monad ys) =
  Set_Monad (fold (\ x -> fold (\ y -> (\ a -> (x, y) : a)) ys) xs []);
productc a b = Collect_set (\ (x, y) -> member x a && member y b);

set_Cons ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Set a -> Set [a] -> Set [a];
set_Cons a xs =
  image (\ (aa, b) -> aa : b)
    (productc (inf_set (image (\ x -> x) a) top_set)
      (inf_set top_set (image (\ xsa -> xsa) xs)));

listset :: forall a. (Ceq a, Ccompare a, Set_impl a) => [Set a] -> Set [a];
listset [] = inserta [] (set_empty (of_phantom set_impl_list));
listset (a : asa) = set_Cons a (listset asa);

remdups :: forall a. (Eq a) => [a] -> [a];
remdups [] = [];
remdups (x : xs) = (if membera xs x then remdups xs else x : remdups xs);

l2m_lookup ::
  forall a b c. (Eq a, Eq b) => [(a, [(b, c)])] -> (a, b) -> Maybe c;
l2m_lookup [] uu = Nothing;
l2m_lookup ((a, kvs) : rec) (k1, k2) = (case k1 == a of {
 True -> map_of kvs k2;
 False -> l2m_lookup rec (k1, k2);
                                       });

lm_store_acc ::
  forall a b. (Eq a) => [(a, b)] -> (a, b) -> [(a, b)] -> [(a, b)];
lm_store_acc [] kv accu = kv : accu;
lm_store_acc ((a, uu) : rec) (k, v) accu =
  (case k == a of {
    True -> accu;
    False -> lm_store_acc rec (k, v) accu;
  });

lm_store :: forall a b. (Eq a) => [(a, b)] -> (a, b) -> [(a, b)];
lm_store m kv = lm_store_acc m kv m;

l2m_store ::
  forall a b c.
    (Eq a, Eq b) => [(a, [(b, c)])] -> ((a, b), c) -> [(a, [(b, c)])];
l2m_store [] ((k1, k2), v) = [(k1, [(k2, v)])];
l2m_store ((a, kvs) : rec) ((k1, k2), v) =
  (case k1 == a of {
    True -> (a, lm_store kvs (k2, v)) : rec;
    False -> (a, kvs) : l2m_store rec ((k1, k2), v);
  });

l2m :: forall a b c. (Eq a, Eq b) => Memory_ext [(a, [(b, c)])] (a, b) c ();
l2m = Memory_ext (\ _ -> []) l2m_lookup l2m_store ();

aux ::
  forall a b.
    (Eq a,
      Compare_order b) => (a -> Maybe b) ->
                            Rbt b [a] -> a -> Rbt b [a] -> Rbt b [a];
aux key ma v m =
  (case key v of {
    Nothing -> m;
    Just k ->
      (case lookup ma k of {
        Nothing -> m;
        Just ws ->
          (if membera ws v then (case lookup m k of {
                                  Nothing -> insert k [v] m;
                                  Just vs -> insert k (insertb v vs) m;
                                })
            else m);
      });
  });

root_rat_floor :: Nat -> Rat -> Int;
root_rat_floor p x =
  let {
    (a, b) = quotient_of x;
  } in divide_int
         (root_int_floor p (times_int a (binary_power b (minus_nat p one_nat))))
         b;

root_rat_ceiling :: Nat -> Rat -> Int;
root_rat_ceiling p x = uminus_int (root_rat_floor p (uminus_rat x));

initial_upper_bound :: Nat -> Rat -> Rat;
initial_upper_bound n r = of_int (root_rat_ceiling n r);

initial_lower_bound :: Nat -> Rat -> Rat;
initial_lower_bound n l =
  (if less_eq_rat l one_rat then l else of_int (root_rat_floor n l));

tighten_bound_root ::
  Nat -> Maybe (Root_info, (Poly Rat, (Rat, Rat))) -> (Rat, Rat) -> (Rat, Rat);
tighten_bound_root n x (l, r) =
  let {
    m = divide_rat (plus_rat l r) (of_int (Int_of_integer (2 :: Integer)));
    ma = binary_power m n;
  } in (case compare_rat_rai_intern ma x of {
         Eqa -> (m, m);
         Lt -> (m, r);
         Gt -> (l, m);
       });

poly_nth_root :: forall a. (Field a, Eq a) => Nat -> Poly a -> Poly a;
poly_nth_root n p = pcompose p (monom onea n);

root_rai_fun_pos ::
  Nat ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
      Maybe (Root_info, (Poly Rat, (Rat, Rat)));
root_rai_fun_pos n (Just (ri, (p, (l, r)))) =
  select_correct_factor_rat_poly (tighten_bound_root n (Just (ri, (p, (l, r)))))
    (\ x -> x) (initial_lower_bound n l, initial_upper_bound n r)
    (poly_nth_root n p);
root_rai_fun_pos n Nothing = Nothing;

sgn_rai_rat :: Maybe (Root_info, (Poly Rat, (Rat, Rat))) -> Rat;
sgn_rai_rat impl = (case impl of {
                     Nothing -> zero_rat;
                     Just a -> let {
                                 (_, aa) = a;
                                 (_, ab) = aa;
                                 (_, ac) = ab;
                               } in sgn_rat ac;
                   });

root_rai_fun ::
  Nat ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat))) ->
      Maybe (Root_info, (Poly Rat, (Rat, Rat)));
root_rai_fun n impl =
  (if equal_nat n zero_nat then of_rat_rai_fun zero_rat
    else (if less_eq_rat zero_rat (sgn_rai_rat impl)
           then root_rai_fun_pos n impl
           else uminus_rai_fun (root_rai_fun_pos n (uminus_rai_fun impl))));

root_rai :: Nat -> Real_alg_intern -> Real_alg_intern;
root_rai n xa = Abs_real_alg_intern (root_rai_fun n (rep_real_alg_intern xa));

root_radt :: Nat -> Real_alg_dt -> Real_alg_dt;
root_radt n x = real_alg_dt (root_rai n (rai_of_radt x));

root_radtc :: Nat -> Real_alg_dtc -> Real_alg_dtc;
root_radtc xb xc = Abs_real_alg_dtc (root_radt xb (rep_real_alg_dtc xc));

root_real_alg :: Nat -> Real_alg -> Real_alg;
root_real_alg xa (Abstr_real_alg x) = Abstr_real_alg (root_radtc xa x);

roota :: Nat -> Real -> Real;
roota n (Real_of x) = Real_of (root_real_alg n x);

sqrt :: Real -> Real;
sqrt = roota (nat_of_integer (2 :: Integer));

these :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set (Maybe a) -> Set a;
these a = image the (filtera (\ x -> not (is_none x)) a);

rev :: Pos -> Pos;
rev Empty = Empty;
rev (PCons i p) = append (rev p) (PCons i Empty);

key :: forall a b c. (a, (Term b c, Term b c)) -> Maybe (b, Nat);
key (uu, (Fun f ts, uv)) = Just (f, size_list ts);
key (uw, (Var ux, uy)) = Nothing;

gelb :: forall a. (Eq a) => (a -> a -> Bool) -> a -> Maybe a -> Bool;
gelb lt c b = (case b of {
                Nothing -> True;
                Just ba -> lt ba c || ba == c;
              });

geub :: forall a. (Eq a) => (a -> a -> Bool) -> a -> Maybe a -> Bool;
geub lt c b = (case b of {
                Nothing -> False;
                Just ba -> lt ba c || ba == c;
              });

gtlb :: forall a b. (a -> b -> Bool) -> b -> Maybe a -> Bool;
gtlb lt c b = (case b of {
                Nothing -> True;
                Just ba -> lt ba c;
              });

leub :: forall a. (Eq a) => (a -> a -> Bool) -> a -> Maybe a -> Bool;
leub lt c b = (case b of {
                Nothing -> True;
                Just ba -> lt c ba || c == ba;
              });

ltlb :: forall a b. (a -> b -> Bool) -> a -> Maybe b -> Bool;
ltlb lt c b = (case b of {
                Nothing -> False;
                Just a -> lt c a;
              });

ltub :: forall a b. (a -> b -> Bool) -> a -> Maybe b -> Bool;
ltub lt c b = (case b of {
                Nothing -> True;
                Just a -> lt c a;
              });

poly :: forall a. Ns_constraint a -> Linear_poly;
poly (LEQ_ns p a) = p;
poly (GEQ_ns p a) = p;

subt_at :: forall a b. Term a b -> Pos -> Term a b;
subt_at s Empty = s;
subt_at (Fun f ss) (PCons i p) = subt_at (nth ss i) p;

comp_fun_idem_apply :: forall b a. Comp_fun_idem b a -> b -> a -> a;
comp_fun_idem_apply (Abs_comp_fun_idem x) = x;

set_fold_cfi ::
  forall a b. (Ceq a, Ccompare a) => Comp_fun_idem a b -> b -> Set a -> b;
set_fold_cfi f b (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold_cfi RBT_set: ccompare = None"
        (\ _ -> set_fold_cfi f b (RBT_set rbt));
    Just _ -> foldb (comp_fun_idem_apply f) rbt b;
  });
set_fold_cfi f b (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold_cfi DList_set: ceq = None"
        (\ _ -> set_fold_cfi f b (DList_set dxs));
    Just _ -> foldc (comp_fun_idem_apply f) dxs b;
  });
set_fold_cfi f b (Set_Monad xs) = fold (comp_fun_idem_apply f) xs b;
set_fold_cfi f b (Collect_set p) =
  (error :: forall a. String -> (() -> a) -> a)
    "set_fold_cfi not supported on Collect_set"
    (\ _ -> set_fold_cfi f b (Collect_set p));
set_fold_cfi f b (Complement a) =
  (error :: forall a. String -> (() -> a) -> a)
    "set_fold_cfi not supported on Complement"
    (\ _ -> set_fold_cfi f b (Complement a));

sup_cfi :: forall a. (Lattice a) => Comp_fun_idem a a;
sup_cfi = Abs_comp_fun_idem sup;

sup_seta ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a,
      Set_impl a) => Set (Set a) -> Set a;
sup_seta a =
  (if finite a then set_fold_cfi sup_cfi bot_set a
    else (error :: forall a. String -> (() -> a) -> a) "Sup: infinite"
           (\ _ -> sup_seta a));

varposs :: forall a b. Term a b -> Set Pos;
varposs (Var x) = inserta Empty (set_empty (of_phantom set_impl_pos));
varposs (Fun f ts) =
  sup_seta
    (image (\ i -> image (PCons i) (varposs (nth ts i)))
      (set (upt zero_nat (size_list ts))));

vars_term ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => Term a b -> Set b;
vars_term (Var x1) = inserta x1 bot_set;
vars_term (Fun x21 x22) = sup_seta (image vars_term (set x22));

vars_rule ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Set b;
vars_rule r = sup_set (vars_term (fst r)) (vars_term (snd r));

vars_trs ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => Set (Term a b, Term a b) -> Set b;
vars_trs r = sup_seta (image vars_rule r);

xml_error ::
  forall a b c d e.
    (Showa d) => [Prelude.Char] ->
                   ([Xml], (a, (b, (c, d)))) ->
                     Sum (Xml_error [Prelude.Char]) e;
xml_error str x =
  let {
    (xmls, (_, (_, (_, pos)))) = x;
    next =
      (case xmls of {
        [] -> ['t', 'a', 'g', ' ', 'c', 'l', 'o', 's', 'e'];
        XML tag _ _ : _ -> ['<'] ++ tag ++ ['>'];
        XML_text stra : _ ->
          ['t', 'e', 'x', 't', ' ', 'e', 'l', 'e', 'm', 'e', 'n', 't', ' ',
            '\"'] ++
            stra ++ ['\"'];
      });
  } in Inl (Fatal
             (['p', 'a', 'r', 's', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o',
                'n', ' '] ++
               next ++
                 [' ', 'a', 't', ' '] ++
                   shows_prec zero_nat pos [] ++ [':', '\n'] ++ str));

mismatch ::
  forall a b c.
    (Showa b) => [Prelude.Char] ->
                   ([Xml], (a, (Bool, ([[Prelude.Char]], b)))) ->
                     Sum (Xml_error [Prelude.Char]) c;
mismatch tag x =
  (case x of {
    (_, (_, (True, (cands, _)))) -> Inl (TagMismatch (tag : cands));
    (_, (_, (False, (cands, _)))) ->
      xml_error
        (['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' '] ++
          shows_prec_list zero_nat (tag : cands) [])
        x;
  });

xml_do ::
  forall a.
    [Prelude.Char] ->
      (([Xml],
         ([([Prelude.Char], [Prelude.Char])],
           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a) ->
        (Xml, ([([Prelude.Char], [Prelude.Char])],
                (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) a;
xml_do tag p x =
  (case x of {
    (XML nam atts xmls, (_, (_, (_, pos)))) ->
      (if nam == tag then p (xmls, (atts, (False, ([], tag : pos))))
        else mismatch tag ([fst x], snd x));
    (XML_text _, _) -> mismatch tag ([fst x], snd x);
  });

xml_or ::
  forall a b c d e f g.
    ((a, (b, (Bool, (c, d)))) -> Sum (Xml_error e) f) ->
      ((a, (b, (g, ([[Prelude.Char]], d)))) -> Sum (Xml_error e) f) ->
        (a, (b, (g, (c, d)))) -> Sum (Xml_error e) f;
xml_or p1 p2 x =
  let {
    (x1, (atts, (flag, (cands, rest)))) = x;
  } in (case p1 (x1, (atts, (True, (cands, rest)))) of {
         Inl a ->
           (case a of {
             TagMismatch cands1 -> p2 (x1, (atts, (flag, (cands1, rest))));
             Fatal aa -> Inl (Fatal aa);
           });
         Inr a -> Inr a;
       });

norm_complex :: Complex -> Real;
norm_complex z =
  sqrt (plus_real (binary_power (re z) (nat_of_integer (2 :: Integer)))
         (binary_power (im z) (nat_of_integer (2 :: Integer))));

csqrt :: Complex -> Complex;
csqrt z =
  Complex
    (sqrt (divide_real (plus_real (norm_complex z) (re z))
            (of_inta (Int_of_integer (2 :: Integer)))))
    (times_real
      (if equal_real (im z) zero_real then one_real else sgn_real (im z))
      (sqrt (divide_real (minus_real (norm_complex z) (re z))
              (of_inta (Int_of_integer (2 :: Integer))))));

or_ok :: forall a. Sum a () -> Sum a () -> Sum a ();
or_ok (Inl a) b = b;
or_ok (Inr a) b = Inr a;

distinct :: forall a. (Eq a) => [a] -> Bool;
distinct [] = True;
distinct (x : xs) = not (membera xs x) && distinct xs;

add_mset :: forall a. (Eq a) => a -> Multiset a -> Multiset a;
add_mset x (Bag xs) =
  Bag (joina (\ _ (a, b) -> plus_nat a b) (updatea x one_nat emptya) xs);

mset :: forall a. (Eq a) => [a] -> Multiset a;
mset (a : x) = add_mset a (mset x);
mset [] = zero_multiset;

add ::
  forall a b. Partial_object_ext a (Monoid_ext a (Ring_ext a b)) -> a -> a -> a;
add (Partial_object_ext carrier (Monoid_ext mult one (Ring_ext zero add more)))
  = add;

shows_nl :: [Prelude.Char] -> [Prelude.Char];
shows_nl = shows_prec_char zero_nat '\n';

lvars :: [(Nat, Linear_poly)] -> Set Nat;
lvars t = set (map lhs t);

linear_poly_map :: Linear_poly -> Fmap Nat Rat;
linear_poly_map (LinearPoly x) = x;

fmmap :: forall a b c. (a -> b) -> Fmap c a -> Fmap c b;
fmmap f (Fmap_of_list m) = Fmap_of_list (map (apsnd f) m);

fmempty :: forall a b. Fmap a b;
fmempty = Fmap_of_list [];

scale :: Rat -> Fmap Nat Rat -> Fmap Nat Rat;
scale r lp = (if equal_rat r zero_rat then fmempty else fmmap (times_rat r) lp);

scaleRat_linear_poly :: Rat -> Linear_poly -> Linear_poly;
scaleRat_linear_poly r p = LinearPoly (scale r (linear_poly_map p));

uminus_linear_poly :: Linear_poly -> Linear_poly;
uminus_linear_poly lp = scaleRat_linear_poly (uminus_rat one_rat) lp;

fmlookup :: forall a b. (Eq a) => Fmap a b -> a -> Maybe b;
fmlookup (Fmap_of_list m) = map_of m;

get_var_coeff :: Fmap Nat Rat -> Nat -> Rat;
get_var_coeff lp v = (case fmlookup lp v of {
                       Nothing -> zero_rat;
                       Just c -> c;
                     });

sorted_list_of_set ::
  forall a. (Ceq a, Ccompare a, Eq a, Linorder a) => Set a -> [a];
sorted_list_of_set (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "sorted_list_of_set RBT_set: ccompare = None"
        (\ _ -> sorted_list_of_set (RBT_set rbt));
    Just _ -> sort_key (\ x -> x) (keysa rbt);
  });
sorted_list_of_set (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "sorted_list_of_set DList_set: ceq = None"
        (\ _ -> sorted_list_of_set (DList_set dxs));
    Just _ -> sort_key (\ x -> x) (list_of_dlist dxs);
  });
sorted_list_of_set (Set_Monad xs) = sort_key (\ x -> x) (remdups xs);

fset_of_list :: forall a. (Ceq a, Ccompare a, Set_impl a) => [a] -> Fset a;
fset_of_list xa = Abs_fset (set xa);

fmdom ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Fmap a b -> Fset a;
fmdom (Fmap_of_list m) = fimage fst (fset_of_list m);

ordered_keys ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Linorder a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Fmap a b -> [a];
ordered_keys m = sorted_list_of_set (fset (fmdom m));

fmfilter :: forall a b. (a -> Bool) -> Fmap a b -> Fmap a b;
fmfilter p (Fmap_of_list m) = Fmap_of_list (filter (\ (k, _) -> p k) m);

fmdrop :: forall a b. (Eq a) => a -> Fmap a b -> Fmap a b;
fmdrop a = fmfilter (\ aa -> not (aa == a));

fmadd :: forall a b. (Eq a) => Fmap a b -> Fmap a b -> Fmap a b;
fmadd (Fmap_of_list m) (Fmap_of_list n) = Fmap_of_list (merge m n);

fmupd :: forall a b. (Eq a) => a -> b -> Fmap a b -> Fmap a b;
fmupd k v m = fmadd m (Fmap_of_list [(k, v)]);

set_var_coeff :: Nat -> Rat -> Fmap Nat Rat -> Fmap Nat Rat;
set_var_coeff v c lp =
  (if equal_rat c zero_rat then fmdrop v lp else fmupd v c lp);

add_monom :: Rat -> Nat -> Fmap Nat Rat -> Fmap Nat Rat;
add_monom c v lp = set_var_coeff v (plus_rat c (get_var_coeff lp v)) lp;

adda :: Fmap Nat Rat -> Fmap Nat Rat -> Fmap Nat Rat;
adda lp1 lp2 =
  foldl (\ lp v -> add_monom (get_var_coeff lp1 v) v lp) lp2 (ordered_keys lp1);

plus_linear_poly :: Linear_poly -> Linear_poly -> Linear_poly;
plus_linear_poly p1 p2 =
  LinearPoly (adda (linear_poly_map p1) (linear_poly_map p2));

minus_linear_poly :: Linear_poly -> Linear_poly -> Linear_poly;
minus_linear_poly lp1 lp2 = plus_linear_poly lp1 (uminus_linear_poly lp2);

constraint_to_qdelta_constraint :: Constraint -> [Ns_constraint QDelta];
constraint_to_qdelta_constraint (LTa l r) =
  [LEQ_ns l (QDelta r (uminus_rat one_rat))];
constraint_to_qdelta_constraint (GTa l r) = [GEQ_ns l (QDelta r one_rat)];
constraint_to_qdelta_constraint (LEQ l r) = [LEQ_ns l (QDelta r zero_rat)];
constraint_to_qdelta_constraint (GEQ l r) = [GEQ_ns l (QDelta r zero_rat)];
constraint_to_qdelta_constraint (EQa l r) =
  [LEQ_ns l (QDelta r zero_rat), GEQ_ns l (QDelta r zero_rat)];
constraint_to_qdelta_constraint (LTPP l1 l2) =
  [LEQ_ns (minus_linear_poly l1 l2) (QDelta zero_rat (uminus_rat one_rat))];
constraint_to_qdelta_constraint (GTPP l1 l2) =
  [GEQ_ns (minus_linear_poly l1 l2) (QDelta zero_rat one_rat)];
constraint_to_qdelta_constraint (LEQPP l1 l2) =
  [LEQ_ns (minus_linear_poly l1 l2) zero_QDelta];
constraint_to_qdelta_constraint (GEQPP l1 l2) =
  [GEQ_ns (minus_linear_poly l1 l2) zero_QDelta];
constraint_to_qdelta_constraint (EQPP l1 l2) =
  [LEQ_ns (minus_linear_poly l1 l2) zero_QDelta,
    GEQ_ns (minus_linear_poly l1 l2) zero_QDelta];

to_ns :: [Constraint] -> [Ns_constraint QDelta];
to_ns l = concatMap constraint_to_qdelta_constraint l;

hole_pos :: forall a b. Ctxt a b -> Pos;
hole_pos Hole = Empty;
hole_pos (More f ss d ts) = PCons (size_list ss) (hole_pos d);

mk_subst ::
  forall a b c. (Eq a) => (a -> Term b c) -> [(a, Term b c)] -> a -> Term b c;
mk_subst d xts = (\ x -> (case map_of xts x of {
                           Nothing -> d x;
                           Just t -> t;
                         }));

funas_term ::
  forall a b. (Ceq a, Ccompare a, Set_impl a) => Term a b -> Set (a, Nat);
funas_term (Var uu) = bot_set;
funas_term (Fun f ts) =
  sup_set (inserta (f, size_list ts) bot_set)
    (foldr (sup_set . funas_term) ts bot_set);

funas_rule ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a) => (Term a b, Term a b) -> Set (a, Nat);
funas_rule r = sup_set (funas_term (fst r)) (funas_term (snd r));

funas_trs ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Set (Term a b, Term a b) -> Set (a, Nat);
funas_trs r = sup_seta (image funas_rule r);

unapp :: forall a b. (Eq a) => a -> Term a b -> (Term a b, [Term a b]);
unapp a (Var x) = (Var x, []);
unapp a (Fun f ss) =
  (if f == a && equal_nat (size_list ss) (nat_of_integer (2 :: Integer))
    then let {
           (r, ts) = unapp a (nth ss zero_nat);
         } in (r, ts ++ [nth ss one_nat])
    else (Fun f ss, []));

is_letter :: Prelude.Char -> Bool;
is_letter c =
  'a' <= c && c <= 'z' ||
    ('A' <= c && c <= 'Z' ||
      ('0' <= c && c <= '9' || membera ['_', '&', ';', ':', '-'] c));

update_tokens :: forall a. ([a] -> [a]) -> [a] -> Sum [Prelude.Char] ([a], [a]);
update_tokens f ts = Inr (ts, f ts);

remove_comments_aux_acc ::
  [Prelude.Char] -> Bool -> [Prelude.Char] -> [Prelude.Char];
remove_comments_aux_acc a False (c : cs) =
  (if c == '<' && take (nat_of_integer (3 :: Integer)) cs == ['!', '-', '-']
    then remove_comments_aux_acc a True (tla cs)
    else remove_comments_aux_acc (c : a) False cs);
remove_comments_aux_acc a True (c : cs) =
  (if c == '-' && take (nat_of_integer (2 :: Integer)) cs == ['-', '>']
    then remove_comments_aux_acc a False
           (drop (nat_of_integer (2 :: Integer)) cs)
    else remove_comments_aux_acc a True cs);
remove_comments_aux_acc a uu [] = a;

remove_comments_aux :: Bool -> [Prelude.Char] -> [Prelude.Char];
remove_comments_aux False (c : cs) =
  (if c == '<' && take (nat_of_integer (3 :: Integer)) cs == ['!', '-', '-']
    then remove_comments_aux True (tla cs)
    else c : remove_comments_aux False cs);
remove_comments_aux True (c : cs) =
  (if c == '-' && take (nat_of_integer (2 :: Integer)) cs == ['-', '>']
    then remove_comments_aux False (drop (nat_of_integer (2 :: Integer)) cs)
    else remove_comments_aux True cs);
remove_comments_aux uu [] = [];

remove_comments :: [Prelude.Char] -> [Prelude.Char];
remove_comments =
  (if False then reverse . remove_comments_aux_acc [] False
    else remove_comments_aux False);

returnb :: forall a b. a -> [b] -> Sum [Prelude.Char] (a, [b]);
returnb x = (\ ts -> Inr (x, ts));

bindb :: forall a b c. Sum a b -> (b -> Sum a c) -> Sum a c;
bindb m f = (case m of {
              Inl a -> Inl a;
              Inr a -> f a;
            });

bindc ::
  forall a b c.
    ([a] -> Sum [Prelude.Char] (b, [a])) ->
      (b -> [a] -> Sum [Prelude.Char] (c, [a])) ->
        [a] -> Sum [Prelude.Char] (c, [a]);
bindc m f ts = bindb (m ts) (\ (a, b) -> f a b);

shows_quote ::
  ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_quote s =
  (shows_prec_char zero_nat '\'' . s) . shows_prec_char zero_nat '\'';

scan_upto ::
  [Prelude.Char] ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
scan_upto end (t : ts) =
  (if map snd (zip end (t : ts)) == end
    then Inr (end, drop (size_list end) (t : ts))
    else bindb (scan_upto end ts) (\ (res, tsa) -> Inr (t : res, tsa)));
scan_upto end [] =
  Inl (['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 'e',
         'n', 'd', '-', 'm', 'a', 'r', 'k', 'e', 'r', ' '] ++
        shows_quote (shows_prec_list zero_nat end) []);

trim :: [Prelude.Char] -> [Prelude.Char];
trim = dropWhile (membera [' ', '\n', '\t', '\r']);

manya ::
  (Prelude.Char -> Bool) ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
manya p (t : ts) =
  (if p t then bindb (manya p ts) (\ (rs, tsa) -> Inr (t : rs, tsa))
    else Inr ([], t : ts));
manya p [] = Inr ([], []);

parse_header ::
  [Prelude.Char] -> Sum [Prelude.Char] ([[Prelude.Char]], [Prelude.Char]);
parse_header ts =
  (if take (nat_of_integer (2 :: Integer)) (trim ts) == ['<', '?']
    then bindc (scan_upto ['?', '>'])
           (\ h -> bindc parse_header (\ hs -> returnb (h : hs))) ts
    else bindc (bindc (manya (membera [' ', '\n', '\t', '\r']))
                 (\ _ -> returnb ()))
           (\ _ -> returnb []) ts);

err_expecting ::
  forall a b. (Showa a) => [Prelude.Char] -> [a] -> Sum [Prelude.Char] (b, [a]);
err_expecting msg ts =
  Inl (['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' '] ++
        msg ++
          [',', ' ', 'b', 'u', 't', ' ', 'f', 'o', 'u', 'n', 'd', ':', ' '] ++
            shows_quote
              (shows_prec_list zero_nat
                (take (nat_of_integer (30 :: Integer)) ts))
              []);

eoi :: forall a. (Showa a) => [a] -> Sum [Prelude.Char] ((), [a]);
eoi [] = Inr ((), []);
eoi (v : va) =
  err_expecting ['e', 'n', 'd', ' ', 'o', 'f', ' ', 'i', 'n', 'p', 'u', 't']
    (v : va);

exactly_aux ::
  [Prelude.Char] ->
    [Prelude.Char] ->
      [Prelude.Char] ->
        [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
exactly_aux s i (x : xs) (y : ys) =
  (if x == y then exactly_aux s i xs ys
    else err_expecting (['\"'] ++ s ++ ['\"']) i);
exactly_aux s i [] xs = Inr (s, trim xs);
exactly_aux s i (x : xs) [] = err_expecting (['\"'] ++ s ++ ['\"']) i;

exactly ::
  [Prelude.Char] ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
exactly s x = exactly_aux s x s x;

parse_attribute_value ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
parse_attribute_value =
  bindc (exactly ['\"'])
    (\ _ ->
      bindc (manya (\ y -> not ('\"' == y)))
        (\ v -> bindc (exactly ['\"']) (\ _ -> returnb v)));

errorb :: forall a b. [Prelude.Char] -> [a] -> Sum [Prelude.Char] (b, [a]);
errorb e = (\ _ -> Inl e);

parse_name ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
parse_name s =
  bindc (manya is_letter)
    (\ n ->
      bindc (bindc (manya (membera [' ', '\n', '\t', '\r']))
              (\ _ -> returnb ()))
        (\ _ ->
          (if null n
            then errorb
                   (['e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'l', 'e', 't',
                      't', 'e', 'r', ' '] ++
                     letters ++
                       [' ', 'b', 'u', 't', ' ', 'f', 'i', 'r', 's', 't', ' ',
                         's', 'y', 'm', 'b', 'o', 'l', ' ', 'i', 's', ' ',
                         '\"'] ++
                         take one_nat s ++ ['\"'])
            else returnb n)))
    s;

parse_attributes ::
  [Prelude.Char] ->
    Sum [Prelude.Char] ([([Prelude.Char], [Prelude.Char])], [Prelude.Char]);
parse_attributes [] = Inr ([], []);
parse_attributes (c : s) =
  (if membera ['/', '>'] c then Inr ([], c : s)
    else bindc parse_name
           (\ k ->
             bindc (exactly ['='])
               (\ _ ->
                 bindc parse_attribute_value
                   (\ v ->
                     bindc parse_attributes
                       (\ atts -> returnb ((k, v) : atts)))))
           (c : s));

oneof_closed ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
oneof_closed (x : xs) =
  (if x == '>' then Inr (['>'], trim xs)
    else (if x == '/' && (case xs of {
                           [] -> False;
                           y : _ -> y == '>';
                         })
           then Inr (['/', '>'], trim (tla xs))
           else err_expecting
                  ['o', 'n', 'e', ' ', 'o', 'f', ' ', '[', '/', '>', ',', ' ',
                    '>', ']']
                  (x : xs)));
oneof_closed [] =
  err_expecting
    ['o', 'n', 'e', ' ', 'o', 'f', ' ', '[', '/', '>', ',', ' ', '>', ']'] [];

parse_text ::
  [Prelude.Char] -> Sum [Prelude.Char] (Maybe [Prelude.Char], [Prelude.Char]);
parse_text =
  bindc (manya (\ y -> not ('<' == y)))
    (\ ts ->
      let {
        text = trim ts;
      } in (if null text then returnb Nothing
             else returnb (Just (reverse (trim (reverse text))))));

parse_nodes :: [Prelude.Char] -> Sum [Prelude.Char] ([Xml], [Prelude.Char]);
parse_nodes ts =
  (if null ts || take (nat_of_integer (2 :: Integer)) ts == ['<', '/']
    then returnb [] ts
    else (if not (hda ts == '<')
           then bindc parse_text
                  (\ t ->
                    bindc parse_nodes (\ ns -> returnb (XML_text (the t) : ns)))
                  ts
           else bindc (exactly ['<'])
                  (\ _ ->
                    bindc parse_name
                      (\ n ->
                        bindc parse_attributes
                          (\ atts ->
                            bindc oneof_closed
                              (\ e ->
                                (if e == ['/', '>']
                                  then bindc parse_nodes
 (\ cs -> returnb (XML n atts [] : cs))
                                  else bindc parse_nodes
 (\ cs ->
   bindc (exactly ['<', '/'])
     (\ _ ->
       bindc (exactly n)
         (\ _ ->
           bindc (exactly ['>'])
             (\ _ ->
               bindc parse_nodes (\ ns -> returnb (XML n atts cs : ns)))))))))))
                  ts));

parse_node :: [Prelude.Char] -> Sum [Prelude.Char] (Xml, [Prelude.Char]);
parse_node =
  bindc (exactly ['<'])
    (\ _ ->
      bindc parse_name
        (\ n ->
          bindc parse_attributes
            (\ atts ->
              bindc oneof_closed
                (\ e ->
                  (if e == ['/', '>'] then returnb (XML n atts [])
                    else bindc parse_nodes
                           (\ cs ->
                             bindc (exactly ['<', '/'])
                               (\ _ ->
                                 bindc (exactly n)
                                   (\ _ ->
                                     bindc (exactly ['>'])
                                       (\ _ -> returnb (XML n atts cs))))))))));

parse_doc :: [Prelude.Char] -> Sum [Prelude.Char] (Xmldoc, [Prelude.Char]);
parse_doc =
  bindc (update_tokens remove_comments)
    (\ _ ->
      bindc parse_header
        (\ h ->
          bindc parse_node
            (\ xml -> bindc eoi (\ _ -> returnb (XMLDOC h xml)))));

pick_up ::
  forall a b. (Eq a) => [(a, b)] -> a -> [(a, b)] -> Maybe (b, [(a, b)]);
pick_up rest key [] = Nothing;
pick_up rest key ((l, r) : s) =
  (if key == l then Just (r, rest ++ s) else pick_up ((l, r) : rest) key s);

nat_of_digit :: Prelude.Char -> Maybe Nat;
nat_of_digit x =
  (if x == '0' then Just zero_nat
    else (if x == '1' then Just one_nat
           else (if x == '2' then Just (nat_of_integer (2 :: Integer))
                  else (if x == '3' then Just (nat_of_integer (3 :: Integer))
                         else (if x == '4'
                                then Just (nat_of_integer (4 :: Integer))
                                else (if x == '5'
                                       then Just (nat_of_integer (5 :: Integer))
                                       else (if x == '6'
      then Just (nat_of_integer (6 :: Integer))
      else (if x == '7' then Just (nat_of_integer (7 :: Integer))
             else (if x == '8' then Just (nat_of_integer (8 :: Integer))
                    else (if x == '9' then Just (nat_of_integer (9 :: Integer))
                           else Nothing))))))))));

nat_of_string_aux :: Nat -> [Prelude.Char] -> Maybe Nat;
nat_of_string_aux n [] = Just n;
nat_of_string_aux n (d : s) =
  bind (nat_of_digit d)
    (\ m ->
      nat_of_string_aux
        (plus_nat (times_nat (nat_of_integer (10 :: Integer)) n) m) s);

nat_of_string :: [Prelude.Char] -> Sum [Prelude.Char] Nat;
nat_of_string s =
  (case (if null s then Nothing else nat_of_string_aux zero_nat s) of {
    Nothing ->
      Inl (['c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'o', 'n', 'v', 'e', 'r',
             't', ' ', '\"'] ++
            s ++ ['\"', ' ', 't', 'o', ' ', 'a', ' ', 'n', 'u', 'm', 'b', 'e',
                   'r']);
    Just a -> Inr a;
  });

safe_head :: forall a. [a] -> Maybe a;
safe_head [] = Nothing;
safe_head (x : xs) = Just x;

int_of_stringa :: [Prelude.Char] -> Sum [Prelude.Char] Int;
int_of_stringa s =
  (if safe_head s == Just '-'
    then bindb (nat_of_string (tla s)) (\ n -> Inr (uminus_int (int_of_nat n)))
    else bindb (nat_of_string s) (\ n -> Inr (int_of_nat n)));

xml_take_int ::
  forall a.
    (Int ->
      ([Xml],
        ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a) ->
      ([Xml],
        ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a;
xml_take_int p xs =
  (case xs of {
    ([], _) ->
      xml_error
        ['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' ', 'a', 'n', ' ', 'i',
          'n', 't', 'e', 'g', 'e', 'r']
        xs;
    (XML _ _ _ : _, _) ->
      xml_error
        ['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' ', 'a', 'n', ' ', 'i',
          'n', 't', 'e', 'g', 'e', 'r']
        xs;
    (XML_text text : xmls, s) -> (case int_of_stringa text of {
                                   Inl x -> xml_error x xs;
                                   Inr n -> p n (xmls, s);
                                 });
  });

xml_return ::
  forall a.
    a -> ([Xml],
           ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
           Sum (Xml_error [Prelude.Char]) a;
xml_return v x =
  (case x of {
    ([], _) -> Inr v;
    (_ : _, _) ->
      xml_error
        ['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' ', 't', 'a', 'g', ' ',
          'c', 'l', 'o', 's', 'e']
        x;
  });

xml_int ::
  [Prelude.Char] ->
    (Xml, ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) Int;
xml_int tag = xml_do tag (xml_take_int xml_return);

xml_take_nat ::
  forall a.
    (Nat ->
      ([Xml],
        ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a) ->
      ([Xml],
        ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a;
xml_take_nat p xs =
  (case xs of {
    ([], _) ->
      xml_error
        ['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' ', 'a', ' ', 'n', 'u',
          'm', 'b', 'e', 'r']
        xs;
    (XML _ _ _ : _, _) ->
      xml_error
        ['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' ', 'a', ' ', 'n', 'u',
          'm', 'b', 'e', 'r']
        xs;
    (XML_text text : xmls, s) -> (case nat_of_string text of {
                                   Inl x -> xml_error x xs;
                                   Inr n -> p n (xmls, s);
                                 });
  });

xml_nat ::
  [Prelude.Char] ->
    (Xml, ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) Nat;
xml_nat tag = xml_do tag (xml_take_nat xml_return);

zero_enat :: Enat;
zero_enat = Enat zero_nat;

minus_enat :: Enat -> Enat -> Enat;
minus_enat (Enat a) Infinity_enat = zero_enat;
minus_enat Infinity_enat n = Infinity_enat;
minus_enat (Enat a) (Enat b) = Enat (minus_nat a b);

equal_enat :: Enat -> Enat -> Bool;
equal_enat (Enat nat) Infinity_enat = False;
equal_enat Infinity_enat (Enat nat) = False;
equal_enat (Enat nata) (Enat nat) = equal_nat nata nat;
equal_enat Infinity_enat Infinity_enat = True;

one_enat :: Enat;
one_enat = Enat one_nat;

xml_take_many_sub ::
  forall a b.
    [a] ->
      Nat ->
        Enat ->
          ((Xml, ([([Prelude.Char], [Prelude.Char])],
                   (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
            Sum (Xml_error [Prelude.Char]) a) ->
            ([a] ->
              ([Xml],
                ([([Prelude.Char], [Prelude.Char])],
                  (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                Sum (Xml_error [Prelude.Char]) b) ->
              ([Xml],
                ([([Prelude.Char], [Prelude.Char])],
                  (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                Sum (Xml_error [Prelude.Char]) b;
xml_take_many_sub acc minOccurs maxOccurs p1 p2 ([], (atts, (allow, rest))) =
  (if equal_nat minOccurs zero_nat
    then p2 (reverse acc) ([], (atts, (allow, rest)))
    else (case p1 (XML [] [] [], (atts, (False, rest))) of {
           Inl a -> Inl a;
           Inr _ ->
             Inl (Fatal ['u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd']);
         }));
xml_take_many_sub acc minOccurs maxOccurs p1 p2
  (xml : xmls, (atts, (allow, (cands, rest)))) =
  (if equal_enat maxOccurs zero_enat
    then p2 (reverse acc) (xml : xmls, (atts, (allow, (cands, rest))))
    else (case p1 (xml, (atts, (equal_nat minOccurs zero_nat, (cands, rest))))
           of {
           Inl (TagMismatch _) ->
             p2 (reverse acc) (xml : xmls, (atts, (allow, (cands, rest))));
           Inl (Fatal aa) -> Inl (Fatal aa);
           Inr a ->
             xml_take_many_sub (a : acc) (minus_nat minOccurs one_nat)
               (minus_enat maxOccurs one_enat) p1 p2
               (xmls, (atts, (False, ([], rest))));
         }));

position ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) Nat;
position =
  xml_do ['p', 'o', 's', 'i', 't', 'i', 'o', 'n']
    (xml_take_nat (\ n -> xml_return (minus_nat n one_nat)));

xml_change ::
  forall a b.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      (a -> ([Xml],
              ([([Prelude.Char], [Prelude.Char])],
                (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
              Sum (Xml_error [Prelude.Char]) b) ->
        (Xml, ([([Prelude.Char], [Prelude.Char])],
                (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) b;
xml_change p f x = (case p x of {
                     Inl a -> Inl a;
                     Inr a -> let {
                                (_, rest) = x;
                              } in f a ([], rest);
                   });

xml_take ::
  forall a b.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      (a -> ([Xml],
              ([([Prelude.Char], [Prelude.Char])],
                (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
              Sum (Xml_error [Prelude.Char]) b) ->
        ([Xml],
          ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) b;
xml_take p1 p2 x =
  (case x of {
    ([], rest) ->
      (case p1 (XML [] [] [], rest) of {
        Inl a -> Inl a;
        Inr _ -> Inl (Fatal ['u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd']);
      });
    (xa : xs, rest) -> let {
                         (atts, (flag, (cands, resta))) = rest;
                       } in (case p1 (xa, (atts, (flag, (cands, resta)))) of {
                              Inl a -> Inl a;
                              Inr a -> p2 a (xs, (atts, (False, ([], resta))));
                            });
  });

afs ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) [((a, Nat), Af_entry)];
afs xml2name =
  xml_do ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r',
          'E', 'n', 't', 'r', 'y']
        (xml_take xml2name
          (\ name ->
            xml_take (xml_nat ['a', 'r', 'i', 't', 'y'])
              (\ arity ->
                xml_take
                  (xml_or
                    (xml_change
                      (xml_nat
                        ['c', 'o', 'l', 'l', 'a', 'p', 's', 'i', 'n', 'g'])
                      (\ n -> xml_return (Collapse (minus_nat n one_nat))))
                    (xml_do
                      ['n', 'o', 'n', 'C', 'o', 'l', 'l', 'a', 'p', 's', 'i',
                        'n', 'g']
                      (xml_take_many_sub [] zero_nat Infinity_enat position
                        (\ ls -> xml_return (AFList ls)))))
                  (\ main -> xml_return ((name, arity), main))))))
      xml_return);

scg_position ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) Nat;
scg_position = xml_nat ['p', 'o', 's', 'i', 't', 'i', 'o', 'n'];

xml_take_default ::
  forall a b.
    a -> ((Xml, ([([Prelude.Char], [Prelude.Char])],
                  (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
           Sum (Xml_error [Prelude.Char]) a) ->
           (a -> ([Xml],
                   ([([Prelude.Char], [Prelude.Char])],
                     (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) b) ->
             ([Xml],
               ([([Prelude.Char], [Prelude.Char])],
                 (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
               Sum (Xml_error [Prelude.Char]) b;
xml_take_default a p1 p2 xs =
  (case xs of {
    ([], _) -> p2 a xs;
    (xml : xmls, (atts, (allow, (cands, rest)))) ->
      (case p1 (xml, (atts, (True, (cands, rest)))) of {
        Inl (TagMismatch cands1) ->
          p2 a (xml : xmls, (atts, (allow, (cands1, rest))));
        Inl (Fatal aa) -> Inl (Fatal aa);
        Inr aa -> p2 aa (xmls, (atts, (False, ([], rest))));
      });
  });

xml_take_text ::
  forall a.
    ([Prelude.Char] ->
      ([Xml],
        ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a) ->
      ([Xml],
        ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a;
xml_take_text p xs =
  (case xs of {
    ([], _) ->
      xml_error
        ['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' ', 'a', ' ', 't', 'e',
          'x', 't']
        xs;
    (XML _ _ _ : _, _) ->
      xml_error
        ['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' ', 'a', ' ', 't', 'e',
          'x', 't']
        xs;
    (XML_text text : xmls, s) -> p text (xmls, s);
  });

xml_text ::
  [Prelude.Char] ->
    (Xml, ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) [Prelude.Char];
xml_text tag = xml_do tag (xml_take_text xml_return);

plain_var ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) [Prelude.Char];
plain_var = xml_text ['v', 'a', 'r'];

var ::
  forall a.
    (Xml, ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) (Term a [Prelude.Char]);
var = xml_change plain_var (xml_return . Var);

term ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Term a [Prelude.Char]);
term xml2name x =
  xml_or var
    (xml_do ['f', 'u', 'n', 'a', 'p', 'p']
      (xml_take xml2name
        (\ name ->
          xml_take_many_sub [] zero_nat Infinity_enat
            (xml_or (term xml2name)
              (xml_do ['a', 'r', 'g'] (xml_take (term xml2name) xml_return)))
            (\ args -> xml_return (Fun name args)))))
    x;

conditions ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   [Prelude.Char] ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char])
                         [(Term a [Prelude.Char], Term a [Prelude.Char])];
conditions xml2name tag =
  xml_do tag
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n']
        (xml_take (xml_do ['l', 'h', 's'] (xml_take (term xml2name) xml_return))
          (\ l ->
            xml_take
              (xml_do ['r', 'h', 's'] (xml_take (term xml2name) xml_return))
              (\ r -> xml_return (l, r)))))
      xml_return);

crule ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   [Prelude.Char] ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char])
                         ((Term a [Prelude.Char], Term a [Prelude.Char]),
                           [(Term a [Prelude.Char], Term a [Prelude.Char])]);
crule xml2name tag =
  xml_do tag
    (xml_take (xml_do ['l', 'h', 's'] (xml_take (term xml2name) xml_return))
      (\ l ->
        xml_take (xml_do ['r', 'h', 's'] (xml_take (term xml2name) xml_return))
          (\ r ->
            xml_take_default []
              (conditions xml2name
                ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's'])
              (\ conds -> xml_return ((l, r), conds)))));

rule ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Term a [Prelude.Char], Term a [Prelude.Char]);
rule xml2name =
  xml_change (crule xml2name ['r', 'u', 'l', 'e'])
    (\ (lr, conds) ->
      (if null conds then xml_return lr
        else xml_error
               ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'r',
                 'u', 'l', 'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'h', 'e', 'r', 'e']));

bool_of_string :: [Prelude.Char] -> Sum [Prelude.Char] Bool;
bool_of_string s =
  (if s == ['t', 'r', 'u', 'e'] then Inr True
    else (if s == ['f', 'a', 'l', 's', 'e'] then Inr False
           else Inl (['c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'o', 'n', 'v',
                       'e', 'r', 't', ' ', '\"'] ++
                      s ++ ['\"', ' ', 'i', 'n', 't', 'o', ' ', 'B', 'o', 'o',
                             'l', 'e', 'a', 'n'])));

xml_bool ::
  [Prelude.Char] ->
    (Xml, ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) Bool;
xml_bool tag x = (case xml_text tag x of {
                   Inl a -> Inl a;
                   Inr str -> (case bool_of_string str of {
                                Inl err -> xml_error err ([fst x], snd x);
                                Inr a -> Inr a;
                              });
                 });

scg ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       ((Term a [Prelude.Char], Term a [Prelude.Char]),
                         ([(Nat, Nat)], [(Nat, Nat)]));
scg xml2name =
  xml_do
    ['s', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'G', 'r', 'a', 'p', 'h']
    (xml_take (rule xml2name)
      (\ lr ->
        xml_take_many_sub [] zero_nat Infinity_enat
          (xml_do ['e', 'd', 'g', 'e']
            (xml_take scg_position
              (\ p ->
                xml_take (xml_bool ['s', 't', 'r', 'i', 'c', 't'])
                  (\ s ->
                    xml_take scg_position (\ q -> xml_return (s, (p, q)))))))
          (\ edges ->
            xml_return
              (lr, (map_filter
                      (\ x -> (if fst x then Just (snd x) else Nothing)) edges,
                     map_filter
                       (\ x -> (if not (fst x) then Just (snd x) else Nothing))
                       edges)))));

gt1 ::
  forall a b c d. [(Term a b, Term c d)] -> [(Maybe (a, Nat), Maybe (c, Nat))];
gt1 = map (\ (s, t) -> (root s, root t));

map_term :: forall a b c d. (a -> b) -> (c -> d) -> Term a c -> Term b d;
map_term f1 f2 (Var x1) = Var (f2 x1);
map_term f1 f2 (Fun x21 x22) = Fun (f1 x21) (map (map_term f1 f2) x22);

class_to_term_intern ::
  forall a b. (Nat -> a) -> Nat -> Term b (Sum () a) -> (Nat, Term b a);
class_to_term_intern iv i (Fun f ts) =
  let {
    (k, ss) =
      foldr (\ t (j, ss) -> let {
                              (k, s) = class_to_term_intern iv j t;
                            } in (k, s : ss))
        ts (i, []);
  } in (k, Fun f ss);
class_to_term_intern iv i (Var (Inl uu)) = (plus_nat i one_nat, Var (iv i));
class_to_term_intern iv i (Var (Inr x)) = (i, Var x);

class_to_term ::
  forall a.
    Prelude.Char -> Term a (Sum () [Prelude.Char]) -> Term a [Prelude.Char];
class_to_term c t =
  snd (class_to_term_intern (\ i -> c : shows_prec_nat zero_nat i []) zero_nat
        t);

subst_apply_term :: forall a b c. Term a b -> (b -> Term a c) -> Term a c;
subst_apply_term (Var x) sigma = sigma x;
subst_apply_term (Fun f ss) sigma =
  Fun f (map (\ t -> subst_apply_term t sigma) ss);

subst_compose ::
  forall a b c d. (a -> Term b c) -> (c -> Term b d) -> a -> Term b d;
subst_compose sigma tau = (\ x -> subst_apply_term (sigma x) tau);

subst_of :: forall a b. (Eq a) => [(a, Term b a)] -> a -> Term b a;
subst_of ss = foldr (\ (x, t) sigma -> subst_compose sigma (subst x t)) ss Var;

contains_var_term :: forall a b. (Eq a) => a -> Term b a -> Bool;
contains_var_term x (Var y) = x == y;
contains_var_term x (Fun uu ts) = any (contains_var_term x) ts;

subst_list ::
  forall a b.
    (a -> Term b a) -> [(Term b a, Term b a)] -> [(Term b a, Term b a)];
subst_list sigma ys =
  map (\ p -> (subst_apply_term (fst p) sigma, subst_apply_term (snd p) sigma))
    ys;

decompose ::
  forall a b c. (Eq a) => Term a b -> Term a c -> Maybe [(Term a b, Term a c)];
decompose s t =
  (case (s, t) of {
    (Var _, _) -> Nothing;
    (Fun _ _, Var _) -> Nothing;
    (Fun f ss, Fun g ts) -> (if f == g then zip_option ss ts else Nothing);
  });

unify ::
  forall a b.
    (Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(b, Term a b)] -> Maybe [(b, Term a b)];
unify [] bs = Just bs;
unify ((Fun f ss, Fun g ts) : e) bs =
  (case decompose (Fun f ss) (Fun g ts) of {
    Nothing -> Nothing;
    Just us -> unify (us ++ e) bs;
  });
unify ((Var x, t) : e) bs =
  (if equal_term t (Var x) then unify e bs
    else (if contains_var_term x t then Nothing
           else unify (subst_list (subst x t) e) ((x, t) : bs)));
unify ((Fun v va, Var x) : e) bs =
  (if contains_var_term x (Fun v va) then Nothing
    else unify (subst_list (subst x (Fun v va)) e) ((x, Fun v va) : bs));

mgu ::
  forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Maybe (b -> Term a b);
mgu s t = (case unify [(s, t)] [] of {
            Nothing -> Nothing;
            Just res -> Just (subst_of res);
          });

mgu_class ::
  forall a.
    (Eq a) => Term a (Sum () [Prelude.Char]) ->
                Term a [Prelude.Char] ->
                  Maybe ([Prelude.Char] -> Term a [Prelude.Char]);
mgu_class cs t =
  mgu (class_to_term 'z' cs) (map_term (\ x -> x) (\ a -> 'y' : a) t);

removeAll :: forall a. (Eq a) => a -> [a] -> [a];
removeAll x [] = [];
removeAll x (y : xs) = (if x == y then removeAll x xs else y : removeAll x xs);

span :: forall a. (a -> Bool) -> [a] -> ([a], [a]);
span p (x : xs) = (if p x then let {
                                 a = span p xs;
                                 (ys, aa) = a;
                               } in (x : ys, aa)
                    else ([], x : xs));
span uu [] = ([], []);

match_term_list_code ::
  forall a b c.
    (Eq a, Ccompare b, Eq b,
      Eq c) => [(Term a b, Term a c)] ->
                 Mapping b (Term a c) -> Maybe (Mapping b (Term a c));
match_term_list_code ((Fun f ss, Var x) : p) sigma = Nothing;
match_term_list_code ((Fun f ss, Fun g ts) : p) sigma =
  (case decompose (Fun f ss) (Fun g ts) of {
    Nothing -> Nothing;
    Just us -> match_term_list_code (us ++ p) sigma;
  });
match_term_list_code ((Var x, t) : p) sigma =
  (if is_none (lookupb sigma x) || lookupb sigma x == Just t
    then match_term_list_code p (updateb x t sigma) else Nothing);
match_term_list_code [] sigma = Just sigma;

subst_of_map :: forall a b. (a -> b) -> (a -> Maybe b) -> a -> b;
subst_of_map d sigma x = (case sigma x of {
                           Nothing -> d x;
                           Just t -> t;
                         });

match_list ::
  forall a b c.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Eq c) => (a -> Term b c) ->
                 [(Term b a, Term b c)] -> Maybe (a -> Term b c);
match_list d p =
  map_option (subst_of_map d . lookupb) (match_term_list_code p emptyb);

match ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b -> Term a b -> Maybe (b -> Term a b);
match t l = match_list Var [(l, t)];

mat_add :: forall a. (Plus a) => Mat a -> Mat a -> Mat a;
mat_add a b =
  mat (mat_dim_row b) (mat_dim_col b)
    (\ ij -> plus (mat_index a ij) (mat_index b ij));

mat_map :: forall a b. (a -> b) -> Mat a -> Mat b;
mat_map f a = mat (mat_dim_row a) (mat_dim_col a) (\ ij -> f (mat_index a ij));

mat_one :: forall a. (One a, Zero a) => Nat -> Mat a;
mat_one n = mat n n (\ (i, j) -> (if equal_nat i j then onea else zerob));

vec_dim_impl :: forall a. Vec_impl a -> Nat;
vec_dim_impl xa = fst (rep_vec_impl xa);

vec_dim :: forall a. Vec a -> Nat;
vec_dim (Vec_impl v) = vec_dim_impl v;

scalar_prod :: forall a. (Semiring_0 a) => Vec a -> Vec a -> a;
scalar_prod v w =
  sum_list
    (map (\ i -> times (vec_index v i) (vec_index w i))
      (upt zero_nat (vec_dim w)));

mat_mult_mat :: forall a. (Semiring_0 a) => Mat a -> Mat a -> Mat a;
mat_mult_mat a b =
  mat (mat_dim_row a) (mat_dim_col b)
    (\ (i, j) -> scalar_prod (row a i) (col b j));

mat_pow :: forall a. (Semiring_1 a) => Mat a -> Nat -> Mat a;
mat_pow a k =
  (if equal_nat k zero_nat then mat_one (mat_dim_row a)
    else mat_mult_mat (mat_pow a (minus_nat k one_nat)) a);

rBT_Impl_fold1 :: forall a. (a -> a -> a) -> Rbta a () -> a;
rBT_Impl_fold1 f (Branch ca (Branch c l ka va ra) k v r) =
  folda (\ kb _ -> f kb) r (f k (rBT_Impl_fold1 f (Branch c l ka va ra)));
rBT_Impl_fold1 f (Branch c Emptya k v r) = folda (\ ka _ -> f ka) r k;
rBT_Impl_fold1 f Emptya = error "undefined";

fold1 :: forall a. (Ccompare a) => (a -> a -> a) -> Mapping_rbt a () -> a;
fold1 x xc = rBT_Impl_fold1 x (impl_ofb xc);

imagea ::
  forall a b.
    (Ceq a, Ccompare a, Ceq b, Ccompare b,
      Set_impl b) => Set (a, b) -> Set a -> Set b;
imagea (RBT_set rbt) c =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Image RBT_set: ccompare1 = None" (\ _ -> imagea (RBT_set rbt) c);
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "Image RBT_set: ccompare2 = None" (\ _ -> imagea (RBT_set rbt) c);
        Just _ ->
          foldb (\ (x, y) acc -> (if member x c then inserta y acc else acc))
            rbt bot_set;
      });
  });
imagea (DList_set dxs) b =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Image DList_set: ceq1 = None" (\ _ -> imagea (DList_set dxs) b);
    Just _ ->
      (case (ceq :: Maybe (b -> b -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "Image DList_set: ceq2 = None" (\ _ -> imagea (DList_set dxs) b);
        Just _ ->
          foldc (\ (x, y) acc -> (if member x b then inserta y acc else acc))
            dxs bot_set;
      });
  });
imagea (Set_Monad rxs) a =
  Set_Monad
    (fold (\ (x, y) rest -> (if member x a then y : rest else rest)) rxs []);
imagea x y = image snd (filtera (\ (xa, _) -> member xa y) x);

zero :: forall a b. Partial_object_ext a (Monoid_ext a (Ring_ext a b)) -> a;
zero (Partial_object_ext carrier (Monoid_ext mult one (Ring_ext zero add more)))
  = zero;

args :: forall a b. Term a b -> [Term a b];
args (Var x1) = [];
args (Fun x21 x22) = x22;

aarity :: forall a. (a -> Nat -> [a]) -> a -> Nat -> Nat;
aarity sm f n = minus_nat (size_list (sm f n)) one_nat;

list2position :: [Nat] -> Pos;
list2position [] = Empty;
list2position (n : ns) = PCons n (list2position ns);

pos ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) Pos;
pos = xml_do
        ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', 'I', 'n', 'T', 'e', 'r', 'm']
        (xml_take_many_sub [] zero_nat Infinity_enat position
          (\ lst -> xml_return (list2position lst)));

many1_gen ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> [b] -> c) -> Xml -> Sum_bot [Prelude.Char] c;
many1_gen tag p1 p2 f (XML name atts cs) =
  (if name == tag && null atts && not (null cs)
    then let {
           (h : t) = cs;
         } in binda (p1 h)
                (\ x -> binda (map_sum_bot (p2 x) t) (\ xs -> returna (f x xs)))
    else fail tag (XML name atts cs));
many1_gen tag p1 p2 f (XML_text v) = fail tag (XML_text v);

list1element :: forall a. [a] -> Maybe a;
list1element [x] = Just x;
list1element [] = Nothing;
list1element (v : vb : vc) = Nothing;

singleton ::
  forall a b.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> b) -> Xml -> Sum_bot [Prelude.Char] b;
singleton tag p1 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list1element cs of {
               Nothing -> fail tag xml;
               Just cs1 -> binda (p1 cs1) (returna . f);
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

xml_leaf ::
  forall a.
    [Prelude.Char] ->
      a -> (Xml, ([([Prelude.Char], [Prelude.Char])],
                   (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
             Sum (Xml_error [Prelude.Char]) a;
xml_leaf tag ret = xml_do tag (xml_return ret);

map_entry :: forall a b. (Eq a) => a -> (b -> b) -> [(a, b)] -> [(a, b)];
map_entry k f [] = [];
map_entry k f (p : ps) =
  (if fst p == k then (k, f (snd p)) : ps else p : map_entry k f ps);

ctxt ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Ctxt a [Prelude.Char]);
ctxt xml2name x =
  xml_or (xml_do ['b', 'o', 'x'] (xml_return Hole))
    (xml_do ['f', 'u', 'n', 'C', 'o', 'n', 't', 'e', 'x', 't']
      (xml_take xml2name
        (\ name ->
          xml_take
            (xml_do ['b', 'e', 'f', 'o', 'r', 'e']
              (xml_take_many_sub [] zero_nat Infinity_enat (term xml2name)
                xml_return))
            (\ left ->
              xml_take (ctxt xml2name)
                (\ mid ->
                  xml_take
                    (xml_do ['a', 'f', 't', 'e', 'r']
                      (xml_take_many_sub [] zero_nat Infinity_enat
                        (term xml2name) xml_return))
                    (\ right -> xml_return (More name left mid right)))))))
    x;

xml_take_optional ::
  forall a b.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      (Maybe a ->
        ([Xml],
          ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) b) ->
        ([Xml],
          ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) b;
xml_take_optional p1 p2 xs =
  (case xs of {
    ([], _) -> p2 Nothing xs;
    (xml : xmls, (atts, (allow, (cands, rest)))) ->
      (case p1 (xml, (atts, (True, (cands, rest)))) of {
        Inl (TagMismatch cands1) ->
          p2 Nothing (xml : xmls, (atts, (allow, (cands1, rest))));
        Inl (Fatal aa) -> Inl (Fatal aa);
        Inr a -> p2 (Just a) (xmls, (atts, (False, ([], rest))));
      });
  });

relstep ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                               (Bool, Term a [Prelude.Char])));
relstep xml2name =
  xml_do ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 't', 'e', 'p']
    (xml_take pos
      (\ p ->
        xml_take (rule xml2name)
          (\ r ->
            xml_take_optional
              (xml_leaf ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e'] ())
              (\ rel ->
                xml_take (term xml2name)
                  (\ t -> xml_return (p, (r, (is_none rel, t))))))));

relsteps ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Term a [Prelude.Char],
                         [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                                  (Bool, Term a [Prelude.Char])))]);
relsteps xml2name =
  xml_do
    ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e']
    (xml_take
      (xml_do ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm']
        (xml_take (term xml2name) (\ x -> xml_return (id x))))
      (\ start ->
        xml_take_many_sub [] zero_nat Infinity_enat (relstep xml2name)
          (\ steps -> xml_return (start, steps))));

substa ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       [([Prelude.Char], Term a [Prelude.Char])];
substa xml2name =
  xml_do ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do ['s', 'u', 'b', 's', 't', 'E', 'n', 't', 'r', 'y']
        (xml_take (xml_do ['v', 'a', 'r'] (xml_take_text xml_return))
          (\ var -> xml_take (term xml2name) (\ trm -> xml_return (var, trm)))))
      xml_return);

loop ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Term a [Prelude.Char],
                         ([(Pos, ((Term a [Prelude.Char],
                                    Term a [Prelude.Char]),
                                   (Bool, Term a [Prelude.Char])))],
                           ([([Prelude.Char], Term a [Prelude.Char])],
                             Ctxt a [Prelude.Char])));
loop xml2name =
  xml_do ['l', 'o', 'o', 'p']
    (xml_take (relsteps xml2name)
      (\ (s, rseq) ->
        xml_take (substa xml2name)
          (\ sigma ->
            xml_take (ctxt xml2name)
              (\ c -> xml_return (s, (rseq, (sigma, c)))))));

proj ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (ProjL a);
proj xml2name =
  xml_change (afs xml2name)
    (\ afl ->
      xml_return
        (Projection (map (\ (fa, a) -> (case a of {
 Collapse aa -> (fa, aa);
 AFList _ -> (fa, snd fa);
                                       }))
                      afl)));

catch_error :: forall a b c. Sum_bot a b -> (a -> Sum_bot c b) -> Sum_bot c b;
catch_error (Sumbot a) f = (case a of {
                             Inl aa -> f aa;
                             Inr aa -> Sumbot (Inr aa);
                           });

real :: Xml -> Sum_bot [Prelude.Char] Real;
real x =
  catch_error (change rat of_rat x)
    (\ _ ->
      triple ['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c'] rat rat rat
        (\ a b c ->
          plus_real (of_rat a) (times_real (of_rat b) (sqrt (of_rat c))))
        x);

proj_term :: forall a b. ((a, Nat) -> Nat) -> Term a b -> Term a b;
proj_term p (Var x) = Var x;
proj_term p (Fun f ts) = let {
                           n = size_list ts;
                           i = p (f, n);
                         } in (if less_nat i n then nth ts i else Fun f ts);

start_term ::
  forall a.
    (Eq a,
      Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) a) ->
                    Term a [Prelude.Char] ->
                      (Xml, ([([Prelude.Char], [Prelude.Char])],
                              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                        Sum (Xml_error [Prelude.Char]) (Term a [Prelude.Char]);
start_term xml2name t =
  xml_do ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm']
    (xml_take (term xml2name)
      (\ s ->
        (if equal_term s t then xml_return t
          else xml_error
                 ['<', 's', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm', '>', ' ',
                   'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                   'c', 'h', ' ', 'l', 'h', 's'])));

rstep ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                               Term a [Prelude.Char]));
rstep xml2name =
  xml_do ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 't', 'e', 'p']
    (xml_take pos
      (\ p ->
        xml_take (rule xml2name)
          (\ r -> xml_take (term xml2name) (\ t -> xml_return (p, (r, t))))));

rseq ::
  forall a.
    (Eq a,
      Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) a) ->
                    ((a, Nat) -> Nat) ->
                      (Term a [Prelude.Char], Term a [Prelude.Char]) ->
                        (Xml, ([([Prelude.Char], [Prelude.Char])],
                                (Bool,
                                  ([[Prelude.Char]], [[Prelude.Char]])))) ->
                          Sum (Xml_error [Prelude.Char])
                            ((Term a [Prelude.Char], Term a [Prelude.Char]),
                              [(Pos, ((Term a [Prelude.Char],
Term a [Prelude.Char]),
                                       Term a [Prelude.Char]))]);
rseq xml2name pi r =
  xml_do
    ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e']
    (xml_take (start_term xml2name (proj_term pi (fst r)))
      (\ _ ->
        xml_take_many_sub [] zero_nat Infinity_enat (rstep xml2name)
          (\ rseq -> xml_return (r, rseq))));

trivial_mute_fun :: forall a. (Comm_ring_1 a) => a -> a -> (a, (a, a));
trivial_mute_fun x y = (x, (y, onea));

fst_sel_fun :: forall a. [(Nat, a)] -> Nat;
fst_sel_fun x = fst (hda x);

find_non0 ::
  forall a.
    (Eq a, Idom_divide a) => ([(Nat, a)] -> Nat) -> Nat -> Mat a -> Maybe Nat;
find_non0 sel_fun l a =
  let {
    is = upt (suc l) (mat_dim_row a);
    ais = filter (\ (_, ail) -> not (ail == zerob))
            (map (\ i -> (i, mat_index a (i, l))) is);
  } in (case ais of {
         [] -> Nothing;
         _ : _ -> Just (sel_fun ais);
       });

mat_addrow_gen_impl ::
  forall a.
    (a -> a -> a) ->
      (a -> a -> a) -> a -> Nat -> Nat -> Mat_impl a -> Mat_impl a;
mat_addrow_gen_impl xd xe xf xh xi xj =
  Abs_mat_impl
    (let {
       (nr, a) = rep_mat_impl xj;
       (nc, aa) = a;
     } in (if less_nat xi nr
            then let {
                   ak = sub aa xh;
                   al = sub aa xi;
                   aka = of_fun (\ i -> xd (xe xf (sub al i)) (sub ak i))
                           (min (length ak) (length al));
                   ab = of_fun
                          (\ i -> (if equal_nat i xh then aka else sub aa i))
                          (length aa);
                 } in (nr, (nc, ab))
            else (nr, (nc, aa))));

mat_addrow_gen ::
  forall a. (a -> a -> a) -> (a -> a -> a) -> a -> Nat -> Nat -> Mat a -> Mat a;
mat_addrow_gen ad mul aa k l (Mat_impl a) =
  (if less_nat l (mat_dim_row_impl a)
    then Mat_impl (mat_addrow_gen_impl ad mul aa k l a)
    else (error :: forall a. String -> (() -> a) -> a)
           "index out of bounds in mat_addrow"
           (\ _ -> mat_addrow_gen ad mul aa k l (Mat_impl a)));

mute ::
  forall a.
    (Eq a,
      Idom_divide a) => (a -> a -> (a, (a, a))) ->
                          a -> Nat -> Nat -> (a, Mat a) -> (a, Mat a);
mute mf a_ll k l (r, a) =
  let {
    p = mat_index a (k, l);
  } in (if p == zerob then (r, a)
         else let {
                (q, (pa, _)) = mf a_ll p;
              } in (times r q,
                     mat_addrow_gen plus times (uminus pa) k l
                       (mat_multrow_gen times k q a)));

sub1 ::
  forall a.
    (Eq a,
      Idom_divide a) => (a -> a -> (a, (a, a))) ->
                          a -> Nat -> Nat -> (a, Mat a) -> (a, Mat a);
sub1 mf q k l rA =
  (if equal_nat k zero_nat then rA
    else mute mf q (plus_nat l (suc (minus_nat k one_nat))) l
           (sub1 mf q (minus_nat k one_nat) l rA));

sub2 ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) ->
                            Nat -> Nat -> (a, Mat a) -> (a, Mat a);
sub2 sel_fun mf d l (r, a) =
  (case find_non0 sel_fun l a of {
    Nothing -> (r, a);
    Just m ->
      let {
        aa = mat_swaprows m l a;
      } in sub1 mf (mat_index aa (l, l)) (minus_nat d (suc l)) l (uminus r, aa);
  });

sub3 ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) ->
                            Nat -> Nat -> (a, Mat a) -> (a, Mat a);
sub3 sel_fun mf d l rA =
  (if equal_nat l zero_nat then rA
    else sub2 sel_fun mf d (minus_nat l one_nat)
           (sub3 sel_fun mf d (minus_nat l one_nat) rA));

triangulize ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) -> Mat a -> (a, Mat a);
triangulize sel_fun mf a =
  sub3 sel_fun mf (mat_dim_row a) (mat_dim_row a) (onea, a);

mat_diag :: forall a. Mat a -> [a];
mat_diag a = map (\ i -> mat_index a (i, i)) (upt zero_nat (mat_dim_row a));

det_code ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) -> Mat a -> a;
det_code sel_fun mf a =
  (if equal_nat (mat_dim_row a) (mat_dim_col a)
    then let {
           (m, aa) = triangulize sel_fun mf a;
         } in divide (prod_list (mat_diag aa)) m
    else zerob);

det :: forall a. (Eq a, Idom_divide a) => Mat a -> a;
det a = det_code fst_sel_fun trivial_mute_fun a;

form_or :: forall a. Formula a -> Formula a -> Formula a;
form_or (Disjunction []) psi = psi;
form_or (Atom v) (Disjunction []) = Atom v;
form_or (NegAtom v) (Disjunction []) = NegAtom v;
form_or (Conjunction v) (Disjunction []) = Conjunction v;
form_or (Disjunction (va : vb)) (Disjunction []) = Disjunction (va : vb);
form_or (Disjunction (v : va)) (Disjunction (vb : vc)) =
  Disjunction ((v : va) ++ vb : vc);
form_or (Disjunction (v : va)) (Atom vb) = Disjunction ((v : va) ++ [Atom vb]);
form_or (Disjunction (v : va)) (NegAtom vb) =
  Disjunction ((v : va) ++ [NegAtom vb]);
form_or (Disjunction (v : va)) (Conjunction vb) =
  Disjunction ((v : va) ++ [Conjunction vb]);
form_or (Atom v) (Disjunction (va : vb)) = Disjunction (Atom v : va : vb);
form_or (NegAtom v) (Disjunction (va : vb)) = Disjunction (NegAtom v : va : vb);
form_or (Conjunction v) (Disjunction (va : vb)) =
  Disjunction (Conjunction v : va : vb);
form_or (Atom v) (Atom va) = Disjunction [Atom v, Atom va];
form_or (Atom v) (NegAtom va) = Disjunction [Atom v, NegAtom va];
form_or (Atom v) (Conjunction va) = Disjunction [Atom v, Conjunction va];
form_or (NegAtom v) (Atom va) = Disjunction [NegAtom v, Atom va];
form_or (NegAtom v) (NegAtom va) = Disjunction [NegAtom v, NegAtom va];
form_or (NegAtom v) (Conjunction va) = Disjunction [NegAtom v, Conjunction va];
form_or (Conjunction v) (Atom va) = Disjunction [Conjunction v, Atom va];
form_or (Conjunction v) (NegAtom va) = Disjunction [Conjunction v, NegAtom va];
form_or (Conjunction v) (Conjunction va) =
  Disjunction [Conjunction v, Conjunction va];

cnf_form_or :: forall a. Formula a -> Formula a -> Formula a;
cnf_form_or (Conjunction phi_s) (Conjunction psi_s) =
  Conjunction (concatMap (\ phi -> map (form_or phi) psi_s) phi_s);
cnf_form_or (Atom v) psi = form_or (Atom v) psi;
cnf_form_or (NegAtom v) psi = form_or (NegAtom v) psi;
cnf_form_or (Disjunction v) psi = form_or (Disjunction v) psi;
cnf_form_or phi (Atom v) = form_or phi (Atom v);
cnf_form_or phi (NegAtom v) = form_or phi (NegAtom v);
cnf_form_or phi (Disjunction v) = form_or phi (Disjunction v);

form_cnf_ex :: forall a. [Formula a] -> Formula a;
form_cnf_ex [] = Conjunction [Disjunction []];
form_cnf_ex (phi : phi_s) = cnf_form_or phi (form_cnf_ex phi_s);

form_and :: forall a. Formula a -> Formula a -> Formula a;
form_and (Conjunction []) psi = psi;
form_and (Atom v) (Conjunction []) = Atom v;
form_and (NegAtom v) (Conjunction []) = NegAtom v;
form_and (Conjunction (va : vb)) (Conjunction []) = Conjunction (va : vb);
form_and (Disjunction v) (Conjunction []) = Disjunction v;
form_and (Conjunction (v : va)) (Conjunction (vb : vc)) =
  Conjunction ((v : va) ++ vb : vc);
form_and (Conjunction (v : va)) (Atom vb) = Conjunction ((v : va) ++ [Atom vb]);
form_and (Conjunction (v : va)) (NegAtom vb) =
  Conjunction ((v : va) ++ [NegAtom vb]);
form_and (Conjunction (v : va)) (Disjunction vb) =
  Conjunction ((v : va) ++ [Disjunction vb]);
form_and (Atom v) (Conjunction (va : vb)) = Conjunction (Atom v : va : vb);
form_and (NegAtom v) (Conjunction (va : vb)) =
  Conjunction (NegAtom v : va : vb);
form_and (Disjunction v) (Conjunction (va : vb)) =
  Conjunction (Disjunction v : va : vb);
form_and (Atom v) (Atom va) = Conjunction [Atom v, Atom va];
form_and (Atom v) (NegAtom va) = Conjunction [Atom v, NegAtom va];
form_and (Atom v) (Disjunction va) = Conjunction [Atom v, Disjunction va];
form_and (NegAtom v) (Atom va) = Conjunction [NegAtom v, Atom va];
form_and (NegAtom v) (NegAtom va) = Conjunction [NegAtom v, NegAtom va];
form_and (NegAtom v) (Disjunction va) = Conjunction [NegAtom v, Disjunction va];
form_and (Disjunction v) (Atom va) = Conjunction [Disjunction v, Atom va];
form_and (Disjunction v) (NegAtom va) = Conjunction [Disjunction v, NegAtom va];
form_and (Disjunction v) (Disjunction va) =
  Conjunction [Disjunction v, Disjunction va];

form_all :: forall a. [Formula a] -> Formula a;
form_all [] = Conjunction [];
form_all (phi : phi_s) = form_and phi (form_all phi_s);

flatten :: forall a. Formula a -> Formula a;
flatten (Conjunction phi_s) = form_all (map flatten phi_s);
flatten (Disjunction phi_s) = form_cnf_ex (map flatten phi_s);
flatten (Atom v) = Conjunction [Disjunction [Atom v]];
flatten (NegAtom v) = Conjunction [Disjunction [NegAtom v]];

is_Atom :: forall a. Formula a -> Bool;
is_Atom (Atom uu) = True;
is_Atom (NegAtom v) = False;
is_Atom (Conjunction v) = False;
is_Atom (Disjunction v) = False;

gen_set :: forall a b. a -> (b -> a -> a) -> [b] -> a;
gen_set emp ins l = fold ins l emp;

initial :: forall a b c d e. Lts_ext a b c d e -> Set d;
initial (Lts_ext initial transition_rules assertion more) = initial;

untrans_var :: forall a. Trans_var a -> a;
untrans_var (Pre x) = x;
untrans_var (Post x) = x;
untrans_var (Intermediate x) = x;

label :: forall a b. Lab a b -> Nat -> Sum b [Lab a b] -> Lab a b;
label f n (Inl l) = Lab f l;
label f n (Inr l) = FunLab f l;

unlab :: forall a b. Lab a b -> Lab a b;
unlab (Lab f l) = f;
unlab (FunLab f l) = f;
unlab (UnLab v) = UnLab v;
unlab (Sharp v) = Sharp v;

mat_carrier :: forall a. Nat -> Nat -> Set (Mat a);
mat_carrier nr nc =
  Collect_set
    (\ a -> equal_nat (mat_dim_row a) nr && equal_nat (mat_dim_col a) nc);

mat_zero :: forall a. (Zero a) => Nat -> Nat -> Mat a;
mat_zero nr nc = mat nr nc (\ _ -> zerob);

mat_ring ::
  forall a b.
    (Semiring_1 a) => Itself a ->
                        Nat ->
                          b -> Partial_object_ext (Mat a)
                                 (Monoid_ext (Mat a) (Ring_ext (Mat a) b));
mat_ring ty n b =
  Partial_object_ext (mat_carrier n n)
    (Monoid_ext mat_mult_mat (mat_one n) (Ring_ext (mat_zero n n) mat_add b));

emptyd :: forall a b. (Ccompare b, Mapping_impl b) => (a -> b) -> Multimap b a;
emptyd xa = Abs_multimap (xa, (emptyb, []));

rm_iterateoi ::
  forall a b c. Rbta a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
rm_iterateoi Emptya c f sigma = sigma;
rm_iterateoi (Branch col l k v r) c f sigma =
  (if c sigma
    then let {
           sigmaa = rm_iterateoi l c f sigma;
         } in (if c sigmaa then rm_iterateoi r c f (f (k, v) sigmaa)
                else sigmaa)
    else sigma);

iteratei_bmap_op_list_it_rm_basic_ops ::
  forall a b c.
    (Linorder a) => Rbt a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
iteratei_bmap_op_list_it_rm_basic_ops s = rm_iterateoi (impl_of s);

g_to_list_rm_basic_ops :: forall a b. (Linorder a) => Rbt a b -> [(a, b)];
g_to_list_rm_basic_ops m =
  iteratei_bmap_op_list_it_rm_basic_ops m (\ _ -> True) (\ a b -> a : b) [];

values :: forall a b. (Linorder a) => Rbt a [b] -> [b];
values m = concatMap snd (g_to_list_rm_basic_ops m);

vars_list :: Linear_poly -> [Nat];
vars_list lp = ordered_keys (linear_poly_map lp);

valuate :: forall a. (Rational_vector a) => Linear_poly -> (Nat -> a) -> a;
valuate lp val =
  let {
    lpm = linear_poly_map lp;
  } in sum_list
         (map (\ x -> scaleRat (the (fmlookup lpm x)) (val x)) (vars_list lp));

delta_0 :: QDelta -> QDelta -> Rat;
delta_0 qd1 qd2 =
  let {
    c1 = qdfst qd1;
    c2 = qdfst qd2;
    k1 = qdsnd qd1;
    k2 = qdsnd qd2;
  } in (if less_rat c1 c2 && less_rat k2 k1
         then divide_rat (minus_rat c2 c1) (minus_rat k1 k2) else one_rat);

delta_0_val :: Ns_constraint QDelta -> (Nat -> QDelta) -> Rat;
delta_0_val (LEQ_ns lll rrr) vl = delta_0 (valuate lll vl) rrr;
delta_0_val (GEQ_ns lll rrr) vl = delta_0 rrr (valuate lll vl);

delta_0_val_min :: [Ns_constraint QDelta] -> (Nat -> QDelta) -> Rat;
delta_0_val_min [] vl = one_rat;
delta_0_val_min (h : t) vl = min (delta_0_val_min t vl) (delta_0_val h vl);

tabulate ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a) => [a] -> (a -> b) -> Mapping a b;
tabulate xs f = fold (\ k -> updateb k (f k)) xs emptyb;

map2fun :: forall a. (Zero a) => Mapping Nat a -> Nat -> a;
map2fun v = (\ x -> (case lookupb v x of {
                      Nothing -> zerob;
                      Just y -> y;
                    }));

from_ns :: Mapping Nat QDelta -> [Ns_constraint QDelta] -> Mapping Nat Rat;
from_ns vl cs =
  let {
    delta = delta_0_val_min cs (map2fun vl);
  } in tabulate (remdups (concatMap vars_list (map poly cs)))
         (\ var -> val (map2fun vl var) delta);

u_update :: forall a b. (Bool -> Bool) -> State_ext a b -> State_ext a b;
u_update ua (State_ext t b_l b_u v u more) = State_ext t b_l b_u v (ua u) more;

uB_upd ::
  forall a b.
    (Linorder a) => Direction_ext a b ->
                      ((Nat -> Maybe a) -> Nat -> Maybe a) ->
                        State_ext a () -> State_ext a ();
uB_upd (Direction_ext lt lb ub uB_upd le more) = uB_upd;

lt :: forall a b. (Linorder a) => Direction_ext a b -> a -> a -> Bool;
lt (Direction_ext lt lb ub uB_upd le more) = lt;

ub :: forall a b.
        (Linorder a) => Direction_ext a b -> State_ext a () -> Nat -> Maybe a;
ub (Direction_ext lt lb ub uB_upd le more) = ub;

lb :: forall a b.
        (Linorder a) => Direction_ext a b -> State_ext a () -> Nat -> Maybe a;
lb (Direction_ext lt lb ub uB_upd le more) = lb;

v_update ::
  forall a b.
    (Mapping Nat a -> Mapping Nat a) -> State_ext a b -> State_ext a b;
v_update va (State_ext t b_l b_u v u more) = State_ext t b_l b_u (va v) u more;

v :: forall a b. State_ext a b -> Mapping Nat a;
v (State_ext t b_l b_u v u more) = v;

t :: forall a b. State_ext a b -> [(Nat, Linear_poly)];
t (State_ext t b_l b_u v u more) = t;

coeffa :: Linear_poly -> Nat -> Rat;
coeffa lp = get_var_coeff (linear_poly_map lp);

rhs_eq_val ::
  forall a.
    (ScaleRat a, Minus a, Plus a,
      Zero a) => Mapping Nat a -> Nat -> a -> (Nat, Linear_poly) -> a;
rhs_eq_val v x_i c e =
  let {
    x_j = lhs e;
    a_i_j = coeffa (rhs e) x_i;
  } in plus (map2fun v x_j) (scaleRat a_i_j (minus c (map2fun v x_i)));

update_code ::
  forall a. (Lrv a) => Nat -> a -> State_ext a () -> State_ext a ();
update_code x c s =
  v_update
    (\ _ ->
      updateb x c
        (foldl (\ va e -> updateb (lhs e) (rhs_eq_val (v s) x c e) va) (v s)
          (t s)))
    s;

update_B ::
  forall a b c d.
    (Eq a) => (((a -> Maybe b) -> a -> Maybe b) -> c -> d) -> a -> b -> c -> d;
update_B field_update x c s = field_update (\ b -> fun_upd b x (Just c)) s;

assert_bound_codea ::
  forall a b.
    (Lrv a,
      Eq a) => Direction_ext a b ->
                 Nat -> a -> State_ext a () -> State_ext a ();
assert_bound_codea dir x c s =
  (if geub (lt dir) c (ub dir s x) then s
    else let {
           sa = update_B (uB_upd dir) x c s;
         } in (if ltlb (lt dir) c (lb dir s x) then u_update (\ _ -> True) sa
                else (if not (member x (lvars (t sa))) &&
                           lt dir c (map2fun (v s) x)
                       then update_code x c sa else sa)));

b_u_update ::
  forall a b.
    ((Nat -> Maybe a) -> Nat -> Maybe a) -> State_ext a b -> State_ext a b;
b_u_update b_ua (State_ext t b_l b_u v u more) =
  State_ext t b_l (b_ua b_u) v u more;

b_u :: forall a b. State_ext a b -> Nat -> Maybe a;
b_u (State_ext t b_l b_u v u more) = b_u;

b_l :: forall a b. State_ext a b -> Nat -> Maybe a;
b_l (State_ext t b_l b_u v u more) = b_l;

positive :: forall a. (Linorder a) => Direction_ext a ();
positive = Direction_ext less b_l b_u b_u_update Leq ();

b_l_update ::
  forall a b.
    ((Nat -> Maybe a) -> Nat -> Maybe a) -> State_ext a b -> State_ext a b;
b_l_update b_la (State_ext t b_l b_u v u more) =
  State_ext t (b_la b_l) b_u v u more;

negative :: forall a. (Linorder a) => Direction_ext a ();
negative = Direction_ext (\ x y -> less y x) b_u b_l b_l_update Geq ();

assert_bound_code ::
  forall a. (Lrv a, Eq a) => Atom a -> State_ext a () -> State_ext a ();
assert_bound_code (Leq x c) s = assert_bound_codea positive x c s;
assert_bound_code (Geq x c) s = assert_bound_codea negative x c s;

u :: forall a b. State_ext a b -> Bool;
u (State_ext t b_l b_u v u more) = u;

assert_bound_loop_code ::
  forall a. (Lrv a, Eq a) => [Atom a] -> State_ext a () -> State_ext a ();
assert_bound_loop_code ats s =
  foldl (\ sa a -> (if u sa then sa else assert_bound_code a sa)) s ats;

init_state :: forall a. (Zero a) => [(Nat, Linear_poly)] -> State_ext a ();
init_state t =
  State_ext t (\ _ -> Nothing) (\ _ -> Nothing)
    (tabulate (remdups (map lhs t ++ concatMap (vars_list . rhs) t))
      (\ _ -> zerob))
    False ();

min_satisfying :: forall a. (Linorder a) => (a -> Bool) -> [a] -> Maybe a;
min_satisfying p l =
  let {
    xs = filter p l;
  } in (if null xs then Nothing else Just (foldl min (hda xs) (tla xs)));

le_ubound :: forall a. (Eq a, Linorder a) => a -> Maybe a -> Bool;
le_ubound c b = leub less c b;

ge_lbound :: forall a. (Eq a, Linorder a) => a -> Maybe a -> Bool;
ge_lbound c b = gelb less c b;

in_bounds ::
  forall a b.
    (Eq b, Linorder b) => a -> (a -> b) -> (a -> Maybe b, a -> Maybe b) -> Bool;
in_bounds x v (lb, ub) = ge_lbound (v x) (lb x) && le_ubound (v x) (ub x);

min_lvar_not_in_bounds ::
  forall a. (Zero a, Eq a, Linorder a) => State_ext a () -> Maybe Nat;
min_lvar_not_in_bounds s =
  min_satisfying (\ x -> not (in_bounds x (map2fun (v s)) (b_l s, b_u s)))
    (map lhs (t s));

vara :: Nat -> Linear_poly;
vara x = LinearPoly (set_var_coeff x one_rat fmempty);

subst_var :: Nat -> Linear_poly -> Linear_poly -> Linear_poly;
subst_var v lpa lp =
  minus_linear_poly
    (plus_linear_poly lp (scaleRat_linear_poly (coeffa lp v) lpa))
    (scaleRat_linear_poly (coeffa lp v) (vara v));

subst_var_eq_code ::
  Nat -> Linear_poly -> (Nat, Linear_poly) -> (Nat, Linear_poly);
subst_var_eq_code v lp eq = (lhs eq, subst_var v lp (rhs eq));

eq_idx_for_lvar_aux :: [(Nat, Linear_poly)] -> Nat -> Nat -> Nat;
eq_idx_for_lvar_aux [] x i = i;
eq_idx_for_lvar_aux (eq : t) x i =
  (if equal_nat (lhs eq) x then i
    else eq_idx_for_lvar_aux t x (plus_nat i one_nat));

eq_idx_for_lvar :: [(Nat, Linear_poly)] -> Nat -> Nat;
eq_idx_for_lvar t x = eq_idx_for_lvar_aux t x zero_nat;

eq_for_lvar_code :: [(Nat, Linear_poly)] -> Nat -> (Nat, Linear_poly);
eq_for_lvar_code t v = nth t (eq_idx_for_lvar t v);

pivot_eq :: (Nat, Linear_poly) -> Nat -> (Nat, Linear_poly);
pivot_eq e y =
  let {
    cy = coeffa (rhs e) y;
  } in (y, plus_linear_poly
             (scaleRat_linear_poly (divide_rat (uminus_rat one_rat) cy)
               (minus_linear_poly (rhs e) (scaleRat_linear_poly cy (vara y))))
             (scaleRat_linear_poly (divide_rat one_rat cy) (vara (lhs e))));

pivot_tableau_code ::
  Nat -> Nat -> [(Nat, Linear_poly)] -> [(Nat, Linear_poly)];
pivot_tableau_code x_i x_j t =
  let {
    eq = eq_for_lvar_code t x_i;
    eqa = pivot_eq eq x_j;
  } in map (\ e ->
             (if equal_nat (lhs e) (lhs eq) then eqa
               else subst_var_eq_code x_j (rhs eqa) e))
         t;

t_update ::
  forall a b.
    ([(Nat, Linear_poly)] -> [(Nat, Linear_poly)]) ->
      State_ext a b -> State_ext a b;
t_update ta (State_ext t b_l b_u v u more) = State_ext (ta t) b_l b_u v u more;

pivot_code ::
  forall a. (Lrv a) => Nat -> Nat -> State_ext a () -> State_ext a ();
pivot_code x_i x_j s = t_update (\ _ -> pivot_tableau_code x_i x_j (t s)) s;

pivot_and_update_code ::
  forall a. (Lrv a) => Nat -> Nat -> a -> State_ext a () -> State_ext a ();
pivot_and_update_code x_i x_j c s = update_code x_i c (pivot_code x_i x_j s);

min_rvar_incdec_eq ::
  forall a.
    (Lrv a) => Direction_ext a () ->
                 State_ext a () -> (Nat, Linear_poly) -> Maybe Nat;
min_rvar_incdec_eq dir s eq =
  min_satisfying
    (\ x ->
      less_rat zero_rat (coeffa (rhs eq) x) &&
        ltub (lt dir) (map2fun (v s) x) (ub dir s x) ||
        less_rat (coeffa (rhs eq) x) zero_rat &&
          gtlb (lt dir) (map2fun (v s) x) (lb dir s x))
    (vars_list (rhs eq));

check_codea ::
  forall a.
    (Lrv a) => Direction_ext a () -> Nat -> State_ext a () -> State_ext a ();
check_codea dir x_i s =
  let {
    l_i = the (lb dir s x_i);
  } in (case min_rvar_incdec_eq dir s (eq_for_lvar_code (t s) x_i) of {
         Nothing -> u_update (\ _ -> True) s;
         Just x_j -> pivot_and_update_code x_i x_j l_i s;
       });

lt_lbound :: forall a. (Linorder a) => a -> Maybe a -> Bool;
lt_lbound c b = ltlb less c b;

check_code :: forall a. (Lrv a, Eq a) => State_ext a () -> State_ext a ();
check_code s =
  (if u s then s
    else (case min_lvar_not_in_bounds s of {
           Nothing -> s;
           Just x_i ->
             let {
               dir = (if lt_lbound (map2fun (v s) x_i) (b_l s x_i) then positive
                       else negative);
             } in check_code (check_codea dir x_i s);
         }));

assert_all_state_code ::
  forall a. (Lrv a, Eq a) => [(Nat, Linear_poly)] -> [Atom a] -> State_ext a ();
assert_all_state_code t ats =
  check_code (assert_bound_loop_code ats (init_state t));

assert_all_code ::
  forall a.
    (Lrv a,
      Eq a) => [(Nat, Linear_poly)] ->
                 [Atom a] -> (Bool, Maybe (Mapping Nat a));
assert_all_code t asa =
  let {
    s = assert_all_state_code t asa;
  } in (if u s then (False, Nothing) else (True, Just (v s)));

max_var :: Linear_poly -> Nat;
max_var lp = let {
               vl = vars_list lp;
             } in (if null vl then zero_nat else foldl max (hda vl) (tla vl));

start_fresh_variable :: [Ns_constraint QDelta] -> Nat;
start_fresh_variable [] = zero_nat;
start_fresh_variable (h : t) =
  max (plus_nat (max_var (poly h)) one_nat) (start_fresh_variable t);

tableau :: forall a. Istate_ext a -> [(Nat, Linear_poly)];
tableau (Istate_ext firstFreshVariable tableau atoms more) = tableau;

atoms :: forall a. Istate_ext a -> [Atom QDelta];
atoms (Istate_ext firstFreshVariable tableau atoms more) = atoms;

is_monom :: Linear_poly -> Bool;
is_monom l = equal_nat (size_list (vars_list l)) one_nat;

monom_var :: Linear_poly -> Nat;
monom_var l = max_var l;

monom_coeff :: Linear_poly -> Rat;
monom_coeff l = coeffa l (monom_var l);

monom_to_atom :: Ns_constraint QDelta -> Atom QDelta;
monom_to_atom (LEQ_ns l r) =
  (if less_rat (monom_coeff l) zero_rat
    then Geq (monom_var l) (scaleRat_QDelta (inverse_rat (monom_coeff l)) r)
    else Leq (monom_var l) (scaleRat_QDelta (inverse_rat (monom_coeff l)) r));
monom_to_atom (GEQ_ns l r) =
  (if less_rat (monom_coeff l) zero_rat
    then Leq (monom_var l) (scaleRat_QDelta (inverse_rat (monom_coeff l)) r)
    else Geq (monom_var l) (scaleRat_QDelta (inverse_rat (monom_coeff l)) r));

qdelta_constraint_to_atom :: Ns_constraint QDelta -> Nat -> Atom QDelta;
qdelta_constraint_to_atom (LEQ_ns l r) v =
  (if is_monom l then monom_to_atom (LEQ_ns l r) else Leq v r);
qdelta_constraint_to_atom (GEQ_ns l r) v =
  (if is_monom l then monom_to_atom (GEQ_ns l r) else Geq v r);

firstFreshVariable :: forall a. Istate_ext a -> Nat;
firstFreshVariable (Istate_ext firstFreshVariable tableau atoms more) =
  firstFreshVariable;

qdelta_constraint_to_eq :: Ns_constraint QDelta -> Nat -> (Nat, Linear_poly);
qdelta_constraint_to_eq (LEQ_ns l r) v = (v, l);
qdelta_constraint_to_eq (GEQ_ns l r) v = (v, l);

preprocessa :: [Ns_constraint QDelta] -> Nat -> Istate_ext ();
preprocessa [] v = Istate_ext v [] [] ();
preprocessa (h : t) v =
  let {
    s = preprocessa t v;
    va = firstFreshVariable s;
    ta = tableau s;
    a = atoms s;
  } in Istate_ext (if is_monom (poly h) then va else plus_nat va one_nat)
         (if is_monom (poly h) then ta else qdelta_constraint_to_eq h va : ta)
         (qdelta_constraint_to_atom h va : a) ();

preprocess :: [Ns_constraint QDelta] -> ([(Nat, Linear_poly)], [Atom QDelta]);
preprocess l = let {
                 start = start_fresh_variable l;
                 is = preprocessa l start;
               } in (tableau is, atoms is);

solve_exec_ns_code ::
  [Ns_constraint QDelta] -> (Bool, Maybe (Mapping Nat QDelta));
solve_exec_ns_code s = let {
                         a = preprocess s;
                         (aa, b) = a;
                       } in assert_all_code aa b;

solve_exec_code :: [Constraint] -> (Bool, Maybe (Mapping Nat Rat));
solve_exec_code cs = let {
                       csa = to_ns cs;
                     } in (case solve_exec_ns_code csa of {
                            (True, v) -> (True, Just (from_ns (the v) csa));
                            (False, _) -> (False, Nothing);
                          });

simplex :: [Constraint] -> Maybe (Mapping Nat Rat);
simplex cs = snd (solve_exec_code cs);

tcapI ::
  forall a b. (Eq a, Eq b) => [(Term a b, Term a b)] -> Term a b -> Gctxt a b;
tcapI uu (Var uv) = GCHole;
tcapI r (Fun f ts) =
  let {
    h = GCFun f (map (tcapI r) ts);
  } in (if any (\ ra -> matchb h (fst ra)) r then GCHole else h);

sharp_term :: forall a b. (a -> a) -> Term a b -> Term a b;
sharp_term shp (Var x) = Var x;
sharp_term shp (Fun f ss) = Fun (shp f) ss;

hvf_top :: forall a b. (Eq a) => a -> Nat -> Term a b -> Bool;
hvf_top a n (Fun f ts) =
  (if f == a && equal_nat (size_list ts) n then not (is_Var (hda ts))
    else True);
hvf_top a n (Var uu) = False;

version :: [Prelude.Char];
version =
  ['2', '.', '3', '1', ' ', '[', 'h', 'g', ':', ' ', '1', 'c', '1', 'e', '7',
    '7', 'd', '7', '0', '6', '6', '0', ']'];

status :: forall a. Status a -> (a, Nat) -> [Nat];
status (Abs_status x) = x;

af_wpo :: forall a. ((a, Nat) -> Set Nat) -> Status a -> (a, Nat) -> Set Nat;
af_wpo pi sigma f = sup_set (set (status sigma f)) (pi f);

lex_ext_unbounded ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
lex_ext_unbounded f [] [] = (False, True);
lex_ext_unbounded f (uu : uv) [] = (True, True);
lex_ext_unbounded f [] (uw : ux) = (False, False);
lex_ext_unbounded f (a : asa) (b : bs) =
  (case f a b of {
    (True, _) -> (True, True);
    (False, True) -> lex_ext_unbounded f asa bs;
    (False, False) -> (False, False);
  });

wpo_ub ::
  forall a b.
    (Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool)) ->
                ((a, Nat) -> Bool) ->
                  (Term a b -> Term a b -> Bool) ->
                    (Term a b -> Term a b -> Bool) ->
                      Status a -> Term a b -> Term a b -> (Bool, Bool);
wpo_ub pr prl cS cNS sigma s t =
  (case s of {
    Var x ->
      (False,
        (case t of {
          Var a -> x == a;
          Fun g ts ->
            cNS s t &&
              null (status sigma (g, size_list ts)) && prl (g, size_list ts);
        }));
    Fun f ss ->
      (if cS s t then (True, True)
        else let {
               ff = (f, size_list ss);
               sf = status sigma ff;
             } in (if cNS s t
                    then (if any (\ i ->
                                   snd (wpo_ub pr prl cS cNS sigma (nth ss i)
 t))
                               sf
                           then (True, True)
                           else (case t of {
                                  Var _ -> (False, False);
                                  Fun g ts ->
                                    let {
                                      gg = (g, size_list ts);
                                      sg = status sigma gg;
                                      (prs, prns) = pr ff gg;
                                    } in (if prns &&
       all (\ j -> fst (wpo_ub pr prl cS cNS sigma s (nth ts j))) sg
   then (if prs then (True, True)
          else lex_ext_unbounded (wpo_ub pr prl cS cNS sigma) (map (nth ss) sf)
                 (map (nth ts) sg))
   else (False, False));
                                }))
                    else (False, False)));
  });

parse_xml ::
  forall a.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      Xml -> Sum [Prelude.Char] a;
parse_xml p xml =
  (case xml_take p xml_return ([xml], ([], (False, ([], [])))) of {
    Inl a -> let {
               (Fatal aa) = a;
             } in Inl aa;
    Inr a -> Inr a;
  });

cstep ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Cstep_proof (Lab a b) [Prelude.Char]);
cstep xml2name x =
  xml_do
    ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'w', 'r',
      'i', 't', 'e', 'S', 't', 'e', 'p']
    (xml_take (crule xml2name ['r', 'u', 'l', 'e'])
      (\ a ->
        xml_take pos
          (\ b ->
            xml_take (substa xml2name)
              (\ c ->
                xml_take
                  (xml_do ['s', 'o', 'u', 'r', 'c', 'e']
                    (xml_take (term xml2name) (\ xa -> xml_return (id xa))))
                  (\ d ->
                    xml_take
                      (xml_do ['t', 'a', 'r', 'g', 'e', 't']
                        (xml_take (term xml2name) (\ xa -> xml_return (id xa))))
                      (\ e ->
                        xml_take
                          (xml_do
                            ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's']
                            (xml_take_many_sub [] zero_nat Infinity_enat
                              (csteps xml2name) (\ aa -> xml_return (id aa))))
                          (\ f ->
                            xml_return
                              (Cstep_step a b (mk_subst Var c) d e f))))))))
    x;

csteps ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        [Cstep_proof (Lab a b) [Prelude.Char]];
csteps xml2name x =
  xml_do
    ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'w', 'r',
      'i', 't', 'i', 'n', 'g', 'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e']
    (xml_take_many_sub [] zero_nat Infinity_enat (cstep xml2name)
      (\ a -> xml_return (id a)))
    x;

estep ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                               (Bool, Term a [Prelude.Char])));
estep xml2name =
  xml_do ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'S', 't', 'e', 'p']
    (xml_take pos
      (\ p ->
        xml_take (rule xml2name)
          (\ r ->
            xml_take
              (xml_or
                (xml_leaf ['l', 'e', 'f', 't', 'R', 'i', 'g', 'h', 't'] True)
                (xml_leaf ['r', 'i', 'g', 'h', 't', 'L', 'e', 'f', 't'] False))
              (\ b ->
                xml_take (term xml2name)
                  (\ t -> xml_return (p, (r, (b, t))))))));

state ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) [Prelude.Char];
state = xml_text ['s', 't', 'a', 't', 'e'];

case_sum_bot :: forall a b c. a -> (b -> a) -> (c -> a) -> Sum_bot b c -> a;
case_sum_bot f g h (Sumbot p) = (case p of {
                                  Inl a -> g a;
                                  Inr a -> h a;
                                });

xmlt2 ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a;
xmlt2 xmlt x =
  let {
    (xml, (_, (_, (_, p)))) = x;
  } in case_sum_bot (error "undefined")
         (\ err -> xml_error err ([fst x], snd x))
         (\ v -> xml_return v ([], ([], (False, ([], p))))) (xmlt xml);

isOK :: forall a b. Sum a b -> Bool;
isOK m = (case m of {
           Inl _ -> False;
           Inr _ -> True;
         });

mapM :: forall a b c. (a -> Sum b c) -> [a] -> Sum b [c];
mapM f [] = Inr [];
mapM f (x : xs) = bindb (f x) (\ y -> bindb (mapM f xs) (\ ys -> Inr (y : ys)));

form_not :: forall a. Formula a -> Formula a;
form_not (Atom a) = NegAtom a;
form_not (NegAtom a) = Atom a;
form_not (Conjunction phi_s) = Disjunction (map form_not phi_s);
form_not (Disjunction phi_s) = Conjunction (map form_not phi_s);

get_Atom :: forall a. Formula a -> a;
get_Atom (Atom a) = a;
get_Atom (NegAtom a) = a;

simplify :: forall a. Formula a -> Formula a;
simplify (Disjunction (phi : phi_s)) =
  form_or (simplify phi) (simplify (Disjunction phi_s));
simplify (Conjunction [phi]) = simplify phi;
simplify (Conjunction (phi : v : va)) =
  form_and (simplify phi) (simplify (Conjunction (v : va)));
simplify (Atom v) = Atom v;
simplify (NegAtom v) = NegAtom v;
simplify (Conjunction []) = Conjunction [];
simplify (Disjunction []) = Disjunction [];

gen_ball ::
  forall a b c d e f.
    (a -> (b -> b) -> (c -> d -> e) -> Bool -> f) -> a -> (c -> e) -> f;
gen_ball it m p = it m (\ x -> x) (\ x _ -> p x) True;

gen_balla ::
  forall a b c d e.
    (a -> (b -> b) -> (c -> d -> Bool) -> Bool -> e) -> a -> (c -> Bool) -> e;
gen_balla it s p = it s (\ x -> x) (\ x _ -> p x) True;

gen_pick ::
  forall a b c d e f.
    (a -> (Maybe b -> Bool) -> (c -> d -> Maybe c) -> Maybe e -> Maybe f) ->
      a -> f;
gen_pick it s =
  the (it s (\ a -> (case a of {
                      Nothing -> True;
                      Just _ -> False;
                    }))
         (\ x _ -> Just x)
        Nothing);

one :: forall a b. Partial_object_ext a (Monoid_ext a b) -> a;
one (Partial_object_ext carrier (Monoid_ext mult one more)) = one;

base :: forall a. (a, Nat) -> a;
base (f, h) = f;

lift :: forall a. Nat -> a -> (a, Nat);
lift h f = (f, h);

add_vars_term :: forall a b. Term a b -> [b] -> [b];
add_vars_term (Var x) xs = x : xs;
add_vars_term (Fun uu ts) xs = foldr add_vars_term ts xs;

vars_term_list :: forall a b. Term a b -> [b];
vars_term_list t = add_vars_term t [];

roof ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Term a b -> Bool;
roof (l, r) = let {
                xs = vars_term_list r;
              } in (\ t -> let {
                             xt = vars_term t;
                           } in all (\ x -> member x xt) xs);

matches ::
  forall a b c.
    (Eq a, Eq b, Ccompare c, Eq c,
      Mapping_impl c) => Term a b -> Term a c -> Bool;
matches t p = (case match_list (\ _ -> t) [(p, t)] of {
                Nothing -> False;
                Just _ -> True;
              });

rep_multimap :: forall a b. Multimap a b -> (b -> a, (Mapping a [b], [b]));
rep_multimap (Abs_multimap x) = x;

option_list_to_list :: forall a. Maybe [a] -> [a];
option_list_to_list Nothing = [];
option_list_to_list (Just asa) = asa;

insertd :: forall a b. (Ccompare b, Eq b) => a -> Multimap b a -> Multimap b a;
insertd xb xc = Abs_multimap (let {
                                (f, (m, alla)) = rep_multimap xc;
                                k = f xb;
                                old = option_list_to_list (lookupb m k);
                                new = xb : old;
                              } in (f, (updateb k new m, xb : alla)));

lookupc :: forall a b. (Ccompare a, Eq a) => Multimap a b -> a -> [b];
lookupc xa = let {
               (_, (m, _)) = rep_multimap xa;
             } in (\ k -> option_list_to_list (lookupb m k));

valuesa :: forall a b. Multimap a b -> [b];
valuesa xa = let {
               (_, (_, alla)) = rep_multimap xa;
             } in alla;

subtract_entries_raw ::
  forall a b. (Eq a, Minus b) => [(a, b)] -> [(a, b)] -> [(a, b)];
subtract_entries_raw xs ys =
  foldr (\ (k, v) -> map_entry k (\ va -> minus va v)) ys xs;

subtract_entries ::
  forall a b. (Eq a, Minus b) => Alist a b -> Alist a b -> Alist a b;
subtract_entries xb xc =
  Alist (subtract_entries_raw (impl_ofa xb) (impl_ofa xc));

minus_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
minus_multiset (Bag xs) (Bag ys) = Bag (subtract_entries xs ys);

inf_subset_mset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
inf_subset_mset a b = minus_multiset a (minus_multiset a b);

fold_impl :: forall a b. (a -> Nat -> b -> b) -> b -> [(a, Nat)] -> b;
fold_impl fn e ((a, n) : ms) = fold_impl fn (fn a n e) ms;
fold_impl fn e [] = e;

foldd :: forall a b. (a -> Nat -> b -> b) -> b -> Alist a Nat -> b;
foldd f e al = fold_impl f e (impl_ofa al);

set_mset :: forall a. (Ceq a, Ccompare a, Set_impl a) => Multiset a -> Set a;
set_mset (Bag ms) =
  foldd (\ a n -> (if equal_nat n zero_nat then (\ m -> m) else inserta a))
    bot_set ms;

multeqp ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Set_impl a) => (a -> a -> Bool) -> Multiset a -> Multiset a -> Bool;
multeqp p n m = let {
                  z = inf_subset_mset m n;
                  x = minus_multiset m z;
                  y = minus_multiset n z;
                } in ball (set_mset y) (\ ya -> bex (set_mset x) (p ya));

is_Inr :: forall a b. Sum a b -> Bool;
is_Inr (Inr uu) = True;
is_Inr (Inl uv) = False;

eq_monom :: forall a. (Eq a) => [(a, Nat)] -> [(a, Nat)] -> Bool;
eq_monom [] n = null n;
eq_monom ((x, p) : m) n =
  (case extract (\ yq -> fst yq == x) n of {
    Nothing -> False;
    Just (n1, ((_, q), n2)) -> equal_nat p q && eq_monom m (n1 ++ n2);
  });

poly_split ::
  forall a b.
    (Eq a, Zero b) => [(a, Nat)] -> [([(a, Nat)], b)] -> (b, [([(a, Nat)], b)]);
poly_split m p = (case extract (\ (n, _) -> eq_monom m n) p of {
                   Nothing -> (zerob, p);
                   Just (p1, ((_, c), p2)) -> (c, p1 ++ p2);
                 });

max_v ::
  forall a b.
    (Zero a,
      Ord a) => a -> ((b, Nat) -> [([(Nat, Nat)], a)]) -> [(b, Nat)] -> a;
max_v v i fs =
  max v (foldr (\ f m -> max m (fst (poly_split [] (i f)))) fs zerob);

order :: forall a. (Eq a, Idom_divide a) => a -> Poly a -> Nat;
order a p =
  (if (case coeffs p of {
        [] -> True;
        _ : _ -> False;
      })
    then (error :: forall a. String -> (() -> a) -> a)
           "order of polynomial 0 undefined" (\ _ -> order a p)
    else (if not (polya p a == zerob) then zero_nat
           else suc (order a
                      (divide_polya p
                        (pCons (uminus a) (pCons onea zero_polya))))));

relcomp ::
  forall a b c.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b, Ceq c, Ccompare c,
      Set_impl c) => Set (a, b) -> Set (b, c) -> Set (a, c);
relcomp (Set_Monad xs6) (DList_set dxs4) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad DList_set: ceq1 = None"
        (\ _ -> relcomp (Set_Monad xs6) (DList_set dxs4));
    Just eq ->
      (case (ceq :: Maybe (c -> c -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp Set_Monad DList_set: ceq2 = None"
            (\ _ -> relcomp (Set_Monad xs6) (DList_set dxs4));
        Just _ ->
          fold (\ (x, y) ->
                 foldc (\ (ya, z) a ->
                         (if eq y ya then inserta (x, z) a else a))
                   dxs4)
            xs6 bot_set;
      });
  });
relcomp (DList_set dxs3) (Set_Monad xs5) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set Set_Monad: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs3) (Set_Monad xs5));
    Just _ ->
      (case ceq of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set Set_Monad: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs3) (Set_Monad xs5));
        Just eq ->
          foldc (\ (x, y) ->
                  fold (\ (ya, z) a ->
                         (if eq y ya then inserta (x, z) a else a))
                    xs5)
            dxs3 bot_set;
      });
  });
relcomp (Set_Monad xs4) (RBT_set rbt5) =
  (case (ccompare :: Maybe (c -> c -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad RBT_set: ccompare1 = None"
        (\ _ -> relcomp (Set_Monad xs4) (RBT_set rbt5));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp Set_Monad RBT_set: ccompare2 = None"
            (\ _ -> relcomp (Set_Monad xs4) (RBT_set rbt5));
        Just c_b ->
          fold (\ (x, y) ->
                 foldb (\ (ya, z) a ->
                         (if not (equal_order (c_b y ya) Eqa) then a
                           else inserta (x, z) a))
                   rbt5)
            xs4 bot_set;
      });
  });
relcomp (RBT_set rbt1) (Set_Monad xs3) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set Set_Monad: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt1) (Set_Monad xs3));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set Set_Monad: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt1) (Set_Monad xs3));
        Just c_b ->
          foldb (\ (x, y) ->
                  fold (\ (ya, z) a ->
                         (if not (equal_order (c_b y ya) Eqa) then a
                           else inserta (x, z) a))
                    xs3)
            rbt1 bot_set;
      });
  });
relcomp (Set_Monad xs1) (Set_Monad xs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad Set_Monad: ceq = None"
        (\ _ -> relcomp (Set_Monad xs1) (Set_Monad xs2));
    Just eq ->
      fold (\ (x, y) ->
             fold (\ (ya, z) a -> (if eq y ya then inserta (x, z) a else a))
               xs2)
        xs1 bot_set;
  });
relcomp (DList_set dxs3) (DList_set dxs4) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set DList_set: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
    Just _ ->
      (case ceq of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set DList_set: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
        Just eq ->
          (case (ceq :: Maybe (c -> c -> Bool)) of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp DList_set DList_set: ceq3 = None"
                (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
            Just _ ->
              foldc (\ (x, y) ->
                      foldc (\ (ya, z) a ->
                              (if eq y ya then inserta (x, z) a else a))
                        dxs4)
                dxs3 bot_set;
          });
      });
  });
relcomp (DList_set dxs2) (RBT_set rbt4) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set RBT_set: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set RBT_set: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
        Just _ ->
          (case ceq of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp DList_set RBT_set: ccompare2 = None"
                (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
            Just eq ->
              (case (ccompare :: Maybe (c -> c -> Ordera)) of {
                Nothing ->
                  (error :: forall a. String -> (() -> a) -> a)
                    "relcomp DList_set RBT_set: ccompare3 = None"
                    (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
                Just _ ->
                  foldc (\ (x, y) ->
                          foldb (\ (ya, z) a ->
                                  (if eq y ya then inserta (x, z) a else a))
                            rbt4)
                    dxs2 bot_set;
              });
          });
      });
  });
relcomp (RBT_set rbt3) (DList_set dxs1) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set DList_set: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set DList_set: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
        Just _ ->
          (case ceq of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp RBT_set DList_set: ceq2 = None"
                (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
            Just eq ->
              (case (ceq :: Maybe (c -> c -> Bool)) of {
                Nothing ->
                  (error :: forall a. String -> (() -> a) -> a)
                    "relcomp RBT_set DList_set: ceq3 = None"
                    (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
                Just _ ->
                  foldb (\ (x, y) ->
                          foldc (\ (ya, z) a ->
                                  (if eq y ya then inserta (x, z) a else a))
                            dxs1)
                    rbt3 bot_set;
              });
          });
      });
  });
relcomp (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set RBT_set: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set RBT_set: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
        Just c_b ->
          (case (ccompare :: Maybe (c -> c -> Ordera)) of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp RBT_set RBT_set: ccompare3 = None"
                (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
            Just _ ->
              foldb (\ (x, y) ->
                      foldb (\ (ya, z) a ->
                              (if not (equal_order (c_b y ya) Eqa) then a
                                else inserta (x, z) a))
                        rbt2)
                rbt1 bot_set;
          });
      });
  });

max_sls :: forall a. (Linorder a) => Semilattice_set a;
max_sls = Abs_semilattice_set max;

shows_lines :: forall a. (Showa a) => [a] -> [Prelude.Char] -> [Prelude.Char];
shows_lines = shows_sep (shows_prec zero_nat) shows_nl;

lp_monom :: Rat -> Nat -> Linear_poly;
lp_monom c x =
  LinearPoly (if equal_rat c zero_rat then fmempty else fmupd x c fmempty);

tcapRM2 ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> [(Term a b, Term a b)]) -> Term a b -> Gctxt a b;
tcapRM2 uu (Var uv) = GCHole;
tcapRM2 rm (Fun f ts) =
  let {
    h = GCFun f (map (tcapRM2 rm) ts);
    n = size_list ts;
  } in (if any (\ r -> matchb h (fst r)) (rm (f, n)) then GCHole else h);

tcapRM ::
  forall a b.
    (Eq a,
      Eq b) => Bool ->
                 ((a, Nat) -> [(Term a b, Term a b)]) -> Term a b -> Gctxt a b;
tcapRM nlv rm = (if nlv then tcapRM2 rm else (\ _ -> GCHole));

linear_term_impl ::
  forall a b. (Ceq a, Ccompare a) => Set a -> Term b a -> Maybe (Set a);
linear_term_impl xs (Var x) =
  (if member x xs then Nothing else Just (inserta x xs));
linear_term_impl xs (Fun uu []) = Just xs;
linear_term_impl xs (Fun f (t : ts)) =
  (case linear_term_impl xs t of {
    Nothing -> Nothing;
    Just ys -> linear_term_impl ys (Fun f ts);
  });

linear_term :: forall a b. (Ceq b, Ccompare b, Set_impl b) => Term a b -> Bool;
linear_term t = not (is_none (linear_term_impl bot_set t));

funposs_list :: forall a b. Term a b -> [Pos];
funposs_list (Var x) = [];
funposs_list (Fun f ss) =
  Empty :
    concatMap (\ (i, a) -> map (PCons i) a)
      (zip (upt zero_nat (size_list ss)) (map funposs_list ss));

ctxt_of_pos_term :: forall a b. Pos -> Term a b -> Ctxt a b;
ctxt_of_pos_term Empty t = Hole;
ctxt_of_pos_term (PCons i ps) (Fun f ts) =
  More f (take i ts) (ctxt_of_pos_term ps (nth ts i)) (drop (suc i) ts);

ctxt_apply_term :: forall a b. Ctxt a b -> Term a b -> Term a b;
ctxt_apply_term Hole s = s;
ctxt_apply_term (More f ss1 c ss2) s = Fun f (ss1 ++ ctxt_apply_term c s : ss2);

poss_list :: forall a b. Term a b -> [Pos];
poss_list (Var x) = [Empty];
poss_list (Fun f ss) =
  Empty :
    concatMap (\ (i, a) -> map (PCons i) a)
      (zip (upt zero_nat (size_list ss)) (map poss_list ss));

rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
rewrite r s =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ p ->
          (case match (subt_at s p) l of {
            Nothing -> [];
            Just sigma ->
              [ctxt_apply_term (ctxt_of_pos_term p s)
                 (subst_apply_term ra sigma)];
          }))
        (poss_list s))
    r;

hvf_term :: forall a b. (Eq a) => a -> Term a b -> Bool;
hvf_term a t = (case unapp a t of {
                 (Var _, ts) -> null ts;
                 (Fun _ us, ts) -> all (hvf_term a) (us ++ ts);
               });

max_list :: [Nat] -> Nat;
max_list [] = zero_nat;
max_list (x : xs) = max x (max_list xs);

rules ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       [(Term a [Prelude.Char], Term a [Prelude.Char])];
rules xml2name =
  xml_do ['r', 'u', 'l', 'e', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat (rule xml2name) xml_return);

num_children :: Xml -> Nat;
num_children (XML uu uv cs) = size_list cs;
num_children (XML_text uw) = zero_nat;

string2xml :: [Prelude.Char] -> Sum [Prelude.Char] Xml;
string2xml str =
  (case bindc (update_tokens remove_comments)
          (\ _ -> bindc parse_node (\ xml -> bindc eoi (\ _ -> returnb xml)))
          str
    of {
    Inl a -> Inl a;
    Inr (xml, _) -> Inr xml;
  });

string ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char]) [Lab a b];
string xml2name =
  xml_do ['s', 't', 'r', 'i', 'n', 'g']
    (xml_take_many_sub [] zero_nat Infinity_enat xml2name
      (\ a -> xml_return (id a)));

oc_srs ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char]) ([Lab a b], [Lab a b]);
oc_srs xml2name =
  xml_do
    ['o', 'v', 'e', 'r', 'l', 'a', 'p', 'C', 'l', 'o', 's', 'u', 'r', 'e', 'S',
      'R', 'S']
    (xml_take (string xml2name)
      (\ a -> xml_take (string xml2name) (\ b -> xml_return (a, b))));

rsteps ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Term a [Prelude.Char],
                         [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                                  Term a [Prelude.Char]))]);
rsteps xml2name =
  xml_do
    ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e']
    (xml_take
      (xml_do ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm']
        (xml_take (term xml2name) (\ x -> xml_return (id x))))
      (\ start ->
        xml_take_many_sub [] zero_nat Infinity_enat (rstep xml2name)
          (\ steps -> xml_return (start, steps))));

check :: forall a. Bool -> a -> Sum a ();
check b e = (if b then Inr () else Inl e);

degree :: Complexity_class -> Nat;
degree (Comp_Poly d) = d;

show_hint :: forall a. (Showa a) => Hint a -> [Prelude.Char];
show_hint Default = [' ', 'a', 'u', 't', 'o'];
show_hint (Base raw) = [' '] ++ shows_prec zero_nat raw [];
show_hint (Distribute i hints) =
  [' ', 'D', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', ' '] ++
    shows_prec_nat zero_nat i [] ++
      [' ', '['] ++ concatMap show_hint hints ++ [' ', ']'];
show_hint (LexStrict hints) =
  [' ', 'L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', '['] ++
    concatMap show_hint hints ++ [' ', ']'];
show_hint (LexWeak hints) =
  [' ', 'L', 'e', 'x', 'W', 'e', 'a', 'k', '['] ++
    concatMap show_hint hints ++ [' ', ']'];
show_hint (Erase i hint) =
  [' ', 'E', 'r', 'a', 's', 'e', ' '] ++
    shows_prec_nat zero_nat i [] ++ [' ', '['] ++ show_hint hint ++ [' ', ']'];

gen_image ::
  forall a b c d e f g h.
    (a -> (b -> Bool) -> (c -> d -> e) -> f -> g) ->
      f -> (h -> d -> e) -> (c -> h) -> a -> g;
gen_image it1 emp2 ins2 f s1 = it1 s1 (\ _ -> True) (\ x -> ins2 (f x)) emp2;

catch_errora :: forall a b c. Sum a b -> (a -> Sum c b) -> Sum c b;
catch_errora m f = (case m of {
                     Inl a -> f a;
                     Inr a -> Inr a;
                   });

check_no_edge ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ((a, a) -> Bool) -> a -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_edge ss g m n =
  check (not (g (m, n)))
    (shows_string ['e', 'd', 'g', 'e', ' ', 'f', 'r', 'o', 'm', ' '] .
      ss m . shows_string [' ', 't', 'o', ' '] . ss n);

forallM :: forall a b. (a -> Sum b ()) -> [a] -> Sum (a, b) ();
forallM f [] = Inr ();
forallM f (x : xs) =
  bindb (catch_errora (f x) (\ xa -> Inl (x, xa))) (\ _ -> forallM f xs);

check_edges ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ((a, a) -> Bool) ->
        [a] -> [a] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_edges ss g c d =
  catch_errora
    (forallM
      (\ n ->
        catch_errora (forallM (check_no_edge ss g n) d) (\ x -> Inl (snd x)))
      c)
    (\ x -> Inl (snd x));

mult :: forall a b. Partial_object_ext a (Monoid_ext a b) -> a -> a -> a;
mult (Partial_object_ext carrier (Monoid_ext mult one more)) = mult;

comp2eq :: forall a b. (a -> b -> Comp_res) -> a -> b -> Bool;
comp2eq cmp a b = (case cmp a b of {
                    LESS -> False;
                    EQUAL -> True;
                    GREATER -> False;
                  });

prec_ext ::
  forall a b. (Eq a) => (a -> Maybe (Nat, b)) -> a -> a -> (Bool, Bool);
prec_ext prwm =
  (\ f g ->
    (case prwm f of {
      Nothing -> (False, f == g);
      Just pf ->
        (case prwm g of {
          Nothing -> (True, True);
          Just pg ->
            (less_nat (fst pg) (fst pf), less_eq_nat (fst pg) (fst pf));
        });
    }));

assertion ::
  forall a b c d e. Lts_ext a b c d e -> d -> Formula (Term a (b, c));
assertion (Lts_ext initial transition_rules assertion more) = assertion;

map_of_total ::
  forall a b.
    (Ccompare a, Eq a,
      Mapping_impl a) => (a -> [Prelude.Char]) -> [(a, b)] -> a -> b;
map_of_total err xys =
  let {
    m = of_alist xys;
  } in (\ x ->
         (case lookupb m x of {
           Nothing ->
             (error :: forall a. String -> (() -> a) -> a) (err x)
               (\ _ -> the Nothing);
           Just y -> y;
         }));

transition_of ::
  forall a b c d e.
    (Ccompare e, Eq e, Mapping_impl e,
      Showa e) => Lts_impl a b c d e -> e -> Transition_rule a b c d;
transition_of pi =
  map_of_total
    (\ a ->
      ['a', 'c', 'c', 'e', 's', 's', ' ', 't', 'o', ' ', 'n', 'o', 'n', '-',
        'e', 'x', 'i', 's', 't', 'i', 'n', 'g', ' ', 't', 'r', 'a', 'n', 's',
        'i', 't', 'i', 'o', 'n', ' '] ++
        shows_prec zero_nat a [] ++
          ['\n', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 't', 'r',
            'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 's', ':', '\n'] ++
            shows_prec_list zero_nat (map fst (transitions_impl pi)) [])
    (transitions_impl pi);

matcha :: forall a b. (Term a b, Term a b) -> Term a b -> Bool;
matcha = (\ _ _ -> True);

fresh_strings_list ::
  [Prelude.Char] -> Nat -> [[Prelude.Char]] -> Nat -> [[Prelude.Char]];
fresh_strings_list name offset used n =
  take n
    (filter (\ s -> not (membera (remdups used) s))
      (map (\ i -> name ++ shows_prec_nat zero_nat (plus_nat i offset) [])
        (upt zero_nat (plus_nat n (size_list (remdups used))))));

fresh_string :: [Prelude.Char] -> [[Prelude.Char]] -> [Prelude.Char];
fresh_string pre = (\ s -> hda (fresh_strings_list pre one_nat s one_nat));

mapMa :: forall a b. (a -> Maybe b) -> [a] -> Maybe [b];
mapMa f [] = Just [];
mapMa f (x : xs) =
  bind (f x) (\ y -> bind (mapMa f xs) (\ ys -> Just (y : ys)));

equal_order_tag :: Order_tag -> Order_tag -> Bool;
equal_order_tag Lex Mul = False;
equal_order_tag Mul Lex = False;
equal_order_tag Mul Mul = True;
equal_order_tag Lex Lex = True;

any_nstri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> (Bool, b);
any_nstri_efficient_m f [] m = (False, m);
any_nstri_efficient_m f (a : asa) m =
  let {
    aa = f a m;
    (ab, b) = aa;
  } in let {
         (_, ns) = ab;
       } in (\ ma ->
              (if ns then (True, ma) else any_nstri_efficient_m f asa ma))
         b;

all_stri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> (Bool, b);
all_stri_efficient_m f [] m = (True, m);
all_stri_efficient_m f (a : asa) m =
  let {
    aa = f a m;
    (ab, b) = aa;
  } in let {
         (s, _) = ab;
       } in (\ ma -> (if s then all_stri_efficient_m f asa ma else (False, ma)))
         b;

filter_not_stri_efficient_m_aux ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ([a], b);
filter_not_stri_efficient_m_aux f [] bs m = (bs, m);
filter_not_stri_efficient_m_aux f (a : asa) bs m =
  let {
    b = f a m;
    (ba, c) = b;
  } in let {
         (s, _) = ba;
       } in (\ ma ->
              (if s then filter_not_stri_efficient_m_aux f asa bs ma
                else filter_not_stri_efficient_m_aux f asa (a : bs) ma))
         c;

filter_not_stri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> ([a], b);
filter_not_stri_efficient_m f asa m =
  let {
    a = filter_not_stri_efficient_m_aux f asa [] m;
    (ys, aa) = a;
  } in (reverse ys, aa);

mul_ext_efficient_m ::
  forall a b.
    (a -> a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ((Bool, Bool), b);
mul_ext_efficient_m f [] [] m = ((False, True), m);
mul_ext_efficient_m f [] (v : va) m = ((False, False), m);
mul_ext_efficient_m f (v : va) [] m = ((True, True), m);
mul_ext_efficient_m f (v : va) (y : ys) m =
  mul_ex_dom_efficient_m f (v : va) [] y ys m;

mul_ex_dom_efficient_m ::
  forall a b.
    (a -> a -> b -> ((Bool, Bool), b)) ->
      [a] -> [a] -> a -> [a] -> b -> ((Bool, Bool), b);
mul_ex_dom_efficient_m f [] xs y ys m = ((False, False), m);
mul_ex_dom_efficient_m f (x : xsa) xs y ys m =
  let {
    a = f x y m;
    (aa, b) = a;
  } in let {
         (s, ns) = aa;
       } in (\ ma ->
              (if s then let {
                           (ysa, m2) = filter_not_stri_efficient_m (f x) ys ma;
                           ab = mul_ext_efficient_m f (xsa ++ xs) ysa m2;
                           (ac, ba) = ab;
                         } in let {
                                (_, nsa) = ac;
                              } in (\ m3 ->
                                     (if nsa then ((True, True), m3)
                                       else mul_ex_dom_efficient_m f xsa
      (x : xs) y ys m3))
                                ba
                else (if ns
                       then let {
                              ab = mul_ext_efficient_m f (xsa ++ xs) ys ma;
                              (ac, ba) = ab;
                            } in let {
                                   (s2, ns2) = ac;
                                 } in (\ m4 ->
(if s2 then ((True, True), m4)
  else let {
         ad = mul_ex_dom_efficient_m f xsa (x : xs) y ys m4;
         (ae, bb) = ad;
       } in let {
              (s3, ns3) = ae;
            } in (\ m5 ->
                   (if s3 then ((True, True), m5)
                     else ((False, ns2 || ns3), m5)))
              bb))
                                   ba
                       else mul_ex_dom_efficient_m f xsa (x : xs) y ys ma)))
         b;

lex_ext_efficient_m ::
  forall a b.
    (a -> a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ((Bool, Bool), b);
lex_ext_efficient_m f [] [] m = ((False, True), m);
lex_ext_efficient_m f (uu : uv) [] m = ((True, True), m);
lex_ext_efficient_m f [] (uw : ux) m = ((False, False), m);
lex_ext_efficient_m f (a : asa) (b : bs) m =
  let {
    aa = f a b m;
    (ab, ba) = aa;
  } in let {
         (s, ns) = ab;
       } in (\ ma ->
              (if s then ((True, True), ma)
                else (if ns then lex_ext_efficient_m f asa bs ma
                       else ((False, False), ma))))
         ba;

lookupe :: forall a b c d. Memory_ext a b c d -> a -> b -> Maybe c;
lookupe (Memory_ext empty lookup store more) = lookup;

store :: forall a b c d. Memory_ext a b c d -> a -> (b, c) -> a;
store (Memory_ext empty lookup store more) = store;

diag_l :: forall a b. (a, b) -> ((a, a), b);
diag_l (a, b) = ((a, a), b);

rpo_efficient_m ::
  forall a b c.
    (Eq c) => Memory_ext a (Term b c, Term b c) (Bool, Bool) () ->
                ((b, Nat) -> (b, Nat) -> (Bool, Bool), (b, Nat) -> Bool) ->
                  ((b, Nat) -> Order_tag) ->
                    Term b c -> Term b c -> a -> ((Bool, Bool), a);
rpo_efficient_m model pr tag s t m =
  (case lookupe model m (s, t) of {
    Nothing ->
      let {
        (res, res_m) =
          (case (s, t) of {
            (Var x, Var y) -> ((False, x == y), m);
            (Var _, Fun g ts) -> ((False, null ts && snd pr (g, zero_nat)), m);
            (Fun _ ss, Var y) ->
              diag_l
                (any_nstri_efficient_m
                  (\ sa -> rpo_efficient_m model pr tag sa (Var y)) ss m);
            (Fun f ss, Fun g ts) ->
              (case any_nstri_efficient_m
                      (\ sa -> rpo_efficient_m model pr tag sa (Fun g ts)) ss m
                of {
                (True, ma) -> ((True, True), ma);
                (False, ma) ->
                  let {
                    maa = size_list ss;
                    n = size_list ts;
                  } in (case fst pr (f, maa) (g, n) of {
                         (prs, True) ->
                           (case all_stri_efficient_m
                                   (rpo_efficient_m model pr tag (Fun f ss)) ts
                                   ma
                             of {
                             (True, mb) ->
                               (if prs then ((True, True), mb)
                                 else let {
cf = tag (f, maa);
                                      } in
(if equal_order_tag cf (tag (g, n))
  then (if equal_order_tag cf Mul
         then mul_ext_efficient_m (rpo_efficient_m model pr tag) ss ts mb
         else lex_ext_efficient_m (rpo_efficient_m model pr tag) ss ts mb)
  else let {
         b = equal_nat n zero_nat;
       } in ((not (equal_nat maa zero_nat) && b, b), mb)));
                             (False, mb) -> ((False, False), mb);
                           });
                         (_, False) -> ((False, False), ma);
                       });
              });
          });
      } in (res, store model res_m ((s, t), res));
    Just v -> (v, m);
  });

emptyf :: forall a b c d. Memory_ext a b c d -> () -> a;
emptyf (Memory_ext empty lookup store more) = empty;

efficient_rpo_2 ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
efficient_rpo_2 pr tag p q =
  fst (rpo_efficient_m l2m pr tag p q (emptyf l2m ()));

rpo_unbounded_impl ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
rpo_unbounded_impl = efficient_rpo_2;

rpo_unbounded ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
rpo_unbounded = rpo_unbounded_impl;

converse ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Set (a, b) -> Set (b, a);
converse r = image (\ (x, y) -> (y, x)) r;

ctxt_compose :: forall a b. Ctxt a b -> Ctxt a b -> Ctxt a b;
ctxt_compose Hole d = d;
ctxt_compose (More f ss1 c ss2) d = More f ss1 (ctxt_compose c d) ss2;

sum_mset :: forall a. (Comm_monoid_add a) => Multiset a -> a;
sum_mset (Bag ms) = foldd (\ a n -> funpow n (plus a)) zerob ms;

funs_term_ms :: forall a b. (Eq a) => Term a b -> Multiset a;
funs_term_ms (Var x) = zero_multiset;
funs_term_ms (Fun f ts) =
  plus_multiset (add_mset f zero_multiset)
    (sum_mset (mset (map funs_term_ms ts)));

subt_at_ctxt :: forall a b. Ctxt a b -> Pos -> Ctxt a b;
subt_at_ctxt c Empty = c;
subt_at_ctxt (More f bef c aft) (PCons i p) = subt_at_ctxt c p;

the_Var :: forall a b. Term a b -> b;
the_Var (Var x1) = x1;

vars_term_ms :: forall a b. (Eq b) => Term a b -> Multiset b;
vars_term_ms (Var x) = add_mset x zero_multiset;
vars_term_ms (Fun f ts) = sum_mset (mset (map vars_term_ms ts));

in_poss :: forall a b. Pos -> Term a b -> Bool;
in_poss Empty uu = True;
in_poss (PCons i p) (Fun f ts) =
  less_nat i (size_list ts) && in_poss p (nth ts i);
in_poss (PCons i p) (Var uv) = False;

add_funs_term :: forall a b. Term a b -> [a] -> [a];
add_funs_term (Var uu) fs = fs;
add_funs_term (Fun f ts) fs = f : foldr add_funs_term ts fs;

add_funs_rule :: forall a b. (Term a b, Term a b) -> [a] -> [a];
add_funs_rule r fs = add_funs_term (fst r) (add_funs_term (snd r) fs);

funs_trs_list :: forall a b. [(Term a b, Term a b)] -> [a];
funs_trs_list trs = foldr add_funs_rule trs [];

instance_rule ::
  forall a b c.
    (Eq a, Eq b, Ccompare c, Eq c,
      Mapping_impl c) => (Term a b, Term a b) -> (Term a c, Term a c) -> Bool;
instance_rule lr st =
  not (is_none
        (match_list (\ _ -> fst lr) [(fst st, fst lr), (snd st, snd lr)]));

map_funs_rule ::
  forall a b c. (a -> b) -> (Term a c, Term a c) -> (Term b c, Term b c);
map_funs_rule fg lr =
  (map_term fg (\ x -> x) (fst lr), map_term fg (\ x -> x) (snd lr));

add_vars_rule :: forall a b. (Term a b, Term a b) -> [b] -> [b];
add_vars_rule r xs = add_vars_term (fst r) (add_vars_term (snd r) xs);

vars_trs_list :: forall a b. [(Term a b, Term a b)] -> [b];
vars_trs_list trs = foldr add_vars_rule trs [];

elem_list_to_rm ::
  forall a b. (Compare_order b) => (a -> b) -> [a] -> Rbt b [a];
elem_list_to_rm key (d : ds) = let {
                                 rm = elem_list_to_rm key ds;
                                 k = key d;
                               } in (case lookup rm k of {
                                      Nothing -> insert k [d] rm;
                                      Just dataa -> insert k (d : dataa) rm;
                                    });
elem_list_to_rm key [] = empty;

fun_of_map :: forall a b. (a -> Maybe b) -> b -> a -> b;
fun_of_map m d a = (case m a of {
                     Nothing -> d;
                     Just b -> b;
                   });

term_map :: forall a b. (Key a) => [Term a b] -> (a, Nat) -> [Term a b];
term_map ts = fun_of_map (lookup (elem_list_to_rm (the . root) ts)) [];

label_depth :: forall a b. Lab a b -> Nat;
label_depth (UnLab uu) = zero_nat;
label_depth (Lab f uv) = suc (label_depth f);
label_depth (FunLab f uw) = suc (label_depth f);
label_depth (Sharp f) = suc (label_depth f);

gen_label :: forall a b. Lab a b -> Nat -> Lab a b;
gen_label f n =
  (if equal_nat n zero_nat then f
    else FunLab (gen_label f (minus_nat n one_nat)) []);

fmap ::
  forall a b.
    (Eq a,
      Eq b) => Lab a b ->
                 Nat ->
                   [((Lab a b, Nat), [Lab a b])] -> Lab a b -> Nat -> Lab a b;
fmap a nn sml =
  let {
    m = suc (max_list (map label_depth (a : concatMap snd sml)));
  } in (\ f n -> (if (f, n) == (a, nn) then a else gen_label f m));

enum_vectors :: forall a b. [a] -> [b] -> [[(b, a)]];
enum_vectors c [] = [[]];
enum_vectors c (x : xs) =
  let {
    a = enum_vectors c xs;
  } in concatMap (\ vec -> map (\ ca -> (x, ca) : vec) c) a;

replace_impl :: forall a. (Eq a) => a -> [a] -> [a] -> [a];
replace_impl a bs m =
  (if membera m a then bs ++ filter (\ b -> not (b == a)) m else m);

doc_of_string :: [Prelude.Char] -> Sum [Prelude.Char] Xmldoc;
doc_of_string s = bindb (parse_doc s) (\ (doc, _) -> Inr doc);

special_map :: [Prelude.Char] -> Maybe [Prelude.Char];
special_map =
  map_of
    [(['q', 'u', 'o', 't'], ['\"']), (['#', '3', '4'], ['\"']),
      (['a', 'm', 'p'], ['&']), (['#', '3', '8'], ['&']),
      (['a', 'p', 'o', 's'], ['\'']), (['#', '3', '9'], ['\'']),
      (['l', 't'], ['<']), (['#', '6', '0'], ['<']), (['g', 't'], ['>']),
      (['#', '6', '2'], ['>'])];

pat_eqv_prf ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Pat_eqv_prf a [Prelude.Char]);
pat_eqv_prf xml2name =
  let {
    sub = substa xml2name;
  } in xml_do
         ['p', 'a', 't', 't', 'e', 'r', 'n', 'E', 'q', 'u', 'i', 'v', 'a', 'l',
           'e', 'n', 'c', 'e']
         (xml_take
           (xml_or
             (xml_do
               ['d', 'o', 'm', 'a', 'i', 'n', 'R', 'e', 'n', 'a', 'm', 'i', 'n',
                 'g']
               (xml_take sub (\ n -> xml_return (Pat_Dom_Renaming n))))
             (xml_or
               (xml_do ['i', 'r', 'r', 'e', 'l', 'e', 'v', 'a', 'n', 't']
                 (xml_take sub
                   (\ n ->
                     xml_take sub (\ n2 -> xml_return (Pat_Irrelevant n n2)))))
               (xml_do
                 ['s', 'i', 'm', 'p', 'l', 'i', 'f', 'i', 'c', 'a', 't', 'i',
                   'o', 'n']
                 (xml_take sub
                   (\ n ->
                     xml_take sub (\ n2 -> xml_return (Pat_Simplify n n2)))))))
           (\ x -> xml_return (id x)));

pat_term ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Term a [Prelude.Char],
                         ([([Prelude.Char], Term a [Prelude.Char])],
                           [([Prelude.Char], Term a [Prelude.Char])]));
pat_term xml2name =
  xml_do ['p', 'a', 't', 't', 'e', 'r', 'n', 'T', 'e', 'r', 'm']
    (xml_take (term xml2name)
      (\ t ->
        xml_take (substa xml2name)
          (\ s1 ->
            xml_take (substa xml2name) (\ s2 -> xml_return (t, (s1, s2))))));

pat_rule_prf ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Pat_rule_prf a [Prelude.Char]);
pat_rule_prf xml2name x =
  let {
    pat = pat_rule_prf xml2name;
    sub = substa xml2name;
    pt = pat_term xml2name;
    var = xml_text ['v', 'a', 'r'];
  } in xml_do ['p', 'a', 't', 't', 'e', 'r', 'n', 'R', 'u', 'l', 'e']
         (xml_take pt
           (\ _ ->
             xml_take pt
               (\ _ ->
                 xml_take
                   (xml_or
                     (xml_do
                       ['o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', 'R', 'u', 'l',
                         'e']
                       (xml_take (rule xml2name)
                         (\ r ->
                           xml_take (xml_bool ['i', 's', 'P', 'a', 'i', 'r'])
                             (\ b -> xml_return (Pat_OrigRule r b)))))
                     (xml_or
                       (xml_do
                         ['i', 'n', 'i', 't', 'i', 'a', 'l', 'P', 'u', 'm', 'p',
                           'i', 'n', 'g']
                         (xml_take pat
                           (\ a ->
                             xml_take sub
                               (\ b ->
                                 xml_take sub
                                   (\ c -> xml_return (Pat_InitPump a b c))))))
                       (xml_or
                         (xml_do
                           ['i', 'n', 'i', 't', 'i', 'a', 'l', 'P', 'u', 'm',
                             'p', 'i', 'n', 'g', 'C', 'o', 'n', 't', 'e', 'x',
                             't']
                           (xml_take pat
                             (\ a ->
                               xml_take sub
                                 (\ b ->
                                   xml_take pos
                                     (\ c ->
                                       xml_take var
 (\ d -> xml_return (Pat_InitPumpCtxt a b c d)))))))
                         (xml_or
                           (xml_do
                             ['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c',
                               'e']
                             (xml_take pat
                               (\ a ->
                                 xml_take
                                   (xml_or (xml_leaf ['l', 'e', 'f', 't'] True)
                                     (xml_leaf ['r', 'i', 'g', 'h', 't'] False))
                                   (\ b ->
                                     xml_take (pat_eqv_prf xml2name)
                                       (\ c -> xml_return (Pat_Equiv a b c))))))
                           (xml_or
                             (xml_do
                               ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g']
                               (xml_take pat
                                 (\ a ->
                                   xml_take pat
                                     (\ b ->
                                       xml_take pos
 (\ c -> xml_return (Pat_Narrow a b c))))))
                             (xml_or
                               (xml_do
                                 ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a',
                                   't', 'i', 'o', 'n']
                                 (xml_take pat
                                   (\ a ->
                                     xml_take sub
                                       (\ b ->
 xml_take
   (xml_or (xml_leaf ['b', 'a', 's', 'e'] Pat_Base)
     (xml_or (xml_leaf ['p', 'u', 'm', 'p', 'i', 'n', 'g'] Pat_Pump)
       (xml_leaf ['c', 'l', 'o', 's', 'i', 'n', 'g'] Pat_Close)))
   (\ c -> xml_return (Pat_Inst a b c))))))
                               (xml_or
                                 (xml_do
                                   ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a',
                                     't', 'i', 'o', 'n', 'P', 'u', 'm', 'p',
                                     'i', 'n', 'g']
                                   (xml_take pat
                                     (\ a ->
                                       xml_take
 (xml_nat ['p', 'o', 'w', 'e', 'r']) (\ b -> xml_return (Pat_Exp_Sigma a b)))))
                                 (xml_do
                                   ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g']
                                   (xml_take pat
                                     (\ a ->
                                       xml_take (rsteps xml2name)
 (\ b ->
   xml_take
     (xml_or (xml_leaf ['b', 'a', 's', 'e'] (Pat_Base, []))
       (xml_or
         (xml_do ['p', 'u', 'm', 'p', 'i', 'n', 'g']
           (xml_take var (\ v -> xml_return (Pat_Pump, v))))
         (xml_do ['c', 'l', 'o', 's', 'i', 'n', 'g']
           (xml_take var (\ v -> xml_return (Pat_Close, v))))))
     (\ (po, va) -> xml_return (Pat_Rewr a b po va)))))))))))))
                   xml_return)))
         x;

nonloop ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Non_loop_prf (Lab a b) [Prelude.Char]);
nonloop xml2name =
  xml_do ['n', 'o', 'n', 'L', 'o', 'o', 'p']
    (xml_take (pat_rule_prf xml2name)
      (\ a ->
        xml_take (substa xml2name)
          (\ b ->
            xml_take (substa xml2name)
              (\ c ->
                xml_take (xml_nat ['n', 'a', 't', 'u', 'r', 'a', 'l'])
                  (\ d ->
                    xml_take (xml_nat ['n', 'a', 't', 'u', 'r', 'a', 'l'])
                      (\ e ->
                        xml_take pos
                          (\ f -> xml_return (Non_loop_prf a b c d e f))))))));

eq_set ::
  forall a. (Card_UNIV a, Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
eq_set = set_eq;

choice :: forall a b. [Sum a b] -> Sum [a] b;
choice [] = Inl [];
choice (x : xs) =
  catch_errora x (\ e -> catch_errora (choice xs) (\ xa -> Inl (e : xa)));

gen_filter ::
  forall a b c d e f.
    (a -> (b -> Bool) -> (c -> d -> d) -> e -> f) ->
      e -> (c -> d -> d) -> (c -> Bool) -> a -> f;
gen_filter it1 emp2 ins2 p s1 =
  it1 s1 (\ _ -> True) (\ x s -> (if p x then ins2 x s else s)) emp2;

gt_term ::
  forall a b c d.
    (Eq a,
      Eq c) => Bool ->
                 Bool ->
                   (Maybe (a, Nat) -> Maybe (b, Nat) -> Bool) ->
                     ((a, Nat) -> [(Term a c, Term a c)]) ->
                       Term a c -> Term b d -> Bool;
gt_term nlv ne gt_fun rm s t =
  ne && let {
          root1 = root s;
          root2 = root t;
        } in (is_Var s ||
               (is_Var t ||
                 (gt_fun Nothing Nothing ||
                   (gt_fun root1 root2 ||
                     (gt_fun root1 Nothing || gt_fun Nothing root2))))) &&
               (if nlv
                 then (case root1 of {
                        Nothing -> True;
                        Just fn ->
                          any (\ r -> matchb (tcapRM nlv rm s) (fst r)) (rm fn);
                      })
                 else True);

rd_impl ::
  forall a b c.
    (Eq a) => (Term a b -> Term a c -> Bool) ->
                (Term a b, Term a c) -> [(Term a b, Term a c)];
rd_impl gt (Fun f ss, Fun g ts) =
  (if f == g &&
        equal_nat (size_list ss) (size_list ts) &&
          not (gt (Fun f ss) (Fun g ts))
    then concatMap (rd_impl gt) (zip ss ts) else [(Fun f ss, Fun g ts)]);
rd_impl uu (Var v, t) = [(Var v, t)];
rd_impl uu (s, Var v) = [(s, Var v)];

dflt_cmp ::
  forall a b. (a -> b -> Bool) -> (a -> b -> Bool) -> a -> b -> Comp_res;
dflt_cmp le lt a b =
  (if lt a b then LESS else (if le a b then EQUAL else GREATER));

nodes_lts_impl :: forall a b c d e. (Eq d) => Lts_impl a b c d e -> [d];
nodes_lts_impl pi =
  remdups
    (map (source . snd) (transitions_impl pi) ++
      map (target . snd) (transitions_impl pi));

rec_list :: forall a b. a -> (b -> [b] -> a -> a) -> [b] -> a;
rec_list f1 f2 [] = f1;
rec_list f1 f2 (x21 : x22) = f2 x21 x22 (rec_list f1 f2 x22);

product_lists :: forall a. [[a]] -> [[a]];
product_lists [] = [[]];
product_lists (xs : xss) =
  concatMap (\ x -> map (\ a -> x : a) (product_lists xss)) xs;

min_list :: forall a. (Linorder a) => [a] -> a;
min_list [x] = x;
min_list (x : v : va) = min x (min_list (v : va));

height :: forall a. (a, Nat) -> Nat;
height (f, h) = h;

mat_of_cols :: forall a. Nat -> [Vec a] -> Mat a;
mat_of_cols n cs = mat n (size_list cs) (\ (i, j) -> vec_index (nth cs j) i);

vec_of_list_impl :: forall a. [a] -> Vec_impl a;
vec_of_list_impl xa = Abs_vec_impl (size_list xa, IArray.listIArray xa);

vec_of_list :: forall a. [a] -> Vec a;
vec_of_list v = Vec_impl (vec_of_list_impl v);

shows_monom ::
  forall a. (Showa a) => [(a, Nat)] -> [Prelude.Char] -> [Prelude.Char];
shows_monom [(x, p)] =
  (if equal_nat p one_nat then shows_prec zero_nat x
    else shows_prec zero_nat x .
           shows_string ['^'] . shows_prec_nat zero_nat p);
shows_monom ((x, p) : v : va) =
  (if equal_nat p one_nat then shows_prec zero_nat x
    else shows_prec zero_nat x .
           shows_string ['^'] . shows_prec_nat zero_nat p) .
    shows_string ['*'] . shows_monom (v : va);
shows_monom [] = shows_string ['1'];

shows_poly ::
  forall a b.
    (Showa a, One b, Eq b,
      Showa b) => [([(a, Nat)], b)] -> [Prelude.Char] -> [Prelude.Char];
shows_poly [] = shows_string ['0'];
shows_poly ((m, c) : p) =
  (if c == onea then shows_monom m
    else (if null m then shows_prec zero_nat c
           else shows_prec zero_nat c . shows_string ['*'] . shows_monom m)) .
    (if null p then shows_string []
      else shows_string [' ', '+', ' '] . shows_poly p);

check_poly_ge ::
  forall a b.
    (Eq a,
      Ordered_semiring_0a b) => [([(a, Nat)], b)] -> [([(a, Nat)], b)] -> Bool;
check_poly_ge [] q = all (\ (_, d) -> less_eq d zerob) q;
check_poly_ge ((m, c) : p) q =
  (case extract (\ nd -> eq_monom (fst nd) m) q of {
    Nothing -> less_eq zerob c && check_poly_ge p q;
    Just (q1, ((_, d), q2)) -> less_eq d c && check_poly_ge p (q1 ++ q2);
  });

check_poly_gt ::
  forall a b.
    (Ordered_semiring_0a a,
      Eq b) => (a -> a -> Bool) ->
                 [([(b, Nat)], a)] -> [([(b, Nat)], a)] -> Bool;
check_poly_gt gt p q = let {
                         (a1, p1) = poly_split [] p;
                         (b1, q1) = poly_split [] q;
                       } in gt a1 b1 && check_poly_ge p1 q1;

monom_mult :: forall a. (Eq a) => [(a, Nat)] -> [(a, Nat)] -> [(a, Nat)];
monom_mult [] n = n;
monom_mult ((x, p) : m) n =
  (case extract (\ yq -> fst yq == x) n of {
    Nothing -> (x, p) : monom_mult m n;
    Just (n1, ((_, q), n2)) -> (x, plus_nat p q) : monom_mult m (n1 ++ n2);
  });

monom_mult_poly ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => ([(a, Nat)], b) ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
monom_mult_poly uu [] = [];
monom_mult_poly (ma, c) ((m, d) : p) =
  (if times c d == zerob then monom_mult_poly (ma, c) p
    else (monom_mult ma m, times c d) : monom_mult_poly (ma, c) p);

poly_add ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
poly_add [] q = q;
poly_add ((m, c) : p) q =
  (case extract (\ mc -> eq_monom (fst mc) m) q of {
    Nothing -> (m, c) : poly_add p q;
    Just (q1, ((_, d), q2)) ->
      (if plus c d == zerob then poly_add p (q1 ++ q2)
        else (m, plus c d) : poly_add p (q1 ++ q2));
  });

poly_mult ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
poly_mult [] q = [];
poly_mult (mc : p) q = poly_add (monom_mult_poly mc q) (poly_mult p q);

one_poly :: forall a b. (Semiring_1 b) => [([(a, Nat)], b)];
one_poly = [([], onea)];

poly_power ::
  forall a b.
    (Eq a, Eq b,
      Comm_semiring_1 b) => [([(a, Nat)], b)] -> Nat -> [([(a, Nat)], b)];
poly_power uu n =
  (if equal_nat n zero_nat then one_poly
    else poly_mult uu (poly_power uu (minus_nat n one_nat)));

monom_subst ::
  forall a b c.
    (Eq b, Eq c,
      Comm_semiring_1 c) => (a -> [([(b, Nat)], c)]) ->
                              [(a, Nat)] -> [([(b, Nat)], c)];
monom_subst sigma [] = one_poly;
monom_subst sigma ((x, p) : m) =
  poly_mult (poly_power (sigma x) p) (monom_subst sigma m);

zero_poly :: forall a b. [([(a, Nat)], b)];
zero_poly = [];

poly_subst ::
  forall a b c.
    (Eq b, Eq c,
      Comm_semiring_1 c) => (a -> [([(b, Nat)], c)]) ->
                              [([(a, Nat)], c)] -> [([(b, Nat)], c)];
poly_subst sigma [] = zero_poly;
poly_subst sigma ((m, c) : p) =
  poly_add (poly_mult [([], c)] (monom_subst sigma m)) (poly_subst sigma p);

eval_term ::
  forall a b c.
    (Eq b, Poly_carrier b,
      Eq c) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                 Term a c -> [([(c, Nat)], b)];
eval_term uu (Var x) = [([(x, one_nat)], onea)];
eval_term i (Fun f ts) =
  let {
    ps = map (eval_term i) ts;
    n = size_list ts;
  } in poly_subst (\ ia -> (if less_nat ia n then nth ps ia else zero_poly))
         (i (f, n));

check_s ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Showa b, Eq c,
      Showa c) => (a -> a -> Bool) ->
                    ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                      (Term b c, Term b c) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_s gt i =
  (\ (s, t) ->
    let {
      p = eval_term i s;
      q = eval_term i t;
    } in check (check_poly_gt gt p q)
           (shows_string
              ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
                'u', 'r', 'e', ' '] .
             shows_prec_term zero_nat s .
               shows_string [' ', '>', ' '] .
                 shows_prec_term zero_nat t .
                   shows_string
                     [' ', 's', 'i', 'n', 'c', 'e', ' ', 'w', 'e', ' '] .
                     shows_nl .
                       shows_string
                         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e',
                           'n', 's', 'u', 'r', 'e', ' '] .
                         shows_poly p .
                           shows_string [' ', '>', ' '] . shows_poly q));

shows_rpo_repr ::
  forall a.
    (Showa a) => [((a, Nat), (Nat, Order_tag))] ->
                   [Prelude.Char] -> [Prelude.Char];
shows_rpo_repr prs =
  ((((((((((shows_prec_list zero_nat
              ['R', 'P', 'O', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'e', ' ',
                'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'p', 'r', 'e',
                'c', 'e', 'd', 'e', 'n', 'c', 'e'] .
             shows_nl) .
            foldr (\ (a, b) ->
                    let {
                      (f, n) = a;
                    } in (\ (pr, _) ->
                           (((((shows_prec_list zero_nat
                                  ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c',
                                    'e', '('] .
                                 shows_prec zero_nat f) .
                                shows_prec_list zero_nat ['[']) .
                               shows_prec_nat zero_nat n) .
                              shows_prec_list zero_nat
                                [']', ')', ' ', '=', ' ']) .
                             shows_prec_nat zero_nat pr) .
                             shows_nl)
                      b)
              prs) .
           shows_nl) .
          shows_prec_list zero_nat
            ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', '(', '_', ')',
              ' ', '=', ' ', '0']) .
         shows_nl) .
        shows_prec_list zero_nat
          ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w',
            'i', 'n', 'g', ' ', 's', 't', 'a', 't', 'u', 's']) .
       shows_nl) .
      foldr (\ (a, b) ->
              let {
                (f, n) = a;
              } in (\ (_, s) ->
                     (((((shows_prec_list zero_nat
                            ['s', 't', 'a', 't', 'u', 's', '('] .
                           shows_prec zero_nat f) .
                          shows_prec_list zero_nat ['[']) .
                         shows_prec_nat zero_nat n) .
                        shows_prec_list zero_nat [']', ')', ' ', '=', ' ']) .
                       shows_prec_list zero_nat (case s of {
          Lex -> ['l', 'e', 'x'];
          Mul -> ['m', 'u', 'l'];
        })) .
                       shows_nl)
                b)
        prs) .
     shows_nl) .
    shows_prec_list zero_nat
      ['s', 't', 'a', 't', 'u', 's', '(', '_', ')', ' ', '=', ' ', 'l', 'e',
        'x']) .
    shows_nl;

scnp_af_to_af ::
  forall a.
    ((a, Nat) -> [(Nat, Nat)]) -> ((a, Nat) -> Set Nat) -> (a, Nat) -> Set Nat;
scnp_af_to_af pia pi =
  (\ (f, n) ->
    let {
      is = map fst (pia (f, n));
    } in (if any (less_eq_nat n) is then sup_set (pi (f, n)) (set is)
           else set is));

semilattice_set_apply :: forall a. Semilattice_set a -> a -> a -> a;
semilattice_set_apply (Abs_semilattice_set x) = x;

set_fold1 ::
  forall a. (Ceq a, Ccompare a, Lattice a) => Semilattice_set a -> Set a -> a;
set_fold1 f (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold1 RBT_set: ccompare = None" (\ _ -> set_fold1 f (RBT_set rbt));
    Just _ ->
      (if is_emptya rbt
        then (error :: forall a. String -> (() -> a) -> a)
               "set_fold1 RBT_set: empty set" (\ _ -> set_fold1 f (RBT_set rbt))
        else fold1 (semilattice_set_apply f) rbt);
  });
set_fold1 f (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold1 DList_set: ceq = None" (\ _ -> set_fold1 f (DList_set dxs));
    Just _ ->
      (if nulla dxs
        then (error :: forall a. String -> (() -> a) -> a)
               "set_fold1 DList_set: empty set"
               (\ _ -> set_fold1 f (DList_set dxs))
        else foldc (semilattice_set_apply f) (tl dxs) (hd dxs));
  });
set_fold1 f (Set_Monad (x : xs)) = fold (semilattice_set_apply f) xs x;
set_fold1 f (Collect_set p) =
  (error :: forall a. String -> (() -> a) -> a) "set_fold1: Collect_set"
    (\ _ -> set_fold1 f (Collect_set p));
set_fold1 f (Complement a) =
  (error :: forall a. String -> (() -> a) -> a) "set_fold1: Complement"
    (\ _ -> set_fold1 f (Complement a));

projr :: forall a b. Sum a b -> b;
projr (Inr x2) = x2;

rec_term ::
  forall a b c. (a -> b) -> (c -> [(Term c a, b)] -> b) -> Term c a -> b;
rec_term f1 f2 (Var x1) = f1 x1;
rec_term f1 f2 (Fun x21 x22) =
  f2 x21 (map (\ term -> (term, rec_term f1 f2 term)) x22);

mk_subst_domain ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)];
mk_subst_domain sigma =
  let {
    tau = mk_subst Var sigma;
  } in filter (\ (x, t) -> not (equal_term (Var x) t))
         (map (\ x -> (x, tau x)) (remdups (map fst sigma)));

subst_eq ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> Bool;
subst_eq sigma tau = let {
                       sigmaa = mk_subst_domain sigma;
                       taua = mk_subst_domain tau;
                     } in set_eq (set sigmaa) (set taua);

full_af :: forall a. (a, Nat) -> Set Nat;
full_af fn = set (upt zero_nat (snd fn));

add_funas_term :: forall a b. Term a b -> [(a, Nat)] -> [(a, Nat)];
add_funas_term (Var uu) fs = fs;
add_funas_term (Fun f ts) fs = (f, size_list ts) : foldr add_funas_term ts fs;

add_funas_rule :: forall a b. (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
add_funas_rule r fs = add_funas_term (fst r) (add_funas_term (snd r) fs);

funas_trs_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
funas_trs_list trs = foldr add_funas_rule trs [];

funs_rule_list :: forall a b. (Term a b, Term a b) -> [a];
funs_rule_list r = add_funs_rule r [];

vars_rule_list :: forall a b. (Term a b, Term a b) -> [b];
vars_rule_list r = add_vars_rule r [];

supteq_list :: forall a b. Term a b -> [Term a b];
supteq_list (Var x) = [Var x];
supteq_list (Fun f ts) = Fun f ts : concatMap supteq_list ts;

is_NF_main ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool -> ((a, Nat) -> [Term a b]) -> Term a b -> Bool;
is_NF_main var_cond r_empty m =
  (if var_cond then (\ _ -> False)
    else (if r_empty then (\ _ -> True)
           else (\ t ->
                  all (\ u ->
                        (if not (is_Var u)
                          then all (\ l -> not (matches u l)) (m (the (root u)))
                          else True))
                    (supteq_list t))));

is_NF_trs ::
  forall a b c.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, c)] -> Term a b -> Bool;
is_NF_trs r =
  is_NF_main (any (\ ra -> is_Var (fst ra)) r) (null r) (term_map (map fst r));

apply_args :: forall a b. a -> Term a b -> [Term a b] -> Term a b;
apply_args a t [] = t;
apply_args a t (s : ss) = apply_args a (Fun a [t, s]) ss;

get_symbol :: forall a. (a -> Nat -> [a]) -> a -> Nat -> Nat -> a;
get_symbol sm f n i = nth (sm f n) i;

strategy_of_string ::
  forall a b c d.
    [Prelude.Char] ->
      ([Xml],
        ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) (Sum (Strategy a b) (Fp_strategy c d));
strategy_of_string str =
  (if str == ['F', 'U', 'L', 'L'] then xml_return (Inl No_Strategy)
    else (if str == ['I', 'N', 'N', 'E', 'R', 'M', 'O', 'S', 'T']
           then xml_return (Inl Innermost)
           else (if str == ['O', 'U', 'T', 'E', 'R', 'M', 'O', 'S', 'T']
                  then xml_return (Inr Outermost)
                  else xml_error
                         (['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 's', 't',
                            'r', 'a', 't', 'e', 'g', 'y', ' ', '\"'] ++
                           str ++ ['\"']))));

signature_to_AC ::
  forall a b. (Showa a) => [a] -> [a] -> [(a, (b, (Bool, Bool)))] -> ([a], [a]);
signature_to_AC asa cs [] = (asa, cs);
signature_to_AC asa cs (fnac : sig) =
  let {
    (f, a) = fnac;
    (_, aa) = a;
    (ab, c) = aa;
  } in signature_to_AC (if ab then f : asa else asa) (if c then f : cs else cs)
         sig;

xml_take_attribute ::
  forall a.
    [Prelude.Char] ->
      ([Prelude.Char] ->
        ([Xml],
          ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) a) ->
        ([Xml],
          ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) a;
xml_take_attribute att p xs =
  let {
    (xmls, (atts, (allow, (cands, pos)))) = xs;
  } in (case pick_up [] att atts of {
         Nothing ->
           xml_error
             (['a', 't', 't', 'r', 'i', 'b', 'u', 't', 'e', ' ', '\"'] ++
               att ++ ['\"', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'u', 'n', 'd'])
             xs;
         Just (v, rest) -> p v (xmls, (rest, (allow, (cands, pos))));
       });

signature ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) [(a, (Nat, (Bool, Bool)))];
signature xml2name =
  xml_do ['s', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do ['f', 'u', 'n', 'c', 's', 'y', 'm']
        (xml_take xml2name
          (\ name ->
            xml_take (xml_nat ['a', 'r', 'i', 't', 'y'])
              (\ arity ->
                xml_take_optional (xml_text ['t', 'h', 'e', 'o', 'r', 'y'])
                  (\ a ->
                    (case a of {
                      Nothing -> xml_return (name, (arity, (False, False)));
                      Just th ->
                        (if th == ['A']
                          then (if equal_nat arity
                                     (nat_of_integer (2 :: Integer))
                                 then xml_return (name, (arity, (True, False)))
                                 else xml_error
(['w', 'r', 'o', 'n', 'g', ' ', 'a', 'r', 'i', 't', 'y', ' '] ++
  shows_prec_nat zero_nat arity [] ++
    [' ', 'f', 'o', 'r', ' ', 'a', 's', 's', 'o', 'c', 'i', 'a', 't', 'i', 'v',
      'e', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ', '\"'] ++
      shows_prec zero_nat name [] ++ ['\"']))
                          else (if th == ['A', 'C']
                                 then (if equal_nat arity
    (nat_of_integer (2 :: Integer))
then xml_return (name, (arity, (True, True)))
else xml_error
       (['w', 'r', 'o', 'n', 'g', ' ', 'a', 'r', 'i', 't', 'y', ' '] ++
         shows_prec_nat zero_nat arity [] ++
           [' ', 'f', 'o', 'r', ' ', 'A', 'C', ' ', 's', 'y', 'm', 'b', 'o',
             'l', ' ', '\"'] ++
             shows_prec zero_nat name [] ++ ['\"']))
                                 else (if th == ['C']
then (if equal_nat arity (nat_of_integer (2 :: Integer))
       then xml_return (name, (arity, (False, True)))
       else xml_error
              (['w', 'r', 'o', 'n', 'g', ' ', 'a', 'r', 'i', 't', 'y', ' '] ++
                shows_prec_nat zero_nat arity [] ++
                  [' ', 'f', 'o', 'r', ' ', 'c', 'o', 'm', 'm', 'u', 't', 'a',
                    't', 'i', 'v', 'e', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ',
                    '\"'] ++
                    shows_prec zero_nat name [] ++ ['\"']))
else xml_error
       (['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 't', 'h', 'e', 'o', 'r', 'y',
          ' ', '\"'] ++
         th ++ ['\"']))));
                    }))))))
      xml_return);

problem ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Input a [Prelude.Char]);
problem xml2name =
  xml_do ['p', 'r', 'o', 'b', 'l', 'e', 'm']
    (xml_take_attribute ['t', 'y', 'p', 'e']
      (\ _ ->
        xml_take
          (xml_do ['t', 'r', 's']
            (xml_take
              (xml_do ['r', 'u', 'l', 'e', 's']
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (crule xml2name ['r', 'u', 'l', 'e'])
                  (\ crules ->
                    xml_take_default []
                      (xml_do ['r', 'e', 'l', 'r', 'u', 'l', 'e', 's']
                        (xml_take_many_sub [] zero_nat Infinity_enat
                          (rule xml2name) xml_return))
                      (\ rel -> xml_return (crules, rel)))))
              (\ (crules, rel) ->
                xml_take (signature xml2name)
                  (\ sig ->
                    let {
                      a = signature_to_AC [] [] sig;
                      (aa, c) = a;
                    } in xml_take_optional
                           (xml_do ['c', 'o', 'm', 'm', 'e', 'n', 't']
                             (xml_take_many_sub [] zero_nat Infinity_enat
                               (\ x -> Inr (fst x)) (\ _ -> xml_return ())))
                           (\ _ ->
                             xml_take_optional
                               (xml_do
                                 ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                   't', 'y', 'p', 'e']
                                 (xml_take_many_sub [] zero_nat Infinity_enat
                                   (\ x -> Inr (fst x)) (\ _ -> xml_return ())))
                               (\ _ -> xml_return (crules, (rel, (aa, c)))))))))
          (\ (crules, a) ->
            let {
              (rel, aa) = a;
              (ab, c) = aa;
            } in xml_take
                   (xml_change
                     (xml_text ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'])
                     strategy_of_string)
                   (\ strat ->
                     xml_take_default Full
                       (xml_do ['s', 't', 'a', 'r', 't', 't', 'e', 'r', 'm']
                         (xml_take
                           (xml_or
                             (xml_do
                               ['c', 'o', 'n', 's', 't', 'r', 'u', 'c', 't',
                                 'o', 'r', '-', 'b', 'a', 's', 'e', 'd']
                               (xml_return Constructor_Based))
                             (xml_do ['f', 'u', 'l', 'l'] (xml_return Full)))
                           xml_return))
                       (\ start ->
                         xml_take_optional
                           (xml_do ['s', 't', 'a', 't', 'u', 's']
                             (xml_take_many_sub [] zero_nat Infinity_enat
                               (\ x -> Inr (fst x)) (\ _ -> xml_return ())))
                           (\ _ ->
                             xml_take_optional
                               (xml_do
                                 ['m', 'e', 't', 'a', 'i', 'n', 'f', 'o', 'r',
                                   'm', 'a', 't', 'i', 'o', 'n']
                                 (xml_take_many_sub [] zero_nat Infinity_enat
                                   (\ x -> Inr (fst x)) (\ _ -> xml_return ())))
                               (\ _ ->
                                 let {
                                   relative = not (null rel);
                                   (conditional, r) =
                                     (if all (\ (_, ac) -> null ac) crules
                                       then (False, map fst crules)
                                       else (True, []));
                                   equational = not (null ab) || not (null c);
                                 } in (case
(conditional, (equational, (relative, (strat, start)))) of {
(True, (True, _)) ->
  xml_error
    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'c', 'o', 'n', 'd',
      'i', 't', 'i', 'o', 'n', 'a', 'l', ' ', 's', 'y', 's', 't', 'e', 'm'];
(True, (False, (True, _))) ->
  xml_error
    ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'c', 'o', 'n', 'd', 'i', 't',
      'i', 'o', 'n', 'a', 'l', ' ', 's', 'y', 's', 't', 'e', 'm'];
(True, (False, (False, (Inl No_Strategy, Full)))) ->
  xml_return (CTRS_input crules);
(True, (False, (False, (Inl No_Strategy, Constructor_Based)))) ->
  xml_error
    ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'o', 'm',
      'b', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
(True, (False, (False, (Inl Innermost, _)))) ->
  xml_error
    ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'o', 'm',
      'b', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
(True, (False, (False, (Inl (Innermost_Q _), _)))) ->
  xml_error
    ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'o', 'm',
      'b', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
(True, (False, (False, (Inr _, _)))) ->
  xml_error
    ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'o', 'm',
      'b', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
(False, (True, (True, _))) ->
  xml_error
    ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'e', 'q', 'u', 'a', 't', 'i',
      'o', 'n', 'a', 'l', ' ', 's', 'y', 's', 't', 'e', 'm'];
(False, (True, (False, (Inl No_Strategy, Full)))) ->
  xml_return (AC_input r ab c);
(False, (True, (False, (Inl No_Strategy, Constructor_Based)))) ->
  xml_error
    ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'o', 'm',
      'b', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
(False, (True, (False, (Inl Innermost, _)))) ->
  xml_error
    ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'o', 'm',
      'b', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
(False, (True, (False, (Inl (Innermost_Q _), _)))) ->
  xml_error
    ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'o', 'm',
      'b', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
(False, (True, (False, (Inr _, _)))) ->
  xml_error
    ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'o', 'm',
      'b', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
(False, (False, (True, (Inl istrat, _)))) ->
  xml_return (Inn_TRS_input istrat r rel start);
(False, (False, (True, (Inr _, _)))) ->
  xml_error
    ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'o', 'm',
      'b', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
(False, (False, (False, (Inl istrat, _)))) ->
  xml_return (Inn_TRS_input istrat r rel start);
(False, (False, (False, (Inr fpstrat, Full)))) ->
  xml_return (FP_TRS_input fpstrat r);
(False, (False, (False, (Inr _, Constructor_Based)))) ->
  xml_error
    ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'c', 'o', 'm',
      'b', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
                                      }))))))));

symbols ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   [Prelude.Char] ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) [(a, Nat)];
symbols xml2name tagname =
  xml_do tagname
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do ['s', 'y', 'm', 'b', 'o', 'l']
        (xml_take xml2name
          (\ a ->
            xml_take (xml_nat ['a', 'r', 'i', 't', 'y'])
              (\ b -> xml_return (a, b)))))
      xml_return);

map_xml_text :: ([Prelude.Char] -> [Prelude.Char]) -> Xml -> Xml;
map_xml_text f (XML t asa cs) = XML t asa (map (map_xml_text f) cs);
map_xml_text f (XML_text txt) = XML_text (f txt);

orig_term :: forall a b. (a -> Maybe b) -> Term a b -> Term a b;
orig_term m (Var x) = Var x;
orig_term m (Fun f []) = (case m f of {
                           Nothing -> Fun f [];
                           Just a -> Var a;
                         });
orig_term m (Fun f (v : va)) = Fun f (map (orig_term m) (v : va));

rep_afs :: forall a. Afs a -> ((a, Nat) -> Af_entry, Set (a, Nat));
rep_afs (Abs_afs x) = x;

afsa :: forall a. Afs a -> (a, Nat) -> Af_entry;
afsa xa = fst (rep_afs xa);

sum_lpoly ::
  forall a.
    Partial_object_ext a (Monoid_ext a (Ring_ext a ())) -> [a] -> [a] -> [a];
sum_lpoly c [] ys = ys;
sum_lpoly c (v : va) [] = v : va;
sum_lpoly c (x : xs) (y : ys) = add c x y : sum_lpoly c xs ys;

lpoly_of ::
  forall a.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a ())) ->
                Tpoly Nat a -> Sum_bot [Prelude.Char] (a, [a]);
lpoly_of c (PNum i) = returna (i, []);
lpoly_of c (PVar x) = returna (zero c, replicate x (zero c) ++ [one c]);
lpoly_of c (PSum []) = returna (zero c, []);
lpoly_of c (PSum (p : ps)) =
  binda (lpoly_of c p)
    (\ (cp, ncp) ->
      binda (lpoly_of c (PSum ps))
        (\ (cq, ncq) -> returna (add c cp cq, sum_lpoly c ncp ncq)));
lpoly_of c (PMult []) = returna (one c, []);
lpoly_of c (PMult (p : ps)) =
  binda (lpoly_of c p)
    (\ (cp, ncp) ->
      binda (lpoly_of c (PMult ps))
        (\ (cq, ncq) ->
          (if all (\ a -> zero c == a) ncp
            then returna (mult c cp cq, map (mult c cp) ncq)
            else (if all (\ a -> zero c == a) ncq
                   then returna (mult c cp cq, map (\ x -> mult c x cq) ncp)
                   else errora
                          ['c', 'a', 'n', 'n', 'o', 't', ' ', 't', 'r', 'a',
                            'n', 's', 'f', 'o', 'r', 'm', ' ', 'n', 'o', 'n',
                            '-', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'p', 'o',
                            'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 't',
                            'o', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'p',
                            'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']))));

renaming ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) [(a, a)];
renaming xml2name =
  xml_do ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', 'E', 'n', 't', 'r', 'y']
        (xml_take xml2name
          (\ a -> xml_take xml2name (\ b -> xml_return (a, b)))))
      xml_return);

subset ::
  forall a. (Card_UNIV a, Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
subset = subset_eq;

mat_scalar_mult :: forall a. (Times a) => a -> Mat a -> Mat a;
mat_scalar_mult aa a = mat_map (times aa) a;

char_poly_matrix ::
  forall a.
    (Eq a, Comm_ring_1 a, Semiring_no_zero_divisors a) => Mat a -> Mat (Poly a);
char_poly_matrix a =
  mat_add
    (mat_scalar_mult (pCons zerob (pCons onea zero_polya))
      (mat_one (mat_dim_row a)))
    (mat_map (\ aa -> pCons (uminus aa) zero_polya) a);

char_poly :: forall a. (Eq a, Idom_divide a) => Mat a -> Poly a;
char_poly a = det (char_poly_matrix a);

existsM :: forall a b. (a -> Sum b ()) -> [a] -> Sum [b] ();
existsM f [] = Inl [];
existsM f (x : xs) =
  catch_errora (f x)
    (\ e -> catch_errora (existsM f xs) (\ xa -> Inl (e : xa)));

is_neg_atom :: forall a. Formula a -> Bool;
is_neg_atom (NegAtom uu) = True;
is_neg_atom (Atom v) = False;
is_neg_atom (Conjunction v) = False;
is_neg_atom (Disjunction v) = False;

gen_isEmpty :: forall a b c. (a -> (b -> Bool) -> c) -> a -> c;
gen_isEmpty ball m = ball m (\ _ -> False);

gen_isEmptya :: forall a b. (a -> (b -> Bool) -> Bool) -> a -> Bool;
gen_isEmptya ball s = ball s (\ _ -> False);

nonreach ::
  forall a b c.
    (Eq a) => (Term a b -> Term a c -> Bool) -> Term a b -> Term a c -> Bool;
nonreach gt s t =
  (case (s, t) of {
    (Var _, _) -> False;
    (Fun _ _, Var _) -> False;
    (Fun f ss, Fun g ts) ->
      not ((f, size_list ss) == (g, size_list ts)) && not (gt s t);
  });

weight ::
  forall a b.
    ((a, Nat) -> Nat) -> Nat -> ((a, Nat) -> Nat -> Nat) -> Term a b -> Nat;
weight w w0 scf (Fun f ts) =
  let {
    n = size_list ts;
    scff = scf (f, n);
  } in plus_nat (w (f, n))
         (sum_list
           (map (\ (ti, i) -> times_nat (weight w w0 scf ti) (scff i))
             (zip ts (upt zero_nat n))));
weight w w0 scf (Var x) = w0;

kbo_impl ::
  forall a b.
    (Eq b) => ((a, Nat) -> Nat) ->
                Nat ->
                  ((a, Nat) -> (a, Nat) -> (Bool, Bool)) ->
                    (a -> Bool) ->
                      ((a, Nat) -> Nat -> Nat) ->
                        Term a b -> Term a b -> (Bool, Bool);
kbo_impl w w0 prc least scf s t =
  let {
    wt = weight w w0 scf t;
    ws = weight w w0 scf s;
  } in (if subseteq_mset (vars_term_ms (scf_term scf t))
             (vars_term_ms (scf_term scf s)) &&
             less_eq_nat wt ws
         then (if less_nat wt ws then (True, True)
                else (case s of {
                       Var _ -> (False, (case t of {
  Var _ -> True;
  Fun g ts -> null ts && least g;
}));
                       Fun f ss ->
                         (case t of {
                           Var _ -> (True, True);
                           Fun g ts ->
                             let {
                               p = prc (f, size_list ss) (g, size_list ts);
                             } in (if fst p then (True, True)
                                    else (if snd p
   then lex_ext_unbounded (kbo_impl w w0 prc least scf) ss ts
   else (False, False)));
                         });
                     }))
         else (False, False));

kbo_strict ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool)) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        (a -> Bool) ->
                          ((a, Nat) -> Nat -> Nat) ->
                            (Term a b, Term a b) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
kbo_strict pr w w0 least scf =
  (\ (s, t) ->
    check (fst (kbo_impl w w0 pr least scf s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term zero_nat s .
          shows_string [' ', '>', 'K', 'B', 'O', ' '] .
            shows_prec_term zero_nat t . shows_nl));

trans_id ::
  forall a.
    ([Prelude.Char] ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a;
trans_id trans_id_parser =
  trans_id_parser ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 'I', 'd'];

zeroa :: Fmap Nat Rat;
zeroa = fmempty;

list_all2 :: forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool;
list_all2 p (x : xs) (y : ys) = p x y && list_all2 p xs ys;
list_all2 p xs [] = null xs;
list_all2 p [] ys = null ys;

list_diff :: forall a. (Eq a) => [a] -> [a] -> [a];
list_diff [] ys = [];
list_diff (x : xs) ys = let {
                          zs = list_diff xs ys;
                        } in (if membera ys x then zs else x : zs);

mat_elements :: forall a. (Ceq a, Ccompare a, Set_impl a) => Mat a -> Set a;
mat_elements a =
  set (concatMap
        (\ i -> map (\ j -> mat_index a (i, j)) (upt zero_nat (mat_dim_col a)))
        (upt zero_nat (mat_dim_row a)));

single_alist_entry :: forall a b. a -> b -> Alist a b;
single_alist_entry xb xc = Alist [(xb, xc)];

image_mset :: forall a b. (Eq b) => (a -> b) -> Multiset a -> Multiset b;
image_mset f (Bag ms) =
  foldd (\ a n -> plus_multiset (Bag (single_alist_entry (f a) n)))
    zero_multiset ms;

eval :: forall a b c. (a -> [b] -> b) -> (c -> b) -> Term a c -> b;
eval i alpha (Var x) = alpha x;
eval i alpha (Fun f ts) = i f (map (eval i alpha) ts);

poly_vars_list :: forall a b. (Eq a) => [([(a, Nat)], b)] -> [a];
poly_vars_list p = remdups (concatMap (map fst . fst) p);

concat_lists :: forall a. [[a]] -> [[a]];
concat_lists [] = [[]];
concat_lists (asa : xs) =
  concatMap (\ vec -> map (\ a -> a : vec) asa) (concat_lists xs);

poly_of ::
  forall a b. (Eq a, Eq b, Comm_semiring_1 b) => Tpoly a b -> [([(a, Nat)], b)];
poly_of (PNum i) = (if i == zerob then [] else [([], i)]);
poly_of (PVar x) = [([(x, one_nat)], onea)];
poly_of (PSum []) = zero_poly;
poly_of (PSum (p : ps)) = poly_add (poly_of p) (poly_of (PSum ps));
poly_of (PMult []) = one_poly;
poly_of (PMult (p : ps)) = poly_mult (poly_of p) (poly_of (PMult ps));

square_possibilities ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => (a -> [a]) -> [([(b, Nat)], a)] -> [[([(b, Nat)], a)]];
square_possibilities sqrt p =
  let {
    roots =
      map (\ x ->
            map (\ a -> (x, a))
              (sqrt (fst (poly_split [(x, nat_of_integer (2 :: Integer))] p))))
        (poly_vars_list p);
    choices = (if membera roots [] then [] else concat_lists roots);
    polys =
      map (\ xas ->
            poly_of (PSum (map (\ (x, a) -> PMult [PVar x, PNum a]) xas)))
        choices;
  } in polys;

check_poly_eq ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] -> [([(a, Nat)], b)] -> Bool;
check_poly_eq [] q = null q;
check_poly_eq ((m, c) : p) q =
  (case extract (\ nd -> eq_monom (fst nd) m) q of {
    Nothing -> False;
    Just (q1, ((_, d), q2)) -> c == d && check_poly_eq p (q1 ++ q2);
  });

monom_degree :: forall a. [(a, Nat)] -> Nat;
monom_degree xps = sum_list (map snd xps);

poly_degree :: forall a b. [([(a, Nat)], b)] -> Nat;
poly_degree p = max_list (map (\ (m, _) -> monom_degree m) p);

check_quadratic ::
  forall a.
    (Eq a,
      Poly_carrier a) => (a -> [a]) ->
                           [([(Nat, Nat)], a)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quadratic sqrt p =
  bindb (check (equal_nat (poly_degree p) (nat_of_integer (2 :: Integer)))
          (shows_prec_list zero_nat
            ['n', 'o', 't', ' ', 'q', 'u', 'a', 'd', 'r', 'a', 't', 'i', 'c']))
    (\ _ ->
      let {
        polys = square_possibilities sqrt p;
      } in check (any (\ q -> check_poly_eq (poly_mult q q) p) polys)
             (shows_prec_list zero_nat
               ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
                 'd', ' ', 'q', 'u', 'a', 'd', 'r', 'a', 't', 'i', 'c', ' ',
                 'p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']));

check_quadratic_ge_const ::
  forall a b c.
    (Eq a, Poly_carrier a,
      Eq c) => (a -> [a]) ->
                 ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                   (Term b c, Term b c) ->
                     Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quadratic_ge_const sq i st =
  let {
    (s, t) = st;
  } in bindb (check (not (is_Var s))
               (shows_prec_list zero_nat
                 ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'n', 'o', 'n', '-',
                   'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's',
                   ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's']))
         (\ _ ->
           let {
             pt = eval_term i t;
             (c, p0) = poly_split [] pt;
           } in bindb (check (p0 == zero_poly)
                        (shows_prec_list zero_nat
                          ['r', 'h', 's', ' ', 'm', 'u', 's', 't', ' ', 'e',
                            'v', 'a', 'l', 'u', 'a', 't', 'e', ' ', 't', 'o',
                            ' ', 'c', 'o', 'n', 's', 't', 'a', 'n', 't']))
                  (\ _ ->
                    let {
                      ps = i (the (root s));
                      (d, psx) = poly_split [] ps;
                    } in bindb (check (less_eq c d)
                                 (shows_prec_list zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                     'n', ' ', 'c', 'o', 'm', 'p', 'a', 'r',
                                     'i', 'n', 'g', ' ', 'c', 'o', 'n', 's',
                                     't', 'a', 'n', 't', 's']))
                           (\ _ -> check_quadratic sq psx)));

check_ns ::
  forall a b c.
    (Showa a, Eq b, Poly_carrier b, Showa b, Eq c,
      Showa c) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                    (Term a c, Term a c) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ns i =
  (\ (s, t) ->
    let {
      p = eval_term i s;
      q = eval_term i t;
    } in check (check_poly_ge p q)
           (shows_string
              ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
                'u', 'r', 'e', ' '] .
             shows_prec_term zero_nat s .
               shows_string [' ', '>', '=', ' '] .
                 shows_prec_term zero_nat t .
                   shows_string
                     [' ', 's', 'i', 'n', 'c', 'e', ' ', 'w', 'e', ' '] .
                     shows_nl .
                       shows_string
                         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e',
                           'n', 's', 'u', 'r', 'e', ' '] .
                         shows_poly p .
                           shows_string [' ', '>', '=', ' '] . shows_poly q));

check_cc ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Showa b, Eq c,
      Showa c) => (a -> [a]) ->
                    (a -> a -> Bool) ->
                      ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                        C_constraint b c ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cc sq gt i (Unconditional_C False st) =
  (if isOK (check_quadratic_ge_const sq i st) then Inr () else check_ns i st);
check_cc sq gt i (Unconditional_C True st) = check_s gt i st;
check_cc sq gt i (Conditional_C True (u, v) (s, t)) =
  let {
    ss = eval_term i s;
    tt = eval_term i t;
    uu = eval_term i u;
    vv = eval_term i v;
  } in (if check_poly_gt gt ss tt then Inr ()
         else check (check_poly_ge (poly_add ss vv) (poly_add tt uu))
                (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                     's', 'u', 'r', 'e', ' '] .
                  shows_prec_term zero_nat u .
                    shows_string [' ', '>', ' '] .
                      shows_prec_term zero_nat v .
                        shows_string [' ', '=', '=', '>', ' '] .
                          shows_prec_term zero_nat s .
                            shows_string [' ', '>', ' '] .
                              shows_prec_term zero_nat t));
check_cc sq gt i (Conditional_C False (u, v) (s, t)) =
  (if isOK (check_quadratic_ge_const sq i (s, t)) then Inr ()
    else let {
           ss = eval_term i s;
           tt = eval_term i t;
           uu = eval_term i u;
           vv = eval_term i v;
         } in (if check_poly_ge ss tt then Inr ()
                else check (check_poly_ge (poly_add ss vv) (poly_add tt uu))
                       (shows_string
                          ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                            'e', 'n', 's', 'u', 'r', 'e', ' '] .
                         shows_prec_term zero_nat u .
                           shows_string [' ', '>', '=', ' '] .
                             shows_prec_term zero_nat v .
                               shows_string [' ', '=', '=', '>', ' '] .
                                 shows_prec_term zero_nat s .
                                   shows_string [' ', '>', '=', ' '] .
                                     shows_prec_term zero_nat t)));

is_left_of :: Pos -> Pos -> Bool;
is_left_of Empty q = False;
is_left_of (PCons i p) q =
  (case q of {
    Empty -> False;
    PCons j qa ->
      (if less_nat i j then True
        else (if less_nat j i then False else is_left_of p qa));
  });

pos_prefix :: Pos -> Pos -> Maybe Pos;
pos_prefix Empty q = Just q;
pos_prefix (PCons i p) q =
  (case q of {
    Empty -> Nothing;
    PCons j qa -> (if equal_nat i j then pos_prefix p qa else Nothing);
  });

pos_suffix :: Pos -> Pos -> Maybe Pos;
pos_suffix p q = (case pos_prefix (rev p) (rev q) of {
                   Nothing -> Nothing;
                   Just qa -> Just (rev qa);
                 });

rules_with ::
  forall a b c.
    (Linorder b) => (a -> Bool) ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        [(Term b c, Term b c)];
rules_with p m =
  map_filter (\ x -> (if (p . fst) x then Just (snd x) else Nothing))
    (values m);

scnp_desc ::
  forall a.
    (Showa a) => [((a, Nat), [(Nat, Nat)])] ->
                   [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
scnp_desc af mu =
  ((((shows_prec_list zero_nat
        ['S', 'C', 'N', 'P', '-', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'w',
          'i', 't', 'h', ' ', 'm', 'u', ' ', '=', ' '] .
       shows_prec_list zero_nat mu) .
      shows_prec_list zero_nat
        [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'l', 'e', 'v', 'e', 'l',
          ' ', 'm', 'a', 'p', 'p', 'i', 'n', 'g', ' ', 'd', 'e', 'f', 'i', 'n',
          'e', 'd', ' ', 'b', 'y', ' ']) .
     shows_nl) .
    shows_sep
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ asa ->
               ((shows_prec_list zero_nat ['p', 'i', '('] .
                  shows_prec zero_nat f) .
                 shows_prec_list zero_nat [')', ' ', '=', ' ']) .
                 showsp_list
                   (\ _ (p, l) ->
                     (((shows_prec_list zero_nat ['('] .
                         (if less_nat p n then shows_prec_nat zero_nat (suc p)
                           else shows_prec_list zero_nat
                                  ['e', 'p', 's', 'i', 'l', 'o', 'n'])) .
                        shows_prec_list zero_nat [',']) .
                       shows_prec_nat zero_nat l) .
                       shows_prec_list zero_nat [')'])
                   zero_nat asa)
          b)
      shows_nl af) .
    shows_nl;

split_rulesb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_rulesb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = split_rules;

delete_R_Rwb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_R_Rwb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = delete_R_Rw;

nfsb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
nfsb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
       rules_map delete_R_Rw split_rules mk nfs more)
  = nfs;

mkc ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      Bool ->
        [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkc (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
      rules_map delete_R_Rw split_rules mk nfs more)
  = mk;

qb :: forall a b c d. Tp_ops_ext a b c d -> a -> [Term b c];
qb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
     delete_R_Rw split_rules mk nfs more)
  = q;

split_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () -> a -> [(Term b c, Term b c)] -> (a, a);
split_tt i tp r_remove = let {
                           (r, rw) = split_rulesb i tp r_remove;
                           tp1 = mkc i (nfsb i tp) (qb i tp) r rw;
                           a = delete_R_Rwb i tp r_remove r_remove;
                         } in (tp1, a);

sturm_aux :: Poly Real -> Poly Real -> [Poly Real];
sturm_aux p q =
  (if equal_nat (degreea q) zero_nat then [p, q]
    else p : sturm_aux q (uminus_poly (modulo_poly p q)));

sturm :: Poly Real -> [Poly Real];
sturm p = sturm_aux p (pderiv p);

funs_term_list :: forall a b. Term a b -> [a];
funs_term_list t = add_funs_term t [];

supt_impl :: forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Bool;
supt_impl (Var x) t = False;
supt_impl (Fun f ss) t = membera ss t || any (\ s -> supt_impl s t) ss;

supt_list :: forall a b. Term a b -> [Term a b];
supt_list (Var x) = [];
supt_list (Fun f ts) = concatMap supteq_list ts;

af_inter ::
  forall a.
    ((a, Nat) -> Set Nat) -> ((a, Nat) -> Set Nat) -> (a, Nat) -> Set Nat;
af_inter pi mu f = inf_set (pi f) (mu f);

empty_af :: forall a. (a, Nat) -> Set Nat;
empty_af fn = set_empty (of_phantom set_impl_nat);

r_sym :: forall a b. Ta_rule a b -> (b, Nat);
r_sym (TA_rule f qs q) = (f, size_list qs);

shows_rule ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          (Term a b, Term a b) -> [Prelude.Char] -> [Prelude.Char];
shows_rule fun var arr (l, r) =
  (shows_term fun var l . shows_prec_list zero_nat arr) . shows_term fun var r;

shows_rules ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          [(Term a b, Term a b)] -> [Prelude.Char] -> [Prelude.Char];
shows_rules fun var arr trs =
  shows_list_gen (shows_rule fun var arr) [] [] ['\n'] [] trs . shows_nl;

shows_trs ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          [Prelude.Char] ->
            [(Term a b, Term a b)] -> [Prelude.Char] -> [Prelude.Char];
shows_trs fun var name arr r =
  ((shows_prec_list zero_nat name . shows_nl) . shows_nl) .
    shows_rules fun var arr r;

aarity_term ::
  forall a b. (Eq a) => a -> (a -> Nat -> [a]) -> Term a b -> Maybe Nat;
aarity_term a sm t =
  (case unapp a t of {
    (Var _, _) -> Nothing;
    (Fun f ss, ts) ->
      Just (minus_nat (aarity sm f (size_list ss)) (size_list ts));
  });

map_funs_term_wa :: forall a b c. ((a, Nat) -> b) -> Term a c -> Term b c;
map_funs_term_wa fg (Var x) = Var x;
map_funs_term_wa fg (Fun f ts) =
  Fun (fg (f, size_list ts)) (map (map_funs_term_wa fg) ts);

uncurry_top ::
  forall a b. (Eq a) => a -> Nat -> (a -> Nat -> [a]) -> Term a b -> Term a b;
uncurry_top a n sm (Fun f ts) =
  let {
    mt = map (map_funs_term_wa (\ (fa, na) -> get_symbol sm fa na zero_nat));
    (h, m) = the (root (hda ts));
  } in (if f == a &&
             equal_nat (size_list ts) n &&
               not (is_Var (hda ts)) && not (equal_nat (aarity sm h m) zero_nat)
         then let {
                (Fun g ss) = hda ts;
              } in Fun (get_symbol sm g (size_list ss) one_nat)
                     (mt (ss ++ tla ts))
         else Fun (let {
                     (fa, na) = (f, size_list ts);
                   } in get_symbol sm fa na zero_nat)
                (mt ts));
uncurry_top a n sm (Var x) = Var x;

innermostLhss ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) [Term a [Prelude.Char]];
innermostLhss xml2name =
  xml_do ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat (term xml2name) xml_return);

strategy ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Strategy a [Prelude.Char]);
strategy xml2name =
  xml_do ['s', 't', 'r', 'a', 't', 'e', 'g', 'y']
    (xml_take
      (xml_or (xml_leaf ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'] Innermost)
        (xml_change (innermostLhss xml2name) (xml_return . Innermost_Q)))
      xml_return);

extract_special ::
  [Prelude.Char] -> [Prelude.Char] -> Maybe ([Prelude.Char], [Prelude.Char]);
extract_special acc [] = Nothing;
extract_special acc (x : xs) =
  (if x == ';' then map_option (\ s -> (s, xs)) (special_map (reverse acc))
    else extract_special (x : acc) xs);

normalize_special :: [Prelude.Char] -> [Prelude.Char];
normalize_special [] = [];
normalize_special (x : xs) =
  (if x == '&' then (case extract_special [] xs of {
                      Nothing -> ['&'] ++ normalize_special xs;
                      Just (spec, ys) -> spec ++ normalize_special ys;
                    })
    else x : normalize_special xs);

parse_xmlfile ::
  forall a.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      [Prelude.Char] -> Sum [Prelude.Char] a;
parse_xmlfile p str =
  (case doc_of_string str of {
    Inl a -> Inl a;
    Inr (XMLDOC _ xml) -> parse_xml p (map_xml_text normalize_special xml);
  });

right :: forall a b. a -> Sum_bot b a;
right x = Sumbot (Inr x);

left :: forall a b. a -> Sum_bot a b;
left x = Sumbot (Inl x);

xmlt_of_xmlt2 ::
  forall a.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      Xml -> Sum_bot [Prelude.Char] a;
xmlt_of_xmlt2 p xml =
  (case xml_take p xml_return ([xml], ([], (False, ([], [['?', '?']])))) of {
    Inl a -> let {
               (Fatal aa) = a;
             } in left aa;
    Inr a -> right a;
  });

aABin :: forall a b. (Eq a) => a -> Acterm a b -> Acterm a b -> Acterm a b;
aABin f (AFun g [s, t]) u =
  (if f == g then AFun f [s, aABin f t u] else AFun f [AFun g [s, t], u]);
aABin f (AVar v) t = AFun f [AVar v, t];
aABin f (AFun v []) t = AFun f [AFun v [], t];
aABin f (AFun v [vb]) t = AFun f [AFun v [vb], t];
aABin f (AFun v (vb : vd : vf : vg)) t = AFun f [AFun v (vb : vd : vf : vg), t];
aABin f (AAC v va) t = AFun f [AAC v va, t];

actop :: forall a b. (Eq a, Eq b) => a -> Term a b -> Multiset (Term a b);
actop f (Fun g [s, t]) =
  (if f == g then plus_multiset (actop f s) (actop f t)
    else add_mset (Fun g [s, t]) zero_multiset);
actop f (Var v) = add_mset (Var v) zero_multiset;
actop f (Fun v []) = add_mset (Fun v []) zero_multiset;
actop f (Fun v [vb]) = add_mset (Fun v [vb]) zero_multiset;
actop f (Fun v (vb : vd : vf : vg)) =
  add_mset (Fun v (vb : vd : vf : vg)) zero_multiset;

aocnf ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Eq b) => Set a -> Set a -> Term a b -> Acterm a b;
aocnf f_A f_C (Fun f (s : t : u : us)) =
  AFun f
    (aocnf f_A f_C s :
      aocnf f_A f_C t : aocnf f_A f_C u : map (aocnf f_A f_C) us);
aocnf f_A f_C (Fun f [t]) = AFun f [aocnf f_A f_C t];
aocnf f_A f_C (Fun f []) = AFun f [];
aocnf f_A f_C (Fun f [s, t]) =
  let {
    a = member f f_A;
    c = member f f_C;
  } in (if a && c
         then AAC f (image_mset (aocnf f_A f_C) (actop f (Fun f [s, t])))
         else (if a then aABin f (aocnf f_A f_C s) (aocnf f_A f_C t)
                else (if c then AAC f (add_mset (aocnf f_A f_C s)
(add_mset (aocnf f_A f_C t) zero_multiset))
                       else AFun f [aocnf f_A f_C s, aocnf f_A f_C t])));
aocnf f_A f_C (Var x) = AVar x;

cstep_trg :: forall a b. Cstep_proof a b -> Term a b;
cstep_trg (Cstep_step x1 x2 x3 x4 x5 x6) = x5;

cstep_src :: forall a b. Cstep_proof a b -> Term a b;
cstep_src (Cstep_step x1 x2 x3 x4 x5 x6) = x4;

shows_eq ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        (Term a b, Term a b) -> [Prelude.Char] -> [Prelude.Char];
shows_eq fun var = shows_rule fun var [' ', '-', '>', '*', ' '];

shows_conditions ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [(Term a b, Term a b)] -> [Prelude.Char] -> [Prelude.Char];
shows_conditions fun var =
  shows_sep (shows_eq fun var) (shows_prec_list zero_nat [',', ' ']);

shows_crule ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        ((Term a b, Term a b), [(Term a b, Term a b)]) ->
          [Prelude.Char] -> [Prelude.Char];
shows_crule fun var cr =
  (shows_rule fun var [' ', '-', '>', ' '] (fst cr) .
    (if null (snd cr) then id else shows_prec_list zero_nat [' ', '|', ' '])) .
    shows_conditions fun var (snd cr);

match_rules ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] -> Maybe (b -> Term a b);
match_rules rs_1 rs_2 =
  bind (zip_option (map fst rs_2 ++ map snd rs_2)
         (map fst rs_1 ++ map snd rs_1))
    (match_list Var);

check_crule_variants ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_crule_variants ra r =
  let {
    rs = fst ra : snd ra;
    rsa = fst r : snd r;
  } in check (not (is_none (match_rules rs rsa)) &&
               not (is_none (match_rules rsa rs)))
         ((((shows_crule (shows_prec zero_nat) (shows_prec zero_nat) ra .
              shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' ']) .
             shows_crule (shows_prec zero_nat) (shows_prec zero_nat) r) .
            shows_prec_list zero_nat
              [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'v', 'a', 'r', 'i',
                'a', 'n', 't', 's', ' ', 'o', 'f', ' ', 'e', 'a', 'c', 'h', ' ',
                'o', 't', 'h', 'e', 'r']) .
           shows_nl);

shows_crules ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [((Term a b, Term a b), [(Term a b, Term a b)])] ->
          [Prelude.Char] -> [Prelude.Char];
shows_crules fun var ctrs =
  shows_list_gen (shows_crule fun var) [] [] ['\n'] [] ctrs . shows_nl;

shows_ctrs ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [((Term a b, Term a b), [(Term a b, Term a b)])] ->
          [Prelude.Char] -> [Prelude.Char];
shows_ctrs fun var r =
  ((shows_prec_list zero_nat ['C', 'T', 'R', 'S', ':'] . shows_nl) . shows_nl) .
    shows_crules fun var r;

check_variant_in_ctrs ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_variant_in_ctrs ra r =
  catch_errora
    (catch_errora (existsM (check_crule_variants r) ra)
      (\ x -> Inl (shows_sep id id x)))
    (\ _ ->
      Inl ((((shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
               shows_crule (shows_prec zero_nat) (shows_prec zero_nat) r) .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'v', 'a',
                  'r', 'i', 'a', 'n', 't', ' ', 'o', 'f', ' ', 'a', 'n', 'y',
                  ' ', 'r', 'u', 'l', 'e', ' ', 'i', 'n', ':']) .
             shows_nl) .
            shows_ctrs (shows_prec zero_nat) (shows_prec zero_nat) ra));

check_csteps ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Term a b ->
                      Term a b ->
                        [Cstep_proof a b] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_csteps r s t [] =
  check (equal_term s t)
    ((((shows_prec_list zero_nat
          ['e', 'm', 'p', 't', 'y', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
            's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ' ', 'b', 'u', 't', ' ',
            's', 'o', 'u', 'r', 'c', 'e', ' '] .
         shows_prec_term zero_nat s) .
        shows_prec_list zero_nat
          [' ', 'a', 'n', 'd', ' ', 't', 'a', 'r', 'g', 'e', 't', ' ']) .
       shows_prec_term zero_nat t) .
      shows_prec_list zero_nat [' ', 'd', 'i', 'f', 'f', 'e', 'r']);
check_csteps r s t [p] =
  bindb (check (equal_term (cstep_src p) s)
          ((shows_prec_term zero_nat (cstep_src p) .
             shows_prec_list zero_nat
               [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                 'c', 'h', ' ', 't', 'h', 'e', ' ', 's', 'o', 'u', 'r', 'c',
                 'e', ' ']) .
            shows_prec_term zero_nat s))
    (\ _ ->
      bindb (check (equal_term (cstep_trg p) t)
              ((shows_prec_term zero_nat (cstep_trg p) .
                 shows_prec_list zero_nat
                   [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a',
                     't', 'c', 'h', ' ', 't', 'h', 'e', ' ', 't', 'a', 'r', 'g',
                     'e', 't', ' ']) .
                shows_prec_term zero_nat t))
        (\ _ -> check_cstep r p));
check_csteps r s t (p : v : va) =
  bindb (check (equal_term (cstep_src p) s)
          ((shows_prec_term zero_nat (cstep_src p) .
             shows_prec_list zero_nat
               [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                 'c', 'h', ' ', 't', 'h', 'e', ' ', 's', 'o', 'u', 'r', 'c',
                 'e', ' ']) .
            shows_prec_term zero_nat s))
    (\ _ ->
      bindb (check_cstep r p) (\ _ -> check_csteps r (cstep_trg p) t (v : va)));

check_cstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Cstep_proof a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cstep ra (Cstep_step ((l, r), cs) p sigma s t pss) =
  bindb (check_variant_in_ctrs ra ((l, r), cs))
    (\ _ ->
      bindb (check (equal_nat (size_list pss) (size_list cs))
              (shows_prec_list zero_nat
                ['m', 'i', 's', 'm', 'a', 't', 'c', 'h', ' ', 'b', 'e', 't',
                  'w', 'e', 'e', 'n', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ',
                  'o', 'f', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                  's', ' ', 'a', 'n', 'd', ' ', 'n', 'u', 'm', 'b', 'e', 'r',
                  ' ', 'o', 'f', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                  's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 's']))
        (\ _ ->
          bindb (check
                  (equal_term s
                    (ctxt_apply_term (ctxt_of_pos_term p s)
                      (subst_apply_term l sigma)))
                  ((shows_prec_term zero_nat s .
                     shows_prec_list zero_nat
                       [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c',
                         'o', 'n', 't', 'a', 'i', 'n', ' ', 'a', 'n', ' ', 'i',
                         'n', 's', 't', 'a', 'n', 'c', 'e', ' ', 'o', 'f',
                         ' ']) .
                    shows_prec_term zero_nat l))
            (\ _ ->
              bindb (check
                      (equal_term t
                        (ctxt_apply_term (ctxt_of_pos_term p s)
                          (subst_apply_term r sigma)))
                      ((shows_prec_term zero_nat t .
                         shows_prec_list zero_nat
                           [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                             'c', 'o', 'n', 't', 'a', 'i', 'n', ' ', 'a', 'n',
                             ' ', 'i', 'n', 's', 't', 'a', 'n', 'c', 'e', ' ',
                             'o', 'f', ' ']) .
                        shows_prec_term zero_nat r))
                (\ _ ->
                  catch_errora
                    (forallM
                      (\ i ->
                        check_csteps ra
                          (subst_apply_term (fst (nth cs i)) sigma)
                          (subst_apply_term (snd (nth cs i)) sigma) (nth pss i))
                      (upt zero_nat (size_list cs)))
                    (\ x -> Inl (snd x))))));

map_funs_crule ::
  forall a b c.
    (a -> b) ->
      ((Term a c, Term a c), [(Term a c, Term a c)]) ->
        ((Term b c, Term b c), [(Term b c, Term b c)]);
map_funs_crule f r =
  ((map_term f (\ x -> x) (fst (fst r)), map_term f (\ x -> x) (snd (fst r))),
    map (map_funs_rule f) (snd r));

skol_crule ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Set ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                 Set b ->
                   ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                     ((Term (Sum a b) b, Term (Sum a b) b),
                       [(Term (Sum a b) b, Term (Sum a b) b)]);
skol_crule ra v r =
  (if member r ra then map_funs_crule Inl r
    else ((skol v (fst (fst r)), skol v (snd (fst r))),
           map (\ (s, t) -> (skol v s, skol v t)) (snd r)));

skol_cstep_proof ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Set ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                 Set b -> Cstep_proof a b -> Cstep_proof (Sum a b) b;
skol_cstep_proof r v (Cstep_step rho p sigma s t pss) =
  Cstep_step (skol_crule r v rho) p (skol v . sigma) (skol v s) (skol v t)
    (map (map (skol_cstep_proof r v)) pss);

map_funs_crules ::
  forall a b c.
    (a -> b) ->
      [((Term a c, Term a c), [(Term a c, Term a c)])] ->
        [((Term b c, Term b c), [(Term b c, Term b c)])];
map_funs_crules f r = map (map_funs_crule f) r;

rules2crules ::
  forall a b.
    [(Term a b, Term a b)] -> [((Term a b, Term a b), [(Term a b, Term a b)])];
rules2crules rs = map (\ r -> (r, [])) rs;

skol_rules ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       [(Term (Sum a b) b, Term (Sum a b) b)];
skol_rules cs = let {
                  v = vars_trs (set cs);
                } in map (\ (l, r) -> (skol v l, skol v r)) cs;

check_context_joinablea ::
  forall a b.
    (Compare a, Eq a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Mapping_impl b, Set_impl b,
      Showa b) => Context_joinable_proof a b ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Term a b ->
                        Term a b ->
                          [(Term a b, Term a b)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_context_joinablea (Contextual_Join u ps qs) r s t cs =
  catch_errora
    (let {
       c = skol_rules cs;
       v = vars_trs (set cs);
       sa = skol v s;
       ta = skol v t;
       ua = skol v u;
       psa = map (skol_cstep_proof (set r) v) ps;
       qsa = map (skol_cstep_proof (set r) v) qs;
       ra = map_funs_crules Inl r ++ rules2crules c;
     } in bindb (check_csteps ra sa ua psa) (\ _ -> check_csteps ra ta ua qsa))
    (\ x ->
      Inl (((((shows_term (shows_prec zero_nat) (shows_prec zero_nat) s .
                shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' ']) .
               shows_term (shows_prec zero_nat) (shows_prec zero_nat) t) .
              shows_prec_list zero_nat
                [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'n',
                  't', 'e', 'x', 't', '-', 'j', 'o', 'i', 'n', 'a', 'b', 'l',
                  'e']) .
             shows_nl) .
            x));

check_context_joinable ::
  forall a b.
    (Eq a, Key a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Mapping_impl b, Infinite b, Set_impl b,
      Showa b) => [(Term a b,
                     (Term a b,
                       ([(Term a b, Term a b)],
                         Context_joinable_proof a b)))] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Term a b ->
                        Term a b ->
                          [(Term a b, Term a b)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_context_joinable cj r s t cs =
  catch_errora
    (existsM
      (\ (sa, (ta, (csa, p))) ->
        bindb (check
                (not (is_none (match_rules ((s, t) : cs) ((sa, ta) : csa)))) id)
          (\ _ ->
            bindb (check
                    (not (is_none (match_rules ((sa, ta) : csa) ((s, t) : cs))))
                    id)
              (\ _ -> check_context_joinablea p r sa ta csa)))
      cj)
    (\ x -> Inl (shows_sep id shows_nl x));

shows_coverlap ::
  forall a b c d e.
    (Showa a, Showa b, Showa c, Showa d,
      Showa e) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    ((Term c d, Term c d), [(Term c d, Term c d)]) ->
                      e -> [Prelude.Char] -> [Prelude.Char];
shows_coverlap rho_1 rho_2 p =
  ((((shows_prec_list zero_nat
        ['o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'o', 'f', ' ', 'c', 'o', 'n',
          'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'r', 'u', 'l', 'e', 's',
          ' '] .
       shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rho_1) .
      shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' ']) .
     shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rho_2) .
    shows_prec_list zero_nat
      [' ', 'a', 't', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ']) .
    shows_prec zero_nat p;

mgu_var_disjoint_generic ::
  forall a b c d.
    (Eq b,
      Eq d) => (a -> b) ->
                 (c -> b) ->
                   Term d a -> Term d c -> Maybe (a -> Term d b, c -> Term d b);
mgu_var_disjoint_generic vu wu s t =
  (case mgu (map_term (\ x -> x) vu s) (map_term (\ x -> x) wu t) of {
    Nothing -> Nothing;
    Just gamma -> Just (gamma . vu, gamma . wu);
  });

check_overlap ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Infinite a, Showa a, Eq b,
      Showa b) => (a -> a) ->
                    (a -> a) ->
                      ([((Term b a, Term b a), [(Term b a, Term b a)])] ->
                        Term b a ->
                          Term b a ->
                            [(Term b a, Term b a)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        ([((Term b a, Term b a), [(Term b a, Term b a)])] ->
                          [(Term b a, Term b a)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          ([((Term b a, Term b a), [(Term b a, Term b a)])] ->
                            Term b a ->
                              (a -> Term b a) ->
                                [(Term b a, Term b a)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            [((Term b a, Term b a), [(Term b a, Term b a)])] ->
                              ((Term b a, Term b a), [(Term b a, Term b a)]) ->
                                ((Term b a, Term b a),
                                  [(Term b a, Term b a)]) ->
                                  Pos ->
                                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_overlap xvar yvar check_context_joinable check_infeasible check_unfeasible
  r rho_1 rho_2 p =
  catch_errora
    (case mgu_var_disjoint_generic xvar yvar (subt_at (fst (fst rho_1)) p)
            (fst (fst rho_2))
      of {
      Nothing -> Inr ();
      Just (sigma_1, sigma_2) ->
        let {
          cs = subst_list sigma_1 (snd rho_1) ++ subst_list sigma_2 (snd rho_2);
          s = subst_apply_term (snd (fst rho_1)) sigma_1;
          t = ctxt_apply_term
                (ctxt_of_pos_term p
                  (subst_apply_term (fst (fst rho_1)) sigma_1))
                (subst_apply_term (snd (fst rho_2)) sigma_2);
        } in catch_errora
               (choice
                 [catch_errora
                    (bindb (check (equal_pos p Empty) id)
                      (\ _ -> check_crule_variants rho_1 rho_2))
                    (\ x ->
                      Inl ((shows_prec_list zero_nat
                              ['t', 'h', 'e', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
                                'p', ' ', 'i', 's', ' ', 'c', 'r', 'i', 't',
                                'i', 'c', 'a', 'l'] .
                             shows_nl) .
                            x)),
                   catch_errora (check_context_joinable r s t cs)
                     (\ x ->
                       Inl ((shows_prec_list zero_nat
                               ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                 ' ', 'b', 'e', ' ', 's', 'h', 'o', 'w', 'n',
                                 ' ', 't', 'o', ' ', 'b', 'e', ' ', 'c', 'o',
                                 'n', 't', 'e', 'x', 't', '-', 'j', 'o', 'i',
                                 'n', 'a', 'b', 'l', 'e'] .
                              shows_nl) .
                             x)),
                   catch_errora (check_infeasible r cs)
                     (\ x ->
                       Inl ((shows_prec_list zero_nat
                               ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                 ' ', 'b', 'e', ' ', 's', 'h', 'o', 'w', 'n',
                                 ' ', 't', 'o', ' ', 'b', 'e', ' ', 'i', 'n',
                                 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e'] .
                              shows_nl) .
                             x)),
                   catch_errora
                     (check_unfeasible r (fst (fst rho_1)) sigma_1 cs)
                     (\ x ->
                       Inl ((shows_prec_list zero_nat
                               ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                 ' ', 'b', 'e', ' ', 's', 'h', 'o', 'w', 'n',
                                 ' ', 't', 'o', ' ', 'b', 'e', ' ', 'u', 'n',
                                 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e'] .
                              shows_nl) .
                             x))])
               (\ x -> Inl (shows_sep id shows_nl x));
    })
    (\ x ->
      Inl ((((shows_coverlap rho_1 rho_2 p . shows_prec_list zero_nat [':']) .
              shows_nl) .
             shows_nl) .
            x));

rule2 ::
  forall a b.
    Unfeasible_proof a b -> ((Term a b, Term a b), [(Term a b, Term a b)]);
rule2 (UnfeasibleOverlap x1 x2 x3 x4 x5 x6 x7) = x7;

rule1 ::
  forall a b.
    Unfeasible_proof a b -> ((Term a b, Term a b), [(Term a b, Term a b)]);
rule1 (UnfeasibleOverlap x1 x2 x3 x4 x5 x6 x7) = x6;

check_airr ::
  forall a.
    (Eq a,
      Showa a) => [((Term a [Prelude.Char], Term a [Prelude.Char]),
                     [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                    Term a [Prelude.Char] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_airr r t =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ p ->
                check (is_none
                        (mgu_var_disjoint_generic (\ a -> 'x' : a)
                          (\ a -> 'y' : a) (subt_at t p) (fst (fst cr))))
                  (((((shows_prec_list zero_nat
                         ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                        shows_term (shows_prec zero_nat)
                          (shows_prec_list zero_nat) t) .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'u', 'n', 'i', 'f', 'i', 'a', 'b',
                           'l', 'e', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h',
                           'e', ' ', 'l', 'e', 'f', 't', '-', 'h', 'a', 'n',
                           'd', ' ', 's', 'i', 'd', 'e', ' ', 'o', 'f', ' ',
                           'r', 'u', 'l', 'e', ' ']) .
                      shows_crule (shows_prec zero_nat)
                        (shows_prec_list zero_nat) cr) .
                     shows_prec_list zero_nat
                       [' ', 'a', 't', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o',
                         'n', ' ']) .
                    shows_pos p))
              (funposs_list t))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((((shows_prec_list zero_nat
                ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
               shows_term (shows_prec zero_nat) (shows_prec_list zero_nat) t) .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'b', 's', 'o',
                  'l', 'u', 't', 'e', 'l', 'y', ' ', 'i', 'r', 'r', 'e', 'd',
                  'u', 'c', 'i', 'b', 'l', 'e']) .
             shows_nl) .
            x));

check_unfeasiblea ::
  forall a.
    (Compare a, Eq a,
      Showa a) => Unfeasible_proof a [Prelude.Char] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]),
                       [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                      Term a [Prelude.Char] ->
                        ([Prelude.Char] -> Term a [Prelude.Char]) ->
                          [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unfeasiblea (UnfeasibleOverlap t u v ps qs rho_1 rho_2) r l mu cs =
  catch_errora
    (let {
       c = skol_rules cs;
       va = vars_trs (set cs);
       ta = skol va t;
       ua = skol va u;
       vb = skol va v;
       psa = map (skol_cstep_proof (set r) va) ps;
       qsa = map (skol_cstep_proof (set r) va) qs;
       ra = map_funs_crules Inl r ++ rules2crules c;
     } in bindb (check (equal_term l (fst (fst rho_1))) id)
            (\ _ ->
              bindb (check (all (\ (a, b) -> let {
       (la, _) = a;
     } in (\ _ -> not (is_Var la))
       b)
                             r)
                      (shows_prec_list zero_nat
                        ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'l', 'e',
                          'f', 't', '-', 'h', 'a', 'n', 'd', ' ', 's', 'i', 'd',
                          'e']))
                (\ _ ->
                  bindb (check_variant_in_ctrs r rho_1)
                    (\ _ ->
                      bindb (check_variant_in_ctrs r rho_2)
                        (\ _ ->
                          bindb (check
                                  (equal_term (subst_apply_term l mu)
                                     (subst_apply_term (fst (fst rho_2)) mu) ||
                                    supt_impl (subst_apply_term l mu)
                                      (subst_apply_term (fst (fst rho_2)) mu))
                                  id)
                            (\ _ ->
                              bindb (check (member t (image fst (set cs))) id)
                                (\ _ ->
                                  bindb (check
  (cs == subst_list mu (snd rho_1 ++ snd rho_2)) id)
                                    (\ _ ->
                                      bindb (check_csteps ra ta ua psa)
(\ _ ->
  bindb (check_csteps ra ta vb qsa)
    (\ _ ->
      bindb (check_airr r u)
        (\ _ ->
          bindb (check_airr r v)
            (\ _ ->
              check (is_none (mgu u v))
                (((shows_term (shows_prec zero_nat) (shows_prec_list zero_nat)
                     u .
                    shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' ']) .
                   shows_term (shows_prec zero_nat) (shows_prec_list zero_nat)
                     v) .
                  shows_prec_list zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'u', 'n', 'i', 'f', 'i', 'a', 'b',
                      'l', 'e'])))))))))))))
    (\ x ->
      Inl ((((shows_prec_list zero_nat
                ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' '] .
               shows_conditions (shows_prec zero_nat) (shows_prec_list zero_nat)
                 cs) .
              shows_prec_list zero_nat
                [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'u', 'n', 'f',
                  'e', 'a', 's', 'i', 'b', 'l', 'e']) .
             shows_nl) .
            x));

check_unfeasible ::
  forall a.
    (Eq a, Key a,
      Showa a) => [([Prelude.Char] -> Term a [Prelude.Char],
                     Unfeasible_proof a [Prelude.Char])] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]),
                       [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                      Term a [Prelude.Char] ->
                        ([Prelude.Char] -> Term a [Prelude.Char]) ->
                          [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unfeasible css r l mu cs =
  catch_errora
    (existsM
      (\ (mua, uo) ->
        let {
          cs_1 = snd (rule1 uo);
          cs_2 = snd (rule2 uo);
          csa = subst_list mua (cs_1 ++ cs_2);
          la = fst (fst (rule1 uo));
        } in bindb (check (equal_nat (size_list csa) (size_list cs))
                     (shows_prec_list zero_nat
                       ['l', 'e', 'n', 'g', 't', 'h', 's', ' ', 'd', 'i', 'f',
                         'f', 'e', 'r']))
               (\ _ ->
                 bindb (check
                         (not (is_none
                                (match_rules
                                  ((subst_apply_term l mu,
                                     subst_apply_term l mu) :
                                    cs)
                                  ((subst_apply_term la mua,
                                     subst_apply_term la mua) :
                                    csa))) &&
                           not (is_none
                                 (match_rules
                                   ((subst_apply_term la mua,
                                      subst_apply_term la mua) :
                                     csa)
                                   ((subst_apply_term l mu,
                                      subst_apply_term l mu) :
                                     cs))))
                         id)
                   (\ _ -> check_unfeasiblea uo r la mua csa)))
      css)
    (\ x -> Inl (shows_sep id shows_nl x));

ta_rules_implb :: forall a b. Tree_automaton a b -> [Ta_rule a b];
ta_rules_implb (Tree_Automaton x1 x2 x3) = x2;

check_subseteq :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_subseteq xs ys =
  catch_errora (forallM (\ x -> (if membera ys x then Inr () else Inl x)) xs)
    (\ x -> Inl (snd x));

check_rules_subseteq ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [Ta_rule a b] ->
                    Tree_automaton a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rules_subseteq rs a =
  catch_errora (check_subseteq rs (ta_rules_implb a))
    (\ x ->
      Inl ((shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
             shows_prec_ta_rule zero_nat x) .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g']));

ta_rules :: forall a b c. Ta_ext a b c -> Set (Ta_rule a b);
ta_rules (Ta_ext ta_final ta_rules ta_eps more) = ta_rules;

ta_final :: forall a b c. Ta_ext a b c -> Set a;
ta_final (Ta_ext ta_final ta_rules ta_eps more) = ta_final;

ta_syms ::
  forall a b.
    (Ccompare a, Eq a, Ceq b, Ccompare b, Eq b,
      Set_impl b) => Ta_ext a b () -> Set (b, Nat);
ta_syms ta = image r_sym (ta_rules ta);

ta_inter_eps_empty ::
  forall a b c d.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ceq b, Ccompare b, Eq b, Set_impl b,
      Ceq c, Ccompare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Ta_ext c b d -> Ta_ext (a, c) b ();
ta_inter_eps_empty ta t =
  Ta_ext (productc (ta_final ta) (ta_final t))
    (image (\ (TA_rule f ps p, TA_rule _ qs q) -> TA_rule f (zip ps qs) (p, q))
      (sup_seta
        (image
          (\ f ->
            productc (filtera (\ r -> r_sym r == f) (ta_rules ta))
              (filtera (\ r -> r_sym r == f) (ta_rules t)))
          (ta_syms ta))))
    bot_set ();

add_rule_states :: forall a b. (Eq a) => [Ta_rule a b] -> [a] -> [a];
add_rule_states rs ss =
  fold (\ r ssa -> let {
                     (TA_rule _ qs q) = r;
                   } in insertb q (fold insertb qs ssa))
    rs ss;

sig_rules ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Ccompare b,
      Eq b) => Set (a, Nat) -> b -> Set (Ta_rule b a);
sig_rules f c = image (\ (fa, n) -> TA_rule fa (replicate n c) c) f;

star :: forall a b. a -> Term a b -> Term a b;
star c (Var x) = Fun c [];
star c (Fun f ts) = Fun f (map (star c) ts);

ground_instances_rules ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Set (a, Nat) -> a -> Term a b -> Set (Ta_rule (Term a b) a);
ground_instances_rules f c (Var x) = sig_rules f (Fun c []);
ground_instances_rules fa c (Fun f ts) =
  sup_set
    (inserta (TA_rule f (map (star c) ts) (star c (Fun f ts)))
      (set_empty (of_phantom set_impl_ta_rule)))
    (sup_seta (image (ground_instances_rules fa c) (set ts)));

ground_instances_ta ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Set (a, Nat) -> a -> Term a b -> Ta_ext (Term a b) a ();
ground_instances_ta f c t =
  Ta_ext (inserta (star c t) (set_empty (of_phantom set_impl_term)))
    (ground_instances_rules f c t)
    (set_empty
      (of_phantom (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla)))
    ();

sig_rules_list :: forall a b. [(a, Nat)] -> b -> [Ta_rule b a];
sig_rules_list f c = map (\ (fa, n) -> TA_rule fa (replicate n c) c) f;

gi_rules_list ::
  forall a b. [(a, Nat)] -> a -> Term a b -> [Ta_rule (Term a b) a];
gi_rules_list f c (Var x) = sig_rules_list f (Fun c []);
gi_rules_list fa c (Fun f ts) =
  TA_rule f (map (star c) ts) (star c (Fun f ts)) :
    concatMap (gi_rules_list fa c) ts;

size_pos :: Pos -> Nat;
size_pos Empty = zero_nat;
size_pos (PCons x21 x22) = plus_nat (size_pos x22) (suc zero_nat);

growing_rule ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Bool;
growing_rule (l, r) =
  ball (vars_term r)
    (\ x ->
      ball (varposs l)
        (\ p ->
          (if equal_term (Var x) (subt_at l p)
            then less_eq_nat (size_pos p) one_nat else True)));

growing ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => Set (Term a b, Term a b) -> Bool;
growing r = ball r growing_rule;

check_growing ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_growing r =
  check (growing (set r))
    (shows_prec_list zero_nat
      ['T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'g', 'r', 'o',
        'w', 'i', 'n', 'g']);

combs :: forall a b. [a] -> [b] -> [[(a, b)]];
combs [] ys = [[]];
combs (x : xs) ys = concatMap (\ l -> map (\ y -> (x, y) : l) ys) (combs xs ys);

state_substs :: forall a b. [a] -> [b] -> [[(a, b)]];
state_substs v q = combs v q;

lhss_impl :: forall a b. (Eq a) => [(a, b)] -> [a];
lhss_impl r = remdups (map fst r);

mp_ta_rules ::
  forall a b c.
    (Eq a,
      Eq b) => [(Term a b, c)] -> [(a, Nat)] -> a -> [Ta_rule (Term a b) a];
mp_ta_rules r f c = concatMap (gi_rules_list f c) (lhss_impl r);

r_lhs_states :: forall a b. Ta_rule a b -> [a];
r_lhs_states (TA_rule x1 x2 x3) = x2;

r_root :: forall a b. Ta_rule a b -> b;
r_root (TA_rule x1 x2 x3) = x1;

r_rhs :: forall a b. Ta_rule a b -> a;
r_rhs (TA_rule x1 x2 x3) = x3;

reachable_states ::
  forall a b c.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Set (Ta_rule a b) -> Term (Sum b a) c -> Set a;
reachable_states delta (Fun (Inr q) []) = inserta q bot_set;
reachable_states delta (Fun (Inl f) ts) =
  image r_rhs
    (filtera
      (\ r ->
        r_root r == f &&
          equal_nat (size_list (r_lhs_states r)) (size_list ts) &&
            all_interval_nat
              (\ i ->
                member (nth (r_lhs_states r) i)
                  (reachable_states delta (nth ts i)))
              zero_nat (size_list ts))
      delta);
reachable_states delta (Var v) = bot_set;
reachable_states delta (Fun (Inr va) (vb : vc)) = bot_set;

qi :: forall a b.
        (Eq b) => a -> Term a b -> (b -> Term a b) -> Term a b -> Term a b;
qi c t g (Var x) = (if contains_var_term x t then g x else star c (Var x));
qi c t g (Fun f ts) = star c (Fun f ts);

inf_step ::
  forall a b.
    (Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => a -> [(Term a b, Term a b)] ->
                      [[(b, Term a b)]] ->
                        Set (Ta_rule (Term a b) a) ->
                          Set (Ta_rule (Term a b) a);
inf_step c r s delta =
  foldr (sup_set .
          (\ (a, b) ->
            let {
              (l, ra) = a;
            } in (\ theta ->
                   let {
                     (Fun f ls) = l;
                   } in image (TA_rule f (map (qi c ra (fun_of theta)) ls))
                          ((reachable_states ::
                             Set (Ta_rule (Term a b) a) ->
                               Term (Sum a (Term a b)) b -> Set (Term a b))
                            delta
                            (subst_apply_term (map_term Inl (\ x -> x) ra)
                              ((\ fa -> Fun (Inr fa) []) . fun_of theta))))
              b))
    (product r s) (set_empty (of_phantom set_impl_ta_rule));

funas_ta_rule ::
  forall a b. (Ceq b, Ccompare b, Set_impl b) => Ta_rule a b -> Set (b, Nat);
funas_ta_rule r = inserta (r_root r, size_list (r_lhs_states r)) bot_set;

funas_ta ::
  forall a b.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b,
      Set_impl b) => Ta_ext a b () -> Set (b, Nat);
funas_ta a = sup_seta (image funas_ta_rule (ta_rules a));

check_varcond_no_Var_lhs ::
  forall a b.
    (Showa a,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_varcond_no_Var_lhs =
  (\ xs ->
    catch_errora
      (forallM
        (\ rule ->
          check (not (is_Var (fst rule)))
            ((shows_prec_list zero_nat
                ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'l', 'e', 'f',
                  't', '-', 'h', 'a', 'n', 'd', ' ', 's', 'i', 'd', 'e', ' ',
                  'i', 'n', ' ', 'r', 'u', 'l', 'e', ' '] .
               shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                 [' ', '-', '>', ' '] rule) .
              shows_nl))
        xs)
      (\ x -> Inl (snd x)));

ta_of_ta ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Tree_automaton a b -> Ta_ext a b ();
ta_of_ta (Tree_Automaton fin rules eps) =
  Ta_ext (set fin) (set rules) (set eps) ();

insert_funas_term :: forall a b. (Eq a) => Term a b -> [(a, Nat)] -> [(a, Nat)];
insert_funas_term (Var x) fs = fs;
insert_funas_term (Fun f ts) fs =
  insertb (f, size_list ts) (foldr insert_funas_term ts fs);

insert_funas_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_funas_rule r fs =
  insert_funas_term (fst r) (insert_funas_term (snd r) fs);

insert_funas_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_funas_trs trs = foldr insert_funas_rule trs;

check_linear_trs ::
  forall a b.
    (Showa a, Ceq b, Ccompare b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_linear_trs r =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (l, ra) = x;
              } in linear_term l && linear_term ra
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ _ ->
      Inl (((shows_prec_list zero_nat r . shows_nl) .
             shows_prec_list zero_nat
               ['i', 's', ' ', 'n', 'o', 't', ' ', 'l', 'i', 'n', 'e', 'a',
                 'r']) .
            shows_nl));

ta_eps :: forall a b c. Ta_ext a b c -> Set (a, a);
ta_eps (Ta_ext ta_final ta_rules ta_eps more) = ta_eps;

reduced_TA ::
  forall a b c.
    (Ccompare a, Eq a, Ceq b, Ccompare b, Eq b,
      Set_impl b) => a -> Ta_ext b a c -> Set b -> Ta_ext b a ();
reduced_TA f ta q =
  Ta_ext bot_set
    (sup_set
      (image
        (\ (TA_rule fa qs a) ->
          TA_rule fa (filter (\ qa -> not (member qa q)) qs) a)
        (filtera (\ r -> not (member (r_rhs r) q)) (ta_rules ta)))
      (image (\ p -> TA_rule f [] (snd p))
        (filtera (\ p -> member (fst p) q && not (member (snd p) q))
          (ta_eps ta))))
    (filtera (\ p -> not (member (fst p) q) && not (member (snd p) q))
      (ta_eps ta))
    ();

new_reach ::
  forall a b c.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b c -> Set a;
new_reach ta =
  image r_rhs (filtera (\ r -> null (r_lhs_states r)) (ta_rules ta));

ta_reachable ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Default b,
      Eq b) => Ta_ext a b () -> Set a;
ta_reachable ta =
  let {
    q = new_reach ta;
  } in (if less_eq_set q bot_set then bot_set
         else sup_set q (ta_reachable (reduced_TA defaulta ta q)));

ta_empty ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Default b,
      Eq b) => Ta_ext a b () -> Bool;
ta_empty ta = less_eq_set (inf_set (ta_reachable ta) (ta_final ta)) bot_set;

check_etac_nonreachable ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Default a,
      Eq a, Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => [(a, Nat)] ->
                    a -> a -> Tree_automaton (Term a b) a ->
                                [(Term a b, Term a b)] ->
                                  Term a b ->
                                    Term a b ->
                                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_etac_nonreachable f aa c a r s t =
  let {
    fa = set f;
  } in bindb (check (member (aa, zero_nat) fa)
               ((shows_prec_list zero_nat
                   ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' '] .
                  shows_prec zero_nat aa) .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 's',
                     'i', 'g', 'n', 'a', 't', 'u', 'r', 'e']))
         (\ _ ->
           bindb (check (not (member (c, zero_nat) fa))
                   (shows_prec_list zero_nat
                     ['s', 't', 'a', 'r', '-', 's', 'y', 'm', 'b', 'o', 'l',
                       ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e',
                       's', 'h', ' ', 'w', '.', 'r', '.', 't', '.', ' ', 's',
                       'i', 'g', 'n', 'a', 't', 'u', 'r', 'e']))
             (\ _ ->
               bindb (catch_errora (check_subseteq (insert_funas_term s []) f)
                       (\ _ ->
                         Inl (shows_prec_list zero_nat
                               ['l', 'h', 's', ' ', 'v', 'i', 'o', 'l', 'a',
                                 't', 'e', 's', ' ', 's', 'i', 'g', 'n', 'a',
                                 't', 'u', 'r', 'e'])))
                 (\ _ ->
                   bindb (catch_errora
                           (check_subseteq (insert_funas_term t []) f)
                           (\ _ ->
                             Inl (shows_prec_list zero_nat
                                   ['r', 'h', 's', ' ', 'v', 'i', 'o', 'l', 'a',
                                     't', 'e', 's', ' ', 's', 'i', 'g', 'n',
                                     'a', 't', 'u', 'r', 'e'])))
                     (\ _ ->
                       let {
                         fs = insert_funas_trs r [];
                       } in bindb (catch_errora (check_subseteq fs f)
                                    (\ _ ->
                                      Inl
(shows_prec_list zero_nat
  ['T', 'R', 'S', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 's', 'i',
    'g', 'n', 'a', 't', 'u', 'r', 'e'])))
                              (\ _ ->
                                bindb (check_varcond_no_Var_lhs r)
                                  (\ _ ->
                                    bindb (check_linear_trs r)
                                      (\ _ ->
bindb (check_growing r)
  (\ _ ->
    let {
      aaa = ta_of_ta a;
    } in bindb (check
                 (set_eq (ta_eps aaa)
                   (set_empty
                     (of_phantom
                       (set_impl_prod ::
                         Phantom (Term a b, Term a b) Set_impla))))
                 (shows_prec_list zero_nat
                   ['n', 'o', ' ', 'e', 'p', 's', 'i', 'l', 'o', 'n', ' ', 't',
                     'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 's', ' ', 'a',
                     'l', 'l', 'o', 'w', 'e', 'd']))
           (\ _ ->
             bindb (check (member (star c t) (ta_final aaa))
                     ((shows_prec_list zero_nat
                         ['f', 'i', 'n', 'a', 'l', ' ', 's', 't', 'a', 't', 'e',
                           ' ', 'f', 'o', 'r', ' '] .
                        shows_prec_term zero_nat t) .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                           'g']))
               (\ _ ->
                 bindb (check (less_eq_set (funas_ta aaa) fa)
                         (shows_prec_list zero_nat
                           ['t', 'h', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ',
                             'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ',
                             'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'r',
                             'e', 's', 'p', 'e', 'c', 't', ' ', 't', 'h', 'e',
                             ' ', 's', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e']))
                   (\ _ ->
                     let {
                       ts = gi_rules_list f c t;
                       ms = mp_ta_rules r f c;
                     } in bindb (check_rules_subseteq ts a)
                            (\ _ ->
                              bindb (check_rules_subseteq ms a)
                                (\ _ ->
                                  let {
                                    q = add_rule_states ts
  (add_rule_states ms []);
                                    ss = state_substs
   (remdups (concatMap (vars_term_list . snd) r)) q;
                                    d = set (ta_rules_implb a);
                                    da = inf_step c r ss d;
                                  } in bindb
 (check (less_eq_set da d)
   (shows_prec_list zero_nat
     ['t', 'h', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ', 't', 'r', 'e', 'e', ' ',
       'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ', 'i', 's', ' ', 'n',
       'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'u', 'n', 'd', 'e',
       'r', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', ' ', 'r',
       'u', 'l', 'e', 's']))
 (\ _ ->
   check (ta_empty (ta_inter_eps_empty aaa (ground_instances_ta fa c s)))
     (shows_prec_list zero_nat
       ['t', 'h', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ', 't', 'r', 'e', 'e',
         ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ', 'd', 'o', 'e',
         's', ' ', 'n', 'o', 't', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'y', ' ',
         'n', 'o', 'n', '-', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'i', 'l', 'i',
         't', 'y'])))))))))))))));

is_instance_rule ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b, Term a b) -> (Term a b, Term a b) -> Bool;
is_instance_rule ra r =
  (case match_list Var [(fst r, fst ra), (snd r, snd ra)] of {
    Nothing -> False;
    Just _ -> True;
  });

check_subst_overapproximation ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subst_overapproximation ra r =
  catch_errora
    (catch_errora
      (forallM
        (\ raa ->
          catch_errora (existsM (\ rb -> check (is_instance_rule raa rb) id) r)
            (\ _ ->
              Inl (((shows_prec_list zero_nat
                       ['g', 'r', 'o', 'w', 'i', 'n', 'g', ' ', 'r', 'u', 'l',
                         'e', ' ', 'f', 'o', 'r', ' '] .
                      shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                        [' ', '-', '>', ' '] raa) .
                     shows_prec_list zero_nat
                       [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                         'g']) .
                    shows_nl)))
        ra)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((((((shows_prec_list zero_nat r . shows_nl) .
                shows_prec_list zero_nat
                  ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'o', 'v',
                    'e', 'r', 'a', 'p', 'p', 'r', 'o', 'x', 'i', 'm', 'a', 't',
                    'i', 'o', 'n', ' ', 'o', 'f']) .
               shows_nl) .
              shows_prec_list zero_nat ra) .
             shows_nl) .
            x));

group_key :: forall a b. (Eq b) => (a -> b) -> [a] -> [[a]];
group_key f [] = [];
group_key f (x : xs) =
  (x : takeWhile (\ y -> f x == f y) xs) :
    group_key f (dropWhile (\ y -> f x == f y) xs);

nonlinear_var_nonreach ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Compare b, Eq b, Compare c,
      Eq c) => [(a, Nat)] ->
                 (Maybe (a, Nat) -> Maybe (a, Nat) -> Bool) ->
                   [(Term b c, Term a d)] -> Bool;
nonlinear_var_nonreach f gt_fun xs =
  let {
    xs1 = filter (is_Var . fst) xs;
    xs2 = sort_key fst xs1;
    a = group_key fst xs2;
  } in any (\ xts ->
             less_nat one_nat (size_list xts) &&
               all (\ fa ->
                     not (gt_fun (Just fa) Nothing) &&
                       any (\ (_, v) ->
                             not (is_Var v) &&
                               less_eq_set (funas_term v) (set f) &&
                                 not (root v == Just fa) &&
                                   not (gt_fun (Just fa) (root v)))
                         xts)
                 f)
         a;

nonreachable_gtcapRM ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Nat)] ->
                 Bool ->
                   Bool ->
                     (Maybe (a, Nat) -> Maybe (a, Nat) -> Bool) ->
                       ((a, Nat) -> [(Term a b, Term a b)]) ->
                         Term a b -> Term a c -> Bool;
nonreachable_gtcapRM fs nlv ne gt_fun rm s t =
  let {
    gt = gt_term nlv ne gt_fun rm;
    rs = rd_impl gt (s, t);
  } in any (\ (a, b) -> nonreach gt a b) rs ||
         nlv && ne && nonlinear_var_nonreach fs gt_fun rs;

insert_value ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> a -> Rbt b [a] -> Rbt b [a];
insert_value key v m = (case key v of {
                         Nothing -> m;
                         Just k -> (case lookup m k of {
                                     Nothing -> insert k [v] m;
                                     Just vs -> insert k (insertb v vs) m;
                                   });
                       });

insert_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
insert_values uu [] m = m;
insert_values key (v : vs) m = insert_value key v (insert_values key vs m);

insert_rules ::
  forall a b c.
    (Eq a, Compare_order b, Eq b,
      Eq c) => a -> [(Term b c, Term b c)] ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        Rbt (b, Nat) [(a, (Term b c, Term b c))];
insert_rules a rs = insert_values key (map (\ b -> (a, b)) rs);

rule_map ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => [(Term a b, Term a b)] -> (a, Nat) -> [(Term a b, Term a b)];
rule_map r fn = (case lookup (insert_rules () r empty) fn of {
                  Nothing -> [];
                  Just a -> map snd a;
                });

relpow_impl ::
  forall a b.
    ([a] -> [a]) -> ([a] -> b -> b) -> (a -> b -> Bool) -> [a] -> b -> Nat -> b;
relpow_impl succ un memb new have m =
  (if equal_nat m zero_nat then un new have
    else (if null new then have
           else let {
                  maybe = succ new;
                  havea = un new have;
                  newa = filter (\ n -> not (memb n havea)) maybe;
                } in relpow_impl succ un memb newa havea
                       (minus_nat m one_nat)));

trancl_impl ::
  forall a b.
    ([(a, a)] -> [a] -> [a]) ->
      ([a] -> b -> b) -> (a -> b -> Bool) -> b -> [(a, a)] -> [a] -> b;
trancl_impl gen_succ un memb emp rel =
  let {
    succ = gen_succ rel;
    n = size_list rel;
  } in (\ asa -> relpow_impl succ un memb (succ asa) emp n);

trancl_list_impl :: forall a. (Eq a) => [(a, a)] -> [a] -> [a];
trancl_list_impl =
  trancl_impl
    (\ r asa ->
      remdups
        (map_filter
          (\ x -> (if let {
                        (a, _) = x;
                      } in membera asa a
                    then Just (snd x) else Nothing))
          r))
    (\ xs ys -> filter (\ x -> not (membera ys x)) xs ++ ys)
    (\ x xs -> membera xs x) [];

memo_list_trancl :: forall a. (Eq a) => [(a, a)] -> a -> [a];
memo_list_trancl r = let {
                       tr = trancl_list_impl r;
                       rm = map (\ a -> (a, tr [a])) ((remdups . map fst) r);
                     } in (\ a -> (case map_of rm a of {
                                    Nothing -> [];
                                    Just asa -> asa;
                                  }));

mk_gt_fun ::
  forall a b c.
    (Eq a) => [(Term a b, Term a c)] ->
                Maybe (a, Nat) -> Maybe (a, Nat) -> Bool;
mk_gt_fun rs = let {
                 in_trancl = memo_list_trancl (gt1 rs);
               } in (\ f -> membera (in_trancl f));

check_nonreachable ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      Term a b ->
                        Nonreachability_proof a b ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_nonreachable r s t Nonreachable_Tcap =
  check (not (matchb (tcapI r s) t))
    (shows_prec_list zero_nat
      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 's', 'h', 'o', 'w',
        ' ', 'n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'i', 'l', 'i',
        't', 'y', ' ', 'v', 'i', 'a', ' ', 't', 'c', 'a', 'p']);
check_nonreachable r s t Nonreachable_Gtcap =
  let {
    nlv = all (\ lr -> not (is_Var (fst lr))) r;
    fs = funas_trs_list r;
  } in check (not (matchb (tcapI r s) t) ||
               nonreachable_gtcapRM fs nlv (not (null r)) (mk_gt_fun r)
                 (rule_map r) s t)
         (shows_prec_list zero_nat
           ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 's', 'h', 'o',
             'w', ' ', 'n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'i',
             'l', 'i', 't', 'y', ' ', 'v', 'i', 'a', ' ', 'g', 'e', 'n', 'e',
             'r', 'a', 'l', 'i', 'z', 'e', 'd', ' ', 't', 'c', 'a', 'p']);
check_nonreachable r s t (Nonreachable_ETAC f aa c a) =
  check_etac_nonreachable f aa c a r s t;
check_nonreachable ra s t (Nonreachable_Subst_Approx r p) =
  bindb (check_subst_overapproximation ra r)
    (\ _ -> check_nonreachable r s t p);
check_nonreachable r s t (Nonreachable_Reverse p) =
  check_nonreachable (map (\ (x, y) -> (y, x)) r) t s p;

unifiable :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Bool;
unifiable s t = not (is_none (mergea s t));

check_nonjoinable ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      Term a b ->
                        Nonjoinability_proof a b ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_nonjoinable r s t Nonjoinable_Tcap =
  check (not (unifiable (tcapI r s) (tcapI r t)))
    (shows_prec_list zero_nat
      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 's', 'h', 'o', 'w',
        ' ', 'n', 'o', 'n', 'j', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't',
        'y', ' ', 'v', 'i', 'a', ' ', 't', 'c', 'a', 'p']);
check_nonjoinable r s t (Nonjoinable_Ground_NF p) =
  (if is_NF_trs r s && ground s then check_nonreachable r t s p
    else (if is_NF_trs r t && ground t then check_nonreachable r s t p
           else Inl (shows_prec_list zero_nat ['n', 'o', 'n', ' ', 'N', 'F'])));

check_infeasibleb ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => [((Term a b, Term a b), c)] ->
                    [(Term a b, Term a b)] ->
                      Infeasibility_proof a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_infeasibleb r cs (Infeasible_Compound_Conditions f p) =
  check_nonreachable (map fst r) (Fun f (map fst cs)) (Fun f (map snd cs)) p;
check_infeasibleb r cs (Infeasible_Equation s t p) =
  bindb (check (membera cs (s, t))
          (((shows_prec_list zero_nat
               ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
              shows_eq (shows_prec zero_nat) (shows_prec zero_nat) (s, t)) .
             shows_prec_list zero_nat
               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'l', 'i',
                 's', 't', ' ', 'o', 'f', ' ', 'c', 'o', 'n', 'd', 'i', 't',
                 'i', 'o', 'n', 's']) .
            shows_nl))
    (\ _ -> check_nonreachable (map fst r) s t p);
check_infeasibleb r csa (Infeasible_Subset cs p) =
  bindb (catch_errora (check_subseteq cs csa)
          (\ x ->
            Inl (((shows_prec_list zero_nat
                     ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
                    shows_eq (shows_prec zero_nat) (shows_prec zero_nat) x) .
                   shows_prec_list zero_nat
                     [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ',
                       'l', 'i', 's', 't', ' ', 'o', 'f', ' ', 'c', 'o', 'n',
                       'd', 'i', 't', 'i', 'o', 'n', 's']) .
                  shows_nl)))
    (\ _ -> check_infeasibleb r cs p);
check_infeasibleb r cs (Infeasible_Rhss_Equal s t u p) =
  bindb (check (membera cs (s, u))
          (((shows_prec_list zero_nat
               ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
              shows_eq (shows_prec zero_nat) (shows_prec zero_nat) (s, u)) .
             shows_prec_list zero_nat
               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'l', 'i',
                 's', 't', ' ', 'o', 'f', ' ', 'c', 'o', 'n', 'd', 'i', 't',
                 'i', 'o', 'n', 's']) .
            shows_nl))
    (\ _ ->
      bindb (check (membera cs (t, u))
              (((shows_prec_list zero_nat
                   ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
                  shows_eq (shows_prec zero_nat) (shows_prec zero_nat) (t, u)) .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'l',
                     'i', 's', 't', ' ', 'o', 'f', ' ', 'c', 'o', 'n', 'd', 'i',
                     't', 'i', 'o', 'n', 's']) .
                shows_nl))
        (\ _ -> check_nonjoinable (map fst r) s t p));

check_infeasible ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => [([(Term a b, Term a b)], Infeasibility_proof a b)] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [(Term a b, Term a b)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_infeasible css r cs =
  catch_errora
    (existsM
      (\ (csa, p) ->
        bindb (check (equal_nat (size_list csa) (size_list cs))
                (shows_prec_list zero_nat
                  ['l', 'e', 'n', 'g', 't', 'h', 's', ' ', 'd', 'i', 'f', 'f',
                    'e', 'r']))
          (\ _ ->
            bindb (check
                    (not (is_none (match_rules cs csa)) &&
                      not (is_none (match_rules csa cs)))
                    id)
              (\ _ -> check_infeasibleb r csa p)))
      css)
    (\ x -> Inl (shows_sep id shows_nl x));

check_CCPs ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a,
      Showa a) => [(Term a [Prelude.Char],
                     (Term a [Prelude.Char],
                       ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                         Context_joinable_proof a [Prelude.Char])))] ->
                    [([(Term a [Prelude.Char], Term a [Prelude.Char])],
                       Infeasibility_proof a [Prelude.Char])] ->
                      [([Prelude.Char] -> Term a [Prelude.Char],
                         Unfeasible_proof a [Prelude.Char])] ->
                        [((Term a [Prelude.Char], Term a [Prelude.Char]),
                           [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_CCPs cj css uo r =
  catch_errora
    (forallM
      (\ rho_1 ->
        let {
          l_1 = fst (fst rho_1);
        } in catch_errora
               (forallM
                 (\ rho_2 ->
                   catch_errora
                     (forallM
                       (check_overlap (\ a -> 'x' : a) (\ a -> 'y' : a)
                         (check_context_joinable cj) (check_infeasible css)
                         (check_unfeasible uo) r rho_1 rho_2)
                       (funposs_list l_1))
                     (\ x -> Inl (snd x)))
                 r)
               (\ x -> Inl (snd x)))
      r)
    (\ x -> Inl (snd x));

check_type3 ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_type3 r =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (check_subseteq (vars_term_list (snd (fst cr)))
              (vars_term_list (fst (fst cr)) ++ vars_trs_list (snd cr)))
            (\ x ->
              Inl ((((shows_prec_list zero_nat
                        ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                       shows_prec zero_nat x) .
                      shows_prec_list zero_nat
                        [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 'o', 'n', 'l',
                          'y', ' ', 'i', 'n', ' ', 'r', 'i', 'g', 'h', 't', '-',
                          'h', 'a', 'n', 'd', ' ', 's', 'i', 'd', 'e', ' ', 'o',
                          'f', ' ', 'r', 'u', 'l', 'e', ' ']) .
                     shows_crule (shows_prec zero_nat) (shows_prec zero_nat)
                       cr) .
                    shows_nl)))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                'o', 't', ' ', 'o', 'f', ' ', 't', 'y', 'p', 'e', ' ', '3'] .
             shows_nl) .
            x));

x_impl ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> [b];
x_impl cr i =
  concat
    (vars_term_list (fst (fst cr)) :
      map (vars_term_list . snd) (take i (snd cr)));

check_dctrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dctrs r =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                catch_errora
                  (check_subseteq (vars_term_list (fst (nth (snd cr) i)))
                    (x_impl cr i))
                  (\ x ->
                    Inl (((((((shows_prec_list zero_nat
                                 ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                                shows_prec zero_nat x) .
                               shows_prec_list zero_nat
                                 [' ', 'i', 'n', ' ', 'c', 'o', 'n', 'd', 'i',
                                   't', 'i', 'o', 'n', ' ']) .
                              shows_rule (shows_prec zero_nat)
                                (shows_prec zero_nat) [' ', '-', '>', ' ']
                                (nth (snd cr) i)) .
                             shows_prec_list zero_nat
                               [' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', ' ']) .
                            shows_crule (shows_prec zero_nat)
                              (shows_prec zero_nat) cr) .
                           shows_prec_list zero_nat
                             ['v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 'D',
                               'C', 'T', 'R', 'S', ' ', 'c', 'o', 'n', 'd', 'i',
                               't', 'i', 'o', 'n']) .
                          shows_nl)))
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                'o', 't', ' ', 'd', 'e', 't', 'e', 'r', 'm', 'i', 'n', 'i', 's',
                't', 'i', 'c'] .
             shows_nl) .
            x));

check_wf_ctrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_ctrs r =
  catch_errora
    (bindb (check_varcond_no_Var_lhs (map fst r))
      (\ _ -> bindb (check_dctrs r) (\ _ -> check_type3 r)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                'o', 't', ' ', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e',
                'd'] .
             shows_nl) .
            x));

check_adtrs ::
  forall a.
    (Eq a,
      Showa a) => [((Term a [Prelude.Char], Term a [Prelude.Char]),
                     [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_adtrs r =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM (\ i -> let {
                               a = snd (nth (snd cr) i);
                             } in check_airr r a)
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                'o', 't', ' ', 'a', 'b', 's', 'o', 'l', 'u', 't', 'e', 'l', 'y',
                ' ', 'd', 'e', 't', 'e', 'r', 'm', 'i', 'n', 'i', 's', 't', 'i',
                'c'] .
             shows_nl) .
            x));

check_al94 ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a,
      Showa a) => [(Term a [Prelude.Char],
                     (Term a [Prelude.Char],
                       ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                         Context_joinable_proof a [Prelude.Char])))] ->
                    [([(Term a [Prelude.Char], Term a [Prelude.Char])],
                       Infeasibility_proof a [Prelude.Char])] ->
                      [([Prelude.Char] -> Term a [Prelude.Char],
                         Unfeasible_proof a [Prelude.Char])] ->
                        [((Term a [Prelude.Char], Term a [Prelude.Char]),
                           [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_al94 cj css uo r =
  catch_errora
    (bindb (check_wf_ctrs r)
      (\ _ -> bindb (check_adtrs r) (\ _ -> check_CCPs cj css uo r)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['A', 'v', 'e', 'n', 'h', 'a', 'u', 's', ' ', '&', ' ', 'L', 'o',
                'r', 'i', 'a', '-', 'S', 'a', 'e', 'n', 'z', ' ', '1', '9', '9',
                '4', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                'p', 'l', 'y'] .
             shows_nl) .
            x));

orig_crule ::
  forall a b.
    (a -> Maybe b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) ->
        ((Term a b, Term a b), [(Term a b, Term a b)]);
orig_crule m r =
  ((orig_term m (fst (fst r)), orig_term m (snd (fst r))),
    map (\ (s, t) -> (orig_term m s, orig_term m t)) (snd r));

orig_cstep :: forall a b. (a -> Maybe b) -> Cstep_proof a b -> Cstep_proof a b;
orig_cstep m (Cstep_step rho p sigma s t css) =
  Cstep_step (orig_crule m rho) p (orig_term m . sigma) (orig_term m s)
    (orig_term m t) (map (map (orig_cstep m)) css);

arith_fun :: Xml -> Sum_bot [Prelude.Char] ArithFun;
arith_fun xml =
  singleton ['a', 'r', 'i', 't', 'h', 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n']
    (options
      [(['n', 'a', 't', 'u', 'r', 'a', 'l'],
         change (nata ['n', 'a', 't', 'u', 'r', 'a', 'l']) Consta),
        (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'],
          change (nata ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'])
            (\ n -> Arg (minus_nat n one_nat))),
        (['s', 'u', 'm'], many ['s', 'u', 'm'] arith_fun Suma),
        (['p', 'r', 'o', 'd', 'u', 'c', 't'],
          many ['p', 'r', 'o', 'd', 'u', 'c', 't'] arith_fun Prod),
        (['m', 'i', 'n'], many ['m', 'i', 'n'] arith_fun Min),
        (['m', 'a', 'x'], many ['m', 'a', 'x'] arith_fun Max),
        (['i', 'f', 'E', 'q', 'u', 'a', 'l'],
          tuple4 ['i', 'f', 'E', 'q', 'u', 'a', 'l'] arith_fun arith_fun
            arith_fun arith_fun IfEqual)])
    id xml;

int_coeff :: Xml -> Sum_bot [Prelude.Char] Int;
int_coeff = int ['i', 'n', 't', 'e', 'g', 'e', 'r'];

vec_coeff ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] (Vec a);
vec_coeff xml2coeff =
  many ['v', 'e', 'c', 't', 'o', 'r']
    (singleton ['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't'] xml2coeff
      id)
    vec_of_list;

mat_coeff ::
  forall a.
    Nat ->
      a -> (Xml -> Sum_bot [Prelude.Char] a) ->
             Xml -> Sum_bot [Prelude.Char] (Mat a);
mat_coeff n ze xml2coeff =
  options
    [(['m', 'a', 't', 'r', 'i', 'x'],
       many ['m', 'a', 't', 'r', 'i', 'x'] (vec_coeff xml2coeff)
         (mat_of_cols n)),
      (['v', 'e', 'c', 't', 'o', 'r'],
        change (vec_coeff xml2coeff)
          (\ v ->
            mat n n
              (\ (i, j) ->
                (if equal_nat j zero_nat then vec_index v i else ze))))];

closed_criterion ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) (Ta_relation [Prelude.Char]);
closed_criterion =
  xml_do ['c', 'r', 'i', 't', 'e', 'r', 'i', 'o', 'n']
    (xml_take
      (xml_or
        (xml_leaf
          ['c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y']
          Id_Relation)
        (xml_or
          (xml_do
            ['s', 't', 'a', 't', 'e', 'C', 'o', 'm', 'p', 'a', 't', 'i', 'b',
              'i', 'l', 'i', 't', 'y']
            (xml_take
              (xml_do ['r', 'e', 'l', 'a', 't', 'i', 'o', 'n']
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (xml_do ['e', 'n', 't', 'r', 'y']
                    (xml_take state
                      (\ a -> xml_take state (\ b -> xml_return (a, b)))))
                  xml_return))
              (\ x -> xml_return (Some_Relation x))))
          (xml_or
            (xml_leaf
              ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', 'P', 'r', 'o', 'c', 'e',
                'd', 'u', 'r', 'e']
              Decision_Proc)
            (xml_leaf
              ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', 'P', 'r', 'o', 'c', 'e',
                'd', 'u', 'r', 'e', 'O', 'l', 'd']
              Decision_Proc_Old))))
      xml_return);

final_states ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) [[Prelude.Char]];
final_states =
  xml_do ['f', 'i', 'n', 'a', 'l', 'S', 't', 'a', 't', 'e', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat state xml_return);

transition ::
  forall a b.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) (Sum (a, [[Prelude.Char]]) b)) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char])
          (Sum (Ta_rule [Prelude.Char] a) (b, [Prelude.Char]));
transition xml2lhs =
  xml_do ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n']
    (xml_take xml2lhs
      (\ a ->
        xml_take
          (xml_do ['r', 'h', 's'] (xml_take state (\ x -> xml_return (id x))))
          (\ b -> xml_return (case a of {
                               Inl (f, qs) -> Inl (TA_rule f qs b);
                               Inr q -> Inr (q, b);
                             }))));

transitions ::
  forall a b.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) (Sum (a, [[Prelude.Char]]) b)) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char])
          ([Ta_rule [Prelude.Char] a], [(b, [Prelude.Char])]);
transitions xml2lhs =
  xml_do ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat (transition xml2lhs)
      (\ rls -> let {
                  (rules, eps) = partition (\ a -> (case a of {
             Inl _ -> True;
             Inr _ -> False;
           }))
                                   rls;
                  ruls = map (\ (Inl r) -> r) rules;
                  ep = map (\ (Inr e) -> e) eps;
                } in xml_return (ruls, ep)));

tree_automaton ::
  forall a.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char])
        (Sum (a, [[Prelude.Char]]) [Prelude.Char])) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) (Tree_automaton [Prelude.Char] a);
tree_automaton xml2lhs =
  xml_do ['t', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n']
    (xml_take final_states
      (\ a ->
        xml_take (transitions xml2lhs)
          (\ b -> xml_return (let {
                                (ba, c) = b;
                              } in Tree_Automaton a ba c))));

ta_normal_lhs ::
  forall a.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char])
          (Sum (a, [[Prelude.Char]]) [Prelude.Char]);
ta_normal_lhs xml2name =
  xml_do ['l', 'h', 's']
    (xml_or (xml_take state (\ a -> xml_return (Inr a)))
      (xml_take xml2name
        (\ a ->
          xml_take_many_sub [] zero_nat Infinity_enat state
            (\ b -> xml_return (Inl (a, b))))));

not_wn_ta ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Not_wn_ta_prf (Lab a b) [Prelude.Char]);
not_wn_ta xml2name =
  xml_do
    ['n', 'o', 't', 'W', 'N', 'T', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a',
      't', 'o', 'n']
    (xml_take (tree_automaton (ta_normal_lhs xml2name))
      (\ a ->
        xml_take closed_criterion (\ b -> xml_return (Not_wn_ta_prf a b))));

precedence_weight ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Nat -> ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat));
precedence_weight xml2name =
  xml_do
    ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'W', 'e', 'i', 'g', 'h',
      't']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'W', 'e', 'i', 'g',
          'h', 't', 'E', 'n', 't', 'r', 'y']
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat ['a', 'r', 'i', 't', 'y'])
              (\ a ->
                xml_take
                  (xml_nat ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e'])
                  (\ p ->
                    xml_take (xml_nat ['w', 'e', 'i', 'g', 'h', 't'])
                      (\ w ->
                        xml_take_optional
                          (xml_do
                            ['s', 'u', 'b', 't', 'e', 'r', 'm', 'C', 'o', 'e',
                              'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', 'E', 'n',
                              't', 'r', 'i', 'e', 's']
                            (xml_take_many_sub [] zero_nat Infinity_enat
                              (xml_nat ['e', 'n', 't', 'r', 'y']) xml_return))
                          (\ e -> xml_return ((f, a), (p, (w, e))))))))))
      (\ ret -> xml_return (\ a -> (ret, a))));

knuth_bendix_order ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Redtriple_impl a);
knuth_bendix_order xml2name =
  xml_do
    ['k', 'n', 'u', 't', 'h', 'B', 'e', 'n', 'd', 'i', 'x', 'O', 'r', 'd', 'e',
      'r']
    (xml_take (xml_nat ['w', '0'])
      (\ w0 ->
        xml_take (precedence_weight xml2name)
          (\ prw ->
            xml_take_default [] (afs xml2name)
              (\ afsa -> xml_return (KBO (prw w0) afsa)))));

arctic_rat_linear_poly ::
  forall a.
    Interpretation a -> ((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]));
arctic_rat_linear_poly (Arctic_rat_linear_poly x4) = x4;

real_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Real)]);
real_non_linear_poly (Real_non_linear_poly x13) = x13;

rat_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Rat)]);
rat_non_linear_poly (Rat_non_linear_poly x12) = x12;

int_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Int)]);
int_non_linear_poly (Int_non_linear_poly x11) = x11;

arctic_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), (Arctic, [Arctic]));
arctic_linear_poly (Arctic_linear_poly x3) = x3;

arctic_rat_matrix ::
  forall a.
    Interpretation a ->
      ((a, Nat), (Mat (Arctic_delta Rat), [Mat (Arctic_delta Rat)]));
arctic_rat_matrix (Arctic_rat_matrix x9) = x9;

real_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Real, [Real]));
real_linear_poly (Real_linear_poly x5) = x5;

rat_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Rat, [Rat]));
rat_linear_poly (Rat_linear_poly x2) = x2;

int_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Int, [Int]));
int_linear_poly (Int_linear_poly x1) = x1;

arctic_matrix ::
  forall a. Interpretation a -> ((a, Nat), (Mat Arctic, [Mat Arctic]));
arctic_matrix (Arctic_matrix x8) = x8;

real_matrix :: forall a. Interpretation a -> ((a, Nat), (Mat Real, [Mat Real]));
real_matrix (Real_matrix x10) = x10;

rat_matrix :: forall a. Interpretation a -> ((a, Nat), (Mat Rat, [Mat Rat]));
rat_matrix (Rat_matrix x7) = x7;

int_matrix :: forall a. Interpretation a -> ((a, Nat), (Mat Int, [Mat Int]));
int_matrix (Int_matrix x6) = x6;

class_semiring ::
  forall a b.
    (Ceq a, Ccompare a, One a, Plus a, Times a, Zero a,
      Set_impl a) => Itself a ->
                       b -> Partial_object_ext a (Monoid_ext a (Ring_ext a b));
class_semiring uu b =
  Partial_object_ext top_set (Monoid_ext times onea (Ring_ext zerob plus b));

real_domain :: Xml -> Sum_bot [Prelude.Char] Real;
real_domain =
  singleton
    ['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c', 'N', 'u', 'm', 'b', 'e', 'r',
      's']
    (singleton ['d', 'e', 'l', 't', 'a'] real id) id;

rat_domain :: Xml -> Sum_bot [Prelude.Char] Rat;
rat_domain =
  singleton ['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's']
    (singleton ['d', 'e', 'l', 't', 'a'] rat id) id;

basic_domain :: Xml -> Sum_bot [Prelude.Char] (Nat -> Domain);
basic_domain =
  options
    [(['n', 'a', 't', 'u', 'r', 'a', 'l', 's'],
       leaf ['n', 'a', 't', 'u', 'r', 'a', 'l', 's'] Natural),
      (['i', 'n', 't', 'e', 'g', 'e', 'r', 's'],
        leaf ['i', 'n', 't', 'e', 'g', 'e', 'r', 's'] (\ _ -> Integera)),
      (['a', 'r', 'c', 't', 'i', 'c'],
        singleton ['a', 'r', 'c', 't', 'i', 'c']
          (singleton ['d', 'o', 'm', 'a', 'i', 'n']
            (options
              [(['n', 'a', 't', 'u', 'r', 'a', 'l', 's'],
                 leaf ['n', 'a', 't', 'u', 'r', 'a', 'l', 's'] (\ _ -> Arctic)),
                (['i', 'n', 't', 'e', 'g', 'e', 'r', 's'],
                  leaf ['i', 'n', 't', 'e', 'g', 'e', 'r', 's']
                    (\ _ -> Arctic)),
                (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's'],
                  change rat_domain (\ _ _ -> Arctic_rat))])
            id)
          id),
      (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's'],
        change rat_domain Rational),
      (['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c', 'N', 'u', 'm', 'b', 'e',
         'r', 's'],
        change real_domain Mini_Alg)];

interpretation_type :: Xml -> Sum_bot [Prelude.Char] Domain;
interpretation_type =
  singleton ['t', 'y', 'p', 'e']
    (options
      [(['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l'],
         pair ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']
           (singleton ['d', 'o', 'm', 'a', 'i', 'n']
             (options
               [(['n', 'a', 't', 'u', 'r', 'a', 'l', 's'], basic_domain),
                 (['i', 'n', 't', 'e', 'g', 'e', 'r', 's'], basic_domain),
                 (['a', 'r', 'c', 't', 'i', 'c'], basic_domain),
                 (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's'], basic_domain),
                 (['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c', 'N', 'u', 'm',
                    'b', 'e', 'r', 's'],
                   basic_domain),
                 (['m', 'a', 't', 'r', 'i', 'c', 'e', 's'],
                   triple ['m', 'a', 't', 'r', 'i', 'c', 'e', 's']
                     (nata ['d', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n'])
                     (nata ['s', 't', 'r', 'i', 'c', 't', 'D', 'i', 'm', 'e',
                             'n', 's', 'i', 'o', 'n'])
                     (singleton ['d', 'o', 'm', 'a', 'i', 'n'] basic_domain id)
                     (\ di sd domain d ->
                       (case domain d of {
                         Natural _ -> Int_mat di sd;
                         Integera -> Int_mat di sd;
                         Arctic -> Arctic_mat di;
                         Arctic_rat -> Arctic_rat_mat di;
                         Rational _ _ -> Rat_mat di sd;
                         Mini_Alg _ _ -> Mini_Alg_mat di sd;
                       })))])
             id)
           (nata ['d', 'e', 'g', 'r', 'e', 'e']) (\ typea -> typea)),
        (['m', 'a', 't', 'r', 'i', 'x', 'I', 'n', 't', 'e', 'r', 'p', 'r', 'e',
           't', 'a', 't', 'i', 'o', 'n'],
          triple
            ['m', 'a', 't', 'r', 'i', 'x', 'I', 'n', 't', 'e', 'r', 'p', 'r',
              'e', 't', 'a', 't', 'i', 'o', 'n']
            (singleton ['d', 'o', 'm', 'a', 'i', 'n'] basic_domain id)
            (nata ['d', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n'])
            (nata ['s', 't', 'r', 'i', 'c', 't', 'D', 'i', 'm', 'e', 'n', 's',
                    'i', 'o', 'n'])
            (\ domain di sd -> (case domain zero_nat of {
                                 Natural _ -> Int_mat di sd;
                                 Integera -> Int_mat di sd;
                                 Arctic -> Arctic_mat di;
                                 Arctic_rat -> Arctic_rat_mat di;
                                 Rational _ _ -> Rat_mat di sd;
                                 Mini_Alg _ _ -> Mini_Alg_mat di sd;
                               })))])
    id;

arctic_rat_coeff :: Xml -> Sum_bot [Prelude.Char] (Arctic_delta Rat);
arctic_rat_coeff =
  options
    [(['i', 'n', 't', 'e', 'g', 'e', 'r'], change rat Num_arc_delta),
      (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l'], change rat Num_arc_delta),
      (['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y'],
        leaf ['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y']
          MinInfty_delta)];

arctic_coeff :: Xml -> Sum_bot [Prelude.Char] Arctic;
arctic_coeff =
  options
    [(['i', 'n', 't', 'e', 'g', 'e', 'r'],
       change (int ['i', 'n', 't', 'e', 'g', 'e', 'r']) Num_arc),
      (['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y'],
        leaf ['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y']
          MinInfty)];

polynomial ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Tpoly Nat a);
polynomial xml2coeff x =
  singleton ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']
    (options
      [(['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't'],
         singleton ['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't']
           xml2coeff PNum),
        (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'],
          change (nata ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'])
            (\ n -> PVar (minus_nat n one_nat))),
        (['s', 'u', 'm'], many ['s', 'u', 'm'] (polynomial xml2coeff) PSum),
        (['p', 'r', 'o', 'd', 'u', 'c', 't'],
          many ['p', 'r', 'o', 'd', 'u', 'c', 't'] (polynomial xml2coeff)
            PMult)])
    id x;

fit_length ::
  forall a.
    Partial_object_ext a (Monoid_ext a (Ring_ext a ())) -> Nat -> [a] -> [a];
fit_length c n uu =
  (if equal_nat n zero_nat then []
    else (case uu of {
           [] -> replicate (suc (minus_nat n one_nat)) (zero c);
           b : bs -> b : fit_length c (minus_nat n one_nat) bs;
         }));

interpretation ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
interpretation bi xml2name =
  many1_gen
    ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
    interpretation_type
    (\ a ->
      (case a of {
        Natural deg ->
          (if less_eq_nat deg one_nat && not bi
            then triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial int_coeff x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Int_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial int_coeff x)
                       (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Int_non_linear_poly ((f, aa), poly)));
        Integera ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x -> binda (polynomial int_coeff x) (\ p -> returna (poly_of p)))
            (\ f aa poly -> Int_non_linear_poly ((f, aa), poly));
        Arctic ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial arctic_coeff x)
                (lpoly_of (class_semiring Type ())))
            (\ f aa poly ->
              Arctic_linear_poly
                ((f, aa),
                  (fst poly,
                    fit_length (class_semiring Type ()) aa (snd poly))));
        Arctic_rat ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial arctic_rat_coeff x)
                (lpoly_of (class_semiring Type ())))
            (\ f aa poly ->
              Arctic_rat_linear_poly
                ((f, aa),
                  (fst poly,
                    fit_length (class_semiring Type ()) aa (snd poly))));
        Int_mat n _ ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff n zero_int int_coeff) x)
                (lpoly_of (mat_ring Type n ())))
            (\ f aa poly ->
              Int_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring Type n ()) aa (snd poly))));
        Arctic_mat n ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff n MinInfty arctic_coeff) x)
                (lpoly_of (mat_ring Type n ())))
            (\ f aa poly ->
              Arctic_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring Type n ()) aa (snd poly))));
        Arctic_rat_mat n ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff n MinInfty_delta arctic_rat_coeff) x)
                (lpoly_of (mat_ring Type n ())))
            (\ f aa poly ->
              Arctic_rat_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring Type n ()) aa (snd poly))));
        Rational _ deg ->
          (if less_eq_nat deg one_nat && not bi
            then triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial rat x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Rat_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial rat x) (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Rat_non_linear_poly ((f, aa), poly)));
        Rat_mat n _ ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff n zero_rat rat) x)
                (lpoly_of (mat_ring Type n ())))
            (\ f aa poly ->
              Rat_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring Type n ()) aa (snd poly))));
        Mini_Alg _ deg ->
          (if less_eq_nat deg one_nat && not bi
            then triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial real x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Real_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial real x) (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Real_non_linear_poly ((f, aa), poly)));
        Mini_Alg_mat n _ ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff n zero_real real) x)
                (lpoly_of (mat_ring Type n ())))
            (\ f aa poly ->
              Real_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring Type n ()) aa (snd poly))));
      }))
    (\ typea pi ->
      (case typea of {
        Natural deg ->
          (if less_eq_nat deg one_nat && not bi
            then Int_carrier (map int_linear_poly pi)
            else Int_nl_carrier (map int_non_linear_poly pi));
        Integera -> Int_nl_carrier (map int_non_linear_poly pi);
        Arctic -> Arctic_carrier (map arctic_linear_poly pi);
        Arctic_rat -> Arctic_rat_carrier (map arctic_rat_linear_poly pi);
        Int_mat n sd -> Int_mat_carrier n sd (map int_matrix pi);
        Arctic_mat n -> Arctic_mat_carrier n (map arctic_matrix pi);
        Arctic_rat_mat n -> Arctic_rat_mat_carrier n (map arctic_rat_matrix pi);
        Rational d deg ->
          (if less_eq_nat deg one_nat && not bi
            then Rat_carrier (map rat_linear_poly pi)
            else Rat_nl_carrier d (map rat_non_linear_poly pi));
        Rat_mat n sd -> Rat_mat_carrier n sd (map rat_matrix pi);
        Mini_Alg d deg ->
          (if less_eq_nat deg one_nat && not bi
            then Real_carrier (map real_linear_poly pi)
            else Real_nl_carrier d (map real_non_linear_poly pi));
        Mini_Alg_mat n sd -> Real_mat_carrier n sd (map real_matrix pi);
      }));

wpo_params ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) [((a, Nat), (Nat, [Nat]))];
wpo_params xml2name =
  xml_do
    ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'S', 't', 'a', 't', 'u',
      's']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'S', 't', 'a', 't',
          'u', 's', 'E', 'n', 't', 'r', 'y']
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat ['a', 'r', 'i', 't', 'y'])
              (\ a ->
                xml_take
                  (xml_nat ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e'])
                  (\ p ->
                    xml_take
                      (xml_do ['s', 't', 'a', 't', 'u', 's']
                        (xml_take_many_sub [] zero_nat Infinity_enat position
                          xml_return))
                      (\ s -> xml_return ((f, a), (p, s))))))))
      xml_return);

status_precedence ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       [((a, Nat), (Nat, Order_tag))];
status_precedence xml2name =
  xml_do
    ['s', 't', 'a', 't', 'u', 's', 'P', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c',
      'e']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['s', 't', 'a', 't', 'u', 's', 'P', 'r', 'e', 'c', 'e', 'd', 'e', 'n',
          'c', 'e', 'E', 'n', 't', 'r', 'y']
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat ['a', 'r', 'i', 't', 'y'])
              (\ a ->
                xml_take
                  (xml_nat ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e'])
                  (\ p ->
                    xml_take
                      (xml_or (xml_leaf ['l', 'e', 'x'] Lex)
                        (xml_leaf ['m', 'u', 'l'] Mul))
                      (\ s -> xml_return ((f, a), (p, s))))))))
      xml_return);

path_order ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Redtriple_impl a);
path_order xml2name =
  xml_do ['p', 'a', 't', 'h', 'O', 'r', 'd', 'e', 'r']
    (xml_take (status_precedence xml2name)
      (\ prec_tau ->
        xml_take_default [] (afs xml2name)
          (\ af -> xml_return (RPO prec_tau af))));

redtriple ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   Bool ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) (Redtriple_impl a);
redtriple xml2name bi x =
  xml_or (path_order xml2name)
    (xml_or (knuth_bendix_order xml2name)
      (xml_or
        (xml_do
          ['w', 'e', 'i', 'g', 'h', 't', 'e', 'd', 'P', 'a', 't', 'h', 'O', 'r',
            'd', 'e', 'r']
          (xml_take (wpo_params xml2name)
            (\ a ->
              xml_take (redtriple xml2name bi) (\ b -> xml_return (WPO a b)))))
        (xmlt2 (interpretation bi (xmlt_of_xmlt2 xml2name)))))
    x;

joinable_critical_pairs ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       [(Term a [Prelude.Char],
                          ([(Pos, ((Term a [Prelude.Char],
                                     Term a [Prelude.Char]),
                                    Term a [Prelude.Char]))],
                            (Term a [Prelude.Char],
                              [(Pos, ((Term a [Prelude.Char],
Term a [Prelude.Char]),
                                       Term a [Prelude.Char]))])))];
joinable_critical_pairs xml2name =
  let {
    rew = rsteps xml2name;
  } in xml_do
         ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i', 'c',
           'a', 'l', 'P', 'a', 'i', 'r', 's']
         (xml_take_many_sub [] zero_nat Infinity_enat
           (xml_do
             ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i',
               'c', 'a', 'l', 'P', 'a', 'i', 'r']
             (xml_take rew
               (\ (s, sseq) ->
                 xml_take rew
                   (\ (t, tseq) -> xml_return (s, (sseq, (t, tseq)))))))
           xml_return);

wcr_proof ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Join_info a);
wcr_proof xml2name =
  xml_do ['w', 'c', 'r', 'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_change (joinable_critical_pairs xml2name) (xml_return . Guided))
        (xml_or
          (xml_change
            (xml_nat
              ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i',
                'c', 'a', 'l', 'P', 'a', 'i', 'r', 's', 'B', 'F', 'S'])
            (xml_return . Join_BFS))
          (xml_leaf
            ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i',
              'c', 'a', 'l', 'P', 'a', 'i', 'r', 's', 'A', 'u', 't', 'o']
            Join_NF)))
      (\ x -> xml_return (id x)));

formula_parser ::
  forall a b c.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) (Formula (Term a (b, c)))) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) (Formula (Term a (b, c)));
formula_parser atom_parser x =
  xml_or
    (xml_do ['d', 'i', 's', 'j', 'u', 'n', 'c', 't', 'i', 'o', 'n']
      (xml_take_many_sub [] zero_nat Infinity_enat (formula_parser atom_parser)
        (\ fs -> xml_return (Disjunction fs))))
    (xml_or
      (xml_do ['c', 'o', 'n', 'j', 'u', 'n', 'c', 't', 'i', 'o', 'n']
        (xml_take_many_sub [] zero_nat Infinity_enat
          (formula_parser atom_parser) (\ fs -> xml_return (Conjunction fs))))
      atom_parser)
    x;

transition_parser ::
  forall a b c d e.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      ((Xml, ([([Prelude.Char], [Prelude.Char])],
               (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) b) ->
        ((Xml, ([([Prelude.Char], [Prelude.Char])],
                 (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) (Formula (Term c (Trans_var d, e)))) ->
          (Xml, ([([Prelude.Char], [Prelude.Char])],
                  (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
            Sum (Xml_error [Prelude.Char]) (b, Transition_rule c d e a);
transition_parser location_parser trans_parser tatom_parser =
  xml_do ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n']
    (xml_take trans_parser
      (\ tr ->
        xml_take
          (xml_do ['s', 'o', 'u', 'r', 'c', 'e']
            (xml_take location_parser xml_return))
          (\ l ->
            xml_take
              (xml_do ['t', 'a', 'r', 'g', 'e', 't']
                (xml_take location_parser xml_return))
              (\ r ->
                xml_take
                  (xml_do ['f', 'o', 'r', 'm', 'u', 'l', 'a']
                    (xml_take (formula_parser tatom_parser) xml_return))
                  (\ phi -> xml_return (tr, Transition l r phi))))));

lts_parser ::
  forall a b c d e.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      ((Xml, ([([Prelude.Char], [Prelude.Char])],
               (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) b) ->
        ((Xml, ([([Prelude.Char], [Prelude.Char])],
                 (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) (Formula (Term c (Trans_var d, e)))) ->
          [Prelude.Char] ->
            (Xml, ([([Prelude.Char], [Prelude.Char])],
                    (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
              Sum (Xml_error [Prelude.Char]) (Lts_impl c d e a b);
lts_parser location_parser trans_parser tatom_parser tag =
  xml_do tag
    (xml_take
      (xml_do ['i', 'n', 'i', 't', 'i', 'a', 'l']
        (xml_take_many_sub [] one_nat Infinity_enat location_parser xml_return))
      (\ i ->
        xml_take_many_sub [] zero_nat Infinity_enat
          (transition_parser location_parser trans_parser tatom_parser)
          (\ t -> xml_return (Lts_Impl i t []))));

safety_input_parser ::
  forall a b c d e.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      ((Xml, ([([Prelude.Char], [Prelude.Char])],
               (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) b) ->
        ((Xml, ([([Prelude.Char], [Prelude.Char])],
                 (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) (Formula (Term c (Trans_var d, e)))) ->
          (Xml, ([([Prelude.Char], [Prelude.Char])],
                  (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
            Sum (Xml_error [Prelude.Char]) (Lts_impl c d e a b, [a]);
safety_input_parser location_parser trans_parser tatom_parser =
  xml_do ['l', 't', 's', 'S', 'a', 'f', 'e', 't', 'y', 'I', 'n', 'p', 'u', 't']
    (xml_take
      (lts_parser location_parser trans_parser tatom_parser ['l', 't', 's'])
      (\ lts ->
        xml_take
          (xml_do ['e', 'r', 'r', 'o', 'r']
            (xml_take_many_sub [] one_nat Infinity_enat location_parser
              xml_return))
          (\ err -> xml_return (lts, err))));

variable_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) [Prelude.Char];
variable_parser = xml_text ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'I', 'd'];

trans_var_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) (Trans_var [Prelude.Char]);
trans_var_parser =
  xml_or
    (xml_do ['p', 'o', 's', 't']
      (xml_take variable_parser (\ v -> xml_return (Post v))))
    (xml_or (xml_change (xml_text ['a', 'u', 'x']) (xml_return . Intermediate))
      (xml_change variable_parser (xml_return . Pre)));

exp_parsera ::
  forall a.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) (Term Sig (a, Ty));
exp_parsera v xml =
  xml_or
    (xml_do ['p', 'r', 'o', 'd', 'u', 'c', 't']
      (xml_take_many_sub [] zero_nat Infinity_enat (exp_parsera v)
        (\ exps -> xml_return (Fun (Mult (size_list exps)) exps))))
    (xml_or
      (xml_do ['s', 'u', 'm']
        (xml_take_many_sub [] zero_nat Infinity_enat (exp_parsera v)
          (\ exps -> xml_return (Fun (Sum (size_list exps)) exps))))
      (xml_or
        (xml_change (xml_int ['c', 'o', 'n', 's', 't', 'a', 'n', 't'])
          (\ i -> xml_return (Fun (Const i) [])))
        (xml_change v (\ x -> xml_return (Var (x, IntT))))))
    xml;

bexp_parser ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Term Sig (a, Ty));
bexp_parser v =
  xml_or
    (xml_do ['l', 'e', 'q']
      (xml_take (exp_parsera v)
        (\ l ->
          xml_take (exp_parsera v) (\ r -> xml_return (Fun Lesseq [l, r])))))
    (xml_or
      (xml_do ['l', 'e', 's', 's']
        (xml_take (exp_parsera v)
          (\ l ->
            xml_take (exp_parsera v) (\ r -> xml_return (Fun Less [l, r])))))
      (xml_do ['e', 'q']
        (xml_take (exp_parsera v)
          (\ l ->
            xml_take (exp_parsera v)
              (\ r -> xml_return (Fun Equals [l, r]))))));

tatom_parsera ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char])
      (Formula (Term Sig (Trans_var [Prelude.Char], Ty)));
tatom_parsera = xml_change (bexp_parser trans_var_parser) (xml_return . Atom);

location_parser ::
  forall a.
    ([Prelude.Char] ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a;
location_parser location_id_parser =
  location_id_parser ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n', 'I', 'd'];

lts_safety_input_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char])
      (Lts_impl Sig [Prelude.Char] Ty [Prelude.Char] [Prelude.Char],
        [[Prelude.Char]]);
lts_safety_input_parser =
  safety_input_parser (location_parser xml_text) (trans_id xml_text)
    tatom_parsera;

xml2equational_input ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Input a [Prelude.Char]);
xml2equational_input xml2name =
  xml_do
    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'a', 's', 'o',
      'n', 'i', 'n', 'g', 'I', 'n', 'p', 'u', 't']
    (xml_take
      (xml_do ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's']
        (xml_take (rules xml2name) xml_return))
      (\ eqs ->
        xml_take
          (xml_or
            (xml_do ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n']
              (xml_take (term xml2name)
                (\ a ->
                  xml_take (term xml2name)
                    (\ b -> xml_return (Equation (a, b))))))
            (xml_do ['i', 'n', 'e', 'q', 'u', 'a', 'l', 'i', 't', 'y']
              (xml_take (term xml2name)
                (\ a ->
                  xml_take (term xml2name)
                    (\ b -> xml_return (Inequality (a, b)))))))
          (\ goal -> xml_return (EQ_input eqs goal))));

xml2completion_input ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Input a [Prelude.Char]);
xml2completion_input xml2name =
  xml_do
    ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'I', 'n', 'p', 'u', 't']
    (xml_take
      (xml_do ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's']
        (xml_take (rules xml2name) xml_return))
      (\ a ->
        xml_take (xml_do ['t', 'r', 's'] (xml_take (rules xml2name) xml_return))
          (\ b -> xml_return (COMP_input a b))));

cPFsignature ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) [(a, Nat)];
cPFsignature xml2name =
  symbols xml2name ['s', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e'];

complexity_measure ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Complexity_measure a [Prelude.Char]);
complexity_measure xml2name =
  xml_or
    (xml_do
      ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o',
        'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
      (xml_take (cPFsignature xml2name)
        (\ a -> xml_return (Derivational_Complexity a))))
    (xml_do
      ['r', 'u', 'n', 't', 'i', 'm', 'e', 'C', 'o', 'm', 'p', 'l', 'e', 'x',
        'i', 't', 'y']
      (xml_take (cPFsignature xml2name)
        (\ a ->
          xml_take (cPFsignature xml2name)
            (\ b -> xml_return (Runtime_Complexity a b)))));

complexity_class ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) Complexity_class;
complexity_class =
  xml_change (xml_nat ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l'])
    (xml_return . Comp_Poly);

forbidden_pattern ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Ctxt a [Prelude.Char],
                         (Term a [Prelude.Char], Location));
forbidden_pattern xml2name =
  xml_do
    ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e', 'r',
      'n']
    (xml_take (term xml2name)
      (\ t ->
        xml_take pos
          (\ p ->
            xml_take
              (xml_or (xml_leaf ['h', 'e', 'r', 'e'] H)
                (xml_or (xml_leaf ['a', 'b', 'o', 'v', 'e'] A)
                  (xml_or (xml_leaf ['b', 'e', 'l', 'o', 'w'] Ba)
                    (xml_leaf ['b', 'e', 'l', 'o', 'w'] Ra))))
              (\ l ->
                (if in_poss p t
                  then xml_return (ctxt_of_pos_term p t, (subt_at t p, l))
                  else xml_error
                         ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'd', 'o',
                           'e', 's', ' ', 'n', 'o', 't', ' ', 'e', 'x', 'i',
                           's', 't', ' ', 'i', 'n', ' ', 't', 'e', 'r',
                           'm'])))));

forbidden_patterns ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       [(Ctxt a [Prelude.Char],
                          (Term a [Prelude.Char], Location))];
forbidden_patterns xml2name =
  xml_do
    ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e', 'r',
      'n', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat (forbidden_pattern xml2name)
      xml_return);

replacement_map ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) [((a, Nat), [Nat])];
replacement_map xml2name =
  xml_do
    ['c', 'o', 'n', 't', 'e', 'x', 't', 'S', 'e', 'n', 's', 'i', 't', 'i', 'v',
      'e']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['r', 'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', 'M', 'a', 'p',
          'E', 'n', 't', 'r', 'y']
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat ['a', 'r', 'i', 't', 'y'])
              (\ a ->
                xml_take_many_sub [] zero_nat Infinity_enat position
                  (\ is -> xml_return ((f, a), is))))))
      xml_return);

inn_fp_strategy ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Sum (Strategy a [Prelude.Char])
                         (Fp_strategy a [Prelude.Char]));
inn_fp_strategy xml2name =
  xml_do ['s', 't', 'r', 'a', 't', 'e', 'g', 'y']
    (xml_take
      (xml_or
        (xml_leaf ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'] (Inl Innermost))
        (xml_or
          (xml_leaf ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't']
            (Inr Outermost))
          (xml_or
            (xml_change (replacement_map xml2name)
              (\ p -> xml_return (Inr (Context_Sensitive p))))
            (xml_or
              (xml_change (forbidden_patterns xml2name)
                (\ p -> xml_return (Inr (Forbidden_Patterns p))))
              (xml_change (innermostLhss xml2name)
                (\ q -> xml_return (Inl (Innermost_Q q))))))))
      xml_return);

xml2_trs_input ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Input a [Prelude.Char]);
xml2_trs_input xml2name =
  xml_do ['t', 'r', 's', 'I', 'n', 'p', 'u', 't']
    (xml_take (xml_do ['t', 'r', 's'] (xml_take (rules xml2name) xml_return))
      (\ r ->
        xml_take_default (Inl No_Strategy) (inn_fp_strategy xml2name)
          (\ str ->
            xml_take_default []
              (xml_do
                ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'R', 'u', 'l', 'e',
                  's']
                (xml_take (rules xml2name) xml_return))
              (\ rel ->
                (case str of {
                  Inl istrat -> xml_return (Inn_TRS_input istrat r rel Full);
                  Inr fpstrat ->
                    (if null rel then xml_return (FP_TRS_input fpstrat r)
                      else xml_error
                             ['t', 'h', 'e', ' ', 'c', 'o', 'm', 'b', 'i', 'n',
                               'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 'r',
                               'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u',
                               'l', 'e', 's', ' ', 'w', 'i', 't', 'h', ' ', 's',
                               't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ',
                               'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 's', 'u',
                               'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'f', 'o',
                               'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's',
                               't']);
                })))));

xml2complexity_input ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Input a [Prelude.Char]);
xml2complexity_input xml2name =
  xml_do
    ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'I', 'n', 'p', 'u', 't']
    (xml_take
      (xml_change (xml2_trs_input xml2name)
        (\ a ->
          (case a of {
            DP_input _ _ _ _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
            Inn_TRS_input q r s start -> xml_return (q, (r, (s, start)));
            CPX_input _ _ _ _ _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
            COMP_input _ _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
            EQ_input _ _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
            FP_TRS_input _ _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
            CTRS_input _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
            TA_input _ _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
            AC_input _ _ _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
            LTS_input _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
            LTS_safety_input _ _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
            Unknown_input _ ->
              xml_error
                ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e',
                  'r', 'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't',
                  ' ', 't', 'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
          })))
      (\ (q, (r, (s, _))) ->
        xml_take (complexity_measure xml2name)
          (\ cm ->
            xml_take complexity_class
              (\ cc -> xml_return (CPX_input q r s cm cc)))));

lts_input_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char])
      (Lts_impl Sig [Prelude.Char] Ty [Prelude.Char] [Prelude.Char]);
lts_input_parser =
  lts_parser (location_parser xml_text) (trans_id xml_text) tatom_parsera
    ['l', 't', 's'];

xml2unknown_input ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) [Prelude.Char];
xml2unknown_input =
  xml_text ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't'];

symbols_no_arity ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   [Prelude.Char] ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) [a];
symbols_no_arity xml2name tagname =
  xml_do tagname
    (xml_take_many_sub [] zero_nat Infinity_enat xml2name xml_return);

xml2ac_tp_input ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Input a [Prelude.Char]);
xml2ac_tp_input xml2name =
  xml_do
    ['a', 'c', 'R', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'y', 's', 't', 'e', 'm']
    (xml_take
      (xml_do ['t', 'r', 's']
        (xml_take (rules xml2name) (\ x -> xml_return (id x))))
      (\ a ->
        xml_take
          (symbols_no_arity xml2name ['A', 's', 'y', 'm', 'b', 'o', 'l', 's'])
          (\ b ->
            xml_take
              (symbols_no_arity xml2name
                ['C', 's', 'y', 'm', 'b', 'o', 'l', 's'])
              (\ c -> xml_return (AC_input a b c)))));

xml2ctrs_input ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Input a [Prelude.Char]);
xml2ctrs_input xml2name =
  xml_do ['c', 't', 'r', 's', 'I', 'n', 'p', 'u', 't']
    (xml_take
      (xml_do ['r', 'u', 'l', 'e', 's']
        (xml_take_many_sub [] zero_nat Infinity_enat
          (crule xml2name ['r', 'u', 'l', 'e']) xml_return))
      (\ a -> xml_return (CTRS_input a)));

xml2dp_input ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Input a [Prelude.Char]);
xml2dp_input xml2name =
  xml_do ['d', 'p', 'I', 'n', 'p', 'u', 't']
    (xml_take
      (xml_do ['t', 'r', 's']
        (xml_take (rules xml2name) (\ x -> xml_return (id x))))
      (\ r ->
        xml_take
          (xml_do ['d', 'p', 's']
            (xml_take (rules xml2name) (\ x -> xml_return (id x))))
          (\ p ->
            xml_take_default No_Strategy (strategy xml2name)
              (\ s ->
                xml_take (xml_bool ['m', 'i', 'n', 'i', 'm', 'a', 'l'])
                  (\ m -> xml_return (DP_input m p s r))))));

xml2input ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Input a [Prelude.Char]);
xml2input xml2name =
  xml_do ['i', 'n', 'p', 'u', 't']
    (xml_take
      (xml_or (xml2dp_input xml2name)
        (xml_or (xml2completion_input xml2name)
          (xml_or (xml2_trs_input xml2name)
            (xml_or (xml2equational_input xml2name)
              (xml_or (xml2complexity_input xml2name)
                (xml_or (xml2ctrs_input xml2name)
                  (xml_or
                    (xml_do
                      ['t', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't',
                        'o', 'n', 'P', 'r', 'o', 'b', 'l', 'e', 'm']
                      (xml_take (tree_automaton (ta_normal_lhs xml2name))
                        (\ a ->
                          xml_take
                            (xml_do ['t', 'r', 's']
                              (xml_take (rules xml2name)
                                (\ x -> xml_return (id x))))
                            (\ b -> xml_return (TA_input a b)))))
                    (xml_or (xml2ac_tp_input xml2name)
                      (xml_or
                        (xml_change lts_input_parser (xml_return . LTS_input))
                        (xml_or
                          (xml_change lts_safety_input_parser
                            (\ (x, y) -> xml_return (LTS_safety_input x y)))
                          (xml_change xml2unknown_input
                            (xml_return . Unknown_input))))))))))))
      (\ x -> xml_return (id x)));

missing ::
  [Prelude.Char] ->
    ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
missing s x =
  shows_string ['t', 'h', 'e', ' '] .
    shows_string s .
      shows_string [' '] .
        x . shows_string
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'];

toomuch ::
  [Prelude.Char] ->
    ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
toomuch s x =
  shows_string ['s', 'u', 'p', 'e', 'r', 'f', 'l', 'u', 'o', 'u', 's', ' '] .
    shows_string s . shows_string [' '] . x . x;

array_get :: forall a. Array.Array a -> Nat -> a;
array_get (Array.Array a) n = nth a n;

array_set :: forall a. Array.Array a -> Nat -> a -> Array.Array a;
array_set (Array.Array aa) n a = Array.Array (list_update aa n a);

as_length :: forall a. (Array.Array a, Nat) -> Nat;
as_length = snd;

array_shrink :: forall a. Array.Array a -> Nat -> Array.Array a;
array_shrink (Array.Array a) sz =
  (if less_nat (size_list a) sz then error "undefined"
    else Array.Array (take sz a));

array_length :: forall a. Array.Array a -> Nat;
array_length (Array.Array a) = size_list a;

as_shrink :: forall a. (Array.Array a, Nat) -> (Array.Array a, Nat);
as_shrink s =
  let {
    a = s;
    (aa, n) = a;
    ab = (if less_eq_nat (times_nat (nat_of_integer (128 :: Integer)) n)
               (array_length aa) &&
               less_nat (nat_of_integer (4 :: Integer)) n
           then array_shrink aa n else aa);
  } in (ab, n);

as_take :: forall a. Nat -> (Array.Array a, Nat) -> (Array.Array a, Nat);
as_take m s = let {
                a = s;
                (aa, n) = a;
              } in (if less_nat m n then as_shrink (aa, m) else (aa, n));

as_top :: forall a. (Array.Array a, Nat) -> a;
as_top s = let {
             a = s;
             (aa, n) = a;
           } in array_get aa (minus_nat n one_nat);

as_pop :: forall a. (Array.Array a, Nat) -> (Array.Array a, Nat);
as_pop s = let {
             a = s;
             (aa, n) = a;
           } in as_shrink (aa, minus_nat n one_nat);

as_get :: forall a. (Array.Array a, Nat) -> Nat -> a;
as_get s i = let {
               a = s;
               (aa, _) = a;
             } in array_get aa i;

while :: forall a. (a -> Bool) -> (a -> a) -> a -> a;
while b c s = (if b s then while b c (c s) else s);

pop_tr ::
  forall a.
    (Compare_order a) => ((Array.Array a, Nat),
                           ((Array.Array Nat, Nat),
                             (Rbta a Int, (Array.Array (Nat, [a]), Nat)))) ->
                           ((Array.Array a, Nat),
                             ((Array.Array Nat, Nat),
                               (Rbta a Int, (Array.Array (Nat, [a]), Nat))));
pop_tr s =
  let {
    (a, (aa, (ab, bb))) = s;
    x = minus_nat (as_length aa) one_nat;
    xa = let {
           (_, bc) =
             while (\ (xf, _) ->
                     less_nat xf
                       (if equal_nat (plus_nat x one_nat) (as_length aa)
                         then as_length a else as_get aa (plus_nat x one_nat)))
               (\ (ac, bc) ->
                 (suc ac,
                   rbt_insert (as_get a ac)
                     (uminus_int (Int_of_integer (1 :: Integer))) bc))
               (as_get aa x, ab);
         } in bc;
    xb = as_take (as_top aa) a;
    xc = as_pop aa;
  } in (xb, (xc, (xa, bb)));

gen_disjoint ::
  forall a b c d e f.
    (a -> (b -> b) -> (c -> d -> Bool) -> Bool -> e) ->
      (c -> f -> Bool) -> a -> f -> e;
gen_disjoint it1 mem2 s1 s2 = it1 s1 (\ x -> x) (\ x _ -> not (mem2 x s2)) True;

negatea ::
  forall a. (Showa a) => Term Sig (a, Ty) -> Formula (Term Sig (a, Ty));
negatea (Fun Less [a, b]) = Atom (Fun Lesseq [b, a]);
negatea (Fun Lesseq [a, b]) = Atom (Fun Less [b, a]);
negatea (Fun Equals [a, b]) =
  Disjunction [Atom (Fun Less [a, b]), Atom (Fun Less [b, a])];
negatea (Var v) = Conjunction [];
negatea (Fun Lesseq []) = Conjunction [];
negatea (Fun Lesseq [v]) = Conjunction [];
negatea (Fun Lesseq (v : vc : ve : vf)) = Conjunction [];
negatea (Fun (Sum vb) va) = Conjunction [];
negatea (Fun (Const vb) va) = Conjunction [];
negatea (Fun (Mult vb) va) = Conjunction [];
negatea (Fun Equals []) = Conjunction [];
negatea (Fun Equals [v]) = Conjunction [];
negatea (Fun Equals (v : vc : ve : vf)) = Conjunction [];
negatea (Fun v []) = Conjunction [];
negatea (Fun v [vb]) = Conjunction [];
negatea (Fun v (vb : vd : vf : vg)) = Conjunction [];

is_NF_subset :: forall a b. (Term a b -> Bool) -> [Term a b] -> Bool;
is_NF_subset is_Q_nf q = all (\ qa -> not (is_Q_nf qa)) q;

icap_impl_gen ::
  forall a.
    (Eq a) => Bool ->
                (Term a [Prelude.Char] -> Bool) ->
                  [Term a [Prelude.Char]] ->
                    [Term a [Prelude.Char]] ->
                      ([Prelude.Char] -> Bool) ->
                        Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char]);
icap_impl_gen nf isQnf ls s sx (Var x) =
  (if nf && sx x then Var (Inr x) else Var (Inl ()));
icap_impl_gen nf isQnf ls s sx (Fun f ts) =
  let {
    t = Fun f (map (icap_impl_gen nf isQnf ls s sx) ts);
  } in (if any (\ l ->
                 (case mgu_class t l of {
                   Nothing -> False;
                   Just mu ->
                     all (\ u ->
                           isQnf (subst_apply_term
                                   (map_term (\ x -> x) (\ a -> 'y' : a) u) mu))
                       (args l) &&
                       all (\ u -> isQnf (subst_apply_term u mu)) s;
                 }))
             ls
         then Var (Inl ()) else t);

ins_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
ins_rm_basic_ops x s = insert x () s;

g_from_list_aux_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> [a] -> Rbt a ();
g_from_list_aux_dflt_basic_oops_rm_basic_ops y [] = y;
g_from_list_aux_dflt_basic_oops_rm_basic_ops accs (x : l) =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops (ins_rm_basic_ops x accs) l;

empty_rm_basic_ops :: forall a. (Linorder a) => () -> Rbt a ();
empty_rm_basic_ops = (\ _ -> empty);

g_from_list_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => [a] -> Rbt a ();
g_from_list_dflt_basic_oops_rm_basic_ops l =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops (empty_rm_basic_ops ()) l;

memb_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Bool;
memb_rm_basic_ops x s = not (is_none (lookup s x));

ceta_set_of :: forall a. (Key a) => [a] -> a -> Bool;
ceta_set_of ps = let {
                   tree = g_from_list_dflt_basic_oops_rm_basic_ops ps;
                 } in (\ a -> memb_rm_basic_ops a tree);

icap_impl ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char]);
icap_impl isnf r =
  let {
    ls = map fst r;
    nf = is_NF_subset isnf ls;
    ic = icap_impl_gen nf isnf ls;
  } in (\ s -> let {
                 sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
                 sx = ceta_set_of (concatMap vars_term_list sa);
               } in (\ t -> ic sa sx (map_term (\ x -> x) (\ a -> 'x' : a) t)));

rep_subst_incr ::
  forall a b. Subst_incr a b -> (b -> Term a b, (Set b, Term a b -> [b]));
rep_subst_incr (Abs_subst_incr x) = x;

si_W :: forall a b. Subst_incr a b -> Term a b -> [b];
si_W xa = snd (snd (rep_subst_incr xa));

kbo_nstrict ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool)) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        (a -> Bool) ->
                          ((a, Nat) -> Nat -> Nat) ->
                            (Term a b, Term a b) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
kbo_nstrict pr w w0 least scf =
  (\ (s, t) ->
    check (snd (kbo_impl w w0 pr least scf s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term zero_nat s .
          shows_string [' ', '>', '=', 'K', 'B', 'O', ' '] .
            shows_prec_term zero_nat t . shows_nl));

succ_transitions ::
  forall a b c d e.
    (Eq d) => Lts_impl a b c d e -> d -> [Transition_rule a b c d];
succ_transitions (Lts_Impl i ts lc) l =
  concatMap (\ (_, tau) -> (if source tau == l then [tau] else [])) ts;

list_inter :: forall a. (Eq a) => [a] -> [a] -> [a];
list_inter [] bs = [];
list_inter (a : asa) bs =
  (if membera bs a then a : list_inter asa bs else list_inter asa bs);

list_union :: forall a. (Eq a) => [a] -> [a] -> [a];
list_union [] ys = ys;
list_union (x : xs) ys = let {
                           zs = list_union xs ys;
                         } in (if membera zs x then zs else x : zs);

default_I :: forall a. (Poly_carrier a) => a -> Nat -> [([(Nat, Nat)], a)];
default_I def n =
  ([], def) : map (\ i -> ([(i, one_nat)], onea)) (upt zero_nat n);

proper_prefix_list :: Pos -> [Pos];
proper_prefix_list Empty = [];
proper_prefix_list (PCons i p) = Empty : map (PCons i) (proper_prefix_list p);

prefix_list :: Pos -> [Pos];
prefix_list p = p : proper_prefix_list p;

scnp_arity :: forall a. [((a, Nat), [(Nat, Nat)])] -> Nat;
scnp_arity af = max_list (map (\ (_, a) -> size_list a) af);

rules_no_left_vara :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
rules_no_left_vara
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_no_left_var;

rules_mapc ::
  forall a b c d.
    Dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
rules_mapc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_map;

tcapRM_dpp ::
  forall a b c.
    (Eq b, Eq c) => Dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
tcapRM_dpp i dpp = tcapRM (rules_no_left_vara i dpp) (rules_mapc i dpp);

funas_term_list :: forall a b. Term a b -> [(a, Nat)];
funas_term_list (Var uu) = [];
funas_term_list (Fun f ts) = (f, size_list ts) : concatMap funas_term_list ts;

check_supt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Term a b ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_supt s t =
  check (supt_impl s t)
    (shows_prec_term zero_nat t .
      shows_string
        [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r', 'o', 'p',
          'e', 'r', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', ' ', 'o', 'f',
          ' '] .
        shows_prec_term zero_nat s);

compute_trancl ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Set_impl a) => Set a -> Set (a, a) -> Set a;
compute_trancl a r =
  let {
    b = imagea r a;
  } in (if less_eq_set b bot_set then bot_set
         else sup_set b
                (compute_trancl b
                  (filtera
                    (\ ab -> not (member (fst ab) a) && not (member (snd ab) b))
                    r)));

ta_res ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b () -> Term b a -> Set a;
ta_res ta (Fun f ts) =
  let {
    qs = map (ta_res ta) ts;
    g = (f, size_list ts);
  } in sup_set
         (image r_rhs
           (filtera
             (\ r ->
               r_sym r == g &&
                 all (\ qq -> member (snd qq) (fst qq))
                   (zip qs (r_lhs_states r)))
             (ta_rules ta)))
         (compute_trancl
           (image r_rhs
             (filtera
               (\ r ->
                 r_sym r == g &&
                   all (\ qq -> member (snd qq) (fst qq))
                     (zip qs (r_lhs_states r)))
               (ta_rules ta)))
           (ta_eps ta));
ta_res ta (Var q) =
  sup_set (inserta q bot_set) (compute_trancl (inserta q bot_set) (ta_eps ta));

eq_rule_mod_vars ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b, Term a b) -> (Term a b, Term a b) -> Bool;
eq_rule_mod_vars lr st = instance_rule lr st && instance_rule st lr;

is_NF_terms ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> Term a b -> Bool;
is_NF_terms q = is_NF_main (any is_Var q) (null q) (term_map q);

generate_var :: Nat -> [Prelude.Char];
generate_var i = 'x' : shows_prec_nat zero_nat i [];

uncurry_term ::
  forall a b. (Eq a) => a -> (a -> Nat -> [a]) -> Term a b -> Term a b;
uncurry_term a sm t =
  (case unapp a t of {
    (Var x, ts) -> apply_args a (Var x) (map (uncurry_term a sm) ts);
    (Fun f ss, ts) ->
      let {
        n = size_list ss;
        uss = map (uncurry_term a sm) ss;
        uts = map (uncurry_term a sm) ts;
        aa = aarity sm f n;
        m = min (size_list ts) aa;
        fm = get_symbol sm f n m;
      } in apply_args a (Fun fm (uss ++ take m uts)) (drop m uts);
  });

xml2claim ::
  forall a b.
    (Xml, ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) (Claim a b);
xml2claim =
  xml_or
    (xml_do ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'n', 'g']
      (xml_take_optional
        (xml_do ['u', 'p', 'p', 'e', 'r', 'b', 'o', 'u', 'n', 'd']
          (xml_take
            (xml_do ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']
              (xml_take_attribute ['d', 'e', 'g', 'r', 'e', 'e']
                (\ deg_s -> (case nat_of_string deg_s of {
                              Inl a -> xml_error a;
                              Inr deg -> xml_return (Upperbound deg);
                            }))))
            xml_return))
        (\ a -> (case a of {
                  Nothing -> xml_return Terminating;
                  Just aa -> xml_return aa;
                }))))
    (xml_or
      (xml_leaf
        ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'n', 'g']
        Nonterminating)
      (xml_or (xml_leaf ['c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 't'] Confluent)
        (xml_leaf ['n', 'o', 'n', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 't']
          Nonconfluent)));

conversion ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Term a [Prelude.Char],
                         [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                                  (Bool, Term a [Prelude.Char])))]);
conversion xml2name =
  xml_do ['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n']
    (xml_take
      (xml_do ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm']
        (xml_take (term xml2name) (\ x -> xml_return (id x))))
      (\ a ->
        xml_take_many_sub [] zero_nat Infinity_enat (estep xml2name)
          (\ b -> xml_return (a, b))));

plain_name ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) (Lab [Prelude.Char] [Nat]);
plain_name x =
  xml_or (xml_change (xml_text ['n', 'a', 'm', 'e']) (xml_return . UnLab))
    (xml_or
      (xml_do ['s', 'h', 'a', 'r', 'p']
        (xml_take plain_name (\ xa -> xml_return (Sharp xa))))
      (xml_do ['l', 'a', 'b', 'e', 'l', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l']
        (xml_take plain_name
          (\ a ->
            xml_take
              (xml_or
                (xml_do ['n', 'u', 'm', 'b', 'e', 'r', 'L', 'a', 'b', 'e', 'l']
                  (xml_take_many_sub [] zero_nat Infinity_enat
                    (xml_nat ['n', 'u', 'm', 'b', 'e', 'r'])
                    (\ aa -> xml_return (Inl aa))))
                (xml_do ['s', 'y', 'm', 'b', 'o', 'l', 'L', 'a', 'b', 'e', 'l']
                  (xml_take_many_sub [] zero_nat Infinity_enat plain_name
                    (\ aa -> xml_return (Inr aa)))))
              (\ b -> xml_return (case b of {
                                   Inl ba -> Lab a ba;
                                   Inr ba -> FunLab a ba;
                                 }))))))
    x;

level_mapping ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) [((a, Nat), [(Nat, Nat)])];
level_mapping xml2name =
  xml_do ['l', 'e', 'v', 'e', 'l', 'M', 'a', 'p', 'p', 'i', 'n', 'g']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['l', 'e', 'v', 'e', 'l', 'M', 'a', 'p', 'p', 'i', 'n', 'g', 'E', 'n',
          't', 'r', 'y']
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat ['a', 'r', 'i', 't', 'y'])
              (\ a ->
                xml_take_many_sub [] zero_nat Infinity_enat
                  (xml_do
                    ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', 'L', 'e', 'v', 'e',
                      'l', 'E', 'n', 't', 'r', 'y']
                    (xml_take (xml_nat ['p', 'o', 's', 'i', 't', 'i', 'o', 'n'])
                      (\ aa ->
                        xml_take (xml_nat ['l', 'e', 'v', 'e', 'l'])
                          (\ b -> xml_return (aa, b)))))
                  (\ ps ->
                    xml_return
                      ((f, a),
                        map (\ (p, b) ->
                              ((if equal_nat p zero_nat then a
                                 else minus_nat p one_nat),
                                b))
                          ps))))))
      xml_return);

redtriplea ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   Bool ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char])
                         (Sum (Root_redtriple_impl a) (Redtriple_impl a));
redtriplea xml2name bi =
  xml_do ['r', 'e', 'd', 'P', 'a', 'i', 'r']
    (xml_take
      (xml_or
        (xml_do ['s', 'c', 'n', 'p']
          (xml_take
            (xml_do ['s', 't', 'a', 't', 'u', 's']
              (xml_take
                (xml_or (xml_leaf ['m', 's'] MS_Ext)
                  (xml_or (xml_leaf ['m', 'i', 'n'] Min_Ext)
                    (xml_or (xml_leaf ['d', 'm', 's'] Dms_Ext)
                      (xml_leaf ['m', 'a', 'x'] Max_Ext))))
                xml_return))
            (\ a ->
              xml_take (level_mapping xml2name)
                (\ b ->
                  xml_take
                    (xml_do ['r', 'e', 'd', 'P', 'a', 'i', 'r']
                      (xml_take (redtriple xml2name False)
                        (\ x -> xml_return (id x))))
                    (\ c -> xml_return (Inl (SCNP a b c)))))))
        (xml_change (redtriple xml2name bi) (xml_return . Inr)))
      xml_return);

rule_pairs ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   [Prelude.Char] ->
                     [Prelude.Char] ->
                       (Xml, ([([Prelude.Char], [Prelude.Char])],
                               (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                         Sum (Xml_error [Prelude.Char])
                           [((Term a [Prelude.Char], Term a [Prelude.Char]),
                              (Term a [Prelude.Char], Term a [Prelude.Char]))];
rule_pairs xml2name s p =
  xml_do s
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do p
        (xml_take (rule xml2name)
          (\ a -> xml_take (rule xml2name) (\ b -> xml_return (a, b)))))
      xml_return);

xml1or2many_elements ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> Maybe b -> [c] -> d) -> Xml -> Sum_bot [Prelude.Char] d;
xml1or2many_elements tag p1 p2 p3 f (XML name atts cs) =
  (if name == tag && null atts && not (null cs)
    then let {
           (cs0 : tt) = cs;
         } in binda (p1 cs0)
                (\ x ->
                  (case tt of {
                    [] -> returna (f x Nothing []);
                    cs1 : t ->
                      catch_error
                        (binda (p2 cs1)
                          (\ y ->
                            binda (map_sum_bot p3 t)
                              (\ xs -> returna (f x (Just y) xs))))
                        (\ _ ->
                          binda (map_sum_bot p3 tt)
                            (\ xs -> returna (f x Nothing xs)));
                  }))
    else fail tag (XML name atts cs));
xml1or2many_elements tag p1 p2 p3 f (XML_text v) = fail tag (XML_text v);

sl_variant ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Sl_variant a [Prelude.Char]);
sl_variant xml2name =
  singleton ['m', 'o', 'd', 'e', 'l']
    (options
      [(['f', 'i', 'n', 'i', 't', 'e', 'M', 'o', 'd', 'e', 'l'],
         xml1or2many_elements
           ['f', 'i', 'n', 'i', 't', 'e', 'M', 'o', 'd', 'e', 'l']
           (change
             (nata ['c', 'a', 'r', 'r', 'i', 'e', 'r', 'S', 'i', 'z', 'e'])
             (\ n -> minus_nat n one_nat))
           (singleton ['t', 'u', 'p', 'l', 'e', 'O', 'r', 'd', 'e', 'r']
             (leaf ['p', 'o', 'i', 'n', 't', 'W', 'i', 's', 'e'] ()) id)
           (triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
             (nata ['a', 'r', 'i', 't', 'y']) arith_fun
             (\ f a -> (\ b -> ((f, a), b))))
           (\ n model xs ->
             (if is_none model then Finitelab (SL_Inter n xs)
               else QuasiFinitelab (SL_Inter n xs) []))),
        (['r', 'o', 'o', 't', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g'],
          guard (\ x -> equal_nat (num_children x) zero_nat)
            (leaf ['r', 'o', 'o', 't', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
              (Rootlab Nothing))
            (singleton
              ['r', 'o', 'o', 't', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
              xml2name (\ f -> Rootlab (Just (f, one_nat)))))])
    id;

char_matrix :: forall a. (Field a) => Mat a -> a -> Mat a;
char_matrix a e =
  mat_add a (mat_scalar_mult (uminus e) (mat_one (mat_dim_row a)));

array_grow :: forall a. Array.Array a -> Nat -> a -> Array.Array a;
array_grow (Array.Array a) inc x = Array.Array (a ++ replicate inc x);

roots1 :: forall a. (Field a) => Poly a -> a;
roots1 p = divide (uminus (case coeffs p of {
                            [] -> zerob;
                            x : _ -> x;
                          }))
             (coeff p one_nat);

formula_pos_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) Nat;
formula_pos_parser =
  xml_or
    (xml_do ['c', 'o', 'n', 'c', 'l', 'u', 's', 'i', 'o', 'n']
      (xml_return zero_nat))
    (xml_or
      (xml_do ['a', 's', 's', 'e', 'r', 't', 'i', 'o', 'n']
        (xml_return (nat_of_integer (2 :: Integer))))
      (xml_or
        (xml_do ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n']
          (xml_return (nat_of_integer (3 :: Integer))))
        (xml_do
          ['t', 'a', 'r', 'g', 'e', 't', 'A', 's', 's', 'e', 'r', 't', 'i', 'o',
            'n']
          (xml_return (nat_of_integer (4 :: Integer))))));

hints_parser ::
  forall a.
    (Default a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) a) ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) (Hint a);
hints_parser hint_parser xml =
  xml_or (xml_do ['a', 'u', 't', 'o'] (xml_return default_hint))
    (xml_or
      (xml_do ['d', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e']
        (xml_take formula_pos_parser
          (\ pos ->
            xml_take_many_sub [] zero_nat Infinity_enat
              (hints_parser hint_parser)
              (\ hints -> xml_return (Distribute pos hints)))))
      (xml_or
        (xml_do ['e', 'r', 'a', 's', 'e']
          (xml_take formula_pos_parser
            (\ pos ->
              xml_take (hints_parser hint_parser)
                (\ hint -> xml_return (Erase pos hint)))))
        (xml_or
          (xml_do ['l', 'e', 'x', 'W', 'e', 'a', 'k']
            (xml_take_many_sub [] zero_nat Infinity_enat
              (hints_parser hint_parser)
              (\ hints -> xml_return (LexWeak hints))))
          (xml_or
            (xml_do ['l', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't']
              (xml_take_many_sub [] zero_nat Infinity_enat
                (hints_parser hint_parser)
                (\ hints -> xml_return (LexStrict hints))))
            (xml_change hint_parser (xml_return . Base))))))
    xml;

art_node_parser ::
  forall a b c d e f g.
    (Default g) => ([Prelude.Char] ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) a) ->
                     ((Xml, ([([Prelude.Char], [Prelude.Char])],
                              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) b) ->
                       ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                (Bool,
                                  ([[Prelude.Char]], [[Prelude.Char]])))) ->
                         Sum (Xml_error [Prelude.Char]) c) ->
                         ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                  (Bool,
                                    ([[Prelude.Char]], [[Prelude.Char]])))) ->
                           Sum (Xml_error [Prelude.Char])
                             (Formula (Term d (e, f)))) ->
                           ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                    (Bool,
                                      ([[Prelude.Char]], [[Prelude.Char]])))) ->
                             Sum (Xml_error [Prelude.Char]) g) ->
                             (Xml, ([([Prelude.Char], [Prelude.Char])],
                                     (Bool,
                                       ([[Prelude.Char]],
 [[Prelude.Char]])))) ->
                               Sum (Xml_error [Prelude.Char])
                                 (Art_node_impl d e f b a c (Hint g), [a]);
art_node_parser art_node_id_parser location_parser trans_parser atom_parser
  hint_parser =
  xml_do ['n', 'o', 'd', 'e']
    (xml_take_default False
      (xml_do ['i', 'n', 'i', 't', 'i', 'a', 'l'] (xml_return True))
      (\ init ->
        xml_take (art_node_id_parser ['n', 'o', 'd', 'e', 'I', 'd'])
          (\ nodeId ->
            xml_take
              (xml_do ['i', 'n', 'v', 'a', 'r', 'i', 'a', 'n', 't']
                (xml_take (formula_parser atom_parser) xml_return))
              (\ invariant ->
                xml_take
                  (xml_do ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n']
                    (xml_take location_parser xml_return))
                  (\ location ->
                    xml_take
                      (xml_or
                        (xml_do ['c', 'h', 'i', 'l', 'd', 'r', 'e', 'n']
                          (xml_take_many_sub [] zero_nat Infinity_enat
                            (xml_do ['c', 'h', 'i', 'l', 'd']
                              (xml_take trans_parser
                                (\ tr ->
                                  xml_take
                                    (art_node_id_parser
                                      ['n', 'o', 'd', 'e', 'I', 'd'])
                                    (\ n ->
                                      xml_take_default default_hint
(xml_do ['h', 'i', 'n', 't', 's']
  (xml_take (hints_parser hint_parser) xml_return))
(\ h -> xml_return (tr, (n, h)))))))
                            (\ chs -> xml_return (Children_Edge chs))))
                        (xml_do ['c', 'o', 'v', 'e', 'r', 'E', 'd', 'g', 'e']
                          (xml_take
                            (art_node_id_parser ['n', 'o', 'd', 'e', 'I', 'd'])
                            (\ n ->
                              xml_take_default default_hint
                                (xml_do ['h', 'i', 'n', 't', 's']
                                  (xml_take (hints_parser hint_parser)
                                    xml_return))
                                (\ h -> xml_return (Cover_Edge n h))))))
                      (\ edges ->
                        xml_return
                          (Art_Node nodeId invariant location edges,
                            (if init then [nodeId] else []))))))));

art_parser ::
  forall a b c d e f g.
    (Default g) => ([Prelude.Char] ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) a) ->
                     ((Xml, ([([Prelude.Char], [Prelude.Char])],
                              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) b) ->
                       ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                (Bool,
                                  ([[Prelude.Char]], [[Prelude.Char]])))) ->
                         Sum (Xml_error [Prelude.Char]) c) ->
                         ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                  (Bool,
                                    ([[Prelude.Char]], [[Prelude.Char]])))) ->
                           Sum (Xml_error [Prelude.Char])
                             (Formula (Term d (e, f)))) ->
                           ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                    (Bool,
                                      ([[Prelude.Char]], [[Prelude.Char]])))) ->
                             Sum (Xml_error [Prelude.Char]) g) ->
                             (Xml, ([([Prelude.Char], [Prelude.Char])],
                                     (Bool,
                                       ([[Prelude.Char]],
 [[Prelude.Char]])))) ->
                               Sum (Xml_error [Prelude.Char])
                                 (Art_impl_ext d e f b a c (Hint g) ());
art_parser art_node_id_parser location_parser trans_parser atom_parser
  hint_parser =
  xml_do ['i', 'm', 'p', 'a', 'c', 't']
    (xml_take_default []
      (xml_change (art_node_id_parser ['i', 'n', 'i', 't', 'i', 'a', 'l'])
        (\ x -> xml_return [x]))
      (\ init ->
        xml_take
          (xml_do ['n', 'o', 'd', 'e', 's']
            (xml_take_many_sub [] zero_nat Infinity_enat
              (art_node_parser art_node_id_parser location_parser trans_parser
                atom_parser hint_parser)
              xml_return))
          (\ pairs -> let {
                        nodes = map fst pairs;
                        inits = init ++ concatMap snd pairs;
                      } in xml_return (Art_impl_ext inits nodes ()))));

check_prop_rstep_rule ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      Pos ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstep_rule nfs pa p rule s t =
  bindb (check (in_poss p s)
          (shows_prec_pos zero_nat p .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o', 's',
                'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
              shows_prec_term zero_nat s . shows_nl))
    (\ _ ->
      bindb (check (in_poss p t)
              (shows_prec_pos zero_nat p .
                shows_string
                  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
                    's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                  shows_prec_term zero_nat t . shows_nl))
        (\ _ ->
          let {
            c = ctxt_of_pos_term p s;
            d = ctxt_of_pos_term p t;
            u = subt_at s p;
            v = subt_at t p;
          } in (case match_list Var [(fst rule, u), (snd rule, v)] of {
                 Nothing ->
                   Inl (shows_string
                          ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                         shows_prec_term zero_nat t .
                           shows_string
                             [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                               'r', 'e', 's', 'u', 'l', 't', ' ', 'f', 'r', 'o',
                               'm', ' ', 'a', ' ', 'p', 'r', 'o', 'p', 'e', 'r',
                               ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                               'o', 'n', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e',
                               ' '] .
                             shows_nl .
                               shows_rule (shows_prec zero_nat)
                                 (shows_prec zero_nat) [' ', '-', '>', ' ']
                                 rule .
                                 shows_string
                                   [' ', 'a', 't', ' ', 'p', 'o', 's', 'i', 't',
                                     'i', 'o', 'n', ' '] .
                                   shows_prec_pos zero_nat p . shows_nl);
                 Just tau ->
                   bindb (catch_errora
                           (forallM pa
                             (args u ++
                               (if nfs then map tau (vars_rule_list rule)
                                 else [])))
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       check (equal_ctxt c d)
                         (shows_string
                            ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                           shows_prec_term zero_nat t .
                             shows_string
                               [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't',
                                 ' ', 'r', 'e', 's', 'u', 'l', 't', ' ', 'f',
                                 'r', 'o', 'm', ' ', 'a', ' ', 'p', 'r', 'o',
                                 'p', 'e', 'r', ' ', 'a', 'p', 'p', 'l', 'i',
                                 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
                                 ' ', 'r', 'u', 'l', 'e', ' '] .
                               shows_nl .
                                 shows_rule (shows_prec zero_nat)
                                   (shows_prec zero_nat) [' ', '-', '>', ' ']
                                   rule .
                                   shows_string
                                     [' ', 'a', 't', ' ', 'p', 'o', 's', 'i',
                                       't', 'i', 'o', 'n', ' '] .
                                     shows_prec_pos zero_nat p . shows_nl));
               })));

check_prop_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstep nfs pa r p rule s t =
  check (any (\ ra ->
               eq_rule_mod_vars rule ra &&
                 isOK (check_prop_rstep_rule nfs pa p ra s t))
          r)
    (shows_prec_list zero_nat
       ['t', 'h', 'e', ' ', 's', 't', 'e', 'p', ' ', 'f', 'r', 'o', 'm', ' '] .
      shows_prec_term zero_nat s .
        shows_prec_list zero_nat [' ', 't', 'o', ' '] .
          shows_prec_term zero_nat t .
            shows_prec_list zero_nat
              [' ', 'v', 'i', 'a', ' ', 'r', 'u', 'l', 'e', ' '] .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '-', '>', ' '] rule .
                shows_prec_list zero_nat
                  [' ', 'a', 't', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n',
                    ' '] .
                  shows_prec_pos zero_nat p .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                        'a', 't', 'i', 'c'] .
                      shows_nl);

check_qrstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrstep nf nfs =
  check_prop_rstep nfs
    (\ t ->
      check (nf t)
        (shows_prec_term zero_nat t .
          shows_prec_list zero_nat
            [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'Q', '-',
              'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']));

check_rqrstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rqrstep nf nfs r rule s t = check_qrstep nf nfs r Empty rule s t;

check_qsteps ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qsteps nf nfs p r [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term zero_nat u . shows_nl);
check_qsteps nf nfs p ra ((uu, (r, (True, t))) : prts) s u =
  bindb (check_rqrstep nf nfs p r s t)
    (\ _ -> check_qsteps nf nfs p ra prts t u);
check_qsteps nf nfs pa ra ((p, (r, (False, t))) : prts) s u =
  bindb (check_qrstep nf nfs ra p r s t)
    (\ _ -> check_qsteps nf nfs pa ra prts t u);

check_qrsteps ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrsteps nf nfs r prts s u =
  check_qsteps nf nfs [] r (map (\ (p, (ra, t)) -> (p, (ra, (False, t)))) prts)
    s u;

check_qrstep_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrstep_subst cni nfs =
  let {
    main =
      check_prop_rstep nfs
        (\ t ->
          catch_errora (cni t)
            (\ _ ->
              Inl (shows_prec_term zero_nat t .
                    shows_prec_list zero_nat
                      [' ', 'm', 'u', ' ', '^', '^', ' ', 'i', ' ', 'i', 's',
                        ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'Q', '-', 'n',
                        'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ',
                        'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ', 'i'])));
  } in (\ r p ra s t ->
         bindb (check (not (is_Var (fst ra)))
                 (shows_prec_list zero_nat
                   ['l', 'o', 'o', 'p', ' ', 'c', 'h', 'e', 'c', 'k', ' ', 'r',
                     'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'l', 'h', 's', 's',
                     ' ', 't', 'o', ' ', 'b', 'e', ' ', 'n', 'o', 'n', '-', 'v',
                     'a', 'r', 'i', 'a', 'b', 'l', 'e']))
           (\ _ -> main r p ra s t));

check_rqrstep_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rqrstep_subst cni nfs = (\ r -> check_qrstep_subst cni nfs r Empty);

check_qsteps_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qsteps_subst cni nfs p r [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term zero_nat u . shows_nl);
check_qsteps_subst cni nfs p ra ((uu, (r, (True, t))) : prts) s u =
  bindb (check_rqrstep_subst cni nfs p r s t)
    (\ _ -> check_qsteps_subst cni nfs p ra prts t u);
check_qsteps_subst cni nfs pa ra ((p, (r, (False, t))) : prts) s u =
  bindb (check_qrstep_subst cni nfs ra p r s t)
    (\ _ -> check_qsteps_subst cni nfs pa ra prts t u);

check_qrsteps_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrsteps_subst cni nfs r prts s u =
  check_qsteps_subst cni nfs [] r
    (map (\ (p, (ra, t)) -> (p, (ra, (False, t)))) prts) s u;

si_subst :: forall a b. Subst_incr a b -> b -> Term a b;
si_subst xa = fst (rep_subst_incr xa);

match_prob_of_rp_impl ::
  forall a b.
    (Eq a,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> [(Term a b, Term a b)];
match_prob_of_rp_impl mu (t, Var x) = [(t, Var x)];
match_prob_of_rp_impl mu (t, Fun v va) =
  let {
    sterms = remdups (t : map (si_subst mu) (si_W mu t));
    uterms = concatMap (filter (\ ta -> not (is_Var ta)) . supteq_list) sterms;
  } in map (\ u -> (u, Fun v va)) (remdups uterms);

si_v_incr :: forall a b. Subst_incr a b -> Set b;
si_v_incr xa = fst (snd (rep_subst_incr xa));

simplify_mp ::
  forall a b.
    (Eq a, Ceq b,
      Ccompare b) => Subst_incr a b ->
                       [(Term a b, Term a b)] ->
                         [(Term a b, Term a b)] ->
                           Maybe ([(Term a b, Term a b)], Nat);
simplify_mp mu_incr ((Var x, Fun f ls) : mp) solved =
  bind (guarda (member x (si_v_incr mu_incr)))
    (\ _ ->
      let {
        m = map (\ (s, a) -> (subst_apply_term s (si_subst mu_incr), a));
      } in bind (simplify_mp mu_incr (m ((Var x, Fun f ls) : mp)) (m solved))
             (\ (smp, i) -> Just (smp, suc i)));
simplify_mp mu_incr ((Fun g ts, Fun f ls) : mp) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (zip_option ts ls)
        (\ pairs -> simplify_mp mu_incr (pairs ++ mp) solved));
simplify_mp mu_incr ((s, Var x) : mp) solved =
  simplify_mp mu_incr mp ((s, Var x) : solved);
simplify_mp mu_incr [] solved = Just (solved, zero_nat);

conflicts ::
  forall a b.
    (Eq a,
      Eq b) => (a -> Term b a) ->
                 (Term b a, (Term b a, Nat)) -> [(Term b a, (Term b a, Nat))];
conflicts mu (Fun f ts, (Fun g ss, n)) =
  (if f == g && equal_nat (size_list ts) (size_list ss)
    then concatMap (\ (s, t) -> conflicts mu (s, (t, n))) (zip ts ss)
    else [(Fun f ts, (Fun g ss, n))]);
conflicts mu (Var x, (Fun g ss, n)) = [(Var x, (Fun g ss, n))];
conflicts mu (Fun f ts, (Var y, n)) =
  (if equal_nat n zero_nat then [(Var y, (Fun f ts, zero_nat))]
    else conflicts mu (Fun f ts, (mu y, minus_nat n one_nat)));
conflicts mu (Var x, (Var y, n)) =
  (if equal_nat n zero_nat
    then (if x == y then [] else [(Var x, (Var y, zero_nat))])
    else conflicts mu (Var x, (mu y, minus_nat n one_nat)));

ident_solvea ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b ->
                 Set (Term a b, (Term a b, Nat)) ->
                   (Term a b, (Term a b, Nat)) -> Maybe Nat;
ident_solvea mu_incr cps st =
  let {
    cp = conflicts (si_subst mu_incr) st;
  } in (if any (\ (u, (_, _)) -> not (is_Var u)) cp then Nothing
         else (if any (\ (u, (v, _)) ->
                        member (u, v) (image (\ (ua, (va, _)) -> (ua, va)) cps))
                    cp
                then Nothing
                else bind (mapMa
                            (\ (u, (v, m)) ->
                              ident_solvea mu_incr (inserta (u, (v, m)) cps)
                                (subst_apply_term u (si_subst mu_incr),
                                  (v, suc m)))
                            (conflicts (si_subst mu_incr) st))
                       (\ is -> Just (max_list (map suc is)))));

ident_solve ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Maybe Nat;
ident_solve mu_incr =
  (\ (s, t) ->
    ident_solvea mu_incr
      (set_empty
        (of_phantom
          (set_impl_prod :: Phantom (Term a b, (Term a b, Nat)) Set_impla)))
      (s, (t, zero_nat)));

ident_decision ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
ident_decision sigma ip = not (is_none (ident_solve sigma ip));

ident_prob_of_smp ::
  forall a b. (Eq a, Eq b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)];
ident_prob_of_smp [] = [];
ident_prob_of_smp ((t, l) : other) =
  map_filter
    (\ x -> (if let {
                  (_, s) = x;
                } in equal_term s l
              then Just (let {
                           (s, _) = x;
                         } in (t, s))
              else Nothing))
    other ++
    ident_prob_of_smp other;

gmatch_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> [(Term a b, Term a b)] -> Bool;
gmatch_decision sigma mp =
  not (is_none
        (bind (simplify_mp sigma mp [])
          (\ (smp, _) ->
            guarda (all (ident_decision sigma) (ident_prob_of_smp smp)))));

match_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
match_decision mu mp = gmatch_decision mu [mp];

redex_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
redex_decision mu rp = any (match_decision mu) (match_prob_of_rp_impl mu rp);

new_as :: forall a b. (a -> b -> Bool) -> [a] -> [b] -> [b];
new_as p bs asa = filter (\ a -> any (\ b -> p b a) bs) asa;

the_set_impl_main ::
  forall a b.
    (Eq a, Eq b) => (a -> b -> Bool) -> (b -> [a]) -> [b] -> [b] -> [a] -> [b];
the_set_impl_main p q remain have bs =
  let {
    new = new_as p bs remain;
  } in (if null new then have
         else the_set_impl_main p q (list_diff remain new) (new ++ have)
                (remdups (concatMap q new)));

the_set_impl ::
  forall a b.
    (Eq a, Eq b) => [a] -> (b -> a -> Bool) -> (a -> [b]) -> [b] -> [a];
the_set_impl r p q bs = the_set_impl_main p q r [] bs;

inductive_set_impl ::
  forall a b.
    (Eq a, Eq b) => [a] -> (b -> a -> Bool) -> (a -> [b]) -> [b] -> [a];
inductive_set_impl = the_set_impl;

v_incr_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
v_incr_impl mu =
  inductive_set_impl (map fst mu) (\ a b -> a == b)
    (\ x ->
      concatMap (\ (y, t) -> (if equal_term t (Var x) then [y] else [])) mu)
    (concatMap (\ (y, t) -> (if not (is_Var t) then [y] else [])) mu);

rtrancl_impl ::
  forall a b.
    ([(a, a)] -> [a] -> [a]) ->
      ([a] -> b -> b) -> (a -> b -> Bool) -> b -> [(a, a)] -> [a] -> b;
rtrancl_impl gen_succ un memb emp rel =
  let {
    succ = gen_succ rel;
    n = size_list rel;
  } in (\ asa -> relpow_impl succ un memb asa emp n);

rtrancl_list_impl :: forall a. (Eq a) => [(a, a)] -> [a] -> [a];
rtrancl_list_impl =
  rtrancl_impl
    (\ r asa ->
      remdups
        (map_filter
          (\ x -> (if let {
                        (a, _) = x;
                      } in membera asa a
                    then Just (snd x) else Nothing))
          r))
    (\ xs ys -> filter (\ x -> not (membera ys x)) xs ++ ys)
    (\ x xs -> membera xs x) [];

w_impl :: forall a b. (Eq a) => [(a, Term b a)] -> Term b a -> [a];
w_impl d =
  let {
    filt = filter (\ (x, y) -> not (x == y));
    xvs = concatMap (\ (x, t) -> map (\ a -> (x, a)) (vars_term_list t)) d;
    rel = filt xvs;
    rtran = rtrancl_list_impl rel;
  } in (\ t -> rtran (vars_term_list t));

subst_incr ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq b) => [(a, Term b a)] -> Subst_incr b a;
subst_incr xa =
  Abs_subst_incr (let {
                    dom = mk_subst_domain xa;
                  } in (mk_subst Var xa, (set (v_incr_impl dom), w_impl dom)));

redex_rps_decision ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] ->
                 [(Term b a, Term b a)] -> Sum (Term b a, Term b a) ();
redex_rps_decision mu =
  let {
    mua = subst_incr mu;
    main = redex_decision mua;
  } in (\ xs ->
         catch_errora (forallM (\ tl -> check (not (main tl)) tl) xs)
           (\ x -> Inl (snd x)));

check_NF_iteration ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] ->
                 [Term b a] -> Term b a -> Sum (Term b a, Term b a) ();
check_NF_iteration mu = let {
                          dec = redex_rps_decision mu;
                        } in (\ q t -> dec (map (\ a -> (t, a)) q));

check_loop ::
  forall a b.
    (Compare a, Eq a, Showa a, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [Term a b] ->
                    Bool ->
                      Term a b ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          [(b, Term a b)] ->
                            Ctxt a b ->
                              [(Term a b, Term a b)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_loop q nfs s rseq sigma c r =
  bindb (check (not (null rseq))
          (shows_prec_list zero_nat
            ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'e', 'q', 'u', 'e',
              'n', 'c', 'e', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n',
              'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
    (\ _ ->
      (if null q
        then check_qrsteps (\ _ -> True) nfs r rseq s
               (ctxt_apply_term c (subst_apply_term s (mk_subst Var sigma)))
        else check_qrsteps_subst (check_NF_iteration sigma q) nfs r rseq s
               (ctxt_apply_term c (subst_apply_term s (mk_subst Var sigma)))));

delete_value ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> a -> Rbt b [a] -> Rbt b [a];
delete_value key v m = (case key v of {
                         Nothing -> m;
                         Just k -> (case lookup m k of {
                                     Nothing -> m;
                                     Just vs -> insert k (removeAll v vs) m;
                                   });
                       });

check_ge_v :: forall a. (Poly_carrier a) => a -> [([(Nat, Nat)], a)] -> Bool;
check_ge_v v p = (case p of {
                   [] -> True;
                   [([], c)] -> less_eq c v;
                   ([], _) : _ : _ -> False;
                   (_ : _, _) : _ -> False;
                 });

check_poly_weak_anti_mono_discrete ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono_discrete p v =
  check_poly_ge p
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p);

check_poly_weak_anti_mono ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Ordered_semiring_0a b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono p v =
  all (\ (m, c) -> less_eq c zerob || not (member v (image fst (set m)))) p;

check_poly_weak_anti_mono_smart ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Eq b,
      Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono_smart discrete =
  (if discrete then check_poly_weak_anti_mono_discrete
    else check_poly_weak_anti_mono);

check_poly_weak_mono_discrete ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono_discrete p v =
  check_poly_ge
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p)
    p;

check_poly_weak_mono ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Ordered_semiring_0a b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono p v =
  all (\ (m, c) -> less_eq zerob c || not (member v (image fst (set m)))) p;

check_poly_weak_mono_smart ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Eq b,
      Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono_smart discrete =
  (if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono);

fun_of_map_fun :: forall a b. (a -> Maybe b) -> (a -> b) -> a -> b;
fun_of_map_fun m d a = (case m a of {
                         Nothing -> d a;
                         Just b -> b;
                       });

g_list_to_map_rm_basic_ops ::
  forall a b. (Compare_order a) => [(a, b)] -> Rbt a b;
g_list_to_map_rm_basic_ops l =
  foldl (\ m (k, v) -> insert k v m) empty (reverse l);

ceta_map_of :: forall a b. (Key a) => [(a, b)] -> a -> Maybe b;
ceta_map_of ps = lookup (g_list_to_map_rm_basic_ops ps);

poly_inter_list_to_inter ::
  forall a b.
    (Poly_carrier a,
      Key b) => a -> [((b, Nat), [([(Nat, Nat)], a)])] ->
                       (b, Nat) -> [([(Nat, Nat)], a)];
poly_inter_list_to_inter def i =
  fun_of_map_fun (ceta_map_of i) (\ fn -> default_I def (snd fn));

fun_of_map_funa ::
  forall a b c. (a -> Maybe b) -> (a -> c) -> (b -> c) -> a -> c;
fun_of_map_funa m d f a = (case m a of {
                            Nothing -> d a;
                            Just aa -> f aa;
                          });

create_dep ::
  forall a b.
    (Eq a, Poly_carrier a, Eq b,
      Key b) => Bool ->
                  a -> [((b, Nat), [([(Nat, Nat)], a)])] ->
                         (b, Nat) -> Nat -> Dependance;
create_dep discrete def i =
  let {
    fs = remdups (map fst i);
    ii = poly_inter_list_to_inter def i;
    fsres =
      map (\ fn ->
            let {
              p = ii fn;
              vars = poly_vars_list p;
              is = upt zero_nat (snd fn);
              a = map (\ ia ->
                        (if membera vars ia
                          then (if check_poly_weak_mono_smart discrete p ia
                                 then Increase
                                 else (if check_poly_weak_anti_mono_smart
    discrete p ia
then Decrease else Wild))
                          else Ignore))
                    is;
            } in (fn, a))
        fs;
    iii = fun_of_map_funa (ceta_map_of fsres) (\ _ _ -> Increase) nth;
  } in iii;

eval_monom :: forall a b. (Comm_semiring_1 b) => (a -> b) -> [(a, Nat)] -> b;
eval_monom alpha [] = onea;
eval_monom alpha ((x, p) : m) =
  times (eval_monom alpha m) (binary_power (alpha x) p);

eval_poly ::
  forall a b. (Comm_semiring_1 b) => (a -> b) -> [([(a, Nat)], b)] -> b;
eval_poly alpha [] = zerob;
eval_poly alpha (mc : p) =
  plus (times (eval_monom alpha (fst mc)) (snd mc)) (eval_poly alpha p);

poly_vars ::
  forall a b. (Ceq a, Ccompare a, Set_impl a) => [([(a, Nat)], b)] -> Set a;
poly_vars p = set (concatMap (map fst . fst) p);

enfc_q ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                (Term a [Prelude.Char] -> Bool) ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [Term a [Prelude.Char]] ->
                      [Term a [Prelude.Char]] -> Term a [Prelude.Char] -> Bool;
enfc_q isQnf isRnf r q s (Var x) = True;
enfc_q isQnf isRnf r q s (Fun f ts) =
  all (\ qa ->
        (case mgu_class (Fun f (map (icap_impl isQnf r s) ts)) qa of {
          Nothing -> True;
          Just mu ->
            not (all (\ u ->
                       isQnf (subst_apply_term
                               (map_term (\ x -> x) (\ a -> 'x' : a) u) mu))
                   s &&
                  isRnf (subst_apply_term
                          (map_term (\ x -> x) (\ a -> 'y' : a) qa) mu));
        }))
    q;

delete_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
delete_values uu [] m = m;
delete_values key (v : vs) m = delete_value key v (delete_values key vs m);

delete_rules ::
  forall a b c.
    (Eq a, Compare_order b, Eq b,
      Eq c) => a -> [(Term b c, Term b c)] ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        Rbt (b, Nat) [(a, (Term b c, Term b c))];
delete_rules a rs = delete_values key (map (\ b -> (a, b)) rs);

split_rulesc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_rulesc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = split_rules;

split_pairsa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_pairsa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = split_pairs;

delete_R_Rwc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_R_Rwc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = delete_R_Rw;

delete_P_Pwa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_P_Pwa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = delete_P_Pw;

minimal :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
minimal
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = minimal;

nfsc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
nfsc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
       rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
       reverse_rules_map intersect_pairs replace_pair intersect_rules
       delete_P_Pw delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules
       more)
  = nfs;

mkd ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      Bool ->
        Bool ->
          [(Term b c, Term b c)] ->
            [(Term b c, Term b c)] ->
              [Term b c] ->
                [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkd (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = mk;

qc :: forall a b c d. Dpp_ops_ext a b c d -> a -> [Term b c];
qc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = q;

split_proc ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> [(Term b c, Term b c)] ->
                           [(Term b c, Term b c)] -> (a, a);
split_proc i d p_remove r_remove =
  let {
    (p, pw) = split_pairsa i d p_remove;
    (r, rw) = split_rulesc i d r_remove;
    dpp1 = mkd i (nfsc i d) (minimal i d) p pw (qc i d) r rw;
    a = delete_R_Rwc i (delete_P_Pwa i d p_remove p_remove) r_remove r_remove;
  } in (dpp1, a);

rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a ->
      Maybe ((a, Nat) -> [Nat]);
rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
  (Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option x) = x;

sel21 ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a -> Status a;
sel21 xa =
  Abs_status
    (case rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option xa of {
      Nothing -> status (error "undefined");
      Just x2 -> x2;
    });

dis1 ::
  forall a. X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a -> Bool;
dis1 xa =
  (case rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option xa of {
    Nothing -> True;
    Just _ -> False;
  });

rep_isom ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a ->
      Maybe (Status a);
rep_isom x = (if dis1 x then Nothing else Just (sel21 x));

status_of_aux ::
  forall a.
    (Eq a) => [((a, Nat), [Nat])] ->
                X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a;
status_of_aux xa =
  Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
    (if all (\ fidx -> all (\ i -> less_nat i (snd (fst fidx))) (snd fidx)) xa
      then Just (fun_of_map_fun (map_of xa) (\ (_, a) -> upt zero_nat a))
      else Nothing);

status_of :: forall a. (Eq a) => [((a, Nat), [Nat])] -> Maybe (Status a);
status_of x = rep_isom (status_of_aux x);

subst_apply_ctxt :: forall a b c. Ctxt a b -> (b -> Term a c) -> Ctxt a c;
subst_apply_ctxt Hole sigma = Hole;
subst_apply_ctxt (More f ss1 d ss2) sigma =
  More f (map (\ t -> subst_apply_term t sigma) ss1) (subst_apply_ctxt d sigma)
    (map (\ t -> subst_apply_term t sigma) ss2);

shows_ctxt ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Ctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_ctxt fun var Hole = shows_string ['[', ']'];
shows_ctxt fun var (More f ss1 d ss2) =
  fun f .
    shows_string ['('] .
      shows_list_gen (shows_term fun var) [] [] [',', ' '] [',', ' '] ss1 .
        shows_ctxt fun var d .
          shows_list_gen (shows_term fun var) [')'] [',', ' '] [',', ' '] [')']
            ss2;

r_states :: forall a b. (Ceq a, Ccompare a, Set_impl a) => Ta_rule a b -> Set a;
r_states = (\ ta_rule -> inserta (r_rhs ta_rule) (set (r_lhs_states ta_rule)));

ta_states ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set a;
ta_states ta =
  sup_set
    (sup_set (sup_seta (image r_states (ta_rules ta)))
      (sup_seta
        (image (\ (q, qa) -> inserta q (inserta qa bot_set)) (ta_eps ta))))
    (ta_final ta);

prod_ta ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Set_impl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Ta_ext c b () -> Set (a, c) -> Ta_ext (a, c) b ();
prod_ta tA1 tA2 f =
  Ta_ext f
    (image
      (\ (TA_rule fa qs1 q1, TA_rule _ qs2 q2) ->
        TA_rule fa (zip qs1 qs2) (q1, q2))
      (sup_seta
        (image
          (\ fa ->
            productc (filtera (\ r -> r_sym r == fa) (ta_rules tA1))
              (filtera (\ r -> r_sym r == fa) (ta_rules tA2)))
          (ta_syms tA1))))
    (sup_set
      (image (\ (a, b) -> let {
                            (q, qa) = a;
                          } in (\ p -> ((q, p), (qa, p)))
                            b)
        (productc (ta_eps tA1) (ta_states tA2)))
      (image (\ (p, (q, qa)) -> ((p, q), (p, qa)))
        (productc (ta_states tA1) (ta_eps tA2))))
    ();

productive_relation ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set (a, a);
productive_relation ta =
  sup_set (image (\ (a, b) -> (b, a)) (ta_eps ta))
    (sup_seta
      (image (\ r -> image (\ a -> (r_rhs r, a)) (set (r_lhs_states r)))
        (ta_rules ta)));

ta_productive ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set a;
ta_productive ta =
  sup_set (ta_final ta) (compute_trancl (ta_final ta) (productive_relation ta));

ta_restrict ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b c -> Set a -> Ta_ext a b ();
ta_restrict ta q =
  Ta_ext (inf_set (ta_final ta) q)
    (filtera (\ r -> less_eq_set (r_states r) q) (ta_rules ta))
    (inf_set (ta_eps ta) (productc q q)) ();

trim_ta ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Default b, Eq b) => Ta_ext a b () -> Ta_ext a b ();
trim_ta ta =
  ta_restrict (ta_restrict ta (ta_reachable ta))
    (ta_productive (ta_restrict ta (ta_reachable ta)));

check_varcond_subset ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_varcond_subset r =
  catch_errora
    (forallM
      (\ rule ->
        catch_errora
          (check_subseteq (insert_vars_term (snd rule) [])
            (insert_vars_term (fst rule) []))
          (\ x ->
            Inl ((((shows_prec_list zero_nat
                      ['f', 'r', 'e', 'e', ' ', 'v', 'a', 'r', 'i', 'a', 'b',
                        'l', 'e', ' '] .
                     shows_prec zero_nat x) .
                    shows_prec_list zero_nat
                      [' ', 'i', 'n', ' ', 'r', 'i', 'g', 'h', 't', '-', 'h',
                        'a', 'n', 'd', ' ', 's', 'i', 'd', 'e', ' ', 'o', 'f',
                        ' ', 'r', 'u', 'l', 'e', ' ']) .
                   shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                     [' ', '-', '>', ' '] rule) .
                  shows_nl)))
      r)
    (\ x -> Inl (snd x));

check_wf_trs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_trs r =
  catch_errora
    (bindb (check_varcond_no_Var_lhs r) (\ _ -> check_varcond_subset r))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o',
                't', ' ', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e',
                'd'] .
             shows_nl) .
            x));

defined_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
defined_list r =
  concatMap (\ (l, _) -> (if not (is_Var l) then [the (root l)] else [])) r;

generate_f_xs :: forall a. a -> Nat -> Term a [Prelude.Char];
generate_f_xs f n = Fun f (map (\ i -> Var (generate_var i)) (upt zero_nat n));

num_symbs :: forall a b. Term a b -> Nat;
num_symbs (Var x) = one_nat;
num_symbs (Fun f ts) = plus_nat (sum_list (map num_symbs ts)) one_nat;

rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Maybe ((a, Nat) -> Af_entry, Set (a, Nat));
rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
  (Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
    x)
  = x;

sel21b ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Afs a;
sel21b xa =
  Abs_afs
    (case rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
            xa
      of {
      Nothing -> rep_afs (error "undefined");
      Just x2 -> x2;
    });

dis1b ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Bool;
dis1b xa =
  (case rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
          xa
    of {
    Nothing -> True;
    Just _ -> False;
  });

rep_isomb ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Maybe (Afs a);
rep_isomb x = (if dis1b x then Nothing else Just (sel21b x));

default_af_entry :: Nat -> Af_entry;
default_af_entry n = AFList (upt zero_nat n);

wf_af_entry :: Nat -> Af_entry -> Bool;
wf_af_entry n (Collapse i) = less_nat i n;
wf_af_entry n (AFList is) = all (\ i -> less_nat i n) is;

afs_of_aux ::
  forall a.
    (Ceq a, Ccompare a, Key a,
      Set_impl a) => [((a, Nat), Af_entry)] ->
                       X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                         a;
afs_of_aux xa =
  Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
    (if all (\ ((_, n), e) -> wf_af_entry n e) xa
      then Just (fun_of_map_fun (ceta_map_of xa)
                   (\ fn -> default_af_entry (snd fn)),
                  set (map fst xa))
      else Nothing);

afs_of ::
  forall a.
    (Ceq a, Ccompare a, Key a,
      Set_impl a) => [((a, Nat), Af_entry)] -> Maybe (Afs a);
afs_of x = rep_isomb (afs_of_aux x);

ta_bounds_lhs ::
  forall a.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char])
          (Sum ((a, Nat), [[Prelude.Char]]) [Prelude.Char]);
ta_bounds_lhs xml2name =
  xml_do ['l', 'h', 's']
    (xml_or (xml_take state (\ a -> xml_return (Inr a)))
      (xml_take xml2name
        (\ f ->
          xml_take (xml_nat ['h', 'e', 'i', 'g', 'h', 't'])
            (\ h ->
              xml_take_many_sub [] zero_nat Infinity_enat state
                (\ qs -> xml_return (Inl ((f, h), qs)))))));

bounds_bound ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) Nat;
bounds_bound = xml_nat ['b', 'o', 'u', 'n', 'd'];

bounds_type ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) Boundstype;
bounds_type =
  xml_do ['t', 'y', 'p', 'e']
    (xml_take
      (xml_or (xml_leaf ['r', 'o', 'o', 'f'] Roof)
        (xml_leaf ['m', 'a', 't', 'c', 'h'] Match))
      (\ x -> xml_return (id x)));

bounds_info ::
  forall a.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) (Bounds_info a [Prelude.Char]);
bounds_info xml2name =
  xml_do ['b', 'o', 'u', 'n', 'd', 's']
    (xml_take bounds_type
      (\ a ->
        xml_take bounds_bound
          (\ b ->
            xml_take final_states
              (\ c ->
                xml_take (tree_automaton (ta_bounds_lhs xml2name))
                  (\ d ->
                    xml_take_default Id_Relation closed_criterion
                      (\ e -> xml_return (Bounds_Info a b c d e)))))));

multiset_af ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) [((a, Nat), [Nat])];
multiset_af xml2name =
  xml_do
    ['m', 'u', 'l', 't', 'i', 's', 'e', 't', 'A', 'r', 'g', 'u', 'm', 'e', 'n',
      't', 'F', 'i', 'l', 't', 'e', 'r']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['m', 'u', 'l', 't', 'i', 's', 'e', 't', 'A', 'r', 'g', 'u', 'm', 'e',
          'n', 't', 'F', 'i', 'l', 't', 'e', 'r', 'E', 'n', 't', 'r', 'y']
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat ['a', 'r', 'i', 't', 'y'])
              (\ a ->
                xml_take
                  (xml_do ['s', 't', 'a', 't', 'u', 's']
                    (xml_take_many_sub [] zero_nat Infinity_enat position
                      xml_return))
                  (\ p -> xml_return ((f, a), p))))))
      xml_return);

word_pattern ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        ([Lab a b], ((Nat, (Nat, [Lab a b])), [Lab a b]));
word_pattern xml2name =
  xml_do ['w', 'o', 'r', 'd', 'P', 'a', 't', 't', 'e', 'r', 'n']
    (xml_take (string xml2name)
      (\ l ->
        xml_take (string xml2name)
          (\ m ->
            xml_take (xml_nat ['f', 'a', 'c', 't', 'o', 'r'])
              (\ f ->
                xml_take (xml_nat ['c', 'o', 'n', 's', 't', 'a', 'n', 't'])
                  (\ c ->
                    xml_take (string xml2name)
                      (\ r -> xml_return (l, ((f, (c, m)), r))))))));

derivation_pattern ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (([Lab a b], ((Nat, (Nat, [Lab a b])), [Lab a b])),
                          ([Lab a b], ((Nat, (Nat, [Lab a b])), [Lab a b])));
derivation_pattern xml2name =
  xml_do
    ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'P', 'a', 't', 't', 'e',
      'r', 'n']
    (xml_take (word_pattern xml2name)
      (\ a -> xml_take (word_pattern xml2name) (\ b -> xml_return (a, b))));

derivation_pattern_proof ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char]) (Dp_proof_step (Lab a b));
derivation_pattern_proof xml2name =
  let {
    oc = oc_srs xml2name;
    dp = derivation_pattern xml2name;
    s = string xml2name;
  } in xml_do
         ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'P', 'a', 't', 't',
           'e', 'r', 'n', 'P', 'r', 'o', 'o', 'f']
         (xml_take
           (xml_or
             (xml_do ['O', 'C', '1']
               (xml_take oc
                 (\ a ->
                   xml_take (xml_bool ['i', 's', 'P', 'a', 'i', 'r'])
                     (\ b -> xml_return (OC1 a b)))))
             (xml_or
               (xml_do ['O', 'C', '2']
                 (xml_take oc
                   (\ a ->
                     xml_take oc
                       (\ b ->
                         xml_take oc
                           (\ c ->
                             xml_take s
                               (\ d ->
                                 xml_take s
                                   (\ e ->
                                     xml_take s
                                       (\ f ->
 xml_return (OC2 a b c d e f)))))))))
               (xml_or
                 (xml_do ['O', 'C', '2', 'p', 'r', 'i', 'm', 'e']
                   (xml_take oc
                     (\ a ->
                       xml_take oc
                         (\ b ->
                           xml_take oc
                             (\ c ->
                               xml_take s
                                 (\ d ->
                                   xml_take s
                                     (\ e ->
                                       xml_take s
 (\ f -> xml_return (OC2p a b c d e f)))))))))
                 (xml_or
                   (xml_do ['O', 'C', '3']
                     (xml_take oc
                       (\ a ->
                         xml_take oc
                           (\ b ->
                             xml_take oc
                               (\ c ->
                                 xml_take s
                                   (\ d ->
                                     xml_take s
                                       (\ e -> xml_return (OC3 a b c d e))))))))
                   (xml_or
                     (xml_do ['O', 'C', '3', 'p', 'r', 'i', 'm', 'e']
                       (xml_take oc
                         (\ a ->
                           xml_take oc
                             (\ b ->
                               xml_take oc
                                 (\ c ->
                                   xml_take s
                                     (\ d ->
                                       xml_take s
 (\ e -> xml_return (OC3p a b c d e))))))))
                     (xml_or
                       (xml_do ['O', 'C', 'i', 'n', 't', 'o', 'D', 'P', '1']
                         (xml_take dp
                           (\ a ->
                             xml_take oc (\ b -> xml_return (OCDP1 a b)))))
                       (xml_or
                         (xml_do ['O', 'C', 'i', 'n', 't', 'o', 'D', 'P', '2']
                           (xml_take dp
                             (\ a ->
                               xml_take oc (\ b -> xml_return (OCDP2 a b)))))
                         (xml_or
                           (xml_do
                             ['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 't']
                             (xml_take dp
                               (\ a ->
                                 xml_take dp (\ b -> xml_return (WPEQ a b)))))
                           (xml_or
                             (xml_do ['l', 'i', 'f', 't']
                               (xml_take dp
                                 (\ a ->
                                   xml_take dp (\ b -> xml_return (Lift a b)))))
                             (xml_or
                               (xml_do
                                 ['D', 'P', '_', 'O', 'C', '_', '1', '_', '1']
                                 (xml_take dp
                                   (\ a ->
                                     xml_take dp
                                       (\ b ->
 xml_take oc
   (\ c ->
     xml_take s (\ d -> xml_take s (\ e -> xml_return (DPOC1_1 a b c d e))))))))
                               (xml_or
                                 (xml_do
                                   ['D', 'P', '_', 'O', 'C', '_', '1', '_', '2']
                                   (xml_take dp
                                     (\ a ->
                                       xml_take dp
 (\ b ->
   xml_take oc
     (\ c ->
       xml_take s
         (\ d ->
           xml_take s
             (\ e -> xml_take s (\ f -> xml_return (DPOC1_2 a b c d e f)))))))))
                                 (xml_or
                                   (xml_do ['D', 'P', '_', 'O', 'C', '_', '2']
                                     (xml_take dp
                                       (\ a ->
 xml_take dp
   (\ b ->
     xml_take oc
       (\ c ->
         xml_take s
           (\ d -> xml_take s (\ e -> xml_return (DPOC2 a b c d e))))))))
                                   (xml_or
                                     (xml_do
                                       ['D', 'P', '_', 'O', 'C', '_', '3', '_',
 '1']
                                       (xml_take dp
 (\ a ->
   xml_take dp
     (\ b ->
       xml_take oc
         (\ c ->
           xml_take s
             (\ d -> xml_take s (\ e -> xml_return (DPOC3_1 a b c d e))))))))
                                     (xml_or
                                       (xml_do
 ['D', 'P', '_', 'O', 'C', '_', '3', '_', '2']
 (xml_take dp
   (\ a ->
     xml_take dp
       (\ b ->
         xml_take oc
           (\ c ->
             xml_take s
               (\ d ->
                 xml_take s
                   (\ e ->
                     xml_take s (\ f -> xml_return (DPOC3_2 a b c d e f)))))))))
                                       (xml_or
 (xml_do ['D', 'P', '_', 'D', 'P', '_', '1', '_', '1']
   (xml_take dp
     (\ a ->
       xml_take dp
         (\ b ->
           xml_take dp
             (\ c ->
               xml_take s
                 (\ d ->
                   xml_take s (\ e -> xml_return (DPDP1_1 a b c d e))))))))
 (xml_or
   (xml_do ['D', 'P', '_', 'D', 'P', '_', '1', '_', '2']
     (xml_take dp
       (\ a ->
         xml_take dp
           (\ b ->
             xml_take dp
               (\ c ->
                 xml_take s
                   (\ d ->
                     xml_take s (\ e -> xml_return (DPDP1_2 a b c d e))))))))
   (xml_or
     (xml_do ['D', 'P', '_', 'D', 'P', '_', '2', '_', '1']
       (xml_take dp
         (\ a ->
           xml_take dp
             (\ b ->
               xml_take dp
                 (\ c ->
                   xml_take s
                     (\ d ->
                       xml_take s (\ e -> xml_return (DPDP2_1 a b c d e))))))))
     (xml_do ['D', 'P', '_', 'D', 'P', '_', '2', '_', '2']
       (xml_take dp
         (\ a ->
           xml_take dp
             (\ b ->
               xml_take dp
                 (\ c ->
                   xml_take s
                     (\ d ->
                       xml_take s
                         (\ e ->
                           xml_return
                             (DPDP2_2 a b c d e)))))))))))))))))))))))))
           (\ x -> xml_return (id x)));

nonloop_srs_reason ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        ([Dp_proof_step (Lab a b)] ->
                          Non_loop_srs_proof (Lab a b));
nonloop_srs_reason xml2name =
  xml_or
    (xml_do
      ['s', 'e', 'l', 'f', 'E', 'm', 'b', 'e', 'd', 'd', 'i', 'n', 'g', 'O',
        'C']
      (xml_take (string xml2name)
        (\ a ->
          xml_take (string xml2name)
            (\ b ->
              xml_take (string xml2name)
                (\ c -> xml_return (SE_OC (b, a ++ b ++ c) a c))))))
    (xml_do
      ['s', 'e', 'l', 'f', 'E', 'm', 'b', 'e', 'd', 'd', 'i', 'n', 'g', 'D',
        'P']
      (xml_take (derivation_pattern xml2name)
        (\ a ->
          xml_take (string xml2name)
            (\ b ->
              xml_take (string xml2name) (\ c -> xml_return (SE_DP a b c))))));

nonloop_srs ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Non_loop_srs_proof (Lab a b));
nonloop_srs xml2name =
  xml_do
    ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'n', 'g', 'S',
      'R', 'S']
    (xml_take
      (xml_do
        ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'P', 'a', 't', 't',
          'e', 'r', 'n', 's']
        (xml_take_many_sub [] zero_nat Infinity_enat
          (derivation_pattern_proof xml2name) (\ a -> xml_return (id a))))
      (\ a ->
        xml_take (nonloop_srs_reason xml2name) (\ b -> xml_return (b a))));

croots2 :: Poly Complex -> [Complex];
croots2 p =
  let {
    a = coeff p (nat_of_integer (2 :: Integer));
    b = coeff p one_nat;
    c = (case coeffs p of {
          [] -> zero_complex;
          x : _ -> x;
        });
    b2a = divide_complex b (times_complex (numeral (Bit0 One)) a);
    bac = minus_complex (binary_power b2a (nat_of_integer (2 :: Integer)))
            (divide_complex c a);
    e = csqrt bac;
  } in remdups
         [plus_complex (uminus_complex b2a) e,
           minus_complex (uminus_complex b2a) e];

showsp_formula ::
  forall a.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      Nat -> Formula a -> [Prelude.Char] -> [Prelude.Char];
showsp_formula show_a p (Disjunction x) =
  (((shows_pl p .
      shows_string ['D', 'i', 's', 'j', 'u', 'n', 'c', 't', 'i', 'o', 'n']) .
     shows_space) .
    showsp_list (showsp_formula show_a) one_nat x) .
    shows_pr p;
showsp_formula show_a p (Conjunction x) =
  (((shows_pl p .
      shows_string ['C', 'o', 'n', 'j', 'u', 'n', 'c', 't', 'i', 'o', 'n']) .
     shows_space) .
    showsp_list (showsp_formula show_a) one_nat x) .
    shows_pr p;
showsp_formula show_a p (NegAtom x) =
  (((shows_pl p . shows_string ['N', 'e', 'g', 'A', 't', 'o', 'm']) .
     shows_space) .
    show_a one_nat x) .
    shows_pr p;
showsp_formula show_a p (Atom x) =
  (((shows_pl p . shows_string ['A', 't', 'o', 'm']) . shows_space) .
    show_a one_nat x) .
    shows_pr p;

nFQ_subset_NF_rulesb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
nFQ_subset_NF_rulesb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = nFQ_subset_NF_rules;

is_QNFb :: forall a b c d. Tp_ops_ext a b c d -> a -> Term b c -> Bool;
is_QNFb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = is_QNF;

rulesd :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulesd
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = rules;

icap_impl_tp ::
  forall a b.
    (Eq b) => Tp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_tp i d =
  let {
    qr = nFQ_subset_NF_rulesb i d;
    qnf = is_QNFb i d;
    r = rulesd i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s -> let {
                 a = ceta_set_of (concatMap vars_term_list s);
               } in ic s a);

label_decomp :: forall a b. Lab a b -> (Lab a b, Sum b [Lab a b]);
label_decomp (Lab f l) = (f, Inl l);
label_decomp (FunLab f l) = (f, Inr l);

is_partition_impl ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => [Set a] -> Maybe (Set a);
is_partition_impl [] = Just bot_set;
is_partition_impl (asa : rest) =
  bind (is_partition_impl rest)
    (\ alla ->
      (if is_empty (inf_set asa alla) then Just (sup_set alla asa)
        else Nothing));

is_partition ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a, Set_impl a) => [Set a] -> Bool;
is_partition asa = not (is_none (is_partition_impl asa));

remdups_sort :: forall a. (Eq a, Linorder a) => [a] -> [a];
remdups_sort xs = remdups_adj (sort_key (\ x -> x) xs);

list_all_rec :: forall a. (a -> Bool) -> [a] -> Bool;
list_all_rec p [] = True;
list_all_rec p (a : l) = p a && list_all_rec p l;

rep_rai_list :: Rai_list -> [Maybe (Root_info, (Poly Rat, (Rat, Rat)))];
rep_rai_list (Abs_rai_list x) = x;

rai_list_hd_intern ::
  [Maybe (Root_info, (Poly Rat, (Rat, Rat)))] ->
    Maybe (Root_info, (Poly Rat, (Rat, Rat)));
rai_list_hd_intern (x : xs) = x;
rai_list_hd_intern [] = Nothing;

rai_list_hd :: Rai_list -> Real_alg_intern;
rai_list_hd xa = Abs_real_alg_intern (rai_list_hd_intern (rep_rai_list xa));

rai_list_tl :: Rai_list -> Rai_list;
rai_list_tl xa = Abs_rai_list (tla (rep_rai_list xa));

max_list_non_empty :: forall a. (Linorder a) => [a] -> a;
max_list_non_empty [x] = x;
max_list_non_empty (x : v : va) = max x (max_list_non_empty (v : va));

root_bounds :: Poly Rat -> (Rat, Rat);
root_bounds p =
  let {
    n = degreea p;
    m = times_rat (of_nat n) (max_list_non_empty (map abs_rat (coeffs p)));
    ma = of_int (ceiling m);
  } in (uminus_rat ma, ma);

set_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
set_ext s_ns =
  (\ asa bs ->
    (not (null asa) && all (\ b -> any (\ a -> fst (s_ns a b)) asa) bs,
      all (\ b -> any (\ a -> snd (s_ns a b)) asa) bs));

poly_inf_rat :: Poly Rat -> Rat;
poly_inf_rat p = sgn_rat (coeff p (degreea p));

check_no_var ::
  forall a b.
    (Showa a, Showa b) => Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_var t =
  check (not (is_Var t))
    (shows_string
       ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'f', 'o', 'u', 'n', 'd'] .
      shows_nl);

check_supteq ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Term a b ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_supteq s t =
  check (equal_term s t || supt_impl s t)
    (shows_prec_term zero_nat t .
      shows_string
        [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 't',
          'e', 'r', 'm', ' ', 'o', 'f', ' '] .
        shows_prec_term zero_nat s);

ta_match ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Eq b, Ceq c,
      Ccompare c) => Ta_ext a b () ->
                       Set a -> Term b c -> Set a -> Set [(c, a)];
ta_match ta qsig (Fun f ts) q =
  let {
    n = size_list ts;
    rls = filtera
            (\ rule ->
              r_sym rule == (f, n) &&
                bex (sup_set (inserta (r_rhs rule) bot_set)
                      (compute_trancl (inserta (r_rhs rule) bot_set)
                        (ta_eps ta)))
                  (\ qa -> member qa q))
            (ta_rules ta);
  } in sup_seta
         (image
           (\ (TA_rule _ qs _) ->
             image concat
               (listset
                 (map (\ (tsi, qsi) ->
                        ta_match ta qsig tsi (inserta qsi bot_set))
                   (zip ts qs))))
           rls);
ta_match ta qsig (Var x) q =
  image (\ qa -> [(x, qa)])
    (filtera (\ qa -> member qa qsig)
      (sup_set q (compute_trancl q (converse (ta_eps ta)))));

generate_listset ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Nat -> Set a -> Set [a];
generate_listset n s =
  (if equal_nat n zero_nat
    then inserta [] (set_empty (of_phantom set_impl_list))
    else set_Cons s (generate_listset (minus_nat n one_nat) s));

minus_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
minus_set a b = inf_set a (uminus_set b);

mergeb :: forall a. (Eq a) => Term a () -> Term a () -> Maybe (Term a ());
mergeb (Fun fa tsa) (Fun f ts) =
  bind (guarda (fa == f))
    (\ _ ->
      bind (guarda (equal_nat (size_list tsa) (size_list ts)))
        (\ _ ->
          bind (mapMa (\ (a, b) -> mergeb a b) (zip tsa ts))
            (\ tsb -> Just (Fun fa tsb))));
mergeb (Var ()) x = Just x;
mergeb (Fun v va) (Var ()) = Just (Fun v va);

merge_cl :: forall a. (Compare a, Eq a) => Set (Term a ()) -> Set (Term a ());
merge_cl s =
  let {
    new = minus_set (these (image (\ (a, b) -> mergeb a b) (productc s s))) s;
  } in (if set_eq new (set_empty (of_phantom set_impl_term)) then s
         else merge_cl (sup_set s new));

subt_merge_cl ::
  forall a b.
    (Compare a, Eq a, Compare b, Eq b) => Set (Term a b) -> Set (Term a ());
subt_merge_cl s =
  merge_cl
    (sup_set (inserta (Var ()) (set_empty (of_phantom set_impl_term)))
      (sup_seta
        (image (\ t -> set (supt_list t))
          (image (map_term (\ x -> x) (\ _ -> ())) s))));

maxa :: forall a. (Ceq a, Ccompare a, Lattice a, Linorder a) => Set a -> a;
maxa a = set_fold1 max_sls a;

matchd :: forall a b. (Eq a) => Term a () -> Term a b -> Bool;
matchd (Var ()) x = True;
matchd (Fun fa tsa) (Fun f ts) = fa == f && list_all2 matchd tsa ts;
matchd (Fun v va) (Var vb) = False;

shrinks ::
  forall a.
    (Compare a, Eq a) => Term a () -> Set (Term a ()) -> Set (Term a ());
shrinks ta t =
  let {
    s = filtera (\ s -> matchd s ta) t;
    max = maxa (image (size_list . funs_term_list) s);
  } in filtera (\ sa -> equal_nat ((size_list . funs_term_list) sa) max) s;

nf_rules_states_impl ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Set (Term a b) ->
                 Set (a, Nat) -> (Set (Ta_rule (Term a ()) a), Set (Term a ()));
nf_rules_states_impl t sig =
  let {
    mcl = subt_merge_cl t;
    states =
      filtera
        (\ q ->
          ball t (\ ta -> not (matchd (map_term (\ x -> x) (\ _ -> ()) ta) q)))
        mcl;
    lhss =
      sup_seta
        (image (\ (f, n) -> image (\ a -> (f, a)) (generate_listset n states))
          sig);
    flhss =
      filtera
        (\ q ->
          ball t
            (\ ta ->
              not (matchd (map_term (\ x -> x) (\ _ -> ()) ta)
                    (Fun (fst q) (snd q)))))
        lhss;
    rules =
      image (\ (f, qs) -> image (TA_rule f qs) (shrinks (Fun f qs) mcl)) flhss;
  } in (sup_seta rules, states);

ta_nf ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Set (Term a b) -> Set (a, Nat) -> Ta_ext (Term a ()) a ();
ta_nf t sig =
  let {
    (rules, states) = nf_rules_states_impl t sig;
  } in Ta_ext states rules
         (set_empty
           (of_phantom
             (set_impl_prod :: Phantom (Term a (), Term a ()) Set_impla)))
         ();

compute_NF :: forall a. (a -> Maybe a) -> a -> Maybe a;
compute_NF f a = (case f a of {
                   Nothing -> Just a;
                   Just aa -> compute_NF f aa;
                 });

first_rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
first_rewrite r s = (case rewrite r s of {
                      [] -> Nothing;
                      t : _ -> Just t;
                    });

compute_rstep_NF ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
compute_rstep_NF r s = compute_NF (first_rewrite r) s;

check_join_NF ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join_NF r s t =
  (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
    (Nothing, _) ->
      Inl (shows_prec_list zero_nat
            ['s', 't', 'r', 'a', 'n', 'g', 'e', ' ', 'e', 'r', 'r', 'o', 'r',
              ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
              'r', 'm', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'a', 't', 'i', 'o',
              'n']);
    (Just _, Nothing) ->
      Inl (shows_prec_list zero_nat
            ['s', 't', 'r', 'a', 'n', 'g', 'e', ' ', 'e', 'r', 'r', 'o', 'r',
              ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
              'r', 'm', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'a', 't', 'i', 'o',
              'n']);
    (Just sa, Just ta) ->
      check (equal_term sa ta)
        (shows_string
           ['t', 'h', 'e', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
             'r', 'm', ' '] .
          shows_prec_term zero_nat sa .
            shows_prec_list zero_nat [' ', 'o', 'f', ' '] .
              shows_prec_term zero_nat s .
                shows_prec_list zero_nat
                  [' ', 'd', 'i', 'f', 'f', 'e', 'r', 's', ' ', 'f', 'r', 'o',
                    'm', ' '] .
                  shows_nl .
                    shows_prec_list zero_nat
                      ['t', 'h', 'e', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ',
                        'f', 'o', 'r', 'm', ' '] .
                      shows_prec_term zero_nat ta .
                        shows_prec_list zero_nat [' ', 'o', 'f', ' '] .
                          shows_prec_term zero_nat t);
  });

in_rstep_impl ::
  forall a b.
    (Compare a, Eq a, Ccompare b, Compare b, Eq b,
      Mapping_impl b) => Term a b ->
                           Term a b -> Set (Term a b, Term a b) -> Bool;
in_rstep_impl s t r =
  any (\ p ->
        in_poss p t &&
          equal_ctxt (ctxt_of_pos_term p s) (ctxt_of_pos_term p t) &&
            let {
              sp = subt_at s p;
              tp = subt_at t p;
            } in bex r (\ lr ->
                         not (is_none
                               (match_list Var [(fst lr, sp), (snd lr, tp)]))))
    (poss_list s);

reverse_rules :: forall a b. [(Term a b, Term a b)] -> [(Term a b, Term a b)];
reverse_rules rs = map swap rs;

wf_rules_impl ::
  forall a b. (Eq b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)];
wf_rules_impl r = filter wf_rule r;

check_pairwise :: forall a b. (a -> a -> Sum b ()) -> [a] -> Sum b ();
check_pairwise c [] = Inr ();
check_pairwise c (x : xs) =
  bindb (catch_errora (forallM (c x) xs) (\ xa -> Inl (snd xa)))
    (\ _ -> check_pairwise c xs);

check_disjoint :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_disjoint xs ys =
  catch_errora
    (forallM (\ x -> (if not (membera ys x) then Inr () else Inl x)) xs)
    (\ x -> Inl (snd x));

check_partition :: forall a. (Eq a) => [[a]] -> Sum a ();
check_partition xss = check_pairwise check_disjoint xss;

check_inj ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Lab a b ->
                    Nat ->
                      [((Lab a b, Nat), [Lab a b])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_inj a nn sml =
  let {
    symbols =
      map (\ (aa, b) ->
            let {
              (_, n) = aa;
            } in (\ fs ->
                   map (\ (g, i) ->
                         (g, plus_nat n (times_nat i (minus_nat nn one_nat))))
                     (zip fs (upt zero_nat (size_list fs))))
              b)
        sml;
    fsymbols = concat symbols;
  } in bindb (catch_errora (check_partition symbols)
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
                       shows_prec_prod zero_nat x .
                         shows_prec_list zero_nat
                           [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 't', 'w',
                             'i', 'c', 'e', ')'])))
         (\ _ ->
           bindb (check (not (membera fsymbols (a, nn)))
                   (shows_prec_list zero_nat
                      ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
                        ' ', 's', 'y', 'm', 'b', 'o', 'l'] .
                     shows_prec_lab zero_nat a .
                       shows_prec_list zero_nat
                         [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'o',
                           'c', 'c', 'u', 'r', ' ', 'a', 's', ' ', 'n', 'e',
                           'w', ' ', 's', 'y', 'm', 'b', 'o', 'l']))
             (\ _ ->
               bindb (check (not (membera (map fst sml) (a, nn)))
                       (shows_prec_list zero_nat
                          ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o',
                            'n', ' ', 's', 'y', 'm', 'b', 'o', 'l'] .
                         shows_prec_lab zero_nat a .
                           shows_prec_list zero_nat
                             [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                               'b', 'e', ' ', 'u', 'n', 'c', 'u', 'r', 'r', 'i',
                               'e', 'd']))
                 (\ _ ->
                   (if less_eq_nat nn one_nat
                     then catch_errora
                            (forallM
                              (check_pairwise
                                (\ gn1 gn2 ->
                                  check (not (gn1 == gn2))
                                    (shows_prec_list zero_nat
                                       ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
                                      shows_prec_prod zero_nat gn1 .
shows_prec_list zero_nat
  [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 't', 'w', 'i', 'c', 'e'])))
                              symbols)
                            (\ x -> Inl (snd x))
                     else Inr ()))));

not_ws_ns :: forall a b c. Redtriple_ext a b c -> Maybe [(a, Nat)];
not_ws_ns (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more)
  = not_ws_ns;

no_complexity_check ::
  forall a b. a -> b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
no_complexity_check =
  (\ _ _ ->
    Inl (shows_prec_list zero_nat
          ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'a', 'n', 'a',
            'l', 'y', 's', 'i', 's', ' ', 'u', 'n', 's', 'u', 'p', 'p', 'o',
            'r', 't', 'e', 'd']));

valid ::
  forall a b c.
    Redtriple_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
valid (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  valid;

desc :: forall a b c. Redtriple_ext a b c -> [Prelude.Char] -> [Prelude.Char];
desc (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  desc;

check_status_ws_info ::
  forall a.
    (Showa a) => Status a ->
                   ((Term a [Prelude.Char], Term a [Prelude.Char]) ->
                     Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                     Maybe [(a, Nat)] ->
                       Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_status_ws_info sigma cns Nothing =
  Inl (shows_prec_list zero_nat
        ['m', 'i', 's', 's', 'i', 'n', 'g', ' ', 'w', 'e', 'a', 'k', '-', 's',
          'u', 'b', 't', 'e', 'r', 'm', ' ', 's', 't', 'a', 't', 'u', 's', ' ',
          'o', 'f', ' ', 'b', 'a', 's', 'e', ' ', 'r', 'e', 'd', 'u', 'c', 't',
          'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r']);
check_status_ws_info sigma cns (Just fs) =
  catch_errora
    (forallM
      (\ f ->
        catch_errora
          (forallM
            (\ i ->
              catch_errora
                (cns (Fun (fst f)
                        (map (\ ia -> Var (shows_prec_nat zero_nat ia []))
                          (upt zero_nat (snd f))),
                       Var (shows_prec_nat zero_nat i [])))
                (\ _ ->
                  Inl (shows_prec_list zero_nat
                         ['a', 'c', 'c', 'o', 'r', 'd', 'i', 'n', 'g', ' ', 't',
                           'o', ' ', 'w', 'e', 'a', 'k', '-', 'm', 'o', 'n',
                           '.', ' ', 'i', 'n', 'f', 'o', 'r', 'm', 'a', 't',
                           'i', 'o', 'n', ' ', 'o', 'f', ' ', 'o', 'r', 'd',
                           'e', 'r', ',', ' ', 'a', 'r', 'g', 'u', 'm', 'e',
                           'n', 't', ' ', '#'] .
                        shows_prec_nat zero_nat (suc i) .
                          shows_prec_list zero_nat
                            [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                              'o', 'c', 'c', 'u', 'r', ' ', 'i', 'n', ' ', 's',
                              't', 'a', 't', 'u', 's', ' ', 'o', 'f', ' '] .
                            shows_prec_prod zero_nat f)))
            (status sigma f))
          (\ x -> Inl (snd x)))
      fs)
    (\ x -> Inl (snd x));

ns :: forall a b c.
        Redtriple_ext a b c ->
          (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
ns (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) = ns;

af :: forall a b c. Redtriple_ext a b c -> (a, Nat) -> Set Nat;
af (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) = af;

s :: forall a b c.
       Redtriple_ext a b c ->
         (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
s (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) = s;

shows_wpo_params ::
  forall a.
    (Showa a) => [((a, Nat), (Nat, [Nat]))] -> [Prelude.Char] -> [Prelude.Char];
shows_wpo_params params =
  shows_prec_list zero_nat
    ['s', 't', 'a', 't', 'u', 's', ' ', 'a', 'n', 'd', ' ', 'p', 'r', 'e', 'c',
      'e', 'd', 'e', 'n', 'c', 'e', ' '] .
    shows_nl .
      shows_sep
        (\ (f, (p, s)) ->
          shows_prec_list zero_nat ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec_prod zero_nat f .
              shows_prec_list zero_nat
                [':', ' ', 'p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e',
                  ' ', '=', ' '] .
                shows_prec_nat zero_nat p .
                  shows_prec_list zero_nat
                    [' ', ' ', ' ', 's', 't', 'a', 't', 'u', 's', ' ', '=',
                      ' '] .
                    shows_prec_list zero_nat s)
        shows_nl params;

faulty_redtriple ::
  forall a b.
    Itself a ->
      Itself b ->
        ([Prelude.Char] -> [Prelude.Char]) ->
          ([Prelude.Char] -> [Prelude.Char]) -> Redtriple_ext a b ();
faulty_redtriple uu uv err desc =
  Redtriple_ext (Inl err) (\ _ -> Inr ()) (\ _ -> Inr ()) (\ _ -> Inr ())
    full_af empty_af (\ _ -> Inr ()) desc Nothing no_complexity_check ();

prl_nat :: forall a. ((a, Nat) -> Nat) -> (a, Nat) -> Bool;
prl_nat pr = (\ f -> equal_nat (pr f) zero_nat);

prc_nat :: forall a. ((a, Nat) -> Nat) -> (a, Nat) -> (a, Nat) -> (Bool, Bool);
prc_nat pr = (\ f g -> let {
                         pf = pr f;
                         pg = pr g;
                       } in (less_nat pg pf, less_eq_nat pg pf));

wpo_redtriple ::
  forall a.
    (Eq a, Key a,
      Showa a) => Redtriple_ext a [Prelude.Char] () ->
                    [((a, Nat), (Nat, [Nat]))] ->
                      Redtriple_ext a [Prelude.Char] ();
wpo_redtriple rt params =
  let {
    stat = map (\ (f, ps) -> (f, snd ps)) params;
    pr = fun_of_map_funa (ceta_map_of params) (\ _ -> zero_nat) fst;
    desca =
      shows_prec_list zero_nat ['W', 'P', 'O', ' ', 'w', 'i', 't', 'h', ' '] .
        shows_wpo_params params .
          shows_nl .
            shows_prec_list zero_nat
              ['o', 'v', 'e', 'r', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                'o', 'w', 'i', 'n', 'g', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i',
                'o', 'n', ' ', 'p', 'a', 'i', 'r', ':'] .
              shows_nl . desc rt;
  } in (case status_of stat of {
         Nothing ->
           faulty_redtriple Type Type
             (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
                 'i', 'n', 'd', 'i', 'c', 'e', 's', ' ', 'i', 'n', ' ', 's',
                 't', 'a', 't', 'u', 's', ' ', 'o', 'f', ' ', 'W', 'P', 'O',
                 '!'])
             desca;
         Just sigma ->
           let {
             sa = (\ sa t -> isOK (s rt (sa, t)));
             nsa = (\ sb t -> isOK (ns rt (sb, t)));
             wpo = wpo_ub (prc_nat pr) (prl_nat pr) sa nsa sigma;
             wpo_s =
               (\ (sb, t) ->
                 check (fst (wpo sb t))
                   (shows_prec_term zero_nat sb .
                     shows_prec_list zero_nat [' ', '>', 'w', 'p', 'o', ' '] .
                       shows_prec_term zero_nat t .
                         shows_prec_list zero_nat
                           [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                             ' ', 'b', 'e', ' ', 'e', 'n', 's', 'u', 'r', 'e',
                             'd']));
             wpo_ns =
               (\ (sb, t) ->
                 check (snd (wpo sb t))
                   (shows_prec_term zero_nat sb .
                     shows_prec_list zero_nat
                       [' ', '>', '=', 'w', 'p', 'o', ' '] .
                       shows_prec_term zero_nat t .
                         shows_prec_list zero_nat
                           [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                             ' ', 'b', 'e', ' ', 'e', 'n', 's', 'u', 'r', 'e',
                             'd']));
           } in Redtriple_ext
                  (bindb (valid rt)
                    (\ _ -> check_status_ws_info sigma (ns rt) (not_ws_ns rt)))
                  wpo_s wpo_ns wpo_ns (af_wpo (af rt) sigma) empty_af
                  (\ _ ->
                    catch_errora
                      (forallM
                        (\ (a, b) ->
                          let {
                            (f, n) = a;
                          } in (\ idx ->
                                 check (eq_set (set idx) (set (upt zero_nat n)))
                                   (shows_prec_list zero_nat
                                      ['f', 'o', 'r', ' ', 'm', 'o', 'n', 'o',
't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ',', ' ', 's', 't', 'a', 't', 'u', 's',
' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 't',
'e', ',', ' ', 'b', 'u', 't', ' ', 's', 't', 'a', 't', 'u', 's', ' ', 'o', 'f',
' '] .
                                     shows_prec_prod zero_nat (f, n) .
                                       shows_prec_list zero_nat
 [' ', 'i', 's', ' '] .
 shows_prec_list zero_nat (map suc idx)))
                            b)
                        stat)
                      (\ x -> Inl (snd x)))
                  desca (Just (map fst stat)) no_complexity_check ();
       });

parse_xml_string ::
  forall a.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      [Prelude.Char] -> Sum [Prelude.Char] a;
parse_xml_string p str = (case string2xml str of {
                           Inl a -> Inl a;
                           Inr a -> parse_xml p a;
                         });

parse_claim ::
  forall a b c. a -> [Prelude.Char] -> Sum [Prelude.Char] (Claim b c);
parse_claim f = parse_xml_string xml2claim;

apply_af_entry :: forall a b. a -> Af_entry -> [Term a b] -> Term a b;
apply_af_entry uu (Collapse i) ts = nth ts i;
apply_af_entry f (AFList is) ts = Fun f (map (nth ts) is);

afs_term :: forall a b. Afs a -> Term a b -> Term (Filtered a) b;
afs_term pi (Fun f ts) =
  let {
    l = size_list ts;
  } in apply_af_entry (FPair f l) (afsa pi (f, l)) (map (afs_term pi) ts);
afs_term pi (Var x) = Var x;

afs_rule ::
  forall a b.
    Afs a -> (Term a b, Term a b) -> (Term (Filtered a) b, Term (Filtered a) b);
afs_rule pi lr = (afs_term pi (fst lr), afs_term pi (snd lr));

af_rule :: forall a b. Afs a -> (Term a b, Term a b) -> (Term a b, Term a b);
af_rule pi = (\ t -> map_funs_rule filtered_fun (afs_rule pi t));

af_term :: forall a b. Afs a -> Term a b -> Term a b;
af_term pi t = map_term filtered_fun (\ x -> x) (afs_term pi t);

nat_or_empty ::
  forall a b c d.
    (Showa d) => ([Xml], (a, (b, (c, d)))) ->
                   Sum (Xml_error [Prelude.Char]) (Maybe Nat);
nat_or_empty ([], s) = Inr Nothing;
nat_or_empty ([XML_text txt], s) = (case int_of_stringa txt of {
                                     Inl err -> xml_error err ([], s);
                                     Inr n -> Inr (Just (nat n));
                                   });

uncurry_info ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (a, ([((a, Nat), [a])],
                             ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                               [(Term a [Prelude.Char],
                                  Term a [Prelude.Char])])));
uncurry_info xml2name =
  xml_do
    ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'I', 'n', 'f', 'o', 'r', 'm', 'a', 't',
      'i', 'o', 'n']
    (xml_take xml2name
      (\ a ->
        xml_take
          (xml_do
            ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', 'S', 'y', 'm', 'b',
              'o', 'l', 's']
            (xml_take_many_sub [] zero_nat Infinity_enat
              (xml_do
                ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', 'S', 'y', 'm',
                  'b', 'o', 'l', 'E', 'n', 't', 'r', 'y']
                (xml_take xml2name
                  (\ f ->
                    xml_take (xml_nat ['a', 'r', 'i', 't', 'y'])
                      (\ n ->
                        xml_take_many_sub [] zero_nat Infinity_enat xml2name
                          (\ fs -> xml_return ((f, n), fs))))))
              xml_return))
          (\ sml ->
            xml_take
              (xml_do
                ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'R', 'u', 'l', 'e', 's']
                (xml_take (rules xml2name) (\ x -> xml_return (id x))))
              (\ u ->
                xml_take
                  (xml_do ['e', 't', 'a', 'R', 'u', 'l', 'e', 's']
                    (xml_take (rules xml2name) (\ x -> xml_return (id x))))
                  (\ e -> xml_return (a, (sml, (u, e))))))));

convertible_critical_peaks ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       [(Term a [Prelude.Char],
                          (Term a [Prelude.Char],
                            ([(Pos, ((Term a [Prelude.Char],
                                       Term a [Prelude.Char]),
                                      (Bool, Term a [Prelude.Char])))],
                              ([(Pos, ((Term a [Prelude.Char],
 Term a [Prelude.Char]),
Term a [Prelude.Char]))],
                                ([(Pos, ((Term a [Prelude.Char],
   Term a [Prelude.Char]),
  (Bool, Term a [Prelude.Char])))],
                                  (Term a [Prelude.Char],
                                    ([(Pos,
((Term a [Prelude.Char], Term a [Prelude.Char]),
  (Bool, Term a [Prelude.Char])))],
                                      ([(Pos,
  ((Term a [Prelude.Char], Term a [Prelude.Char]), Term a [Prelude.Char]))],
[(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
         (Bool, Term a [Prelude.Char])))]))))))))];
convertible_critical_peaks xml2name =
  let {
    rew = rsteps xml2name;
    conv = conversion xml2name;
  } in xml_do
         ['c', 'o', 'n', 'v', 'e', 'r', 't', 'i', 'b', 'l', 'e', 'C', 'r', 'i',
           't', 'i', 'c', 'a', 'l', 'P', 'e', 'a', 'k', 's']
         (xml_take_many_sub [] zero_nat Infinity_enat
           (xml_do
             ['c', 'o', 'n', 'v', 'e', 'r', 't', 'i', 'b', 'l', 'e', 'C', 'r',
               'i', 't', 'i', 'c', 'a', 'l', 'P', 'e', 'a', 'k']
             (xml_take
               (xml_do ['s', 'o', 'u', 'r', 'c', 'e']
                 (xml_take (term xml2name) (\ x -> xml_return (id x))))
               (\ s ->
                 xml_take
                   (xml_do
                     ['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', 'L',
                       'e', 'f', 't']
                     (xml_take conv
                       (\ (sa, c1) ->
                         xml_take rew
                           (\ (_, r) ->
                             xml_take conv
                               (\ (_, c2) -> xml_return (sa, (c1, (r, c2))))))))
                   (\ (s1, (cl1, (sl, cl2))) ->
                     xml_take
                       (xml_do
                         ['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', 'R',
                           'i', 'g', 'h', 't']
                         (xml_take conv
                           (\ (sa, c1) ->
                             xml_take rew
                               (\ (_, r) ->
                                 xml_take conv
                                   (\ (_, c2) ->
                                     xml_return (sa, (c1, (r, c2))))))))
                       (\ (s2, (cr1, (sr, cr2))) ->
                         xml_return
                           (s, (s1, (cl1, (sl,
    (cl2, (s2, (cr1, (sr, cr2)))))))))))))
           xml_return);

ordering_constraint_proof ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   Bool ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) (Redtriple_impl a);
ordering_constraint_proof xml2name bi =
  xml_do
    ['o', 'r', 'd', 'e', 'r', 'i', 'n', 'g', 'C', 'o', 'n', 's', 't', 'r', 'a',
      'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_do ['r', 'e', 'd', 'P', 'a', 'i', 'r']
        (xml_take (redtriple xml2name bi) (\ x -> xml_return (id x))))
      (\ x -> xml_return (id x)));

ordering_constraint_proofa ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   Bool ->
                     (Xml, ([([Prelude.Char], [Prelude.Char])],
                             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char])
                         (Sum (Root_redtriple_impl a) (Redtriple_impl a));
ordering_constraint_proofa xml2name bi =
  xml_do
    ['o', 'r', 'd', 'e', 'r', 'i', 'n', 'g', 'C', 'o', 'n', 's', 't', 'r', 'a',
      'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
    (xml_take (redtriplea xml2name bi) (\ x -> xml_return (id x)));

create_proj :: forall a. (Key a) => ProjL a -> (a, Nat) -> Nat;
create_proj (Projection p) = let {
                               i = ceta_map_of p;
                             } in (\ f -> (case i f of {
    Nothing -> zero_nat;
    Just n -> n;
  }));

xml2cond_constraint ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Cond_constraint a [Prelude.Char]);
xml2cond_constraint xml2name x =
  xml_do
    ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o', 'n', 's',
      't', 'r', 'a', 'i', 'n', 't']
    (xml_take
      (xml_or
        (xml_do ['a', 'l', 'l']
          (xml_take (xml_text ['v', 'a', 'r'])
            (\ a ->
              xml_take (xml2cond_constraint xml2name)
                (\ b -> xml_return (CC_all a b)))))
        (xml_or
          (xml_do ['i', 'm', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n']
            (xml_take (xml2cond_constraint xml2name)
              (\ c ->
                xml_take_many_sub [] zero_nat Infinity_enat
                  (xml2cond_constraint xml2name)
                  (\ cs ->
                    let {
                      ccs = c : cs;
                    } in xml_return
                           (CC_impl (take (size_list cs) ccs) (last ccs))))))
          (xml_do ['c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't']
            (xml_take (term xml2name)
              (\ s ->
                xml_take
                  (xml_or (xml_leaf ['r', 'e', 'w', 'r', 'i', 't', 'e'] Nothing)
                    (xml_or
                      (xml_leaf ['s', 't', 'r', 'i', 'c', 't'] (Just True))
                      (xml_leaf ['n', 'o', 'n', 'S', 't', 'r', 'i', 'c', 't']
                        (Just False))))
                  (\ rel ->
                    xml_take (term xml2name)
                      (\ t ->
                        xml_return (case rel of {
                                     Nothing -> CC_rewr s t;
                                     Just stri -> CC_cond stri (s, t);
                                   }))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2cond_constraint_prf ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Cond_constraint_prf a [Prelude.Char]);
xml2cond_constraint_prf xml2name x =
  let {
    cc = xml2cond_constraint xml2name;
  } in xml_do
         ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o', 'n',
           's', 't', 'r', 'a', 'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
         (xml_take
           (xml_or (xml_leaf ['f', 'i', 'n', 'a', 'l'] Final)
             (xml_or
               (xml_do
                 ['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', 'C', 'o', 'n',
                   's', 't', 'r', 'u', 'c', 't', 'o', 'r']
                 (xml_take cc (\ a -> xml_return (Different_Constructor a))))
               (xml_or
                 (xml_do
                   ['s', 'a', 'm', 'e', 'C', 'o', 'n', 's', 't', 'r', 'u', 'c',
                     't', 'o', 'r']
                   (xml_take cc
                     (\ a ->
                       xml_take cc
                         (\ b ->
                           xml_take (xml2cond_constraint_prf xml2name)
                             (\ c -> xml_return (Same_Constructor a b c))))))
                 (xml_or
                   (xml_do
                     ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'E', 'q', 'u',
                       'a', 't', 'i', 'o', 'n']
                     (xml_take (xml_text ['v', 'a', 'r'])
                       (\ a ->
                         xml_take (term xml2name)
                           (\ b ->
                             xml_take cc
                               (\ c ->
                                 xml_take (xml2cond_constraint_prf xml2name)
                                   (\ d ->
                                     xml_return
                                       (Variable_Equation a b c d)))))))
                   (xml_or
                     (xml_do
                       ['f', 'u', 'n', 'a', 'r', 'g', 'I', 'n', 't', 'o', 'V',
                         'a', 'r']
                       (xml_take cc
                         (\ a ->
                           xml_take position
                             (\ b ->
                               xml_take (xml_text ['v', 'a', 'r'])
                                 (\ c ->
                                   xml_take cc
                                     (\ d ->
                                       xml_take
 (xml2cond_constraint_prf xml2name)
 (\ e -> xml_return (Funarg_Into_Var a b c d e))))))))
                     (xml_or
                       (xml_do
                         ['s', 'i', 'm', 'p', 'l', 'i', 'f', 'y', 'C', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n']
                         (xml_take cc
                           (\ a ->
                             xml_take (substa xml2name)
                               (\ b ->
                                 xml_take cc
                                   (\ c ->
                                     xml_take (xml2cond_constraint_prf xml2name)
                                       (\ d ->
 xml_return (Simplify_Condition a b c d)))))))
                       (xml_or
                         (xml_do ['i', 'n', 'd', 'u', 'c', 't', 'i', 'o', 'n']
                           (xml_take cc
                             (\ a ->
                               xml_take
                                 (xml_do
                                   ['c', 'o', 'n', 'j', 'u', 'n', 'c', 't', 's']
                                   (xml_take_many_sub [] zero_nat Infinity_enat
                                     cc xml_return))
                                 (\ b ->
                                   xml_take
                                     (xml_do
                                       ['r', 'u', 'l', 'e', 'C', 'o', 'n', 's',
 't', 'r', 'a', 'i', 'n', 't', 'P', 'r', 'o', 'o', 'f', 's']
                                       (xml_take_many_sub [] zero_nat
 Infinity_enat
 (xml_do
   ['r', 'u', 'l', 'e', 'C', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', 'P',
     'r', 'o', 'o', 'f']
   (xml_take (rule xml2name)
     (\ lr ->
       xml_take
         (xml_do
           ['s', 'u', 'b', 't', 'e', 'r', 'm', 'V', 'a', 'r', 'E', 'n', 't',
             'r', 'i', 'e', 's']
           (xml_take_many_sub [] zero_nat Infinity_enat
             (xml_do
               ['s', 'u', 'b', 't', 'e', 'r', 'm', 'V', 'a', 'r', 'E', 'n', 't',
                 'r', 'y']
               (xml_take (term xml2name)
                 (\ aa ->
                   xml_take_many_sub [] zero_nat Infinity_enat
                     (xml_text ['v', 'a', 'r']) (\ ba -> xml_return (aa, ba)))))
             xml_return))
         (\ rys ->
           xml_take cc
             (\ cca ->
               xml_take (xml2cond_constraint_prf xml2name)
                 (\ p -> xml_return (lr, (rys, (cca, p)))))))))
 xml_return))
                                     (\ c -> xml_return (Induction a b c))))))
                         (xml_do
                           ['d', 'e', 'l', 'e', 't', 'e', 'C', 'o', 'n', 'd',
                             'i', 't', 'i', 'o', 'n']
                           (xml_take cc
                             (\ a ->
                               xml_take (xml2cond_constraint_prf xml2name)
                                 (\ b ->
                                   xml_return (Delete_Condition a b))))))))))))
           (\ xa -> xml_return (id xa)))
         x;

xml2cond_red_pair_proof ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       (Cond_red_pair_prf a [Prelude.Char]);
xml2cond_red_pair_proof xml2name =
  xml_do
    ['c', 'o', 'n', 'd', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'o',
      'f']
    (xml_take xml2name
      (\ c ->
        xml_take (xml_nat ['b', 'e', 'f', 'o', 'r', 'e'])
          (\ b ->
            xml_take (xml_nat ['a', 'f', 't', 'e', 'r'])
              (\ a ->
                xml_take
                  (xml_do ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's']
                    (xml_take_many_sub [] zero_nat Infinity_enat
                      (xml_do ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n']
                        (xml_take (xml2cond_constraint xml2name)
                          (\ ca ->
                            xml_take
                              (xml_do
                                ['d', 'p', 'S', 'e', 'q', 'u', 'e', 'n', 'c',
                                  'e']
                                (xml_take (rules xml2name)
                                  (\ x -> xml_return (id x))))
                              (\ s ->
                                xml_take (xml2cond_constraint_prf xml2name)
                                  (\ p -> xml_return (ca, (s, p)))))))
                      xml_return))
                  (\ ccs -> xml_return (Cond_Red_Pair_Prf c ccs b a))))));

projected_rseq ::
  forall a.
    (Eq a,
      Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) a) ->
                    ((a, Nat) -> Nat) ->
                      (Xml, ([([Prelude.Char], [Prelude.Char])],
                              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                        Sum (Xml_error [Prelude.Char])
                          ((Term a [Prelude.Char], Term a [Prelude.Char]),
                            [(Pos, ((Term a [Prelude.Char],
                                      Term a [Prelude.Char]),
                                     Term a [Prelude.Char]))]);
projected_rseq xml2name pi =
  xml_do
    ['p', 'r', 'o', 'j', 'e', 'c', 't', 'e', 'd', 'R', 'e', 'w', 'r', 'i', 't',
      'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e']
    (xml_take (rule xml2name)
      (\ r -> xml_take (rseq xml2name pi r) xml_return));

default_nfs_nt_dp :: Bool;
default_nfs_nt_dp = False;

strategy_to_Q ::
  forall a b.
    (Eq a, Eq b) => Strategy a b -> [(Term a b, Term a b)] -> [Term a b];
strategy_to_Q No_Strategy uu = [];
strategy_to_Q Innermost r = remdups (map fst r);
strategy_to_Q (Innermost_Q q) uv = q;

default_nfs_dp :: Bool;
default_nfs_dp = True;

xml2dp_inputa ::
  forall a b c.
    (Eq a,
      Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) a) ->
                    Bool ->
                      (Xml, ([([Prelude.Char], [Prelude.Char])],
                              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                        Sum (Xml_error [Prelude.Char])
                          (Bool,
                            (Bool,
                              ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                                ([b], ([Term a [Prelude.Char]],
([c], [(Term a [Prelude.Char], Term a [Prelude.Char])]))))));
xml2dp_inputa xml2name termination =
  xml_change (xml2dp_input xml2name)
    (\ (DP_input m p q r) ->
      xml_return
        ((if termination then default_nfs_dp else default_nfs_nt_dp),
          (m, (p, ([], (strategy_to_Q q r, ([], r)))))));

flat_contexts ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) [Ctxt a [Prelude.Char]];
flat_contexts xml2name =
  xml_do ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat (ctxt xml2name) xml_return);

equal_start_term :: Start_term -> Start_term -> Bool;
equal_start_term Full Constructor_Based = False;
equal_start_term Constructor_Based Full = False;
equal_start_term Constructor_Based Constructor_Based = True;
equal_start_term Full Full = True;

o_to_fp_term :: forall a b. Term a b -> (Ctxt a b, (Term a b, Location));
o_to_fp_term t = (Hole, (t, Ba));

o_to_fp_impl :: forall a b. [Term a b] -> [(Ctxt a b, (Term a b, Location))];
o_to_fp_impl = map o_to_fp_term;

mu_to_fp_impl ::
  forall a.
    (Eq a) => [((a, Nat), [Nat])] ->
                [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
mu_to_fp_impl mu =
  let {
    fs = remdups (map fst mu);
    m = map_of mu;
    a = concatMap
          (\ f ->
            let {
              xs = map Var (fresh_strings_list ['x'] zero_nat [] (snd f));
            } in map (\ i -> (f, (xs, i)))
                   (concatMap
                     (\ i -> (if not (membera (the (m f)) i) then [i] else []))
                     (upt zero_nat (snd f))))
          fs;
  } in concatMap
         (\ ((f, _), (xs, i)) ->
           map (\ loc ->
                 (ctxt_of_pos_term (PCons i Empty) (Fun f xs), (nth xs i, loc)))
             [Ba, H])
         a;

strategy_to_fp ::
  forall a.
    (Eq a) => Fp_strategy a [Prelude.Char] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
strategy_to_fp (Forbidden_Patterns p) r = p;
strategy_to_fp Outermost r = o_to_fp_impl (map fst r);
strategy_to_fp (Context_Sensitive mu) r = mu_to_fp_impl mu;

default_nfs_trs :: Bool;
default_nfs_trs = False;

xml2inn_fp_trs_assm ::
  forall a.
    (Eq a,
      Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) a) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Sum (Bool,
                               ([Term a [Prelude.Char]],
                                 ([(Term a [Prelude.Char],
                                     Term a [Prelude.Char])],
                                   [(Term a [Prelude.Char],
                                      Term a [Prelude.Char])])))
                          ([(Ctxt a [Prelude.Char],
                              (Term a [Prelude.Char], Location))],
                            [(Term a [Prelude.Char], Term a [Prelude.Char])]));
xml2inn_fp_trs_assm xml2name =
  xml_change (xml2_trs_input xml2name)
    (\ a ->
      (case a of {
        DP_input _ _ _ _ ->
          xml_error
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        Inn_TRS_input inn r s start ->
          (if not (equal_start_term start Full)
            then xml_error
                   ['s', 't', 'a', 'r', 't', ' ', 't', 'e', 'r', 'm', ' ', 'i',
                     's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
                     'd', ' ', 'h', 'e', 'r', 'e']
            else xml_return
                   (Inl (default_nfs_trs, (strategy_to_Q inn r, (r, s)))));
        CPX_input _ _ _ _ _ ->
          xml_error
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        COMP_input _ _ ->
          xml_error
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        EQ_input _ _ ->
          xml_error
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        FP_TRS_input fp r -> xml_return (Inr (strategy_to_fp fp r, r));
        CTRS_input _ ->
          xml_error
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        TA_input _ _ ->
          xml_error
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        AC_input _ _ _ ->
          xml_error
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        LTS_input _ ->
          xml_error
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        LTS_safety_input _ _ ->
          xml_error
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        Unknown_input _ ->
          xml_error
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
      }));

xml2inn_trs_assm ::
  forall a.
    (Eq a,
      Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) a) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Bool,
                          ([Term a [Prelude.Char]],
                            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                              [(Term a [Prelude.Char],
                                 Term a [Prelude.Char])])));
xml2inn_trs_assm xml2name =
  xml_change (xml2inn_fp_trs_assm xml2name)
    (\ a ->
      (case a of {
        Inl aa -> xml_return aa;
        Inr _ ->
          xml_error
            ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', '(', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ')', ' ', 'T', 'R', 'S', ' ', 'e',
              'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'a', 't', ' ', 't', 'h',
              'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
      }));

xml2trs_termination_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Trs_termination_proof a b [Prelude.Char]);
xml2trs_termination_proof xml2name x =
  xml_or
    (xml_do
      ['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
        'P', 'r', 'o', 'o', 'f']
      (xml_take (xml2trs_termination_proof_inner xml2name)
        (\ xa -> xml_return (id xa))))
    (xml_do
      ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm', 'i', 'n',
        'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f']
      (xml_take (xml2trs_termination_proof_inner xml2name)
        (\ xa -> xml_return (id xa))))
    x;

xml2dp_termination_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Dp_termination_proof a b [Prelude.Char]);
xml2dp_termination_proof xml2name x =
  xml_do ['d', 'p', 'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or (xml_leaf ['p', 'I', 's', 'E', 'm', 'p', 't', 'y'] P_is_Empty)
        (xml_or
          (xml_do ['d', 'e', 'p', 'G', 'r', 'a', 'p', 'h', 'P', 'r', 'o', 'c']
            (xml_take_many_sub [] zero_nat Infinity_enat
              (xml_do ['c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't']
                (xml_take
                  (xml_do ['d', 'p', 's']
                    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                  (\ dps ->
                    xml_take_optional
                      (xml_bool ['r', 'e', 'a', 'l', 'S', 'c', 'c'])
                      (\ _ ->
                        xml_take_optional
                          (xml_do ['a', 'r', 'c', 's']
                            (xml_take_many_sub [] zero_nat Infinity_enat
                              (\ xa -> Inr (fst xa)) (\ _ -> xml_return ())))
                          (\ _ ->
                            xml_take_optional
                              (xml2dp_termination_proof xml2name)
                              (\ prfOpt -> xml_return (prfOpt, dps)))))))
              (\ a -> xml_return (Dep_Graph_Proc a))))
          (xml_or
            (xml_do ['r', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c']
              (xml_take (ordering_constraint_proofa xml2name False)
                (\ a ->
                  xml_take
                    (xml_do ['d', 'p', 's']
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ b ->
                      xml_take (xml2dp_termination_proof xml2name)
                        (\ c -> xml_return (Redpair_Proc a b c))))))
            (xml_or
              (xml_do
                ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'P',
                  'r', 'o', 'c']
                (xml_take
                  (xml_do
                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                  (\ a ->
                    xml_take (xml2dp_termination_proof xml2name)
                      (\ b -> xml_return (Usable_Rules_Proc a b)))))
              (xml_or
                (xml_do
                  ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's',
                    's', 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c']
                  (xml_take (innermostLhss xml2name)
                    (\ a ->
                      xml_take (xml2dp_termination_proof xml2name)
                        (\ b -> xml_return (Q_Reduction_Proc a b)))))
                (xml_or
                  (xml_do
                    ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                      'c']
                    (xml_take (rule xml2name)
                      (\ (s, t) ->
                        xml_take (rstep xml2name)
                          (\ (p, (lr, ta)) ->
                            xml_take_default (s, ta) (rule xml2name)
                              (\ st ->
                                xml_take_optional
                                  (xml_do
                                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u',
                                      'l', 'e', 's']
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ ur ->
                                    xml_take (xml2dp_termination_proof xml2name)
                                      (\ prof ->
xml_return (Rewriting_Proc ur (s, t) (s, ta) st lr p prof))))))))
                  (xml_or
                    (xml_do
                      ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 'P', 'r',
                        'o', 'c']
                      (xml_take (rule xml2name)
                        (\ a ->
                          xml_take pos
                            (\ b ->
                              xml_take
                                (xml_do
                                  ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g',
                                    's']
                                  (xml_take (rules xml2name)
                                    (\ xa -> xml_return (id xa))))
                                (\ c ->
                                  xml_take (xml2dp_termination_proof xml2name)
                                    (\ d ->
                                      xml_return (Narrowing_Proc a b c d)))))))
                    (xml_or
                      (xml_do
                        ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i',
                          'o', 'n', 'P', 'r', 'o', 'c']
                        (xml_take (rule xml2name)
                          (\ a ->
                            xml_take
                              (xml_do
                                ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a',
                                  't', 'i', 'o', 'n', 's']
                                (xml_take (rules xml2name)
                                  (\ xa -> xml_return (id xa))))
                              (\ b ->
                                xml_take (xml2dp_termination_proof xml2name)
                                  (\ c ->
                                    xml_return (Instantiation_Proc a b c))))))
                      (xml_or
                        (xml_do
                          ['f', 'o', 'r', 'w', 'a', 'r', 'd', 'I', 'n', 's',
                            't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                            'P', 'r', 'o', 'c']
                          (xml_take (rule xml2name)
                            (\ a ->
                              xml_take
                                (xml_do
                                  ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a',
                                    't', 'i', 'o', 'n', 's']
                                  (xml_take (rules xml2name)
                                    (\ xa -> xml_return (id xa))))
                                (\ b ->
                                  xml_take_optional
                                    (xml_do
                                      ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u',
'l', 'e', 's']
                                      (xml_take (rules xml2name)
(\ xa -> xml_return (id xa))))
                                    (\ c ->
                                      xml_take
(xml2dp_termination_proof xml2name)
(\ d -> xml_return (Forward_Instantiation_Proc a b c d)))))))
                        (xml_or
                          (xml_do
                            ['s', 'e', 'm', 'l', 'a', 'b', 'P', 'r', 'o', 'c']
                            (xml_take
                              (xmlt2 (sl_variant (xmlt_of_xmlt2 xml2name)))
                              (\ sli ->
                                xml_take
                                  (xml_do ['d', 'p', 's']
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ lp ->
                                    xml_take
                                      (xml_do ['t', 'r', 's']
(xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                                      (\ lr ->
xml_take_default [] (innermostLhss xml2name)
  (\ lq ->
    xml_take (xml2dp_termination_proof xml2name)
      (\ p -> xml_return (Semlab_Proc sli lp lq lr p))))))))
                          (xml_or
                            (xml_do
                              ['s', 'u', 'b', 't', 'e', 'r', 'm', 'P', 'r', 'o',
                                'c']
                              (xml_take
                                (xml_or
                                  (xml_change (proj xml2name)
                                    (xml_return . Inl))
                                  (xml_change (multiset_af xml2name)
                                    (xml_return . Inr)))
                                (\ pi_mpi ->
                                  xml_take_many_sub [] zero_nat Infinity_enat
                                    (projected_rseq xml2name
                                      (create_proj (case pi_mpi of {
             Inl lpi -> lpi;
             Inr _ -> Projection [];
           })))
                                    (\ seq ->
                                      xml_take
(xml_do ['d', 'p', 's']
  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
(\ dps ->
  xml_take (xml2dp_termination_proof xml2name)
    (\ prf ->
      xml_return (case pi_mpi of {
                   Inl lpi -> Subterm_Criterion_Proc lpi seq dps prf;
                   Inr mpi -> Gen_Subterm_Criterion_Proc mpi dps prf;
                 })))))))
                            (xml_or
                              (xml_do
                                ['r', 'e', 'd', 'P', 'a', 'i', 'r', 'U', 'r',
                                  'P', 'r', 'o', 'c']
                                (xml_take
                                  (ordering_constraint_proofa xml2name False)
                                  (\ a ->
                                    xml_take
                                      (xml_do ['d', 'p', 's']
(xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                                      (\ b ->
xml_take
  (xml_do ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
  (\ c ->
    xml_take (xml2dp_termination_proof xml2name)
      (\ d -> xml_return (Redpair_UR_Proc a b c d)))))))
                              (xml_or
                                (xml_do
                                  ['m', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a',
                                    'i', 'r', 'U', 'r', 'P', 'r', 'o', 'c']
                                  (xml_take
                                    (ordering_constraint_proof xml2name False)
                                    (\ a ->
                                      xml_take
(xml_do ['d', 'p', 's']
  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
(\ b ->
  xml_take
    (xml_do ['t', 'r', 's']
      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
    (\ c ->
      xml_take
        (xml_do ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
          (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
        (\ d ->
          xml_take (xml2dp_termination_proof xml2name)
            (\ e -> xml_return (Mono_Redpair_UR_Proc a b c d e))))))))
                                (xml_or
                                  (xml_do
                                    ['m', 'o', 'n', 'o', 'R', 'e', 'd', 'P',
                                      'a', 'i', 'r', 'P', 'r', 'o', 'c']
                                    (xml_take
                                      (ordering_constraint_proof xml2name False)
                                      (\ a ->
xml_take
  (xml_do ['d', 'p', 's']
    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
  (\ b ->
    xml_take
      (xml_do ['t', 'r', 's']
        (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
      (\ c ->
        xml_take (xml2dp_termination_proof xml2name)
          (\ d -> xml_return (Mono_Redpair_Proc a b c d)))))))
                                  (xml_or
                                    (xml_do
                                      ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's',
't', 'M', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c']
                                      (xml_take
(ordering_constraint_proof xml2name False)
(\ a ->
  xml_take
    (xml_do ['d', 'e', 'l', 'e', 't', 'e', 'd']
      (xml_take
        (xml_do ['d', 'p', 's']
          (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
        (\ aa ->
          xml_take
            (xml_do ['t', 'r', 's']
              (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
            (\ b -> xml_return (aa, b)))))
    (\ b ->
      xml_take (xml2dp_termination_proof xml2name)
        (\ c -> xml_return (let {
                              (ba, ca) = b;
                            } in Mono_URM_Redpair_Proc a ba ca
                             c))))))
                                    (xml_or
                                      (xml_do
['u', 'n', 'c', 'u', 'r', 'r', 'y', 'P', 'r', 'o', 'c']
(xml_take_optional
  (xml_nat
    ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'v', 'e', 'T', 'o', 'p'])
  (\ a ->
    xml_take (uncurry_info xml2name)
      (\ b ->
        xml_take
          (xml_do ['d', 'p', 's']
            (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
          (\ c ->
            xml_take
              (xml_do ['t', 'r', 's']
                (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
              (\ d ->
                xml_take (xml2dp_termination_proof xml2name)
                  (\ e -> xml_return (Uncurry_Proc a b c d e))))))))
                                      (xml_or
(xml_do
  ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C', 'l', 'o', 's',
    'u', 'r', 'e', 'P', 'r', 'o', 'c']
  (xml_take
    (xml_do ['f', 'r', 'e', 's', 'h', 'S', 'y', 'm', 'b', 'o', 'l']
      (xml_take xml2name (\ xa -> xml_return (id xa))))
    (\ a ->
      xml_take (flat_contexts xml2name)
        (\ b ->
          xml_take
            (xml_do ['d', 'p', 's']
              (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
            (\ c ->
              xml_take
                (xml_do ['t', 'r', 's']
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ d ->
                  xml_take (xml2dp_termination_proof xml2name)
                    (\ e -> xml_return (Fcc_Proc a b c d e))))))))
(xml_or
  (xml_do
    ['s', 'w', 'i', 't', 'c', 'h', 'I', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't',
      'P', 'r', 'o', 'c']
    (xml_take (wcr_proof xml2name)
      (\ a ->
        xml_take (xml2dp_termination_proof xml2name)
          (\ b -> xml_return (Switch_Innermost_Proc a b)))))
  (xml_or
    (xml_do ['s', 'p', 'l', 'i', 't', 'P', 'r', 'o', 'c']
      (xml_take
        (xml_do ['d', 'p', 's']
          (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
        (\ a ->
          xml_take
            (xml_do ['t', 'r', 's']
              (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
            (\ b ->
              xml_take (xml2dp_termination_proof xml2name)
                (\ c ->
                  xml_take (xml2dp_termination_proof xml2name)
                    (\ d -> xml_return (Split_Proc a b c d)))))))
    (xml_or
      (xml_do
        ['f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', 'A', 's', 's', 'u',
          'm', 'p', 't', 'i', 'o', 'n']
        (xml_take (xml2dp_inputa xml2name True)
          (\ xa -> xml_return (Assume_Finite xa []))))
      (xml_or
        (xml_do ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
          (xml_take
            (xml_text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (\ _ ->
              xml_take (xml2dp_inputa xml2name True)
                (\ b ->
                  xml_take_many_sub [] zero_nat Infinity_enat
                    (\ xa -> Inr (fst xa))
                    (\ _ -> xml_return (Assume_Finite b []))))))
        (xml_or
          (xml_do ['s', 'w', 'i', 't', 'c', 'h', 'T', 'o', 'T', 'R', 'S']
            (xml_take (xml2trs_termination_proof xml2name)
              (\ xa -> xml_return (To_Trs_Proc xa))))
          (xml_or
            (xml_do ['u', 'n', 'l', 'a', 'b', 'P', 'r', 'o', 'c']
              (xml_take
                (xml_do ['d', 'p', 's']
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ a ->
                  xml_take
                    (xml_do ['t', 'r', 's']
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ b ->
                      xml_take (xml2dp_termination_proof xml2name)
                        (\ c -> xml_return (Unlab_Proc a b c))))))
            (xml_or
              (xml_do
                ['g', 'e', 'n', 'e', 'r', 'a', 'l', 'R', 'e', 'd', 'P', 'a',
                  'i', 'r', 'P', 'r', 'o', 'c']
                (xml_take (ordering_constraint_proof xml2name True)
                  (\ rp ->
                    xml_take
                      (xml_do ['s', 't', 'r', 'i', 'c', 't']
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ s ->
                        xml_take
                          (xml_do ['b', 'o', 'u', 'n', 'd']
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ b ->
                            xml_take (xml2cond_red_pair_proof xml2name)
                              (\ c ->
                                xml_take (xml2dp_termination_proof xml2name)
                                  (\ ps ->
                                    xml_take_optional
                                      (xml2dp_termination_proof xml2name)
                                      (\ pbo ->
xml_return (General_Redpair_Proc rp s b c (case pbo of {
    Nothing -> [ps];
    Just pb -> [ps, pb];
  }))))))))))
              (xml_or
                (xml_do
                  ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'C', 'o', 'n', 's', 't',
                    'a', 'n', 't', 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r',
                    'o', 'c']
                  (xml_take (term xml2name)
                    (\ a ->
                      xml_take
                        (xml_do ['r', 'u', 'l', 'e', 'M', 'a', 'p']
                          (xml_take_many_sub [] zero_nat Infinity_enat
                            (xml_do
                              ['r', 'u', 'l', 'e', 'M', 'a', 'p', 'E', 'n', 't',
                                'r', 'y']
                              (xml_take (rule xml2name)
                                (\ aa ->
                                  xml_take (rule xml2name)
                                    (\ b -> xml_return (aa, b)))))
                            (\ aa -> xml_return (id aa))))
                        (\ b ->
                          xml_take (xml2dp_termination_proof xml2name)
                            (\ c ->
                              xml_return
                                (Complex_Constant_Removal_Proc
                                  (Complex_Constant_Removal_Proof a b) c))))))
                (xml_do
                  ['s', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'P', 'r',
                    'o', 'c']
                  (xml_take
                    (xml_or
                      (xml_leaf
                        ['s', 'u', 'b', 't', 'e', 'r', 'm', 'C', 'r', 'i', 't',
                          'e', 'r', 'i', 'o', 'n']
                        Nothing)
                      (xml_do
                        ['r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', 'P', 'a',
                          'i', 'r']
                        (xml_take (ordering_constraint_proof xml2name False)
                          (\ redp ->
                            xml_take_optional
                              (xml_do
                                ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l',
                                  'e', 's']
                                (xml_take (rules xml2name)
                                  (\ xa -> xml_return (id xa))))
                              (\ ur -> xml_return (Just (redp, ur)))))))
                    (\ version ->
                      xml_take_many_sub [] zero_nat Infinity_enat (scg xml2name)
                        (\ b ->
                          (case version of {
                            Nothing -> xml_return (Size_Change_Subterm_Proc b);
                            Just redp_ur ->
                              xml_return
                                (Size_Change_Redpair_Proc (fst redp_ur)
                                  (snd redp_ur) b);
                          }))))))))))))))))))))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2trs_termination_proof_inner ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Trs_termination_proof a b [Prelude.Char]);
xml2trs_termination_proof_inner xml2name x =
  xml_or (xml_leaf ['r', 'I', 's', 'E', 'm', 'p', 't', 'y'] R_is_Empty)
    (xml_or
      (xml_do ['s', 'I', 's', 'E', 'm', 'p', 't', 'y']
        (xml_take (xml2trs_termination_proof xml2name) xml_return))
      (xml_or
        (xml_do ['s', 'e', 'm', 'l', 'a', 'b']
          (xml_take (xmlt2 (sl_variant (xmlt_of_xmlt2 xml2name)))
            (\ sli ->
              xml_take
                (xml_do ['t', 'r', 's']
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ lr ->
                  xml_take_default []
                    (xml_do ['t', 'r', 's']
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ lrw ->
                      xml_take_default [] (innermostLhss xml2name)
                        (\ lq ->
                          xml_take (xml2trs_termination_proof xml2name)
                            (\ p ->
                              xml_return (Semlab sli lq (lr ++ lrw) p))))))))
        (xml_or
          (xml_do ['s', 'p', 'l', 'i', 't']
            (xml_take
              (xml_do ['t', 'r', 's']
                (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
              (\ a ->
                xml_take (xml2trs_termination_proof xml2name)
                  (\ b ->
                    xml_take (xml2trs_termination_proof xml2name)
                      (\ c -> xml_return (Split a b c))))))
          (xml_or
            (xml_do ['d', 'p', 'T', 'r', 'a', 'n', 's']
              (xml_take
                (xml_do ['d', 'p', 's']
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ a ->
                  xml_take
                    (xml_bool
                      ['m', 'a', 'r', 'k', 'e', 'd', 'S', 'y', 'm', 'b', 'o',
                        'l', 's'])
                    (\ _ ->
                      xml_take (xml2dp_termination_proof xml2name)
                        (\ c ->
                          xml_return (DP_Trans default_nfs_dp True a c))))))
            (xml_or
              (xml_do ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
                (xml_take (ordering_constraint_proof xml2name False)
                  (\ ord ->
                    xml_take
                      (xml_do ['t', 'r', 's']
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ r ->
                        xml_take_default []
                          (xml_do ['t', 'r', 's']
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ s ->
                            xml_take (xml2trs_termination_proof xml2name)
                              (\ p ->
                                xml_return (Rule_Removal ord (r ++ s) p)))))))
              (xml_or (xml_change (bounds_info xml2name) (xml_return . Bounds))
                (xml_or
                  (xml_do
                    ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's',
                      'a', 'l']
                    (xml_take
                      (xml_do ['t', 'r', 's']
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ _ ->
                        xml_take_optional
                          (xml_do ['t', 'r', 's']
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ _ ->
                            xml_take (xml2trs_termination_proof xml2name)
                              (\ prf -> xml_return (String_Reversal prf))))))
                  (xml_or
                    (xml_do
                      ['e', 'q', 'u', 'a', 'l', 'i', 't', 'y', 'R', 'e', 'm',
                        'o', 'v', 'a', 'l']
                      (xml_take (xml2trs_termination_proof xml2name)
                        (\ xa -> xml_return (Drop_Equality xa))))
                    (xml_or
                      (xml_do
                        ['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U',
                          'n', 'a', 'r', 'y']
                        (xml_take plain_var
                          (\ v ->
                            xml_take (renaming xml2name)
                              (\ ren ->
                                xml_take
                                  (xml_do ['t', 'r', 's']
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ s ->
                                    xml_take_default []
                                      (xml_do ['t', 'r', 's']
(xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                                      (\ sw ->
xml_take (xml2trs_termination_proof xml2name)
  (\ p ->
    xml_return (Constant_String (Const_string_sound_proof v ren s sw) p))))))))
                      (xml_or
                        (xml_do
                          ['r', 'e', 'm', 'o', 'v', 'e', 'N', 'o', 'n', 'A',
                            'p', 'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e', 'R',
                            'u', 'l', 'e', 's']
                          (xml_take
                            (xml_do ['t', 'r', 's']
                              (xml_take (rules xml2name)
                                (\ xa -> xml_return (id xa))))
                            (\ a ->
                              xml_take (xml2trs_termination_proof xml2name)
                                (\ b ->
                                  xml_return
                                    (Remove_Nonapplicable_Rules a b)))))
                        (xml_or
                          (xml_do ['u', 'n', 'c', 'u', 'r', 'r', 'y']
                            (xml_take (uncurry_info xml2name)
                              (\ i ->
                                xml_take
                                  (xml_do ['t', 'r', 's']
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ r ->
                                    xml_take_default []
                                      (xml_do ['t', 'r', 's']
(xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                                      (\ s ->
xml_take (xml2trs_termination_proof xml2name)
  (\ p -> xml_return (Uncurry i (r ++ s) p)))))))
                          (xml_or
                            (xml_do
                              ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x',
                                't', 'C', 'l', 'o', 's', 'u', 'r', 'e']
                              (xml_take (flat_contexts xml2name)
                                (\ i ->
                                  xml_take
                                    (xml_do ['t', 'r', 's']
                                      (xml_take (rules xml2name)
(\ xa -> xml_return (id xa))))
                                    (\ r ->
                                      xml_take_default []
(xml_do ['t', 'r', 's']
  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
(\ s ->
  xml_take (xml2trs_termination_proof xml2name)
    (\ p -> xml_return (Fcc i (r ++ s) p)))))))
                            (xml_or
                              (xml_do
                                ['s', 'w', 'i', 't', 'c', 'h', 'I', 'n', 'n',
                                  'e', 'r', 'm', 'o', 's', 't']
                                (xml_take (wcr_proof xml2name)
                                  (\ a ->
                                    xml_take
                                      (xml2trs_termination_proof xml2name)
                                      (\ b ->
xml_return (Switch_Innermost a b)))))
                              (xml_or
                                (xml_do
                                  ['p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g',
                                    'A', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F',
                                    'i', 'l', 't', 'e', 'r']
                                  (xml_take (afs xml2name)
                                    (\ a ->
                                      xml_take
(xml2trs_termination_proof xml2name) (\ b -> xml_return (Permuting_AFS a b)))))
                                (xml_or
                                  (xml_do
                                    ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't',
                                      'i', 'o', 'n', 'A', 's', 's', 'u', 'm',
                                      'p', 't', 'i', 'o', 'n']
                                    (xml_take (xml2inn_trs_assm xml2name)
                                      (\ xa -> xml_return (Assume_SN xa []))))
                                  (xml_or
                                    (xml_do
                                      ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e',
'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'A', 's', 's', 'u', 'm',
'p', 't', 'i', 'o', 'n']
                                      (xml_take
(xml_do ['t', 'r', 's', 'I', 'n', 'p', 'u', 't']
  (xml_take
    (xml_do ['t', 'r', 's']
      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
    (\ r ->
      xml_take_default []
        (xml_do
          ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'R', 'u', 'l', 'e', 's']
          (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
        (\ rw -> xml_return (Assume_SN (default_nfs_trs, ([], (r, rw))) [])))))
xml_return))
                                    (xml_do
                                      ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P',
'r', 'o', 'o', 'f']
                                      (xml_take
(xml_text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
(\ _ ->
  xml_take (xml2inn_trs_assm xml2name)
    (\ b ->
      xml_take_many_sub [] zero_nat Infinity_enat (\ xa -> Inr (fst xa))
        (\ _ -> xml_return (Assume_SN b []))))))))))))))))))))))
    x;

rule_labeling_function ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        [((Term (Lab a b) [Prelude.Char],
                            Term (Lab a b) [Prelude.Char]),
                           Nat)];
rule_labeling_function xml2name =
  xml_do
    ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g', 'F', 'u', 'n',
      'c', 't', 'i', 'o', 'n']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g', 'F', 'u',
          'n', 'c', 't', 'i', 'o', 'n', 'E', 'n', 't', 'r', 'y']
        (xml_take (rule xml2name)
          (\ a ->
            xml_take (xml_nat ['l', 'a', 'b', 'e', 'l'])
              (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (id a)));

add_source_lab_proof ::
  forall a b c.
    Cr_proof a b c ->
      Maybe Nat -> Trs_termination_proof a b c -> Cr_proof a b c;
add_source_lab_proof (Rule_Labeling rl js uu) uv prf =
  Rule_Labeling rl js (Just prf);
add_source_lab_proof (Rule_Labeling_Conv rl cs uw) (Just n) prf =
  Rule_Labeling_Conv rl cs (Just (n, prf));

xml2cr_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Cr_proof a b [Prelude.Char]);
xml2cr_proof xml2name x =
  xml_do ['c', 'r', 'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_do ['w', 'c', 'r', 'A', 'n', 'd', 'S', 'N']
          (xml_take (wcr_proof xml2name)
            (\ a ->
              xml_take (xml2trs_termination_proof xml2name)
                (\ b -> xml_return (SN_WCR a b)))))
        (xml_or
          (xml_leaf ['o', 'r', 't', 'h', 'o', 'g', 'o', 'n', 'a', 'l']
            Weakly_Orthogonal)
          (xml_or
            (xml_change
              (xml_nat
                ['s', 't', 'r', 'o', 'n', 'g', 'l', 'y', 'C', 'l', 'o', 's',
                  'e', 'd'])
              (xml_return . Strongly_Closed))
            (xml_or
              (xml_change
                (xml_do
                  ['p', 'a', 'r', 'a', 'l', 'l', 'e', 'l', 'C', 'l', 'o', 's',
                    'e', 'd']
                  nat_or_empty)
                (xml_return . Parallel_Closed))
              (xml_or
                (xml_do
                  ['c', 'r', 'i', 't', 'i', 'c', 'a', 'l', 'P', 'a', 'i', 'r',
                    'C', 'l', 'o', 's', 'i', 'n', 'g', 'S', 'y', 's', 't', 'e',
                    'm']
                  (xml_take
                    (xml_do ['t', 'r', 's']
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ a ->
                      xml_take (xml2trs_termination_proof xml2name)
                        (\ b ->
                          xml_take (xml_nat ['n', 'r', 'S', 't', 'e', 'p', 's'])
                            (\ c ->
                              xml_return
                                (Critical_Pair_Closing_System a b c))))))
                (xml_or
                  (xml_do
                    ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
                    (xml_take (rule_labeling_function xml2name)
                      (\ a ->
                        xml_take (joinable_critical_pairs xml2name)
                          (\ b -> xml_return (Rule_Labeling a b Nothing)))))
                  (xml_or
                    (xml_do
                      ['d', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n', 'g', 'D',
                        'i', 'a', 'g', 'r', 'a', 'm', 's']
                      (xml_take_optional (xml2trs_termination_proof xml2name)
                        (\ a ->
                          xml_take
                            (xml_or
                              (xml_do
                                ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l',
                                  'i', 'n', 'g']
                                (xml_take (rule_labeling_function xml2name)
                                  (\ rl ->
                                    xml_take (joinable_critical_pairs xml2name)
                                      (\ js ->
(case a of {
  Nothing -> xml_return (Rule_Labeling rl js Nothing);
  Just prf ->
    xml_return (add_source_lab_proof (Rule_Labeling rl js Nothing) Nothing prf);
})))))
                              (xml_do
                                ['r', 'u', 'l', 'e', 'L', 'a', 'b', 'e', 'l',
                                  'i', 'n', 'g', 'C', 'o', 'n', 'v']
                                (xml_take (rule_labeling_function xml2name)
                                  (\ rl ->
                                    xml_take
                                      (convertible_critical_peaks xml2name)
                                      (\ cs ->
(case a of {
  Nothing -> xml_return (Rule_Labeling_Conv rl cs Nothing);
  Just prf ->
    xml_take (xml_nat ['n', 'r', 'S', 't', 'e', 'p', 's'])
      (\ n ->
        xml_return
          (add_source_lab_proof (Rule_Labeling_Conv rl cs Nothing) (Just n)
            prf));
}))))))
                            xml_return)))
                    (xml_do
                      ['r', 'e', 'd', 'u', 'n', 'd', 'a', 'n', 't', 'R', 'u',
                        'l', 'e', 's']
                      (xml_take
                        (xml_do ['t', 'r', 's']
                          (xml_take (rules xml2name)
                            (\ xa -> xml_return (id xa))))
                        (\ trs ->
                          xml_take (xml_nat ['n', 'r', 'S', 't', 'e', 'p', 's'])
                            (\ n ->
                              xml_take_default []
                                (xml_do
                                  ['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o',
                                    'n', 's']
                                  (xml_take_many_sub [] zero_nat Infinity_enat
                                    (conversion xml2name)
                                    (\ a -> xml_return (map snd a))))
                                (\ cs ->
                                  xml_take (xml2cr_proof xml2name)
                                    (\ prf ->
                                      xml_return
(Redundant_Rules trs n cs prf))))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2eq_proof ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) (Eq_proof a [Prelude.Char]);
xml2eq_proof xml2name x =
  xml_or
    (xml_do ['r', 'e', 'f', 'l']
      (xml_take (term xml2name) (\ xa -> xml_return (Refl xa))))
    (xml_or
      (xml_do ['s', 'y', 'm']
        (xml_take (xml2eq_proof xml2name) (\ xa -> xml_return (Sym xa))))
      (xml_or
        (xml_do ['t', 'r', 'a', 'n', 's']
          (xml_take (xml2eq_proof xml2name)
            (\ a ->
              xml_take (xml2eq_proof xml2name)
                (\ b -> xml_return (Trans a b)))))
        (xml_or
          (xml_do ['a', 's', 's', 'm']
            (xml_take (rule xml2name)
              (\ a ->
                xml_take (substa xml2name)
                  (\ b -> xml_return (Assm a (mk_subst Var b))))))
          (xml_do ['c', 'o', 'n', 'g']
            (xml_take xml2name
              (\ a ->
                xml_take_many_sub [] zero_nat Infinity_enat
                  (xml2eq_proof xml2name) (\ b -> xml_return (Cong a b))))))))
    x;

mk_cpx ::
  forall a b c d e.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    ([Term (Lab b c) [Prelude.Char]],
                      ([(Term (Lab b c) [Prelude.Char],
                          Term (Lab b c) [Prelude.Char])],
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          (d, e)))) ->
                      (a, (d, e));
mk_cpx i (q, (s, (w, (cm, cc)))) = (mkc i False q s w, (cm, cc));

mk_tp ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      (Bool, ([Term b c], ([(Term b c, Term b c)], [(Term b c, Term b c)]))) ->
        a;
mk_tp i (nfs, (q, (r, rw))) = mkc i nfs q r rw;

formula :: forall a. (a -> Bool) -> Formula a -> Bool;
formula atom (Disjunction phi_s) = all (formula atom) phi_s;
formula atom (Conjunction phi_s) = all (formula atom) phi_s;
formula atom (NegAtom a) = atom a;
formula atom (Atom a) = atom a;

in_vars_formula :: forall a b. (Eq a) => a -> Formula (Term b a) -> Bool;
in_vars_formula x (Atom a) = membera (vars_term_list a) x;
in_vars_formula x (NegAtom a) = membera (vars_term_list a) x;
in_vars_formula x (Conjunction phi_s) = any (in_vars_formula x) phi_s;
in_vars_formula x (Disjunction phi_s) = any (in_vars_formula x) phi_s;

trivial_checker :: forall a. (Eq a) => [Formula a] -> Bool;
trivial_checker lits = let {
                         (asa, nas) = partition is_Atom lits;
                         pos = map get_Atom asa;
                         neg = map get_Atom nas;
                       } in any (membera neg) pos;

trivial_formula :: forall a. Formula a -> Bool;
trivial_formula (Disjunction phi_s) = any trivial_formula phi_s;
trivial_formula (Conjunction phi_s) = all trivial_formula phi_s;
trivial_formula (Atom v) = False;
trivial_formula (NegAtom v) = False;

find_max_nat :: Nat -> (Nat -> Bool) -> Nat;
find_max_nat n uu =
  (if equal_nat n zero_nat then zero_nat
    else (if uu (minus_nat n one_nat) then minus_nat n one_nat
           else find_max_nat (minus_nat n one_nat) uu));

rbt_lookup :: forall a b. (a -> a -> Bool) -> Rbta a b -> a -> Maybe b;
rbt_lookup less (Branch uu l x y r) k =
  (if less k x then rbt_lookup less l k
    else (if less x k then rbt_lookup less r k else Just y));
rbt_lookup less Emptya k = Nothing;

idx_of_tr ::
  forall a.
    (Linorder a) => a -> ((Array.Array a, Nat),
                           ((Array.Array Nat, Nat),
                             (Rbta a Int, (Array.Array (Nat, [a]), Nat)))) ->
                           Nat;
idx_of_tr s v =
  let {
    (_, (aa, (ab, _))) = v;
    x = let {
          (Just i) = rbt_lookup less ab s;
          True = less_eq_int zero_int i;
        } in nat i;
    xa = find_max_nat (as_length aa) (\ j -> less_eq_nat (as_get aa j) x);
  } in xa;

gi_E :: forall a b c d. Gen_g_impl_ext a b c d -> b;
gi_E (Gen_g_impl_ext gi_V gi_E gi_V0 more) = gi_E;

stat_newnode :: () -> ();
stat_newnode = (\ _ -> ());

is_Nil :: forall a. [a] -> Bool;
is_Nil a = (case a of {
             [] -> True;
             _ : _ -> False;
           });

as_push :: forall a. (Array.Array a, Nat) -> a -> (Array.Array a, Nat);
as_push s x =
  let {
    a = s;
    (aa, n) = a;
    ab = (if equal_nat n (array_length aa)
           then array_grow aa
                  (max (nat_of_integer (4 :: Integer))
                    (times_nat (nat_of_integer (2 :: Integer)) n))
                  x
           else aa);
    ac = array_set ab n x;
  } in (ac, plus_nat n one_nat);

push_code ::
  forall a b.
    (Compare_order a) => Gen_g_impl_ext (a -> Bool) (a -> [a]) [a] b ->
                           a -> ((Array.Array a, Nat),
                                  ((Array.Array Nat, Nat),
                                    (Rbta a Int,
                                      (Array.Array (Nat, [a]), Nat)))) ->
                                  ((Array.Array a, Nat),
                                    ((Array.Array Nat, Nat),
                                      (Rbta a Int,
(Array.Array (Nat, [a]), Nat))));
push_code g_impl =
  (\ x (xa, (xb, (xc, xd))) ->
    let {
      _ = stat_newnode ();
      xf = as_length xa;
      xg = as_push xa x;
      xh = as_push xb xf;
      xi = rbt_insert x (int_of_nat xf) xc;
      xj = (if is_Nil (gi_E g_impl x) then xd
             else as_push xd (xf, gi_E g_impl x));
    } in (xg, (xh, (xi, xj))));

nFQ_subset_NF_rulesc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
nFQ_subset_NF_rulesc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = nFQ_subset_NF_rules;

is_QNFc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Term b c -> Bool;
is_QNFc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = is_QNF;

rulese :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulese
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules;

icap_impl_dpp ::
  forall a b.
    (Eq b) => Dpp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_dpp i d =
  let {
    qr = nFQ_subset_NF_rulesc i d;
    qnf = is_QNFc i d;
    r = rulese i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s -> let {
                 a = ceta_set_of (concatMap vars_term_list s);
               } in ic s a);

as_set :: forall a. (Array.Array a, Nat) -> Nat -> a -> (Array.Array a, Nat);
as_set s i x = let {
                 a = s;
                 (aa, b) = a;
               } in (array_set aa i x, b);

the_int :: Val -> Int;
the_int val = let {
                (Int x1) = val;
              } in x1;

i :: Sig -> [Val] -> Val;
i Less [x, y] = Boola (less_int (the_int x) (the_int y));
i Lesseq [x, y] = Boola (less_eq_int (the_int x) (the_int y));
i Equals [x, y] = Boola (equal_int (the_int x) (the_int y));
i (Sum n) xs = Int (sum_list (map the_int xs));
i (Const x) [] = Int x;
i (Mult n) xs = Int (prod_list (map the_int xs));
i Lesseq [] = error "undefined";
i Lesseq [v] = error "undefined";
i Lesseq (v : vb : vd : ve) = error "undefined";
i (Const v) (va : vb) = error "undefined";
i Equals [] = error "undefined";
i Equals [v] = error "undefined";
i Equals (v : vb : vd : ve) = error "undefined";
i Less [] = error "undefined";
i Less [v] = error "undefined";
i Less (v : vb : vd : ve) = error "undefined";

shows_kbo_repr ::
  forall a.
    (Showa a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                   [Prelude.Char] -> [Prelude.Char];
shows_kbo_repr (prs, w0) =
  ((((((((((((((((((((shows_prec_list zero_nat
                        ['K', 'B', 'O', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h',
                          'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                          ' ', 'p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e',
                          ' ', 'a', 'n', 'd', ' ', 'w', 'e', 'i', 'g', 'h', 't',
                          ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n'] .
                       shows_nl) .
                      foldr (\ (a, b) ->
                              let {
                                (f, n) = a;
                              } in (\ (pr, (_, _)) ->
                                     (((((shows_prec_list zero_nat
    ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', '('] .
   shows_prec zero_nat f) .
  shows_prec_list zero_nat ['[']) .
 shows_prec_nat zero_nat n) .
shows_prec_list zero_nat [']', ')', ' ', '=', ' ']) .
                                       shows_prec_nat zero_nat pr) .
                                       shows_nl)
                                b)
                        prs) .
                     shows_nl) .
                    shows_prec_list zero_nat
                      ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', '(',
                        '_', ')', ' ', '=', ' ', '0']) .
                   shows_nl) .
                  shows_prec_list zero_nat
                    ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                      'o', 'w', 'i', 'n', 'g', ' ', 'w', 'e', 'i', 'g', 'h',
                      't']) .
                 shows_nl) .
                foldr (\ (a, b) ->
                        let {
                          (f, n) = a;
                        } in (\ (_, (w, _)) ->
                               (((((shows_prec_list zero_nat
                                      ['w', 'e', 'i', 'g', 'h', 't', '('] .
                                     shows_prec zero_nat f) .
                                    shows_prec_list zero_nat ['[']) .
                                   shows_prec_nat zero_nat n) .
                                  shows_prec_list zero_nat
                                    [']', ')', ' ', '=', ' ']) .
                                 shows_prec_nat zero_nat w) .
                                 shows_nl)
                          b)
                  prs) .
               shows_nl) .
              shows_prec_list zero_nat
                ['w', 'e', 'i', 'g', 'h', 't', '(', '_', ')', ' ', '=', ' ']) .
             shows_prec_nat zero_nat (suc w0)) .
            shows_nl) .
           shows_prec_list zero_nat ['w', '0', ' ', '=', ' ']) .
          shows_prec_nat zero_nat w0) .
         shows_nl) .
        shows_prec_list zero_nat
          ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w',
            'i', 'n', 'g', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', ' ', 'c',
            'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', ' ', 'f', 'u',
            'n', 'c', 't', 'i', 'o', 'n', 's']) .
       shows_nl) .
      foldr (\ (a, b) ->
              let {
                (f, n) = a;
              } in (\ (_, (_, scf)) ->
                     (((((shows_prec_list zero_nat ['s', 'c', 'f', '('] .
                           shows_prec zero_nat f) .
                          shows_prec_list zero_nat ['[']) .
                         shows_prec_nat zero_nat n) .
                        shows_prec_list zero_nat [']', ')', ' ', '=', ' ']) .
                       (if is_none scf
                         then shows_prec_list zero_nat ['a', 'l', 'l', ' ', '1']
                         else shows_prec_list zero_nat (the scf))) .
                       shows_nl)
                b)
        prs) .
     shows_nl) .
    shows_prec_list zero_nat
      ['s', 'c', 'f', '(', '_', ')', ' ', '=', ' ', 'a', 'l', 'l', ' ', '1']) .
    shows_nl;

roots_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
roots_of_cm (Derivational_Complexity f) = f;
roots_of_cm (Runtime_Complexity c d) = d;

sym_collect :: forall a b. (Term a b -> Bool) -> Term a b -> [a];
sym_collect p (Var x) = [];
sym_collect p (Fun f ts) =
  (if p (Fun f ts) then [f] else []) ++ concatMap (sym_collect p) ts;

upper_triangular :: forall a. (Zero a, Eq a) => Mat a -> Bool;
upper_triangular a =
  all_interval_nat
    (\ i -> all_interval_nat (\ j -> mat_index a (i, j) == zerob) zero_nat i)
    zero_nat (mat_dim_row a);

pat_of ::
  forall a.
    Dp_proof_step a ->
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])));
pat_of (OC1 rl uu) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC2 rl uv uw ux uy uz) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC2p rl va vb vc vd ve) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC3 rl vf vg vh vi) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC3p rl vj vk vl vm) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OCDP1 p vn) = p;
pat_of (OCDP2 p vo) = p;
pat_of (WPEQ p vp) = p;
pat_of (Lift p vq) = p;
pat_of (DPOC1_1 p vr vs vt vu) = p;
pat_of (DPOC1_2 p vv vw vx vy vz) = p;
pat_of (DPOC2 p wa wb wc wd) = p;
pat_of (DPOC3_1 p we wf wg wh) = p;
pat_of (DPOC3_2 p wi wj wk wl wm) = p;
pat_of (DPDP1_1 p wn wo wp wq) = p;
pat_of (DPDP1_2 p wr ws wt wu) = p;
pat_of (DPDP2_1 p wv ww wx wy) = p;
pat_of (DPDP2_2 p wz xa xb xc) = p;

power :: forall a. (Power a) => a -> Nat -> a;
power a n =
  (if equal_nat n zero_nat then onea
    else times a (power a (minus_nat n one_nat)));

mk_rtrancl_list_main ::
  forall a. (a -> a -> Bool) -> (a -> [a]) -> [a] -> [a] -> [a];
mk_rtrancl_list_main subsumes r todo fin =
  (case todo of {
    [] -> fin;
    a : tod ->
      (if any (\ b -> subsumes b a) fin
        then mk_rtrancl_list_main subsumes r tod fin
        else mk_rtrancl_list_main subsumes r (r a ++ tod) (a : fin));
  });

mk_rtrancl_list :: forall a. (a -> a -> Bool) -> (a -> [a]) -> [a] -> [a];
mk_rtrancl_list subsumes r init = mk_rtrancl_list_main subsumes r init [];

ins_dj_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
ins_dj_rm_basic_ops x s = insert x () s;

mk_rtrancl_set_main ::
  forall a. (Compare_order a) => (a -> [a]) -> [a] -> Rbt a () -> Rbt a ();
mk_rtrancl_set_main r todo fin =
  (case todo of {
    [] -> fin;
    a : tod ->
      (if memb_rm_basic_ops a fin then mk_rtrancl_set_main r tod fin
        else mk_rtrancl_set_main r (r a ++ tod) (ins_dj_rm_basic_ops a fin));
  });

mk_rtrancl_set :: forall a. (Compare_order a) => (a -> [a]) -> [a] -> Rbt a ();
mk_rtrancl_set r init = mk_rtrancl_set_main r init (empty_rm_basic_ops ());

rai_list_nil :: Rai_list -> Bool;
rai_list_nil xa = (case rep_rai_list xa of {
                    [] -> True;
                    _ : _ -> False;
                  });

roots_of_rai_main ::
  Poly Rat ->
    Root_info ->
      (Rat -> Rat -> Nat) ->
        [(Rat, Rat)] ->
          [Maybe (Root_info, (Poly Rat, (Rat, Rat)))] ->
            [Maybe (Root_info, (Poly Rat, (Rat, Rat)))];
roots_of_rai_main p ri cr lrs rais =
  (case lrs of {
    [] -> rais;
    (l, r) : lrsa ->
      let {
        c = cr l r;
      } in (if equal_nat c zero_nat then roots_of_rai_main p ri cr lrsa rais
             else (if equal_nat c one_nat
                    then roots_of_rai_main p ri cr lrsa
                           (mk_rai_intern ri p l r : rais)
                    else let {
                           m = divide_rat (plus_rat l r)
                                 (of_int (Int_of_integer (2 :: Integer)));
                         } in roots_of_rai_main p ri cr ((m, r) : (l, m) : lrsa)
                                rais));
  });

roots_of_rai_intern_monic_irr ::
  Poly Rat -> [Maybe (Root_info, (Poly Rat, (Rat, Rat)))];
roots_of_rai_intern_monic_irr p =
  (if equal_nat (degreea p) one_nat
    then [of_rat_rai_fun (uminus_rat (case coeffs p of {
                                       [] -> zero_rat;
                                       x : _ -> x;
                                     }))]
    else let {
           ri = count_roots_interval_rat p;
           cr = l_r ri;
         } in map rai_normalize_bounds
                (roots_of_rai_main p ri cr [root_bounds p] []));

roots_of_rai_intern :: Poly Rat -> [Maybe (Root_info, (Poly Rat, (Rat, Rat)))];
roots_of_rai_intern p =
  concatMap roots_of_rai_intern_monic_irr (factors_of_rat_poly p);

roots_of_rai_list :: Poly Rat -> Rai_list;
roots_of_rai_list xa = Abs_rai_list (roots_of_rai_intern xa);

rai_list_convert :: Rai_list -> [Real_alg_intern];
rai_list_convert xs =
  (if rai_list_nil xs then []
    else rai_list_hd xs : rai_list_convert (rai_list_tl xs));

roots_of_rai_impl :: Poly Rat -> [Real_alg_intern];
roots_of_rai_impl p = rai_list_convert (roots_of_rai_list p);

roots_of_rai :: Poly Rat -> [Real_alg_intern];
roots_of_rai p = roots_of_rai_impl p;

eval_polya ::
  forall a b. (Zero a, Comm_semiring_1 b) => (a -> b) -> Poly a -> b -> b;
eval_polya h p x = fold_coeffs (\ a b -> plus (h a) (times x b)) p zerob;

eq_rules_no_left_vara :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> Bool;
eq_rules_no_left_vara
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = eq_rules_no_left_var;

eq_rules_map ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
eq_rules_map
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = eq_rules_map;

tcapRM_ac_dpp ::
  forall a b c.
    (Eq b, Eq c) => Ac_dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
tcapRM_ac_dpp i dpp = tcapRM (eq_rules_no_left_vara i dpp) (eq_rules_map i dpp);

subst_compose_impl ::
  forall a b.
    (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> [(a, Term b a)];
subst_compose_impl sigma tau =
  let {
    sigmaa = mk_subst_domain sigma;
    taua = mk_subst_domain tau;
    d_sigma = map fst sigmaa;
  } in map (\ (x, t) -> (x, subst_apply_term t (mk_subst Var taua))) sigmaa ++
         filter (\ (x, _) -> not (membera d_sigma x)) taua;

commutes_impl ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> Bool;
commutes_impl sigma mu =
  subst_eq (subst_compose_impl sigma mu) (subst_compose_impl mu sigma);

mk_subst_case ::
  forall a b.
    (Eq a,
      Eq b) => [a] -> (a -> Term b a) -> [(a, Term b a)] -> [(a, Term b a)];
mk_subst_case xs sigma tau =
  subst_compose_impl (map (\ x -> (x, sigma x)) xs) tau;

ta_matcha ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Eq b, Ceq c,
      Ccompare c) => Ta_ext a b () -> Set a -> Term b c -> Set [(c, a)];
ta_matcha ta q t = ta_match ta q t q;

adapt_vars :: forall a b c. Term a b -> Term a c;
adapt_vars (Fun f ts) = Fun f (map adapt_vars ts);

ta_member ::
  forall a b c.
    (Ccompare a, Eq a, Cenum c, Ceq c, Ccompare c, Eq c,
      Set_impl c) => Term a b -> Ta_ext c a () -> Bool;
ta_member t ta =
  ground t &&
    not (less_eq_set (inf_set (ta_final ta) (ta_res ta (adapt_vars t)))
          bot_set);

rhs_eps_cl_memo ::
  forall a b c.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Set_impl b, Ccompare c,
      Eq c) => (a -> Set b) -> Set (Ta_rule a c) -> Set b;
rhs_eps_cl_memo memo rules = sup_seta (image (memo . r_rhs) rules);

list_intera :: forall a. (Ceq a, Ccompare a, Set_impl a) => [Set a] -> Set a;
list_intera [] = top_set;
list_intera [x] = x;
list_intera (x : v : va) = inf_set x (list_intera (v : va));

ps_states_cons_impl ::
  forall a b c d e.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Set_impl b, Ceq c,
      Ccompare c, Ccompare d,
      Eq d) => (a -> Set b) ->
                 Set (c, (Nat, Set (Ta_rule a d))) ->
                   e -> Set (Set a) -> Set (Set b);
ps_states_cons_impl meps parts rules q =
  let {
    lhs_nth_in_Q =
      (\ (n, rs) ->
        map (\ i ->
              minus_set
                (image
                  (\ p -> filtera (\ r -> member (nth (r_lhs_states r) i) p) rs)
                  q)
                (inserta (set_empty (of_phantom set_impl_ta_rule))
                  (set_empty (of_phantom set_impl_set))))
          (upt zero_nat n));
  } in sup_seta
         (image
           (\ (_, nrs) ->
             minus_set
               (image (\ rs -> rhs_eps_cl_memo meps (list_intera rs))
                 (listset (lhs_nth_in_Q nrs)))
               (inserta bot_set (set_empty (of_phantom set_impl_set))))
           parts);

ps_states_nil_impl ::
  forall a b c.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Set_impl b, Ceq c, Ccompare c, Eq c,
      Set_impl c) => (a -> Set b) -> Set (Ta_rule a c) -> Set (Set b);
ps_states_nil_impl meps rules =
  let {
    rsz = filtera (\ r -> null (r_lhs_states r)) rules;
  } in image (\ f -> rhs_eps_cl_memo meps (filtera (\ r -> r_root r == f) rsz))
         (image r_root rsz);

ps_rules_cons_impl ::
  forall a b c d.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Ccompare c,
      Eq c) => (a -> Set a) ->
                 Set (b, (Nat, Set (Ta_rule a c))) ->
                   d -> Set (Set a) -> Set (Ta_rule (Set a) b);
ps_rules_cons_impl meps parts rules q =
  let {
    lhs_nth =
      (\ (n, rs) ->
        map (\ i ->
              filtera
                (\ x ->
                  not (set_eq (snd x)
                        (set_empty (of_phantom set_impl_ta_rule))))
                (image
                  (\ p ->
                    (p, filtera (\ r -> member (nth (r_lhs_states r) i) p) rs))
                  q))
          (upt zero_nat n));
  } in sup_seta
         (image
           (\ (f, nrs) ->
             filtera (\ r -> not (is_empty (r_rhs r)))
               (image
                 (\ rs ->
                   TA_rule f (map fst rs)
                     (rhs_eps_cl_memo meps (list_intera (map snd rs))))
                 (listset (lhs_nth nrs))))
           parts);

ps_rules_nil_impl ::
  forall a b c.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b,
      Set_impl b, Ceq c, Ccompare c, Eq c,
      Set_impl c) => (a -> Set b) ->
                       Set (Ta_rule a c) -> Set (Ta_rule (Set b) c);
ps_rules_nil_impl meps rules =
  let {
    rsz = filtera (\ r -> null (r_lhs_states r)) rules;
  } in image (\ f ->
               TA_rule f []
                 (rhs_eps_cl_memo meps (filtera (\ r -> r_root r == f) rsz)))
         (image r_root rsz);

memo_list_rtrancl_set ::
  forall a. (Ceq a, Ccompare a, Eq a, Set_impl a) => [(a, a)] -> a -> Set a;
memo_list_rtrancl_set r =
  let {
    tr = rtrancl_list_impl r;
    rm = map_of (map (\ a -> (a, set (tr [a]))) ((remdups . map fst) r));
  } in (\ a -> (case rm a of {
                 Nothing -> inserta a bot_set;
                 Just asa -> asa;
               }));

memo_rtrancl ::
  forall a. (Ceq a, Ccompare a, Eq a, Set_impl a) => Set (a, a) -> a -> Set a;
memo_rtrancl (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "memo_rtrancl RBT_set: ccompare = None"
        (\ _ -> memo_rtrancl (RBT_set rbt));
    Just _ -> memo_list_rtrancl_set (keysa rbt);
  });
memo_rtrancl (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "memo_rtrancl DList_set: ceq = None"
        (\ _ -> memo_rtrancl (DList_set dxs));
    Just _ -> memo_list_rtrancl_set (list_of_dlist dxs);
  });
memo_rtrancl (Set_Monad xs) = memo_list_rtrancl_set xs;

sym_parts ::
  forall a b.
    (Ccompare a, Eq a, Ceq b, Ccompare b, Eq b,
      Set_impl b) => Set (Ta_rule a b) -> Set (b, (Nat, Set (Ta_rule a b)));
sym_parts rules =
  image (\ (f, n) -> (f, (n, filtera (\ r -> r_sym r == (f, n)) rules)))
    (image r_sym rules);

ps_ta ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Set_impl b) => Ta_ext a b () -> Ta_ext (Set a) b ();
ps_ta ta =
  let {
    eps = ta_eps ta;
    rules = ta_rules ta;
  } in (if finite eps && finite rules
         then let {
                meps = memo_rtrancl eps;
                parts =
                  sym_parts
                    (filtera (\ r -> not (null (r_lhs_states r))) rules);
                qinit = ps_states_nil_impl meps rules;
                q = fst (while (\ (qold, qnew) -> not (less_eq_set qnew qold))
                          (\ (_, qnew) ->
                            (qnew,
                              sup_set qinit
                                (ps_states_cons_impl meps parts rules qnew)))
                          (set_empty (of_phantom set_impl_set), qinit));
                final =
                  filtera (\ qa -> not (is_empty (inf_set qa (ta_final ta)))) q;
                rulesa =
                  sup_set (ps_rules_nil_impl meps rules)
                    (ps_rules_cons_impl meps parts rules q);
              } in Ta_ext final rulesa
                     (set_empty
                       (of_phantom
                         (set_impl_prod :: Phantom (Set a, Set a) Set_impla)))
                     ()
         else ps_ta ta);

add_funas_args_term :: forall a b. Term a b -> [(a, Nat)] -> [(a, Nat)];
add_funas_args_term t fs = foldr add_funas_term (args t) fs;

add_funas_args_rule ::
  forall a b. (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
add_funas_args_rule r fs =
  add_funas_args_term (fst r) (add_funas_args_term (snd r) fs);

funas_args_trs_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
funas_args_trs_list trs = foldr add_funas_args_rule trs [];

rwc :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwc (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
      rules_map delete_R_Rw split_rules mk nfs more)
  = rw;

rc :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rc (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
     delete_R_Rw split_rules mk nfs more)
  = r;

uncurry_of_sig_list ::
  forall a.
    a -> [((a, Nat), [a])] ->
           (a -> Nat -> [a]) ->
             [(Term a [Prelude.Char], Term a [Prelude.Char])];
uncurry_of_sig_list a sml sm =
  concatMap
    (\ (b, c) ->
      let {
        (f, n) = b;
      } in (\ _ ->
             let {
               g = get_symbol sm f n;
             } in map (\ i ->
                        (Fun a [generate_f_xs (g i) (plus_nat n i),
                                 Var (generate_var (plus_nat n i))],
                          generate_f_xs (g (suc i)) (plus_nat n (suc i))))
                    (upt zero_nat (aarity sm f n)))
        c)
    sml;

sig_list_to_sig_map ::
  forall a.
    (Eq a) => a -> [((a, Nat), [a])] ->
                     ([((a, Nat), [a])] -> a -> Nat -> a) -> a -> Nat -> [a];
sig_list_to_sig_map a sml fmap =
  let {
    fm = fmap sml;
  } in (\ f n -> (case map_of sml (f, n) of {
                   Nothing -> [fm f n];
                   Just xs -> (if null xs then [fm f n] else xs);
                 }));

uncurry_eta_split ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             ([(Term a b, Term a b)], [(Term a b, Term a b)]);
uncurry_eta_split eboth rtest =
  let {
    test =
      (\ (l, r) ->
        less_nat zero_nat (size_list (args l)) &&
          less_nat zero_nat (size_list (args r)) &&
            any (eq_rule_mod_vars (hda (args l), hda (args r))) rtest);
  } in partition test eboth;

insert_vars_rule :: forall a b. (Eq b) => (Term a b, Term a b) -> [b] -> [b];
insert_vars_rule r xs = insert_vars_term (fst r) (insert_vars_term (snd r) xs);

eta_closed_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => a -> (a -> Nat -> [a]) ->
                         [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
eta_closed_rules a sm ra r =
  catch_errora
    (forallM
      (\ (l, raa) ->
        (case aarity_term a sm l of {
          Nothing -> Inr ();
          Just ab ->
            (if equal_nat ab zero_nat then Inr ()
              else check (any (\ (lll, rrr) ->
                                (case (lll, rrr) of {
                                  (Var _, _) -> False;
                                  (Fun _ [], _) -> False;
                                  (Fun _ [_], _) -> False;
                                  (Fun _ [_, Var _], Var _) -> False;
                                  (Fun _ [_, Var _], Fun _ []) -> False;
                                  (Fun _ [_, Var _], Fun _ [_]) -> False;
                                  (Fun f [ll, Var x], Fun g [rr, Var y]) ->
                                    f == a &&
                                      g == a &&
x == y &&
  not (membera (insert_vars_rule (ll, rr) []) x) &&
    instance_rule (l, raa) (ll, rr);
                                  (Fun _ [_, Var _], Fun _ (_ : Var _ : _ : _))
                                    -> False;
                                  (Fun _ [_, Var _], Fun _ (_ : Fun _ _ : _)) ->
                                    False;
                                  (Fun _ (_ : Var _ : _ : _), _) -> False;
                                  (Fun _ (_ : Fun _ _ : _), _) -> False;
                                }))
                           r)
                     ((shows_prec_list zero_nat
                         ['e', 't', 'a', ' ', 'e', 'x', 'p', 'a', 'n', 's', 'i',
                           'o', 'n', ' ', 'o', 'f', ' '] .
                        shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                          [' ', '-', '>', ' '] (l, raa)) .
                       shows_prec_list zero_nat
                         [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']));
        }))
      ra)
    (\ x -> Inl (snd x));

uncurry_rules ::
  forall a b.
    (Eq a) => a -> (a -> Nat -> [a]) ->
                     [(Term a b, Term a b)] -> [(Term a b, Term a b)];
uncurry_rules a sm =
  map (\ (l, r) -> (uncurry_term a sm l, uncurry_term a sm r));

check_CS_subseteq ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Sum (Term a b, Term a b) ();
check_CS_subseteq r s =
  catch_errora
    (forallM (\ (l, ra) -> check (any (instance_rule (l, ra)) s) (l, ra)) r)
    (\ x -> Inl (snd x));

uncurry_tt ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_tt i info r tp =
  let {
    (a, (sml, (u, eb))) = info;
    ra = rc i tp;
    rw = rwc i tp;
    (e, ew) = uncurry_eta_split eb ra;
    r_eta = e ++ ra;
    rw_eta = ew ++ rw;
    rb_eta = r_eta ++ rw_eta;
    fmap = (\ _ f _ -> f);
    sm = sig_list_to_sig_map a sml fmap;
    uR = uncurry_rules a sm r_eta;
    uRw = uncurry_rules a sm rw_eta;
  } in (case let {
               s = uncurry_of_sig_list a sml sm;
             } in bindb (catch_errora
                          (forallM
                            (\ (l, _) ->
                              check (hvf_term a l)
                                (shows_prec_list zero_nat
                                   ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i',
                                     'a', 'b', 'l', 'e', ' ', 'i', 'n', ' ',
                                     'l', 'h', 's', ' '] .
                                  shows_term (shows_prec zero_nat)
                                    (shows_prec_list zero_nat) l .
                                    shows_prec_list zero_nat
                                      [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l',
'o', 'w', 'e', 'd']))
                            r_eta)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (catch_errora
                              (forallM
                                (\ (l, _) ->
                                  check (hvf_term a l)
                                    (shows_prec_list zero_nat
                                       ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r',
 'i', 'a', 'b', 'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                                      shows_term (shows_prec zero_nat)
(shows_prec_list zero_nat) l .
shows_prec_list zero_nat
  [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                                rw_eta)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          bindb (eta_closed_rules a sm r_eta r_eta)
                            (\ _ ->
                              bindb (eta_closed_rules a sm rb_eta rb_eta)
                                (\ _ ->
                                  bindb (catch_errora
  (forallM
    (\ (l, rb) ->
      check (not (is_Var l))
        (shows_prec_list zero_nat
           ['l', 'h', 's', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
             'b', 'e', ' ', 'a', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
             ' ', 'i', 'n', ' ', 'r', 'u', 'l', 'e', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
            [' ', '-', '>', ' '] (l, rb)))
    rw_eta)
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora (check_subseteq uR r)
  (\ x ->
    Inl (shows_prec_list zero_nat
           ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l',
             'e', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
            [' ', '-', '>', ' '] x .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
(\ _ ->
  bindb (catch_errora (check_subseteq uRw r)
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u',
                     'l', 'e', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                    [' ', '-', '>', ' '] x .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
    (\ _ ->
      bindb (catch_errora (check_CS_subseteq s u)
              (\ x ->
                Inl (shows_prec_list zero_nat
                       ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l',
                         'e', ' '] .
                      shows_rule (shows_prec zero_nat)
                        (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                        shows_prec_list zero_nat
                          [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                            'g'])))
        (\ _ ->
          catch_errora (check_subseteq u r)
            (\ x ->
              Inl (shows_prec_list zero_nat
                     ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l',
                       'e', ' '] .
                    shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                      [' ', '-', '>', ' '] x .
                      shows_prec_list zero_nat
                        [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g',
                          ' ', 'i', 'n', ' ', 'n', 'e', 'w', ' ', 'T', 'R',
                          'S']))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkc i (nfsb i tp) [] uR (uRw ++ u));
       });

check_prefix_equivalent ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prefix_equivalent rhoa rho n =
  catch_errora
    (bindb
      (check (less_nat n (size_list (snd rhoa)))
        (shows_string
           ['T', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 'f', 'e', 'w',
             'e', 'r', ' ', 't', 'h', 'a', 'n', ' '] .
          shows_prec_nat zero_nat n .
            shows_string
              [' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ', 'i',
                'n', ' '] .
              shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rhoa))
      (\ _ ->
        bindb (check (less_nat n (size_list (snd rho)))
                (shows_string
                   ['T', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 'f', 'e',
                     'w', 'e', 'r', ' ', 't', 'h', 'a', 'n', ' '] .
                  shows_prec_nat zero_nat n .
                    shows_string
                      [' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's',
                        ' ', 'i', 'n', ' '] .
                      shows_crule (shows_prec zero_nat) (shows_prec zero_nat)
                        rho))
          (\ _ ->
            bindb (check (equal_term (fst (fst rhoa)) (fst (fst rho)))
                    (shows_prec_list zero_nat
                      ['L', 'e', 'f', 't', '-', 'h', 'a', 'n', 'd', ' ', 's',
                        'i', 'd', 'e', 's', ' ', 'a', 'r', 'e', ' ', 'd', 'i',
                        'f', 'f', 'e', 'r', 'e', 'n', 't', '.']))
              (\ _ ->
                bindb (catch_errora
                        (forallM
                          (\ i ->
                            check (equal_term (snd (nth (snd rhoa) i))
                                    (snd (nth (snd rho) i)))
                              (shows_string
                                 ['R', 'h', 's', ' ', 'o', 'f', ' ', 'c', 'o',
                                   'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ',
                                   'a', 'r', 'e', ' ', 'd', 'i', 'f', 'f', 'e',
                                   'r', 'e', 'n', 't', ' '] .
                                shows_nl))
                          (upt zero_nat n))
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    catch_errora
                      (forallM
                        (\ i ->
                          check (equal_term (fst (nth (snd rhoa) i))
                                  (fst (nth (snd rho) i)))
                            (shows_string
                               ['L', 'h', 's', ' ', 'o', 'f', ' ', 'c', 'o',
                                 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ',
                                 'a', 'r', 'e', ' ', 'd', 'i', 'f', 'f', 'e',
                                 'r', 'e', 'n', 't', ' '] .
                              shows_nl))
                        (upt zero_nat (suc n)))
                      (\ x -> Inl (snd x)))))))
    (\ x ->
      Inl (shows_string ['R', 'u', 'l', 'e', 's'] .
            shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rhoa .
              shows_string [' ', 'a', 'n', 'd', ' '] .
                shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rho .
                  shows_string [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' '] .
                    shows_prec_nat zero_nat n .
                      shows_string
                        [' ', 'e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 't',
                          '.'] .
                        shows_nl . x));

check_f ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    Nat ->
                      a -> [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                             (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                               Nat -> Ctxt a b) ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_f cr j f crs u =
  catch_errora
    (forallM
      (\ cra ->
        catch_errora
          (forallM
            (\ i ->
              (case u cra i of {
                Hole -> Inr ();
                More g _ _ _ ->
                  (if f == g
                    then catch_errora
                           (bindb
                             (check (equal_nat i j)
                               (shows_string
                                  ['S', 'a', 'm', 'e', ' ', 's', 'y', 'm', 'b',
                                    'o', 'l', ' ', 'o', 'c', 'c', 'u', 'r', 's',
                                    ' ', 'a', 't', ' ', 'd', 'i', 'f', 'f', 'e',
                                    'r', 'e', 'n', 't', ' ', 'l', 'e', 'v', 'e',
                                    'l', 's'] .
                                 shows_nl))
                             (\ _ ->
                               bindb (catch_errora
                                       (forallM
 (\ k ->
   check (equal_ctxt (u cra k) (u cr k))
     (shows_string
        ['C', 'o', 'n', 't', 'e', 'x', 't', 's', ' ', 'a', 'r', 'e', ' ', 'd',
          'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', ' '] .
       shows_nl))
 (upt zero_nat (suc j)))
                                       (\ x -> Inl (snd x)))
                                 (\ _ -> check_prefix_equivalent cra cr j)))
                           (\ x ->
                             Inl (shows_string ['R', 'u', 'l', 'e', 's'] .
                                   shows_crule (shows_prec zero_nat)
                                     (shows_prec zero_nat) cra .
                                     shows_string [' ', 'a', 'n', 'd', ' '] .
                                       shows_crule (shows_prec zero_nat)
 (shows_prec zero_nat) cr .
 shows_string
   [' ', 's', 'h', 'a', 'r', 'e', ' ', 'a', ' ', 's', 'y', 'm', 'b', 'o', 'l',
     '.'] .
   shows_nl . x))
                    else Inr ());
              }))
            (upt zero_nat (size_list (snd cra))))
          (\ x -> Inl (snd x)))
      crs)
    (\ x -> Inl (snd x));

af_rules ::
  forall a b. Afs a -> [(Term a b, Term a b)] -> [(Term a b, Term a b)];
af_rules pi r = map (af_rule pi) r;

afs_syms :: forall a. Afs a -> Set (a, Nat);
afs_syms xa = snd (rep_afs xa);

mono_af_entry :: Nat -> Af_entry -> Bool;
mono_af_entry n (Collapse i) = less_eq_nat n one_nat;
mono_af_entry n (AFList ids) = all_interval_nat (membera ids) zero_nat n;

mono_afs :: forall a. (Ceq a, Ccompare a) => Afs a -> Bool;
mono_afs pi = ball (afs_syms pi) (\ (f, n) -> mono_af_entry n (afsa pi (f, n)));

compatible_ta ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    [Prelude.Char] ->
                      (Xml, ([([Prelude.Char], [Prelude.Char])],
                              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                        Sum (Xml_error [Prelude.Char])
                          (Tree_automaton [Prelude.Char] (Lab a b),
                            Ta_relation [Prelude.Char]);
compatible_ta xml2name tag =
  xml_do tag
    (xml_take (tree_automaton (ta_normal_lhs xml2name))
      (\ a ->
        xml_take_default Id_Relation closed_criterion
          (\ b -> xml_return (a, b))));

xml2const_map ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Lab a b -> Maybe [Prelude.Char]);
xml2const_map xml2name =
  xml_do ['c', 'o', 'n', 's', 't', 'M', 'a', 'p']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do ['e', 'n', 't', 'r', 'y']
        (xml_take
          (xml_do ['s', 'y', 'm', 'b', 'o', 'l']
            (xml_take xml2name (\ x -> xml_return (id x))))
          (\ a ->
            xml_take (xml_text ['c', 'o', 'n', 's', 't'])
              (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (map_of a)));

default_grd_fun ::
  forall a.
    Term (Lab [Prelude.Char] a) [Prelude.Char] ->
      Term (Lab [Prelude.Char] a) [Prelude.Char] ->
        [Prelude.Char] -> Term (Lab [Prelude.Char] a) [Prelude.Char];
default_grd_fun s t =
  let {
    f = funs_rule_list (s, t);
    m = fold (\ fa m -> (case fa of {
                          Lab _ _ -> m;
                          FunLab _ _ -> m;
                          UnLab _ -> m;
                          Sharp (Lab _ _) -> m;
                          Sharp (FunLab _ _) -> m;
                          Sharp (UnLab g) -> max (size_list g) m;
                          Sharp (Sharp _) -> m;
                        }))
          f zero_nat;
    suffix = replicate (suc m) 'a';
  } in (\ x -> Fun (Sharp (UnLab (x ++ suffix))) []);

xml2non_join_info ::
  ((Xml, ([([Prelude.Char], [Prelude.Char])],
           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) (Lab [Prelude.Char] [Nat])) ->
    (Xml, ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char])
        (Non_join_info (Lab [Prelude.Char] [Nat]) [Prelude.Char]
          [Prelude.Char]);
xml2non_join_info xml2name x =
  xml_or
    (xml_leaf
      ['d', 'i', 's', 't', 'i', 'n', 'c', 't', 'N', 'o', 'r', 'm', 'a', 'l',
        'F', 'o', 'r', 'm', 's']
      Diff_NFs)
    (xml_or
      (xml_leaf ['c', 'a', 'p', 'N', 'o', 't', 'U', 'n', 'i', 'f']
        (Tcap_Non_Unif default_grd_fun))
      (xml_or
        (xml_do ['s', 'u', 'b', 't', 'e', 'r', 'm']
          (xml_take pos
            (\ a ->
              xml_take (xml2non_join_info xml2name)
                (\ b -> xml_return (Subterm_NJ a b)))))
        (xml_or
          (xml_do ['g', 'r', 'o', 'u', 'n', 'd', 'i', 'n', 'g']
            (xml_take (substa xml2name)
              (\ a ->
                xml_take (xml2non_join_info xml2name)
                  (\ b -> xml_return (Grounding a b)))))
          (xml_or
            (xml_do
              ['e', 'm', 'p', 't', 'y', 'T', 'r', 'e', 'e', 'A', 'u', 't', 'o',
                'm', 'a', 't', 'a', 'I', 'n', 't', 'e', 'r', 's', 'e', 'c', 't',
                'i', 'o', 'n']
              (xml_take
                (compatible_ta xml2name
                  ['f', 'i', 'r', 's', 't', 'A', 'u', 't', 'o', 'm', 'a', 't',
                    'o', 'n'])
                (\ a ->
                  xml_take
                    (compatible_ta xml2name
                      ['s', 'e', 'c', 'o', 'n', 'd', 'A', 'u', 't', 'o', 'm',
                        'a', 't', 'o', 'n'])
                    (\ b ->
                      xml_return
                        (let {
                           (ta1, rel1) = a;
                         } in (\ (aa, ba) ->
                                Tree_Aut_Intersect_Empty ta1 rel1 aa ba)
                          b)))))
            (xml_or
              (xml_do
                ['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', 'I', 'n', 't',
                  'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
                (xml_take (xmlt2 (sl_variant (xmlt_of_xmlt2 xml2name)))
                  (\ xa -> xml_return (Finite_Model_Gt xa))))
              (xml_or
                (xml_do
                  ['s', 't', 'r', 'i', 'c', 't', 'D', 'e', 'c', 'r', 'e', 'a',
                    's', 'e']
                  (xml_take (ordering_constraint_proof xml2name False)
                    (\ xa -> xml_return (Reduction_Pair_Gt xa))))
                (xml_or
                  (xml_do
                    ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't',
                      'e', 'r', 'N', 'o', 'n', 'J', 'o', 'i', 'n']
                    (xml_take (afs xml2name)
                      (\ a ->
                        xml_take (xml2non_join_info xml2name)
                          (\ b -> xml_return (Argument_Filter_NJ a b)))))
                  (xml_do
                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'N',
                      'o', 'n', 'J', 'o', 'i', 'n']
                    (xml_take_optional
                      (xml_or (xml_leaf ['l', 'e', 'f', 't'] True)
                        (xml_leaf ['r', 'i', 'g', 'h', 't'] False))
                      (\ a ->
                        (case a of {
                          Nothing ->
                            xml_take (xml2non_join_info xml2name)
                              (\ b -> xml_return (Usable_Rules_Reach_NJ b));
                          Just left ->
                            xml_take
                              (xml_do
                                ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l',
                                  'e', 's']
                                (xml_take (rules xml2name)
                                  (\ xa -> xml_return (id xa))))
                              (\ u ->
                                xml_take (xml2non_join_info xml2name)
                                  (\ p ->
                                    xml_return
                                      (Usable_Rules_Reach_Unif_NJ
(if left then Inl u else Inr u) p)));
                        })))))))))))
    x;

xml2ncr_proof ::
  ((Xml, ([([Prelude.Char], [Prelude.Char])],
           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) (Lab [Prelude.Char] [Nat])) ->
    (Xml, ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char])
        (Ncr_proof [Prelude.Char] [Nat] [Prelude.Char] [Prelude.Char]);
xml2ncr_proof xml2name x =
  let {
    rew = rsteps xml2name;
  } in xml_do ['c', 'r', 'D', 'i', 's', 'p', 'r', 'o', 'o', 'f']
         (xml_take
           (xml_or
             (xml_do ['n', 'o', 'n', 'W', 'c', 'r', 'A', 'n', 'd', 'S', 'N']
               (xml_take (\ xa -> Inr (fst xa))
                 (\ _ ->
                   xml_take (xml2trs_termination_proof xml2name)
                     (\ prf -> xml_return (SN_NWCR prf)))))
             (xml_or
               (xml_do
                 ['n', 'o', 'n', 'J', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'F',
                   'o', 'r', 'k']
                 (xml_take rew
                   (\ a ->
                     xml_take rew
                       (\ b ->
                         xml_take (xml2non_join_info xml2name)
                           (\ c ->
                             xml_return
                               (let {
                                  (s, seq1) = a;
                                } in (\ (_, aa) -> Non_Join s seq1 aa)
                                  b
                                 c))))))
               (xml_or
                 (xml_do
                   ['m', 'o', 'd', 'u', 'l', 'a', 'r', 'i', 't', 'y', 'D', 'i',
                     's', 'j', 'o', 'i', 'n', 't']
                   (xml_take
                     (xml_do ['t', 'r', 's']
                       (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                     (\ a ->
                       xml_take (xml2ncr_proof xml2name)
                         (\ b -> xml_return (NCR_Disj_Subtrs a b)))))
                 (xml_do
                   ['r', 'e', 'd', 'u', 'n', 'd', 'a', 'n', 't', 'R', 'u', 'l',
                     'e', 's']
                   (xml_take
                     (xml_do ['t', 'r', 's']
                       (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                     (\ a ->
                       xml_take (xml_nat ['n', 'r', 'S', 't', 'e', 'p', 's'])
                         (\ b ->
                           xml_take (xml2ncr_proof xml2name)
                             (\ c ->
                               xml_return (NCR_Redundant_Rules a b c)))))))))
           (\ xa -> xml_return (id xa)))
         x;

xml2state_map ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        ([Prelude.Char] -> Term (Lab a b) [Prelude.Char]);
xml2state_map xml2name =
  xml_do ['s', 't', 'a', 't', 'e', 'M', 'a', 'p']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do ['e', 'n', 't', 'r', 'y']
        (xml_take state
          (\ a -> xml_take (term xml2name) (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (\ x -> the (map_of a x))));

is_root_step ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Term a b -> Bool;
is_root_step r s t =
  any (\ (l, ra) -> (case match s l of {
                      Nothing -> False;
                      Just sigma -> equal_term (subst_apply_term ra sigma) t;
                    }))
    r;

is_par_rstep ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Term a b -> Bool;
is_par_rstep r (Var x) (Var y) = x == y;
is_par_rstep r (Fun f ss) (Fun g ts) =
  equal_term (Fun f ss) (Fun g ts) ||
    (is_root_step r (Fun f ss) (Fun g ts) ||
      (if f == g && equal_nat (size_list ss) (size_list ts)
        then list_all2 (is_par_rstep r) ss ts else False));
is_par_rstep r (Fun v va) (Var vb) = is_root_step r (Fun v va) (Var vb);
is_par_rstep r (Var vb) (Fun v va) = is_root_step r (Var vb) (Fun v va);

reachable_terms ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Nat -> [Term a b];
reachable_terms r s n =
  (if equal_nat n zero_nat then [s]
    else let {
           ts = reachable_terms r s (minus_nat n one_nat);
         } in remdups (ts ++ concatMap (rewrite r) ts));

is_critical_pair_closing_cp ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Nat -> (Bool, (Term a b, Term a b)) -> Bool;
is_critical_pair_closing_cp c n (False, (s, t)) =
  not (is_none (find (is_par_rstep c t) (reachable_terms c s n)));
is_critical_pair_closing_cp c n (True, (s, t)) =
  not (is_none
        (find (membera (reachable_terms c s n)) (reachable_terms c t n)));

critical_pairs_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Bool, (Term a [Prelude.Char], Term a [Prelude.Char]))];
critical_pairs_impl p r =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ pa ->
          let {
            c = ctxt_of_pos_term pa l;
            la = subt_at l pa;
            b = equal_ctxt c Hole;
          } in (if is_Var la then []
                 else concatMap
                        (\ (laa, rb) ->
                          (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                                  (\ a -> 'y' : a) la laa
                            of {
                            Nothing -> [];
                            Just (sigma, tau) ->
                              [(b, (subst_apply_term ra sigma,
                                     ctxt_apply_term (subst_apply_ctxt c sigma)
                                       (subst_apply_term rb tau)))];
                          }))
                        r))
        (poss_list l))
    p;

check_left_linear_trs ::
  forall a b.
    (Showa a, Ceq b, Ccompare b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_left_linear_trs trs =
  catch_errora
    (catch_errora
      (forallM (\ x -> (if linear_term (fst x) then Inr () else Inl x)) trs)
      (\ x -> Inl (snd x)))
    (\ _ ->
      Inl (((shows_prec_list zero_nat trs . shows_nl) .
             shows_prec_list zero_nat
               ['i', 's', ' ', 'n', 'o', 't', ' ', 'l', 'e', 'f', 't', '-', 'l',
                 'i', 'n', 'e', 'a', 'r']) .
            shows_nl));

indent ::
  ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
indent p s = concatMap (\ c -> (if c == '\n' then ['\n', ' '] else [c])) (p s);

check_critical_pair_closing ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pair_closing r c n =
  catch_errora
    (bindb (check_left_linear_trs r)
      (\ _ ->
        bindb (catch_errora (check_subseteq c r)
                (\ _ ->
                  Inl (shows_prec_list zero_nat
                        ['C', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's', 'u', 'b',
                          's', 'y', 's', 't', 'e', 'm', ' ', 'o', 'f', ' ',
                          'R'])))
          (\ _ ->
            catch_errora
              (forallM
                (\ (b, (s, t)) ->
                  check (is_critical_pair_closing_cp c n (b, (s, t)))
                    (shows_prec_list zero_nat
                       ['t', 'h', 'e', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a',
                         'l', ' ', 'p', 'a', 'i', 'r', ' '] .
                      shows_term (shows_prec zero_nat)
                        (shows_prec_list zero_nat) s .
                        shows_prec_list zero_nat
                          [' ', '<', '-', ' ', '.', ' ', '-', '>', ' '] .
                          shows_term (shows_prec zero_nat)
                            (shows_prec_list zero_nat) t .
                            shows_prec_list zero_nat
                              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l',
                                'o', 's', 'e', 'd', ' ', 'w', 'i', 't', 'h',
                                'i', 'n', ' '] .
                              shows_prec_nat zero_nat n .
                                shows_prec_list zero_nat
                                  [' ', 's', 't', 'e', 'p', 's', '.']))
                (critical_pairs_impl r r))
              (\ x -> Inl (snd x)))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list zero_nat
                   ['h', 'e', 'n', 'c', 'e', ' ', 't', 'h', 'e', ' ', 'f', 'o',
                     'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'T', 'R', 'S', ' ',
                     'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'r', 'i', 't', 'i',
                     'c', 'a', 'l', ' ', 'p', 'a', 'i', 'r', ' ', 'c', 'l', 'o',
                     's', 'i', 'n', 'g', ' '] .
                   shows_nl .
                     shows_trs (shows_prec zero_nat) (shows_prec_list zero_nat)
                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                         't', 'e', 'm', ':']
                       [' ', '-', '>', ' '] r .
                       indent x));

check_strongly_closed ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strongly_closed r n =
  catch_errora
    (bindb (check_linear_trs r)
      (\ _ ->
        catch_errora
          (forallM
            (\ (_, (s, t)) ->
              check (not (is_none
                           (find (membera (reachable_terms r s n))
                             (reachable_terms r t (suc zero_nat)))) &&
                      not (is_none
                            (find (membera (reachable_terms r t n))
                              (reachable_terms r s (suc zero_nat)))))
                (shows_prec_list zero_nat
                   ['t', 'h', 'e', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l',
                     ' ', 'p', 'a', 'i', 'r', ' '] .
                  shows_term (shows_prec zero_nat) (shows_prec_list zero_nat)
                    s .
                    shows_prec_list zero_nat
                      [' ', '<', '-', ' ', '.', ' ', '-', '>', ' '] .
                      shows_term (shows_prec zero_nat)
                        (shows_prec_list zero_nat) t .
                        shows_prec_list zero_nat
                          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 't',
                            'r', 'o', 'n', 'g', 'l', 'y', ' ', 'c', 'l', 'o',
                            's', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n',
                            ' '] .
                          shows_prec_nat zero_nat n .
                            shows_prec_list zero_nat
                              [' ', 's', 't', 'e', 'p', 's', '.']))
            (critical_pairs_impl r r))
          (\ x -> Inl (snd x))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list zero_nat
                   ['h', 'e', 'n', 'c', 'e', ' ', 't', 'h', 'e', ' ', 'f', 'o',
                     'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'T', 'R', 'S', ' ',
                     'i', 's', ' ', 'n', 'o', 't', ' ', 's', 't', 'r', 'o', 'n',
                     'g', 'l', 'y', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' '] .
                   shows_nl .
                     shows_trs (shows_prec zero_nat) (shows_prec_list zero_nat)
                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                         't', 'e', 'm', ':']
                       [' ', '-', '>', ' '] r .
                       indent x));

showsp_option ::
  forall a.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      Nat -> Maybe a -> [Prelude.Char] -> [Prelude.Char];
showsp_option show_a p (Just x) =
  (((shows_pl p . shows_string ['S', 'o', 'm', 'e']) . shows_space) .
    show_a one_nat x) .
    shows_pr p;
showsp_option show_a p Nothing = shows_string ['N', 'o', 'n', 'e'];

shows_prec_option ::
  forall a. (Showa a) => Nat -> Maybe a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_option = showsp_option shows_prec;

root_rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
root_rewrite r s =
  concatMap (\ (l, ra) -> (case match s l of {
                            Nothing -> [];
                            Just sigma -> [subst_apply_term ra sigma];
                          }))
    r;

parallel_rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
parallel_rewrite r (Var x) = [Var x];
parallel_rewrite r (Fun f ss) =
  remdups
    (root_rewrite r (Fun f ss) ++
      map (Fun f) (product_lists (map (parallel_rewrite r) ss)));

is_parallel_closed_cp ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Maybe Nat -> (Bool, (Term a b, Term a b)) -> Bool;
is_parallel_closed_cp r uu (False, (s, t)) = is_par_rstep r t s;
is_parallel_closed_cp r (Just n) (True, (s, t)) =
  not (is_none (find (is_par_rstep r t) (reachable_terms r s n)));
is_parallel_closed_cp r Nothing (True, (s, t)) =
  not (is_none (find (is_par_rstep r t) (parallel_rewrite r s)));

check_parallel_closed ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Maybe Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_parallel_closed r n =
  catch_errora
    (bindb (check_left_linear_trs r)
      (\ _ ->
        catch_errora
          (forallM
            (\ (b, (s, t)) ->
              check (is_parallel_closed_cp r n (b, (s, t)))
                (shows_prec_list zero_nat
                   ['t', 'h', 'e', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l',
                     ' ', 'p', 'a', 'i', 'r', ' '] .
                  shows_term (shows_prec zero_nat) (shows_prec_list zero_nat)
                    s .
                    shows_prec_list zero_nat
                      [' ', '<', '-', ' ', '.', ' ', '-', '>', ' '] .
                      shows_term (shows_prec zero_nat)
                        (shows_prec_list zero_nat) t .
                        shows_prec_list zero_nat
                          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', '(', 'a',
                            'l', 'm', 'o', 's', 't', ')', ' ', 'p', 'a', 'r',
                            'a', 'l', 'l', 'e', 'l', ' ', 'c', 'l', 'o', 's',
                            'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' '] .
                          shows_prec_option zero_nat n .
                            shows_prec_list zero_nat
                              [' ', 's', 't', 'e', 'p', 's', '.']))
            (critical_pairs_impl r r))
          (\ x -> Inl (snd x))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list zero_nat
                   ['h', 'e', 'n', 'c', 'e', ' ', 't', 'h', 'e', ' ', 'f', 'o',
                     'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'T', 'R', 'S', ' ',
                     'i', 's', ' ', 'n', 'o', 't', ' ', '(', 'a', 'l', 'm', 'o',
                     's', 't', ')', ' ', 'p', 'a', 'r', 'a', 'l', 'l', 'e', 'l',
                     ' ', 'c', 'l', 'o', 's', 'e', 'd', ' '] .
                   shows_nl .
                     shows_trs (shows_prec zero_nat) (shows_prec_list zero_nat)
                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                         't', 'e', 'm', ':']
                       [' ', '-', '>', ' '] r .
                       indent x));

applicable_rule_impl ::
  forall a b. (Term a b -> Bool) -> (Term a b, Term a b) -> Bool;
applicable_rule_impl isNF = (\ (l, _) -> all isNF (args l));

check_non_applicable_rules ::
  forall a b.
    (Term a b -> Bool) -> [(Term a b, Term a b)] -> Sum (Term a b, Term a b) ();
check_non_applicable_rules isNF r =
  catch_errora
    (forallM
      (\ x -> (if not (applicable_rule_impl isNF x) then Inr () else Inl x)) r)
    (\ x -> Inl (snd x));

rule_match_impl ::
  forall a b.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                (b -> Term a (Sum () [Prelude.Char])) ->
                  [Term a [Prelude.Char]] ->
                    a -> [b] -> Term a [Prelude.Char] -> Bool;
rule_match_impl nfq e_cap s f ts l =
  (case mgu_class (Fun f (map e_cap ts)) l of {
    Nothing -> False;
    Just mu ->
      all (\ u ->
            nfq (subst_apply_term (map_term (\ x -> x) (\ a -> 'y' : a) u) mu))
        (args l) &&
        all (\ u -> nfq (subst_apply_term u mu)) s;
  });

is_ur_closed_term_af_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   ((a, Nat) -> Set Nat) ->
                     [(Term a [Prelude.Char], c)] ->
                       [(Term a [Prelude.Char], c)] ->
                         [Term a [Prelude.Char]] -> Term a b -> Bool;
is_ur_closed_term_af_impl nfq e_cap pi r u s (Var x) = True;
is_ur_closed_term_af_impl nfq e_cap pi r u s (Fun f ts) =
  let {
    n = size_list ts;
    pi_f = pi (f, n);
  } in all (\ (i, t) ->
             (if member i pi_f
               then is_ur_closed_term_af_impl nfq e_cap pi r u s t else True))
         (zip (upt zero_nat n) ts) &&
         all (\ (l, ra) ->
               membera u (l, ra) || not (rule_match_impl nfq e_cap s f ts l))
           r;

is_ur_closed_af_impl_dpp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Term b [Prelude.Char] -> Bool;
is_ur_closed_af_impl_dpp_mv i d pi =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulese i d;
    urc = (\ s -> is_ur_closed_term_af_impl qnf (ic s) pi r);
  } in (\ u s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_term (\ x -> x) (\ a -> 'x' : a) t)));

wwf_rulesa :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
wwf_rulesa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = wwf_rules;

q_emptyc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
q_emptyc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = q_empty;

matchCapRMBelow ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                 Term a b -> Term a b -> Bool;
matchCapRMBelow rm l (Fun f ts) = matchb (GCFun f (map (tcapRM2 rm) ts)) l;

forallM_index_aux ::
  forall a b. (a -> Nat -> Sum b ()) -> Nat -> [a] -> Sum ((a, Nat), b) ();
forallM_index_aux p i [] = Inr ();
forallM_index_aux p i (x : xs) =
  bindb (catch_errora (p x i) (\ xa -> Inl ((x, i), xa)))
    (\ _ -> forallM_index_aux p (suc i) xs);

forallM_index ::
  forall a b. (a -> Nat -> Sum b ()) -> [a] -> Sum ((a, Nat), b) ();
forallM_index p xs = forallM_index_aux p zero_nat xs;

check_ur_closed_term_rm_af ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                    [(Term a b, Term a b)] ->
                      ((a, Nat) -> Set Nat) ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ur_closed_term_rm_af uu uv uw (Var x) = Inr ();
check_ur_closed_term_rm_af rm ur pi (Fun f ts) =
  let {
    n = size_list ts;
    pia = pi (f, n);
  } in bindb (catch_errora
               (forallM_index
                 (\ t i ->
                   (if member i pia then check_ur_closed_term_rm_af rm ur pi t
                     else Inr ()))
                 ts)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ lr ->
                 check (membera ur lr ||
                         not (matchCapRMBelow rm (fst lr) (Fun f ts)))
                   (shows_string
                      ['d', 'u', 'e', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ',
                        's', 'u', 'b', 't', 'e', 'r', 'm', ' '] .
                     shows_prec_term zero_nat (Fun f ts) .
                       shows_string
                         [' ', 'o', 'f', ' ', 's', 'o', 'm', 'e', ' ', 'u', 's',
                           'a', 'b', 'l', 'e', ' ', 'r', 'h', 's', ',', ' ',
                           'r', 'u', 'l', 'e', ' '] .
                         shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                           [' ', '-', '>', ' '] lr .
                           shows_string
                             [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e',
                               ' ', 'u', 's', 'a', 'b', 'l', 'e', '.']))
               (rm (f, n)))
             (\ x -> Inl (snd x)));

check_ur_P_closed_rm_af ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                    [(Term a b, Term a b)] ->
                      ((a, Nat) -> Set Nat) ->
                        [(Term a b, Term a b)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ur_P_closed_rm_af rm ur pi p =
  bindb (catch_errora
          (catch_errora
            (forallM (\ lr -> check_ur_closed_term_rm_af rm ur pi (snd lr)) ur)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (shows_string
                   ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
                     'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'c', 'l', 'o', 's',
                     'u', 'r', 'e', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'i',
                     'e', 's', ' ', 'o', 'f', ' ', 'r', 'h', 's', ' ', 'o', 'f',
                     ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                     's'] .
                  shows_nl . x)))
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM (\ st -> check_ur_closed_term_rm_af rm ur pi (snd st)) p)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_string
                 ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
                   'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'c', 'l', 'o', 's',
                   'u', 'r', 'e', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'i',
                   'e', 's', ' ', 'o', 'f', ' ', 'r', 'h', 's', ' ', 'o', 'f',
                   ' ', 'D', 'P', 's'] .
                shows_nl . x)));

smart_usable_rules_checker_impl ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           Maybe [(Term b [Prelude.Char],
                                    Term b [Prelude.Char])] ->
                             [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                               Sum ([Prelude.Char] -> [Prelude.Char])
                                 [(Term b [Prelude.Char],
                                    Term b [Prelude.Char])];
smart_usable_rules_checker_impl i d pi u_opt sts =
  let {
    nfs = nfsc i d;
    m = minimal i d;
    wwf = wwf_rulesa i d;
    qempty = q_emptyc i d;
  } in (case u_opt of {
         Nothing -> Inr (rulese i d);
         Just u ->
           (if nFQ_subset_NF_rulesc i d &&
                 (nfs || isOK (check_varcond_subset sts)) && (nfs || (m || wwf))
             then let {
                    urc = is_ur_closed_af_impl_dpp_mv i d pi u;
                    check_urc =
                      (\ s t ->
                        check (urc s t)
                          (shows_prec_list zero_nat ['t', 'e', 'r', 'm', ' '] .
                            shows_prec_term zero_nat t .
                              shows_prec_list zero_nat
                                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c',
                                  'l', 'o', 's', 'e', 'd', ' ', 'u', 'n', 'd',
                                  'e', 'r', ' ', 'u', 's', 'a', 'b', 'l', 'e',
                                  ' ', 'r', 'u', 'l', 'e', 's']));
                  } in bindb (catch_errora
                               (forallM (\ (s, a) -> check_urc [s] a) sts)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM (\ (l, a) -> check_urc (args l) a)
                                     u)
                                   (\ x -> Inl (snd x)))
                             (\ _ -> Inr u))
             else bindb (check (m && (if nfs then qempty || wwf else True))
                          (shows_prec_list zero_nat
                            ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                              ' ', 'a', 'n', 'd', ' ', 'w', 'e', 'l', 'l', ' ',
                              'f', 'o', 'r', 'm', 'e', 'd', 'n', 'e', 's', 's',
                              ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                    (\ _ ->
                      bindb (catch_errora
                              (forallM
                                (\ (l, _) ->
                                  check (not (is_Var l))
                                    (shows_prec_list zero_nat
                                      ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
's', ' ', 'a', 's', ' ', 'l', 'h', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l',
'l', 'o', 'w', 'e', 'd']))
                                (rulese i d))
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          let {
                            rm = rules_mapc i d;
                          } in bindb (check_ur_P_closed_rm_af rm u pi sts)
                                 (\ _ -> Inr u))));
       });

root_aft_to_entry ::
  forall a b c. a -> Term b c -> ((b, Nat) -> Set Nat) -> [(a, Term b c)];
root_aft_to_entry s t pi =
  let {
    rt = the (root t);
    pi_t = pi rt;
    ts = args t;
  } in map_filter
         (\ x -> (if member x pi_t then Just (s, nth ts x) else Nothing))
         (upt zero_nat (snd rt));

check_no_defined_root ::
  forall a b.
    (Showa a,
      Showa b) => ((a, Nat) -> Bool) ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_defined_root isdef t =
  check (not (isdef (the (root t))))
    (shows_string ['t', 'h', 'e', ' ', 'r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
      shows_prec_term zero_nat t .
        shows_string [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd']);

pairsb :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pairsb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = pairs;

valida ::
  forall a b c.
    Root_redtriple_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
valida (Root_redtriple_ext valid s ns nst af aft desc more) = valid;

descb ::
  forall a b c. Root_redtriple_ext a b c -> [Prelude.Char] -> [Prelude.Char];
descb (Root_redtriple_ext valid s ns nst af aft desc more) = desc;

nsta ::
  forall a b c.
    Root_redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsta (Root_redtriple_ext valid s ns nst af aft desc more) = nst;

aft :: forall a b c. Root_redtriple_ext a b c -> (a, Nat) -> Set Nat;
aft (Root_redtriple_ext valid s ns nst af aft desc more) = aft;

nsa ::
  forall a b c.
    Root_redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsa (Root_redtriple_ext valid s ns nst af aft desc more) = ns;

afa :: forall a b c. Root_redtriple_ext a b c -> (a, Nat) -> Set Nat;
afa (Root_redtriple_ext valid s ns nst af aft desc more) = af;

sa :: forall a b c.
        Root_redtriple_ext a b c ->
          (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sa (Root_redtriple_ext valid s ns nst af aft desc more) = s;

generic_ur_af_root_redtriple_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Root_redtriple_ext b [Prelude.Char] () ->
                      Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_ur_af_root_redtriple_proc i rp u_opt premove dpp =
  (case catch_errora
          (bindb (valida rp)
            (\ _ ->
              let {
                (ps, pns) = split_pairsa i dpp premove;
                p = pairsb i dpp;
                pi = afa rp;
                pia = aft rp;
                is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
              } in bindb (catch_errora
                           (forallM
                             (\ (l, r) ->
                               bindb (check_no_var l)
                                 (\ _ ->
                                   bindb (check_no_var r)
                                     (\ _ -> check_no_defined_root is_def r)))
                             p)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulese i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (smart_usable_rules_checker_impl i dpp pi u_opt
                                   (concatMap
                                     (\ (s, t) -> root_aft_to_entry s t pia) p))
                             (\ u ->
                               bindb (catch_errora
                                       (catch_errora (forallM (nsa rp) u)
 (\ x -> Inl (snd x)))
                                       (\ x ->
 Inl (shows_string
        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
          'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', '(', 'u', 's', 'a', 'b',
          'l', 'e', ')', ' ', 'r', 'u', 'l', 'e', 's'] .
       shows_nl . x)))
                                 (\ _ ->
                                   bindb (catch_errora
   (catch_errora (forallM (nsta rp) pns) (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
              'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
           shows_nl . x)))
                                     (\ _ ->
                                       catch_errora
 (catch_errora (forallM (sa rp) ps) (\ x -> Inl (snd x)))
 (\ x ->
   Inl (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
            'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
         shows_nl . x)))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e',
                     'r', 'i', 'c', ' ', 'r', 'o', 'o', 't', ' ', 'r', 'e', 'd',
                     'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ',
                     'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i',
                     't', 'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o',
                     'w', 'i', 'n', 'g'] .
                  shows_nl . descb rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp premove premove);
  });

nst ::
  forall a b c.
    Redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nst (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  nst;

generic_ur_af_redtriple_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_ur_af_redtriple_proc i rp u_opt premove dpp =
  (case catch_errora
          (bindb (valid rp)
            (\ _ ->
              let {
                (ps, pns) = split_pairsa i dpp premove;
                p = pairsb i dpp;
              } in bindb (smart_usable_rules_checker_impl i dpp (af rp) u_opt p)
                     (\ u ->
                       bindb (catch_errora
                               (catch_errora (forallM (ns rp) u)
                                 (\ x -> Inl (snd x)))
                               (\ x ->
                                 Inl (shows_string
['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r', 'i',
  'e', 'n', 't', 'i', 'n', 'g', ' ', '(', 'u', 's', 'a', 'b', 'l', 'e', ')',
  ' ', 'r', 'u', 'l', 'e', 's'] .
                                       shows_nl . x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (catch_errora (forallM (nst rp) pns)
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (shows_string
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
      'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
   shows_nl . x)))
                             (\ _ ->
                               catch_errora
                                 (catch_errora (forallM (s rp) ps)
                                   (\ x -> Inl (snd x)))
                                 (\ x ->
                                   Inl (shows_string
  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
    'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
 shows_nl . x)))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e',
                     'r', 'i', 'c', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o',
                     'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e',
                     's', 's', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h',
                     'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp premove premove);
  });

is_ur_closed_term_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   [(Term a [Prelude.Char], c)] ->
                     [(Term a [Prelude.Char], c)] ->
                       [Term a [Prelude.Char]] -> Term a b -> Bool;
is_ur_closed_term_impl nfq e_cap r u s (Var x) = True;
is_ur_closed_term_impl nfq e_cap r u s (Fun f ts) =
  all (is_ur_closed_term_impl nfq e_cap r u s) ts &&
    all (\ (l, ra) ->
          membera u (l, ra) || not (rule_match_impl nfq e_cap s f ts l))
      r;

is_ur_closed_impl_dpp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                           [Term b [Prelude.Char]] ->
                             Term b [Prelude.Char] -> Bool;
is_ur_closed_impl_dpp_mv i d =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulese i d;
    urc = (\ s -> is_ur_closed_term_impl qnf (ic s) r);
  } in (\ u s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_term (\ x -> x) (\ a -> 'x' : a) t)));

intersect_rulesb ::
  forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_rulesb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = intersect_rules;

usable_rules_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_proc i u dpp =
  (case bindb (check (nFQ_subset_NF_rulesc i dpp)
                (shows_prec_list zero_nat
                  ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e',
                    'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'r', 'e', 'q', 'u',
                    'i', 'r', 'e', 'd']))
          (\ _ ->
            bindb (check (nfsc i dpp || (minimal i dpp || wwf_rulesa i dpp))
                    (shows_prec_list zero_nat
                      ['n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm',
                        ' ', 's', 'u', 'b', 's', 't', ',', ' ', 'm', 'i', 'n',
                        'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'o', 'r', ' ',
                        'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd',
                        'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                        'e', 'd']))
              (\ _ ->
                let {
                  p = pairsb i dpp;
                  urc = is_ur_closed_impl_dpp_mv i dpp u;
                  check_urc =
                    (\ s t ->
                      check (urc s t)
                        (shows_prec_list zero_nat ['t', 'e', 'r', 'm', ' '] .
                          shows_prec_term zero_nat t .
                            shows_prec_list zero_nat
                              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l',
                                'o', 's', 'e', 'd', ' ', 'u', 'n', 'd', 'e',
                                'r', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                                'r', 'u', 'l', 'e', 's']));
                  nfs = nfsc i dpp;
                } in bindb (catch_errora
                             (forallM
                               (\ (l, r) ->
                                 bindb (if nfs then Inr ()
 else catch_errora (check_subseteq (vars_term_list r) (vars_term_list l))
        (\ _ ->
          Inl (shows_prec_list zero_nat
                ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'n',
                  'd', 'i', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'P', ' ',
                  'v', 'i', 'o', 'l', 'a', 't', 'e', 'd'])))
                                   (\ _ -> check_urc [l] r))
                               p)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         catch_errora
                           (forallM (\ (l, a) -> check_urc (args l) a) u)
                           (\ x -> Inl (snd x)))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (intersect_rulesb i dpp u);
  });

mono ::
  forall a b c.
    Redtriple_ext a b c ->
      [(Term a b, Term a b)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
mono (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  mono;

mono_inn_usable_rules_ce_proc ::
  forall a b.
    (Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_inn_usable_rules_ce_proc i rp premove rremove ur dpp =
  (case catch_errora
          (bindb (usable_rules_proc i ur dpp)
            (\ _ ->
              let {
                p = pairsb i dpp;
                us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
                filt =
                  (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
                (pms, pns) = split_pairsa i dpp premove;
                (ps, pnwf) = partition filt pms;
                (urms, urns) = partition (membera rremove) ur;
                (urs, urnwf) = partition filt urms;
              } in bindb (valid rp)
                     (\ _ ->
                       bindb (mono rp
                               (ps ++ urs ++ urns ++ urnwf ++ pns ++ pnwf))
                         (\ _ ->
                           bindb (catch_errora
                                   (catch_errora
                                     (forallM (ns rp) (urns ++ urnwf))
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (shows_string
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
      'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
      'r', 'u', 'l', 'e', 's'] .
   shows_nl . x)))
                             (\ _ ->
                               bindb (catch_errora
                                       (catch_errora (forallM (s rp) urs)
 (\ x -> Inl (snd x)))
                                       (\ x ->
 Inl (shows_string
        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
          'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l',
          'e', ' ', 'r', 'u', 'l', 'e', 's'] .
       shows_nl . x)))
                                 (\ _ ->
                                   bindb (catch_errora
   (catch_errora (forallM (ns rp) (pns ++ pnwf)) (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
              'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
           shows_nl . x)))
                                     (\ _ ->
                                       catch_errora
 (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
 (\ x ->
   Inl (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
            'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
         shows_nl . x)))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'i', 'n', 'n', 'e',
                     'r', 'm', 'o', 's', 't', ' ', 'u', 's', 'a', 'b', 'l', 'e',
                     ' ', 'r', 'u', 'l', 'e', 's', ' ', 'r', 'e', 'd', 'u', 'c',
                     't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r',
                     'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't', 'h',
                     ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i',
                     'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

mono_ur_redpair_proc ::
  forall a b c.
    (Ceq b, Ccompare b, Eq b, Set_impl b, Showa b, Eq c,
      Showa c) => Dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          [(Term b c, Term b c)] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_ur_redpair_proc i rp premove rremove ur dpp =
  (case catch_errora
          (bindb
            (check (minimal i dpp)
              (shows_prec_list zero_nat
                ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'r',
                  'e', 'q', 'u', 'i', 'r', 'e', 'd']))
            (\ _ ->
              bindb (check
                      (if nfsc i dpp
                        then (if not (q_emptyc i dpp) then wwf_rulesa i dpp
                               else True)
                        else True)
                      (shows_prec_list zero_nat
                        ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e', 'd',
                          'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                          'e', 'd']))
                (\ _ ->
                  let {
                    p = pairsb i dpp;
                    us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
                    filt =
                      (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
                    (pms, pns) = split_pairsa i dpp premove;
                    (ps, pnwf) = partition filt pms;
                    (urms, urns) = partition (membera rremove) ur;
                    (urs, urnwf) = partition filt urms;
                    rm = rules_mapc i dpp;
                  } in bindb (valid rp)
                         (\ _ ->
                           bindb (mono rp
                                   (ps ++ urs ++ urns ++ urnwf ++ pns ++ pnwf))
                             (\ _ ->
                               bindb (check_ur_P_closed_rm_af rm ur full_af p)
                                 (\ _ ->
                                   bindb (catch_errora
   (forallM
     (\ (l, _) ->
       check (not (is_Var l))
         (shows_prec_list zero_nat
           ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ',
             'l', 'h', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
             'w', 'e', 'd']))
     (rulese i dpp))
   (\ x -> Inl (snd x)))
                                     (\ _ ->
                                       bindb
 (catch_errora
   (catch_errora (forallM (ns rp) (urns ++ urnwf)) (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
              'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a',
              'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
           shows_nl . x)))
 (\ _ ->
   bindb (catch_errora (catch_errora (forallM (s rp) urs) (\ x -> Inl (snd x)))
           (\ x ->
             Inl (shows_string
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                      ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ',
                      'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                      's'] .
                   shows_nl . x)))
     (\ _ ->
       bindb (catch_errora
               (catch_errora (forallM (ns rp) (pns ++ pnwf))
                 (\ x -> Inl (snd x)))
               (\ x ->
                 Inl (shows_string
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                          'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                          ' ', 'D', 'P', 's'] .
                       shows_nl . x)))
         (\ _ ->
           catch_errora (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
             (\ x ->
               Inl (shows_string
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                        'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                        ' ', 'D', 'P', 's'] .
                     shows_nl . x))))))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'n', 'o',
                     't', 'o', 'n', 'i', 'c', ' ', 'r', 'e', 'd', 'u', 'c', 't',
                     'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o',
                     'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ',
                     't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n',
                     'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

generic_mono_ur_redpair_proc ::
  forall a b.
    (Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_mono_ur_redpair_proc i rp premove rremove ur dpp =
  (if nFQ_subset_NF_rulesc i dpp
    then mono_inn_usable_rules_ce_proc i rp premove rremove ur dpp
    else bindb (check (minimal i dpp)
                 (shows_prec_list zero_nat
                   ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'o',
                     'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ',
                     'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ', 'f', 'o', 'r',
                     ' ', 'm', 'o', 'n', '.', ' ', 'r', 'e', 'd', '.', ' ', 'p',
                     'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', '.', ' ', 'w', 'i',
                     't', 'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u',
                     'l', 'e', 's']))
           (\ _ -> mono_ur_redpair_proc i rp premove rremove ur dpp));

compat_roota :: forall a b. (Eq a) => Term a b -> Maybe (a, Nat) -> Bool;
compat_roota uu Nothing = False;
compat_roota (Var uv) (Just v) = False;
compat_roota (Fun va vb) (Just v) = root (Fun va vb) == Just v;

usable_rules_gen2 ::
  forall a b.
    (Eq a) => [(Term a b, Term a b)] ->
                (Maybe (a, Nat), Bool) -> [(Term a b, Term a b)];
usable_rules_gen2 r (fn, b) =
  let {
    rr = concatMap (\ (l, ra) -> (if compat_roota l fn then [(l, ra)] else []))
           r;
  } in (if b then rr else map (\ (l, ra) -> (ra, l)) rr);

rel_dep_prod :: Bool -> Dependance -> [Bool];
rel_dep_prod uu Ignore = [];
rel_dep_prod b Increase = [b];
rel_dep_prod b Decrease = [not b];
rel_dep_prod uv Wild = [True, False];

compat_root :: forall a b c. (Eq a) => Term a b -> Term a c -> Bool;
compat_root uu (Var uv) = False;
compat_root (Var uw) (Fun v va) = False;
compat_root (Fun vb vc) (Fun v va) = root (Fun vb vc) == root (Fun v va);

usable_rules_gen1 ::
  forall a b.
    (Eq a) => ((a, Nat) -> Nat -> Dependance) ->
                [(Term a b, Term a b)] ->
                  (Term a b, Bool) -> [(Term a b, Bool)];
usable_rules_gen1 pi r (Var uu, uv) = [];
usable_rules_gen1 pi r (Fun f ts, b) =
  let {
    n = size_list ts;
  } in concatMap
         (\ (l, ra) -> (if compat_root l (Fun f ts) then [(ra, b)] else []))
         r ++
         concatMap
           (\ i -> map (\ a -> (nth ts i, a)) (rel_dep_prod b (pi (f, n) i)))
           (upt zero_nat n);

usable_rules_gen ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> Nat -> Dependance) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] -> [(Term a b, Term a b)];
usable_rules_gen pi r p =
  concatMap (usable_rules_gen2 r)
    (remdups
      (map (\ (t, a) -> (root t, a))
        (mk_rtrancl_list (\ a b -> a == b) (usable_rules_gen1 pi r)
          (map (\ (_, t) -> (t, True)) p))));

generate_lists :: forall a. Nat -> [a] -> [[a]];
generate_lists n xs = concat_lists (map (\ _ -> xs) (upt zero_nat n));

initial_conditions_gen_impl ::
  forall a. (a -> a -> Bool) -> Nat -> Nat -> [a] -> a -> [[a]];
initial_conditions_gen_impl pa bef_len aft_len p st =
  let {
    pairs = (\ n -> generate_lists n p);
    a = concatMap (\ bef -> map (\ aft -> bef ++ st : aft) (pairs aft_len))
          (pairs bef_len);
  } in filter
         (\ bef_st_aft ->
           all_interval_nat
             (\ i -> pa (nth bef_st_aft i) (nth bef_st_aft (suc i))) zero_nat
             (plus_nat bef_len aft_len))
         a;

disjoint_variant ::
  forall a b.
    (Compare a, Eq a, Card_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Mapping_impl b,
      Set_impl b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Bool;
disjoint_variant sts uvs =
  equal_nat (size_list sts) (size_list uvs) &&
    all_interval_nat (\ i -> eq_rule_mod_vars (nth sts i) (nth uvs i)) zero_nat
      (size_list sts) &&
      is_partition (map vars_rule uvs);

condition_of ::
  forall a b.
    a -> Condition_type -> (Term a b, Term a b) -> Cond_constraint a b;
condition_of c Bound (s, uu) = CC_cond False (s, Fun c []);
condition_of c Strict st = CC_cond True st;
condition_of c Non_Strict st = CC_cond False st;

constraint_of ::
  forall a b.
    a -> Condition_type -> [(Term a b, Term a b)] -> Nat -> Cond_constraint a b;
constraint_of c ctype uvs bef =
  CC_impl
    (map (\ i -> CC_rewr (snd (nth uvs i)) (fst (nth uvs (suc i))))
      (upt zero_nat (minus_nat (size_list uvs) one_nat)))
    (condition_of c ctype (nth uvs bef));

the_set_impl_main_lazy ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Eq b) => (a -> [b]) -> (b -> [a]) -> [a] -> Set a -> [b] -> [a];
the_set_impl_main_lazy q gen_as have_asa have_as bs =
  let {
    new_as =
      concatMap
        (\ b ->
          concatMap (\ a -> (if not (member a have_as) then [a] else []))
            (gen_as b))
        bs;
  } in (if null new_as then have_asa
         else the_set_impl_main_lazy q gen_as (new_as ++ have_asa)
                (sup_set (set new_as) have_as) (remdups (concatMap q new_as)));

the_set_impl_lazy ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Eq b) => (a -> [b]) -> (b -> [a]) -> [b] -> [a];
the_set_impl_lazy q gen_as bs = the_set_impl_main_lazy q gen_as [] bot_set bs;

inductive_set_impl_lazy ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Set_impl b) => (a -> [b]) -> (b -> [a]) -> [a] -> [b];
inductive_set_impl_lazy q p = the_set_impl_lazy p q;

ur_term_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   [(Term a [Prelude.Char], c)] ->
                     ((a, Nat) -> Set Nat) ->
                       [Term a [Prelude.Char]] ->
                         Term a b -> [(Term a [Prelude.Char], c)];
ur_term_impl nfq e_cap r pi s (Var x) = [];
ur_term_impl nfq e_cap r pi s (Fun f ts) =
  let {
    n = size_list ts;
    rec = map (ur_term_impl nfq e_cap r pi s) ts;
  } in remdups
         (concatMap (\ (i, urs) -> (if member i (pi (f, n)) then urs else []))
            (zip (upt zero_nat n) rec) ++
           filter (\ (l, _) -> rule_match_impl nfq e_cap s f ts l) r);

precompute_fun :: forall a b. (Key a) => (a -> b) -> [a] -> a -> b;
precompute_fun f asa =
  fun_of_map_fun (ceta_map_of (map (\ a -> (a, f a)) asa)) f;

usable_rules_calc_impl ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  ([Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      [([Term a [Prelude.Char]], Term a [Prelude.Char])] ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])];
usable_rules_calc_impl nfq e_cap r =
  let {
    urt = (\ (s, t) ->
            let {
              sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
            } in ur_term_impl nfq (e_cap sa) r full_af sa
                   (map_term (\ x -> x) (\ a -> 'x' : a) t));
    urules = map (\ (l, a) -> (args l, a)) r;
    ufun = precompute_fun urt urules;
  } in inductive_set_impl_lazy ufun (\ (l, ra) -> [(args l, ra)]);

ur_calc_singleton ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  ([Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      ([Term a [Prelude.Char]], Term a [Prelude.Char]) ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])];
ur_calc_singleton nfq e_cap r st = usable_rules_calc_impl nfq e_cap r [st];

inn_usable_rules_pair ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                         [(Term b [Prelude.Char], Term b [Prelude.Char])];
inn_usable_rules_pair i d =
  let {
    inn = nFQ_subset_NF_rulesc i d;
    r = rulese i d;
    qnf = is_QNFc i d;
    ic = icap_impl_dpp i d;
    calc = ur_calc_singleton qnf ic r;
    nfs = nfsc i d;
    wwf = wwf_rulesa i d;
    m = minimal i d;
  } in (\ (s, t) ->
         (if inn &&
               (nfs || subset (vars_term t) (vars_term s)) &&
                 (nfs || (m || wwf))
           then calc ([s], t) else r));

icap_impl_dpp_mv ::
  forall a b.
    (Eq b) => Dpp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_dpp_mv i d =
  let {
    qr = nFQ_subset_NF_rulesc i d;
    qnf = is_QNFc i d;
    r = rulese i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s -> let {
                 sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
                 sx = ceta_set_of (concatMap vars_term_list sa);
               } in (\ t -> ic sa sx (map_term (\ x -> x) (\ a -> 'x' : a) t)));

is_iedg_edge_dpp ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                           Term b [Prelude.Char] -> Bool;
is_iedg_edge_dpp i d =
  let {
    qnf = is_QNFc i d;
    ic = icap_impl_dpp_mv i d;
    _ = rulese i d;
    urules = inn_usable_rules_pair i d;
  } in (\ (s, t) ->
         let {
           cst = ic [s] t;
           urls = reverse_rules (urules (s, t));
           ica = icap_impl (is_NF_terms []) urls;
         } in (\ u ->
                (case mgu_class cst u of {
                  Nothing -> False;
                  Just mu ->
                    qnf (subst_apply_term
                          (map_term (\ x -> x) (\ a -> 'x' : a) s) mu) &&
                      qnf (subst_apply_term
                            (map_term (\ x -> x) (\ a -> 'y' : a) u) mu);
                }) &&
                  let {
                    cu = ica [] u;
                  } in (case mgu_class cu t of {
                         Nothing -> False;
                         Just mu ->
                           qnf (subst_apply_term
                                 (map_term (\ x -> x) (\ a -> 'y' : a) s) mu);
                       })));

deep_normalize_cca :: forall a b. Cond_constraint a b -> Cond_constraint a b;
deep_normalize_cca (CC_impl [] c) = deep_normalize_cca c;
deep_normalize_cca (CC_impl (v : va) c) =
  CC_impl (map deep_normalize_cca (v : va)) (deep_normalize_cca c);
deep_normalize_cca (CC_cond s c) = CC_cond s c;
deep_normalize_cca (CC_all s c) = CC_all s (deep_normalize_cca c);
deep_normalize_cca (CC_rewr s c) = CC_rewr s c;

vars_cc_list :: forall a b. (Eq b) => Cond_constraint a b -> [b];
vars_cc_list (CC_cond ct (s, t)) = vars_term_list s ++ vars_term_list t;
vars_cc_list (CC_rewr s t) = vars_term_list s ++ vars_term_list t;
vars_cc_list (CC_impl c1 c2) = concatMap vars_cc_list c1 ++ vars_cc_list c2;
vars_cc_list (CC_all x c) =
  concatMap (\ y -> (if not (y == x) then [y] else [])) (vars_cc_list c);

cc_subst_apply ::
  forall a b.
    (Eq a) => ([a] -> a) ->
                Cond_constraint b a ->
                  (a -> Term b a, [a]) -> Cond_constraint b a;
cc_subst_apply fresh (CC_all x c) (sigma, vs) =
  let {
    y = fresh (vs ++ vars_cc_list (CC_all x c));
  } in CC_all y (cc_subst_apply fresh c (fun_upd sigma x (Var y), y : vs));
cc_subst_apply fresh (CC_impl c1 c2) sigma =
  CC_impl (map (\ c -> cc_subst_apply fresh c sigma) c1)
    (cc_subst_apply fresh c2 sigma);
cc_subst_apply fresh (CC_rewr s t) (sigma, uv) =
  CC_rewr (subst_apply_term s sigma) (subst_apply_term t sigma);
cc_subst_apply fresh (CC_cond ct (s, t)) (sigma, uu) =
  CC_cond ct (subst_apply_term s sigma, subst_apply_term t sigma);

normalize_alpha ::
  forall a b.
    (Eq a) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a;
normalize_alpha fresh c = cc_subst_apply fresh c (Var, []);

deep_normalize_cc ::
  forall a b.
    (Eq a) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a;
deep_normalize_cc fresh c = normalize_alpha fresh (deep_normalize_cca c);

check_subsumesa ::
  forall a b.
    (Eq a, Eq b) => Cond_constraint a b -> Cond_constraint a b -> Bool;
check_subsumesa (CC_impl cs c) (CC_impl ds d) =
  check_subsumesa c d &&
    all (\ ca -> any (\ da -> check_subsumesa da ca) ds) cs;
check_subsumesa (CC_cond v va) (CC_impl ds d) =
  check_subsumesa (CC_cond v va) d;
check_subsumesa (CC_rewr v va) (CC_impl ds d) =
  check_subsumesa (CC_rewr v va) d;
check_subsumesa (CC_all v va) (CC_impl ds d) = check_subsumesa (CC_all v va) d;
check_subsumesa (CC_all x c) (CC_all y d) = x == y && check_subsumesa c d;
check_subsumesa (CC_cond v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_cond vb vc);
check_subsumesa (CC_cond v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_rewr vb vc);
check_subsumesa (CC_cond v va) (CC_all vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_all vb vc);
check_subsumesa (CC_rewr v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_cond vb vc);
check_subsumesa (CC_rewr v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_rewr vb vc);
check_subsumesa (CC_rewr v va) (CC_all vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_all vb vc);
check_subsumesa (CC_all v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_all v va) (CC_cond vb vc);
check_subsumesa (CC_all v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_all v va) (CC_rewr vb vc);
check_subsumesa c (CC_cond v va) = equal_cond_constraint c (CC_cond v va);
check_subsumesa c (CC_rewr v va) = equal_cond_constraint c (CC_rewr v va);
check_subsumesa (CC_impl vb vc) (CC_all v va) =
  equal_cond_constraint (CC_impl vb vc) (CC_all v va);

check_subsumes ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a -> Bool;
check_subsumes fresh c d = let {
                             n = deep_normalize_cc fresh;
                           } in check_subsumesa (n c) (n d);

check_constraint_present ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> b -> [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                                Nat ->
                                  Nat ->
                                    [(Cond_constraint b [Prelude.Char],
                                       [(Term b [Prelude.Char],
  Term b [Prelude.Char])])] ->
                                      Condition_type ->
(Term b [Prelude.Char], Term b [Prelude.Char]) ->
  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_constraint_present i dpp constant p bef aft ccs =
  let {
    edg = is_iedg_edge_dpp i dpp;
    init_conds =
      initial_conditions_gen_impl (\ st uv -> edg st (fst uv)) bef aft p;
  } in (\ ct st ->
         catch_errora
           (forallM
             (\ sts ->
               check (any (\ (c, uvs) ->
                            disjoint_variant sts uvs &&
                              check_subsumes (fresh_string ['x', 'x']) c
                                (constraint_of constant ct uvs bef))
                       ccs)
                 (shows_prec_list zero_nat
                    ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
                      ' '] .
                   shows_prec_list zero_nat
                     (case ct of {
                       Bound -> ['b', 'o', 'u', 'n', 'd'];
                       Strict -> ['s', 't', 'r', 'i', 'c', 't'];
                       Non_Strict ->
                         ['n', 'o', 'n', '-', 's', 't', 'r', 'i', 'c', 't'];
                     }) .
                     shows_prec_list zero_nat
                       [' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't',
                         ' ', 'f', 'o', 'r', ' ', 's', 'e', 'q', 'u', 'e', 'n',
                         'c', 'e', ' '] .
                       shows_rules (shows_prec zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] sts))
             (init_conds st))
           (\ x -> Inl (snd x)));

check_weakly_orthogonal ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_weakly_orthogonal r =
  catch_errora
    (bindb (check_left_linear_trs r)
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ (l, _) ->
                    check (not (is_Var l))
                      (shows_prec_list zero_nat
                        ['t', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'h', 'a', 's',
                          ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ',
                          'a', 's', ' ', 'l', 'e', 'f', 't', '-', 'h', 'a', 'n',
                          'd', ' ', 's', 'i', 'd', 'e', 's']))
                  r)
                (\ x -> Inl (snd x)))
          (\ _ ->
            catch_errora
              (forallM
                (\ (_, (s, t)) ->
                  check (equal_term s t)
                    (shows_prec_list zero_nat
                       ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', ' ',
                         'n', 'o', 'n', '-', 't', 'r', 'i', 'v', 'i', 'a', 'l',
                         ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p',
                         'a', 'i', 'r', ':', ' '] .
                      shows_term (shows_prec zero_nat)
                        (shows_prec_list zero_nat) s .
                        shows_prec_list zero_nat
                          [' ', '<', '-', ' ', '.', ' ', '-', '>', ' '] .
                          shows_term (shows_prec zero_nat)
                            (shows_prec_list zero_nat) t))
                (critical_pairs_impl r r))
              (\ x -> Inl (snd x)))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list zero_nat
                   ['h', 'e', 'n', 'c', 'e', ',', ' ', 't', 'h', 'e', ' ', 'f',
                     'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'T', 'R', 'S',
                     ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'w', 'e', 'a', 'k',
                     'l', 'y', ' ', 'o', 'r', 't', 'h', 'o', 'g', 'o', 'n', 'a',
                     'l', ' '] .
                   shows_nl .
                     shows_trs (shows_prec zero_nat) (shows_prec_list zero_nat)
                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                         't', 'e', 'm', ':']
                       [' ', '-', '>', ' '] r .
                       indent x));

validb ::
  forall a b c.
    Non_inf_order_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
validb (Non_inf_order_ext valid ns cc af desc more) = valid;

descc ::
  forall a b c. Non_inf_order_ext a b c -> [Prelude.Char] -> [Prelude.Char];
descc (Non_inf_order_ext valid ns cc af desc more) = desc;

nsb ::
  forall a b c.
    Non_inf_order_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsb (Non_inf_order_ext valid ns cc af desc more) = ns;

cc :: forall a b c.
        Non_inf_order_ext a b c ->
          C_constraint a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
cc (Non_inf_order_ext valid ns cc af desc more) = cc;

afb :: forall a b c. Non_inf_order_ext a b c -> (a, Nat) -> Nat -> Dependance;
afb (Non_inf_order_ext valid ns cc af desc more) = af;

range_vars_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
range_vars_impl sigma = let {
                          a = mk_subst_domain sigma;
                        } in concatMap (vars_term_list . snd) a;

cc_bound :: forall a b. [a] -> Cond_constraint b a -> Cond_constraint b a;
cc_bound [] c = c;
cc_bound (x : xs) c = CC_all x (cc_bound xs c);

cc_ih_prems ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) ->
                 b -> Term b a ->
                        [a] ->
                          [Cond_constraint b a] ->
                            Cond_constraint b a ->
                              [(Term b a, [a])] -> [Cond_constraint b a];
cc_ih_prems fresh f q xs phi psi rs_ys_list =
  map (\ (r, ys) ->
        let {
          rs = args r;
          mu = mk_subst Var (zip xs rs);
          vs = range_vars_impl (zip xs rs);
          mua = (\ c -> cc_subst_apply fresh c (mu, vs));
          a = CC_impl (CC_rewr r (subst_apply_term q mu) : map mua phi)
                (mua psi);
        } in cc_bound ys a)
    rs_ys_list;

cc_rule_constraint ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) ->
                 b -> [Term b a] ->
                        Term b a ->
                          Term b a ->
                            [a] ->
                              [Cond_constraint b a] ->
                                Cond_constraint b a ->
                                  [(Term b a, [a])] -> Cond_constraint b a;
cc_rule_constraint fresh f ls r q xs phi psi rs_ys_list =
  let {
    sigma = mk_subst Var (zip xs ls);
    vs = range_vars_impl (zip xs ls);
    rew = CC_rewr r (subst_apply_term q sigma);
    phi_sig = map (\ c -> cc_subst_apply fresh c (sigma, vs)) phi;
    psi_sig = cc_subst_apply fresh psi (sigma, vs);
    ihs = cc_ih_prems fresh f q xs phi psi rs_ys_list;
  } in CC_impl (rew : phi_sig ++ ihs) psi_sig;

cc_unbound :: forall a b. Cond_constraint a b -> ([b], Cond_constraint a b);
cc_unbound (CC_all x c) = let {
                            (xs, a) = cc_unbound c;
                          } in (x : xs, a);
cc_unbound (CC_cond v va) = ([], CC_cond v va);
cc_unbound (CC_rewr v va) = ([], CC_rewr v va);
cc_unbound (CC_impl v va) = ([], CC_impl v va);

funas_args_term_list :: forall a b. Term a b -> [(a, Nat)];
funas_args_term_list t = concatMap funas_term_list (args t);

check_rys ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> Bool) ->
                    Maybe (a, Nat) ->
                      Term a b ->
                        (Term a b, [b]) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rys d rt r rys =
  let {
    (ra, ys) = rys;
  } in bindb (check (root ra == rt)
               (shows_string ['r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
                 shows_prec_term zero_nat ra .
                   shows_string [' ', 'i', 's', ' ', 'n', 'o', 't', ' '] .
                     shows_prec_prod zero_nat (the rt)))
         (\ _ ->
           bindb (check (equal_term r ra || supt_impl r ra)
                   (shows_prec_term zero_nat ra .
                     shows_string
                       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's',
                         'u', 'b', 't', 'e', 'r', 'm', ' ', 'o', 'f', ' '] .
                       shows_prec_term zero_nat r))
             (\ _ ->
               bindb (catch_errora
                       (forallM
                         (\ f ->
                           check (not (d f))
                             (shows_string
                                ['t', 'h', 'e', ' ', 'd', 'e', 'f', 'i', 'n',
                                  'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l',
                                  ' '] .
                               shows_prec_prod zero_nat f .
                                 shows_string
                                   [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 'i',
                                     'n', ' ', 't', 'h', 'e', ' ', 's', 'u',
                                     'b', 't', 'e', 'r', 'm', ' '] .
                                   shows_prec_term zero_nat ra .
                                     shows_prec_list zero_nat
                                       [' ', 'o', 'f', ' ', 't', 'h', 'e', ' ',
 'r', 'h', 's']))
                         (funas_args_term_list ra))
                       (\ x -> Inl (snd x)))
                 (\ _ ->
                   catch_errora (check_disjoint ys (vars_term_list r))
                     (\ x ->
                       Inl (shows_prec zero_nat x .
                             shows_string
                               [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 'i',
                                 'n', ' '] .
                               shows_prec_term zero_nat r)))));

shows_cc_aux ::
  forall a b.
    (Showa a,
      Showa b) => Bool ->
                    Cond_constraint a b -> [Prelude.Char] -> [Prelude.Char];
shows_cc_aux b (CC_rewr s t) =
  shows_prec_term zero_nat s .
    shows_prec_list zero_nat [' ', '=', ' '] . shows_prec_term zero_nat t;
shows_cc_aux b (CC_cond stri (s, t)) =
  shows_prec_term zero_nat s .
    shows_prec_list zero_nat
      (if stri then [' ', '>', ' '] else [' ', '>', '=', ' ']) .
      shows_prec_term zero_nat t;
shows_cc_aux b (CC_all x c) =
  let {
    s = shows_prec_list zero_nat ['A', 'L', 'L', ' '] .
          shows_prec zero_nat x .
            shows_prec_list zero_nat ['.', ' '] . shows_cc_aux False c;
  } in (if b then shows_prec_list zero_nat ['('] .
                    s . shows_prec_list zero_nat [')']
         else s);
shows_cc_aux b (CC_impl cs c2) =
  shows_string ['('] .
    shows_list_gen (shows_cc_aux True) ['T', 'r', 'u', 'e'] []
      [' ', 'a', 'n', 'd', ' '] [] cs .
      shows_prec_list zero_nat [' ', '=', '>', ' '] .
        shows_cc_aux True c2 . shows_prec_list zero_nat [')'];

shows_cc ::
  forall a b.
    (Showa a,
      Showa b) => Cond_constraint a b -> [Prelude.Char] -> [Prelude.Char];
shows_cc = shows_cc_aux False;

prems_of :: forall a b. Cond_constraint a b -> [Cond_constraint a b];
prems_of (CC_impl c1 c2) = c1;
prems_of (CC_cond v va) = [];
prems_of (CC_rewr v va) = [];
prems_of (CC_all v va) = [];

concl_of :: forall a b. Cond_constraint a b -> Cond_constraint a b;
concl_of (CC_impl c1 c2) = c2;
concl_of (CC_cond v va) = CC_cond v va;
concl_of (CC_rewr v va) = CC_rewr v va;
concl_of (CC_all v va) = CC_all v va;

normalize_cc :: forall a b. Cond_constraint a b -> Cond_constraint a b;
normalize_cc c = CC_impl (prems_of c) (concl_of c);

check_cc_prf ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ((a, Nat) -> Bool) ->
                      [(a, Nat)] ->
                        Bool ->
                          Cond_constraint a [Prelude.Char] ->
                            Cond_constraint_prf a [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char])
                                [C_constraint a [Prelude.Char]];
check_cc_prf r d f m_ortho cc Final =
  (case normalize_cc cc of {
    CC_cond _ _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_rewr _ _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_cond stri st) -> Inr [Unconditional_C stri st];
    CC_impl [] (CC_rewr _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_impl _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_all _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond stri uv] (CC_cond stria st) ->
      (if stri == stria then Inr [Conditional_C stri uv st]
        else Inl (shows_prec_list zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f',
                      'i', 'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r',
                      'a', 'i', 'n', 't', ':', ' ', 'd', 'i', 'f', 'f', 'e',
                      'r', 'e', 'n', 't', ' ', 'r', 'e', 'l', 'a', 't', 'i',
                      'o', 'n', 's', ' ', 'f', 'o', 'r', ' ', 'f', 'i', 'n',
                      'a', 'l', 'i', 'z', 'i', 'n', 'g', ' '] .
                   shows_cc cc));
    CC_impl [CC_cond _ _] (CC_rewr _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond _ _] (CC_impl _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond _ _] (CC_all _ _) ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_cond _ _ : _ : _) _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_rewr _ _ : _) _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_impl _ _ : _) _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_all _ _ : _) _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_all _ _ ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
  });
check_cc_prf r da f m_ortho c (Delete_Condition d prf) =
  bindb (check (check_subsumes (fresh_string ['x', 'x']) d c)
          (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'd', 'e',
               'l', 'e', 't', 'e', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'w', 'i', 't', 'c',
               'h', 'i', 'n', 'g', ' ', 'f', 'r', 'o', 'm', ' '] .
            shows_nl .
              shows_cc c .
                shows_string [' ', 't', 'o', ' '] . shows_nl . shows_cc d))
    (\ _ -> check_cc_prf r da f m_ortho d prf);
check_cc_prf r da f m_ortho c (Different_Constructor d) =
  let {
    (CC_impl cs _) = normalize_cc c;
  } in catch_errora
         (bindb
           (check (membera cs d)
             (shows_cc d .
               shows_nl .
                 shows_string
                   ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r', 'e',
                     'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                   shows_cc c))
           (\ _ ->
             (case d of {
               CC_cond _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_rewr (Var _) _ ->
                 Inl (shows_cc d .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_rewr (Fun _ _) (Var _) ->
                 Inl (shows_cc d .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_rewr (Fun fa ss) (Fun g ts) ->
                 bindb (check (not (da (fa, size_list ss)))
                         (shows_prec zero_nat fa .
                           shows_prec_list zero_nat
                             [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e',
                               'd']))
                   (\ _ ->
                     bindb (check
                             (not ((fa, size_list ss) == (g, size_list ts)))
                             (shows_string
                                ['t', 'h', 'e', ' ', 'r', 'o', 'o', 't', ' '] .
                               shows_prec zero_nat fa .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'i', 'd', 'e', 'n', 't',
                                     'i', 'c', 'a', 'l', ' ', 'o', 'n', ' ',
                                     'b', 'o', 't', 'h', ' ', 's', 'i', 'd',
                                     'e', 's']))
                       (\ _ -> Inr []));
               CC_impl _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_all _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
             })))
         (\ x ->
           Inl (shows_string
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'D',
                    'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', ' ', 'C', 'o', 'n',
                    's', 't', 'r', 'u', 'c', 't', 'o', 'r', ' ', 'w', 'i', 't',
                    'h', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o',
                    'n', 'd', 'i', 't', 'i', 'o', 'n', ' '] .
                 shows_cc d .
                   shows_nl .
                     shows_string
                       ['o', 'n', ' ', 'i', 'n', 'p', 'u', 't', ' ', 'c', 'o',
                         'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' '] .
                       shows_nl . shows_cc c . shows_nl . x));
check_cc_prf r da f m_ortho ca (Same_Constructor d c p) =
  let {
    (CC_impl cs con) = normalize_cc ca;
  } in bindb (catch_errora
               (bindb
                 (check (membera cs d)
                   (shows_cc d .
                     shows_nl .
                       shows_string
                         ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r',
                           'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_cc ca))
                 (\ _ ->
                   (case d of {
                     CC_cond _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_rewr (Var _) _ ->
                       Inl (shows_cc d .
                             shows_prec_list zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_rewr (Fun _ _) (Var _) ->
                       Inl (shows_cc d .
                             shows_prec_list zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_rewr (Fun fa ss) (Fun g ts) ->
                       bindb (check (not (da (fa, size_list ss)))
                               (shows_prec zero_nat fa .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n',
                                     'e', 'd']))
                         (\ _ ->
                           bindb (check
                                   ((fa, size_list ss) == (g, size_list ts))
                                   (shows_prec zero_nat fa .
                                     shows_string [' ', 'a', 'n', 'd', ' '] .
                                       shows_prec zero_nat g .
 shows_prec_list zero_nat
   [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i',
     'c', 'a', 'l']))
                             (\ _ ->
                               let {
                                 ds = cs ++
map (\ (a, b) -> CC_rewr a b) (zip ss ts);
                                 db = CC_impl ds con;
                               } in check (check_subsumes
    (fresh_string ['x', 'x']) c db)
                                      (shows_string
 ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ',
   'i', 's', ' '] .
shows_cc c .
  shows_nl .
    shows_string
      ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'w',
        'a', 's', ' '] .
      shows_cc db)));
                     CC_impl _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_all _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                   })))
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'S', 'a', 'm', 'e', ' ', 'C', 'o', 'n', 's', 't', 'r',
                          'u', 'c', 't', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ',
                          'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                          'd', 'i', 't', 'i', 'o', 'n', ' '] .
                       shows_cc d .
                         shows_nl .
                           shows_string
                             [' ', 'w', 'h', 'e', 'n', ' ', 's', 'w', 'i', 't',
                               'c', 'h', 'i', 'n', 'g', ' ', 'f', 'r', 'o', 'm',
                               ' '] .
                             shows_nl .
                               shows_cc ca .
                                 shows_string [' ', 't', 'o', ' '] .
                                   shows_nl . shows_cc c . shows_nl . x)))
         (\ _ -> check_cc_prf r da f m_ortho c p);
check_cc_prf r da f m_ortho c (Variable_Equation x t d p) =
  let {
    (CC_impl cs _) = normalize_cc c;
  } in bindb (catch_errora
               (bindb
                 (check
                   (membera cs (CC_rewr (Var x) t) ||
                     membera cs (CC_rewr t (Var x)) &&
                       ball (funas_term t) (\ fa -> not (da fa)))
                   (shows_string
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                        'i', 'n', 'd', ' '] .
                     shows_cc (CC_rewr (Var x) t) .
                       shows_string
                         [' ', 'o', 'r', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'e',
                           'd', ' ', 'a', 's', ' ', 'a', ' ', 'p', 'r', 'e',
                           'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_nl . shows_cc c))
                 (\ _ ->
                   let {
                     ca = cc_subst_apply (fresh_string ['x', 'x']) c
                            (fun_upd Var x t, vars_term_list t);
                   } in check (check_subsumes (fresh_string ['x', 'x']) d ca)
                          (shows_string
                             ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r',
                               'a', 'i', 'n', 't', ' ', 'i', 's', ' '] .
                            shows_cc d .
                              shows_nl .
                                shows_string
                                  ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c',
                                    't', 'e', 'd', ' ', 'w', 'a', 's', ' '] .
                                  shows_cc ca)))
               (\ xa ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'V', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'E', 'q',
                          'u', 'a', 't', 'i', 'o', 'n', ' ', 'w', 'i', 't', 'h',
                          ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i',
                          'o', 'n', ' '] .
                       shows_prec_list zero_nat x .
                         shows_prec_list zero_nat ['/'] .
                           shows_prec_term zero_nat t .
                             shows_string
                               [' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c',
                                 'h', ' ', 'f', 'r', 'o', 'm'] .
                               shows_nl .
                                 shows_cc c .
                                   shows_nl .
                                     shows_string ['t', 'o'] .
                                       shows_nl . shows_cc d . shows_nl . xa)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho ca (Funarg_Into_Var c i x d p) =
  let {
    (CC_impl cs con) = normalize_cc ca;
  } in bindb (catch_errora
               (bindb
                 (check (membera cs c)
                   (shows_cc c .
                     shows_nl .
                       shows_string
                         ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r',
                           'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_cc ca))
                 (\ _ ->
                   bindb (check (not (membera (vars_cc_list ca) x))
                           (shows_string
                              ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                             shows_prec_list zero_nat x .
                               shows_prec_list zero_nat
                                 [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f',
                                   'r', 'e', 's', 'h']))
                     (\ _ ->
                       (case c of {
                         CC_cond _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Var _) _ ->
                           Inl (shows_cc c .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Fun fa ss) q ->
                           bindb (check (less_nat i (size_list ss))
                                   (shows_prec_list zero_nat
                                     ['i', 'n', 'v', 'a', 'l', 'i', 'd', ' ',
                                       'p', 'o', 's', 'i', 't', 'i', 'o', 'n']))
                             (\ _ ->
                               let {
                                 (bef, (pa, aft)) =
                                   (take i ss, (nth ss i, drop (suc i) ss));
                               } in bindb (catch_errora
    (check_subseteq (funas_term_list pa) f)
    (\ xa ->
      Inl (shows_string
             ['f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 's', 'y', 'm', 'b',
               'o', 'l', ' '] .
            shows_prec_prod zero_nat xa .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
                  'w', 'e', 'd', ' ', 'i', 'n', ' ', 'a', 'r', 'g', 'u', 'm',
                  'e', 'n', 't'])))
                                      (\ _ ->
let {
  px = CC_rewr pa (Var x);
  fq = CC_rewr (Fun fa (bef ++ Var x : aft)) q;
  ds = px : fq : cs;
  daa = CC_impl ds con;
} in check (check_subsumes (fresh_string ['x', 'x']) d daa)
       (shows_string
          ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't',
            ' ', 'i', 's', ' '] .
         shows_cc d .
           shows_nl .
             shows_string
               ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ',
                 'w', 'a', 's', ' '] .
               shows_cc daa)));
                         CC_impl _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_all _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                       }))))
               (\ xa ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'i', 'n', 't', 'r', 'o', 'd', 'u', 'c', 'i', 'n', 'g',
                          ' ', 'f', 'r', 'e', 's', 'h', ' ', 'v', 'a', 'r', 'i',
                          'a', 'b', 'l', 'e', ' '] .
                       shows_prec_list zero_nat x .
                         shows_string [' ', 'o', 'n', ' '] .
                           shows_prec_nat zero_nat (suc i) .
                             shows_string
                               ['-', 't', 'h', ' ', 'a', 'r', 'g', 'u', 'm',
                                 'e', 'n', 't', ' ', 'o', 'f', ' ', 'l', 'h',
                                 's', ' ', 'o', 'f', ' '] .
                               shows_cc c .
                                 shows_string
                                   [' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c',
                                     'h', ' ', 'f', 'r', 'o', 'm', ' '] .
                                   shows_cc ca .
                                     shows_string ['t', 'o'] .
                                       shows_nl . shows_cc d . shows_nl . xa)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho c (Simplify_Condition bc sigma d p) =
  let {
    (CC_impl cs psi) = normalize_cc c;
  } in bindb (catch_errora
               (bindb
                 (check (membera cs bc)
                   (shows_cc bc .
                     shows_nl .
                       shows_string
                         ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r',
                           'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_cc c))
                 (\ _ ->
                   let {
                     (ys, cc) = cc_unbound bc;
                     (phi, psia) = let {
                                     (CC_impl a b) = normalize_cc cc;
                                   } in (a, b);
                     dom_ran = mk_subst_domain sigma;
                   } in bindb (catch_errora
                                (check_subseteq (map fst dom_ran) ys)
                                (\ x ->
                                  Inl (shows_prec_list zero_nat x .
shows_prec_list zero_nat
  [' ', 'i', 's', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'd', 'o', 'm', 'a',
    'i', 'n', ' ', 'o', 'f', ' ', 's', 'i', 'g', 'm', 'a', ',', ' ', 'b', 'u',
    't', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'b', 'o', 'u', 'n', 'd', ' ', 'v',
    'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '])))
                          (\ _ ->
                            bindb (catch_errora
                                    (forallM
                                      (\ fn ->
bindb (check (not (da fn))
        (shows_string ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
          shows_prec_prod zero_nat fn .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                'e', 'd', ' ', 'i', 'n', ' ', 'r', 'a', 'n', 'g', 'e', ' ', 'o',
                'f', ' ', 's', 'i', 'g', 'm', 'a', ',', ' ', 'a', 's', ' ', 'i',
                't', ' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd']))
  (\ _ ->
    check (membera f fn)
      (shows_string ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
        shows_prec_prod zero_nat fn .
          shows_prec_list zero_nat
            [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
              'e', 'd', ' ', 'i', 'n', ' ', 'r', 'a', 'n', 'g', 'e', ' ', 'o',
              'f', ' ', 's', 'i', 'g', 'm', 'a', ',', ' ', 'a', 's', ' ', 'i',
              't', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ',
              'F'])))
                                      (concatMap
(\ x_t -> funas_term_list (snd x_t)) dom_ran))
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                let {
                                  vs = remdups
 (concatMap (\ x_t -> vars_term_list (snd x_t)) dom_ran);
                                  sigmaa =
                                    (\ ca ->
                                      cc_subst_apply (fresh_string ['x', 'x'])
ca (mk_subst Var sigma, vs));
                                } in bindb (catch_errora
     (forallM
       (\ ca ->
         check (any (\ caa ->
                      check_subsumes (fresh_string ['x', 'x']) caa (sigmaa ca))
                 cs)
           (shows_cc (sigmaa ca) .
             shows_nl .
               shows_prec_list zero_nat
                 ['i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'n', 't', 'a',
                   'i', 'n', 'e', 'd', ' ', 'a', 's', ' ', 'p', 'r', 'e', 'm',
                   'i', 's', 'e', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'i',
                   'n', 'p', 'u', 't', ' ', 'i', 'm', 'p', 'l', 'i', 'c', 'a',
                   't', 'i', 'o', 'n']))
       phi)
     (\ x -> Inl (snd x)))
                                       (\ _ ->
 let {
   daa = CC_impl (sigmaa psia : cs) psi;
 } in check (check_subsumes (fresh_string ['x', 'x']) d daa)
        (shows_string
           ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
             't', ' ', 'i', 's', ' '] .
          shows_cc d .
            shows_nl .
              shows_string
                ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
                  ' ', 'w', 'a', 's', ' '] .
                shows_cc daa))))))
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'S', 'i', 'm', 'p', 'l', 'i', 'f', 'y', ' ', 'C', 'o',
                          'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'w', 'i', 't',
                          'h', ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't',
                          'i', 'o', 'n', ' '] .
                       shows_prec_list zero_nat sigma .
                         shows_string [' ', 'o', 'n', ' ', 'I', 'H'] .
                           shows_nl .
                             shows_cc bc .
                               shows_nl .
                                 shows_string
                                   ['t', 'o', ' ', 's', 'w', 'i', 't', 'c', 'h',
                                     ' ', 'f', 'r', 'o', 'm'] .
                                   shows_nl .
                                     shows_cc c .
                                       shows_nl .
 shows_string ['t', 'o'] . shows_nl . shows_cc d . shows_nl . x)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho c (Induction d ccs ihs) =
  let {
    (CC_impl cs ca) = normalize_cc c;
  } in bindb (catch_errora
               (bindb
                 (check m_ortho
                   (shows_prec_list zero_nat
                     ['C', 'R', ' ', 'o', 'r', ' ', 'm', 'i', 'n', 'i', 'm',
                       'a', 'l', 'i', 't', 'y', ' ', 'r', 'e', 'q', 'u', 'i',
                       'r', 'e', 'd']))
                 (\ _ ->
                   bindb (catch_errora
                           (forallM
                             (\ cc ->
                               check (membera cs cc)
                                 (shows_cc cc .
                                   shows_nl .
                                     shows_string
                                       ['i', 's', ' ', 'n', 'o', 't', ' ', 'a',
 ' ', 'p', 'r', 'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                                       shows_cc c))
                             (d : ccs))
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       (case d of {
                         CC_cond _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Var _) _ ->
                           Inl (shows_cc d .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Fun fa xs) q ->
                           let {
                             csa = vars_cc_list
                                     (CC_impl (CC_rewr (Fun fa xs) q : ccs) ca);
                           } in bindb (check
(all is_Var xs && distinct (map the_Var xs))
(shows_prec_list zero_nat
   ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ' ', 'o', 'f', ' '] .
  shows_prec_term zero_nat (Fun fa xs) .
    shows_prec_list zero_nat
      [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'i', 'f', 'f', 'e',
        'r', 'e', 'n', 't', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
                                  (\ _ ->
                                    let {
                                      xsa = map the_Var xs;
                                      rt = root (Fun fa xs);
                                    } in bindb
   (check (is_none (mgu (Fun fa xs) q))
     (shows_prec_list zero_nat
       ['l', 'h', 's', ' ', 'a', 'n', 'd', ' ', 'r', 'h', 's', ' ', 'u', 'n',
         'i', 'f', 'y']))
   (\ _ ->
     bindb (catch_errora
             (forallM
               (\ lr ->
                 check (if root (fst lr) == rt
                         then any (\ lra ->
                                    eq_rule_mod_vars lr lra &&
                                      isOK
(check_disjoint csa (vars_rule_list lra)))
                                (map (\ (ra, _) -> ra) ihs)
                         else True)
                   (shows_prec_list zero_nat
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                        'i', 'n', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
                        'e', ' ', 'r', 'e', 'n', 'a', 'm', 'e', 'd', ' ', 'v',
                        'e', 'r', 's', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 'r',
                        'u', 'l', 'e', ' '] .
                     shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                       [' ', '-', '>', ' '] lr))
               r)
             (\ x -> Inl (snd x)))
       (\ _ ->
         catch_errora
           (forallM
             (\ (a, b) ->
               let {
                 (l, ra) = a;
               } in (\ (rys, (cc, _)) ->
                      catch_errora
                        (let {
                           cca = cc_rule_constraint (fresh_string ['x', 'x']) fa
                                   (args l) ra q xsa ccs ca rys;
                         } in bindb (catch_errora
                                      (forallM (check_rys da rt ra) rys)
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  check (check_subsumes
  (fresh_string ['x', 'x']) cc cca)
                                    (shows_string
                                       ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's',
 't', 'r', 'a', 'i', 'n', 't', ' ', 'i', 's', ' '] .
                                      shows_cc cc .
shows_nl .
  shows_string
    ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'a',
      's', ' '] .
    shows_cc cca)))
                        (\ x ->
                          Inl (shows_string
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                   'n', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a',
                                   'i', 'n', 't', ' ', 'f', 'o', 'r', ' ', 'r',
                                   'u', 'l', 'e', ' '] .
                                shows_rule (shows_prec zero_nat)
                                  (shows_prec_list zero_nat)
                                  [' ', '-', '>', ' '] (l, ra) .
                                  shows_nl . x)))
                 b)
             ihs)
           (\ x -> Inl (snd x)))));
                         CC_impl _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_all _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                       }))))
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'I', 'n', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'r',
                          'u', 'l', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'r', 'e',
                          'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n', 'd', 'i',
                          't', 'i', 'o', 'n', ' '] .
                       shows_cc d .
                         shows_string
                           [' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c', 'h',
                             ' ', 'f', 'r', 'o', 'm'] .
                           shows_nl .
                             shows_cc c .
                               shows_nl .
                                 shows_string ['t', 'o'] .
                                   shows_nl .
                                     shows_list_gen
                                       (\ (_, (_, (cb, _))) ->
 shows_cc cb . shows_nl)
                                       [] [] [] [] ihs .
                                       x)))
         (\ _ ->
           bindb (mapM (\ (_, a) -> let {
                                      (_, aa) = a;
                                      (ab, b) = aa;
                                    } in check_cc_prf r da f m_ortho ab b)
                   ihs)
             (\ fcss -> Inr (concat fcss)));

check_cc_prfs ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ((a, Nat) -> Bool) ->
                      [(a, Nat)] ->
                        Bool ->
                          [(Cond_constraint a [Prelude.Char],
                             (b, Cond_constraint_prf a [Prelude.Char]))] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              [C_constraint a [Prelude.Char]];
check_cc_prfs r d f m_ortho [] = Inr [];
check_cc_prfs r d f m_ortho ((c, (uu, prf)) : cpfs) =
  bindb (check_cc_prf r d f m_ortho c prf)
    (\ l1 -> bindb (check_cc_prfs r d f m_ortho cpfs) (\ l2 -> Inr (l1 ++ l2)));

conditional_general_reduction_pair_proc ::
  forall a b.
    (Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    ([(b, Nat)] -> Non_inf_order_ext b [Prelude.Char] ()) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          Cond_red_pair_prf b [Prelude.Char] ->
                            Bool ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) [a];
conditional_general_reduction_pair_proc i grp pstrict pbound prof merge dpp =
  let {
    (Cond_Red_Pair_Prf c ccs bef aft) = prof;
    p = pairsb i dpp;
    r = rulese i dpp;
    f = remdups
          (funas_trs_list r ++
            funas_args_trs_list p ++ concatMap funas_term_list (qc i dpp));
    rp = grp f;
  } in (case catch_errora
               (bindb (validb rp)
                 (\ _ ->
                   bindb (check (wwf_rulesa i dpp)
                           (shows_prec_list zero_nat
                             ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'w', 'e',
                               'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd', 'n',
                               'e', 's', 's', ' ', 'o', 'f', ' ', 'T', 'R',
                               'S']))
                     (\ _ ->
                       let {
                         is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
                       } in bindb (check_varcond_subset p)
                              (\ _ ->
                                bindb (catch_errora
(forallM
  (\ (l, ra) ->
    bindb (check_no_var l)
      (\ _ -> bindb (check_no_var ra) (\ _ -> check_no_defined_root is_def ra)))
  p)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    let {
                                      ccsa =
map (\ (ca, (uvs, _)) -> (ca, uvs)) ccs;
                                      check_present =
check_constraint_present i dpp c p bef aft ccsa;
                                      (ps, pns) = split_pairsa i dpp pstrict;
                                      (pb, _) = split_pairsa i dpp pbound;
                                      pi = afb rp;
                                      us = usable_rules_gen pi r p;
                                    } in bindb
   (catch_errora (forallM (check_present Strict) ps) (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (catch_errora (forallM (check_present Non_Strict) pns)
             (\ x -> Inl (snd x)))
       (\ _ ->
         bindb (catch_errora (forallM (check_present Bound) pb)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             bindb (check (nFQ_subset_NF_rulesc i dpp)
                     (shows_prec_list zero_nat
                       ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r',
                         'e', 'q', 'u', 'i', 'r', 'e', 'd']))
               (\ _ ->
                 bindb (catch_errora
                         (catch_errora (forallM (nsb rp) us)
                           (\ x -> Inl (snd x)))
                         (\ x ->
                           Inl (shows_string
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                    'h', 'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n',
                                    't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b',
                                    'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
                                 shows_nl . x)))
                   (\ _ ->
                     let {
                       m = minimal i dpp;
                       ortho = isOK (check_weakly_orthogonal r);
                     } in bindb (catch_errora
                                  (check_cc_prfs r
                                    (\ fn -> not (null (rules_mapc i dpp fn))) f
                                    (m || ortho) ccs)
                                  (\ x ->
                                    Inl (shows_string
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'i',
     'm', 'p', 'l', 'i', 'f', 'y', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 'd', 'i',
     't', 'i', 'o', 'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i',
     'n', 't', 's'] .
  shows_nl . x)))
                            (\ fcs ->
                              catch_errora
                                (catch_errora (forallM (cc rp) fcs)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'f', 'i', 'n', 'a', 'l', ' ', '(',
   'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', ')', ' ', 'c', 'o',
   'n', 's', 't', 'r', 'a', 'i', 'n', 't', 's', ' ', 'f', 'o', 'r', ' ', 'p',
   'a', 'i', 'r', 's'] .
shows_nl . x)))))))))))))
               (\ x ->
                 Inl (shows_string
                        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a',
                          'p', 'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'b', 'o',
                          'u', 'n', 'd', 'e', 'd', ' ', 'i', 'n', 'c', 'r', 'e',
                          'a', 's', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                          'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'e',
                          ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g'] .
                       shows_nl . descc rp . shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (if merge
                 then [delete_P_Pwa i dpp (list_inter pstrict pbound)
                         (list_inter pstrict pbound)]
                 else [delete_P_Pwa i dpp pstrict pstrict,
                        delete_P_Pwa i dpp pbound pbound]);
       });

critical_pairs_top_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])];
critical_pairs_top_impl p r =
  concatMap
    (\ (l, ra) ->
      (if is_Var l then []
        else concatMap
               (\ (la, rb) ->
                 (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                         (\ a -> 'y' : a) l la
                   of {
                   Nothing -> [];
                   Just (sigma, tau) ->
                     [(subst_apply_term ra sigma, subst_apply_term rb tau)];
                 }))
               r))
    p;

show_crit_pair ::
  forall a b.
    (Showa a,
      Showa b) => (Term a b, Term a b) -> [Prelude.Char] -> [Prelude.Char];
show_crit_pair lr =
  shows_prec_list zero_nat ['('] .
    shows_prec_term zero_nat (fst lr) .
      shows_prec_list zero_nat [',', ' '] .
        shows_prec_term zero_nat (snd lr) . shows_prec_list zero_nat [')'];

check_critical_pairs_innermost ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_innermost r =
  catch_errora
    (forallM
      (\ (l, ra) ->
        check (equal_term l ra)
          (shows_prec_list zero_nat
             ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', ' ', 'n', 'o',
               'n', '-', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ', 'c', 'r', 'i',
               't', 'i', 'c', 'a', 'l', ' ', 'p', 'a', 'i', 'r', ' '] .
            show_crit_pair (l, ra)))
      (critical_pairs_top_impl r r))
    (\ x -> Inl (snd x));

extract_fresh_var ::
  forall a b.
    [((Term a b, Term a b), (Term a b, Term a b))] ->
      Sum ([Prelude.Char] -> [Prelude.Char]) b;
extract_fresh_var sts =
  (case (case sts of {
          [] -> Nothing;
          (_, (Var _, _)) : _ -> Nothing;
          (_, (Fun _ ss, _)) : _ ->
            (if null ss then Nothing else (case last ss of {
    Var a -> Just a;
    Fun _ _ -> Nothing;
  }));
        })
    of {
    Nothing ->
      Inl (shows_prec_list zero_nat
            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't',
              'r', 'a', 'c', 't', ' ', 'f', 'r', 'e', 's', 'h', ' ', 'v', 'a',
              'r', 'i', 'a', 'b', 'l', 'e', ' ', '(', 'a', 's', ' ', 'l', 'a',
              's', 't', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f',
              'r', 'o', 'm', ' ', 's', 'o', 'm', 'e', ' ', 'l', 'h', 's', ' ',
              'o', 'f', ' ', 'n', 'e', 'w', ' ', 'p', 'a', 'i', 'r', 's', ')']);
    Just a -> Inr a;
  });

extract_ren ::
  forall a b.
    (Eq a) => [((Term a b, Term a b), (Term a b, Term a b))] ->
                Sum ([Prelude.Char] -> [Prelude.Char]) ((a, Nat) -> a);
extract_ren ps_ps =
  bindb (check
          (all (\ (a, b) ->
                 let {
                   (s, t) = a;
                 } in (\ (sa, ta) ->
                        not (is_Var s) &&
                          not (is_Var t) && not (is_Var sa) && not (is_Var ta))
                   b)
            ps_ps)
          (shows_prec_list zero_nat
            ['a', 'l', 'l', ' ', 'l', 'h', 's', 's', ' ', 'a', 'n', 'd', ' ',
              'r', 'h', 's', 's', ' ', 'o', 'f', ' ', 'p', 'a', 'i', 'r', 's',
              ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n', '-',
              'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
    (\ _ ->
      let {
        rt = (\ t -> the (root t));
        pair = (\ s sa -> (rt s, fst (rt sa)));
        pairs =
          (\ (st, sta) -> [pair (fst st) (fst sta), pair (snd st) (snd sta)]);
        ren = map_of (remdups (concatMap pairs ps_ps));
        a = (\ fn -> (case ren fn of {
                       Nothing -> fst fn;
                       Just f -> f;
                     }));
      } in Inr a);

check_drop ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> Term b a ->
                         ((b, Nat) -> b) ->
                           ((Term b a, Term b a), (Term b a, Term b a)) ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_drop x c ren st_st =
  let {
    ((s, t), (sa, ta)) = st_st;
    (Fun f ss) = s;
    (Fun g ts) = t;
  } in bindb (check
               (equal_term sa (Fun (ren (f, size_list ss)) (ss ++ [Var x])))
               (shows_prec_list zero_nat
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'r', 'e',
                    'l', 'a', 't', 'e', ' '] .
                 shows_prec_term zero_nat s .
                   shows_prec_list zero_nat [' ', 'w', 'i', 't', 'h', ' '] .
                     shows_prec_term zero_nat sa))
         (\ _ ->
           let {
             tsa = args ta;
             tsaa = take (minus_nat (size_list tsa) one_nat) tsa;
           } in check (equal_term ta
                         (Fun (ren (g, size_list ts)) (tsaa ++ [Var x])) &&
                        ts == map (\ tb -> subst_apply_term tb (subst x c))
                                tsaa)
                  (shows_prec_list zero_nat
                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'r',
                       'e', 'l', 'a', 't', 'e', ' '] .
                    shows_prec_term zero_nat t .
                      shows_prec_list zero_nat [' ', 'w', 'i', 't', 'h', ' '] .
                        shows_prec_term zero_nat ta));

rwd :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwd (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = rw;

pwb :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pwb (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = pw;

rd :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rd (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = r;

pb :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pb (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = p;

complex_constant_removal_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Complex_constant_removal_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
complex_constant_removal_proc i (Complex_Constant_Removal_Proof c ps) dpp =
  catch_errora
    (let {
       p = pb i dpp;
       pw = pwb i dpp;
       r = rwd i dpp;
       q = qc i dpp;
       pairs = pairsb i dpp;
     } in bindb (extract_fresh_var ps)
            (\ x ->
              bindb (extract_ren ps)
                (\ ren ->
                  let {
                    is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
                    rQs = remdups (map root q);
                  } in bindb (catch_errora
                               (forallM
                                 (\ (s, t) ->
                                   bindb (check_no_var s)
                                     (\ _ ->
                                       bindb (check_no_var t)
 (\ _ ->
   bindb (check_no_defined_root is_def t)
     (\ _ ->
       bindb (check (not (membera (vars_rule_list (s, t)) x))
               (shows_prec_list zero_nat x .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's',
                     'h', ' ', 'f', 'o', 'r', ' ', 'p', 'a', 'i', 'r', ' '] .
                   shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                     [' ', '-', '>', ' '] (s, t)))
         (\ _ ->
           let {
             f = the (root s);
             fa = (ren f, suc (snd f));
           } in bindb (check (not (membera rQs (Just fa)))
                        (shows_prec_list zero_nat
                          ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', ' ', 'd',
                            'e', 'l', 'i', 'v', 'e', 'r', 's', ' ', 'd', 'e',
                            'f', 'i', 'n', 'e', 'd', ' ', 's', 'y', 'm', 'b',
                            'o', 'l', ' ', 'o', 'f', ' ', 'Q']))
                  (\ _ ->
                    check (not (is_def fa))
                      (shows_prec_list zero_nat
                        ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', ' ', 'd', 'e',
                          'l', 'i', 'v', 'e', 'r', 's', ' ', 'd', 'e', 'f', 'i',
                          'n', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ',
                          'o', 'f', ' ', 'R'])))))))
                                 pairs)
                               (\ xa -> Inl (snd xa)))
                         (\ _ ->
                           let {
                             pps = filter (\ st_st -> membera p (fst st_st)) ps;
                             pwps =
                               filter (\ st_st -> membera pw (fst st_st)) ps;
                           } in bindb (catch_errora
(forallM
  (\ st ->
    check (membera (map fst pps) st)
      (shows_prec_list zero_nat
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
           ' ', 'e', 'n', 't', 'r', 'y', ' ', 'f', 'o', 'r', ' ', 'p', 'a', 'i',
           'r', ' '] .
        shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
          [' ', '-', '>', ' '] st))
  p)
(\ xa -> Inl (snd xa)))
                                  (\ _ ->
                                    bindb (catch_errora
    (forallM
      (\ st ->
        check (membera (map fst pwps) st)
          (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
               'd', ' ', 'e', 'n', 't', 'r', 'y', ' ', 'f', 'o', 'r', ' ', 'p',
               'a', 'i', 'r', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
              [' ', '-', '>', ' '] st))
      pw)
    (\ xa -> Inl (snd xa)))
                                      (\ _ ->
bindb (check (ground c)
        (shows_prec_list zero_nat
           ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
          shows_prec_term zero_nat c .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'g', 'r', 'o', 'u', 'n',
                'd']))
  (\ _ ->
    bindb (check (nFQ_subset_NF_rulesc i dpp)
            (shows_prec_list zero_nat
              ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e', 'q',
                'u', 'i', 'r', 'e', 'd']))
      (\ _ ->
        bindb (check (null (rd i dpp))
                (shows_prec_list zero_nat
                  ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's',
                    ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
                    'd']))
          (\ _ ->
            bindb (check (rules_no_left_vara i dpp)
                    (shows_prec_list zero_nat
                      ['r', 'u', 'l', 'e', 's', ' ', 'm', 'a', 'y', ' ', 'n',
                        'o', 't', ' ', 'h', 'a', 'v', 'e', ' ', 'v', 'a', 'r',
                        'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ', 'l',
                        'h', 's', 's']))
              (\ _ ->
                bindb (if is_NF_trs r c then Inr ()
                        else catch_errora (check_critical_pairs_innermost r)
                               (\ xa ->
                                 Inl (shows_prec_list zero_nat
['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's', 'u', 'r', 'e',
  ' ', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e'] .
                                       shows_nl . xa)))
                  (\ _ ->
                    bindb (catch_errora
                            (forallM
                              (\ st_st ->
                                catch_errora (check_drop x c ren st_st)
                                  (\ xa ->
                                    Inl (shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i', 'n', 'd',
     'i', 'n', 'g', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd', 'e',
     'n', 'c', 'e', ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', 'r', 'u', 'l',
     'e', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] (fst st_st) .
    shows_prec_list zero_nat
      [' ', 'a', 'n', 'd', ' ', 'r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
        [' ', '-', '>', ' '] (snd st_st) .
        shows_nl . xa)))
                              ps)
                            (\ xa -> Inl (snd xa)))
                      (\ _ ->
                        Inr (mkd i (nfsc i dpp) (minimal i dpp) (map snd pps)
                              (map snd pwps) q [] r)))))))))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'o',
               'm', 'p', 'l', 'e', 'x', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n',
               't', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'p', 'r', 'o',
               'c', ':', ' '] .
            shows_nl . x));

fun_of_default :: forall a b. (Eq a) => [(a, b)] -> b -> a -> b;
fun_of_default m d = let {
                       mm = map_of m;
                     } in (\ i -> (case mm i of {
                                    Nothing -> d;
                                    Just e -> e;
                                  }));

get_arg :: forall a b. Term a b -> Nat -> Term a b;
get_arg t n =
  (if equal_nat n zero_nat then t else nth (args t) (minus_nat n one_nat));

iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops ::
  forall a b.
    (Linorder a) => Rbt a () -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s =
  (\ c f -> rm_iterateoi (impl_of s) c (f . fst));

g_ball_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> (a -> Bool) -> Bool;
g_ball_dflt_basic_oops_rm_basic_ops s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ c -> c)
    (\ x _ -> p x) True;

subtract_list_sorted :: forall a. (Eq a, Linorder a) => [a] -> [a] -> [a];
subtract_list_sorted (x : xs) (y : ys) =
  (if x == y then subtract_list_sorted xs (y : ys)
    else (if less x y then x : subtract_list_sorted xs (y : ys)
           else subtract_list_sorted (x : xs) ys));
subtract_list_sorted [] ys = [];
subtract_list_sorted (v : va) [] = v : va;

comp :: forall a. (Eq a, Linorder a) => [(a, a)] -> [(a, a)] -> [(a, a)];
comp esa es =
  remdups_sort
    (concatMap
      (\ (x, y) ->
        concatMap (\ (ya, z) -> (if y == ya then [(x, z)] else [])) es)
      esa);

scg_comp ::
  forall a b.
    (Eq b, Linorder b) => (a -> a -> Bool) -> Scg a b -> Scg a b -> Scg a b;
scg_comp conn (Scg pa qa stra wka) (Scg p q str wk) =
  (if not (conn qa p) then Null
    else let {
           strs = remdups_sort (comp stra str ++ comp stra wk ++ comp wka str);
           a = subtract_list_sorted (remdups_sort (comp wka wk)) strs;
         } in Scg pa q strs a);
scg_comp conn Null g = Null;
scg_comp conn (Scg v va vb vc) Null = Null;

generate_scgs ::
  forall a b.
    (Eq a, Eq b,
      Linorder b) => (a -> a -> Bool) -> [Scg a b] -> Scg a b -> [Scg a b];
generate_scgs conn base g =
  filter (\ ga -> not (equal_scg ga Null)) (map (scg_comp conn g) base);

subsumes :: forall a b. (Eq a, Eq b) => Scg a b -> Scg a b -> Bool;
subsumes (Scg pa qa stra wka) (Scg p q str wk) =
  pa == p && qa == q && all (membera str) stra && all (membera (str ++ wk)) wka;
subsumes g Null = True;
subsumes Null (Scg v va vb vc) = False;

in_situ :: forall a b. (Eq b) => Scg a b -> Bool;
in_situ Null = True;
in_situ (Scg p q str wk) = any (\ (a, b) -> a == b) str;

union_list_sorted :: forall a. (Eq a, Ord a) => [a] -> [a] -> [a];
union_list_sorted (x : xs) (y : ys) =
  (if x == y then x : union_list_sorted xs ys
    else (if less x y then x : union_list_sorted xs (y : ys)
           else y : union_list_sorted (x : xs) ys));
union_list_sorted [] ys = ys;
union_list_sorted (v : va) [] = v : va;

combinea :: forall a b. (Eq b, Linorder b) => Scg a b -> Scg a b -> Scg a b;
combinea (Scg pa qa stra wka) (Scg p q str wk) =
  Scg pa qa (union_list_sorted stra str) (union_list_sorted wka wk);
combinea Null s = Null;
combinea (Scg v va vb vc) Null = Null;

sagiv ::
  forall a b. (Eq a, Eq b, Linorder b) => (a -> a -> Bool) -> Scg a b -> Bool;
sagiv conn g =
  (if in_situ g then True
    else let {
           gg = scg_comp conn g g;
         } in (if subsumes gg g then False else sagiv conn (combinea g gg)));

check_SCT ::
  forall a b.
    (Compare_order a, Eq a, Compare_order b,
      Eq b) => (a -> a -> Bool) -> [Scg a b] -> Bool;
check_SCT conn gs =
  g_ball_dflt_basic_oops_rm_basic_ops
    (mk_rtrancl_set (generate_scgs conn gs) gs) (sagiv conn);

sct_subterm_precise_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_precise_proc i gs dpp =
  catch_errora
    (let {
       p = pairsb i dpp;
       is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
       eidg = is_iedg_edge_dpp i dpp;
     } in bindb (catch_errora (check_subseteq p (map fst gs))
                  (\ x ->
                    Inl (shows_string
                           ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n',
                             'o', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a',
                             'n', 'g', 'e', ' ', 'g', 'r', 'a', 'p', 'h', ' ',
                             'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                             'i', 'r', ' '] .
                          shows_rule (shows_prec zero_nat)
                            (shows_prec_list zero_nat) [' ', '-', '>', ' '] x)))
            (\ _ ->
              let {
                gGs = filter (\ g -> membera p (fst g)) gs;
              } in bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                           (shows_prec_list zero_nat
                             ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                               ' ', 'o', 'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                               'o', 's', 't', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                               'e', 'd']))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulese i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ (a, b) ->
                                       let {
 (s, t) = a;
                                       } in
 (\ (stri, nstri) ->
   catch_errora
     (bindb (check_no_var s)
       (\ _ ->
         bindb (check_no_var t)
           (\ _ ->
             bindb (check_no_defined_root is_def t)
               (\ _ ->
                 let {
                   m = size_list (args t);
                   n = size_list (args s);
                 } in bindb (catch_errora
                              (forallM
                                (\ (ia, j) ->
                                  check (less_eq_nat ia n &&
  less_eq_nat j m && isOK (check_supt (get_arg s ia) (get_arg t j)))
                                    (shows_string
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
 'w', 'i', 't', 'h', ' ', 'e', 'd', 'g', 'e', ' '] .
                                      shows_prec_nat zero_nat ia .
shows_string [' ', '|', '>', ' '] . shows_prec_nat zero_nat j . shows_nl))
                                stri)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          catch_errora
                            (forallM
                              (\ (ia, j) ->
                                check (less_eq_nat ia n &&
less_eq_nat j m && isOK (check_supteq (get_arg s ia) (get_arg t j)))
                                  (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'e', 'd', 'g',
                                       'e', ' '] .
                                    shows_prec_nat zero_nat ia .
                                      shows_string [' ', '|', '>', '=', ' '] .
shows_prec_nat zero_nat j . shows_nl))
                              nstri)
                            (\ x -> Inl (snd x)))))))
     (\ x ->
       Inl (shows_string
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
                'p', 'a', 'i', 'r', ' '] .
             shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
               [' ', '-', '>', ' '] (s, t) .
               shows_nl . x)))
 b)
                                     gGs)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               let {
                                 n = size_list p;
                                 nums = upt zero_nat n;
                                 numPs = zip p nums;
                                 num_of = fun_of_default numPs n;
                               } in check (check_SCT
    (\ (_, succs) (uv, _) -> membera succs uv)
    (map (\ (st, (stri, nstri)) ->
           let {
             eidg_st = eidg st;
             ia = num_of st;
             e = (ia, map_filter
                        (\ x ->
                          (if ((eidg_st . fst) . fst) x then Just (snd x)
                            else Nothing))
                        numPs);
           } in Scg e e (remdups_sort stri) (remdups_sort nstri))
      gGs))
                                      (shows_string
 ['s', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'a', 'n', 'a',
   'l', 'y', 's', 'i', 's', ' ', 'f', 'a', 'i', 'l', 'e', 'd'] .
shows_nl))))))
    (\ x ->
      Inl (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
               'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'i', 'z', 'e', '-', 'c',
               'h', 'a', 'n', 'g', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
               'o', 'r', ' ', 'b', 'a', 's', 'e', 'd', ' ', 'o', 'n', ' ', 't',
               'h', 'e', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', '-', 'r', 'e',
               'l', 'a', 't', 'i', 'o', 'n'] .
            shows_nl . x));

sct_subterm_approx_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_approx_proc i gs dpp =
  catch_errora
    (let {
       p = pairsb i dpp;
       is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
     } in bindb (catch_errora (check_subseteq p (map fst gs))
                  (\ x ->
                    Inl (shows_string
                           ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n',
                             'o', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a',
                             'n', 'g', 'e', ' ', 'g', 'r', 'a', 'p', 'h', ' ',
                             'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                             'i', 'r', ' '] .
                          shows_rule (shows_prec zero_nat)
                            (shows_prec_list zero_nat) [' ', '-', '>', ' '] x)))
            (\ _ ->
              let {
                gGs = filter (\ g -> membera p (fst g)) gs;
              } in bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                           (shows_prec_list zero_nat
                             ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                               ' ', 'o', 'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                               'o', 's', 't', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                               'e', 'd']))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulese i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ (a, b) ->
                                       let {
 (s, t) = a;
                                       } in
 (\ (stri, nstri) ->
   catch_errora
     (bindb (check_no_var s)
       (\ _ ->
         bindb (check_no_var t)
           (\ _ ->
             bindb (check_no_defined_root is_def t)
               (\ _ ->
                 let {
                   m = size_list (args t);
                   n = size_list (args s);
                 } in bindb (catch_errora
                              (forallM
                                (\ (ia, j) ->
                                  check (less_eq_nat ia n &&
  less_eq_nat j m && isOK (check_supt (get_arg s ia) (get_arg t j)))
                                    (shows_string
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
 'w', 'i', 't', 'h', ' ', 'e', 'd', 'g', 'e', ' '] .
                                      shows_prec_nat zero_nat ia .
shows_string [' ', '|', '>', ' '] . shows_prec_nat zero_nat j . shows_nl))
                                stri)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          catch_errora
                            (forallM
                              (\ (ia, j) ->
                                check (less_eq_nat ia n &&
less_eq_nat j m && isOK (check_supteq (get_arg s ia) (get_arg t j)))
                                  (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'e', 'd', 'g',
                                       'e', ' '] .
                                    shows_prec_nat zero_nat ia .
                                      shows_string [' ', '|', '>', '=', ' '] .
shows_prec_nat zero_nat j . shows_nl))
                              nstri)
                            (\ x -> Inl (snd x)))))))
     (\ x ->
       Inl (shows_string
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
                'p', 'a', 'i', 'r', ' '] .
             shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
               [' ', '-', '>', ' '] (s, t) .
               shows_nl . x)))
 b)
                                     gGs)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               check (check_SCT (\ (_, g) (h, _) -> g == h)
                                       (remdups
 (map (\ (st, (stri, nstri)) ->
        let {
          e = (the (root (fst st)), the (root (snd st)));
        } in Scg e e (remdups_sort stri) (remdups_sort nstri))
   gGs)))
                                 (shows_string
                                    ['s', 'i', 'z', 'e', '-', 'c', 'h', 'a',
                                      'n', 'g', 'e', ' ', 'a', 'n', 'a', 'l',
                                      'y', 's', 'i', 's', ' ', 'f', 'a', 'i',
                                      'l', 'e', 'd'] .
                                   shows_nl))))))
    (\ x ->
      Inl (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
               'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'i', 'z', 'e', '-', 'c',
               'h', 'a', 'n', 'g', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
               'o', 'r', ' ', 'b', 'a', 's', 'e', 'd', ' ', 'o', 'n', ' ', 't',
               'h', 'e', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', '-', 'r', 'e',
               'l', 'a', 't', 'i', 'o', 'n'] .
            shows_nl . x));

sct_subterm_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_proc i gs dpp =
  (if isOK (sct_subterm_approx_proc i gs dpp) then Inr ()
    else sct_subterm_precise_proc i gs dpp);

sct_entry_to_sts ::
  forall a b c d. a -> Term b c -> [(d, Nat)] -> [(d, Nat)] -> [(a, Term b c)];
sct_entry_to_sts s t stri nstri = let {
                                    a = remdups (map snd (stri ++ nstri));
                                  } in map (\ j -> (s, get_arg t j)) a;

check_sct_entry ::
  forall a b c d e f.
    (Showa a,
      Showa b) => ((a, Nat) -> Bool) ->
                    ((Term a b, Term a b) -> Sum c d) ->
                      ((Term a b, Term a b) -> Sum e f) ->
                        Term a b ->
                          Term a b ->
                            [(Nat, Nat)] ->
                              [(Nat, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sct_entry is_def sa nst s t stri nstri =
  catch_errora
    (bindb (check_no_var s)
      (\ _ ->
        bindb (check_no_var t)
          (\ _ ->
            bindb (check_no_defined_root is_def t)
              (\ _ ->
                let {
                  m = size_list (args t);
                  n = size_list (args s);
                } in bindb (catch_errora
                             (forallM
                               (\ i ->
                                 check (less_eq_nat i n)
                                   (shows_string
                                      ['l', 'e', 'f', 't', '-', 'i', 'n', 'd',
'e', 'x', ' ', 't', 'o', ' ', 'l', 'a', 'r', 'g', 'e'] .
                                     shows_prec_nat zero_nat i . shows_nl))
                               (remdups (map fst (stri ++ nstri))))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM
                                   (\ j ->
                                     check (less_eq_nat j m)
                                       (shows_string
  ['r', 'i', 'g', 'h', 't', '-', 'i', 'n', 'd', 'e', 'x', ' ', 't', 'o', ' ',
    'l', 'a', 'r', 'g', 'e', ' ', 'o', 'r', ' ', 'a', 'r', 'g', 'u', 'm', 'e',
    'n', 't', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 'u', 's', 'a',
    'b', 'l', 'e', '-', 'r', 'u', 'l', 'e', 's', ' ', 'c', 'o', 'n', 'd', 'i',
    't', 'i', 'o', 'n'] .
 shows_prec_nat zero_nat j))
                                   (remdups (map snd (stri ++ nstri))))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             let {
                               _ = args s;
                               _ = args t;
                             } in bindb (catch_errora
  (forallM
    (\ (i, j) ->
      check (isOK (sa (get_arg s i, get_arg t j)))
        (shows_string
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
             'e', 'd', 'g', 'e', ' '] .
          shows_prec_nat zero_nat i .
            shows_string [' ', '-', 'S', '-', '>', ' '] .
              shows_prec_nat zero_nat j))
    stri)
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      catch_errora
(forallM
  (\ (i, j) ->
    check (isOK (nst (get_arg s i, get_arg t j)))
      (shows_string
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 'e',
           'd', 'g', 'e', ' '] .
        shows_prec_nat zero_nat i .
          shows_string [' ', '-', 'N', 'S', '-', '>', ' '] .
            shows_prec_nat zero_nat j))
  nstri)
(\ x -> Inl (snd x)))))))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', 's', ' ', 'w', 'i', 't', 'h',
               ' ', 'D', 'P', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] (s, t) .
              shows_nl . x));

sct_ur_af_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [((Term b [Prelude.Char], Term b [Prelude.Char]),
                         ([(Nat, Nat)], [(Nat, Nat)]))] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_ur_af_proc i rp gs u_opt dpp =
  catch_errora
    (bindb (valid rp)
      (\ _ ->
        let {
          is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
          pi = af rp;
          sa = s rp;
          nsa = ns rp;
          nsta = nst rp;
          p = pairsb i dpp;
          gGs = filter (\ g -> membera p (fst g)) gs;
        } in bindb (catch_errora
                     (forallM (\ (l, _) -> check_no_var l) (rulese i dpp))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (catch_errora
                         (forallM
                           (\ (a, b) ->
                             let {
                               (saa, t) = a;
                             } in (\ (aa, ba) ->
                                    check_sct_entry is_def sa nsta saa t aa ba)
                               b)
                           gGs)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     let {
                       sts = concatMap
                               (\ (a, b) ->
                                 let {
                                   (sb, t) = a;
                                 } in (\ (aa, ba) ->
sct_entry_to_sts sb t aa ba)
                                   b)
                               gGs;
                     } in bindb (smart_usable_rules_checker_impl i dpp pi u_opt
                                  sts)
                            (\ u ->
                              bindb (catch_errora
                                      (catch_errora (forallM nsa u)
(\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
         'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l',
         'e', ' ', 'r', 'u', 'l', 'e', 's'] .
      shows_nl . x)))
                                (\ _ ->
                                  let {
                                    eidg = is_iedg_edge_dpp i dpp;
                                  } in bindb
 (catch_errora (check_subseteq p (map fst gs))
   (\ x ->
     Inl (shows_string
            ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n', 'o', ' ', 's',
              'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'g', 'r',
              'a', 'p', 'h', ' ', 'f', 'o', 'r', ' ', 'D', 'P', ' '] .
           shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
             [' ', '-', '>', ' '] x)))
 (\ _ ->
   let {
     n = size_list p;
     nums = upt zero_nat n;
     numPs = zip p nums;
     num_of = fun_of_default numPs n;
   } in check (check_SCT (\ (_, succs) (uv, _) -> membera succs uv)
                (map (\ (st, (stri, nstri)) ->
                       let {
                         eidg_st = eidg st;
                         ia = num_of st;
                         e = (ia, map_filter
                                    (\ x ->
                                      (if ((eidg_st . fst) . fst) x
then Just (snd x) else Nothing))
                                    numPs);
                       } in Scg e e stri nstri)
                  gGs))
          (shows_string
             ['s', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'a',
               'n', 'a', 'l', 'y', 's', 'i', 's', ' ', 'f', 'a', 'i', 'l', 'e',
               'd'] .
            shows_nl))))))))
    (\ x ->
      Inl (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
               'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'i', 'z', 'e', '-', 'c',
               'h', 'a', 'n', 'g', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
               'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'e', ' ', 'f',
               'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' '] .
            shows_nl .
              desc rp .
                shows_nl .
                  shows_string
                    ['f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                      'o', 'w', 'i', 'n', 'g', ' ', 'r', 'e', 'a', 's', 'o',
                      'n'] .
                    shows_nl . x));

proj_terma ::
  forall a b.
    (Ceq a, Ccompare a, Eq a,
      Eq b) => Status a -> Set (a, Nat) -> Term a b -> Multiset (Term a b);
proj_terma proj f (Var x) = add_mset (Var x) zero_multiset;
proj_terma proj fa (Fun f ts) =
  (if member (f, size_list ts) fa
    then sum_mset
           (mset (map (\ i -> proj_terma proj fa (nth ts i))
                   (status proj (f, size_list ts))))
    else add_mset (Fun f ts) zero_multiset);

weak_supt_mul ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Status a -> Set (a, Nat) -> Term a b -> Term a b -> Bool;
weak_supt_mul =
  (\ proj f s t ->
    multeqp (\ x y -> supt_impl y x) (proj_terma proj f t)
      (proj_terma proj f s));

check_supteqproj_pred ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Showa a, Compare b, Eq b,
      Showa b) => Status a ->
                    Set (a, Nat) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_supteqproj_pred pi f lr =
  check (let {
           (a, b) = lr;
         } in weak_supt_mul pi f a b)
    ((shows_prec_list zero_nat
        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
          'n', 't', ' ', 'r', 'u', 'l', 'e', ' '] .
       shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
         [' ', '-', '>', ' '] lr) .
      shows_prec_list zero_nat
        [' ', 'b', 'y', ' ', 's', 'u', 'p', 't', 'e', 'q', '^', 'm', 'u', 'l']);

strict_supt_mul ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Status a -> Set (a, Nat) -> Term a b -> Term a b -> Bool;
strict_supt_mul =
  (\ proj f s t ->
    multeqp (\ x y -> supt_impl y x) (proj_terma proj f t)
      (proj_terma proj f s) &&
      not (equal_multiset (proj_terma proj f s) (proj_terma proj f t)));

check_suptproj_pred ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Showa a, Compare b, Eq b,
      Showa b) => Status a ->
                    Set (a, Nat) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_suptproj_pred pi f lr =
  check (let {
           (a, b) = lr;
         } in strict_supt_mul pi f a b)
    ((shows_prec_list zero_nat
        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
          'n', 't', ' ', 'r', 'u', 'l', 'e', ' '] .
       shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
         [' ', '-', '>', ' '] lr) .
      shows_prec_list zero_nat
        [' ', 'b', 'y', ' ', 's', 'u', 'p', 't', '^', 'm', 'u', 'l']);

generalized_subterm_proc ::
  forall a b c.
    (Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b, Compare c, Eq c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [((b, Nat), [Nat])] ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generalized_subterm_proc i pi p_remove dpp =
  (case catch_errora
          (let {
             p = pairsb i dpp;
             r = rulese i dpp;
             f = map fst pi;
             ff = set f;
             pi_opt = status_of pi;
           } in bindb (check (null (qc i dpp))
                        (shows_prec_list zero_nat
                          ['c', 'u', 'r', 'r', 'e', 'n', 't', 'l', 'y', ' ',
                            'g', 'e', 'n', 'e', 'r', 'a', 'l', 'i', 'z', 'e',
                            'd', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', ' ',
                            'c', 'r', 'i', 't', 'e', 'r', 'i', 'o', 'n', ' ',
                            'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 's',
                            'u', 'p', 'p', 'o', 'r', 't', ' ', 's', 't', 'r',
                            'a', 't', 'e', 'g', 'i', 'e', 's']))
                  (\ _ ->
                    bindb (check (minimal i dpp)
                            (shows_prec_list zero_nat
                              ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                                ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                      (\ _ ->
                        bindb (check (not (is_none pi_opt))
                                (shows_prec_list zero_nat
                                  ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ',
                                    'f', 'i', 'l', 't', 'e', 'r', ' ', 'l', 'i',
                                    's', 't', 's', ' ', 'i', 'n', 'v', 'a', 'l',
                                    'i', 'd', ' ', 'p', 'o', 's', 'i', 't', 'i',
                                    'o', 'n', 's']))
                          (\ _ ->
                            let {
                              pia = the pi_opt;
                              premove = set p_remove;
                              (ps, pns) =
                                partition (\ lr -> member lr premove) p;
                            } in bindb (catch_errora
 (forallM
   (\ fa ->
     check (not (null (status pia fa)))
       ((shows_prec_list zero_nat
           ['s', 't', 'a', 't', 'u', 's', ' ', 'o', 'f', ' ', 's', 'y', 'm',
             'b', 'o', 'l', ' '] .
          shows_prec_prod zero_nat fa) .
         shows_prec_list zero_nat
           [' ', 'i', 'n', ' ', 'F', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e',
             ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
   f)
 (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (catch_errora
     (forallM
       (\ (l, _) ->
         check (not (is_Var l))
           (shows_prec_list zero_nat
             ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ',
               'l', 'h', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
               'w', 'e', 'd']))
       r)
     (\ x -> Inl (snd x)))
                                       (\ _ ->
 bindb (catch_errora
         (catch_errora
           (forallM (check_supteqproj_pred pia ff)
             (filter (\ lr -> member (the (root (fst lr))) ff) r))
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                    ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'r',
                    'u', 'l', 'e', 's', ' ', 'w', 'i', 't', 'h', ' ', 'r', 'o',
                    'o', 't', ' ', 'i', 'n', ' ', 'F', '\n'] .
                 x)))
   (\ _ ->
     bindb (catch_errora
             (catch_errora (forallM (check_supteqproj_pred pia ff) pns)
               (\ x -> Inl (snd x)))
             (\ x ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                        'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                        ' ', 'D', 'P', 's', '\n'] .
                     x)))
       (\ _ ->
         catch_errora
           (catch_errora (forallM (check_suptproj_pred pia ff) ps)
             (\ x -> Inl (snd x)))
           (\ x ->
             Inl (shows_prec_list zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                      ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ',
                      'D', 'P', 's', '\n'] .
                   x))))))))))
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'u', 'b', 't',
                     'e', 'r', 'm', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                     'r', '\n'] .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp p_remove p_remove);
  });

filter_prec_weight_repr ::
  forall a.
    ((a, Nat) -> Af_entry) ->
      ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
        ([((Filtered a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat);
filter_prec_weight_repr pi (prw, w0) =
  let {
    fprw = filter (\ (fn, _) -> (case pi fn of {
                                  Collapse _ -> False;
                                  AFList _ -> True;
                                }))
             prw;
    mprw =
      map (\ (a, b) ->
            let {
              (f, n) = a;
            } in (\ aa -> ((FPair f n, (case pi (f, n) of {
 Collapse _ -> zero_nat;
 AFList ab -> size_list ab;
                                       })),
                            aa))
              b)
        fprw;
  } in (mprw, w0);

prec_repr_to_status ::
  forall a.
    (Key a) => [((a, Nat), (Nat, Order_tag))] -> (Filtered a, Nat) -> Order_tag;
prec_repr_to_status prs = let {
                            m = ceta_map_of prs;
                          } in (\ (FPair f a, _) -> (case m (f, a) of {
              Nothing -> Lex;
              Just aa -> snd aa;
            }));

prec_repr_to_pr ::
  forall a.
    (Key a) => [((a, Nat), (Nat, Order_tag))] -> (Filtered a, Nat) -> Nat;
prec_repr_to_pr prs = let {
                        m = ceta_map_of prs;
                      } in (\ (FPair f a, _) -> (case m (f, a) of {
          Nothing -> zero_nat;
          Just aa -> fst aa;
        }));

plus_single_mono ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      Bool;
plus_single_mono
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = plus_single_mono;

check_complexity ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_complexity
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = check_complexity;

maxb ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      a -> a -> a;
maxb (Partial_object_ext carrier
       (Monoid_ext mult one
         (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = max;

poly_c_max_inter_bcoeff_strict ::
  forall a b c.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      [(c, Nat)] -> ((c, Nat) -> (a, [a])) -> a;
poly_c_max_inter_bcoeff_strict r f pi =
  foldr (maxb r) (concatMap (\ fn -> snd (pi fn)) f) (zero r);

geq ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      a -> a -> Bool;
geq (Partial_object_ext carrier
      (Monoid_ext mult one
        (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = geq;

poly_c_max_inter_bcoeff ::
  forall a b c.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      [(c, Nat)] -> ((c, Nat) -> (a, [a])) -> a;
poly_c_max_inter_bcoeff r f pi =
  foldr (maxb r)
    (concatMap (\ fn -> filter (\ b -> not (geq r (one r) b)) (snd (pi fn))) f)
    (zero r);

convert_lpoly_complexity ::
  forall a b c d.
    (Eq a) => Partial_object_ext a
                (Monoid_ext a
                  (Ring_ext a
                    (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
                ((c, Nat) -> (a, [a])) ->
                  Complexity_measure c d ->
                    Complexity_class ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
convert_lpoly_complexity r pi cm (Comp_Poly deg) =
  let {
    f = (case cm of {
          Derivational_Complexity f -> f;
          Runtime_Complexity c _ -> c;
        });
    bc = poly_c_max_inter_bcoeff r f pi;
    bca = poly_c_max_inter_bcoeff_strict r f pi;
  } in bindb (check (less_nat zero_nat deg || bca == zero r)
               (shows_prec_list zero_nat
                 ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'c', 'o', 'm',
                   'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'n', 'o', 't', ' ',
                   'f', 'u', 'l', 'l', 'y', ' ', 's', 'u', 'p', 'p', 'o', 'r',
                   't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'l', 'i', 'n', 'e',
                   'a', 'r', ' ', '(', 'p', 'o', 'l', 'y', '/', 'm', 'a', 't',
                   'r', 'i', 'x', ')', '-', 'i', 'n', 't', 'e', 'r', 'p', 'r',
                   'e', 't', 'a', 't', 'i', 'o', 'n', 's']))
         (\ _ -> check_complexity r bc (minus_nat deg one_nat));

check_poly_mono_npsm ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [(c, Nat)] ->
                      [((c, Nat), (a, [a]))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_poly_mono_npsm r f pi =
  bindb (catch_errora
          (forallM
            (\ (a, b) ->
              let {
                (fa, n) = a;
              } in (\ (c, cs) ->
                     catch_errora
                       (bindb
                         (check
                           (if equal_nat n (suc zero_nat) then c == zero r
                             else True)
                           (shows_string
                              ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'p',
                                'a', 'r', 't', ' '] .
                             shows_prec zero_nat c .
                               shows_string
                                 [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ',
                                   '0', ' '] .
                                 shows_nl))
                         (\ _ ->
                           bindb (check (equal_nat n (size_list cs))
                                   (shows_string
                                      ['t', 'h', 'e', ' ', 'a', 'r', 'i', 't',
'y', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 't', 'h', 'e', ' ', 's', 'a', 'm',
'e', ' ', 'a', 's', ' ', 't', 'h', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ',
'o', 'f', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's'] .
                                     shows_nl))
                             (\ _ ->
                               check (less_eq_nat n (suc zero_nat))
                                 (shows_string
                                    ['s', 'y', 'm', 'b', 'o', 'l', ' ', 'h',
                                      'a', 's', ' ', 'a', 'r', 'i', 't', 'y',
                                      ' ', 'l', 'a', 'r', 'g', 'e', 'r', ' ',
                                      't', 'h', 'a', 'n', ' ', '1'] .
                                   shows_nl))))
                       (\ x ->
                         Inl (shows_string
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                  'i', 't', 'h', ' ', 'm', 'o', 'n', 'o', 't',
                                  'o', 'n', 'i', 'c', 'i', 't', 'y', ' ', 'd',
                                  'u', 'e', ' ', 't', 'o', ' ', 'i', 'n', 't',
                                  'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i',
                                  'o', 'n', ' ', 'o', 'f', ' '] .
                               shows_prec zero_nat fa .
                                 shows_string ['/'] .
                                   shows_prec_nat zero_nat n . shows_nl . x)))
                b)
            pi)
          (\ x -> Inl (snd x)))
    (\ _ ->
      catch_errora (check_subseteq f (map fst pi))
        (\ x ->
          Inl (shows_string
                 ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'i', 'n', 't', 'e',
                   'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'f',
                   'o', 'r', ' '] .
                shows_prec_prod zero_nat x . shows_nl)));

arcpos ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Bool;
arcpos
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = arcpos;

carrier :: forall a b. Partial_object_ext a b -> Set a;
carrier (Partial_object_ext carrier more) = carrier;

check_lpoly_coeffs ::
  forall a b c.
    (Ceq a, Ccompare a, Showa a,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [((c, Nat), (a, [a]))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_coeffs r i =
  catch_errora
    (forallM
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ (c, cs) ->
               catch_errora
                 (bindb
                   (check (member c (carrier r))
                     (shows_string
                        ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'p', 'a',
                          'r', 't', ' '] .
                       shows_prec zero_nat c .
                         shows_string
                           [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'w', 'e',
                             'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd'] .
                           shows_nl))
                   (\ _ ->
                     bindb (check (less_eq_nat (size_list cs) n)
                             (shows_string
                                ['n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f',
                                  ' ', 'c', 'o', 'e', 'f', 'f', 'i', 'c', 'i',
                                  'e', 'n', 't', 's', ' ', 'e', 'x', 'c', 'e',
                                  'e', 'd', 's', ' ', 'a', 'r', 'i', 't', 'y',
                                  ' ', 'o', 'f', ' ', 's', 'y', 'm', 'b', 'o',
                                  'l', ' '] .
                               shows_prec zero_nat f))
                       (\ _ ->
                         bindb (check (arcpos r c || any (arcpos r) cs)
                                 (shows_string
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 'f', 'i', 'n', 'd', ' ', 'p',
                                      'o', 's', 'i', 't', 'i', 'v', 'e', ' ',
                                      'e', 'n', 't', 'r', 'y', ' ', 'w', 'h',
                                      'i', 'c', 'h', ' ', 'i', 's', ' ', 'r',
                                      'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ',
                                      'f', 'o', 'r', ' ', 'a', 'r', 'c', 't',
                                      'i', 'c', ' ', 'i', 'n', 't', 'e', 'r',
                                      'p', 'r', 'e', 't', 'a', 't', 'i', 'o',
                                      'n', 's'] .
                                   shows_nl))
                           (\ _ ->
                             catch_errora
                               (forallM
                                 (\ aa ->
                                   check (geq r aa (zero r) &&
   member aa (carrier r))
                                     (shows_string
['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', ' '] .
                                       shows_prec zero_nat aa .
 shows_string
   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd'] .
   shows_nl))
                                 cs)
                               (\ x -> Inl (snd x))))))
                 (\ x ->
                   Inl (shows_string
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                            't', 'h', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r',
                            'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
                            ' '] .
                         shows_prec zero_nat f .
                           shows_string ['/'] .
                             shows_prec_nat zero_nat n . shows_nl . x)))
          b)
      i)
    (\ x -> Inl (snd x));

description ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      [Prelude.Char];
description
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = description;

defaultb ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a;
defaultb
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = defaulta;

to_lpoly_inter ::
  forall a b c.
    (Key c) => Partial_object_ext a
                 (Monoid_ext a
                   (Ring_ext a
                     (Ordered_semiring_ext a
                       (Lpoly_order_semiring_ext a b)))) ->
                 [((c, Nat), (a, [a]))] -> (c, Nat) -> (a, [a]);
to_lpoly_inter r i =
  fun_of_map_fun (ceta_map_of i)
    (\ fn -> (defaultb r, replicate (snd fn) (one r)));

show_pvars ::
  forall a b c.
    (Eq a, Showa a,
      Showa c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                    [(c, a)] -> [[Prelude.Char]];
show_pvars r [] = [];
show_pvars r ((x, c) : vas) =
  (if c == one r then id else shows_prec zero_nat c)
    (shows_prec zero_nat x []) :
    show_pvars r vas;

shows_lpoly ::
  forall a b c.
    (Eq a, Showa a,
      Showa c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                    L_poly c a -> [Prelude.Char] -> [Prelude.Char];
shows_lpoly r (LPoly c cs) =
  (case show_pvars r cs of {
    [] -> shows_prec zero_nat c;
    a : list ->
      (if c == zero r then id
        else shows_prec zero_nat c . shows_string [' ', '+', ' ']) .
        shows_list_gen (shows_prec_list zero_nat) [] [] [' ', '+', ' '] []
          (a : list);
  });

add_var ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 c -> a -> [(c, a)] -> [(c, a)];
add_var r x a [] = [(x, a)];
add_var r x a ((y, b) : vas) =
  (if x == y then let {
                    s = add r a b;
                  } in (if s == zero r then vas else (x, s) : vas)
    else (y, b) : add_var r x a vas);

sum_pvars ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 [(c, a)] -> [(c, a)] -> [(c, a)];
sum_pvars r [] vbs = vbs;
sum_pvars r ((x, a) : vas) vbs =
  (if a == zero r then sum_pvars r vas vbs
    else sum_pvars r vas (add_var r x a vbs));

sum_lpolya ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 L_poly c a -> L_poly c a -> L_poly c a;
sum_lpolya r (LPoly a vas) (LPoly b vbs) =
  LPoly (add r a b) (sum_pvars r vas vbs);

mul_pvars ::
  forall a b c.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                a -> [(c, a)] -> [(c, a)];
mul_pvars r a [] = [];
mul_pvars r a ((x, b) : vas) = let {
                                 p = mult r a b;
                                 res = mul_pvars r a vas;
                               } in (if p == zero r then res else (x, p) : res);

mul_lpoly ::
  forall a b c.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                a -> L_poly c a -> L_poly c a;
mul_lpoly r a (LPoly b vas) = LPoly (mult r a b) (mul_pvars r a vas);

list_prod :: forall a b. Partial_object_ext a (Monoid_ext a b) -> [a] -> a;
list_prod r [] = one r;
list_prod r (x : xs) = mult r x (list_prod r xs);

wf_pvars ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Partial_object_ext a b -> [(c, a)] -> Bool;
wf_pvars r vas = less_eq_set (set (map snd vas)) (carrier r);

wf_lpoly ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Partial_object_ext a b -> L_poly c a -> Bool;
wf_lpoly r (LPoly a vas) = member a (carrier r) && wf_pvars r vas;

pleftI ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq d) => Partial_object_ext a
                 (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                 ((c, Nat) -> (a, [a])) -> Term c d -> L_poly d a;
pleftI r pi (Var x) = LPoly (zero r) [(x, one r)];
pleftI r pi (Fun f ts) =
  let {
    (c, asa) = pi (f, size_list ts);
  } in (case sum_lpolya r (LPoly c [])
               (list_prod
                 (Partial_object_ext (collect (wf_lpoly r))
                   (Monoid_ext (sum_lpolya r) (LPoly (zero r) []) ()))
                 (map (\ at -> mul_lpoly r (fst at) (pleftI r pi (snd at)))
                   (zip asa ts)))
         of {
         LPoly d [] -> LPoly (maxb r (zero r) d) [];
         LPoly d (ab : lista) -> LPoly d (ab : lista);
       });

create_lpoly_repr ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b, Key b,
      Showa b) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a ())))) ->
                    [((b, Nat), (a, [a]))] -> [Prelude.Char] -> [Prelude.Char];
create_lpoly_repr c i =
  let {
    pi = to_lpoly_inter c i;
  } in shows_string
         ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n', 't',
           'e', 'r', 'p', 'r', 'e', 't', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'o',
           'v', 'e', 'r', ' '] .
         shows_string (description c) .
           shows_nl .
             shows_sep
               (\ (f, n) ->
                 let {
                   t = Fun f (map Var
                               (fresh_strings_list ['x', '_'] one_nat [] n));
                 } in shows_string ['P', 'o', 'l', '('] .
                        shows_prec_term zero_nat t .
                          shows_string [')', ' ', '=', ' '] .
                            shows_lpoly c (pleftI c pi t))
               shows_nl (remdups (map fst i));

checkmono ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Bool;
checkmono
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = checkmono;

check_poly_mono ::
  forall a b c.
    (Showa a,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [((c, Nat), (a, [a]))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_poly_mono r =
  (\ xs ->
    catch_errora
      (forallM
        (\ (a, b) ->
          let {
            (f, n) = a;
          } in (\ (c, cs) ->
                 catch_errora
                   (bindb
                     (check (geq r c (zero r))
                       (shows_string
                          ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'p',
                            'a', 'r', 't', ' '] .
                         shows_prec zero_nat c .
                           shows_string
                             [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a',
                               't', ' ', 'l', 'e', 'a', 's', 't', ' '] .
                             shows_prec zero_nat (zero r) . shows_nl))
                     (\ _ ->
                       bindb (check (less_eq_nat n (size_list cs))
                               (shows_string
                                  ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ',
                                    'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ',
                                    'i', 's', ' ', 'i', 'g', 'n', 'o', 'r', 'e',
                                    'd'] .
                                 shows_nl))
                         (\ _ ->
                           catch_errora
                             (forallM
                               (\ d ->
                                 check (checkmono r d)
                                   (shows_string
                                      ['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i',
'e', 'n', 't', ' '] .
                                     shows_prec zero_nat d .
                                       shows_string
 [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd'] .
 shows_nl))
                               cs)
                             (\ x -> Inl (snd x)))))
                   (\ x ->
                     Inl (shows_string
                            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                              't', 'h', ' ', 'm', 'o', 'n', 'o', 't', 'o', 'n',
                              'i', 'c', 'i', 't', 'y', ' ', 'd', 'u', 'e', ' ',
                              't', 'o', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r',
                              'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
                              ' '] .
                           shows_prec zero_nat f .
                             shows_string ['/'] .
                               shows_prec_nat zero_nat n . shows_nl . x)))
            b)
        xs)
      (\ x -> Inl (snd x)));

create_mono_af ::
  forall a b c.
    (Eq a,
      Key c) => Partial_object_ext a
                  (Monoid_ext a
                    (Ring_ext a
                      (Ordered_semiring_ext a
                        (Lpoly_order_semiring_ext a b)))) ->
                  [((c, Nat), (a, [a]))] -> (c, Nat) -> Set Nat;
create_mono_af r i =
  (if plus_single_mono r
    then fun_of_map_funa (ceta_map_of i) (\ (_, n) -> set (upt zero_nat n))
           (\ (c, coeffs) ->
             set (if geq r c (zero r)
                   then concatMap
                          (\ (ca, ia) ->
                            (if ca == one r || checkmono r ca then [ia]
                              else []))
                          (zip coeffs (upt zero_nat (size_list coeffs)))
                   else []))
    else empty_af);

lookup_rest :: forall a b. (Eq a) => a -> [(a, b)] -> Maybe (b, [(a, b)]);
lookup_rest x [] = Nothing;
lookup_rest x ((y, c) : ycs) =
  (if x == y then Just (c, ycs)
    else (case lookup_rest x ycs of {
           Nothing -> Nothing;
           Just (d, yccs) -> Just (d, (y, c) : yccs);
         }));

check_pvars ::
  forall a b c.
    (Showa a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 (a -> a -> Bool) -> [(c, a)] -> [(c, a)] -> Sum c ();
check_pvars r rel vas [] =
  catch_errora (forallM (\ va -> check (rel (snd va) (zero r)) (fst va)) vas)
    (\ x -> Inl (snd x));
check_pvars r rel vas ((x, b) : vbs) =
  let {
    a = (case lookup_rest x vas of {
          Nothing -> (zero r, vas);
          Just a -> let {
                      (aa, ba) = a;
                    } in (aa, ba);
        });
    (aa, vasa) = a;
  } in bindb (check (rel aa b) x) (\ _ -> check_pvars r rel vasa vbs);

check_lpoly_ns ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                    L_poly c a ->
                      L_poly c a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_ns r (LPoly a vas) (LPoly b vbs) =
  catch_errora
    (bindb
      (check (geq r a b)
        (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
            'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 's',
            't', 'a', 'n', 't', ' ', 'p', 'a', 'r', 't', 's']))
      (\ _ ->
        catch_errora (check_pvars r (geq r) vas vbs)
          (\ x ->
            Inl (shows_string
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c',
                     'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', 's', ' ',
                     'o', 'f', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
                     ' '] .
                  shows_prec zero_nat x))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' '] .
            shows_lpoly r (LPoly a vas) .
              shows_string [' ', '>', '=', ' '] .
                shows_lpoly r (LPoly b vbs) . shows_nl . x));

prightI ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq d) => Partial_object_ext a
                 (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                 ((c, Nat) -> (a, [a])) -> Term c d -> L_poly d a;
prightI r pi (Var x) = LPoly (zero r) [(x, one r)];
prightI r pi (Fun f ts) =
  let {
    (c, asa) = pi (f, size_list ts);
    (LPoly d a) =
      sum_lpolya r (LPoly c [])
        (list_prod
          (Partial_object_ext (collect (wf_lpoly r))
            (Monoid_ext (sum_lpolya r) (LPoly (zero r) []) ()))
          (map (\ at -> mul_lpoly r (fst at) (prightI r pi (snd at)))
            (zip asa ts)));
  } in LPoly (maxb r (zero r) d) a;

check_polo_ns ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Showa c, Eq d,
      Showa d) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    ((c, Nat) -> (a, [a])) ->
                      (Term c d, Term c d) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_polo_ns r pi (s, t) =
  let {
    left = pleftI r pi s;
    right = prightI r pi t;
  } in catch_errora (check_lpoly_ns r left right)
         (\ x ->
           Inl (shows_string
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                    's', 'u', 'r', 'e', ' '] .
                 shows_prec_term zero_nat s .
                   shows_string [' ', '>', '=', ' '] .
                     shows_prec_term zero_nat t . shows_nl . x));

gt :: forall a b.
        Partial_object_ext a
          (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
          a -> a -> Bool;
gt (Partial_object_ext carrier
     (Monoid_ext mult one
       (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = gt;

check_lpoly_s ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    L_poly c a ->
                      L_poly c a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_s r (LPoly a vas) (LPoly b vbs) =
  catch_errora
    (bindb
      (check (gt r a b)
        (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
            'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 's',
            't', 'a', 'n', 't', ' ', 'p', 'a', 'r', 't']))
      (\ _ ->
        catch_errora
          (check_pvars r (if plus_single_mono r then geq r else gt r) vas vbs)
          (\ x ->
            Inl (shows_string
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c',
                     'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', 's', ' ',
                     'o', 'f', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
                     ' '] .
                  shows_prec zero_nat x))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' '] .
            shows_lpoly r (LPoly a vas) .
              shows_string [' ', '>', ' '] .
                shows_lpoly r (LPoly b vbs) . shows_nl . x));

check_polo_s ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Showa c, Eq d,
      Showa d) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    ((c, Nat) -> (a, [a])) ->
                      (Term c d, Term c d) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_polo_s r pi (s, t) =
  let {
    left = pleftI r pi s;
    right = prightI r pi t;
  } in catch_errora (check_lpoly_s r left right)
         (\ x ->
           Inl (shows_string
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                    's', 'u', 'r', 'e', ' '] .
                 shows_prec_term zero_nat s .
                   shows_string [' ', '>', ' '] .
                     shows_prec_term zero_nat t . shows_nl . x));

create_af ::
  forall a b c.
    (Eq a,
      Key c) => Partial_object_ext a
                  (Monoid_ext a
                    (Ring_ext a
                      (Ordered_semiring_ext a
                        (Lpoly_order_semiring_ext a b)))) ->
                  [((c, Nat), (a, [a]))] -> (c, Nat) -> Set Nat;
create_af r i =
  fun_of_map_funa (ceta_map_of i) (\ (_, n) -> set (upt zero_nat n))
    (\ (_, coeffs) ->
      set (concatMap (\ (c, ia) -> (if not (c == zero r) then [ia] else []))
            (zip coeffs (upt zero_nat (size_list coeffs)))));

create_poly_redtriple ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b, Key b,
      Showa b, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a ())))) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                      [((b, Nat), (a, [a]))] -> Redtriple_ext b c ();
create_poly_redtriple c cI i =
  let {
    pi = to_lpoly_inter c i;
    ns = check_polo_ns c pi;
  } in Redtriple_ext (bindb cI (\ _ -> check_lpoly_coeffs c i))
         (check_polo_s c pi) ns ns (create_af c i) (create_mono_af c i)
         (\ s_ns_nst ->
           (if plus_single_mono c then check_poly_mono c i
             else check_poly_mono_npsm c (funas_trs_list s_ns_nst) i))
         (create_lpoly_repr c i) (Just (map fst i))
         (if plus_single_mono c then convert_lpoly_complexity c pi
           else no_complexity_check)
         ();

weak_gt_arctic_delta ::
  forall a. (Floor_ceiling a) => Arctic_delta a -> Arctic_delta a -> Bool;
weak_gt_arctic_delta uu MinInfty_delta = True;
weak_gt_arctic_delta MinInfty_delta (Num_arc_delta uv) = False;
weak_gt_arctic_delta (Num_arc_delta x) (Num_arc_delta y) = less y x;

check_poly_strict_mono_discrete ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => (a -> a -> Bool) -> [([(b, Nat)], a)] -> b -> Bool;
check_poly_strict_mono_discrete gt p v =
  check_poly_gt gt
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p)
    p;

check_monom_strict_mono :: forall a. (Eq a) => Bool -> [(a, Nat)] -> a -> Bool;
check_monom_strict_mono pm m v =
  not (null m) &&
    null (tla m) &&
      fst (hda m) == v &&
        (if pm then less_eq_nat one_nat (snd (hda m))
          else equal_nat (snd (hda m)) one_nat);

check_poly_strict_mono ::
  forall a b. (Eq a, Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_strict_mono pm p v =
  any (\ (m, c) -> less_eq onea c && check_monom_strict_mono pm m v) p;

check_poly_strict_mono_smart ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => Bool ->
                 Bool -> (a -> a -> Bool) -> [([(b, Nat)], a)] -> b -> Bool;
check_poly_strict_mono_smart discrete pm gt p v =
  (if discrete then check_poly_strict_mono_discrete gt p v
    else check_poly_strict_mono pm p v);

check_poly_weak_mono_all ::
  forall a b. (Ordered_semiring_0a b) => [([(a, Nat)], b)] -> Bool;
check_poly_weak_mono_all p = all (\ (_, a) -> less_eq zerob a) p;

check_poly_weak_mono_and_pos ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> Bool;
check_poly_weak_mono_and_pos discrete p =
  (if discrete
    then all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&
           less_eq zerob (eval_poly (\ _ -> zerob) p)
    else check_poly_weak_mono_all p);

poly_inter_to_mono_af ::
  forall a b.
    (Eq a, Poly_carrier a,
      Key b) => Bool ->
                  Bool ->
                    (a -> a -> Bool) ->
                      [((b, Nat), [([(Nat, Nat)], a)])] -> (b, Nat) -> Set Nat;
poly_inter_to_mono_af discrete power_mono gt i =
  fun_of_map_fun
    (ceta_map_of
      (map (\ (a, b) ->
             let {
               (f, n) = a;
             } in (\ e ->
                    ((f, n),
                      set (filter
                            (\ ia ->
                              check_poly_weak_mono_and_pos discrete e &&
                                check_poly_strict_mono_smart discrete power_mono
                                  gt e ia)
                            (upt zero_nat n))))
               b)
        i))
    (\ fn -> set (upt zero_nat (snd fn)));

check_poly_inter_list ::
  forall a b.
    (Eq a, Eq b,
      Poly_carrier b) => Bool ->
                           [((a, Nat), [([(Nat, Nat)], b)])] ->
                             Sum (Sum ([Prelude.Char] -> [Prelude.Char])
                                   (a, [([(Nat, Nat)], b)]))
                               ();
check_poly_inter_list discrete i =
  bindb (check (distinct (map fst i))
          (Inl (shows_prec_list zero_nat
                 ['s', 'o', 'm', 'e', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ',
                   'h', 'a', 's', ' ', 't', 'w', 'o', ' ', 'i', 'n', 't', 'e',
                   'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', 's'])))
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM
            (\ x ->
              (if let {
                    (_, a) = x;
                  } in check_poly_weak_mono_and_pos discrete a
                then Inr () else Inl x))
            i)
          (\ x -> Inl (snd x)))
        (\ x -> Inl (let {
                       (a, b) = x;
                     } in let {
                            (f, _) = a;
                          } in (\ p -> Inr (f, p))
                            b)));

less_eq_complexity_class :: Complexity_class -> Complexity_class -> Bool;
less_eq_complexity_class x y = less_eq_nat (degree x) (degree y);

strongly_linear ::
  forall a. (Poly_carrier a) => Nat -> [([(Nat, Nat)], a)] -> a -> Bool;
strongly_linear x p v =
  (if equal_nat x zero_nat then check_ge_v v p
    else let {
           a = poly_split [(minus_nat x one_nat, suc zero_nat)] p;
           (aa, pa) = a;
         } in less_eq aa onea && strongly_linear (minus_nat x one_nat) pa v);

sl_complexity_sig_check ::
  forall a b.
    (Poly_carrier b) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                          b -> [(a, Nat)] -> Sum (a, Nat) ();
sl_complexity_sig_check i v f =
  catch_errora
    (forallM (\ (fa, n) -> check (strongly_linear n (i (fa, n)) v) (fa, n)) f)
    (\ x -> Inl (snd x));

sl_complexity_check ::
  forall a b.
    (Poly_carrier a,
      Showa b) => a -> ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                         [(b, Nat)] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
sl_complexity_check v i f =
  let {
    w = max_v v i f;
  } in catch_errora (sl_complexity_sig_check i w f)
         (\ x ->
           Inl (let {
                  (fa, _) = x;
                } in shows_string ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
                       shows_prec zero_nat fa .
                         shows_prec_list zero_nat
                           [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                             'p', 'o', 's', 's', 'e', 's', 's', ' ', 'a', ' ',
                             's', 't', 'r', 'o', 'n', 'g', 'l', 'y', ' ', 'l',
                             'i', 'n', 'e', 'a', 'r', ' ', 'i', 'n', 't', 'e',
                             'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o',
                             'n']));

nl_complexity_check ::
  forall a b c.
    (Showa a,
      Poly_carrier b) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                           Complexity_measure a c ->
                             Complexity_class ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
nl_complexity_check i (Derivational_Complexity f) cc =
  bindb (sl_complexity_check zerob i f)
    (\ _ ->
      check (less_eq_complexity_class (Comp_Poly one_nat) cc)
        (shows_prec_list zero_nat
          ['c', 'a', 'n', 'n', 'o', 't', ' ', 'd', 'e', 'd', 'u', 'c', 'e', ' ',
            'c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'c', 'o', 'm', 'p',
            'l', 'e', 'x', 'i', 't', 'y', ' ', 'f', 'o', 'r', ' ', 'd', 'e',
            'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'c', 'o',
            'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']));
nl_complexity_check i (Runtime_Complexity c d) (Comp_Poly deg) =
  bindb (sl_complexity_check onea i c)
    (\ _ ->
      catch_errora
        (forallM
          (\ f ->
            check (less_eq_nat (poly_degree (i f)) deg)
              ((shows_prec_list zero_nat
                  ['d', 'e', 'g', 'r', 'e', 'e', ' ', 'o', 'f', ' ', 'i', 'n',
                    't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n',
                    ' ', 'f', 'o', 'r', ' '] .
                 shows_prec_prod zero_nat f) .
                shows_prec_list zero_nat
                  [' ', 'e', 'x', 'c', 'e', 'e', 'd', 's', ' ', 'b', 'o', 'u',
                    'n', 'd', ' ']))
          d)
        (\ x -> Inl (snd x)));

poly_inter_to_af ::
  forall a b.
    (Key a) => [((a, Nat), [([(Nat, Nat)], b)])] -> (a, Nat) -> Set Nat;
poly_inter_to_af i =
  fun_of_map_fun (ceta_map_of (map (\ (fn, e) -> (fn, poly_vars e)) i))
    (\ fn -> set (upt zero_nat (snd fn)));

create_nlpoly_redtriple ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                    a -> (a -> a -> Bool) ->
                           Bool ->
                             Bool ->
                               [((b, Nat), [([(Nat, Nat)], a)])] ->
                                 Redtriple_ext b c ();
create_nlpoly_redtriple cI def gt power_mono discrete i =
  let {
    j = poly_inter_list_to_inter def i;
    x = poly_subst
          (\ n -> poly_of (PVar (['x', '_'] ++ shows_prec_nat zero_nat n [])));
  } in Redtriple_ext
         (bindb cI
           (\ _ ->
             catch_errora (check_poly_inter_list discrete i)
               (\ xa ->
                 Inl (case xa of {
                       Inl a -> id a;
                       Inr (f, p) ->
                         shows_string
                           ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a',
                             't', 'i', 'o', 'n', ' '] .
                           shows_poly (x p) .
                             shows_string [' ', 'o', 'f', ' '] .
                               shows_prec zero_nat f .
                                 shows_string
                                   [' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd',
                                     ' '];
                     }))))
         (check_s gt j) (check_ns j) (check_ns j) (poly_inter_to_af i)
         (poly_inter_to_mono_af discrete power_mono gt i)
         (\ _ ->
           catch_errora
             (catch_errora
               (forallM
                 (\ xa ->
                   (if let {
                         (a, b) = xa;
                       } in let {
                              (_, n) = a;
                            } in (\ p ->
                                   all_interval_nat
                                     (check_poly_strict_mono_smart discrete
                                       power_mono gt p)
                                     zero_nat n)
                              b
                     then Inr () else Inl xa))
                 i)
               (\ xa -> Inl (snd xa)))
             (\ xa ->
               Inl (let {
                      (a, b) = xa;
                    } in let {
                           (f, _) = a;
                         } in (\ p ->
                                shows_string
                                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                    ' ', 'e', 'n', 's', 'u', 'r', 'e', ' ', 'm',
                                    'o', 'n', 'o', 't', 'o', 'n', 'i', 'c', 't',
                                    'y', ' ', 'o', 'f', ' '] .
                                  shows_poly (x p) .
                                    shows_string
                                      [' ', 'a', 's', ' ', 'i', 'n', 't', 'e',
'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                                      shows_prec zero_nat f)
                           b)))
         (shows_string
            ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n',
              't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n'] .
           shows_nl .
             shows_sep
               (\ (a, b) ->
                 let {
                   (f, n) = a;
                 } in (\ p ->
                        shows_string ['P', 'o', 'l', '('] .
                          shows_prec zero_nat f .
                            shows_string ['/'] .
                              shows_prec_nat zero_nat n .
                                shows_string [')', ' ', '=', ' '] .
                                  shows_poly (x p))
                   b)
               shows_nl i)
         (Just (map fst i)) (nl_complexity_check j) ();

pos_arctic_delta :: forall a. (Floor_ceiling a) => Arctic_delta a -> Bool;
pos_arctic_delta MinInfty_delta = False;
pos_arctic_delta (Num_arc_delta n) = less_eq zerob n;

class_ordered_semiring ::
  forall a b.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => Itself a ->
                       (a -> a -> Bool) ->
                         b -> Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a (Ordered_semiring_ext a b)));
class_ordered_semiring a gt b =
  class_semiring a (Ordered_semiring_ext (\ x y -> less_eq y x) gt max b);

class_arc_complexity ::
  forall a. a -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
class_arc_complexity a deg =
  Inl (shows_prec_list zero_nat
        ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'f', 'o', 'r',
          ' ', 'a', 'r', 'c', 't', 'i', 'c', ' ', 's', 'e', 'm', 'i', 'r', 'i',
          'n', 'g', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r',
          't', 'e', 'd']);

class_arc_lpoly_order ::
  forall a.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => a -> (a -> Bool) ->
                            (a -> a -> Bool) ->
                              Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a
                                    (Ordered_semiring_ext a
                                      (Lpoly_order_semiring_ext a ()))));
class_arc_lpoly_order def apos gtt =
  class_ordered_semiring Type gtt
    (Lpoly_order_semiring_ext False def apos (\ _ -> False) (\ _ -> zero_nat)
      class_arc_complexity
      ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n', 't',
        'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'v',
        'e', 'r', ' ', 'a', 'r', 'c', 't', 'i', 'c', ' ', 's', 'e', 'm', 'i',
        'r', 'i', 'n', 'g']
      ());

mat_max :: forall a. (Ord a) => Mat a -> Mat a -> Mat a;
mat_max a b =
  mat (mat_dim_row a) (mat_dim_col a)
    (\ ij -> max (mat_index a ij) (mat_index b ij));

mat_ge :: forall a. (Ord a) => Mat a -> Mat a -> Bool;
mat_ge a b =
  all_interval_nat
    (\ i ->
      all_interval_nat
        (\ j -> less_eq (mat_index b (i, j)) (mat_index a (i, j))) zero_nat
        (mat_dim_col a))
    zero_nat (mat_dim_row a);

mat_comp_all :: forall a. (a -> a -> Bool) -> Mat a -> Mat a -> Bool;
mat_comp_all r a b =
  all_interval_nat
    (\ i ->
      all_interval_nat (\ j -> r (mat_index a (i, j)) (mat_index b (i, j)))
        zero_nat (mat_dim_col a))
    zero_nat (mat_dim_row a);

mat_both_ordered_semiring ::
  forall a b.
    (Ordered_semiring_1 a) => Nat ->
                                (a -> a -> Bool) ->
                                  b -> Partial_object_ext (Mat a)
 (Monoid_ext (Mat a) (Ring_ext (Mat a) (Ordered_semiring_ext (Mat a) b)));
mat_both_ordered_semiring n gt b =
  mat_ring Type n (Ordered_semiring_ext mat_ge (mat_comp_all gt) mat_max b);

mat_default :: forall a. (Zero a) => a -> Nat -> Mat a;
mat_default d n = mat n n (\ (i, j) -> (if equal_nat i j then d else zerob));

mat_arc_complexity ::
  forall a. a -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
mat_arc_complexity m deg =
  Inl (shows_prec_list zero_nat
        ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'f', 'o', 'r',
          ' ', 'a', 'r', 'c', 't', 'i', 'c', ' ', 'm', 'a', 't', 'r', 'i', 'c',
          'e', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
          'e', 'd']);

mat_arc_posI :: forall a. (a -> Bool) -> Mat a -> Bool;
mat_arc_posI ap a = ap (mat_index a (zero_nat, zero_nat));

mat_arc_lpoly_order ::
  forall a.
    (Ordered_semiring_1 a) => Nat ->
                                a -> (a -> Bool) ->
                                       (a -> a -> Bool) ->
 Partial_object_ext (Mat a)
   (Monoid_ext (Mat a)
     (Ring_ext (Mat a)
       (Ordered_semiring_ext (Mat a) (Lpoly_order_semiring_ext (Mat a) ()))));
mat_arc_lpoly_order n def apos gtt =
  mat_both_ordered_semiring n gtt
    (Lpoly_order_semiring_ext False (mat_default def n) (mat_arc_posI apos)
      (\ _ -> False) (\ _ -> zero_nat) mat_arc_complexity
      ['a', 'r', 'c', 't', 'i', 'c', ' ', 'm', 'a', 't', 'r', 'i', 'x', ' ',
        'i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
      ());

check_arc_dimension :: Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_arc_dimension n =
  check (less_nat zero_nat n)
    (shows_prec_list zero_nat
      ['d', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n', ' ', 'm', 'u', 's', 't',
        ' ', 'b', 'e', ' ', 'a', 't', ' ', 'l', 'e', 'a', 's', 't', ' ', '1']);

class_complexity ::
  forall a.
    (Ordered_semiring_1 a) => a -> Nat ->
                                     Sum ([Prelude.Char] -> [Prelude.Char]) ();
class_complexity a deg =
  check (less_eq a onea)
    (shows_prec_list zero_nat
      ['v', 'a', 'l', 'u', 'e', ' ', 'i', 's', ' ', 'l', 'a', 'r', 'g', 'e',
        'r', ' ', 't', 'h', 'a', 'n', ' ', '1']);

class_lpoly_order ::
  forall a.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => a -> (a -> Bool) ->
                            (a -> a -> Bool) ->
                              Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a
                                    (Ordered_semiring_ext a
                                      (Lpoly_order_semiring_ext a ()))));
class_lpoly_order def mon gtt =
  class_ordered_semiring Type gtt
    (Lpoly_order_semiring_ext True def (\ _ -> True) mon (\ _ -> zero_nat)
      class_complexity
      ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n', 't',
        'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
      ());

scf_repr_to_scf ::
  forall a. ((a, Nat) -> Maybe [Nat]) -> (a, Nat) -> Nat -> Nat;
scf_repr_to_scf scf fn i = (case scf fn of {
                             Nothing -> one_nat;
                             Just xs -> nth xs i;
                           });

check_scf_entry ::
  forall a.
    (Showa a) => (a, Nat) ->
                   Maybe [Nat] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_scf_entry fn Nothing = Inr ();
check_scf_entry (f, n) (Just es) =
  catch_errora
    (bindb
      (check (equal_nat (size_list es) n)
        (shows_prec_list zero_nat
           ['n', 'r', ' ', 'o', 'f', ' ', 'e', 'n', 't', 'r', 'i', 'e', 's',
             ' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e', ' '] .
          shows_prec_nat zero_nat n))
      (\ _ ->
        check (all (less_nat zero_nat) es)
          (shows_prec_list zero_nat
            ['a', 'l', 'l', ' ', 'e', 'n', 't', 'r', 'i', 'e', 's', ' ', 'm',
              'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n', '-', 'z', 'e',
              'r', 'o'])))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
               's', 'u', 'b', 't', 'e', 'r', 'm', ' ', 'c', 'o', 'e', 'f', 'f',
               'i', 'c', 'i', 'e', 'n', 't', 's', ' ', 'f', 'o', 'r', ' '] .
            shows_prec_prod zero_nat (f, n) .
              shows_prec_list zero_nat [':', ' '] . x . shows_nl));

prec_weight_repr_to_prec_weight ::
  forall a.
    (Eq a, Key a,
      Showa a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    (Sum ([Prelude.Char] -> [Prelude.Char]) (),
                      ((a, Nat) -> (a, Nat) -> (Bool, Bool),
                        ((a, Nat) -> Nat,
                          (Nat, ([a], (a, Nat) -> Nat -> Nat)))));
prec_weight_repr_to_prec_weight prw_w0 =
  let {
    (prw, w0) = prw_w0;
    prwm = ceta_map_of prw;
    w_fun = fun_of_map_funa prwm (\ _ -> suc w0) (fst . snd);
    p_fun = prec_ext prwm;
    scf_fun = fun_of_map_funa prwm (\ _ -> Nothing) (snd . snd);
    fs = map fst prw;
    cw_okay =
      catch_errora
        (forallM
          (\ fn ->
            check (if equal_nat (snd fn) zero_nat then less_eq_nat w0 (w_fun fn)
                    else True)
              (shows_prec_list zero_nat
                 ['w', 'e', 'i', 'g', 'h', 't', ' ', 'o', 'f', ' ', 'c', 'o',
                   'n', 's', 't', 'a', 'n', 't', ' '] .
                shows_prec zero_nat (fst fn) .
                  shows_prec_list zero_nat
                    [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', 't', ' ',
                      'l', 'e', 'a', 's', 't', ' ', 'w', '0']))
          (map fst prw))
        (\ x -> Inl (snd x));
    adm = catch_errora
            (forallM
              (\ fn ->
                check (if equal_nat (snd fn) one_nat
                        then (if equal_nat (w_fun fn) zero_nat
                               then all (snd . p_fun fn) fs else True)
                        else True)
                  (shows_prec_list zero_nat
                     ['u', 'n', 'a', 'r', 'y', ' ', 's', 'y', 'm', 'b', 'o',
                       'l', ' '] .
                    shows_prec zero_nat (fst fn) .
                      shows_prec_list zero_nat
                        [' ', 'w', 'i', 't', 'h', ' ', 'w', 'e', 'i', 'g', 'h',
                          't', ' ', '0', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o',
                          't', ' ', 'h', 'a', 'v', 'e', ' ', 'm', 'a', 'x', 'i',
                          'm', 'a', 'l', ' ', 'p', 'r', 'e', 'c', 'e', 'd', 'e',
                          'n', 'c', 'e']))
              (map fst prw))
            (\ x -> Inl (snd x));
    scf_ok =
      catch_errora
        (forallM (\ fn -> check_scf_entry fn (scf_fun fn)) (map fst prw))
        (\ x -> Inl (snd x));
    cs = filter (\ fn -> equal_nat (snd fn) zero_nat && equal_nat (w_fun fn) w0)
           fs;
    lcs = map_filter
            (\ x ->
              (if all (\ c -> snd (p_fun c x)) cs then Just (fst x)
                else Nothing))
            cs;
    ok = bindb (check (less_nat zero_nat w0)
                 (shows_prec_list zero_nat
                   ['w', '0', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'l',
                     'a', 'r', 'g', 'e', 'r', ' ', 't', 'h', 'a', 'n', ' ',
                     '0']))
           (\ _ -> bindb adm (\ _ -> bindb cw_okay (\ _ -> scf_ok)));
  } in (ok, (p_fun, (w_fun, (w0, (lcs, scf_repr_to_scf scf_fun)))));

create_KBO_redtriple ::
  forall a b c.
    (Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => (([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    ([((b, Nat), (Nat, (Nat, Maybe [Nat])))], Nat)) ->
                    ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                      Redtriple_ext b c ();
create_KBO_redtriple f_to_g pr =
  let {
    (ch, (p, (w, (w0, (lcs, scf))))) =
      prec_weight_repr_to_prec_weight (f_to_g pr);
    ns = kbo_nstrict p w w0 (membera lcs) scf;
    s = kbo_strict p w w0 (membera lcs) scf;
  } in Redtriple_ext ch s ns ns full_af full_af (\ _ -> Inr ())
         (shows_kbo_repr pr) (Just []) no_complexity_check ();

check_dimensions ::
  Nat ->
    Nat ->
      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dimensions n sd c =
  bindb c
    (\ _ ->
      check (less_eq_nat sd n && less_nat zero_nat sd)
        (shows_prec_list zero_nat
          ['s', 't', 'r', 'i', 'c', 't', ' ', 'd', 'i', 'm', 'e', 'n', 's', 'i',
            'o', 'n', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', 't',
            ' ', 'l', 'e', 'a', 's', 't', ' ', '1', ' ', 'a', 'n', 'd', ' ',
            'l', 'e', 's', 's', ' ', 't', 'h', 'a', 'n', ' ', 't', 'o', 't',
            'a', 'l', ' ', 'd', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n']));

fpair_f :: forall a. Filtered a -> a;
fpair_f (FPair x1 x2) = x1;

check_mono_afs ::
  forall a.
    (Ceq a, Ccompare a) => Afs a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_mono_afs pi =
  check (mono_afs pi)
    (shows_prec_list zero_nat
      ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f', 'i', 'l', 't', 'e',
        'r', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'm', 'o', 'n', 'o', 't',
        'o', 'n', 'e']);

shows_afs ::
  forall a.
    (Showa a) => [((a, Nat), Af_entry)] -> [Prelude.Char] -> [Prelude.Char];
shows_afs af =
  foldr (\ (a, b) ->
          let {
            (f, n) = a;
          } in (\ e ->
                 (((((shows_prec_list zero_nat ['p', 'i', '('] .
                       shows_prec zero_nat f) .
                      shows_prec_list zero_nat ['/']) .
                     shows_prec_nat zero_nat n) .
                    shows_prec_list zero_nat [')', ' ', '=', ' ']) .
                   (case e of {
                     Collapse i -> shows_prec_nat zero_nat (suc i);
                     AFList ids -> shows_prec_list zero_nat (map suc ids);
                   })) .
                   shows_nl)
            b)
    af;

afs_to_af :: forall a. (Key a) => Afs a -> (a, Nat) -> Set Nat;
afs_to_af pi fn =
  (case afsa pi fn of {
    Collapse j -> inserta j (set_empty (of_phantom set_impl_nat));
    AFList a -> set a;
  });

afs_check ::
  forall a b.
    (Showa a,
      Showa b) => ([Prelude.Char] -> [Prelude.Char]) ->
                    Afs a ->
                      ((Term (Filtered a) b, Term (Filtered a) b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
afs_check r pi g lr =
  let {
    pl = afs_term pi (fst lr);
    pr = afs_term pi (snd lr);
  } in catch_errora (g (pl, pr))
         (\ x ->
           Inl (shows_string
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r',
                    'i', 'e', 'n', 't', ' '] .
                 shows_prec_term zero_nat (fst lr) .
                   shows_string [' '] .
                     r . shows_string [' '] .
                           shows_prec_term zero_nat (snd lr) .
                             shows_nl .
                               shows_string ['p', 'i', '(', ' '] .
                                 shows_prec_term zero_nat (fst lr) .
                                   shows_string [' ', ')', ' ', '=', ' '] .
                                     shows_prec_term zero_nat pl .
                                       shows_nl .
 shows_string ['p', 'i', '(', ' '] .
   shows_prec_term zero_nat (snd lr) .
     shows_string [' ', ')', ' ', '=', ' '] .
       shows_prec_term zero_nat pr . shows_nl . x));

af_redtriple ::
  forall a b.
    (Ceq a, Ccompare a, Key a, Set_impl a, Showa a,
      Showa b) => [((a, Nat), Af_entry)] ->
                    Redtriple_ext (Filtered a) b () -> Redtriple_ext a b ();
af_redtriple pi rp =
  let {
    afso = afs_of pi;
    afs = the afso;
    af = afs_to_af afs;
  } in Redtriple_ext
         (bindb
           (check (not (is_none afso))
             (shows_prec_list zero_nat
               ['i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'p', 'o', 's', 'i', 't',
                 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ', 'a', 'r', 'g', 'u',
                 'm', 'e', 'n', 't', ' ', 'f', 'i', 'l', 't', 'e', 'r']))
           (\ _ -> valid rp))
         (afs_check (shows_prec_list zero_nat ['>']) afs (s rp))
         (afs_check (shows_prec_list zero_nat ['>', '=']) afs (ns rp))
         (afs_check (shows_prec_list zero_nat ['>', '=']) afs (nst rp)) af
         empty_af
         (\ cs ->
           bindb (check_mono_afs afs) (\ _ -> mono rp (map (afs_rule afs) cs)))
         ((((shows_prec_list zero_nat
               ['A', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'F', 'i', 'l', 't',
                 'e', 'r', ':', ' '] .
              shows_nl) .
             shows_afs pi) .
            shows_nl) .
           desc rp)
         (map_option (\ fs -> map fst pi ++ map (\ (f, a) -> (fpair_f f, a)) fs)
           (not_ws_ns rp))
         no_complexity_check ();

pos_arctic :: Arctic -> Bool;
pos_arctic MinInfty = False;
pos_arctic (Num_arc n) = less_eq_int zero_int n;

delta_mono :: forall a. (Floor_ceiling a) => a -> Bool;
delta_mono x = less_eq onea x;

mat_gt ::
  forall a. (Ord a) => (a -> a -> Bool) -> Nat -> Mat a -> Mat a -> Bool;
mat_gt gt sd a b =
  mat_ge a b &&
    not (all_interval_nat
          (not .
            (\ i ->
              not (all_interval_nat
                    (not .
                      (\ j -> gt (mat_index a (i, j)) (mat_index b (i, j))))
                    zero_nat sd)))
          zero_nat sd);

mat_ordered_semiring ::
  forall a b.
    (Ordered_semiring_1 a) => Nat ->
                                Nat ->
                                  (a -> a -> Bool) ->
                                    b -> Partial_object_ext (Mat a)
   (Monoid_ext (Mat a) (Ring_ext (Mat a) (Ordered_semiring_ext (Mat a) b)));
mat_ordered_semiring n sd gt b =
  mat_ring Type n (Ordered_semiring_ext mat_ge (mat_gt gt sd) mat_max b);

eliminate_entries_gen ::
  forall a.
    (a -> a -> a) ->
      (a -> a -> a) -> (Nat -> a) -> Mat a -> Nat -> Nat -> Mat a;
eliminate_entries_gen minus times v a i j =
  mat (mat_dim_row a) (mat_dim_col a)
    (\ (ia, ja) ->
      (if not (equal_nat ia i)
        then minus (mat_index a (ia, ja)) (times (v ia) (mat_index a (i, ja)))
        else mat_index a (ia, ja)));

gauss_jordan_main ::
  forall a. (Field a, Eq a) => Mat a -> Mat a -> Nat -> Nat -> (Mat a, Mat a);
gauss_jordan_main a b i j =
  let {
    nr = mat_dim_row a;
    nc = mat_dim_col a;
  } in (if less_nat i nr && less_nat j nc
         then let {
                aij = mat_index a (i, j);
              } in (if aij == zerob
                     then (case concatMap
                                  (\ ia ->
                                    (if not (mat_index a (ia, j) == zerob)
                                      then [ia] else []))
                                  (upt (suc i) nr)
                            of {
                            [] -> gauss_jordan_main a b i (suc j);
                            ia : _ ->
                              gauss_jordan_main (mat_swaprows i ia a)
                                (mat_swaprows i ia b) i j;
                          })
                     else (if aij == onea
                            then let {
                                   v = (\ ia -> mat_index a (ia, j));
                                 } in gauss_jordan_main
(eliminate_entries_gen minus times v a i j)
(eliminate_entries_gen minus times v b i j) (suc i) (suc j)
                            else let {
                                   iaij = inverse aij;
                                   aa = mat_multrow_gen times i iaij a;
                                   ba = mat_multrow_gen times i iaij b;
                                   v = (\ ia -> mat_index aa (ia, j));
                                 } in gauss_jordan_main
(eliminate_entries_gen minus times v aa i j)
(eliminate_entries_gen minus times v ba i j) (suc i) (suc j)))
         else (a, b));

gauss_jordan :: forall a. (Field a, Eq a) => Mat a -> Mat a -> (Mat a, Mat a);
gauss_jordan a b = gauss_jordan_main a b zero_nat zero_nat;

gauss_jordan_single :: forall a. (Field a, Eq a) => Mat a -> Mat a;
gauss_jordan_single a =
  fst (gauss_jordan a (mat_zero (mat_dim_row a) zero_nat));

kernel_dim :: forall a. (Field a, Eq a) => Mat a -> Nat;
kernel_dim a =
  minus_nat (mat_dim_col a)
    (size_list (pivot_positions_gen zerob (gauss_jordan_single a)));

dim_gen_eigenspace :: forall a. (Field a, Eq a) => Mat a -> a -> Nat -> Nat;
dim_gen_eigenspace a ev k = kernel_dim (mat_pow (char_matrix a ev) k);

compute_set_of_jordan_blocks ::
  forall a. (Field a, Eq a) => Mat a -> a -> [(Nat, a)];
compute_set_of_jordan_blocks a ev =
  let {
    k = order ev (char_poly a);
    asa = map (dim_gen_eigenspace a ev) (upt zero_nat (suc (suc k)));
    aa = map (\ ka ->
               (ka, minus_nat
                      (minus_nat
                        (times_nat (nat_of_integer (2 :: Integer)) (nth asa ka))
                        (nth asa (minus_nat ka one_nat)))
                      (nth asa (suc ka))))
           (upt one_nat (suc k));
  } in map_filter
         (\ x ->
           (if let {
                 (_, c) = x;
               } in not (equal_nat c zero_nat)
             then Just (let {
                          (ka, _) = x;
                        } in (ka, ev))
             else Nothing))
         aa;

analyse_evs ::
  Nat -> Mat Complex -> [Complex] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
analyse_evs d a evs =
  catch_errora
    (forallM
      (\ e ->
        let {
          ns = plus_real (binary_power (re e) (nat_of_integer (2 :: Integer)))
                 (binary_power (im e) (nat_of_integer (2 :: Integer)));
        } in bindb (check (less_eq_real ns one_real)
                     (shows_prec_list zero_nat
                        ['d', 'e', 't', 'e', 'c', 't', 'e', 'd', ' ', 'e', 'i',
                          'g', 'e', 'n', 'v', 'a', 'l', 'u', 'e', ' ', 'w', 'i',
                          't', 'h', ' ', 'n', 'o', 'r', 'm', ' ', '>', ' ', '1',
                          ':', ' '] .
                       shows_prec_complex zero_nat e))
               (\ _ ->
                 (if equal_real ns one_real
                   then catch_errora
                          (forallM
                            (\ (n, _) ->
                              check (less_eq_nat n d)
                                (((shows_prec_list zero_nat
                                     ['d', 'e', 't', 'e', 'c', 't', 'e', 'd',
                                       ' ', 'J', 'o', 'r', 'd', 'a', 'n', '-',
                                       'B', 'l', 'o', 'c', 'k', ' ', 'o', 'f',
                                       ' ', 's', 'i', 'z', 'e', ' '] .
                                    shows_prec_nat zero_nat n) .
                                   shows_prec_list zero_nat
                                     [' ', 'f', 'o', 'r', ' ', 'e', 'i', 'g',
                                       'e', 'n', 'v', 'a', 'l', 'u', 'e',
                                       ' ']) .
                                  shows_prec_complex zero_nat e))
                            (compute_set_of_jordan_blocks a e))
                          (\ x -> Inl (snd x))
                   else Inr ())))
      evs)
    (\ x -> Inl (snd x));

approximate_jordan_blocks_complex_mat ::
  Nat ->
    Maybe [Complex] -> Mat Complex -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
approximate_jordan_blocks_complex_mat d evso a =
  catch_errora
    (bindb
      (check (not (is_none evso))
        (shows_prec_list zero_nat
          ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'd', 'e', 't', 'e',
            'r', 'm', 'i', 'n', 'e', ' ', 'e', 'i', 'g', 'e', 'n', 'v', 'a',
            'l', 'u', 'e', 's']))
      (\ _ -> analyse_evs d a (the evso)))
    (\ x ->
      Inl (((((shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'e',
                   's', 't', 'i', 'm', 'a', 't', 'i', 'n', 'g', ' ', 'g', 'r',
                   'o', 'w', 't', 'h', ' ', 'r', 'a', 't', 'e', ' ', 'o', 'f',
                   ' ', 'm', 'a', 't', 'r', 'i', 'x', '\n'] .
                shows_prec_mat zero_nat a) .
               shows_prec_list zero_nat
                 ['\n', 'w', 'i', 't', 'h', ' ', 'd', 'e', 't', 'e', 'r', 'm',
                   'i', 'n', 'e', 'd', ' ', 'e', 'i', 'g', 'e', 'n', 'v', 'a',
                   'l', 'u', 'e', 's', ' ']) .
              shows_prec_option zero_nat evso) .
             shows_nl) .
            x));

yun_factorization ::
  forall a.
    (Euclidean_ring_gcd a, Field_char_0 a,
      Eq a) => (Poly a -> Poly a -> Poly a) -> Poly a -> (a, [(Poly a, Nat)]);
yun_factorization gcd p =
  (if (case coeffs p of {
        [] -> True;
        _ : _ -> False;
      })
    then (zerob, []) else let {
                            c = coeff p (degreea p);
                            q = smult (inverse c) p;
                          } in (c, yun_monic_factorization gcd q));

gcd_poly_code ::
  forall a. (Factorial_ring_gcd a, Eq a) => Poly a -> Poly a -> Poly a;
gcd_poly_code p q =
  (if (case coeffs p of {
        [] -> True;
        _ : _ -> False;
      })
    then normalize_poly q
    else (if (case coeffs q of {
               [] -> True;
               _ : _ -> False;
             })
           then normalize_poly p
           else smult (gcda (contenta p) (contenta q))
                  (gcd_poly_code_aux (primitive_part p) (primitive_part q))));

gcd_poly ::
  forall a. (Factorial_ring_gcd a, Eq a) => Poly a -> Poly a -> Poly a;
gcd_poly p q = gcd_poly_code p q;

div_field_poly_impl :: forall a. (Field a, Eq a) => Poly a -> Poly a -> Poly a;
div_field_poly_impl f g =
  let {
    cg = coeffs g;
  } in (if null cg then zero_polya
         else let {
                cf = coeffs f;
                ilc = inverse (last cg);
                ch = map (times ilc) cg;
                q = fst (divmod_poly_one_main_list [] (reverse cf) (reverse ch)
                          (minus_nat (plus_nat one_nat (size_list cf))
                            (size_list cg)));
              } in poly_of_list (map (times ilc) q));

sturm_squarefree :: Poly Real -> [Poly Real];
sturm_squarefree p = sturm (div_field_poly_impl p (gcd_poly p (pderiv p)));

poly_inf :: forall a. (Real_normed_vector a) => Poly a -> a;
poly_inf p = sgn (coeff p (degreea p));

sign_changes_inf :: forall a. (Eq a, Real_normed_vector a) => [Poly a] -> Nat;
sign_changes_inf ps =
  minus_nat
    (size_list
      (remdups_adj (filter (\ x -> not (x == zerob)) (map poly_inf ps))))
    one_nat;

sign_changes :: [Poly Real] -> Real -> Nat;
sign_changes ps x =
  minus_nat
    (size_list
      (remdups_adj
        (filter (\ xa -> not (equal_real xa zero_real))
          (map (\ p -> sgn_real (polya p x)) ps))))
    one_nat;

count_roots_above :: Poly Real -> Real -> Nat;
count_roots_above p a =
  let {
    q = pderiv p;
  } in (if equal_poly p zero_polya then zero_nat
         else (if not (equal_real (polya p a) zero_real) ||
                    not (equal_real (polya q a) zero_real)
                then let {
                       ps = sturm p;
                     } in minus_nat (sign_changes ps a) (sign_changes_inf ps)
                else let {
                       ps = sturm_squarefree p;
                     } in minus_nat (sign_changes ps a) (sign_changes_inf ps)));

nonneg_mat :: Mat Real -> Bool;
nonneg_mat a = ball (mat_elements a) (less_eq_real zero_real);

poly_neg_inf :: forall a. (Real_normed_vector a) => Poly a -> a;
poly_neg_inf p =
  (if dvd (nat_of_integer (2 :: Integer)) (degreea p)
    then sgn (coeff p (degreea p)) else uminus (sgn (coeff p (degreea p))));

sign_changes_neg_inf ::
  forall a. (Eq a, Real_normed_vector a) => [Poly a] -> Nat;
sign_changes_neg_inf ps =
  minus_nat
    (size_list
      (remdups_adj (filter (\ x -> not (x == zerob)) (map poly_neg_inf ps))))
    one_nat;

count_roots :: Poly Real -> Nat;
count_roots p =
  (if equal_poly p zero_polya then zero_nat
    else let {
           ps = sturm p;
         } in minus_nat (sign_changes_neg_inf ps) (sign_changes_inf ps));

complexity_via_perron_frobenius :: Nat -> Poly Real -> Mat Real -> Bool;
complexity_via_perron_frobenius d cp a =
  nonneg_mat a &&
    equal_nat (count_roots_above cp one_real) zero_nat &&
      let {
        (_, aa) = yun_factorization gcd_poly cp;
      } in all (\ (f_i, i) ->
                 less_eq_nat (suc i) d ||
                   not (equal_real (polya f_i one_real) zero_real) &&
                     not (equal_real (polya f_i (of_rat (uminus_rat one_rat)))
                           zero_real) &&
                       equal_nat (count_roots f_i) (degreea f_i))
             aa;

count_ones_check :: [Real] -> Nat -> Bool;
count_ones_check diag d =
  all (\ a ->
        let {
          aa = abs_real a;
        } in less_eq_real aa one_real &&
               (if equal_real aa one_real
                 then less_eq_nat (size_list (filter (equal_real a) diag)) d
                 else True))
    diag;

to_rat_radt :: Real_alg_dt -> Maybe Rat;
to_rat_radt (Rationala r) = Just r;
to_rat_radt (Irrational rai) = Nothing;

to_rat_radtc :: Real_alg_dtc -> Maybe Rat;
to_rat_radtc xa = to_rat_radt (rep_real_alg_dtc xa);

to_rat_real_alg_main :: Real_alg -> Maybe Rat;
to_rat_real_alg_main (Abstr_real_alg xa) = to_rat_radtc xa;

is_rat_real_alg :: Real_alg -> Bool;
is_rat_real_alg x = (case to_rat_real_alg_main x of {
                      Nothing -> False;
                      Just _ -> True;
                    });

is_rat_real :: Real -> Bool;
is_rat_real (Real_of x) = is_rat_real_alg x;

is_rat_complex :: Complex -> Bool;
is_rat_complex x = is_rat_real (re x) && equal_real (im x) zero_real;

root_poly_Re :: Poly Rat -> Poly Rat;
root_poly_Re p =
  let {
    np = snd (rat_to_int_poly p);
  } in poly_mult_rat (inverse_rat (of_int (Int_of_integer (2 :: Integer))))
         (map_poly of_int (poly_add_int np np));

root_poly_Im :: Poly Rat -> [Poly Rat];
root_poly_Im p =
  let {
    fs = factors_of_rat_poly
           (map_poly of_int
             (poly_add_int (snd (rat_to_int_poly p))
               (snd (rat_to_int_poly (poly_uminus p)))));
  } in remdups
         (if any (\ f -> equal_rat (case coeffs f of {
                                     [] -> zero_rat;
                                     x : _ -> x;
                                   })
                           zero_rat)
               fs
           then [pCons zero_rat (pCons one_rat zero_polya)] else []) ++
         map (\ f ->
               map_poly of_int
                 (poly_mult_int
                   (pCons (Int_of_integer (1 :: Integer))
                     (pCons zero_int
                       (pCons (Int_of_integer (4 :: Integer)) zero_polya)))
                   (snd (rat_to_int_poly f))))
           fs;

radtc_of_rai :: Real_alg_intern -> Real_alg_dtc;
radtc_of_rai xa = Abs_real_alg_dtc (real_alg_dt xa);

roots_of_radtc :: Poly Rat -> [Real_alg_dtc];
roots_of_radtc p = map radtc_of_rai (roots_of_rai p);

roots_of_real_alg :: Poly Rat -> [Real_alg];
roots_of_real_alg x = map Abstr_real_alg (roots_of_radtc x);

real_roots_of_rat_poly :: Poly Rat -> [Real];
real_roots_of_rat_poly p = map Real_of (roots_of_real_alg p);

sign_changes_inf_rat :: [Poly Rat] -> Nat;
sign_changes_inf_rat ps =
  minus_nat
    (size_list
      (remdups_adj
        (filter (\ x -> not (equal_rat x zero_rat)) (map poly_inf_rat ps))))
    one_nat;

count_roots_rat :: Poly Rat -> Nat;
count_roots_rat p =
  (if equal_poly p zero_polya then zero_nat
    else let {
           ps = sturm_rat p;
         } in minus_nat (sign_changes_neg_inf_rat ps)
                (sign_changes_inf_rat ps));

complex_roots_of_rat_poly3 :: Poly Rat -> [Complex];
complex_roots_of_rat_poly3 p =
  let {
    n = degreea p;
    rr = count_roots_rat p;
    rrts = real_roots_of_rat_poly p;
    rrtsa = (if equal_nat (size_list rrts) rr then rrts else remdups rrts);
    crts = map (\ r -> Complex r zero_real) rrtsa;
  } in (if equal_nat n rr then crts
         else (if equal_nat (minus_nat n rr) (nat_of_integer (2 :: Integer))
                then let {
                       pp = div_field_poly_impl (map_poly of_rat p)
                              (prod_list
                                (map (\ x ->
                                       pCons (uminus_real x)
 (pCons one_real zero_polya))
                                  rrtsa));
                       cpp = map_poly (\ r -> Complex r zero_real) pp;
                     } in crts ++ croots2 cpp
                else let {
                       rp = root_poly_Re p;
                       ip = root_poly_Im p;
                       rxs = real_roots_of_rat_poly rp;
                       ixs = remdups
                               (filter (less_real zero_real)
                                 (concatMap real_roots_of_rat_poly ip));
                       rts = concatMap (\ rx -> map (Complex rx) ixs) rxs;
                       crtsa =
                         filter
                           (\ c ->
                             equal_complex (eval_polya of_rat p c) zero_complex)
                           rts;
                     } in crts ++ crtsa ++ map cnj crtsa));

complex_roots_of_rat_poly_all :: Poly Rat -> [Complex];
complex_roots_of_rat_poly_all p =
  let {
    n = degreea p;
  } in (if less_eq_nat (nat_of_integer (3 :: Integer)) n
         then complex_roots_of_rat_poly3 p
         else (if equal_nat n one_nat then [roots1 (map_poly of_rat p)]
                else (if equal_nat n (nat_of_integer (2 :: Integer))
                       then croots2 (map_poly of_rat p) else [])));

complex_roots_of_rat_poly :: Poly Rat -> [Complex];
complex_roots_of_rat_poly p =
  let {
    a = (if less_eq_nat (nat_of_integer (3 :: Integer)) (degreea p)
          then factors_of_rat_poly p else [p]);
  } in concatMap complex_roots_of_rat_poly_all a;

to_rat_real_alg :: Real_alg -> Rat;
to_rat_real_alg x = (case to_rat_real_alg_main x of {
                      Nothing -> zero_rat;
                      Just q -> q;
                    });

to_rat_real :: Real -> Rat;
to_rat_real (Real_of x) = to_rat_real_alg x;

to_rat_complex :: Complex -> Rat;
to_rat_complex x =
  (if is_rat_real (re x) && equal_real (im x) zero_real then to_rat_real (re x)
    else zero_rat);

roots_of_complex_main :: Poly Complex -> [Complex];
roots_of_complex_main p =
  let {
    n = degreea p;
  } in (if equal_nat n zero_nat then []
         else (if equal_nat n one_nat then [roots1 p]
                else (if equal_nat n (nat_of_integer (2 :: Integer))
                       then croots2 p
                       else complex_roots_of_rat_poly
                              (map_poly to_rat_complex p))));

roots_of_complex_poly :: Poly Complex -> Maybe [Complex];
roots_of_complex_poly p =
  let {
    (c, pis) = yun_factorization gcd_poly p;
  } in (if not (equal_complex c zero_complex) &&
             all (\ (pa, _) ->
                   less_eq_nat (degreea pa) (nat_of_integer (2 :: Integer)) ||
                     all is_rat_complex (coeffs pa))
               pis
         then Just (concatMap (roots_of_complex_main . fst) pis) else Nothing);

of_real :: forall a. (Real_algebra_1 a) => Real -> a;
of_real r = scaleR r onea;

approximate_jordan_blocks_real_mat ::
  [Complex] ->
    [Poly Complex] ->
      Nat -> Mat Real -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
approximate_jordan_blocks_real_mat csamples cpsamples d a =
  (if upper_triangular a
    then let {
           diag = mat_diag a;
         } in (if count_ones_check diag d then Inr ()
                else approximate_jordan_blocks_complex_mat d
                       (Just (map of_real (remdups diag))) (mat_map of_real a))
    else let {
           cp = char_poly a;
         } in (if complexity_via_perron_frobenius d cp a then Inr ()
                else approximate_jordan_blocks_complex_mat d
                       (roots_of_complex_poly (map_poly of_real cp))
                       (mat_map of_real a)));

mat_estimate_complexity_jb ::
  forall a.
    (Large_real_ordered_semiring_1 a) => Nat ->
   Mat a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
mat_estimate_complexity_jb d a =
  let {
    b = mat_map real_of a;
  } in bindb (check (equal_nat (mat_dim_row a) (mat_dim_col a))
               (shows_prec_list zero_nat
                  ['e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 's', 'q', 'u',
                    'a', 'r', 'e', ' ', 'm', 'a', 't', 'r', 'i', 'x', ' ', 'b',
                    'u', 't', ' ', 'g', 'o', 't', ' ', '\n'] .
                 shows_prec_mat zero_nat b))
         (\ _ -> approximate_jordan_blocks_real_mat [] [] d b);

mat_complexity ::
  forall a.
    (Large_real_ordered_semiring_1 a) => Nat ->
   Mat a -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
mat_complexity n m d = mat_estimate_complexity_jb (suc d) m;

mat_mono :: forall a. (a -> Bool) -> Nat -> Mat a -> Bool;
mat_mono mon sd a =
  all_interval_nat
    (\ j ->
      not (all_interval_nat (not . (\ i -> mon (mat_index a (i, j)))) zero_nat
            sd))
    zero_nat sd;

mat_lpoly_order ::
  forall a.
    (Large_real_ordered_semiring_1 a) => Nat ->
   Nat ->
     a -> (a -> Bool) ->
            (a -> a -> Bool) ->
              Partial_object_ext (Mat a)
                (Monoid_ext (Mat a)
                  (Ring_ext (Mat a)
                    (Ordered_semiring_ext (Mat a)
                      (Lpoly_order_semiring_ext (Mat a) ()))));
mat_lpoly_order n sd def mon gtt =
  mat_ordered_semiring n sd gtt
    (Lpoly_order_semiring_ext True (mat_default def n) (\ _ -> True)
      (mat_mono mon sd) (\ _ -> zero_nat) (mat_complexity n)
      ['m', 'a', 't', 'r', 'i', 'x', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r',
        'e', 't', 'a', 't', 'i', 'o', 'n']
      ());

int_mono :: Int -> Bool;
int_mono x = less_eq_int (Int_of_integer (1 :: Integer)) x;

delta_gt :: forall a. (Floor_ceiling a) => a -> a -> a -> Bool;
delta_gt delta = (\ x y -> less_eq delta (minus x y));

check_def_pos ::
  forall a. (Zero a, Ord a) => a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_def_pos d =
  check (less zerob d)
    (shows_prec_list zero_nat
      ['d', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'v', 'a', 'l', 'u', 'e', ' ',
        'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'p', 'o', 's', 'i', 't', 'i',
        'v', 'e']);

rpo_nstrict_unbounded ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                    ((a, Nat) -> Order_tag) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
rpo_nstrict_unbounded pr c =
  (\ (s, t) ->
    check (snd (rpo_unbounded pr c s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term zero_nat s .
          shows_string [' ', '>', '=', 'R', 'P', 'O', ' '] .
            shows_prec_term zero_nat t . shows_nl));

rpo_strict_unbounded ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                    ((a, Nat) -> Order_tag) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
rpo_strict_unbounded pr c =
  (\ (s, t) ->
    check (fst (rpo_unbounded pr c s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term zero_nat s .
          shows_string [' ', '>', 'R', 'P', 'O', ' '] .
            shows_prec_term zero_nat t . shows_nl));

create_RPO_redtriple ::
  forall a b c.
    (Showa a, Eq b, Showa b, Eq c,
      Showa c) => ([((a, Nat), (Nat, Order_tag))] ->
                    ((b, Nat) -> Nat, (b, Nat) -> Order_tag)) ->
                    [((a, Nat), (Nat, Order_tag))] -> Redtriple_ext b c ();
create_RPO_redtriple prec_repr_to_pr pr =
  let {
    (p, tau) = prec_repr_to_pr pr;
    ns = rpo_nstrict_unbounded (prc_nat p, prl_nat p) tau;
  } in Redtriple_ext (Inr ()) (rpo_strict_unbounded (prc_nat p, prl_nat p) tau)
         ns ns full_af full_af (\ _ -> Inr ()) (shows_rpo_repr pr) (Just [])
         no_complexity_check ();

get_redtriple ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => Redtriple_impl a -> Redtriple_ext a [Prelude.Char] ();
get_redtriple (Int_carrier i) =
  create_poly_redtriple
    (class_lpoly_order (Int_of_integer (1 :: Integer)) int_mono
      (\ x y -> less_int y x))
    (Inr ()) i;
get_redtriple (Int_nl_carrier i) =
  create_nlpoly_redtriple (Inr ()) (Int_of_integer (1 :: Integer))
    (\ x y -> less_int y x) True True i;
get_redtriple (Rat_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_rat delta_mono (\ x y -> less_rat y x))
    (check_def_pos one_rat) i;
get_redtriple (Rat_nl_carrier d i) =
  create_nlpoly_redtriple (check_def_pos d) d (delta_gt d)
    (less_eq_rat one_rat d) False i;
get_redtriple (Real_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_real delta_mono (\ x y -> less_real y x))
    (check_def_pos one_real) i;
get_redtriple (Real_nl_carrier d i) =
  create_nlpoly_redtriple (check_def_pos d) d (delta_gt d)
    (less_eq_real one_real d) False i;
get_redtriple (Arctic_carrier i) =
  create_poly_redtriple
    (class_arc_lpoly_order one_arctic pos_arctic (\ x y -> less_arctic y x))
    (Inr ()) i;
get_redtriple (Arctic_rat_carrier i) =
  create_poly_redtriple
    (class_arc_lpoly_order one_arctic_delta pos_arctic_delta
      weak_gt_arctic_delta)
    (Inr ()) i;
get_redtriple (Int_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd (Int_of_integer (1 :: Integer)) int_mono
      (\ x y -> less_int y x))
    (check_dimensions n sd (Inr ())) i;
get_redtriple (Rat_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_rat delta_mono (\ x y -> less_rat y x))
    (check_dimensions n sd (check_def_pos one_rat)) i;
get_redtriple (Real_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_real delta_mono (\ x y -> less_real y x))
    (check_dimensions n sd (check_def_pos one_real)) i;
get_redtriple (Arctic_mat_carrier n i) =
  create_poly_redtriple
    (mat_arc_lpoly_order n one_arctic pos_arctic (\ x y -> less_arctic y x))
    (check_arc_dimension n) i;
get_redtriple (Arctic_rat_mat_carrier n i) =
  create_poly_redtriple
    (mat_arc_lpoly_order n one_arctic_delta pos_arctic_delta
      weak_gt_arctic_delta)
    (check_arc_dimension n) i;
get_redtriple (RPO prec_tau pi) =
  af_redtriple pi
    (create_RPO_redtriple (\ pr -> (prec_repr_to_pr pr, prec_repr_to_status pr))
      prec_tau);
get_redtriple (KBO precw pi) =
  af_redtriple pi
    (create_KBO_redtriple
      (filter_prec_weight_repr
        (fun_of_map_fun (ceta_map_of pi) (\ fn -> default_af_entry (snd fn))))
      precw);
get_redtriple (WPO params rp) = wpo_redtriple (get_redtriple rp) params;

list_ext_name :: List_order_type -> [Prelude.Char];
list_ext_name MS_Ext = ['M', 'S'];
list_ext_name Dms_Ext = ['D', 'M', 'S'];
list_ext_name Min_Ext = ['M', 'I', 'N'];
list_ext_name Max_Ext = ['M', 'A', 'X'];

dms_preprocess :: [[(Nat, (Bool, Bool))]] -> [[(Nat, (Bool, Bool))]];
dms_preprocess p = map (filter (\ (_, a) -> let {
      (aa, b) = a;
    } in aa || b))
                     p;

dms_simplify ::
  Bool -> [Nat] -> [[(Nat, (Bool, Bool))]] -> [[(Nat, (Bool, Bool))]];
dms_simplify stri is p = (if any (\ i -> null (nth p i)) is then [[]] else p);

dms_decide_singletons :: Bool -> Nat -> [(Nat, (Bool, Bool))] -> Bool;
dms_decide_singletons stri n p =
  all_interval_nat
    (\ i ->
      let {
        (j, (s, ns)) = nth p i;
      } in s && not (membera (drop (suc i) p) (j, (False, True))) ||
             ns && not (membera (map fst (drop (suc i) p)) j))
    zero_nat (size_list p) &&
    (if stri
      then not (all_interval_nat
                 (not . (\ j -> not (membera p (j, (False, True))))) zero_nat n)
      else True);

dms_select :: Bool -> [[(Nat, (Bool, Bool))]] -> Nat;
dms_select stri p =
  snd (hda (sort_key fst
             (filter (\ (l, _) -> less_nat one_nat l)
               (zip (map size_list p) (upt zero_nat (size_list p))))));

dms_solve_or_select :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Sum Bool Nat;
dms_solve_or_select stri n p =
  (if all (\ jsns -> less_eq_nat (size_list jsns) one_nat) p
    then Inl (if membera p [] then False
               else dms_decide_singletons stri n (map hda p))
    else Inr (dms_select stri p));

dms_solve :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_solve stri n p =
  (case dms_solve_or_select stri n p of {
    Inl res -> res;
    Inr k ->
      let {
        ksns = nth p k;
      } in dms_solve stri n
             (dms_simplify stri [k] (list_update p k [hda ksns])) ||
             dms_solve stri n
               (dms_simplify stri [k] (list_update p k (tla ksns)));
  });

dms_bool_ex_idx_impl :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_bool_ex_idx_impl stri n p =
  dms_solve stri n
    (dms_simplify stri (upt zero_nat (size_list p)) (dms_preprocess p));

dms_bool_ex_idx :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_bool_ex_idx = dms_bool_ex_idx_impl;

dms_convert ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> [[(Nat, (Bool, Bool))]];
dms_convert f asa bs = let {
                         jbs = zip (upt zero_nat (size_list bs)) bs;
                       } in map (\ a -> map (\ (j, b) -> (j, f a b)) jbs) asa;

dms_order_ext ::
  forall a. Nat -> (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
dms_order_ext n f asa bs =
  let {
    p = dms_convert f asa bs;
    lts = size_list bs;
    len = less_eq_nat lts n || equal_nat (size_list asa) lts;
  } in (len && dms_bool_ex_idx True lts p, len && dms_bool_ex_idx False lts p);

min_set_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
min_set_ext s_ns =
  (\ asa bs ->
    (not (null bs) && all (\ a -> any (\ b -> fst (s_ns a b)) bs) asa,
      all (\ a -> any (\ b -> snd (s_ns a b)) bs) asa));

or2 :: (Bool, Bool) -> (Bool, Bool) -> (Bool, Bool);
or2 a b = (fst a || fst b, snd a || snd b);

mul_ext_impl ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
mul_ext_impl sns [] [] = (False, True);
mul_ext_impl sns [] (v : va) = (False, False);
mul_ext_impl sns (v : va) [] = (True, True);
mul_ext_impl sns (v : va) (y : ys) = mul_ex_dom sns (v : va) [] y ys;

mul_ex_dom ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> a -> [a] -> (Bool, Bool);
mul_ex_dom sns [] xs y ys = (False, False);
mul_ex_dom sns (x : xsa) xs y ys =
  (case sns x y of {
    (True, _) ->
      (if snd (mul_ext_impl sns (xsa ++ xs)
                (filter (\ ya -> not (fst (sns x ya))) ys))
        then (True, True) else mul_ex_dom sns xsa (x : xs) y ys);
    (False, True) ->
      or2 (mul_ext_impl sns (xsa ++ xs) ys) (mul_ex_dom sns xsa (x : xs) y ys);
    (False, False) -> mul_ex_dom sns xsa (x : xs) y ys;
  });

mul_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
mul_ext = mul_ext_impl;

list_ext ::
  forall a.
    Nat ->
      List_order_type -> (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
list_ext uu MS_Ext = mul_ext;
list_ext uv Max_Ext = set_ext;
list_ext uw Min_Ext = min_set_ext;
list_ext n Dms_Ext = dms_order_ext n;

label_s_ns_impl ::
  forall a b.
    (Showa a,
      Showa b) => ((Term a b, Term a b) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    ((Term a b, Term a b) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool);
label_s_ns_impl cS cNS s t =
  let {
    (sa, i) = s;
    (ta, j) = t;
  } in (if isOK (cS (sa, ta)) then (True, True)
         else (if isOK (cNS (sa, ta)) then (less_nat j i, less_eq_nat j i)
                else (False, False)));

nST_label_mul_impl ::
  forall a b.
    (Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    ((a, Nat) -> [(Nat, Nat)]) ->
                      ((Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        ((Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Term a b, Term a b) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
nST_label_mul_impl list_ext af cS cNS st =
  (case st of {
    (Var _, _) ->
      Inl (shows_prec_list zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun _ _, Var _) ->
      Inl (shows_prec_list zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun f ss, Fun g ts) ->
      check (snd (list_ext (label_s_ns_impl cS cNS) (lterms af (Fun f ss))
                   (lterms af (Fun g ts))))
        (shows_prec_list zero_nat
           ['c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e', 'n', 't',
             ' ', 'p', 'a', 'i', 'r', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] st .
            shows_prec_list zero_nat [' ', 'w', 'e', 'a', 'k', 'l', 'y', ':'] .
              shows_nl .
                shows_prec_list zero_nat (lterms af (Fun f ss)) .
                  shows_prec_list zero_nat [' ', '>', '=', 'm', 'u', ' '] .
                    shows_prec_list zero_nat (lterms af (Fun g ts)) .
                      shows_prec_list zero_nat
                        [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                          'b', 'e', ' ', 'e', 'n', 's', 'u', 'r', 'e', 'd']);
  });

s_label_mul_impl ::
  forall a b.
    (Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    ((a, Nat) -> [(Nat, Nat)]) ->
                      ((Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        ((Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Term a b, Term a b) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
s_label_mul_impl list_ext af cS cNS st =
  (case st of {
    (Var _, _) ->
      Inl (shows_prec_list zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun _ _, Var _) ->
      Inl (shows_prec_list zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun f ss, Fun g ts) ->
      check (fst (list_ext (label_s_ns_impl cS cNS) (lterms af (Fun f ss))
                   (lterms af (Fun g ts))))
        (shows_prec_list zero_nat
           ['c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e', 'n', 't',
             ' ', 'p', 'a', 'i', 'r', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] st .
            shows_prec_list zero_nat
              [' ', 's', 't', 'r', 'i', 'c', 't', 'l', 'y', ':'] .
              shows_nl .
                shows_prec_list zero_nat (lterms af (Fun f ss)) .
                  shows_prec_list zero_nat [' ', '>', 'm', 'u', ' '] .
                    shows_prec_list zero_nat (lterms af (Fun g ts)) .
                      shows_prec_list zero_nat
                        [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                          'b', 'e', ' ', 'e', 'n', 's', 'u', 'r', 'e', 'd']);
  });

generate_scnp_rp ::
  forall a b c.
    (Key a, Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    [Prelude.Char] ->
                      [((a, Nat), [(Nat, Nat)])] ->
                        (c -> Redtriple_ext a b ()) ->
                          c -> Root_redtriple_ext a b ();
generate_scnp_rp list_ext list_ext_name afa rti x =
  let {
    rt = rti x;
    afaa = fun_of_map (ceta_map_of afa) [];
    pi = af rt;
    cS = s rt;
    cNS = ns rt;
  } in Root_redtriple_ext (valid rt) (s_label_mul_impl list_ext afaa cS cNS)
         (ns rt) (nST_label_mul_impl list_ext afaa cS cNS) pi
         (scnp_af_to_af afaa pi) (scnp_desc afa list_ext_name . desc rt) ();

get_root_redtriple ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => Root_redtriple_impl a ->
                    Root_redtriple_ext a [Prelude.Char] ();
get_root_redtriple (SCNP typea af rp) =
  generate_scnp_rp (list_ext (scnp_arity af) typea) (list_ext_name typea) af
    get_redtriple rp;

faulty_non_inf_order ::
  forall a b c.
    (Showa b, Showa c) => [Prelude.Char] -> a -> Non_inf_order_ext b c ();
faulty_non_inf_order s f =
  Non_inf_order_ext (Inl (shows_string s)) (\ _ -> Inr ()) (\ _ -> Inr ())
    (\ _ _ -> Wild) id ();

sqrt_real :: Real -> [Real];
sqrt_real x =
  (if less_eq_real zero_real x then let {
                                      y = sqrt x;
                                    } in remdups [y, uminus_real y]
    else []);

check_non_inf_poly_inter_list ::
  forall a b.
    (Eq a, Eq b,
      Poly_carrier b) => Bool ->
                           [(a, Nat)] ->
                             [((a, Nat), [([(Nat, Nat)], b)])] ->
                               Sum (a, [([(Nat, Nat)], b)]) ();
check_non_inf_poly_inter_list discrete f i =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (_, a) = x;
              } in check_poly_weak_mono_and_pos discrete a
            then Inr () else Inl x))
        (filter (\ (fn, _) -> membera f fn) i))
      (\ x -> Inl (snd x)))
    (\ x -> Inl (let {
                   (a, b) = x;
                 } in let {
                        (fa, _) = a;
                      } in (\ aa -> (fa, aa))
                        b));

create_nlpoly_non_inf_order ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                    a -> (a -> a -> Bool) ->
                           Bool ->
                             Bool ->
                               (a -> [a]) ->
                                 [((b, Nat), [([(Nat, Nat)], a)])] ->
                                   [(b, Nat)] -> Non_inf_order_ext b c ();
create_nlpoly_non_inf_order cI def gt power_mono discrete sqrt i f =
  let {
    j = poly_inter_list_to_inter def i;
    x = poly_subst
          (\ n -> poly_of (PVar (['x', '_'] ++ shows_prec_nat zero_nat n [])));
  } in Non_inf_order_ext
         (bindb cI
           (\ _ ->
             catch_errora (check_non_inf_poly_inter_list discrete f i)
               (\ xa ->
                 Inl (let {
                        (fa, p) = xa;
                      } in shows_string
                             ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a',
                               't', 'i', 'o', 'n', ' '] .
                             shows_poly (x p) .
                               shows_string [' ', 'o', 'f', ' '] .
                                 shows_prec zero_nat fa .
                                   shows_string
                                     [' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd',
                                       ' ']))))
         (check_ns j) (check_cc sqrt gt j) (create_dep discrete def i)
         (shows_string
            ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n',
              't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n'] .
           shows_nl .
             shows_sep
               (\ (a, b) ->
                 let {
                   (fa, n) = a;
                 } in (\ p ->
                        shows_string ['P', 'o', 'l', '('] .
                          shows_prec zero_nat fa .
                            shows_string ['/'] .
                              shows_prec_nat zero_nat n .
                                shows_string [')', ' ', '=', ' '] .
                                  shows_poly (x p))
                   b)
               shows_nl i)
         ();

sqrt_int_maina :: Int -> Int -> (Int, Bool);
sqrt_int_maina x n =
  let {
    x2 = times_int x x;
  } in (if less_eq_int x2 n then (x, equal_int x2 n)
         else sqrt_int_maina
                (divide_int (plus_int (divide_int n x) x)
                  (Int_of_integer (2 :: Integer)))
                n);

sqrt_int_main :: Int -> (Int, Bool);
sqrt_int_main x =
  sqrt_int_maina (start_value x (nat_of_integer (2 :: Integer))) x;

sqrt_int :: Int -> [Int];
sqrt_int x =
  (if less_int x zero_int then []
    else (case sqrt_int_main x of {
           (y, True) ->
             (if equal_int y zero_int then [zero_int] else [y, uminus_int y]);
           (_, False) -> [];
         }));

sqrt_rat :: Rat -> [Rat];
sqrt_rat x =
  let {
    (z, n) = quotient_of x;
  } in (case sqrt_int n of {
         [] -> [];
         sn : _ ->
           map (\ sz -> divide_rat (of_int sz) (of_int sn)) (sqrt_int z);
       });

get_non_inf_order ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b,
      Showa b) => Redtriple_impl a -> [(a, Nat)] -> Non_inf_order_ext a b ();
get_non_inf_order (Int_nl_carrier i) =
  create_nlpoly_non_inf_order (Inr ()) (Int_of_integer (1 :: Integer))
    (\ x y -> less_int y x) True True sqrt_int i;
get_non_inf_order (Rat_nl_carrier d i) =
  create_nlpoly_non_inf_order (check_def_pos d) d (delta_gt d)
    (less_eq_rat one_rat d) False sqrt_rat i;
get_non_inf_order (Real_nl_carrier d i) =
  create_nlpoly_non_inf_order (check_def_pos d) d (delta_gt d)
    (less_eq_real one_real d) False sqrt_real i;
get_non_inf_order (Int_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Rat_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Real_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_rat_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Int_mat_carrier v va vb) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Rat_mat_carrier v va vb) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Real_mat_carrier v va vb) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_mat_carrier v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_rat_mat_carrier v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (RPO v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (KBO v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (WPO v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];

check_strict_one_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b, Term a b) ->
                      Maybe [(Pos, ((Term a b, Term a b), Term a b))]) ->
                      ((a, Nat) -> Nat) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strict_one_rstep ra rseqm p r =
  let {
    s = proj_term p (fst r);
    t = proj_term p (snd r);
  } in (case rseqm r of {
         Nothing -> check_supt s t;
         Just [] ->
           Inl (shows_string
                 ['m', 'o', 'r', 'e', ' ', 't', 'h', 'a', 'n', ' ', 'a', ' ',
                   's', 'i', 'n', 'g', 'l', 'e', ' ', 'r', 'e', 'w', 'r', 'i',
                   't', 'e', ' ', 's', 't', 'e', 'p', ' ', 'i', 's', ' ', 'n',
                   'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']);
         Just [(pos, (rule, u))] ->
           bindb (check_qrstep (\ _ -> True) False ra pos rule s u)
             (\ _ -> check_supteq u t);
         Just ((_, (_, _)) : _ : _) ->
           Inl (shows_string
                 ['m', 'o', 'r', 'e', ' ', 't', 'h', 'a', 'n', ' ', 'a', ' ',
                   's', 'i', 'n', 'g', 'l', 'e', ' ', 'r', 'e', 'w', 'r', 'i',
                   't', 'e', ' ', 's', 't', 'e', 'p', ' ', 'i', 's', ' ', 'n',
                   'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']);
       });

check_rsteps ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), Term a b))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rsteps = check_qrsteps (\ _ -> True) False;

rseq_last ::
  forall a b. Term a b -> [(Pos, ((Term a b, Term a b), Term a b))] -> Term a b;
rseq_last s steps = last (s : map (\ (_, (_, sa)) -> sa) steps);

check_rsteps_last ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      [(Pos, ((Term a b, Term a b), Term a b))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rsteps_last = (\ r s steps -> check_rsteps r steps s (rseq_last s steps));

check_strict_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b, Term a b) ->
                      Maybe [(Pos, ((Term a b, Term a b), Term a b))]) ->
                      ((a, Nat) -> Nat) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strict_rstep ra rseqm p r =
  let {
    s = proj_term p (fst r);
    t = proj_term p (snd r);
  } in (case rseqm r of {
         Nothing -> check_supt s t;
         Just rseq ->
           (if equal_nat (size_list rseq) zero_nat then check_supt s t
             else bindb (check_rsteps_last ra s rseq)
                    (\ _ -> check_supteq (rseq_last s rseq) t));
       });

create_rseq_map ::
  forall a b.
    (Key a,
      Key b) => [((Term a b, Term a b),
                   [(Pos, ((Term a b, Term a b), Term a b))])] ->
                  (Term a b, Term a b) ->
                    Maybe [(Pos, ((Term a b, Term a b), Term a b))];
create_rseq_map rseqs = ceta_map_of rseqs;

check_weak ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> Nat) ->
                    (Term a b, Term a b) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_weak p r =
  catch_errora
    (check (equal_term (proj_term p (fst r)) (proj_term p (snd r)))
      (shows_string
         ['t', 'h', 'e', ' ', 'p', 'r', 'o', 'j', 'e', 'c', 't', 'e', 'd', ' ',
           'l', 'h', 's', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'q', 'u',
           'a', 'l', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'j',
           'e', 'c', 't', 'e', 'd', ' ', 'r', 'h', 's'] .
        shows_nl))
    (\ x ->
      Inl (shows_string
             ['C', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i',
               'e', 'n', 't', ' ', 'r', 'u', 'l', 'e', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] r .
              shows_string [',', ' ', 's', 'i', 'n', 'c', 'e'] .
                shows_nl .
                  shows_prec_term zero_nat (proj_term p (fst r)) .
                    shows_string [' ', '!', '=', ' '] .
                      shows_prec_term zero_nat (proj_term p (snd r)) .
                        shows_nl . x));

subterm_criterion_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Ccompare c, Eq c, Key c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    ProjL b ->
                      [((Term b c, Term b c),
                         [(Pos, ((Term b c, Term b c), Term b c))])] ->
                        [(Term b c, Term b c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
subterm_criterion_proc i pL rseqmL prm dpp =
  (case let {
          p = create_proj pL;
          rseqm = create_rseq_map rseqmL;
          pa = pairsb i dpp;
          _ = nfsc i dpp;
          r = rulese i dpp;
          pb = snd (split_pairsa i dpp prm);
          wfR = wf_rules_impl r;
        } in bindb (catch_errora
                     (forallM
                       (\ (l, ra) ->
                         bindb (check_no_var l)
                           (\ _ ->
                             bindb (check_no_var ra)
                               (\ _ ->
                                 check_no_defined_root
                                   (\ fn -> not (null (rules_mapc i dpp fn)))
                                   ra)))
                       pa)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                         (shows_prec_list zero_nat
                           ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                             ' ', 'o', 'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                             'o', 's', 't', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                             'e', 'd']))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM (\ (l, _) -> check_no_var l) r)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (if q_emptyc i dpp
                                 then catch_errora
(forallM (check_strict_rstep r rseqm p) prm) (\ x -> Inl (snd x))
                                 else catch_errora
(forallM (check_strict_one_rstep wfR rseqm p) prm) (\ x -> Inl (snd x)))
                           (\ _ ->
                             catch_errora (forallM (check_weak p) pb)
                               (\ x -> Inl (snd x))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp prm prm);
  });

replace_paira ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> (Term b c, Term b c) -> [(Term b c, Term b c)] -> a;
replace_paira
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = replace_pair;

forward_instantiation_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
forward_instantiation_proc i st sts u_opt dpp =
  (case let {
          isnf = is_QNFc i dpp;
          (s, t) = st;
          iedg = is_iedg_edge_dpp i dpp (s, t);
          sy = map_term (\ x -> x) (\ a -> 'y' : a) s;
          ty = map_term (\ x -> x) (\ a -> 'y' : a) t;
          u = (case u_opt of {
                Nothing -> rulese i dpp;
                Just u -> u;
              });
        } in bindb (if is_none u_opt then Inr ()
                     else let {
                            urc = is_ur_closed_impl_dpp_mv i dpp u;
                            check_urc =
                              (\ sa ta ->
                                check (urc sa ta)
                                  (shows_prec_list zero_nat
                                     ['t', 'e', 'r', 'm', ' '] .
                                    shows_prec_term zero_nat ta .
                                      shows_prec_list zero_nat
[' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'u',
  'n', 'd', 'e', 'r', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
  'e', 's']));
                          } in bindb (check (nfsc i dpp || minimal i dpp)
                                       (shows_prec_list zero_nat
 ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'o', 'r', ' ', 'n',
   'o', 'r', 'm', 'a', 'l', ' ', 's', 'u', 'b', 's', 't', ' ', 'r', 'e', 'q',
   'u', 'i', 'r', 'e', 'd']))
                                 (\ _ ->
                                   bindb (check (nFQ_subset_NF_rulesc i dpp)
   (shows_prec_list zero_nat
     ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e', 'w', 'r', 'i',
       't', 'i', 'n', 'g', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                                     (\ _ ->
                                       bindb
 (catch_errora (forallM (\ (l, a) -> check_urc (args l) a) u)
   (\ x -> Inl (snd x)))
 (\ _ ->
   bindb (check_urc [s] t)
     (\ _ ->
       (if nfsc i dpp then Inr ()
         else catch_errora
                (check_subseteq (vars_term_list t) (vars_term_list s))
                (\ _ ->
                  Inl (shows_prec_list zero_nat
                        ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'c', 'o',
                          'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ',
                          'p', 'a', 'i', 'r', ' ', 'v', 'i', 'o', 'l', 'a', 't',
                          'e', 'd']))))))))
               (\ _ ->
                 let {
                   ur = map (\ (l, r) -> (r, l)) u;
                   ic = icap_impl (is_NF_terms []) ur [];
                 } in catch_errora
                        (forallM
                          (\ (ua, v) ->
                            (case mgu_class (ic ua) t of {
                              Nothing -> Inr ();
                              Just mu ->
                                check (not (isnf (subst_apply_term sy mu)) ||
(not (isnf (subst_apply_term (map_term (\ x -> x) (\ a -> 'x' : a) ua) mu)) ||
  any (\ sta ->
        instance_rule sta st &&
          instance_rule (subst_apply_term sy mu, subst_apply_term ty mu) sta)
    sts))
                                  (shows_prec_list zero_nat
                                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                       't', ' ', 'f', 'i', 'n', 'd', ' ', 'i',
                                       'n', 's', 't', 'a', 'n', 'c', 'e', ' ',
                                       'o', 'f', ' ', 'p', 'a', 'i', 'r', ' '] .
                                    shows_rule (shows_prec zero_nat)
                                      (shows_prec_list zero_nat)
                                      [' ', '-', '>', ' ']
                                      (subst_apply_term sy mu,
subst_apply_term ty mu) .
                                      shows_nl .
shows_prec_list zero_nat
  ['w', 'h', 'i', 'c', 'h', ' ', 'r', 'e', 's', 'u', 'l', 't', 'e', 'd', ' ',
    'f', 'r', 'o', 'm', ' ', 'D', 'P', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] (ua, v));
                            }))
                          (filter (\ (ua, _) -> iedg ua) (pairsb i dpp)))
                        (\ x -> Inl (snd x)))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

check_join ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      [(Pos, ((Term a b, Term a b), Term a b))] ->
                        Term a b ->
                          [(Pos, ((Term a b, Term a b), Term a b))] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join r s sseq t tseq =
  let {
    chk = check_rsteps_last r;
  } in bindb (chk s sseq)
         (\ _ ->
           bindb (chk t tseq)
             (\ _ ->
               let {
                 u = rseq_last s sseq;
                 v = rseq_last t tseq;
               } in check (equal_term u v)
                      (shows_prec_list zero_nat
                         ['t', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                           ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 's',
                           ' ', 'e', 'n', 'd', ' ', 'i', 'n', ' ', 'd', 'i',
                           'f', 'f', 'e', 'r', 'e', 'n', 't', ' ', 't', 'e',
                           'r', 'm', 's', ' '] .
                        shows_prec_term zero_nat u .
                          shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                            shows_prec_term zero_nat v)));

check_critical_pairs_guided ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Bool, (Term a b, Term a b))] ->
                      [(Term a b,
                         ([(Pos, ((Term a b, Term a b), Term a b))],
                           (Term a b,
                             [(Pos, ((Term a b, Term a b), Term a b))])))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_guided r cp joins =
  bindb (catch_errora
          (forallM (\ (s, a) -> let {
                                  (sseq, aa) = a;
                                  (ab, b) = aa;
                                } in check_join r s sseq ab b)
            joins)
          (\ x -> Inl (snd x)))
    (\ _ ->
      let {
        cpa = map (\ (s, (_, (t, _))) -> (s, t)) joins;
      } in catch_errora
             (forallM
               (\ (_, (s, t)) ->
                 check (equal_term s t ||
                         any (\ st ->
                               instance_rule (s, t) st ||
                                 instance_rule (t, s) st)
                           cpa)
                   (shows_prec_list zero_nat
                      ['c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'a',
                        'i', 'r', ' '] .
                     show_crit_pair (s, t) .
                       shows_prec_list zero_nat
                         [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']))
               cp)
             (\ x -> Inl (snd x)));

iterative_join_search_main ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Nat -> Nat -> Bool;
iterative_join_search_main r s t i n =
  (if less_eq_nat i n
    then not (null (list_inter (reachable_terms r s i)
                     (reachable_terms r t i))) ||
           iterative_join_search_main r s t (suc i) n
    else False);

iterative_join_search ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Nat -> Bool;
iterative_join_search r s t n = iterative_join_search_main r s t zero_nat n;

check_join_BFS_limit ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Nat ->
                    [(Term a b, Term a b)] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join_BFS_limit n r s t =
  check (iterative_join_search r s t n)
    (shows_prec_list zero_nat
       ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
         ' ', 'a', ' ', 'j', 'o', 'i', 'n', 'i', 'n', 'g', ' ', 's', 'e', 'q',
         'u', 'e', 'n', 'c', 'e', ' ', 'o', 'f', ' ', 'l', 'e', 'n', 'g', 't',
         'h', ' ', 'a', 't', ' ', 'm', 'o', 's', 't', ' '] .
      shows_prec_nat zero_nat n .
        shows_prec_list zero_nat
          [' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm', 's',
            ' '] .
          shows_prec_term zero_nat s .
            shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
              shows_prec_term zero_nat t . shows_nl);

check_critical_pairs_BFS ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Nat ->
                    [(Term a b, Term a b)] ->
                      [(Bool, (Term a b, Term a b))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_BFS n r cp =
  catch_errora
    (forallM
      (\ (_, (s, t)) ->
        (if equal_term s t then Inr ()
          else catch_errora (check_join_BFS_limit n r s t)
                 (\ x ->
                   Inl (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h',
                            'e', 'n', ' ', 'j', 'o', 'i', 'n', 'i', 'n', 'g',
                            ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ',
                            'p', 'a', 'i', 'r', ' '] .
                         show_crit_pair (s, t) . shows_nl . x))))
      cp)
    (\ x -> Inl (snd x));

check_critical_pairs_NF ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Bool, (Term a b, Term a b))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_NF r cp =
  catch_errora
    (forallM
      (\ (_, (s, t)) ->
        (if equal_term s t then Inr ()
          else catch_errora (check_join_NF r s t)
                 (\ x ->
                   Inl (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h',
                            'e', 'n', ' ', 'j', 'o', 'i', 'n', 'i', 'n', 'g',
                            ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ',
                            'p', 'a', 'i', 'r', ' '] .
                         show_crit_pair (s, t) . shows_nl . x))))
      cp)
    (\ x -> Inl (snd x));

check_critical_pairs ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Bool, (Term a [Prelude.Char], Term a [Prelude.Char]))] ->
                      Join_info a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs r cp join_info =
  (case join_info of {
    Guided a -> check_critical_pairs_guided r cp a;
    Join_NF -> check_critical_pairs_NF r cp;
    Join_BFS n -> check_critical_pairs_BFS n r cp;
  });

switch_innermost_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_innermost_proc i joins_i dpp =
  let {
    r = rwd i dpp;
    p = pb i dpp;
    pw = pwb i dpp;
    nfs = nfsc i dpp;
  } in (case bindb (catch_errora
                     (forallM
                       (\ (l, _) ->
                         check (not (is_Var l))
                           (shows_prec_list zero_nat
                             ['l', 'e', 'f', 't', ' ', 'v', 'a', 'r', 'i', 'a',
                               'b', 'l', 'e', 's', ' ', 'i', 'n', ' ', 'R', ' ',
                               'f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n']))
                       (if nfs then r else []))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check (minimal i dpp)
                         (shows_prec_list zero_nat
                           ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                             ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                   (\ _ ->
                     bindb (check (null (qc i dpp))
                             (shows_prec_list zero_nat
                               ['n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y',
                                 ' ', 'Q', ' ', 'n', 'o', 't', ' ', 'y', 'e',
                                 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
                                 'e', 'd']))
                       (\ _ ->
                         bindb (check (null (rd i dpp))
                                 (shows_prec_list zero_nat
                                   ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u',
                                     'l', 'e', 's', ' ', 'n', 'o', 't', ' ',
                                     'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                           (\ _ ->
                             bindb (check
                                     (null (critical_pairs_impl (p ++ pw) r))
                                     (shows_prec_list zero_nat
                                       ['o', 'v', 'e', 'r', 'l', 'a', 'p', 's',
 ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', 'P', ' ', 'a', 'n', 'd', ' ', 'R',
 ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                               (\ _ ->
                                 check_critical_pairs r
                                   (critical_pairs_impl r r) joins_i)))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i nfs True p pw (map fst r) [] r);
       });

mk_dpp ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      (Bool,
        (Bool,
          ([(Term b c, Term b c)],
            ([(Term b c, Term b c)],
              ([Term b c],
                ([(Term b c, Term b c)], [(Term b c, Term b c)])))))) ->
        a;
mk_dpp i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkd i nfs m p pw q r rw;

check_assma ::
  forall a b c d e f g.
    (Countable b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      (a -> d -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (c -> e -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (([(Ctxt (Lab b [Nat]) [Prelude.Char],
                               (Term (Lab b [Nat]) [Prelude.Char], Location))],
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])]) ->
                            f -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([Prelude.Char] ->
                              g -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              Generic_assm_proof b [Nat] [Prelude.Char] d e f ()
                                g ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assma j i tp_check dp_check fptp_check unk_check (SN_assm_proof t prf) =
  tp_check (mk_tp j t) prf;
check_assma j i tp_check dp_check fptp_check unk_check (Finite_assm_proof t prf)
  = dp_check (mk_dpp i t) prf;
check_assma j i tp_check dp_check fptp_check unk_check
  (Unknown_assm_proof t prf) = unk_check t prf;
check_assma j i tp_check dp_check fptp_check unk_check (SN_FP_assm_proof t prf)
  = fptp_check t prf;
check_assma j i uu uv uw ux (Not_SN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assma j i uu uv uw ux (Infinite_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assma j i uu uv uw ux (Not_RelSN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assma j i uu uv uw ux (Not_SN_FP_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assma j i uu uv uw ux (Complexity_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);

quasi_splitter ::
  forall a b c.
    (Compare a, Eq a, Compare c,
      Eq c) => (a -> (a, b)) ->
                 [(Term a c, Term a c)] ->
                   Set (Term a c, Term a c) ->
                     ([(Term a c, Term a c)],
                       ([(Term a c, Term a c)], [(Term a c, Term a c)]));
quasi_splitter ld lAll uRw =
  let {
    unlab = (\ lf -> fst (ld lf));
    la = map (\ r -> (r, map_funs_rule unlab r)) lAll;
    (d, nD) =
      partition
        (\ (r, ur) ->
          equal_term (fst ur) (snd ur) && not (equal_term (fst r) (snd r)))
        la;
    (rw, r) = partition (\ (_, ur) -> member ur uRw) nD;
  } in (map fst r, (map fst rw, map fst d));

model_splitter ::
  forall a b c.
    (Compare a, Eq a, Compare c,
      Eq c) => (a -> (a, b)) ->
                 [(Term a c, Term a c)] ->
                   Set (Term a c, Term a c) ->
                     ([(Term a c, Term a c)],
                       ([(Term a c, Term a c)], [(Term a c, Term a c)]));
model_splitter ld lAll uRw =
  let {
    unlab = (\ lf -> fst (ld lf));
    la = map (\ r -> (r, map_funs_rule unlab r)) lAll;
    (rw, r) = partition (\ (_, ur) -> member ur uRw) la;
  } in (map fst r, (map fst rw, []));

check_sl_Q ::
  forall a b c.
    (Eq a, Showa a, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => (a -> (a, b)) ->
                    [Term a c] ->
                      [Term a c] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_Q ld lQ q =
  let {
    u = (\ l -> fst (ld l));
  } in catch_errora
         (forallM
           (\ lq ->
             check (let {
                      mlq = map_term u (\ x -> x) lq;
                    } in any (\ qa -> matches mlq qa && matches qa mlq) q)
               (shows_prec_list zero_nat
                  ['u', 'n', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ' '] .
                 shows_term (shows_prec zero_nat) (shows_prec zero_nat) lq .
                   shows_prec_list zero_nat
                     [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 'a', ' ', 't',
                       'e', 'r', 'm', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ',
                       'Q']))
           lQ)
         (\ x -> Inl (snd x));

sem_lab_quasi_root_proc ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ceq d, Ccompare d, Compare d, Eq d,
      Mapping_impl d, Set_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([(Term a d, Term a d)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          ([(Term a d, Term a d)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([Term a d] ->
                              [Term a d] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                ([(Term a d, Term a d)] ->
                                  [(Term a d, Term a d)] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char])
                                      ()) ->
                                  (Set (Term a d, Term a d) ->
                                    [(Term a d, Term a d)] ->
                                      Sum ([Prelude.Char] -> [Prelude.Char])
()) ->
                                    [(Term a d, Term a d)] ->
                                      [Term a d] ->
[(Term a d, Term a d)] -> c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_quasi_root_proc ld i valid check_decra check_decr check_lhss_more
  check_lab_all check_lab_all_trs check_model_lab lPAll lQ lRAll dpp =
  let {
    r = rd i dpp;
    rw = rwd i dpp;
    pw = pwb i dpp;
    p = pb i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll (set pw);
    (lR, (lRw, d)) = quasi_splitter ld lRAll (set rw);
    qempty = q_emptyc i dpp;
  } in (case bindb valid
               (\ _ ->
                 bindb (check
                         (if nfs
                           then (if not qempty then wwf_rulesa i dpp else True)
                           else True)
                         (shows_prec_list zero_nat
                           ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e',
                             'd', 'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u',
                             'i', 'r', 'e', 'd']))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM
                               (\ (l, ra) ->
                                 bindb (check_no_var l)
                                   (\ _ ->
                                     bindb (check_no_var ra)
                                       (\ _ ->
 check_no_defined_root (\ fn -> not (null (rules_mapc i dpp fn))) ra)))
                               (pairsb i dpp))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM (\ (l, _) -> check_no_var l)
                                   (rulese i dpp))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             let {
                               q = qc i dpp;
                             } in bindb (if nfs && not qempty
  then check_wf_trs d else Inr ())
                                    (\ _ ->
                                      bindb (check_decra d)
(\ _ ->
  bindb (check_decr d)
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ qa ->
                  check (linear_term qa)
                    (shows_prec_list zero_nat
                      ['Q', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                        'c', 'o', 'n', 't', 'a', 'i', 'n', ' ', 'n', 'o', 'n',
                        '-', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 't', 'e', 'r',
                        'm', 's']))
                q)
              (\ x -> Inl (snd x)))
        (\ _ ->
          catch_errora
            (bindb (check_lhss_more lQ q)
              (\ _ ->
                bindb (check_sl_Q ld lQ q)
                  (\ _ ->
                    bindb (check_lab_all (set lP) p)
                      (\ _ ->
                        bindb (check_lab_all (set lPw) pw)
                          (\ _ ->
                            bindb (check_model_lab (set lR) r)
                              (\ _ ->
                                bindb (check_model_lab (set lRw) rw)
                                  (\ _ ->
                                    bindb (check_lab_all_trs lR r)
                                      (\ _ -> check_lab_all_trs lRw rw))))))))
            (\ x ->
              Inl (shows_string
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'd', 'u', 'r',
                       'i', 'n', 'g', ' ', 'l', 'a', 'b', 'e', 'l', 'i', 'n',
                       'g', ':'] .
                    shows_nl . x))))))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i nfs m lP lPw lQ lR (lRw ++ d));
       });

eval_lab ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> Nat -> c -> d) -> (e -> b) -> Term a e -> (b, Term d e);
eval_lab i l lc alpha (Var x) = (alpha x, Var x);
eval_lab i l lc alpha (Fun f ts) =
  let {
    clts = map (eval_lab i l lc alpha) ts;
    cs = map fst clts;
    c = i f cs;
    lts = map snd clts;
  } in (c, Fun (lc f (size_list ts) (l f cs)) lts);

check_sl_rule_ass ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => Bool ->
                    (a -> [b] -> b) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          (b -> b -> Bool) ->
                            Set (Term d e, Term d e) ->
                              (e -> b) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_ass mc i la lc cge lR alpha (l, r) =
  let {
    cl_ll = eval_lab i la lc alpha l;
    cr_lr = eval_lab i la lc alpha r;
  } in bindb (check (if mc then cge (fst cl_ll) (fst cr_lr) else True)
               (shows_string ['r', 'u', 'l', 'e', ' '] .
                 shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                   [' ', '-', '>', ' '] (l, r) .
                   shows_string
                     [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 't',
                       'h', 'e', ' ', 'm', 'o', 'd', 'e', 'l', ' ', 'c', 'o',
                       'n', 'd', 'i', 't', 'i', 'o', 'n', ',', ' ', '[', 'l',
                       'h', 's', ']', ' ', '=', ' '] .
                     shows_prec zero_nat (fst cl_ll) .
                       shows_string
                         [',', ' ', '[', 'r', 'h', 's', ']', ' ', '=', ' '] .
                         shows_prec zero_nat (fst cr_lr)))
         (\ _ ->
           check (member (snd cl_ll, snd cr_lr) lR)
             (shows_string
                ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                  ' '] .
               shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                 [' ', '-', '>', ' '] (snd cl_ll, snd cr_lr) .
                 shows_string [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']));

check_sl_rule ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> d) ->
                        [b] ->
                          (b -> b -> Bool) ->
                            Bool ->
                              Set (Term d e, Term d e) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule i l lc c cge mc lR lr =
  catch_errora
    (forallM (\ alpha -> check_sl_rule_ass mc i l lc cge lR alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_model_lab_trs_set ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_model_lab_trs_set i l c cge labl lR r =
  catch_errora (forallM (check_sl_rule i l labl c cge True lR) r)
    (\ x -> Inl (snd x));

check_sl_model_lab_trs ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_model_lab_trs i l c cge labl lR r =
  check_sl_model_lab_trs_set i l c cge labl lR r;

check_NF_vars_subset ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_vars_subset qa q =
  catch_errora (forallM (\ qaa -> check (any (matches qaa) q) qaa) qa)
    (\ x -> Inl (snd x));

flatten_term_enum :: forall a b. Term [a] b -> [Term a b];
flatten_term_enum (Var x) = [Var x];
flatten_term_enum (Fun fs ts) = let {
                                  lts = map flatten_term_enum ts;
                                  ss = concat_lists lts;
                                } in concatMap (\ f -> map (Fun f) ss) fs;

lab_lhss_more_impl ::
  forall a b c d.
    (a -> Nat -> b -> c) -> (a -> Nat -> [b]) -> [Term a d] -> [Term c d];
lab_lhss_more_impl lc lS_gen q =
  let {
    f_all = (\ (f, n) -> map (lc f n) (lS_gen f n));
  } in concatMap (\ qa -> flatten_term_enum (map_funs_term_wa f_all qa)) q;

check_sl_lab_lhss_more ::
  forall a b c.
    (Eq a, Showa a, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => (a -> Nat -> b -> a) ->
                    (a -> Nat -> [b]) ->
                      [Term a c] ->
                        [Term a c] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_lhss_more lc lS_gen lQ q =
  catch_errora (check_NF_vars_subset (lab_lhss_more_impl lc lS_gen q) lQ)
    (\ x ->
      Inl (shows_term (shows_prec zero_nat) (shows_prec zero_nat) x .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i',
                'n', ' ', 'l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'Q']));

sl_check_decr ::
  forall a b c d e.
    Sl_ops_ext a b c d e ->
      [(Term a d, Term a d)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sl_check_decr
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_check_decr;

lab_root ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> [b] -> c) ->
          (a -> Nat -> c -> d) -> (e -> b) -> Term a e -> Term d e;
lab_root i la l lc alpha (Fun f ts) = let {
clts = map (eval_lab i la lc alpha) ts;
cs = map fst clts;
a = map snd clts;
                                      } in Fun (lc f (size_list ts) (l f cs)) a;
lab_root uu uv uw ux uy (Var x) = Var x;

check_sl_rule_all_ass ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          (c -> [c]) ->
                            Set (Term d e, Term d e) ->
                              (e -> b) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_all_ass i lb la lc gen_smaller lR alpha (l, Fun f ts) =
  let {
    ll = lab_root i lb la lc alpha l;
    clts = map (eval_lab i lb lc alpha) ts;
    lts = map snd clts;
    ld = la f (map fst clts);
    n = size_list ts;
    small = gen_smaller ld;
  } in catch_errora
         (forallM
           (\ le ->
             check (member (ll, Fun (lc f n le) lts) lR)
               (shows_string
                  ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                    ' '] .
                 shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                   [' ', '-', '>', ' '] (ll, Fun (lc f n le) lts) .
                   shows_string [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']))
           small)
         (\ x -> Inl (snd x));
check_sl_rule_all_ass i lb la lc gen_smaller lR alpha (l, Var x) =
  let {
    ll = lab_root i lb la lc alpha l;
    lr = lab_root i lb la lc alpha (Var x);
  } in check (member (ll, lr) lR)
         (shows_string
            ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e', ' '] .
           shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] (ll, lr) .
             shows_string [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']);

check_sl_rule_all ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          [b] ->
                            (c -> [c]) ->
                              Set (Term d e, Term d e) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_all i la l lc c gen_smaller lR lr =
  catch_errora
    (forallM
      (\ alpha -> check_sl_rule_all_ass i la l lc gen_smaller lR alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_lab_all_trs ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        [b] ->
                          (c -> [c]) ->
                            (a -> Nat -> c -> d) ->
                              Set (Term d e, Term d e) ->
                                [(Term a e, Term a e)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_all_trs i la l c gen labl lP p =
  catch_errora (forallM (check_sl_rule_all i la l labl c gen lP) p)
    (\ x -> Inl (snd x));

check_wf_sym_F_all ::
  forall a b c.
    (Eq c,
      Showa c) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        (c, Nat) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_sym_F_all lc ld ls =
  (\ (lf, n) ->
    let {
      (f, l) = ld lf;
    } in check (ls f n l && lf == lc f n l)
           (shows_prec_list zero_nat
              ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o',
                'l', ' '] .
             shows_prec zero_nat lf .
               shows_prec_list zero_nat
                 [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']));

check_wf_terms_F_all ::
  forall a b c d.
    (Eq c,
      Showa c) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        Term c d -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_terms_F_all lc ld ls lt =
  let {
    lfs = insert_funas_term lt [];
  } in catch_errora (forallM (check_wf_sym_F_all lc ld ls) lfs)
         (\ x -> Inl (snd x));

check_Lab_all_trs ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        [(Term a c, Term a c)] ->
                          [(Term a c, Term a c)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_Lab_all_trs lc ld ls lR r =
  catch_errora
    (forallM
      (\ (l, ra) ->
        catch_errora
          (bindb (check_wf_terms_F_all lc ld ls ra)
            (\ _ ->
              check (membera r (map_funs_rule (\ lf -> fst (ld lf)) (l, ra)))
                (shows_prec_list zero_nat
                  ['u', 'n', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ' ', 'o',
                    'f', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' ', 'd',
                    'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'y', 'i', 'e', 'l',
                    'd', ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 'r',
                    'u', 'l', 'e'])))
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h',
                     ' ', 'l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l',
                     'e'] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '-', '>', ' '] (l, ra) .
                    shows_nl . x)))
      lR)
    (\ x -> Inl (snd x));

sl_LS_gen :: forall a b c d e. Sl_ops_ext a b c d e -> a -> Nat -> [c];
sl_LS_gen
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_LS_gen;

sl_lgen :: forall a b c d e. Sl_ops_ext a b c d e -> c -> [c];
sl_lgen
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_lgen;

lge_to_lgr ::
  forall a b.
    (Eq b) => (a -> Nat -> b -> b -> Bool) ->
                (a -> Nat -> b -> Bool) -> a -> Nat -> b -> b -> Bool;
lge_to_lgr lge ls f n =
  let {
    lSfn = ls f n;
    lgefn = lge f n;
  } in (\ l la -> not (l == la) && lSfn l && lSfn la && lgefn l la);

check_sl_decr_rule ::
  forall a b c d.
    (Eq a, Eq b, Eq c,
      Eq d) => (a -> Nat -> b -> c) ->
                 (c -> (a, b)) ->
                   (a -> Nat -> b -> Bool) ->
                     (a -> Nat -> b -> b -> Bool) ->
                       (Term c d, Term c d) -> Bool;
check_sl_decr_rule lc ld ls lge (Fun lf ts, Fun lg us) =
  let {
    (f, l1) = ld lf;
    (g, l2) = ld lg;
    n = size_list ts;
  } in f == g &&
         ts == us &&
           lf == lc f n l1 &&
             lg == lc f n l2 &&
               ls f n l1 && ls f n l2 && lge_to_lgr lge ls f n l1 l2;
check_sl_decr_rule uu uv uw ux (Var vb, va) = False;
check_sl_decr_rule uu uv uw ux (v, Var vb) = False;

check_sl_decr ::
  forall a b c d.
    (Eq a, Eq b, Eq c, Showa c, Eq d,
      Showa d) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        (a -> Nat -> b -> b -> Bool) ->
                          [(Term c d, Term c d)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_decr lc ld ls lge d =
  catch_errora
    (forallM
      (\ lr ->
        check (check_sl_decr_rule lc ld ls lge lr)
          (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] lr .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'd', 'e', 'c',
                'r', 'e', 'a', 's', 'i', 'n', 'g', ' ', 'r', 'u', 'l', 'e']))
      d)
    (\ x -> Inl (snd x));

sl_La :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> c;
sl_La (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
        sl_LS_gen more)
  = sl_L;

sl_LS :: forall a b c d e. Sl_ops_ext a b c d e -> a -> Nat -> c -> Bool;
sl_LS (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
        sl_LS_gen more)
  = sl_LSa;

sl_L :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> c;
sl_L (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_La;

sl_I :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> b;
sl_I (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_I;

sl_C :: forall a b c d e. Sl_ops_ext a b c d e -> [b];
sl_C (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_C;

insert_funas_args_term ::
  forall a b. (Eq a) => Term a b -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_term t fs = foldr insert_funas_term (args t) fs;

insert_funas_args_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_rule r fs =
  insert_funas_args_term (fst r) (insert_funas_args_term (snd r) fs);

insert_funas_args_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_trs trs = foldr insert_funas_args_rule trs;

option_to_list :: forall a. Maybe a -> [a];
option_to_list (Just a) = [a];
option_to_list Nothing = [];

insert_roots_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_roots_rule r fs =
  foldr insertb (option_to_list (root (fst r)) ++ option_to_list (root (snd r)))
    fs;

insert_roots_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_roots_trs trs = foldr insert_roots_rule trs;

sem_lab_fin_quasi_root_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Eq b, Showa c, Ceq e, Ccompare e, Compare e,
      Eq e, Mapping_impl e, Set_impl e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      (c -> c -> Bool) ->
                        (a -> Nat -> b -> b -> Bool) ->
                          Dpp_ops_ext d a e () ->
                            ([(a, Nat)] ->
                              [(a, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char])
                                  (Sl_ops_ext a c b e ())) ->
                              [(Term a e, Term a e)] ->
                                [Term a e] ->
                                  [(Term a e, Term a e)] ->
                                    d -> Sum ([Prelude.Char] -> [Prelude.Char])
   d;
sem_lab_fin_quasi_root_proc lc ld cge lge i gen lPAll lQ lRAll dp =
  let {
    pairs = pairsb i dp;
  } in bindb (gen (list_union (insert_funas_trs (rulese i dp) [])
                    (insert_funas_args_trs pairs []))
               (insert_roots_trs pairs []))
         (\ ops ->
           let {
             check_d = sl_check_decr ops;
             check_da = check_sl_decr lc ld (sl_LS ops) lge;
             check_q = check_sl_lab_lhss_more lc (sl_LS_gen ops);
             check_ml =
               check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) cge lc;
             check_l =
               check_sl_lab_all_trs (sl_I ops) (sl_L ops) (sl_La ops) (sl_C ops)
                 (sl_lgen ops) lc;
             check_la = check_Lab_all_trs lc ld (sl_LS ops);
           } in sem_lab_quasi_root_proc ld i (Inr ()) check_d check_da check_q
                  check_l check_la check_ml lPAll lQ lRAll dp);

check_sl_rule_root ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          [b] ->
                            Set (Term d e, Term d e) ->
                              (Term a e, Term a e) ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_root i la l lc c lR lr =
  catch_errora
    (forallM
      (\ alpha ->
        let {
          laa = lab_root i la l lc alpha;
          lb = laa (fst lr);
          r = laa (snd lr);
        } in check (member (lb, r) lR)
               (shows_prec_list zero_nat
                  ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                    ' '] .
                 shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                   [' ', '-', '>', ' '] (lb, r) .
                   shows_prec_list zero_nat
                     [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g']))
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_lab_root_trs ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        [b] ->
                          (a -> Nat -> c -> d) ->
                            Set (Term d e, Term d e) ->
                              [(Term a e, Term a e)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_root_trs i la l c labl lP p =
  catch_errora (forallM (check_sl_rule_root i la l labl c lP) p)
    (\ x -> Inl (snd x));

sem_lab_root_proc ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([Term a d] ->
                          [Term a d] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Set (Term a d, Term a d) ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                [(Term a d, Term a d)] ->
                                  [Term a d] ->
                                    [(Term a d, Term a d)] ->
                                      c ->
Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_root_proc ld i valid check_Q check_laba check_lab check_model_lab lPAll
  lQ lRAll dpp =
  let {
    r = rd i dpp;
    rw = rwd i dpp;
    pw = pwb i dpp;
    p = pb i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll (set pw);
    (lR, (lRw, _)) = model_splitter ld lRAll (set rw);
  } in (case bindb valid
               (\ _ ->
                 bindb (catch_errora
                         (forallM
                           (\ (l, ra) ->
                             bindb (check_no_var l)
                               (\ _ ->
                                 bindb (check_no_var ra)
                                   (\ _ ->
                                     check_no_defined_root
                                       (\ fn ->
 not (null (rules_mapc i dpp fn)))
                                       ra)))
                           (pairsb i dpp))
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM (\ (l, _) -> check_no_var l)
                               (rulese i dpp))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         let {
                           q = qc i dpp;
                         } in catch_errora
                                (bindb
                                  (check
                                    (if nfs
                                      then (if not (q_emptyc i dpp)
     then wwf_rulesa i dpp else True)
                                      else True)
                                    (shows_prec_list zero_nat
                                      ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r',
'm', 'e', 'd', 'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e',
'd']))
                                  (\ _ ->
                                    bindb (check_Q lQ q)
                                      (\ _ ->
bindb (check_sl_Q ld lQ q)
  (\ _ ->
    bindb (check_laba (set lP) p)
      (\ _ ->
        bindb (check_laba (set lPw) pw)
          (\ _ ->
            bindb (check_model_lab (set lR) r)
              (\ _ ->
                bindb (check_model_lab (set lRw) rw)
                  (\ _ ->
                    bindb (check_lab lR r) (\ _ -> check_lab lRw rw)))))))))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'd', 'u', 'r', 'i', 'n', 'g', ' ',
   'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ':'] .
shows_nl . x)))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i nfs m lP lPw lQ lR lRw);
       });

lab_rule_ass ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> Nat -> c -> d) ->
          (e -> b) -> (Term a e, Term a e) -> (Term d e, Term d e);
lab_rule_ass i l lc alpha rule =
  (snd (eval_lab i l lc alpha (fst rule)),
    snd (eval_lab i l lc alpha (snd rule)));

lab_rule_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) ->
                    [b] -> (Term a e, Term a e) -> [(Term d e, Term d e)];
lab_rule_list i l lc c lr =
  map (\ alpha -> lab_rule_ass i l lc alpha lr)
    (map fun_of (enum_vectors c (insert_vars_rule lr [])));

lab_trs_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) ->
                    [b] -> [(Term a e, Term a e)] -> [(Term d e, Term d e)];
lab_trs_list i l lc c r = concatMap (lab_rule_list i l lc c) r;

check_sl_lab ::
  forall a b c d.
    (Eq a, Showa a, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> a) ->
                        [b] ->
                          [(Term a d, Term a d)] ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab i l lc c lR r =
  bindb (check (not (null c))
          (shows_prec_list zero_nat
            ['c', 'a', 'r', 'r', 'i', 'e', 'r', ' ', 'm', 'u', 's', 't', ' ',
              'b', 'e', ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
    (\ _ ->
      catch_errora (check_subseteq lR (lab_trs_list i l lc c r))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                   ' '] .
                shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                  [' ', '-', '>', ' '] x .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
                      'w', 'e', 'd'])));

lab_lhs_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) -> [b] -> Term a e -> [Term d e];
lab_lhs_list i l lc c t =
  map (\ alpha -> snd (eval_lab i l lc alpha t))
    (map fun_of (enum_vectors c (insert_vars_term t [])));

lab_lhss_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) -> [b] -> [Term a e] -> [Term d e];
lab_lhss_list i l lc c q = concatMap (lab_lhs_list i l lc c) q;

check_sl_Qa ::
  forall a b c d.
    (Eq a, Showa a, Ccompare d, Eq d, Mapping_impl d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> a) ->
                        [b] ->
                          [Term a d] ->
                            [Term a d] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_Qa i l lc c lQ q =
  bindb (check (not (null c))
          (shows_prec_list zero_nat
            ['c', 'a', 'r', 'r', 'i', 'e', 'r', ' ', 'm', 'u', 's', 't', ' ',
              'b', 'e', ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
    (\ _ ->
      catch_errora (check_NF_vars_subset (lab_lhss_list i l lc c q) lQ)
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 't', 'e', 'r', 'm',
                   ' '] .
                shows_term (shows_prec zero_nat) (shows_prec zero_nat) x .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])));

sem_lab_fin_root_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d, Eq e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      Dpp_ops_ext c a d () ->
                        ([(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              (Sl_ops_ext a e b d ())) ->
                          [(Term a d, Term a d)] ->
                            [Term a d] ->
                              [(Term a d, Term a d)] ->
                                c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_fin_root_proc lc ld i gen lPAll lQ lRAll dp =
  let {
    pairs = pairsb i dp;
  } in bindb (gen (list_union (insert_funas_trs (rulese i dp) [])
                    (insert_funas_args_trs pairs []))
               (insert_roots_trs pairs []))
         (\ ops ->
           let {
             check_q = check_sl_Qa (sl_I ops) (sl_L ops) lc (sl_C ops);
             check_ml =
               check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops)
                 (\ a b -> a == b) lc;
             check_l =
               check_sl_lab_root_trs (sl_I ops) (sl_L ops) (sl_La ops)
                 (sl_C ops) lc;
             check_la = check_sl_lab (sl_I ops) (sl_L ops) lc (sl_C ops);
           } in sem_lab_root_proc ld i (Inr ()) check_q check_l check_la
                  check_ml lPAll lQ lRAll dp);

slm_La :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> c;
slm_La (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_L;

slm_c :: forall a b c d. Slm_ops_ext a b c d -> b;
slm_c (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_c;

slm_L :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> c;
slm_L (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_La;

slm_I :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> b;
slm_I (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_I;

slm_C :: forall a b c d. Slm_ops_ext a b c d -> [b];
slm_C (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_C;

slm_to_sl :: forall a b c d. Slm_ops_ext a b c () -> Sl_ops_ext a b c d ();
slm_to_sl ops =
  Sl_ops_ext (slm_L ops) (\ _ _ _ -> True) (slm_I ops) (slm_C ops) (slm_c ops)
    (\ _ -> Inr ()) (slm_La ops) (\ _ _ _ -> True) (\ l -> [l]) (\ _ _ -> [])
    ();

slm_gen_to_sl_gen ::
  forall a b c d.
    ([(a, Nat)] ->
      [(a, Nat)] ->
        Sum ([Prelude.Char] -> [Prelude.Char]) (Slm_ops_ext a b c ())) ->
      [(a, Nat)] ->
        [(a, Nat)] ->
          Sum ([Prelude.Char] -> [Prelude.Char]) (Sl_ops_ext a b c d ());
slm_gen_to_sl_gen gen =
  (\ f g -> bindb (gen f g) (\ ops -> Inr (slm_to_sl ops)));

check_sl_lab_trs_set ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_trs_set i l c cge labl lP p =
  catch_errora (forallM (check_sl_rule i l labl c cge False lP) p)
    (\ x -> Inl (snd x));

check_sl_lab_trs ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_trs i l c cge labl lP p = check_sl_lab_trs_set i l c cge labl lP p;

sem_lab_proc ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([Term a d] ->
                          [Term a d] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Set (Term a d, Term a d) ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                [(Term a d, Term a d)] ->
                                  [Term a d] ->
                                    [(Term a d, Term a d)] ->
                                      c ->
Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_proc ld i valid check_Q check_laba check_lab check_model_lab lPAll lQ
  lRAll dpp =
  let {
    r = rd i dpp;
    rw = rwd i dpp;
    pw = pwb i dpp;
    p = pb i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll (set pw);
    (lR, (lRw, _)) = model_splitter ld lRAll (set rw);
  } in (case bindb valid
               (\ _ ->
                 let {
                   q = qc i dpp;
                 } in catch_errora
                        (bindb
                          (check
                            (if nfs
                              then (if not (q_emptyc i dpp)
                                     then wwf_rulesa i dpp else True)
                              else True)
                            (shows_prec_list zero_nat
                              ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e',
                                'd', 'n', 'e', 's', 's', ' ', 'r', 'e', 'q',
                                'u', 'i', 'r', 'e', 'd']))
                          (\ _ ->
                            bindb (check_Q lQ q)
                              (\ _ ->
                                bindb (check_sl_Q ld lQ q)
                                  (\ _ ->
                                    bindb (check_laba (set lP) p)
                                      (\ _ ->
bindb (check_laba (set lPw) pw)
  (\ _ ->
    bindb (check_model_lab (set lR) r)
      (\ _ ->
        bindb (check_model_lab (set lRw) rw)
          (\ _ -> bindb (check_lab lR r) (\ _ -> check_lab lRw rw)))))))))
                        (\ x ->
                          Inl (shows_string
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'd',
                                   'u', 'r', 'i', 'n', 'g', ' ', 'l', 'a', 'b',
                                   'e', 'l', 'i', 'n', 'g', ':'] .
                                shows_nl . x)))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i nfs m lP lPw lQ lR lRw);
       });

sem_lab_fin_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d, Eq e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      Dpp_ops_ext c a d () ->
                        ([(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              (Sl_ops_ext a e b d ())) ->
                          [(Term a d, Term a d)] ->
                            [Term a d] ->
                              [(Term a d, Term a d)] ->
                                c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_fin_proc lc ld i gen lPAll lQ lRAll dp =
  bindb (gen (list_union (insert_funas_trs (rulese i dp) [])
               (insert_funas_args_trs (pairsb i dp) []))
          [])
    (\ ops ->
      let {
        check_q = check_sl_Qa (sl_I ops) (sl_L ops) lc (sl_C ops);
        check_ml =
          check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops)
            (\ a b -> a == b) lc;
        check_l =
          check_sl_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) (\ a b -> a == b)
            lc;
        check_la = check_sl_lab (sl_I ops) (sl_L ops) lc (sl_C ops);
      } in sem_lab_proc ld i (Inr ()) check_q check_l check_la check_ml lPAll lQ
             lRAll dp);

get_largest_element :: forall a. Sl_inter a -> Nat;
get_largest_element (SL_Inter n uu) = n;

take_default :: forall a. a -> [a] -> Nat -> a;
take_default def [] uu = def;
take_default uv (x : xs) i =
  (if equal_nat i zero_nat then x
    else take_default uv xs (minus_nat i one_nat));

eval_arithFun :: Nat -> [Nat] -> ArithFun -> Nat;
eval_arithFun c nats f = modulo_nat (eval_arithFun_unbound c nats f) c;

eval_arithFun_unbound :: Nat -> [Nat] -> ArithFun -> Nat;
eval_arithFun_unbound c nats (Arg i) = take_default zero_nat nats i;
eval_arithFun_unbound c nats (Consta n) = n;
eval_arithFun_unbound c nats (Suma []) = zero_nat;
eval_arithFun_unbound c nats (Suma (f : fs)) =
  plus_nat (eval_arithFun c nats f) (eval_arithFun c nats (Suma fs));
eval_arithFun_unbound c nats (Prod []) = one_nat;
eval_arithFun_unbound c nats (Prod (f : fs)) =
  times_nat (eval_arithFun c nats f) (eval_arithFun c nats (Prod fs));
eval_arithFun_unbound c nats (Max [f]) = eval_arithFun c nats f;
eval_arithFun_unbound c nats (Max (f : v : va)) =
  max (eval_arithFun c nats f) (eval_arithFun c nats (Max (v : va)));
eval_arithFun_unbound c nats (Min [f]) = eval_arithFun c nats f;
eval_arithFun_unbound c nats (Min (f : v : va)) =
  min (eval_arithFun c nats f) (eval_arithFun c nats (Min (v : va)));
eval_arithFun_unbound c nats (IfEqual f1 f2 ft fe) =
  (if equal_nat (eval_arithFun c nats f1) (eval_arithFun c nats f2)
    then eval_arithFun c nats ft else eval_arithFun c nats fe);

sl_inter_to_inter :: forall a. (Eq a) => Sl_inter a -> a -> [Nat] -> Nat;
sl_inter_to_inter (SL_Inter c ls) fl cs =
  (case map_of ls (fl, size_list cs) of {
    Nothing -> zero_nat;
    Just a -> eval_arithFun (suc c) cs a;
  });

sli_to_slm ::
  forall a.
    (Eq a) => Sl_inter (Lab a [Nat]) ->
                Slm_ops_ext (Lab a [Nat]) Nat (Sum [Nat] [Lab a [Nat]]) ();
sli_to_slm sli =
  let {
    c = get_largest_element sli;
  } in Slm_ops_ext (\ _ -> Inl) (sl_inter_to_inter sli) (upt zero_nat (suc c)) c
         (\ _ -> Inl) ();

enum_vectors_nat :: forall a. [a] -> Nat -> [[a]];
enum_vectors_nat c n =
  (if equal_nat n zero_nat then [[]]
    else let {
           a = enum_vectors_nat c (minus_nat n one_nat);
         } in concatMap (\ vec -> map (\ ca -> ca : vec) c) a);

qmodel_check_interpretation ::
  ArithFun -> Nat -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_interpretation f n c =
  let {
    ca = upt zero_nat (suc c);
    css = enum_vectors_nat ca n;
  } in catch_errora
         (forallM
           (\ cs ->
             catch_errora
               (forallM
                 (\ i ->
                   catch_errora
                     (forallM
                       (\ l ->
                         check (less_eq_nat (eval_arithFun (suc c) cs f)
                                 (eval_arithFun (suc c) (list_update cs i l) f))
                           (shows_prec_list zero_nat
                              ['n', 'o', 't', ' ', 'm', 'o', 'n', 'o', 't', 'o',
                                'n', 'e', ' ', 'i', 'n', ' '] .
                             shows_prec_nat zero_nat (suc i) .
                               shows_prec_list zero_nat
                                 ['.', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n',
                                   't']))
                       (upt (nth cs i) (suc c)))
                     (\ x -> Inl (snd x)))
                 (upt zero_nat n))
               (\ x -> Inl (snd x)))
           css)
         (\ x -> Inl (snd x));

qmodel_check_valid ::
  forall a.
    (Showa a) => Sl_inter a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_valid (SL_Inter c ls) =
  catch_errora
    (forallM
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ g ->
               catch_errora (qmodel_check_interpretation g n c)
                 (\ x ->
                   Inl (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n',
                            ' ', 'w', 'e', 'a', 'k', '-', 'm', 'o', 'n', 'o',
                            't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ' ', 'o',
                            'f', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r', 'e',
                            't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                         shows_prec zero_nat f . shows_nl . x)))
          b)
      ls)
    (\ x -> Inl (snd x));

check_decr_present_aux_1 ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a (b, Nat), Term a (b, Nat))] ->
                           b -> a -> a -> Nat ->
    Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present_aux_1 r v f1 f2 n =
  let {
    vs = map (\ na -> Var (v, na)) (upt zero_nat n);
    rule = (Fun f1 vs, Fun f2 vs);
  } in check (not (is_none (find (instance_rule rule) r))) rule;

check_decr_present_aux_2 ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           b -> [(a, (a, Nat))] ->
                                  Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present_aux_2 r v req =
  let {
    add_nats = map_term (\ x -> x) (\ va -> (va, zero_nat));
    ra = map (\ (l, ra) -> (add_nats l, add_nats ra)) r;
  } in catch_errora
         (forallM (\ (f1, a) -> let {
                                  (aa, b) = a;
                                } in check_decr_present_aux_1 ra v f1 aa b)
           req)
         (\ x -> Inl (snd x));

check_decr_present ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(a, Nat)] ->
                           (a -> [Nat] -> a) ->
                             b -> Nat ->
                                    [(Term a b, Term a b)] ->
                                      Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present sig l v c r =
  let {
    ca = upt zero_nat (suc c);
    ls = (\ (f, n) ->
           concatMap
             (\ cs ->
               concatMap
                 (\ i ->
                   let {
                     ci = nth cs i;
                   } in (if less_nat ci c
                          then [(l f (list_update cs i (suc ci)), (l f cs, n))]
                          else []))
                 (upt zero_nat n))
             (enum_vectors_nat ca n));
  } in check_decr_present_aux_2 r v (concatMap ls sig);

qmodel_check_decr ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b,
      Mapping_impl b) => [(Lab a [Nat], Nat)] ->
                           b -> Nat ->
                                  [(Term (Lab a [Nat]) b,
                                     Term (Lab a [Nat]) b)] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_decr sig v c =
  (\ lR ->
    catch_errora (check_decr_present sig Lab v c lR)
      (\ x ->
        Inl (let {
               display =
                 map_term (\ xa -> xa)
                   (\ (_, n) ->
                     (shows_prec_list zero_nat ['x'] .
                       shows_prec_nat zero_nat n)
                       []);
             } in shows_prec_list zero_nat
                    ['d', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n', 'g', ' ', 'r',
                      'u', 'l', 'e', ' '] .
                    shows_rule (shows_prec_lab zero_nat)
                      (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                      (display (fst x), display (snd x)) .
                      shows_prec_list zero_nat
                        [' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])));

qmodel_LS_gen ::
  forall a b c. (Eq a) => [(a, Nat)] -> [b] -> a -> Nat -> [Sum [b] c];
qmodel_LS_gen sig ls =
  (\ f n ->
    (if membera sig (f, n) then map Inl (enum_vectors_nat ls n) else [Inl []]));

pointwise_lgen :: [Nat] -> [[Nat]];
pointwise_lgen ns = concat_lists (map (\ n -> upt zero_nat (suc n)) ns);

qmodel_lgen :: forall a. Sum [Nat] a -> [Sum [Nat] a];
qmodel_lgen l = (case l of {
                  Inl ns -> map Inl (pointwise_lgen ns);
                  Inr _ -> [];
                });

qmodel_LSa :: forall a. Lab a [Nat] -> Nat -> Sum [Nat] [Lab a [Nat]] -> Bool;
qmodel_LSa = (\ _ _ a -> (case a of {
                           Inl _ -> True;
                           Inr _ -> False;
                         }));

qmodel_LS ::
  forall a b c.
    (Eq a, Eq b, Eq c) => [(a, Nat)] -> [b] -> a -> Nat -> Sum [b] c -> Bool;
qmodel_LS sig ls = (\ f n -> membera (qmodel_LS_gen sig ls f n));

qmodel_L ::
  forall a b c d.
    (Eq a, Eq b) => [(Lab a b, Nat)] -> Lab a b -> [c] -> Sum [c] d;
qmodel_L sig =
  (\ f cs -> (if membera sig (f, size_list cs) then Inl cs else Inl []));

qsli_to_sl_unsafe ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Showa b) => a -> [(Lab b [Nat], Nat)] ->
                         [(Lab b [Nat], Nat)] ->
                           Sl_inter (Lab b [Nat]) ->
                             Sl_ops_ext (Lab b [Nat]) Nat
                               (Sum [Nat] [Lab b [Nat]]) a ();
qsli_to_sl_unsafe v f g sli =
  let {
    c = get_largest_element sli;
    ca = upt zero_nat (suc c);
  } in Sl_ops_ext (qmodel_L f) (qmodel_LS f ca) (sl_inter_to_inter sli) ca c
         (qmodel_check_decr f v c) (qmodel_L g) qmodel_LSa qmodel_lgen
         (qmodel_LS_gen f ca) ();

qsli_to_sl ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Showa b) => a -> [(Lab b [Nat], Nat)] ->
                         [(Lab b [Nat], Nat)] ->
                           Sl_inter (Lab b [Nat]) ->
                             Sum ([Prelude.Char] -> [Prelude.Char])
                               (Sl_ops_ext (Lab b [Nat]) Nat
                                 (Sum [Nat] [Lab b [Nat]]) a ());
qsli_to_sl v f g sli =
  bindb (qmodel_check_valid sli) (\ _ -> Inr (qsli_to_sl_unsafe v f g sli));

pointwise_ext ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
pointwise_ext f [] [] = (False, True);
pointwise_ext f (uu : uv) [] = (False, False);
pointwise_ext f [] (uw : ux) = (False, False);
pointwise_ext f (a : asa) (b : bs) =
  (case f a b of {
    (stri, True) -> (case pointwise_ext f asa bs of {
                      (strir, True) -> (stri || strir, True);
                      (_, False) -> (False, False);
                    });
    (_, False) -> (False, False);
  });

qmodel_lge :: forall a b c d. a -> b -> Sum [Nat] c -> Sum [Nat] d -> Bool;
qmodel_lge f n =
  (\ l r ->
    (case (l, r) of {
      (Inl cs1, Inl cs2) ->
        snd (pointwise_ext (\ x y -> (less_nat y x, less_eq_nat y x)) cs1 cs2);
      (Inl _, Inr _) -> False;
      (Inr _, _) -> False;
    }));

qmodel_cge :: Nat -> Nat -> Bool;
qmodel_cge = (\ x y -> less_eq_nat y x);

rl_slm ::
  forall a b.
    (Eq a,
      Eq b) => Maybe (Lab a b, Nat) ->
                 [(Lab a b, Nat)] ->
                   [(Lab a b, Nat)] ->
                     Sum ([Prelude.Char] -> [Prelude.Char])
                       (Slm_ops_ext (Lab a b) (Lab a b) (Sum b [Lab a b]) ());
rl_slm delt_opt pre_fs g =
  let {
    fs = (if is_none delt_opt then pre_fs
           else filter (\ f -> not (f == the delt_opt)) pre_fs);
  } in bindb (check (not (null fs))
               (shows_string
                  ['r', 'o', 'o', 't', '-', 'l', 'a', 'b', 'e', 'l', 'i', 'n',
                    'g', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'a',
                    't', ' ', 'l', 'e', 'a', 's', 't', ' ', 'o', 'n', 'e', ' ',
                    'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 's', 'y', 'm',
                    'b', 'o', 'l', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 's',
                    'i', 'g', 'n', 'a', 't', 'u', 'r', 'e'] .
                 shows_nl))
         (\ _ ->
           let {
             f = fst (hda fs);
           } in Inr (Slm_ops_ext (\ _ -> Inr)
                      (\ ga cs ->
                        (if membera fs (ga, size_list cs) then ga else f))
                      (map fst fs) f
                      (if is_none delt_opt then (\ _ -> Inr)
                        else (\ _ gs ->
                               Inr (replicate (size_list gs)
                                     (fst (the delt_opt)))))
                      ()));

semlab_fin_proc ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a (Lab b [Nat]) c () ->
                    Sl_variant (Lab b [Nat]) c ->
                      [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                        [Term (Lab b [Nat]) c] ->
                          [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
semlab_fin_proc j (Rootlab Nothing) =
  sem_lab_fin_proc label label_decomp j (slm_gen_to_sl_gen (rl_slm Nothing));
semlab_fin_proc j (Rootlab (Just d)) =
  sem_lab_fin_root_proc label label_decomp j
    (slm_gen_to_sl_gen (rl_slm (Just d)));
semlab_fin_proc j (Finitelab sli) =
  sem_lab_fin_proc label label_decomp j
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli)));
semlab_fin_proc j (QuasiFinitelab sli v) =
  sem_lab_fin_quasi_root_proc label label_decomp qmodel_cge qmodel_lge j
    (\ f g -> qsli_to_sl v f g sli);

all_terms_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    [([Term a [Prelude.Char]], Term a [Prelude.Char])];
all_terms_impl rr initt =
  remdups
    (map (\ (ss, (t, _)) -> (ss, t)) initt ++ map (\ (l, a) -> (args l, a)) rr);

all_subterms_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    [([Term a [Prelude.Char]], Term a [Prelude.Char])];
all_subterms_impl rr initt =
  remdups
    (concatMap (\ (ss, s) -> map (\ a -> (ss, a)) (supteq_list s))
      (all_terms_impl rr initt));

everything_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    [Sum ([Term a [Prelude.Char]],
                           (Term a [Prelude.Char],
                             (Term a [Prelude.Char], Term a [Prelude.Char])))
                       ((a, Nat), Nat)];
everything_impl rr initt =
  map Inl
    (concatMap
      (\ (ss, t) ->
        map (\ lr -> (ss, (t, lr))) (remdups (map (snd . snd) initt)))
      (all_subterms_impl rr initt)) ++
    remdups
      (map Inr
        (concatMap
          (\ t ->
            (if not (is_Var t)
              then concatMap
                     (\ (f, ts) ->
                       map (\ a -> ((f, size_list ts), a))
                         (upt zero_nat (size_list ts)))
                     (let {
                        (Fun f ts) = t;
                      } in [(f, ts)])
              else []))
          (remdups (map snd (all_subterms_impl rr initt)))));

generate_impl ::
  forall a b c d.
    (Eq a, Key a, Eq b,
      Eq c) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                 (Term a [Prelude.Char] -> Bool) ->
                   ([Term a [Prelude.Char]] ->
                     Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                     ([Term a [Prelude.Char]] ->
                       Term a [Prelude.Char] -> [(b, c)]) ->
                       Sum ([Term a [Prelude.Char]],
                             (Term a [Prelude.Char], (b, c)))
                         d ->
                         [Sum ([Term a [Prelude.Char]],
                                (Term a [Prelude.Char], (b, c)))
                            ((a, Nat), Nat)];
generate_impl rr nfq e_cap uu (Inr v) = [];
generate_impl rr nfq e_cap uu (Inl (va, (Var ve, vd))) = [];
generate_impl rr nfq e_cap uu (Inl (ss, (Fun f ts, (l, r)))) =
  concatMap
    (\ i ->
      (if membera (uu ss (nth ts i)) (l, r)
        then map (\ u -> u)
               [Inl (ss, (nth ts i, (l, r))), Inr ((f, size_list ts), i)]
        else []))
    (upt zero_nat (size_list ts)) ++
    concatMap
      (\ (la, ra) ->
        concatMap
          (\ mss ->
            (if rule_match_impl nfq (e_cap mss) mss f
                  (map (map_term (\ x -> x) (\ a -> 'x' : a)) ts) la
              then (if membera (uu (args la) ra) (l, r)
                     then [Inl (args la, (ra, (l, r)))] else [])
              else []))
          [map (map_term (\ x -> x) (\ a -> 'x' : a)) ss])
      rr;

mu_approx_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])]) ->
                      (Term a [Prelude.Char] -> Bool) ->
                        ([Term a [Prelude.Char]] ->
                          Term a [Prelude.Char] ->
                            Term a (Sum () [Prelude.Char])) ->
                          ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
mu_approx_impl rr initt u_impl nfq e_cap =
  let {
    uu = precompute_fun (\ (a, b) -> u_impl a b) (all_subterms_impl rr initt);
    uua = (\ s t -> uu (s, t));
    fis = remdups
            (concatMap (\ entry -> map (\ fi -> fi) (case entry of {
              Inl _ -> [];
              Inr fi -> [fi];
            }))
              (inductive_set_impl (everything_impl rr initt) equal_sum
                (generate_impl rr nfq e_cap uua) (map Inl initt)));
    fs = remdups (map fst fis);
    mu = (\ f ->
           set (map_filter
                 (\ x -> (if let {
                               (g, _) = x;
                             } in g == f
                           then Just (snd x) else Nothing))
                 fis));
  } in (fs, (precompute_fun mu fs,
              ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'U', 'R', 'M',
                ' ', 'w', 'r', 't', '.', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i',
                'c', ' ', 'r', 'u', 'l', 'e', 's']));

inn_usable_rules_wf ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  ([Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      Bool ->
                        ([Term a [Prelude.Char]], Term a [Prelude.Char]) ->
                          [(Term a [Prelude.Char], Term a [Prelude.Char])];
inn_usable_rules_wf nfq e_cap r nfs =
  (\ (ss, t) ->
    (if nfs ||
          all (\ x -> any (contains_var_term x) ss) (remdups (vars_term_list t))
      then ur_calc_singleton nfq e_cap r (ss, t) else r));

inn_usable_rules_wf_dpp ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> Bool ->
                         ([Term b [Prelude.Char]], Term b [Prelude.Char]) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])];
inn_usable_rules_wf_dpp i d nfs =
  inn_usable_rules_wf (is_QNFc i d) (icap_impl_dpp i d) (rulese i d) nfs;

get_innermost_strict_repl_map_dpp ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                         ([(b, Nat)], ((b, Nat) -> Set Nat, [Prelude.Char]));
get_innermost_strict_repl_map_dpp i d s =
  let {
    r = rulese i d;
    p = pairsb i d;
    isNF = is_QNFc i d;
    u = inn_usable_rules_wf_dpp i d True;
    a = icap_impl_dpp i d;
  } in mu_approx_impl r
         (concatMap (\ (sa, t) -> map (\ lr -> ([sa], (t, lr))) s) p)
         (\ ss t -> u (ss, t)) isNF a;

show_position_set ::
  forall a. (a, Nat) -> Set Nat -> [Prelude.Char] -> [Prelude.Char];
show_position_set f s =
  shows_list_nat
    (concatMap (\ i -> (if member i s then [suc i] else []))
      (upt zero_nat (snd f)));

mono_af :: forall a b c. Redtriple_ext a b c -> (a, Nat) -> Set Nat;
mono_af (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  mono_af;

mono_urm_redpair_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_urm_redpair_proc i rp premove rremove dpp =
  (case catch_errora
          (let {
             (ps, pns) = split_pairsa i dpp premove;
             (rs, rns) = split_rulesc i dpp rremove;
             r = rulese i dpp;
             _ = qc i dpp;
             p = pairsb i dpp;
           } in bindb (check_wf_trs p)
                  (\ _ ->
                    bindb (check_wf_trs r)
                      (\ _ ->
                        bindb (check (nFQ_subset_NF_rulesc i dpp)
                                (shows_prec_list zero_nat
                                  ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't',
                                    ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e',
                                    'd']))
                          (\ _ ->
                            let {
                              (fs, (mu, info)) =
                                get_innermost_strict_repl_map_dpp i dpp rs;
                            } in bindb (valid rp)
                                   (\ _ ->
                                     let {
                                       mua = mono_af rp;
                                     } in bindb
    (catch_errora
      (catch_errora
        (forallM
          (\ f ->
            check (subset (mu f) (mua f))
              (shows_string
                 ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'm', 'o', 'n',
                   'o', 't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ':', ' ', 's',
                   't', 'r', 'i', 'c', 't', ' ', 'o', 'r', 'd', 'e', 'r', ' ',
                   'f', 'o', 'r', ' '] .
                shows_prec_prod zero_nat f .
                  shows_string
                    [' ', 'e', 'n', 's', 'u', 'r', 'e', 's', ' ', 'm', 'o', 'n',
                      'o', 't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ' ', 'i',
                      'n', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n', 's',
                      ' '] .
                    show_position_set f (mua f) .
                      shows_string
                        ['\n', 'b', 'u', 't', ' ', 'u', 's', 'a', 'b', 'l', 'e',
                          ' ', 'r', 'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n',
                          't', ' ', 'm', 'a', 'p', ' ', 'i', 's', ' '] .
                        show_position_set f (mu f)))
          fs)
        (\ x -> Inl (snd x)))
      (\ x ->
        Inl (x . shows_string
                   ['\n', 't', 'h', 'e', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'e',
                     'd', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'e', 'p',
                     'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ' ', 'm', 'a', 'p',
                     ' ', '('] .
                   shows_string info .
                     shows_string [')', ' ', 'i', 's', '\n'] .
                       shows_sep
                         (\ f ->
                           shows_prec_list zero_nat ['m', 'u', '('] .
                             shows_prec_prod zero_nat f .
                               shows_prec_list zero_nat [')', ' ', '=', ' '] .
                                 show_position_set f (mu f))
                         shows_nl fs .
                         shows_prec_list zero_nat
                           ['\n', 'a', 'n', 'd', ' ', 'm', 'u', '(', 'f', ')',
                             ' ', '=', ' ', '{', '}', ' ', 'f', 'o', 'r', ' ',
                             'a', 'l', 'l', ' ', 'o', 't', 'h', 'e', 'r', ' ',
                             's', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'f'])))
    (\ _ ->
      bindb (catch_errora
              (catch_errora (forallM (ns rp) rns) (\ x -> Inl (snd x)))
              (\ x ->
                Inl (shows_string
                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                         'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                         ' ', 'T', 'R', 'S'] .
                      shows_nl . x)))
        (\ _ ->
          bindb (catch_errora
                  (catch_errora (forallM (s rp) rs) (\ x -> Inl (snd x)))
                  (\ x ->
                    Inl (shows_string
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h',
                             'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i',
                             'n', 'g', ' ', 'T', 'R', 'S'] .
                          shows_nl . x)))
            (\ _ ->
              bindb (catch_errora
                      (catch_errora (forallM (ns rp) pns) (\ x -> Inl (snd x)))
                      (\ x ->
                        Inl (shows_string
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n',
                                 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
                              shows_nl . x)))
                (\ _ ->
                  catch_errora
                    (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
                    (\ x ->
                      Inl (shows_string
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h',
                               'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i',
                               'n', 'g', ' ', 'D', 'P', 's'] .
                            shows_nl . x)))))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'd', 'u',
                     'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                     'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'e', 'p',
                     'l', '.', ' ', 'm', 'a', 'p', 's', ' ', 'a', 'n', 'd', ' ',
                     't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n',
                     'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

partition_rules ::
  forall a b.
    (Eq a,
      Eq b) => [Ctxt a b] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     ([(Term a b, Term a b)], [(Term a b, Term a b)]);
partition_rules cs r =
  partition
    (\ lr ->
      any (\ (u, v) ->
            any (\ c -> lr == (ctxt_apply_term c u, ctxt_apply_term c v))
              (Hole : cs))
        r);

strip_unary_root :: forall a b. (Eq a) => a -> Term a b -> Term a b;
strip_unary_root f (Fun g [t]) = (if f == g then t else Fun g [t]);
strip_unary_root f (Var v) = Var v;
strip_unary_root f (Fun v []) = Fun v [];
strip_unary_root f (Fun v (vb : vd : ve)) = Fun v (vb : vd : ve);

has_unary_root :: forall a b. (Eq a) => a -> Term a b -> Bool;
has_unary_root f (Fun g [t]) = f == g;
has_unary_root f (Var v) = False;
has_unary_root f (Fun v []) = False;
has_unary_root f (Fun v (vb : vd : ve)) = False;

unblock_term :: forall a b. (Eq a) => a -> Term a b -> Term a b;
unblock_term f (Fun g ts) =
  (if all (has_unary_root f) ts then Fun g (map (strip_unary_root f) ts)
    else Fun g ts);
unblock_term f (Var v) = Var v;

unblock_rule ::
  forall a b. (Eq a) => a -> (Term a b, Term a b) -> (Term a b, Term a b);
unblock_rule f r = (unblock_term f (fst r), unblock_term f (snd r));

partition_pairs ::
  forall a b.
    (Eq a,
      Eq b) => a -> [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]);
partition_pairs f p = partition (\ r -> membera p (unblock_rule f r));

check_no_defined_root_defined ::
  forall a b.
    (Eq a, Showa a,
      Showa b) => [(a, Nat)] ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_defined_root_defined f t =
  check (not (membera f (the (root t))))
    (shows_string ['t', 'h', 'e', ' ', 'r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
      shows_prec_term zero_nat t .
        shows_string [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd']);

block_term :: forall a b. a -> Term a b -> Term a b;
block_term f (Var x) = Var x;
block_term f (Fun g ts) = Fun g (map (\ t -> Fun f [t]) ts);

block_rule :: forall a b. a -> (Term a b, Term a b) -> (Term a b, Term a b);
block_rule f r = (block_term f (fst r), block_term f (snd r));

check_superset_of_blocked ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> [(Term a b, Term a b)] ->
                         [(Term a b, Term a b)] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_superset_of_blocked f pa p =
  catch_errora
    (catch_errora
      (catch_errora
        (forallM
          (\ x -> (if membera pa (block_rule f x) then Inr () else Inl x)) p)
        (\ x -> Inl (snd x)))
      (\ x ->
        Inl (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '-', '>', ' '] (block_rule f x) .
                shows_string
                  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'] .
                  shows_nl)))
    (\ x ->
      Inl (shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
             ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't', 'e',
               'm', ':']
             [' ', '-', '>', ' '] p .
            shows_string
              ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 's',
                'e', 't', ' ', 'o', 'f'] .
              shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't',
                  'e', 'm', ':']
                [' ', '-', '>', ' '] pa .
                x . shows_nl));

hole_at :: forall a b. (Eq a) => Nat -> Nat -> a -> Ctxt a b -> Bool;
hole_at n i f (More g ss1 Hole ss2) =
  g == f &&
    equal_nat (size_list ss1) i &&
      equal_nat (size_list ss2) (minus_nat (minus_nat n i) one_nat);
hole_at n i f Hole = False;
hole_at n i f (More v va (More vd ve vf vg) vc) = False;

check_flat_ctxt_complete ::
  forall a b.
    (Eq a, Showa a,
      Showa b) => [Ctxt a b] ->
                    (a, Nat) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_flat_ctxt_complete fcs fa =
  check (all_interval_nat (\ i -> any (hole_at (snd fa) i (fst fa)) fcs)
          zero_nat (snd fa))
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'i', 's', 't', ' ', 'o', 'f', ' ', 'f', 'l',
         'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', 's', ' ', 'i', 's',
         ' ', 'i', 'n', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'e'] .
      shows_nl);

check_rule_reflecting ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [Ctxt a b] ->
                    [(Term a b, Term a b)] ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_reflecting fcs rs rule =
  check (any (\ (l, r) ->
               any (\ c ->
                     equal_term (fst rule) (ctxt_apply_term c l) &&
                       equal_term (snd rule) (ctxt_apply_term c r))
                 (Hole : fcs))
          rs)
    (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] rule .
        shows_string
          [' ', 'i', 's', ' ', 'n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'c', 'o',
            'n', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h',
            'e', ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 's', 'e',
            't', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'n', 'o',
            'r', ' ', 'o', 'b', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'b', 'y',
            ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'a', ' ', 'f',
            'l', 'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
          shows_nl);

check_rule_preserving ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [Ctxt a b] ->
                    [(Term a b, Term a b)] ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_preserving fcs rs rule =
  check (any (instance_rule rule) rs ||
          all (\ c ->
                any (instance_rule
                      (ctxt_apply_term c (fst rule),
                        ctxt_apply_term c (snd rule)))
                  rs)
            fcs)
    (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] rule .
        shows_string
          [' ', 'i', 's', ' ', 'n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'c', 'o',
            'n', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h',
            'e', ' ', 'r', 'e', 's', 'u', 'l', 't', 'i', 'n', 'g', ' ', 's',
            'e', 't', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'n',
            'o', 'r', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'u', 'n', 'd',
            'e', 'r', ' ', 'a', 'l', 'l', ' ', 'f', 'l', 'a', 't', ' ', 'c',
            'o', 'n', 't', 'e', 'x', 't', 's'] .
          shows_nl);

is_flat_ctxt_list ::
  forall a b. (Eq a, Eq b) => [a] -> [(b, Nat)] -> Ctxt b a -> Bool;
is_flat_ctxt_list vs fas (More f ss1 Hole ss2) =
  let {
    ss = ss1 ++ ss2;
  } in membera fas (f, suc (size_list ss)) &&
         all is_Var ss && distinct ss && null (list_inter (map the_Var ss) vs);
is_flat_ctxt_list vs fas Hole = False;
is_flat_ctxt_list vs fas (More v va (More vd ve vf vg) vc) = False;

shows_prec_ctxt ::
  forall a b.
    (Showa a, Showa b) => Nat -> Ctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_ctxt p c = shows_ctxt (shows_prec zero_nat) (shows_prec zero_nat) c;

check_is_flat_ctxt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [a] ->
                    [(b, Nat)] ->
                      Ctxt b a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_is_flat_ctxt vs fas c =
  check (is_flat_ctxt_list vs fas c)
    (shows_prec_ctxt zero_nat c .
      shows_string
        [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'f', 'l', 'a', 't',
          ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
        shows_nl);

check_flat_ctxt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [a] -> Ctxt b a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_flat_ctxt vs c =
  (case c of {
    Hole ->
      Inl (shows_prec_ctxt zero_nat c .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'f', 'l', 'a',
                't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
              shows_nl);
    More _ ss1 Hole ss2 ->
      let {
        ss = ss1 ++ ss2;
      } in bindb (check (distinct ss)
                   (shows_prec_ctxt zero_nat c .
                     shows_string
                       [' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'd',
                         'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', ' ', 'v', 'a',
                         'r', 'i', 'a', 'b', 'l', 'e', 's'] .
                       shows_nl))
             (\ _ ->
               bindb (check (all is_Var ss)
                       (shows_prec_ctxt zero_nat c .
                         shows_string
                           [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'l',
                             'a', 't', ',', ' ', 'i', '.', 'e', '.', ',', ' ',
                             'h', 'a', 's', ' ', 'd', 'e', 'p', 't', 'h', ' ',
                             'g', 'r', 'e', 'a', 't', 'e', 'r', ' ', 't', 'h',
                             'a', 'n', ' ', 'o', 'n', 'e'] .
                           shows_nl))
                 (\ _ ->
                   check (all (\ t -> not (membera vs (the_Var t)))
                           (ss1 ++ ss2))
                     (shows_prec_ctxt zero_nat c .
                       shows_string
                         [' ', 'h', 'a', 's', ' ', 't', 'o', ' ', 'c', 'o', 'n',
                           't', 'a', 'i', 'n', ' ', 'o', 'n', 'l', 'y', ' ',
                           'f', 'r', 'e', 's', 'h', ' ', 'v', 'a', 'r', 'i',
                           'a', 'b', 'l', 'e', 's'] .
                         shows_nl)));
    More _ _ (More _ _ _ _) _ ->
      Inl (shows_prec_ctxt zero_nat c .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'f', 'l', 'a',
                't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
              shows_nl);
  });

shows_terms ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] -> [Term a b] -> [Prelude.Char] -> [Prelude.Char];
shows_terms fun var name ts =
  ((shows_prec_list zero_nat name . shows_nl) .
    shows_list_gen (shows_term fun var) [] [] ['\n'] [] ts) .
    shows_nl;

shows_dpp ::
  forall a b c.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Dpp_ops_ext c a b () -> c -> [Prelude.Char] -> [Prelude.Char];
shows_dpp fun var i d =
  let {
    m = minimal i d;
    nfs = nfsc i d;
    p = pb i d;
    pw = pwb i d;
    r = rd i d;
    rw = rwd i d;
    q = qc i d;
  } in shows_trs fun var ['p', 'a', 'i', 'r', 's', ':'] [' ', '-', '>', ' '] p .
         (if null pw then id
           else shows_trs fun var
                  ['w', 'e', 'a', 'k', ' ', 'p', 'a', 'i', 'r', 's', ':']
                  [' ', '-', '>', '=', ' '] pw) .
           (if null r then id
             else shows_trs fun var
                    ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's',
                      ':']
                    [' ', '-', '>', '!', ' '] r) .
             shows_trs fun var ['r', 'u', 'l', 'e', 's', ':']
               [' ', '-', '>', ' '] rw .
               (if null q then id
                 else shows_terms fun var
                        ['Q', '-', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't',
                          ':']
                        q) .
                 (if m then shows_nl .
                              shows_prec_list zero_nat
                                ['(', 'm', 'i', 'n', 'i', 'm', 'a', 'l', ')']
                   else id) .
                   (if nfs && not (null q)
                     then shows_nl .
                            shows_prec_list zero_nat
                              ['(', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
                                'r', 'm', ' ', 's', 'u', 'b', 's', 't', 'i',
                                't', 'u', 't', 'i', 'o', 'n', 's', ')']
                     else id);

fcc_proc_cond ::
  forall a b c.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               [(Term b c, Term b c)] ->
                                 [(Term b c, Term b c)] ->
                                   a -> Sum ([Prelude.Char] -> [Prelude.Char])
  a;
fcc_proc_cond i f fcs p pw r rw dpp =
  let {
    pa = pb i dpp;
    pwa = pwb i dpp;
    ra = rd i dpp;
    rwa = rwd i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    new_dpp = mkd i nfs m p pw [] r rw;
  } in (case catch_errora
               (let {
                  pba = list_union pa pwa;
                  rb = list_union ra rwa;
                  rba = list_union r rw;
                  fa = (f, one_nat);
                  cf = More f [] Hole [];
                  fcsa = cf : fcs;
                  vs = vars_trs_list rb;
                  fs = list_union (funas_trs_list rb) (funas_args_trs_list pba);
                  fas = fa : fs;
                  ds = defined_list rb;
                } in bindb (check (not (membera ds fa))
                             (shows_prec zero_nat f .
                               shows_string
                                 ['i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r',
                                   'e', 's', 'h'] .
                                 shows_nl))
                       (\ _ ->
                         bindb (check_wf_trs rb)
                           (\ _ ->
                             bindb (catch_errora
                                     (forallM
                                       (\ rc ->
 bindb (check_no_var (fst rc))
   (\ _ ->
     bindb (check_no_var (snd rc))
       (\ _ -> check_no_defined_root_defined ds (snd rc))))
                                       pba)
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 bindb (catch_errora
 (forallM (check_flat_ctxt vs) fcsa) (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (catch_errora
     (forallM (check_is_flat_ctxt vs fas) fcsa) (\ x -> Inl (snd x)))
                                       (\ _ ->
 bindb (catch_errora (forallM (check_flat_ctxt_complete fcsa) fas)
         (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (catch_errora (forallM (check_rule_preserving fcsa r) ra)
             (\ x -> Inl (snd x)))
       (\ _ ->
         bindb (catch_errora (forallM (check_rule_preserving fcsa rba) rwa)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             bindb (catch_errora (forallM (check_rule_reflecting fcsa rb) rba)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check_superset_of_blocked f p pa)
                   (\ _ -> check_superset_of_blocked f pw pwa)))))))))))
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                          'n', ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ',
                          'f', 'l', 'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x',
                          't', ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e', ' ', 'c',
                          'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ', 't',
                          'o', ' ', 's', 'w', 'i', 't', 'c', 'h', ' ', 'f', 'r',
                          'o', 'm', ' '] .
                       shows_nl .
                         shows_dpp (shows_prec zero_nat) (shows_prec zero_nat) i
                           dpp .
                           shows_nl .
                             shows_prec_list zero_nat
                               ['t', 'o', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                                 ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                               shows_nl .
                                 shows_dpp (shows_prec zero_nat)
                                   (shows_prec zero_nat) i new_dpp .
                                   shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr new_dpp;
       });

g_to_list_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> [a];
g_to_list_dflt_basic_oops_rm_basic_ops s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ _ -> True)
    (\ a b -> a : b) [];

delete_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
delete_rm_basic_ops x s = delete x s;

ceta_list_diff :: forall a. (Key a) => [a] -> [a] -> [a];
ceta_list_diff xs ys =
  g_to_list_dflt_basic_oops_rm_basic_ops
    (foldl (\ a b -> delete_rm_basic_ops b a)
      (g_from_list_dflt_basic_oops_rm_basic_ops xs) ys);

fcc_split_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Ceq c, Ccompare c, Eq c, Key c, Mapping_impl c,
      Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               [(Term b c, Term b c)] ->
                                 [(Term b c, Term b c)] ->
                                   a -> Sum ([Prelude.Char] -> [Prelude.Char])
  (a, a);
fcc_split_proc i f fcs pba rb ps rs dpp =
  let {
    p = pb i dpp;
    pw = pwb i dpp;
    r = rd i dpp;
    rw = rwd i dpp;
    q = qc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    pbaa = list_union p pw;
    rba = rw;
    pns = ceta_list_diff pbaa ps;
    rns = ceta_list_diff rba rs;
    (pa, pwa) = partition_pairs f ps pba;
    (ra, rwa) = partition_rules (More f [] Hole [] : fcs) rs rb;
    two = mkd i nfs m (ceta_list_diff p ps) (ceta_list_diff pw ps) [] [] rns;
    dpp_mid = mkd i nfs m ps pns [] rs rns;
  } in bindb (bindb
               (catch_errora (check_subseteq ps pbaa)
                 (\ x ->
                   Inl (shows_prec_list zero_nat ['p', 'a', 'i', 'r', ' '] .
                         shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                           [' ', '-', '>', ' '] x .
                           shows_prec_list zero_nat
                             [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e',
                               ' ', 'd', 'e', 'l', 'e', 't', 'e', 'd', ' ', 'b',
                               'u', 't', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                               'p', 'r', 'e', 's', 'e', 'n', 't'])))
               (\ _ ->
                 bindb (catch_errora (check_subseteq rs rba)
                         (\ x ->
                           Inl (shows_prec_list zero_nat
                                  ['r', 'u', 'l', 'e', ' '] .
                                 shows_rule (shows_prec zero_nat)
                                   (shows_prec zero_nat) [' ', '-', '>', ' ']
                                   x .
                                   shows_prec_list zero_nat
                                     [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ',
                                       'b', 'e', ' ', 'd', 'e', 'l', 'e', 't',
                                       'e', 'd', ' ', 'b', 'u', 't', ' ', 'i',
                                       's', ' ', 'n', 'o', 't', ' ', 'p', 'r',
                                       'e', 's', 'e', 'n', 't'])))
                   (\ _ ->
                     bindb (check (null q)
                             (shows_string
                                ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                                  'e', 'm', 'p', 't', 'y'] .
                               shows_nl))
                       (\ _ ->
                         bindb (check (null r)
                                 (shows_prec_list zero_nat
                                   ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u',
                                     'l', 'e', 's', ' ', 'n', 'o', 't', ' ',
                                     'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                           (\ _ ->
                             bindb (check_left_linear_trs rw)
                               (\ _ ->
                                 fcc_proc_cond i f fcs pa pwa ra rwa
                                   dpp_mid))))))
         (\ one -> Inr (one, two));

mono_redpair_proc ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_redpair_proc i rp premove rremove dpp =
  (case catch_errora
          (let {
             (ps, pns) = split_pairsa i dpp premove;
             (rs, rns) = split_rulesc i dpp rremove;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (catch_errora (mono rp (ps ++ rs ++ pns ++ rns))
                            (\ x ->
                              Inl (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'm', 'o', 'n',
                                       'o', 't', 'o', 'n', 'i', 'c', 'i', 't',
                                       'y', ' ', 'o', 'f', ' ', 's', 't', 'r',
                                       'i', 'c', 't', ' ', 'o', 'r', 'd', 'e',
                                       'r'] .
                                    shows_nl . x)))
                      (\ _ ->
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T', 'R', 'S'] .
shows_nl . x)))
                          (\ _ ->
                            bindb (catch_errora
                                    (catch_errora (forallM (s rp) rs)
                                      (\ x -> Inl (snd x)))
                                    (\ x ->
                                      Inl
(shows_string
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
     'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T', 'R', 'S'] .
  shows_nl . x)))
                              (\ _ ->
                                bindb (catch_errora
(catch_errora (forallM (ns rp) pns) (\ x -> Inl (snd x)))
(\ x ->
  Inl (shows_string
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
           'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
        shows_nl . x)))
                                  (\ _ ->
                                    catch_errora
                                      (catch_errora (forallM (s rp) ps)
(\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
         'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
      shows_nl . x))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'd', 'u',
                     'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                     'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w',
                     'i', 'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

instantiation_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
instantiation_proc i st sts dpp =
  (case let {
          ic = icap_impl_dpp_mv i dpp;
          isnf = is_QNFc i dpp;
          (s, t) = st;
          sy = map_term (\ x -> x) (\ a -> 'y' : a) s;
          ty = map_term (\ x -> x) (\ a -> 'y' : a) t;
          iedg = is_iedg_edge_dpp i dpp;
        } in catch_errora
               (forallM
                 (\ (u, v) ->
                   (case mgu_class (ic [u] v) s of {
                     Nothing -> Inr ();
                     Just mu ->
                       check (not (isnf (subst_apply_term sy mu)) ||
                               (not (isnf (subst_apply_term
    (map_term (\ x -> x) (\ a -> 'x' : a) u) mu)) ||
                                 any (\ sta ->
                                       instance_rule sta st &&
 instance_rule (subst_apply_term sy mu, subst_apply_term ty mu) sta)
                                   sts))
                         (shows_prec_list zero_nat
                            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                              'f', 'i', 'n', 'd', ' ', 'i', 'n', 's', 't', 'a',
                              'n', 'c', 'e', ' ', 'o', 'f', ' ', 'p', 'a', 'i',
                              'r', ' '] .
                           shows_rule (shows_prec zero_nat)
                             (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                             (subst_apply_term sy mu, subst_apply_term ty mu) .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['w', 'h', 'i', 'c', 'h', ' ', 'r', 'e', 's',
                                   'u', 'l', 't', 'e', 'd', ' ', 'f', 'r', 'o',
                                   'm', ' ', 'D', 'P', ' '] .
                                 shows_rule (shows_prec zero_nat)
                                   (shows_prec_list zero_nat)
                                   [' ', '-', '>', ' '] (u, v));
                   }))
                 (filter (\ (u, v) -> iedg (u, v) s) (pairsb i dpp)))
               (\ x -> Inl (snd x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

intersect_pairsb ::
  forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_pairsb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = intersect_pairs;

graph_approx_rt_sym_main ::
  forall a b c.
    (Ccompare a, Eq a) => Multimap (Maybe (a, Nat)) b -> Gctxt a c -> [b];
graph_approx_rt_sym_main m (GCFun f ts) =
  lookupc m Nothing ++ lookupc m (Just (f, size_list ts));
graph_approx_rt_sym_main m GCHole = valuesa m;

graph_approx_rt_sym ::
  forall a b c d e f.
    (Ccompare a,
      Eq a) => Multimap (Maybe (a, Nat)) b -> (c, (d, (Gctxt a e, f))) -> [b];
graph_approx_rt_sym m (uu, (uv, (ct, uw))) = graph_approx_rt_sym_main m ct;

rules_non_collapsinga :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
rules_non_collapsinga
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_non_collapsing;

reverse_rules_mapb ::
  forall a b c d.
    Dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
reverse_rules_mapb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = reverse_rules_map;

reverse_tcapRM_dpp ::
  forall a b c.
    (Eq b, Eq c) => Dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
reverse_tcapRM_dpp i dpp =
  tcapRM (rules_non_collapsinga i dpp) (reverse_rules_mapb i dpp);

check_no_back_edges ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> a -> [a]) ->
        (a -> b -> b) ->
          ((a, a) -> Bool) ->
            b -> [[a]] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_back_edges ss candidates add_index g i [] = Inr ();
check_no_back_edges ss candidates add_index g i (asa : cs) =
  bindb (catch_errora
          (forallM
            (\ a ->
              catch_errora (forallM (check_no_edge ss g a) (candidates i a))
                (\ x -> Inl (snd x)))
            asa)
          (\ x -> Inl (snd x)))
    (\ _ ->
      check_no_back_edges ss candidates add_index g (foldr add_index asa i) cs);

check_graph_decomp ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      b -> (b -> a -> [a]) ->
             (a -> b -> b) ->
               ((a, a) -> Bool) ->
                 [(Bool, [a])] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_graph_decomp ss empty_index candidates add_index g rcs =
  bindb (check_no_back_edges ss candidates add_index g empty_index
          (map snd rcs))
    (\ _ ->
      catch_errora
        (forallM (\ c -> check_edges ss g c c)
          (map_filter (\ x -> (if not (fst x) then Just (snd x) else Nothing))
            rcs))
        (\ x -> Inl (snd x)));

check_dep_graph_proc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dep_graph_proc i dpp dps =
  let {
    c = tcapRM_dpp i dpp;
    rc = reverse_tcapRM_dpp i dpp;
    iedg = is_iedg_edge_dpp i dpp;
    p = pairsb i dpp;
    r = rulese i dpp;
    f = funas_trs_list r;
    gt_fun = mk_gt_fun r;
    rm = rules_mapc i dpp;
    nlv = rules_no_left_vara i dpp;
  } in bindb (catch_errora (check_subseteq p (concatMap snd dps))
               (\ x ->
                 Inl (shows_string
                        ['D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ',
                          'P', 'a', 'i', 'r', ' '] .
                       shows_rule (shows_prec zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                         shows_string
                           [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                             'g', ' ', 'i', 'n', ' ', 'd', 'e', 'c', 'o', 'm',
                             'p', 'o', 's', 'i', 't', 'i', 'o', 'n'] .
                           shows_nl)))
         (\ _ ->
           catch_errora
             (check_graph_decomp (shows_prec_prod zero_nat . fst)
               (emptyd ((root . fst) . fst)) graph_approx_rt_sym insertd
               (\ (a, b) ->
                 let {
                   (aa, ba) = a;
                 } in let {
                        (_, t) = aa;
                      } in (\ (_, (ct, ict)) (ab, bb) ->
                             let {
                               (u, _) = ab;
                             } in (\ (cu, (_, _)) ->
                                    matchb ct u &&
                                      matchb cu t &&
ict u && not (nonreachable_gtcapRM f nlv (not (null r)) gt_fun rm t u))
                               bb)
                        ba
                   b)
               (map (\ (real, cs) ->
                      (not (is_none real),
                        map (\ (s, t) -> ((s, t), (rc s, (c t, iedg (s, t)))))
                          cs))
                 dps))
             (\ x ->
               Inl (shows_string
                      ['o', 'u', 'r', ' ', 'e', 's', 't', 'i', 'm', 'a', 't',
                        'i', 'o', 'n', ' ', '(', 'E', 'D', 'G', '*', '*', '*',
                        ' ', '+', ' ', 'I', 'E', 'D', 'G', '*', '*', '*', ')',
                        ' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                        's', 'h', 'o', 'w', ' ', 't', 'h', 'a', 't', ' ', 'y',
                        'o', 'u', ' ', 'h', 'a', 'v', 'e', ' ', 'a', ' ', 'v',
                        'a', 'l', 'i', 'd', ' ', 'd', 'e', 'c', 'o', 'm', 'p',
                        'o', 's', 'i', 't', 'i', 'o', 'n', ' '] .
                     shows_string
                       ['d', 'u', 'e', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ',
                         'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'r',
                         'e', 'a', 's', 'o', 'n'] .
                       shows_nl . x)));

dep_graph_proc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) [(c, a)];
dep_graph_proc i d dps =
  (case check_dep_graph_proc i d dps of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (map_filter
            (\ x ->
              (if not (is_none (fst x))
                then Just (the (fst x), intersect_pairsb i d (snd x))
                else Nothing))
            dps);
  });

check_NF_terms_subset ::
  forall a b. (Term a b -> Bool) -> [Term a b] -> Sum (Term a b) ();
check_NF_terms_subset is_Q_nf =
  (\ q ->
    catch_errora
      (forallM (\ x -> (if not (is_Q_nf x) then Inr () else Inl x)) q)
      (\ x -> Inl (snd x)));

check_NF_terms_eq ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_terms_eq qa q =
  bindb (check_NF_terms_subset (is_NF_terms qa) q)
    (\ _ -> check_NF_terms_subset (is_NF_terms q) qa);

check_dpp_subsumes ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c, Showa c, Ccompare d, Eq d,
      Mapping_impl d,
      Showa d) => Dpp_ops_ext a (Lab b c) d () ->
                    (Bool,
                      (Bool,
                        ([(Term (Lab b c) d, Term (Lab b c) d)],
                          ([(Term (Lab b c) d, Term (Lab b c) d)],
                            ([Term (Lab b c) d],
                              ([(Term (Lab b c) d, Term (Lab b c) d)],
                                [(Term (Lab b c) d, Term (Lab b c) d)])))))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dpp_subsumes i (nfs, (m, (p, (pw, (q, (r, rw)))))) d =
  catch_errora
    (let {
       pa = pb i d;
       pwa = pwb i d;
       qa = qc i d;
       ra = rd i d;
       rwa = rwd i d;
       nfsa = nfsc i d;
       ma = minimal i d;
       pba = p ++ pw;
       rb = ra ++ rwa;
       rba = r ++ rw;
     } in bindb (check (ma == m)
                  (shows_prec_list zero_nat
                    ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e',
                      ' ', 'm', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                      ' ', 'f', 'l', 'a', 'g', 's']))
            (\ _ ->
              bindb (check (nfsa == nfs)
                      (shows_prec_list zero_nat
                        ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l',
                          'e', ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't',
                          'i', 'o', 'n', 's', '-', 'i', 'n', '-', 'n', 'o', 'r',
                          'm', 'a', 'l', '-', 'f', 'o', 'r', 'm', ' ', 'f', 'l',
                          'a', 'g', 's']))
                (\ _ ->
                  bindb (catch_errora (check_subseteq pa p)
                          (\ x ->
                            Inl (toomuch ['p', 'a', 'i', 'r']
                                  (shows_rule (shows_prec_lab zero_nat)
                                    (shows_prec zero_nat) [' ', '-', '>', ' ']
                                    x))))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq pwa pba)
                              (\ x ->
                                Inl (toomuch
                                      ['w', 'e', 'a', 'k', ' ', 'p', 'a', 'i',
'r']
                                      (shows_rule (shows_prec_lab zero_nat)
(shows_prec zero_nat) [' ', '-', '>', ' '] x))))
                        (\ _ ->
                          bindb (catch_errora (check_NF_terms_eq qa q)
                                  (\ x ->
                                    Inl (shows_prec_list zero_nat
   ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f', 'f', 'e', 'r', 's', ' ', 'd',
     'u', 'e', ' ', 't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
  shows_term (shows_prec_lab zero_nat) (shows_prec zero_nat) x)))
                            (\ _ ->
                              bindb (catch_errora (check_subseteq ra r)
                                      (\ x ->
Inl (toomuch ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e']
      (shows_rule (shows_prec_lab zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] x))))
                                (\ _ ->
                                  bindb (catch_errora (check_subseteq rb rba)
  (\ x ->
    Inl (toomuch
          ['s', 't', 'r', 'i', 'c', 't', '/', 'w', 'e', 'a', 'k', ' ', 'r', 'u',
            'l', 'e']
          (shows_rule (shows_prec_lab zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] x))))
                                    (\ _ ->
                                      bindb
(catch_errora (check_subseteq rba rb)
  (\ x ->
    Inl (missing
          ['s', 't', 'r', 'i', 'c', 't', '/', 'w', 'e', 'a', 'k', ' ', 'r', 'u',
            'l', 'e']
          (shows_rule (shows_prec_lab zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] x))))
(\ _ -> Inr ())))))))))
    (\ x ->
      Inl (shows_string
             ['f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'o', 'f',
               ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
            shows_nl .
              shows_dpp (shows_prec_lab zero_nat) (shows_prec zero_nat) i d .
                shows_nl .
                  shows_string
                    ['m', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'c',
                      'o', 'n', 'c', 'l', 'u', 'd', 'e', 'd', ' ', 'f', 'r',
                      'o', 'm', ' ', 'a', 's', 's', 'u', 'm', 'i', 'n', 'g',
                      ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's',
                      ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o',
                      'b', 'l', 'e', 'm'] .
                    shows_nl .
                      shows_dpp (shows_prec_lab zero_nat) (shows_prec zero_nat)
                        i (mkd i nfs m p pw q r rw) .
                        shows_nl . x . shows_nl));

fcc_proc ::
  forall a b c.
    (Eq b, Showa b, Ceq c, Ccompare c, Eq c, Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
fcc_proc i f fcs pba rw dpp =
  let {
    p = pb i dpp;
    q = qc i dpp;
    r = rd i dpp;
    (pa, pw) = partition_pairs f p pba;
  } in bindb (check (null q)
               (shows_string
                  ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p',
                    't', 'y'] .
                 shows_nl))
         (\ _ ->
           bindb (check (null r)
                   (shows_prec_list zero_nat
                     ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e',
                       's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                       'e', 'd']))
             (\ _ ->
               bindb (check_left_linear_trs (rwd i dpp))
                 (\ _ -> fcc_proc_cond i f fcs pa pw [] rw dpp)));

q_reduction_proc_non_min ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc_non_min i q dpp =
  (case catch_errora
          (bindb
            (catch_errora (check_NF_terms_subset (is_QNFc i dpp) q)
              (\ x ->
                Inl (shows_prec_list zero_nat
                       ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                      shows_prec_term zero_nat x .
                        shows_prec_list zero_nat
                          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l',
                            'l', 'o', 'w', 'e', 'd', ' ', 'i', 'n', ' ', 'Q',
                            '\'', ' '])))
            (\ _ -> Inr ()))
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'r', 'e', 'd', 'u', 'c', 'i', 'n', 'g', ' ', 'Q', ' ',
                     'i', 'n', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r',
                     'o', 'b', 'l', 'e', 'm', ' '] .
                  shows_nl .
                    shows_dpp (shows_prec zero_nat) (shows_prec zero_nat) i
                      dpp .
                      shows_nl .
                        shows_prec_list zero_nat
                          ['t', 'o', ' ', 't', 'h', 'e', ' ', 's', 'e', 't',
                            ' '] .
                          shows_nl .
                            shows_terms (shows_prec zero_nat)
                              (shows_prec zero_nat) ['Q', '\'', ':'] q .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (mkd i (nfsc i dpp) False (pb i dpp) (pwb i dpp) q (rd i dpp)
            (rwd i dpp));
  });

q_reduction_proc_min_inn ::
  forall a b c.
    (Eq b, Key b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc_min_inn i q dpp =
  let {
    pba = pairsb i dpp;
    rb = rulese i dpp;
    f = map Just (funas_trs_list (pba ++ rb));
    qa = qc i dpp;
    isnf = is_QNFc i dpp;
    qq = filter (\ qb -> all isnf (args qb)) qa;
    rQ = filter (\ qb -> membera f (root qb)) qq;
  } in (case catch_errora
               (bindb
                 (check (nFQ_subset_NF_rulesc i dpp)
                   (shows_prec_list zero_nat
                     ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r',
                       'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'r', 'e',
                       'q', 'u', 'i', 'r', 'e', 'd']))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       bindb (catch_errora
                               (check_NF_terms_subset (is_NF_terms q) rQ)
                               (\ x ->
                                 Inl (shows_prec_list zero_nat
['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                                       shows_prec_term zero_nat x .
 shows_prec_list zero_nat
   [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 'n', ' ',
     'Q', '\'', ' '])))
                         (\ _ ->
                           bindb (catch_errora
                                   (check_NF_terms_subset (is_NF_terms qq) q)
                                   (\ x ->
                                     Inl (shows_prec_list zero_nat
    ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
   shows_prec_term zero_nat x .
     shows_prec_list zero_nat
       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
         'd', ' ', 'i', 'n', ' ', 'Q', '\'', ' '])))
                             (\ _ ->
                               (if nfsc i dpp then Inr ()
                                 else check_varcond_subset pba))))))
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                          'n', ' ', 'r', 'e', 'd', 'u', 'c', 'i', 'n', 'g', ' ',
                          'Q', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                          ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                       shows_nl .
                         shows_dpp (shows_prec zero_nat) (shows_prec zero_nat) i
                           dpp .
                           shows_nl .
                             shows_prec_list zero_nat
                               ['t', 'o', ' ', 't', 'h', 'e', ' ', 's', 'e',
                                 't', ' '] .
                               shows_nl .
                                 shows_terms (shows_prec zero_nat)
                                   (shows_prec zero_nat) ['Q', '\'', ':'] q .
                                   shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (mkd i (nfsc i dpp) (minimal i dpp) (pb i dpp) (pwb i dpp) q
                 (rd i dpp) (rwd i dpp));
       });

q_reduction_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc i q dpp = (case q_reduction_proc_min_inn i q dpp of {
                             Inl _ -> q_reduction_proc_non_min i q dpp;
                             Inr a -> Inr a;
                           });

get_fcc_option ::
  forall a b c.
    Dp_termination_proof a b c ->
      Maybe (Lab a b,
              ([Ctxt (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  ([(Term (Lab a b) c, Term (Lab a b) c)],
                    Dp_termination_proof a b c))));
get_fcc_option (Fcc_Proc f fcs pb rb prf) = Just (f, (fcs, (pb, (rb, prf))));
get_fcc_option P_is_Empty = Nothing;
get_fcc_option (Subterm_Criterion_Proc v va vb vc) = Nothing;
get_fcc_option (Gen_Subterm_Criterion_Proc v va vb) = Nothing;
get_fcc_option (Redpair_Proc v va vb) = Nothing;
get_fcc_option (Redpair_UR_Proc v va vb vc) = Nothing;
get_fcc_option (Usable_Rules_Proc v va) = Nothing;
get_fcc_option (Dep_Graph_Proc v) = Nothing;
get_fcc_option (Mono_Redpair_Proc v va vb vc) = Nothing;
get_fcc_option (Mono_URM_Redpair_Proc v va vb vc) = Nothing;
get_fcc_option (Mono_Redpair_UR_Proc v va vb vc vd) = Nothing;
get_fcc_option (Size_Change_Subterm_Proc v) = Nothing;
get_fcc_option (Size_Change_Redpair_Proc v va vb) = Nothing;
get_fcc_option (Uncurry_Proc v va vb vc vd) = Nothing;
get_fcc_option (Split_Proc v va vb vc) = Nothing;
get_fcc_option (Semlab_Proc v va vb vc vd) = Nothing;
get_fcc_option (Switch_Innermost_Proc v va) = Nothing;
get_fcc_option (Rewriting_Proc v va vb vc vd ve vf) = Nothing;
get_fcc_option (Instantiation_Proc v va vb) = Nothing;
get_fcc_option (Forward_Instantiation_Proc v va vb vc) = Nothing;
get_fcc_option (Narrowing_Proc v va vb vc) = Nothing;
get_fcc_option (Assume_Finite v va) = Nothing;
get_fcc_option (Unlab_Proc v va vb) = Nothing;
get_fcc_option (Q_Reduction_Proc v va) = Nothing;
get_fcc_option (Complex_Constant_Removal_Proc v va) = Nothing;
get_fcc_option (General_Redpair_Proc v va vb vc vd) = Nothing;
get_fcc_option (To_Trs_Proc v) = Nothing;

uncurry_of_top_sig_list ::
  forall a.
    a -> Nat ->
           [((a, Nat), [a])] ->
             (a -> Nat -> [a]) ->
               [(Term a [Prelude.Char], Term a [Prelude.Char])];
uncurry_of_top_sig_list a m sml sm =
  concatMap
    (\ (b, c) ->
      let {
        (f, n) = b;
      } in (\ _ ->
             let {
               g = get_symbol sm f n;
             } in map (\ i ->
                        (Fun a (generate_f_xs (g i) (plus_nat n i) :
                                 map (\ ia -> Var (generate_var ia))
                                   (upt (plus_nat n i)
                                     (plus_nat (plus_nat n i)
                                       (minus_nat m one_nat)))),
                          generate_f_xs (g (suc i))
                            (plus_nat (plus_nat n i) (minus_nat m one_nat))))
                    (upt zero_nat (aarity sm f n)))
        c)
    sml;

eta_closed_top_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => a -> Nat ->
                         (a -> Nat -> [a]) ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
eta_closed_top_rules a n sm r p =
  catch_errora
    (forallM
      (\ (l, ra) ->
        (case l of {
          Var _ -> Inr ();
          Fun ff ls ->
            check (equal_nat (aarity sm ff (size_list ls)) zero_nat ||
                    any (\ (lll, rrr) ->
                          (case (lll, rrr) of {
                            (Var _, _) -> False;
                            (Fun _ [], _) -> False;
                            (Fun _ (_ : _), Var _) -> False;
                            (Fun _ (_ : _), Fun _ []) -> False;
                            (Fun f (ll : yy), Fun g (rr : zz)) ->
                              f == a &&
                                g == a &&
                                  zz == yy &&
                                    equal_nat (size_list yy)
                                      (minus_nat n one_nat) &&
                                      distinct yy &&
all is_Var yy &&
  null (list_inter (map the_Var yy) (insert_vars_rule (ll, rr) [])) &&
    instance_rule (l, ra) (ll, rr);
                          }))
                      p)
              ((shows_prec_list zero_nat
                  ['e', 't', 'a', ' ', 'e', 'x', 'p', 'a', 'n', 's', 'i', 'o',
                    'n', ' ', 'o', 'f', ' '] .
                 shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                   [' ', '-', '>', ' '] (l, ra)) .
                shows_prec_list zero_nat
                  [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']);
        }))
      r)
    (\ x -> Inl (snd x));

uncurry_top_rules ::
  forall a b.
    (Eq a) => a -> Nat ->
                     (a -> Nat -> [a]) ->
                       [(Term a b, Term a b)] -> [(Term a b, Term a b)];
uncurry_top_rules a n sm =
  map (\ (l, r) -> (uncurry_top a n sm l, uncurry_top a n sm r));

map_funs_rules_wa ::
  forall a b c.
    ((a, Nat) -> b) -> [(Term a c, Term a c)] -> [(Term b c, Term b c)];
map_funs_rules_wa fg r =
  map (\ (l, ra) -> (map_funs_term_wa fg l, map_funs_term_wa fg ra)) r;

uncurry_top_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      Nat ->
                        ([((b, Nat), [b])] -> b -> Nat -> b) ->
                          (b -> Nat ->
                                  [((b, Nat), [b])] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char])
                                      ()) ->
                            [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                              [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                                a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_top_proc i info n fmap check_inj p r dpp =
  let {
    (a, (sml, (u, eb))) = info;
    pa = pb i dpp;
    pw = pwb i dpp;
    ra = rd i dpp;
    rw = rwd i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (e, ew) = uncurry_eta_split eb ra;
    sm = sig_list_to_sig_map a sml fmap;
    p_eta = e ++ pa;
    pw_eta = ew ++ pw;
    uP = uncurry_top_rules a n sm p_eta;
    uPw = uncurry_top_rules a n sm pw_eta;
    uR = map_funs_rules_wa (\ (f, na) -> get_symbol sm f na zero_nat) ra;
    uRw = map_funs_rules_wa (\ (f, na) -> get_symbol sm f na zero_nat) rw;
  } in (case bindb (check (null (qc i dpp))
                     (shows_prec_list zero_nat
                       ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'c', 'u',
                         'r', 'r', 'e', 'n', 't', 'l', 'y', ' ', 'u', 'n', 's',
                         'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
               (\ _ ->
                 bindb (check (not (equal_nat n zero_nat))
                         (shows_prec_list zero_nat
                           ['t', 'h', 'e', ' ', 'a', 'r', 'i', 't', 'y', ' ',
                             'o', 'f', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c',
                             'u', 'r', 'r', 'i', 'e', 'd', ' ', 's', 'y', 'm',
                             'b', 'o', 'l', ' ', 'm', 'u', 's', 't', ' ', 'b',
                             'e', ' ', 'a', 't', ' ', 'l', 'e', 'a', 's', 't',
                             ' ', '1']))
                   (\ _ ->
                     bindb (check_inj a n sml)
                       (\ _ ->
                         let {
                           pba = pairsb i dpp;
                           is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
                           rm = rules_mapc i dpp;
                         } in bindb (catch_errora
                                      (forallM
(\ (l, _) ->
  check (not (is_Var l))
    (shows_prec_list zero_nat
      ['l', 'h', 's', ' ', 'a', 's', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
        'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
        'e', 'd']))
(ra ++ rw))
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  bindb (catch_errora
  (forallM
    (\ (l, rb) ->
      bindb (check (hvf_top a n l)
              (shows_prec_list zero_nat
                 ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
                   'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                shows_term (shows_prec zero_nat) (shows_prec_list zero_nat) l .
                  shows_prec_list zero_nat
                    [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
                      'd']))
        (\ _ -> check_no_var rb))
    (pw_eta ++ p_eta))
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora
  (forallM
    (\ (_, rb) ->
      check (not (is_def (the (root rb))))
        (shows_prec_list zero_nat ['r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
          shows_term (shows_prec zero_nat) (shows_prec_list zero_nat) rb .
            shows_prec_list zero_nat
              [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ',
                'd', 'e', 'f', 'i', 'n', 'e', 'd']))
    pba)
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (check (not (is_def (a, n)))
          (shows_prec_list zero_nat
             ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 's',
               'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec zero_nat a .
              shows_prec_list zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e',
                  ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ',
                  'R']))
    (\ _ ->
      bindb (if any (\ (_, rb) ->
                      the (root rb) == (a, n) &&
                        equal_gctxt (tcapRM2 rm (hda (args rb))) GCHole)
                  pba
              then bindb (catch_errora
                           (check_CS_subseteq
                             (uncurry_of_top_sig_list a n sml sm) u)
                           (\ x ->
                             Inl (shows_prec_list zero_nat
                                    ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'i',
                                      'n', 'g', ' ', 'p', 'a', 'i', 'r', ' '] .
                                   shows_rule (shows_prec zero_nat)
                                     (shows_prec_list zero_nat)
                                     [' ', '-', '>', ' '] x .
                                     shows_prec_list zero_nat
                                       [' ', 'i', 's', ' ', 'm', 'i', 's', 's',
 'i', 'n', 'g', ' ', 'i', 'n'] .
                                       shows_nl .
 shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] u)))
                     (\ _ ->
                       bindb (eta_closed_top_rules a n sm ra p_eta)
                         (\ _ -> eta_closed_top_rules a n sm rw pw_eta))
              else Inr ())
        (\ _ ->
          bindb (catch_errora (check_subseteq uP p)
                  (\ x ->
                    Inl (shows_prec_list zero_nat
                           ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ',
                             'p', 'a', 'i', 'r', ' '] .
                          shows_rule (shows_prec zero_nat)
                            (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                            shows_prec_list zero_nat
                              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                                'g'])))
            (\ _ ->
              bindb (catch_errora (check_subseteq uPw p)
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd',
                                 ' ', 'p', 'a', 'i', 'r', ' '] .
                              shows_rule (shows_prec zero_nat)
                                (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                x .
                                shows_prec_list zero_nat
                                  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i',
                                    'n', 'g'])))
                (\ _ ->
                  bindb (catch_errora (check_subseteq u p)
                          (\ x ->
                            Inl (shows_prec_list zero_nat
                                   ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'i', 'n',
                                     'g', ' ', 'p', 'a', 'i', 'r', ' '] .
                                  shows_rule (shows_prec zero_nat)
                                    (shows_prec_list zero_nat)
                                    [' ', '-', '>', ' '] x .
                                    shows_prec_list zero_nat
                                      [' ', 'i', 's', ' ', 'm', 'i', 's', 's',
'i', 'n', 'g', ' ', 'i', 'n', ' ', 'n', 'e', 'w', ' ', 'p', 'a', 'i', 'r',
's'])))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq uR r)
                              (\ x ->
                                Inl (shows_prec_list zero_nat
                                       ['r', 'u', 'l', 'e', ' '] .
                                      shows_rule (shows_prec zero_nat)
(shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
shows_prec_list zero_nat
  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 'n', ' ',
    'n', 'e', 'w', ' ', 'r', 'u', 'l', 'e', 's'])))
                        (\ _ ->
                          catch_errora (check_subseteq uRw r)
                            (\ x ->
                              Inl (shows_prec_list zero_nat
                                     ['r', 'u', 'l', 'e', ' '] .
                                    shows_rule (shows_prec zero_nat)
                                      (shows_prec_list zero_nat)
                                      [' ', '-', '>', ' '] x .
                                      shows_prec_list zero_nat
[' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 'n', ' ', 'n',
  'e', 'w', ' ', 'r', 'u', 'l', 'e', 's']))))))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkd i nfs m uP (uPw ++ u) [] uR uRw);
       });

only_eta_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
only_eta_rules e r_eta =
  catch_errora
    (forallM
      (\ (l, r) ->
        check (case (l, r) of {
                (Var _, _) -> False;
                (Fun _ _, Var _) -> False;
                (Fun f ls, Fun g rs) ->
                  f == g &&
                    equal_nat (size_list ls) (nat_of_integer (2 :: Integer)) &&
                      equal_nat (size_list rs)
                        (nat_of_integer (2 :: Integer)) &&
                        equal_term (nth ls one_nat) (nth rs one_nat) &&
                          any (\ (la, ra) ->
                                instance_rule (hda ls, hda rs) (la, ra))
                            r_eta;
              })
          (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '-', '>', ' '] (l, r) .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', '(',
                  'e', 't', 'a', '-', 'e', 'x', 'p', 'a', 'n', 'd', 'e', 'd',
                  ')', ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 'r',
                  'u', 'l', 'e']))
      e)
    (\ x -> Inl (snd x));

uncurry_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      ([((b, Nat), [b])] -> b -> Nat -> b) ->
                        (b -> Nat ->
                                [((b, Nat), [b])] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_proc i info fmap check_inj p r dpp =
  let {
    (a, (sml, (u, eb))) = info;
    pa = pb i dpp;
    pw = pwb i dpp;
    ra = rd i dpp;
    rw = rwd i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (e, ew) = uncurry_eta_split eb ra;
    sm = sig_list_to_sig_map a sml fmap;
    uP = uncurry_rules a sm pa;
    uPw = uncurry_rules a sm pw;
    r_eta = e ++ ra;
    rw_eta = ew ++ rw;
    uR = uncurry_rules a sm r_eta;
    uRw = uncurry_rules a sm rw_eta;
  } in (case let {
               s = uncurry_of_sig_list a sml sm;
             } in bindb (check (null (qc i dpp))
                          (shows_prec_list zero_nat
                            ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'n',
                              'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
                              'e', 'd', ' ', 'f', 'o', 'r', ' ', 'u', 'n', 'c',
                              'u', 'r', 'r', 'y', 'i', 'n', 'g']))
                    (\ _ ->
                      bindb (only_eta_rules e r_eta)
                        (\ _ ->
                          bindb (only_eta_rules ew rw_eta)
                            (\ _ ->
                              bindb (check_inj a (nat_of_integer (2 :: Integer))
                                      sml)
                                (\ _ ->
                                  bindb (catch_errora
  (forallM
    (\ (l, _) ->
      check (not (is_Var l))
        (shows_prec_list zero_nat
          ['l', 'h', 's', ' ', 'a', 's', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
            'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
            'w', 'e', 'd']))
    (ra ++ rw))
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora
  (forallM
    (\ (l, _) ->
      check (hvf_term a l)
        (shows_prec_list zero_nat
           ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
             ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
          shows_term (shows_prec zero_nat) (shows_prec_list zero_nat) l .
            shows_prec_list zero_nat
              [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
    pa)
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (catch_errora
          (forallM
            (\ (l, _) ->
              check (hvf_term a l)
                (shows_prec_list zero_nat
                   ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
                     'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                  shows_term (shows_prec zero_nat) (shows_prec_list zero_nat)
                    l .
                    shows_prec_list zero_nat
                      [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
                        'd']))
            pw)
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ (l, _) ->
                  check (hvf_term a l)
                    (shows_prec_list zero_nat
                       ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b',
                         'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                      shows_term (shows_prec zero_nat)
                        (shows_prec_list zero_nat) l .
                        shows_prec_list zero_nat
                          [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                            'e', 'd']))
                r_eta)
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (catch_errora
                  (forallM
                    (\ (l, _) ->
                      check (hvf_term a l)
                        (shows_prec_list zero_nat
                           ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a',
                             'b', 'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's',
                             ' '] .
                          shows_term (shows_prec zero_nat)
                            (shows_prec_list zero_nat) l .
                            shows_prec_list zero_nat
                              [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                                'e', 'd']))
                    rw_eta)
                  (\ x -> Inl (snd x)))
            (\ _ ->
              bindb (eta_closed_rules a sm r_eta r_eta)
                (\ _ ->
                  bindb (eta_closed_rules a sm rw_eta rw_eta)
                    (\ _ ->
                      bindb (catch_errora (check_subseteq uP p)
                              (\ x ->
                                Inl (shows_prec_list zero_nat
                                       ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e',
 'd', ' ', 'p', 'a', 'i', 'r', ' '] .
                                      shows_rule (shows_prec zero_nat)
(shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
shows_prec_list zero_nat
  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                        (\ _ ->
                          bindb (catch_errora (check_subseteq uPw p)
                                  (\ x ->
                                    Inl (shows_prec_list zero_nat
   ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'p', 'a', 'i', 'r', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] x .
    shows_prec_list zero_nat
      [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                            (\ _ ->
                              bindb (catch_errora (check_subseteq uR r)
                                      (\ x ->
Inl (shows_prec_list zero_nat
       ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
         ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
        [' ', '-', '>', ' '] x .
        shows_prec_list zero_nat
          [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                                (\ _ ->
                                  bindb (catch_errora (check_subseteq uRw r)
  (\ x ->
    Inl (shows_prec_list zero_nat
           ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l',
             'e', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
            [' ', '-', '>', ' '] x .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                                    (\ _ ->
                                      bindb
(catch_errora (check_CS_subseteq s u)
  (\ x ->
    Inl (shows_prec_list zero_nat
           ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l', 'e', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
            [' ', '-', '>', ' '] x .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
(\ _ ->
  bindb (catch_errora (check_CS_subseteq u s)
          (\ x ->
            Inl (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                    [' ', '-', '>', ' '] x .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ',
                        'u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l',
                        'e'])))
    (\ _ ->
      catch_errora (check_subseteq u r)
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l', 'e',
                   ' '] .
                shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                  [' ', '-', '>', ' '] x .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ',
                      'i', 'n', ' ', 'n', 'e', 'w', ' ', 'T', 'R',
                      'S'])))))))))))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkd i nfs m uP uPw [] uR (uRw ++ u));
       });

uncurry_proc_both ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Dpp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Maybe Nat ->
                      (Lab b c,
                        ([((Lab b c, Nat), [Lab b c])],
                          ([(Term (Lab b c) [Prelude.Char],
                              Term (Lab b c) [Prelude.Char])],
                            [(Term (Lab b c) [Prelude.Char],
                               Term (Lab b c) [Prelude.Char])]))) ->
                        [(Term (Lab b c) [Prelude.Char],
                           Term (Lab b c) [Prelude.Char])] ->
                          [(Term (Lab b c) [Prelude.Char],
                             Term (Lab b c) [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_proc_both i Nothing (a, (sml, (u, eb))) =
  uncurry_proc i (a, (sml, (u, eb))) (fmap a (nat_of_integer (2 :: Integer)))
    check_inj;
uncurry_proc_both i (Just n) (a, (sml, (u, eb))) =
  uncurry_top_proc i (a, (sml, (u, eb))) n (fmap a n) check_inj;

check_rewrite_common_preconditions ::
  forall a b c d.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      (Term b [Prelude.Char], Term c [Prelude.Char]) ->
                        [Term b [Prelude.Char]] ->
                          [Term b [Prelude.Char]] ->
                            d -> (Term b [Prelude.Char],
                                   Term b [Prelude.Char]) ->
                                   Pos ->
                                     Bool ->
                                       a ->
 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rewrite_common_preconditions i u_opt st ss ts t lr p sound dpp =
  let {
    r = rulese i dpp;
    s = fst st;
    ta = snd st;
    tp = subt_at ta p;
    u = (case u_opt of {
          Nothing -> concatMap (\ tb -> inn_usable_rules_pair i dpp (s, tb)) ts;
          Just u -> u;
        });
  } in bindb (catch_errora (check_subseteq u r)
               (\ x ->
                 Inl (shows_rule (shows_prec zero_nat)
                        (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'u', 'l', 'e', ' ', 'o', 'f', ' ', 't', 'h', 'e',
                           ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                           'y', 's', 't', 'e', 'm', ' '])))
         (\ _ ->
           let {
             urc = is_ur_closed_impl_dpp_mv i dpp u;
             check_urc =
               (\ sa tb ->
                 check (urc sa tb)
                   (shows_prec_list zero_nat ['t', 'e', 'r', 'm', ' '] .
                     shows_prec_term zero_nat tb .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l', 'o',
                           's', 'e', 'd', ' ', 'u', 'n', 'd', 'e', 'r', ' ',
                           'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                           'e', 's']));
             nfs = nfsc i dpp;
           } in bindb (catch_errora
                        (forallM
                          (\ (l, _) ->
                            check (not (is_Var l))
                              (shows_prec_list zero_nat
                                ['l', 'h', 's', 's', ' ', 'm', 'u', 's', 't',
                                  ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'v',
                                  'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
                          u)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    bindb (check (wf_rule lr)
                            (shows_rule (shows_prec zero_nat)
                               (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                               lr .
                              shows_prec_list zero_nat
                                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                  ' ', 'w', 'e', 'l', 'l', ' ', 'f', 'o', 'r',
                                  'm', 'e', 'd', ' ', 'r', 'u', 'l', 'e']))
                      (\ _ ->
                        bindb (if nfs && sound then Inr ()
                                else catch_errora
                                       (check_subseteq (vars_term_list tp)
 (vars_term_list s))
                                       (\ _ ->
 Inl (shows_prec_list zero_nat
       ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'n', 'd', 'i',
         't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'v',
         'i', 'o', 'l', 'a', 't', 'e', 'd'])))
                          (\ _ ->
                            bindb (catch_errora (forallM (check_urc ss) ts)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (catch_errora
(forallM (\ (l, a) -> check_urc (args l) a) u) (\ x -> Inl (snd x)))
                                  (\ _ ->
                                    bindb (catch_errora
    (check_critical_pairs_innermost u)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's', 'h',
               'o', 'w', 'i', 'n', 'g', ' ', 'U', 'N', 'F', ' ', 'o', 'f', ' ',
               'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
            shows_nl . x)))
                                      (\ _ ->
catch_errora
  (forallM
    (\ (_, (sa, tb)) ->
      check (equal_term sa tb)
        (shows_prec_list zero_nat
          ['n', 'o', 'n', '-', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ', 'c', 'r',
            'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'a', 'i', 'r', ' ', 'b',
            'e', 't', 'w', 'e', 'e', 'n', ' ', 'r', 'u', 'l', 'e', ' ', 't',
            'o', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 'a', 'n', 'd',
            ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']))
    (critical_pairs_impl [lr] u))
  (\ x -> Inl (snd x)))))))));

check_prop_rstepa ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstepa nfs pa r p rule s t =
  bindb (check (membera r rule)
          (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] rule .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r', 'u', 'l',
                'e', ' ', 'o', 'f'] .
              shows_nl .
                shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                  ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't',
                    'e', 'm', ':']
                  [' ', '-', '>', ' '] r .
                  shows_nl))
    (\ _ -> check_prop_rstep_rule nfs pa p rule s t);

check_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Pos ->
                      (Term a b, Term a b) ->
                        Term a b ->
                          Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rstep = check_prop_rstepa False (\ _ -> Inr ());

rewriting_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                        (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                          (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                            (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                              Pos ->
                                a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rewriting_proc i u stb sta st lr p dpp =
  (case let {
          s = fst stb;
          t = snd sta;
        } in bindb (check_rstep (rulese i dpp) p lr (snd stb) t)
               (\ _ ->
                 bindb (check (nFQ_subset_NF_rulesc i dpp)
                         (shows_prec_list zero_nat
                           ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ',
                             'r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                             'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                   (\ _ ->
                     bindb (check_rewrite_common_preconditions i u stb [s]
                             [subt_at (snd stb) p] t lr p True dpp)
                       (\ _ ->
                         bindb (check (eq_rule_mod_vars sta st)
                                 (shows_prec_list zero_nat
                                    ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                                      ' '] .
                                   shows_rule (shows_prec zero_nat)
                                     (shows_prec_list zero_nat)
                                     [' ', '-', '>', ' '] sta .
                                     shows_prec_list zero_nat
                                       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
 'a', ' ', 'r', 'e', 'n', 'a', 'm', 'e', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'n',
 't', ' ', 'o', 'f', ' '] .
                                       shows_rule (shows_prec zero_nat)
 (shows_prec_list zero_nat) [' ', '-', '>', ' '] st))
                           (\ _ ->
                             bindb (check (equal_term s (fst sta))
                                     (shows_prec_list zero_nat
                                       ['l', 'e', 'f', 't', '-', 'h', 'a', 'n',
 'd', ' ', 's', 'i', 'd', 'e', 's', ' ', 'o', 'f', ' ', 'o', 'l', 'd', ' ', 'a',
 'n', 'd', ' ', 'n', 'e', 'w', ' ', 'p', 'a', 'i', 'r', ' ', 'd', 'i', 'f', 'f',
 'e', 'r']))
                               (\ _ ->
                                 bindb (check
 (membera (pb i dpp) stb || null (rd i dpp))
 (shows_prec_list zero_nat
   ['s', 't', 'r', 'i', 'c', 't', ' ', 'D', 'P', ' ', 'o', 'r', ' ', 'n', 'o',
     ' ', 's', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'r',
     'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                                   (\ _ ->
                                     check (nfsc i dpp || wwf_rulesa i dpp)
                                       (shows_prec_list zero_nat
 ['w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd', ' ', 'r', 'u', 'l',
   'e', 's', ' ', 'o', 'r', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 's', 'u',
   'b', 's', 't', '.', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'])))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp stb [st]);
  });

nF_subst_impl ::
  forall a b.
    (Term a b -> Bool) ->
      Bool -> (Term a b, Term a b) -> (b -> Term a b) -> Bool;
nF_subst_impl nf nfs r sigma =
  (if nfs then all (\ x -> nf (sigma x)) (vars_rule_list r) else True);

qnarrows_impl ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                Bool ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Term a [Prelude.Char] ->
                      [(Term a [Prelude.Char],
                         [Prelude.Char] -> Term a [Prelude.Char])];
qnarrows_impl isnf nfs r t =
  concatMap
    (\ p ->
      let {
        tp = subt_at t p;
      } in (if not (is_Var tp)
             then concatMap
                    (\ (l, ra) ->
                      concatMap
                        (\ (mu_1, mu_2) ->
                          (if nF_subst_impl isnf nfs (l, ra) mu_2
                            then (if all isnf (args (subst_apply_term l mu_2))
                                   then [(ctxt_apply_term
    (ctxt_of_pos_term p (subst_apply_term t mu_1)) (subst_apply_term ra mu_2),
   mu_1)]
                                   else [])
                            else []))
                        (option_to_list
                          (mgu_var_disjoint_generic (\ a -> 'x' : a)
                            (\ a -> 'y' : a) tp l)))
                    r
             else []))
    (poss_list t);

narrowing_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      Pos ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
narrowing_proc i st p sts dpp =
  (case let {
          (s, t) = st;
          q = qc i dpp;
        } in bindb (check
                     (nFQ_subset_NF_rulesc i dpp || null q && linear_term t)
                     (shows_prec_list zero_nat
                       ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'o',
                         'r', ' ', 'f', 'u', 'l', 'l', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'r', 'e', 'q', 'u', 'i',
                         'r', 'e', 'd', ' ', '(', 'a', 'n', 'd', ' ', 'l', 'i',
                         'n', 'e', 'a', 'r', 'i', 't', 'y', ' ', 'o', 'f', ' ',
                         't', ' ', 'i', 'n', ' ', 'f', 'u', 'l', 'l', ' ', 'r',
                         'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'c', 'a',
                         's', 'e', ')']))
               (\ _ ->
                 let {
                   ic = icap_impl_dpp_mv i dpp;
                   isnf = is_QNFc i dpp;
                   pairs = pairsb i dpp;
                 } in bindb (check (membera (poss_list t) p)
                              (shows_prec_list zero_nat
                                 ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ',
                                   'n', 'o', 't', ' ', 'c', 'o', 'n', 't', 'a',
                                   'i', 'n', 'e', 'd', ' ', 'i', 'n', ' '] .
                                shows_prec_term zero_nat t))
                        (\ _ ->
                          let {
                            tp = subt_at t p;
                            nftp = isnf tp;
                          } in bindb (check
                                       (membera (poss_list (ic [s] t)) p ||
 not nftp)
                                       (shows_prec_list zero_nat
 ['n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'i', 's', ' ', 'p', 'o', 's', 'i',
   't', 'i', 'o', 'n', ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 'e', 'd', ' ',
   'i', 'n', ' ', 'c', 'a', 'p', 'p', 'e', 'd', ' ', 't', 'e', 'r', 'm', ' ',
   'o', 'f', ' ', 't', ',', ' ', 'n', 'o', 'r', ' ', 'i', 's', ' ', 't', '|',
   '_', 'p', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'Q', '-', 'n', 'o', 'r',
   'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']))
                                 (\ _ ->
                                   let {
                                     nfs = nfsc i dpp;
                                     narrows =
                                       qnarrows_impl isnf nfs (rulese i dpp) tp;
                                     stsa =
                                       filter (\ (smu, _) -> isnf smu)
 (map (\ (ta, mu) ->
        (subst_apply_term s mu,
          ctxt_apply_term (ctxt_of_pos_term p (subst_apply_term t mu)) ta))
   narrows);
                                   } in bindb
  (catch_errora
    (forallM
      (\ new ->
        check (any (\ sta ->
                     instance_rule new sta &&
                       (not nfs || (null q || wf_rule sta)))
                sts)
          (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
               'd', ' ', 'n', 'a', 'r', 'r', 'o', 'w', 'e', 'd', ' ', 'p', 'a',
               'i', 'r', ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
              [' ', '-', '>', ' '] new))
      stsa)
    (\ x -> Inl (snd x)))
  (\ _ ->
    let {
      iedg = is_iedg_edge_dpp i dpp (s, t);
    } in bindb (catch_errora
                 (check_subseteq (vars_term_list tp) (vars_term_list s))
                 (\ x ->
                   Inl (shows_prec_list zero_nat
                         (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] ++
                           x ++ [' ', 'o', 'n', 'l', 'y', ' ', 'o', 'c', 'c',
                                  'u', 'r', 's', ' ', 'o', 'n', ' ', 'r', 'h',
                                  's', ' ', 'o', 'f', ' ', 'p', 'a', 'i',
                                  'r']))))
           (\ _ ->
             bindb (check (membera (pb i dpp) st || null (rd i dpp))
                     (shows_prec_list zero_nat
                       ['s', 't', 'r', 'i', 'c', 't', ' ', 'D', 'P', ' ', 'o',
                         'r', ' ', 'n', 'o', ' ', 's', 't', 'r', 'i', 'c', 't',
                         ' ', 'r', 'u', 'l', 'e', 's', ' ', 'r', 'e', 'q', 'u',
                         'i', 'r', 'e', 'd']))
               (\ _ ->
                 (if nftp
                   then catch_errora
                          (forallM
                            (\ (u, v) ->
                              bindb (check (membera (poss_list u) p)
                                      (shows_prec_list zero_nat
 ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'c', 'o',
   'n', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' ',
   'o', 'f', ' ', 'p', 'a', 'i', 'r', ' '] .
shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat) [' ', '-', '>', ' ']
  (u, v)))
                                (\ _ ->
                                  (case mgu_var_disjoint_generic
  (\ a -> 'x' : a) (\ a -> 'y' : a) tp (subt_at u p)
                                    of {
                                    Nothing -> Inr ();
                                    Just (mu_1, mu_2) ->
                                      check
(not (isnf (subst_apply_term s mu_1)) || not (isnf (subst_apply_term u mu_2)))
(shows_prec_list zero_nat
   ['t', ' ', '|', '_', ' ', 'p', ' ', 'a', 'n', 'd', ' ', 'u', ' ', '|', '_',
     ' ', 'p', ' ', 'u', 'n', 'i', 'f', 'y', ' ', 'a', 'n', 'd', ' ', 's', 'a',
     't', 'i', 's', 'f', 'y', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ',
     'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'p',
     'a', 'i', 'r', ' ', '(', 'u', ',', 'v', ')', ' ', '=', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] (u, v));
                                  })))
                            (filter (\ (u, _) -> iedg u) pairs))
                          (\ x -> Inl (snd x))
                   else Inr ())))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

extract_renamings :: forall a. (Eq a) => [(a, a)] -> (a -> a, a -> a);
extract_renamings old_new =
  (fun_of_map_fun (map_of old_new) id,
    fun_of_map_fun (map_of (map swap old_new)) id);

extract_components ::
  forall a. (Eq a) => [(a, Nat)] -> [(a, a)] -> (a -> a, (a -> a, [a]));
extract_components mu old_new =
  let {
    (d, da) = extract_renamings old_new;
    c = map_filter
          (\ x -> (if let {
                        (_, a) = x;
                      } in equal_nat a zero_nat
                    then Just (fst x) else Nothing))
          mu;
    nu = map d c;
  } in (d, (da, nu));

check_components ::
  forall a.
    (Eq a,
      Showa a) => [(a, Nat)] ->
                    (a -> a, (a -> a, [a])) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_components mu ddNU =
  let {
    (d, (da, nu)) = ddNU;
  } in bindb (catch_errora
               (forallM
                 (\ f ->
                   bindb (check (not (membera mu (f, one_nat)))
                           (shows_prec_list zero_nat
                              ['n', 'e', 'w', ' ', 'u', 'n', 'a', 'r', 'y', ' ',
                                's', 'y', 'm', 'b', 'o', 'l', ' '] .
                             shows_prec zero_nat f .
                               shows_prec_list zero_nat
                                 [' ', 'c', 'l', 'a', 's', 'h', 'e', 's', ' ',
                                   'w', 'i', 't', 'h', ' ', 'o', 'l', 'd', ' ',
                                   's', 'y', 'm', 'b', 'o', 'l']))
                     (\ _ ->
                       bindb (check (d (da f) == f)
                               (shows_prec_list zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                    'i', 't', 'h', ' ', 'b', 'i', 'j', 'e', 'c',
                                    't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ',
                                    'r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', ' ',
                                    'o', 'f', ' '] .
                                 shows_prec zero_nat f))
                         (\ _ ->
                           check (membera mu (da f, zero_nat))
                             (shows_prec_list zero_nat
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                  'i', 't', 'h', ' ', 'i', 'n', 'v', 'e', 'r',
                                  's', 'e', ' ', 'r', 'e', 'n', 'a', 'm', 'i',
                                  'n', 'g', ' ', 'o', 'f', ' '] .
                               shows_prec zero_nat f))))
                 nu)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ (f, n) ->
                 bindb (check (less_eq_nat n one_nat)
                         (shows_prec_list zero_nat
                            ['a', 'r', 'i', 't', 'y', ' ', '>', ' ', '1', ' ',
                              'f', 'o', 'r', ' ', 's', 'y', 'm', 'b', 'o', 'l',
                              ' '] .
                           shows_prec zero_nat f))
                   (\ _ ->
                     check (if equal_nat n zero_nat
                             then membera nu (d f) && da (d f) == f else True)
                       (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                            't', 'h', ' ', 'b', 'i', 'j', 'e', 'c', 't', 'i',
                            'o', 'n', ' ', 'f', 'o', 'r', ' ', 'r', 'e', 'n',
                            'a', 'm', 'i', 'n', 'g', ' ', 'o', 'f', ' ', 'c',
                            'o', 'n', 's', 't', 'a', 'n', 't', ' '] .
                         shows_prec zero_nat f)))
               mu)
             (\ x -> Inl (snd x)));

str :: forall a b. (a -> a) -> b -> Term a b -> Term a b;
str d x (Fun f (v : vb : vc)) = Fun (d f) [Var x];
str d x (Fun f []) = Fun (d f) [Var x];
str d x (Fun f [t]) = Fun f [str d x t];
str d uu (Var x) = Var x;

choose_var :: forall a b. a -> Term b a -> a;
choose_var x l = hda (vars_term_list l ++ [x]);

check_to_srs_sound ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showa a, Compare b, Eq b,
      Showa b) => a -> [(b, b)] ->
                         [(Term b a, Term b a)] ->
                           [(Term b a, Term b a)] ->
                             [(Term b a, Term b a)] ->
                               [(Term b a, Term b a)] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_to_srs_sound v old_new r s rw sw =
  let {
    mu = funas_trs_list (r ++ rw);
    (d, (da, nu)) = extract_components mu old_new;
  } in bindb (check_components mu (d, (da, nu)))
         (\ _ ->
           bindb (check_varcond_subset r)
             (\ _ ->
               bindb (check_varcond_subset rw)
                 (\ _ ->
                   let {
                     checka =
                       (\ ra sa ->
                         catch_errora
                           (forallM
                             (\ (l, rb) ->
                               let {
                                 y = choose_var v l;
                                 stra = str d y;
                                 slr = (stra l, stra rb);
                               } in check (less_eq_set (vars_term l)
     (inserta y bot_set) &&
    membera sa slr)
                                      (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 'n', 'e',
   'w', ' ', 'r', 'u', 'l', 'e', ' '] .
shows_rule (shows_prec zero_nat) (shows_prec zero_nat) [' ', '-', '>', ' ']
  slr))
                             ra)
                           (\ x -> Inl (snd x)));
                   } in bindb (checka r s) (\ _ -> checka rw sw))));

const_to_string_sound_tt ::
  forall a b c.
    (Compare a, Eq a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => Const_string_sound_proof a b ->
                    Tp_ops_ext c a b () ->
                      c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
const_to_string_sound_tt (Const_string_sound_proof v old_new s sw) i tp =
  bindb (check_to_srs_sound v old_new (rc i tp) s (rwc i tp) sw)
    (\ _ -> Inr (mkc i False [] s sw));

dP_list ::
  forall a b.
    (Eq a,
      Eq b) => (a -> a) ->
                 [(Term a b, Term a b)] -> [(a, Nat)] -> [(Term a b, Term a b)];
dP_list shp r d_list =
  concatMap
    (\ lr ->
      let {
        l = fst lr;
        s = sharp_term shp l;
      } in map_filter
             (\ x ->
               (if not (supt_impl l x) &&
                     not (is_Var x) && membera d_list (the (root x))
                 then Just (s, sharp_term shp x) else Nothing))
             (supteq_list (snd lr)))
    r;

dependency_pairs_tt ::
  forall a b c d.
    (Compare a, Eq a, Linorder a, Showa a, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Linorder c,
      Showa c) => (a -> a) ->
                    Tp_ops_ext b a c () ->
                      Dpp_ops_ext d a c () ->
                        b -> Bool ->
                               Bool ->
                                 [(Term a c, Term a c)] ->
                                   Sum ([Prelude.Char] -> [Prelude.Char]) d;
dependency_pairs_tt shp i j tp nfs m p =
  let {
    r = rulesd i tp;
    q = qb i tp;
    iQ = is_QNFb i tp;
    u = filter (applicable_rule_impl iQ) r;
  } in (case catch_errora
               (bindb
                 (if isOK (check_wf_trs u) then Inr ()
                   else check (nfs &&
                                nfsb i tp &&
                                  nFQ_subset_NF_rulesb i tp &&
                                    all (\ l -> not (is_Var l)) (map fst r))
                          (shows_prec_list zero_nat
                            ['n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'i', 's',
                              ' ', 't', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'w',
                              'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd',
                              ',', ' ', 'n', 'o', 'r', ' ', 'i', 's', ' ', 't',
                              'h', 'e', ' ', 'r', 'e', 's', 't', 'r', 'i', 'c',
                              't', 'i', 'o', 'n', ' ', 't', 'o', ' ', 'i', 'n',
                              'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'w', 'i',
                              't', 'h', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ',
                              'f', 'o', 'r', 'm', ' ', 's', 'u', 'b', 's', 't',
                              'i', 't', 'u', 't', 'i', 'o', 'n', 's', ' ', 'p',
                              'r', 'e', 's', 'e', 'n', 't']))
                 (\ _ ->
                   bindb (catch_errora (forallM check_no_var q)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       let {
                         qr = map (\ (Fun f ss) -> (f, size_list ss)) q;
                         d = defined_list u;
                       } in bindb (catch_errora
                                    (forallM
                                      (\ (f, n) ->
check (not (membera d (shp f, n)))
  (shows_string ['s', 'h', 'a', 'r', 'p', 'i', 'n', 'g', ' '] .
    shows_prec zero_nat f .
      shows_string
        [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 't', 'h', 'e', ' ', 'd', 'e',
          'f', 'i', 'n', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' '] .
        shows_prec zero_nat (shp f)))
                                      d)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (catch_errora
(forallM
  (\ (f, n) ->
    check (not (membera qr (shp f, n)))
      (shows_string ['s', 'h', 'a', 'r', 'p', 'i', 'n', 'g', ' '] .
        shows_prec zero_nat f .
          shows_string
            [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 't', 'h', 'e', ' ', 's',
              'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec zero_nat (shp f) .
              shows_string
                [' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'a', ' ',
                  'r', 'o', 'o', 't', ' ', 'o', 'f', ' ', 'Q']))
  d)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    let {
                                      pa = set p;
                                    } in catch_errora
   (catch_errora
     (forallM
       (\ x ->
         (if member x pa || any (eq_rule_mod_vars x) p then Inr () else Inl x))
       (dP_list shp u d))
     (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string ['t', 'h', 'e', ' ', 'D', 'P', ' '] .
           shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] x .
             shows_string
               [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
                 'e', 'a', 'r', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'D',
                 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
               shows_nl)))))))
               (\ x ->
                 Inl (shows_string
                        ['t', 'h', 'e', ' ', 'D', 'P', '-', 't', 'r', 'a', 'n',
                          's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', ' ',
                          'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p', 'l',
                          'i', 'e', 'd', ' ', 'c', 'o', 'r', 'r', 'e', 'c', 't',
                          'l', 'y', '.'] .
                       shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd j nfs m p [] q [] r);
       });

switch_innermost_tt ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_innermost_tt i joins_i trs =
  let {
    r = rulesd i trs;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list zero_nat
                                  ['r', 'u', 'l', 'e', 's', ' ', 'a', 'r', 'e',
                                    ' ', 'n', 'o', 't', ' ', 'o', 'v', 'e', 'r',
                                    'l', 'a', 'y']))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_critical_pairs r cp joins_i)
                        (\ _ -> check_wf_trs r))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i True (map fst r) r []);
       });

unary_term :: forall a b. Term a b -> Bool;
unary_term (Var x) = True;
unary_term (Fun f [t]) = unary_term t;
unary_term (Fun v []) = False;
unary_term (Fun v (vb : vd : ve)) = False;

check_unary_signature ::
  forall a b.
    (Showa a,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unary_signature r =
  catch_errora
    (catch_errora
      (forallM
        (\ x -> (if let {
                      (l, ra) = x;
                    } in unary_term l && unary_term ra
                  then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
            shows_nl .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '-', '>', ' '] x .
                shows_nl .
                  shows_string
                    ['v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 't', 'h', 'e',
                      ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', ' ',
                      't', 'h', 'a', 't', ' ', 'a', 'l', 'l', ' ', 'f', 'u',
                      'n', 'c', 't', 'i', 'o', 'n', ' ', 's', 'y', 'm', 'b',
                      'o', 'l', 's'] .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['h', 'a', 'v', 'e', ' ', 't', 'o', ' ', 'b', 'e', ' ',
                          'u', 'n', 'a', 'r', 'y']));

rev_term :: forall a b. Ctxt a b -> Term a b -> Term a b;
rev_term c (Var x) = ctxt_apply_term c (Var x);
rev_term c (Fun f [t]) = rev_term (More f [] c []) t;

rev_rule :: forall a b. (Term a b, Term a b) -> (Term a b, Term a b);
rev_rule (l, r) = (rev_term Hole l, rev_term Hole r);

string_reversal_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_tt i trs =
  let {
    rs = rulesd i trs;
    r = rc i trs;
    s = rwc i trs;
  } in (case check_unary_signature rs of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (mkc i default_nfs_trs [] (map rev_rule r) (map rev_rule s));
       });

q_emptyb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
q_emptyb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = q_empty;

sem_lab_rel_tt ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ccompare b, Compare b, Eq b, Mapping_impl b,
      Showa b) => ([(Term a b, Term a b)] ->
                    Set (Term a b, Term a b) ->
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]))) ->
                    (a -> (a, c)) ->
                      Tp_ops_ext d a b () ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                          ([(Term a b, Term a b)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            (Set (Term a b, Term a b) ->
                              [(Term a b, Term a b)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              [Term a b] ->
                                [(Term a b, Term a b)] ->
                                  d -> Sum ([Prelude.Char] -> [Prelude.Char]) d;
sem_lab_rel_tt splitter ld i valid check_decr check_model_lab lQ lAll tp =
  let {
    r = rc i tp;
    rw = rwc i tp;
    nfs = nfsb i tp;
    (lR, (lRw, d)) = splitter lAll (set rw);
  } in (case bindb valid
               (\ _ ->
                 let {
                   q = qb i tp;
                 } in catch_errora
                        (bindb
                          (if nfs && not (q_emptyb i tp) then check_wf_trs d
                            else Inr ())
                          (\ _ ->
                            bindb (check_decr d)
                              (\ _ ->
                                bindb (check_sl_Q ld lQ q)
                                  (\ _ ->
                                    bindb (check_model_lab (set lR) r)
                                      (\ _ -> check_model_lab (set lRw) rw)))))
                        (\ x ->
                          Inl (shows_string
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                   'i', 't', 'h', ' ', 'l', 'a', 'b', 'e', 'l',
                                   'e', 'd', ' ', 'T', 'R', 'S', ':'] .
                                shows_nl . x)))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs lQ lR (lRw ++ d));
       });

sem_lab_fin_tt ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Ccompare b, Compare b, Eq b, Mapping_impl b,
      Showa b,
      Showa d) => ([(Term a b, Term a b)] ->
                    Set (Term a b, Term a b) ->
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]))) ->
                    (a -> Nat -> c -> a) ->
                      (a -> (a, c)) ->
                        (d -> d -> Bool) ->
                          Tp_ops_ext e a b () ->
                            ([(a, Nat)] ->
                              [(a, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char])
                                  (Sl_ops_ext a d c b ())) ->
                              [Term a b] ->
                                [(Term a b, Term a b)] ->
                                  e -> Sum ([Prelude.Char] -> [Prelude.Char]) e;
sem_lab_fin_tt splitter lc ld cge i gen lQ lAll tp =
  bindb (gen (insert_funas_trs (rulesd i tp) []) [])
    (\ ops ->
      let {
        check_ml =
          check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) cge lc;
        check_d = sl_check_decr ops;
      } in sem_lab_rel_tt splitter ld i (Inr ()) check_d check_ml lQ lAll tp);

semlab_fin_tt ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a (Lab b [Nat]) c () ->
                    Sl_variant (Lab b [Nat]) c ->
                      [Term (Lab b [Nat]) c] ->
                        [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
semlab_fin_tt j (Rootlab uu) =
  sem_lab_fin_tt (model_splitter label_decomp) label label_decomp equal_lab j
    (slm_gen_to_sl_gen (rl_slm Nothing));
semlab_fin_tt j (Finitelab sli) =
  sem_lab_fin_tt (model_splitter label_decomp) label label_decomp equal_nat j
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli)));
semlab_fin_tt j (QuasiFinitelab sli v) =
  sem_lab_fin_tt (quasi_splitter label_decomp) label label_decomp qmodel_cge j
    (\ f g -> qsli_to_sl v f g sli);

permutation_afs :: forall a. (Ceq a, Ccompare a) => Afs a -> Bool;
permutation_afs pi =
  ball (afs_syms pi)
    (\ (f, n) ->
      (case afsa pi (f, n) of {
        Collapse _ -> False;
        AFList xs -> eq_set (set xs) (set (upt zero_nat n)) && distinct xs;
      }));

argument_filter_tt ::
  forall a b c.
    (Ceq b, Ccompare b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b c () ->
                    [((b, Nat), Af_entry)] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
argument_filter_tt i pi tp =
  (case afs_of pi of {
    Nothing ->
      Inl (shows_prec_list zero_nat
            ['i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'a', 'r', 'g', 'u', 'm',
              'e', 'n', 't', ' ', 'f', 'i', 'l', 't', 'e', 'r']);
    Just af ->
      bindb (check (permutation_afs af)
              (shows_prec_list zero_nat
                ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f', 'i', 'l',
                  't', 'e', 'r', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                  ' ', 'p', 'e', 'r', 'm', 'u', 't', 'a', 't', 'i', 'o', 'n']))
        (\ _ ->
          let {
            pia = af_rules af;
          } in Inr (mkc i default_nfs_trs [] (pia (rc i tp)) (pia (rwc i tp))));
  });

rule_removal_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_tt i rp rremove trs =
  (case catch_errora
          (let {
             (rs, rns) = split_rulesb i trs rremove;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (catch_errora (mono rp (rs ++ rns))
                            (\ x ->
                              Inl (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'm', 'o', 'n',
                                       'o', 't', 'o', 'n', 'i', 'c', 'i', 't',
                                       'y', ' ', 'o', 'f', ' ', 's', 't', 'r',
                                       'i', 'c', 't', ' ', 'o', 'r', 'd', 'e',
                                       'r'] .
                                    shows_nl . x)))
                      (\ _ ->
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T', 'R', 'S'] .
shows_nl . x)))
                          (\ _ ->
                            catch_errora
                              (catch_errora (forallM (s rp) rs)
                                (\ x -> Inl (snd x)))
                              (\ x ->
                                Inl (shows_string
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
 'w', 'h', 'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T',
 'R', 'S'] .
                                      shows_nl . x))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'd', 'u',
                     'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                     'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w',
                     'i', 'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_R_Rwb i trs rremove rremove);
  });

check_wwf_qtrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => (Term a b -> Bool) ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wwf_qtrs nf r =
  catch_errora
    (catch_errora
      (forallM
        (\ ra ->
          (if applicable_rule_impl nf ra
            then catch_errora
                   (bindb
                     (check (not (is_Var (fst ra)))
                       (shows_string
                         ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'l', 'e',
                           'f', 't', '-', 'h', 'a', 'n', 'd', ' ', 's', 'i',
                           'd', 'e', ' ', 'i', 'n']))
                     (\ _ ->
                       catch_errora
                         (check_subseteq (vars_term_list (snd ra))
                           (vars_term_list (fst ra)))
                         (\ x ->
                           Inl (shows_string
                                  ['f', 'r', 'e', 'e', ' ', 'v', 'a', 'r', 'i',
                                    'a', 'b', 'l', 'e', ' '] .
                                 shows_prec zero_nat x .
                                   shows_string
                                     [' ', 'i', 'n', ' ', 'r', 'i', 'g', 'h',
                                       't', '-', 'h', 'a', 'n', 'd', ' ', 's',
                                       'i', 'd', 'e', ' ', 'o', 'f']))))
                   (\ x ->
                     Inl (x . shows_string [' ', 'r', 'u', 'l', 'e', ' '] .
                                shows_rule (shows_prec zero_nat)
                                  (shows_prec zero_nat) [' ', '-', '>', ' ']
                                  ra .
                                  shows_nl))
            else Inr ()))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string
             ['t', 'h', 'e', ' ', 'Q', '-', 'T', 'R', 'S', ' ', 'i', 's', ' ',
               'n', 'o', 't', ' ', 'w', 'e', 'a', 'k', 'l', 'y', ' ', 'w', 'e',
               'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd'] .
            shows_nl . x));

check_compatible_nfs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => Bool ->
                    (Term a b -> Bool) ->
                      [(Term a b, Term a b)] -> Bool -> [Term a b] -> Bool;
check_compatible_nfs nfs1 nf1 r1 nfs2 q2 =
  nfs1 == nfs2 || (null q2 || isOK (check_wwf_qtrs nf1 r1));

shows_tp ::
  forall a b c.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Tp_ops_ext c a b () -> c -> [Prelude.Char] -> [Prelude.Char];
shows_tp fun var i t =
  let {
    nfs = nfsb i t;
    r = rc i t;
    rw = rwc i t;
    q = qb i t;
  } in shows_trs fun var ['r', 'u', 'l', 'e', 's', ':'] [' ', '-', '>', ' '] r .
         (if null rw then id
           else shows_trs fun var
                  ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l',
                    'e', 's', ':']
                  [' ', '-', '>', '=', ' '] rw) .
           (if null q then id
             else shows_terms fun var
                    ['Q', '-', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', ':']
                    q) .
             (if nfs
               then shows_string
                      ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o',
                        'n', 's', ' ', 'a', 'r', 'e', ' ', 'a', 's', 's', 'u',
                        'm', 'e', 'd', ' ', 't', 'o', ' ', 'b', 'e', ' ', 'i',
                        'n', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
                        'r', 'm'] .
                      shows_nl
               else id);

check_tp_subsumes ::
  forall a b c d.
    (Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => Tp_ops_ext a (Lab b c) d () ->
                    (Bool,
                      ([Term (Lab b c) d],
                        ([(Term (Lab b c) d, Term (Lab b c) d)],
                          [(Term (Lab b c) d, Term (Lab b c) d)]))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_tp_subsumes i (nfs, (q, (r, rw))) tp =
  catch_errora
    (let {
       nfsa = nfsb i tp;
       qa = is_QNFb i tp;
       ra = rc i tp;
       rwa = rwc i tp;
       rb = r ++ rw;
       nf1 = is_QNFb i tp;
     } in bindb (check (check_compatible_nfs nfsa nf1 (ra ++ rwa) nfs q)
                  (shows_prec_list zero_nat
                    ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e',
                      ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i',
                      'o', 'n', 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm',
                      'a', 'l', '-', 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a',
                      'g', 's']))
            (\ _ ->
              bindb (catch_errora (check_NF_terms_subset qa q)
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' ', 'i', 'n', 'n', 'e', 'r',
                                 'm', 'o', 's', 't', ' ', 's', 't', 'r', 'a',
                                 't', 'e', 'g', 'y', ' ', 'd', 'u', 'e', ' ',
                                 't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
                              shows_term (shows_prec_lab zero_nat)
                                (shows_prec zero_nat) x)))
                (\ _ ->
                  bindb (catch_errora (check_subseteq ra r)
                          (\ x ->
                            Inl (toomuch ['r', 'u', 'l', 'e']
                                  (shows_rule (shows_prec_lab zero_nat)
                                    (shows_prec zero_nat) [' ', '-', '>', ' ']
                                    x))))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq rwa rb)
                              (\ x ->
                                Inl (toomuch
                                      ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e',
' ', 'r', 'u', 'l', 'e']
                                      (shows_rule (shows_prec_lab zero_nat)
(shows_prec zero_nat) [' ', '-', '>', ' '] x))))
                        (\ _ -> Inr ())))))
    (\ x ->
      Inl (shows_string
             ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
               'f', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'b', 'l', 'e',
               'm'] .
            shows_nl .
              shows_tp (shows_prec_lab zero_nat) (shows_prec zero_nat) i tp .
                shows_nl .
                  shows_string
                    ['m', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'c',
                      'o', 'n', 'c', 'l', 'u', 'd', 'e', 'd', ' ', 'f', 'r',
                      'o', 'm', ' ', 'a', 's', 's', 'u', 'm', 'i', 'n', 'g',
                      ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                      'n', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'p', 'r',
                      'o', 'b', 'l', 'e', 'm'] .
                    shows_nl .
                      shows_tp (shows_prec_lab zero_nat) (shows_prec zero_nat) i
                        (mkc i nfs q r rw) .
                        shows_nl . x . shows_nl));

fcc_tt ::
  forall a b c.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    [Ctxt b c] ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
fcc_tt i fcs cRb tp =
  let {
    r = rc i tp;
    rw = rwc i tp;
    nfs = nfsb i tp;
    rb = r ++ rw;
    (cR, cRw) = partition_rules fcs r cRb;
    _ = qb i tp;
    vs = vars_trs_list rb;
    fas = funas_trs_list rb;
  } in (case bindb (check (not (null fcs))
                     (shows_string
                        ['a', 't', ' ', 'l', 'e', 'a', 's', 't', ' ', 'o', 'n',
                          'e', ' ', 'f', 'l', 'a', 't', ' ', 'c', 'o', 'n', 't',
                          'e', 'x', 't', ' ', 'i', 's', ' ', 'r', 'e', 'q', 'u',
                          'i', 'r', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'f', 'l',
                          'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', ' ',
                          'c', 'l', 'o', 's', 'u', 'r', 'e'] .
                       shows_nl))
               (\ _ ->
                 bindb (catch_errora (forallM (check_flat_ctxt vs) fcs)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM (check_is_flat_ctxt vs fas) fcs)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM (check_flat_ctxt_complete fcs) fas)
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             bindb (catch_errora
                                     (forallM (check_rule_preserving fcs cR) r)
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 catch_errora
                                   (forallM (check_rule_preserving fcs cRb) rw)
                                   (\ x -> Inl (snd x)))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs [] cR cRw);
       });

g_isEmpty_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> Bool;
g_isEmpty_dflt_basic_oops_rm_basic_ops s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ c -> c)
    (\ _ _ -> False) True;

ta_rhs_states_set :: forall a b. Ta_impl a b -> Rbt a ();
ta_rhs_states_set (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x4;

ta_rules_impl :: forall a b. Ta_impl a b -> Rbt (b, Nat) [Ta_rule_impl a b];
ta_rules_impl (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x2;

r_lhs_states_impl :: forall a b. Ta_rule_impl a b -> [a];
r_lhs_states_impl (TA_rule_impl f qsa q qs) = qsa;

rm_set_lookup :: forall a b. (Compare_order a) => Rbt a [b] -> a -> [b];
rm_set_lookup rm = (\ a -> (case lookup rm a of {
                             Nothing -> [];
                             Just rules -> rules;
                           }));

g_union_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Rbt a ();
g_union_dflt_basic_oops_rm_basic_ops s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s1 (\ _ -> True)
    ins_rm_basic_ops s2;

rs_Union :: forall a. (Compare_order a) => [Rbt a ()] -> Rbt a ();
rs_Union = foldl g_union_dflt_basic_oops_rm_basic_ops (empty_rm_basic_ops ());

rqss_impl :: forall a b. Ta_rule_impl a b -> Rbt a ();
rqss_impl (TA_rule_impl f qsa q qs) = qs;

ta_res_impl_all ::
  forall a b c.
    (Compare_order a,
      Compare_order b) => Rbt a () ->
                            Rbt (b, Nat) [Ta_rule_impl a b] ->
                              Term b c -> Rbt a ();
ta_res_impl_all q ta (Var uu) = q;
ta_res_impl_all q ta (Fun f ts) =
  let {
    rec = map (ta_res_impl_all q ta) ts;
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    arules =
      filter
        (\ rule ->
          let {
            qs = r_lhs_states_impl rule;
          } in all_interval_nat
                 (\ i -> memb_rm_basic_ops (nth qs i) (nth rec i)) zero_nat n)
        rules;
    a = map rqss_impl arules;
  } in rs_Union a;

rule_state_compatible_heuristic ::
  forall a b c.
    (Compare_order a, Compare_order b,
      Linorder c) => Ta_impl a b -> Term b c -> Bool;
rule_state_compatible_heuristic ta l =
  g_isEmpty_dflt_basic_oops_rm_basic_ops
    (ta_res_impl_all (ta_rhs_states_set ta) (ta_rules_impl ta) l);

check_state_raise_consistent ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Linorder a, Set_impl a, Showa a, Eq b,
      Showa b) => Tree_automaton a (b, Nat) ->
                    [(a, a)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_state_raise_consistent ta rel =
  let {
    rels = set rel;
    rls = ta_rules_implb ta;
  } in catch_errora
         (forallM
           (\ r1 ->
             let {
               (TA_rule (f1, i1) qs1 q1) = r1;
             } in catch_errora
                    (forallM
                      (\ r2 ->
                        let {
                          (TA_rule (f2, i2) qs2 q2) = r2;
                        } in (if f1 == f2 && less_nat i1 i2 && qs1 == qs2
                               then check (member (q1, q2) rels)
                                      (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 'r', 'a',
   'i', 's', 'e', ' ', 'c', 'o', 'n', 's', 'i', 's', 't', 'e', 'n', 'c', 'y',
   ' ', 'b', 'e', 'c', 'a', 'u', 's', 'e', ' ', 'o', 'f', ' ', 'a', 'u', 't',
   'o', 'm', 'a', 't', 'o', 'n', '-', 'r', 'u', 'l', 'e', 's', ' '] .
shows_nl .
  shows_prec_ta_rule zero_nat r1 .
    shows_nl .
      shows_prec_ta_rule zero_nat r2 .
        shows_nl .
          shows_prec zero_nat q1 .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', '>', '>', '^', '*',
                ' '] .
              shows_prec zero_nat q2)
                               else Inr ()))
                      rls)
                    (\ x -> Inl (snd x)))
           rls)
         (\ x -> Inl (snd x));

ta_epsrs_impl :: forall a b. Ta_impl a b -> a -> Rbt a ();
ta_epsrs_impl (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x7;

ta_epss_impl :: forall a b. Ta_impl a b -> a -> Rbt a ();
ta_epss_impl (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x6;

g_inter_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Rbt a ();
g_inter_dflt_basic_oops_rm_basic_ops s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s1 (\ _ -> True)
    (\ x s -> (if memb_rm_basic_ops x s2 then ins_dj_rm_basic_ops x s else s))
    (empty_rm_basic_ops ());

ta_match_impl ::
  forall a b c.
    (Compare_order a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                 Rbt b () ->
                   (b -> Rbt b ()) -> Term a c -> [b] -> Rbt [(c, b)] ();
ta_match_impl ta qsig eps (Var x) q =
  g_from_list_dflt_basic_oops_rm_basic_ops
    (map (\ qa -> [(x, qa)])
      (g_to_list_dflt_basic_oops_rm_basic_ops
        (g_inter_dflt_basic_oops_rm_basic_ops (rs_Union (map eps q)) qsig)));
ta_match_impl ta qsig eps (Fun f ts) q =
  let {
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    ep = rs_Union (map eps q);
    fa = (\ rule ->
           g_from_list_dflt_basic_oops_rm_basic_ops
             (let {
                (TA_rule_impl _ qs qa _) = rule;
              } in (if memb_rm_basic_ops qa ep
                     then let {
                            rec = map (\ (tsi, qsi) ->
g_to_list_dflt_basic_oops_rm_basic_ops (ta_match_impl ta qsig eps tsi [qsi]))
                                    (zip ts qs);
                          } in map concat (concat_lists rec)
                     else [])));
  } in rs_Union (map fa rules);

ta_match_impla ::
  forall a b c.
    (Compare_order a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                 Rbt b () ->
                   (b -> Rbt b ()) -> [b] -> Term a c -> Rbt [(c, b)] ();
ta_match_impla ta qsig eps rhs t = ta_match_impl ta qsig eps t rhs;

ta_res_impl ::
  forall a b.
    (Compare_order a,
      Compare_order b) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                            (b -> Rbt b ()) -> Term a b -> Rbt b ();
ta_res_impl ta eps (Var q) = eps q;
ta_res_impl ta eps (Fun f ts) =
  let {
    rec = map (ta_res_impl ta eps) ts;
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    arules =
      filter
        (\ rule ->
          let {
            qs = r_lhs_states_impl rule;
          } in all_interval_nat
                 (\ i -> memb_rm_basic_ops (nth qs i) (nth rec i)) zero_nat n)
        rules;
    a = map rqss_impl arules;
  } in rs_Union a;

rule_state_compatible_eff_list ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => Ta_impl a b ->
                 (Rbt a () -> Rbt a () -> Maybe a) ->
                   (Term b c, Term b c) -> Sum ((Term b a, Term b a), a) ();
rule_state_compatible_eff_list ta rel (l, r) =
  let {
    rm = ta_rules_impl ta;
    eps = ta_epss_impl ta;
    epsa = ta_epsrs_impl ta;
    ta_res = ta_res_impl rm eps;
    rhs_rbt = ta_rhs_states_set ta;
    rhs = g_to_list_dflt_basic_oops_rm_basic_ops rhs_rbt;
  } in catch_errora
         (forallM (\ sigma -> let {
                                sigmaa = fun_of sigma;
                                l_sigma = map_term (\ x -> x) sigmaa l;
                                r_sigma = map_term (\ x -> x) sigmaa r;
                                qsl = ta_res l_sigma;
                                qsr = ta_res r_sigma;
                              } in (case rel qsl qsr of {
                                     Nothing -> Inr ();
                                     Just q -> Inl ((l_sigma, r_sigma), q);
                                   }))
           (g_to_list_dflt_basic_oops_rm_basic_ops
             (ta_match_impla rm rhs_rbt epsa rhs l)))
         (\ x -> Inl (snd x));

state_compatible_eff_list ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => Ta_impl a b ->
                 (Rbt a () -> Rbt a () -> Maybe a) ->
                   [(Term b c, Term b c)] ->
                     Sum ((Term b c, Term b c), ((Term b a, Term b a), a)) ();
state_compatible_eff_list ta rel r =
  let {
    check = rule_state_compatible_eff_list ta rel;
  } in catch_errora
         (forallM (\ lr -> catch_errora (check lr) (\ x -> Inl (lr, x))) r)
         (\ x -> Inl (snd x));

ta_final_impl :: forall a b. Ta_impl a b -> Rbt a ();
ta_final_impl (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x1;

flatten_term_enum_filter ::
  forall a b. (Term a b -> Bool) -> Term [a] b -> [Term a b];
flatten_term_enum_filter f (Var x) = let {
                                       tx = Var x;
                                     } in (if f tx then [tx] else []);
flatten_term_enum_filter f (Fun fs ts) =
  let {
    lts = map (flatten_term_enum_filter f) ts;
  } in (if any null lts then []
         else let {
                ss = concat_lists lts;
              } in filter f (concatMap (\ fa -> map (Fun fa) ss) fs));

inverse_base_term_filter ::
  forall a b. (Term (a, Nat) b -> Bool) -> Term a b -> Nat -> [Term (a, Nat) b];
inverse_base_term_filter filt l c =
  let {
    hs = upt zero_nat (suc c);
  } in flatten_term_enum_filter filt
         (map_term (\ f -> map (\ h -> lift h f) hs) (\ x -> x) l);

size_multiset :: forall a. Multiset a -> Nat;
size_multiset (Bag ms) = foldd (\ _ -> plus_nat) zero_nat ms;

compute_height ::
  forall a b.
    (Eq a,
      Eq b) => Relation_kind ->
                 Term a b -> Term a b -> Term (a, Nat) b -> Nat -> Nat;
compute_height (Weak_TRS Nothing) bl br =
  (if less_eq_nat (size_multiset (funs_term_ms br))
        (size_multiset (funs_term_ms bl))
    then (\ l x ->
           (if equal_term (map_term (lift x) (\ xa -> xa) bl) l then x
             else suc x))
    else (\ _ -> suc));
compute_height (Weak_TRS (Just c)) bl br =
  (if less_eq_nat (size_multiset (funs_term_ms br))
        (size_multiset (funs_term_ms bl))
    then (\ l x ->
           (if equal_term (map_term (lift x) (\ xa -> xa) bl) l then min c x
             else min c (suc x)))
    else (\ _ x -> min c (suc x)));
compute_height Strict_TRS bl br = (\ _ -> suc);

cover_bound_list_filter ::
  forall a b.
    (Eq a,
      Eq b) => (Term (a, Nat) b -> Bool) ->
                 ((Term a b, Term a b) -> Term a b -> Bool) ->
                   Relation_kind ->
                     Nat ->
                       [(Term a b, Term a b)] ->
                         [(Term (a, Nat) b, Term (a, Nat) b)];
cover_bound_list_filter filt ff gg c r =
  concatMap
    (\ (l, ra) ->
      let {
        ch = compute_height gg l ra;
        ee = ff (l, ra);
      } in map (\ la ->
                 (la, map_term
                        (lift (ch la
                                (min_list
                                  (map height
                                    (sym_collect
                                      (\ t -> ee (map_term base (\ x -> x) t))
                                      la)))))
                        (\ x -> x) ra))
             (inverse_base_term_filter filt l c))
    r;

g_bex_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> (a -> Bool) -> Bool;
g_bex_dflt_basic_oops_rm_basic_ops s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s not (\ x _ -> p x)
    False;

ta_contains_aux_impl ::
  forall a b.
    (Compare_order a, Ceq b, Ccompare b, Eq b,
      Linorder b) => [(a, Nat)] ->
                       [b] -> Ta_impl b a -> Set b -> Sum (Term a b) ();
ta_contains_aux_impl f qs ta q =
  let {
    _ = ta_final_impl ta;
    look = rm_set_lookup (ta_rules_impl ta);
    _ = ta_epss_impl ta;
  } in catch_errora
         (forallM
           (\ (fa, n) ->
             let {
               rules = look (fa, n);
             } in catch_errora
                    (catch_errora
                      (forallM
                        (\ x ->
                          (if any (\ rule ->
                                    r_lhs_states_impl rule == x &&
                                      let {
qq = rqss_impl rule;
                                      } in
g_bex_dflt_basic_oops_rm_basic_ops qq (\ qa -> member qa q))
                                rules
                            then Inr () else Inl x))
                        (concat_lists (replicate n qs)))
                      (\ x -> Inl (snd x)))
                    (\ x -> Inl (Fun fa (map Var x))))
           f)
         (\ x -> Inl (snd x));

alpha_rm_basic_ops :: forall a. (Cenum a, Compare_order a) => Rbt a () -> Set a;
alpha_rm_basic_ops s = dom (lookup s);

ta_contains_impl ::
  forall a b.
    (Compare_order a, Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b,
      Set_impl b) => [(a, Nat)] ->
                       [(a, Nat)] -> Ta_impl b a -> [b] -> Sum (Term a b) ();
ta_contains_impl f g ta qs =
  bindb (ta_contains_aux_impl f qs ta (set qs))
    (\ _ ->
      ta_contains_aux_impl g qs ta (alpha_rm_basic_ops (ta_final_impl ta)));

check_coherent_rule ::
  forall a b.
    (Compare_order a, Eq a, Showa a, Eq b,
      Showa b) => (a -> [a]) ->
                    Rbt (a, a) () ->
                      [Ta_rule a b] ->
                        Ta_rule a b ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_coherent_rule iter rel rules (TA_rule f qs q) =
  catch_errora
    (forallM
      (\ i ->
        let {
          qi = nth qs i;
        } in catch_errora
               (forallM
                 (\ qia ->
                   let {
                     qsa = list_update qs i qia;
                   } in check (not (null (filter
   (\ (TA_rule g qsb qa) ->
     f == g && qsa == qsb && memb_rm_basic_ops (q, qa) rel)
   rules)))
                          (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                            shows_prec zero_nat f .
                              shows_prec_list zero_nat ['('] .
                                shows_prec_list zero_nat qs .
                                  shows_prec_list zero_nat
                                    [')', ' ', '-', '>', ' '] .
                                    shows_prec zero_nat q .
                                      shows_prec_list zero_nat
[' ', 'w', 'i', 't', 'h', ' '] .
shows_prec_nat zero_nat (suc i) .
  shows_prec_list zero_nat
    ['.', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'd', 'e', 'c', 'r',
      'e', 'a', 's', 'e', 'd', ' ', 't', 'o', ' '] .
    shows_prec zero_nat qia .
      shows_prec_list zero_nat
        [' ', 'h', 'a', 's', ' ', 'n', 'o', ' ', 'c', 'o', 'u', 'n', 't', 'e',
          'r', 'p', 'a', 'r', 't']))
                 (iter qi))
               (\ x -> Inl (snd x)))
      (upt zero_nat (size_list qs)))
    (\ x -> Inl (snd x));

ntrancl ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Nat -> Set (a, a) -> Set (a, a);
ntrancl n r =
  (if equal_nat n zero_nat then r else let {
 ra = ntrancl (minus_nat n one_nat) r;
                                       } in sup_set ra (relcomp ra r));

trancl ::
  forall a.
    (Card_UNIV a, Ceq a, Ccompare a, Set_impl a) => Set (a, a) -> Set (a, a);
trancl a =
  (if finite a then ntrancl (minus_nat (card a) one_nat) a
    else (error :: forall a. String -> (() -> a) -> a) "trancl: infinite set"
           (\ _ -> trancl a));

check_coherent ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showa a, Eq b,
      Showa b) => Tree_automaton a b ->
                    Ta_relation a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_coherent (Tree_Automaton fin rules eps) (Some_Relation rel) =
  let {
    iter =
      (\ q ->
        map_filter (\ x -> (if let {
                                 (a, _) = x;
                               } in a == q
                             then Just (snd x) else Nothing))
          rel);
    rs = g_from_list_dflt_basic_oops_rm_basic_ops rel;
    ep = set eps;
    rell = converse (set rel);
  } in bindb (catch_errora (check_subseteq (concatMap iter fin) fin)
               (\ x ->
                 Inl (shows_prec zero_nat x .
                       shows_prec_list zero_nat
                         [' ', 'i', 's', ' ', 'i', 'n', ' ', 'r', 'e', 'l', 'a',
                           't', 'i', 'o', 'n', ' ', 't', 'o', ' ', 'a', ' ',
                           'f', 'i', 'n', 'a', 'l', ' ', 's', 't', 'a', 't',
                           'e', ',', ' ', 'b', 'u', 't', ' ', 'n', 'o', 't',
                           ' ', 'a', ' ', 'f', 'i', 'n', 'a', 'l', ' ', 's',
                           't', 'a', 't', 'e', ' ', 'i', 't', 's', 'e', 'l',
                           'f'])))
         (\ _ ->
           bindb (catch_errora
                   (forallM (check_coherent_rule iter rs rules) rules)
                   (\ x -> Inl (snd x)))
             (\ _ ->
               check (less_eq_set (relcomp rell ep)
                       (sup_set (relcomp (trancl ep) rell) rell))
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c',
                     'o', 'h', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 'o', 'f', ' ',
                     'e', 'p', 's', 'i', 'l', 'o', 'n', ' ', 'r', 'u', 'l', 'e',
                     's'])));
check_coherent uu Decision_Proc_Old = Inr ();
check_coherent uu Decision_Proc = Inr ();
check_coherent uu Id_Relation = Inr ();

rtrancl_rbt_impl :: forall a. (Compare_order a) => [(a, a)] -> [a] -> Rbt a ();
rtrancl_rbt_impl =
  rtrancl_impl
    (\ r ->
      let {
        rm = elem_list_to_rm fst r;
      } in (\ asa ->
             g_to_list_dflt_basic_oops_rm_basic_ops
               (rs_Union
                 (map (\ a ->
                        g_from_list_dflt_basic_oops_rm_basic_ops
                          (map snd (rm_set_lookup rm a)))
                   asa))))
    (\ asa bs ->
      g_union_dflt_basic_oops_rm_basic_ops bs
        (g_from_list_dflt_basic_oops_rm_basic_ops asa))
    memb_rm_basic_ops (empty_rm_basic_ops ());

memo_rbt_rtrancl :: forall a. (Compare_order a) => [(a, a)] -> a -> Rbt a ();
memo_rbt_rtrancl r =
  let {
    tr = rtrancl_rbt_impl r;
    rm = g_list_to_map_rm_basic_ops
           (map (\ a -> (a, tr [a]))
             (((g_to_list_dflt_basic_oops_rm_basic_ops .
                 g_from_list_dflt_basic_oops_rm_basic_ops) .
                map fst)
               r));
  } in (\ a -> (case lookup rm a of {
                 Nothing -> g_from_list_dflt_basic_oops_rm_basic_ops [a];
                 Just asa -> asa;
               }));

conv_ta_rule :: forall a b. (a -> Rbt a ()) -> Ta_rule a b -> Ta_rule_impl a b;
conv_ta_rule eps (TA_rule f qs q) = TA_rule_impl f qs q (eps q);

r_sym_impl :: forall a b. Ta_rule_impl a b -> (b, Nat);
r_sym_impl (TA_rule_impl f qsa q qs) = (f, size_list qsa);

generate_ta ::
  forall a b.
    (Compare_order a, Compare_order b) => Tree_automaton a b -> Ta_impl a b;
generate_ta (Tree_Automaton fin rules eps) =
  let {
    ep = memo_rbt_rtrancl eps;
    epr = memo_rbt_rtrancl (map (\ (q, qa) -> (qa, q)) eps);
    rqs_rs = rs_Union (map (\ rule -> ep (r_rhs rule)) rules);
    rrules = map (conv_ta_rule ep) rules;
  } in TA_Impl (g_from_list_dflt_basic_oops_rm_basic_ops fin)
         (elem_list_to_rm r_sym_impl rrules)
         (g_to_list_dflt_basic_oops_rm_basic_ops rqs_rs) rqs_rs eps ep epr;

generate_ta_cond ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showa a, Compare_order b, Eq b,
      Showa b) => Tree_automaton a b ->
                    Ta_relation a ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) (Ta_impl a b);
generate_ta_cond ta rel =
  bindb (catch_errora (check_coherent ta rel)
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ', 'i', 's',
                     ' ', 'n', 'o', 't', ' ', 'c', 'o', 'h', 'e', 'r', 'e', 'n',
                     't', ' ', 'w', '.', 'r', '.', 't', '.', ' ', 'r', 'e', 'l',
                     'a', 't', 'i', 'o', 'n'] .
                  shows_nl . x)))
    (\ _ -> Inr (generate_ta ta));

relation_as_list ::
  forall a. Ta_relation a -> Sum ([Prelude.Char] -> [Prelude.Char]) [(a, a)];
relation_as_list (Some_Relation rel) = Inr rel;
relation_as_list Id_Relation = Inr [];
relation_as_list Decision_Proc =
  Inl (shows_prec_list zero_nat
        ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e',
          'd', 'u', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l',
          'a', 'b', 'l', 'e', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'l',
          'e', 'f', 't', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'T', 'R', 'S',
          's']);
relation_as_list Decision_Proc_Old =
  Inl (shows_prec_list zero_nat
        ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e',
          'd', 'u', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l',
          'a', 'b', 'l', 'e', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'l',
          'e', 'f', 't', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'T', 'R', 'S',
          's']);

check_ta_bounded ::
  forall a b.
    (Linorder b,
      Showa b) => Ta_impl a (b, Nat) ->
                    Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ta_bounded ta c =
  catch_errora
    (catch_errora
      (forallM
        (\ x -> (if let {
                      (f, _) = x;
                    } in less_eq_nat (height f) c
                  then Inr () else Inl x))
        (map fst (g_to_list_rm_basic_ops (ta_rules_impl ta))))
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (let {
             (f, _) = x;
           } in shows_prec_prod zero_nat f .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ', 'i',
                      'n', ' ', 'T', 'A', ' ', 'w', 'i', 't', 'h', ' ', 'h',
                      'e', 'i', 'g', 'h', 't', ' ', 'l', 'a', 'r', 'g', 'e',
                      'r', ' ', 't', 'h', 'a', 'n', ' ', 'c', ' ', '=', ' '] .
                    shows_prec_nat zero_nat c));

bounds_condition ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => Boundstype ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_condition Roof uu = Inr ();
bounds_condition Match r =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (l, ra) = x;
              } in subseteq_mset (vars_term_ms ra) (vars_term_ms l)
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (let {
             (l, ra) = x;
           } in shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '-', '>', ' '] (l, ra) .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'd', 'u', 'p', 'l', 'i', 'c', 'a',
                        't', 'i', 'n', 'g']));

non_collapsing_impl :: forall a b c. [(a, Term b c)] -> Bool;
non_collapsing_impl r = all ((\ t -> not (is_Var t)) . snd) r;

construct_c_opt :: forall a b. Nat -> [(Term a b, Term a b)] -> Maybe Nat;
construct_c_opt c r = (if non_collapsing_impl r then Just c else Nothing);

boundstype_fun ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => Boundstype -> (Term a b, Term a b) -> Term a b -> Bool;
boundstype_fun Roof = roof;
boundstype_fun Match = matcha;

iteratei_set_op_list_it_rs_ops ::
  forall a b.
    (Linorder a) => Rbt a () -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_set_op_list_it_rs_ops s =
  (\ c f -> rm_iterateoi (impl_of s) c (f . fst));

rs_subset :: forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Maybe a;
rs_subset asa bs =
  iteratei_set_op_list_it_rs_ops asa (\ a -> (case a of {
       Nothing -> True;
       Just _ -> False;
     }))
    (\ a _ -> (if memb_rm_basic_ops a bs then Nothing else Just a)) Nothing;

rel_checker ::
  forall a.
    (Compare_order a, Eq a) => Ta_relation a -> Rbt a () -> Rbt a () -> Maybe a;
rel_checker (Some_Relation rel) =
  (\ lhs rhs ->
    let {
      rlist = g_to_list_dflt_basic_oops_rm_basic_ops rhs;
    } in (case catch_errora
                 (forallM
                   (\ l -> check (any (\ r -> membera rel (l, r)) rlist) l)
                   (g_to_list_dflt_basic_oops_rm_basic_ops lhs))
                 (\ x -> Inl (snd x))
           of {
           Inl a -> Just a;
           Inr _ -> Nothing;
         }));
rel_checker Id_Relation = rs_subset;
rel_checker Decision_Proc = rs_subset;
rel_checker Decision_Proc_Old = rs_subset;

check_det ::
  forall a b.
    (Eq a,
      Eq b) => Tree_automaton a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_det (Tree_Automaton fin rules eps) =
  catch_errora
    (bindb
      (check (null eps)
        (shows_prec_list zero_nat
          ['e', 'p', 's', 'i', 'l', 'o', 'n', ' ', 't', 'r', 'a', 'n', 's', 'i',
            't', 'i', 'o', 'n', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l',
            'o', 'w', 'e', 'd']))
      (\ _ ->
        check (distinct (map (\ (TA_rule f qs _) -> (f, qs)) (remdups rules)))
          (shows_prec_list zero_nat
            ['s', 'o', 'm', 'e', ' ', 'l', 'h', 's', ' ', 'o', 'c', 'c', 'u',
              'r', 's', ' ', 't', 'w', 'i', 'c', 'e'])))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'e', 'n', 's', 'u', 'r', 'i', 'n', 'g', ' ', 'd', 'e', 't', 'e',
               'r', 'm', 'i', 'n', 'i', 's', 'm', ' ', 'o', 'f', ' ', 'a', 'u',
               't', 'o', 'm', 'a', 't', 'a'] .
            shows_nl . x));

check_bounds_generic ::
  forall a b c.
    (Compare_order a, Eq a, Showa a, Card_UNIV b, Cenum b, Ceq b, Ccompare b,
      Compare_order b, Eq b, Set_impl b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c,
      Showa c) => Bounds_info a b ->
                    [(Term a c, Term a c)] ->
                      [(Term a c, Term a c)] ->
                        [(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_bounds_generic (Bounds_Info typea c qfin preTA rel) r s f g =
  let {
    c_opt = construct_c_opt c r;
    rs = r ++ s;
  } in bindb (generate_ta_cond preTA rel)
         (\ ta ->
           let {
             rell = rel_checker rel;
           } in bindb (check_wf_trs rs)
                  (\ _ ->
                    bindb (check
                            (less_eq_set (set qfin)
                              (alpha_rm_basic_ops (ta_final_impl ta)))
                            (shows_prec_list zero_nat
                              ['e', 'x', 'p', 'l', 'i', 'c', 'i', 't', 'l', 'y',
                                ' ', 'm', 'e', 'n', 't', 'i', 'o', 'n', 'e',
                                'd', ' ', 'f', 'i', 'n', 'a', 'l', ' ', 's',
                                't', 'a', 't', 'e', 's', ' ', 'm', 'u', 's',
                                't', ' ', 'b', 'e', ' ', 'f', 'i', 'n', 'a',
                                'l']))
                      (\ _ ->
                        bindb (if isOK (check_left_linear_trs rs) then Inr ()
                                else bindb (catch_errora (check_det preTA)
     (\ x ->
       Inl (shows_prec_list zero_nat
              ['f', 'o', 'r', ' ', 'n', 'o', 'n', ' ', 'l', 'e', 'f', 't', '-',
                'l', 'i', 'n', 'e', 'a', 'r', ' ', 'T', 'R', 'S', ' ', 'w', 'e',
                ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'd', 'e', 't', '.',
                ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n'] .
             shows_nl . x)))
                                       (\ _ ->
 bindb (relation_as_list rel) (check_state_raise_consistent preTA)))
                          (\ _ ->
                            bindb (bounds_condition typea rs)
                              (\ _ ->
                                bindb (check_ta_bounded ta c)
                                  (\ _ ->
                                    bindb (check
    (any (\ q -> memb_rm_basic_ops q (ta_rhs_states_set ta)) qfin)
    (shows_prec_list zero_nat
      ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 'm',
        'e', 'n', 't', 'i', 'o', 'n', 'e', 'd', ' ', 'f', 'i', 'n', 'a', 'l',
        ' ', 's', 't', 'a', 't', 'e', ' ', 'i', 'n', ' ', 'T', 'A']))
                                      (\ _ ->
bindb (catch_errora
        (ta_contains_impl (map (\ (fa, a) -> (lift zero_nat fa, a)) f)
          (map (\ (fa, a) -> (lift zero_nat fa, a)) g) ta qfin)
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['i', 't', ' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                   ' ', 'b', 'e', ' ', 'g', 'u', 'a', 'r', 'a', 'n', 't', 'e',
                   'e', 'd', ' ', 't', 'h', 'a', 't', ' ', 'l', 'i', 'f', 't',
                   '0', '(', 'T', '(', 'S', 'i', 'g', 'm', 'a', ')', ')', ' ',
                   'i', 's', ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', ' ',
                   'b', 'y', ' ', 'T', 'A'] .
                shows_nl .
                  shows_prec_list zero_nat
                    ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n', 'o', ' ',
                      't', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' ',
                      'f', 'r', 'o', 'm', ' '] .
                    shows_prec_term zero_nat x .
                      shows_prec_list zero_nat
                        [' ', 't', 'o', ' ', 'a', ' ', 'f', 'i', 'n', 'a', 'l',
                          ' ', 's', 't', 'a', 't', 'e'])))
  (\ _ ->
    bindb (catch_errora
            (state_compatible_eff_list ta rell
              (cover_bound_list_filter
                (\ l -> not (rule_state_compatible_heuristic ta l))
                (boundstype_fun typea) Strict_TRS c r))
            (\ x ->
              Inl (let {
                     (lr, (lr_rhs, q)) = x;
                   } in shows_prec_list zero_nat
                          ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                            'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e',
                            ' ', 'w', 'i', 't', 'h', ' ', 'T', 'R', 'S'] .
                          shows_nl .
                            shows_prec_list zero_nat
                              ['f', 'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
                              shows_rule (shows_prec_prod zero_nat)
                                (shows_prec zero_nat) [' ', '-', '>', ' '] lr .
                                shows_nl .
                                  shows_prec_list zero_nat
                                    ['w', 'h', 'i', 'c', 'h', ' ', 'i', 's',
                                      ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                                      'i', 'a', 't', 'e', 'd', ' ', 'b', 'y',
                                      ' ', 's', 't', 'a', 't', 'e', 's', ' ',
                                      't', 'o', ' '] .
                                    shows_rule (shows_prec_prod zero_nat)
                                      (shows_prec zero_nat) [' ', '-', '>', ' ']
                                      lr_rhs .
                                      shows_nl .
shows_prec_list zero_nat ['t', 'h', 'e', ' ', 's', 't', 'a', 't', 'e', ' '] .
  shows_prec zero_nat q .
    shows_prec_list zero_nat
      [' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'r', 'e', 'a', 'c', 'h',
        'a', 'b', 'l', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ',
        'l', 'h', 's'] .
      shows_nl)))
      (\ _ ->
        catch_errora
          (state_compatible_eff_list ta rell
            (cover_bound_list_filter
              (\ l -> not (rule_state_compatible_heuristic ta l)) matcha
              (Weak_TRS c_opt) c s))
          (\ x ->
            Inl (let {
                   (lr, (lr_rhs, q)) = x;
                 } in shows_prec_list zero_nat
                        ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c',
                          'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ', 'w',
                          'i', 't', 'h', ' ', 'r', 'e', 'l', 'a', 't', 'i', 'v',
                          'e', ' ', 'T', 'R', 'S'] .
                        shows_nl .
                          shows_prec_list zero_nat
                            ['f', 'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
                            shows_rule (shows_prec_prod zero_nat)
                              (shows_prec zero_nat) [' ', '-', '>', ' '] lr .
                              shows_nl .
                                shows_prec_list zero_nat
                                  ['w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ',
                                    'i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a',
                                    't', 'e', 'd', ' ', 'b', 'y', ' ', 's', 't',
                                    'a', 't', 'e', 's', ' ', 't', 'o', ' '] .
                                  shows_rule (shows_prec_prod zero_nat)
                                    (shows_prec zero_nat) [' ', '-', '>', ' ']
                                    lr_rhs .
                                    shows_nl .
                                      shows_prec_list zero_nat
['t', 'h', 'e', ' ', 's', 't', 'a', 't', 'e', ' '] .
shows_prec zero_nat q .
  shows_prec_list zero_nat
    [' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'r', 'e', 'a', 'c', 'h', 'a',
      'b', 'l', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ', 'l', 'h',
      's'] .
    shows_nl)))))))))));

bounds_tt ::
  forall a b c d.
    (Compare_order b, Eq b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showa c,
      Card_UNIV d, Cenum d, Ceq d, Ccompare d, Compare_order d, Eq d,
      Set_impl d,
      Showa d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_tt i info tp = let {
                        r = rulesd i tp;
                        f = funas_trs_list r;
                      } in check_bounds_generic info r [] f f;

check_trs_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_termination_proof_main j ia assms i tp R_is_Empty =
  debug (i []) ['R', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y']
    (if null (rc j tp) then Inr ()
      else Inl (i . shows_string
                      [':', ' ', 'R', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                        'e', 'm', 'p', 't', 'y', ' ', 'i', 'n', ' ', 't', 'h',
                        'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                        ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                        'n', '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                      shows_nl .
                        shows_tp (shows_prec_lab zero_nat)
                          (shows_prec_list zero_nat) j tp));
check_trs_termination_proof_main j ia assms i tp (Rule_Removal redp rR prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (let {
       r = rulesd j tp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora (rule_removal_tt j (get_redtriple redp) rr tp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'r',
                                 'u', 'l', 'e', ' ', 'r', 'e', 'm', 'o', 'v',
                                 'a', 'l', ' ', 't', 'e', 'c', 'h', 'n', 'i',
                                 'q', 'u', 'e', ' ', 'o', 'n', ' '] .
                               shows_nl .
                                 shows_tp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) j tp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
 'v', 'e', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] rr .
   shows_nl . x)))
            (\ tpa ->
              catch_errora
                (check_trs_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) tpa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u',
                               'l', 'e', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l',
                               ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u',
                               'e'] .
                             shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (DP_Trans nfs m p prf) =
  debug (i []) ['D', 'P', ' ', 't', 'r', 'a', 'n', 's']
    (bindb
      (catch_errora (dependency_pairs_tt Sharp j ia tp nfs m p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g',
                       ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ', 'T',
                       'R', 'S'] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl .
                           shows_string
                             ['t', 'o', ' ', 't', 'h', 'e', ' ', 'i', 'n', 'i',
                               't', 'i', 'a', 'l', ' ', 'D', 'P', ' ', 'p', 'r',
                               'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h',
                               ' ', 'p', 'a', 'i', 'r', 's', ' '] .
                             shows_nl .
                               shows_rules (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                 p .
                                 shows_nl . x)))
      (\ dpp ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dpp prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 's', 'w', 'i', 't', 'c', 'h', ' ', 't',
                         'o', ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c',
                         'y', ' ', 'p', 'a', 'i', 'r', 's'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (String_Reversal prf) =
  debug (i [])
    ['S', 't', 'r', 'i', 'n', 'g', ' ', 'R', 'e', 'v', 'e', 'r', 's', 'a', 'l']
    (bindb
      (catch_errora (string_reversal_tt j tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 't', 'r', 'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e',
                       'r', 's', 'a', 'l', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 't', 'r', 'i',
                         'n', 'g', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'a', 'l',
                         ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Constant_String p prf) =
  debug (i [])
    ['C', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 't', 'o', ' ', 'U', 'n', 'a',
      'r', 'y']
    (bindb
      (catch_errora (const_to_string_sound_tt p j tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 't', 'u', 'r', 'n', 'i', 'n', 'g', ' ', 'c',
                       'o', 'n', 's', 't', 'a', 'n', 't', 's', ' ', 'i', 'n',
                       't', 'o', ' ', 'u', 'n', 'a', 'r', 'y', ' ', 's', 'y',
                       'm', 'b', 'o', 'l', 's', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 's',
                         't', 'a', 'n', 't', ' ', 't', 'o', ' ', 'u', 'n', 'a',
                         'r', 'y', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u',
                         'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Semlab sli lQ lAll prf) =
  debug (i []) ['S', 'e', 'm', 'l', 'a', 'b']
    (bindb
      (catch_errora (semlab_fin_tt j sli lQ lAll tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 'e', 'm', 'a', 'n', 't', 'i', 'c', ' ', 'l', 'a',
                       'b', 'e', 'l', 'l', 'i', 'n', 'g', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'e', 'm', '.',
                         'l', 'a', 'b', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q',
                         'u', 'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Bounds info) =
  debug (i []) ['B', 'o', 'u', 'n', 'd', 's']
    (catch_errora (bounds_tt j info tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'b', 'o',
                     'u', 'n', 'd', 's', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ',
                     't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                     'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                   shows_nl .
                     shows_tp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) j tp .
                       shows_nl . x)));
check_trs_termination_proof_main j ia assms i tp (Uncurry u_info rR prf) =
  debug (i []) ['U', 'n', 'c', 'u', 'r', 'r', 'y']
    (bindb
      (catch_errora (uncurry_tt j u_info rR tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       'c', 'u', 'r', 'r', 'y', 'i', 'n', 'g', ' ', 't', 'r',
                       'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o',
                       'n'] .
                     shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c', 'u',
                         'r', 'r', 'y', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Fcc fcs r prf) =
  debug (i []) ['F', 'c', 'c']
    (bindb
      (catch_errora (fcc_tt j fcs r tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       'f', 'l', 'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x',
                       't', ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e'] .
                     shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 'f', 'l', 'a', 't', ' ', 'c', 'o', 'n',
                         't', 'e', 'x', 't', ' ', 'c', 'l', 'o', 's', 'u', 'r',
                         'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Split rrem prf1 prf2) =
  debug (i []) ['S', 'p', 'l', 'i', 't']
    (let {
       (tp1, tp2) = split_tt j tp rrem;
     } in bindb (catch_errora
                  (check_trs_termination_proof_main j ia assms
                    (i . shows_string ['.', '1']) tp1 prf1)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                 'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                 's', 'p', 'l', 'i', 't', 't', 'i', 'n', 'g'] .
                               shows_nl . indent x)))
            (\ _ ->
              catch_errora
                (check_trs_termination_proof_main j ia assms
                  (i . shows_string ['.', '2']) tp2 prf2)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'p',
                               'l', 'i', 't', 't', 'i', 'n', 'g'] .
                             shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Switch_Innermost joins prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', ' ', 'I', 'n', 'n', 'e', 'r', 'm', 'o', 's',
      't']
    (bindb
      (catch_errora (switch_innermost_tt j joins tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g',
                       ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r', 'm', 'o',
                       's', 't', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'w', 'i', 't',
                         'c', 'h', ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r',
                         'm', 'o', 's', 't'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Drop_Equality prf) =
  debug (i []) ['D', 'r', 'o', 'p', ' ', 'E', 'q', 'u', 'a', 'l', 'i', 't', 'y']
    (let {
       tpa = mkc j (nfsb j tp) (qb j tp) (rc j tp)
               (filter (\ (l, r) -> not (equal_term l r)) (rwc j tp));
     } in catch_errora
            (check_trs_termination_proof_main j ia assms
              (i . shows_string ['.', '1']) tpa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 'd', 'r', 'o', 'p', 'p', 'i', 'n',
                           'g', ' ', 'e', 'q', 'u', 'a', 'l', 'i', 't', 'y',
                           ' ', 'r', 'u', 'l', 'e', 's'] .
                         shows_nl . indent x)));
check_trs_termination_proof_main j ia assms i tp
  (Remove_Nonapplicable_Rules r prf) =
  debug (i [])
    ['R', 'e', 'm', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a', 'p',
      'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']
    (let {
       _ = rc j tp;
     } in bindb (catch_errora (check_non_applicable_rules (is_QNFb j tp) r)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'r', 'e', 'm', 'o', 'v',
                                 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a',
                                 'p', 'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e',
                                 ' ', 'r', 'u', 'l', 'e', 's'] .
                               shows_nl .
                                 indent
                                   (shows_rule (shows_prec_lab zero_nat)
                                      (shows_prec_list zero_nat)
                                      [' ', '-', '>', ' '] x .
                                     shows_prec_list zero_nat
                                       [' ', 'i', 's', ' ', 'a', 'p', 'p', 'l',
 'i', 'c', 'a', 'b', 'l', 'e']))))
            (\ _ ->
              let {
                tpa = delete_R_Rwb j tp r r;
              } in catch_errora
                     (check_trs_termination_proof_main j ia assms
                       (i . shows_string ['.', '1']) tpa prf)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                    'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                    'n', 'o', 'n', '-', 'a', 'p', 'p', 'l', 'i',
                                    'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                                    'e', 's', ' ', 'r', 'e', 'm', 'o', 'v', 'a',
                                    'l'] .
                                  shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Permuting_AFS pi prf) =
  debug (i [])
    ['P', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', ' ', 's', 'o', 'm', 'e', ' ',
      'r', 'u', 'l', 'e', 's']
    (bindb
      (catch_errora (argument_filter_tt j pi tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g',
                       ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ' ',
                       'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'p', 'e', 'r', 'm',
                         'u', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                         'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tpa (Assume_SN tp ass) =
  debug (i [])
    ['T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'A', 's', 's',
      'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n',
      'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora (check_tp_subsumes j tp tpa)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a',
                                  't', 'i', 'o', 'n', ' ', 'a', 's', 's', 'u',
                                  'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r',
                                  ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ',
                                  'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_fptrs_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b [Nat]) [Prelude.Char],
                              (Term (Lab b [Nat]) [Prelude.Char], Location))],
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])]) ->
                            Fptrs_termination_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fptrs_termination_proof_main j ia assms i tpa (Assume_FP_SN tp ass) =
  debug (i [])
    ['O', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 'T', 'e', 'r', 'm', 'i',
      'n', 'a', 't', 'i', 'o', 'n', ' ', 'A', 's', 's', 'u', 'm', 'p', 't', 'i',
      'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'P',
      'r', 'o', 'o', 'f']
    (if assms
      then bindb (check (tpa == tp)
                   (shows_prec_list zero_nat
                     ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 'a',
                       's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'd',
                       'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                       'c', 'h', ' ', 'c', 'u', 'r', 'r', 'e', 'n', 't', ' ',
                       'g', 'o', 'a', 'l']))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_dp_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          c -> Dp_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_termination_proof_main j ia assms i dpp P_is_Empty =
  debug (i []) ['P', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y']
    (if null (pb ia dpp) && (null (pwb ia dpp) || null (rd ia dpp)) then Inr ()
      else Inl (i . shows_string
                      [':', ' ', 'P', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                        'e', 'm', 'p', 't', 'y', ' ', 'i', 'n', ' ', 't', 'h',
                        'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                        ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                        ' '] .
                      shows_nl .
                        shows_dpp (shows_prec_lab zero_nat)
                          (shows_prec_list zero_nat) ia dpp));
check_dp_termination_proof_main j ia assms i dpp
  (Subterm_Criterion_Proc p rseq rP prf) =
  debug (i [])
    ['S', 'u', 'b', 't', 'e', 'r', 'm', '_', 'C', 'r', 'i', 't', 'e', 'r', 'i',
      'o', 'n', '_', 'P', 'r', 'o', 'c']
    (let {
       pa = pairsb ia dpp;
       pr = ceta_list_diff pa rP;
     } in bindb (catch_errora (subterm_criterion_proc ia p rseq pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 's',
                                 'u', 'b', 't', 'e', 'r', 'm', ' ', 'c', 'r',
                                 'i', 't', 'e', 'r', 'i', 'o', 'n', ' ', 't',
                                 'o', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ',
                                 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       ['a', 'n', 'd', ' ', 't', 'r', 'y', 'i',
 'n', 'g', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o', 'v', 'e', ' ', 't', 'h', 'e',
 ' ', 'p', 'a', 'i', 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'u',
                               'b', 't', 'e', 'r', 'm', ' ', 'c', 'r', 'i', 't',
                               'e', 'r', 'i', 'o', 'n'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Gen_Subterm_Criterion_Proc p pr prf) =
  debug (i [])
    ['G', 'e', 'n', '_', 'S', 'u', 'b', 't', 'e', 'r', 'm', '_', 'C', 'r', 'i',
      't', 'e', 'r', 'i', 'o', 'n', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (generalized_subterm_proc ia p pr dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r', 'a', 'l',
                       'i', 'z', 'e', 'd', ' ', 's', 'u', 'b', 't', 'e', 'r',
                       'm', ' ', 'c', 'r', 'i', 't', 'e', 'r', 'i', 'o', 'n',
                       ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ',
                       'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl .
                           shows_string
                             ['a', 'n', 'd', ' ', 't', 'r', 'y', 'i', 'n', 'g',
                               ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o', 'v', 'e',
                               ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', 's',
                               ' '] .
                             shows_nl .
                               shows_rules (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                 pr .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e',
                         'r', 'a', 'l', 'i', 'z', 'e', 'd', ' ', 's', 'u', 'b',
                         't', 'e', 'r', 'm', ' ', 'c', 'r', 'i', 't', 'e', 'r',
                         'i', 'o', 'n'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Redpair_Proc redp rP prf) =
  debug (i []) ['R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'P', 'r', 'o', 'c']
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       proc =
         (case redp of {
           Inl rrp ->
             generic_ur_af_root_redtriple_proc ia (get_root_redtriple rrp)
               Nothing;
           Inr rp -> generic_ur_af_redtriple_proc ia (get_redtriple rp) Nothing;
         });
     } in bindb (catch_errora (proc pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'r',
                                 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ',
                                 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c',
                                 'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ',
                                 'r', 'e', 'm', 'o', 'v', 'e', ' ', 'f', 'r',
                                 'o', 'm', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                                 ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e',
                               'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                               'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                               'o', 'r'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Usable_Rules_Proc u prf) =
  debug (i [])
    ['U', 's', 'a', 'b', 'l', 'e', '_', 'R', 'u', 'l', 'e', 's', '_', 'P', 'r',
      'o', 'c']
    (bindb
      (catch_errora (usable_rules_proc ia u dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                       'r', 'u', 'l', 'e', 's', ' ', 'p', 'r', 'o', 'c', 'e',
                       's', 's', 'o', 'r', ' ', 't', 'o', ' ', 'r', 'e', 's',
                       't', 'r', 'i', 'c', 't', ' ', 't', 'h', 'e', ' ', 'D',
                       'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'u', 's',
                               'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's',
                               ' '] .
                             shows_nl .
                               shows_rules (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                 u .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 's', 'a', 'b',
                         'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'p', 'r',
                         'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Q_Reduction_Proc q prf) =
  debug (i [])
    ['Q', '_', 'R', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', '_', 'P', 'r', 'o',
      'c']
    (bindb
      (catch_errora (q_reduction_proc ia q dpp)
        (\ x ->
          Inl (i . shows_prec_list zero_nat
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'Q', '-', 'r', 'e', 'd', 'u', 'c',
                       't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                       's', 'o', 'r'] .
                     shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', '-', 'r', 'e',
                         'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o',
                         'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_Redpair_Proc redp rP rR prf) =
  debug (i [])
    ['M', 'o', 'n', 'o', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'P', 'r',
      'o', 'c']
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       r = rulese ia dpp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora
                  (mono_redpair_proc ia (get_redtriple redp) pr rr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'm',
                                 'o', 'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c',
                                 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r',
                                 ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                                 'r', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
                                 'v', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't',
                                 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o',
                                 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl .
     shows_string
       [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's',
         ' '] .
       shows_nl .
         shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
           [' ', '-', '>', ' '] rr .
           shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o',
                               'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i',
                               'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r',
                               'o', 'c', 'e', 's', 's', 'o', 'r'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_URM_Redpair_Proc redp pr rr prf) =
  debug (i [])
    ['M', 'o', 'n', 'o', '_', 'U', 'R', 'M', '_', 'R', 'e', 'd', 'p', 'a', 'i',
      'r', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (mono_urm_redpair_proc ia (get_redtriple redp) pr rr dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'm', 'o', 'n', 'o', ' ', 'r', 'e',
                       'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i',
                       'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r',
                       ' ', 'w', 'i', 't', 'h', ' ', 'u', 's', 'a', 'b', 'l',
                       'e', ' ', 'r', 'e', 'p', 'l', '.', ' ', 'm', 'a', 'p',
                       ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o', 'v', 'e', ' ',
                       'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                       ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl .
                           shows_string
                             [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', 's',
                               ' '] .
                             shows_nl .
                               shows_rules (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                 pr .
                                 shows_nl .
                                   shows_string
                                     [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e',
                                       ' ', 'r', 'u', 'l', 'e', 's', ' '] .
                                     shows_nl .
                                       shows_rules (shows_prec_lab zero_nat)
 (shows_prec_list zero_nat) [' ', '-', '>', ' '] rr .
 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'n', 'o',
                         ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ',
                         'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                         's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Dep_Graph_Proc edpts) =
  debug (i [])
    ['D', 'e', 'p', '_', 'G', 'r', 'a', 'p', 'h', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (dep_graph_proc ia dpp edpts)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i',
                       'l', 'e', ' ', 't', 'r', 'y', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'p', 'e', 'r', 'f', 'o', 'r', 'm', ' ', 'S',
                       'c', 't', 'x', 't', '_', 'c', 'l', 'o', 's', 'u', 'r',
                       'e', '-', 'd', 'e', 'c', 'o', 'm', 'p', 'o', 's', 'i',
                       't', 'i', 'o', 'n', ' ', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ pdpps ->
        catch_errora
          (catch_errora
            (forallM_index
              (\ (prof, dppa) ja ->
                check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.'] . shows_prec_nat zero_nat (suc ja))
                  dppa prof)
              pdpps)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'd', 'e', 'p', 'e',
                         'n', 'd', 'e', 'n', 'c', 'y', ' ', 'g', 'r', 'a', 'p',
                         'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                         'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Redpair_UR_Proc redp rP ur prf) =
  debug (i [])
    ['R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'U', 'R', '_', 'P', 'r', 'o', 'c']
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       proc =
         (case redp of {
           Inl rrp ->
             generic_ur_af_root_redtriple_proc ia (get_root_redtriple rrp)
               (Just ur);
           Inr rp ->
             generic_ur_af_redtriple_proc ia (get_redtriple rp) (Just ur);
         });
     } in bindb (catch_errora (proc pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'r',
                                 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ',
                                 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c',
                                 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                                 'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                                 'r', 'u', 'l', 'e', 's', ' ', 't', 'o', ' ',
                                 'r', 'e', 'm', 'o', 'v', 'e', ' ', 'f', 'r',
                                 'o', 'm', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                                 ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e',
                               'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                               'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                               'o', 'r'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_Redpair_UR_Proc redp rP rR ur prf) =
  debug (i [])
    ['M', 'o', 'n', 'o', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'U', 'R',
      '_', 'P', 'r', 'o', 'c']
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       r = rulese ia dpp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora
                  (generic_mono_ur_redpair_proc ia (get_redtriple redp) pr rr ur
                    dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'm',
                                 'o', 'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c',
                                 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r',
                                 ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                                 'r', ' ', 'w', 'i', 't', 'h', ' ', 'u', 's',
                                 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                                 's', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
                                 'v', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't',
                                 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o',
                                 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl .
     shows_string
       [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's',
         ' '] .
       shows_nl .
         shows_rules (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
           [' ', '-', '>', ' '] rr .
           shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o',
                               'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i',
                               'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r',
                               'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i',
                               't', 'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                               'r', 'u', 'l', 'e', 's'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Uncurry_Proc mode u_info p r prf) =
  debug (i []) ['U', 'n', 'c', 'u', 'r', 'r', 'y', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (uncurry_proc_both ia mode u_info p r dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'u', 'n', 'c', 'u', 'r', 'r', 'y',
                       'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'D',
                       'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c', 'u',
                         'r', 'r', 'y', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c',
                         'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Size_Change_Subterm_Proc graphs) =
  debug (i [])
    ['S', 'i', 'z', 'e', '_', 'C', 'h', 'a', 'n', 'g', 'e', '_', 'S', 'u', 'b',
      't', 'e', 'r', 'm', '_', 'P', 'r', 'o', 'c']
    (catch_errora (sct_subterm_proc ia graphs dpp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 't', 'h',
                     'e', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g',
                     'e', ' ', '(', 's', 'u', 'b', 't', 'e', 'r', 'm', ')', ' ',
                     'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'o', 'n',
                     ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b',
                     'l', 'e', 'm'] .
                   shows_nl .
                     shows_dpp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) ia dpp .
                       shows_nl . x)));
check_dp_termination_proof_main j ia assms i dpp
  (Size_Change_Redpair_Proc redp u_opt graphs) =
  debug (i [])
    ['S', 'i', 'z', 'e', '_', 'C', 'h', 'a', 'n', 'g', 'e', '_', 'R', 'e', 'd',
      'p', 'a', 'i', 'r', '_', 'P', 'r', 'o', 'c']
    (catch_errora (sct_ur_af_proc ia (get_redtriple redp) graphs u_opt dpp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 't', 'h',
                     'e', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g',
                     'e', ' ', '(', 'r', 'e', 'd', 'p', 'a', 'i', 'r', ')', ' ',
                     'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'o', 'n',
                     ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b',
                     'l', 'e', 'm'] .
                   shows_nl .
                     shows_dpp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) ia dpp .
                       shows_nl . x)));
check_dp_termination_proof_main j ia assms i dpp (Fcc_Proc f fcs pb r prf) =
  debug (i []) ['F', 'c', 'c', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (fcc_proc ia f fcs pb r dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'f', 'l', 'a', 't', ' ', 'c', 'o',
                       'n', 't', 'e', 'x', 't', ' ', 'c', 'l', 'o', 's', 'u',
                       'r', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                       ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'f', 'l', 'a', 't',
                         ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', ' ', 'c', 'l',
                         'o', 's', 'u', 'r', 'e', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Split_Proc prem rrem prf1 prf2) =
  debug (i []) ['S', 'p', 'l', 'i', 't', '_', 'P', 'r', 'o', 'c']
    (case get_fcc_option prf1 of {
      Nothing ->
        let {
          (dpp1, dpp2) = split_proc ia dpp prem rrem;
        } in bindb (catch_errora
                     (check_dp_termination_proof_main j ia assms
                       (i . shows_string ['.', '1']) dpp1 prf1)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                    'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                    's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o',
                                    'c', 'e', 's', 's', 'o', 'r'] .
                                  shows_nl . indent x)))
               (\ _ ->
                 catch_errora
                   (check_dp_termination_proof_main j ia assms
                     (i . shows_string ['.', '2']) dpp2 prf2)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                  's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o',
                                  'c', 'e', 's', 's', 'o', 'r'] .
                                shows_nl . indent x)));
      Just (f, (fcs, (pb, (rb, prf1a)))) ->
        debug (i [])
          ['S', 'p', 'l', 'i', 't', '_', 'P', 'r', 'o', 'c', 'F', 'c', 'c']
          (bindb (fcc_split_proc ia f fcs pb rb prem rrem dpp)
            (\ (dpp1, dpp2) ->
              bindb (catch_errora
                      (check_dp_termination_proof_main j ia assms
                        (i . shows_string ['.', '1', '.', '1']) dpp1 prf1a)
                      (\ x ->
                        Inl (i . shows_string
                                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                     'e', 'l', 'o', 'w', ' ', 't', 'h', 'e',
                                     ' ', 's', 'p', 'l', 'i', 't', ' ', 'a',
                                     'n', 'd', ' ', 'f', 'c', 'c', ' ', 'p',
                                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                                   shows_nl . indent x)))
                (\ _ ->
                  catch_errora
                    (check_dp_termination_proof_main j ia assms
                      (i . shows_string ['.', '2']) dpp2 prf2)
                    (\ x ->
                      Inl (i . shows_string
                                 [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                   'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                   's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o',
                                   'c', 'e', 's', 's', 'o', 'r'] .
                                 shows_nl . indent x)))));
    });
check_dp_termination_proof_main j ia assms i dpp (Semlab_Proc sli lP lQ lR prf)
  = debug (i []) ['S', 'e', 'm', 'l', 'a', 'b', '_', 'P', 'r', 'o', 'c']
      (bindb
        (catch_errora (semlab_fin_proc ia sli lP lQ lR dpp)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         't', 'h', 'e', ' ', 's', 'e', 'm', 'l', 'a', 'b', ' ',
                         'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'o',
                         'n', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r',
                         'o', 'b', 'l', 'e', 'm'] .
                       shows_nl .
                         shows_dpp (shows_prec_lab zero_nat)
                           (shows_prec_list zero_nat) ia dpp .
                           shows_nl . x)))
        (\ dppa ->
          catch_errora
            (check_dp_termination_proof_main j ia assms
              (i . shows_string ['.', '1']) dppa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'e', 'm',
                           'l', 'a', 'b', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                           's', 'o', 'r'] .
                         shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Switch_Innermost_Proc joins prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', '_', 'I', 'n', 'n', 'e', 'r', 'm', 'o', 's',
      't', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (switch_innermost_proc ia joins dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c',
                       'h', ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                       'o', 's', 't', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ',
                       'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'w', 'i', 't',
                         'c', 'h', ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r',
                         'm', 'o', 's', 't', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                         's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dppa (Assume_Finite dpp ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora (check_dpp_subsumes ia dpp dppa)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n',
                                  'e', 's', 's', ' ', 'a', 's', 's', 'u', 'm',
                                  'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ',
                                  'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                                  'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assma j ia
                         (check_trs_termination_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_dp_termination_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_fptrs_termination_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_unknown_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's',
                        ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
                        ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n',
                        ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));
check_dp_termination_proof_main j ia assms i dpp
  (Rewriting_Proc u_opt stb sta st lr p prf) =
  debug (i [])
    ['R', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (rewriting_proc ia u_opt stb sta st lr p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r', ' ', 't', 'o', ' ', 'r', 'e', 'w', 'r', 'i', 't',
                       'e', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', ' '] .
                     shows_nl .
                       shows_rule (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] stb .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                               'i', 'r', ' '] .
                             shows_nl .
                               shows_rule (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                                 st .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Narrowing_Proc st p sts prf) =
  debug (i [])
    ['N', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (narrowing_proc ia st p sts dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'n', 'a', 'r', 'r', 'o', 'w', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r', ' ', 't', 'o', ' ', 'n', 'a', 'r', 'r', 'o', 'w',
                       ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', ' '] .
                     shows_nl .
                       shows_rule (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] st .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                               'i', 'r', 's', ' '] .
                             shows_nl .
                               shows_trs (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat)
                                 ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                   'y', 's', 't', 'e', 'm', ':']
                                 [' ', '-', '>', ' '] sts .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'n', 'a', 'r', 'r',
                         'o', 'w', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Instantiation_Proc st sts prf)
  = debug (i [])
      ['I', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n', '_',
        'P', 'r', 'o', 'c']
      (bindb
        (catch_errora (instantiation_proc ia st sts dpp)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         't', 'h', 'e', ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                         'i', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c',
                         'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ', 'i', 'n',
                         's', 't', 'a', 'n', 't', 'i', 'a', 't', 'e', ' ', 't',
                         'h', 'e', ' ', 'p', 'a', 'i', 'r', ' '] .
                       shows_nl .
                         shows_rule (shows_prec_lab zero_nat)
                           (shows_prec_list zero_nat) [' ', '-', '>', ' '] st .
                           shows_nl .
                             shows_string
                               [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p',
                                 'a', 'i', 'r', 's', ' '] .
                               shows_nl .
                                 shows_trs (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat)
                                   ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                     'y', 's', 't', 'e', 'm', ':']
                                   [' ', '-', '>', ' '] sts .
                                   shows_nl . x)))
        (\ dppa ->
          catch_errora
            (check_dp_termination_proof_main j ia assms
              (i . shows_string ['.', '1']) dppa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 't', 'h', 'e', ' ', 'i', 'n', 's',
                           't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                           ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                         shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Forward_Instantiation_Proc st sts u_opt prf) =
  debug (i [])
    ['F', 'o', 'r', 'w', 'a', 'r', 'd', '_', 'I', 'n', 's', 't', 'a', 'n', 't',
      'i', 'a', 't', 'i', 'o', 'n', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (forward_instantiation_proc ia st sts u_opt dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'f', 'o', 'r', 'w', 'a', 'r', 'd',
                       '_', 'i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't',
                       'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 't', 'o', ' ', 'i', 'n', 's', 't', 'a',
                       'n', 't', 'i', 'a', 't', 'e', ' ', 't', 'h', 'e', ' ',
                       'p', 'a', 'i', 'r', ' '] .
                     shows_nl .
                       shows_rule (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] st .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                               'i', 'r', 's', ' '] .
                             shows_nl .
                               shows_trs (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat)
                                 ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                   'y', 's', 't', 'e', 'm', ':']
                                 [' ', '-', '>', ' '] sts .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'r', 'w',
                         'a', 'r', 'd', ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                         'i', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c',
                         'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Unlab_Proc p r prf) =
  debug (i []) ['U', 'n', 'l', 'a', 'b', '_', 'P', 'r', 'o', 'c']
    (Inl (shows_prec_list zero_nat
           ['u', 'n', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ' ', 'p', 'r',
             'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'n', 'o', 't', ' ', 's',
             'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']));
check_dp_termination_proof_main j ia assms i dpp
  (General_Redpair_Proc rp ps pb prof prfs) =
  debug (i [])
    ['G', 'e', 'n', 'e', 'r', 'a', 'l', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r',
      '_', 'P', 'r', 'o', 'c', 'P', 'r', 'o', 'c']
    (let {
       n = size_list prfs;
     } in bindb (check (less_nat zero_nat n)
                  (shows_prec_list zero_nat
                    ['a', 't', ' ', 'l', 'e', 'a', 's', 't', ' ', 'o', 'n', 'e',
                      ' ', 's', 'u', 'b', 'p', 'r', 'o', 'o', 'f', ' ', 'i',
                      's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
            (\ _ ->
              let {
                merge = equal_nat n one_nat;
              } in bindb (catch_errora
                           (conditional_general_reduction_pair_proc ia
                             (get_non_inf_order rp) ps pb prof merge dpp)
                           (\ x ->
                             Inl (i . shows_string
[':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'a', 'p', 'p',
  'l', 'y', 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r',
  'i', 'c', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
  'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 't', 'o',
  ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
shows_nl .
  shows_dpp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) ia dpp .
    shows_nl . x)))
                     (\ dpps ->
                       bindb (catch_errora
                               (check_dp_termination_proof_main j ia assms
                                 (i . shows_string ['.', '1'])
                                 (nth dpps zero_nat) (nth prfs zero_nat))
                               (\ x ->
                                 Inl (i . shows_string
    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l', 'o', 'w', ' ', 't',
      'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r', 'i', 'c', ' ', 'r', 'e', 'd', 'u',
      'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c',
      'e', 's', 's', 'o', 'r'] .
    shows_nl . indent x)))
                         (\ _ ->
                           (if merge then Inr ()
                             else catch_errora
                                    (check_dp_termination_proof_main j ia assms
                                      (i . shows_string ['.', '2'])
                                      (nth dpps one_nat) (nth prfs one_nat))
                                    (\ x ->
                                      Inl
(i . shows_string
       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l', 'o', 'w', ' ',
         't', 'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r', 'i', 'c', ' ', 'r', 'e',
         'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
       shows_nl . indent x)))))));
check_dp_termination_proof_main j ia assms i dpp
  (Complex_Constant_Removal_Proc p prf) =
  debug (i [])
    ['C', 'o', 'm', 'p', 'l', 'e', 'x', '_', 'C', 'o', 'n', 's', 't', 'a', 'n',
      't', '_', 'R', 'e', 'm', 'o', 'v', 'a', 'l', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (complex_constant_removal_proc ia p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x',
                       ' ', 'c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'r',
                       'e', 'm', 'o', 'v', 'a', 'l', ' ', 'p', 'r', 'o', 'c',
                       'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ', 't', 'h',
                       'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e',
                       'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'm', 'p',
                         'l', 'e', 'x', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n',
                         't', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'p',
                         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (To_Trs_Proc prf) =
  debug (i []) ['T', 'o', '_', 'T', 'r', 's', '_', 'P', 'r', 'o', 'c']
    (catch_errora
      (check_trs_termination_proof_main j ia assms (i . shows_string ['.', '1'])
        (mk_tp j
          (nfsc ia dpp,
            (qc ia dpp, (pb ia dpp ++ rd ia dpp, pwb ia dpp ++ rwd ia dpp))))
        prf)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l', 'o',
                     'w', ' ', 't', 'h', 'e', ' ', 'T', 'o', '-', 'T', 'r', 's',
                     ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                   shows_nl . indent x)));

check_unknown_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Unknown_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_proof_main j ia assms i tpa (Assume_Unknown tp ass) =
  debug (i []) ['U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora
                   (check (tpa == tp)
                     (shows_prec_list zero_nat
                        ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o',
                          'b', 'l', 'e', 'm', 's', ' ', 'a', 'r', 'e', ' ', 'n',
                          'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i', 'c', 'a',
                          'l', ':', ' '] .
                       shows_nl .
                         shows_prec_list zero_nat tpa .
                           shows_nl .
                             shows_prec_list zero_nat [' ', 'v', 's', ' '] .
                               shows_nl . shows_prec_list zero_nat tp))
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a',
                                  't', 'i', 'o', 'n', ' ', 'a', 's', 's', 'u',
                                  'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r',
                                  ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ',
                                  'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                        'r', 'o', 'o', 'f'] .
                      shows_nl));

map_assm_proof ::
  forall a b c d e f g.
    (a -> a) ->
      (b -> b) ->
        (c -> c) ->
          (d -> d) ->
            Generic_assm_proof e f g a b c () d ->
              Generic_assm_proof e f g a b c () d;
map_assm_proof tp dpp fptp unk (SN_assm_proof r p) = SN_assm_proof r (tp p);
map_assm_proof tp dpp fptp unk (Finite_assm_proof d p) =
  Finite_assm_proof d (dpp p);
map_assm_proof tp dpp fptp unk (SN_FP_assm_proof r p) =
  SN_FP_assm_proof r (fptp p);
map_assm_proof tp dpp fptp unk (Unknown_assm_proof u p) =
  Unknown_assm_proof u (unk p);
map_assm_proof tp dpp fptp unk (Not_SN_assm_proof v va) =
  Not_SN_assm_proof v va;
map_assm_proof tp dpp fptp unk (Infinite_assm_proof v va) =
  Infinite_assm_proof v va;
map_assm_proof tp dpp fptp unk (Not_RelSN_assm_proof v va) =
  Not_RelSN_assm_proof v va;
map_assm_proof tp dpp fptp unk (Not_SN_FP_assm_proof v va) =
  Not_SN_FP_assm_proof v va;
map_assm_proof tp dpp fptp unk (Complexity_assm_proof v va) =
  Complexity_assm_proof v va;

no_decr ::
  forall a b c.
    (Eq a, Eq b,
      Eq c) => [(Term (Lab a b) c, Term (Lab a b) c)] ->
                 [(Term (Lab a b) c, Term (Lab a b) c)];
no_decr =
  filter
    (\ (l, r) ->
      not (not (equal_term l r) &&
            equal_term (map_term unlab (\ x -> x) l)
              (map_term unlab (\ x -> x) r)));

unlab_of_trs ::
  forall a b c.
    (Eq a, Eq b,
      Eq c) => [(Term (Lab a b) c, Term (Lab a b) c)] ->
                 [(Term (Lab a b) c, Term (Lab a b) c)];
unlab_of_trs r = map (map_funs_rule unlab) (no_decr r);

updatec :: forall a b c. (a -> b) -> (a, c) -> (b, c);
updatec p_to_p (p, info) = (p_to_p p, info);

unlab_to_split_trs ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Trs_termination_proof a b c -> Trs_termination_proof a b c;
unlab_to_split_trs (DP_Trans a1 a2 a3 p) =
  DP_Trans a1 a2 a3 (fst (unlab_to_split_dp p));
unlab_to_split_trs (Rule_Removal a1 a2 p) =
  Rule_Removal a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (String_Reversal p) = String_Reversal (unlab_to_split_trs p);
unlab_to_split_trs (Constant_String a1 p) =
  Constant_String a1 (unlab_to_split_trs p);
unlab_to_split_trs (Bounds a) = Bounds a;
unlab_to_split_trs (Uncurry a1 a2 p) = Uncurry a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (Semlab a1 a2 a3 p) = Semlab a1 a2 a3 (unlab_to_split_trs p);
unlab_to_split_trs R_is_Empty = R_is_Empty;
unlab_to_split_trs (Fcc a1 a2 p) = Fcc a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (Split a1 p q) =
  Split a1 (unlab_to_split_trs p) (unlab_to_split_trs q);
unlab_to_split_trs (Switch_Innermost a1 p) =
  Switch_Innermost a1 (unlab_to_split_trs p);
unlab_to_split_trs (Drop_Equality p) = Drop_Equality (unlab_to_split_trs p);
unlab_to_split_trs (Remove_Nonapplicable_Rules a1 p) =
  Remove_Nonapplicable_Rules a1 (unlab_to_split_trs p);
unlab_to_split_trs (Permuting_AFS a1 p) =
  Permuting_AFS a1 (unlab_to_split_trs p);
unlab_to_split_trs (Assume_SN a p) =
  Assume_SN a
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_unknown ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Unknown_proof a b c -> Unknown_proof a b c;
unlab_to_split_unknown (Assume_Unknown a1 p) =
  Assume_Unknown a1
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_otrs ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Fptrs_termination_proof a b c -> Fptrs_termination_proof a b c;
unlab_to_split_otrs (Assume_FP_SN a p) =
  Assume_FP_SN a
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_dp ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Dp_termination_proof a b c ->
                  (Dp_termination_proof a b c,
                    [([(Term (Lab a b) c, Term (Lab a b) c)],
                       ([(Term (Lab a b) c, Term (Lab a b) c)],
                         Dp_termination_proof a b c))]);
unlab_to_split_dp P_is_Empty = (P_is_Empty, []);
unlab_to_split_dp (Dep_Graph_Proc ps) =
  (Dep_Graph_Proc
     (map (\ (po, a) -> (map_option (fst . unlab_to_split_dp) po, a)) ps),
    []);
unlab_to_split_dp (Subterm_Criterion_Proc a1 a2 a3 p) =
  updatec (Subterm_Criterion_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Gen_Subterm_Criterion_Proc a1 a2 p) =
  updatec (Gen_Subterm_Criterion_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Redpair_Proc a1 a2 p) =
  updatec (Redpair_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Redpair_UR_Proc a1 a2 a3 p) =
  updatec (Redpair_UR_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Usable_Rules_Proc a1 p) =
  updatec (Usable_Rules_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Q_Reduction_Proc a1 p) =
  updatec (Q_Reduction_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_Redpair_Proc a1 a2 a3 p) =
  updatec (Mono_Redpair_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_URM_Redpair_Proc a1 a2 a3 p) =
  updatec (Mono_URM_Redpair_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_Redpair_UR_Proc a1 a2 a3 a4 p) =
  updatec (Mono_Redpair_UR_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Size_Change_Subterm_Proc a1) =
  (Size_Change_Subterm_Proc a1, []);
unlab_to_split_dp (Size_Change_Redpair_Proc a1 a2 a3) =
  (Size_Change_Redpair_Proc a1 a2 a3, []);
unlab_to_split_dp (Uncurry_Proc a1 a2 a3 a4 p) =
  updatec (Uncurry_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Fcc_Proc a1 a2 a3 a4 p) =
  updatec (Fcc_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Switch_Innermost_Proc a1 p) =
  updatec (Switch_Innermost_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Rewriting_Proc a1 a2 a3 a4 a5 a6 p) =
  updatec (Rewriting_Proc a1 a2 a3 a4 a5 a6) (unlab_to_split_dp p);
unlab_to_split_dp (Narrowing_Proc a1 a2 a3 p) =
  updatec (Narrowing_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Instantiation_Proc a1 a2 p) =
  updatec (Instantiation_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Forward_Instantiation_Proc a1 a2 a3 p) =
  updatec (Forward_Instantiation_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Assume_Finite d p) =
  (Assume_Finite d
     (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
            unlab_to_split_otrs unlab_to_split_unknown)
       p),
    []);
unlab_to_split_dp (To_Trs_Proc p) = (To_Trs_Proc (unlab_to_split_trs p), []);
unlab_to_split_dp (Unlab_Proc pa r p) = let {
  (pb, list) = unlab_to_split_dp p;
} in (P_is_Empty, (pa, (r, pb)) : list);
unlab_to_split_dp (Split_Proc a1 a2 p q) =
  (Split_Proc a1 a2 (fst (unlab_to_split_dp p)) (fst (unlab_to_split_dp q)),
    []);
unlab_to_split_dp (Semlab_Proc a1 lP a2 lR p) =
  let {
    (pa, list) = unlab_to_split_dp p;
    sl = Semlab_Proc a1 lP a2 lR pa;
  } in (case list of {
         [] -> (sl, list);
         (pb, (r, prof)) : lista -> let {
                                      ulP = unlab_of_trs lP;
                                      ulR = unlab_of_trs lR;
                                      pr = ceta_list_diff ulP pb;
                                      rr = ceta_list_diff ulR r;
                                    } in (Split_Proc pr rr sl prof, lista);
       });
unlab_to_split_dp (General_Redpair_Proc a1 a2 a3 a4 ps) =
  (General_Redpair_Proc a1 a2 a3 a4 ps, []);
unlab_to_split_dp (Complex_Constant_Removal_Proc a1 p) =
  updatec (Complex_Constant_Removal_Proc a1) (unlab_to_split_dp p);

check_trs_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_termination_proof ia j a i tp prf =
  check_trs_termination_proof_main ia j a i tp (unlab_to_split_trs prf);

rule_lab_repr_to_lab ::
  forall a b.
    (Key a,
      Key b) => [((Term a b, Term a b), Nat)] -> (Term a b, Term a b) -> Nat;
rule_lab_repr_to_lab ps = fun_of_map (ceta_map_of ps) zero_nat;

critical_peaks_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Bool,
                     ((Term a [Prelude.Char],
                        ((Term a [Prelude.Char], Term a [Prelude.Char]),
                          (Pos, ([Prelude.Char] -> Term a [Prelude.Char],
                                  (Bool, Term a [Prelude.Char]))))),
                       (Term a [Prelude.Char],
                         ((Term a [Prelude.Char], Term a [Prelude.Char]),
                           (Pos, ([Prelude.Char] -> Term a [Prelude.Char],
                                   (Bool, Term a [Prelude.Char])))))))];
critical_peaks_impl p r =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ pa ->
          let {
            c = ctxt_of_pos_term pa l;
            la = subt_at l pa;
            b = equal_ctxt c Hole;
          } in (if is_Var la then []
                 else concatMap
                        (\ (lb, rb) ->
                          (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                                  (\ a -> 'y' : a) la lb
                            of {
                            Nothing -> [];
                            Just (sigma, tau) ->
                              [(b, ((subst_apply_term l sigma,
                                      ((l, ra),
(Empty, (sigma, (True, subst_apply_term ra sigma))))),
                                     (subst_apply_term l sigma,
                                       ((lb, rb),
 (pa, (tau, (True,
              ctxt_apply_term (subst_apply_ctxt c sigma)
                (subst_apply_term rb tau))))))))];
                          }))
                        r))
        (poss_list l))
    p;

check_rstepsa ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), Term a b))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rstepsa r [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term zero_nat u . shows_nl);
check_rstepsa r ((p, (lr, t)) : rs) s u =
  bindb (check_rstep r p lr s t) (\ _ -> check_rstepsa r rs t u);

check_estep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Pos ->
                      (Term a b, Term a b) ->
                        Bool ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_estep e p rule l_to_r s t =
  bindb (check (membera e rule)
          (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] rule .
            shows_string
              ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'e', 'q', 'u',
                'a', 't', 'i', 'o', 'n', ' ', 'o', 'f'] .
              shows_nl .
                shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                  ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 's',
                    'y', 's', 't', 'e', 'm', ':']
                  [' ', '=', ' '] e .
                  shows_nl))
    (\ _ ->
      bindb (check (in_poss p s)
              (shows_prec_pos zero_nat p .
                shows_string
                  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
                    's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                  shows_prec_term zero_nat s . shows_nl))
        (\ _ ->
          bindb (check (in_poss p t)
                  (shows_prec_pos zero_nat p .
                    shows_string
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p',
                        'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                      shows_prec_term zero_nat t . shows_nl))
            (\ _ ->
              let {
                c = ctxt_of_pos_term p s;
                d = ctxt_of_pos_term p t;
                u = subt_at s p;
                v = subt_at t p;
                rrule = (if l_to_r then rule else (snd rule, fst rule));
                err = shows_string
                        ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                        shows_prec_term zero_nat t .
                          shows_string
                            [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                              'r', 'e', 's', 'u', 'l', 't', ' ', 'f', 'r', 'o',
                              'm', ' ', 'a', ' ', 'p', 'r', 'o', 'p', 'e', 'r',
                              ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                              'o', 'n', ' ', 'o', 'f', ' ', 't', 'e', 'r', 'm',
                              ' '] .
                            shows_prec_term zero_nat s .
                              shows_string
                                [' ', 'u', 's', 'i', 'n', 'g', ' ', 'e', 'q',
                                  'u', 'a', 't', 'i', 'o', 'n', ' '] .
                                shows_nl .
                                  shows_rule (shows_prec zero_nat)
                                    (shows_prec zero_nat) [' ', '=', ' ']
                                    rrule .
                                    shows_string
                                      [' ', 'a', 't', ' ', 'p', 'o', 's', 'i',
't', 'i', 'o', 'n', ' '] .
                                      shows_prec_pos zero_nat p . shows_nl;
              } in (case match_list Var [(fst rrule, u), (snd rrule, v)] of {
                     Nothing -> Inl err;
                     Just _ -> check (equal_ctxt c d) err;
                   }))));

check_conversion ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conversion e [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's',
         'i', 'o', 'n', ' '] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term zero_nat u . shows_nl);
check_conversion e ((p, (r, (l_to_r, t))) : c) s u =
  bindb (check_estep e p r l_to_r s t) (\ _ -> check_conversion e c t u);

check_ELD_1_nat ::
  Nat ->
    Nat -> [Nat] -> [Nat] -> [Nat] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3 =
  bindb (catch_errora
          (forallM
            (\ x ->
              check (less_nat x beta)
                (shows_prec_list zero_nat
                   ['t', 'h', 'e', ' ', 'l', 'a', 'b', 'e', 'l', 's', ' ', 'a',
                     'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'e', 'c', 'r', 'e',
                     'a', 's', 'i', 'n', 'g', ':', ' '] .
                  shows_prec_nat zero_nat x .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'm', 'a',
                        'l', 'l', 'e', 'r', ' '] .
                      shows_prec_nat zero_nat beta . shows_nl))
            sigma_1)
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ x ->
                  check (less_eq_nat x alpha)
                    (shows_prec_list zero_nat
                       ['t', 'h', 'e', ' ', 'l', 'a', 'b', 'e', 'l', 's', ' ',
                         'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'e', 'c',
                         'r', 'e', 'a', 's', 'i', 'n', 'g', ':', ' '] .
                      shows_prec_nat zero_nat x .
                        shows_prec_list zero_nat
                          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'm',
                            'a', 'l', 'l', 'e', 'r', ' ', 'e', 'q', 'u', 'a',
                            'l', ' '] .
                          shows_prec_nat zero_nat alpha . shows_nl))
                sigma_2)
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (check (less_eq_nat (size_list sigma_2) one_nat)
                  (shows_prec_list zero_nat
                     [' ', ' ', 't', 'h', 'e', ' ', 'l', 'e', 'n', 'g', 't',
                       'h', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'm', 'i',
                       'd', 'd', 'l', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n',
                       'c', 'e', ' ', 'i', 's', ' ', 'g', 'r', 'e', 'a', 't',
                       'e', 'r', ' ', '1'] .
                    shows_nl))
            (\ _ ->
              catch_errora
                (forallM
                  (\ x ->
                    check (less_nat x alpha || less_nat x beta)
                      (shows_prec_list zero_nat
                         ['t', 'h', 'e', ' ', 'l', 'a', 'b', 'e', 'l', 's', ' ',
                           'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'e',
                           'c', 'r', 'e', 'a', 's', 'i', 'n', 'g', ':', ' '] .
                        shows_prec_nat zero_nat x .
                          shows_prec_list zero_nat
                            [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'm',
                              'a', 'l', 'l', 'e', 'r', ' '] .
                            shows_prec_nat zero_nat alpha .
                              shows_prec_list zero_nat
                                [' ', 'o', 'r', ' ', 's', 'm', 'a', 'l', 'l',
                                  'e', 'r', ' '] .
                                shows_prec_nat zero_nat beta . shows_nl))
                  sigma_3)
                (\ x -> Inl (snd x)))));

rule_labeling ::
  forall a b.
    ((Term a b, Term a b) -> Nat) ->
      (Term a b,
        ((Term a b, Term a b), (Pos, (b -> Term a b, (Bool, Term a b))))) ->
        Nat;
rule_labeling i (s, (rl, (p, (sigma, t)))) = i rl;

eseq_to_step_list ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b ->
                           [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                             [(Term a b,
                                ((Term a b, Term a b),
                                  (Pos, (b -> Term a b, (Bool, Term a b)))))];
eseq_to_step_list s [] = [];
eseq_to_step_list s ((p, (lr, (b, t))) : steps) =
  let {
    u = subt_at s p;
    v = subt_at t p;
  } in (if b then let {
                    sigma =
                      let {
                        (Just tau) = match_list Var [(fst lr, u), (snd lr, v)];
                      } in tau;
                  } in (s, (lr, (p, (sigma, (b, t))))) :
                         eseq_to_step_list t steps
         else let {
                sigma =
                  let {
                    (Just tau) = match_list Var [(snd lr, u), (fst lr, v)];
                  } in tau;
              } in (t, (lr, (p, (sigma, (b, s))))) : eseq_to_step_list t steps);

eseq_to_ddconv ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b,
                           [(Pos, ((Term a b, Term a b), (Bool, Term a b)))]) ->
                           (Term a b,
                             [(Term a b,
                                ((Term a b, Term a b),
                                  (Pos, (b -> Term a b, (Bool, Term a b)))))]);
eseq_to_ddconv (s, eseq) = (s, eseq_to_step_list s eseq);

cpeak_instance ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b ->
                           (Term a b, Term a b) ->
                             Term a b -> (Term a b, Term a b) -> Bool;
cpeak_instance sa cpa s cp =
  not (is_none
        (match_list (\ _ -> sa)
          [(sa, s), (fst cpa, fst cp), (snd cpa, snd cp)]));

rseq_to_step_list ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b ->
                           [(Pos, ((Term a b, Term a b), Term a b))] ->
                             [(Term a b,
                                ((Term a b, Term a b),
                                  (Pos, (b -> Term a b, (Bool, Term a b)))))];
rseq_to_step_list s [] = [];
rseq_to_step_list s ((p, (lr, t)) : steps) =
  let {
    u = subt_at s p;
    v = subt_at t p;
    sigma = let {
              (Just tau) = match_list Var [(fst lr, u), (snd lr, v)];
            } in tau;
  } in (s, (lr, (p, (sigma, (True, t))))) : rseq_to_step_list t steps;

rseq_to_ddseq ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b,
                           [(Pos, ((Term a b, Term a b), Term a b))]) ->
                           (Term a b,
                             [(Term a b,
                                ((Term a b, Term a b),
                                  (Pos, (b -> Term a b, (Bool, Term a b)))))]);
rseq_to_ddseq (s, rseq) = (s, rseq_to_step_list s rseq);

get_source ::
  forall a b.
    (Term a b,
      ((Term a b, Term a b), (Pos, (b -> Term a b, (Bool, Term a b))))) ->
      Term a b;
get_source s = fst s;

eseq_last ::
  forall a b.
    Term a b -> [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] -> Term a b;
eseq_last s steps = last (s : map (\ (_, (_, (_, sa))) -> sa) steps);

check_cpeak_eldc ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b,
                       ((Term a b, Term a b),
                         (Pos, (b -> Term a b, (Bool, Term a b))))),
                      (Term a b,
                        ((Term a b, Term a b),
                          (Pos, (b -> Term a b, (Bool, Term a b)))))) ->
                      Term a b ->
                        (Term a b, Term a b) ->
                          [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                            [(Pos, ((Term a b, Term a b), Term a b))] ->
                              [(Pos, ((Term a b, Term a b),
                                       (Bool, Term a b)))] ->
                                [(Pos, ((Term a b, Term a b),
 (Bool, Term a b)))] ->
                                  [(Pos, ((Term a b, Term a b), Term a b))] ->
                                    [(Pos, ((Term a b, Term a b),
     (Bool, Term a b)))] ->
                                      ((Term a b, Term a b) -> Nat) ->
Maybe Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cpeak_eldc r p s cp cl_1 sl cl_2 cr_1 sr cr_2 lab n =
  let {
    ((s1, (r1, (_, (_, (True, t1))))), (_, (r2, (_, (_, (True, t2)))))) = p;
  } in bindb (check (cpeak_instance s cp s1 (t1, t2)) id)
         (\ _ ->
           let {
             u_1 = eseq_last (fst cp) cl_1;
             v_1 = eseq_last (snd cp) cr_1;
             u_2 = rseq_last u_1 sl;
             v_2 = rseq_last v_1 sr;
             u_3 = eseq_last u_2 cl_2;
             v_3 = eseq_last v_2 cr_2;
           } in bindb (check_conversion r cl_1 (fst cp) u_1)
                  (\ _ ->
                    bindb (check_rstepsa r sl u_1 u_2)
                      (\ _ ->
                        bindb (check_conversion r cl_2 u_2 u_3)
                          (\ _ ->
                            bindb (check_conversion r cr_1 (snd cp) v_1)
                              (\ _ ->
                                bindb (check_rstepsa r sr v_1 v_2)
                                  (\ _ ->
                                    bindb (check_conversion r cr_2 v_2 v_3)
                                      (\ _ ->
bindb (check (equal_term u_3 v_3)
        (shows_prec_list zero_nat
           ['t', 'h', 'e', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o',
             'n', 's', ' ', 'e', 'n', 'd', ' ', 'i', 'n', ' ', 'd', 'i', 'f',
             'f', 'e', 'r', 'e', 'n', 't', ' ', 't', 'e', 'r', 'm', 's', ':',
             ' '] .
          shows_prec_term zero_nat u_3 .
            shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
              shows_prec_term zero_nat v_3 . shows_nl))
  (\ _ ->
    let {
      alpha = lab r1;
      beta = lab r2;
      cl_1a = snd (eseq_to_ddconv (fst cp, cl_1));
      sla = snd (rseq_to_ddseq (u_1, sl));
      cl_2a = snd (eseq_to_ddconv (u_2, cl_2));
      cr_1a = snd (eseq_to_ddconv (snd cp, cr_1));
      sra = snd (rseq_to_ddseq (v_1, sr));
      cr_2a = snd (eseq_to_ddconv (v_2, cr_2));
      tau_1 = map (rule_labeling lab) cl_1a;
      tau_2 = map (rule_labeling lab) sla;
      tau_3 = map (rule_labeling lab) cl_2a;
      sigma_1 = map (rule_labeling lab) cr_1a;
      sigma_2 = map (rule_labeling lab) sra;
      sigma_3 = map (rule_labeling lab) cr_2a;
    } in bindb (check_ELD_1_nat alpha beta tau_1 tau_2 tau_3)
           (\ _ ->
             bindb (check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3)
               (\ _ ->
                 (case n of {
                   Nothing -> Inr ();
                   Just na ->
                     let {
                       check_reachable =
                         (\ t ->
                           check (membera (reachable_terms r s na) t)
                             (shows_prec_list zero_nat
                                ['t', 'h', 'e', ' ', 'f', 'a', 'n', ' ', 'p',
                                  'r', 'o', 'p', 'e', 'r', 't', 'y', ' ', 'i',
                                  's', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'e',
                                  'd', ':', ' '] .
                               shows_prec_term zero_nat t .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'r',
                                     'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e',
                                     ' ', 'f', 'r', 'o', 'm', ' '] .
                                   shows_prec_term zero_nat s .
                                     shows_prec_list zero_nat
                                       [' ', 'i', 'n', ' '] .
                                       shows_prec_nat zero_nat na .
 shows_prec_list zero_nat [' ', 's', 't', 'e', 'p', 's'] . shows_nl));
                     } in bindb (catch_errora
                                  (forallM check_reachable
                                    (map get_source cl_1a))
                                  (\ x -> Inl (snd x)))
                            (\ _ ->
                              bindb (catch_errora
                                      (forallM check_reachable
(map get_source sla))
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  bindb (catch_errora
  (forallM check_reachable (map get_source cl_2a)) (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora (forallM check_reachable (map get_source cr_1a))
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (catch_errora (forallM check_reachable (map get_source sra))
          (\ x -> Inl (snd x)))
    (\ _ ->
      catch_errora (forallM check_reachable (map get_source cr_2a))
        (\ x -> Inl (snd x)))))));
                 })))))))))));

check_rule_labeling_eldc ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]), Nat)] ->
                      [(Term a [Prelude.Char],
                         (Term a [Prelude.Char],
                           ([(Pos, ((Term a [Prelude.Char],
                                      Term a [Prelude.Char]),
                                     (Bool, Term a [Prelude.Char])))],
                             ([(Pos, ((Term a [Prelude.Char],
Term a [Prelude.Char]),
                                       Term a [Prelude.Char]))],
                               ([(Pos, ((Term a [Prelude.Char],
  Term a [Prelude.Char]),
 (Bool, Term a [Prelude.Char])))],
                                 (Term a [Prelude.Char],
                                   ([(Pos, ((Term a [Prelude.Char],
      Term a [Prelude.Char]),
     (Bool, Term a [Prelude.Char])))],
                                     ([(Pos,
 ((Term a [Prelude.Char], Term a [Prelude.Char]), Term a [Prelude.Char]))],
                                       [(Pos,
  ((Term a [Prelude.Char], Term a [Prelude.Char]),
    (Bool, Term a [Prelude.Char])))]))))))))] ->
                        Maybe Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_labeling_eldc r lab cs n =
  let {
    cps = critical_peaks_impl r r;
    l = rule_lab_repr_to_lab lab;
    convs =
      cs ++ map (\ (s, (u, (cl_1, (sl, (cl_2, (v, (cr_1, (sr, cr_2)))))))) ->
                  (s, (v, (cr_1, (sr, (cr_2, (u, (cl_1, (sl, cl_2)))))))))
              cs;
  } in catch_errora
         (forallM
           (\ (_, a) ->
             let {
               (aa, b) = a;
             } in let {
                    (s1, (r1, (p1, (sigma_1, (_, t1))))) = aa;
                  } in (\ (s2, (r2, (p2, (sigma_2, (true, t2))))) ->
                         catch_errora
                           (check (equal_term t1 t2)
                             (shows_prec_list zero_nat
                               [' ', 'p', 'a', 'i', 'r', ' ', 'n', 'o', 'n',
                                 '-', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ']))
                           (\ _ ->
                             catch_errora
                               (existsM
                                 (\ (s, (u,
  (cl_1, (sl, (cl_2, (v, (cr_1, (sr, cr_2))))))))
                                   -> check_cpeak_eldc r
((s1, (r1, (p1, (sigma_1, (true, t1))))),
  (s2, (r2, (p2, (sigma_2, (true, t2))))))
s (u, v) cl_1 sl cl_2 cr_1 sr cr_2 l n)
                                 convs)
                               (\ x ->
                                 Inl (shows_nl .
                                       shows_prec_list zero_nat
 ['t', 'h', 'e', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'e',
   'a', 'k', ' '] .
 shows_prec_term zero_nat t1 .
   shows_prec_list zero_nat [' ', '<', '-', ' '] .
     shows_prec_term zero_nat s1 .
       shows_prec_list zero_nat [' ', '-', '>', ' '] .
         shows_prec_term zero_nat t2 .
           shows_prec_list zero_nat
             [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'b', 'e',
               ' ', 'j', 'o', 'i', 'n', 'e', 'd', ' ', 'd', 'e', 'c', 'r', 'e',
               'a', 's', 'i', 'n', 'g', 'l', 'y', ':'] .
             shows_nl . shows_sep id id x))))
                    b)
           cps)
         (\ x -> Inl (snd x));

split_seq :: Nat -> Nat -> [Nat] -> ([Nat], ([Nat], [Nat]));
split_seq alpha beta ss =
  let {
    (ssa, r) = span (\ n -> less_nat n alpha) ss;
  } in (case r of {
         [] -> (ssa, ([], []));
         h : t ->
           (if less_eq_nat h beta then (ssa, ([h], t)) else (ssa, ([], r)));
       });

check_cpeak_eld ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b,
                       ((Term a b, Term a b),
                         (Pos, (b -> Term a b, (Bool, Term a b))))),
                      (Term a b,
                        ((Term a b, Term a b),
                          (Pos, (b -> Term a b, (Bool, Term a b)))))) ->
                      (Term a b, Term a b) ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          [(Pos, ((Term a b, Term a b), Term a b))] ->
                            ((Term a b, Term a b) -> Nat) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cpeak_eld r p cp j1 j2 lab =
  let {
    ((_, (r1, (_, (_, (True, t1))))), (_, (r2, (_, (_, (True, t2)))))) = p;
  } in bindb (check (instance_rule (t1, t2) cp) id)
         (\ _ ->
           let {
             u = rseq_last (fst cp) j1;
             v = rseq_last (snd cp) j2;
           } in bindb (check_rstepsa r j1 (fst cp) u)
                  (\ _ ->
                    bindb (check_rstepsa r j2 (snd cp) v)
                      (\ _ ->
                        bindb (check (equal_term u v)
                                (shows_prec_list zero_nat
                                   ['t', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i',
                                     't', 'e', ' ', 's', 'e', 'q', 'u', 'e',
                                     'n', 'c', 'e', 's', ' ', 'e', 'n', 'd',
                                     ' ', 'i', 'n', ' ', 'd', 'i', 'f', 'f',
                                     'e', 'r', 'e', 'n', 't', ' ', 't', 'e',
                                     'r', 'm', 's', ':', ' '] .
                                  shows_prec_term zero_nat u .
                                    shows_prec_list zero_nat
                                      [' ', 'a', 'n', 'd', ' '] .
                                      shows_prec_term zero_nat v . shows_nl))
                          (\ _ ->
                            let {
                              alpha = lab r1;
                              beta = lab r2;
                              tau = map (rule_labeling lab)
                                      (snd (rseq_to_ddseq (t1, j1)));
                              sigma =
                                map (rule_labeling lab)
                                  (snd (rseq_to_ddseq (t2, j2)));
                              (tau_1, (tau_2, tau_3)) =
                                split_seq alpha beta tau;
                              (sigma_1, (sigma_2, sigma_3)) =
                                split_seq beta alpha sigma;
                            } in bindb (check_ELD_1_nat alpha beta tau_1 tau_2
 tau_3)
                                   (\ _ ->
                                     check_ELD_1_nat beta alpha sigma_1 sigma_2
                                       sigma_3)))));

check_rule_labeling_eld ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]), Nat)] ->
                      [(Term a [Prelude.Char],
                         ([(Pos, ((Term a [Prelude.Char],
                                    Term a [Prelude.Char]),
                                   Term a [Prelude.Char]))],
                           (Term a [Prelude.Char],
                             [(Pos, ((Term a [Prelude.Char],
                                       Term a [Prelude.Char]),
                                      Term a [Prelude.Char]))])))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_labeling_eld r lab js =
  let {
    cps = critical_peaks_impl r r;
    l = rule_lab_repr_to_lab lab;
    joins = js ++ map (\ (u, (j1, (v, j2))) -> (v, (j2, (u, j1)))) js;
  } in catch_errora
         (forallM
           (\ (_, a) ->
             let {
               (aa, b) = a;
             } in let {
                    (s1, (r1, (p1, (sigma_1, (_, t1))))) = aa;
                  } in (\ (s2, (r2, (p2, (sigma_2, (true, t2))))) ->
                         catch_errora
                           (check (equal_term t1 t2)
                             (shows_prec_list zero_nat
                               [' ', 'p', 'a', 'i', 'r', ' ', 'n', 'o', 'n',
                                 '-', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ']))
                           (\ _ ->
                             catch_errora
                               (existsM
                                 (\ (u, (j1, (v, j2))) ->
                                   check_cpeak_eld r
                                     ((s1, (r1, (p1, (sigma_1, (true, t1))))),
                                       (s2, (r2, (p2, (sigma_2, (true, t2))))))
                                     (u, v) j1 j2 l)
                                 joins)
                               (\ x ->
                                 Inl (shows_nl .
                                       shows_prec_list zero_nat
 ['t', 'h', 'e', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'e',
   'a', 'k', ' '] .
 shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
   [' ', '<', '-', ' ', '.', ' ', '-', '>', ' '] (t1, t2) .
   shows_prec_list zero_nat
     [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'j',
       'o', 'i', 'n', 'e', 'd', ' ', 'd', 'e', 'c', 'r', 'e', 'a', 's', 'i',
       'n', 'g', 'l', 'y', ':'] .
     shows_nl . shows_sep id id x))))
                    b)
           cps)
         (\ x -> Inl (snd x));

check_estepa ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Pos ->
                      (Term a b, Term a b) ->
                        Bool ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_estepa e p rule l_to_r s t =
  bindb (check (any (eq_rule_mod_vars rule) e)
          (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] rule .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'e', 'q',
                'u', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f'] .
              shows_nl .
                shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                  ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 's',
                    'y', 's', 't', 'e', 'm', ':']
                  [' ', '=', ' '] e .
                  shows_nl))
    (\ _ ->
      bindb (check (in_poss p s)
              (shows_prec_pos zero_nat p .
                shows_string
                  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
                    's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                  shows_prec_term zero_nat s . shows_nl))
        (\ _ ->
          bindb (check (in_poss p t)
                  (shows_prec_pos zero_nat p .
                    shows_string
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p',
                        'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                      shows_prec_term zero_nat t . shows_nl))
            (\ _ ->
              let {
                c = ctxt_of_pos_term p s;
                d = ctxt_of_pos_term p t;
                u = subt_at s p;
                v = subt_at t p;
                rrule = (if l_to_r then rule else (snd rule, fst rule));
                err = shows_string
                        ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                        shows_prec_term zero_nat t .
                          shows_string
                            [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                              'r', 'e', 's', 'u', 'l', 't', ' ', 'f', 'r', 'o',
                              'm', ' ', 'a', ' ', 'p', 'r', 'o', 'p', 'e', 'r',
                              ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                              'o', 'n', ' ', 'o', 'f', ' ', 't', 'e', 'r', 'm',
                              ' '] .
                            shows_prec_term zero_nat s .
                              shows_string
                                [' ', 'u', 's', 'i', 'n', 'g', ' ', 'e', 'q',
                                  'u', 'a', 't', 'i', 'o', 'n', ' '] .
                                shows_nl .
                                  shows_rule (shows_prec zero_nat)
                                    (shows_prec zero_nat) [' ', '=', ' ']
                                    rrule .
                                    shows_string
                                      [' ', 'a', 't', ' ', 'p', 'o', 's', 'i',
't', 'i', 'o', 'n', ' '] .
                                      shows_prec_pos zero_nat p . shows_nl;
              } in (case match_list Var [(fst rrule, u), (snd rrule, v)] of {
                     Nothing -> Inl err;
                     Just _ -> check (equal_ctxt c d) err;
                   }))));

check_conversiona ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conversiona e [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's',
         'i', 'o', 'n', ' '] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term zero_nat u . shows_nl);
check_conversiona e ((p, (r, (l_to_r, t))) : c) s u =
  bindb (check_estepa e p r l_to_r s t) (\ _ -> check_conversiona e c t u);

check_redundant_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Nat ->
                        [[(Pos, ((Term a b, Term a b), (Bool, Term a b)))]] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_redundant_rules ra r n convs =
  let {
    s = list_diff r ra;
    t = list_diff ra r;
  } in bindb (catch_errora
               (forallM
                 (\ (l, rb) ->
                   check (membera (reachable_terms ra l n) rb)
                     (shows_prec_list zero_nat
                        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 's',
                          'i', 'm', 'u', 'l', 'a', 't', 'e', ' ', 'r', 'u', 'l',
                          'e', ' '] .
                       shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                         [' ', '-', '>', ' '] (l, rb)))
                 s)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ (l, raa) ->
                 catch_errora
                   (existsM (\ conv -> check_conversiona r conv l raa) convs)
                   (\ _ -> check_join_BFS_limit n r l raa))
               t)
             (\ x -> Inl (snd x)));

check_cr_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            Cr_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cr_proof a ia i j r (SN_WCR joins_i prf) =
  debug (ia []) ['S', 'N', '_', 'W', 'C', 'R']
    (let {
       tp = mkc i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a
                    (ia . shows_string ['.', '1']) tp prf)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 's', 't', 'r', 'o',
                                  'n', 'g', ' ', 'n', 'o', 'r', 'm', 'a', 'l',
                                  'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', '+',
                                  ' ', 'w', 'c', 'r'] .
                                shows_nl . indent x)))
            (\ _ ->
              catch_errora
                (check_critical_pairs r (critical_pairs_impl r r) joins_i)
                (\ x ->
                  Inl (ia . shows_prec_list zero_nat
                              ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                                ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ',
                                'l', 'o', 'c', 'a', 'l', ' ', 'c', 'o', 'n',
                                'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'o',
                                'f', ' '] .
                              shows_tp (shows_prec_lab zero_nat)
                                (shows_prec_list zero_nat) i tp .
                                shows_nl . indent x))));
check_cr_proof a ia i j r Weakly_Orthogonal =
  debug (ia [])
    ['W', 'e', 'a', 'k', 'l', 'y', ' ', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
      'a', 'l']
    (catch_errora (check_weakly_orthogonal r)
      (\ x ->
        Inl (ia . shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                      'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'w', 'e', 'a',
                      'k', 'l', 'y', ' ', 'o', 'r', 't', 'h', 'o', 'g', 'o',
                      'n', 'a', 'l', 'i', 't', 'y', ' ', 'o', 'f', ' ', 't',
                      'h', 'e', ' '] .
                    shows_trs (shows_prec_lab zero_nat)
                      (shows_prec_list zero_nat)
                      ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                        't', 'e', 'm', ':']
                      [' ', '-', '>', ' '] r .
                      indent x)));
check_cr_proof a ia i j r (Strongly_Closed n) =
  debug (ia [])
    ['S', 't', 'r', 'o', 'n', 'g', 'l', 'y', ' ', 'C', 'l', 'o', 's', 'e', 'd']
    (catch_errora (check_strongly_closed r n)
      (\ x ->
        Inl (ia . shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                      'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 's', 't', 'r',
                      'o', 'n', 'g', ' ', 'c', 'l', 'o', 's', 'e', 'd', 'n',
                      'e', 's', 's', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e',
                      ' '] .
                    shows_trs (shows_prec_lab zero_nat)
                      (shows_prec_list zero_nat)
                      ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                        't', 'e', 'm', ':']
                      [' ', '-', '>', ' '] r .
                      indent x)));
check_cr_proof a ia i j r (Rule_Labeling rl joins prf) =
  debug (ia [])
    ['R', 'u', 'l', 'e', ' ', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
    (bindb
      (case prf of {
        Nothing -> check_linear_trs r;
        Just prfa ->
          bindb (check_left_linear_trs r)
            (\ _ ->
              let {
                (rnd, rd) = partition (\ lr -> linear_term (snd lr)) r;
                tp = mkc i False [] rd rnd;
              } in catch_errora
                     (check_trs_termination_proof i j a
                       (ia . shows_string ['.', '1']) tp prfa)
                     (\ x ->
                       Inl (ia . shows_string
                                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                     'e', 'l', 'o', 'w', ' ', 'r', 'e', 'l',
                                     'a', 't', 'i', 'v', 'e', ' ', 't', 'e',
                                     'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                                     'n', ' ', 'f', 'o', 'r', ' ', 'r', 'u',
                                     'l', 'e', ' ', 'l', 'a', 'b', 'e', 'l',
                                     'i', 'n', 'g'] .
                                   shows_nl . indent x)));
      })
      (\ _ ->
        catch_errora (check_rule_labeling_eld r rl joins)
          (\ x ->
            Inl (ia . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                          'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'd', 'e',
                          'c', 'r', 'e', 'a', 's', 'i', 'n', 'g', 'n', 'e', 's',
                          's', ' ', 'o', 'f', ' ', 'C', 'P', 's', ' ', 'u', 's',
                          'i', 'n', 'g', ' ', 'r', 'u', 'l', 'e', ' ', 'l', 'a',
                          'b', 'e', 'l', 'i', 'n', 'g', ' ', 'f', 'o', 'r', ' ',
                          't', 'h', 'e', ' '] .
                        shows_trs (shows_prec_lab zero_nat)
                          (shows_prec_list zero_nat)
                          ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                            's', 't', 'e', 'm', ':']
                          [' ', '-', '>', ' '] r .
                          indent x))));
check_cr_proof a ia i j r (Rule_Labeling_Conv rl convs nprf) =
  debug (ia [])
    ['R', 'u', 'l', 'e', ' ', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
    (case nprf of {
      Nothing ->
        bindb (check_linear_trs r)
          (\ _ ->
            catch_errora (check_rule_labeling_eldc r rl convs Nothing)
              (\ x ->
                Inl (ia . shows_prec_list zero_nat
                            [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n',
                              ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ',
                              'd', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n', 'g',
                              'n', 'e', 's', 's', ' ', 'o', 'f', ' ', 'C', 'P',
                              's', ' ', 'u', 's', 'i', 'n', 'g', ' ', 'r', 'u',
                              'l', 'e', ' ', 'l', 'a', 'b', 'e', 'l', 'i', 'n',
                              'g', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e',
                              ' '] .
                            shows_trs (shows_prec_lab zero_nat)
                              (shows_prec_list zero_nat)
                              ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                                's', 't', 'e', 'm', ':']
                              [' ', '-', '>', ' '] r .
                              indent x)));
      Just (n, prf) ->
        bindb (check_left_linear_trs r)
          (\ _ ->
            let {
              (rnd, rd) = partition (\ lr -> linear_term (snd lr)) r;
              tp = mkc i False [] rd rnd;
            } in bindb (catch_errora
                         (check_trs_termination_proof i j a
                           (ia . shows_string ['.', '1']) tp prf)
                         (\ x ->
                           Inl (ia . shows_string
                                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ',
 'b', 'e', 'l', 'o', 'w', ' ', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 't',
 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'r',
 'u', 'l', 'e', ' ', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g'] .
                                       shows_nl . indent x)))
                   (\ _ ->
                     catch_errora (check_rule_labeling_eldc r rl convs (Just n))
                       (\ x ->
                         Inl (ia . shows_prec_list zero_nat
                                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ',
                                       'i', 'n', ' ', 'c', 'h', 'e', 'c', 'k',
                                       'i', 'n', 'g', ' ', 'd', 'e', 'c', 'r',
                                       'e', 'a', 's', 'i', 'n', 'g', 'n', 'e',
                                       's', 's', ' ', 'o', 'f', ' ', 'C', 'P',
                                       's', ' ', 'u', 's', 'i', 'n', 'g', ' ',
                                       'r', 'u', 'l', 'e', ' ', 'l', 'a', 'b',
                                       'e', 'l', 'i', 'n', 'g', ' ', 'f', 'o',
                                       'r', ' ', 't', 'h', 'e', ' '] .
                                     shows_trs (shows_prec_lab zero_nat)
                                       (shows_prec_list zero_nat)
                                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
 's', 'y', 's', 't', 'e', 'm', ':']
                                       [' ', '-', '>', ' '] r .
                                       indent x))));
    });
check_cr_proof a ia i j r (Redundant_Rules rs n convs prf) =
  debug (ia [])
    ['R', 'e', 'd', 'u', 'n', 'd', 'a', 'n', 't', ' ', 'R', 'u', 'l', 'e', 's']
    (bindb
      (catch_errora (check_cr_proof a (ia . shows_string ['.', '1']) i j rs prf)
        (\ x ->
          Inl (ia . shows_prec_list zero_nat
                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                        'o', 'w', ' ', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n',
                        'c', 'e', ' ', 'o', 'f', ' ', 'm', 'o', 'd', 'i', 'f',
                        'i', 'e', 'd', ' ', 'T', 'R', 'S'] .
                      shows_nl .
                        shows_trs (shows_prec_lab zero_nat)
                          (shows_prec_list zero_nat)
                          ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                            's', 't', 'e', 'm', ':']
                          [' ', '-', '>', ' '] rs .
                          indent x)))
      (\ _ ->
        catch_errora (check_redundant_rules r rs n convs)
          (\ x ->
            Inl (ia . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                          'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'r', 'e',
                          'd', 'u', 'n', 'd', 'a', 'n', 't', ' ', 'r', 'u', 'l',
                          'e', 's', ' ', 't', 'r', 'a', 'n', 's', 'f', 'o', 'r',
                          'm', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 't',
                          'h', 'e', ' '] .
                        shows_trs (shows_prec_lab zero_nat)
                          (shows_prec_list zero_nat)
                          ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                            's', 't', 'e', 'm', ':']
                          [' ', '-', '>', ' '] r .
                          shows_prec_list zero_nat
                            ['t', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'e',
                              'd', ' ', 't', 'o', ' ', 't', 'h', 'e', ' '] .
                            shows_trs (shows_prec_lab zero_nat)
                              (shows_prec_list zero_nat)
                              ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                                's', 't', 'e', 'm', ':']
                              [' ', '-', '>', ' '] rs .
                              indent x))));
check_cr_proof a ia i j r (Parallel_Closed n) =
  debug (ia [])
    ['P', 'a', 'r', 'a', 'l', 'l', 'e', 'l', ' ', 'C', 'l', 'o', 's', 'e', 'd']
    (catch_errora (check_parallel_closed r n)
      (\ x ->
        Inl (ia . shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                      'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'p', 'a', 'r',
                      'a', 'l', 'l', 'e', 'l', ' ', 'c', 'l', 'o', 's', 'e',
                      'd', 'n', 'e', 's', 's', ' ', 'f', 'o', 'r', ' ', 't',
                      'h', 'e', ' '] .
                    shows_trs (shows_prec_lab zero_nat)
                      (shows_prec_list zero_nat)
                      ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                        't', 'e', 'm', ':']
                      [' ', '-', '>', ' '] r .
                      indent x)));
check_cr_proof a ia i j r (Critical_Pair_Closing_System c prf n) =
  debug (ia [])
    ['C', 'r', 'i', 't', 'i', 'c', 'a', 'l', '-', 'P', 'a', 'i', 'r', '-', 'C',
      'l', 'o', 's', 'i', 'n', 'g', ' ', 'S', 'y', 's', 't', 'e', 'm']
    (let {
       tp = mkc i False [] c [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a
                    (ia . shows_string ['.', '1']) tp prf)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 's', 't', 'r', 'o',
                                  'n', 'g', ' ', 'n', 'o', 'r', 'm', 'a', 'l',
                                  'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', 'o',
                                  'f', ' ', 'C', 'P', 'C', 'S'] .
                                shows_nl . indent x)))
            (\ _ ->
              catch_errora (check_critical_pair_closing r c n)
                (\ x ->
                  Inl (ia . shows_prec_list zero_nat
                              ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                                ' ', 'c', 'l', 'o', 's', 'i', 'n', 'g', ' ',
                                'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ',
                                'p', 'a', 'i', 'r', 's', ' ', 'o', 'f', ' '] .
                              shows_tp (shows_prec_lab zero_nat)
                                (shows_prec_list zero_nat) i tp .
                                shows_nl . indent x))));

edges_to_adj_fun :: forall a. (Eq a, Key a) => [(a, a)] -> a -> [a];
edges_to_adj_fun e =
  precompute_fun
    (\ a ->
      remdups (concatMap (\ ea -> (if fst ea == a then [snd ea] else [])) e))
    (remdups (map fst e ++ map snd e));

create_graph_impl ::
  forall a.
    (Eq a, Key a) => [(a, a)] -> Gen_g_impl_ext (a -> Bool) (a -> [a]) [a] ();
create_graph_impl e =
  Gen_g_impl_ext (membera (map fst e ++ map snd e)) (edges_to_adj_fun e)
    (remdups (map fst e ++ map snd e)) ();

as_singleton :: forall a b. (One b) => a -> (Array.Array a, b);
as_singleton x = (Array.Array [x], onea);

gi_V0 :: forall a b c d. Gen_g_impl_ext a b c d -> c;
gi_V0 (Gen_g_impl_ext gi_V gi_E gi_V0 more) = gi_V0;

as_is_empty :: forall a. (Array.Array a, Nat) -> Bool;
as_is_empty s = equal_nat (snd s) zero_nat;

rev_append :: forall a. [a] -> [a] -> [a];
rev_append [] ac = ac;
rev_append (x : xs) ac = rev_append xs (x : ac);

glist_delete_aux :: forall a. (a -> a -> Bool) -> a -> [a] -> [a] -> [a];
glist_delete_aux eq x [] asa = asa;
glist_delete_aux eq x (y : ys) asa =
  (if eq x y then rev_append asa ys else glist_delete_aux eq x ys (y : asa));

glist_delete :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
glist_delete eq x l = glist_delete_aux eq x l [];

select_edge_tr ::
  forall a.
    (Linorder a) => ((Array.Array a, Nat),
                      ((Array.Array Nat, Nat),
                        (Rbta a Int, (Array.Array (Nat, [a]), Nat)))) ->
                      (Maybe a,
                        ((Array.Array a, Nat),
                          ((Array.Array Nat, Nat),
                            (Rbta a Int, (Array.Array (Nat, [a]), Nat)))));
select_edge_tr s =
  let {
    (a, (aa, (ab, bb))) = s;
  } in (if as_is_empty bb then (Nothing, (a, (aa, (ab, bb))))
         else let {
                (ac, bc) = as_top bb;
              } in (if less_eq_nat
                         (as_get aa (minus_nat (as_length aa) one_nat)) ac
                     then let {
                            xa = gen_pick (\ x -> foldli (id x)) bc;
                            xb = glist_delete (comp2eq (dflt_cmp less_eq less))
                                   xa bc;
                            xc = (if is_Nil xb then as_pop bb
                                   else as_set bb
  (minus_nat (as_length bb) one_nat) (ac, xb));
                          } in (Just xa, (a, (aa, (ab, xc))))
                     else (Nothing, (a, (aa, (ab, bb))))));

as_empty :: forall a b. (Zero b) => () -> (Array.Array a, b);
as_empty uu = (Array.Array [], zerob);

stat_start :: () -> ();
stat_start = (\ _ -> ());

last_seg_tr ::
  forall a.
    (Linorder a) => ((Array.Array a, Nat),
                      ((Array.Array Nat, Nat),
                        (Rbta a Int, (Array.Array (Nat, [a]), Nat)))) ->
                      [a];
last_seg_tr s =
  let {
    (a, (aa, (_, _))) = s;
    (_, bc) =
      while (\ (xe, _) ->
              less_nat xe
                (if equal_nat
                      (plus_nat (minus_nat (as_length aa) one_nat) one_nat)
                      (as_length aa)
                  then as_length a
                  else as_get aa
                         (plus_nat (minus_nat (as_length aa) one_nat) one_nat)))
        (\ (ac, bc) -> let {
                         xa = as_get a ac;
                       } in (suc ac, xa : bc))
        (as_get aa (minus_nat (as_length aa) one_nat), []);
  } in bc;

collapse_tr ::
  forall a.
    (Linorder a) => a -> ((Array.Array a, Nat),
                           ((Array.Array Nat, Nat),
                             (Rbta a Int, (Array.Array (Nat, [a]), Nat)))) ->
                           ((Array.Array a, Nat),
                             ((Array.Array Nat, Nat),
                               (Rbta a Int, (Array.Array (Nat, [a]), Nat))));
collapse_tr v s = let {
                    (a, (aa, (ab, bb))) = s;
                    x = idx_of_tr v (a, (aa, (ab, bb)));
                    xa = as_take (plus_nat x one_nat) aa;
                  } in (a, (xa, (ab, bb)));

stat_stop :: () -> ();
stat_stop = (\ _ -> ());

compute_SCC_tr ::
  forall a b.
    (Compare_order a) => Gen_g_impl_ext (a -> Bool) (a -> [a]) [a] b -> [[a]];
compute_SCC_tr g =
  let {
    _ = stat_start ();
    xa = ([], Emptya);
    a = foldli (id (gi_V0 g)) (\ _ -> True)
          (\ xb (a, b) ->
            (if not (case rbt_lookup less b xb of {
                      Nothing -> False;
                      Just i ->
                        (if less_eq_int zero_int i then False else True);
                    })
              then let {
                     xc = (a, (as_singleton xb,
                                (as_singleton zero_nat,
                                  (rbt_insert xb (int_of_nat zero_nat) b,
                                    (if is_Nil (gi_E g xb) then as_empty ()
                                      else as_singleton
     (zero_nat, gi_E g xb))))));
                     (aa, (_, (_, (ad, _)))) =
                       while (\ (_, xh) ->
                               not (as_is_empty (let {
           (xi, (_, (_, _))) = xh;
         } in xi)))
                         (\ (aa, ba) ->
                           (case select_edge_tr ba of {
                             (Nothing, bb) -> let {
        xf = last_seg_tr bb;
        xg = pop_tr bb;
        xh = xf : aa;
      } in (xh, xg);
                             (Just xf, bb) ->
                               (if (case rbt_lookup less
   (let {
      (_, (_, (xn, _))) = bb;
    } in xn)
   xf
                                     of {
                                     Nothing -> False;
                                     Just i ->
                                       (if less_eq_int zero_int i then True
 else False);
                                   })
                                 then let {
ab = collapse_tr xf bb;
                                      } in (aa, ab)
                                 else (if not
    (case rbt_lookup less (let {
                             (_, (_, (xn, _))) = bb;
                           } in xn)
            xf
      of {
      Nothing -> False;
      Just i -> (if less_eq_int zero_int i then False else True);
    })
then (aa, push_code g xf bb) else (aa, bb)));
                           }))
                         xc;
                   } in (aa, ad)
              else (a, b)))
          xa;
    (aa, _) = a;
    _ = stat_stop ();
  } in aa;

scc_decomp ::
  forall a. (Ceq a, Ccompare a, Eq a, Key a, Set_impl a) => [(a, a)] -> [[a]];
scc_decomp e =
  let {
    ee = set e;
  } in filter (\ a -> (case a of {
                        [] -> True;
                        [v] -> member (v, v) ee;
                        _ : _ : _ -> True;
                      }))
         (compute_SCC_tr (create_graph_impl e));

check_acyclic ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => [(a, a)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_acyclic r =
  catch_errora
    (catch_errora
      (forallM
        (\ scc ->
          Inl ((shows_prec_list zero_nat ['S', 'C', 'C', ' '] .
                 shows_prec_list zero_nat scc) .
                shows_prec_list zero_nat
                  [' ', 'd', 'e', 't', 'e', 'c', 't', 'e', 'd', ' ']))
        (scc_decomp r))
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (((shows_prec_list zero_nat ['\n', 'g', 'r', 'a', 'p', 'h', ' '] .
              shows_prec_list zero_nat r) .
             shows_prec_list zero_nat
               [' ', 'n', 'o', 't', ' ', 'a', 'c', 'y', 'c', 'l', 'i', 'c',
                 '\n']) .
            x));

get_conjunctions :: forall a. Formula a -> [Formula a];
get_conjunctions (Conjunction phis) = concatMap get_conjunctions phis;
get_conjunctions (Atom v) = [Atom v];
get_conjunctions (NegAtom v) = [NegAtom v];
get_conjunctions (Disjunction v) = [Disjunction v];

get_disjunctions :: forall a. Formula a -> [Formula a];
get_disjunctions (Disjunction phis) = concatMap get_disjunctions phis;
get_disjunctions (Atom v) = [Atom v];
get_disjunctions (NegAtom v) = [NegAtom v];
get_disjunctions (Conjunction v) = [Conjunction v];

bool_types :: forall a b c d. Logic_ext a b c d -> Set b;
bool_types
  (Logic_ext type_of_fun values_of_type bool_types to_bool interpret more) =
  bool_types;

has_type ::
  forall a b c. (Eq b) => (a -> ([b], b)) -> Term a (c, b) -> b -> Bool;
has_type type_of_fun (Fun f es) ty =
  ty == snd (type_of_fun f) &&
    equal_nat (size_list es) (size_list (fst (type_of_fun f))) &&
      all_interval_nat
        (\ i -> has_type type_of_fun (nth es i) (nth (fst (type_of_fun f)) i))
        zero_nat (size_list es);
has_type type_of_fun (Var v) ty = snd v == ty;

type_of_fun :: forall a b c d. Logic_ext a b c d -> a -> ([b], b);
type_of_fun
  (Logic_ext type_of_fun values_of_type bool_types to_bool interpret more) =
  type_of_fun;

is_bool ::
  forall a b c d.
    (Ceq b, Ccompare b, Eq b) => Logic_ext a b c () -> Term a (d, b) -> Bool;
is_bool lambda e =
  bex (bool_types lambda) (has_type (type_of_fun lambda) e) && not (is_Var e);

pos_gctxt :: forall a b. (Compare a, Eq a, Compare b) => Gctxt a b -> Set Pos;
pos_gctxt GCHole = inserta Empty (set_empty (of_phantom set_impl_pos));
pos_gctxt (GCFun f cs) =
  sup_set (inserta Empty (set_empty (of_phantom set_impl_pos)))
    (sup_seta
      (image (\ (c, i) -> image (PCons i) (pos_gctxt c))
        (set (zip cs (upt zero_nat (size_list cs))))));

poly_const :: forall a b. (Zero a, Eq a) => a -> [([(b, Nat)], a)];
poly_const a = (if a == zerob then [] else [([], a)]);

apply_hint ::
  forall a. (Eq a) => [Int] -> [Poly_constraint a] -> [([(a, Nat)], Int)];
apply_hint (n : ns) (Poly_Ge a : asa) =
  poly_add (poly_mult (poly_const (abs_int n)) a) (apply_hint ns asa);
apply_hint (n : ns) (Poly_Eq a : asa) =
  poly_add (poly_mult (poly_const n) a) (apply_hint ns asa);
apply_hint [] (Poly_Ge a : asa) = poly_add a (apply_hint [] asa);
apply_hint [] (Poly_Eq a : asa) = poly_add a (apply_hint [] asa);
apply_hint uu [] = poly_const zero_int;

inline ::
  forall a b.
    (Eq b) => Nat ->
                ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                  ((Term a b, Term a b), [(Term a b, Term a b)]);
inline i rho =
  let {
    cs = snd rho;
    (s, t) = nth cs i;
    sigma = subst (the_Var t) s;
    csa = take i cs ++ drop (suc i) cs;
  } in ((fst (fst rho), subst_apply_term (snd (fst rho)) sigma),
         map (\ (sa, a) -> (subst_apply_term sa sigma, a)) csa);

invariant ::
  forall a b c d e f g. Art_node_impl a b c d e f g -> Formula (Term a (b, c));
invariant (Art_Node x1 x2 x3 x4) = x2;

location :: forall a b c d e f g. Art_node_impl a b c d e f g -> d;
location (Art_Node x1 x2 x3 x4) = x3;

initial_nodesa :: forall a b c d e f g h. Art_impl_ext a b c d e f g h -> [e];
initial_nodesa (Art_impl_ext initial_nodes nodes more) = initial_nodes;

name :: forall a b c d e f g. Art_node_impl a b c d e f g -> e;
name (Art_Node x1 x2 x3 x4) = x1;

edgea ::
  forall a b c d e f g. Art_node_impl a b c d e f g -> Art_edge_impl e f g;
edgea (Art_Node x1 x2 x3 x4) = x4;

nodesb ::
  forall a b c d e f g h.
    Art_impl_ext a b c d e f g h -> [Art_node_impl a b c d e f g];
nodesb (Art_impl_ext initial_nodes nodes more) = nodes;

art_edge_of ::
  forall a b c d e f g.
    (Ccompare e, Eq e, Mapping_impl e,
      Showa e) => Lts_impl a b c d e ->
                    Art_edge_impl f e g -> Art_edge a b c d f;
art_edge_of pi (Cover_Edge an uu) = Cover an;
art_edge_of pi (Children_Edge ans) =
  Children (map (\ (t, a) -> let {
                               (aa, _) = a;
                             } in (transition_of pi t, aa))
             ans);

art_nodes :: forall a b c d e f g. Art_impl_ext a b c d e f g () -> [e];
art_nodes ai = map name (nodesb ai);

art_of ::
  forall a b c d e f g.
    (Ccompare e, Eq e, Mapping_impl e, Showa e, Ccompare f, Eq f,
      Mapping_impl f,
      Showa f) => Lts_impl a b c d e ->
                    Art_impl_ext a b c d f e g () -> Art_ext a b c d f ();
art_of pi ai =
  let {
    ans = nodesb ai;
  } in Art_ext (initial_nodesa ai) (art_nodes ai)
         (map_of_total
           (\ a ->
             ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'l', 'o', 'o', 'k',
               'i', 'n', 'g', ' ', 'u', 'p', ' ', 'a', 'r', 't', ' ', 'e', 'd',
               'g', 'e', ' '] ++
               shows_prec zero_nat a [])
           (map (\ a -> (name a, art_edge_of pi (edgea a))) ans))
         (map_of_total
           (\ a ->
             ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'l', 'o', 'o', 'k',
               'i', 'n', 'g', ' ', 'u', 'p', ' ', 'n', 'o', 'd', 'e', ' ', 'l',
               'o', 'c', 'a', 't', 'i', 'o', 'n', ' '] ++
               shows_prec zero_nat a [])
           (map (\ a -> (name a, location a)) ans))
         (map_of_total
           (\ a ->
             ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'l', 'o', 'o', 'k',
               'i', 'n', 'g', ' ', 'u', 'p', ' ', 'n', 'o', 'd', 'e', ' ', 'i',
               'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', ' '] ++
               shows_prec zero_nat a [])
           (map (\ a -> (name a, invariant a)) ans))
         ();

exp_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) (Term Sig ([Prelude.Char], Ty));
exp_parser = exp_parsera variable_parser;

check_dp_loop ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> Dp_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_loop i dpp (DP_loop_prf s prseq sigma c) =
  let {
    p = pairsb i dpp;
    r = rulese i dpp;
    nfs = nfsc i dpp;
    q = qc i dpp;
  } in (if equal_ctxt c Hole
         then bindb (check (not (null prseq))
                      (shows_prec_list zero_nat
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'e', 'q',
                          'u', 'e', 'n', 'c', 'e', ' ', 'm', 'u', 's', 't', ' ',
                          'b', 'e', ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't',
                          'y']))
                (\ _ ->
                  (if null q
                    then check_qsteps (\ _ -> True) nfs p r prseq s
                           (subst_apply_term s (mk_subst Var sigma))
                    else check_qsteps_subst (check_NF_iteration sigma q) nfs p r
                           prseq s (subst_apply_term s (mk_subst Var sigma))))
         else check_loop q nfs s (map (\ (x, (y, (_, z))) -> (x, (y, z))) prseq)
                sigma c r);

check_rel_seq ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                        Term a b ->
                          Term a b ->
                            Bool -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_seq r sa [] s u True =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term zero_nat s .
          shows_string
            (shows_nl
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm']) .
            shows_nl . shows_prec_term zero_nat u . shows_nl);
check_rel_seq r sa [] s u False =
  Inl (shows_prec_list zero_nat
        ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 's',
          't', 'r', 'i', 'c', 't', ' ', 's', 't', 'e', 'p', ' ', 'i', 'n', ' ',
          'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n',
          'c', 'e']);
check_rel_seq ra sa ((p, (r, (True, t))) : prts) s u b =
  bindb (check_qrstep (\ _ -> True) False ra p r s t)
    (\ _ -> check_rel_seq ra sa prts t u True);
check_rel_seq ra sa ((p, (r, (False, t))) : prts) s u b =
  bindb (check_qrstep (\ _ -> True) False sa p r s t)
    (\ _ -> check_rel_seq ra sa prts t u b);

pat_dv_impl ::
  forall a b.
    (Eq a, Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) -> [b];
pat_dv_impl p =
  let {
    (_, (sigma, mu)) = p;
  } in remdups (map fst (mk_subst_domain sigma ++ mk_subst_domain mu));

shows_exp ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_exp (f, c) =
  shows_prec zero_nat f .
    shows_prec_list zero_nat ['n', '+', ' '] . shows_prec zero_nat c;

shows_p ::
  forall a b c d e.
    (Showa a, Showa b, Showa c, Showa d,
      Showa e) => (a, ((b, (c, d)), e)) -> [Prelude.Char] -> [Prelude.Char];
shows_p (b, ((f, (c, m)), a)) =
  shows_prec zero_nat b .
    shows_prec zero_nat m .
      shows_prec_list zero_nat [' ', '^', ' ', '('] .
        shows_exp (f, c) .
          shows_prec_list zero_nat [')'] . shows_prec zero_nat a;

set_option :: forall a. (Ceq a, Ccompare a, Set_impl a) => Maybe a -> Set a;
set_option Nothing = bot_set;
set_option (Just x2) = inserta x2 bot_set;

equal_complexity_class :: Complexity_class -> Complexity_class -> Bool;
equal_complexity_class (Comp_Poly x) (Comp_Poly ya) = equal_nat x ya;

default_nfs_nt_trs :: Bool;
default_nfs_nt_trs = False;

string_reversal_complete_rel_tt ::
  forall a b c d.
    (Showa b,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_complete_rel_tt i tp =
  bindb (check (q_emptyb i tp)
          (shows_prec_list zero_nat
            ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't',
              'y']))
    (\ _ ->
      bindb (check_unary_signature (rulesd i tp))
        (\ _ ->
          Inr (mkc i default_nfs_nt_trs [] (map rev_rule (rc i tp))
                (map rev_rule (rwc i tp)))));

check_to_srs_complete ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> [(b, b)] ->
                         [(Term b a, Term b a)] ->
                           [(Term b a, Term b a)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_to_srs_complete v old_new r s =
  let {
    mu = funas_trs_list r;
    (d, (da, nu)) = extract_components mu old_new;
  } in bindb (check_components mu (d, (da, nu)))
         (\ _ ->
           bindb (check_varcond_subset s)
             (\ _ ->
               catch_errora
                 (forallM
                   (\ slr ->
                     let {
                       y = choose_var v (fst slr);
                       stra = str d y;
                       to_slr = (\ (l, ra) -> (stra l, stra ra));
                     } in check (any (\ lr -> to_slr lr == slr) r)
                            (shows_prec_list zero_nat
                               ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                 ' ', 'f', 'i', 'n', 'd', ' ', 'o', 'r', 'i',
                                 'g', 'i', 'n', 'a', 'l', ' ', 'r', 'u', 'l',
                                 'e', ' ', 'f', 'o', 'r', ' '] .
                              shows_rule (shows_prec zero_nat)
                                (shows_prec zero_nat) [' ', '-', '>', ' '] slr))
                   s)
                 (\ x -> Inl (snd x))));

const_to_string_complete_tt ::
  forall a b c d.
    (Eq b, Showa b, Eq c,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Const_string_complete_proof b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
const_to_string_complete_tt i tp (Const_string_complete_proof v old_new s) =
  bindb (check (q_emptyb i tp)
          (shows_prec_list zero_nat
            ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't',
              'y']))
    (\ _ ->
      bindb (check_to_srs_complete v old_new (rulesd i tp) s)
        (\ _ -> Inr (mkc i False [] s [])));

check_NF_trs_subset ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [Term a b] -> Sum (Term a b) ();
check_NF_trs_subset r = check_NF_terms_subset (is_NF_trs r);

switch_termination_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_termination_proc i joins_i dpp =
  let {
    p = pairsb i dpp;
    r = rulese i dpp;
    q = qc i dpp;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list zero_nat
                                  ['r', 'u', 'l', 'e', 's', ' ', 'a', 'r', 'e',
                                    ' ', 'n', 'o', 't', ' ', 'o', 'v', 'e', 'r',
                                    'l', 'a', 'y']))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_wf_trs r)
                        (\ _ ->
                          bindb (check_critical_pairs r cp joins_i)
                            (\ _ ->
                              bindb (check (null (critical_pairs_impl p r))
                                      (shows_prec_list zero_nat
['t', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
  'p', 's', ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', 'P', ' ', 'a', 'n',
  'd', ' ', 'R']))
                                (\ _ ->
                                  catch_errora (check_NF_trs_subset r q)
                                    (\ x ->
                                      Inl
(shows_prec_term zero_nat x .
  shows_prec_list zero_nat
    [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm',
      'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ', 'w', '.', 'r', '.', 't', '.', ' ',
      'R']))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i (nfsc i dpp) False p [] [] [] r);
       });

check_instance ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_instance pa p =
  catch_errora
    (forallM
      (\ st ->
        check (any (instance_rule st) pa)
          (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] st .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'i', 'n',
                's', 't', 'a', 'n', 'c', 'e', ' ', 'o', 'f', ' ', 'a', 'n', 'y',
                ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 'p', 'a', 'i',
                'r']))
      p)
    (\ x -> Inl (snd x));

instantiation_complete_proc ::
  forall a b c d.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Instantiation_complete_proc_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
instantiation_complete_proc i dpp (Instantiation_complete_proc_prf p) =
  let {
    pa = pairsb i dpp;
    q = qc i dpp;
    r = rulese i dpp;
    nfs = nfsc i dpp;
  } in bindb (check (not nfs || null q)
               (shows_prec_list zero_nat
                 ['n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ',
                   's', 'u', 'b', 's', 't', '.', ' ', 'c', 'u', 'r', 'r', 'e',
                   'n', 't', 'l', 'y', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p',
                   'p', 'o', 'r', 't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'i',
                   'n', 'n', 'e', 'r', 'm', 'o', 's', 't']))
         (\ _ ->
           bindb (check_instance pa p)
             (\ _ -> Inr (mkd i nfs False p [] q [] r)));

rule_removal_nonterm_dp ::
  forall a b c.
    (Key b, Showa b, Key c,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_dp_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_dp i dpp (Rule_removal_nonterm_dp_prf p r) =
  let {
    prm = (if is_none p then [] else ceta_list_diff (pairsb i dpp) (the p));
    rrm = (if is_none r then [] else ceta_list_diff (rulese i dpp) (the r));
  } in Inr (delete_R_Rwc i (delete_P_Pwa i dpp prm prm) rrm rrm);

mk_rel_tp ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      (Bool, ([Term b c], ([(Term b c, Term b c)], [(Term b c, Term b c)]))) ->
        a;
mk_rel_tp i (nfs, (q, (r, rw))) = mkc i nfs q r rw;

mk_dppa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      (Bool,
        (Bool,
          ([(Term b c, Term b c)],
            ([(Term b c, Term b c)],
              ([Term b c],
                ([(Term b c, Term b c)], [(Term b c, Term b c)])))))) ->
        a;
mk_dppa i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkd i nfs m p pw q r rw;

mk_tpa ::
  forall a b c d.
    Tp_ops_ext a b c d -> (Bool, ([Term b c], [(Term b c, Term b c)])) -> a;
mk_tpa i (nfs, (q, r)) = mkc i nfs q r [];

check_assmb ::
  forall a b c d e f g h i.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      (a -> e -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (d -> f -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (a -> g -> Sum ([Prelude.Char] -> [Prelude.Char])
                                       ()) ->
                            (([(Ctxt (Lab b c) [Prelude.Char],
                                 (Term (Lab b c) [Prelude.Char], Location))],
                               [(Term (Lab b c) [Prelude.Char],
                                  Term (Lab b c) [Prelude.Char])]) ->
                              h -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              ([Prelude.Char] ->
                                i -> Sum ([Prelude.Char] -> [Prelude.Char])
                                       ()) ->
                                Generic_assm_proof b c [Prelude.Char] e f g h
                                  i ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_SN_assm_proof t prf) = tp_check (mk_tpa i t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_RelSN_assm_proof t prf) = rtp_check (mk_rel_tp i t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Infinite_assm_proof t prf) = dp_check (mk_dppa j t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_SN_FP_assm_proof t prf) = fptp_check t prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Unknown_assm_proof t prf) = unk_check t prf;
check_assmb i j uu uv uw ux uy (SN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assmb i j uu uv uw ux uy (Finite_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assmb i j uu uv uw ux uy (SN_FP_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assmb i j uu uv uw ux uy (Complexity_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);

q_increase_nonterm_dp ::
  forall a b c.
    (Eq b,
      Eq c) => Dpp_ops_ext a b c () ->
                 a -> Q_increase_nonterm_dp_prf b c ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_increase_nonterm_dp i dpp (Q_increase_nonterm_dp_prf q) =
  let {
    p = pairsb i dpp;
    r = rulese i dpp;
    qa = qc i dpp;
    nfs = nfsc i dpp;
  } in Inr (mkd i nfs False p [] (list_union qa q) [] r);

dp_q_reduction_nonterm ::
  forall a b c d.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b, Showa b, Ccompare c,
      Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Dp_q_reduction_nonterm_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
dp_q_reduction_nonterm i dpp (DP_q_reduction_nonterm_prf q) =
  let {
    p = pairsb i dpp;
    r = rulese i dpp;
    qa = qc i dpp;
    nfs = nfsc i dpp;
    f = set (funas_trs_list (p ++ r));
    rQ = filter (\ qb -> less_eq_set (funas_term qb) f) qa;
  } in bindb (catch_errora (check_NF_terms_subset (is_NF_terms q) rQ)
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                       shows_prec_term zero_nat x .
                         shows_prec_list zero_nat
                           [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                             'g', ' ', 'i', 'n', ' ', 'Q', '\'', ' '])))
         (\ _ -> Inr (mkd i nfs False p [] q [] r));

check_dpp_subsumesa ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Dpp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      (Bool,
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          ([(Term (Lab b c) [Prelude.Char],
                              Term (Lab b c) [Prelude.Char])],
                            ([Term (Lab b c) [Prelude.Char]],
                              ([(Term (Lab b c) [Prelude.Char],
                                  Term (Lab b c) [Prelude.Char])],
                                [(Term (Lab b c) [Prelude.Char],
                                   Term (Lab b c) [Prelude.Char])])))))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dpp_subsumesa j dp dpp =
  let {
    (nfsa, (_, (p, (pw, (q, (r, rw)))))) = dp;
    pairsa = p ++ pw;
    rulesa = r ++ rw;
    nfs = nfsc j dpp;
    pairs = pairsb j dpp;
    rules = rulese j dpp;
    qa = qc j dpp;
  } in catch_errora
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list zero_nat
               ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ',
                 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
                 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm', 'a', 'l', '-',
                 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a', 'g', 's']))
           (\ _ ->
             bindb (catch_errora (check_subseteq pairsa pairs)
                     (\ x ->
                       Inl (toomuch ['p', 'a', 'i', 'r']
                             (shows_rule (shows_prec_lab zero_nat)
                               (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                               x))))
               (\ _ ->
                 bindb (catch_errora (check_subseteq rulesa rules)
                         (\ x ->
                           Inl (toomuch ['r', 'u', 'l', 'e']
                                 (shows_rule (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat)
                                   [' ', '-', '>', ' '] x))))
                   (\ _ ->
                     catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                       (\ x ->
                         Inl (shows_prec_list zero_nat
                                ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f',
                                  'f', 'e', 'r', 's', ' ', 'd', 'u', 'e', ' ',
                                  't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
                               shows_term (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) x))))))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 's', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

enfc_cand ::
  forall a b.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  b -> ([Term a [Prelude.Char]], Term a [Prelude.Char]) ->
                         [([Term a [Prelude.Char]], Term a [Prelude.Char])];
enfc_cand isQnf r q (uu, Var uv) = [];
enfc_cand isQnf r q (s, Fun f ts) =
  map (\ a -> (s, a)) ts ++
    concatMap
      (\ (l, ra) ->
        (if (case mgu_class (Fun f (map (icap_impl isQnf r s) ts)) l of {
              Nothing -> False;
              Just mu ->
                all (\ u ->
                      isQnf (subst_apply_term
                              (map_term (\ x -> x) (\ a -> 'y' : a) u) mu))
                  (args l) &&
                  all (\ u ->
                        isQnf (subst_apply_term
                                (map_term (\ x -> x) (\ a -> 'x' : a) u) mu))
                    s;
            })
          then [(args l, ra)] else []))
      r;

enfc_impl ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                (Term a [Prelude.Char] -> Bool) ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [Term a [Prelude.Char]] ->
                      [Term a [Prelude.Char]] -> Term a [Prelude.Char] -> Bool;
enfc_impl isQnf isRnf r q s t =
  all (\ (a, b) -> enfc_q isQnf isRnf r q a b)
    (mk_rtrancl_list (\ a b -> a == b) (enfc_cand isQnf r q) [(s, t)]);

check_nfc ::
  forall a.
    (Eq a, Key a,
      Showa a) => Bool ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      [Term a [Prelude.Char]] ->
                        (Term a [Prelude.Char] -> Bool) ->
                          [Term a [Prelude.Char]] ->
                            Bool ->
                              Term a [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_nfc inn r q isQnf ss nfs t =
  bindb (check_wf_trs r)
    (\ _ ->
      (if inn then Inr ()
        else catch_errora
               (forallM
                 (\ ta ->
                   check (enfc_impl isQnf (is_NF_trs r) r q ss ta)
                     (shows_prec_list zero_nat
                        [' ', 'n', 'f', 'c', ' ', 'n', 'o', 't', ' ', 's', 'a',
                          't', 'i', 's', 'f', 'i', 'e', 'd', ' ', 'f', 'o', 'r',
                          ' '] .
                       shows_prec_term zero_nat ta))
                 (supteq_list t))
               (\ x -> Inl (snd x))));

rewriting_complete_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Rewriting_complete_proc_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rewriting_complete_proc i (Rewriting_complete_proc_prf u_opt stb sta st lr p)
  dpp =
  (case catch_errora
          (let {
             s = fst stb;
             t = snd stb;
             ta = snd sta;
             r = rulese i dpp;
           } in bindb (check_rstep r p lr t ta)
                  (\ _ ->
                    bindb (check (nFQ_subset_NF_rulesc i dpp)
                            (shows_prec_list zero_nat
                              ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ',
                                'r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g',
                                ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                      (\ _ ->
                        bindb (check_rewrite_common_preconditions i u_opt stb
                                (args s) (args (subt_at t p)) ta lr p False dpp)
                          (\ _ ->
                            bindb (check (not (is_Var s))
                                    (shows_prec_list zero_nat
                                      ['l', 'h', 's', ' ', 'o', 'f', ' ', 'p',
'a', 'i', 'r', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ',
'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']))
                              (\ _ ->
                                bindb (check (eq_rule_mod_vars sta st)
(shows_prec_list zero_nat ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] sta .
    shows_prec_list zero_nat
      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r', 'e', 'n', 'a',
        'm', 'e', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'n', 't', ' ', 'o', 'f',
        ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
        [' ', '-', '>', ' '] st))
                                  (\ _ ->
                                    bindb (check (equal_term s (fst sta))
    (shows_prec_list zero_nat
      ['l', 'e', 'f', 't', '-', 'h', 'a', 'n', 'd', ' ', 's', 'i', 'd', 'e',
        's', ' ', 'o', 'f', ' ', 'o', 'l', 'd', ' ', 'a', 'n', 'd', ' ', 'n',
        'e', 'w', ' ', 'p', 'a', 'i', 'r', ' ', 'd', 'i', 'f', 'f', 'e', 'r']))
                                      (\ _ ->
let {
  q = qc i dpp;
  inn = isOK (check_NF_trs_subset r q);
} in bindb (check_nfc inn r q (is_QNFc i dpp) (args s) (nfsc i dpp)
             (subt_at t p))
       (\ _ ->
         bindb (catch_errora
                 (forallM
                   (\ (l, _) ->
                     check (not (is_Var l))
                       (shows_prec_list zero_nat
                         ['l', 'h', 's', 's', ' ', 'm', 'u', 's', 't', ' ', 'n',
                           'o', 't', ' ', 'b', 'e', ' ', 'v', 'a', 'r', 'i',
                           'a', 'b', 'l', 'e', 's']))
                   r)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             (if not (is_Var t)
               then check (not (not (null (rules_mapc i dpp (the (root t))))))
                      (shows_prec_list zero_nat
                         ['r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
                        shows_prec_term zero_nat t .
                          shows_prec_list zero_nat
                            [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                              'b', 'e', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd'])
               else Inr ()))))))))))
          (\ x ->
            Inl (shows_string
                   ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'r',
                     'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 't', 'h', 'e',
                     ' ', 'p', 'a', 'i', 'r', ' '] .
                  shows_nl .
                    shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                      [' ', '-', '>', ' '] stb .
                      shows_nl .
                        shows_string
                          [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                            'i', 'r', ' '] .
                          shows_nl .
                            shows_rule (shows_prec zero_nat)
                              (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                              st .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp stb [st]);
  });

less_eq_pos :: Pos -> Pos -> Bool;
less_eq_pos (PCons i q1) (PCons j q2) = equal_nat i j && less_eq_pos q1 q2;
less_eq_pos (PCons i q1) Empty = False;
less_eq_pos Empty p = True;

rstep_enum_impl ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b ->
                             Term a b ->
                               Pos ->
                                 [((Term a b, Term a b), (b -> Term a b, Pos))];
rstep_enum_impl r ta t p =
  concat
    (map_filter
      (\ x ->
        (if less_eq_pos p x
          then Just (let {
                       tp = subt_at ta x;
                     } in (if membera (poss_list t) x
                            then (if equal_ctxt (ctxt_of_pos_term x ta)
                                       (ctxt_of_pos_term x t)
                                   then concatMap
  (\ tpa ->
    concatMap
      (\ (l, ra) ->
        map (\ mu -> ((l, ra), (mu, x)))
          (option_to_list (match_list Var [(l, tp), (ra, tpa)])))
      r)
  [subt_at t x]
                                   else [])
                            else []))
          else Nothing))
      (poss_list ta));

narrow_enum_impl ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           (Term a b, Term a b) ->
                             (Term a b, Term a b) ->
                               Pos ->
                                 [(b -> Term a b,
                                    ((Term a b, Term a b),
                                      (Pos, b -> Term a b)))];
narrow_enum_impl r sta st p =
  let {
    (s, t) = sta;
    (sa, ta) = st;
  } in concatMap
         (\ mu ->
           concatMap (\ (lr, (tau, q)) -> [(mu, (lr, (q, tau)))])
             (rstep_enum_impl r (subst_apply_term t mu) ta p))
         (option_to_list (match sa s));

check_narrow ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Bool ->
                    Dpp_ops_ext a b [Prelude.Char] () ->
                      a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Bool ->
                                 (Term b [Prelude.Char],
                                   Term b [Prelude.Char]) ->
                                   (Term b [Prelude.Char],
                                     Term b [Prelude.Char]) ->
                                     ([Prelude.Char] -> Term b [Prelude.Char],
                                       ((Term b [Prelude.Char],
  Term b [Prelude.Char]),
 (Pos, [Prelude.Char] -> Term b [Prelude.Char]))) ->
                                       Sum ([Prelude.Char] -> [Prelude.Char])
 ();
check_narrow inn i dpp r q nfs sta st quad =
  let {
    ((_, t), ((s, ta), (mu, (lr, (p, _))))) = (sta, (st, quad));
  } in bindb (check_nfc inn r q (is_QNFc i dpp) (args s) nfs
               (subt_at (subst_apply_term t mu) p))
         (\ _ ->
           check_rewrite_common_preconditions i Nothing
             (s, subst_apply_term t mu) (args s)
             (args (subt_at (subst_apply_term t mu) p)) ta lr p False dpp);

narrowing_complete_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Narrowing_complete_proc_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
narrowing_complete_proc i (Narrowing_complete_proc_prf st p sts) dpp =
  (case catch_errora
          (let {
             (s, t) = st;
             q = qc i dpp;
             nfs = nfsc i dpp;
             rules = rulese i dpp;
             check_ndef =
               check_no_defined_root (\ fn -> not (null (rules_mapc i dpp fn)));
             inn = isOK (check_NF_trs_subset rules q);
             cnarrow = check_narrow inn i dpp rules q nfs st;
           } in bindb (check (null q || nFQ_subset_NF_rulesc i dpp)
                        (shows_prec_list zero_nat
                          ['f', 'u', 'l', 'l', ' ', 'o', 'r', ' ', 'i', 'n',
                            'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e',
                            'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'r', 'e',
                            'q', 'u', 'i', 'r', 'e', 'd']))
                  (\ _ ->
                    bindb (if null q then Inr ()
                            else bindb (check_no_var s)
                                   (\ _ ->
                                     bindb (check_no_var t)
                                       (\ _ ->
 bindb (check_ndef t)
   (\ _ ->
     (if nfs
       then bindb (catch_errora (forallM (\ (l, _) -> check_no_var l) rules)
                    (\ x -> Inl (snd x)))
              (\ _ ->
                check (wf_rule (s, t))
                  (shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                     [' ', '-', '>', ' '] (s, t) .
                    shows_prec_list zero_nat
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'w', 'e', 'l',
                        'l', ' ', 'f', 'o', 'r', 'm', 'e', 'd']))
       else Inr ())))))
                      (\ _ ->
                        catch_errora
                          (forallM
                            (\ sta ->
                              let {
                                quads = narrow_enum_impl rules st sta p;
                              } in catch_errora
                                     (existsM
                                       (\ quad ->
 catch_errora
   (check (null q)
     (shows_prec_list zero_nat
       ['q', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't', 'y']))
   (\ _ -> cnarrow sta quad))
                                       quads)
                                     (\ x ->
                                       Inl
 (shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] sta .
   shows_prec_list zero_nat
     (case quads of {
       [] -> [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 's', 'e', 'e',
               'm', ' ', 't', 'o', ' ', 'b', 'e', ' ', 'n', 'a', 'r', 'r', 'o',
               'w', 'e', 'd', ' ', 'p', 'a', 'i', 'r'];
       _ : _ ->
         [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 's', 'i', 'd', 'e',
           ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ', 'f', 'o',
           'r', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'e', 'n', 'e', 's',
           's'];
     }) .
     shows_list_gen id [] [] [] [] x)))
                            sts)
                          (\ x -> Inl (snd x)))))
          (\ x ->
            Inl (shows_string
                   ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'n',
                     'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', ' '] .
                  shows_nl .
                    shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
                      [' ', '-', '>', ' '] st .
                      shows_nl .
                        shows_string
                          [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                            'i', 'r', 's', ' '] .
                          shows_nl .
                            shows_trs (shows_prec zero_nat)
                              (shows_prec_list zero_nat)
                              ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                                's', 't', 'e', 'm', ':']
                              [' ', '-', '>', ' '] sts .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

inverse_var_renaming_impl ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)];
inverse_var_renaming_impl sigma = let {
                                    a = mk_subst_domain sigma;
                                  } in map (\ (x, y) -> (the_Var y, Var x)) a;

vars_subst_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
vars_subst_impl sigma =
  let {
    sigmaa = mk_subst_domain sigma;
  } in map fst sigmaa ++ concatMap (vars_term_list . snd) sigmaa;

vars_pat_term_impl ::
  forall a b.
    (Eq a, Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) -> [b];
vars_pat_term_impl p =
  let {
    (s, (sigma, mu)) = p;
  } in remdups
         (vars_term_list s ++ vars_subst_impl sigma ++ vars_subst_impl mu);

var_renaming_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> Bool;
var_renaming_impl sigma = let {
                            sigmaa = map snd (mk_subst_domain sigma);
                          } in all is_Var sigmaa && distinct sigmaa;

pat_dom_renaming_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                 [(b, Term a b)] -> Bool;
pat_dom_renaming_impl p rho =
  let {
    rhoa = mk_subst_domain rho;
    xs = map Var (vars_pat_term_impl p);
  } in var_renaming_impl rho &&
         all (membera (pat_dv_impl p)) (map fst rhoa) &&
           all (\ t -> not (membera xs t)) (map snd rhoa);

check_pat_eqv_prf ::
  forall a b.
    (Compare a, Eq a, Showa a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Set_impl b,
      Showa b) => Pat_eqv_prf a b ->
                    (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Term a b, ([(b, Term a b)], [(b, Term a b)]));
check_pat_eqv_prf (Pat_Irrelevant sigmaa mua) (t, (sigma, mu)) =
  let {
    w = w_impl (mk_subst_domain sigma) t;
    sig = mk_subst Var sigma;
    siga = mk_subst Var sigmaa;
    mub = mk_subst Var mu;
    muba = mk_subst Var mua;
  } in bindb (catch_errora
               (catch_errora
                 (forallM
                   (\ x ->
                     bindb (check (equal_term (sig x) (siga x))
                             (x, (sig x,
                                   (siga x,
                                     ['p', 'u', 'm', 'p', 'i', 'n', 'g']))))
                       (\ _ ->
                         check (equal_term (mub x) (muba x))
                           (x, (mub x,
                                 (muba x,
                                   ['c', 'l', 'o', 's', 'i', 'n', 'g'])))))
                   w)
                 (\ x -> Inl (snd x)))
               (\ x ->
                 Inl (let {
                        (xa, (tb, (ta, sub))) = x;
                      } in shows_string
                             ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'e',
                               'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e',
                               ' ', '(', 'i', 'r', 'r', 'e', 'l', 'e', 'v', 'a',
                               'n', 't', ')', ':', ' ', 'f', 'o', 'r', ' ', 'v',
                               'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                             shows_prec zero_nat xa .
                               shows_string
                                 [' ', 'o', 'b', 't', 'a', 'i', 'n', ' ', 'd',
                                   'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', ' ',
                                   'v', 'a', 'l', 'u', 'e', 's', ' ', 'f', 'o',
                                   'r', ' '] .
                                 shows_prec_list zero_nat sub .
                                   shows_string
                                     [' ', 's', 'u', 'b', 's', 't', 'i', 't',
                                       'u', 't', 'i', 'o', 'n', ':', ' '] .
                                     shows_prec_term zero_nat tb .
                                       shows_string [' ', '!', '=', ' '] .
 shows_prec_term zero_nat ta)))
         (\ _ -> Inr (t, (sigmaa, mua)));
check_pat_eqv_prf (Pat_Simplify mu_1 mu_2) (t, (sigma, mu)) =
  bindb (check (subst_eq mu (subst_compose_impl mu_1 mu_2))
          (shows_prec_list zero_nat
            ['m', 'u', ' ', '!', '=', ' ', 'm', 'u', '1', ' ', 'm', 'u', '2']))
    (\ _ ->
      bindb (check (commutes_impl mu_1 sigma)
              (shows_prec_list zero_nat
                ['s', 'i', 'g', 'm', 'a', ' ', 'a', 'n', 'd', ' ', 'm', 'u',
                  '1', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm',
                  'm', 'u', 't', 'e']))
        (\ _ -> Inr (subst_apply_term t (mk_subst Var mu_1), (sigma, mu_2))));
check_pat_eqv_prf (Pat_Dom_Renaming rho) (t, (sigma, mu)) =
  bindb (check (pat_dom_renaming_impl (t, (sigma, mu)) rho)
          (shows_prec_list zero_nat
            ['r', 'h', 'o', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ',
              'd', 'o', 'm', 'a', 'i', 'n', ' ', 'r', 'e', 'n', 'a', 'm', 'i',
              'n', 'g', ' ', 'f', 'o', 'r', ' ', 'p']))
    (\ _ ->
      let {
        i_rho = inverse_var_renaming_impl rho;
        sigmaa =
          mk_subst_case
            (map (the_Var . mk_subst Var rho) (map fst (mk_subst_domain sigma)))
            (\ x ->
              subst_apply_term
                (subst_apply_term
                  (subst_apply_term (Var x) (mk_subst Var i_rho))
                  (mk_subst Var sigma))
                (mk_subst Var rho))
            [];
        mua = mk_subst_case
                (map (the_Var . mk_subst Var rho)
                  (map fst (mk_subst_domain mu)))
                (\ x ->
                  subst_apply_term
                    (subst_apply_term (Var x) (mk_subst Var i_rho))
                    (mk_subst Var mu))
                i_rho;
      } in Inr (subst_apply_term t (mk_subst Var rho), (sigmaa, mua)));

subst_compose_impla ::
  forall a b.
    (Eq a, Eq b) => [(a, Term b a)] -> (a -> Term b a) -> [(a, Term b a)];
subst_compose_impla sigma rho =
  map (\ (x, s) -> (x, subst_apply_term s rho)) (mk_subst_domain sigma);

subst_replace_impl ::
  forall a b. (Eq a) => [(a, Term b a)] -> a -> Term b a -> [(a, Term b a)];
subst_replace_impl sigma x t = (x, t) : filter (\ (y, _) -> not (y == x)) sigma;

subst_power_impl ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> Nat -> [(a, Term b a)];
subst_power_impl sigma n =
  (if equal_nat n zero_nat then []
    else subst_compose_impl sigma
           (subst_power_impl sigma (minus_nat n one_nat)));

show_pat_term ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                    [Prelude.Char] -> [Prelude.Char];
show_pat_term p =
  let {
    (s, (sigma, tau)) = p;
  } in shows_prec_prod zero_nat
         (s, (mk_subst_domain sigma, mk_subst_domain tau));

show_pat_rule ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                    ((Term a b, ([(b, Term a b)], [(b, Term a b)])), Bool)) ->
                    [Prelude.Char] -> [Prelude.Char];
show_pat_rule pr =
  let {
    (p1, (p2, _)) = pr;
  } in show_pat_term p1 .
         shows_string [' ', '-', '-', '>', ' '] . show_pat_term p2;

check_pat_rule_prf ::
  forall a b.
    (Compare a, Eq a, Showa a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Pat_rule_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char])
                          ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                            ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                              Bool));
check_pat_rule_prf ra p (Pat_OrigRule (l, r) isPair) =
  (if isPair
    then bindb (check (membera p (l, r))
                 (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '-', '>', ' '] (l, r) .
                   shows_prec_list zero_nat
                     [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p',
                       'a', 'i', 'r']))
           (\ _ -> Inr ((l, ([], [])), ((r, ([], [])), isPair)))
    else bindb (check (membera ra (l, r))
                 (shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '-', '>', ' '] (l, r) .
                   shows_prec_list zero_nat
                     [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                       'u', 'l', 'e']))
           (\ _ -> Inr ((l, ([], [])), ((r, ([], [])), isPair))));
check_pat_rule_prf r p (Pat_InitPump pat sigma theta) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sig, tau)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (siga, taua)) = aa;
             } in (\ bb ->
                    catch_errora
                      (bindb
                        (check (null (sig ++ tau ++ siga ++ taua))
                          (shows_prec_list zero_nat
                            ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i',
                              'o', 'n', 's', ' ', 'm', 'u', 's', 't', ' ', 'b',
                              'e', ' ', 'e', 'm', 'p', 't', 'y']))
                        (\ _ ->
                          bindb (check
                                  (equal_term
                                    (subst_apply_term s (mk_subst Var theta))
                                    (subst_apply_term t (mk_subst Var sigma)))
                                  (shows_prec_list zero_nat
                                    ['s', ' ', 't', 'h', 'e', 't', 'a', ' ',
                                      '!', '=', ' ', 't', ' ', 's', 'i', 'g',
                                      'm', 'a']))
                            (\ _ ->
                              bindb (check (commutes_impl theta sigma)
                                      (shows_prec_list zero_nat
['s', 'i', 'g', 'm', 'a', ' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', 't', 'a', ' ',
  'd', 'o', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm', 'm', 'u', 't', 'e']))
                                (\ _ ->
                                  Inr ((s, (sigma, [])),
((t, (theta, [])), bb))))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['i', 'n', 'i', 't', 'i', 'a', 'l', ' ', 'p',
                                  'u', 'm', 'p', 'i', 'n', 'g'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sig, tau)),
((t, (siga, taua)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r pa (Pat_InitPumpCtxt pat sigma p z) =
  bindb (check_pat_rule_prf r pa pat)
    (\ (a, b) ->
      let {
        (s, (sig, tau)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (siga, taua)) = aa;
             } in (\ bb ->
                    catch_errora
                      (bindb
                        (check (not bb)
                          (shows_prec_list zero_nat
                            ['p', 'a', 'i', 'r', 's', ' ', 'n', 'o', 't', ' ',
                              'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'i', 'n',
                              ' ', 'i', 'n', 'i', 't', ' ', 'p', 'u', 'm', 'p',
                              ' ', 'c', 't', 'x', 't']))
                        (\ _ ->
                          bindb (check (null (sig ++ tau ++ siga ++ taua))
                                  (shows_prec_list zero_nat
                                    ['s', 'u', 'b', 's', 't', 'i', 't', 'u',
                                      't', 'i', 'o', 'n', 's', ' ', 'm', 'u',
                                      's', 't', ' ', 'b', 'e', ' ', 'e', 'm',
                                      'p', 't', 'y']))
                            (\ _ ->
                              bindb (check (in_poss p t)
                                      (shows_prec_list zero_nat
['p', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'v', 'a', 'l', 'i', 'd',
  ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n']))
                                (\ _ ->
                                  bindb (check
  (equal_term s (subst_apply_term (subt_at t p) (mk_subst Var sigma)))
  (shows_prec_list zero_nat
    ['s', ' ', '!', '=', ' ', 't', ' ', '|', '_', ' ', 'p', ' ', 's', 'i', 'g',
      'm', 'a']))
                                    (\ _ ->
                                      bindb
(check
  (not (membera (vars_term_list s ++ vars_term_list t ++ vars_subst_impl sigma)
         z))
  (shows_prec_list zero_nat
    ['z', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's', 'h']))
(\ _ ->
  let {
    tz = ctxt_apply_term (ctxt_of_pos_term p t) (Var z);
  } in Inr ((s, (sigma, [])),
             ((tz, ((z, tz) : sigma, [(z, subt_at t p)])), bb))))))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['i', 'n', 'i', 't', 'i', 'a', 'l', ' ', 'p',
                                  'u', 'm', 'p', 'i', 'n', 'g', ' ', '(', 'w',
                                  'i', 't', 'h', ' ', 'c', 't', 'x', 't', ')',
                                  ' '] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sig, tau)),
((t, (siga, taua)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Equiv pat left eqv) =
  bindb (check_pat_rule_prf r p pat)
    (\ (pleft, (pright, b)) ->
      catch_errora
        (bindb (check_pat_eqv_prf eqv (if left then pleft else pright))
          (\ pnew ->
            Inr (if left then (pnew, (pright, b)) else (pleft, (pnew, b)))))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h',
                   ' '] .
                shows_prec_list zero_nat
                  ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'e', 'q', 'u', 'i',
                    'v', 'a', 'l', 'e', 'n', 'c', 'e'] .
                  shows_prec_list zero_nat
                    [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e', 'r', 'i', 'v',
                      'i', 'n', 'g', ' ', 'c', 'o', 'r', 'r', 'e', 'c', 't',
                      ' ', 'p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r', 'u',
                      'l', 'e', ' '] .
                    shows_nl . show_pat_rule (pleft, (pright, b)) . x)));
check_pat_rule_prf r pa (Pat_Narrow pat1 pat2 p) =
  bindb (check_pat_rule_prf r pa pat1)
    (\ (a, b) ->
      let {
        (s, (sigma, mu)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sig, mua)) = aa;
             } in (\ b1 ->
                    bindb (check_pat_rule_prf r pa pat2)
                      (\ (ab, bb) ->
                        let {
                          (u, (sig1, mu1)) = ab;
                        } in (\ (ac, bc) ->
                               let {
                                 (v, (sig2, mu2)) = ac;
                               } in (\ b2 ->
                                      catch_errora
(bindb
  (check
    (subst_eq sig sigma &&
      subst_eq sig1 sigma &&
        subst_eq sig2 sigma &&
          subst_eq mua mu && subst_eq mu1 mu && subst_eq mu2 mu)
    (shows_prec_list zero_nat
      ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n', 's', ' ',
        'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i',
        'c', 'a', 'l']))
  (\ _ ->
    bindb (check (in_poss p t)
            (shows_prec_list zero_nat
              ['p', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'v', 'a',
                'l', 'i', 'd', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n']))
      (\ _ ->
        bindb (check (equal_term (subt_at t p) u)
                (shows_prec_list zero_nat
                  ['t', ' ', '|', '_', ' ', 'p', ' ', '!', '=', ' ', 'u']))
          (\ _ ->
            bindb (check (if b2 then equal_pos p Empty else True)
                    (shows_prec_list zero_nat
                      ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', ' ',
                        'P', ' ', 's', 't', 'e', 'p', ',', ' ', 's', 'o', ' ',
                        'p', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'e',
                        'p', 's', 'i', 'l', 'o', 'n']))
              (\ _ ->
                Inr ((s, (sigma, mu)),
                      ((ctxt_apply_term (ctxt_of_pos_term p t) v, (sigma, mu)),
                        b1 || b2)))))))
(\ x ->
  Inl (shows_prec_list zero_nat
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' '] .
        shows_prec_list zero_nat
          ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'n', 'a', 'r', 'r', 'o', 'w',
            'i', 'n', 'g'] .
          shows_prec_list zero_nat
            [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e', 'r', 'i', 'v', 'i',
              'n', 'g', ' ', 'c', 'o', 'r', 'r', 'e', 'c', 't', ' ', 'p', 'a',
              't', 't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e', 's', ' '] .
            shows_nl .
              show_pat_rule ((s, (sigma, mu)), ((t, (sig, mua)), b1)) .
                shows_nl .
                  shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                    shows_nl .
                      show_pat_rule ((u, (sig1, mu1)), ((v, (sig2, mu2)), b2)) .
                        x)))
                                 bc)
                          bb))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Base) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         xs = map fst
                                (mk_subst_domain sigma_s ++
                                  mk_subst_domain mu_s ++
                                    mk_subst_domain sigma_t ++
                                      mk_subst_domain mu_t);
                       } in bindb (catch_errora
                                    (forallM
                                      (\ x ->
check (not (membera xs x))
  (shows_prec_list zero_nat
    ['d', 'o', 'm', 'a', 'i', 'n', 's', ' ', 'n', 'o', 't', ' ', 'd', 'i', 's',
      'j', 'o', 'i', 'n', 't']))
                                      (vars_subst_impl rho))
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                let {
                                  rhoa = mk_subst Var rho;
                                } in Inr ((subst_apply_term s rhoa,
    (subst_compose_impla sigma_s rhoa, subst_compose_impla mu_s rhoa)),
   ((subst_apply_term t rhoa,
      (subst_compose_impla sigma_t rhoa, subst_compose_impla mu_t rhoa)),
     bb))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'i',
                                  'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't',
                                  'i', 'o', 'n', ' ', '(', 'b', 'a', 's', 'e',
                                  ')'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Pump) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (bindb
                        (check (commutes_impl rho sigma_s)
                          (shows_prec_list zero_nat
                            ['r', 'h', 'o', ' ', 'd', 'o', 'e', 's', ' ', 'n',
                              'o', 't', ' ', 'c', 'o', 'm', 'm', 'u', 't', 'e',
                              ' ', 'w', 'i', 't', 'h', ' ', 's', 'i', 'g', 'm',
                              'a', '_', 's']))
                        (\ _ ->
                          bindb (check (commutes_impl rho mu_s)
                                  (shows_prec_list zero_nat
                                    ['r', 'h', 'o', ' ', 'd', 'o', 'e', 's',
                                      ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm',
                                      'm', 'u', 't', 'e', ' ', 'w', 'i', 't',
                                      'h', ' ', 'm', 'u', '_', 's']))
                            (\ _ ->
                              bindb (check (commutes_impl rho sigma_t)
                                      (shows_prec_list zero_nat
['r', 'h', 'o', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm',
  'm', 'u', 't', 'e', ' ', 'w', 'i', 't', 'h', ' ', 's', 'i', 'g', 'm', 'a',
  '_', 't']))
                                (\ _ ->
                                  bindb (check (commutes_impl rho mu_t)
  (shows_prec_list zero_nat
    ['r', 'h', 'o', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o',
      'm', 'm', 'u', 't', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'm', 'u', '_',
      't']))
                                    (\ _ ->
                                      Inr
((s, (subst_compose_impl sigma_s rho, mu_s)),
  ((t, (subst_compose_impl sigma_t rho, mu_t)), bb)))))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'i',
                                  'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't',
                                  'i', 'o', 'n', ' ', '(', 'p', 'u', 'm', 'p',
                                  'i', 'n', 'g', ')'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Close) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    Inr ((s, (sigma_s, subst_compose_impl mu_s rho)),
                          ((t, (sigma_t, subst_compose_impl mu_t rho)), bb)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Base uu) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check (equal_term t ta)
                                    (shows_prec_list zero_nat
                                      ['t', 'e', 'r', 'm', 's', ' ', 't', ' ',
'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h']))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((tb, (sigma_t, mu_t)), bb)))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r',
                                  'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                                  '(', 'b', 'a', 's', 'e', ')'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Pump x) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check
                                    (equal_term (mk_subst Var sigma_t x) ta)
                                    (shows_prec_list zero_nat
                                      ['s', 'i', 'g', 'm', 'a', '_', 't', ' ',
'x', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h',
' ', 's', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ', 't', 'e', 'r', 'm']))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((t, (subst_replace_impl sigma_t x tb, mu_t)), bb)))))
                      (\ xa ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r',
                                  'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                                  '(', 'p', 'u', 'm', 'p', 'i', 'n', 'g', ')'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      xa)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Close x) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check (equal_term (mk_subst Var mu_t x) ta)
                                    (shows_prec_list zero_nat
                                      ['s', 'i', 'g', 'm', 'a', '_', 't', ' ',
'x', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h',
' ', 's', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ', 't', 'e', 'r', 'm']))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((t, (sigma_t, subst_replace_impl mu_t x tb)), bb)))))
                      (\ xa ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r',
                                  'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                                  '(', 'c', 'l', 'o', 's', 'i', 'n', 'g', ')'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      xa)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Exp_Sigma pat k) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    Inr ((subst_apply_term s
                            (mk_subst Var (subst_power_impl sigma_s k)),
                           (sigma_s, mu_s)),
                          ((subst_apply_term t
                              (mk_subst Var (subst_power_impl sigma_t k)),
                             (sigma_t, mu_t)),
                            bb)))
               ba)
        b);

check_non_loop_prf ::
  forall a b.
    (Compare a, Eq a, Showa a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Non_loop_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_prf r pa (Non_loop_prf pat sigma mu m b p) =
  bindb (check_pat_rule_prf r pa pat)
    (\ (a, c) ->
      let {
        (s, (sigmaa, mua)) = a;
      } in (\ (aa, ca) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ is_pair ->
                    catch_errora
                      (bindb
                        (check (if is_pair then equal_pos p Empty else True)
                          (shows_prec_list zero_nat
                            ['p', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ',
                              'e', 'm', 'p', 't', 'y', ',', ' ', 's', 'i', 'n',
                              'c', 'e', ' ', 'p', 'a', 'i', 'r', 's', ' ', 'a',
                              'r', 'e', ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n',
                              'e', 'd']))
                        (\ _ ->
                          bindb (check (commutes_impl sigmaa sigma)
                                  (shows_prec_list zero_nat
                                    ['s', 'i', 'g', 'm', 'a', ' ', 'a', 'n',
                                      'd', ' ', 's', 'i', 'g', 'm', 'a', '\'',
                                      ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ',
                                      'c', 'o', 'm', 'm', 'u', 't', 'e']))
                            (\ _ ->
                              bindb (check (commutes_impl mua sigma)
                                      (shows_prec_list zero_nat
['m', 'u', ' ', 'a', 'n', 'd', ' ', 's', 'i', 'g', 'm', 'a', '\'', ' ', 'd',
  'o', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm', 'm', 'u', 't', 'e']))
                                (\ _ ->
                                  bindb (check
  (subst_eq sigma_t (subst_compose_impl (subst_power_impl sigmaa m) sigma))
  (shows_prec_list zero_nat
    ['s', 'i', 'g', 'm', 'a', '_', 't', ' ', '!', '=', ' ', 's', 'i', 'g', 'm',
      'a', '^', 'm', ' ', 's', 'i', 'g', 'm', 'a', '\'', ' ']))
                                    (\ _ ->
                                      bindb
(check (subst_eq mu_t (subst_compose_impl mua mu))
  (shows_prec_list zero_nat
    ['m', 'u', '_', 't', ' ', '!', '=', ' ', 'm', 'u', ' ', 'm', 'u', '\'',
      ' ']))
(\ _ ->
  bindb (check (in_poss p t)
          (shows_prec_list zero_nat
            ['p', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
              's', 'i', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 't']))
    (\ _ ->
      check (equal_term
              (subst_apply_term s (mk_subst Var (subst_power_impl sigmaa b)))
              (subt_at t p))
        (shows_prec_list zero_nat
          ['s', ' ', 's', 'i', 'g', 'm', 'a', '^', 'b', ' ', '!', '=', ' ', 't',
            ' ', '|', '_', ' ', 'p']))))))))
                      (\ x ->
                        Inl (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list zero_nat
                                ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                                  'o', 'n', ' ', 'c', 'o', 'n', 'd', 'i', 't',
                                  'i', 'o', 'n', ' ', 'o', 'f', ' ', 'n', 'o',
                                  'n', '-', 'l', 'o', 'o', 'p', ' ', 't', 'h',
                                  'e', 'o', 'r', 'e', 'm'] .
                                shows_prec_list zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigmaa, mua)),
((t, (sigma_t, mu_t)), is_pair)) .
                                      x)))
               ca)
        c);

check_non_loop_dp_prf ::
  forall a b c d.
    (Compare b, Eq b, Showa b, Cenum c, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Non_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_dp_prf i dpp prf =
  let {
    p = pairsb i dpp;
    r = rulese i dpp;
  } in bindb (check (null (qc i dpp))
               (shows_prec_list zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'f', 'o', 'r',
                   ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p', 's', ' ', 'u',
                   'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
         (\ _ -> check_non_loop_prf r p prf);

rule_removal_nonterm_trs ::
  forall a b c.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_trs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_trs i tp (Rule_removal_nonterm_trs_prf r) =
  let {
    ra = rulesd i tp;
    rrm = ceta_list_diff ra r;
  } in Inr (delete_R_Rwb i tp rrm rrm);

shows_prec_location :: Nat -> Location -> [Prelude.Char] -> [Prelude.Char];
shows_prec_location uu A = shows_prec_list zero_nat ['a', 'b', 'o', 'v', 'e'];
shows_prec_location uv Ba = shows_prec_list zero_nat ['b', 'e', 'l', 'o', 'w'];
shows_prec_location uw H = shows_prec_list zero_nat ['h', 'e', 'r', 'e'];
shows_prec_location ux Ra = shows_prec_list zero_nat ['r', 'i', 'g', 'h', 't'];

shows_pattern ::
  forall a b.
    (Showa a,
      Showa b) => (Ctxt a b, (Term a b, Location)) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_pattern (c, (s, p)) =
  shows_prec_list zero_nat ['('] .
    shows_prec_term zero_nat (ctxt_apply_term c s) .
      shows_prec_list zero_nat [',', ' '] .
        shows_prec_pos zero_nat (hole_pos c) .
          shows_prec_list zero_nat [',', ' '] .
            shows_prec_location zero_nat p . shows_prec_list zero_nat [')'];

fp_R_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_R_decide mu l oo q c t =
  not (bex (let {
              h = hole_pos c;
              q_s = filter (\ qa -> is_left_of qa q) (poss_list t);
              m1 = map (\ qa -> (subt_at t qa, l)) q_s;
              sterms =
                remdups
                  (map (si_subst mu)
                    (remdups (concatMap (\ qa -> si_W mu (subt_at t qa)) q_s)));
              uterms = concatMap supteq_list sterms;
              m2 = map (\ u -> (u, l)) (remdups uterms);
              p_s = filter (\ qa -> is_left_of qa h)
                      (poss_list (ctxt_apply_term c t));
              m3 = map (\ p -> (subt_at (ctxt_apply_term c t) p, l)) p_s;
              stermsa =
                remdups
                  (map (si_subst mu)
                    (remdups
                      (concatMap
                        (\ p -> si_W mu (subt_at (ctxt_apply_term c t) p))
                        p_s)));
              utermsa = concatMap supteq_list stermsa;
              m4 = map (\ u -> (u, l)) (remdups utermsa);
            } in set (m1 ++ m2 ++ m3 ++ m4))
        (match_decision mu));

pos_dec :: Pos -> Pos -> Pos -> Maybe (Nat, Pos);
pos_dec p q oo =
  (if equal_pos p Empty then (case pos_suffix oo q of {
                               Nothing -> Nothing;
                               Just r -> Just (zero_nat, r);
                             })
    else let {
           n0 = nat (ceiling
                      (divide_rat
                        (of_nat (minus_nat (size_pos oo) (size_pos q)))
                        (of_nat (size_pos p))));
         } in (case pos_suffix oo (append (power p n0) q) of {
                Nothing -> Nothing;
                Just r -> Just (n0, r);
              }));

ctxt_subst ::
  forall a b. Ctxt a b -> (b -> Term a b) -> Nat -> Term a b -> Term a b;
ctxt_subst uu uv n t =
  (if equal_nat n zero_nat then t
    else ctxt_apply_term uu
           (subst_apply_term (ctxt_subst uu uv (minus_nat n one_nat) t) uv));

h_match_probs ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => (a -> Term b a) ->
                 Term b a ->
                   Pos ->
                     Pos -> Ctxt b a -> Term b a -> Set (Term b a, Term b a);
h_match_probs mu l oo q c t =
  (case pos_dec (hole_pos c) q oo of {
    Nothing ->
      set_empty
        (of_phantom (set_impl_prod :: Phantom (Term b a, Term b a) Set_impla));
    Just (n, o) ->
      inserta (subt_at (ctxt_subst c mu n t) o, l)
        (set_empty
          (of_phantom
            (set_impl_prod :: Phantom (Term b a, Term b a) Set_impla)));
  });

fp_H_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_H_decide mu l oo q c t =
  not (bex (h_match_probs (si_subst mu) l oo q c t) (match_decision mu));

decompositions :: Pos -> [(Pos, Pos)];
decompositions p = map (\ pa -> (pa, the (pos_prefix pa p))) (prefix_list p);

simplify_emp_main ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b,
                   (Term a b,
                     (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                   [(Term a b, Term a b)] ->
                     Maybe (Maybe (Ctxt a b,
                                    (Term a b,
                                      (Ctxt a b,
(Term a b, [(Term a b, Term a b)])))));
simplify_emp_main mu_incr (Hole, (Fun g ls, (c, (t, [])))) solved =
  (if gmatch_decision mu_incr ((t, Fun g ls) : solved) then Just Nothing
    else (if equal_ctxt c Hole then Nothing
           else simplify_emp_main mu_incr
                  (c, (Fun g ls,
                        (subst_apply_ctxt c (si_subst mu_incr),
                          (subst_apply_term t (si_subst mu_incr), []))))
                  solved));
simplify_emp_main mu_incr (More f bef d aft, (Fun g ls, (c, (t, [])))) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (guarda
             (equal_nat (size_list ls)
               (suc (plus_nat (size_list bef) (size_list aft)))))
        (\ _ ->
          let {
            pairs_bef = zip bef (take (size_list bef) ls);
            pairs_aft = zip aft (drop (suc (size_list bef)) ls);
          } in simplify_emp_main mu_incr
                 (d, (nth ls (size_list bef), (c, (t, pairs_bef ++ pairs_aft))))
                 solved));
simplify_emp_main mu_incr (d, (Var x, (c, (t, [])))) solved =
  Just (Just (d, (Var x, (c, (t, solved)))));
simplify_emp_main mu_incr (d, (l, (c, (t, (Var x, Fun f ls) : mp)))) solved =
  bind (guarda (member x (si_v_incr mu_incr)))
    (\ _ ->
      let {
        m = map (\ (s, a) -> (subst_apply_term s (si_subst mu_incr), a));
      } in simplify_emp_main mu_incr
             (subst_apply_ctxt d (si_subst mu_incr),
               (l, (subst_apply_ctxt c (si_subst mu_incr),
                     (subst_apply_term t (si_subst mu_incr),
                       m ((Var x, Fun f ls) : mp)))))
             (m solved));
simplify_emp_main mu_incr (d, (l, (c, (t, (Fun g ts, Fun f ls) : mp)))) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (zip_option ts ls)
        (\ pairs ->
          simplify_emp_main mu_incr (d, (l, (c, (t, pairs ++ mp)))) solved));
simplify_emp_main mu_incr (d, (l, (c, (t, (s, Var x) : mp)))) solved =
  simplify_emp_main mu_incr (d, (l, (c, (t, mp)))) ((s, Var x) : solved);

simplify_emp ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) ->
                   Sum (Ctxt a b,
                         (Term a b,
                           (Ctxt a b, (Term a b, [(Term a b, Term a b)]))))
                     Bool;
simplify_emp mu_incr emp =
  let {
    (d, (l, (c, t))) = emp;
  } in (case simplify_emp_main mu_incr (d, (l, (c, (t, [])))) [] of {
         Nothing -> Inr False;
         Just a -> (case a of {
                     Nothing -> Inr True;
                     Just aa -> Inl aa;
                   });
       });

eident_prob_to_ident_prob ::
  forall a b.
    (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) -> (Term a b, Term a b);
eident_prob_to_ident_prob (d, (si, (c, t))) = (ctxt_apply_term d t, si);

eident_prob_of_semp ::
  forall a b.
    (Eq a,
      Eq b) => (Ctxt a b,
                 (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                 Maybe (Ctxt a b, (Term a b, (Ctxt a b, Term a b)));
eident_prob_of_semp (d, (l, (c, (t, mp)))) =
  bind (map_of (reverse_rules mp) l) (\ si -> Just (d, (si, (c, t))));

ident_prob_of_semp ::
  forall a b.
    (Eq a,
      Eq b) => (Ctxt a b,
                 (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                 [(Term a b, Term a b)];
ident_prob_of_semp (d, (l, (c, (t, mp)))) = ident_prob_of_smp mp;

ident_prob_of_emp ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) ->
                   Maybe [(Term a b, Term a b)];
ident_prob_of_emp mu_incr emp =
  (case simplify_emp mu_incr emp of {
    Inl semp ->
      Just (map eident_prob_to_ident_prob
              (option_to_list (eident_prob_of_semp semp)) ++
             ident_prob_of_semp semp);
    Inr True -> Just [];
    Inr False -> Nothing;
  });

n0b :: Pos -> Pos -> Pos -> Nat;
n0b p q oo =
  nat (ceiling
        (divide_rat (of_nat (minus_nat (suc (size_pos oo)) (size_pos q)))
          (of_nat (size_pos p))));

less_pos :: Pos -> Pos -> Bool;
less_pos p q = less_eq_pos p q && not (equal_pos p q);

fp_B_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_B_decide mu l oo q c t =
  not (bex (foldr (sup_set . (\ qa -> h_match_probs (si_subst mu) l oo qa c t))
             (proper_prefix_list q)
             (set_empty
               (of_phantom
                 (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla))))
        (match_decision mu)) &&
    not (bex (let {
                p = hole_pos c;
                n = (\ pa -> n0b p pa oo);
                ps = filter
                       (\ (pa, pb) ->
                         less_pos oo (append pb (power p (n pb))) &&
                           less_pos pa p)
                       (remdups (decompositions p));
              } in set (map (\ (pb, pa) ->
                              (subt_at_ctxt c pb,
                                (l, (subst_apply_ctxt c (si_subst mu),
                                      subst_apply_term
(ctxt_subst c (si_subst mu) (n pa) t) (si_subst mu)))))
                         (remdups ps)))
          (\ ep ->
            bex (set_option (ident_prob_of_emp mu ep))
              (all (ident_decision mu))));

n0 :: Pos -> Pos -> Pos -> Nat;
n0 p q oo =
  nat (ceiling
        (divide_rat (of_nat (minus_nat (size_pos oo) (size_pos q)))
          (of_nat (size_pos p))));

bounded_postfixes :: Pos -> [Pos] -> [Pos];
bounded_postfixes p ps =
  map_filter (\ x -> (if not (is_none x) then Just (the x) else Nothing))
    (map (pos_prefix p) ps);

fp_A_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_A_decide mu l oo q c t =
  not (bex (case subt_at t q of {
             Var _ ->
               set_empty
                 (of_phantom
                   (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla));
             Fun _ _ ->
               let {
                 h = hole_pos c;
                 n = n0 h q oo;
                 hn = power h n;
                 cs = ctxt_subst c (si_subst mu) n t;
                 q_s = bounded_postfixes q (poss_list t);
                 qoo_s =
                   concatMap
                     (\ qa ->
                       map (\ a -> (qa, a))
                         (prefix_list (append hn (append q qa))))
                     q_s;
                 qoo_sf =
                   filter
                     (\ qoo -> less_pos (append hn q) (append (snd qoo) oo))
                     qoo_s;
                 m1 = map (\ qoo -> (subt_at cs (snd qoo), l)) qoo_sf;
                 sterms = remdups (map (si_subst mu) (si_W mu (subt_at t q)));
                 uterms =
                   concatMap (filter (\ ta -> not (is_Var ta)) . supteq_list)
                     sterms;
                 m2 = map (\ u -> (u, l)) (remdups uterms);
               } in set (m1 ++ m2);
           })
        (match_decision mu));

fp_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Pos, (Ctxt a b, Term a b)) ->
                   (Ctxt a b, (Term a b, Location)) -> Bool;
fp_decide mu =
  (\ (q, (c, t)) (l, (la, loc)) ->
    (if equal_location loc H
      then fp_H_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
      else True) &&
      (if equal_location loc A
        then fp_A_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
        else True) &&
        (if equal_location loc Ba
          then fp_B_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
          else True) &&
          (if equal_location loc Ra
            then fp_R_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
            else True));

fp_valid ::
  forall a b c.
    (Compare a, Eq a, Compare b, Eq b, Ceq c,
      Ccompare c) => Set (Ctxt a b, (Term a b, c)) -> Bool;
fp_valid p = ball p (\ (l, (la, _)) -> not (is_Var (ctxt_apply_term l la)));

check_fploop ::
  forall a b.
    (Compare a, Eq a, Showa a, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Ctxt a b, (Term a b, Location))] ->
                      Fp_loop_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fploop r p (FP_loop_prf c sigma t seq) =
  let {
    mu = subst_incr sigma;
    mua = si_subst mu;
  } in bindb (check (not (null seq))
               (shows_prec_list zero_nat
                 ['l', 'o', 'o', 'p', 'i', 'n', 'g', ' ', 'r', 'e', 'd', 'u',
                   'c', 't', 'i', 'o', 'n', ' ', 'm', 'u', 's', 't', ' ', 'n',
                   'o', 't', ' ', 'b', 'e', ' ', 'e', 'm', 'p', 't', 'y']))
         (\ _ ->
           bindb (check
                   (equal_term (let {
                                  (_, (_, ta)) = last seq;
                                } in ta)
                     (ctxt_apply_term c (subst_apply_term t mua)))
                   (shows_prec_list zero_nat
                     ['l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ', 'i',
                       'n', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ' ',
                       'i', 's', ' ', 'n', 'o', 't', ' ', 'C', '[', 't', ' ',
                       's', 'i', 'g', 'm', 'a', ']']))
             (\ _ ->
               bindb (check (fp_valid (set p))
                       (shows_prec_list zero_nat
                         ['l', 'h', 's', 's', ' ', 'i', 'n', ' ', 'f', 'o', 'r',
                           'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a', 't',
                           't', 'e', 'r', 'n', 's', ' ', 'm', 'u', 's', 't',
                           ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'v', 'a',
                           'r', 'i', 'a', 'b', 'l', 'e', 's']))
                 (\ _ ->
                   bindb (catch_errora
                           (forallM
                             (\ (l, _) ->
                               check (not (is_Var l))
                                 (shows_prec_list zero_nat
                                   ['l', 'h', 's', 's', ' ', 'o', 'f', ' ', 'T',
                                     'R', 'S', ' ', 'm', 'u', 's', 't', ' ',
                                     'n', 'o', 't', ' ', 'b', 'e', ' ', 'v',
                                     'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
                             r)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       let {
                         seqa = zip (t : map (\ (_, (_, ta)) -> ta) seq) seq;
                       } in catch_errora
                              (forallM
                                (\ (ta, (q, (ra, s))) ->
                                  bindb (check_rstep r q ra ta s)
                                    (\ _ ->
                                      let {
check_fpstep = fp_decide mu (q, (c, ta));
                                      } in
catch_errora
  (forallM
    (\ pt ->
      check (check_fpstep pt)
        (shows_prec_list zero_nat
           ['i', 't', 'e', 'r', 'a', 't', 'i', 'n', 'g', ' ', 'r', 'e', 'd',
             'u', 'c', 't', 'i', 'o', 'n', ' '] .
          shows_prec_term zero_nat ta .
            shows_prec_list zero_nat [' ', '-', '-', '>'] .
              shows_prec_pos zero_nat q .
                shows_prec_list zero_nat [' '] .
                  shows_prec_term zero_nat s .
                    shows_prec_list zero_nat
                      [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'r',
                        'e', 's', 'p', 'e', 'c', 't', ' ', 'f', 'o', 'r', 'b',
                        'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a', 't', 't', 'e',
                        'r', 'n', ' '] .
                      shows_pattern pt))
    p)
  (\ x -> Inl (snd x))))
                                seqa)
                              (\ x -> Inl (snd x))))));

check_fp_tp_subsumes ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ([(Ctxt (Lab a b) [Prelude.Char],
                      (Term (Lab a b) [Prelude.Char], Location))],
                    [(Term (Lab a b) [Prelude.Char],
                       Term (Lab a b) [Prelude.Char])]) ->
                    ([(Ctxt (Lab a b) [Prelude.Char],
                        (Term (Lab a b) [Prelude.Char], Location))],
                      [(Term (Lab a b) [Prelude.Char],
                         Term (Lab a b) [Prelude.Char])]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fp_tp_subsumes ta t =
  let {
    ((p, r), (pa, ra)) = (ta, t);
  } in catch_errora
         (bindb
           (check (p == pa)
             (shows_prec_list zero_nat
               ['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 'i', 'n',
                 ' ', 'f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p',
                 'a', 't', 't', 'e', 'r', 'n', 's', ' ', 's', 't', 'r', 'a',
                 't', 'e', 'g', 'y']))
           (\ _ ->
             catch_errora (check_subseteq r ra)
               (\ x ->
                 Inl (toomuch ['r', 'u', 'l', 'e']
                       (shows_rule (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] x)))))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

string_reversal_complete_tt ::
  forall a b c d.
    (Showa b,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_complete_tt i tp =
  let {
    r = rulesd i tp;
  } in bindb (check (q_emptyb i tp)
               (shows_prec_list zero_nat
                 ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p',
                   't', 'y']))
         (\ _ ->
           bindb (check_unary_signature r)
             (\ _ -> Inr (mkc i default_nfs_nt_trs [] (map rev_rule r) [])));

show_ta ::
  forall a b.
    (Showa a,
      Showa b) => Tree_automaton a b -> [Prelude.Char] -> [Prelude.Char];
show_ta (Tree_Automaton fin rules eps) =
  (((((((shows_prec_list zero_nat ['f', 'i', 'n', 'a', 'l', ':', ' '] .
          shows_prec_list zero_nat fin) .
         shows_nl) .
        shows_prec_list zero_nat ['r', 'u', 'l', 'e', 's', ':', ' ']) .
       shows_lines rules) .
      shows_nl) .
     shows_prec_list zero_nat ['e', 'p', 's', 'i', 'l', 'o', 'n', ':', ' ']) .
    shows_prec_list zero_nat eps) .
    shows_nl;

shows_prec_tree_automaton ::
  forall a b.
    (Showa a,
      Showa b) => Nat -> Tree_automaton a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_tree_automaton d r = show_ta r;

ta_idx_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> e;
ta_idx_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = idx;

comp_res_of_order :: Ordera -> Comp_res;
comp_res_of_order Eqa = EQUAL;
comp_res_of_order Lt = LESS;
comp_res_of_order Gt = GREATER;

compare_res :: forall a. (Compare a) => a -> a -> Comp_res;
compare_res x y = comp_res_of_order (compare x y);

set_iterator_image ::
  forall a b c.
    (a -> b) ->
      ((c -> Bool) -> (a -> c -> c) -> c -> c) ->
        (c -> Bool) -> (b -> c -> c) -> c -> c;
set_iterator_image g it = (\ c f -> it c (\ x -> f (g x)));

map_iterator_dom ::
  forall a b c.
    ((a -> Bool) -> ((b, c) -> a -> a) -> a -> a) ->
      (a -> Bool) -> (b -> a -> a) -> a -> a;
map_iterator_dom it = set_iterator_image fst it;

list_eq :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
list_eq eq [] [] = True;
list_eq eq (aa : la) (a : l) = (if eq aa a then list_eq eq la l else False);
list_eq uu (v : va) [] = False;
list_eq uu [] (v : va) = False;

rule_filter_opt_code ::
  forall a b.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            b -> [a] -> Rbta a ();
rule_filter_opt_code a b c =
  (case rbt_comp_lookup compare_prod (ta_idx_impl a) (b, size_list c) of {
    Nothing -> Emptya;
    Just xc ->
      gen_image (map_iterator_dom . rm_iterateoi) Emptya
        (\ k -> rbt_comp_insert compare k ()) snd
        (gen_filter (map_iterator_dom . rm_iterateoi) Emptya
          (\ k -> rbt_comp_insert compare_prod k ())
          (\ (xd, _) -> list_eq (comp2eq compare_res) xd c) xc);
  });

ta_rhs_states_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> d;
ta_rhs_states_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = rhs;

update_all_code ::
  forall a b. (Compare a) => Rbta a b -> Rbta a () -> b -> Rbta a b;
update_all_code m s v =
  (map_iterator_dom . rm_iterateoi) s (\ _ -> True)
    (\ x -> rbt_comp_insert compare x v) m;

update_all2_code ::
  forall a b c.
    (Compare a,
      Compare b) => Rbta a (Rbta b c) ->
                      Rbta a () -> Rbta b () -> c -> Rbta a (Rbta b c);
update_all2_code m s1 s2 v =
  (map_iterator_dom . rm_iterateoi) s1 (\ _ -> True)
    (\ x sigma ->
      let {
        xa = update_all_code (case rbt_comp_lookup compare sigma x of {
                               Nothing -> Emptya;
                               Just a -> id a;
                             })
               s2 v;
      } in rbt_comp_insert compare x xa sigma)
    m;

union_image_rs_code ::
  forall a b.
    (Compare a, Compare b) => Rbta a () -> (a -> Rbta b ()) -> Rbta b ();
union_image_rs_code s f =
  (map_iterator_dom . rm_iterateoi) s (\ _ -> True)
    (\ x -> rbt_comp_union_with_key compare (\ _ _ rv -> rv) (f x)) Emptya;

ta_eps_cl_impl ::
  forall a b c d e f g h i. (a, (b, (c, (d, (e, (f, (g -> h, i))))))) -> g -> h;
ta_eps_cl_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) q = efcl q;

ta_match_var_ref_code ::
  forall a b c.
    (Compare_order a, Compare_order b,
      Compare c) => (Rbta a (),
                      (Rbta (Ta_rule a b) (),
                        ([(a, a)],
                          (Rbta a (),
                            (Rbta (b, Nat) (Rbta ([a], a) ()),
                              (Bool, (a -> Rbta a (), a -> Rbta a ()))))))) ->
                      Rbta a () -> c -> Rbta a () -> Rbta [(c, a)] ();
ta_match_var_ref_code ta qsig x q =
  (map_iterator_dom . rm_iterateoi) qsig (\ _ -> True)
    (\ xa sigma ->
      (if not (gen_disjoint (map_iterator_dom . rm_iterateoi)
                (\ k s -> (case rbt_comp_lookup compare s k of {
                            Nothing -> False;
                            Just _ -> True;
                          }))
                (ta_eps_cl_impl ta xa) q)
        then rbt_comp_insert compare_list [(x, xa)] () sigma else sigma))
    Emptya;

set_App_code ::
  forall a. (Compare a) => Rbta [a] () -> Rbta [a] () -> Rbta [a] ();
set_App_code x xs =
  (map_iterator_dom . rm_iterateoi) x (\ _ -> True)
    (\ xa ->
      (map_iterator_dom . rm_iterateoi) xs (\ _ -> True)
        (\ xaa -> rbt_comp_insert compare_list (xa ++ xaa) ()))
    Emptya;

concat_listset_code :: forall a. (Compare a) => [Rbta [a] ()] -> Rbta [a] ();
concat_listset_code =
  rec_list (rbt_comp_insert compare_list [] () Emptya)
    (\ x _ -> set_App_code x);

map2 :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c];
map2 f [] ys = [];
map2 f (v : va) [] = [];
map2 f (x : xs) (y : ys) = f x y : map2 f xs ys;

ta_match_code ::
  forall a b c.
    (Compare_order a, Compare_order b,
      Compare c) => (Rbta a (),
                      (Rbta (Ta_rule a b) (),
                        ([(a, a)],
                          (Rbta a (),
                            (Rbta (b, Nat) (Rbta ([a], a) ()),
                              (Bool, (a -> Rbta a (), a -> Rbta a ()))))))) ->
                      Rbta a () -> Term b c -> Rbta a () -> Rbta [(c, a)] ();
ta_match_code ta qsig (Var x) q = ta_match_var_ref_code ta qsig x q;
ta_match_code a b (Fun c d) e =
  (case rbt_comp_lookup compare_prod (ta_idx_impl a) (c, size_list d) of {
    Nothing -> Emptya;
    Just xe ->
      union_image_rs_code xe
        (\ (xf, xg) ->
          (if not (gen_disjoint (map_iterator_dom . rm_iterateoi)
                    (\ k s -> (case rbt_comp_lookup compare s k of {
                                Nothing -> False;
                                Just _ -> True;
                              }))
                    (ta_eps_cl_impl a xg) e)
            then concat_listset_code
                   (map2 (\ t q ->
                           ta_match_code a b t
                             (rbt_comp_insert compare q () Emptya))
                     d xf)
            else Emptya));
  });

ta_res_args_aux_code ::
  forall a b.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            b -> [Rbta a ()] -> Rbta a ();
ta_res_args_aux_code =
  (\ x xa xb ->
    (case rbt_comp_lookup compare_prod (ta_idx_impl x) (xa, size_list xb) of {
      Nothing -> Emptya;
      Just xc ->
        union_image_rs_code xc
          (\ (xd, xe) ->
            (if list_all2 (\ xf s -> (case rbt_comp_lookup compare s xf of {
                                       Nothing -> False;
                                       Just _ -> True;
                                     }))
                  xd xb
              then ta_eps_cl_impl x xe else Emptya));
    }));

ta_res_code ::
  forall a b.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            Term b a -> Rbta a ();
ta_res_code =
  (\ x xa ->
    rec_term (\ xb xc -> ta_eps_cl_impl xc xb)
      (\ xb xc xd -> let {
                       a = map (\ xe -> snd xe xd) xc;
                     } in ta_res_args_aux_code xd xb a)
      xa x);

is_compatible_code ::
  forall a b c.
    (Compare_order a, Compare_order b, Compare c,
      Eq c) => (Rbta a (),
                 (Rbta (Ta_rule a b) (),
                   ([(a, a)],
                     (Rbta a (),
                       (Rbta (b, Nat) (Rbta ([a], a) ()),
                         (Bool, (a -> Rbta a (), a -> Rbta a ()))))))) ->
                 Rbta (Term b c, Term b c) () ->
                   Sum (a, (Term b a, Term b a))
                     (Rbta a (Rbta a (Term b a, Term b a)));
is_compatible_code ta r =
  (map_iterator_dom . rm_iterateoi) r is_Inr
    (\ x sigma ->
      let {
        (a, b) = x;
        xa = ta_match_code ta (ta_rhs_states_impl ta) a (ta_rhs_states_impl ta);
      } in (map_iterator_dom . rm_iterateoi) xa is_Inr
             (\ xb sigmaa ->
               let {
                 xc = map_term (\ xh -> xh) (fun_of xb) a;
                 xd = ta_res_code ta xc;
               } in (if gen_isEmptya
                          (gen_balla (map_iterator_dom . rm_iterateoi)) xd
                      then sigmaa
                      else let {
                             xe = map_term (\ xj -> xj) (fun_of xb) b;
                             xf = ta_res_code ta xe;
                           } in (if gen_isEmptya
                                      (gen_balla
(map_iterator_dom . rm_iterateoi))
                                      xf
                                  then let {
 xg = gen_pick (map_iterator_dom . rm_iterateoi) xd;
                                       } in Inl (xg, (xc, xe))
                                  else let {
 aa = update_all2_code (projr sigmaa) xd xf (xc, xe);
                                       } in Inr aa)))
             sigma)
    (Inr Emptya);

ta_rules_impla ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> b;
ta_rules_impla (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = r;

ta_final_impla ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> a;
ta_final_impla (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = f;

ta_idx_rhs_init_code ::
  forall a b c.
    (Compare a, Compare b,
      Compare c) => Bool ->
                      Rbta (Ta_rule a b) () ->
                        (a -> Rbta c ()) ->
                          (Rbta (b, Nat) (Rbta ([a], a) ()), (Bool, Rbta c ()));
ta_idx_rhs_init_code det rs efcl =
  (map_iterator_dom . rm_iterateoi) rs (\ _ -> True)
    (\ x (a, (aa, ba)) ->
      let {
        (TA_rule xg xh xi) = x;
        xj = size_list xh;
      } in (case rbt_comp_lookup compare_prod a (xg, xj) of {
             Nothing ->
               (rbt_comp_insert compare_prod (xg, xj)
                  (rbt_comp_insert compare_prod (xh, xi) () Emptya) a,
                 (aa, rbt_comp_union_with_key compare (\ _ _ rv -> rv) (efcl xi)
                        ba));
             Just xk ->
               (rbt_comp_insert compare_prod (xg, xj)
                  (rbt_comp_insert compare_prod (xh, xi) () xk) a,
                 ((if aa
                    then gen_balla (map_iterator_dom . rm_iterateoi) xk
                           (\ (xl, _) ->
                             not (list_eq (comp2eq compare_res) xh xl))
                    else False),
                   rbt_comp_union_with_key compare (\ _ _ rv -> rv) (efcl xi)
                     ba));
           }))
    (Emptya, (det, Emptya));

prod_eq ::
  forall a b c d.
    (a -> b -> Bool) -> (c -> d -> Bool) -> (a, c) -> (b, d) -> Bool;
prod_eq eqa eqb x1 x2 = let {
                          (a1, b1) = x1;
                          (a2, b2) = x2;
                        } in eqa a1 a2 && eqb b1 b2;

glist_member :: forall a. (a -> a -> Bool) -> a -> [a] -> Bool;
glist_member eq x [] = False;
glist_member eq x (y : ys) = eq x y || glist_member eq x ys;

glist_insert :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
glist_insert eq x xs = (if glist_member eq x xs then xs else x : xs);

ta_make_code ::
  forall a b c.
    (Compare a, Compare_order b,
      Compare c) => Rbta a () ->
                      Rbta (Ta_rule b c) () ->
                        [(b, b)] ->
                          (Rbta a (),
                            (Rbta (Ta_rule b c) (),
                              ([(b, b)],
                                (Rbta b (),
                                  (Rbta (c, Nat) (Rbta ([b], b) ()),
                                    (Bool,
                                      (b -> Rbta b (), b -> Rbta b ())))))));
ta_make_code f r e =
  let {
    a = ta_idx_rhs_init_code (is_Nil e) r
          (\ xi -> impl_of (memo_rbt_rtrancl e xi));
    (ab, (aa, ba)) = a;
  } in (f, (r, (e, (ba, (ab, (aa, ((\ s -> impl_of (memo_rbt_rtrancl e s)),
                                    (\ s ->
                                      impl_of
(memo_rbt_rtrancl
  (gen_image foldli []
    (glist_insert (prod_eq (comp2eq compare_res) (comp2eq compare_res)))
    (\ xc -> (snd xc, fst xc)) e)
  s)))))))));

ta_eps_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> c;
ta_eps_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = e;

is_None :: forall a. Maybe a -> Bool;
is_None a = (case a of {
              Nothing -> True;
              Just _ -> False;
            });

ta_only_res_wits_code ::
  forall a b c d.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            Rbta a (Term c d) ->
                              (Rbta a (),
                                (Rbta (Ta_rule a b) (),
                                  ([(a, a)],
                                    (Rbta a (),
                                      (Rbta (b, Nat) (Rbta ([a], a) ()),
(Bool, (a -> Rbta a (), a -> Rbta a ())))))));
ta_only_res_wits_code a b =
  let {
    xb = gen_filter (map_iterator_dom . rm_iterateoi) Emptya
           (\ k -> rbt_comp_insert compare k ())
           (\ xb -> not (is_None (rbt_comp_lookup compare b xb)))
           (ta_final_impla a);
    xc = gen_filter (map_iterator_dom . rm_iterateoi) Emptya
           (\ k -> rbt_comp_insert compare_ta_rule k ())
           (\ xc ->
             list_all_rec (\ xd -> not (is_None (rbt_comp_lookup compare b xd)))
               (r_lhs_states xc))
           (ta_rules_impla a);
    aa = filter (\ xd -> not (is_None (rbt_comp_lookup compare b (fst xd))))
           (ta_eps_impl a);
  } in ta_make_code xb xc aa;

ta_only_prs_wits_code ::
  forall a b c d.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            Rbta a (Ctxt c d) ->
                              (Rbta a (),
                                (Rbta (Ta_rule a b) (),
                                  ([(a, a)],
                                    (Rbta a (),
                                      (Rbta (b, Nat) (Rbta ([a], a) ()),
(Bool, (a -> Rbta a (), a -> Rbta a ())))))));
ta_only_prs_wits_code a b =
  let {
    xb = gen_filter (map_iterator_dom . rm_iterateoi) Emptya
           (\ k -> rbt_comp_insert compare k ())
           (\ xb -> not (is_None (rbt_comp_lookup compare b xb)))
           (ta_final_impla a);
    xc = gen_filter (map_iterator_dom . rm_iterateoi) Emptya
           (\ k -> rbt_comp_insert compare_ta_rule k ())
           (\ xc -> not (is_None (rbt_comp_lookup compare b (r_rhs xc))))
           (ta_rules_impla a);
    aa = filter (\ xd -> not (is_None (rbt_comp_lookup compare b (snd xd))))
           (ta_eps_impl a);
  } in ta_make_code xb xc aa;

next_res_wit_code ::
  forall a b c.
    (Compare a,
      Compare b) => Rbta (Ta_rule a b) () ->
                      Rbta a (Term b c) -> Maybe (a, Term b c);
next_res_wit_code r m =
  (map_iterator_dom . rm_iterateoi) r is_None
    (\ x _ ->
      let {
        (TA_rule xb xc xd) = x;
      } in bind (mapMa (rbt_comp_lookup compare m) xc)
             (\ xe -> Just (xd, Fun xb xe)))
    Nothing;

res_wits_code ::
  forall a b c.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            Rbta a (Term b c);
res_wits_code tAi =
  let {
    x = (ta_rules_impla tAi, Emptya);
    (_, b) =
      while (\ (xc, _) ->
              not (gen_isEmptya (gen_balla (map_iterator_dom . rm_iterateoi))
                    xc))
        (\ (a, b) ->
          (case next_res_wit_code a b of {
            Nothing -> (Emptya, b);
            Just (aa, ba) ->
              let {
                xd = ta_eps_cl_impl tAi aa;
                xe = update_all_code b xd ba;
                xf = gen_filter (map_iterator_dom . rm_iterateoi) Emptya
                       (\ k -> rbt_comp_insert compare_ta_rule k ())
                       (\ xi ->
                         not (case rbt_comp_lookup compare xd (r_rhs xi) of {
                               Nothing -> False;
                               Just _ -> True;
                             }))
                       a;
              } in (xf, xe);
          }))
        x;
  } in b;

ta_eps_icl_impl ::
  forall a b c d e f g h i. (a, (b, (c, (d, (e, (f, (g, h -> i))))))) -> h -> i;
ta_eps_icl_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) q = eicl q;

prs_wits_code ::
  forall a b.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            Rbta a (Ctxt b a);
prs_wits_code tAi =
  let {
    x = update_all_code Emptya
          (union_image_rs_code (ta_final_impla tAi) (ta_eps_icl_impl tAi)) Hole;
    xa = (False, (ta_rules_impla tAi, x));
    (_, (_, ba)) =
      while (\ (xd, (_, _)) -> not xd)
        (\ (_, (aa, ba)) ->
          (map_iterator_dom . rm_iterateoi) aa (\ _ -> True)
            (\ xc (ab, (ac, bc)) ->
              (case rbt_comp_lookup compare bc (r_rhs xc) of {
                Nothing -> (ab, (rbt_comp_insert compare_ta_rule xc () ac, bc));
                Just xd ->
                  (False,
                    (ac, let {
                           (TA_rule xl xm _) = xc;
                         } in rec_list (\ _ xp _ _ _ -> xp)
                                (\ xo xp xq xr xs xt xu xv ->
                                  let {
                                    xw = update_all_code xs
   (ta_eps_icl_impl xr (the_Var xo)) (ctxt_compose xt (More xu xv Hole xp));
                                  } in xq xr xw xt xu (xv ++ [xo]))
                                (map Var xm) tAi bc xd xl []));
              }))
            (True, (Emptya, ba)))
        xa;
  } in ba;

trim_ta_wits_code ::
  forall a b c.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            ((Rbta a (),
                               (Rbta (Ta_rule a b) (),
                                 ([(a, a)],
                                   (Rbta a (),
                                     (Rbta (b, Nat) (Rbta ([a], a) ()),
                                       (Bool,
 (a -> Rbta a (), a -> Rbta a ()))))))),
                              (Rbta a (Term b c), Rbta a (Ctxt b a)));
trim_ta_wits_code tAi = let {
                          x = res_wits_code tAi;
                          xa = ta_only_res_wits_code tAi x;
                          xb = prs_wits_code xa;
                          xc = ta_only_prs_wits_code xa xb;
                        } in (xc, (x, xb));

is_coh_final_code ::
  forall a b c d e.
    (Compare a) => Rbta a () ->
                     Rbta a (Rbta a (Term b c, Term d e)) ->
                       Maybe (Term b c, Term d e);
is_coh_final_code fin rel =
  rm_iterateoi rel is_None
    (\ x _ ->
      let {
        (a, b) = x;
      } in (if (case rbt_comp_lookup compare fin a of {
                 Nothing -> False;
                 Just _ -> True;
               })
             then rm_iterateoi b is_None
                    (\ xa _ ->
                      let {
                        (aa, (ab, bb)) = xa;
                      } in (if (case rbt_comp_lookup compare fin aa of {
                                 Nothing -> False;
                                 Just _ -> True;
                               })
                             then Nothing else Just (ab, bb)))
                    Nothing
             else Nothing))
    Nothing;

map_add2_code ::
  forall a b c.
    (Compare a,
      Compare b) => Rbta a (Rbta b c) -> Rbta a (Rbta b c) -> Rbta a (Rbta b c);
map_add2_code m1 m2 =
  rm_iterateoi m2 (\ _ -> True)
    (\ x sigma ->
      let {
        (a, b) = x;
      } in (case rbt_comp_lookup compare sigma a of {
             Nothing -> rbt_comp_insert compare a b sigma;
             Just xc ->
               rbt_comp_insert compare a
                 (rbt_comp_union_with_key compare (\ _ _ rv -> rv) xc b) sigma;
           }))
    m1;

ta_check_comcoh_code ::
  forall a b c d.
    (Compare_order a, Compare_order b, Compare c,
      Eq c) => (Rbta a (),
                 (Rbta (Ta_rule a b) (),
                   ([(a, a)],
                     (Rbta a (),
                       (Rbta (b, Nat) (Rbta ([a], a) ()),
                         (Bool, (a -> Rbta a (), a -> Rbta a ()))))))) ->
                 Rbta (Term b c, Term b c) () -> Maybe (Term b d, Term b d);
ta_check_comcoh_code ta r =
  let {
    a = trim_ta_wits_code ta;
    (ab, (aa, ba)) = a;
    xa = is_compatible_code ab r;
    xb = (\ xf xg ->
           subst_apply_term
             (ctxt_apply_term (the (rbt_comp_lookup compare ba xf)) xg)
             (\ xh -> the (rbt_comp_lookup compare aa xh)));
  } in (case xa of {
         Inl (aba, (ac, bc)) -> Just (xb aba ac, xb aba bc);
         Inr ra ->
           (case let {
                   (aba, bb) =
                     while (\ ac ->
                             (case ac of {
                               (Inl _, _) -> False;
                               (Inr xk, _) ->
                                 not (gen_isEmpty (gen_ball rm_iterateoi) xk);
                             }))
                       (\ (aba, bb) ->
                         let {
                           xd = (map_iterator_dom . rm_iterateoi)
                                  (ta_rules_impla ab) is_Inr
                                  (\ xd sigma ->
                                    let {
                                      (TA_rule xe y z) = xd;
                                    } in foldli (upt zero_nat (size_list y))
   is_Inr
   (\ xf s ->
     let {
       xg = nth y xf;
     } in (case rbt_comp_lookup compare (projr aba) xg of {
            Nothing -> s;
            Just xh ->
              rm_iterateoi xh is_Inr
                (\ xi sigmaa ->
                  let {
                    (ac, (ad, bd)) = xi;
                    xj = map Var (take xf y);
                    xk = map Var (drop (suc xf) y);
                    xl = Fun xe (xj ++ ad : xk);
                    xm = Fun xe (xj ++ bd : xk);
                    xn = list_update y xf ac;
                    xo = rule_filter_opt_code ab xe xn;
                  } in (if gen_isEmptya
                             (gen_balla (map_iterator_dom . rm_iterateoi)) xo
                         then Inl (z, (xl, xm))
                         else let {
                                xp = gen_filter
                                       (map_iterator_dom . rm_iterateoi) Emptya
                                       (\ k -> rbt_comp_insert compare k ())
                                       (\ yd ->
 is_None
   (bind (rbt_comp_lookup compare bb z)
     (\ ye -> rbt_comp_lookup compare ye yd)))
                                       xo;
                              } in (if gen_isEmptya
 (gen_balla (map_iterator_dom . rm_iterateoi)) xp
                                     then sigmaa
                                     else Inr
    (update_all2_code (projr sigmaa) (rbt_comp_insert compare z () Emptya) xp
      (xl, xm)))))
                s;
          }))
   sigma)
                                  (Inr Emptya);
                         } in (if is_Inr xd
                                then (xd, map_add2_code bb (projr xd))
                                else (xd, bb)))
                       (Inr ra, ra);
                 } in (if is_Inr aba then Inr bb else aba)
             of {
             Inl (aba, (ac, bc)) -> Just (xb aba ac, xb aba bc);
             Inr raa ->
               (case is_coh_final_code (ta_final_impla ab) raa of {
                 Nothing -> Nothing;
                 Just (aba, bb) ->
                   Just (subst_apply_term aba
                           (\ xk -> the (rbt_comp_lookup compare aa xk)),
                          subst_apply_term bb
                            (\ xk -> the (rbt_comp_lookup compare aa xk)));
               });
           });
       });

rep_ta_code ::
  forall b a.
    (Compare_order b,
      Compare_order a) => Ta_code b a ->
                            (Rbta b (),
                              (Rbta (Ta_rule b a) (),
                                ([(b, b)],
                                  (Rbta b (),
                                    (Rbta (a, Nat) (Rbta ([b], b) ()),
                                      (Bool,
(b -> Rbta b (), b -> Rbta b ())))))));
rep_ta_code (Abs_ta_code x) = x;

check_comcoh_wit ::
  forall a b c.
    (Compare_order a, Compare_order b, Compare_order c,
      Eq c) => Ta_code a b ->
                 Rbt (Term b c, Term b c) () -> Maybe (Term b c, Term b c);
check_comcoh_wit x xa = ta_check_comcoh_code (rep_ta_code x) (impl_of xa);

check_comcoh_wit_ls ::
  forall a b c.
    (Compare_order a, Compare_order b, Compare_order c,
      Eq c) => Ta_code a b ->
                 [(Term b c, Term b c)] -> Maybe (Term b c, Term b c);
check_comcoh_wit_ls ta r =
  check_comcoh_wit ta (g_from_list_dflt_basic_oops_rm_basic_ops r);

ta_make_ls_code ::
  forall a b.
    (Compare_order a,
      Compare_order b) => [a] ->
                            [Ta_rule a b] ->
                              [(a, a)] ->
                                (Rbta a (),
                                  (Rbta (Ta_rule a b) (),
                                    ([(a, a)],
                                      (Rbta a (),
(Rbta (b, Nat) (Rbta ([a], a) ()),
  (Bool, (a -> Rbta a (), a -> Rbta a ())))))));
ta_make_ls_code =
  (\ x xa xb ->
    ta_make_code (gen_set Emptya (\ k -> rbt_comp_insert compare k ()) x)
      (gen_set Emptya (\ k -> rbt_comp_insert compare_ta_rule k ()) xa)
      (gen_set []
        (glist_insert (prod_eq (comp2eq compare_res) (comp2eq compare_res)))
        xb));

make_ls ::
  forall a b.
    (Compare_order a,
      Compare_order b) => [a] -> [Ta_rule a b] -> [(a, a)] -> Ta_code a b;
make_ls x xa xb = Abs_ta_code (ta_make_ls_code x xa xb);

ta_code_make_impl ::
  forall a b.
    (Compare_order a, Compare_order b) => Tree_automaton a b -> Ta_code a b;
ta_code_make_impl (Tree_Automaton fin rs eps) = make_ls fin rs eps;

ta_rhs_states ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b () -> Set a;
ta_rhs_states ta =
  sup_set (image r_rhs (ta_rules ta))
    (compute_trancl (image r_rhs (ta_rules ta)) (ta_eps ta));

initial_rel ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) -> Set (a, Set a);
initial_rel ta r =
  let {
    rhs = ta_rhs_states ta;
    match = ta_matcha ta rhs;
    analyze_rule =
      (\ (l, ra) ->
        let {
          _ = vars_term l;
        } in sup_seta
               (image
                 (\ sigma ->
                   let {
                     qr = ta_res ta (map_term (\ x -> x) (fun_of sigma) ra);
                   } in image (\ q -> (q, qr))
                          (ta_res ta (map_term (\ x -> x) (fun_of sigma) l)))
                 (match l)));
  } in sup_seta (image analyze_rule r);

initial_relation ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) -> Maybe (Set (a, a));
initial_relation ta r =
  let {
    q_qs = initial_rel ta r;
  } in (if member bot_set (image snd q_qs) then Nothing
         else Just (sup_seta
                     (image (\ (q, a) -> image (\ aa -> (q, aa)) a) q_qs)));

decide_coherent_compatible_main ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) ->
                         (Maybe (Set (a, a)) -> Maybe (Set (a, a))) -> Bool;
decide_coherent_compatible_main ta r normalizer =
  (case normalizer (initial_relation ta r) of {
    Nothing -> False;
    Just rel -> less_eq_set (imagea rel (ta_final ta)) (ta_final ta);
  });

coherent_rule ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b,
      Eq b) => Set (a, a) ->
                 Set (Ta_rule a b) -> Ta_rule a b -> Set (a, Maybe a);
coherent_rule rel rules (TA_rule f qs q) =
  foldr (sup_set .
          (\ i ->
            let {
              qi = nth qs i;
              qi_s = image snd (filtera (\ qq -> fst qq == qi) rel);
              a = sup_seta
                    (image
                      (\ qia ->
                        let {
                          qsa = list_update qs i qia;
                          rls = filtera
                                  (\ (TA_rule g qsaa _) ->
                                    g == f && qsaa == qsa)
                                  rules;
                        } in (if less_eq_set rls
                                   (set_empty (of_phantom set_impl_ta_rule))
                               then inserta Nothing bot_set
                               else image (Just . r_rhs) rls))
                      qi_s);
            } in image (\ aa -> (q, aa)) a))
    (upt zero_nat (size_list qs)) bot_set;

new_states ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set (a, a) -> Set (a, Maybe a);
new_states ta rel = let {
                      rules = ta_rules ta;
                    } in sup_seta (image (coherent_rule rel rules) rules);

normalize_main ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b,
      Eq b) => Ta_ext a b () -> Set (a, a) -> Set (a, a) -> Maybe (Set (a, a));
normalize_main ta rel accu =
  let {
    new = new_states ta rel;
  } in (if member Nothing (image snd new) then Nothing
         else let {
                new_rel = image (\ (x, y) -> (x, the y)) new;
                new_accu = sup_set accu rel;
                todo = minus_set new_rel new_accu;
              } in (if less_eq_set todo bot_set then Just new_accu
                     else normalize_main ta todo new_accu));

normalizea ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b,
      Eq b) => Ta_ext a b () -> Maybe (Set (a, a)) -> Maybe (Set (a, a));
normalizea ta (Just rel) = normalize_main ta rel bot_set;
normalizea ta Nothing = Nothing;

decide_coherent_compatible ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
decide_coherent_compatible ta r =
  decide_coherent_compatible_main ta r (normalizea ta);

closed_under_rewriting ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Default b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
closed_under_rewriting ta r = decide_coherent_compatible (trim_ta ta) r;

ta_det_impl :: forall a b c d e f g. (a, (b, (c, (d, (e, (f, g)))))) -> f;
ta_det_impl (f, (r, (e, (rhs, (idx, (det, x)))))) = det;

deta :: forall a b. (Compare_order a, Compare_order b) => Ta_code a b -> Bool;
deta x = ta_det_impl (rep_ta_code x);

sorted_ps_ta ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Linorder a, Set_impl a, Ceq b, Ccompare b, Compare b, Eq b,
      Set_impl b) => Ta_ext a b () -> Tree_automaton [a] b;
sorted_ps_ta ta =
  Tree_Automaton
    (sorted_list_of_set (image sorted_list_of_set (ta_final (ps_ta ta))))
    (sorted_list_of_set
      (image
        (\ (TA_rule g qs q) ->
          TA_rule g (map sorted_list_of_set qs) (sorted_list_of_set q))
        (ta_rules (ps_ta ta))))
    [];

tree_aut_trs_closed ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a, Showa a, Ceq b, Ccompare b, Compare_order b, Default b, Eq b,
      Set_impl b, Showa b, Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c,
      Compare_order c, Eq c, Set_impl c,
      Showa c) => Tree_automaton a b ->
                    Ta_relation a ->
                      [(Term b c, Term b c)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
tree_aut_trs_closed ta rel r =
  bindb (check_varcond_subset r)
    (\ _ ->
      catch_errora
        (case rel of {
          Decision_Proc_Old ->
            bindb (catch_errora (check_det ta)
                    (\ x ->
                      Inl (shows_prec_list zero_nat
                             ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', ' ', 'p',
                               'r', 'o', 'c', 'e', 'd', 'u', 'r', 'e', ' ', 'r',
                               'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'd', 'e',
                               't', '.', ' ', 'T', 'A', ' ', 'a', 's', ' ', 'i',
                               'n', 'p', 'u', 't'] .
                            shows_nl . x)))
              (\ _ ->
                check (closed_under_rewriting (ta_of_ta ta) (set r))
                  (shows_prec_list zero_nat
                    ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l',
                      'o', 's', 'e', 'd', ' ', 'u', 'n', 'd', 'e', 'r', ' ',
                      'r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g']));
          Decision_Proc ->
            let {
              tc = ta_code_make_impl ta;
            } in (if deta tc
                   then (case check_comcoh_wit_ls tc r of {
                          Nothing -> Inr ();
                          Just (wl, wr) ->
                            Inl (shows_prec_list zero_nat
                                   ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't',
                                     ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ',
                                     'u', 'n', 'd', 'e', 'r', ' ', 'r', 'e',
                                     'w', 'r', 'i', 't', 'i', 'n', 'g'] .
                                  shows_nl .
                                    shows_term (shows_prec zero_nat)
                                      (shows_prec zero_nat) wl .
                                      shows_prec_list zero_nat
[' ', 'i', 's', ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', ' ', 'b', 'y', ' ',
  'T', 'A', ' ', 'a', 'n', 'd', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', 's',
  ' ', 't', 'o'] .
shows_nl .
  shows_term (shows_prec zero_nat) (shows_prec zero_nat) wr .
    shows_prec_list zero_nat
      [' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
        'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'T', 'A']);
                        })
                   else let {
                          tca = ta_code_make_impl
                                  (sorted_ps_ta (trim_ta (ta_of_ta ta)));
                        } in (case check_comcoh_wit_ls tca r of {
                               Nothing -> Inr ();
                               Just (wl, wr) ->
                                 Inl (shows_prec_list zero_nat
['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd',
  ' ', 'u', 'n', 'd', 'e', 'r', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'i', 'n',
  'g'] .
                                       shows_nl .
 shows_term (shows_prec zero_nat) (shows_prec zero_nat) wl .
   shows_prec_list zero_nat
     [' ', 'i', 's', ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', ' ', 'b', 'y',
       ' ', 'T', 'A', ' ', 'a', 'n', 'd', ' ', 'r', 'e', 'w', 'r', 'i', 't',
       'e', 's', ' ', 't', 'o'] .
     shows_nl .
       shows_term (shows_prec zero_nat) (shows_prec zero_nat) wr .
         shows_prec_list zero_nat
           [' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'n', 'o', 't',
             ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd', ' ', 'b', 'y', ' ',
             'T', 'A']);
                             }));
          Id_Relation ->
            bindb (generate_ta_cond ta rel)
              (\ taa ->
                bindb (catch_errora
                        (if isOK (check_left_linear_trs r) then Inr ()
                          else check_det ta)
                        (\ x ->
                          Inl (shows_prec_list zero_nat
                                 ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                   ' ', 'e', 'n', 's', 'u', 'r', 'e', ' ', 'l',
                                   'e', 'f', 't', '-', 'l', 'i', 'n', 'e', 'a',
                                   'r', 'i', 't', 'y', ' ', 'o', 'r', ' ', 'd',
                                   'e', 't', 'e', 'r', 'm', 'i', 'n', 'i', 's',
                                   'm'] .
                                shows_nl . x)))
                  (\ _ ->
                    catch_errora
                      (state_compatible_eff_list taa (rel_checker rel) r)
                      (\ x ->
                        Inl (let {
                               (lr, (lrq, q)) = x;
                             } in shows_prec_list zero_nat
                                    ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o',
                                      't', ' ', 'c', 'o', 'm', 'p', 'a', 't',
                                      'i', 'b', 'l', 'e', ' ', 'w', 'i', 't',
                                      'h', ' ', 'R'] .
                                    shows_nl .
                                      shows_prec_list zero_nat
['f', 'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
shows_rule (shows_prec zero_nat) (shows_prec zero_nat) [' ', '-', '>', ' '] lr .
  shows_nl .
    shows_prec_list zero_nat
      ['w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'i', 'n', 's', 't', 'a',
        'n', 't', 'i', 'a', 't', 'e', 'd', ' ', 'b', 'y', ' ', 's', 't', 'a',
        't', 'e', 's', ' ', 't', 'o', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] lrq .
        shows_nl .
          shows_prec_list zero_nat
            ['t', 'h', 'e', ' ', 's', 't', 'a', 't', 'e', ' '] .
            shows_prec zero_nat q .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'r', 'e', 'a',
                  'c', 'h', 'a', 'b', 'l', 'e', ' ', 'f', 'r', 'o', 'm', ' ',
                  't', 'h', 'e', ' ', 'l', 'h', 's'] .
                shows_nl))));
          Some_Relation _ ->
            bindb (generate_ta_cond ta rel)
              (\ taa ->
                bindb (catch_errora
                        (if isOK (check_left_linear_trs r) then Inr ()
                          else check_det ta)
                        (\ x ->
                          Inl (shows_prec_list zero_nat
                                 ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                   ' ', 'e', 'n', 's', 'u', 'r', 'e', ' ', 'l',
                                   'e', 'f', 't', '-', 'l', 'i', 'n', 'e', 'a',
                                   'r', 'i', 't', 'y', ' ', 'o', 'r', ' ', 'd',
                                   'e', 't', 'e', 'r', 'm', 'i', 'n', 'i', 's',
                                   'm'] .
                                shows_nl . x)))
                  (\ _ ->
                    catch_errora
                      (state_compatible_eff_list taa (rel_checker rel) r)
                      (\ x ->
                        Inl (let {
                               (lr, (lrq, q)) = x;
                             } in shows_prec_list zero_nat
                                    ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o',
                                      't', ' ', 'c', 'o', 'm', 'p', 'a', 't',
                                      'i', 'b', 'l', 'e', ' ', 'w', 'i', 't',
                                      'h', ' ', 'R'] .
                                    shows_nl .
                                      shows_prec_list zero_nat
['f', 'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
shows_rule (shows_prec zero_nat) (shows_prec zero_nat) [' ', '-', '>', ' '] lr .
  shows_nl .
    shows_prec_list zero_nat
      ['w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'i', 'n', 's', 't', 'a',
        'n', 't', 'i', 'a', 't', 'e', 'd', ' ', 'b', 'y', ' ', 's', 't', 'a',
        't', 'e', 's', ' ', 't', 'o', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] lrq .
        shows_nl .
          shows_prec_list zero_nat
            ['t', 'h', 'e', ' ', 's', 't', 'a', 't', 'e', ' '] .
            shows_prec zero_nat q .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'r', 'e', 'a',
                  'c', 'h', 'a', 'b', 'l', 'e', ' ', 'f', 'r', 'o', 'm', ' ',
                  't', 'h', 'e', ' ', 'l', 'h', 's'] .
                shows_nl))));
        })
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                   ' ', 'e', 'n', 's', 'u', 'r', 'i', 'n', 'g', ' ', '(', 's',
                   't', 'a', 't', 'e', '-', ')', 'c', 'o', 'm', 'p', 'a', 't',
                   'i', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'o', 'f', ' ', 'T',
                   'R', 'S', ' ', 'w', 'i', 't', 'h', ' ', 'T', 'A', ' '] .
                shows_nl .
                  shows_prec_tree_automaton zero_nat ta . shows_nl . x)));

intersect_ta ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Set_impl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Eq c,
      Set_impl c) => Ta_ext a b () -> Ta_ext c b () -> Ta_ext (a, c) b ();
intersect_ta tA1 tA2 = prod_ta tA1 tA2 (productc (ta_final tA1) (ta_final tA2));

ta_contains_nf ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare b, Default b,
      Eq b, Set_impl b, Compare c,
      Eq c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
ta_contains_nf ta r =
  not (ta_empty (intersect_ta (ta_nf (image fst r) (ta_syms ta)) ta));

check_trs_not_wn ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b, Showa b,
      Card_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare_order c, Eq c,
      Set_impl c,
      Showa c) => [(Term a b, Term a b)] ->
                    Not_wn_ta_prf a c ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_not_wn r (Not_wn_ta_prf ta rel) =
  bindb (check_varcond_subset r)
    (\ _ ->
      bindb (check_left_linear_trs r)
        (\ _ ->
          let {
            tA_trim = trim_ta (ta_of_ta ta);
          } in bindb (check (not (ta_empty tA_trim))
                       (shows_prec_list zero_nat
                         ['T', 'A', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't',
                           'y']))
                 (\ _ ->
                   bindb (tree_aut_trs_closed ta rel r)
                     (\ _ ->
                       check (not (ta_contains_nf tA_trim (set r)))
                         (shows_prec_list zero_nat
                           ['T', 'A', ' ', 'a', 'c', 'c', 'e', 'p', 't', 's',
                             ' ', 's', 'o', 'm', 'e', ' ', 'n', 'o', 'r', 'm',
                             'a', 'l', ' ', 'f', 'o', 'r', 'm'])))));

check_not_wn_ta_prf ::
  forall a b c d e.
    (Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare_order b,
      Default b, Eq b, Set_impl b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showa c,
      Card_UNIV e, Cenum e, Ceq e, Cproper_interval e, Compare_order e, Eq e,
      Set_impl e,
      Showa e) => Tp_ops_ext a b c d ->
                    a -> Not_wn_ta_prf b e ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_not_wn_ta_prf i tp prf =
  let {
    r = rulesd i tp;
  } in bindb (check (null (qb i tp))
               (shows_prec_list zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'i', 's', ' ',
                   'u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ',
                   'f', 'o', 'r', ' ', 't', 'r', 'e', 'e', ' ', 'a', 'u', 't',
                   'o', 'm', 'a', 't', 'a', ' ', 'b', 'a', 's', 'e', 'd', ' ',
                   'n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                   'o', 'n']))
         (\ _ -> check_trs_not_wn r prf);

check_dps ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (a -> a) ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] -> Sum (Term a b, Term a b) ();
check_dps unshp r p =
  let {
    d = defined_list r;
  } in catch_errora
         (forallM
           (\ x ->
             (if let {
                   (ll, rr) = x;
                 } in not (is_Var rr) &&
                        not (membera d (the (root rr))) &&
                          any (\ (l, ra) ->
                                equal_term l (sharp_term unshp ll) &&
                                  (equal_term ra (sharp_term unshp rr) ||
                                    supt_impl ra (sharp_term unshp rr)))
                            r
               then Inr () else Inl x))
           p)
         (\ x -> Inl (snd x));

unsharp :: forall a b. Lab a b -> Lab a b;
unsharp (Sharp f) = f;
unsharp (Lab v va) = Lab v va;
unsharp (FunLab v va) = FunLab v va;
unsharp (UnLab v) = UnLab v;

dp_trans_nontermination_tt ::
  forall a b c d e f g.
    (Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => Tp_ops_ext a (Lab b c) d e ->
                    Dpp_ops_ext f (Lab b c) d g ->
                      a -> Dp_trans_nontermination_tt_prf b c d ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) f;
dp_trans_nontermination_tt i j tp (DP_trans_nontermination_tt_prf p) =
  let {
    r = rulesd i tp;
    q = qb i tp;
  } in bindb (check (null q || not (nfsb i tp))
               (shows_prec_list zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ', 'a',
                   'n', 'd', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
                   'r', 'm', ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't',
                   'i', 'o', 'n', 's', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm']))
         (\ _ ->
           bindb (catch_errora (check_dps unsharp r p)
                   (\ x ->
                     Inl (shows_prec_list zero_nat
                            ['p', 'r', 'o', 'b', 'l', 'e', 'm', 'a', 't', 'i',
                              'c', ' ', 'r', 'u', 'l', 'e', ':', ' '] .
                           shows_rule (shows_prec_lab zero_nat)
                             (shows_prec zero_nat) [' ', '-', '>', ' '] x)))
             (\ _ -> Inr (mkd j False False p [] q [] r)));

switch_termination_tt ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_termination_tt i joins_i tp =
  let {
    r = rulesd i tp;
    q = qb i tp;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list zero_nat
                                  ['r', 'u', 'l', 'e', 's', ' ', 'a', 'r', 'e',
                                    ' ', 'n', 'o', 't', ' ', 'o', 'v', 'e', 'r',
                                    'l', 'a', 'y']))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_wf_trs r)
                        (\ _ ->
                          bindb (check_critical_pairs r cp joins_i)
                            (\ _ ->
                              catch_errora (check_NF_trs_subset r q)
                                (\ x ->
                                  Inl (shows_prec_term zero_nat x .
shows_prec_list zero_nat
  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm',
    'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ', 'w', '.', 'r', '.', 't', '.', ' ',
    'R'])))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsb i tp) [] r []);
       });

q_increase_nonterm_trs ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Q_increase_nonterm_trs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_increase_nonterm_trs i dpp (Q_increase_nonterm_trs_prf q) =
  let {
    r = rulesd i dpp;
    qa = qb i dpp;
    nfs = nfsb i dpp;
  } in Inr (mkc i nfs (list_union qa q) r []);

shows_srs_rule ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_srs_rule (l, r) =
  shows_prec zero_nat l .
    shows_prec_list zero_nat [' ', '-', '>', ' '] . shows_prec zero_nat r;

shows_pat ::
  forall a b c d e f g h i j.
    (Showa a, Showa b, Showa c, Showa d, Showa e, Showa f, Showa g, Showa h,
      Showa i,
      Showa j) => ((a, ((b, (c, d)), e)), (f, ((g, (h, i)), j))) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_pat (p1, p2) =
  shows_p p1 . shows_prec_list zero_nat [' ', '-', '>', '+', ' '] . shows_p p2;

normalize_wp ::
  forall a.
    (Eq a) => ([a], ((Nat, (Nat, [a])), [a])) ->
                ([a], ((Nat, (Nat, [a])), [a]));
normalize_wp x =
  let {
    (l, (aa, r)) = x;
    (f, aaa) = aa;
  } in (if equal_nat f zero_nat
         then let {
                (aab, m) = aaa;
              } in (if equal_nat aab zero_nat
                     then ([], ((zero_nat, (zero_nat, [])), l ++ r))
                     else normalize_wp
                            (l ++ concat
                                    (replicate (suc (minus_nat aab one_nat)) m),
                              ((zero_nat, (zero_nat, m)), r)))
         else (if equal_nat (minus_nat f one_nat) zero_nat
                then let {
                       (aab, m) = aaa;
                     } in (if equal_nat aab zero_nat
                            then (case m of {
                                   [] -> ([],
   ((zero_nat, (zero_nat, [])), l ++ r));
                                   a : ma ->
                                     (case r of {
                                       [] ->
 (l, ((suc zero_nat, (zero_nat, a : ma)), []));
                                       b : ra ->
 (if a == b
   then normalize_wp (l ++ [b], ((suc zero_nat, (zero_nat, ma ++ [b])), ra))
   else (l, ((suc zero_nat, (zero_nat, a : ma)), b : ra)));
                                     });
                                 })
                            else normalize_wp
                                   (l ++ concat
   (replicate (suc (minus_nat aab one_nat)) m),
                                     ((suc zero_nat, (zero_nat, m)), r)))
                else let {
                       (aab, m) = aaa;
                     } in (if equal_nat aab zero_nat
                            then (case m of {
                                   [] -> ([],
   ((zero_nat, (zero_nat, [])), l ++ r));
                                   vb : vba ->
                                     normalize_wp
                                       (l,
 ((suc zero_nat,
    (zero_nat,
      concat
        (replicate (suc (suc (minus_nat (minus_nat f one_nat) one_nat)))
          (vb : vba)))),
   r));
                                 })
                            else normalize_wp
                                   (l ++ concat
   (replicate (suc (minus_nat aab one_nat)) m),
                                     ((suc
 (suc (minus_nat (minus_nat f one_nat) one_nat)),
(zero_nat, m)),
                                       r)))));

word_pat_equiv ::
  forall a.
    (Eq a) => ([a], ((Nat, (Nat, [a])), [a])) ->
                ([a], ((Nat, (Nat, [a])), [a])) -> Bool;
word_pat_equiv wp1 wp2 = wp1 == wp2 || normalize_wp wp1 == normalize_wp wp2;

shows_oc ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_oc (l, r) =
  shows_prec zero_nat l .
    shows_prec_list zero_nat [' ', '-', '>', '+', ' '] . shows_prec zero_nat r;

check_step ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Dp_proof_step a ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_step r step =
  (case step of {
    OC1 uv _ ->
      check (member uv r)
        (shows_srs_rule uv .
          shows_prec_list zero_nat
            [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'o', 'r',
              'i', 'g', 'i', 'n', 'a', 'l', ' ', 'r', 'u', 'l', 'e']);
    OC2 oc_new oc1 oc2 t x l ->
      let {
        (wl, tr) = oc_new;
        (w, tx) = oc1;
        (xl, ra) = oc2;
      } in catch_errora
             (bindb
               (check (xl == x ++ l)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x', 'l', ' ',
                     '!', '=', ' ', 'x', ' ', 'l']))
               (\ _ ->
                 bindb (check (tx == t ++ x)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                             'x', ' ', '!', '=', ' ', 't', ' ', 'x']))
                   (\ _ ->
                     bindb (check (wl == w ++ l)
                             (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'w', 'l', ' ', '!', '=', ' ', 'w', ' ', 'l']))
                       (\ _ ->
                         check (tr == t ++ ra)
                           (shows_prec_list zero_nat
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                               'r', ' ', '!', '=', ' ', 't', ' ', 'r'])))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '2', ' ', 'o',
                        'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC2p oc_new oc1 oc2 x t l ->
      let {
        (lw, rt) = oc_new;
        (w, xt) = oc1;
        (lx, ra) = oc2;
      } in catch_errora
             (bindb
               (check (lx == l ++ x)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'x', ' ',
                     '!', '=', ' ', 'l', ' ', 'x']))
               (\ _ ->
                 bindb (check (lw == l ++ w)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l',
                             'w', ' ', '!', '=', ' ', 'l', ' ', 'w']))
                   (\ _ ->
                     bindb (check (rt == ra ++ t)
                             (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'r', 't', ' ', '!', '=', ' ', 'r', ' ', 't']))
                       (\ _ ->
                         check (xt == x ++ t)
                           (shows_prec_list zero_nat
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x',
                               't', ' ', '!', '=', ' ', 'x', ' ', 't'])))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '2', '\'', ' ',
                        'o', 'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC3 oc_new oc1 oc2 t1 t2 ->
      let {
        (w, t1rt2) = oc_new;
        (wa, t1xt2) = oc1;
        (x, ra) = oc2;
      } in catch_errora
             (bindb
               (check (t1rt2 == t1 ++ ra ++ t2)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't', '1', '_',
                     'r', '_', 't', '2', ' ', '!', '=', ' ', 't', '1', ' ', 'r',
                     ' ', 't', '2']))
               (\ _ ->
                 bindb (check (t1xt2 == t1 ++ x ++ t2)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                             '1', '_', 'x', '_', 't', '2', ' ', '!', '=', ' ',
                             't', '1', ' ', 'x', ' ', 't', '2']))
                   (\ _ ->
                     check (w == wa)
                       (shows_prec_list zero_nat
                         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'w', ' ',
                           'd', 'i', 'f', 'f', 'e', 'r', 's']))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '3', ' ', 'o',
                        'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC3p oc_new oc1 oc2 t1 t2 ->
      let {
        (t1wt2, ra) = oc_new;
        (t1xt2, raa) = oc1;
        (w, x) = oc2;
      } in catch_errora
             (bindb
               (check (t1wt2 == t1 ++ w ++ t2)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't', '1', '_',
                     'w', '_', 't', '2', ' ', '!', '=', ' ', 't', '1', ' ', 'w',
                     ' ', 't', '2']))
               (\ _ ->
                 bindb (check (t1xt2 == t1 ++ x ++ t2)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                             '1', '_', 'x', '_', 't', '2', ' ', '!', '=', ' ',
                             't', '1', ' ', 'x', ' ', 't', '2']))
                   (\ _ ->
                     check (ra == raa)
                       (shows_prec_list zero_nat
                         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ',
                           'd', 'i', 'f', 'f', 'e', 'r', 's']))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '3', '\'', ' ',
                        'o', 'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OCDP1 p oc1 ->
      let {
        (lc, cr) = oc1;
        a = p;
        (aa, b) = a;
      } in let {
             (e1, ab) = aa;
             (ac, ba) = ab;
           } in let {
                  (f, (d, l)) = ac;
                } in (\ c1 (c2, ad) ->
                       let {
                         (ae, bb) = ad;
                       } in let {
                              (fa, (da, ra)) = ae;
                            } in (\ e2 ->
                                   catch_errora
                                     (bindb
                                       (check (null e1)
 (shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'e', '1', ' ', 'n', 'o', 't',
     ' ', 'e', 'm', 'p', 't', 'y']))
                                       (\ _ ->
 bindb (check (null e2)
         (shows_prec_list zero_nat
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'e', '2', ' ', 'n',
             'o', 't', ' ', 'e', 'm', 'p', 't', 'y']))
   (\ _ ->
     bindb (check (c1 == c2)
             (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', ' ', 'n', 'o',
                 't', ' ', 'e', 'q', 'u', 'a', 'l']))
       (\ _ ->
         bindb (check
                 (equal_nat f one_nat &&
                   equal_nat fa one_nat &&
                     equal_nat d zero_nat && equal_nat da zero_nat)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', '0', ' ', 'a',
                     'n', 'd', ' ', '1', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                     'o', 'n', 's', ' ', 'n', 'o', 't', ' ', 'm', 'e', 't']))
           (\ _ ->
             bindb (check (lc == l ++ c1)
                     (shows_prec_list zero_nat
                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'c',
                         ' ', '!', '=', ' ', 'l', ' ', 'c']))
               (\ _ ->
                 check (cr == c1 ++ ra)
                   (shows_prec_list zero_nat
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'r',
                       ' ', '!', '=', ' ', 'c', ' ', 'r'])))))))
                                     (\ x ->
                                       Inl
 (shows_prec_list zero_nat
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
      'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C',
      'D', 'P', '1', ' ', 'o', 'f', ' '] .
   shows_nl .
     shows_oc oc1 .
       shows_nl .
         shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
           shows_nl . shows_pat p . shows_nl . x)))
                              bb)
                  ba
             b;
    OCDP2 p oc1 ->
      let {
        (cl, rc) = oc1;
        a = p;
        (aa, b) = a;
      } in let {
             (c1, ab) = aa;
             (ac, ba) = ab;
           } in let {
                  (f, (d, l)) = ac;
                } in (\ e1 (e2, ad) ->
                       let {
                         (ae, bb) = ad;
                       } in let {
                              (fa, (da, ra)) = ae;
                            } in (\ c2 ->
                                   catch_errora
                                     (bindb
                                       (check (null e1 && null e2)
 (shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'e', '1', ' ', 'o', 'r', ' ',
     'e', '2', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't', 'y']))
                                       (\ _ ->
 bindb (check (c1 == c2)
         (shows_prec_list zero_nat
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', ' ', 'n', 'o',
             't', ' ', 'e', 'q', 'u', 'a', 'l']))
   (\ _ ->
     bindb (check
             (equal_nat f one_nat &&
               equal_nat fa one_nat &&
                 equal_nat d zero_nat && equal_nat da zero_nat)
             (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', '0', ' ', 'a', 'n',
                 'd', ' ', '1', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
                 'n', 's', ' ', 'n', 'o', 't', ' ', 'm', 'e', 't']))
       (\ _ ->
         bindb (check (cl == c1 ++ l)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'c', ' ',
                     '!', '=', ' ', 'l', ' ', 'c']))
           (\ _ ->
             check (rc == ra ++ c1)
               (shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'r', ' ',
                   '!', '=', ' ', 'c', ' ', 'r']))))))
                                     (\ x ->
                                       Inl
 (shows_prec_list zero_nat
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
      'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C',
      'D', 'P', '1', ' ', 'o', 'f', ' '] .
   shows_nl .
     shows_oc oc1 .
       shows_nl .
         shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
           shows_nl . shows_pat p . shows_nl . x)))
                              bb)
                  ba
             b;
    WPEQ p_new p ->
      let {
        (left, right) = p;
        (lefta, righta) = p_new;
      } in catch_errora
             (bindb
               (check (word_pat_equiv left lefta)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'h', 's',
                     's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'e', 'q',
                     'u', 'i', 'v', 'a', 'l', 'e', 'n', 't']))
               (\ _ ->
                 check (word_pat_equiv right righta)
                   (shows_prec_list zero_nat
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', 'h',
                       's', 's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ',
                       'e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 't'])))
             (\ x ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'e', 'q',
                        'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e', ' ', 'o',
                        'f', ' '] .
                     shows_nl .
                       shows_pat p .
                         shows_nl .
                           shows_prec_list zero_nat ['a', 'n', 'd'] .
                             shows_nl . shows_pat p_new . shows_nl . x));
    Lift p_new p ->
      let {
        a = p;
        (aa, b) = a;
      } in let {
             (l1, ab) = aa;
             (ac, ba) = ab;
           } in let {
                  (f1, (c1, m1)) = ac;
                } in (\ r1 (l2, ad) ->
                       let {
                         (ae, bb) = ad;
                       } in let {
                              (f2, (c2, m2)) = ae;
                            } in (\ r2 ->
                                   let {
                                     af = p_new;
                                     (ag, bc) = af;
                                   } in let {
  (l1a, ah) = ag;
  (ai, bd) = ah;
} in let {
       (f1a, (c1a, m1a)) = ai;
     } in (\ r1a (l2a, aj) ->
            let {
              (ak, be) = aj;
            } in let {
                   (f2a, (c2a, m2a)) = ak;
                 } in (\ r2a ->
                        catch_errora
                          (bindb
                            (check (l1 == l1a && l2 == l2a)
                              (shows_prec_list zero_nat
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                  'l', ' ', 'a', 'n', 'd', ' ', 'l', '\'', ' ',
                                  'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a',
                                  't', 'c', 'h']))
                            (\ _ ->
                              bindb (check (r1 == r1a && r2 == r2a)
                                      (shows_prec_list zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ', 'a', 'n', 'd', ' ', 'r',
  '\'', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h']))
                                (\ _ ->
                                  bindb (check
  (equal_nat f1 f1a && equal_nat f2 f2a)
  (shows_prec_list zero_nat
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'f', ' ', 'a', 'n', 'd', ' ',
      'f', '\'', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c',
      'h']))
                                    (\ _ ->
                                      bindb
(check (m1 == m1a && m2 == m2a)
  (shows_prec_list zero_nat
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', ' ', 'a', 'n', 'd', ' ',
      'm', '\'', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c',
      'h']))
(\ _ ->
  bindb (check (equal_nat c1a (plus_nat c1 f1))
          (shows_prec_list zero_nat
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'o', 'n', 's',
              't', 'a', 'n', 't', ' ', 'f', 'a', 'c', 't', 'o', 'r', ' ', 'o',
              'n', ' ', 't', 'h', 'e', ' ', 'l', 'e', 'f', 't', ' ', 'n', 'o',
              't', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 'l', 'y', ' ', 'i', 'n',
              'c', 'r', 'e', 'a', 's', 'e', 'd']))
    (\ _ ->
      check (equal_nat c2a (plus_nat c2 f2))
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'o', 'n', 's', 't',
            'a', 'n', 't', ' ', 'f', 'a', 'c', 't', 'o', 'r', ' ', 'o', 'n',
            ' ', 't', 'h', 'e', ' ', 'r', 'i', 'g', 'h', 't', ' ', 'n', 'o',
            't', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 'l', 'y', ' ', 'i', 'n',
            'c', 'r', 'e', 'a', 's', 'e', 'd'])))))))
                          (\ x ->
                            Inl (shows_prec_list zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                     'n', ' ', 'c', 'h', 'e', 'c', 'k', 'i',
                                     'n', 'g', ' ', 'l', 'i', 'f', 't', 'i',
                                     'n', 'g', ' ', 'o', 'f', ' '] .
                                  shows_nl .
                                    shows_pat p .
                                      shows_nl .
shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
  shows_nl . shows_pat p_new . shows_nl . x)))
                   be)
       bd
  bc)
                              bb)
                  ba
             b;
    DPOC1_1 p_new p1 oc1 l ra ->
      let {
        (left, (lxr, (m2, r2))) = p1;
        (x, v) = oc1;
        (lefta, (lvr, (m2a, r2a))) = p_new;
      } in catch_errora
             (bindb
               (check (left == lefta)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'h', 's',
                     's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'e', 'q',
                     'u', 'a', 'l']))
               (\ _ ->
                 bindb (check (m2 == m2a)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                             '2', ' ', 'a', 'n', 'd', ' ', 'm', '2', '\'', ' ',
                             'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                             'c', 'h']))
                   (\ _ ->
                     bindb (check (r2 == r2a)
                             (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'r', '2', ' ', 'a', 'n', 'd', ' ', 'r', '2',
                                 '\'', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ',
                                 'm', 'a', 't', 'c', 'h']))
                       (\ _ ->
                         bindb (check (lxr == l ++ x ++ ra)
                                 (shows_prec_list zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                     'l', '_', 'x', '_', 'r', ' ', '!', '=',
                                     ' ', 'l', ' ', '@', ' ', 'x', ' ', '@',
                                     ' ', 'r']))
                           (\ _ ->
                             check (lvr == l ++ v ++ ra)
                               (shows_prec_list zero_nat
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                   'l', '_', 'v', '_', 'r', ' ', '!', '=', ' ',
                                   'l', ' ', '@', ' ', 'v', ' ', '@', ' ',
                                   'r']))))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P', 'O', 'C', '1',
                        '_', '1', ' ', 'o', 'f', ' '] .
                     shows_nl .
                       shows_pat p1 .
                         shows_nl .
                           shows_oc oc1 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_pat p_new . shows_nl . xa));
    DPOC1_2 p_new p1 oc1 l ra x ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (m1, r1)) = aa;
           } in (\ (xr, (m2, r2)) ->
                  let {
                    (lx, v) = oc1;
                    ab = p_new;
                    (ac, ba) = ab;
                  } in let {
                         (ll1, (m1a, r1a)) = ac;
                       } in (\ (vr, (m2a, r2a)) ->
                              catch_errora
                                (bindb
                                  (check (m1 == m1a && m2 == m2a)
                                    (shows_prec_list zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
'd', 'i', 'f', 'i', 'e', 'd']))
                                  (\ _ ->
                                    bindb (check (r1 == r1a && r2 == r2a)
    (shows_prec_list zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ', 'c', 'o', 'm',
        'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
        'e', 'd']))
                                      (\ _ ->
bindb (check (ll1 == l ++ l1)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '1', ' ',
            '!', '=', ' ', 'l', ' ', '@', ' ', 'l', 'l', '1']))
  (\ _ ->
    bindb (check (xr == x ++ ra)
            (shows_prec_list zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x', '_', 'r', ' ',
                '!', '=', ' ', 'x', ' ', '@', ' ', 'r']))
      (\ _ ->
        bindb (check (lx == l ++ x)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'x',
                    ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'x']))
          (\ _ ->
            check (vr == v ++ ra)
              (shows_prec_list zero_nat
                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'v', '_', 'r',
                  ' ', '!', '=', ' ', 'v', ' ', '@', ' ', 'r'])))))))
                                (\ xa ->
                                  Inl (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P',
   'O', 'C', '1', '_', '2', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPOC2 p_new p1 oc1 l ra ->
      let {
        a = p1;
        (left, aa) = a;
        (l2, ab) = aa;
        (ac, b) = ab;
      } in let {
             (f2, (c2, lxr)) = ac;
           } in (\ r2 ->
                  let {
                    (x, v) = oc1;
                    ad = p_new;
                    (lefta, ae) = ad;
                    (l2a, af) = ae;
                    (ag, ba) = af;
                  } in let {
                         (f2a, (c2a, lvr)) = ag;
                       } in (\ r2a ->
                              catch_errora
                                (bindb
                                  (check (left == lefta)
                                    (shows_prec_list zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'l', 'e', 'f', 't', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                                  (\ _ ->
                                    bindb (check (equal_nat f2 f2a)
    (shows_prec_list zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'f', ' ', 'c', 'o', 'm',
        'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
        'e', 'd']))
                                      (\ _ ->
bindb (check (equal_nat c2 c2a)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', ' ', 'c', 'o', 'm',
            'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f',
            'i', 'e', 'd']))
  (\ _ ->
    bindb (check (l2 == l2a)
            (shows_prec_list zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', ' ', 'c', 'o',
                'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
                'f', 'i', 'e', 'd']))
      (\ _ ->
        bindb (check (r2 == r2a)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ', 'c',
                    'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
                    'd', 'i', 'f', 'i', 'e', 'd']))
          (\ _ ->
            bindb (check (lxr == l ++ x ++ ra)
                    (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_',
                        'x', '_', 'r', ' ', '!', '=', ' ', 'l', ' ', '@', ' ',
                        'x', ' ', '@', ' ', 'r']))
              (\ _ ->
                check (lvr == l ++ v ++ ra)
                  (shows_prec_list zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'v',
                      '_', 'r', ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'v',
                      ' ', '@', ' ', 'r']))))))))
                                (\ xa ->
                                  Inl (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P',
   'O', 'C', '2', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPOC3_1 p_new p1 oc1 l ra ->
      let {
        (left, (l2, (m2, lxr))) = p1;
        (x, v) = oc1;
        (lefta, (l2a, (m2a, lvr))) = p_new;
      } in catch_errora
             (bindb
               (check (left == lefta)
                 (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'e', 'f',
                     't', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
                     ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
               (\ _ ->
                 bindb (check (m2 == m2a)
                         (shows_prec_list zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                             ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't',
                             's', ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                   (\ _ ->
                     bindb (check (l2 == l2a)
                             (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'l', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e',
                                 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f',
                                 'i', 'e', 'd']))
                       (\ _ ->
                         bindb (check (lxr == l ++ x ++ ra)
                                 (shows_prec_list zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                     'l', '_', 'x', '_', 'r', ' ', '!', '=',
                                     ' ', 'l', ' ', '@', ' ', 'x', ' ', '@',
                                     ' ', 'r']))
                           (\ _ ->
                             check (lvr == l ++ v ++ ra)
                               (shows_prec_list zero_nat
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                   'l', '_', 'v', '_', 'r', ' ', '!', '=', ' ',
                                   'l', ' ', '@', ' ', 'v', ' ', '@', ' ',
                                   'r']))))))
             (\ xa ->
               Inl (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P', 'O', 'C', '3',
                        '_', '1', ' ', 'o', 'f', ' '] .
                     shows_nl .
                       shows_pat p1 .
                         shows_nl .
                           shows_oc oc1 .
                             shows_nl .
                               shows_prec_list zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_pat p_new . shows_nl . xa));
    DPOC3_2 p_new p1 oc1 l ra x ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (m1, r1)) = aa;
           } in (\ (l2, (m2, lx)) ->
                  let {
                    (xr, v) = oc1;
                    ab = p_new;
                    (ac, ba) = ab;
                  } in let {
                         (l1a, (m1a, r1r)) = ac;
                       } in (\ (l2a, (m2a, lv)) ->
                              catch_errora
                                (bindb
                                  (check (m2 == m2a && m1 == m1a)
                                    (shows_prec_list zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
'd', 'i', 'f', 'i', 'e', 'd']))
                                  (\ _ ->
                                    bindb (check (l1 == l1a)
    (shows_prec_list zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', ' ', 'c', 'o', 'm',
        'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
        'e', 'd']))
                                      (\ _ ->
bindb (check (l2 == l2a)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '2', ' ', 'c', 'o',
            'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
            'f', 'i', 'e', 'd']))
  (\ _ ->
    bindb (check (lx == l ++ x)
            (shows_prec_list zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'x', ' ',
                '!', '=', ' ', 'l', ' ', '@', ' ', 'x']))
      (\ _ ->
        bindb (check (xr == x ++ ra)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x', '_', 'r',
                    ' ', '!', '=', ' ', 'x', ' ', '@', ' ', 'r']))
          (\ _ ->
            bindb (check (r1r == r1 ++ ra)
                    (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '1',
                        '_', 'r', ' ', '!', '=', ' ', 'r', '1', ' ', '@', ' ',
                        'r']))
              (\ _ ->
                check (lv == l ++ v)
                  (shows_prec_list zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'v',
                      ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'v']))))))))
                                (\ xa ->
                                  Inl (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P',
   'O', 'C', '3', '_', '2', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPDP1_1 p_new p1 p2 l ra ->
      let {
        (left, (ll2, (mm, r2r))) = p1;
        a = p2;
        (aa, b) = a;
      } in let {
             (l2, (mma, r2)) = aa;
           } in (\ (l2a, (mm2, r2a)) ->
                  let {
                    (lefta, (ll2a, (mm2a, r2pr))) = p_new;
                  } in catch_errora
                         (bindb
                           (check (left == lefta)
                             (shows_prec_list zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'l', 'e', 'f', 't', ' ', 'c', 'o', 'm', 'p',
                                 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
                                 'd', 'i', 'f', 'i', 'e', 'd']))
                           (\ _ ->
                             bindb (check (mm == mma)
                                     (shows_prec_list zero_nat
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
 ' ', 'm', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm',
 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                               (\ _ ->
                                 bindb (check (mm2 == mm2a)
 (shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm', '2', ' ', 'c', 'o',
     'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
     'e', 'd']))
                                   (\ _ ->
                                     bindb (check (ll2 == l ++ l2)
     (shows_prec_list zero_nat
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '2', ' ',
         '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '2']))
                                       (\ _ ->
 bindb (check (r2r == r2 ++ ra)
         (shows_prec_list zero_nat
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', '_', 'r',
             ' ', '!', '=', ' ', 'r', '2', ' ', '@', ' ', 'r']))
   (\ _ ->
     bindb (check (r2pr == r2a ++ ra)
             (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', 'p', 'r',
                 ' ', '!', '=', ' ', 'r', '2', '\'', ' ', '@', ' ', 'r']))
       (\ _ ->
         check (ll2a == l ++ l2a)
           (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '2',
               ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '2', ' ']))))))))
                         (\ x ->
                           Inl (shows_prec_list zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                    'n', ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n',
                                    'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p',
                                    ' ', 'D', 'P', 'D', 'P', '1', '_', '1', ' ',
                                    'o', 'f', ' '] .
                                 shows_nl .
                                   shows_pat p1 .
                                     shows_nl .
                                       shows_pat p2 .
 shows_nl .
   shows_prec_list zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
     shows_nl . shows_pat p_new . shows_nl . x)))
             b;
    DPDP1_2 p_new p1 p2 l ra ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (mm1, r1)) = aa;
           } in (\ (ll2, (mm, r1a)) ->
                  let {
                    ab = p2;
                    (ac, ba) = ab;
                  } in let {
                         (l2, (mm2, r1r)) = ac;
                       } in (\ (l2a, (mm2a, r2)) ->
                              let {
                                ad = p_new;
                                (ae, bb) = ad;
                              } in let {
                                     (l3, (mm3, r1pr)) = ae;
                                   } in (\ (ll2a, (mm3a, r3)) ->
  catch_errora
    (bindb
      (check (l1 == l3)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '1', '\'', ' ',
            'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
            'd', 'i', 'f', 'i', 'e', 'd']))
      (\ _ ->
        bindb (check (mm1 == mm3)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm', '1',
                    '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
                    ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
          (\ _ ->
            bindb (check (mm == mm2)
                    (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm',
                        ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
                        ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
              (\ _ ->
                bindb (check (mm2a == mm3a)
                        (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                            'm', '2', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                            'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f',
                            'i', 'e', 'd']))
                  (\ _ ->
                    bindb (check (r2 == r3)
                            (shows_prec_list zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r',
                                '2', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                                'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
                                'f', 'i', 'e', 'd']))
                      (\ _ ->
                        bindb (check (ll2 == l ++ l2)
                                (shows_prec_list zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                    'l', '_', 'l', '2', ' ', '!', '=', ' ', 'l',
                                    ' ', '@', ' ', 'l', '2']))
                          (\ _ ->
                            bindb (check (r1pr == r1 ++ ra)
                                    (shows_prec_list zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'r', '1', '\'', 'r', ' ', '!', '=', ' ', 'r', '1', '\'', ' ', '@', ' ',
'r']))
                              (\ _ ->
                                bindb (check (r1r == r1a ++ ra)
(shows_prec_list zero_nat
  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '1', 'r', ' ', '!', '=',
    ' ', 'r', '1', ' ', '@', ' ', 'r']))
                                  (\ _ ->
                                    check (ll2a == l ++ l2a)
                                      (shows_prec_list zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '2', ' ', '!', '=',
  ' ', 'l', ' ', '@', ' ', 'l', '2', ' ']))))))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
               'p', ' ', 'D', 'P', 'D', 'P', '1', '_', '2', ' ', 'o', 'f',
               ' '] .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
    DPDP2_1 p_new p1 p2 l ra ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (mm1, r1)) = aa;
           } in (\ (l1a, (mm, r2r)) ->
                  let {
                    ab = p2;
                    (ac, ba) = ab;
                  } in let {
                         (ll1, (mm2, r2)) = ac;
                       } in (\ (l2, (mm2a, r2a)) ->
                              let {
                                ad = p_new;
                                (ae, bb) = ad;
                              } in let {
                                     (ll1a, (mm3, r3)) = ae;
                                   } in (\ (l3, (mm3a, r2pr)) ->
  catch_errora
    (bindb
      (check (r2r == r2 ++ ra)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', 'r', ' ', '!',
            '=', ' ', 'r', '2', ' ', '@', ' ', 'r']))
      (\ _ ->
        bindb (check (ll1 == l ++ l1a)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l',
                    '1', ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '1']))
          (\ _ ->
            bindb (check (ll1a == l ++ l1)
                    (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_',
                        'l', '1', '\'', ' ', '!', '=', ' ', 'l', ' ', '@', ' ',
                        'l', '1', '\'', ' ']))
              (\ _ ->
                bindb (check (mm1 == mm3)
                        (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                            'm', '1', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                            'e', 'n', 't', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
                            'e', 'd']))
                  (\ _ ->
                    bindb (check (r1 == r3)
                            (shows_prec_list zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r',
                                '1', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                                'e', 'n', 't', ' ', 'm', 'o', 'd', 'i', 'f',
                                'i', 'e', 'd']))
                      (\ _ ->
                        bindb (check (l2 == l3)
                                (shows_prec_list zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                    'l', '2', '\'', ' ', 'c', 'o', 'm', 'p',
                                    'o', 'n', 'e', 'n', 't', ' ', 'm', 'o', 'd',
                                    'i', 'f', 'i', 'e', 'd']))
                          (\ _ ->
                            bindb (check (mm2a == mm3a)
                                    (shows_prec_list zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'm', 'm', '2', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                              (\ _ ->
                                bindb (check (mm == mm2)
(shows_prec_list zero_nat
  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm', ' ', 'c', 'o', 'm',
    'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e',
    'd']))
                                  (\ _ ->
                                    check (r2pr == r2a ++ ra)
                                      (shows_prec_list zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', '\'', 'r', ' ', '!',
  '=', ' ', 'r', '2', '\'', ' ', '@', ' ', 'r']))))))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
               'p', ' ', 'D', 'P', 'D', 'P', '2', '_', '1', ' ', 'o', 'f',
               ' '] .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
    DPDP2_2 p_new p1 p2 l ra ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (mm1, r1)) = aa;
           } in (\ (l1a, (mm1a, r1a)) ->
                  let {
                    ab = p2;
                    (ac, ba) = ab;
                  } in let {
                         (ll1, (mm2, r1r)) = ac;
                       } in (\ right ->
                              let {
                                ad = p_new;
                                (ae, bb) = ad;
                              } in let {
                                     (ll1a, (mm3, r1pr)) = ae;
                                   } in (\ righta ->
  catch_errora
    (bindb
      (check (r1r == r1a ++ ra)
        (shows_prec_list zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '1', 'r', ' ', '!',
            '=', ' ', 'r', '1', ' ', '@', ' ', 'r']))
      (\ _ ->
        bindb (check (ll1 == l ++ l1a)
                (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l',
                    '1', ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '1']))
          (\ _ ->
            bindb (check (ll1a == l ++ l1)
                    (shows_prec_list zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_',
                        'l', '1', '\'', ' ', '!', '=', ' ', 'l', ' ', '@', ' ',
                        'l', '1', '\'', ' ']))
              (\ _ ->
                bindb (check (r1pr == r1 ++ ra)
                        (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r',
                            '1', '\'', '_', 'r', ' ', '!', '=', ' ', 'r', '1',
                            '\'', ' ', '@', ' ', 'r', ' ']))
                  (\ _ ->
                    bindb (check (mm1 == mm3)
                            (shows_prec_list zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                                'm', '1', '\'', ' ', 'c', 'o', 'm', 'p', 'o',
                                'n', 'e', 'n', 't', ' ', 'm', 'o', 'd', 'i',
                                'f', 'i', 'e', 'd']))
                      (\ _ ->
                        bindb (check (mm1a == mm2)
                                (shows_prec_list zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                    'm', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                                    'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
                                    'f', 'i', 'e', 'd']))
                          (\ _ ->
                            check (right == righta)
                              (shows_prec_list zero_nat
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                  'r', 'i', 'g', 'h', 't', ' ', 'c', 'o', 'm',
                                  'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm',
                                  'o', 'd', 'i', 'f', 'i', 'e', 'd']))))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
               'p', ' ', 'D', 'P', 'D', 'P', '2', '_', ' ', 'o', 'f', ' '] .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
  });

prems_ofa ::
  forall a.
    Dp_proof_step a ->
      [(([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))];
prems_ofa step =
  (case step of {
    OC1 _ _ -> [];
    OC2 _ p pa _ _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OC2p _ p pa _ _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OC3 _ p pa _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OC3p _ p pa _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OCDP1 _ p ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p)))];
    OCDP2 _ p ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p)))];
    WPEQ _ p -> [p];
    Lift _ p -> [p];
    DPOC1_1 _ p rl _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC1_2 _ p rl _ _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC2 _ p rl _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC3_1 _ p rl _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC3_2 _ p rl _ _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPDP1_1 _ p1 p2 _ _ -> [p1, p2];
    DPDP1_2 _ p1 p2 _ _ -> [p1, p2];
    DPDP2_1 _ p1 p2 _ _ -> [p1, p2];
    DPDP2_2 _ p1 p2 _ _ -> [p1, p2];
  });

check_proof ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Set (([a], ((Nat, (Nat, [a])), [a])),
                          ([a], ((Nat, (Nat, [a])), [a]))) ->
                      [Dp_proof_step a] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_proof r delta (p : ps) =
  bindb (check_step r p)
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ pa ->
                  check (member pa delta)
                    (shows_prec_list zero_nat
                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'n', 'o',
                         't', 'h', 'i', 'n', 'g', ' ', 'k', 'n', 'o', 'w', 'n',
                         ' ', 'a', 'b', 'o', 'u', 't', ' ', 'p', 'r', 'e', 'm',
                         'i', 's', 'e', ' '] .
                      shows_pat pa))
                (prems_ofa p))
              (\ x -> Inl (snd x)))
        (\ _ ->
          check_proof r
            (sup_set delta
              (inserta (pat_of p)
                (set_empty
                  (of_phantom
                    (set_impl_prod ::
                      Phantom
                        (([a], ((Nat, (Nat, [a])), [a])),
                          ([a], ((Nat, (Nat, [a])), [a])))
                        Set_impla)))))
            ps));
check_proof r delta [] = Inr ();

check_non_loop_srs_proof ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Non_loop_srs_proof a ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_srs_proof ra (SE_OC (m, lmr) l r steps) =
  bindb (check
          (membera (map pat_of steps)
            (([], ((zero_nat, (zero_nat, [])), m)),
              ([], ((zero_nat, (zero_nat, [])), lmr))))
          (shows_prec_list zero_nat
            ['o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'c', 'l', 'o', 's', 'u',
              'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'e', 'r', 'i', 'v', 'e',
              'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'p', 'r', 'o', 'o',
              'f']))
    (\ _ ->
      bindb (check (lmr == l ++ m ++ r)
              (shows_prec_list zero_nat
                ['n', 'o', ' ', 's', 'e', 'l', 'f', 'o', 'v', 'e', 'r', 'l',
                  'a', 'p']))
        (\ _ ->
          check_proof ra
            (set_empty
              (of_phantom
                (set_impl_prod ::
                  Phantom
                    (([a], ((Nat, (Nat, [a])), [a])),
                      ([a], ((Nat, (Nat, [a])), [a])))
                    Set_impla)))
            steps));
check_non_loop_srs_proof ra (SE_DP (left, right) l r steps) =
  bindb (check (membera (map pat_of steps) (left, right))
          (shows_prec_list zero_nat
            ['o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'c', 'l', 'o', 's', 'u',
              'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'e', 'r', 'i', 'v', 'e',
              'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'p', 'r', 'o', 'o',
              'f']))
    (\ _ ->
      let {
        a = left;
        (l1, aa) = a;
        (ab, b) = aa;
      } in let {
             (f1, (c1, m1)) = ab;
           } in (\ r1 ->
                  let {
                    ac = right;
                    (l2, ad) = ac;
                    (ae, ba) = ad;
                  } in let {
                         (f2, (c2, m2)) = ae;
                       } in (\ r2 ->
                              bindb (check
                                      (m1 == m2 &&
l2 == l ++ l1 && r2 == r1 ++ r)
                                      (shows_prec_list zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 's', 'e', 'l',
  'f', 'o', 'v', 'e', 'r', 'l', 'a', 'p']))
                                (\ _ ->
                                  bindb (check
  (less_eq_nat f1 f2 &&
    equal_nat (modulo_nat (max (minus_nat c2 c1) (minus_nat c1 c2)) f1)
      zero_nat &&
      (if less_nat f1 f2 then equal_nat (modulo_nat f2 f1) zero_nat
        else True) &&
        (if equal_nat f1 f2 then less_eq_nat c1 c2 else True))
  (shows_prec_list zero_nat
    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's', 'u', 'r',
      'e', ' ', 'f', 'i', 't', 't', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 'd', 'i',
      't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 's', 'e', 'l', 'f', 'o', 'v',
      'e', 'r', 'l', 'a', 'p']))
                                    (\ _ ->
                                      check_proof ra
(set_empty
  (of_phantom
    (set_impl_prod ::
      Phantom (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
        Set_impla)))
steps)))
                         ba)
             b);

term_to_string :: forall a b. Term a b -> [a];
term_to_string (Fun f [t]) = f : term_to_string t;
term_to_string (Var v) = [];
term_to_string (Fun v []) = [];
term_to_string (Fun v (vb : vd : ve)) = [];

srs_of_trs_impl :: forall a b. [(Term a b, Term a b)] -> [([a], [a])];
srs_of_trs_impl r =
  concatMap
    (\ (l, ra) ->
      (if unary_term l
        then (if unary_term ra then [(term_to_string l, term_to_string ra)]
               else [])
        else []))
    r;

check_non_loop_srs_prf ::
  forall a b c d.
    (Ceq b, Ccompare b, Eq b,
      Showa b) => Tp_ops_ext a b c d ->
                    a -> Non_loop_srs_proof b ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_srs_prf i tp prf =
  let {
    r = rulesd i tp;
    s = set (srs_of_trs_impl r);
  } in bindb (check (null (qb i tp))
               (shows_prec_list zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'f', 'o', 'r',
                   ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p', 's', ' ', 'u',
                   'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
         (\ _ -> check_non_loop_srs_proof s prf);

check_not_wwf_qtrs ::
  forall a b c.
    (Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_not_wwf_qtrs i tp =
  bindb (check (null (qb i tp) || not (nfsb i tp))
          (shows_prec_list zero_nat
            ['s', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ', 'a', 'n',
              'd', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm',
              ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
              's', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm']))
    (\ _ ->
      check (not (isOK (check_wwf_qtrs (is_QNFb i tp) (rulesd i tp))))
        (shows_string
           ['T', 'h', 'e', ' ', 'Q', '-', 'T', 'R', 'S', ' ', 'i', 's', ' ',
             'w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e', 'd'] .
          shows_nl));

check_tp_subsumesa ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      ([Term (Lab b c) [Prelude.Char]],
                        [(Term (Lab b c) [Prelude.Char],
                           Term (Lab b c) [Prelude.Char])])) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_tp_subsumesa i t tp =
  let {
    (nfsa, (q, rs)) = t;
    nfs = nfsb i tp;
    rsa = rulesd i tp;
    qa = qb i tp;
  } in catch_errora
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list zero_nat
               ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ',
                 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
                 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm', 'a', 'l', '-',
                 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a', 'g', 's']))
           (\ _ ->
             bindb (catch_errora (check_subseteq rs rsa)
                     (\ x ->
                       Inl (toomuch ['r', 'u', 'l', 'e']
                             (shows_rule (shows_prec_lab zero_nat)
                               (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                               x))))
               (\ _ ->
                 catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                   (\ x ->
                     Inl (shows_prec_list zero_nat
                            ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f', 'f',
                              'e', 'r', 's', ' ', 'd', 'u', 'e', ' ', 't', 'o',
                              ' ', 't', 'e', 'r', 'm', ' '] .
                           shows_term (shows_prec_lab zero_nat)
                             (shows_prec_list zero_nat) x)))))
         (\ x ->
           Inl ((shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's',
                     'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                     'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                     'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                     'o', 'n'] .
                  shows_nl) .
                 x));

check_non_loop_trs_prf ::
  forall a b c d.
    (Compare b, Eq b, Showa b, Cenum c, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Non_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_trs_prf i tp prf =
  let {
    r = rulesd i tp;
  } in bindb (check (null (qb i tp))
               (shows_prec_list zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'f', 'o', 'r',
                   ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p', 's', ' ', 'u',
                   'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
         (\ _ -> check_non_loop_prf r [] prf);

uncurry_nonterm_tt_check ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      ([((b, Nat), [b])] -> b -> Nat -> b) ->
                        (b -> Nat ->
                                [((b, Nat), [b])] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_nonterm_tt_check i info fmap check_inj r dpp =
  let {
    (a, (sml, (u, e))) = info;
    ra = rulesd i dpp;
    nfs = nfsb i dpp;
    sm = sig_list_to_sig_map a sml fmap;
    r_eta = e ++ ra;
    uR = uncurry_rules a sm r_eta;
  } in (case bindb (check (null (qb i dpp))
                     (shows_prec_list zero_nat
                       ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'n', 'o',
                         't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd',
                         ' ', 'f', 'o', 'r', ' ', 'u', 'n', 'c', 'u', 'r', 'r',
                         'y', 'i', 'n', 'g']))
               (\ _ ->
                 let {
                   s = uncurry_of_sig_list a sml sm;
                 } in bindb (only_eta_rules e r_eta)
                        (\ _ ->
                          bindb (check_inj a (nat_of_integer (2 :: Integer))
                                  sml)
                            (\ _ ->
                              bindb (catch_errora (check_CS_subseteq u s)
                                      (\ x ->
Inl (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
        [' ', '-', '>', ' '] x .
        shows_prec_list zero_nat
          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'u', 'n', 'c',
            'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l', 'e'])))
                                (\ _ ->
                                  catch_errora (check_subseteq r (u ++ uR))
                                    (\ x ->
                                      Inl
(shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] x .
    shows_prec_list zero_nat
      [' ', 'i', 's', ' ', 'n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'u', 'n',
        'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l', 'e', 's', ' ',
        'n', 'o', 'r', ' ', 'u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u',
        'l', 'e']))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkc i nfs [] r []);
       });

uncurry_nonterm_tt ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Uncurry_nt_proof b c [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_nonterm_tt i (Uncurry_nt_proof (a, (sml, (u, e))) r) tp =
  uncurry_nonterm_tt_check i (a, (sml, (u, e)))
    (fmap a (nat_of_integer (2 :: Integer))) check_inj r tp;

check_trs_loop ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Trs_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_loop i tp (TRS_loop_prf s rseq sigma c) =
  check_loop (qb i tp) (nfsb i tp) s rseq sigma c (rulesd i tp);

rule_removal_nonterm_reltrs ::
  forall a b c.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_reltrs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_reltrs i tp (Rule_removal_nonterm_reltrs_prf r s) =
  let {
    rrm = (if is_none r then [] else ceta_list_diff (rc i tp) (the r));
    srm = (if is_none s then [] else ceta_list_diff (rwc i tp) (the s));
  } in Inr (delete_R_Rwb i tp rrm srm);

check_rel_tp_subsumes ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      ([Term (Lab b c) [Prelude.Char]],
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          [(Term (Lab b c) [Prelude.Char],
                             Term (Lab b c) [Prelude.Char])]))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_tp_subsumes i t tp =
  let {
    (nfsa, (q, (r, rw))) = t;
    nfs = nfsb i tp;
    rules = rulesd i tp;
    ra = rc i tp;
    qa = qb i tp;
  } in catch_errora
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list zero_nat
               ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ',
                 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
                 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm', 'a', 'l', '-',
                 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a', 'g', 's']))
           (\ _ ->
             bindb (catch_errora (check_subseteq rw rules)
                     (\ x ->
                       Inl (toomuch ['r', 'u', 'l', 'e']
                             (shows_rule (shows_prec_lab zero_nat)
                               (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                               x))))
               (\ _ ->
                 bindb (catch_errora (check_subseteq r ra)
                         (\ x ->
                           Inl (toomuch ['r', 'u', 'l', 'e']
                                 (shows_rule (shows_prec_lab zero_nat)
                                   (shows_prec_list zero_nat)
                                   [' ', '-', '>', ' '] x))))
                   (\ _ ->
                     catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                       (\ x ->
                         Inl (shows_prec_list zero_nat
                                ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f',
                                  'f', 'e', 'r', 's', ' ', 'd', 'u', 'e', ' ',
                                  't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
                               shows_term (shows_prec_lab zero_nat)
                                 (shows_prec_list zero_nat) x))))))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

check_wf_reltrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ([(Term a b, Term a b)], [(Term a b, Term a b)]) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_reltrs (r, s) =
  bindb (check_wf_trs r)
    (\ _ -> (if null r then Inr () else check_varcond_subset s));

check_not_wf_reltrs ::
  forall a b c.
    (Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_not_wf_reltrs i tp =
  bindb (check (q_emptyb i tp)
          (shows_prec_list zero_nat
            ['c', 'u', 'r', 'r', 'e', 'n', 't', 'l', 'y', ' ', 'o', 'n', 'l',
              'y', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'Q', ' ', 'i', 's', ' ',
              's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
    (\ _ ->
      check (not (isOK (check_wf_reltrs (rc i tp, rwc i tp))))
        (shows_string
           ['T', 'h', 'e', ' ', 'T', 'R', 'S', 's', ' ', 'R', ' ', 'a', 'n',
             'd', ' ', 'S', ' ', 'a', 'r', 'e', ' ', 'w', 'e', 'l', 'l', ' ',
             'f', 'o', 'r', 'm', 'e', 'd'] .
          shows_nl));

reltrs_as_trs ::
  forall a b c.
    Tp_ops_ext a b c () -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
reltrs_as_trs i tp = let {
                       q = qb i tp;
                       r = rc i tp;
                       nfs = nfsb i tp;
                       a = mkc i nfs q r [];
                     } in Inr a;

check_rel_loop ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Term a b ->
                    [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                      [(b, Term a b)] ->
                        Ctxt a b ->
                          [(Term a b, Term a b)] ->
                            [(Term a b, Term a b)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_loop sa rseq sigma c r s =
  check_rel_seq r s rseq sa
    (ctxt_apply_term c (subst_apply_term sa (mk_subst Var sigma))) False;

check_rel_trs_loop ::
  forall a b c.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rel_trs_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_trs_loop i tp (Rel_trs_loop_prf s rseq sigma c) =
  bindb (check (q_emptyb i tp)
          (shows_prec_list zero_nat
            ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't',
              'y']))
    (\ _ -> check_rel_loop s rseq sigma c (rc i tp) (rwc i tp));

check_reltrs_nontermination_proof ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Reltrs_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_reltrs_nontermination_proof ia j assms i tp (Rel_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catch_errora (check_rel_trs_loop ia tp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'l',
                     'o', 'o', 'p', ' ', 'p', 'r', 'o', 'o', 'f'] .
                   shows_nl . x)));
check_reltrs_nontermination_proof ia j assms i tp (Rel_R_Not_SN prf) =
  bindb (reltrs_as_trs ia tp)
    (\ tpa ->
      catch_errora
        (check_trs_nontermination_proof ia j assms (i . shows_string ['.', '1'])
          tpa prf)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                       'o', 'w', ' ', 't', 'h', 'e', ' ', 'n', 'o', 'n', 't',
                       'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                       'p', 'r', 'o', 'o', 'f', ' ', 'f', 'o', 'r', ' ', 'R'] .
                     shows_nl . indent x)));
check_reltrs_nontermination_proof ia j assms i tp Rel_Not_Well_Formed =
  debug (i [])
    ['N', 'o', 't', ' ', 'W', 'e', 'l', 'l', '-', 'F', 'o', 'r', 'm', 'e', 'd']
    (catch_errora (check_not_wf_reltrs ia tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'n',
                     'o', 't', '-', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm',
                     'e', 'd', ' ', 'p', 'r', 'o', 'o', 'f'] .
                   shows_nl . x)));
check_reltrs_nontermination_proof ia j assms i tp (Rel_TRS_String_Reversal prf)
  = debug (i [])
      ['S', 't', 'r', 'i', 'n', 'g', ' ', 'R', 'e', 'v', 'e', 'r', 's', 'a',
        'l']
      (bindb
        (catch_errora (string_reversal_complete_rel_tt ia tp)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         's', 't', 'r', 'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e',
                         'r', 's', 'a', 'l', ' ', 'o', 'n'] .
                       shows_nl .
                         shows_tp (shows_prec_lab zero_nat)
                           (shows_prec_list zero_nat) ia tp .
                           shows_nl . x)))
        (\ tpa ->
          catch_errora
            (check_reltrs_nontermination_proof ia j assms
              (i . shows_string ['.', '1']) tpa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 't', 'r',
                           'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e', 'r', 's',
                           'a', 'l', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q',
                           'u', 'e'] .
                         shows_nl . indent x))));
check_reltrs_nontermination_proof ia j assms i tp (Rel_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_reltrs ia tp p)
      (\ tpa ->
        catch_errora
          (check_reltrs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_reltrs_nontermination_proof ia j assms i tp (Rel_TRS_Assume_Not_SN t ass)
  = debug (i [])
      ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's',
        'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k',
        'n', 'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
      (if assms
        then bindb (catch_errora (check_rel_tp_subsumes ia t tp)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                    'n', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r',
                                    'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                                    'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                                    'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n',
                                    'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o',
                                    'f'] .
                                  shows_nl . x . shows_nl)))
               (\ _ ->
                 catch_errora
                   (catch_errora
                     (forallM_index
                       (\ asa ja ->
                         check_assmb ia j
                           (check_trs_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat zero_nat (suc ja)))
                           (check_dp_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat zero_nat (suc ja)))
                           (check_reltrs_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat zero_nat (suc ja)))
                           (check_fp_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat zero_nat (suc ja)))
                           (check_unknown_disproof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat zero_nat (suc ja)))
                           asa)
                       ass)
                     (\ x -> Inl (snd x)))
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n',
                                  'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . indent x)))
        else Inl (i . shows_string
                        [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                          ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                          'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                          'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                          'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                        shows_nl));

check_trs_nontermination_proof ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_nontermination_proof ia j assms i tp (TRS_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catch_errora (check_trs_loop ia tp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'l', 'o',
                     'o', 'p', ' ', 'o', 'f', ' '] .
                   shows_nl .
                     shows_tp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) ia tp .
                       shows_nl . indent x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Nonloop p) =
  debug (i []) ['N', 'o', 'n', 'l', 'o', 'o', 'p']
    (catch_errora (check_non_loop_trs_prf ia tp p)
      (\ x ->
        Inl (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
                 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'p', 'o', 's', 's', 'i',
                 'b', 'l', 'y', ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p',
                 'i', 'n', 'g', ' ', 'i', 'n', 'f', 'i', 'n', 'i', 't', 'e',
                 ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'f',
                 'o', 'r', ' '] .
              shows_nl .
                shows_tp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) ia
                  tp .
                  indent x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Nonloop_SRS p) =
  debug (i []) ['N', 'o', 'n', 'l', 'o', 'o', 'p', ' ', 'S', 'R', 'S']
    (catch_errora (check_non_loop_srs_prf ia tp p)
      (\ x ->
        Inl (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
                 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'p', 'o', 's', 's', 'i',
                 'b', 'l', 'y', ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p',
                 'i', 'n', 'g', ' ', 'i', 'n', 'f', 'i', 'n', 'i', 't', 'e',
                 ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'f',
                 'o', 'r', ' '] .
              shows_nl .
                shows_tp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) ia
                  tp .
                  indent x)));
check_trs_nontermination_proof ia j assms i tp TRS_Not_Well_Formed =
  debug (i [])
    ['N', 'o', 't', ' ', 'W', 'e', 'l', 'l', '-', 'F', 'o', 'r', 'm', 'e', 'd']
    (catch_errora (check_not_wwf_qtrs ia tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'n',
                     'o', 't', ' ', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm',
                     'e', 'd', ' ', 'p', 'r', 'o', 'o', 'f'] .
                   shows_nl . x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Termination_Switch p prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', ' ', 't', 'o', ' ', 'T', 'e', 'r', 'm', 'i',
      'n', 'a', 't', 'i', 'o', 'n']
    (bindb
      (catch_errora (switch_termination_tt ia p tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'f', 'u', 'l', 'l', ' ', 's', 't', 'r', 'a',
                       't', 'e', 'g', 'y', ' ', 'f', 'o', 'r', ' ', 't', 'h',
                       'e', ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e',
                       'm', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . indent x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm',
                         'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 's', 'w', 'i',
                         't', 'c', 'h', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q',
                         'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_trs ia tp p)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_String_Reversal prf) =
  debug (i [])
    ['S', 't', 'r', 'i', 'n', 'g', ' ', 'R', 'e', 'v', 'e', 'r', 's', 'a', 'l']
    (bindb
      (catch_errora (string_reversal_complete_tt ia tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 't', 'r', 'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e',
                       'r', 's', 'a', 'l', ' ', 'o', 'n'] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 't', 'r', 'i',
                         'n', 'g', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'a', 'l',
                         ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Constant_String p prf) =
  debug (i [])
    ['C', 'o', 'n', 's', 't', 'a', 'n', 't', 's', ' ', 'i', 'n', 't', 'o', ' ',
      'U', 'n', 'a', 'r', 'y']
    (bindb
      (catch_errora (const_to_string_complete_tt ia tp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 't', 'u', 'r', 'n', 'i', 'n', 'g', ' ', 'c',
                       'o', 'n', 's', 't', 'a', 'n', 't', 's', ' ', 'i', 'n',
                       't', 'o', ' ', 's', 't', 'r', 'i', 'n', 'g', 's', ' ',
                       'o', 'n'] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 's',
                         't', 'a', 'n', 't', 's', ' ', 'i', 'n', 't', 'o', ' ',
                         's', 't', 'r', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_DP_Trans p prf) =
  debug (i [])
    ['D', 'P', ' ', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
      'o', 'n']
    (bindb
      (catch_errora (dp_trans_nontermination_tt ia j tp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       'D', 'P', ' ', 't', 'r', 'a', 'n', 's', 'f', 'o', 'r',
                       'm', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'n'] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ dpp ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dpp prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 't',
                         'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
                         'o', 'n'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Q_Increase p prf) =
  debug (i []) ['Q', ' ', 'i', 'n', 'c', 'r', 'e', 'a', 's', 'e']
    (bindb (q_increase_nonterm_trs ia tp p)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', ' ', 'i', 'n',
                         'c', 'r', 'e', 'a', 's', 'e', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Uncurry p prf) =
  debug (i []) ['U', 'n', 'c', 'u', 'r', 'r', 'y', 'i', 'n', 'g']
    (bindb (uncurry_nonterm_tt ia p tp)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c', 'u',
                         'r', 'r', 'y', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Not_WN_Tree_Automaton prf) =
  catch_errora (check_not_wn_ta_prf ia tp prf)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 't', 'r', 'e', 'e',
               ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ', 'b', 'a',
               's', 'e', 'd', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i',
               'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f', ' ',
               'f', 'o', 'r', ' '] .
            shows_nl .
              shows_tp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) ia
                tp .
                indent x));
check_trs_nontermination_proof ia j assms i tp (TRS_Assume_Not_SN t ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora (check_tp_subsumesa ia t tp)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r',
                                  'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                                  'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                                  'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n',
                                  'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_unknown_disproof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));
check_trs_nontermination_proof ia j assms i tp (FPTRS_Assume_Not_SN t ass) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'F',
               'P', 'T', 'R', 'S', '_', 'A', 's', 's', 'u', 'm', 'e', '_', 'N',
               'o', 't', '_', 'S', 'N'] .
             shows_nl);

check_fp_nontermination_proof ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b c) [Prelude.Char],
                              (Term (Lab b c) [Prelude.Char], Location))],
                            [(Term (Lab b c) [Prelude.Char],
                               Term (Lab b c) [Prelude.Char])]) ->
                            Trs_nontermination_proof b c [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fp_nontermination_proof ia j assms i (pa, r) (TRS_Loop p) =
  let {
    (TRS_loop_prf a b c d) = p;
  } in debug (i []) ['L', 'o', 'o', 'p']
         (catch_errora (check_fploop r pa (FP_loop_prf d c a b))
           (\ x ->
             Inl (i . shows_string
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                          'n', ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ',
                          'f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p',
                          'a', 't', 't', 'e', 'r', 'n', ' ', 'l', 'o', 'o',
                          'p'] .
                        shows_nl . indent x)));
check_fp_nontermination_proof ia j assms i (pa, r) (TRS_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_trs ia (mkc ia False [] r []) p)
      (\ tp ->
        catch_errora
          (check_fp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) (pa, rulesd ia tp) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_fp_nontermination_proof ia j assms i tp (FPTRS_Assume_Not_SN t ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora (check_fp_tp_subsumes t tp)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r',
                                  'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                                  'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                                  'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n',
                                  'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_unknown_disproof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));
check_fp_nontermination_proof ia j assms i tp TRS_Not_Well_Formed =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);
check_fp_nontermination_proof ia j assms i tp (TRS_String_Reversal v) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);
check_fp_nontermination_proof ia j assms i tp (TRS_Constant_String v va) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);
check_fp_nontermination_proof ia j assms i tp (TRS_DP_Trans v va) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);
check_fp_nontermination_proof ia j assms i tp (TRS_Termination_Switch v va) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);
check_fp_nontermination_proof ia j assms i tp (TRS_Nonloop v) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);
check_fp_nontermination_proof ia j assms i tp (TRS_Nonloop_SRS v) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);
check_fp_nontermination_proof ia j assms i tp (TRS_Q_Increase v va) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);
check_fp_nontermination_proof ia j assms i tp (TRS_Uncurry v va) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);
check_fp_nontermination_proof ia j assms i tp (TRS_Not_WN_Tree_Automaton v) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);
check_fp_nontermination_proof ia j assms i tp (TRS_Assume_Not_SN v va) =
  Inl (i . shows_string
             [':', ' ', 'e', 'n', 'c', 'o', 'u', 'n', 't', 'e', 'r', 'e', 'd',
               ' ', 'u', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'p',
               'r', 'o', 'o', 'f'] .
             shows_nl);

check_dp_nontermination_proof ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          d -> Dp_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_nontermination_proof ia j assms i dpp (DP_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catch_errora (check_dp_loop j dpp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                     'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'l', 'o', 'o', 'p',
                     ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l',
                     'l', 'o', 'w', 'i', 'n', 'g', ' ', 'D', 'P', '-', 'p', 'r',
                     'o', 'b', 'l', 'e', 'm', ' '] .
                   shows_nl .
                     shows_dpp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) j dpp .
                       shows_nl . indent x)));
check_dp_nontermination_proof ia j assms i dpp (DP_Nonloop p) =
  debug (i []) ['N', 'o', 'n', 'l', 'o', 'o', 'p']
    (catch_errora (check_non_loop_dp_prf j dpp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                     'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'n', 'o', 'n', 'l',
                     'o', 'o', 'p', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ',
                     'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'D', 'P',
                     '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                   shows_nl .
                     shows_dpp (shows_prec_lab zero_nat)
                       (shows_prec_list zero_nat) j dpp .
                       shows_nl . indent x)));
check_dp_nontermination_proof ia j assms i dpp (DP_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_dp j dpp p)
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r',
                         ' ', 'a', 'n', 'd', ' ', 'r', 'u', 'l', 'e', ' ', 'r',
                         'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Q_Reduction p prf) =
  debug (i []) ['Q', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n']
    (bindb
      (catch_errora (dp_q_reduction_nonterm j dpp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       'r', 'e', 'd', 'u', 'c', 'i', 'n', 'g', ' ', 't', 'h',
                       'e', ' ', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't',
                       ' ', 'l', 'h', 's', 's', ' ', 'i', 'n', ' ', 't', 'h',
                       'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                       ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                       ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', ' ', 'r', 'e',
                         'd', 'u', 'c', 't', 'i', 'o', 'n'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Q_Increase p prf) =
  debug (i []) ['Q', ' ', 'i', 'n', 'c', 'r', 'e', 'a', 's', 'e']
    (bindb (q_increase_nonterm_dp j dpp p)
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', ' ', 'i', 'n',
                         'c', 'r', 'e', 'a', 's', 'e'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Termination_Switch p prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', ' ', 't', 'o', ' ', 'T', 'e', 'r', 'm', 'i',
      'n', 'a', 't', 'i', 'o', 'n']
    (bindb
      (catch_errora (switch_termination_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'f', 'u', 'l', 'l', ' ', 's', 't', 'r', 'a',
                       't', 'e', 'g', 'y', ' ', 'f', 'o', 'r', ' ', 't', 'h',
                       'e', ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e',
                       'm', ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm',
                         'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 's', 'w', 'i',
                         't', 'c', 'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                         'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Instantiation p prf) =
  debug (i []) ['I', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n']
    (bindb
      (catch_errora (instantiation_complete_proc j dpp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                       'i', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c',
                       'e', 's', 's', 'o', 'r', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'i', 'n', 's', 't',
                         'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n', ' ', 'p',
                         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Rewriting p prf) =
  debug (i []) ['R', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g']
    (bindb
      (catch_errora (rewriting_complete_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r'] .
                     shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Narrowing p prf) =
  debug (i []) ['N', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g']
    (bindb
      (catch_errora (narrowing_complete_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'n', 'a', 'r', 'r', 'o', 'w', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r'] .
                     shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Assume_Infinite dp ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora (check_dpp_subsumesa j dp dpp)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n',
                                  'e', 's', 's', ' ', 'a', 's', 's', 'u', 'm',
                                  'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ',
                                  'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                                  'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         (check_unknown_disproof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_unknown_disproof ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Neg_unknown_proof b c [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_disproof ia j assms i tpa (Assume_NT_Unknown tp ass) =
  debug (i []) ['U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catch_errora
                   (check (tpa == tp)
                     (shows_prec_list zero_nat
                        ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o',
                          'b', 'l', 'e', 'm', 's', ' ', 'a', 'r', 'e', ' ', 'n',
                          'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i', 'c', 'a',
                          'l', ':', ' '] .
                       shows_nl .
                         shows_prec_list zero_nat tpa .
                           shows_nl .
                             shows_prec_list zero_nat [' ', 'v', 's', ' '] .
                               shows_nl . shows_prec_list zero_nat tp))
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'n', 'o', 'n', 't', 'e', 'r', 'm',
                                  'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
                                  's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
                                  ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o',
                                  'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assmb ia j
                       (check_trs_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_dp_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_reltrs_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_fp_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       (check_unknown_disproof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat zero_nat (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                        'r', 'o', 'o', 'f'] .
                      shows_nl));

rhs_n ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Term a b;
rhs_n u (lr, cs) n =
  (if less_nat n (size_list cs)
    then ctxt_apply_term (u (lr, cs) n) (fst (nth cs n)) else snd lr);

lhs_n ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Term a b;
lhs_n u (lr, cs) n =
  (if equal_nat n zero_nat then fst lr
    else ctxt_apply_term (u (lr, cs) (minus_nat n one_nat))
           (snd (nth cs (minus_nat n one_nat))));

rules_impl ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> [(Term a b, Term a b)];
rules_impl u cr =
  map (\ i -> (lhs_n u cr i, rhs_n u cr i))
    (upt zero_nat (suc (size_list (snd cr))));

create_ctxts :: forall a b. [(Term a b, Term a b)] -> Maybe (Nat -> Ctxt a b);
create_ctxts r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      bind (mapMa (\ a -> (case a of {
                            (Var _, _) -> Nothing;
                            (Fun _ [], _) -> Nothing;
                            (Fun u (_ : ts), _) -> Just (More u [] Hole ts);
                          }))
             rr)
        (\ cs ->
          let {
            _ = size_list cs;
          } in Just (\ i ->
                      (if less_nat i (size_list cs) then nth cs i else Hole)));
  });

create_U ::
  forall a b.
    (Eq a,
      Eq b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                  [(Term a b, Term a b)])] ->
                 Maybe (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                         Nat -> Ctxt a b);
create_U c_rs =
  bind (mapMa
         (\ (cr, rs) ->
           bind (guarda (equal_nat (size_list rs) (suc (size_list (snd cr)))))
             (\ _ -> bind (create_ctxts rs) (\ ctxt -> Just (cr, ctxt))))
         c_rs)
    (\ cr_ctxts -> let {
                     m = map_of cr_ctxts;
                   } in Just (\ cr -> (case m cr of {
Nothing -> (\ _ -> Hole);
Just ctxt -> ctxt;
                                      })));

check_unraveling ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                     [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        [(Term a b, Term a b)];
check_unraveling c_rs ctrs =
  catch_errora
    (bindb
      (catch_errora (check_subseteq ctrs (map fst c_rs))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
                   ' ', 'r', 'u', 'l', 'e', ' '] .
                shows_crule (shows_prec zero_nat) (shows_prec zero_nat) x .
                  shows_nl)))
      (\ _ ->
        bindb (case create_U c_rs of {
                Nothing ->
                  Inl (shows_prec_list zero_nat
                        ['u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'e',
                          'x', 't', 'r', 'a', 'c', 't', ' ', 'u', 'n', 'r', 'a',
                          'v', 'e', 'l', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 't',
                          'e', 'x', 't', 's']);
                Just a -> Inr a;
              })
          (\ u ->
            bindb (catch_errora
                    (forallM
                      (\ (c, rs) ->
                        check (rules_impl u c == rs)
                          (shows_prec_list zero_nat
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                               't', 'h', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'o',
                               'f', ' '] .
                            shows_crule (shows_prec zero_nat)
                              (shows_prec zero_nat) c .
                              shows_nl))
                      c_rs)
                    (\ x -> Inl (snd x)))
              (\ _ -> Inr (concatMap snd c_rs)))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'u', 'n',
               'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', ' '] .
            shows_nl . x));

check_quasi_reductive_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [((Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]),
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])])] ->
                            Quasi_reductive_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quasi_reductive_proof a ia i j ctrs (Unravel u_info prf) =
  debug (ia []) ['U', 'n', 'r', 'a', 'v', 'e', 'l']
    (bindb
      (catch_errora (check_unraveling u_info ctrs)
        (\ x ->
          Inl (ia . shows_string
                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                        'u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g'] .
                      shows_nl . indent x)))
      (\ r ->
        let {
          tp = mkc i False [] r [];
        } in catch_errora
               (check_trs_termination_proof i j a (ia . shows_string ['.', '1'])
                 tp prf)
               (\ x ->
                 Inl (ia . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 's', 't', 'r', 'o', 'n', 'g',
                               ' ', 'n', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a',
                               't', 'i', 'o', 'n', ' ', '+', ' ', 'w', 'c',
                               'r'] .
                             shows_nl . indent x))));

shows_gctxt ::
  forall a b. (Showa a) => Gctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_gctxt GCHole = shows_string ['_'];
shows_gctxt (GCFun f ts) =
  shows_prec zero_nat f .
    shows_list_gen id [] ['('] [',', ' '] [')'] (map shows_gctxt ts);

shows_prec_gctxt ::
  forall a b. (Showa a) => Nat -> Gctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_gctxt p c = shows_gctxt c;

gctxts_to_terms_intern ::
  forall a b. (Nat -> a) -> Nat -> [Gctxt b a] -> (Nat, [Term b a]);
gctxts_to_terms_intern iv i (GCFun f ts : cs) =
  let {
    (i1, res1) = gctxts_to_terms_intern iv i ts;
    (i2, res2) = gctxts_to_terms_intern iv i1 cs;
  } in (i2, Fun f res1 : res2);
gctxts_to_terms_intern iv i (GCHole : cs) =
  let {
    (ia, res) = gctxts_to_terms_intern iv (plus_nat i one_nat) cs;
  } in (ia, Var (iv i) : res);
gctxts_to_terms_intern iv i [] = (i, []);

gc_matcher ::
  forall a.
    (Eq a) => Gctxt a [Prelude.Char] ->
                Term a [Prelude.Char] ->
                  Maybe ([Prelude.Char] -> Term a [Prelude.Char]);
gc_matcher c l =
  map_option fst
    (mgu_var_disjoint_generic (\ a -> 'x' : a) (\ a -> 'y' : a) l
      (hda (snd (gctxts_to_terms_intern
                  (\ i -> 'x' : shows_prec_nat zero_nat i []) zero_nat [c]))));

check_contains_U0 ::
  forall a.
    (Compare a, Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Set (Term a [Prelude.Char], Term a [Prelude.Char]) ->
                      Term a [Prelude.Char] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_contains_U0 r u s =
  catch_errora
    (forallM
      (\ fts ->
        (case fts of {
          Var _ -> Inr ();
          Fun f ts ->
            let {
              tcapb = GCFun f (map (tcap u) ts);
            } in catch_errora
                   (forallM
                     (\ lr ->
                       (case gc_matcher tcapb (fst lr) of {
                         Nothing -> Inr ();
                         Just sigma ->
                           let {
                             irule =
                               (subst_apply_term (fst lr) sigma,
                                 subst_apply_term (snd lr) sigma);
                           } in check (in_rstep_impl (fst irule) (snd irule) u)
                                  (shows_prec_list zero_nat
                                     ['W', 'h', 'e', 'n', ' ', 'c', 'o', 'n',
                                       's', 'i', 'd', 'e', 'r', 'i', 'n', 'g',
                                       ' ', 't', 'h', 'e', ' ', 's', 'u', 'b',
                                       't', 'e', 'r', 'm', ' '] .
                                    shows_prec_term zero_nat fts .
                                      shows_nl .
shows_prec_list zero_nat
  ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
  shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
    [' ', '-', '>', ' '] lr .
    shows_nl .
      shows_prec_list zero_nat
        ['t', 'h', 'e', ' ', 'c', 'a', 'p', 'p', 'e', 'd', ' ', 's', 'u', 'b',
          't', 'e', 'r', 'm', ' ', 'i', 's', ' '] .
        shows_prec_gctxt zero_nat tcapb .
          shows_nl .
            shows_prec_list zero_nat
              ['l', 'e', 'a', 'd', 'i', 'n', 'g', ' ', 't', 'o', ' ', 't', 'h',
                'e', ' ', 'm', 'g', 'u', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h',
                'e', ' ', 'l', 'h', 's', ':', ' '] .
              shows_prec_list zero_nat
                (map (\ x -> (x, sigma x)) (vars_term_list (fst lr))) .
                shows_nl .
                  shows_prec_list zero_nat
                    ['T', 'h', 'e', ' ', 'i', 'n', 's', 't', 'a', 'n', 't', 'i',
                      'a', 't', 'e', 'd', ' ', 'r', 'u', 'l', 'e', ' '] .
                    shows_prec_prod zero_nat irule .
                      shows_nl .
                        shows_prec_list zero_nat
                          ['c', 'a', 'n', 'n', 'o', 't', ' ', 'b', 'e', ' ',
                            's', 'i', 'm', 'u', 'l', 'a', 't', 'e', 'd', ' ',
                            'b', 'y', ' ', 't', 'h', 'e', ' ', 'g', 'i', 'v',
                            'e', 'n', ' ', 's', 'e', 't', ' ', 'o', 'f', ' ',
                            'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                            'e', 's']);
                       }))
                     r)
                   (\ x -> Inl (snd x));
        }))
      (supteq_list s))
    (\ x -> Inl (snd x));

check_usable_instantiation ::
  forall a.
    (Compare a, Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      Term a [Prelude.Char] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_usable_instantiation r u s =
  let {
    uu = set u;
  } in bindb (catch_errora (check_contains_U0 r uu s)
               (\ x ->
                 Inl (shows_prec_list zero_nat
                        ['U', ' ', '<', '=', ' ', 'U', '0', '(', 'R', ',', 's',
                          ')', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'] .
                       shows_nl . x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ ra ->
                 catch_errora (check_contains_U0 r uu ra)
                   (\ x ->
                     Inl (shows_prec_list zero_nat
                            ['U', ' ', '<', '=', ' ', 'U', '0', '(', 'R', ',',
                              'r', ')', ' ', 'f', 'o', 'r', ' ', 'r', 'h', 's',
                              ' ', 'r', ' ', '=', ' '] .
                           shows_prec_term zero_nat ra .
                             shows_prec_list zero_nat
                               [' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'] .
                               shows_nl . x)))
               (map snd u))
             (\ x -> Inl (snd x)));

check_usable_rules_unif ::
  forall a.
    (Compare a, Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      Term a [Prelude.Char] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_usable_rules_unif r u s =
  catch_errora
    (bindb
      (check (ground s || all (\ l -> not (is_Var l)) (map fst r))
        (shows_string ['s', 'i', 'n', 'c', 'e', ' '] .
          shows_prec_term zero_nat s .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'g', 'r', 'o', 'u', 'n',
                'd', ',', ' ', 'l', 'e', 'f', 't', '-', 'h', 'a', 'n', 'd', ' ',
                's', 'i', 'd', 'e', 's', ' ', 'o', 'f', ' ', 'R', ' ', 'm', 'u',
                's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'v', 'a', 'r',
                'i', 'a', 'b', 'l', 'e', 's']))
      (\ _ ->
        bindb (check_varcond_subset u)
          (\ _ ->
            catch_errora (check_usable_instantiation r u s)
              (\ x ->
                Inl (shows_string
                       ['c', 'l', 'o', 's', 'u', 'r', 'e', ' ', 'p', 'r', 'o',
                         'p', 'e', 'r', 't', 'i', 'e', 's', ' ', 'o', 'f', ' ',
                         'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                         's', ' ', 'n', 'o', 't', ' ', 's', 'a', 't', 'i', 's',
                         'f', 'i', 'e', 'd'] .
                      shows_nl . x)))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'v', 'a', 'l', 'i', 'd', 'i',
               't', 'y', ' ', 'o', 'f', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
               'r', 'u', 'l', 'e', 's', ' ', 'U', ' ', '=', ' '] .
            shows_nl .
              shows_trs (shows_prec zero_nat) (shows_prec_list zero_nat)
                ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't',
                  'e', 'm', ':']
                [' ', '-', '>', ' '] u .
                shows_nl .
                  shows_prec_list zero_nat
                    ['f', 'o', 'r', ' ', 't', 'e', 'r', 'm', ' '] .
                    shows_prec_term zero_nat s .
                      shows_nl .
                        shows_string
                          ['w', 'r', 't', ' ', 'T', 'R', 'S', ' ', 'R', ' ',
                            '=', ' '] .
                          shows_nl .
                            shows_trs (shows_prec zero_nat)
                              (shows_prec_list zero_nat)
                              ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                                's', 't', 'e', 'm', ':']
                              [' ', '-', '>', ' '] r .
                              shows_nl . x));

sl_c :: forall a b c d e. Sl_ops_ext a b c d e -> b;
sl_c (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_c;

check_qmodel_rule_ass ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (a -> [b] -> b) ->
                    (b -> b -> Bool) ->
                      (c -> b) ->
                        (Term a c, Term a c) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel_rule_ass i cge alpha (l, r) =
  let {
    cl = eval i alpha l;
    cr = eval i alpha r;
  } in check (cge cl cr)
         (shows_string ['r', 'u', 'l', 'e', ' '] .
           shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
             [' ', '-', '>', ' '] (l, r) .
             shows_string
               [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 't', 'h', 'e',
                 ' ', 'm', 'o', 'd', 'e', 'l', ' ', 'c', 'o', 'n', 'd', 'i',
                 't', 'i', 'o', 'n', ',', ' ', '[', 'l', 'h', 's', ']', ' ',
                 '=', ' '] .
               shows_prec zero_nat cl .
                 shows_string
                   [',', ' ', '[', 'r', 'h', 's', ']', ' ', '=', ' '] .
                   shows_prec zero_nat cr);

check_qmodel_rule ::
  forall a b c.
    (Showa a, Showa b, Eq c,
      Showa c) => (a -> [b] -> b) ->
                    [b] ->
                      (b -> b -> Bool) ->
                        (Term a c, Term a c) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel_rule i c cge lr =
  catch_errora
    (forallM (\ alpha -> check_qmodel_rule_ass i cge alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_qmodel ::
  forall a b c.
    (Showa a, Showa b, Eq c,
      Showa c) => (a -> [b] -> b) ->
                    [b] ->
                      (b -> b -> Bool) ->
                        [(Term a c, Term a c)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel i c cge r =
  catch_errora (forallM (check_qmodel_rule i c cge) r) (\ x -> Inl (snd x));

check_non_join_model ::
  forall a b c d.
    (Showa a, Showa b, Eq d,
      Showa d) => (a -> a -> Bool) ->
                    ([(b, Nat)] ->
                      [(b, Nat)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char])
                          (Sl_ops_ext b a c d ())) ->
                      [(Term b d, Term b d)] ->
                        [(Term b d, Term b d)] ->
                          Term b d ->
                            Term b d ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_model cge gen rs rt s t =
  catch_errora
    (bindb (gen (funas_trs_list (rs ++ rt)) [])
      (\ ops ->
        let {
          i = sl_I ops;
          e = eval i (\ _ -> sl_c ops);
          es = e s;
          et = e t;
        } in bindb (check (not (cge et es))
                     (shows_prec_list zero_nat
                        ['t', 'h', 'e', ' ', 'i', 'n', 'e', 'q', 'u', 'a', 'l',
                          'i', 't', 'y', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o',
                          't', ' ', 'h', 'o', 'l', 'd', ':', ' ', '['] .
                       shows_prec_term zero_nat t .
                         shows_prec_list zero_nat [']', ' ', '=', ' '] .
                           shows_prec zero_nat et .
                             shows_prec_list zero_nat [' ', '>', '=', ' '] .
                               shows_prec zero_nat es .
                                 shows_prec_list zero_nat [' ', '=', ' ', '['] .
                                   shows_prec_term zero_nat s .
                                     shows_prec_list zero_nat [']']))
               (\ _ -> check_qmodel i (sl_C ops) cge (reverse_rules rs ++ rt))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'd', 'i',
               's', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-',
               'j', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'v',
               'i', 'a', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a',
               't', 'i', 'o', 'n', 's'] .
            shows_nl . x));

check_non_join_finite_model ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Sl_variant (Lab a [Nat]) b ->
                    [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                      [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                        Term (Lab a [Nat]) b ->
                          Term (Lab a [Nat]) b ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_finite_model (Rootlab x) rs rt s t =
  check_non_join_model equal_lab (slm_gen_to_sl_gen (rl_slm x)) rs rt s t;
check_non_join_finite_model (Finitelab sli) rs rt s t =
  check_non_join_model equal_nat
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli))) rs rt s t;
check_non_join_finite_model (QuasiFinitelab sli v) rs rt s t =
  check_non_join_model qmodel_cge (\ f g -> qsli_to_sl v f g sli) rs rt s t;

match_tcap_below_impl ::
  forall a b.
    (Eq a, Eq b) => Term a b -> [(Term a b, Term a b)] -> Term a b -> Bool;
match_tcap_below_impl l r (Fun f ts) = matchb (GCFun f (map (tcapI r) ts)) l;
match_tcap_below_impl l r (Var x) = False;

usable_rules_reach_U0_impl ::
  forall a b.
    (Eq a,
      Eq b) => [(Term a b, Term a b)] -> Term a b -> [(Term a b, Term a b)];
usable_rules_reach_U0_impl r t =
  inductive_set_impl r
    (\ ta (l, _) ->
      is_Var l ||
        any (\ u -> not (is_Var u) && match_tcap_below_impl l r u)
          (supteq_list ta))
    (\ lr -> [snd lr]) [t];

usable_rules_reach_impl ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       Term a b -> [(Term a b, Term a b)];
usable_rules_reach_impl r t =
  let {
    u0t = usable_rules_reach_U0_impl r t;
  } in (if all (\ (l, ra) -> less_eq_set (vars_term ra) (vars_term l)) u0t
         then u0t else r);

check_non_join_redpair ::
  forall a b.
    (Key a, Showa a,
      Showa b) => Redtriple_ext a b () ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        Term a b ->
                          Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_redpair rp rs rt sa t =
  catch_errora
    (bindb (valid rp)
      (\ _ ->
        bindb (catch_errora (forallM (ns rp) (reverse_rules rs ++ rt))
                (\ x -> Inl (snd x)))
          (\ _ -> s rp (sa, t))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'd', 'i',
               's', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-',
               'j', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'v',
               'i', 'a', ' ', 'd', 'i', 's', 'c', 'r', 'i', 'm', 'i', 'n', 'a',
               't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', 's'] .
            shows_nl . x));

non_join_with_ta ::
  forall a b c d e f g.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a, Showa a, Ceq b, Ccompare b, Compare_order b, Default b, Eq b,
      Set_impl b, Showa b, Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c,
      Compare_order c, Eq c, Set_impl c, Showa c, Showa d, Card_UNIV e, Cenum e,
      Ceq e, Cproper_interval e, Compare_order e, Eq e, Set_impl e, Showa e,
      Finite_UNIV f, Cenum f, Ceq f, Cproper_interval f, Compare_order f, Eq f,
      Set_impl f, Showa f,
      Showa g) => Tree_automaton a b ->
                    Ta_relation a ->
                      [(Term b c, Term b c)] ->
                        Term b d ->
                          Tree_automaton e b ->
                            Ta_relation e ->
                              [(Term b f, Term b f)] ->
                                Term b g ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
non_join_with_ta ta1 rel1 r1 t1 ta2 rel2 r2 t2 =
  let {
    tA1 = ta_of_ta ta1;
    tA2 = ta_of_ta ta2;
  } in bindb (check (ta_member t1 tA1)
               (shows_prec_term zero_nat t1 .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e',
                     'p', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'f', 'i', 'r', 's',
                     't', ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n']))
         (\ _ ->
           bindb (check (ta_member t2 tA2)
                   (shows_prec_term zero_nat t2 .
                     shows_prec_list zero_nat
                       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                         'e', 'p', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'f', 'i',
                         'r', 's', 't', ' ', 'a', 'u', 't', 'o', 'm', 'a', 't',
                         'o', 'n']))
             (\ _ ->
               bindb (check (ta_empty (intersect_ta tA1 tA2))
                       (shows_prec_list zero_nat
                         ['i', 'n', 't', 'e', 'r', 's', 'e', 'c', 't', 'i', 'o',
                           'n', ' ', 'o', 'f', ' ', 'a', 'u', 't', 'o', 'm',
                           'a', 't', 'a', ' ', 'i', 's', ' ', 'n', 'o', 'n',
                           '-', 'e', 'm', 'p', 't', 'y']))
                 (\ _ ->
                   bindb (catch_errora (tree_aut_trs_closed ta1 rel1 r1)
                           (\ x ->
                             Inl (shows_prec_list zero_nat
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 'e', 'n', 's', 'u', 'r', 'e',
                                      ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e',
                                      ' ', 'u', 'n', 'd', 'e', 'r', ' ', 'r',
                                      'e', 'w', 'r', 'i', 't', 'i', 'n', 'g',
                                      ' ', 'f', 'o', 'r', ' ', 'f', 'i', 'r',
                                      's', 't', ' ', 'a', 'u', 't', 'o', 'm',
                                      'a', 't', 'o', 'n'] .
                                   shows_nl . x)))
                     (\ _ ->
                       catch_errora (tree_aut_trs_closed ta2 rel2 r2)
                         (\ x ->
                           Inl (shows_prec_list zero_nat
                                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                    ' ', 'e', 'n', 's', 'u', 'r', 'e', ' ', 'c',
                                    'l', 'o', 's', 'u', 'r', 'e', ' ', 'u', 'n',
                                    'd', 'e', 'r', ' ', 'r', 'e', 'w', 'r', 'i',
                                    't', 'i', 'n', 'g', ' ', 'f', 'o', 'r', ' ',
                                    's', 'e', 'c', 'o', 'n', 'd', ' ', 'a', 'u',
                                    't', 'o', 'm', 'a', 't', 'o', 'n'] .
                                 shows_nl . x))))));

check_non_join ::
  forall a b.
    (Default a, Eq a, Key a, Showa a, Card_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b,
      Showa b) => [(Term (Lab a [Nat]) [Prelude.Char],
                     Term (Lab a [Nat]) [Prelude.Char])] ->
                    [(Term (Lab a [Nat]) [Prelude.Char],
                       Term (Lab a [Nat]) [Prelude.Char])] ->
                      Term (Lab a [Nat]) [Prelude.Char] ->
                        Term (Lab a [Nat]) [Prelude.Char] ->
                          Non_join_info (Lab a [Nat]) [Prelude.Char] b ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join rs rt s t Diff_NFs =
  bindb (check (not (equal_term s t))
          (shows_prec_list zero_nat
             ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', 's', ' '] .
            shows_prec_term zero_nat s .
              shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term zero_nat t .
                  shows_prec_list zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'i', 'd', 'e', 'n', 't', 'i', 'c',
                      'a', 'l']))
    (\ _ ->
      let {
        chknf =
          (\ sa r ->
            check (is_NF_trs r sa)
              (shows_prec_list zero_nat
                 ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                shows_term (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
                  sa .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'n',
                      'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']));
      } in bindb (chknf s rs) (\ _ -> chknf t rt));
check_non_join rs rt s t (Grounding sigma prf) =
  let {
    sigmaa = mk_subst Var sigma;
  } in check_non_join rs rt (subst_apply_term s sigmaa)
         (subst_apply_term t sigmaa) prf;
check_non_join rs rt s t (Subterm_NJ p prf) =
  bindb (check (member p (pos_gctxt (tcapI rs s)))
          (shows_prec_list zero_nat
             ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' '] .
            shows_prec_pos zero_nat p .
              shows_prec_list zero_nat
                [' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'c', 'a', 'p', 'p',
                  'e', 'd', ' ', 't', 'e', 'r', 'm', ' ', ' ', 'o', 'f', ' '] .
                shows_prec_term zero_nat s))
    (\ _ ->
      bindb (check (member p (pos_gctxt (tcapI rt t)))
              (shows_prec_list zero_nat
                 ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' '] .
                shows_prec_pos zero_nat p .
                  shows_prec_list zero_nat
                    [' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'c', 'a', 'p', 'p',
                      'e', 'd', ' ', 't', 'e', 'r', 'm', ' ', ' ', 'o', 'f',
                      ' '] .
                    shows_prec_term zero_nat t))
        (\ _ -> check_non_join rs rt (subt_at s p) (subt_at t p) prf));
check_non_join rs rt s t (Tcap_Non_Unif grd_subst) =
  let {
    sigma = grd_subst s t;
    cs = tcapI rs (subst_apply_term s sigma);
    ct = tcapI rt (subst_apply_term t sigma);
  } in check (is_none (mergea cs ct))
         (shows_prec_list zero_nat
            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
              'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
           shows_prec_term zero_nat s .
             shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
               shows_prec_term zero_nat t .
                 shows_prec_list zero_nat
                   [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                     'n', 'a', 'b', 'l', 'e']);
check_non_join rs rt s t (Tree_Aut_Intersect_Empty ta1 rel1 ta2 rel2) =
  catch_errora (non_join_with_ta ta1 rel1 rs s ta2 rel2 rt t)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
               'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
            shows_prec_term zero_nat s .
              shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term zero_nat t .
                  shows_prec_list zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                      'n', 'a', 'b', 'l', 'e'] .
                    shows_nl . x));
check_non_join rs rt s t (Finite_Model_Gt i) =
  catch_errora (check_non_join_finite_model i rs rt s t)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
               'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
            shows_prec_term zero_nat s .
              shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term zero_nat t .
                  shows_prec_list zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                      'n', 'a', 'b', 'l', 'e'] .
                    shows_nl . x));
check_non_join rs rt s t (Reduction_Pair_Gt rp) =
  catch_errora (check_non_join_redpair (get_redtriple rp) rs rt s t)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
               'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
            shows_prec_term zero_nat s .
              shows_prec_list zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term zero_nat t .
                  shows_prec_list zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                      'n', 'a', 'b', 'l', 'e'] .
                    shows_nl . x));
check_non_join rs rt s t (Usable_Rules_Reach_NJ prf) =
  check_non_join (usable_rules_reach_impl rs s) (usable_rules_reach_impl rt t) s
    t prf;
check_non_join rs rt s t (Usable_Rules_Reach_Unif_NJ u_sum prf) =
  (case u_sum of {
    Inl u ->
      bindb (check_usable_rules_unif rs u s)
        (\ _ -> check_non_join u rt s t prf);
    Inr u ->
      bindb (check_usable_rules_unif rt u t)
        (\ _ -> check_non_join rs u s t prf);
  });
check_non_join rs rt s t (Argument_Filter_NJ pi prf) =
  (case afs_of pi of {
    Nothing ->
      Inl (shows_prec_list zero_nat
            ['i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'a', 'r', 'g', 'u', 'm',
              'e', 'n', 't', ' ', 'f', 'i', 'l', 't', 'e', 'r']);
    Just pia -> let {
                  af = af_term pia;
                  afs = af_rules pia;
                } in check_non_join (afs rs) (afs rt) (af s) (af t) prf;
  });

ru_impl ::
  forall a b.
    [((Term a b, Term a b), [(Term a b, Term a b)])] -> [(Term a b, Term a b)];
ru_impl r = map fst r;

check_conditional_non_cr ::
  forall a b.
    (Default a, Eq a, Key a, Showa a, Card_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b,
      Showa b) => [((Term (Lab a [Nat]) [Prelude.Char],
                      Term (Lab a [Nat]) [Prelude.Char]),
                     [(Term (Lab a [Nat]) [Prelude.Char],
                        Term (Lab a [Nat]) [Prelude.Char])])] ->
                    Term (Lab a [Nat]) [Prelude.Char] ->
                      Term (Lab a [Nat]) [Prelude.Char] ->
                        Term (Lab a [Nat]) [Prelude.Char] ->
                          [Cstep_proof (Lab a [Nat]) [Prelude.Char]] ->
                            [Cstep_proof (Lab a [Nat]) [Prelude.Char]] ->
                              Non_join_info (Lab a [Nat]) [Prelude.Char] b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conditional_non_cr r s t u ps qs reason =
  bindb (check_csteps r s t ps)
    (\ _ ->
      bindb (check_csteps r s u qs)
        (\ _ -> check_non_join (ru_impl r) (ru_impl r) t u reason));

find_index :: forall a. (Eq a) => Nat -> a -> [a] -> Sum () Nat;
find_index i x [] = Inl ();
find_index i x (y : ys) = (if x == y then Inr i else find_index (suc i) x ys);

check_inline_conds_rule ::
  forall a b.
    (Compare a, Eq a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      [(Term a b, Term a b)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char])
                          ([((Term a b, Term a b), [(Term a b, Term a b)])],
                            ((Term a b, Term a b), [(Term a b, Term a b)]));
check_inline_conds_rule r rho [] = Inr (r, rho);
check_inline_conds_rule r rho (c : cs) =
  catch_errora
    (let {
       a = rho;
       (aa, b) = a;
     } in let {
            (l, _) = aa;
          } in (\ csa ->
                 let {
                   (s, t) = c;
                 } in bindb (check (is_Var t)
                              (shows_prec_list zero_nat
                                ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                  ' ', 'w', 'i', 't', 'h', ' ', 'n', 'o', 'n',
                                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
                                  ' ', 'r', 'h', 's']))
                        (\ _ ->
                          let {
                            x = the_Var t;
                          } in bindb (catch_errora (find_index zero_nat c csa)
                                       (\ xa ->
 Inl (let {
        () = xa;
      } in shows_prec_list zero_nat
             ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'd', 'o', 'e',
               's', ' ', 'n', 'o', 't', ' ', 'o', 'c', 'c', 'u', 'r', ' ', 'i',
               'n', ' ', 'r', 'u', 'l', 'e'])))
                                 (\ i ->
                                   bindb (check (not (contains_var_term x s))
   (shows_prec_list zero_nat
     ['o', 'c', 'c', 'u', 'r', 's', ' ', 'c', 'h', 'e', 'c', 'k', ' ', 'f', 'a',
       'i', 'l', 'e', 'd']))
                                     (\ _ ->
                                       bindb
 (check (not (contains_var_term x l))
   (shows_prec_list zero_nat
     ['i', 'n', 'l', 'i', 'n', 'i', 'n', 'g', ' ', 'n', 'o', 't', ' ', 'a', 'l',
       'l', 'o', 'w', 'e', 'd', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' ', 'o',
       'f', ' ', 'r', 'u', 'l', 'e']))
 (\ _ ->
   bindb (check
           (not (member x
                  (sup_set
                    (sup_seta (image vars_term (image snd (set (take i csa)))))
                    (sup_seta
                      (image vars_term (image snd (set (drop (suc i) csa))))))))
           (shows_prec_list zero_nat
             ['i', 'n', 'l', 'i', 'n', 'i', 'n', 'g', ' ', 'n', 'o', 't', ' ',
               'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'i', 'n', ' ', 'r', 'h',
               's', 's', ' ', 'o', 'f', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', 's']))
     (\ _ ->
       check_inline_conds_rule (inline i rho : removeAll rho r) (inline i rho)
         (map (\ (u, ab) -> (subst_apply_term u (subst x s), ab)) cs)))))))
            b)
    (\ x ->
      Inl (((((shows_prec_list zero_nat
                 ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i', 'l', 'e', ' ',
                   'i', 'n', 'l', 'i', 'n', 'i', 'n', 'g', ' ', 'c', 'o', 'n',
                   'd', 'i', 't', 'i', 'o', 'n', ' '] .
                shows_eq (shows_prec zero_nat) (shows_prec zero_nat) c) .
               shows_prec_list zero_nat
                 [' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', ' ']) .
              shows_crule (shows_prec zero_nat) (shows_prec zero_nat) rho) .
             shows_nl) .
            x));

check_inline_conds_ctrs ::
  forall a b.
    (Compare a, Eq a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    [(((Term a b, Term a b), [(Term a b, Term a b)]),
                       [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        [((Term a b, Term a b), [(Term a b, Term a b)])];
check_inline_conds_ctrs r [] = Inr r;
check_inline_conds_ctrs ra ((r, cs) : rcs) =
  catch_errora
    (bindb
      (check (membera ra r)
        (shows_crule (shows_prec zero_nat) (shows_prec zero_nat) r .
          shows_prec_list zero_nat
            [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'o', 'c', 'c',
              'u', 'r', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'i', 'n', 'p',
              'u', 't', ' ', 'C', 'T', 'R', 'S']))
      (\ _ ->
        bindb (check_inline_conds_rule ra r cs)
          (\ (rb, raa) ->
            check_inline_conds_ctrs (raa : removeAll raa rb) rcs)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i', 'l', 'e', ' ', 'i',
                'n', 'l', 'i', 'n', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 'd', 'i',
                't', 'i', 'o', 'n', 's'] .
             shows_nl) .
            x));

check_same_set :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_same_set xs ys =
  bindb (check_subseteq xs ys) (\ _ -> check_subseteq ys xs);

check_inline_conds ::
  forall a b.
    (Compare a, Eq a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [(((Term a b, Term a b), [(Term a b, Term a b)]),
                         [(Term a b, Term a b)])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_inline_conds ra r rcs =
  bindb (check_inline_conds_ctrs ra rcs)
    (\ raa ->
      catch_errora (check_same_set r raa)
        (\ _ ->
          Inl ((((((((shows_prec_list zero_nat
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i', 'l', 'e',
                          ' ', 'i', 'n', 'l', 'i', 'n', 'i', 'n', 'g', ':'] .
                       shows_nl) .
                      shows_prec_list zero_nat
                        ['i', 'n', 't', 'e', 'r', 'n', 'a', 'l', 'l', 'y', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'e', 'd', ' ', 'C', 'T',
                          'R', 'S']) .
                     shows_nl) .
                    shows_ctrs (shows_prec zero_nat) (shows_prec zero_nat)
                      raa) .
                   shows_nl) .
                  shows_prec_list zero_nat
                    ['b', 'u', 't', ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c',
                      'a', 't', 'e', ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n',
                      's', ' ', 'C', 'T', 'R', 'S']) .
                 shows_nl) .
                shows_ctrs (shows_prec zero_nat) (shows_prec zero_nat) r)));

check_infeasible_rules ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => [((Term a b, Term a b), c)] ->
                    [(((Term a b, Term a b), [(Term a b, Term a b)]),
                       Infeasibility_proof a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_infeasible_rules r =
  (\ xs ->
    catch_errora
      (forallM
        (\ (ra, ps) ->
          catch_errora (check_infeasibleb r (snd ra) ps)
            (\ x ->
              Inl ((((shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                       shows_crule (shows_prec zero_nat) (shows_prec zero_nat)
                         ra) .
                      shows_prec_list zero_nat
                        [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
                          'e', 'a', 's', 'i', 'b', 'l', 'e', ' ']) .
                     shows_nl) .
                    x)))
        xs)
      (\ x -> Inl (snd x)));

check_ccr_trans ::
  forall a b c d.
    (Default b, Eq b, Key b, Showa b, Eq c, Key c, Showa c, Finite_UNIV d,
      Cenum d, Ceq d, Cproper_interval d, Eq d, Key d, Mapping_impl d,
      Set_impl d,
      Showa d) => ([a] -> [Prelude.Char]) ->
                    [((Term (Lab b c) d, Term (Lab b c) d),
                       [(Term (Lab b c) d, Term (Lab b c) d)])] ->
                      Ccr_transformation b c d ->
                        Sum ([Prelude.Char] -> [Prelude.Char])
                          [((Term (Lab b c) d, Term (Lab b c) d),
                             [(Term (Lab b c) d, Term (Lab b c) d)])];
check_ccr_trans i ra (Inline_Conditions_CCRT r rcs) =
  debug (i [])
    ['I', 'n', 'l', 'i', 'n', 'e', ' ', 'C', 'o', 'n', 'd', 'i', 't', 'i', 'o',
      'n', 's']
    (bindb (check_inline_conds ra r rcs) (\ _ -> Inr r));
check_ccr_trans i r (Infeasible_Rule_Removal_CCRT rps) =
  debug (i [])
    ['I', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', ' ', 'R', 'u', 'l', 'e',
      ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (check_infeasible_rules r rps)
      (\ _ -> Inr (list_diff r (map fst rps))));

check_redundant_rules_ncr ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_redundant_rules_ncr ra r n =
  bindb (catch_errora (check_subseteq ra r)
          (\ _ ->
            Inl (shows_prec_list zero_nat
                  ['o', 'l', 'd', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                    'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 's', 'y', 's', 't',
                    'e', 'm', ' ', 'o', 'f', ' ', 'g', 'i', 'v', 'e', 'n', ' ',
                    'T', 'R', 'S'])))
    (\ _ ->
      let {
        s = list_diff r ra;
        t = list_diff ra r;
      } in bindb (catch_errora
                   (forallM
                     (\ (l, rb) ->
                       check (membera (reachable_terms ra l n) rb)
                         (shows_prec_list zero_nat
                            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                              's', 'i', 'm', 'u', 'l', 'a', 't', 'e', ' ', 'r',
                              'u', 'l', 'e', ' '] .
                           shows_rule (shows_prec zero_nat)
                             (shows_prec zero_nat) [' ', '-', '>', ' ']
                             (l, rb)))
                     s)
                   (\ x -> Inl (snd x)))
             (\ _ ->
               catch_errora
                 (forallM
                   (\ (l, raa) ->
                     check (membera (reachable_terms r l n) raa)
                       (shows_prec_list zero_nat
                          ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                            's', 'i', 'm', 'u', 'l', 'a', 't', 'e', ' ', 'r',
                            'u', 'l', 'e', ' '] .
                         shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                           [' ', '-', '>', ' '] (l, raa)))
                   t)
                 (\ x -> Inl (snd x))));

check_modularity_ncr ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_modularity_ncr ra r =
  bindb (catch_errora (check_subseteq r ra)
          (\ _ ->
            Inl (shows_prec_list zero_nat
                  ['n', 'e', 'w', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                    'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 's', 'y', 's', 't',
                    'e', 'm', ' ', 'o', 'f', ' ', 'g', 'i', 'v', 'e', 'n', ' ',
                    'T', 'R', 'S'])))
    (\ _ ->
      let {
        s = list_diff ra r;
        f = funas_trs_list r;
        g = funas_trs_list s;
      } in bindb (check (less_eq_set (inf_set (set f) (set g)) bot_set)
                   (shows_prec_list zero_nat
                     ['s', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', 's', ' ',
                       'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'i', 's',
                       'j', 'o', 'i', 'n', 't']))
             (\ _ ->
               bindb (check_varcond_subset r)
                 (\ _ ->
                   catch_errora
                     (catch_errora
                       (forallM
                         (\ x ->
                           (if let {
                                 (l, _) = x;
                               } in not (is_Var l)
                             then Inr () else Inl x))
                         s)
                       (\ x -> Inl (snd x)))
                     (\ _ ->
                       Inl (shows_prec_list zero_nat
                             ['l', 'h', 's', 's', ' ', 'm', 'u', 's', 't', ' ',
                               'n', 'o', 't', ' ', 'b', 'e', ' ', 'v', 'a', 'r',
                               'i', 'a', 'b', 'l', 'e', 's'])))));

check_non_cr ::
  forall a b.
    (Default a, Eq a, Key a, Showa a, Card_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b,
      Showa b) => [(Term (Lab a [Nat]) [Prelude.Char],
                     Term (Lab a [Nat]) [Prelude.Char])] ->
                    Term (Lab a [Nat]) [Prelude.Char] ->
                      [(Pos, ((Term (Lab a [Nat]) [Prelude.Char],
                                Term (Lab a [Nat]) [Prelude.Char]),
                               Term (Lab a [Nat]) [Prelude.Char]))] ->
                        [(Pos, ((Term (Lab a [Nat]) [Prelude.Char],
                                  Term (Lab a [Nat]) [Prelude.Char]),
                                 Term (Lab a [Nat]) [Prelude.Char]))] ->
                          Non_join_info (Lab a [Nat]) [Prelude.Char] b ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_cr r s seq1 seq2 reason =
  let {
    chk = check_rsteps_last r s;
  } in bindb (chk seq1)
         (\ _ ->
           bindb (chk seq2)
             (\ _ ->
               check_non_join r r (rseq_last s seq1) (rseq_last s seq2)
                 reason));

check_ncr_proof ::
  forall a b c.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            Ncr_proof b [Nat] [Prelude.Char] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ncr_proof a ia i j r (SN_NWCR prf) =
  debug (ia []) ['S', 'N', '_', 'N', 'W', 'C', 'R']
    (let {
       tp = mkc i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a
                    (ia . shows_string ['.', '1']) tp prf)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 's', 't', 'r', 'o',
                                  'n', 'g', ' ', 'n', 'o', 'r', 'm', 'a', 'l',
                                  'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', '+',
                                  ' ', 'w', 'c', 'r'] .
                                shows_nl . indent x)))
            (\ _ ->
              catch_errora
                (check
                  (not (isOK (check_critical_pairs_NF r
                               (critical_pairs_impl r r))))
                  (shows_prec_list zero_nat
                    ['a', 'l', 'l', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l',
                      ' ', 'p', 'a', 'i', 'r', 's', ' ', 'a', 'r', 'e', ' ',
                      'j', 'o', 'i', 'n', 'a', 'b', 'l', 'e']))
                (\ x ->
                  Inl (ia . shows_prec_list zero_nat
                              ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                                ' ', 'd', 'i', 's', 'p', 'r', 'o', 'v', 'i',
                                'n', 'g', ' ', 'l', 'o', 'c', 'a', 'l', ' ',
                                'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c',
                                'e', ' ', 'o', 'f', ' '] .
                              shows_tp (shows_prec_lab zero_nat)
                                (shows_prec_list zero_nat) i tp .
                                shows_nl . indent x))));
check_ncr_proof a ia i j r (Non_Join s seq1 seq2 prf) =
  debug (ia []) ['N', 'o', 'n', '_', 'J', 'o', 'i', 'n']
    (catch_errora (check_non_cr r s seq1 seq2 prf)
      (\ x ->
        Inl (ia . shows_prec_list zero_nat
                    ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'd',
                      'i', 's', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'C',
                      'R', ' ', 'o', 'f', ' '] .
                    shows_trs (shows_prec_lab zero_nat)
                      (shows_prec_list zero_nat)
                      ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                        't', 'e', 'm', ':']
                      [' ', '-', '>', ' '] r .
                      shows_nl . indent x)));
check_ncr_proof a ia i j ra (NCR_Disj_Subtrs r prf) =
  debug (ia []) ['M', 'o', 'd', 'u', 'l', 'a', 'r', 'i', 't', 'y']
    (bindb
      (catch_errora (check_modularity_ncr ra r)
        (\ x ->
          Inl (ia . shows_prec_list zero_nat
                      ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                        'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'm', 'o',
                        'd', 'u', 'l', 'a', 'r', 'i', 't', 'y', ' ', 't', 'o',
                        ' ', 's', 'w', 'i', 't', 'c', 'h', ' ', 't', 'o', ' '] .
                      shows_trs (shows_prec_lab zero_nat)
                        (shows_prec_list zero_nat)
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                          't', 'e', 'm', ':']
                        [' ', '-', '>', ' '] r .
                        shows_nl . indent x)))
      (\ _ ->
        catch_errora
          (check_ncr_proof a (ia . shows_string ['.', '1']) i j r prf)
          (\ x ->
            Inl (ia . shows_string
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'd', 'u',
                          'l', 'a', 'r', ' ', 'd', 'e', 'c', 'o', 'm', 'p', 'o',
                          's', 'i', 't', 'i', 'o', 'n'] .
                        shows_nl . indent x))));
check_ncr_proof a ia i j r (NCR_Redundant_Rules rs n prf) =
  debug (ia [])
    ['R', 'e', 'd', 'u', 'n', 'd', 'a', 'n', 't', ' ', 'R', 'u', 'l', 'e', 's']
    (bindb
      (catch_errora
        (check_ncr_proof a (ia . shows_string ['.', '1']) i j rs prf)
        (\ x ->
          Inl (ia . shows_prec_list zero_nat
                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                        'n', ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'n',
                        'o', 'n', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c',
                        'e', ' ', 'o', 'f', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
                        'e', 'd', ' ', 'T', 'R', 'S'] .
                      shows_nl .
                        shows_trs (shows_prec_lab zero_nat)
                          (shows_prec_list zero_nat)
                          ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                            's', 't', 'e', 'm', ':']
                          [' ', '-', '>', ' '] rs .
                          indent x)))
      (\ _ ->
        catch_errora (check_redundant_rules_ncr r rs n)
          (\ x ->
            Inl (ia . shows_prec_list zero_nat
                        ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c', 'h',
                          'e', 'c', 'k', 'i', 'n', 'g', ' ', 'r', 'e', 'd', 'u',
                          'n', 'd', 'a', 'n', 't', ' ', 'r', 'u', 'l', 'e', 's',
                          ' ', 't', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a',
                          't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 't', 'h', 'e',
                          ' ', 'T', 'R', 'S'] .
                        shows_nl .
                          shows_trs (shows_prec_lab zero_nat)
                            (shows_prec_list zero_nat)
                            ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                              's', 't', 'e', 'm', ':']
                            [' ', '-', '>', ' '] r .
                            indent x))));

check_conditional_ncr_proof ::
  forall a b c.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [((Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]),
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])])] ->
                            Conditional_ncr_proof b [Nat] [Prelude.Char]
                              [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conditional_ncr_proof a ia i j r (Unconditional_CNCR prf) =
  debug (ia [])
    ['U', 'n', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l']
    (bindb
      (catch_errora
        (catch_errora
          (forallM (\ x -> (if null (snd x) then Inr () else Inl x)) r)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl ((shows_prec_list zero_nat
                  ['r', 'u', 'l', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'n', 'o',
                    'n', '-', 'e', 'm', 'p', 't', 'y', ' ', 'c', 'o', 'n', 'd',
                    'i', 't', 'i', 'o', 'n', 's'] .
                 shows_nl) .
                shows_crule (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
                  x)))
      (\ _ -> check_ncr_proof a ia i j (map fst r) prf));
check_conditional_ncr_proof a ia i j r (Transformation_CNCR t prf) =
  debug (ia [])
    ['C', 'R', ' ', 'P', 'r', 'e', 's', 'e', 'r', 'v', 'i', 'n', 'g', ' ', 'T',
      'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n']
    (bindb (check_ccr_trans ia r t)
      (\ ra -> check_conditional_ncr_proof a ia i j ra prf));
check_conditional_ncr_proof a ia i j r (Non_Join_CNCR s t u ps qs prf) =
  debug (ia [])
    ['C', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'N', 'o', 'n',
      '-', 'J', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't', 'y']
    (catch_errora (check_conditional_non_cr r s t u ps qs prf)
      (\ x ->
        Inl (ia . shows_prec_list zero_nat
                    ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'd',
                      'i', 's', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'C',
                      'R', ' ', 'o', 'f', ' '] .
                    shows_ctrs (shows_prec_lab zero_nat)
                      (shows_prec_list zero_nat) r .
                      shows_nl . indent x)));

check_subsumptions_guided ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [((Term a b, Term a b),
                       [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumptions_guided e [] = Inr ();
check_subsumptions_guided ea ((e, seq) : convs) =
  bindb (catch_errora (check_conversiona ea seq (fst e) (snd e))
          (\ x ->
            Inl (shows_string
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c',
                     'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'f', 'o',
                     'r', ' ', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '=', ' '] e .
                    shows_nl . x)))
    (\ _ -> check_subsumptions_guided (e : ea) convs);

check_convertible_instance ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b, Term a b) ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_convertible_instance eq e convs =
  bindb (catch_errora
          (existsM
            (\ c ->
              check (instance_rule (fst c) eq)
                (shows_string
                   ['n', 'o', 't', ' ', 'a', 'n', ' ', 'i', 'n', 's', 't', 'a',
                     'n', 'c', 'e', ' ', 'o', 'f', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '=', ' '] eq))
            convs)
          (\ _ ->
            Inl (shows_prec_list zero_nat
                  [' ', 'n', 'o', ' ', 'i', 'n', 's', 't', 'a', 'n', 'c', 'e',
                    ' ', 'f', 'o', 'u', 'n', 'd'])))
    (\ _ -> check_subsumptions_guided e convs);

check_subsumption_guided ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption_guided ea e convs =
  bindb (catch_errora (check_subseteq ea (map fst convs))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i',
                     'n', 'd', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o',
                     'n', ' ', 'f', 'o', 'r', ' ', 'e', 'q', 'u', 'a', 't', 'i',
                     'o', 'n', ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '=', ' '] x)))
    (\ _ -> check_subsumptions_guided e convs);

check_subsumption_NF ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption_NF e r =
  catch_errora
    (forallM
      (\ ea ->
        catch_errora (check_join_NF r (fst ea) (snd ea))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'j', 'o',
                     'i', 'n', ' ', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
                     ' '] .
                  shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                    [' ', '=', ' '] ea .
                    shows_nl . x)))
      e)
    (\ x -> Inl (snd x));

check_subsumption ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Maybe [((Term a b, Term a b),
                               [(Pos, ((Term a b, Term a b),
(Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption e r convs_o = (case convs_o of {
                                  Nothing -> check_subsumption_NF e r;
                                  Just a -> check_subsumption_guided e r a;
                                });

check_completion_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])] ->
                              Completion_proof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_completion_proof a ia i j e r (SN_WCR_Eq joins_i prf conv1 conv2) =
  debug (ia []) ['S', 'N', '_', 'W', 'C', 'R', '_', 'E', 'q']
    (let {
       tp = mkc i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a
                    (ia . shows_string ['.', '1']) tp prf)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 's', 't', 'r', 'o',
                                  'n', 'g', ' ', 'n', 'o', 'r', 'm', 'a', 'l',
                                  'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', '+',
                                  ' ', 'w', 'c', 'r'] .
                                shows_nl . indent x)))
            (\ _ ->
              bindb (catch_errora (check_subsumption_guided r e conv1)
                      (\ x ->
                        Inl (ia . shows_prec_list zero_nat
                                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ',
                                      'w', 'h', 'e', 'n', ' ', 's', 'h', 'o',
                                      'w', 'i', 'n', 'g', ' ', 't', 'h', 'a',
                                      't', ' ', 'r', 'e', 'w', 'r', 'i', 't',
                                      'e', ' ', 'r', 'e', 'l', 'a', 't', 'i',
                                      'o', 'n', ' ', 'c', 'a', 'n', ' ', 'b',
                                      'e', ' ', 's', 'i', 'm', 'u', 'l', 'a',
                                      't', 'e', 'd', ' ', 'b', 'y', ' ', 'e',
                                      'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] .
                                    shows_nl . indent x)))
                (\ _ ->
                  bindb (catch_errora (check_subsumption e r conv2)
                          (\ x ->
                            Inl (ia . shows_prec_list zero_nat
[':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'h', 'o',
  'w', 'i', 'n', 'g', ' ', 't', 'h', 'a', 't', ' ', 'e', 'q', 'u', 'a', 't',
  'i', 'o', 'n', 's', ' ', 'c', 'a', 'n', ' ', 'b', 'e', ' ', 's', 'i', 'm',
  'u', 'l', 'a', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'r', 'e', 'w', 'r', 'i',
  't', 'e', ' ', 's', 'y', 's', 't', 'e', 'm'] .
shows_nl . indent x)))
                    (\ _ ->
                      catch_errora
                        (check_critical_pairs r (critical_pairs_impl r r)
                          joins_i)
                        (\ x ->
                          Inl (ia . shows_prec_list zero_nat
                                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ',
'w', 'h', 'e', 'n', ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'l', 'o', 'c',
'a', 'l', ' ', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'o', 'f',
' '] .
                                      shows_nl .
shows_tp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) i tp .
  shows_nl . indent x))))));

check_equational_disproof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            Equation_literal (Lab b [Nat]) [Prelude.Char] ->
                              Equational_disproof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_equational_disproof a ia i j e (Equation eq)
  (Completion_and_Normalization_Different r p) =
  debug (ia [])
    ['C', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', '_', 'a', 'n', 'd', '_',
      'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n']
    (bindb (check_completion_proof a ia i j e r p)
      (\ _ ->
        let {
          s = fst eq;
          t = snd eq;
        } in (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
               (Nothing, _) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab zero_nat)
                             (shows_prec_list zero_nat) t);
               (Just _, Nothing) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab zero_nat)
                             (shows_prec_list zero_nat) t);
               (Just sa, Just ta) ->
                 (if not (equal_term sa ta) then Inr ()
                   else Inl (shows_term (shows_prec_lab zero_nat)
                               (shows_prec_list zero_nat) s .
                              shows_string [' ', 'a', 'n', 'd', ' '] .
                                shows_term (shows_prec_lab zero_nat)
                                  (shows_prec_list zero_nat) t .
                                  shows_string
                                    [' ', 'h', 'a', 'v', 'e', ' ', 's', 'a',
                                      'm', 'e', ' ', 'n', 'o', 'r', 'm', 'a',
                                      'l', ' ', 'f', 'o', 'r', 'm', ' '] .
                                    shows_term (shows_prec_lab zero_nat)
                                      (shows_prec_list zero_nat) sa));
             })));
check_equational_disproof a ia i j e (Inequality eq)
  (Convertible_Instance convs) =
  debug (ia [])
    ['C', 'o', 'n', 'v', 'e', 'r', 't', 'i', 'b', 'l', 'e', '_', 'I', 'n', 's',
      't', 'a', 'n', 'c', 'e']
    (check_convertible_instance eq e convs);
check_equational_disproof a ia i j e (Inequality v)
  (Completion_and_Normalization_Different va vb) =
  Inl (shows_string
        ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'd', 'i',
          's', 'p', 'r', 'o', 'o', 'f']);
check_equational_disproof a ia i j e (Equation va) (Convertible_Instance v) =
  Inl (shows_string
        ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'd', 'i',
          's', 'p', 'r', 'o', 'o', 'f']);

match_crule ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                           ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                             Maybe (b -> Term a b);
match_crule rho_1 rho_2 =
  bind (zip_option
         (fst (fst rho_2) :
           snd (fst rho_2) : map fst (snd rho_2) ++ map snd (snd rho_2))
         (fst (fst rho_1) :
           snd (fst rho_1) : map fst (snd rho_1) ++ map snd (snd rho_1)))
    (match_list Var);

check_overlapa ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Infinite a, Showa a, Eq b,
      Showa b) => (a -> a) ->
                    (a -> a) ->
                      ([((Term b a, Term b a), [(Term b a, Term b a)])] ->
                        [(Term b a, Term b a)] ->
                          [(Term b a, Term b a)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        [((Term b a, Term b a), [(Term b a, Term b a)])] ->
                          ((Term b a, Term b a), [(Term b a, Term b a)]) ->
                            ((Term b a, Term b a), [(Term b a, Term b a)]) ->
                              Pos -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_overlapa xvar yvar check_infeasible r rho_1 rho_2 p =
  catch_errora
    (case mgu_var_disjoint_generic xvar yvar (subt_at (fst (fst rho_1)) p)
            (fst (fst rho_2))
      of {
      Nothing -> Inr ();
      Just (sigma_1, sigma_2) ->
        catch_errora
          (choice
            [check (equal_pos p Empty &&
                     equal_term (subst_apply_term (snd (fst rho_1)) sigma_1)
                       (subst_apply_term (snd (fst rho_2)) sigma_2))
               (shows_prec_list zero_nat
                 ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 't', 'r', 'i',
                   'v', 'i', 'a', 'l', ' ', 'r', 'o', 'o', 't', '-', 'o', 'v',
                   'e', 'r', 'l', 'a', 'p']),
              check (equal_pos p Empty &&
                      not (is_none (match_crule rho_1 rho_2)) &&
                        not (is_none (match_crule rho_2 rho_1)))
                (shows_prec_list zero_nat
                  ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r', 'o', 'o',
                    't', '-', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'o', 'f',
                    ' ', 'v', 'a', 'r', 'i', 'a', 'n', 't', 's', ' ', 'o', 'f',
                    ' ', 't', 'h', 'e', ' ', 's', 'a', 'm', 'e', ' ', 'r', 'u',
                    'l', 'e']),
              catch_errora
                (check_infeasible r (subst_list sigma_1 (snd rho_1))
                  (subst_list sigma_2 (snd rho_2)))
                (\ x ->
                  Inl ((shows_prec_list zero_nat
                          ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                            'b', 'e', ' ', 's', 'h', 'o', 'w', 'n', ' ', 't',
                            'o', ' ', 'b', 'e', ' ', 'i', 'n', 'f', 'e', 'a',
                            's', 'i', 'b', 'l', 'e'] .
                         shows_nl) .
                        x))])
          (\ x -> Inl (shows_sep id shows_nl x));
    })
    (\ x ->
      Inl (((shows_prec_list zero_nat ['t', 'h', 'e', ' '] .
              shows_coverlap rho_1 rho_2 p) .
             shows_nl) .
            x));

check_ao_infeasiblea ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => [((Term a b, Term a b), c)] ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        Ao_infeasibility_proof a b ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ao_infeasiblea r cs_1 cs_2 (AO_Infeasibility_Proof p) =
  check_infeasibleb r (cs_1 ++ cs_2) p;
check_ao_infeasiblea r cs_1 cs_2 (AO_Lhss_Equal s t u p) =
  bindb (check (membera cs_1 (s, t))
          ((shows_eq (shows_prec zero_nat) (shows_prec zero_nat) (s, t) .
             shows_prec_list zero_nat
               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'e', 'q',
                 'u', 'a', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ']) .
            shows_conditions (shows_prec zero_nat) (shows_prec zero_nat) cs_1))
    (\ _ ->
      bindb (check (membera cs_2 (s, u))
              ((shows_eq (shows_prec zero_nat) (shows_prec zero_nat) (s, u) .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'e',
                     'q', 'u', 'a', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ']) .
                shows_conditions (shows_prec zero_nat) (shows_prec zero_nat)
                  cs_2))
        (\ _ -> check_nonjoinable (map fst r) t u p));

check_ao_infeasible ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => [([(Term a b, Term a b)],
                     ([(Term a b, Term a b)], Ao_infeasibility_proof a b))] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ao_infeasible css r cs_1 cs_2 =
  catch_errora
    (existsM
      (\ (cs_1a, (cs_2a, p)) ->
        let {
          cs = cs_1 ++ cs_2;
          csa = cs_1a ++ cs_2a;
        } in bindb (check
                     (equal_nat (size_list cs_1a) (size_list cs_1) &&
                       equal_nat (size_list cs_2a) (size_list cs_2))
                     (shows_prec_list zero_nat
                       ['l', 'e', 'n', 'g', 't', 'h', 's', ' ', 'd', 'i', 'f',
                         'f', 'e', 'r']))
               (\ _ ->
                 bindb (check
                         (not (is_none (match_rules csa cs)) &&
                           not (is_none (match_rules cs csa)))
                         id)
                   (\ _ -> check_ao_infeasiblea r cs_1a cs_2a p)))
      css)
    (\ x -> Inl (shows_sep id shows_nl x));

check_almost_orthogonal_modulo_infeasibilitya ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a,
      Showa a) => [([(Term a [Prelude.Char], Term a [Prelude.Char])],
                     ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                       Ao_infeasibility_proof a [Prelude.Char]))] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]),
                       [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_almost_orthogonal_modulo_infeasibilitya css r =
  bindb (check_left_linear_trs (map fst r))
    (\ _ ->
      catch_errora
        (forallM
          (\ rho_1 ->
            let {
              l_1 = fst (fst rho_1);
            } in catch_errora
                   (forallM
                     (\ rho_2 ->
                       catch_errora
                         (forallM
                           (check_overlapa (\ a -> 'x' : a) (\ a -> 'y' : a)
                             (check_ao_infeasible css) r rho_1 rho_2)
                           (funposs_list l_1))
                         (\ x -> Inl (snd x)))
                     r)
                   (\ x -> Inl (snd x)))
          r)
        (\ x -> Inl (snd x)));

x_vars ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                       Nat -> Set b;
x_vars rho i =
  sup_set (vars_term (fst (fst rho)))
    (sup_seta (image vars_term (image snd (set (take i (snd rho))))));

extended_properly_oriented ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => Set ((Term a b, Term a b), [(Term a b, Term a b)]) -> Bool;
extended_properly_oriented r =
  ball r
    (\ rho ->
      less_eq_set (vars_term (snd (fst rho))) (vars_term (fst (fst rho))) ||
        not (all_interval_nat
              (not .
                (\ m ->
                  all_interval_nat
                    (\ i ->
                      less_eq_set (vars_term (fst (nth (snd rho) i)))
                        (x_vars rho i))
                    zero_nat m &&
                    all_interval_nat
                      (\ i ->
                        less_eq_set
                          (inf_set (vars_term (snd (fst rho)))
                            (vars_rule (nth (snd rho) i)))
                          (x_vars rho m))
                      m (size_list (snd rho))))
              zero_nat (suc (size_list (snd rho)))));

check_extended_properly_oriented ::
  forall a b.
    (Compare a, Eq a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_extended_properly_oriented r =
  check (extended_properly_oriented (set r))
    (shows_prec_list zero_nat
       ['t', 'h', 'e', ' ', 'g', 'i', 'v', 'e', 'n', ' ', 'C', 'T', 'R', 'S',
         ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't', 'e', 'n', 'd',
         'e', 'd', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 'l', 'y', ' ', 'o', 'r',
         'i', 'e', 'n', 't', 'e', 'd'] .
      shows_nl);

funas_crule ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => ((Term a b, Term a b), [(Term a b, Term a b)]) -> Set (a, Nat);
funas_crule rho = sup_set (funas_rule (fst rho)) (funas_trs (set (snd rho)));

funas_ctrs ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Set ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                 Set (a, Nat);
funas_ctrs r = sup_seta (image funas_crule r);

check_constructor_term ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showa a, Compare b, Eq b,
      Showa b) => Term a b ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_constructor_term s r =
  check (less_eq_set (funas_term s)
          (minus_set (funas_ctrs (set r)) (set (defined_list (map fst r)))))
    (((shows_prec_list zero_nat ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
        shows_term (shows_prec zero_nat) (shows_prec zero_nat) s) .
       shows_prec_list zero_nat
         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'c', 'o', 'n', 's',
           't', 'r', 'u', 'c', 't', 'o', 'r', ' ', 't', 'e', 'r', 'm']) .
      shows_nl);

check_Ru_NF ::
  forall a b.
    (Eq a, Key a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Term a b ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_Ru_NF s r =
  check (is_NF_trs (map fst r) s)
    (((shows_prec_list zero_nat ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
        shows_term (shows_prec zero_nat) (shows_prec zero_nat) s) .
       shows_prec_list zero_nat
         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'R', 'u', ' ',
           'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']) .
      shows_nl);

check_linear_term ::
  forall a b.
    (Showa a, Ceq b, Ccompare b, Set_impl b,
      Showa b) => Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_linear_term s =
  check (linear_term s)
    (((shows_prec_list zero_nat ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
        shows_term (shows_prec zero_nat) (shows_prec zero_nat) s) .
       shows_prec_list zero_nat
         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'l', 'i', 'n', 'e', 'a',
           'r']) .
      shows_nl);

check_ground_term ::
  forall a b.
    (Showa a, Showa b) => Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ground_term s =
  check (ground s)
    (((shows_prec_list zero_nat ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
        shows_term (shows_prec zero_nat) (shows_prec zero_nat) s) .
       shows_prec_list zero_nat
         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'g', 'r', 'o', 'u',
           'n', 'd', ' ', 't', 'e', 'r', 'm']) .
      shows_nl);

check_right_stable ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Key a, Set_impl a,
      Showa a, Ceq b, Ccompare b, Compare b, Eq b, Mapping_impl b, Set_impl b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_right_stable r =
  catch_errora
    (catch_errora
      (forallM
        (\ ra ->
          catch_errora
            (forallM
              (\ i ->
                let {
                  t_i = snd (nth (snd ra) i);
                } in bindb (catch_errora
                             (check_disjoint
                               (vars_term_list (fst (fst ra)) ++
                                 concatMap (\ (s, _) -> vars_term_list s)
                                   (take (suc i) (snd ra)) ++
                                   concatMap (\ (_, a) -> vars_term_list a)
                                     (take i (snd ra)))
                               (vars_term_list t_i))
                             (\ x ->
                               Inl (((((shows_prec_list zero_nat
  ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
 shows_prec zero_nat x) .
shows_prec_list zero_nat
  [' ', 'i', 'n', ' ', 'r', 'h', 's', ' ', 'o', 'f', ' ', 'c', 'o', 'n', 'd',
    'i', 't', 'i', 'o', 'n', ' ']) .
                                       shows_prec_nat zero_nat i) .
                                      shows_prec_list zero_nat
[' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's', 'h']) .
                                     shows_nl)))
                       (\ _ ->
                         catch_errora
                           (choice
                             [bindb (check_linear_term t_i)
                                (\ _ -> check_constructor_term t_i r),
                               bindb (check_ground_term t_i)
                                 (\ _ -> check_Ru_NF t_i r)])
                           (\ x -> Inl (shows_sep id shows_nl x))))
              (upt zero_nat (size_list (snd ra))))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((shows_prec_list zero_nat
              ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                'o', 't', ' ', 'r', 'i', 'g', 'h', 't', ' ', 's', 't', 'a', 'b',
                'l', 'e'] .
             shows_nl) .
            x));

check_level_confluence_modulo_infeasibilitya ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a,
      Showa a) => [([(Term a [Prelude.Char], Term a [Prelude.Char])],
                     ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                       Ao_infeasibility_proof a [Prelude.Char]))] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]),
                       [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_level_confluence_modulo_infeasibilitya css r =
  bindb (check_varcond_no_Var_lhs (map fst r))
    (\ _ ->
      bindb (check_type3 r)
        (\ _ ->
          bindb (check_extended_properly_oriented r)
            (\ _ ->
              bindb (check_right_stable r)
                (\ _ -> check_almost_orthogonal_modulo_infeasibilitya css r))));

trancl_of_list :: forall a. (Eq a) => [(a, a)] -> [(a, a)];
trancl_of_list xs =
  concatMap (\ x -> map (\ a -> (x, a)) (trancl_list_impl xs [x])) (map fst xs);

check_infeasiblea ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a, Showa a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => [([(Term a b, Term a b)], Infeasibility_proof a b)] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_infeasiblea css r cs_1 cs_2 =
  catch_errora
    (existsM
      (\ (cs, p) ->
        let {
          csa = cs_1 ++ cs_2;
        } in bindb (check
                     (not (is_none (match_rules cs csa)) &&
                       not (is_none (match_rules csa cs)))
                     id)
               (\ _ -> check_infeasibleb r (trancl_of_list cs) p))
      css)
    (\ x -> Inl (shows_sep id shows_nl x));

check_almost_orthogonal_modulo_infeasibility ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a,
      Showa a) => [([(Term a [Prelude.Char], Term a [Prelude.Char])],
                     Infeasibility_proof a [Prelude.Char])] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]),
                       [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_almost_orthogonal_modulo_infeasibility css r =
  bindb (check_left_linear_trs (map fst r))
    (\ _ ->
      catch_errora
        (forallM
          (\ rho_1 ->
            let {
              l_1 = fst (fst rho_1);
            } in catch_errora
                   (forallM
                     (\ rho_2 ->
                       catch_errora
                         (forallM
                           (check_overlapa (\ a -> 'x' : a) (\ a -> 'y' : a)
                             (check_infeasiblea css) r rho_1 rho_2)
                           (funposs_list l_1))
                         (\ x -> Inl (snd x)))
                     r)
                   (\ x -> Inl (snd x)))
          r)
        (\ x -> Inl (snd x)));

check_level_confluence_modulo_infeasibility ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Default a, Eq a, Key a,
      Set_impl a,
      Showa a) => [([(Term a [Prelude.Char], Term a [Prelude.Char])],
                     Infeasibility_proof a [Prelude.Char])] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]),
                       [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_level_confluence_modulo_infeasibility css r =
  bindb (check_varcond_no_Var_lhs (map fst r))
    (\ _ ->
      bindb (check_type3 r)
        (\ _ ->
          bindb (check_extended_properly_oriented r)
            (\ _ ->
              bindb (check_right_stable r)
                (\ _ -> check_almost_orthogonal_modulo_infeasibility css r))));

check_almost_orthogonal ::
  forall a.
    (Eq a,
      Showa a) => [((Term a [Prelude.Char], Term a [Prelude.Char]),
                     [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_almost_orthogonal r =
  bindb (check_left_linear_trs (map fst r))
    (\ _ ->
      catch_errora
        (forallM
          (\ rho_1 ->
            let {
              l_1 = fst (fst rho_1);
            } in catch_errora
                   (forallM
                     (\ rho_2 ->
                       catch_errora
                         (forallM
                           (check_overlapa (\ a -> 'x' : a) (\ a -> 'y' : a)
                             (\ _ _ _ ->
                               Inl (shows_string
                                     ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b',
                                       'i', 'l', 'i', 't', 'y', ' ', 'c', 'h',
                                       'e', 'c', 'k', ' ', 'n', 'o', 't', ' ',
                                       's', 'u', 'p', 'p', 'o', 'r', 't', 'e',
                                       'd']))
                             r rho_1 rho_2)
                           (funposs_list l_1))
                         (\ x -> Inl (snd x)))
                     r)
                   (\ x -> Inl (snd x)))
          r)
        (\ x -> Inl (snd x)));

check_level_confluence ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Key a, Set_impl a,
      Showa a) => [((Term a [Prelude.Char], Term a [Prelude.Char]),
                     [(Term a [Prelude.Char], Term a [Prelude.Char])])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_level_confluence r =
  bindb (check_varcond_no_Var_lhs (map fst r))
    (\ _ ->
      bindb (check_type3 r)
        (\ _ ->
          bindb (check_extended_properly_oriented r)
            (\ _ ->
              bindb (check_right_stable r)
                (\ _ -> check_almost_orthogonal r))));

funs_crule_list ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> [a];
funs_crule_list r = add_funs_rule (fst r) (funs_trs_list (snd r));

funs_ctrs_list ::
  forall a b. [((Term a b, Term a b), [(Term a b, Term a b)])] -> [a];
funs_ctrs_list trs = concatMap funs_crule_list trs;

check_source_preserving ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> [b]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_source_preserving crs zv =
  catch_errora
    (forallM
      (\ cr ->
        catch_errora
          (forallM
            (\ i ->
              catch_errora
                (catch_errora
                  (check_subseteq (vars_term_list (fst (fst cr))) (zv cr i))
                  (\ _ ->
                    Inl (shows_prec_list zero_nat
                           ['S', 'o', 'm', 'e', ' ', 'v', 'a', 'r', 'i', 'a',
                             'b', 'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's',
                             ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                             'o', 'c', 'c', 'u', 'r', ' ', 'i', 'n', ' ', 'Z',
                             '_'] .
                          shows_prec_nat zero_nat i .
                            shows_prec_list zero_nat ['.', ' ', '\n'])))
                (\ x ->
                  Inl (shows_string
                         ['T', 'h', 'e', ' ', 'u', 'n', 'r', 'a', 'v', 'e', 'l',
                           'i', 'n', 'g', ' ', 'i', 's', ' ', 'n', 'o', 't',
                           ' ', 's', 'o', 'u', 'r', 'c', 'e', ' ', 'p', 'r',
                           'e', 's', 'e', 'r', 'v', 'i', 'n', 'g', ' ', 'f',
                           'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
                        shows_crule (shows_prec zero_nat) (shows_prec zero_nat)
                          cr .
                          shows_nl . x)))
            (upt zero_nat (size_list (snd cr))))
          (\ x -> Inl (snd x)))
      crs)
    (\ x -> Inl (snd x));

y_impl ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> [b];
y_impl cr i =
  vars_term_list (snd (fst cr)) ++
    vars_term_list (snd (nth (snd cr) i)) ++
      vars_trs_list (drop (suc i) (snd cr));

check_Z_vars ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> [b]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_Z_vars crs z =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                catch_errora
                  (bindb
                    (catch_errora
                      (check_subseteq (list_inter (x_impl cr i) (y_impl cr i))
                        (z cr i))
                      (\ x ->
                        Inl (shows_string
                               ['V', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                              shows_prec zero_nat x .
                                shows_string
                                  [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't',
                                    ' ', 'o', 'c', 'c', 'u', 'r', ' ', 'i', 'n',
                                    ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
                                    ' ', 'l', 'i', 's', 't', ' ', 'o', 'f',
                                    ' '] .
                                  shows_prec_nat zero_nat (suc i) .
                                    shows_string
                                      ['.', ' ', 'U', '-', 's', 'y', 'm', 'b',
'o', 'l'] .
                                      shows_nl)))
                    (\ _ ->
                      check (distinct (z cr i))
                        (shows_string
                           [' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's',
                             ' ', 'i', 'n', ' ', 'a', 'd', 'd', 'i', 't', 'i',
                             'o', 'n', 'a', 'l', ' ', 'a', 'r', 'g', 'u', 'm',
                             'e', 'n', 't', 's', ' ', 'o', 'f', ' ', 'U', '-',
                             's', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'a', 'r',
                             'e', ' ', 'n', 'o', 't', ' ', 'd', 'i', 's', 't',
                             'i', 'n', 'c', 't', '.', ' '] .
                          shows_nl)))
                  (\ x ->
                    Inl (shows_string
                           ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's',
                             ' ', 'f', 'o', 'r', ' ', 'v', 'a', 'r', 'i', 'a',
                             'b', 'l', 'e', '-', 'l', 'i', 's', 't', 's', ' ',
                             'i', 'n', ' ', 'U', '-', 's', 'y', 'm', 'b', 'o',
                             'l', 's', ' ', 'f', 'o', 'r', ' '] .
                          shows_crule (shows_prec zero_nat)
                            (shows_prec zero_nat) cr .
                            shows_string
                              [' ', 'a', 'r', 'e', ' ', 'v', 'i', 'o', 'l', 'a',
                                't', 'e', 'd', '.'] .
                              shows_nl . x)))
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        crs)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string
             ['T', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'd', 'o', 'e', 's',
               ' ', 'n', 'o', 't', ' ', 'f', 'u', 'l', 'f', 'i', 'l', 'l', ' ',
               't', 'h', 'e', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
               ' ', 'o', 'n', ' ', 'Z', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
               'e', 's', '.', ' '] .
            shows_nl . x));

check_U_cond ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    Nat -> Ctxt a b) ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [a] ->
                        (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                          Nat -> [b]) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_U_cond u crs f z =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                (case u cr i of {
                  Hole ->
                    Inl (shows_prec_list zero_nat
                          [' ', 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e',
                            'd', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'c', 'o',
                            'n', 't', 'e', 'x', 't', '.']);
                  More fa [] Hole aft ->
                    catch_errora
                      (bindb
                        (catch_errora (check_disjoint [fa] f)
                          (\ _ ->
                            Inl (shows_string
                                   ['T', 'h', 'e', ' ', 'f', 'u', 'n', 'c', 't',
                                     'i', 'o', 'n', ' ', 's', 'y', 'm', 'b',
                                     'o', 'l', ' '] .
                                  shows_string (shows_prec zero_nat fa []) .
                                    shows_string
                                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
'f', 'r', 'e', 's', 'h', '.', ' '] .
                                      shows_nl)))
                        (\ _ ->
                          bindb (check (aft == map Var (z cr i))
                                  (shows_prec_list zero_nat
                                    [' ', 'U', ' ', 'd', 'o', 'e', 's', ' ',
                                      'n', 'o', 't', ' ', 'm', 'a', 'p', ' ',
                                      't', 'o', ' ', 'Z', ' ', 'v', 'a', 'r',
                                      's', ' ']))
                            (\ _ -> check_f cr i fa crs u)))
                      (\ x ->
                        Inl (shows_string
                               ['C', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 's', ' ', 'f', 'o', 'r', ' '] .
                              shows_crule (shows_prec zero_nat)
                                (shows_prec zero_nat) cr .
                                shows_string [' ', 'a', 't', ' ', ' '] .
                                  shows_prec_nat zero_nat i .
                                    shows_string
                                      [' ', 'a', 'r', 'e', ' ', 'v', 'i', 'o',
'l', 'a', 't', 'e', 'd', '.'] .
                                      shows_nl . x));
                  More _ [] (More _ _ _ _) _ ->
                    Inl (shows_prec_list zero_nat
                          [' ', 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e',
                            'd', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'c', 'o',
                            'n', 't', 'e', 'x', 't', '.']);
                  More _ (_ : _) _ _ ->
                    Inl (shows_prec_list zero_nat
                          [' ', 'U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e',
                            'd', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'c', 'o',
                            'n', 't', 'e', 'x', 't', '.']);
                }))
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        crs)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string
             ['T', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'd', 'o', 'e', 's',
               ' ', 'n', 'o', 't', ' ', 'f', 'u', 'l', 'f', 'i', 'l', 'l', ' ',
               't', 'h', 'e', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
               ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'U', ' ', 's', 'y', 'm',
               'b', 'o', 'l', 's', '.'] .
            shows_nl . x));

create_Umap_cr ::
  forall a b.
    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
      [(Term a b, Term a b)] ->
        Maybe [(a, (((Term a b, Term a b), [(Term a b, Term a b)]), Nat))];
create_Umap_cr cr r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      mapMa (\ (a, b) -> let {
                           (l, _) = a;
                         } in (\ i -> (case l of {
Var _ -> Nothing;
Fun _ [] -> Nothing;
Fun u (_ : _) -> Just (u, (cr, i));
                                      }))
                           b)
        (zip rr (upt zero_nat (size_list rr)));
  });

create_Umap ::
  forall a b.
    (Eq a) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                 [(Term a b, Term a b)])] ->
                a -> Maybe (((Term a b, Term a b), [(Term a b, Term a b)]),
                             Nat);
create_Umap c_rs = (case mapMa (\ (a, b) -> create_Umap_cr a b) c_rs of {
                     Nothing -> (\ _ -> Nothing);
                     Just u -> map_of (concat u);
                   });

create_zs :: forall a b. [(Term a b, Term a b)] -> Maybe (Nat -> [b]);
create_zs r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      bind (mapMa (\ a -> (case a of {
                            (Var _, _) -> Nothing;
                            (Fun _ [], _) -> Nothing;
                            (Fun _ (_ : ts), _) -> Just (map the_Var ts);
                          }))
             rr)
        (\ cs ->
          Just (\ i -> (if less_nat i (size_list cs) then nth cs i else [])));
  });

create_Z ::
  forall a b.
    (Eq a,
      Eq b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                  [(Term a b, Term a b)])] ->
                 Maybe (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                         Nat -> [b]);
create_Z c_rs =
  bind (mapMa (\ (cr, rs) -> bind (create_zs rs) (\ zs -> Just (cr, zs))) c_rs)
    (\ cr_zs -> let {
                  mc = map_of cr_zs;
                } in Just (\ cr -> (case mc cr of {
                                     Nothing -> (\ _ -> []);
                                     Just zs -> zs;
                                   })));

check_sp_unraveling ::
  forall a b.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Set_impl b,
      Showa b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                     [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        [(Term a b, Term a b)];
check_sp_unraveling c_rs ctrs =
  catch_errora
    (bindb
      (catch_errora (check_same_set ctrs (map fst c_rs))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
                   ' ', 'r', 'u', 'l', 'e', ' '] .
                shows_crule (shows_prec zero_nat) (shows_prec zero_nat) x .
                  shows_nl)))
      (\ _ ->
        bindb (case create_U c_rs of {
                Nothing ->
                  Inl (shows_prec_list zero_nat
                        ['u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'e',
                          'x', 't', 'r', 'a', 'c', 't', ' ', 'u', 'n', 'r', 'a',
                          'v', 'e', 'l', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 't',
                          'e', 'x', 't', 's']);
                Just a -> Inr a;
              })
          (\ u ->
            bindb (case create_Z c_rs of {
                    Nothing ->
                      Inl (shows_prec_list zero_nat
                            ['u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ',
                              'e', 'x', 't', 'r', 'a', 'c', 't', ' ', 'Z', ' ',
                              'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']);
                    Just a -> Inr a;
                  })
              (\ z ->
                bindb (Inr (create_Umap c_rs))
                  (\ _ ->
                    bindb (check_U_cond u ctrs (funs_ctrs_list ctrs) z)
                      (\ _ ->
                        bindb (check_Z_vars ctrs z)
                          (\ _ ->
                            bindb (check_dctrs ctrs)
                              (\ _ ->
                                bindb (check_type3 ctrs)
                                  (\ _ ->
                                    bindb (catch_errora
    (forallM
      (\ (c, rs) ->
        check (rules_impl u c == rs)
          (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
               'r', 'u', 'l', 'e', 's', ' ', 'o', 'f', ' '] .
            shows_crule (shows_prec zero_nat) (shows_prec zero_nat) c .
              shows_nl))
      c_rs)
    (\ x -> Inl (snd x)))
                                      (\ _ ->
bindb (catch_errora (check_left_linear_trs (concatMap snd c_rs))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['t', 'h', 'e', ' ', 'u', 'n', 'r', 'a', 'v', 'e', 'l', 'e',
                   'd', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o', 't',
                   ' ', 'l', 'e', 'f', 't', '-', 'l', 'i', 'n', 'e', 'a', 'r',
                   ' '] .
                shows_nl . x)))
  (\ _ ->
    bindb (catch_errora (check_wf_ctrs ctrs)
            (\ x ->
              Inl (shows_prec_list zero_nat
                     ['t', 'h', 'e', ' ', 'C', 'T', 'R', 'S', ' ', 'i', 's',
                       ' ', 'n', 'o', 't', ' ', 'w', 'e', 'l', 'l', '-', 'f',
                       'o', 'r', 'm', 'e', 'd', ' '] .
                    shows_nl . x)))
      (\ _ ->
        bindb (catch_errora (check_source_preserving ctrs z)
                (\ x ->
                  Inl (shows_prec_list zero_nat
                         ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', ' ',
                           'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'o', 'u',
                           'r', 'c', 'e', ' ', 'p', 'r', 'e', 's', 'e', 'r',
                           'v', 'i', 'n', 'g', ' '] .
                        shows_nl . x)))
          (\ _ -> Inr (concatMap snd c_rs))))))))))))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'e', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's',
               ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'r', 'a', 'v',
               'e', 'l', 'i', 'n', 'g', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't',
               ' ', 's', 'a', 't', 'i', 's', 'f', 'i', 'e', 'd'] .
            shows_nl . x));

check_conditional_cr_proof ::
  forall a b c.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [((Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]),
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])])] ->
                            Conditional_cr_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conditional_cr_proof a ia i j ctrs (Unconditional_CR prf) =
  debug (ia [])
    ['U', 'n', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l']
    (bindb
      (catch_errora
        (catch_errora
          (forallM (\ x -> (if null (snd x) then Inr () else Inl x)) ctrs)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl ((shows_prec_list zero_nat
                  ['r', 'u', 'l', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'n', 'o',
                    'n', '-', 'e', 'm', 'p', 't', 'y', ' ', 'c', 'o', 'n', 'd',
                    'i', 't', 'i', 'o', 'n', 's'] .
                 shows_nl) .
                shows_crule (shows_prec_lab zero_nat) (shows_prec_list zero_nat)
                  x)))
      (\ _ -> check_cr_proof a ia i j (map fst ctrs) prf));
check_conditional_cr_proof a ia i j ctrs (Unravel_CR u_info prf) =
  debug (ia []) ['U', 'n', 'r', 'a', 'v', 'e', 'l']
    (bindb
      (catch_errora (check_sp_unraveling u_info ctrs)
        (\ x ->
          Inl (((ia . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                          'u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g']) .
                 shows_nl) .
                indent x)))
      (\ r ->
        catch_errora (check_cr_proof a (ia . shows_string ['.', '1']) i j r prf)
          (\ x ->
            Inl (((ia . shows_prec_list zero_nat
                          [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                            'l', 'o', 'w', ' ', 'c', 'o', 'n', 'f', 'l', 'u',
                            'e', 'n', 'c', 'e', ' ', 'p', 'r', 'o', 'o', 'f']) .
                   shows_nl) .
                  indent x))));
check_conditional_cr_proof a ia i j ctrs (Transformation_CR t prf) =
  debug (ia [])
    ['C', 'R', ' ', 'R', 'e', 'f', 'l', 'e', 'c', 't', 'i', 'n', 'g', ' ', 'T',
      'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n']
    (bindb (check_ccr_trans ia ctrs t)
      (\ ctrsa -> check_conditional_cr_proof a ia i j ctrsa prf));
check_conditional_cr_proof a ia i j ctrs Almost_Orthogonal_CR =
  debug (ia [])
    ['A', 'l', 'm', 'o', 's', 't', '-', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
      'a', 'l']
    (check_level_confluence ctrs);
check_conditional_cr_proof a ia i j ctrs
  (Almost_Orthogonal_Modulo_Infeasibility_CR cps) =
  debug (ia [])
    ['A', 'l', 'm', 'o', 's', 't', '-', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
      'a', 'l', ' ', 'm', 'o', 'd', 'u', 'l', 'o', ' ', 'I', 'n', 'f', 'e', 'a',
      's', 'i', 'b', 'i', 'l', 'i', 't', 'y']
    (check_level_confluence_modulo_infeasibility cps ctrs);
check_conditional_cr_proof a ia i j ctrs
  (Almost_Orthogonal_Modulo_Infeasibility_CRa cps) =
  debug (ia [])
    ['A', 'l', 'm', 'o', 's', 't', '-', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
      'a', 'l', ' ', 'm', 'o', 'd', 'u', 'l', 'o', ' ', 'I', 'n', 'f', 'e', 'a',
      's', 'i', 'b', 'i', 'l', 'i', 't', 'y', ' ', '+', ' ', 'm', 'e', 'e', 't',
      '-', 't', 'o', '-', 'j', 'o', 'i', 'n']
    (check_level_confluence_modulo_infeasibilitya cps ctrs);
check_conditional_cr_proof a ia i j ctrs (AL94_CR qrp cj icp ucp) =
  debug (ia []) ['A', 'L', '9', '4']
    (bindb (check_quasi_reductive_proof a ia i j ctrs qrp)
      (\ _ -> check_al94 cj icp ucp ctrs));

check_fptrs_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b [Nat]) [Prelude.Char],
                              (Term (Lab b [Nat]) [Prelude.Char], Location))],
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])]) ->
                            Fptrs_termination_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fptrs_termination_proof ia j a i tp prf =
  check_fptrs_termination_proof_main ia j a i tp (unlab_to_split_otrs prf);

check_E_reachable ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Term a b -> Bool;
check_E_reachable e s t =
  membera (mk_rtrancl_list equal_term (rewrite e) [s]) t;

check_AC_rule ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq b) => (Term a b, Term a b) -> Bool;
check_AC_rule lr =
  let {
    (l, r) = lr;
  } in (if is_Var l then False
         else let {
                f = fst (the (root l));
              } in set_eq (funas_term l)
                     (inserta (f, nat_of_integer (2 :: Integer)) bot_set) &&
                     set_eq (funas_term r)
                       (inserta (f, nat_of_integer (2 :: Integer)) bot_set) &&
                       vars_term_ms l == vars_term_ms r &&
                         funs_term_ms l == funs_term_ms r);

check_AC_theory ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_AC_theory e =
  catch_errora
    (forallM
      (\ lr ->
        check (check_AC_rule lr)
          ((shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
             shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
               [' ', '-', '>', ' '] lr) .
            shows_prec_list zero_nat
              [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 'A', 'C', '-',
                'p', 'r', 'o', 'p', 'e', 'r', 't', 'y']))
      e)
    (\ x -> Inl (snd x));

check_symmetric_AC_theory ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Ccompare b, Eq b,
      Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_symmetric_AC_theory e =
  bindb (check_AC_theory e)
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM
            (\ (l, r) ->
              check (check_E_reachable e r l)
                (((shows_prec_list zero_nat ['r', 'h', 's', ' '] .
                    shows_prec_term zero_nat r) .
                   shows_prec_list zero_nat
                     [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'r',
                       'e', 'w', 'r', 'i', 't', 'e', ' ', 't', 'o', ' ', 'l',
                       'h', 's', ' ']) .
                  shows_prec_term zero_nat l))
            e)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['t', 'h', 'e', 'o', 'r', 'y', ' ', 'i', 's', ' ', 'n', 'o',
                   't', ' ', 's', 'y', 'm', 'm', 'e', 't', 'r', 'i', 'c',
                   '\n'] .
                x)));

rf :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rf (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = r;

c :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [b];
c (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = c;

a :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [b];
a (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = a;

check_only_C_rule ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Eq b) => Set a -> (Term a b, Term a b) -> Bool;
check_only_C_rule oc lr =
  (case lr of {
    (Var _, _) -> True;
    (Fun _ [], _) -> True;
    (Fun _ [_], _) -> True;
    (Fun f [s, t], r) ->
      (if member f oc then equal_term r (Fun f [t, s]) else True);
    (Fun _ (_ : _ : _ : _), _) -> True;
  });

check_only_C_theory ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Showa a, Eq b,
      Showa b) => Set a ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_only_C_theory oc e =
  catch_errora
    (forallM
      (\ lr ->
        check (check_only_C_rule oc lr)
          ((shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
             shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
               [' ', '-', '>', ' '] lr) .
            shows_prec_list zero_nat
              [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 'o', 'n', 'l',
                'y', '-', 'C', '-', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'y']))
      e)
    (\ x -> Inl (snd x));

check_AC_same_as_E ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Showa a, Ceq b, Ccompare b, Eq b,
      Set_impl b,
      Showa b) => a -> a -> a -> [b] ->
                                   [b] ->
                                     [(Term b a, Term b a)] ->
                                       Sum ([Prelude.Char] -> [Prelude.Char])
 ();
check_AC_same_as_E x y z a c e =
  catch_errora
    (let {
       xa = Var x;
       ya = Var y;
       za = Var z;
     } in bindb (catch_errora
                  (catch_errora
                    (forallM
                      (\ f ->
                        check (check_E_reachable e (Fun f [xa, ya])
                                (Fun f [ya, xa]))
                          f)
                      c)
                    (\ xb -> Inl (snd xb)))
                  (\ xb ->
                    Inl ((shows_prec_list zero_nat
                            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                              's', 'i', 'm', 'u', 'l', 'a', 't', 'e', ' ', 'C',
                              '-', 'r', 'u', 'l', 'e', 's', ' ', 'f', 'o', 'r',
                              ' '] .
                           shows_prec zero_nat xb) .
                          shows_prec_list zero_nat [' ', 'b', 'y', ' ', 'E'])))
            (\ _ ->
              bindb (catch_errora
                      (catch_errora
                        (forallM
                          (\ f ->
                            check (check_E_reachable e
                                    (Fun f [xa, Fun f [ya, za]])
                                    (Fun f [Fun f [xa, ya], za]))
                              f)
                          a)
                        (\ xb -> Inl (snd xb)))
                      (\ xb ->
                        Inl ((shows_prec_list zero_nat
                                ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                  ' ', 's', 'i', 'm', 'u', 'l', 'a', 't', 'e',
                                  ' ', 'A', '-', 'r', 'u', 'l', 'e', 's', ' ',
                                  'f', 'o', 'r', ' '] .
                               shows_prec zero_nat xb) .
                              shows_prec_list zero_nat
                                [' ', 'b', 'y', ' ', 'E'])))
                (\ _ ->
                  bindb (catch_errora
                          (catch_errora
                            (forallM
                              (\ f ->
                                check (check_E_reachable e
(Fun f [Fun f [xa, ya], za]) (Fun f [xa, Fun f [ya, za]]))
                                  f)
                              a)
                            (\ xb -> Inl (snd xb)))
                          (\ xb ->
                            Inl ((shows_prec_list zero_nat
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 's', 'i', 'm', 'u', 'l', 'a',
                                      't', 'e', ' ', 'A', '-', 'r', 'u', 'l',
                                      'e', 's', ' ', 'f', 'o', 'r', ' '] .
                                   shows_prec zero_nat xb) .
                                  shows_prec_list zero_nat
                                    [' ', 'b', 'y', ' ', 'E'])))
                    (\ _ ->
                      catch_errora
                        (catch_errora
                          (forallM
                            (\ (l, r) ->
                              check (equal_acterm (aocnf (set a) (set c) l)
                                      (aocnf (set a) (set c) r))
                                (l, r))
                            e)
                          (\ xb -> Inl (snd xb)))
                        (\ xb ->
                          Inl ((shows_prec_list zero_nat
                                  ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
                                    ' '] .
                                 shows_rule (shows_prec zero_nat)
                                   (shows_prec zero_nat) [' ', '-', '>', ' ']
                                   xb) .
                                shows_prec_list zero_nat
                                  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'A',
                                    'C', '-', 'e', 'q', 'u', 'i', 'v', 'a', 'l',
                                    'e', 'n', 't']))))))
    (\ xa ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
               'u', 'r', 'e', ' ', 't', 'h', 'a', 't', ' ', 'e', 'q', 'u', 'a',
               't', 'i', 'o', 'n', 's', ' ', 's', 'i', 'm', 'u', 'l', 'a', 't',
               'e', ' ', 'A', 'C', '-', 'e', 'q', 'u', 'i', 'v', 'a', 'l', 'e',
               'n', 'c', 'e', '\n'] .
            xa));

check_ext_rule3 ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Eq b) => (Term a b, Term a b) ->
                 a -> Set b -> (Term a b, Term a b) -> Bool;
check_ext_rule3 (la, ra) f xb
  (Fun ga [Fun ha [Var xa, l], Var ya], Fun g [Fun h [Var x, r], Var y]) =
  (la, (ra, (f, (f, (f, (f, (xa, ya))))))) ==
    (l, (r, (ga, (g, (ha, (h, (x, y))))))) &&
    not (x == y) && not (member x xb) && not (member y xb);
check_ext_rule3 uu uv uw (Var vb, va) = False;
check_ext_rule3 uu uv uw (Fun vb [], va) = False;
check_ext_rule3 uu uv uw (Fun vb (Var vf : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf [] : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf (Fun vj vk : vi) : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf [vh] : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf (vh : vj : vl : vm) : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb [vd], va) = False;
check_ext_rule3 uu uv uw (Fun vb (vd : Fun vh vi : vg), va) = False;
check_ext_rule3 uu uv uw (Fun vb (vd : vf : vh : vi), va) = False;
check_ext_rule3 uu uv uw (v, Var vb) = False;
check_ext_rule3 uu uv uw (v, Fun vb []) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Var vf : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf [] : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf (Fun vj vk : vi) : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf [vh] : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf (vh : vj : vl : vm) : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb [vd]) = False;
check_ext_rule3 uu uv uw (v, Fun vb (vd : Fun vh vi : vg)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (vd : vf : vh : vi)) = False;

check_ext_rule2 ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Eq b) => (Term a b, Term a b) ->
                 a -> Set b -> (Term a b, Term a b) -> Bool;
check_ext_rule2 (la, ra) f xb (Fun ga [Var xa, l], Fun g [Var x, r]) =
  (la, (ra, (f, (f, xa)))) == (l, (r, (ga, (g, x)))) && not (member xa xb);
check_ext_rule2 uu uv uw (Var vb, va) = False;
check_ext_rule2 uu uv uw (Fun vb [], va) = False;
check_ext_rule2 uu uv uw (Fun vb (Fun vf vg : ve), va) = False;
check_ext_rule2 uu uv uw (Fun vb [vd], va) = False;
check_ext_rule2 uu uv uw (Fun vb (vd : vf : vh : vi), va) = False;
check_ext_rule2 uu uv uw (v, Var vb) = False;
check_ext_rule2 uu uv uw (v, Fun vb []) = False;
check_ext_rule2 uu uv uw (v, Fun vb (Fun vf vg : ve)) = False;
check_ext_rule2 uu uv uw (v, Fun vb [vd]) = False;
check_ext_rule2 uu uv uw (v, Fun vb (vd : vf : vh : vi)) = False;

check_ext_rule1 ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Eq b) => (Term a b, Term a b) ->
                 a -> Set b -> (Term a b, Term a b) -> Bool;
check_ext_rule1 (la, ra) f xb (Fun ga [l, Var xa], Fun g [r, Var x]) =
  (la, (ra, (f, (f, xa)))) == (l, (r, (ga, (g, x)))) && not (member xa xb);
check_ext_rule1 uu uv uw (Var vb, va) = False;
check_ext_rule1 uu uv uw (Fun vb [], va) = False;
check_ext_rule1 uu uv uw (Fun vb [vd], va) = False;
check_ext_rule1 uu uv uw (Fun vb (vd : Fun vh vi : vg), va) = False;
check_ext_rule1 uu uv uw (Fun vb (vd : vf : vh : vi), va) = False;
check_ext_rule1 uu uv uw (v, Var vb) = False;
check_ext_rule1 uu uv uw (v, Fun vb []) = False;
check_ext_rule1 uu uv uw (v, Fun vb [vd]) = False;
check_ext_rule1 uu uv uw (v, Fun vb (vd : Fun vh vi : vg)) = False;
check_ext_rule1 uu uv uw (v, Fun vb (vd : vf : vh : vi)) = False;

check_ext_rule ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       Set a -> Set a -> (Term a b, Term a b) -> Bool;
check_ext_rule rext a c lr =
  let {
    (l, _) = lr;
  } in (if is_Var l ||
             (not (equal_nat (size_list (args l))
                    (nat_of_integer (2 :: Integer))) ||
               not (member (fst (the (root l))) a))
         then True
         else let {
                f = fst (the (root l));
                x = vars_rule lr;
              } in any (check_ext_rule1 lr f x) rext &&
                     (if not (member f c)
                       then any (check_ext_rule2 lr f x) rext &&
                              any (check_ext_rule3 lr f x) rext
                       else True));

check_ext_trs ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Showa a, Finite_UNIV b,
      Cenum b, Ceq b, Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [a] ->
                      [a] ->
                        [(Term a b, Term a b)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ext_trs r a c rext =
  let {
    aa = set a;
    ca = set c;
  } in catch_errora
         (catch_errora
           (forallM
             (\ lr ->
               check (check_ext_rule rext aa ca lr)
                 (((shows_prec_list zero_nat
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                        'i', 'n', 'd', ' ', 'e', 'x', 't', 'e', 'n', 'd', 'e',
                        'd', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'f', 'o', 'r',
                        ' ', 'r', 'u', 'l', 'e', ' ', 'l', ' ', '-', '>', ' ',
                        'r', ':', '\n', ' ', ' '] .
                     shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                       [' ', '-', '>', ' '] lr) .
                    shows_prec_list zero_nat
                      ['\n', ' ', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'i', 'n',
                        'g', ' ', 'r', 'u', 'l', 'e', ' ', 'f', '(', 'l', ',',
                        'x', ')', ' ', '-', '>', ' ', 'f', '(', 'r', ',', 'x',
                        ')', ' ', 'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ', 'A',
                        ' ', 'a', 'n', 'd', ' ', 'A', 'C', ' ', 's', 'y', 'm',
                        'b', 'o', 'l', 's', ',', '\n']) .
                   shows_prec_list zero_nat
                     ['a', 'n', 'd', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'f',
                       '(', 'x', ',', 'l', ')', ' ', '-', '>', ' ', 'f', '(',
                       'x', ',', 'r', ')', ' ', 'a', 'n', 'd', ' ', 'f', '(',
                       'f', '(', 'x', ',', 'l', ')', ',', 'y', ')', ' ', '-',
                       '>', ' ', 'f', '(', 'f', '(', 'x', ',', 'r', ')', ',',
                       'y', ')', ' ', 'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ',
                       'A', ' ', 's', 'y', 'm', 'b', 'o', 'l', 's']))
             r)
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                    's', 'u', 'r', 'e', ' ', 'v', 'a', 'l', 'i', 'd', 'i', 't',
                    'y', ' ', 'o', 'f', ' ', 'A', 'C', '-', 'e', 'x', 't', 'e',
                    'n', 'd', 'e', 'd', ' ', 's', 'y', 's', 't', 'e', 'm',
                    '\n'] .
                 x));

ac_dependency_pairs_checks ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Ac_tp_ops_ext a b c () ->
                    (b -> b) ->
                      c -> c -> c -> Ac_dependency_pairs_proof b c ->
                                       a ->
 Sum ([Prelude.Char] -> [Prelude.Char]) ();
ac_dependency_pairs_checks i shp x y z
  (AC_dependency_pairs_proof e dpr dpe rext) tp =
  catch_errora
    (let {
       aa = a i tp;
       ca = c i tp;
       r = rf i tp;
       oc = list_diff ca aa;
       d = defined_list r;
       _ = set d;
       da = defined_list (r ++ e);
     } in bindb (catch_errora
                  (forallM
                    (\ (f, n) ->
                      check (not (membera da (shp f, n)))
                        (shows_string
                           ['s', 'h', 'a', 'r', 'p', 'i', 'n', 'g', ' '] .
                          shows_prec zero_nat f .
                            shows_string
                              [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 't', 'h',
                                'e', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd',
                                ' ', 's', 'y', 'm', 'b', 'o', 'l', ' '] .
                              shows_prec zero_nat (shp f)))
                    da)
                  (\ xa -> Inl (snd xa)))
            (\ _ ->
              bindb (catch_errora (check_wf_trs (r ++ e))
                      (\ xa ->
                        Inl (shows_prec_list zero_nat
                               ['T', 'R', 'S', ' ', 'o', 'r', ' ', 'e', 'q',
                                 'u', 'a', 't', 'i', 'o', 'n', 's', ' ', 'a',
                                 'r', 'e', ' ', 'n', 'o', 't', ' ', 'w', 'e',
                                 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd'] .
                              xa)))
                (\ _ ->
                  bindb (catch_errora (check_symmetric_AC_theory e)
                          (\ xa ->
                            Inl (shows_prec_list zero_nat
                                   ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's',
                                     ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ',
                                     'f', 'o', 'r', 'm', ' ', 'a', ' ', 's',
                                     'y', 'm', 'm', 'e', 't', 'r', 'i', 'c',
                                     ' ', 'A', 'C', '-', 't', 'h', 'e', 'o',
                                     'r', 'y', '\n'] .
                                  xa)))
                    (\ _ ->
                      bindb (catch_errora (check_only_C_theory (set oc) e)
                              (\ xa ->
                                Inl (shows_prec_list zero_nat
                                       ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
 's', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'f', 'o', 'r', 'm', ' ', 'A', 'C',
 '_', 'C', '-', 't', 'h', 'e', 'o', 'r', 'y', '\n'] .
                                      xa)))
                        (\ _ ->
                          bindb (catch_errora
                                  (check_subseteq (funs_trs_list e) (aa ++ ca))
                                  (\ xa ->
                                    Inl ((shows_prec_list zero_nat
    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's', ' ', 'c', 'o', 'n', 't', 'a',
      'i', 'n', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' '] .
   shows_prec zero_nat xa) .
  shows_prec_list zero_nat
    [' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'A',
      'C', '-', 's', 'y', 'm', 'b', 'o', 'l'])))
                            (\ _ ->
                              bindb (catch_errora
                                      (check_AC_same_as_E x y z aa ca e)
                                      (\ xa ->
Inl (shows_prec_list zero_nat
       ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's', 'u',
         'r', 'e', ' ', 't', 'h', 'a', 't', ' ', 'e', 'q', 'u', 'a', 't', 'i',
         'o', 'n', 's', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd',
         ' ', 't', 'o', ' ', 'A', 'C', ' ', 'e', 'q', 'u', 'i', 'v', 'a', 'l',
         'e', 'n', 'c', 'e', '\n'] .
      xa)))
                                (\ _ ->
                                  bindb (catch_errora
  (check_subseteq (dP_list shp r d) dpr)
  (\ xa ->
    Inl (shows_prec_list zero_nat
           ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
             'd', ' ', 'D', 'P', ' ', 'f', 'o', 'r', ' ', 'R', ':', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] xa)))
                                    (\ _ ->
                                      bindb
(catch_errora (check_subseteq (dP_list shp e d) dpe)
  (\ xa ->
    Inl (shows_prec_list zero_nat
           ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
             'd', ' ', 'D', 'P', ' ', 'f', 'o', 'r', ' ', 'E', ':', ' '] .
          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
            [' ', '-', '>', ' '] xa)))
(\ _ ->
  catch_errora (check_ext_trs r aa ca rext)
    (\ xa ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
               'u', 'r', 'e', ' ', 'v', 'a', 'l', 'i', 'd', 'i', 't', 'y', ' ',
               'o', 'f', ' ', 'e', 'x', 't', 'e', 'n', 'd', 'e', 'd', ' ', 'T',
               'R', 'S', ' ', 'R', '_', 'e', 'x', 't', '\n'] .
            xa)))))))))))
    (\ xa ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'a', 'p',
               'p', 'l', 'y', 'i', 'n', 'g', ' ', 'A', 'C', '-', 'd', 'e', 'p',
               'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p', 'a', 'i', 'r', 's',
               '\n'] .
            xa));

mkf ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d ->
      [(Term b c, Term b c)] ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] ->
            [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkf (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
      reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
      eq_rules_non_collapsing intersect_pairs more)
  = mk;

ac_dependency_pairs_proc_simple ::
  forall a b c d.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Ac_tp_ops_ext a b c () ->
                    Ac_dpp_ops_ext d b c () ->
                      (b -> b) ->
                        c -> c -> c -> Ac_dependency_pairs_proof b c ->
 a -> Sum ([Prelude.Char] -> [Prelude.Char]) d;
ac_dependency_pairs_proc_simple i j shp x y z
  (AC_dependency_pairs_proof e dpr dpe rext) tp =
  bindb (ac_dependency_pairs_checks i shp x y z
          (AC_dependency_pairs_proof e dpr dpe rext) tp)
    (\ _ ->
      let {
        r = rf i tp;
      } in Inr (mkf j
                 (dpr ++
                   map (\ (l, ra) -> (sharp_term shp l, sharp_term shp ra))
                     rext)
                 dpe [] r e));

delete_pairs_rulesa ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_pairs_rulesa
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = delete_pairs_rules;

rulesf :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulesf
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = rules;

pairsc :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pairsc
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = pairs;

rwe :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwe (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
      reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
      eq_rules_non_collapsing intersect_pairs more)
  = rw;

rg :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rg (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
     reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
     eq_rules_non_collapsing intersect_pairs more)
  = r;

eb :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
eb (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
     reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
     eq_rules_non_collapsing intersect_pairs more)
  = e;

ac_mono_ur_redpair_proc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showa c) => Ac_dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          [(Term b c, Term b c)] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
ac_mono_ur_redpair_proc i rp p_remove r_remove ur dpp =
  (case catch_errora
          (let {
             p = pairsc i dpp;
             _ = rulesf i dpp;
             e = eb i dpp;
             premove = set p_remove;
             rremove = set r_remove;
             us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
             filt = (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
             (ps, pns) = partition (\ lr -> member lr premove && filt lr) p;
             (urs, urns) = partition (\ lr -> member lr rremove && filt lr) ur;
             rm = eq_rules_map i dpp;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (mono rp (ps ++ urs ++ urns ++ pns))
                      (\ _ ->
                        bindb (catch_errora (check_symmetric_AC_theory e)
                                (\ x ->
                                  Inl (shows_prec_list zero_nat
 ['u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'd', 'e',
   'm', 'a', 'n', 'd', ' ', 's', 'y', 'm', 'm', 'e', 't', 'r', 'i', 'c', ' ',
   'A', 'C', ' ', 't', 'h', 'e', 'o', 'r', 'y', '\n'] .
x)))
                          (\ _ ->
                            bindb (catch_errora
                                    (forallM
                                      (\ (l, _) ->
check (not (is_Var l))
  (shows_prec_list zero_nat
    ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ', 'l', 'h',
      's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                                      (rg i dpp ++ rwe i dpp))
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (check_ur_P_closed_rm_af rm ur full_af p)
                                  (\ _ ->
                                    bindb (catch_errora
    (catch_errora (forallM (ns rp) urns) (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a',
               'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', '\n'] .
            x)))
                                      (\ _ ->
bindb (catch_errora (catch_errora (forallM (s rp) urs) (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                   ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u',
                   's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's',
                   '\n'] .
                x)))
  (\ _ ->
    bindb (catch_errora
            (catch_errora (forallM (ns rp) pns) (\ x -> Inl (snd x)))
            (\ x ->
              Inl (shows_prec_list zero_nat
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                       'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                       ' ', 'D', 'P', 's', '\n'] .
                    x)))
      (\ _ ->
        catch_errora (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D',
                     'P', 's', '\n'] .
                  x)))))))))))
          (\ x ->
            Inl (((shows_prec_list zero_nat
                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a',
                       'p', 'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'm', 'o',
                       'n', 'o', 't', 'o', 'n', 'i', 'c', ' ', 'A', 'C', ' ',
                       'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p',
                       'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 'u', 's', 'a',
                       'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'a',
                       'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                       'o', 'w', 'i', 'n', 'g', '\n'] .
                    desc rp) .
                   shows_nl) .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_pairs_rulesa i dpp p_remove r_remove);
  });

pwc :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pwc (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
      reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
      eq_rules_non_collapsing intersect_pairs more)
  = pw;

pc :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pc (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
     reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
     eq_rules_non_collapsing intersect_pairs more)
  = p;

ac_dpp_trivial_check ::
  forall a b c.
    Ac_dpp_ops_ext a b c () -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
ac_dpp_trivial_check i dpp =
  bindb (check (null (pc i dpp))
          (shows_prec_list zero_nat
            ['t', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 's', 't', 'r',
              'i', 'c', 't', ' ', 'p', 'a', 'i', 'r', 's']))
    (\ _ ->
      check (null (pwc i dpp) || null (rg i dpp))
        (shows_prec_list zero_nat
          ['t', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 'w', 'e', 'a', 'k',
            ' ', 'p', 'a', 'i', 'r', 's', ' ', 'a', 'n', 'd', ' ', 's', 't',
            'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's']));

ac_ur_redpair_proc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showa c) => Ac_dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
ac_ur_redpair_proc i rp p_remove ur dpp =
  (case catch_errora
          (let {
             p = pairsc i dpp;
             _ = rulesf i dpp;
             e = eb i dpp;
             premove = set p_remove;
             (ps, pns) = partition (\ lr -> member lr premove) p;
             rm = eq_rules_map i dpp;
             pi = af rp;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (catch_errora (check_symmetric_AC_theory e)
                            (\ x ->
                              Inl (shows_prec_list zero_nat
                                     ['u', 's', 'a', 'b', 'l', 'e', ' ', 'r',
                                       'u', 'l', 'e', 's', ' ', 'd', 'e', 'm',
                                       'a', 'n', 'd', ' ', 's', 'y', 'm', 'm',
                                       'e', 't', 'r', 'i', 'c', ' ', 'A', 'C',
                                       ' ', 't', 'h', 'e', 'o', 'r', 'y',
                                       '\n'] .
                                    x)))
                      (\ _ ->
                        bindb (catch_errora
                                (forallM
                                  (\ (l, _) ->
                                    check (not (is_Var l))
                                      (shows_prec_list zero_nat
['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ', 'l', 'h', 's',
  's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                                  (rg i dpp ++ rwe i dpp))
                                (\ x -> Inl (snd x)))
                          (\ _ ->
                            bindb (check_ur_P_closed_rm_af rm ur pi p)
                              (\ _ ->
                                bindb (catch_errora
(catch_errora (forallM (ns rp) ur) (\ x -> Inl (snd x)))
(\ x ->
  Inl (shows_prec_list zero_nat
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
           'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l',
           'e', ' ', 'r', 'u', 'l', 'e', 's', '\n'] .
        x)))
                                  (\ _ ->
                                    bindb (catch_errora
    (catch_errora (forallM (nst rp) pns) (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's',
               '\n'] .
            x)))
                                      (\ _ ->
catch_errora (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
  (\ x ->
    Inl (shows_prec_list zero_nat
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
             'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's',
             '\n'] .
          x)))))))))
          (\ x ->
            Inl (((shows_prec_list zero_nat
                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a',
                       'p', 'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'A', 'C',
                       ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ',
                       'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                       's', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 'u', 's',
                       'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
                       'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l',
                       'l', 'o', 'w', 'i', 'n', 'g', '\n'] .
                    desc rp) .
                   shows_nl) .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_pairs_rulesa i dpp p_remove []);
  });

check_size_preserving_trs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_size_preserving_trs e =
  catch_errora
    (catch_errora
      (forallM
        (\ (l, r) ->
          check (equal_nat (num_symbs l) (num_symbs r) &&
                  vars_term_ms l == vars_term_ms r)
            ((shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
               shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                 [' ', '-', '>', ' '] (l, r)) .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'i', 'z', 'e',
                  ' ', 'p', 'r', 'e', 's', 'e', 'r', 'v', 'i', 'n', 'g']))
        e)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'i',
               'z', 'e', '-', 'p', 'r', 'e', 's', 'e', 'r', 'v', 'i', 'n', 'g',
               '\n'] .
            x));

ac_subterm_proc ::
  forall a b c.
    (Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b, Compare c, Eq c,
      Showa c) => Ac_dpp_ops_ext a b c () ->
                    [((b, Nat), [Nat])] ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
ac_subterm_proc i pi p_remove dpp =
  (case catch_errora
          (let {
             p = pairsc i dpp;
             r = rulesf i dpp;
             e = eb i dpp;
             re = r ++ e;
             f = map fst pi;
             ff = set f;
             pi_opt = status_of pi;
           } in bindb (check (not (is_none pi_opt))
                        (shows_prec_list zero_nat
                          ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f',
                            'i', 'l', 't', 'e', 'r', ' ', 'l', 'i', 's', 't',
                            's', ' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd', ' ',
                            'p', 'o', 's', 'i', 't', 'i', 'o', 'n', 's']))
                  (\ _ ->
                    let {
                      pia = the pi_opt;
                      premove = set p_remove;
                      (ps, pns) = partition (\ lr -> member lr premove) p;
                    } in bindb (catch_errora
                                 (forallM
                                   (\ fa ->
                                     check (not (null (status pia fa)))
                                       ((shows_prec_list zero_nat
   ['s', 't', 'a', 't', 'u', 's', ' ', 'o', 'f', ' ', 's', 'y', 'm', 'b', 'o',
     'l', ' '] .
  shows_prec_prod zero_nat fa) .
 shows_prec_list zero_nat
   [' ', 'i', 'n', ' ', 'F', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n',
     'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
                                   f)
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             bindb (catch_errora (check_size_preserving_trs e)
                                     (\ x ->
                                       Inl
 (shows_prec_list zero_nat
    ['E', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'i', 'z', 'e', ' ', 'p',
      'r', 'e', 's', 'e', 'r', 'v', 'i', 'n', 'g', '\n'] .
   x)))
                               (\ _ ->
                                 bindb (catch_errora
 (forallM
   (\ (l, _) ->
     check (not (is_Var l))
       (shows_prec_list zero_nat
         ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ', 'l',
           'h', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
           'd']))
   re)
 (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (catch_errora
     (catch_errora
       (forallM (check_supteqproj_pred pia ff)
         (filter (\ lr -> member (the (root (fst lr))) ff) re))
       (\ x -> Inl (snd x)))
     (\ x ->
       Inl (shows_prec_list zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
                'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'r', 'u', 'l',
                'e', 's', ' ', 'w', 'i', 't', 'h', ' ', 'r', 'o', 'o', 't', ' ',
                'i', 'n', ' ', 'F', '\n'] .
             x)))
                                       (\ _ ->
 bindb (catch_errora
         (catch_errora (forallM (check_supteqproj_pred pia ff) pns)
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                    ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D',
                    'P', 's', '\n'] .
                 x)))
   (\ _ ->
     catch_errora
       (catch_errora (forallM (check_suptproj_pred pia ff) ps)
         (\ x -> Inl (snd x)))
       (\ x ->
         Inl (shows_prec_list zero_nat
                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                  ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D',
                  'P', 's', '\n'] .
               x)))))))))
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'A', 'C', ' ', 's',
                     'u', 'b', 't', 'e', 'r', 'm', ' ', 'p', 'r', 'o', 'c', 'e',
                     's', 's', 'o', 'r', '\n'] .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_pairs_rulesa i dpp p_remove []);
  });

intersect_pairsc ::
  forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_pairsc
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = intersect_pairs;

graph_approx_edg_rt_sym ::
  forall a b c d e.
    (Ccompare a,
      Eq a) => Multimap (Maybe (a, Nat)) b -> (c, (d, Gctxt a e)) -> [b];
graph_approx_edg_rt_sym m (uu, (uv, ct)) = graph_approx_rt_sym_main m ct;

eq_rules_non_collapsinga :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> Bool;
eq_rules_non_collapsinga
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = eq_rules_non_collapsing;

reverse_eq_rules_map ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
reverse_eq_rules_map
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = reverse_eq_rules_map;

reverse_tcapRM_ac_dpp ::
  forall a b c.
    (Eq b, Eq c) => Ac_dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
reverse_tcapRM_ac_dpp i dpp =
  tcapRM (eq_rules_non_collapsinga i dpp) (reverse_eq_rules_map i dpp);

check_ac_dep_graph_proc ::
  forall a b c.
    (Ccompare b, Eq b, Key b, Mapping_impl b,
      Showa b) => Ac_dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ac_dep_graph_proc i dpp dps =
  let {
    c = tcapRM_ac_dpp i dpp;
    rc = reverse_tcapRM_ac_dpp i dpp;
    p = pairsc i dpp;
  } in bindb (catch_errora (check_subseteq p (concatMap snd dps))
               (\ x ->
                 Inl (shows_string
                        ['D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ',
                          'P', 'a', 'i', 'r', ' '] .
                       shows_rule (shows_prec zero_nat)
                         (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                         shows_string
                           [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                             'g', ' ', 'i', 'n', ' ', 'd', 'e', 'c', 'o', 'm',
                             'p', 'o', 's', 'i', 't', 'i', 'o', 'n'] .
                           shows_nl)))
         (\ _ ->
           catch_errora
             (check_graph_decomp (shows_prec_prod zero_nat . fst)
               (emptyd ((root . fst) . fst)) graph_approx_edg_rt_sym insertd
               (\ (a, b) ->
                 let {
                   (aa, ba) = a;
                 } in let {
                        (_, t) = aa;
                      } in (\ (_, ct) (ab, bb) ->
                             let {
                               (u, _) = ab;
                             } in (\ (cu, _) -> matchb ct u && matchb cu t)
                               bb)
                        ba
                   b)
               (map (\ (real, cs) ->
                      (not (is_none real),
                        map (\ (s, t) -> ((s, t), (rc s, c t))) cs))
                 dps))
             (\ x ->
               Inl (shows_string
                      ['o', 'u', 'r', ' ', 'e', 's', 't', 'i', 'm', 'a', 't',
                        'i', 'o', 'n', ' ', '(', 'E', 'D', 'G', '*', '*', '*',
                        ')', ' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                        ' ', 's', 'h', 'o', 'w', ' ', 't', 'h', 'a', 't', ' ',
                        'y', 'o', 'u', ' ', 'h', 'a', 'v', 'e', ' ', 'a', ' ',
                        'v', 'a', 'l', 'i', 'd', ' ', 'd', 'e', 'c', 'o', 'm',
                        'p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' '] .
                     shows_string
                       ['d', 'u', 'e', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ',
                         'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'r',
                         'e', 'a', 's', 'o', 'n'] .
                       shows_nl . x)));

ac_dep_graph_proc ::
  forall a b c.
    (Ccompare b, Eq b, Key b, Mapping_impl b,
      Showa b) => Ac_dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) [(c, a)];
ac_dep_graph_proc i d dps =
  (case check_ac_dep_graph_proc i d dps of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (map_filter
            (\ x ->
              (if not (is_none (fst x))
                then Just (the (fst x), intersect_pairsc i d (snd x))
                else Nothing))
            dps);
  });

shows_ac_dpp ::
  forall a b c.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Ac_dpp_ops_ext c a b () -> c -> [Prelude.Char] -> [Prelude.Char];
shows_ac_dpp fun var i d =
  let {
    p = pc i d;
    pw = pwc i d;
    r = rg i d;
    rw = rwe i d;
    e = eb i d;
  } in ((((if null p then id
            else shows_trs fun var ['p', 'a', 'i', 'r', 's', ':']
                   [' ', '-', '>', ' '] p) .
           (if null pw then id
             else shows_trs fun var
                    ['w', 'e', 'a', 'k', ' ', 'p', 'a', 'i', 'r', 's', ':']
                    [' ', '-', '>', '=', ' '] pw)) .
          (if null r then id
            else shows_trs fun var
                   ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's',
                     ':']
                   [' ', '-', '>', '!', ' '] r)) .
         (if null rw then id
           else shows_trs fun var ['r', 'u', 'l', 'e', 's', ':']
                  [' ', '-', '>', ' '] rw)) .
         (if null e then id
           else shows_trs fun var
                  ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's', ':']
                  [' ', '-', '>', ' '] e);

check_ac_dp_termination_proof ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Mapping_impl b, Set_impl b,
      Showa b) => Ac_dpp_ops_ext a b [Prelude.Char] () ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      a -> Ac_dp_termination_proof b [Prelude.Char] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ac_dp_termination_proof ia i dpp AC_P_is_Empty =
  debug (i []) ['P', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y']
    (catch_errora (ac_dpp_trivial_check ia dpp)
      (\ x ->
        Inl (((i . shows_prec_list zero_nat
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                       'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 't', 'r',
                       'i', 'v', 'i', 'a', 'l', ' ', 'c', 'h', 'e', 'c', 'k',
                       ' ', 'o', 'n', '\n']) .
               shows_ac_dpp (shows_prec zero_nat) (shows_prec_list zero_nat) ia
                 dpp) .
              x)));
check_ac_dp_termination_proof ia i dpp (AC_Redpair_UR_Proc redp del_p ur prf) =
  debug (i [])
    ['A', 'C', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'U', 'R', '_', 'P',
      'r', 'o', 'c']
    (bindb
      (catch_errora (ac_ur_redpair_proc ia (get_redtriple redp) del_p ur dpp)
        (\ x ->
          Inl ((((((i . shows_prec_list zero_nat
                          [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h',
                            'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n',
                            'g', ' ', 't', 'h', 'e', ' ', 'a', 'c', '-', 'r',
                            'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p',
                            'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                            's', 'o', 'r', ' ', 't', 'o', ' ', 'r', 'e', 'm',
                            'o', 'v', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't',
                            'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b',
                            'l', 'e', 'm', '\n']) .
                    shows_ac_dpp (shows_prec zero_nat)
                      (shows_prec_list zero_nat) ia dpp) .
                   shows_prec_list zero_nat
                     ['\n', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', 's',
                       '\n']) .
                  shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
                    [' ', '-', '>', ' '] del_p) .
                 shows_nl) .
                x)))
      (\ dppa ->
        catch_errora
          (check_ac_dp_termination_proof ia
            (i . shows_prec_list zero_nat ['.', '1']) dppa prf)
          (\ x ->
            Inl ((i . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'a', 'c', '-', 'r',
                          'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                          'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                          'r', '\n']) .
                  indent x))));
check_ac_dp_termination_proof ia i dpp (AC_Subterm_Proc pi del_p prf) =
  debug (i [])
    ['A', 'C', '_', 'S', 'u', 'b', 't', 'e', 'r', 'm', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (ac_subterm_proc ia pi del_p dpp)
        (\ x ->
          Inl ((((((i . shows_prec_list zero_nat
                          [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h',
                            'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n',
                            'g', ' ', 't', 'h', 'e', ' ', 'a', 'c', '-', 's',
                            'u', 'b', 't', 'e', 'r', 'm', ' ', 'p', 'r', 'o',
                            'c', 'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ',
                            'r', 'e', 'm', 'o', 'v', 'e', ' ', 'f', 'r', 'o',
                            'm', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p',
                            'r', 'o', 'b', 'l', 'e', 'm', '\n']) .
                    shows_ac_dpp (shows_prec zero_nat)
                      (shows_prec_list zero_nat) ia dpp) .
                   shows_prec_list zero_nat
                     ['\n', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', 's',
                       '\n']) .
                  shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
                    [' ', '-', '>', ' '] del_p) .
                 shows_nl) .
                x)))
      (\ dppa ->
        catch_errora
          (check_ac_dp_termination_proof ia
            (i . shows_prec_list zero_nat ['.', '1']) dppa prf)
          (\ x ->
            Inl ((i . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'a', 'c', '-', 'r',
                          'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                          'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                          'r', '\n']) .
                  indent x))));
check_ac_dp_termination_proof ia i dpp
  (AC_Mono_Redpair_UR_Proc redp del_p del_r ur prf) =
  debug (i [])
    ['A', 'C', '_', 'M', 'o', 'n', 'o', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r',
      '_', 'U', 'R', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora
        (ac_mono_ur_redpair_proc ia (get_redtriple redp) del_p del_r ur dpp)
        (\ x ->
          Inl ((((((((i . shows_prec_list zero_nat
                            [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h',
                              'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n',
                              'g', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'n', 'o',
                              't', 'o', 'n', 'e', ' ', 'a', 'c', '-', 'r', 'e',
                              'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                              'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                              'o', 'r', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
                              'v', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h',
                              'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l',
                              'e', 'm', '\n']) .
                      shows_ac_dpp (shows_prec zero_nat)
                        (shows_prec_list zero_nat) ia dpp) .
                     shows_prec_list zero_nat
                       ['\n', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', 's',
                         '\n']) .
                    shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
                      [' ', '-', '>', ' '] del_p) .
                   shows_prec_list zero_nat
                     ['\n', ' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'r',
                       'u', 'l', 'e', 's', '\n']) .
                  shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
                    [' ', '-', '>', ' '] del_r) .
                 shows_nl) .
                x)))
      (\ dppa ->
        catch_errora
          (check_ac_dp_termination_proof ia
            (i . shows_prec_list zero_nat ['.', '1']) dppa prf)
          (\ x ->
            Inl ((i . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'n', 'o',
                          't', 'o', 'n', 'e', ' ', 'a', 'c', '-', 'r', 'e', 'd',
                          'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r',
                          ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r',
                          '\n']) .
                  indent x))));
check_ac_dp_termination_proof ia i dpp (AC_Dep_Graph_Proc edpts) =
  debug (i [])
    ['D', 'e', 'p', '_', 'G', 'r', 'a', 'p', 'h', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (ac_dep_graph_proc ia dpp edpts)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i',
                       'l', 'e', ' ', 't', 'r', 'y', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'p', 'e', 'r', 'f', 'o', 'r', 'm', ' ', 'S',
                       'c', 't', 'x', 't', '_', 'c', 'l', 'o', 's', 'u', 'r',
                       'e', '-', 'd', 'e', 'c', 'o', 'm', 'p', 'o', 's', 'i',
                       't', 'i', 'o', 'n', ' ', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_ac_dpp (shows_prec zero_nat)
                         (shows_prec_list zero_nat) ia dpp .
                         shows_nl . x)))
      (\ pdpps ->
        catch_errora
          (catch_errora
            (forallM_index
              (\ (prof, dppa) j ->
                check_ac_dp_termination_proof ia
                  (i . shows_string ['.'] . shows_prec_nat zero_nat (suc j))
                  dppa prof)
              pdpps)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'd', 'e', 'p', 'e',
                         'n', 'd', 'e', 'n', 'c', 'y', ' ', 'g', 'r', 'a', 'p',
                         'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                         'r'] .
                       shows_nl . indent x))));

ac_dependency_pairs_proc ::
  forall a b c d.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Ac_tp_ops_ext a b c () ->
                    Ac_dpp_ops_ext d b c () ->
                      (b -> b) ->
                        c -> c -> c -> Ac_dependency_pairs_proof b c ->
 a -> Sum ([Prelude.Char] -> [Prelude.Char]) (d, d);
ac_dependency_pairs_proc i j shp x y z
  (AC_dependency_pairs_proof e dpr dpe rext) tp =
  bindb (ac_dependency_pairs_checks i shp x y z
          (AC_dependency_pairs_proof e dpr dpe rext) tp)
    (\ _ ->
      let {
        r = rf i tp;
      } in Inr (mkf j dpr dpe [] r e,
                 mkf j (map (\ (l, ra) -> (sharp_term shp l, sharp_term shp ra))
                         rext)
                   dpe [] r e));

delete_rulesa ::
  forall a b c d. Ac_tp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
delete_rulesa (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = delete_rules;

ea :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
ea (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = e;

ac_rule_removal ::
  forall a b c.
    (Compare b, Eq b, Showa b, Compare c, Eq c,
      Showa c) => Ac_tp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
ac_rule_removal i rp r_remove tp =
  (case catch_errora
          (let {
             r = rf i tp;
             e = ea i tp;
             rremove = set r_remove;
             rns = filter (\ lr -> not (member lr rremove)) r;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (mono rp (r_remove ++ rns ++ e))
                      (\ _ ->
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_prec_list zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'w', 'e', 'a', 'k', ' ', 'r', 'u',
   'l', 'e', 's', '\n'] .
x)))
                          (\ _ ->
                            bindb (catch_errora
                                    (catch_errora (forallM (ns rp) e)
                                      (\ x -> Inl (snd x)))
                                    (\ x ->
                                      Inl
(shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
     'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'e', 'q', 'u', 'a', 't', 'i', 'o',
     'n', 's', '\n'] .
  x)))
                              (\ _ ->
                                catch_errora
                                  (catch_errora (forallM (s rp) r_remove)
                                    (\ x -> Inl (snd x)))
                                  (\ x ->
                                    Inl (shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
     'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 's', 't', 'r', 'i', 'c', 't', ' ',
     'r', 'u', 'l', 'e', 's', '\n'] .
  x)))))))
          (\ x ->
            Inl (((shows_prec_list zero_nat
                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a',
                       'p', 'p', 'l', 'y', ' ', 'A', 'C', ' ', 'r', 'u', 'l',
                       'e', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'w',
                       'i', 't', 'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l',
                       'l', 'o', 'w', 'i', 'n', 'g', '\n'] .
                    desc rp) .
                   shows_nl) .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_rulesa i tp r_remove);
  });

shows_ac_tp ::
  forall a b c.
    (Showa b,
      Showa c) => Ac_tp_ops_ext a b c () ->
                    a -> [Prelude.Char] -> [Prelude.Char];
shows_ac_tp i t =
  let {
    r = rf i t;
    aa = a i t;
    ca = c i t;
  } in (shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
          ['r', 'u', 'l', 'e', 's', ':'] [' ', '-', '>', ' '] r .
         (if null aa then id
           else (shows_prec_list zero_nat
                   ['A', '-', 's', 'y', 'm', 'b', 'o', 'l', 's', ':', ' '] .
                  shows_prec_list zero_nat aa) .
                  shows_nl)) .
         (if null ca then id
           else (shows_prec_list zero_nat
                   ['C', '-', 's', 'y', 'm', 'b', 'o', 'l', 's', ':', ' '] .
                  shows_prec_list zero_nat ca) .
                  shows_nl);

check_ac_termination_proof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Ac_dpp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Ac_tp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      ([Prelude.Char] -> [Prelude.Char]) ->
                        d -> Ac_termination_proof b c [Prelude.Char] ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ac_termination_proof ia j i tp (AC_DP_Trans info prf1 prf2) =
  debug (i [])
    ['A', 'C', ' ', 'D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 'P',
      'a', 'i', 'r', 's']
    (bindb
      (catch_errora
        (ac_dependency_pairs_proc j ia Sharp ['x'] ['y'] ['z'] info tp)
        (\ x ->
          Inl (((i . shows_prec_list zero_nat
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         't', 'h', 'e', ' ', 'a', 'c', '-', 'd', 'e', 'p', 'e',
                         'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p', 'a', 'i', 'r',
                         ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ',
                         'o', 'n', '\n']) .
                 shows_ac_tp j tp) .
                x)))
      (\ (dp1, dp2) ->
        bindb (catch_errora
                (check_ac_dp_termination_proof ia
                  (i . shows_prec_list zero_nat ['.', '1']) dp1 prf1)
                (\ x ->
                  Inl ((i . shows_prec_list zero_nat
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'a',
                                'c', '-', 'd', 'e', 'p', 'e', 'n', 'd', 'e',
                                'n', 'c', 'y', ' ', 'p', 'a', 'i', 'r', ' ',
                                'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r',
                                '\n']) .
                        indent x)))
          (\ _ ->
            catch_errora
              (check_ac_dp_termination_proof ia
                (i . shows_prec_list zero_nat ['.', '2']) dp2 prf2)
              (\ x ->
                Inl ((i . shows_prec_list zero_nat
                            [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                              'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'a', 'c',
                              '-', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c',
                              'y', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o',
                              'c', 'e', 's', 's', 'o', 'r', '\n']) .
                      indent x)))));
check_ac_termination_proof ia j i tp (AC_DP_Trans_Single info prf1) =
  debug (i [])
    ['A', 'C', ' ', 'D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 'P',
      'a', 'i', 'r', 's']
    (bindb
      (catch_errora
        (ac_dependency_pairs_proc_simple j ia Sharp ['x'] ['y'] ['z'] info tp)
        (\ x ->
          Inl (((i . shows_prec_list zero_nat
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         't', 'h', 'e', ' ', 'a', 'c', '-', 'd', 'e', 'p', 'e',
                         'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p', 'a', 'i', 'r',
                         ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ',
                         'o', 'n', '\n']) .
                 shows_ac_tp j tp) .
                x)))
      (\ dp1 ->
        catch_errora
          (check_ac_dp_termination_proof ia
            (i . shows_prec_list zero_nat ['.', '1']) dp1 prf1)
          (\ x ->
            Inl ((i . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'a', 'c', '-', 'd',
                          'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p',
                          'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                          'o', 'r', '\n']) .
                  indent x))));
check_ac_termination_proof ia j i tp (AC_Rule_Removal redp del_r prf) =
  debug (i [])
    ['A', 'C', '_', 'M', 'o', 'n', 'o', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r',
      '_', 'U', 'R', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catch_errora (ac_rule_removal j (get_redtriple redp) del_r tp)
        (\ x ->
          Inl ((((((i . shows_prec_list zero_nat
                          [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h',
                            'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n',
                            'g', ' ', 'a', 'c', '-', 'r', 'u', 'l', 'e', ' ',
                            'r', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 't', 'o',
                            ' ', 'r', 'e', 'm', 'o', 'v', 'e', ' ', 'f', 'r',
                            'o', 'm', ' ', 't', 'h', 'e', ' ', 'A', 'C', ' ',
                            't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                            'n', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                            '\n']) .
                    shows_ac_tp j tp) .
                   shows_prec_list zero_nat
                     ['\n', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's',
                       '\n']) .
                  shows_rules (shows_prec_lab zero_nat)
                    (shows_prec_list zero_nat) [' ', '-', '>', ' '] del_r) .
                 shows_nl) .
                x)))
      (\ tpa ->
        catch_errora
          (check_ac_termination_proof ia j
            (i . shows_prec_list zero_nat ['.', '1']) tpa prf)
          (\ x ->
            Inl ((i . shows_prec_list zero_nat
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 'a', 'c', '-', 'r', 'u', 'l', 'e', ' ',
                          'r', 'e', 'm', 'o', 'v', 'a', 'l', '\n']) .
                  indent x))));
check_ac_termination_proof ia j i tp AC_R_is_Empty =
  debug (i []) ['A', 'C', '_', 'R', '_', 'i', 's', '_', 'E', 'm', 'p', 't', 'y']
    (catch_errora
      (check (null (rf j tp))
        (shows_prec_list zero_nat
          ['T', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o', 't',
            ' ', 'e', 'm', 'p', 't', 'y']))
      (\ x ->
        Inl ((((i . shows_prec_list zero_nat
                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                        'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                        't', 'h', 'e', ' ', 'R', '-', 'i', 's', '-', 'E', 'm',
                        'p', 't', 'y', ' ', 'c', 'h', 'e', 'c', 'k', ' ', 'o',
                        'n', ' ', 't', 'h', 'e', ' ', 'A', 'C', ' ', 't', 'e',
                        'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p',
                        'r', 'o', 'b', 'l', 'e', 'm', '\n']) .
                shows_ac_tp j tp) .
               shows_nl) .
              x)));

equal_strategy ::
  forall a b. (Eq a, Eq b) => Strategy a b -> Strategy a b -> Bool;
equal_strategy Innermost (Innermost_Q x3) = False;
equal_strategy (Innermost_Q x3) Innermost = False;
equal_strategy No_Strategy (Innermost_Q x3) = False;
equal_strategy (Innermost_Q x3) No_Strategy = False;
equal_strategy No_Strategy Innermost = False;
equal_strategy Innermost No_Strategy = False;
equal_strategy (Innermost_Q x3) (Innermost_Q y3) = x3 == y3;
equal_strategy Innermost Innermost = True;
equal_strategy No_Strategy No_Strategy = True;

shows_formula ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      Formula a -> [Prelude.Char] -> [Prelude.Char];
shows_formula shows_atom (Disjunction fs) =
  let {
    a = map (shows_formula shows_atom) fs;
  } in shows_list_gen id ['F', 'a', 'l', 's', 'e'] ['D', 'i', 's', 'j', '[']
         [',', ' '] [']'] a;
shows_formula shows_atom (Conjunction fs) =
  let {
    a = map (shows_formula shows_atom) fs;
  } in shows_list_gen id ['T', 'r', 'u', 'e'] ['C', 'o', 'n', 'j', '[']
         [',', ' '] [']'] a;
shows_formula shows_atom (NegAtom a) =
  (shows_prec_list zero_nat ['!', ' ', '('] . shows_atom a) .
    shows_prec_list zero_nat [')'];
shows_formula shows_atom (Atom a) = shows_atom a;

shows_transition ::
  forall a b c d.
    (Showa d) => (Term a (Trans_var b, c) ->
                   [Prelude.Char] -> [Prelude.Char]) ->
                   Transition_rule a b c d -> [Prelude.Char] -> [Prelude.Char];
shows_transition shows_tatom (Transition s t phi) =
  (((shows_prec zero_nat s .
      shows_prec_list zero_nat [' ', '-', '-', '-', '>', ' ']) .
     shows_prec zero_nat t) .
    shows_prec_list zero_nat [':', ' ']) .
    shows_formula shows_tatom phi;

transition_hintsa :: forall a b c d e. Hinter_ext a b c d e -> c -> Maybe [a];
transition_hintsa
  (Hinter_ext nodes succ_trans_list cover_hints transition_hints more) =
  transition_hints;

remove_Atom ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (Term a (b, c) -> Formula (Term a (b, c))) ->
                    Formula (Term a (b, c)) -> Formula (Term a (b, c));
remove_Atom negate_atom (Atom phi) = form_not (negate_atom phi);
remove_Atom negate_atom (NegAtom phi) = NegAtom phi;
remove_Atom negate_atom (Disjunction phi_s) =
  Disjunction (map (remove_Atom negate_atom) phi_s);
remove_Atom negate_atom (Conjunction phi_s) =
  Conjunction (map (remove_Atom negate_atom) phi_s);

trivial_clause_checker :: forall a. (Eq a) => Formula a -> Bool;
trivial_clause_checker f = let {
                             (Disjunction a) = f;
                           } in trivial_checker a;

check_valid_formula ::
  forall a b c d.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => (a -> Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (c, d) -> [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_valid_formula logic_checker shows_atom negate_atom phi =
  catch_errora
    (let {
       (Conjunction phi_s) = flatten phi;
     } in catch_errora
            (forallM
              (\ phia ->
                catch_errora
                  (check (trivial_clause_checker phia)
                    ['t', 'r', 'i', 'v', 'i', 'a', 'l', ' ', 'c', 'l', 'a', 'u',
                      's', 'e', ' ', 'c', 'h', 'e', 'c', 'k', 'e', 'r', ' ',
                      'f', 'a', 'i', 'l', 'e', 'd'])
                  (\ _ ->
                    let {
                      (Conjunction phi_sa) =
                        flatten (remove_Atom negate_atom phia);
                    } in catch_errora (forallM (logic_checker defaulta) phi_sa)
                           (\ x -> Inl (snd x))))
              phi_s)
            (\ x -> Inl (snd x)))
    (\ x ->
      Inl (((shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
                 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'v', 'a', 'l', 'i', 'd',
                 'i', 't', 'y', ' ', 'o', 'f', ' ', 'f', 'o', 'r', 'm', 'u',
                 'l', 'a', ' '] .
              shows_formula shows_atom phi) .
             shows_nl) .
            x));

is_neg_atom_clause :: forall a. Formula a -> Bool;
is_neg_atom_clause (NegAtom a) = False;
is_neg_atom_clause (Atom a) = False;
is_neg_atom_clause (Conjunction xs) = False;
is_neg_atom_clause (Disjunction ls) = all is_neg_atom ls;

check_formula ::
  forall a b c d.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => (a -> Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (c, d) -> [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        Hint a ->
                          Formula (Term b (c, d)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_formula logic_checker shows_atom negate_atom (LexStrict hints)
  (Disjunction []) =
  Inl (shows_prec_list zero_nat
         ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n', 't',
           ' ', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' '] .
        shows_formula shows_atom (Disjunction []));
check_formula logic_checker shows_atom negate_atom (LexStrict hints)
  (Conjunction v) =
  Inl (shows_prec_list zero_nat
         ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n', 't',
           ' ', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' '] .
        shows_formula shows_atom (Conjunction v));
check_formula logic_checker shows_atom negate_atom (LexStrict hints) (NegAtom v)
  = Inl (shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' '] .
          shows_formula shows_atom (NegAtom v));
check_formula logic_checker shows_atom negate_atom (LexStrict hints) (Atom v) =
  Inl (shows_prec_list zero_nat
         ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n', 't',
           ' ', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' '] .
        shows_formula shows_atom (Atom v));
check_formula logic_checker shows_atom negate_atom (LexStrict hints)
  (Disjunction (phi : phi_s)) =
  check_formula_lex logic_checker shows_atom negate_atom hints phi phi_s;
check_formula logic_checker shows_atom negate_atom (LexWeak hints)
  (Disjunction []) =
  Inl (shows_prec_list zero_nat
         ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
           'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' '] .
        shows_formula shows_atom (Disjunction []));
check_formula logic_checker shows_atom negate_atom (LexWeak hints)
  (Conjunction v) =
  Inl (shows_prec_list zero_nat
         ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
           'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' '] .
        shows_formula shows_atom (Conjunction v));
check_formula logic_checker shows_atom negate_atom (LexWeak hints) (NegAtom v) =
  Inl (shows_prec_list zero_nat
         ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
           'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' '] .
        shows_formula shows_atom (NegAtom v));
check_formula logic_checker shows_atom negate_atom (LexWeak hints) (Atom v) =
  Inl (shows_prec_list zero_nat
         ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
           'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' '] .
        shows_formula shows_atom (Atom v));
check_formula logic_checker shows_atom negate_atom (LexWeak hints)
  (Disjunction (phi : phi_s)) =
  check_formula_lex_weak logic_checker shows_atom negate_atom hints phi phi_s;
check_formula logic_checker shows_atom negate_atom (Distribute n hints) phi =
  (case phi of {
    Atom _ ->
      Inl (shows_prec_list zero_nat
             ['D', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', ' ', 'h', 'i',
               'n', 't', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', ' ', 'D', 'i',
               's', 'j', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' '] .
            shows_formula shows_atom phi);
    NegAtom _ ->
      Inl (shows_prec_list zero_nat
             ['D', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', ' ', 'h', 'i',
               'n', 't', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', ' ', 'D', 'i',
               's', 'j', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' '] .
            shows_formula shows_atom phi);
    Conjunction _ ->
      Inl (shows_prec_list zero_nat
             ['D', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', ' ', 'h', 'i',
               'n', 't', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', ' ', 'D', 'i',
               's', 'j', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' '] .
            shows_formula shows_atom phi);
    Disjunction phi_s ->
      let {
        l = size_list phi_s;
      } in bindb (check (less_nat n l)
                   (((shows_prec_list zero_nat
                        ['d', 'i', 's', 't', 'r', 'i', 'b', 'u', 't', 'e', ' ',
                          'h', 'i', 'n', 't', ' ', 'a', 't', ' ', 'p', 'o', 's',
                          'i', 't', 'i', 'o', 'n', ' '] .
                       shows_prec_nat zero_nat n) .
                      shows_prec_list zero_nat
                        [' ', 'w', 'h', 'i', 'l', 'e', ' ', 'g', 'o', 'a', 'l',
                          ' ', 'i', 's', ' ', 'l', 'e', 'n', 'g', 't', 'h',
                          ' ']) .
                     shows_prec_nat zero_nat l))
             (\ _ ->
               let {
                 pre = take n phi_s;
                 post = drop (suc n) phi_s;
               } in (case nth phi_s n of {
                      Atom _ ->
                        Inl (((shows_prec_list zero_nat
                                 ['D', 'i', 's', 't', 'r', 'i', 'b', 'u', 't',
                                   'e', ' ', 'h', 'i', 'n', 't', ' ', 'i', 'n',
                                   ':', ' ', '\n'] .
                                shows_formula shows_atom phi) .
                               shows_prec_list zero_nat
                                 ['\n', ' ', 'a', 't', ' ', 'n', 'o', 'n', '-',
                                   'C', 'o', 'n', 'j', 'u', 'n', 'c', 't', 'i',
                                   'o', 'n', ' ', 'p', 'o', 's', 'i', 't', 'i',
                                   'o', 'n', ':', '\n']) .
                              shows_formula shows_atom (nth phi_s n));
                      NegAtom _ ->
                        Inl (((shows_prec_list zero_nat
                                 ['D', 'i', 's', 't', 'r', 'i', 'b', 'u', 't',
                                   'e', ' ', 'h', 'i', 'n', 't', ' ', 'i', 'n',
                                   ':', ' ', '\n'] .
                                shows_formula shows_atom phi) .
                               shows_prec_list zero_nat
                                 ['\n', ' ', 'a', 't', ' ', 'n', 'o', 'n', '-',
                                   'C', 'o', 'n', 'j', 'u', 'n', 'c', 't', 'i',
                                   'o', 'n', ' ', 'p', 'o', 's', 'i', 't', 'i',
                                   'o', 'n', ':', '\n']) .
                              shows_formula shows_atom (nth phi_s n));
                      Conjunction a ->
                        check_formula_dist logic_checker shows_atom negate_atom
                          hints pre post a;
                      Disjunction _ ->
                        Inl (((shows_prec_list zero_nat
                                 ['D', 'i', 's', 't', 'r', 'i', 'b', 'u', 't',
                                   'e', ' ', 'h', 'i', 'n', 't', ' ', 'i', 'n',
                                   ':', ' ', '\n'] .
                                shows_formula shows_atom phi) .
                               shows_prec_list zero_nat
                                 ['\n', ' ', 'a', 't', ' ', 'n', 'o', 'n', '-',
                                   'C', 'o', 'n', 'j', 'u', 'n', 'c', 't', 'i',
                                   'o', 'n', ' ', 'p', 'o', 's', 'i', 't', 'i',
                                   'o', 'n', ':', '\n']) .
                              shows_formula shows_atom (nth phi_s n));
                    }));
  });
check_formula logic_checker shows_atom negate_atom (Erase n hint) phi =
  (case phi of {
    Atom _ ->
      Inl (shows_prec_list zero_nat
            ['E', 'r', 'a', 's', 'e', ' ', 'h', 'i', 'n', 't', ' ', 't', 'o',
              ' ', 'n', 'o', 'n', '-', 'D', 'i', 's', 'j', 'u', 'n', 'c', 't',
              'i', 'o', 'n']);
    NegAtom _ ->
      Inl (shows_prec_list zero_nat
            ['E', 'r', 'a', 's', 'e', ' ', 'h', 'i', 'n', 't', ' ', 't', 'o',
              ' ', 'n', 'o', 'n', '-', 'D', 'i', 's', 'j', 'u', 'n', 'c', 't',
              'i', 'o', 'n']);
    Conjunction _ ->
      Inl (shows_prec_list zero_nat
            ['E', 'r', 'a', 's', 'e', ' ', 'h', 'i', 'n', 't', ' ', 't', 'o',
              ' ', 'n', 'o', 'n', '-', 'D', 'i', 's', 'j', 'u', 'n', 'c', 't',
              'i', 'o', 'n']);
    Disjunction phi_s ->
      let {
        l = size_list phi_s;
      } in bindb (check (less_nat n l)
                   (((shows_prec_list zero_nat
                        ['e', 'r', 'a', 's', 'e', ' ', 'h', 'i', 'n', 't', ' ',
                          'a', 't', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n',
                          ' '] .
                       shows_prec_nat zero_nat n) .
                      shows_prec_list zero_nat
                        [' ', 'w', 'h', 'i', 'l', 'e', ' ', 'g', 'o', 'a', 'l',
                          ' ', 'i', 's', ' ', 'l', 'e', 'n', 'g', 't', 'h',
                          ' ']) .
                     shows_prec_nat zero_nat l))
             (\ _ ->
               let {
                 pre = take n phi_s;
                 post = drop (suc n) phi_s;
               } in check_formula logic_checker shows_atom negate_atom hint
                      (Disjunction (pre ++ Disjunction [] : post)));
  });
check_formula logic_checker shows_atom negate_atom (Base h) phi =
  let {
    psi = remove_Atom negate_atom (simplify phi);
  } in bindb (check (is_neg_atom_clause psi)
               (shows_prec_list zero_nat
                  ['b', 'a', 's', 'e', ' ', 'h', 'i', 'n', 't', ' ', 'g', 'i',
                    'v', 'e', 'n', ' ', 't', 'o', ' '] .
                 shows_formula shows_atom psi))
         (\ _ ->
           catch_errora (logic_checker h psi)
             (\ x ->
               Inl (((shows_prec_list zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' '] .
                       shows_formula shows_atom phi) .
                      shows_nl) .
                     x)));
check_formula logic_checker shows_atom negate_atom Default phi =
  check_valid_formula logic_checker shows_atom negate_atom phi;

check_formula_lex ::
  forall a b c d.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => (a -> Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (c, d) -> [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        [Hint a] ->
                          Formula (Term b (c, d)) ->
                            [Formula (Term b (c, d))] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (va : vc : ve : vf)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (va : vc : ve : vf)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (va : Disjunction ve : vd)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (va : Disjunction ve : vd)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (va : Conjunction (vf : vh : vj : vk) : vd)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom
          (Disjunction (va : Conjunction (vf : vh : vj : vk) : vd)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (va : Conjunction [vf] : vd)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (va : Conjunction [vf] : vd)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (va : Conjunction [] : vd)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (va : Conjunction [] : vd)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (va : NegAtom ve : vd)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (va : NegAtom ve : vd)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (va : Atom ve : vd)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (va : Atom ve : vd)));
check_formula_lex logic_checker shows_atom negate_atom hints (Disjunction [va])
  phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction [va]));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (Disjunction vc : vb)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (Disjunction vc : vb)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (Conjunction (vd : vf : vh : vi) : vb)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom
          (Disjunction (Conjunction (vd : vf : vh : vi) : vb)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (Conjunction [vd] : vb)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (Conjunction [vd] : vb)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (Conjunction [] : vb)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (Conjunction [] : vb)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (NegAtom vc : vb)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (NegAtom vc : vb)));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Disjunction (Atom vc : vb)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction (Atom vc : vb)));
check_formula_lex logic_checker shows_atom negate_atom hints (Disjunction [])
  phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Disjunction []));
check_formula_lex logic_checker shows_atom negate_atom [] (Disjunction v) phi_s
  = Inl (((shows_prec_list zero_nat
             ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
               't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
               ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
            shows_prec_list zero_nat
              ((show_hint :: Hint a -> [Prelude.Char]) (LexStrict []))) .
           shows_prec_list zero_nat
             ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
          shows_formula shows_atom (Disjunction v));
check_formula_lex logic_checker shows_atom negate_atom hints
  (Conjunction (va : vc : ve : vf)) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Conjunction (va : vc : ve : vf)));
check_formula_lex logic_checker shows_atom negate_atom hints (Conjunction [va])
  phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Conjunction [va]));
check_formula_lex logic_checker shows_atom negate_atom hints (Conjunction [])
  phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Conjunction []));
check_formula_lex logic_checker shows_atom negate_atom hints (NegAtom v) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (NegAtom v));
check_formula_lex logic_checker shows_atom negate_atom hints (Atom v) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict hints))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Atom v));
check_formula_lex logic_checker shows_atom negate_atom (v : vb : vd : ve)
  (Conjunction va) phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict (v : vb : vd : ve)))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Conjunction va));
check_formula_lex logic_checker shows_atom negate_atom [v] (Conjunction va)
  phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat (show_hint (LexStrict [v]))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom (Conjunction va));
check_formula_lex logic_checker shows_atom negate_atom [] phi phi_s =
  Inl (((shows_prec_list zero_nat
           ['L', 'e', 'x', 'S', 't', 'r', 'i', 'c', 't', ' ', 'h', 'i', 'n',
             't', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
             ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
          shows_prec_list zero_nat
            ((show_hint :: Hint a -> [Prelude.Char]) (LexStrict []))) .
         shows_prec_list zero_nat
           ['\n', 'a', 'p', 'p', 'l', 'i', 'e', 'd', ' ', 'o', 'n', ' ']) .
        shows_formula shows_atom phi);
check_formula_lex logic_checker shows_atom negate_atom (hint1 : hints)
  (Disjunction [Conjunction [phi_1, phi_2], Conjunction [phi_3, phi_4]]) phi_s =
  (case hints of {
    [] -> bindb (check_formula logic_checker shows_atom negate_atom hint1
                  (Disjunction (phi_3 : phi_s)))
            (\ _ ->
              check_formula_lex logic_checker shows_atom negate_atom hints phi_4
                phi_s);
    [hint2] ->
      bindb (check_formula logic_checker shows_atom negate_atom hint1
              (Disjunction (phi_1 : phi_s)))
        (\ _ ->
          check_formula logic_checker shows_atom negate_atom hint2
            (Disjunction (phi_2 : phi_s)));
    _ : _ : _ ->
      bindb (check_formula logic_checker shows_atom negate_atom hint1
              (Disjunction (phi_3 : phi_s)))
        (\ _ ->
          check_formula_lex logic_checker shows_atom negate_atom hints phi_4
            phi_s);
  });
check_formula_lex logic_checker shows_atom negate_atom [hint1, hint2]
  (Conjunction [phi_1, phi_2]) phi_s =
  bindb (check_formula logic_checker shows_atom negate_atom hint1
          (Disjunction (phi_1 : phi_s)))
    (\ _ ->
      check_formula logic_checker shows_atom negate_atom hint2
        (Disjunction (phi_2 : phi_s)));

check_formula_dist ::
  forall a b c d.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => (a -> Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (c, d) -> [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        [Hint a] ->
                          [Formula (Term b (c, d))] ->
                            [Formula (Term b (c, d))] ->
                              [Formula (Term b (c, d))] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_formula_dist logic_checker shows_atom negate_atom [] uv uw (v : va) =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'n', 'g', 't', 'h', ' ', 'm', 'i', 's', 'm', 'a', 't', 'c',
          'h', ' ', 'i', 'n', ' ', 'D', 'i', 's', 't', 'r', 'i', 'b', 'u', 't',
          'e', ' ', 'h', 'i', 'n', 't', 's']);
check_formula_dist logic_checker shows_atom negate_atom (v : va) uv uw [] =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'n', 'g', 't', 'h', ' ', 'm', 'i', 's', 'm', 'a', 't', 'c',
          'h', ' ', 'i', 'n', ' ', 'D', 'i', 's', 't', 'r', 'i', 'b', 'u', 't',
          'e', ' ', 'h', 'i', 'n', 't', 's']);
check_formula_dist logic_checker shows_atom negate_atom (h : hs) pre post
  (phi : phi_s) =
  bindb (check_formula logic_checker shows_atom negate_atom h
          (Disjunction (pre ++ phi : post)))
    (\ _ ->
      check_formula_dist logic_checker shows_atom negate_atom hs pre post
        phi_s);
check_formula_dist logic_checker shows_atom negate_atom [] pre post [] = Inr ();

check_formula_lex_weak ::
  forall a b c d.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => (a -> Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (c, d) -> [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        [Hint a] ->
                          Formula (Term b (c, d)) ->
                            [Formula (Term b (c, d))] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vb : vd)
  (Disjunction (vc : ve : vg : vh)) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vb : vd)
  (Disjunction (vc : Disjunction vg : vf)) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vb : vd)
  (Disjunction (vc : Conjunction (vh : vj : vl : vm) : vf)) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vb : vd)
  (Disjunction (vc : Conjunction [vh] : vf)) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vb : vd)
  (Disjunction (vc : Conjunction [] : vf)) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vb : vd)
  (Disjunction (vc : NegAtom vg : vf)) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vb : vd)
  (Disjunction (vc : Atom vg : vf)) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vb : vd)
  (Disjunction [vc]) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vb : vc)
  (Disjunction []) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vc : vd)
  (Conjunction vb) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vc : vd)
  (NegAtom vb) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom (v : vc : vd)
  (Atom vb) phi_s =
  Inl (shows_prec_list zero_nat
        ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'h', 'i', 'n', 't', ' ', 'a',
          'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'e', 'r', 'r',
          'o', 'r']);
check_formula_lex_weak logic_checker shows_atom negate_atom [hint]
  (Disjunction (va : vc : ve : vf)) phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (Disjunction (va : vc : ve : vf) : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint]
  (Disjunction (va : Disjunction ve : vd)) phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (Disjunction (va : Disjunction ve : vd) : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint]
  (Disjunction (va : Conjunction (vf : vh : vj : vk) : vd)) phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction
      (Disjunction (va : Conjunction (vf : vh : vj : vk) : vd) : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint]
  (Disjunction (va : Conjunction [vf] : vd)) phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (Disjunction (va : Conjunction [vf] : vd) : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint]
  (Disjunction (va : Conjunction [] : vd)) phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (Disjunction (va : Conjunction [] : vd) : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint]
  (Disjunction (va : NegAtom ve : vd)) phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (Disjunction (va : NegAtom ve : vd) : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint]
  (Disjunction (va : Atom ve : vd)) phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (Disjunction (va : Atom ve : vd) : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint]
  (Disjunction [va]) phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (Disjunction [va] : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint]
  (Disjunction []) phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (Disjunction [] : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint]
  (Conjunction v) phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (Conjunction v : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint] (NegAtom v)
  phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (NegAtom v : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom [hint] (Atom v)
  phi_s =
  check_formula logic_checker shows_atom negate_atom hint
    (Disjunction (Atom v : phi_s));
check_formula_lex_weak logic_checker shows_atom negate_atom (hint : hints)
  (Disjunction [phi_1, Conjunction [phi_2, phi_3]]) phi_s =
  bindb (check_formula logic_checker shows_atom negate_atom hint
          (Disjunction (phi_2 : phi_s)))
    (\ _ ->
      check_formula_lex_weak logic_checker shows_atom negate_atom hints phi_3
        phi_s);
check_formula_lex_weak logic_checker shows_atom negate_atom [] phi phi_s =
  check (trivial_formula phi)
    (shows_prec_list zero_nat
       ['L', 'e', 'x', 'W', 'e', 'a', 'k', ' ', 'b', 'a', 's', 'e', ' ', 'c',
         'a', 's', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ':', ' '] .
      shows_formula shows_atom phi);

node_invariant ::
  forall a b c d e f. Art_ext a b c d e f -> e -> Formula (Term a (b, c));
node_invariant
  (Art_ext initial_nodes nodes edge node_location node_invariant more) =
  node_invariant;

rename_vars_exp :: forall a b c d. (a -> b) -> Term c (a, d) -> Term c (b, d);
rename_vars_exp r = map_term id (map_prod r id);

nodesa :: forall a b c d e. Hinter_ext a b c d e -> [c];
nodesa (Hinter_ext nodes succ_trans_list cover_hints transition_hints more) =
  nodes;

map_formula :: forall a b. (a -> b) -> Formula a -> Formula b;
map_formula f (Atom x1) = Atom (f x1);
map_formula f (NegAtom x2) = NegAtom (f x2);
map_formula f (Conjunction x3) = Conjunction (map (map_formula f) x3);
map_formula f (Disjunction x4) = Disjunction (map (map_formula f) x4);

edge :: forall a b c d e f. Art_ext a b c d e f -> e -> Art_edge a b c d e;
edge (Art_ext initial_nodes nodes edge node_location node_invariant more) =
  edge;

check_children_edges_cond ::
  forall a b c d e f.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d, Showa d, Showa e,
      Showa f) => (a -> Formula (Term b (Trans_var c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (Trans_var c, d) ->
                      [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (Trans_var c, d) ->
                        Formula (Term b (Trans_var c, d))) ->
                        Lts_ext b c d e () ->
                          Art_ext b c d e f () ->
                            Hinter_ext (Hint a) e f (Transition_rule b c d e)
                              () ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_children_edges_cond tc2 sa2 ne2 p a h =
  let {
    lc = assertion p;
  } in catch_errora
         (catch_errora
           (forallM
             (\ aa ->
               (case edge a aa of {
                 Cover _ -> Inr ();
                 Children children ->
                   (case transition_hintsa h aa of {
                     Nothing ->
                       Inl (shows_prec_list zero_nat
                             ['n', 'o', 't', ' ', 'y', 'e', 't']);
                     Just hints ->
                       catch_errora
                         (bindb
                           (check
                             (equal_nat (size_list hints) (size_list children))
                             (shows_prec_list zero_nat
                               ['t', 'h', 'e', ' ', 'n', 'u', 'm', 'b', 'e',
                                 'r', ' ', 'o', 'f', ' ', 'h', 'i', 'n', 't',
                                 's', ' ', 'd', 'i', 'f', 'f', 'e', 'r', 's',
                                 ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e',
                                 ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', 'o',
                                 'f', ' ', 'c', 'h', 'i', 'l', 'd', 'r', 'e',
                                 'n']))
                           (\ _ ->
                             catch_errora
                               (forallM
                                 (\ (b, c) ->
                                   let {
                                     (tau, ba) = b;
                                   } in (\ ha ->
  let {
    (Transition l _ phi) = tau;
  } in catch_errora
         (check_formula tc2 sa2 ne2 ha
           (Disjunction
             [map_formula (rename_vars_exp Post) (node_invariant a ba),
               form_not
                 (map_formula (rename_vars_exp Pre) (node_invariant a aa)),
               form_not (map_formula (rename_vars_exp Pre) (lc l)),
               form_not phi]))
         (\ x ->
           Inl ((((((((shows_prec_list zero_nat
                         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                           'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'e',
                           'd', 'g', 'e', ' '] .
                        shows_prec zero_nat aa) .
                       shows_prec_list zero_nat [' ', '-', '-', '>', ' ']) .
                      shows_prec zero_nat ba) .
                     shows_prec_list zero_nat
                       [' ', 'f', 'o', 'r', ' ', 't', 'r', 'a', 'n', 's', 'i',
                         't', 'i', 'o', 'n']) .
                    shows_nl) .
                   shows_transition sa2 tau) .
                  shows_nl) .
                 x)))
                                     c)
                                 (zip children hints))
                               (\ x -> Inl (snd x))))
                         (\ x ->
                           Inl (((shows_prec_list zero_nat
                                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                      'i', 'n', ' ', 'c', 'h', 'e', 'c', 'k',
                                      'i', 'n', 'g', ' ', 't', 'r', 'a', 'n',
                                      's', 'i', 't', 'i', 'o', 'n', 's', ' ',
                                      'o', 'f', ' ', 'n', 'o', 'd', 'e', ' '] .
                                   shows_prec zero_nat aa) .
                                  shows_nl) .
                                 x));
                   });
               }))
             (nodesa h))
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                    's', 'u', 'r', 'e', ' ', 't', 'r', 'a', 'n', 's', 'i', 't',
                    'i', 'o', 'n', ' ', 'e', 'd', 'g', 'e', ' ', 'c', 'o', 'n',
                    'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 'A', 'R',
                    'T', '\n'] .
                 x));

is_cover_nodea :: forall a b c d e. Art_edge a b c d e -> Bool;
is_cover_nodea (Cover x1) = True;
is_cover_nodea (Children x2) = False;

cover_hintsa :: forall a b c d e. Hinter_ext a b c d e -> c -> a;
cover_hintsa
  (Hinter_ext nodes succ_trans_list cover_hints transition_hints more) =
  cover_hints;

node_location :: forall a b c d e f. Art_ext a b c d e f -> e -> d;
node_location
  (Art_ext initial_nodes nodes edge node_location node_invariant more) =
  node_location;

nodes :: forall a b c d e f. Art_ext a b c d e f -> [e];
nodes (Art_ext initial_nodes nodes edge node_location node_invariant more) =
  nodes;

check_cover_edges_cond ::
  forall a b c d e f.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d, Showa d, Eq e,
      Showa e, Eq f,
      Showa f) => (a -> Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (c, d) -> [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        Lts_ext b c d e () ->
                          Art_ext b c d e f () ->
                            Hinter_ext (Hint a) e f (Transition_rule b c d e)
                              () ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cover_edges_cond tc sa ne p a h =
  let {
    _ = assertion p;
  } in catch_errora
         (catch_errora
           (forallM
             (\ aa ->
               (case edge a aa of {
                 Cover b ->
                   catch_errora
                     (bindb
                       (check (membera (nodes a) b)
                         (shows_prec_list zero_nat
                           ['t', 'a', 'r', 'g', 'e', 't', ' ', 'n', 'o', 'd',
                             'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'l',
                             'i', 's', 't', 'e', 'd', ' ', 'a', 's', ' ', 'a',
                             'r', 't', '-', 'n', 'o', 'd', 'e']))
                       (\ _ ->
                         bindb (check (node_location a aa == node_location a b)
                                 (shows_prec_list zero_nat
                                   ['n', 'o', 'd', 'e', '-', 'l', 'o', 'c', 'a',
                                     't', 'i', 'o', 'n', 's', ' ', 'd', 'i',
                                     'f', 'f', 'e', 'r']))
                           (\ _ ->
                             bindb (check (not (is_cover_nodea (edge a b)))
                                     (shows_prec_list zero_nat
                                       ['t', 'a', 'r', 'g', 'e', 't', ' ', 'n',
 'o', 'd', 'e', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'h', 'a', 'v',
 'e', ' ', 'c', 'o', 'v', 'e', 'r', ' ', 'e', 'd', 'g', 'e']))
                               (\ _ ->
                                 check_formula tc sa ne (cover_hintsa h aa)
                                   (Disjunction
                                     [node_invariant a b,
                                       form_not (node_invariant a aa)])))))
                     (\ x ->
                       Inl (((shows_prec_list zero_nat
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                  'n', ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n',
                                  'g', ' ', 'c', 'o', 'v', 'e', 'r', ' ', 'e',
                                  'd', 'g', 'e', ' ', 'o', 'f', ' ', 'n', 'o',
                                  'd', 'e', ' '] .
                               shows_prec zero_nat aa) .
                              shows_nl) .
                             x));
                 Children _ -> Inr ();
               }))
             (nodesa h))
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (shows_prec_list zero_nat
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                    's', 'u', 'r', 'e', ' ', 'c', 'o', 'v', 'e', 'r', ' ', 'e',
                    'd', 'g', 'e', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
                    'n', ' ', 'o', 'f', ' ', 'A', 'R', 'T', '\n'] .
                 x));

succ_trans_list :: forall a b c d e. Hinter_ext a b c d e -> b -> [d];
succ_trans_list
  (Hinter_ext nodes succ_trans_list cover_hints transition_hints more) =
  succ_trans_list;

initial_nodes :: forall a b c d e f. Art_ext a b c d e f -> [e];
initial_nodes
  (Art_ext initial_nodes nodes edge node_location node_invariant more) =
  initial_nodes;

check_simulation_cond ::
  forall a b c d e f.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d, Showa d, Cenum e,
      Ceq e, Ccompare e, Eq e, Set_impl e, Showa e, Eq f,
      Showa f) => (a -> Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (c, d) -> [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        Lts_ext b c d e () ->
                          Art_ext b c d e f () ->
                            Hinter_ext (Hint a) e f (Transition_rule b c d e)
                              () ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_simulation_cond tc sa ne p a h =
  catch_errora
    (bindb
      (check
        (less_eq_set (initial p)
          (set (map (node_location a) (initial_nodes a))))
        (shows_prec_list zero_nat
          ['n', 'o', 't', ' ', 'a', 'l', 'l', ' ', 'i', 'n', 'i', 't', 'i', 'a',
            'l', ' ', 'n', 'o', 'd', 'e', 's', ' ', 'o', 'f', ' ', 'L', 'T',
            'S', ' ', 'a', 'r', 'e', ' ', 'r', 'e', 'p', 'r', 'e', 's', 'e',
            'n', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'i', 'n', 'i', 't', 'i',
            'a', 'l', ' ', 'n', 'o', 'd', 'e', 's', ' ', 'i', 'n', ' ', 'A',
            'R', 'T']))
      (\ _ ->
        catch_errora
          (forallM
            (\ aa ->
              (case edge a aa of {
                Cover _ -> Inr ();
                Children children ->
                  let {
                    l = node_location a aa;
                  } in catch_errora
                         (catch_errora
                           (forallM
                             (\ tau ->
                               check (any (\ (taua, b) ->
    equal_transition_rule taua tau &&
      node_location a b == target tau && membera (nodes a) b)
                                       children)
                                 (((((shows_prec_list zero_nat
['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 'm',
  'a', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't', 'r', 'a', 'n', 's', 'i', 't',
  'i', 'o', 'n', ' ', 'i', 'n', ' ', 'A', 'R', 'T', ' ', 'f', 'o', 'r', ' ',
  'n', 'o', 'd', 'e', ' '] .
                                       shows_prec zero_nat aa) .
                                      shows_prec_list zero_nat
[' ', 'a', 'n', 'd', ' ', 't', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n',
  ' ']) .
                                     shows_prec zero_nat (source tau)) .
                                    shows_prec_list zero_nat
                                      [' ', '-', '-', '>', ' ']) .
                                   shows_prec zero_nat (target tau)))
                             (succ_trans_list h l))
                           (\ x -> Inl (snd x)))
                         (\ e1 ->
                           catch_errora
                             (check_valid_formula tc sa ne
                               (form_not (node_invariant a aa)))
                             (\ _ ->
                               Inl ((e1 . shows_nl) .
                                     shows_prec_list zero_nat
                                       ['a', 'n', 'd', ' ', 'c', 'o', 'u', 'l',
 'd', ' ', 'n', 'o', 't', ' ', 'p', 'r', 'o', 'v', 'e', ' ', 'u', 'n', 's', 'a',
 't', 'i', 's', 'f', 'i', 'a', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'o', 'f', ' ',
 't', 'h', 'e', ' ', 'n', 'o', 'd', 'e', ' ', 'i', 'n', 'v', 'a', 'r', 'i', 'a',
 'n', 't'])));
              }))
            (nodesa h))
          (\ x -> Inl (snd x))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
               'u', 'r', 'e', ' ', 's', 'i', 'm', 'u', 'l', 'a', 't', 'i', 'o',
               'n', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'o',
               'f', ' ', 'A', 'R', 'T', '\n'] .
            x));

check_initial_cond ::
  forall a b c d e.
    (Eq a, Showa a, Eq b, Showa b, Eq c, Showa c, Showa d, Eq e,
      Showa e) => (Term a (b, c) -> [Prelude.Char] -> [Prelude.Char]) ->
                    Art_ext a b c d e () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_initial_cond sa a =
  catch_errora
    (forallM
      (\ init ->
        bindb (check (membera (nodes a) init)
                ((shows_prec_list zero_nat
                    ['i', 'n', 'i', 't', 'i', 'a', 'l', ' ', 'n', 'o', 'd', 'e',
                      ' ', 'o', 'f', ' ', 'A', ' ', '('] .
                   shows_prec zero_nat init) .
                  shows_prec_list zero_nat
                    [')', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'm', 'e', 'n',
                      't', 'i', 'o', 'n', 'e', 'd', ' ', 'a', 's', ' ', 'n',
                      'o', 'd', 'e', ' ', 'o', 'f', ' ', 'A', 'R', 'T']))
          (\ _ ->
            check (equal_formula (node_invariant a init) (Conjunction []))
              (((shows_prec_list zero_nat
                   ['t', 'h', 'e', ' ', 'n', 'o', 'd', 'e', ' ', 'i', 'n', 'v',
                     'a', 'r', 'i', 'a', 'n', 't', ' ', 'f', 'o', 'r', ' ', 't',
                     'h', 'e', ' ', 'i', 'n', 'i', 't', 'i', 'a', 'l', ' ', 'A',
                     'R', 'T', ' ', 'n', 'o', 'd', 'e', ' ', '('] .
                  shows_prec zero_nat init) .
                 shows_prec_list zero_nat
                   [')', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'T', 'R',
                     'U', 'E', ',', ' ', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ',
                     'i', 's', ' ']) .
                shows_formula sa (node_invariant a init))))
      (initial_nodes a))
    (\ x -> Inl (snd x));

art ::
  forall a b c d e f.
    (Ceq b, Ccompare b,
      Eq b) => Logic_ext a b c () -> Art_ext a d b e f () -> Bool;
art lambda a =
  all (\ aa -> formula (is_bool lambda) (node_invariant a aa)) (nodes a);

check_art ::
  forall a b c d e f.
    (Ceq b, Ccompare b,
      Eq b) => Logic_ext a b c () ->
                 Art_ext a d b e f () ->
                   Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_art lambda a =
  check (art lambda a)
    (shows_prec_list zero_nat
      ['i', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd', ' ', 'i', 'n', 'v',
        'a', 'r', 'i', 'a', 'n', 't']);

check_art_invariants ::
  forall a b c d e f g.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d, Showa d, Eq e,
      Showa e, Cenum f, Ceq f, Ccompare f, Eq f, Set_impl f, Showa f, Eq g,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (d -> Formula (Term a (Trans_var e, b)) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                          (Term a (Trans_var e, b) ->
                            [Prelude.Char] -> [Prelude.Char]) ->
                            (Term a (e, b) -> Formula (Term a (e, b))) ->
                              (Term a (Trans_var e, b) ->
                                Formula (Term a (Trans_var e, b))) ->
                                Lts_ext a e b f () ->
                                  Art_ext a e b f g () ->
                                    Hinter_ext (Hint d) f g
                                      (Transition_rule a e b f) () ->
                                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_art_invariants t tc tc2 sa sa2 ne ne2 p a h =
  catch_errora
    (bindb (check_art t a)
      (\ _ ->
        bindb (check_initial_cond sa a)
          (\ _ ->
            bindb (check_simulation_cond tc sa ne p a h)
              (\ _ ->
                bindb (check_cover_edges_cond tc sa ne p a h)
                  (\ _ -> check_children_edges_cond tc2 sa2 ne2 p a h)))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
               'u', 'r', 'e', ' ', 'v', 'a', 'l', 'i', 'd', 'i', 't', 'y', ' ',
               'o', 'f', ' ', 'a', 'r', 't', '-', 'g', 'r', 'a', 'p', 'h', ':',
               '\n'] .
            x));

is_cover_node :: forall a b c d e f g. Art_node_impl a b c d e f g -> Bool;
is_cover_node (Art_Node uu uv uw (Cover_Edge ux uy)) = True;
is_cover_node (Art_Node uz va vb (Children_Edge vc)) = False;

transition_hints ::
  forall a b c d e f g.
    (Eq e) => Art_impl_ext a b c d e f g () -> e -> Maybe [g];
transition_hints ai =
  map_of
    (map_filter
      (\ x ->
        (if not (is_cover_node x)
          then Just (name x, let {
                               (Children_Edge a) = edgea x;
                             } in map (\ (_, (_, h)) -> h) a)
          else Nothing))
      (nodesb ai));

cover_hints ::
  forall a b c d e f g.
    (Ccompare e, Eq e, Mapping_impl e,
      Default g) => Art_impl_ext a b c d e f g () -> e -> g;
cover_hints ai =
  map_of_default defaulta
    (map_filter
      (\ x ->
        (if is_cover_node x then Just (name x, let {
         (Cover_Edge _ h) = edgea x;
       } in h)
          else Nothing))
      (nodesb ai));

make_hinter ::
  forall a b c d e f g h i j k l.
    (Eq d, Ccompare j, Eq j, Mapping_impl j,
      Default l) => Lts_impl a b c d e ->
                      Art_impl_ext f g h i j k l () ->
                        Hinter_ext l d j (Transition_rule a b c d) ();
make_hinter pi ai =
  Hinter_ext (art_nodes ai) (succ_transitions pi) (cover_hints ai)
    (transition_hints ai) ();

check_art_invariants_impl ::
  forall a b c d e f g h.
    (Ccompare a, Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d,
      Showa d, Ccompare e, Eq e, Showa e, Cenum f, Ceq f, Ccompare f, Eq f,
      Mapping_impl f, Set_impl f, Showa f, Ccompare g, Eq g, Mapping_impl g,
      Showa g, Ceq h, Ccompare h, Eq h, Mapping_impl h, Set_impl h,
      Showa h) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (d -> Formula (Term a (Trans_var e, b)) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                          (Term a (Trans_var e, b) ->
                            [Prelude.Char] -> [Prelude.Char]) ->
                            (Term a (e, b) -> Formula (Term a (e, b))) ->
                              (Term a (Trans_var e, b) ->
                                Formula (Term a (Trans_var e, b))) ->
                                Art_impl_ext a e b f g h (Hint d) () ->
                                  Lts_impl a e b f h ->
                                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_art_invariants_impl lambda tc tc2 sa sa2 ne ne2 ai pi =
  check_art_invariants lambda tc tc2 sa sa2 ne ne2 (lts_of pi) (art_of pi ai)
    (make_hinter pi ai);

check_unique_names ::
  forall a b c d e f g h.
    (Eq e) => Art_impl_ext a b c d e f g h ->
                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unique_names ai =
  check (distinct (map name (nodesb ai)))
    (shows_prec_list zero_nat
      ['N', 'o', 'd', 'e', 's', ' ', 'i', 'n', ' ', 'a', 'r', 't', ' ', 'g',
        'r', 'a', 'p', 'h', ' ', 'm', 'u', 's', 't', ' ', 'h', 'a', 'v', 'e',
        ' ', 'u', 'n', 'i', 'q', 'u', 'e', ' ', 'n', 'a', 'm', 'e', 's']);

restrict_invariants ::
  forall a b c d.
    (Ceq a,
      Ccompare a) => (a -> Formula (Term b (c, d))) ->
                       Set a -> a -> Formula (Term b (c, d));
restrict_invariants i la l = (if member l la then i l else Conjunction []);

get_disj_invariant ::
  forall a b c d e.
    (Eq d) => Art_ext a b c d e () -> d -> Formula (Term a (b, c));
get_disj_invariant a l =
  Disjunction
    (map_filter
      (\ x ->
        (if node_location a x == l && not (is_cover_nodea (edge a x))
          then Just (node_invariant a x) else Nothing))
      (nodes a));

shows_labeled_transition ::
  forall a b c d e.
    (Showa d,
      Showa e) => (Term a (Trans_var b, c) ->
                    [Prelude.Char] -> [Prelude.Char]) ->
                    (d, Transition_rule a b c e) ->
                      [Prelude.Char] -> [Prelude.Char];
shows_labeled_transition shows_tatom (lab, tran) =
  (shows_prec zero_nat lab . shows_prec_list zero_nat [':', ' ']) .
    shows_transition shows_tatom tran;

shows_lts ::
  forall a b c d e.
    (Showa d,
      Showa e) => (Term a (b, c) -> [Prelude.Char] -> [Prelude.Char]) ->
                    (Term a (Trans_var b, c) ->
                      [Prelude.Char] -> [Prelude.Char]) ->
                      Lts_impl a b c d e -> [Prelude.Char] -> [Prelude.Char];
shows_lts shows_atom shows_tatom (Lts_Impl i tran lc) =
  (((((shows_prec_list zero_nat
         ['L', 'T', 'S', ':', '\n', 'I', 'n', 'i', 't', 'i', 'a', 'l', ' ', 'l',
           'o', 'c', 'a', 't', 'i', 'o', 'n', 's', ':', ' '] .
        shows_prec_list zero_nat i) .
       shows_prec_list zero_nat
         ['\n', 'T', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 's', '\n']) .
      shows_sep (shows_labeled_transition shows_tatom) shows_nl tran) .
     shows_prec_list zero_nat
       ['\n', 'L', 'o', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'c', 'o', 'n', 'd',
         'i', 't', 'i', 'o', 'n', 's']) .
    shows_sep
      (\ (l, f) ->
        (shows_prec zero_nat l . shows_prec_list zero_nat [':', ' ']) .
          shows_formula shows_atom f)
      shows_nl lc) .
    shows_nl;

check_trivial_implication :: forall a. (Eq a) => Formula a -> Formula a -> Bool;
check_trivial_implication phi psi =
  all (\ phia ->
        let {
          c_phis = get_conjunctions phia;
        } in any (\ psia -> all (membera c_phis) (get_conjunctions psia))
               (get_disjunctions psi))
    (get_disjunctions phi);

shows_art_node ::
  forall a b c d e f g.
    (Showa d, Showa e,
      Showa f) => Art_node_impl a b c d e f g ->
                    [Prelude.Char] -> [Prelude.Char];
shows_art_node (Art_Node n uu l (Cover_Edge m uv)) =
  (((shows_prec zero_nat n . shows_prec_list zero_nat ['(', '@', ' ']) .
     shows_prec zero_nat l) .
    shows_prec_list zero_nat
      [')', ':', ' ', 'c', 'o', 'v', 'e', 'r', 'e', 'd', ' ', 'b', 'y', ' ']) .
    shows_prec zero_nat m;
shows_art_node (Art_Node n uw l (Children_Edge ls)) =
  (((shows_prec zero_nat n . shows_prec_list zero_nat ['(', '@', ' ']) .
     shows_prec zero_nat l) .
    shows_prec_list zero_nat
      [')', ':', ' ', 'g', 'o', 'e', 's', ' ', 't', 'o', ' ']) .
    shows_list_gen
      (\ (tr, (na, _)) ->
        ((shows_prec_list zero_nat ['-'] . shows_prec zero_nat tr) .
          shows_prec_list zero_nat ['-', '>']) .
          shows_prec zero_nat na)
      ['[', ']'] ['['] [',', ' '] [']'] ls;

shows_art ::
  forall a b c d e f g.
    (Showa d, Showa e,
      Showa f) => Art_impl_ext a b c d e f g () ->
                    [Prelude.Char] -> [Prelude.Char];
shows_art a =
  (((shows_prec_list zero_nat
       ['A', 'R', 'T', ':', '\n', 'I', 'n', 'i', 't', 'i', 'a', 'l', ' ', 'n',
         'o', 'd', 'e', ':', ' '] .
      shows_prec_list zero_nat (initial_nodesa a)) .
     shows_prec_list zero_nat ['\n', 'A', 'r', 'c', 's', '\n']) .
    shows_sep shows_art_node shows_nl (nodesb a)) .
    shows_nl;

invariant_proof_checker ::
  forall a b c d e f g h.
    (Ccompare a, Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d,
      Showa d, Ccompare e, Eq e, Showa e, Cenum f, Ceq f, Ccompare f, Eq f,
      Mapping_impl f, Set_impl f, Showa f, Ceq g, Ccompare g, Eq g,
      Mapping_impl g, Set_impl g, Showa g, Ccompare h, Eq h, Mapping_impl h,
      Showa h) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (d -> Formula (Term a (Trans_var e, b)) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                          (Term a (Trans_var e, b) ->
                            [Prelude.Char] -> [Prelude.Char]) ->
                            (Term a (e, b) -> Formula (Term a (e, b))) ->
                              (Term a (Trans_var e, b) ->
                                Formula (Term a (Trans_var e, b))) ->
                                Lts_impl a e b f g ->
                                  Invariant_proof a e b f h g d ->
                                    Sum ([Prelude.Char] -> [Prelude.Char])
                                      (f -> Formula (Term a (e, b)));
invariant_proof_checker lambda tc tc2 sa sa2 ne ne2 pi (Impact ii ai) =
  debug ['i', 'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', ' ', 'c', 'h', 'e', 'c',
          'k', 'i', 'n', 'g', ':']
    ['I', 'm', 'p', 'a', 'c', 't']
    (let {
       i = map_of_default (Conjunction []) ii;
     } in (case catch_errora
                  (bindb (check_unique_names ai)
                    (\ _ ->
                      bindb (debug []
                              ['p', 'r', 'o', 'v', 'i', 'd', 'e', 'd', ' ', 'i',
                                'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', 's',
                                ' ', 'a', 'g', 'a', 'i', 'n', 's', 't', ' ',
                                'd', 'e', 'd', 'u', 'c', 'e', 'd', ' ', 'i',
                                'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', 's',
                                ' ', 'f', 'r', 'o', 'm', ' ', 'A', 'R', 'T',
                                ' ', 'g', 'r', 'a', 'p', 'h']
                              (catch_errora
                                (forallM
                                  (\ l ->
                                    let {
                                      il = i l;
                                    } in bindb
   (check (formula (is_bool lambda) il)
     (shows_prec_list zero_nat
        ['i', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd', ' ', 'f', 'o', 'r',
          'm', 'u', 'l', 'a', ' ', 'f', 'o', 'r', ' ', 'l', 'o', 'c', 'a', 't',
          'i', 'o', 'n', ' '] .
       shows_prec zero_nat l))
   (\ _ ->
     check (check_trivial_implication (get_disj_invariant (art_of pi ai) l) il)
       (shows_prec_list zero_nat
          ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c',
            'h', ' ', 'p', 'r', 'o', 'v', 'i', 'd', 'e', 'd', ' ', 'i', 'n',
            'v', 'a', 'r', 'i', 'a', 'n', 't', ' ', 'w', 'i', 't', 'h', ' ',
            'i', 'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', ' ', 'e', 'x', 't',
            'r', 'a', 'c', 't', 'e', 'd', ' ', 'f', 'r', 'o', 'm', ' ', 'a',
            'r', 't', '-', 'g', 'r', 'a', 'p', 'h', ' ', 'a', 't', ' ', 'l',
            'o', 'c', 'a', 't', 'i', 'o', 'n', ' '] .
         shows_prec zero_nat l)))
                                  (nodes_lts_impl pi))
                                (\ x -> Inl (snd x))))
                        (\ _ ->
                          debug []
                            ['c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'A',
                              'R', 'T', ' ', 'g', 'r', 'a', 'p', 'h']
                            (check_art_invariants_impl lambda tc tc2 sa sa2 ne
                              ne2 ai pi))))
                  (\ x ->
                    Inl ((((shows_prec_list zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n',
                                ' ', 'e', 'n', 's', 'u', 'r', 'i', 'n', 'g',
                                ' ', 'i', 'n', 'v', 'a', 'r', 'i', 'a', 'n',
                                't', 's', ' ', 'f', 'o', 'r', ' '] .
                             shows_lts sa sa2 pi) .
                            shows_prec_list zero_nat
                              ['\n', 'v', 'i', 'a', ' ']) .
                           shows_art ai) .
                          x))
            of {
            Inl a -> Inl a;
            Inr _ -> Inr (restrict_invariants i (set (nodes_lts_impl pi)));
          }));

safe_by_assertion_checker ::
  forall a b c d e f.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d, Showa d,
      Ccompare e, Eq e, Mapping_impl e,
      Showa e) => (a -> Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (c, d) -> [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        Lts_impl b c d e f ->
                          [e] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
safe_by_assertion_checker logic_checker shows_atom negate_atom pi err =
  catch_errora
    (forallM
      (\ l ->
        catch_errora
          (check_valid_formula logic_checker shows_atom negate_atom
            (form_not (assertion_of pi l)))
          (\ _ ->
            Inl ((shows_prec_list zero_nat
                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'd', 'e',
                      'd', 'u', 'c', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 'a',
                      's', 's', 'e', 'r', 't', 'i', 'o', 'n', ' ', 't', 'h',
                      'a', 't', ' '] .
                   shows_prec zero_nat l) .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'u', 'n', 'r', 'e', 'a', 'c', 'h', 'a',
                      'b', 'l', 'e'])))
      err)
    (\ x -> Inl (snd x));

fix_invariants ::
  forall a b c d e.
    (Ccompare d, Eq d, Mapping_impl d, Showa d,
      Showa e) => Lts_impl a b c d e ->
                    (d -> Formula (Term a (b, c))) ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Lts_impl a b c d e);
fix_invariants p i =
  catch_errora
    (let {
       ls = nodes_lts_impl p;
       _ = assertion_of p;
     } in Inr (Lts_Impl (initiala p) (transitions_impl p)
                (map (\ l -> (l, i l)) ls)))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'f', 'i', 'x', 'i', 'n', 'g', ' ', 'i', 'n', 'v', 'a', 'r', 'i',
               'a', 'n', 't', 's', ' ', 'a', 's', ' ', 'a', 's', 's', 'e', 'r',
               't', 'i', 'o', 'n', 's', '\n'] .
            x));

check_safety_proof ::
  forall a b c d e f g h.
    (Ccompare a, Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d,
      Showa d, Ccompare e, Eq e, Showa e, Cenum f, Ceq f, Ccompare f, Eq f,
      Mapping_impl f, Set_impl f, Showa f, Ceq g, Ccompare g, Eq g,
      Mapping_impl g, Set_impl g, Showa g, Ccompare h, Eq h, Mapping_impl h,
      Showa h) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (d -> Formula (Term a (Trans_var e, b)) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                          (Term a (Trans_var e, b) ->
                            [Prelude.Char] -> [Prelude.Char]) ->
                            (Term a (e, b) -> Formula (Term a (e, b))) ->
                              (Term a (Trans_var e, b) ->
                                Formula (Term a (Trans_var e, b))) ->
                                Lts_impl a e b f g ->
                                  [f] ->
                                    Safety_proof a e b f h g d ->
                                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_safety_proof lambda tc tc2 sa sa2 ne ne2 pi err
  (Invariant_Assertion inv_prf inner) =
  debug []
    ['A', 'd', 'd', ' ', 'I', 'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', 's']
    (bindb (invariant_proof_checker lambda tc tc2 sa sa2 ne ne2 pi inv_prf)
      (\ i ->
        bindb (fix_invariants pi i)
          (\ qi ->
            check_safety_proof lambda tc tc2 sa sa2 ne ne2 qi err inner)));
check_safety_proof lambda tc tc2 sa sa2 ne ne2 pi err Trivial =
  debug []
    ['U', 'n', 's', 'a', 't', 'i', 's', 'f', 'i', 'a', 'b', 'l', 'e', ' ', 'E',
      'r', 'r', 'o', 'r', ' ', 's', 't', 'a', 't', 'e', 's']
    (safe_by_assertion_checker tc sa ne pi err);

transition_rule ::
  forall a b c d e.
    (Ceq b, Ccompare b,
      Eq b) => Logic_ext a b c () -> Transition_rule a d b e -> Bool;
transition_rule lambda (Transition l r phi) = formula (is_bool lambda) phi;

check_lts_impl ::
  forall a b c d e f.
    (Ceq b, Ccompare b,
      Eq b) => Logic_ext a b c () ->
                 Lts_impl a d b e f ->
                   Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lts_impl lambda pi =
  let {
    (Lts_Impl _ ti lc) = pi;
  } in bindb (catch_errora
               (forallM
                 (\ (_, t) ->
                   check (transition_rule lambda t)
                     (shows_prec_list zero_nat
                       ['i', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd', ' ',
                         't', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' ',
                         'i', 'n', ' ', 'L', 'T', 'S']))
                 ti)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ (_, f) ->
                 check (formula (is_bool lambda) f)
                   (shows_prec_list zero_nat
                     ['i', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd', ' ',
                       'l', 'o', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'c', 'o',
                       'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ',
                       'L', 'T', 'S']))
               lc)
             (\ x -> Inl (snd x)));

check_safety ::
  forall a b c d e f g h.
    (Ccompare a, Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d,
      Showa d, Ccompare e, Eq e, Showa e, Cenum f, Ceq f, Ccompare f, Eq f,
      Mapping_impl f, Set_impl f, Showa f, Ceq g, Ccompare g, Eq g,
      Mapping_impl g, Set_impl g, Showa g, Ccompare h, Eq h, Mapping_impl h,
      Showa h) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (d -> Formula (Term a (Trans_var e, b)) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                          (Term a (Trans_var e, b) ->
                            [Prelude.Char] -> [Prelude.Char]) ->
                            (Term a (e, b) -> Formula (Term a (e, b))) ->
                              (Term a (Trans_var e, b) ->
                                Formula (Term a (Trans_var e, b))) ->
                                Lts_impl a e b f g ->
                                  [f] ->
                                    Safety_proof a e b f h g d ->
                                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_safety lambda tc tc2 sa sa2 ne ne2 pi err prf =
  bindb (debug ['i', 'n', 'i', 't']
          ['C', 'h', 'e', 'c', 'k', ' ', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r',
            'm', 'e', 'd', 'n', 'e', 's', 's']
          (check_lts_impl lambda pi))
    (\ _ -> check_safety_proof lambda tc tc2 sa sa2 ne ne2 pi err prf);

check_single_subsumption ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b, Term a b) ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_single_subsumption eq e convs =
  bindb (check (membera (map fst convs) eq)
          (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
               'd', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ',
               'f', 'o', 'r', ' ', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
               ' '] .
            shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
              [' ', '=', ' '] eq))
    (\ _ -> check_subsumptions_guided e convs);

eq_proof_lines ::
  forall a b.
    (Showa a,
      Showa b) => Eq_proof a b ->
                    Nat ->
                      ([Prelude.Char] -> [Prelude.Char],
                        (Nat, (Term a b, Term a b)));
eq_proof_lines (Refl s) i =
  ((shows_nl . shows_prec_nat zero_nat (suc i) . shows_string [':', ' ']) .
     shows_rule (shows_prec zero_nat) (shows_prec zero_nat) [' ', '=', ' ']
       (s, s) .
       shows_string [' ', '[', 'r', 'e', 'f', 'l', ']'],
    (suc i, (s, s)));
eq_proof_lines (Sym p) i =
  let {
    (s, (ia, (l, r))) = eq_proof_lines p i;
  } in (s . (shows_nl .
              shows_prec_nat zero_nat (suc ia) . shows_string [':', ' ']) .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '=', ' '] (r, l) .
                shows_string [' ', '[', 's', 'y', 'm', ' '] .
                  shows_prec_nat zero_nat ia . shows_string [']'],
         (suc ia, (r, l)));
eq_proof_lines (Trans p1 p2) i =
  let {
    (s1, (i1, (s, _))) = eq_proof_lines p1 i;
    (s2, (i2, (_, v))) = eq_proof_lines p2 i1;
  } in (s1 . s2 . (shows_nl .
                    shows_prec_nat zero_nat (suc i2) .
                      shows_string [':', ' ']) .
                    shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                      [' ', '=', ' '] (s, v) .
                      shows_string [' ', '[', 't', 'r', 'a', 'n', 's', ' '] .
                        shows_prec_nat zero_nat i1 .
                          shows_string [',', ' '] .
                            shows_prec_nat zero_nat i2 . shows_string [']'],
         (suc i2, (s, v)));
eq_proof_lines (Assm (l, r) sigma) i =
  let {
    eq = (subst_apply_term l sigma, subst_apply_term r sigma);
  } in ((shows_nl . shows_prec_nat zero_nat (suc i) . shows_string [':', ' ']) .
          shows_rule (shows_prec zero_nat) (shows_prec zero_nat) [' ', '=', ' ']
            eq .
            shows_string [' ', '[', 'a', 's', 's', 'm', ' '] .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '=', ' '] (l, r) .
                shows_string [']'],
         (suc i, eq));
eq_proof_lines (Cong f ps) i =
  let {
    (s, (is, (ls, rs))) = eq_proofs_lines ps i;
    eq = (Fun f ls, Fun f rs);
    ia = last is;
    isa = butlast is;
  } in (s . (shows_nl .
              shows_prec_nat zero_nat (suc ia) . shows_string [':', ' ']) .
              shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                [' ', '=', ' '] eq .
                shows_list_gen (shows_prec_nat zero_nat)
                  [' ', '[', 'c', 'o', 'n', 'g', ']']
                  [' ', '[', 'c', 'o', 'n', 'g', ' '] [',', ' '] [']'] isa,
         (suc ia, eq));

eq_proofs_lines ::
  forall a b.
    (Showa a,
      Showa b) => [Eq_proof a b] ->
                    Nat ->
                      ([Prelude.Char] -> [Prelude.Char],
                        ([Nat], ([Term a b], [Term a b])));
eq_proofs_lines [] i = (id, ([i], ([], [])));
eq_proofs_lines (p : ps) i = let {
                               (s1, (ia, (l, r))) = eq_proof_lines p i;
                               (s2, (is, (ls, rs))) = eq_proofs_lines ps ia;
                             } in (s1 . s2, (ia : is, (l : ls, r : rs)));

check_proves ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Eq_proof a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Term a b, Term a b);
check_proves e (Refl s) = Inr (s, s);
check_proves e (Sym p) = bindb (check_proves e p) (\ (s, t) -> Inr (t, s));
check_proves e (Trans p1 p2) =
  bindb (check_proves e p1)
    (\ (s, t) ->
      bindb (check_proves e p2)
        (\ (ta, u) ->
          (if equal_term t ta then Inr (s, u)
            else Inl (shows_string
                        ['t', 'h', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o',
                          'c', 'c', 'u', 'r', 's', ' ', 'i', 'n', ' ', 't', 'h',
                          'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                          ' ', 'p', 'a', 'r', 't', ' '] .
                       shows_nl .
                         fst (eq_proof_lines (Trans p1 p2) zero_nat) .
                           shows_nl .
                             shows_nl .
                               shows_prec_term zero_nat t .
                                 shows_string
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e',
                                     'q', 'u', 'a', 'l', ' ', 't', 'o', ' '] .
                                   shows_prec_term zero_nat ta))));
check_proves e (Assm (l, r) sigma) =
  (if membera e (l, r)
    then Inr (subst_apply_term l sigma, subst_apply_term r sigma)
    else Inl (shows_string
                ['t', 'h', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o', 'c',
                  'c', 'u', 'r', 's', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ',
                  'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'p', 'a',
                  'r', 't', ' '] .
               shows_nl .
                 fst (eq_proof_lines (Assm (l, r) sigma) zero_nat) .
                   shows_nl .
                     shows_nl .
                       shows_eq (shows_prec zero_nat) (shows_prec zero_nat)
                         (l, r) .
                         shows_string
                           [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n',
                             ' ', 't', 'h', 'e', ' '] .
                           shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                             ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l',
                               ' ', 's', 'y', 's', 't', 'e', 'm', ':']
                             [' ', '=', ' '] e));
check_proves e (Cong f ps) =
  bindb (mapM (check_proves e) ps)
    (\ sts -> Inr (Fun f (map fst sts), Fun f (map snd sts)));

check_eq_proof ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Eq_proof a b ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_eq_proof e p eq =
  catch_errora
    (bindb (check_proves e p)
      (\ eqa ->
        (if eq == eqa then Inr ()
          else Inl (shows_string
                     ['t', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'd',
                       'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'f', 'i', 't',
                       ' ', 't', 'h', 'e', ' ', 'g', 'o', 'a', 'l']))))
    (\ x ->
      Inl (shows_string
             ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', 'n', ' ', 'e',
               'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'e',
               'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'l', 'o', 'g',
               'i', 'c', ' ', 'p', 'r', 'o', 'o', 'f'] .
            shows_nl .
              fst (eq_proof_lines p zero_nat) .
                shows_nl .
                  shows_nl .
                    shows_string
                      ['f', 'o', 'r', ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g',
                        ' ', 't', 'h', 'e', ' ', 'e', 'q', 'u', 'a', 't', 'i',
                        'o', 'n'] .
                      shows_nl .
                        shows_nl .
                          shows_eq (shows_prec zero_nat) (shows_prec zero_nat)
                            eq .
                            shows_nl .
                              shows_nl .
                                shows_string
                                  ['u', 's', 'i', 'n', 'g', ' ', 't', 'h', 'e',
                                    ' '] .
                                  shows_trs (shows_prec zero_nat)
                                    (shows_prec zero_nat)
                                    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
                                      'a', 'l', ' ', 's', 'y', 's', 't', 'e',
                                      'm', ':']
                                    [' ', '=', ' '] e .
                                    shows_nl . x));

check_equational_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            Equation_literal (Lab b [Nat]) [Prelude.Char] ->
                              Equational_proof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_equational_proof a ia i j e (Equation eq) (Equational_Proof_Tree p) =
  debug (ia [])
    ['E', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', '_', 'P', 'r', 'o', 'o',
      'f', '_', 'T', 'r', 'e', 'e']
    (check_eq_proof e p eq);
check_equational_proof a ia i j e (Equation eq) (Conversion eseq) =
  debug (ia []) ['C', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n']
    (check_conversiona e eseq (fst eq) (snd eq));
check_equational_proof a ia i j e (Equation eq) (Conversion_With_History convs)
  = debug (ia [])
      ['C', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'w', 'i', 't',
        'h', ' ', 'H', 'i', 's', 't', 'o', 'r', 'y']
      (check_single_subsumption eq e convs);
check_equational_proof a ia i j e (Equation eq)
  (Completion_and_Normalization r p) =
  debug (ia [])
    ['C', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', '_', 'a', 'n', 'd', '_',
      'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n']
    (bindb (check_completion_proof a ia i j e r p)
      (\ _ ->
        let {
          s = fst eq;
          t = snd eq;
        } in (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
               (Nothing, _) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab zero_nat)
                             (shows_prec_list zero_nat) t);
               (Just _, Nothing) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab zero_nat)
                             (shows_prec_list zero_nat) t);
               (Just sa, Just ta) ->
                 (if equal_term sa ta then Inr ()
                   else Inl (shows_term (shows_prec_lab zero_nat)
                               (shows_prec_list zero_nat) s .
                              shows_string [' ', 'a', 'n', 'd', ' '] .
                                shows_term (shows_prec_lab zero_nat)
                                  (shows_prec_list zero_nat) t .
                                  shows_string
                                    [' ', 'h', 'a', 'v', 'e', ' ', 'd', 'i',
                                      'f', 'f', 'e', 'r', 'e', 'n', 't', ' ',
                                      'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f',
                                      'o', 'r', 'm', 's']));
             })));
check_equational_proof uu uv uw ux uy (Inequality v) va =
  Inl (shows_string
        ['u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'e', 'q',
          'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'p', 'r', 'o', 'o', 'f',
          ' ']);

check_dp_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          c -> Dp_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_termination_proof ia j a i dpp prf =
  check_dp_termination_proof_main ia j a i dpp (fst (unlab_to_split_dp prf));

equal_claim :: forall a b. Claim a b -> Claim a b -> Bool;
equal_claim Completed Anything = False;
equal_claim Anything Completed = False;
equal_claim Nonconfluent Anything = False;
equal_claim Anything Nonconfluent = False;
equal_claim Nonconfluent Completed = False;
equal_claim Completed Nonconfluent = False;
equal_claim Confluent Anything = False;
equal_claim Anything Confluent = False;
equal_claim Confluent Completed = False;
equal_claim Completed Confluent = False;
equal_claim Confluent Nonconfluent = False;
equal_claim Nonconfluent Confluent = False;
equal_claim Nonterminating Anything = False;
equal_claim Anything Nonterminating = False;
equal_claim Nonterminating Completed = False;
equal_claim Completed Nonterminating = False;
equal_claim Nonterminating Nonconfluent = False;
equal_claim Nonconfluent Nonterminating = False;
equal_claim Nonterminating Confluent = False;
equal_claim Confluent Nonterminating = False;
equal_claim (Upperbound x4) Anything = False;
equal_claim Anything (Upperbound x4) = False;
equal_claim (Upperbound x4) Completed = False;
equal_claim Completed (Upperbound x4) = False;
equal_claim (Upperbound x4) Nonconfluent = False;
equal_claim Nonconfluent (Upperbound x4) = False;
equal_claim (Upperbound x4) Confluent = False;
equal_claim Confluent (Upperbound x4) = False;
equal_claim (Upperbound x4) Nonterminating = False;
equal_claim Nonterminating (Upperbound x4) = False;
equal_claim Terminating Anything = False;
equal_claim Anything Terminating = False;
equal_claim Terminating Completed = False;
equal_claim Completed Terminating = False;
equal_claim Terminating Nonconfluent = False;
equal_claim Nonconfluent Terminating = False;
equal_claim Terminating Confluent = False;
equal_claim Confluent Terminating = False;
equal_claim Terminating Nonterminating = False;
equal_claim Nonterminating Terminating = False;
equal_claim Terminating (Upperbound x4) = False;
equal_claim (Upperbound x4) Terminating = False;
equal_claim No Anything = False;
equal_claim Anything No = False;
equal_claim No Completed = False;
equal_claim Completed No = False;
equal_claim No Nonconfluent = False;
equal_claim Nonconfluent No = False;
equal_claim No Confluent = False;
equal_claim Confluent No = False;
equal_claim No Nonterminating = False;
equal_claim Nonterminating No = False;
equal_claim No (Upperbound x4) = False;
equal_claim (Upperbound x4) No = False;
equal_claim No Terminating = False;
equal_claim Terminating No = False;
equal_claim Yes Anything = False;
equal_claim Anything Yes = False;
equal_claim Yes Completed = False;
equal_claim Completed Yes = False;
equal_claim Yes Nonconfluent = False;
equal_claim Nonconfluent Yes = False;
equal_claim Yes Confluent = False;
equal_claim Confluent Yes = False;
equal_claim Yes Nonterminating = False;
equal_claim Nonterminating Yes = False;
equal_claim Yes (Upperbound x4) = False;
equal_claim (Upperbound x4) Yes = False;
equal_claim Yes Terminating = False;
equal_claim Terminating Yes = False;
equal_claim Yes No = False;
equal_claim No Yes = False;
equal_claim (Upperbound x4) (Upperbound y4) = equal_nat x4 y4;
equal_claim Anything Anything = True;
equal_claim Completed Completed = True;
equal_claim Nonconfluent Nonconfluent = True;
equal_claim Confluent Confluent = True;
equal_claim Nonterminating Nonterminating = True;
equal_claim Terminating Terminating = True;
equal_claim No No = True;
equal_claim Yes Yes = True;

mke ::
  forall a b c d.
    Ac_tp_ops_ext a b c d -> [(Term b c, Term b c)] -> [b] -> [b] -> a;
mke (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = mk;

get_args_impl :: forall a b. Bool -> Term a b -> [Term a b];
get_args_impl True t = args t;
get_args_impl False t = [t];

innermost_repl_map_impl ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                        [((a, Nat), Nat)];
innermost_repl_map_impl r ecap p =
  remdups
    (concatMap
      (\ ((l, ra), b) ->
        concatMap
          (\ u ->
            (if not (is_Var u)
              then concatMap
                     (\ rs ->
                       concatMap
                         (\ f ->
                           concatMap
                             (\ n ->
                               concatMap
                                 (\ i ->
                                   (if contains_var_term (Inl ())
 (ecap (get_args_impl b l) (nth rs i))
                                     then [(f, i)] else []))
                                 (upt zero_nat n))
                             [snd f])
                         [the (root u)])
                     [args u]
              else []))
          (supteq_list ra))
      (map (\ lr -> (lr, True)) r ++ map (\ st -> (st, False)) p));

mu_i_P_impl ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                        ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
mu_i_P_impl r ecap p =
  let {
    fis = innermost_repl_map_impl r ecap p;
    fs = remdups (map fst fis);
    mu = (\ f ->
           set (map_filter
                 (\ x -> (if let {
                               (g, _) = x;
                             } in g == f
                           then Just (snd x) else Nothing))
                 fis));
  } in (fs, (precompute_fun mu fs,
              ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'U', 'R',
                'M']));

mu_i_impl ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
mu_i_impl r ecap = mu_i_P_impl r ecap [];

default_fs ::
  forall a.
    (Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(a, Nat)];
default_fs r = funas_trs_list r;

full_empty ::
  forall a.
    (Eq a) => [(a, Nat)] -> ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
full_empty fs =
  let {
    fsa = filter (\ (_, n) -> not (equal_nat n zero_nat)) fs;
  } in (fsa, ((\ f ->
                (if membera fsa f then full_af f
                  else set_empty (of_phantom set_impl_nat))),
               ['f', 'u', 'l', 'l', ' ', 'A', 'F']));

get_fs_mu ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      Bool ->
                        Complexity_measure a [Prelude.Char] ->
                          ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
get_fs_mu r ecap inn (Runtime_Complexity c d) =
  (if inn && less_eq_set (inf_set (set c) (set (defined_list r))) bot_set
    then mu_i_impl r ecap else full_empty (remdups (c ++ d ++ default_fs r)));
get_fs_mu r ecap inn (Derivational_Complexity f) =
  full_empty (remdups (f ++ default_fs r));

is_Fsharp_term ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Set (a, Nat) -> Set (a, Nat) -> Term a b -> Bool;
is_Fsharp_term uu uv (Var uw) = False;
is_Fsharp_term fs fa (Fun f ts) =
  member (f, size_list ts) fs &&
    less_eq_set (set (concatMap funas_term_list ts)) fa;

funas_mctxt_list :: forall a b. Mctxt a b -> [(a, Nat)];
funas_mctxt_list (MFun f cs) =
  (f, size_list cs) : concatMap funas_mctxt_list cs;
funas_mctxt_list (MVar v) = [];
funas_mctxt_list MHole = [];

split_term ::
  forall a b. (Term a b -> Bool) -> Term a b -> (Mctxt a b, [Term a b]);
split_term p (Var x) = (if p (Var x) then (MHole, [Var x]) else (MVar x, []));
split_term p (Fun f ts) =
  (if p (Fun f ts) then (MHole, [Fun f ts])
    else let {
           us = map (split_term p) ts;
         } in (MFun f (map fst us), concatMap snd us));

split_DP ::
  forall a b.
    (Ceq a,
      Ccompare a) => Set (a, Nat) ->
                       (Term a b, Term a b) -> (Mctxt a b, [Term a b]);
split_DP fs =
  (\ r ->
    split_term (\ t -> not (is_Var t) && member (the (root t)) fs) (snd r));

check_DP_complexity ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Showa a,
      Showa b) => [(Term a b, Term a b)] ->
                    Complexity_measure a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        ([(Term a b, Term a b)],
                          ([(Term a b, Term a b)],
                            ([(a, Nat)], ([(a, Nat)], [(a, Nat)]))));
check_DP_complexity p (Derivational_Complexity uu) =
  Inl (shows_prec_list zero_nat
        ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'r', 'u', 'n', 't', 'i', 'm',
          'e', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']);
check_DP_complexity p (Runtime_Complexity c fs) =
  let {
    fsa = set fs;
    (rs, r) = partition (\ lr -> member (the (root (fst lr))) fsa) p;
    cs_ts = map (split_DP fsa) rs;
    cp = remdups (concatMap (funas_mctxt_list . fst) cs_ts);
    cpa = set cp;
    f = remdups
          (c ++ funas_trs_list r ++
                  concat
                    (concatMap (\ (fsb, _) -> map funas_term_list (args fsb))
                      rs) ++
                    concat
                      (concatMap
                        (\ (_, a) ->
                          concatMap (\ t -> map funas_term_list (args t)) a)
                        cs_ts));
    fa = set f;
  } in bindb (check
               (is_empty (inf_set fa fsa) &&
                 is_empty (inf_set fa cpa) && is_empty (inf_set fsa cpa))
               (shows_prec_list zero_nat
                 ['s', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'a', 'r', 'e', ' ',
                   'n', 'o', 't', ' ', 'd', 'i', 's', 'j', 'o', 'i', 'n', 't']))
         (\ _ ->
           bindb (check (all (\ lr -> is_Fsharp_term fsa fa (fst lr)) rs)
                   (shows_prec_list zero_nat
                     ['l', 'h', 's', 's', ' ', 'o', 'f', ' ', 'R', 'S', ' ',
                       'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 's', 'h', 'a',
                       'r', 'p', ' ', 't', 'e', 'r', 'm', 's']))
             (\ _ -> Inr (rs, (r, (cp, (fs, f))))));

get_fs_mu_DP ::
  forall a.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Key a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      Bool ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                          Complexity_measure a [Prelude.Char] ->
                            ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
get_fs_mu_DP r ecap inn s cm =
  let {
    (fs, (mu, info)) = get_fs_mu r ecap inn cm;
  } in (case check_DP_complexity r cm of {
         Inl _ -> (fs, (mu, info));
         Inr (rs, (_, (cp, (_, _)))) ->
           (if all (membera rs) s
             then (list_inter fs cp,
                    ((\ f ->
                       (if membera cp f then mu f
                         else set_empty (of_phantom set_impl_nat))),
                      info ++ [' ', 'w', 'i', 't', 'h', ' ', 'D', 'P', 's']))
             else (fs, (mu, info)));
       });

shows_prec_complexity_class ::
  Nat -> Complexity_class -> [Prelude.Char] -> [Prelude.Char];
shows_prec_complexity_class d c =
  (if equal_nat (degree c) zero_nat
    then shows_prec_list zero_nat ['O', '(', '1', ')']
    else (if equal_nat (degree c) one_nat
           then shows_prec_list zero_nat ['O', '(', 'n', ')']
           else shows_string ['O', '(', 'n', '^'] .
                  shows_prec_nat zero_nat (degree c) .
                    shows_prec_list zero_nat [')']));

is_ur_closed_af_impl_tp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Term b [Prelude.Char] -> Bool;
is_ur_closed_af_impl_tp_mv i d pi =
  let {
    ic = icap_impl_tp i d;
    qnf = is_QNFb i d;
    r = rulesd i d;
    urc = (\ s -> is_ur_closed_term_af_impl qnf (ic s) pi r);
  } in (\ u s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_term (\ x -> x) (\ a -> 'x' : a) t)));

extract_rt_C_D ::
  forall a b.
    Complexity_measure a b ->
      Sum ([Prelude.Char] -> [Prelude.Char]) ([(a, Nat)], [(a, Nat)]);
extract_rt_C_D (Runtime_Complexity c d) = Inr (c, d);
extract_rt_C_D (Derivational_Complexity v) =
  Inl (shows_prec_list zero_nat
        ['r', 'u', 'n', 't', 'i', 'm', 'e', ' ', 'c', 'o', 'm', 'p', 'l', 'e',
          'x', 'i', 't', 'y', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']);

cpx ::
  forall a b c.
    Redtriple_ext a b c ->
      Complexity_measure a b ->
        Complexity_class -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
cpx (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  cpx;

rule_shift_complexity_urm_ur_tt ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          Complexity_measure b [Prelude.Char] ->
                            Complexity_class ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_shift_complexity_urm_ur_tt i rp rdelete ur cm cc tp =
  let {
    rb = rulesd i tp;
    r = rc i tp;
    rw = rwc i tp;
    r2 = ceta_list_diff r rdelete;
    rremain = rw ++ r2;
    isnf = is_QNFb i tp;
    inn = nFQ_subset_NF_rulesb i tp;
  } in (case catch_errora
               (bindb
                 (catch_errora (check_subseteq rdelete rb)
                   (\ x ->
                     Inl (shows_string ['r', 'u', 'l', 'e', ' '] .
                           shows_rule (shows_prec zero_nat)
                             (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                             shows_prec_list zero_nat
                               [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b',
                                 'e', ' ', 'd', 'e', 'l', 'e', 't', 'e', 'd',
                                 ',', ' ', 'b', 'u', 't', ' ', 'd', 'o', 'e',
                                 's', ' ', 'n', 'o', 't', ' ', 'o', 'c', 'c',
                                 'u', 'r', ' ', 'i', 'n', ' ', 'p', 'r', 'o',
                                 'b', 'l', 'e', 'm'])))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       bindb (check (nFQ_subset_NF_rulesb i tp)
                               (shows_prec_list zero_nat
                                 ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't',
                                   ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e',
                                   'd']))
                         (\ _ ->
                           let {
                             (fs, (mu, info)) =
                               get_fs_mu_DP rb (icap_impl isnf rb) inn rdelete
                                 cm;
                             (_, (pi, _)) =
                               get_fs_mu_DP rb (icap_impl isnf rb) inn rremain
                                 cm;
                           } in bindb (extract_rt_C_D cm)
                                  (\ (cl, dl) ->
                                    let {
                                      c = set cl;
                                      d = set dl;
                                    } in bindb
   (check (null (list_inter cl (defined_list rb)))
     (shows_prec_list zero_nat
        ['c', 'o', 'n', 's', 't', 'r', 'u', 'c', 't', 'o', 'r', 's', ' '] .
       shows_prec_list zero_nat cl .
         shows_prec_list zero_nat
           [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ',
             'd', 'e', 'f', 'i', 'n', 'e', 'd']))
   (\ _ ->
     bindb (valid rp)
       (\ _ ->
         bindb (catch_errora
                 (forallM
                   (\ (l, ra) ->
                     check (not (member (the (root l)) d &&
                                  less_eq_set
                                    (foldr (sup_set . funas_term) (args l)
                                      bot_set)
                                    c))
                       (shows_rule (shows_prec zero_nat)
                          (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                          (l, ra) .
                         shows_prec_list zero_nat
                           [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e',
                             ' ', 'u', 's', 'a', 'b', 'l', 'e']))
                   (list_diff rb ur))
                 (\ x -> Inl (snd x)))
           (\ _ ->
             let {
               is_urc = is_ur_closed_af_impl_tp_mv i tp mu ur;
               pia = af_inter (af rp) pi;
               is_urc_pi = is_ur_closed_af_impl_tp_mv i tp pia ur;
             } in bindb (catch_errora
                          (forallM
                            (\ (l, ra) ->
                              check (is_urc (args l) ra &&
                                      is_urc_pi (args l) ra)
                                (shows_prec_list zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                     'i', 't', 'h', ' ', 'c', 'l', 'o', 's',
                                     'u', 'r', 'e', ' ', 'p', 'r', 'o', 'p',
                                     'e', 'r', 't', 'i', 'e', 's', ' ', 'o',
                                     'f', ' ', 'u', 's', 'a', 'b', 'l', 'e',
                                     ' ', 'r', 'u', 'l', 'e', ' '] .
                                  shows_rule (shows_prec zero_nat)
                                    (shows_prec_list zero_nat)
                                    [' ', '-', '>', ' '] (l, ra) .
                                    shows_prec_list zero_nat
                                      [':', ' ', 'r', 'h', 's', ' ', 'i', 's',
' ', 'n', 'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'u', 'n', 'd', 'e',
'r', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']))
                            ur)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (catch_errora
                              (catch_errora
                                (forallM
                                  (\ f ->
                                    check (subset (mu f) (mono_af rp f))
                                      (shows_string
 ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'm', 'o', 'n', 'o', 't', 'o',
   'n', 'i', 'c', 'i', 't', 'y', ':', ' ', 's', 't', 'r', 'i', 'c', 't', ' ',
   'o', 'r', 'd', 'e', 'r', ' ', 'f', 'o', 'r', ' '] .
shows_prec_prod zero_nat f .
  shows_string
    [' ', 'e', 'n', 's', 'u', 'r', 'e', 's', ' ', 'm', 'o', 'n', 'o', 't', 'o',
      'n', 'i', 'c', 'i', 't', 'y', ' ', 'i', 'n', ' ', 'p', 'o', 's', 'i', 't',
      'i', 'o', 'n', 's', ' '] .
    show_position_set f (mono_af rp f) .
      shows_string
        ['\n', 'b', 'u', 't', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'e',
          'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ' ', 'm', 'a', 'p', ' ',
          'i', 's', ' '] .
        show_position_set f (mu f)))
                                  fs)
                                (\ x -> Inl (snd x)))
                              (\ x ->
                                Inl (x . shows_string
   ['\n', 't', 'h', 'e', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'e', 'd', ' ', 'u',
     's', 'a', 'b', 'l', 'e', ' ', 'r', 'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e',
     'n', 't', ' ', 'm', 'a', 'p', ' ', '('] .
   shows_string info .
     shows_string [')', ' ', 'i', 's', '\n'] .
       shows_sep
         (\ f ->
           shows_prec_list zero_nat ['m', 'u', '('] .
             shows_prec_prod zero_nat f .
               shows_prec_list zero_nat [')', ' ', '=', ' '] .
                 show_position_set f (mu f))
         shows_nl fs .
         shows_prec_list zero_nat
           ['\n', 'a', 'n', 'd', ' ', 'm', 'u', '(', 'f', ')', ' ', '=', ' ',
             '{', '}', ' ', 'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ', 'o', 't',
             'h', 'e', 'r', ' ', 's', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'f'])))
                        (\ _ ->
                          bindb (catch_errora
                                  (catch_errora
                                    (forallM (s rp) (list_inter rdelete ur))
                                    (\ x -> Inl (snd x)))
                                  (\ x ->
                                    Inl (shows_string
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
     'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 's', 't', 'r', 'i', 'c', 't', ' ',
     'T', 'R', 'S', '\n'] .
  x)))
                            (\ _ ->
                              bindb (catch_errora
                                      (catch_errora
(forallM (ns rp) (list_inter rremain ur)) (\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
         'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 's',
         't', 'r', 'i', 'c', 't', ' ', 'T', 'R', 'S', '\n'] .
      x)))
                                (\ _ ->
                                  catch_errora (cpx rp cm cc)
                                    (\ x ->
                                      Inl
(shows_prec_list zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'e', 'n',
     's', 'u', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i',
     't', 'y', ' ', 'o', 'f', ' ', 'o', 'r', 'd', 'e', 'r', '\n'] .
  x))))))))))))))
               (\ x ->
                 Inl (shows_string
                        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'd',
                          'e', 'r', 'i', 'v', 'e', ' ', 't', 'h', 'e', ' ', 'i',
                          'n', 't', 'e', 'n', 'd', 'e', 'd', ' ', 'c', 'o', 'm',
                          'p', 'l', 'e', 'x', 'i', 't', 'y', ' '] .
                       shows_prec_complexity_class zero_nat cc .
                         shows_string
                           [' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ',
                             'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                             '\n'] .
                           desc rp .
                             shows_nl .
                               x . shows_string
                                     ['\n', 'w', 'i', 't', 'h', ' ', 'u', 's',
                                       'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                                       'e', 's', '\n'] .
                                     shows_trs (shows_prec zero_nat)
                                       (shows_prec_list zero_nat)
                                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
 's', 'y', 's', 't', 'e', 'm', ':']
                                       [' ', '-', '>', ' '] ur))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsb i tp) (qb i tp) r2 (list_union rw rdelete));
       });

inn_usable_rules_wf_tp ::
  forall a b.
    (Eq b,
      Key b) => Tp_ops_ext a b [Prelude.Char] () ->
                  a -> Bool ->
                         ([Term b [Prelude.Char]], Term b [Prelude.Char]) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])];
inn_usable_rules_wf_tp i d nfs =
  inn_usable_rules_wf (is_QNFb i d) (icap_impl_tp i d) (rulesd i d) nfs;

x_1_to_x_n :: Nat -> [[Prelude.Char]];
x_1_to_x_n = fresh_strings_list ['x'] one_nat [];

get_innermost_strict_repl_map_rc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                           Complexity_measure b c ->
                             ([(b, Nat)],
                               ((b, Nat) -> Set Nat, [Prelude.Char]));
get_innermost_strict_repl_map_rc i d s (Derivational_Complexity f) =
  full_empty (remdups (f ++ default_fs (rulesd i d)));
get_innermost_strict_repl_map_rc i da s (Runtime_Complexity c d) =
  let {
    r = rulesd i da;
  } in (if nFQ_subset_NF_rulesb i da &&
             less_eq_set (inf_set (set c) (set (defined_list r))) bot_set
         then let {
                isNF = is_QNFb i da;
                u = inn_usable_rules_wf_tp i da True;
                a = icap_impl_tp i da;
              } in mu_approx_impl r
                     (concatMap
                       (\ (f, n) ->
                         concatMap
                           (\ xs -> map (\ lr -> (xs, (Fun f xs, lr))) s)
                           [map Var (x_1_to_x_n n)])
                       d)
                     (\ ss t -> u (ss, t)) isNF a
         else full_empty (remdups (c ++ d ++ default_fs r)));

get_innermost_strict_repl_map_rc_DP ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                           Complexity_measure b [Prelude.Char] ->
                             ([(b, Nat)],
                               ((b, Nat) -> Set Nat, [Prelude.Char]));
get_innermost_strict_repl_map_rc_DP i d s t =
  let {
    (fs, (mu, info)) = get_innermost_strict_repl_map_rc i d s t;
  } in (case check_DP_complexity (rulesd i d) t of {
         Inl _ -> (fs, (mu, info));
         Inr (rs, (_, (cp, (_, _)))) ->
           (if all (membera rs) s
             then (list_inter fs cp,
                    ((\ f ->
                       (if membera cp f then mu f
                         else set_empty (of_phantom set_impl_nat))),
                      info ++ [' ', 'w', 'i', 't', 'h', ' ', 'D', 'P', 's']))
             else (fs, (mu, info)));
       });

rule_shift_complexity_urm_tt ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        Complexity_measure b [Prelude.Char] ->
                          Complexity_class ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_shift_complexity_urm_tt i rp rdelete cm cc tp =
  let {
    rb = rulesd i tp;
    r = rc i tp;
    rw = rwc i tp;
    r2 = ceta_list_diff r rdelete;
    _ = qb i tp;
  } in (case catch_errora
               (bindb
                 (catch_errora (check_subseteq rdelete rb)
                   (\ x ->
                     Inl (shows_string ['r', 'u', 'l', 'e', ' '] .
                           shows_rule (shows_prec zero_nat)
                             (shows_prec_list zero_nat) [' ', '-', '>', ' '] x .
                             shows_prec_list zero_nat
                               [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b',
                                 'e', ' ', 'd', 'e', 'l', 'e', 't', 'e', 'd',
                                 ',', ' ', 'b', 'u', 't', ' ', 'd', 'o', 'e',
                                 's', ' ', 'n', 'o', 't', ' ', 'o', 'c', 'c',
                                 'u', 'r', ' ', 'i', 'n', ' ', 'p', 'r', 'o',
                                 'b', 'l', 'e', 'm'])))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       let {
                         (fs, (mu, info)) =
                           get_innermost_strict_repl_map_rc_DP i tp rdelete cm;
                       } in bindb (valid rp)
                              (\ _ ->
                                bindb (catch_errora
(catch_errora
  (forallM
    (\ f ->
      check (subset (mu f) (mono_af rp f))
        (((((shows_prec_list zero_nat
               ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'm', 'o', 'n', 'o',
                 't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ':', ' ', 's', 't',
                 'r', 'i', 'c', 't', ' ', 'o', 'r', 'd', 'e', 'r', ' ', 'f',
                 'o', 'r', ' '] .
              shows_prec_prod zero_nat f) .
             shows_prec_list zero_nat
               [' ', 'e', 'n', 's', 'u', 'r', 'e', 's', ' ', 'm', 'o', 'n', 'o',
                 't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ' ', 'i', 'n', ' ',
                 'p', 'o', 's', 'i', 't', 'i', 'o', 'n', 's', ' ']) .
            show_position_set f (mono_af rp f)) .
           shows_prec_list zero_nat
             ['\n', 'b', 'u', 't', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r',
               'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ' ', 'm', 'a',
               'p', ' ', 'i', 's', ' ']) .
          show_position_set f (mu f)))
    fs)
  (\ x -> Inl (snd x)))
(\ x ->
  Inl (((((x . shows_prec_list zero_nat
                 ['\n', 't', 'h', 'e', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'e',
                   'd', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'e', 'p',
                   'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', ' ', 'm', 'a', 'p',
                   ' ', '(']) .
           shows_prec_list zero_nat info) .
          shows_prec_list zero_nat [')', ' ', 'i', 's', '\n']) .
         shows_sep
           (\ f ->
             ((shows_prec_list zero_nat ['m', 'u', '('] .
                shows_prec_prod zero_nat f) .
               shows_prec_list zero_nat [')', ' ', '=', ' ']) .
               show_position_set f (mu f))
           shows_nl fs) .
        shows_prec_list zero_nat
          ['\n', 'a', 'n', 'd', ' ', 'm', 'u', '(', 'f', ')', ' ', '=', ' ',
            '{', '}', ' ', 'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ', 'o', 't',
            'h', 'e', 'r', ' ', 's', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'f'])))
                                  (\ _ ->
                                    bindb (catch_errora
    (catch_errora (forallM (s rp) rdelete) (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 's', 't', 'r',
               'i', 'c', 't', ' ', 'T', 'R', 'S', '\n'] .
            x)))
                                      (\ _ ->
bindb (catch_errora
        (catch_errora (forallM (ns rp) (rw ++ r2)) (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                   ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'n',
                   'o', 'n', '-', 's', 't', 'r', 'i', 'c', 't', ' ', 'T', 'R',
                   'S', '\n'] .
                x)))
  (\ _ ->
    catch_errora (cpx rp cm cc)
      (\ x ->
        Inl (shows_prec_list zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
                 'e', 'n', 's', 'u', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'm',
                 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'o', 'f', ' ', 'o',
                 'r', 'd', 'e', 'r', '\n'] .
              x)))))))))
               (\ x ->
                 Inl (((((shows_prec_list zero_nat
                            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                              'd', 'e', 'r', 'i', 'v', 'e', ' ', 't', 'h', 'e',
                              ' ', 'i', 'n', 't', 'e', 'n', 'd', 'e', 'd', ' ',
                              'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                              ' '] .
                           shows_prec_complexity_class zero_nat cc) .
                          shows_prec_list zero_nat
                            [' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ',
                              'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                              '\n']) .
                         desc rp) .
                        shows_nl) .
                       x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsb i tp) (qb i tp) r2 (list_union rw rdelete));
       });

smart_rule_shift_complexity ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          Complexity_measure b [Prelude.Char] ->
                            Complexity_class ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
smart_rule_shift_complexity i rp rdelete (Just ur) cm cc tp =
  rule_shift_complexity_urm_ur_tt i rp rdelete ur cm cc tp;
smart_rule_shift_complexity i rp rdelete Nothing cm cc tp =
  rule_shift_complexity_urm_tt i rp rdelete cm cc tp;

usable_rules_complexity_innermost ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      Complexity_measure b [Prelude.Char] ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_complexity_innermost i nUr cm cc cp =
  catch_errora
    (let {
       s = rc i cp;
       w = rwc i cp;
       r = s ++ w;
     } in bindb (check (nFQ_subset_NF_rulesb i cp)
                  (shows_prec_list zero_nat
                    ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e',
                      'q', 'u', 'i', 'r', 'e', 'd']))
            (\ _ ->
              bindb (check_wf_trs r)
                (\ _ ->
                  bindb (extract_rt_C_D cm)
                    (\ (cl, dl) ->
                      let {
                        c = set cl;
                        d = set dl;
                        isnf = is_QNFb i cp;
                      } in bindb (check (null (list_inter cl (defined_list r)))
                                   (shows_prec_list zero_nat
                                      ['c', 'o', 'n', 's', 't', 'r', 'u', 'c',
't', 'o', 'r', 's', ' '] .
                                     shows_prec_list zero_nat cl .
                                       shows_prec_list zero_nat
 [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'd', 'e',
   'f', 'i', 'n', 'e', 'd']))
                             (\ _ ->
                               bindb (catch_errora (check_subseteq nUr r)
                                       (\ _ ->
 Inl (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
       shows_rules (shows_prec zero_nat) (shows_prec_list zero_nat)
         [' ', '-', '>', ' '] nUr .
         shows_prec_list zero_nat
           [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'o', 'c', 'c',
             'u', 'r', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'])))
                                 (\ _ ->
                                   let {
                                     ur = list_diff r nUr;
                                   } in bindb
  (catch_errora
    (forallM
      (\ (l, ra) ->
        check (not (member (the (root l)) d &&
                     less_eq_set (foldr (sup_set . funas_term) (args l) bot_set)
                       c))
          (shows_rule (shows_prec zero_nat) (shows_prec_list zero_nat)
             [' ', '-', '>', ' '] (l, ra) .
            shows_prec_list zero_nat
              [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e', ' ', 'u', 's',
                'a', 'b', 'l', 'e']))
      nUr)
    (\ x -> Inl (snd x)))
  (\ _ ->
    let {
      (_, (mu, _)) = get_fs_mu r (icap_impl isnf r) True cm;
      is_urc = is_ur_closed_af_impl_tp_mv i cp mu ur;
    } in bindb (catch_errora
                 (forallM
                   (\ (l, ra) ->
                     check (is_urc (args l) ra)
                       (shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                            't', 'h', ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e',
                            ' ', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'i', 'e',
                            's', ' ', 'o', 'f', ' ', 'u', 's', 'a', 'b', 'l',
                            'e', ' ', 'r', 'u', 'l', 'e', ' '] .
                         shows_rule (shows_prec zero_nat)
                           (shows_prec_list zero_nat) [' ', '-', '>', ' ']
                           (l, ra) .
                           shows_prec_list zero_nat
                             [':', ' ', 'r', 'h', 's', ' ', 'i', 's', ' ', 'n',
                               'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ',
                               'u', 'n', 'd', 'e', 'r', ' ', 'u', 's', 'a', 'b',
                               'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']))
                   ur)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             Inr (mkc i (nfsb i cp) (qb i cp) (list_diff s nUr)
                   (list_diff w nUr))))))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'r', 'e',
               's', 't', 'r', 'i', 'c', 't', 'i', 'n', 'g', ' ', 't', 'o', ' ',
               'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'u', 's', 'a',
               'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
            shows_nl . x));

get_signature_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
get_signature_of_cm (Derivational_Complexity f) = f;
get_signature_of_cm (Runtime_Complexity c d) = c ++ d;

usable_rules_complexity_usymbols ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Compare c, Eq c,
      Showa c) => Tp_ops_ext a b c () ->
                    [(Term b c, Term b c)] ->
                      Complexity_measure b c ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_complexity_usymbols i nUr cm cc cp =
  catch_errora
    (let {
       s = rc i cp;
       w = rwc i cp;
       r = s ++ w;
     } in bindb (catch_errora (check_subseteq nUr r)
                  (\ _ ->
                    Inl (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                          shows_rules (shows_prec zero_nat)
                            (shows_prec zero_nat) [' ', '-', '>', ' '] nUr .
                            shows_prec_list zero_nat
                              [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                                'o', 'c', 'c', 'u', 'r', ' ', 'i', 'n', ' ',
                                'p', 'r', 'o', 'b', 'l', 'e', 'm'])))
            (\ _ ->
              let {
                ur = list_diff r nUr;
                us = set (concatMap (funas_term_list . snd) ur ++
                           get_signature_of_cm cm);
                urs = set ur;
              } in bindb (check_varcond_subset ur)
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ lr ->
                                   check (if less_eq_set (funas_term (fst lr))
       us
   then member lr urs else True)
                                     (shows_prec_list zero_nat
['r', 'u', 'l', 'e', ' '] .
                                       shows_rule (shows_prec zero_nat)
 (shows_prec zero_nat) [' ', '-', '>', ' '] lr .
 shows_prec_list zero_nat
   [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e', ' ', 'u', 's', 'a', 'b',
     'l', 'e']))
                                 r)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           Inr (mkc i (nfsb i cp) (qb i cp) (list_diff s nUr)
                                 (list_diff w nUr))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'r', 'e',
               's', 't', 'r', 'i', 'c', 't', 'i', 'n', 'g', ' ', 't', 'o', ' ',
               'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
               'w', '.', 'r', '.', 't', '.', ' ', 'u', 's', 'a', 'b', 'l', 'e',
               ' ', 's', 'y', 'm', 'b', 'o', 'l', 's'] .
            shows_nl . x));

usable_rules_complexity ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      Complexity_measure b [Prelude.Char] ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_complexity i nUr cm cc cp =
  (case usable_rules_complexity_usymbols i nUr cm cc cp of {
    Inl e ->
      (case usable_rules_complexity_innermost i nUr cm cc cp of {
        Inl ea ->
          Inl (shows_prec_list zero_nat
                 ['n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'o', 'f', ' ', 't',
                   'h', 'e', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u',
                   'l', 'e', 's', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                   'r', 's', ' ', 'i', 's', ' ', 'a', 'p', 'p', 'l', 'i', 'c',
                   'a', 'b', 'l', 'e', ':', ' '] .
                shows_nl .
                  shows_prec_list zero_nat
                    ['t', 'h', 'e', ' ', 'o', 'n', 'e', ' ', 'v', 'i', 'a', ' ',
                      'u', 's', 'a', 'b', 'l', 'e', ' ', 's', 'y', 'm', 'b',
                      'o', 'l', 's', ' ', 'c', 'o', 'm', 'p', 'l', 'a', 'i',
                      'n', 's', ' ', 'a', 's', ' ', 'f', 'o', 'l', 'l', 'o',
                      'w', 's'] .
                    shows_nl .
                      e . shows_nl .
                            shows_nl .
                              shows_prec_list zero_nat
                                ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'o',
                                  'n', 'e', ' ', 'v', 'i', 'a', ' ', 'i', 'c',
                                  'a', 'p', ' ', 'a', 'n', 'd', ' ', 'i', 'n',
                                  'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 's',
                                  'a', 'y', 's', ' '] .
                                shows_nl . ea);
        Inr a -> Inr a;
      });
    Inr a -> Inr a;
  });

split_proc_complexity ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Tp_ops_ext a b c () ->
                    [(Term b c, Term b c)] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) (a, a);
split_proc_complexity i s1 cp =
  catch_errora
    (let {
       s = rc i cp;
       w = rwc i cp;
       nfs = nfsb i cp;
       q = qb i cp;
     } in bindb (catch_errora (check_subseteq s1 s)
                  (\ x ->
                    Inl (shows_prec_list zero_nat ['r', 'u', 'l', 'e', ' '] .
                          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                            [' ', '-', '>', ' '] x .
                            shows_prec_list zero_nat
                              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ',
                                's', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u',
                                'l', 'e'])))
            (\ _ ->
              let {
                s2 = list_diff s s1;
              } in Inr (mkc i nfs q s1 (s2 ++ w), mkc i nfs q s2 (s1 ++ w))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'p',
               'l', 'i', 't', 't', 'i', 'n', 'g', ' ', 'c', 'o', 'm', 'p', 'l',
               'e', 'x', 'i', 't', 'y', ' ', 'p', 'r', 'o', 'b', 'l', 'e',
               'm'] .
            shows_nl . x));

shows_complexity_measure ::
  forall a b.
    (Linorder a,
      Showa a) => Complexity_measure a b -> [Prelude.Char] -> [Prelude.Char];
shows_complexity_measure (Runtime_Complexity c d) =
  shows_prec_list zero_nat
    ['b', 'a', 's', 'i', 'c', ' ', 't', 'e', 'r', 'm', 's', ' ', 'f', '(', 'c',
      '1', ',', '.', '.', ',', 'c', 'n', ')', ' ', 'w', 'h', 'e', 'r', 'e', ' ',
      'f', ' ', 'i', 'n', ' '] .
    shows_nl .
      shows_prec_list zero_nat (sort_key (\ x -> x) d) .
        shows_nl .
          shows_prec_list zero_nat
            [' ', 'a', 'n', 'd', ' ', 'c', 'i', ' ', 'i', 's', ' ', 't', 'e',
              'r', 'm', ' ', 'o', 'v', 'e', 'r', ' ', 's', 'i', 'g', 'n', 'a',
              't', 'u', 'r', 'e', ' '] .
            shows_nl .
              shows_prec_list zero_nat (sort_key (\ x -> x) c) . shows_nl;
shows_complexity_measure (Derivational_Complexity f) =
  shows_prec_list zero_nat
    ['a', 'l', 'l', ' ', 't', 'e', 'r', 'm', 's', ' ', 'o', 'v', 'e', 'r', ' ',
      's', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', ' '] .
    shows_nl . shows_prec_list zero_nat (sort_key (\ x -> x) f) . shows_nl;

shows_complexityLL ::
  forall a b c.
    (Key a, Showa a, Key b, Showa b, Key c,
      Showa c) => ([Term (Lab a b) c],
                    ([(Term (Lab a b) c, Term (Lab a b) c)],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        (Complexity_measure (Lab a b) c, Complexity_class)))) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_complexityLL (q, (s, (w, (cm, cc)))) =
  shows_prec_list zero_nat
    ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's'] .
    shows_nl .
      shows_rules (shows_prec_lab zero_nat) (shows_prec zero_nat)
        [' ', '-', '>', ' '] (sort_key (\ x -> x) s) .
        shows_nl .
          shows_nl .
            shows_prec_list zero_nat
              ['w', 'e', 'a', 'k', ' ', 'r', 'u', 'l', 'e', 's'] .
              shows_nl .
                shows_rules (shows_prec_lab zero_nat) (shows_prec zero_nat)
                  [' ', '-', '>', ' '] (sort_key (\ x -> x) w) .
                  shows_nl .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'l',
                          'h', 's', 's', ' ', '(', 'Q', ')'] .
                        shows_nl .
                          shows_lines (sort_key (\ x -> x) q) .
                            shows_nl .
                              shows_nl .
                                shows_prec_list zero_nat
                                  ['s', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ',
                                    't', 'e', 'r', 'm', 's', ':', ' '] .
                                  shows_complexity_measure cm .
                                    shows_nl .
                                      shows_prec_list zero_nat
['i', 'n', 't', 'e', 'n', 'd', 'e', 'd', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x',
  'i', 't', 'y', ':', ' '] .
shows_prec_complexity_class zero_nat cc . shows_nl;

check_terms_of_main ::
  forall a b.
    (Eq a,
      Showa a) => Complexity_measure a b ->
                    Complexity_measure a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_terms_of_main (Derivational_Complexity f) (Derivational_Complexity g) =
  catch_errora (check_subseteq f g)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'n', 's', 'i', 'd', 'e', 'r', ' ', 'o', 'f', ' ', 's',
               'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec_prod zero_nat x));
check_terms_of_main (Runtime_Complexity f h) (Derivational_Complexity g) =
  catch_errora (check_subseteq (f ++ h) g)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'n', 's', 'i', 'd', 'e', 'r', ' ', 'o', 'f', ' ', 's',
               'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec_prod zero_nat x));
check_terms_of_main (Runtime_Complexity f h) (Runtime_Complexity f1 h1) =
  bindb (catch_errora (check_subseteq f f1)
          (\ x ->
            Inl (shows_prec_list zero_nat
                   ['c', 'o', 'n', 's', 'i', 'd', 'e', 'r', ' ', 's', 'y', 'm',
                     'b', 'o', 'l', ' '] .
                  shows_prec_prod zero_nat x)))
    (\ _ ->
      catch_errora (check_subseteq h h1)
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['c', 'o', 'n', 's', 'i', 'd', 'e', 'r', ' ', 's', 'y', 'm',
                   'b', 'o', 'l', ' '] .
                shows_prec_prod zero_nat x)));
check_terms_of_main (Derivational_Complexity g) (Runtime_Complexity f1 h1) =
  Inl (shows_prec_list zero_nat
        ['m', 'i', 'x', 'i', 'n', 'g', ' ', 'r', 'u', 'n', 't', 'i', 'm', 'e',
          ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'a', 'n',
          'd', ' ', 'd', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l',
          ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']);

check_terms_of_nat ::
  forall a b.
    (Eq a,
      Showa a) => Complexity_measure a b ->
                    Complexity_measure a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_terms_of_nat cm1 cm2 =
  catch_errora (check_terms_of_main cm1 cm2)
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'm', 'p', 'a', 'r', 'i',
               'n', 'g', ' ', 's', 't', 'a', 'r', 't', ' ', 't', 'e', 'r', 'm',
               's'] .
            shows_nl . x));

check_complexity_subsumes ::
  forall a b c.
    (Eq a, Key a, Showa a, Eq b, Key b, Showa b, Ccompare c, Eq c, Key c,
      Mapping_impl c,
      Showa c) => ([Term (Lab a b) c],
                    ([(Term (Lab a b) c, Term (Lab a b) c)],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        (Complexity_measure (Lab a b) c, Complexity_class)))) ->
                    ([Term (Lab a b) c],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        ([(Term (Lab a b) c, Term (Lab a b) c)],
                          (Complexity_measure (Lab a b) c,
                            Complexity_class)))) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_complexity_subsumes (q1, (s1, (w1, (cm1, cc1))))
  (q2, (s2, (w2, (cm2, cc2)))) =
  catch_errora
    (bindb
      (catch_errora (check_subseteq s2 s1)
        (\ x ->
          Inl (shows_prec_list zero_nat
                 ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', ' '] .
                shows_rule (shows_prec_lab zero_nat) (shows_prec zero_nat)
                  [' ', '-', '>', ' '] x .
                  shows_prec_list zero_nat
                    [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
      (\ _ ->
        bindb (catch_errora (check_subseteq w2 w1)
                (\ x ->
                  Inl (shows_prec_list zero_nat
                         ['w', 'e', 'a', 'k', ' ', 'r', 'u', 'l', 'e', ' '] .
                        shows_rule (shows_prec_lab zero_nat)
                          (shows_prec zero_nat) [' ', '-', '>', ' '] x .
                          shows_prec_list zero_nat
                            [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                              'g'])))
          (\ _ ->
            bindb (catch_errora (check_NF_terms_subset (is_NF_terms q2) q1)
                    (\ x ->
                      Inl (shows_prec_list zero_nat
                             ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f', 'f',
                               'e', 'r', 's', ' ', 'd', 'u', 'e', ' ', 't', 'o',
                               ' ', 't', 'e', 'r', 'm', ' '] .
                            shows_prec_term zero_nat x)))
              (\ _ ->
                bindb (check (less_eq_complexity_class cc1 cc2)
                        (shows_prec_list zero_nat
                          ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                            ' ', 'c', 'l', 'a', 's', 's', 'e', 's', ' ', 'd',
                            'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c',
                            'h']))
                  (\ _ -> check_terms_of_nat cm2 cm1)))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
               'u', 'r', 'e', ' ', 't', 'h', 'a', 't', ' ', 'a', 's', 's', 'u',
               'm', 'p', 't', 'i', 'o', 'n', ' ', 'm', 'a', 't', 'c', 'h', 'e',
               's', ' ', 'c', 'u', 'r', 'r', 'e', 'n', 't', ' ', 'c', 'o', 'm',
               'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'p', 'r', 'o', 'b', 'l',
               'e', 'm'] .
            shows_nl .
              x . shows_nl .
                    shows_nl .
                      shows_prec_list zero_nat
                        ['a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', ' ',
                          'i', 's', ' '] .
                        shows_nl .
                          shows_complexityLL (q1, (s1, (w1, (cm1, cc1)))) .
                            shows_nl .
                              shows_nl .
                                shows_prec_list zero_nat
                                  ['c', 'u', 'r', 'r', 'e', 'n', 't', ' ', 'p',
                                    'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 's',
                                    ' '] .
                                  shows_nl .
                                    shows_complexityLL
                                      (q2, (s2, (w2, (cm2, cc2))))));

check_tup :: forall a b. (Ceq a, Ccompare a) => Set a -> Term a b -> Bool;
check_tup t (Var x) = False;
check_tup t (Fun f ts) = member f t;

dPos_impl ::
  forall a b.
    (Ceq a,
      Ccompare a) => (a -> a) -> Set (a, Nat) -> Term a b -> [(Pos, Term a b)];
dPos_impl shp d (Var x) = [];
dPos_impl shp d (Fun f ts) =
  let {
    n = size_list ts;
  } in (if member (f, n) d then (\ a -> (Empty, Fun (shp f) ts) : a) else id)
         (concatMap
           (\ (i, ti) -> map (\ (p, a) -> (PCons i p, a)) (dPos_impl shp d ti))
           (zip (upt zero_nat n) ts));

check_rule_dt ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Showa a, Eq b,
      Showa b) => (a -> a) ->
                    Set (a, Nat) ->
                      Set a ->
                        ((Term a b, Term a b), (Term a b, Term a b)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_dt shp d ds =
  (\ (a, b) ->
    let {
      (l, r) = a;
    } in (\ (dl, dr) ->
           catch_errora
             (let {
                sl = sharp_term shp l;
              } in bindb (check (equal_term sl dl)
                           (shows_string
                              ['w', 'r', 'o', 'n', 'g', ' ', 'l', 'h', 's', ',',
                                ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
                                ' '] .
                             shows_prec_term zero_nat sl .
                               shows_string
                                 [' ', 'b', 'u', 't', ' ', 'g', 'o', 't', ' '] .
                                 shows_prec_term zero_nat dl))
                     (\ _ ->
                       let {
                         pts = dPos_impl shp d r;
                         spts = map snd pts;
                         (_, dts) = split_term (check_tup ds) dr;
                       } in check (equal_multiset (mset dts) (mset spts))
                              (shows_prec_list zero_nat
                                ['m', 'u', 'l', 't', 'i', 's', 'e', 't', ' ',
                                  'o', 'f', ' ', 's', 'u', 'b', 't', 'e', 'r',
                                  'm', 's', ' ', 'w', 'i', 't', 'h', ' ', 'd',
                                  'e', 'f', 'i', 'n', 'e', 'd', ' ', 'r', 'o',
                                  'o', 't', 's', ' ', 'd', 'i', 'f', 'f', 'e',
                                  'r', 's'])))
             (\ x ->
               Inl (shows_string
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e',
                        'n', 's', 'u', 'r', 'e', ' ', 't', 'h', 'a', 't', ' '] .
                     shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                       [' ', '-', '>', ' '] (dl, dr) .
                       shows_string
                         [' ', 'i', 's', ' ', 'a', ' ', 'v', 'a', 'l', 'i', 'd',
                           ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c',
                           'y', ' ', 't', 'u', 'p', 'l', 'e', ' ', 'f', 'o',
                           'r', ' '] .
                         shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                           [' ', '-', '>', ' '] (l, r) .
                           shows_nl . x)))
      b);

dt_transformation ::
  forall a b c.
    (Card_UNIV a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Showa a,
      Ccompare c, Eq c, Mapping_impl c,
      Showa c) => (a -> a) ->
                    Tp_ops_ext b a c () ->
                      Dt_transformation_info a c ->
                        Complexity_measure a c ->
                          Complexity_class ->
                            b -> Sum ([Prelude.Char] -> [Prelude.Char])
                                   (Complexity_measure a c, b);
dt_transformation shp i info cm cc cp =
  catch_errora
    (let {
       (DT_Transformation_Info s_DT_s w_DT_w q) = info;
     } in (case cm of {
            Derivational_Complexity _ ->
              Inl (shows_prec_list zero_nat
                    ['o', 'n', 'l', 'y', ' ', 'r', 'u', 'n', 't', 'i', 'm', 'e',
                      ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                      ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ',
                      'f', 'o', 'r', ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e',
                      'n', 'c', 'y', ' ', 't', 'u', 'p', 'l', 'e', 's']);
            Runtime_Complexity c d ->
              let {
                s = rc i cp;
                w = rwc i cp;
                sa = map fst s_DT_s;
                wa = map fst w_DT_w;
                r = sa ++ wa;
                dd = defined_list r;
                dda = set d;
              } in bindb (catch_errora
                           (forallM
                             (\ lr ->
                               check (any (eq_rule_mod_vars lr) sa)
                                 (shows_prec_list zero_nat
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 'f', 'i', 'n', 'd', ' ', 'D',
                                      'T', ' ', 'f', 'o', 'r', ' ', 's', 't',
                                      'r', 'i', 'c', 't', ' ', 'r', 'u', 'l',
                                      'e', ' '] .
                                   shows_prec_prod zero_nat lr))
                             s)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ lr ->
                                   check (any (eq_rule_mod_vars lr) wa)
                                     (shows_prec_list zero_nat
['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 'D',
  'T', ' ', 'f', 'o', 'r', ' ', 'w', 'e', 'a', 'k', ' ', 'r', 'u', 'l', 'e',
  ' '] .
                                       shows_prec_prod zero_nat lr))
                                 w)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ f ->
                                       check (member f dda)
 (shows_prec_list zero_nat
    ['d', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l',
      ' '] .
   shows_prec_prod zero_nat f .
     shows_prec_list zero_nat
       [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'o', 'c', 'c', 'u',
         'r', ' ', 'i', 'n', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's',
         'y', 'm', 'b', 'o', 'l', 's', ' ', 'f', 'r', 'o', 'm', ' ', 'R', 'C']))
                                     dd)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               let {
                                 dTs = map snd s_DT_s;
                                 dTw = map snd w_DT_w;
                                 da = set dd;
                                 shpf = (\ (f, a) -> (shp f, a));
                                 ds = image shpf da;
                                 ddd = image (shp . fst) da;
                                 f = funas_trs_list r ++ c ++ d;
                                 fs = set f;
                               } in bindb (catch_errora
    (forallM
      (\ qa ->
        check (not (is_Var qa) && not (member (the (root qa)) fs))
          (shows_prec_list zero_nat
             ['n', 'e', 'w', ' ', 'Q', '-', 't', 'e', 'r', 'm', ' '] .
            shows_prec_term zero_nat qa .
              shows_prec_list zero_nat
                [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
      q)
    (\ x -> Inl (snd x)))
                                      (\ _ ->
bindb (check_wf_trs r)
  (\ _ ->
    bindb (catch_errora (check_NF_terms_subset (is_QNFb i cp) (map fst r))
            (\ _ ->
              Inl (shows_prec_list zero_nat
                    ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e',
                      'q', 'u', 'i', 'r', 'e', 'd'])))
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ fa ->
                    check (not (member fa ds))
                      (shows_prec_prod zero_nat fa .
                        shows_prec_list zero_nat
                          [' ', 'a', 's', ' ', 's', 'h', 'a', 'r', 'p', 'e',
                            'd', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ', 'i',
                            's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's',
                            'h']))
                  f)
                (\ x -> Inl (snd x)))
          (\ _ ->
            bindb (check (is_empty (inf_set (set c) da))
                    (shows_prec_list zero_nat
                      ['c', 'o', 'n', 's', 't', 'r', 'u', 'c', 't', 'o', 'r',
                        's', ' ', 'o', 'f', ' ', 'R', 'C', ' ', 'a', 'n', 'd',
                        ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 's', 'y',
                        'm', 'b', 'o', 'l', 's', ' ', 'o', 'f', ' ', 'T', 'R',
                        'S', 's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ',
                        'd', 'i', 's', 'j', 'o', 'i', 'n', 't']))
              (\ _ ->
                bindb (catch_errora (forallM (check_rule_dt shp da ddd) s_DT_s)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    bindb (catch_errora
                            (forallM (check_rule_dt shp da ddd) w_DT_w)
                            (\ x -> Inl (snd x)))
                      (\ _ ->
                        Inr (Runtime_Complexity c (map shpf d),
                              mkc i False (qb i cp ++ q) dTs
                                (r ++ dTw))))))))))));
          }))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'w',
               'i', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't', 'o', ' ', 'd', 'e',
               'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 't', 'u', 'p', 'l',
               'e', 's'] .
            shows_nl . x));

shows_mctxt ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Mctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_mctxt fun var MHole = shows_string ['[', ']'];
shows_mctxt fun var (MVar x) = var x;
shows_mctxt fun var (MFun f cs) =
  fun f .
    shows_list_gen id [] ['('] [',', ' '] [')'] (map (shows_mctxt fun var) cs);

shows_prec_mctxt ::
  forall a b.
    (Showa a, Showa b) => Nat -> Mctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_mctxt p c =
  shows_mctxt (shows_prec zero_nat) (shows_prec zero_nat) c;

ground_mctxt :: forall a b. Mctxt a b -> Bool;
ground_mctxt (MVar uu) = False;
ground_mctxt MHole = True;
ground_mctxt (MFun f cs) = all ground_mctxt cs;

funas_mctxt ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Mctxt a b -> Set (a, Nat);
funas_mctxt (MFun f cs) =
  sup_set (inserta (f, size_list cs) bot_set)
    (sup_seta (image funas_mctxt (set cs)));
funas_mctxt (MVar v) = bot_set;
funas_mctxt MHole = bot_set;

is_compound_context ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Set (a, Nat) -> Mctxt a b -> Bool;
is_compound_context cComp c =
  ground_mctxt c && less_eq_set (funas_mctxt c) cComp;

if_Fun_in_set ::
  forall a b. (Ceq a, Ccompare a) => Set (a, Nat) -> Term a b -> Bool;
if_Fun_in_set f = (\ t -> is_Var t || member (the (root t)) f);

uncap_till :: forall a b. (Term a b -> Bool) -> Term a b -> [Term a b];
uncap_till p (Var x) = (if p (Var x) then [Var x] else []);
uncap_till p (Fun f ts) =
  (if p (Fun f ts) then [Fun f ts] else concatMap (uncap_till p) ts);

check_rule_wdp ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showa a, Compare b, Eq b,
      Showa b) => (a -> a) ->
                    Set (a, Nat) ->
                      ((Term a b, Term a b), (Term a b, Term a b)) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_wdp shp cComp =
  (\ (a, b) ->
    let {
      (l, r) = a;
    } in (\ (p, q) ->
           catch_errora
             (let {
                la = sharp_term shp l;
              } in bindb (check (equal_term la p)
                           (shows_string
                              ['w', 'r', 'o', 'n', 'g', ' ', 'l', 'h', 's', ',',
                                ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
                                ' '] .
                             shows_prec_term zero_nat la .
                               shows_string
                                 [' ', 'b', 'u', 't', ' ', 'g', 'o', 't', ' '] .
                                 shows_prec_term zero_nat p))
                     (\ _ ->
                       let {
                         us = uncap_till (if_Fun_in_set (uminus_set cComp)) r;
                         (c, usa) =
                           split_term (if_Fun_in_set (uminus_set cComp)) q;
                       } in bindb (check (map (sharp_term shp) us == usa)
                                    (shows_prec_list zero_nat
                                      ['l', 'i', 's', 't', 's', ' ', 'o', 'f',
' ', 'm', 'a', 'x', 'i', 'm', 'a', 'l', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm',
's', ' ', 'w', 'i', 't', 'h', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'r',
'o', 'o', 't', ' ', 'd', 'i', 'f', 'f', 'e', 'r']))
                              (\ _ ->
                                check (is_compound_context cComp c)
                                  (shows_prec_mctxt zero_nat c .
                                    shows_string
                                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
'a', ' ', 'p', 'r', 'o', 'p', 'e', 'r', ' ', 'c', 'o', 'm', 'p', 'o', 'u', 'n',
'd', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', ' ', 'o', 'f', ' '] .
                                      shows_prec_term zero_nat q))))
             (\ x ->
               Inl (shows_string
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e',
                        'n', 's', 'u', 'r', 'e', ' ', 't', 'h', 'a', 't', ' '] .
                     shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                       [' ', '-', '>', ' '] (p, q) .
                       shows_string
                         [' ', 'i', 's', ' ', 'a', ' ', 'v', 'a', 'l', 'i', 'd',
                           ' ', 'w', 'e', 'a', 'k', ' ', 'd', 'e', 'p', 'e',
                           'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p', 'a', 'i',
                           'r', ' ', 'f', 'o', 'r', ' '] .
                         shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                           [' ', '-', '>', ' '] (l, r) .
                           shows_nl . x)))
      b);

check_wdp_trans ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showa a, Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showa c) => (a -> a) ->
                    Tp_ops_ext b a c () ->
                      Wdp_trans_info a c ->
                        Complexity_measure a c ->
                          Complexity_class ->
                            b -> Sum ([Prelude.Char] -> [Prelude.Char])
                                   (Complexity_measure a c, b);
check_wdp_trans shp i info cm cc cp =
  catch_errora
    (let {
       (WDP_Trans_Info compa s_wdps w_wdps q) = info;
     } in (case cm of {
            Derivational_Complexity _ ->
              Inl (shows_prec_list zero_nat
                    ['o', 'n', 'l', 'y', ' ', 'r', 'u', 'n', 't', 'i', 'm', 'e',
                      ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                      ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ',
                      'f', 'o', 'r', ' ', 'w', 'e', 'a', 'k', ' ', 'd', 'e',
                      'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p', 'a',
                      'i', 'r', 's']);
            Runtime_Complexity c d ->
              let {
                s = rc i cp;
                w = rwc i cp;
                sa = map fst s_wdps;
                wa = map fst w_wdps;
                r = sa ++ wa;
                fs = funas_trs_list r;
                ds = defined_list r;
              } in bindb (catch_errora
                           (forallM
                             (\ ra ->
                               check (any (eq_rule_mod_vars ra) sa)
                                 (shows_prec_list zero_nat
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 'f', 'i', 'n', 'd', ' ', 'w',
                                      'e', 'a', 'k', ' ', 'd', 'e', 'p', 'e',
                                      'n', 'd', 'e', 'n', 'c', 'y', ' ', 'p',
                                      'a', 'i', 'r', ' ', 'f', 'o', 'r', ' ',
                                      's', 't', 'r', 'i', 'c', 't', ' ', 'r',
                                      'u', 'l', 'e', ' '] .
                                   shows_prec_prod zero_nat ra))
                             s)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ ra ->
                                   check (any (eq_rule_mod_vars ra) wa)
                                     (shows_prec_list zero_nat
['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 'w',
  'e', 'a', 'k', ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ',
  'p', 'a', 'i', 'r', ' ', 'f', 'o', 'r', ' ', 'w', 'e', 'a', 'k', ' ', 'r',
  'u', 'l', 'e', ' '] .
                                       shows_prec_prod zero_nat ra))
                                 w)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           let {
                             wDP_S = map snd s_wdps;
                             wDP_W = map snd w_wdps;
                             shpf = (\ (f, a) -> (shp f, a));
                             f = fs ++ c ++ d;
                             f_sharps = map shpf f;
                             _ = image (\ (fa, a) -> (shp fa, a)) (set f);
                             cComp =
                               sup_set
                                 (minus_set
                                   (minus_set (set fs) (set (defined_list r)))
                                   (set d))
                                 compa;
                           } in bindb (catch_errora
(forallM
  (\ qa ->
    check (not (is_Var qa) && not (membera f (the (root qa))))
      (shows_prec_list zero_nat
         ['n', 'e', 'w', ' ', 'Q', '-', 't', 'e', 'r', 'm', ' '] .
        shows_prec_term zero_nat qa .
          shows_prec_list zero_nat
            [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
  q)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    bindb (check_wf_trs r)
                                      (\ _ ->
bindb (catch_errora
        (forallM
          (\ fa ->
            check (not (member fa cComp))
              (shows_prec_prod zero_nat fa .
                shows_prec_list zero_nat
                  [' ', 'c', 'l', 'a', 's', 'h', 'e', 's', ' ', 'w', 'i', 't',
                    'h', ' ', 's', 'h', 'a', 'r', 'p', ' ', 's', 'y', 'm', 'b',
                    'o', 'l', 's']))
          f_sharps)
        (\ x -> Inl (snd x)))
  (\ _ ->
    bindb (catch_errora
            (forallM
              (\ fa ->
                check (not (member fa cComp))
                  (shows_prec_prod zero_nat fa .
                    shows_prec_list zero_nat
                      [' ', 'c', 'l', 'a', 's', 'h', 'e', 's', ' ', 'w', 'i',
                        't', 'h', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ',
                        's', 'y', 'm', 'b', 'o', 'l', 's', ' ', 'o', 'f', ' ',
                        'R', 'C']))
              d)
            (\ x -> Inl (snd x)))
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ fa ->
                    check (not (member fa cComp))
                      (shows_prec_prod zero_nat fa .
                        shows_prec_list zero_nat
                          [' ', 'c', 'l', 'a', 's', 'h', 'e', 's', ' ', 'w',
                            'i', 't', 'h', ' ', 'd', 'e', 'f', 'i', 'n', 'e',
                            'd', ' ', 's', 'y', 'm', 'b', 'o', 'l', 's']))
                  ds)
                (\ x -> Inl (snd x)))
          (\ _ ->
            bindb (catch_errora (forallM (check_rule_wdp shp cComp) s_wdps)
                    (\ x -> Inl (snd x)))
              (\ _ ->
                bindb (catch_errora (forallM (check_rule_wdp shp cComp) w_wdps)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    Inr (Runtime_Complexity c (map shpf d),
                          mkc i (nfsb i cp) (qb i cp ++ q) (wDP_S ++ sa)
                            (wDP_W ++ wa)))))))))));
          }))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'w',
               'i', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't', 'o', ' ', 'w', 'e',
               'a', 'k', ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y',
               ' ', 'p', 'a', 'i', 'r', 's'] .
            shows_nl . x));

equal_boundstype :: Boundstype -> Boundstype -> Bool;
equal_boundstype Roof Match = False;
equal_boundstype Match Roof = False;
equal_boundstype Match Match = True;
equal_boundstype Roof Roof = True;

boundstype :: forall a b. Bounds_info a b -> Boundstype;
boundstype (Bounds_Info x1 x2 x3 x4 x5) = x1;

stackable_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
stackable_of_cm (Derivational_Complexity f) = f;
stackable_of_cm (Runtime_Complexity c d) = c;

bounds_complexity_rel ::
  forall a b c d.
    (Eq b, Key b, Showa b, Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c,
      Eq c, Key c, Set_impl c, Showa c, Card_UNIV d, Cenum d, Ceq d, Ccompare d,
      Compare_order d, Eq d, Set_impl d,
      Showa d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      [(Term b c, Term b c)] ->
                        Complexity_measure b c ->
                          Complexity_class ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
bounds_complexity_rel i info rdelete cm cc tp =
  catch_errora
    (let {
       r = rc i tp;
       rw = rwc i tp;
       r2 = ceta_list_diff r rdelete;
     } in bindb (catch_errora (check_subseteq rdelete (rulesd i tp))
                  (\ x ->
                    Inl (shows_prec_list zero_nat
                           ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                             'f', 'i', 'n', 'd', ' ', 'r', 'u', 'l', 'e', ' '] .
                          shows_rule (shows_prec zero_nat) (shows_prec zero_nat)
                            [' ', '-', '>', ' '] x .
                            shows_prec_list zero_nat
                              [' ', 'i', 'n', ' ', 'c', 'u', 'r', 'r', 'e', 'n',
                                't', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x',
                                'i', 't', 'y', ' ', 'p', 'r', 'o', 'b', 'l',
                                'e', 'm'])))
            (\ _ ->
              bindb (check (less_eq_complexity_class (Comp_Poly one_nat) cc)
                      (shows_prec_list zero_nat
                        ['c', 'a', 'n', ' ', 'o', 'n', 'l', 'y', ' ', 'e', 'n',
                          's', 'u', 'r', 'e', ' ', 'l', 'i', 'n', 'e', 'a', 'r',
                          ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
                          'y']))
                (\ _ ->
                  bindb (check (equal_boundstype (boundstype info) Match)
                          (shows_prec_list zero_nat
                            ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                              ' ', 'a', 'n', 'a', 'l', 'y', 's', 'i', 's', ' ',
                              'r', 'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'b',
                              'o', 'u', 'n', 'd', 's', 't', 'y', 'p', 'e', ' ',
                              'm', 'a', 't', 'c', 'h']))
                    (\ _ ->
                      let {
                        _ = rulesd i tp;
                      } in bindb (check_bounds_generic info rdelete (rw ++ r2)
                                   (stackable_of_cm cm) (roots_of_cm cm))
                             (\ _ ->
                               Inr (mkc i (nfsb i tp) (qb i tp) r2
                                     (list_union rw rdelete)))))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'e', 'n',
               's', 'u', 'r', 'i', 'n', 'g', ' ', 'm', 'a', 't', 'c', 'h', '-',
               'R', 'T', ' ', 'b', 'o', 'u', 'n', 'd', 'e', 'd', 'n', 'e', 's',
               's', ' ', 'o', 'f', ' '] .
            shows_nl .
              shows_tp (shows_prec zero_nat) (shows_prec zero_nat) i tp .
                shows_nl .
                  shows_prec_list zero_nat
                    ['w', 'i', 't', 'h', ' ', 'd', 'e', 'l', 'e', 't', 'i', 'o',
                      'n', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', 's'] .
                    shows_nl .
                      shows_trs (shows_prec zero_nat) (shows_prec zero_nat)
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                          't', 'e', 'm', ':']
                        [' ', '-', '>', ' '] rdelete .
                        x));

bounds_complexity ::
  forall a b c d.
    (Compare_order b, Eq b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showa c,
      Card_UNIV d, Cenum d, Ceq d, Ccompare d, Compare_order d, Eq d,
      Set_impl d,
      Showa d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      Complexity_measure b c ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_complexity i info cm cc tp =
  catch_errora
    (bindb
      (check (less_eq_complexity_class (Comp_Poly one_nat) cc)
        (shows_prec_list zero_nat
          ['c', 'a', 'n', ' ', 'o', 'n', 'l', 'y', ' ', 'e', 'n', 's', 'u', 'r',
            'e', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'c', 'o', 'm', 'p',
            'l', 'e', 'x', 'i', 't', 'y']))
      (\ _ ->
        bindb (check (equal_boundstype (boundstype info) Match)
                (shows_prec_list zero_nat
                  ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'a',
                    'n', 'a', 'l', 'y', 's', 'i', 's', ' ', 'r', 'e', 'q', 'u',
                    'i', 'r', 'e', 's', ' ', 'b', 'o', 'u', 'n', 'd', 's', 't',
                    'y', 'p', 'e', ' ', 'm', 'a', 't', 'c', 'h']))
          (\ _ ->
            check_bounds_generic info (rulesd i tp) [] (stackable_of_cm cm)
              (roots_of_cm cm))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'e', 'n',
               's', 'u', 'r', 'i', 'n', 'g', ' ', 'm', 'a', 't', 'c', 'h', ' ',
               'b', 'o', 'u', 'n', 'd', 'e', 'd', 'n', 'e', 's', 's', ' ', 'o',
               'f', ' '] .
            shows_nl .
              shows_tp (shows_prec zero_nat) (shows_prec zero_nat) i tp .
                shows_nl . x));

check_assm ::
  forall a b c d.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    ((a, (Complexity_measure (Lab b c) [Prelude.Char],
                           Complexity_class)) ->
                      d -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      Generic_assm_proof b c [Prelude.Char] d () () () () ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assm i cpx_check (Complexity_assm_proof cp prf) =
  cpx_check (mk_cpx i cp) prf;
check_assm i uu (SN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Finite_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (SN_FP_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Not_SN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Infinite_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Not_RelSN_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Not_SN_FP_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm i uu (Unknown_assm_proof v va) =
  Inl (shows_prec_list zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
          'r', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
          'i', 'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
          's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't',
          'y', ' ', 'p', 'r', 'o', 'o', 'f']);

check_complexity_proof ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Bool ->
                      ([Prelude.Char] -> [Prelude.Char]) ->
                        (a, (Complexity_measure (Lab b c) [Prelude.Char],
                              Complexity_class)) ->
                          Complexity_proof b c [Prelude.Char] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_complexity_proof ia assms i (tp, (cm, cc))
  (Rule_Shift_Complexity redp rdelete ur_opt prf) =
  debug (i [])
    ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'C', 'o',
      'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
    (bindb
      (catch_errora
        (smart_rule_shift_complexity ia (get_redtriple redp) rdelete ur_opt cm
          cc tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' ', 's', 'h',
                       'i', 'f', 't', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                       'n', 'i', 'q', 'u', 'e', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ['.', '1'])
            (tpa, (cm, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 's', 'h', 'i', 'f', 't', 'i', 'n', 'g', ' ', 'p',
                         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) RisEmpty_Complexity =
  debug (i [])
    ['R', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'f', 'o', 'r', ' ',
      'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
    (check (null (rc ia tp))
      (i . shows_string
             [':', ' ', 'R', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm',
               'p', 't', 'y', ' ', 'i', 'n', ' '] .
             shows_nl .
               shows_tp (shows_prec_lab zero_nat) (shows_prec_list zero_nat) ia
                 tp));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Remove_Nonapplicable_Rules_Complexity r prf) =
  debug (i [])
    ['R', 'e', 'm', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a', 'p',
      'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']
    (let {
       _ = rc ia tp;
     } in bindb (catch_errora (check_non_applicable_rules (is_QNFb ia tp) r)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'r', 'e', 'm', 'o', 'v',
                                 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a',
                                 'p', 'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e',
                                 ' ', 'r', 'u', 'l', 'e', 's'] .
                               shows_nl .
                                 indent
                                   (shows_rule (shows_prec_lab zero_nat)
                                      (shows_prec_list zero_nat)
                                      [' ', '-', '>', ' '] x .
                                     shows_prec_list zero_nat
                                       [' ', 'i', 's', ' ', 'a', 'p', 'p', 'l',
 'i', 'c', 'a', 'b', 'l', 'e']))))
            (\ _ ->
              let {
                tpa = delete_R_Rwb ia tp r r;
              } in catch_errora
                     (check_complexity_proof ia assms
                       (i . shows_string ['.', '1']) (tpa, (cm, cc)) prf)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                    'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                    'n', 'o', 'n', '-', 'a', 'p', 'p', 'l', 'i',
                                    'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                                    'e', 's', ' ', 'r', 'e', 'm', 'o', 'v', 'a',
                                    'l'] .
                                  shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (Matchbounds_Complexity info) =
  debug (i []) ['M', 'a', 't', 'c', 'h', 'b', 'o', 'u', 'n', 'd', 's']
    (catch_errora (bounds_complexity ia info cm cc tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'm', 'a',
                     't', 'c', 'h', 'b', 'o', 'u', 'n', 'd', 's'] .
                   shows_nl . indent x)));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Matchbounds_Rel_Complexity info rdel prf) =
  debug (i [])
    ['M', 'a', 't', 'c', 'h', 'b', 'o', 'u', 'n', 'd', 's', '-', 'R', 'e', 'l']
    (bindb
      (catch_errora (bounds_complexity_rel ia info rdel cm cc tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'm', 'a',
                       't', 'c', 'h', 'b', 'o', 'u', 'n', 'd', 's'] .
                     shows_nl . indent x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ['.', '1'])
            (tpa, (cm, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g',
                         ' ', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'm',
                         'a', 't', 'c', 'h', 'b', 'o', 'u', 'n', 'd', 's'] .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (DT_Transformation info prf) =
  debug (i [])
    ['D', 'T', ' ', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
      'o', 'n']
    (bindb
      (catch_errora (dt_transformation Sharp ia info cm cc tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'D', 'T', ' ', 't', 'r', 'a', 'n',
                       's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', ' ',
                       'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ (cma, tpa) ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ['.', '1'])
            (tpa, (cma, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'D', 'T', ' ', 't',
                         'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
                         'o', 'n'] .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (WDP_Transformation info prf) =
  debug (i [])
    ['W', 'D', 'P', ' ', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't',
      'i', 'o', 'n']
    (bindb
      (catch_errora (check_wdp_trans Sharp ia info cm cc tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'W', 'D', 'P', ' ', 't', 'r', 'a',
                       'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n',
                       ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab zero_nat)
                         (shows_prec_list zero_nat) ia tp .
                         shows_nl . x)))
      (\ (cma, tpa) ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ['.', '1'])
            (tpa, (cma, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'W', 'D', 'P', ' ',
                         't', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't',
                         'i', 'o', 'n'] .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Usable_Rules_Complexity ur prf) =
  debug (i []) ['U', 's', 'a', 'b', 'l', 'e', ' ', 'R', 'u', 'l', 'e', 's']
    (bindb
      (catch_errora (usable_rules_complexity ia ur cm cc tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                       's'] .
                     shows_nl . indent x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ['.', '1'])
            (tpa, (cm, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g',
                         ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                         'e', 's'] .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (Complexity_Assumption a ass) =
  debug (i [])
    ['C', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n']
    (if assms
      then bindb (catch_errora
                   (check_complexity_subsumes a
                     (qb ia tp, (rc ia tp, (rwc ia tp, (cm, cc)))))
                   (\ x ->
                     Inl (i . shows_prec_list zero_nat
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x',
                                  'i', 't', 'y', ' ', 'a', 's', 's', 'u', 'm',
                                  'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ',
                                  'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                                  'r', 'o', 'o', 'f'] .
                                shows_nl . x)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa j ->
                       check_assm ia
                         (check_complexity_proof ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat zero_nat (suc j)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (shows_prec_list zero_nat
                 ['t', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'c', 'o',
                   'n', 't', 'a', 'i', 'n', 's', ' ', 'a', 'n', ' ', 'a', 's',
                   's', 'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ',
                   'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o',
                   'f', ' ', 'w', 'h', 'i', 'c', 'h', ' ', 'h', 'a', 'v', 'e',
                   ' ', 't', 'o', ' ', 'b', 'e', ' ', 'm', 'a', 'n', 'u', 'a',
                   'l', 'l', 'y', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Split_Complexity info prf1 prf2) =
  debug (i []) ['S', 'p', 'l', 'i', 't']
    (bindb
      (catch_errora (split_proc_complexity ia info tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o', 'c', 'e',
                       's', 's', 'o', 'r'] .
                     shows_nl . indent x)))
      (\ (tp1, tp2) ->
        bindb (catch_errora
                (check_complexity_proof ia assms (i . shows_string ['.', '1'])
                  (tp1, (cm, cc)) prf1)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 'a', 'p', 'p', 'l', 'y', 'i',
                               'n', 'g', ' ', 's', 'p', 'l', 'i', 't', ' ', 'p',
                               'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                             shows_nl . indent x)))
          (\ _ ->
            catch_errora
              (check_complexity_proof ia assms (i . shows_string ['.', '2'])
                (tp2, (cm, cc)) prf2)
              (\ x ->
                Inl (i . shows_string
                           [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                             'l', 'o', 'w', ' ', 'a', 'p', 'p', 'l', 'y', 'i',
                             'n', 'g', ' ', 's', 'p', 'l', 'i', 't', ' ', 'p',
                             'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                           shows_nl . indent x)))));

translate_complexity_claim ::
  forall a b c.
    (Eq a) => [(Term a b, Term a b)] ->
                [(Term a b, Term a b)] -> Start_term -> Complexity_measure a c;
translate_complexity_claim r s start =
  let {
    f = funas_trs_list (r ++ s);
    d = defined_list (r ++ s);
    c = filter (\ fa -> not (membera d fa)) f;
  } in (case start of {
         Full -> Derivational_Complexity f;
         Constructor_Based -> Runtime_Complexity c d;
       });

check_unknown_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Unknown_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_proof ia j a i u prf =
  check_unknown_proof_main ia j a i u (unlab_to_split_unknown prf);

fp_strategy_to_fp_impl ::
  forall a b.
    (Eq a) => Fp_strategy a [Prelude.Char] ->
                [(Term a [Prelude.Char], b)] ->
                  [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
fp_strategy_to_fp_impl strat r = (case strat of {
                                   Outermost -> o_to_fp_impl (map fst r);
                                   Context_Sensitive a -> mu_to_fp_impl a;
                                   Forbidden_Patterns fp -> fp;
                                 });

iA_exp_to_tpoly :: forall a. Term Sig (a, Ty) -> Tpoly a Int;
iA_exp_to_tpoly (Var (a, ty)) = PVar a;
iA_exp_to_tpoly (Fun (Sum uu) asa) = PSum (map iA_exp_to_tpoly asa);
iA_exp_to_tpoly (Fun (Const a) []) = PNum a;
iA_exp_to_tpoly (Fun (Mult uv) asa) = PMult (map iA_exp_to_tpoly asa);

iA_exp_to_poly :: forall a. (Eq a) => Term Sig (a, Ty) -> [([(a, Nat)], Int)];
iA_exp_to_poly = poly_of . iA_exp_to_tpoly;

show_IA_exp ::
  forall a.
    (Eq a, Showa a) => Term Sig (a, Ty) -> [Prelude.Char] -> [Prelude.Char];
show_IA_exp (Fun Less [s, t]) =
  (show_IA_exp s . shows_prec_list zero_nat [' ', '<', ' ']) . show_IA_exp t;
show_IA_exp (Fun Lesseq [s, t]) =
  (show_IA_exp s . shows_prec_list zero_nat [' ', '<', '=', ' ']) .
    show_IA_exp t;
show_IA_exp (Fun Equals [s, t]) =
  (show_IA_exp s . shows_prec_list zero_nat [' ', '=', ' ']) . show_IA_exp t;
show_IA_exp (Var v) = shows_poly (iA_exp_to_poly (Var v));
show_IA_exp (Fun Lesseq []) =
  (shows_poly :: [([(a, Nat)], Int)] -> [Prelude.Char] -> [Prelude.Char])
    ((iA_exp_to_poly :: Term Sig (a, Ty) -> [([(a, Nat)], Int)])
      (Fun Lesseq []));
show_IA_exp (Fun Lesseq [v]) = shows_poly (iA_exp_to_poly (Fun Lesseq [v]));
show_IA_exp (Fun Lesseq (v : vc : ve : vf)) =
  shows_poly (iA_exp_to_poly (Fun Lesseq (v : vc : ve : vf)));
show_IA_exp (Fun (Sum vb) va) = shows_poly (iA_exp_to_poly (Fun (Sum vb) va));
show_IA_exp (Fun (Const vb) va) =
  shows_poly (iA_exp_to_poly (Fun (Const vb) va));
show_IA_exp (Fun (Mult vb) va) = shows_poly (iA_exp_to_poly (Fun (Mult vb) va));
show_IA_exp (Fun Equals []) =
  (shows_poly :: [([(a, Nat)], Int)] -> [Prelude.Char] -> [Prelude.Char])
    ((iA_exp_to_poly :: Term Sig (a, Ty) -> [([(a, Nat)], Int)])
      (Fun Equals []));
show_IA_exp (Fun Equals [v]) = shows_poly (iA_exp_to_poly (Fun Equals [v]));
show_IA_exp (Fun Equals (v : vc : ve : vf)) =
  shows_poly (iA_exp_to_poly (Fun Equals (v : vc : ve : vf)));
show_IA_exp (Fun v []) =
  (shows_poly :: [([(a, Nat)], Int)] -> [Prelude.Char] -> [Prelude.Char])
    ((iA_exp_to_poly :: Term Sig (a, Ty) -> [([(a, Nat)], Int)]) (Fun v []));
show_IA_exp (Fun v [vb]) = shows_poly (iA_exp_to_poly (Fun v [vb]));
show_IA_exp (Fun v (vb : vd : vf : vg)) =
  shows_poly (iA_exp_to_poly (Fun v (vb : vd : vf : vg)));

fresh_variable_checker ::
  forall a b c d e f.
    (Showa a, Ceq b, Ccompare b, Eq b, Showa b, Eq d, Showa d, Showa e,
      Showa f) => Logic_ext a b c () ->
                    (Trans_var d ->
                      b -> Formula (Term a (Trans_var d, b)) ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a (Trans_var d, b) ->
                        [Prelude.Char] -> [Prelude.Char]) ->
                        Lts_impl a d b e f ->
                          (f -> Formula (Term a (Trans_var d, b))) ->
                            d -> b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
fresh_variable_checker lambda def_checker sa2 p f x ty =
  catch_errora
    (bindb
      (catch_errora
        (forallM
          (\ (l, fa) ->
            check (not (in_vars_formula (x, ty) fa))
              ((shows_prec zero_nat x .
                 shows_prec_list zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's',
                     'h', ',', ' ', 'i', 't', ' ', 'o', 'c', 'c', 'u', 'r', 's',
                     ' ', 'i', 'n', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o', 'n',
                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'o',
                     'f', ' ']) .
                shows_prec zero_nat l))
          (assertion_impl p))
        (\ xa -> Inl (snd xa)))
      (\ _ ->
        catch_errora
          (forallM
            (\ (tr, tau) ->
              let {
                psi = f tr;
              } in bindb (check (formula (is_bool lambda) psi)
                           (shows_prec_list zero_nat
                             ['n', 'e', 'w', ' ', 't', 'r', 'a', 'n', 's', 'i',
                               't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', 'm', 'u',
                               'l', 'a', ' ', 's', 'e', 'e', 'm', 's', ' ', 't',
                               'o', ' ', 'b', 'e', ' ', 'n', 'o', 't', ' ', 'w',
                               'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e',
                               'd']))
                     (\ _ ->
                       catch_errora
                         (let {
                            (Transition _ _ phi) = tau;
                          } in bindb (def_checker (Post x) ty psi)
                                 (\ _ ->
                                   bindb (check
   (not (in_vars_formula (Post x, ty) phi))
   (shows_prec_list zero_nat
      ['P', 'o', 's', 't', ' ', 'x', ' ', 'i', 'n', ' ', 't', 'r', 'a', 'n',
        's', 'i', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', 'm', 'u', 'l', 'a'] .
     shows_formula sa2 phi))
                                     (\ _ ->
                                       check
 (not (in_vars_formula (Pre x, ty) phi))
 (shows_prec_list zero_nat
    ['P', 'r', 'e', ' ', 'x', ' ', 'i', 'n', ' ', 't', 'r', 'a', 'n', 's', 'i',
      't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', 'm', 'u', 'l', 'a'] .
   shows_formula sa2 phi))))
                         (\ xa ->
                           Inl (((shows_prec_list zero_nat
                                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                      'i', 'n', ' ', 't', 'r', 'a', 'n', 's',
                                      'i', 't', 'i', 'o', 'n', ' ', 'f', 'o',
                                      'r', 'm', 'u', 'l', 'a', ' ', 'o', 'f',
                                      ' ', 't', 'r', 'a', 'n', 's', 'i', 't',
                                      'i', 'o', 'n', ' '] .
                                   shows_prec zero_nat tr) .
                                  shows_nl) .
                                 xa))))
            (transitions_impl p))
          (\ xa -> Inl (snd xa))))
    (\ xa ->
      Inl (shows_prec_list zero_nat
             ['f', 'r', 'e', 's', 'h', '_', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
               'e', '_', 'c', 'h', 'e', 'c', 'k', 'e', 'r', ' ', 'f', 'a', 'i',
               'l', 'e', 'd', '\n'] .
            xa));

shows_prec_formula ::
  forall a. (Showa a) => Nat -> Formula a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_formula = showsp_formula shows_prec;

refine_transition_formula ::
  forall a b c d.
    Transition_rule a b c d ->
      Formula (Term a (Trans_var b, c)) -> Transition_rule a b c d;
refine_transition_formula (Transition l r phi) psi =
  Transition l r (form_and phi psi);

refine_transition_formulas ::
  forall a b c d e.
    Lts_impl a b c d e ->
      (e -> Formula (Term a (Trans_var b, c))) -> Lts_impl a b c d e;
refine_transition_formulas p f =
  Lts_Impl (initiala p)
    (map (\ (tr, tau) -> (tr, refine_transition_formula tau (f tr)))
      (transitions_impl p))
    (assertion_impl p);

fresh_variable_addition ::
  forall a b c d e f.
    (Showa a, Ceq b, Ccompare b, Eq b, Showa b, Eq d, Showa d, Showa e,
      Ccompare f, Eq f, Mapping_impl f,
      Showa f) => Logic_ext a b c () ->
                    (Trans_var d ->
                      b -> Formula (Term a (Trans_var d, b)) ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a (Trans_var d, b) ->
                        [Prelude.Char] -> [Prelude.Char]) ->
                        Lts_impl a d b e f ->
                          Fresh_variable_addition_info a d b f ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              (Lts_impl a d b e f);
fresh_variable_addition lambda def_checker sa2 p
  (Fresh_Variable_Addition_Info x ty forms) =
  let {
    m = of_alist forms;
    f = lookup_default (Conjunction []) m;
  } in (case catch_errora
               (bindb
                 (catch_errora
                   (forallM
                     (\ fa ->
                       check (formula (is_bool lambda) fa)
                         (shows_prec_formula zero_nat fa .
                           shows_prec_list zero_nat
                             [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ',
                               'v', 'a', 'l', 'i', 'd', ' ', 'f', 'o', 'r', 'm',
                               'u', 'l', 'a']))
                     (map snd forms))
                   (\ xa -> Inl (snd xa)))
                 (\ _ ->
                   fresh_variable_checker lambda def_checker sa2 p f x ty))
               (\ xa ->
                 Inl (((shows_prec_list zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n',
                            ' ', 'a', 'd', 'd', 'i', 'n', 'g', ' ', 'f', 'r',
                            'e', 's', 'h', ' ', 'v', 'a', 'r', 'i', 'a', 'b',
                            'l', 'e', ' '] .
                         shows_prec zero_nat x) .
                        shows_nl) .
                       xa))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (refine_transition_formulas p f);
       });

is_sharp :: forall a. Sharp a -> Bool;
is_sharp (Flat uu) = False;
is_sharp (Sharpa uv) = True;

trivial_termination_checker ::
  forall a b c d e.
    (Showa d,
      Showa e) => (Term a (b, c) -> [Prelude.Char] -> [Prelude.Char]) ->
                    (Term a (Trans_var b, c) ->
                      [Prelude.Char] -> [Prelude.Char]) ->
                      Lts_impl a b c (Sharp d) e ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
trivial_termination_checker shows_atom shows_tatom p =
  check (null (filter (\ tau -> is_sharp (source tau))
                (map snd (transitions_impl p))))
    (shows_prec_list zero_nat
       ['t', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 'r', 'e', 'm', 'a',
         'i', 'n', 'i', 'n', 'g', ' ', 's', 'h', 'a', 'r', 'p', ' ', 't', 'r',
         'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' '] .
      shows_lts shows_atom shows_tatom p);

lex_less_formula ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (Term a (Trans_var b, c) ->
                    Term a (Trans_var b, c) ->
                      Formula (Term a (Trans_var b, c))) ->
                    (Term a (Trans_var b, c) ->
                      Term a (Trans_var b, c) ->
                        Formula (Term a (Trans_var b, c))) ->
                      [Term a (Trans_var b, c)] ->
                        [Term a (Trans_var b, c)] ->
                          [Term a (Trans_var b, c)] ->
                            Formula (Term a (Trans_var b, c));
lex_less_formula less_eq_formula less_formula uu [va] (v : vb : vc) =
  Disjunction [];
lex_less_formula less_eq_formula less_formula uu [] (v : vb : vc) =
  Disjunction [];
lex_less_formula less_eq_formula less_formula [va] uv (v : vb : vc) =
  Disjunction [];
lex_less_formula less_eq_formula less_formula [] uv (v : vb : vc) =
  Disjunction [];
lex_less_formula less_eq_formula less_formula uu uv [] = Disjunction [];
lex_less_formula less_eq_formula less_formula uu (v : vb : vc) [va] =
  Disjunction [];
lex_less_formula less_eq_formula less_formula [va] (v : vb : vc) uw =
  Disjunction [];
lex_less_formula less_eq_formula less_formula [] (v : vb : vc) uw =
  Disjunction [];
lex_less_formula less_eq_formula less_formula uu [] uw = Disjunction [];
lex_less_formula less_eq_formula less_formula (v : vb : vc) uv [va] =
  Disjunction [];
lex_less_formula less_eq_formula less_formula (v : vb : vc) [va] uw =
  Disjunction [];
lex_less_formula less_eq_formula less_formula [] uv uw = Disjunction [];
lex_less_formula less_eq_formula less_formula (ba : b : bs) (xa : x : xs)
  (ya : y : ys) =
  form_or (form_and (less_formula xa ya) (less_eq_formula ba ya))
    (Conjunction
      [less_eq_formula xa ya,
        lex_less_formula less_eq_formula less_formula (b : bs) (x : xs)
          (y : ys)]);
lex_less_formula less_eq_formula less_formula [b] [x] [y] =
  form_and (less_formula x y) (less_eq_formula b y);

bound_exp :: forall a b c d e. Transition_removal_info a b c d e -> a;
bound_exp (Transition_removal_info x1 x2 x3 x4 x5) = x4;

hinter :: forall a b c d e. Transition_removal_info a b c d e -> d -> Hint e;
hinter (Transition_removal_info x1 x2 x3 x4 x5) = x5;

rank :: forall a b c d e. Transition_removal_info a b c d e -> Sharp c -> a;
rank (Transition_removal_info x1 x2 x3 x4 x5) = x1;

check_lex_strict ::
  forall a b c d e f g.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d, Showa d, Eq e,
      Showa e, Ccompare f, Eq f, Showa f,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (Trans_var e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a (Trans_var e, b) ->
                        [Prelude.Char] -> [Prelude.Char]) ->
                        (Term a (Trans_var e, b) ->
                          Formula (Term a (Trans_var e, b))) ->
                          (Term a (Trans_var e, b) ->
                            Term a (Trans_var e, b) ->
                              Formula (Term a (Trans_var e, b))) ->
                            (Term a (Trans_var e, b) ->
                              Term a (Trans_var e, b) ->
                                Formula (Term a (Trans_var e, b))) ->
                              Transition_removal_info [Term a (e, b)] b f g d ->
                                Lts_impl a e b (Sharp f) g ->
                                  (g, Transition_rule a e b (Sharp f)) ->
                                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lex_strict lambda check_logic sa ne less_eq_formula less_formula info pi
  (tr, Transition l r phi) =
  let {
    psi = lex_less_formula less_eq_formula less_formula
            (map (rename_vars_exp Pre) (bound_exp info))
            (map (rename_vars_exp Post) (rank info r))
            (map (rename_vars_exp Pre) (rank info l));
  } in bindb (check (formula (is_bool lambda) psi)
               ((shows_prec_list zero_nat
                   ['l', 'e', 'x', '-', 'l', 'e', 's', 's', ' ', 'd', 'o', 'e',
                     's', ' ', 'n', 'o', 't', ' ', 'e', 'n', 'c', 'o', 'd', 'e',
                     ' ', 'v', 'a', 'l', 'i', 'd', ' ', 'f', 'o', 'r', 'm', 'u',
                     'l', 'a'] .
                  shows_nl) .
                 shows_prec_formula zero_nat psi))
         (\ _ ->
           check_formula check_logic sa ne (hinter info tr)
             (Disjunction
               [psi, Disjunction [],
                 form_not
                   (map_formula (rename_vars_exp Pre) (assertion_of pi l)),
                 form_not phi]));

lex_leq_formula ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (Term a (Trans_var b, c) ->
                    Term a (Trans_var b, c) ->
                      Formula (Term a (Trans_var b, c))) ->
                    (Term a (Trans_var b, c) ->
                      Term a (Trans_var b, c) ->
                        Formula (Term a (Trans_var b, c))) ->
                      [Term a (Trans_var b, c)] ->
                        [Term a (Trans_var b, c)] ->
                          [Term a (Trans_var b, c)] ->
                            Formula (Term a (Trans_var b, c));
lex_leq_formula less_eq_formula less_formula uu [va] (v : vb : vc) =
  Disjunction [];
lex_leq_formula less_eq_formula less_formula uu [] (v : vb : vc) =
  Disjunction [];
lex_leq_formula less_eq_formula less_formula [va] uv (v : vb : vc) =
  Disjunction [];
lex_leq_formula less_eq_formula less_formula [] uv (v : vb : vc) =
  Disjunction [];
lex_leq_formula less_eq_formula less_formula uu (v : va) [] = Disjunction [];
lex_leq_formula less_eq_formula less_formula (v : va) uv [] = Disjunction [];
lex_leq_formula less_eq_formula less_formula uu (v : vb : vc) [va] =
  Disjunction [];
lex_leq_formula less_eq_formula less_formula [va] (v : vb : vc) uw =
  Disjunction [];
lex_leq_formula less_eq_formula less_formula [] (v : vb : vc) uw =
  Disjunction [];
lex_leq_formula less_eq_formula less_formula uu [] (v : va) = Disjunction [];
lex_leq_formula less_eq_formula less_formula (v : va) [] uw = Disjunction [];
lex_leq_formula less_eq_formula less_formula (v : vb : vc) uv [va] =
  Disjunction [];
lex_leq_formula less_eq_formula less_formula (v : vb : vc) [va] uw =
  Disjunction [];
lex_leq_formula less_eq_formula less_formula [] uv (v : va) = Disjunction [];
lex_leq_formula less_eq_formula less_formula [] (v : va) uw = Disjunction [];
lex_leq_formula less_eq_formula less_formula [] [] [] = Conjunction [];
lex_leq_formula less_eq_formula less_formula (ba : b : bs) (xa : x : xs)
  (ya : y : ys) =
  form_or (form_and (less_formula xa ya) (less_eq_formula ba ya))
    (Conjunction
      [less_eq_formula xa ya,
        lex_leq_formula less_eq_formula less_formula (b : bs) (x : xs)
          (y : ys)]);
lex_leq_formula less_eq_formula less_formula [b] [x] [y] = less_eq_formula x y;

check_lex_weak ::
  forall a b c d e f g.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d, Showa d, Eq e,
      Showa e, Ccompare f, Eq f, Showa f,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (Trans_var e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a (Trans_var e, b) ->
                        [Prelude.Char] -> [Prelude.Char]) ->
                        (Term a (Trans_var e, b) ->
                          Formula (Term a (Trans_var e, b))) ->
                          (Term a (Trans_var e, b) ->
                            Term a (Trans_var e, b) ->
                              Formula (Term a (Trans_var e, b))) ->
                            (Term a (Trans_var e, b) ->
                              Term a (Trans_var e, b) ->
                                Formula (Term a (Trans_var e, b))) ->
                              Transition_removal_info [Term a (e, b)] b f g d ->
                                Lts_impl a e b (Sharp f) g ->
                                  (g, Transition_rule a e b (Sharp f)) ->
                                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lex_weak lambda check_logic sa ne less_eq_formula less_formula info pi
  (tr, Transition l r phi) =
  let {
    psi = lex_leq_formula less_eq_formula less_formula
            (map (rename_vars_exp Pre) (bound_exp info))
            (map (rename_vars_exp Post) (rank info r))
            (map (rename_vars_exp Pre) (rank info l));
  } in bindb (check (formula (is_bool lambda) psi)
               ((shows_prec_list zero_nat
                   ['l', 'e', 'x', '-', 'l', 'e', 'q', ' ', 'd', 'o', 'e', 's',
                     ' ', 'n', 'o', 't', ' ', 'e', 'n', 'c', 'o', 'd', 'e', ' ',
                     'v', 'a', 'l', 'i', 'd', ' ', 'f', 'o', 'r', 'm', 'u', 'l',
                     'a'] .
                  shows_nl) .
                 shows_prec_formula zero_nat psi))
         (\ _ ->
           check_formula check_logic sa ne (hinter info tr)
             (Disjunction
               [psi, Disjunction [],
                 form_not
                   (map_formula (rename_vars_exp Pre) (assertion_of pi l)),
                 form_not phi]));

update_transitions_impl ::
  forall a b c d e f.
    Lts_impl a b c d e -> [(f, Transition_rule a b c d)] -> Lts_impl a b c d f;
update_transitions_impl (Lts_Impl i tsa lc) ts = Lts_Impl i ts lc;

diff_by_label ::
  forall a b. (Ceq a, Ccompare a) => [(a, b)] -> Set a -> [(a, b)];
diff_by_label pairs l = filter (\ v -> not (member (fst v) l)) pairs;

del_transitions_impl ::
  forall a b c d e.
    (Ceq e, Ccompare e,
      Set_impl e) => Lts_impl a b c d e -> [e] -> Lts_impl a b c d e;
del_transitions_impl p td =
  update_transitions_impl p (diff_by_label (transitions_impl p) (set td));

processor ::
  forall a b c d e.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Showa a) => ((a, Transition_rule b c d (Sharp e)) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    ((a, Transition_rule b c d (Sharp e)) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      [a] ->
                        Lts_impl b c d (Sharp e) a ->
                          Sum ([Prelude.Char] -> [Prelude.Char])
                            (Lts_impl b c d (Sharp e) a);
processor check_weak check_strict td pi =
  catch_errora
    (bindb
      (catch_errora
        (forallM
          (\ (tr, tau) ->
            (if membera td tr
              then bindb (check (is_sharp (source tau))
                           ((shows_prec_list zero_nat
                               ['n', 'o', 'n', '-', 's', 'h', 'a', 'r', 'p',
                                 ' ', 't', 'r', 'a', 'n', 's', 'i', 't', 'i',
                                 'o', 'n', ' '] .
                              shows_prec zero_nat tr) .
                             shows_prec_list zero_nat
                               [' ', 'c', 'a', 'n', 'n', 'o', 't', ' ', 'b',
                                 'e', ' ', 'r', 'e', 'm', 'o', 'v', 'e', 'd']))
                     (\ _ ->
                       catch_errora (check_strict (tr, tau))
                         (\ x ->
                           Inl (((shows_prec_list zero_nat
                                    ['F', 'a', 'i', 'l', 'e', 'd', ' ', 't',
                                      'o', ' ', 's', 't', 'r', 'i', 'c', 't',
                                      'l', 'y', ' ', 'o', 'r', 'i', 'e', 'n',
                                      't', ' ', 't', 'r', 'a', 'n', 's', 'i',
                                      't', 'i', 'o', 'n', ' '] .
                                   shows_prec zero_nat tr) .
                                  shows_nl) .
                                 x)))
              else (if is_sharp (source tau)
                     then catch_errora (check_weak (tr, tau))
                            (\ x ->
                              Inl (((shows_prec_list zero_nat
                                       ['F', 'a', 'i', 'l', 'e', 'd', ' ', 't',
 'o', ' ', 'w', 'e', 'a', 'k', 'l', 'y', ' ', 'o', 'r', 'i', 'e', 'n', 't', ' ',
 't', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' '] .
                                      shows_prec zero_nat tr) .
                                     shows_nl) .
                                    x))
                     else Inr ())))
          (transitions_impl pi))
        (\ x -> Inl (snd x)))
      (\ _ -> Inr (del_transitions_impl pi td)))
    (\ x ->
      Inl (((shows_prec_list zero_nat
               ['F', 'a', 'i', 'l', 'e', 'd', ' ', 't', 'o', ' ', 'e', 'l', 'i',
                 'm', 'i', 'n', 'a', 't', 'e', ' ', 't', 'r', 'a', 'n', 's',
                 'i', 't', 'i', 'o', 'n', 's', ' '] .
              shows_prec_list zero_nat td) .
             shows_prec_list zero_nat [':', '\n']) .
            x));

removed :: forall a b c d e. Transition_removal_info a b c d e -> [d];
removed (Transition_removal_info x1 x2 x3 x4 x5) = x2;

lex_processor ::
  forall a b c d e f g.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d, Showa d, Eq e,
      Showa e, Ccompare f, Eq f, Showa f, Ceq g, Ccompare g, Eq g, Set_impl g,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (Trans_var e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a (Trans_var e, b) ->
                        [Prelude.Char] -> [Prelude.Char]) ->
                        (Term a (Trans_var e, b) ->
                          Formula (Term a (Trans_var e, b))) ->
                          b -> (Term a (Trans_var e, b) ->
                                 Term a (Trans_var e, b) ->
                                   Formula (Term a (Trans_var e, b))) ->
                                 (Term a (Trans_var e, b) ->
                                   Term a (Trans_var e, b) ->
                                     Formula (Term a (Trans_var e, b))) ->
                                   (Term a (Trans_var e, b) -> Bool) ->
                                     Transition_removal_info [Term a (e, b)] b f
                                       g d ->
                                       Lts_impl a e b (Sharp f) g ->
 Sum ([Prelude.Char] -> [Prelude.Char]) (Lts_impl a e b (Sharp f) g);
lex_processor lambda check_logic sa ne dom_type less_eq_formula less_formula
  is_constant info pi =
  bindb (catch_errora
          (forallM
            (\ l ->
              catch_errora
                (forallM
                  (\ e ->
                    check (has_type (type_of_fun lambda) e dom_type)
                      (shows_prec_list zero_nat
                         ['U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ',
                           't', 'y', 'p', 'e', ' ', 'o', 'f', ' ', 'e', 'x',
                           'p', 'r', 'e', 's', 's', 'i', 'o', 'n', ':', '\n'] .
                        shows_prec_term zero_nat e))
                  (rank info l))
                (\ x -> Inl (snd x)))
            (nodes_lts_impl pi))
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ e ->
                  check (has_type (type_of_fun lambda) e dom_type)
                    (shows_prec_list zero_nat
                       ['U', 'n', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ',
                         't', 'y', 'p', 'e', ' ', 'o', 'f', ' ', 'b', 'o', 'u',
                         'n', 'd', ':', ' '] .
                      shows_prec_term zero_nat e))
                (bound_exp info))
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (catch_errora
                  (forallM
                    (\ e ->
                      check (is_constant e)
                        (shows_prec_list zero_nat
                           ['N', 'o', 'n', '-', 'c', 'o', 'n', 's', 't', 'a',
                             'n', 't', ' ', 'b', 'o', 'u', 'n', 'd', ':', ' '] .
                          shows_prec_term zero_nat e))
                    (map (rename_vars_exp Pre) (bound_exp info)))
                  (\ x -> Inl (snd x)))
            (\ _ ->
              processor
                (check_lex_weak lambda check_logic sa ne less_eq_formula
                  less_formula info pi)
                (check_lex_strict lambda check_logic sa ne less_eq_formula
                  less_formula info pi)
                (removed info) pi)));

check_skip_transition ::
  forall a b c d e.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => (a -> Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (c, d) -> [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        Transition_rule b c d e ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_skip_transition logic_checker shows_atom negate_atom tau =
  let {
    (Transition _ _ phi) = tau;
  } in check_valid_formula logic_checker shows_atom negate_atom
         (map_formula (rename_vars_exp untrans_var) phi);

change_source ::
  forall a b c d. a -> Transition_rule b c d a -> Transition_rule b c d a;
change_source l (Transition src tgt phi) = Transition l tgt phi;

location_addition_outgoing ::
  forall a b c d e f g.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d, Showa d, Eq e,
      Showa e, Ccompare f, Eq f, Showa f,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                        (Term a (e, b) -> Formula (Term a (e, b))) ->
                          Lts_impl a e b (Sharp f) g ->
                            Location_addition_info a e b (Sharp f) g ->
                              Sum ([Prelude.Char] -> [Prelude.Char])
                                (Lts_impl a e b (Sharp f) g);
location_addition_outgoing lambda logic_checker shows_atom negate_atom p
  (Location_Addition_Info old new skip_ID skip) =
  bindb (check (not (membera (nodes_lts_impl p) new))
          ((shows_prec_list zero_nat
              ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n', '-', 'i', 'd', ' '] .
             shows_prec_sharp zero_nat new) .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's',
                'h']))
    (\ _ ->
      bindb (check (is_sharp new)
              ((shows_prec_list zero_nat
                  ['n', 'e', 'w', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o', 'n',
                    ' '] .
                 shows_prec_sharp zero_nat new) .
                shows_prec_list zero_nat
                  [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 's', 'h', 'a',
                    'r', 'p', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o', 'n']))
        (\ _ ->
          bindb (check (is_sharp old)
                  ((shows_prec_list zero_nat
                      ['c', 'o', 'p', 'i', 'e', 'd', ' ', 'l', 'o', 'c', 'a',
                        't', 'i', 'o', 'n', ' '] .
                     shows_prec_sharp zero_nat old) .
                    shows_prec_list zero_nat
                      [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 's', 'h',
                        'a', 'r', 'p', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o',
                        'n']))
            (\ _ ->
              bindb (check (transition_rule lambda skip)
                      ((shows_prec_list zero_nat
                          ['n', 'e', 'w', ' ', 't', 'r', 'a', 'n', 's', 'i',
                            't', 'i', 'o', 'n', ' '] .
                         shows_prec zero_nat skip_ID) .
                        shows_prec_list zero_nat
                          [' ', 's', 'e', 'e', 'm', 's', ' ', 't', 'o', ' ',
                            'b', 'e', ' ', 'i', 'l', 'l', '-', 'f', 'o', 'r',
                            'm', 'e', 'd']))
                (\ _ ->
                  bindb (catch_errora
                          (check_skip_transition logic_checker shows_atom
                            negate_atom skip)
                          (\ x ->
                            Inl (((shows_prec_list zero_nat
                                     ['n', 'e', 'w', ' ', 't', 'r', 'a', 'n',
                                       's', 'i', 't', 'i', 'o', 'n', ' '] .
                                    shows_prec zero_nat skip_ID) .
                                   shows_prec_list zero_nat
                                     [' ', 'm', 'u', 's', 't', ' ', 'b', 'e',
                                       ' ', 's', 'k', 'i', 'p', ' ', 't', 'r',
                                       'a', 'n', 's', 'i', 't', 'i', 'o', 'n',
                                       '\n']) .
                                  x)))
                    (\ _ ->
                      bindb (check
                              (equal_sharp (source skip) old &&
                                equal_sharp (target skip) new)
                              (((((shows_prec_list zero_nat
                                     ['n', 'e', 'w', ' ', 's', 'k', 'i', 'p',
                                       ' ', 't', 'r', 'a', 'n', 's', 'i', 't',
                                       'i', 'o', 'n', ' '] .
                                    shows_prec zero_nat skip_ID) .
                                   shows_prec_list zero_nat
                                     [' ', 'm', 'u', 's', 't', ' ', 'b', 'e',
                                       ' ', 'f', 'r', 'o', 'm', ' ']) .
                                  shows_prec_sharp zero_nat old) .
                                 shows_prec_list zero_nat
                                   [' ', 't', 'o', ' ']) .
                                shows_prec_sharp zero_nat new))
                        (\ _ ->
                          let {
                            trans = transitions_impl p;
                            (sharp, flat) =
                              partition (\ tau -> is_sharp (source (snd tau)))
                                trans;
                            (sharp_modify, sharp_keep) =
                              partition
                                (\ tau -> equal_sharp (source (snd tau)) old)
                                sharp;
                            q = Lts_Impl (initiala p)
                                  ((skip_ID, skip) :
                                    flat ++
                                      sharp_keep ++
map (\ tau -> (fst tau, change_source new (snd tau))) sharp_modify)
                                  ((new, assertion_of p old) :
                                    assertion_impl p);
                          } in bindb (catch_errora
                                       (forallM
 (\ l ->
   check (equal_formula (assertion_of p l) (assertion_of q l))
     ((shows_prec_list zero_nat
         ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'c', 'o', 'n', 'd', 'i',
           't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 'i', 'n', 'i', 't', 'i', 'a',
           'l', ' ', 's', 't', 'a', 't', 'e', ' '] .
        shows_prec_sharp zero_nat l) .
       shows_prec_list zero_nat
         [' ', 'h', 'a', 's', ' ', 'b', 'e', 'e', 'n', ' ', 'c', 'h', 'a', 'n',
           'g', 'e', 'd']))
 (initiala p))
                                       (\ x -> Inl (snd x)))
                                 (\ _ -> Inr q)))))));

change_target ::
  forall a b c d. a -> Transition_rule b c d a -> Transition_rule b c d a;
change_target l (Transition src tgt phi) = Transition src l phi;

location_addition_incoming ::
  forall a b c d e f g.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d, Showa d, Eq e,
      Showa e, Ccompare f, Eq f, Showa f,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                        (Term a (e, b) -> Formula (Term a (e, b))) ->
                          Lts_impl a e b (Sharp f) g ->
                            Location_addition_info a e b (Sharp f) g ->
                              Sum ([Prelude.Char] -> [Prelude.Char])
                                (Lts_impl a e b (Sharp f) g);
location_addition_incoming lambda logic_checker shows_atom negate_atom p
  (Location_Addition_Info new old skip_ID skip) =
  bindb (check (not (membera (nodes_lts_impl p) new))
          ((shows_prec_list zero_nat
              ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n', '-', 'i', 'd', ' '] .
             shows_prec_sharp zero_nat new) .
            shows_prec_list zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's',
                'h']))
    (\ _ ->
      bindb (check (is_sharp new)
              ((shows_prec_list zero_nat
                  ['n', 'e', 'w', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o', 'n',
                    ' '] .
                 shows_prec_sharp zero_nat new) .
                shows_prec_list zero_nat
                  [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 's', 'h', 'a',
                    'r', 'p', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o', 'n']))
        (\ _ ->
          bindb (check (is_sharp old)
                  ((shows_prec_list zero_nat
                      ['c', 'o', 'p', 'i', 'e', 'd', ' ', 'l', 'o', 'c', 'a',
                        't', 'i', 'o', 'n', ' '] .
                     shows_prec_sharp zero_nat old) .
                    shows_prec_list zero_nat
                      [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 's', 'h',
                        'a', 'r', 'p', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o',
                        'n']))
            (\ _ ->
              bindb (check (transition_rule lambda skip)
                      ((shows_prec_list zero_nat
                          ['n', 'e', 'w', ' ', 't', 'r', 'a', 'n', 's', 'i',
                            't', 'i', 'o', 'n', ' '] .
                         shows_prec zero_nat skip_ID) .
                        shows_prec_list zero_nat
                          [' ', 's', 'e', 'e', 'm', 's', ' ', 't', 'o', ' ',
                            'b', 'e', ' ', 'i', 'l', 'l', '-', 'f', 'o', 'r',
                            'm', 'e', 'd']))
                (\ _ ->
                  bindb (catch_errora
                          (check_skip_transition logic_checker shows_atom
                            negate_atom skip)
                          (\ x ->
                            Inl (((shows_prec_list zero_nat
                                     ['n', 'e', 'w', ' ', 't', 'r', 'a', 'n',
                                       's', 'i', 't', 'i', 'o', 'n', ' '] .
                                    shows_prec zero_nat skip_ID) .
                                   shows_prec_list zero_nat
                                     [' ', 'm', 'u', 's', 't', ' ', 'b', 'e',
                                       ' ', 's', 'k', 'i', 'p', ' ', 't', 'r',
                                       'a', 'n', 's', 'i', 't', 'i', 'o', 'n',
                                       '\n']) .
                                  x)))
                    (\ _ ->
                      bindb (check
                              (equal_sharp (source skip) new &&
                                equal_sharp (target skip) old)
                              (((((shows_prec_list zero_nat
                                     ['n', 'e', 'w', ' ', 's', 'k', 'i', 'p',
                                       ' ', 't', 'r', 'a', 'n', 's', 'i', 't',
                                       'i', 'o', 'n', ' '] .
                                    shows_prec zero_nat skip_ID) .
                                   shows_prec_list zero_nat
                                     [' ', 'm', 'u', 's', 't', ' ', 'b', 'e',
                                       ' ', 'f', 'r', 'o', 'm', ' ']) .
                                  shows_prec_sharp zero_nat new) .
                                 shows_prec_list zero_nat
                                   [' ', 't', 'o', ' ']) .
                                shows_prec_sharp zero_nat old))
                        (\ _ ->
                          let {
                            trans = transitions_impl p;
                            (sharp, flat) =
                              partition (\ tau -> is_sharp (source (snd tau)))
                                trans;
                            (sharp_modify, sharp_keep) =
                              partition
                                (\ tau -> equal_sharp (target (snd tau)) old)
                                sharp;
                            q = Lts_Impl (initiala p)
                                  ((skip_ID, skip) :
                                    flat ++
                                      sharp_keep ++
map (\ tau -> (fst tau, change_target new (snd tau))) sharp_modify)
                                  ((new, assertion_of p old) :
                                    assertion_impl p);
                          } in bindb (catch_errora
                                       (forallM
 (\ l ->
   check (equal_formula (assertion_of p l) (assertion_of q l))
     ((shows_prec_list zero_nat
         ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'c', 'o', 'n', 'd', 'i',
           't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 'i', 'n', 'i', 't', 'i', 'a',
           'l', ' ', 's', 't', 'a', 't', 'e', ' '] .
        shows_prec_sharp zero_nat l) .
       shows_prec_list zero_nat
         [' ', 'h', 'a', 's', ' ', 'b', 'e', 'e', 'n', ' ', 'c', 'h', 'a', 'n',
           'g', 'e', 'd']))
 (initiala p))
                                       (\ x -> Inl (snd x)))
                                 (\ _ -> Inr q)))))));

location_addition ::
  forall a b c d e f g.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d, Showa d, Eq e,
      Showa e, Ccompare f, Eq f, Showa f,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                        (Term a (e, b) -> Formula (Term a (e, b))) ->
                          Lts_impl a e b (Sharp f) g ->
                            Location_addition_info a e b (Sharp f) g ->
                              Sum ([Prelude.Char] -> [Prelude.Char])
                                (Lts_impl a e b (Sharp f) g);
location_addition lambda logic_checker shows_atom negate_atom p info =
  let {
    (Location_Addition_Info src _ _ _) = info;
  } in (if not (membera (nodes_lts_impl p) src)
         then location_addition_incoming lambda logic_checker shows_atom
                negate_atom p info
         else location_addition_outgoing lambda logic_checker shows_atom
                negate_atom p info);

call_graph_sharp_impl ::
  forall a b c d e.
    (Eq d) => Lts_impl a b c (Sharp d) e -> [(Sharp d, Sharp d)];
call_graph_sharp_impl r =
  remdups
    (concatMap
      (\ tau ->
        (if is_sharp (source (snd tau))
          then [(source (snd tau), target (snd tau))] else []))
      (transitions_impl r));

scc_decomposition ::
  forall a b c d e.
    (Ccompare d, Eq d, Key d,
      Showa d) => Lts_impl a b c (Sharp d) e ->
                    [[Sharp d]] ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        [Lts_impl a b c (Sharp d) e];
scc_decomposition cp sccs_info =
  let {
    cg = call_graph_sharp_impl cp;
    sccs = scc_decomp cg;
  } in bindb (catch_errora
               (forallM
                 (\ c ->
                   check (any (\ d -> set_eq (set c) (set d)) sccs_info)
                     ((shows_prec_list zero_nat
                         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                           'i', 'n', 'd', ' ', 'S', 'C', 'C', ' '] .
                        shows_prec_list zero_nat c) .
                       shows_prec_list zero_nat
                         [' ', 'i', 'n', ' ', 'p', 'r', 'o', 'v', 'i', 'd', 'e',
                           'd', ' ', 'd', 'e', 'c', 'o', 'm', 'p', 'o', 's',
                           'i', 't', 'i', 'o', 'n']))
                 sccs)
               (\ x -> Inl (snd x)))
         (\ _ ->
           let {
             trans = transitions_impl cp;
             (sharp, flat) =
               partition (\ tau -> is_sharp (source (snd tau))) trans;
             cPs = map (\ c ->
                         let {
                           l = set c;
                         } in Lts_Impl (initiala cp)
                                (flat ++
                                  filter
                                    (\ tau ->
                                      member (source (snd tau)) l &&
member (target (snd tau)) l)
                                    sharp)
                                (assertion_impl cp))
                     sccs_info;
           } in catch_errora (Inr cPs)
                  (\ x ->
                    Inl (((shows_prec_list zero_nat
                             ['e', 'r', 'r', 'o', 'r', ' ', 'i', 's', ' ', 'S',
                               'C', 'C', '-', 'd', 'e', 'c', 'o', 'm', 'p', 'o',
                               's', 'i', 't', 'i', 'o', 'n', ' ', 'w', '.', 'r',
                               '.', 't', '.', ' ', 's', 'c', 'c', 's', '_', 'i',
                               'n', 'f', 'o'] .
                            shows_prec_list zero_nat sccs_info) .
                           shows_nl) .
                          x)));

cut_transition_split ::
  forall a b c d e.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Ccompare e, Eq e,
      Showa e) => Cut_transition_split_info a ->
                    Lts_impl b c d (Sharp e) a ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        [Lts_impl b c d (Sharp e) a];
cut_transition_split (Cut_Transition_Split_Info ct_ids) cp =
  catch_errora
    (let {
       (p, r) =
         partition ((\ tau -> is_sharp (source tau)) . snd)
           (transitions_impl cp);
       (ct, rr) = partition ((is_sharp . target) . snd) r;
       slist = map (source . snd) p;
       s = set slist;
       cT_ids = set (concat ct_ids);
     } in bindb (catch_errora
                  (forallM
                    (\ l ->
                      check (not (is_sharp l))
                        ((shows_prec_list zero_nat
                            ['i', 'n', 'i', 't', 'i', 'a', 'l', ' ', 's', 't',
                              'a', 't', 'e', ' '] .
                           shows_prec_sharp zero_nat l) .
                          shows_prec_list zero_nat
                            [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                              'b', 'e', ' ', 's', 'h', 'a', 'r', 'p', 'e',
                              'd']))
                    (initiala cp))
                  (\ x -> Inl (snd x)))
            (\ _ ->
              bindb (catch_errora
                      (forallM
                        (\ (t_id, cta) ->
                          check (if member (target cta) s
                                  then member t_id cT_ids else True)
                            (((shows_prec_list zero_nat
                                 ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                                   'i', 'n', 'd', ' ', 'c', 'u', 't', '-', 't',
                                   'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n',
                                   ' '] .
                                shows_prec zero_nat t_id) .
                               shows_prec_list zero_nat
                                 [' ', 'i', 'n', ' ', 'p', 'a', 'r', 't', 'i',
                                   't', 'i', 'o', 'n', '\n', 'r', 'e', 'l', 'e',
                                   'v', 'a', 'n', 't', ' ', 'c', 'u', 't', '-',
                                   'p', 'o', 'i', 'n', 't', 's', ' ', 'a', 'r',
                                   'e', ':', ' ']) .
                              shows_prec_list zero_nat slist))
                        ct)
                      (\ x -> Inl (snd x)))
                (\ _ ->
                  let {
                    rrp = rr ++ p;
                  } in Inr (map (\ ct_idsa ->
                                  Lts_Impl (initiala cp)
                                    (filter (\ cta -> membera ct_idsa (fst cta))
                                       ct ++
                                      rrp)
                                    (assertion_impl cp))
                             ct_ids))))
    (\ x ->
      Inl (shows_prec_list zero_nat
             ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 's', 'p', 'l', 'i',
               't', 't', 'i', 'n', 'g', ' ', 'c', 'u', 't', ' ', 't', 'r', 'a',
               'n', 's', 'i', 't', 'i', 'o', 'n', 's', ' ', 'o', 'n', ' ', 'L',
               'T', 'S', '\n'] .
            x));

shows_cooperation_program ::
  forall a b c d e.
    (Showa d,
      Showa e) => Lts_impl a b c (Sharp d) e ->
                    [Prelude.Char] -> [Prelude.Char];
shows_cooperation_program (Lts_Impl i tran lc) =
  let {
    trana = filter (\ (_, tt) -> is_sharp (target tt)) tran;
    tranb = let {
              (ss, fs) = partition (\ (_, tt) -> is_sharp (source tt)) trana;
            } in fs ++ ss;
  } in shows_prec_list zero_nat
         ['C', 'o', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r',
           'o', 'g', 'r', 'a', 'm', ' ', '(', 'o', 'n', 'l', 'y', ' ', 's', 'h',
           'a', 'r', 'p', '-', 'p', 'a', 'r', 't', ')', '\n'] .
         shows_sep
           (\ (t, tt) ->
             (((shows_prec zero_nat t . shows_prec_list zero_nat [':', ' ']) .
                shows_prec_sharp zero_nat (source tt)) .
               shows_prec_list zero_nat [' ', '-', '-', '>', ' ']) .
               shows_prec_sharp zero_nat (target tt))
           shows_nl tranb .
    shows_nl;

check_cooperation_proof ::
  forall a b c d e f g.
    (Ccompare a, Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d,
      Showa d, Ccompare e, Eq e, Showa e, Ccompare f, Eq f, Key f, Showa f,
      Ceq g, Ccompare g, Eq g, Mapping_impl g, Set_impl g,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (d -> Formula (Term a (Trans_var e, b)) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                          (Term a (Trans_var e, b) ->
                            [Prelude.Char] -> [Prelude.Char]) ->
                            (Term a (e, b) -> Formula (Term a (e, b))) ->
                              (Term a (Trans_var e, b) ->
                                Formula (Term a (Trans_var e, b))) ->
                                (Trans_var e ->
                                  b -> Formula (Term a (Trans_var e, b)) ->
 Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                  b -> (Term a (Trans_var e, b) ->
 Term a (Trans_var e, b) -> Formula (Term a (Trans_var e, b))) ->
 (Term a (Trans_var e, b) ->
   Term a (Trans_var e, b) -> Formula (Term a (Trans_var e, b))) ->
   (Term a (Trans_var e, b) -> Bool) ->
     ([Prelude.Char] -> [Prelude.Char]) ->
       Nat ->
         Lts_impl a e b (Sharp f) g ->
           Cooperation_proof a e b f g d ->
             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
  less_eq_formula less_formula is_constant pre i cPi
  (Cut_Transition_Split scc_proofs) =
  debug ((pre . shows_prec_nat zero_nat i) [])
    ['C', 'u', 't', ' ', 'T', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' ',
      'S', 'p', 'l', 'i', 't']
    (bindb
      (catch_errora
        (cut_transition_split (Cut_Transition_Split_Info (map fst scc_proofs))
          cPi)
        (\ x ->
          Inl ((((pre . shows_prec_nat zero_nat i) .
                  shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                      'u', 't', '-', 't', 'r', 'a', 'n', 's', 'i', 't', 'i',
                      'o', 'n', ' ', 's', 'p', 'l', 'i', 't', '\n']) .
                 shows_cooperation_program cPi) .
                x)))
      (\ sccs ->
        catch_errora
          (forallM_index
            (\ (scc, prof) j ->
              catch_errora
                (check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker
                  dom_type less_eq_formula less_formula is_constant
                  ((((pre . shows_prec_nat zero_nat i) .
                      shows_prec_list zero_nat ['.']) .
                     shows_prec_nat zero_nat (suc j)) .
                    shows_prec_list zero_nat ['.'])
                  one_nat scc prof)
                (\ x ->
                  Inl (((pre . shows_prec_nat zero_nat i) .
                         shows_prec_list zero_nat
                           [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                             'l', 'o', 'w', ' ', 'c', 'u', 't', '-', 't', 'r',
                             'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' ', 's',
                             'p', 'l', 'i', 't', '\n']) .
                        x)))
            (zip sccs (map snd scc_proofs)))
          (\ x -> Inl (snd x))));
check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
  less_eq_formula less_formula is_constant pre i cPi (Scc_Decomp scc_proofs) =
  debug ((pre . shows_prec_nat zero_nat i) [])
    ['S', 'C', 'C', ' ', 'D', 'e', 'c', 'o', 'm', 'p']
    (bindb
      (catch_errora (scc_decomposition cPi (map fst scc_proofs))
        (\ x ->
          Inl ((((pre . shows_prec_nat zero_nat i) .
                  shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'S',
                      'c', 'c', ' ', 'd', 'e', 'c', 'o', 'm', 'p', 'o', 's',
                      'i', 't', 'i', 'o', 'n', '\n']) .
                 shows_cooperation_program cPi) .
                x)))
      (\ sccs ->
        catch_errora
          (forallM_index
            (\ (scc, prof) j ->
              catch_errora
                (check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker
                  dom_type less_eq_formula less_formula is_constant
                  ((((pre . shows_prec_nat zero_nat i) .
                      shows_prec_list zero_nat ['.']) .
                     shows_prec_nat zero_nat (suc j)) .
                    shows_prec_list zero_nat ['.'])
                  one_nat scc prof)
                (\ x ->
                  Inl (((pre . shows_prec_nat zero_nat i) .
                         shows_prec_list zero_nat
                           [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                             'l', 'o', 'w', ' ', 'S', 'c', 'c', ' ', 'd', 'e',
                             'c', 'o', 'm', 'p', 'o', 's', 'i', 't', 'i', 'o',
                             'n', '\n']) .
                        x)))
            (zip sccs (map snd scc_proofs)))
          (\ x -> Inl (snd x))));
check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
  less_eq_formula less_formula is_constant pre i cPi
  (Fresh_Variable_Addition info iproof) =
  debug ((pre . shows_prec_nat zero_nat i) [])
    ['F', 'r', 'e', 's', 'h', ' ', 'V', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ',
      'A', 'd', 'd', 'i', 't', 'i', 'o', 'n']
    (bindb
      (catch_errora (fresh_variable_addition lambda def_checker sa2 cPi info)
        (\ x ->
          Inl ((((pre . shows_prec_nat zero_nat i) .
                  shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'f',
                      'r', 'e', 's', 'h', ' ', 'v', 'a', 'r', 'i', 'a', 'b',
                      'l', 'e', ' ', 'a', 'd', 'd', 'i', 't', 'i', 'o', 'n',
                      '\n']) .
                 shows_cooperation_program cPi) .
                x)))
      (\ q ->
        catch_errora
          (check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker
            dom_type less_eq_formula less_formula is_constant pre
            (plus_nat i one_nat) q iproof)
          (\ x ->
            Inl (((pre . shows_prec_nat zero_nat i) .
                   shows_prec_list zero_nat
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                       'o', 'w', ' ', 'f', 'r', 'e', 's', 'h', ' ', 'v', 'a',
                       'r', 'i', 'a', 'b', 'l', 'e', ' ', 'a', 'd', 'd', 'i',
                       't', 'i', 'o', 'n', '\n']) .
                  x))));
check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
  less_eq_formula less_formula is_constant pre i cPi
  (Location_Addition info iproof) =
  debug ((pre . shows_prec_nat zero_nat i) [])
    ['L', 'o', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'A', 'd', 'd', 'i', 't', 'i',
      'o', 'n']
    (bindb
      (catch_errora (location_addition lambda tc sa ne cPi info)
        (\ x ->
          Inl (((pre .
                  shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'l',
                      'o', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'a', 'd', 'd',
                      'i', 't', 'i', 'o', 'n', '\n']) .
                 shows_cooperation_program cPi) .
                x)))
      (\ q ->
        catch_errora
          (check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker
            dom_type less_eq_formula less_formula is_constant pre
            (plus_nat i one_nat) q iproof)
          (\ x ->
            Inl (((pre . shows_prec_nat zero_nat i) .
                   shows_prec_list zero_nat
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                       'o', 'w', ' ', 'l', 'o', 'c', 'a', 't', 'i', 'o', 'n',
                       ' ', 'a', 'd', 'd', 'i', 't', 'i', 'o', 'n', '\n']) .
                  x))));
check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
  less_eq_formula less_formula is_constant pre i cPi
  (Transition_Removal info iproof) =
  debug ((pre . shows_prec_nat zero_nat i) [])
    ['T', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' ', 'R', 'e', 'm', 'o',
      'v', 'a', 'l']
    (bindb
      (catch_errora
        (lex_processor lambda tc2 sa2 ne2 dom_type less_eq_formula less_formula
          is_constant info cPi)
        (\ x ->
          Inl ((((pre . shows_prec_nat zero_nat i) .
                  shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 't',
                      'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' ', 'r',
                      'e', 'm', 'o', 'v', 'a', 'l', '\n']) .
                 shows_cooperation_program cPi) .
                x)))
      (\ cPia ->
        catch_errora
          (check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker
            dom_type less_eq_formula less_formula is_constant pre
            (plus_nat i one_nat) cPia iproof)
          (\ x ->
            Inl (((pre . shows_prec_nat zero_nat i) .
                   shows_prec_list zero_nat
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                       'o', 'w', ' ', 't', 'r', 'a', 'n', 's', 'i', 't', 'i',
                       'o', 'n', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l',
                       '\n']) .
                  x))));
check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
  less_eq_formula less_formula is_constant pre i cPi
  (Invariants_Update iproof cproof) =
  debug ((pre . shows_prec_nat zero_nat i) [])
    ['I', 'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', 's', '_', 'U', 'p', 'd', 'a',
      't', 'e']
    (bindb
      (catch_errora
        (invariant_proof_checker lambda tc tc2 sa sa2 ne ne2 cPi iproof)
        (\ x ->
          Inl ((((pre . shows_prec_nat zero_nat i) .
                  shows_prec_list zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'i',
                      'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', ' ', 'u', 'p',
                      'd', 'a', 't', 'e', '\n']) .
                 shows_cooperation_program cPi) .
                x)))
      (\ ia ->
        bindb (fix_invariants cPi ia)
          (\ q ->
            catch_errora
              (check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker
                dom_type less_eq_formula less_formula is_constant pre
                (plus_nat i one_nat) q cproof)
              (\ x ->
                Inl (((pre . shows_prec_nat zero_nat i) .
                       shows_prec_list zero_nat
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 'i', 'n', 'v', 'a', 'r', 'i', 'a',
                           'n', 't', ' ', 'u', 'p', 'd', 'a', 't', 'e', '\n']) .
                      x)))));
check_cooperation_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
  less_eq_formula less_formula is_constant pre i cPi Triviala =
  debug ((pre . shows_prec_nat zero_nat i) [])
    ['T', 'r', 'i', 'v', 'i', 'a', 'l', ' ', 'C', 'P']
    (catch_errora (trivial_termination_checker sa sa2 cPi)
      (\ x ->
        Inl (((pre . shows_prec_nat zero_nat i) .
               shows_prec_list zero_nat
                 [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 't',
                   'r', 'i', 'v', 'i', 'a', 'l', ' ', 'c', 'o', 'o', 'p', 'e',
                   'r', 'a', 't', 'i', 'o', 'n', ' ', 't', 'e', 'r', 'm', 'i',
                   'n', 'a', 't', 'i', 'o', 'n', ' ', 'c', 'h', 'e', 'c', 'k',
                   'e', 'r', '\n']) .
              x)));

check_exists_cut ::
  forall a b c d e.
    (Default a, Showa a, Eq b, Showa b, Eq c, Showa c, Eq d, Showa d, Eq e,
      Showa e) => (a -> Formula (Term b (c, d)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    (Term b (c, d) -> [Prelude.Char] -> [Prelude.Char]) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        [Transition_rule b c d (Sharp e)] ->
                          e -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_exists_cut logic_checker shows_atom negate_atom taus n =
  check (any (\ tau ->
               equal_sharp (source tau) (Flat n) &&
                 equal_sharp (target tau) (Sharpa n) &&
                   isOK (check_skip_transition logic_checker shows_atom
                          negate_atom tau))
          taus)
    (shows_prec_list zero_nat
      (['m', 'i', 's', 's', 'i', 'n', 'g', ' ', 's', 'k', 'i', 'p', ' ', 't',
         'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r',
         ' '] ++
        shows_prec zero_nat n []));

sharp_transition ::
  forall a b c d. Transition_rule a b c d -> Transition_rule a b c (Sharp d);
sharp_transition (Transition l r phi) = Transition (Sharpa l) (Sharpa r) phi;

flat_transition ::
  forall a b c d. Transition_rule a b c d -> Transition_rule a b c (Sharp d);
flat_transition (Transition l r phi) = Transition (Flat l) (Flat r) phi;

make_copy_prog ::
  forall a b c d e.
    Lts_impl a b c d e ->
      [(Sharp e, Transition_rule a b c (Sharp d))] ->
        Lts_impl a b c (Sharp d) (Sharp e);
make_copy_prog (Lts_Impl init tau_s lc) cutpoints =
  Lts_Impl (map Flat init)
    (map (\ (tr, tau) -> (Flat tr, flat_transition tau)) tau_s ++
      cutpoints ++ map (\ (tr, tau) -> (Sharpa tr, sharp_transition tau)) tau_s)
    (map (\ (tr, a) -> (Flat tr, a)) lc ++
      map (\ (tr, a) -> (Sharpa tr, a)) lc);

call_graph_impl :: forall a b c d e. (Eq d) => Lts_impl a b c d e -> [(d, d)];
call_graph_impl r =
  remdups
    (map (\ tau -> (source (snd tau), target (snd tau))) (transitions_impl r));

check_cut_points ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => [(a, a)] ->
                    Set a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cut_points r x =
  check_acyclic
    (filter (\ ab -> not (member (fst ab) x) && not (member (snd ab) x)) r);

natural :: forall a. Sharp a -> a;
natural (Sharpa l) = l;
natural (Flat l) = l;

create_initial_cp_prog ::
  forall a b c d e f g.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d, Showa d, Eq e,
      Showa e, Ceq f, Ccompare f, Eq f, Key f, Set_impl f, Showa f,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                        (Term a (e, b) -> Formula (Term a (e, b))) ->
                          Lts_impl a e b f g ->
                            [[(Sharp g, Transition_rule a e b (Sharp f))]] ->
                              Sum ([Prelude.Char] -> [Prelude.Char])
                                [Lts_impl a e b (Sharp f) (Sharp g)];
create_initial_cp_prog lambda logic_checker shows_atom negate_atom p
  cp_trans_list =
  (case let {
          cp_trans = concat cp_trans_list;
          cut_points =
            remdups (map (\ (_, tau) -> natural (source tau)) cp_trans);
        } in bindb (catch_errora
                     (check_cut_points (call_graph_impl p) (set cut_points))
                     (\ x ->
                       Inl (shows_prec_list zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n',
                                ' ', 'e', 'n', 's', 'u', 'r', 'i', 'n', 'g',
                                ' ', 'v', 'a', 'l', 'i', 'd', 'i', 't', 'y',
                                ' ', 'o', 'f', ' ', 'c', 'u', 't', 'p', 'o',
                                'i', 'n', 't', 's', '\n'] .
                             x)))
               (\ _ ->
                 bindb (catch_errora
                         (forallM
                           (\ (n, cp) ->
                             check (transition_rule lambda cp)
                               (shows_prec_sharp zero_nat n .
                                 shows_prec_list zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 'n', ' ', 'v',
                                     'a', 'l', 'i', 'd', ' ', 't', 'r', 'a',
                                     'n', 's', 'i', 't', 'i', 'o', 'n', ' ',
                                     'r', 'u', 'l', 'e']))
                           cp_trans)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     catch_errora
                       (forallM
                         (check_exists_cut logic_checker shows_atom negate_atom
                           (map snd cp_trans))
                         cut_points)
                       (\ x -> Inl (snd x))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (map (make_copy_prog p) cp_trans_list);
  });

check_termination_proof ::
  forall a b c d e f g.
    (Ccompare a, Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d,
      Showa d, Ccompare e, Eq e, Showa e, Cenum f, Ceq f, Ccompare f, Eq f,
      Key f, Mapping_impl f, Set_impl f, Showa f, Ceq g, Ccompare g, Eq g,
      Mapping_impl g, Set_impl g,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (d -> Formula (Term a (Trans_var e, b)) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                          (Term a (Trans_var e, b) ->
                            [Prelude.Char] -> [Prelude.Char]) ->
                            (Term a (e, b) -> Formula (Term a (e, b))) ->
                              (Term a (Trans_var e, b) ->
                                Formula (Term a (Trans_var e, b))) ->
                                (Trans_var e ->
                                  b -> Formula (Term a (Trans_var e, b)) ->
 Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                  b -> (Term a (Trans_var e, b) ->
 Term a (Trans_var e, b) -> Formula (Term a (Trans_var e, b))) ->
 (Term a (Trans_var e, b) ->
   Term a (Trans_var e, b) -> Formula (Term a (Trans_var e, b))) ->
   (Term a (Trans_var e, b) -> Bool) ->
     ([Prelude.Char] -> [Prelude.Char]) ->
       Nat ->
         Lts_impl a e b f g ->
           Termination_proof a e b f g d ->
             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_termination_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
  less_eq_formula less_formula is_constant pre i pi (Via_Cooperation cp_proofs)
  = debug (pre [])
      ['S', 'w', 'i', 't', 'c', 'h', ' ', 't', 'o', ' ', 'C', 'o', 'o', 'p',
        'e', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'P', 'r', 'o', 'g', 'r', 'a',
        'm']
      (bindb
        (catch_errora
          (create_initial_cp_prog lambda tc sa ne pi (map fst cp_proofs))
          (\ x ->
            Inl (((pre . shows_prec_nat zero_nat i) .
                   shows_prec_list zero_nat
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       'c', 'r', 'e', 'a', 't', 'i', 'n', 'g', ' ', 'i', 'n',
                       'i', 't', 'i', 'a', 'l', ' ', 'c', 'o', 'o', 'p', 'e',
                       'r', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'g',
                       'r', 'a', 'm', '\n']) .
                  x)))
        (\ cPi ->
          catch_errora
            (forallM_index
              (\ (r, prf) _ ->
                catch_errora
                  (check_cooperation_proof lambda tc tc2 sa sa2 ne ne2
                    def_checker dom_type less_eq_formula less_formula
                    is_constant pre (suc i) r prf)
                  (\ x ->
                    Inl (((pre . shows_prec_nat zero_nat i) .
                           shows_prec_list zero_nat
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 's', 'w', 'i', 't', 'c', 'h',
                               'i', 'n', 'g', ' ', 't', 'o', ' ', 'i', 'n', 'i',
                               't', 'i', 'a', 'l', ' ', 'c', 'o', 'o', 'p', 'e',
                               'r', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o',
                               'g', 'r', 'a', 'm', '\n']) .
                          x)))
              (zip cPi (map snd cp_proofs)))
            (\ x -> Inl (snd x))));
check_termination_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
  less_eq_formula less_formula is_constant pre i pi
  (Invariants_Update_LTS iproof cproof) =
  debug (pre [])
    ['I', 'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', ' ', 'U', 'p', 'd', 'a', 't',
      'e']
    (bindb
      (catch_errora
        (invariant_proof_checker lambda tc tc2 sa sa2 ne ne2 pi iproof)
        (\ x ->
          Inl (((pre . shows_prec_nat zero_nat i) .
                 shows_prec_list zero_nat
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'i',
                     'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', ' ', 'u', 'p', 'd',
                     'a', 't', 'e', '\n']) .
                x)))
      (\ ia ->
        bindb (fix_invariants pi ia)
          (\ q ->
            catch_errora
              (check_termination_proof lambda tc tc2 sa sa2 ne ne2 def_checker
                dom_type less_eq_formula less_formula is_constant pre
                (plus_nat i one_nat) q cproof)
              (\ x ->
                Inl (((pre . shows_prec_nat zero_nat i) .
                       shows_prec_list zero_nat
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 'i', 'n', 'v', 'a', 'r', 'i', 'a',
                           'n', 't', ' ', 'u', 'p', 'd', 'a', 't', 'e', '\n']) .
                      x)))));
check_termination_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
  less_eq_formula less_formula is_constant pre i pi Trivialb =
  debug (pre [])
    ['T', 'r', 'i', 'v', 'i', 'a', 'l', ' ', 'T', 'e', 'r', 'm', 'i', 'n', 'a',
      't', 'i', 'o', 'n']
    (catch_errora
      (check (null (transitions_impl pi))
        (shows_prec_list zero_nat
          ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' ', 'r', 'u', 'l',
            'e', 's', ' ', 'r', 'e', 'm', 'a', 'i', 'n', 's', ' ', 'a', 't',
            ' ', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ', 't', 'e', 'r', 'm',
            'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f']))
      (\ x ->
        Inl (((pre . shows_prec_nat zero_nat i) .
               shows_prec_list zero_nat
                 [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 't',
                   'r', 'i', 'v', 'i', 'a', 'l', ' ', 't', 'e', 'r', 'm', 'i',
                   'n', 'a', 't', 'i', 'o', 'n', ' ', 'c', 'h', 'e', 'c', 'k',
                   'e', 'r', '\n']) .
              x)));

checka ::
  forall a b c d e f g.
    (Ccompare a, Eq a, Showa a, Ceq b, Ccompare b, Eq b, Showa b, Default d,
      Showa d, Ccompare e, Eq e, Showa e, Cenum f, Ceq f, Ccompare f, Eq f,
      Key f, Mapping_impl f, Set_impl f, Showa f, Ceq g, Ccompare g, Eq g,
      Mapping_impl g, Set_impl g,
      Showa g) => Logic_ext a b c () ->
                    (d -> Formula (Term a (e, b)) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (d -> Formula (Term a (Trans_var e, b)) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a (e, b) -> [Prelude.Char] -> [Prelude.Char]) ->
                          (Term a (Trans_var e, b) ->
                            [Prelude.Char] -> [Prelude.Char]) ->
                            (Term a (e, b) -> Formula (Term a (e, b))) ->
                              (Term a (Trans_var e, b) ->
                                Formula (Term a (Trans_var e, b))) ->
                                (Trans_var e ->
                                  b -> Formula (Term a (Trans_var e, b)) ->
 Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                  b -> (Term a (Trans_var e, b) ->
 Term a (Trans_var e, b) -> Formula (Term a (Trans_var e, b))) ->
 (Term a (Trans_var e, b) ->
   Term a (Trans_var e, b) -> Formula (Term a (Trans_var e, b))) ->
   (Term a (Trans_var e, b) -> Bool) ->
     Lts_impl a e b f g ->
       Termination_proof a e b f g d ->
         Sum ([Prelude.Char] -> [Prelude.Char]) ();
checka lambda tc tc2 sa sa2 ne ne2 def_checker dom_type less_eq_formula
  less_formula is_constant pi prf =
  bindb (debug ['i', 'n', 'i', 't']
          ['C', 'h', 'e', 'c', 'k', ' ', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r',
            'm', 'e', 'd', 'n', 'e', 's', 's']
          (catch_errora (check_lts_impl lambda pi)
            (\ x ->
              Inl (shows_prec_list zero_nat
                     ['i', 'n', 'p', 'u', 't', ' ', 'L', 'T', 'S', ' ', 'i',
                       's', ' ', 'n', 'o', 't', ' ', 'w', 'e', 'l', 'l', '-',
                       'f', 'o', 'r', 'm', 'e', 'd'] .
                    x))))
    (\ _ ->
      check_termination_proof lambda tc tc2 sa sa2 ne ne2 def_checker dom_type
        less_eq_formula less_formula is_constant
        ((shows_prec_list ::
           Nat -> [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char])
          zero_nat [])
        one_nat pi prf);

set_impl_ty :: Phantom Ty Set_impla;
set_impl_ty = Phantom Set_RBT;

iA_Values_of_type :: Ty -> Set Val;
iA_Values_of_type BoolT = image Boola top_set;
iA_Values_of_type IntT = image Int top_set;

iA_type_of_fun :: Sig -> ([Ty], Ty);
iA_type_of_fun Less = ([IntT, IntT], BoolT);
iA_type_of_fun Lesseq = ([IntT, IntT], BoolT);
iA_type_of_fun Equals = ([IntT, IntT], BoolT);
iA_type_of_fun (Sum n) = (replicate n IntT, IntT);
iA_type_of_fun (Const uu) = ([], IntT);
iA_type_of_fun (Mult n) = (replicate n IntT, IntT);

the_bool :: Val -> Bool;
the_bool val = let {
                 (Boola x2) = val;
               } in x2;

lambda :: Logic_ext Sig Ty Val ();
lambda =
  Logic_ext iA_type_of_fun iA_Values_of_type
    (inserta BoolT (set_empty (of_phantom set_impl_ty))) the_bool i ();

def_checker_main ::
  forall a.
    (Eq a) => a -> Ty -> Term Sig (a, Ty) ->
                           Term Sig (a, Ty) ->
                             Term Sig (a, Ty) -> Term Sig (a, Ty) -> Bool;
def_checker_main x ty l1 r1 l2 r2 =
  is_bool lambda (Fun Lesseq [l1, r1]) &&
    has_type (type_of_fun lambda) r1 ty &&
      is_bool lambda (Fun Lesseq [l2, r2]) &&
        equal_term (Var (x, ty)) l1 &&
          equal_term l1 r2 &&
            equal_term l2 r1 && not (contains_var_term (x, ty) r1);

def_checker_maina ::
  forall a. (Eq a) => a -> Ty -> Term Sig (a, Ty) -> Term Sig (a, Ty) -> Bool;
def_checker_maina x ty l1 r1 =
  is_bool lambda (Fun Equals [l1, r1]) &&
    has_type (type_of_fun lambda) r1 ty &&
      equal_term (Var (x, ty)) l1 && not (contains_var_term (x, ty) r1);

def_checker_eq ::
  forall a.
    (Eq a) => a -> Ty -> Formula (Term Sig (a, Ty)) ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
def_checker_eq x ty eq =
  (case eq of {
    Atom (Var _) ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'i', 't', 'e', 'r',
              'a', 'l']);
    Atom (Fun Less _) ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'i', 't', 'e', 'r',
              'a', 'l']);
    Atom (Fun Lesseq _) ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'i', 't', 'e', 'r',
              'a', 'l']);
    Atom (Fun (Sum _) _) ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'i', 't', 'e', 'r',
              'a', 'l']);
    Atom (Fun (Const _) _) ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'i', 't', 'e', 'r',
              'a', 'l']);
    Atom (Fun (Mult _) _) ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'i', 't', 'e', 'r',
              'a', 'l']);
    Atom (Fun Equals []) ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'i', 't', 'e', 'r',
              'a', 'l']);
    Atom (Fun Equals [_]) ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'i', 't', 'e', 'r',
              'a', 'l']);
    Atom (Fun Equals [l1, r1]) ->
      check (def_checker_maina x ty l1 r1 || def_checker_maina x ty r1 l1)
        (shows_prec_list zero_nat
          ['N', 'o', 'n', '-', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' ', 'n',
            'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']);
    Atom (Fun Equals (_ : _ : _ : _)) ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'l', 'i', 't', 'e', 'r',
              'a', 'l']);
    NegAtom _ ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'l', 'a', 'u', 's',
              'e']);
    Conjunction _ ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'l', 'a', 'u', 's',
              'e']);
    Disjunction _ ->
      Inl (shows_prec_list zero_nat
            ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'c', 'l', 'a', 'u', 's',
              'e']);
  });

def_checker ::
  forall a.
    (Eq a,
      Showa a) => a -> Ty -> Formula (Term Sig (a, Ty)) ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
def_checker x ty phi =
  catch_errora
    (case phi of {
      Atom _ -> def_checker_eq x ty phi;
      NegAtom _ -> def_checker_eq x ty phi;
      Conjunction [] -> Inr ();
      Conjunction [eq] -> def_checker_eq x ty eq;
      Conjunction [Atom (Var _), _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'l',
                'i', 't', 'e', 'r', 'a', 'l']);
      Conjunction [Atom (Fun Less _), _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'l',
                'i', 't', 'e', 'r', 'a', 'l']);
      Conjunction [Atom (Fun Lesseq []), _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'l',
                'i', 't', 'e', 'r', 'a', 'l']);
      Conjunction [Atom (Fun Lesseq [_]), _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'l',
                'i', 't', 'e', 'r', 'a', 'l']);
      Conjunction [Atom (Fun Lesseq [l1, r1]), lt2] ->
        (case lt2 of {
          Atom (Var _) ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'l', 'i', 't', 'e', 'r', 'a', 'l']);
          Atom (Fun Less _) ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'l', 'i', 't', 'e', 'r', 'a', 'l']);
          Atom (Fun Lesseq []) ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'l', 'i', 't', 'e', 'r', 'a', 'l']);
          Atom (Fun Lesseq [_]) ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'l', 'i', 't', 'e', 'r', 'a', 'l']);
          Atom (Fun Lesseq [l2, r2]) ->
            check (def_checker_main x ty l1 r1 l2 r2 ||
                    def_checker_main x ty l2 r2 l1 r1)
              (shows_prec_list zero_nat
                ['N', 'o', 'n', '-', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
                  ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
                  'e', 'd']);
          Atom (Fun Lesseq (_ : _ : _ : _)) ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'l', 'i', 't', 'e', 'r', 'a', 'l']);
          Atom (Fun (Sum _) _) ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'l', 'i', 't', 'e', 'r', 'a', 'l']);
          Atom (Fun (Const _) _) ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'l', 'i', 't', 'e', 'r', 'a', 'l']);
          Atom (Fun (Mult _) _) ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'l', 'i', 't', 'e', 'r', 'a', 'l']);
          Atom (Fun Equals _) ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'l', 'i', 't', 'e', 'r', 'a', 'l']);
          NegAtom _ ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'c', 'l', 'a', 'u', 's', 'e']);
          Conjunction _ ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'c', 'l', 'a', 'u', 's', 'e']);
          Disjunction _ ->
            Inl (shows_prec_list zero_nat
                  ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '2', 'n', 'd', ' ',
                    'c', 'l', 'a', 'u', 's', 'e']);
        });
      Conjunction [Atom (Fun Lesseq (_ : _ : _ : _)), _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'l',
                'i', 't', 'e', 'r', 'a', 'l']);
      Conjunction [Atom (Fun (Sum _) _), _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'l',
                'i', 't', 'e', 'r', 'a', 'l']);
      Conjunction [Atom (Fun (Const _) _), _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'l',
                'i', 't', 'e', 'r', 'a', 'l']);
      Conjunction [Atom (Fun (Mult _) _), _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'l',
                'i', 't', 'e', 'r', 'a', 'l']);
      Conjunction [Atom (Fun Equals _), _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'l',
                'i', 't', 'e', 'r', 'a', 'l']);
      Conjunction [NegAtom _, _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'c',
                'l', 'a', 'u', 's', 'e']);
      Conjunction [Conjunction _, _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'c',
                'l', 'a', 'u', 's', 'e']);
      Conjunction [Disjunction _, _] ->
        Inl (shows_prec_list zero_nat
              ['I', 'n', 'v', 'a', 'l', 'i', 'd', ' ', '1', 's', 't', ' ', 'c',
                'l', 'a', 'u', 's', 'e']);
      Conjunction (_ : _ : _ : _) ->
        Inl (shows_prec_list zero_nat
              ['C', 'o', 'n', 'j', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'o',
                'f', ' ', 'm', 'o', 'r', 'e', ' ', 't', 'h', 'a', 'n', ' ', 't',
                'w', 'o']);
      Disjunction _ -> def_checker_eq x ty phi;
    })
    (\ xa ->
      Inl (((((shows_prec_list zero_nat
                 ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'd', 'e', 'f',
                   'i', 'n', 'i', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'c', 'h',
                   'e', 'c', 'k', 'e', 'r', ' ', 'f', 'o', 'r', ' '] .
                shows_prec zero_nat x) .
               shows_prec_list zero_nat
                 [' ', 'o', 'n', ' ', 'f', 'o', 'r', 'm', 'u', 'l', 'a', '\n',
                   ' ', ' ']) .
              shows_formula show_IA_exp phi) .
             shows_nl) .
            xa));

is_constant :: forall a b. Term a b -> Bool;
is_constant (Fun uu []) = True;
is_constant (Var v) = False;
is_constant (Fun v (vb : vc)) = False;

poly_minus ::
  forall a b.
    (Eq a, Eq b,
      Ring_1 b) => [([(a, Nat)], b)] -> [([(a, Nat)], b)] -> [([(a, Nat)], b)];
poly_minus f g = poly_add f (poly_mult (poly_const (uminus onea)) g);

poly_one :: forall a b. (One b) => [([(a, Nat)], b)];
poly_one = [([], onea)];

iA_exp_to_poly_constraint ::
  forall a. (Eq a) => Term Sig (a, Ty) -> Poly_constraint a;
iA_exp_to_poly_constraint (Fun Lesseq [a, b]) =
  Poly_Ge (poly_minus (iA_exp_to_poly b) (iA_exp_to_poly a));
iA_exp_to_poly_constraint (Fun Equals [a, b]) =
  Poly_Eq (poly_minus (iA_exp_to_poly b) (iA_exp_to_poly a));
iA_exp_to_poly_constraint (Fun Less [a, b]) =
  Poly_Ge
    (poly_minus (poly_minus (iA_exp_to_poly b) (iA_exp_to_poly a)) poly_one);

shows_poly_constraint ::
  forall a. (Showa a) => Poly_constraint a -> [Prelude.Char] -> [Prelude.Char];
shows_poly_constraint (Poly_Ge p) =
  shows_poly p . shows_prec_list zero_nat [' ', '>', '=', ' ', '0'];
shows_poly_constraint (Poly_Eq p) =
  shows_poly p . shows_prec_list zero_nat [' ', '=', ' ', '0'];

translate_atom :: forall a. Formula a -> a;
translate_atom (Atom e) = e;

translate_atoms :: forall a. [Formula a] -> [a];
translate_atoms = map translate_atom;

translate_conj :: forall a. Formula a -> [a];
translate_conj (Conjunction phi_s) = translate_atoms phi_s;

poly_is_negative_constant ::
  forall a.
    (Eq a,
      Showa a) => [([(a, Nat)], Int)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
poly_is_negative_constant f =
  catch_errora
    (bindb
      (check (null (poly_vars_list f))
        (shows_prec_list zero_nat
          ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 's', ' ',
            'n', 'o', 't', ' ', 'a', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n',
            't']))
      (\ _ ->
        check (less_int (eval_poly (\ _ -> zero_int) f) zero_int)
          (shows_prec_list zero_nat
            ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 's',
              ' ', 'n', 'o', 't', ' ', 'a', ' ', 'n', 'e', 'g', 'a', 't', 'i',
              'v', 'e', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n', 't'])))
    (\ x ->
      Inl ((((shows_prec_list zero_nat
                ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 't', 'h',
                  'a', 't', ' '] .
               shows_poly f) .
              shows_prec_list zero_nat
                [' ', 'i', 's', ' ', 'a', ' ', 'n', 'e', 'g', 'a', 't', 'i',
                  'v', 'e', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n', 't']) .
             shows_nl) .
            x));

vars_poly_constraint_list :: forall a. (Eq a) => Poly_constraint a -> [a];
vars_poly_constraint_list (Poly_Ge p) = poly_vars_list p;
vars_poly_constraint_list (Poly_Eq p) = poly_vars_list p;

zero_linear_poly :: Linear_poly;
zero_linear_poly = LinearPoly zeroa;

ipoly_to_linear_poly ::
  forall a. (a -> Nat) -> [([(a, Nat)], Int)] -> Maybe (Linear_poly, Int);
ipoly_to_linear_poly rho [] = Just (zero_linear_poly, zero_int);
ipoly_to_linear_poly rho ((mon, c) : rest) =
  bind (ipoly_to_linear_poly rho rest)
    (\ (p, d) ->
      (case mon of {
        [] -> Just (p, plus_int c d);
        [(x, n)] ->
          (if equal_nat n one_nat
            then Just (plus_linear_poly (lp_monom (of_int c) (rho x)) p, d)
            else Nothing);
        (_, _) : _ : _ -> Nothing;
      }));

to_simplex_constraint ::
  forall a. (a -> Nat) -> Poly_constraint a -> [Constraint];
to_simplex_constraint rho (Poly_Ge p) =
  (case ipoly_to_linear_poly rho p of {
    Nothing -> [];
    Just (q, c) -> [GEQ q (of_int (uminus_int c))];
  });
to_simplex_constraint rho (Poly_Eq p) =
  (case ipoly_to_linear_poly rho p of {
    Nothing -> [];
    Just (q, c) -> [EQa q (of_int (uminus_int c))];
  });

unsat_via_simplex ::
  forall a.
    (Ccompare a, Eq a, Mapping_impl a, Showa a) => [Poly_constraint a] -> Bool;
unsat_via_simplex les =
  let {
    vs = remdups (concatMap vars_poly_constraint_list les);
    ren_map = of_alist (zip vs (upt zero_nat (size_list vs)));
    ren_fun = (\ v -> (case lookupb ren_map v of {
                        Nothing -> zero_nat;
                        Just n -> n;
                      }));
    cs = concatMap (to_simplex_constraint ren_fun) les;
  } in is_none (simplex cs);

unsat_checker ::
  forall a.
    (Ccompare a, Eq a, Mapping_impl a, Linorder a,
      Showa a) => Hints ->
                    [Poly_constraint a] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
unsat_checker hints cnjs =
  catch_errora
    (case hints of {
      Hints coeffs ->
        or_ok (poly_is_negative_constant (apply_hint (zero_int : coeffs) cnjs))
          (poly_is_negative_constant
            (apply_hint (Int_of_integer (1 :: Integer) : coeffs) cnjs));
      Simplex ->
        check (unsat_via_simplex cnjs)
          (shows_prec_list zero_nat
            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'u', 's', 'e',
              ' ', 's', 'i', 'm', 'p', 'l', 'e', 'x', ' ', 'a', 'l', 'g', 'o',
              'r', 'i', 't', 'h', 'm', ' ', 't', 'o', ' ', 'p', 'r', 'o', 'v',
              'e', ' ', 'u', 'n', 's', 'a', 't', 'i', 's', 'f', 'i', 'a', 'b',
              'i', 'l', 'i', 't', 'y']);
    })
    (\ x ->
      Inl (((((shows_prec_list zero_nat
                 ['T', 'h', 'e', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'i',
                   'n', 'e', 'q', 'u', 'a', 'l', 'i', 't', 'i', 'e', 's', '\n',
                   ' ', ' '] .
                shows_sep shows_poly_constraint
                  (shows_prec_list zero_nat ['\n', ' ', ' ']) cnjs) .
               shows_prec_list zero_nat
                 ['\n', 'c', 'a', 'n', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'p',
                   'r', 'o', 'v', 'e', 'd', ' ', 'u', 'n', 's', 'a', 't', 'i',
                   's', 'f', 'i', 'a', 'b', 'l', 'e', ' ', 'v', 'i', 'a', ' ',
                   'h', 'i', 'n', 't', 's', '\n', ' ', ' ']) .
              shows_prec_hints zero_nat hints) .
             shows_nl) .
            x));

check_clause ::
  forall a.
    (Ccompare a, Eq a, Mapping_impl a, Linorder a,
      Showa a) => Hints ->
                    Formula (Term Sig (a, Ty)) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_clause hints phi =
  let {
    es = map iA_exp_to_poly_constraint (translate_conj (form_not phi));
  } in catch_errora (unsat_checker hints es)
         (\ x ->
           Inl ((((shows_prec_list zero_nat
                     ['C', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'p',
                       'r', 'o', 'v', 'e', ' ', 'u', 'n', 's', 'a', 't', 'i',
                       's', 'f', 'i', 'a', 'b', 'i', 'l', 'i', 't', 'y', ' ',
                       'o', 'f', ' ', 'I', 'A', ' ', 'c', 'o', 'n', 'j', 'u',
                       'n', 'c', 't', 'i', 'o', 'n', ' '] .
                    shows_nl) .
                   shows_list_gen shows_poly_constraint
                     ['F', 'a', 'l', 's', 'e'] [] [' ', '&', '&', ' '] [] es) .
                  shows_nl) .
                 x));

check_termination ::
  forall a b c.
    (Ccompare a, Compare a, Eq a, Mapping_impl a, Linorder a, Showa a, Cenum b,
      Ceq b, Ccompare b, Eq b, Key b, Mapping_impl b, Set_impl b, Showa b,
      Ceq c, Ccompare c, Eq c, Mapping_impl c, Set_impl c,
      Showa c) => Lts_impl Sig a Ty b c ->
                    Termination_proof Sig a Ty b c Hints ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_termination =
  checka lambda check_clause check_clause show_IA_exp show_IA_exp negatea
    negatea def_checker IntT (\ s t -> Atom (Fun Lesseq [s, t]))
    (\ s t -> Atom (Fun Less [s, t])) is_constant;

proof_to_string :: forall a b c. Proof a b c -> [Prelude.Char];
proof_to_string proof =
  (case proof of {
    TRS_Termination_Proof _ ->
      ['T', 'R', 'S', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
        'n', ' ', 'p', 'r', 'o', 'o', 'f'];
    Complexity_Proof _ ->
      ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'p', 'r', 'o',
        'o', 'f'];
    DP_Termination_Proof _ ->
      ['D', 'P', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
        ' ', 'p', 'r', 'o', 'o', 'f'];
    DP_Nontermination_Proof _ ->
      ['D', 'P', ' ', 'n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
        'i', 'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f'];
    TRS_Nontermination_Proof _ ->
      ['T', 'R', 'S', ' ', 'n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a',
        't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f'];
    FP_Termination_Proof _ ->
      ['F', 'P', ' ', 'T', 'R', 'S', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a',
        't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f'];
    Relative_TRS_Nontermination_Proof _ ->
      ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'n',
        'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
        'p', 'r', 'o', 'o', 'f'];
    TRS_Confluence_Proof _ ->
      ['T', 'R', 'S', ' ', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e',
        ' ', 'p', 'r', 'o', 'o', 'f'];
    TRS_Non_Confluence_Proof _ ->
      ['T', 'R', 'S', ' ', 'n', 'o', 'n', 'c', 'o', 'n', 'f', 'l', 'u', 'e',
        'n', 'c', 'e', ' ', 'p', 'r', 'o', 'o', 'f'];
    Completion_Proof _ ->
      ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o',
        'o', 'f'];
    Equational_Proof _ ->
      ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'p', 'r', 'o',
        'o', 'f'];
    Equational_Disproof _ ->
      ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'd', 'i', 's',
        'p', 'r', 'o', 'o', 'f'];
    Quasi_Reductive_Proof _ ->
      ['q', 'u', 'a', 's', 'i', '-', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'v',
        'e', ' ', 'p', 'r', 'o', 'o', 'f'];
    Conditional_CR_Proof _ ->
      ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'c', 'o',
        'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'p', 'r', 'o', 'o', 'f'];
    Conditional_Non_CR_Proof _ ->
      ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'n', 'o',
        'n', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'p', 'r',
        'o', 'o', 'f'];
    Tree_Automata_Closed_Proof _ ->
      ['t', 'r', 'e', 'e', ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'a', ' ',
        'c', 'l', 'o', 's', 'e', 'd', ' ', 'p', 'r', 'o', 'o', 'f'];
    AC_Termination_Proof _ ->
      ['A', 'C', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
        ' ', 'p', 'r', 'o', 'o', 'f'];
    LTS_Termination_Proof _ ->
      ['L', 'T', 'S', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
        'n', ' ', 'p', 'r', 'o', 'o', 'f'];
    LTS_Safety_Proof _ ->
      ['L', 'T', 'S', ' ', 's', 'a', 'f', 'e', 't', 'y', ' ', 'p', 'r', 'o',
        'o', 'f'];
    Unknown_Proof _ ->
      ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'];
    Unknown_Disproof _ ->
      ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'd', 'i', 's', 'p', 'r', 'o',
        'o', 'f'];
  });

input_to_string :: forall a b. Input a b -> [Prelude.Char];
input_to_string input =
  (case input of {
    DP_input _ _ _ _ -> ['D', 'P', ' ', 'i', 'n', 'p', 'u', 't'];
    Inn_TRS_input _ _ _ _ -> ['T', 'R', 'S', ' ', 'i', 'n', 'p', 'u', 't'];
    CPX_input _ _ _ _ _ ->
      ['C', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'i', 'n', 'p',
        'u', 't'];
    COMP_input _ _ ->
      ['C', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', ' ', 'i', 'n', 'p',
        'u', 't'];
    EQ_input _ _ ->
      ['E', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'i', 'n', 'p',
        'u', 't'];
    FP_TRS_input _ _ ->
      ['F', 'P', '-', 'T', 'R', 'S', ' ', 'i', 'n', 'p', 'u', 't'];
    CTRS_input _ -> ['C', 'T', 'R', 'S', ' ', 'i', 'n', 'p', 'u', 't'];
    TA_input _ _ -> ['T', 'A', ' ', 'i', 'n', 'p', 'u', 't'];
    AC_input _ _ _ ->
      ['A', 'C', '-', 'T', 'R', 'S', ' ', 'i', 'n', 'p', 'u', 't'];
    LTS_input _ -> ['L', 'T', 'S', ' ', 'i', 'n', 'p', 'u', 't'];
    LTS_safety_input _ _ ->
      ['L', 'T', 'S', ' ', 's', 'a', 'f', 'e', 't', 'y', ' ', 'i', 'n', 'p',
        'u', 't'];
    Unknown_input _ ->
      ['U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'i', 'n', 'p', 'u', 't'];
  });

claim_to_string :: forall a b. Claim a b -> [Prelude.Char];
claim_to_string claim =
  (case claim of {
    Yes -> ['y', 'e', 's'];
    No -> ['n', 'o'];
    Terminating -> ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
    Upperbound _ ->
      ['u', 'p', 'p', 'e', 'r', 'b', 'o', 'u', 'n', 'd', ' ', 'c', 'o', 'm',
        'p', 'l', 'e', 'x', 'i', 't', 'y'];
    Nonterminating ->
      ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n'];
    Confluent -> ['c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e'];
    Nonconfluent ->
      ['n', 'o', 'n', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e'];
    Completed -> ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n'];
    Anything -> ['a', 'n', 'y', 't', 'h', 'i', 'n', 'g'];
  });

check_cert ::
  forall a b c d e.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Ac_tp_ops_ext d (Lab b [Nat]) [Prelude.Char] () ->
                        Ac_dpp_ops_ext e (Lab b [Nat]) [Prelude.Char] () ->
                          Bool ->
                            Input (Lab b [Nat]) [Prelude.Char] ->
                              Claim (Lab b [Nat]) [Prelude.Char] ->
                                Proof b [Nat] [Prelude.Char] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cert i j k l a input claim proof =
  let {
    mismatch =
      shows_prec_list zero_nat
        (['C', 'l', 'a', 'i', 'm', 'i', 'n', 'g', ' '] ++
          claim_to_string claim ++
            [' ', 'o', 'f', ' '] ++
              input_to_string input ++
                [' ', 'b', 'y', ' '] ++ proof_to_string proof);
  } in (case input of {
         DP_input m p q r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_dp_termination_proof i j a (shows_string ['1'])
                        (mkd j default_nfs_dp m p [] (strategy_to_Q q r) [] r)
                        prf
                 else Inl mismatch);
             DP_Nontermination_Proof prf ->
               (if equal_claim claim Nonterminating ||
                     equal_claim claim Anything
                 then check_dp_nontermination_proof i j a (shows_string ['1'])
                        (mkd j default_nfs_nt_dp m p [] (strategy_to_Q q r) []
                          r)
                        prf
                 else Inl mismatch);
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         Inn_TRS_input q r s start ->
           (case proof of {
             TRS_Termination_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_trs_termination_proof i j a (shows_string ['1'])
                        (mkc i default_nfs_trs (strategy_to_Q q r) r s) prf
                 else Inl mismatch);
             Complexity_Proof prf ->
               (case claim of {
                 Yes -> Inl mismatch;
                 No -> Inl mismatch;
                 Terminating -> Inl mismatch;
                 Upperbound ub ->
                   let {
                     cm = translate_complexity_claim r s start;
                     cc = Comp_Poly ub;
                   } in check_complexity_proof i a (shows_string ['1'])
                          (mkc i True (strategy_to_Q q (r ++ s)) r s, (cm, cc))
                          prf;
                 Nonterminating -> Inl mismatch;
                 Confluent -> Inl mismatch;
                 Nonconfluent -> Inl mismatch;
                 Completed -> Inl mismatch;
                 Anything -> Inl mismatch;
               });
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof prf ->
               (if equal_claim claim Nonterminating ||
                     equal_claim claim Anything
                 then bindb (check (equal_start_term start Full) mismatch)
                        (\ _ ->
                          bindb (check (null s) mismatch)
                            (\ _ ->
                              check_trs_nontermination_proof i j a
                                (shows_string ['1'])
                                (mkc i default_nfs_nt_trs (strategy_to_Q q r) r
                                  [])
                                prf))
                 else Inl mismatch);
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof prf ->
               (if equal_claim claim Nonterminating ||
                     equal_claim claim Anything
                 then bindb (check (equal_start_term start Full) mismatch)
                        (\ _ ->
                          check_reltrs_nontermination_proof i j a
                            (shows_string ['1'])
                            (mkc i default_nfs_nt_trs (strategy_to_Q q r) r s)
                            prf)
                 else Inl mismatch);
             TRS_Confluence_Proof prf ->
               (if equal_claim claim Confluent || equal_claim claim Anything
                 then bindb (check (equal_start_term start Full)
                              (shows_prec_list zero_nat
                                ['C', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c',
                                  'e', ' ', 'w', 'i', 't', 'h', ' ', 's', 't',
                                  'a', 'r', 't', ' ', 't', 'e', 'r', 'm', ' ',
                                  'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o',
                                  'r', 't', 'e', 'd']))
                        (\ _ ->
                          bindb (check (equal_strategy q No_Strategy)
                                  (shows_prec_list zero_nat
                                    ['C', 'o', 'n', 'f', 'l', 'u', 'e', 'n',
                                      'c', 'e', ' ', 'u', 'n', 'd', 'e', 'r',
                                      ' ', 's', 't', 'r', 'a', 't', 'e', 'g',
                                      'y', ' ', 'n', 'o', 't', ' ', 's', 'u',
                                      'p', 'p', 'o', 'r', 't', 'e', 'd']))
                            (\ _ ->
                              bindb (check (null s)
                                      (shows_prec_list zero_nat
['R', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'c', 'o', 'n', 'f', 'l', 'u', 'e',
  'n', 'c', 'e', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
  'e', 'd']))
                                (\ _ ->
                                  check_cr_proof a (shows_string ['1']) i j r
                                    prf)))
                 else Inl mismatch);
             TRS_Non_Confluence_Proof prf ->
               (if equal_claim claim Nonconfluent || equal_claim claim Anything
                 then bindb (check (equal_start_term start Full)
                              (shows_prec_list zero_nat
                                ['N', 'o', 'n', 'c', 'o', 'n', 'f', 'l', 'u',
                                  'e', 'n', 'c', 'e', ' ', 'w', 'i', 't', 'h',
                                  ' ', 's', 't', 'a', 'r', 't', ' ', 't', 'e',
                                  'r', 'm', ' ', 'n', 'o', 't', ' ', 's', 'u',
                                  'p', 'p', 'o', 'r', 't', 'e', 'd']))
                        (\ _ ->
                          bindb (check (equal_strategy q No_Strategy)
                                  (shows_prec_list zero_nat
                                    ['C', 'o', 'n', 'f', 'l', 'u', 'e', 'n',
                                      'c', 'e', ' ', 'u', 'n', 'd', 'e', 'r',
                                      ' ', 's', 't', 'r', 'a', 't', 'e', 'g',
                                      'y', ' ', 'n', 'o', 't', ' ', 's', 'u',
                                      'p', 'p', 'o', 'r', 't', 'e', 'd']))
                            (\ _ ->
                              bindb (check (null s)
                                      (shows_prec_list zero_nat
['R', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'n', 'o', 'n', 'c', 'o', 'n', 'f',
  'l', 'u', 'e', 'n', 'c', 'e', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p',
  'o', 'r', 't', 'e', 'd']))
                                (\ _ ->
                                  check_ncr_proof a (shows_string ['1']) i j r
                                    prf)))
                 else Inl mismatch);
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         CPX_input q r s cm cc ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof prf ->
               bindb (case claim of {
                       Yes -> Inl mismatch;
                       No -> Inl mismatch;
                       Terminating -> Inl mismatch;
                       Upperbound ub ->
                         check (equal_complexity_class cc (Comp_Poly ub))
                           (shows_prec_list zero_nat
                             ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                               ' ', 'c', 'l', 'a', 's', 's', ' ', 'm', 'i', 's',
                               'm', 'a', 't', 'c', 'h']);
                       Nonterminating -> Inl mismatch;
                       Confluent -> Inl mismatch;
                       Nonconfluent -> Inl mismatch;
                       Completed -> Inl mismatch;
                       Anything -> Inr ();
                     })
                 (\ _ ->
                   check_complexity_proof i a (shows_string ['1'])
                     (mkc i True (strategy_to_Q q (r ++ s)) r s, (cm, cc)) prf);
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         COMP_input e r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof prf ->
               (if equal_claim claim Completed || equal_claim claim Anything
                 then check_completion_proof a (shows_string ['1']) i j e r prf
                 else Inl mismatch);
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         EQ_input e eq ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof prf ->
               (if equal_claim claim Yes || equal_claim claim Anything
                 then check_equational_proof a (shows_string ['1']) i j e eq prf
                 else Inl mismatch);
             Equational_Disproof prf ->
               (if equal_claim claim No || equal_claim claim Anything
                 then check_equational_disproof a (shows_string ['1']) i j e eq
                        prf
                 else Inl mismatch);
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         FP_TRS_input strat r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof prf ->
               (if equal_claim claim Nonterminating ||
                     equal_claim claim Anything
                 then check_fp_nontermination_proof i j a (shows_string ['1'])
                        (fp_strategy_to_fp_impl strat r, r) prf
                 else Inl mismatch);
             FP_Termination_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_fptrs_termination_proof i j a (shows_string ['1'])
                        (fp_strategy_to_fp_impl strat r, r) prf
                 else Inl mismatch);
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         CTRS_input ctrs ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_quasi_reductive_proof a (shows_string ['1']) i j
                        ctrs prf
                 else Inl mismatch);
             Conditional_CR_Proof prf ->
               (if equal_claim claim Confluent || equal_claim claim Anything
                 then check_conditional_cr_proof a (shows_string ['1']) i j ctrs
                        prf
                 else Inl mismatch);
             Conditional_Non_CR_Proof prf ->
               (if equal_claim claim Nonconfluent || equal_claim claim Anything
                 then check_conditional_ncr_proof a (shows_string ['1']) i j
                        ctrs prf
                 else Inl mismatch);
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         TA_input ta r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof prf ->
               (if equal_claim claim Yes || equal_claim claim Anything
                 then tree_aut_trs_closed ta prf r else Inl mismatch);
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         AC_input r aa c ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_ac_termination_proof l k (shows_string ['1'])
                        (mke k r aa c) prf
                 else Inl mismatch);
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         LTS_input r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_termination r prf else Inl mismatch);
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         LTS_safety_input r e ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof prf ->
               (if equal_claim claim Yes || equal_claim claim Anything
                 then check_safety lambda check_clause check_clause show_IA_exp
                        show_IA_exp negatea negatea r e prf
                 else Inl mismatch);
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         Unknown_input ur ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Unknown_Proof b ->
               check_unknown_proof i j a (shows_string ['1']) ur b;
             Unknown_Disproof b ->
               check_unknown_disproof i j a (shows_string ['1']) ur b;
           });
       });

intersect_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
intersect_values key vs m = foldr (aux key m) vs empty;

intersect_rules ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 Rbt (a, Nat) [(Bool, (Term a b, Term a b))] ->
                   Rbt (a, Nat) [(Bool, (Term a b, Term a b))];
intersect_rules rs =
  intersect_values key
    (map (\ a -> (True, a)) rs ++ map (\ a -> (False, a)) rs);

atom_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) (Formula (Term Sig ([Prelude.Char], Ty)));
atom_parser = xml_change (bexp_parser variable_parser) (xml_return . Atom);

hint_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) Hints;
hint_parser =
  xml_do
    ['l', 'i', 'n', 'e', 'a', 'r', 'C', 'o', 'm', 'b', 'i', 'n', 'a', 't', 'i',
      'o', 'n']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_int ['c', 'o', 'n', 's', 't', 'a', 'n', 't'])
      (\ xs -> xml_return (Hints xs)));

type_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) Ty;
type_parser =
  xml_or (xml_do ['i', 'n', 't'] (xml_return IntT))
    (xml_do ['b', 'o', 'o', 'l'] (xml_return BoolT));

sharp_trans_id ::
  forall a.
    ([Prelude.Char] ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) (Sharp a);
sharp_trans_id trans_id_parser =
  xml_or
    (xml_change
      (trans_id_parser
        ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 'D', 'u', 'p', 'l',
          'i', 'c', 'a', 't', 'e'])
      (xml_return . Sharpa))
    (xml_change
      (trans_id_parser
        ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 'I', 'd'])
      (xml_return . Flat));

unraveling_info ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        [(((Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char]),
                            [(Term (Lab a b) [Prelude.Char],
                               Term (Lab a b) [Prelude.Char])]),
                           [(Term (Lab a b) [Prelude.Char],
                              Term (Lab a b) [Prelude.Char])])];
unraveling_info xml2name =
  xml_do
    ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', 'I', 'n', 'f', 'o', 'r',
      'm', 'a', 't', 'i', 'o', 'n']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', 'E', 'n', 't', 'r',
          'y']
        (xml_take
          (crule xml2name
            ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'u',
              'l', 'e'])
          (\ a ->
            xml_take_many_sub [] zero_nat Infinity_enat (rule xml2name)
              (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (id a)));

tatom_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char])
      (Formula (Term Sig (Trans_var [Prelude.Char], Ty)));
tatom_parser = xml_change (bexp_parser trans_var_parser) (xml_return . Atom);

impl_ofc ::
  forall b a.
    (Key b,
      Key a) => Tp b a ->
                  (Bool,
                    ([Term b a],
                      (Bool,
                        ([(Term b a, Term b a)],
                          ([(Term b a, Term b a)],
                            (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                              Term b a -> Bool))))));
impl_ofc (TP x) = x;

q_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      [Term a b];
q_impl (uu, (q, uv)) = q;

q :: forall a b. (Key a, Key b) => Tp a b -> [Term a b];
q tp = q_impl (impl_ofc tp);

r_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)];
r_impl (uu, (uv, (uw, (vR, (ux, (m, uy)))))) = vR ++ rules_with id m;

r :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
r tp = r_impl (impl_ofc tp);

invariant_proof_parser ::
  forall a b c d e f.
    (Default f) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) a) ->
                     ((Xml, ([([Prelude.Char], [Prelude.Char])],
                              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) b) ->
                       ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                (Bool,
                                  ([[Prelude.Char]], [[Prelude.Char]])))) ->
                         Sum (Xml_error [Prelude.Char])
                           (Formula (Term c (d, e)))) ->
                         ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                  (Bool,
                                    ([[Prelude.Char]], [[Prelude.Char]])))) ->
                           Sum (Xml_error [Prelude.Char]) f) ->
                           [(a, Formula (Term c (d, e)))] ->
                             (Xml, ([([Prelude.Char], [Prelude.Char])],
                                     (Bool,
                                       ([[Prelude.Char]],
 [[Prelude.Char]])))) ->
                               Sum (Xml_error [Prelude.Char])
                                 (Invariant_proof c d e a [Prelude.Char] b f);
invariant_proof_parser location_parser trans_parser atom_parser hint_parser i =
  xml_change
    (art_parser xml_text location_parser trans_parser atom_parser hint_parser)
    (\ prf -> xml_return (Impact i prf));

sharp_location_parser ::
  forall a.
    ([Prelude.Char] ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) (Sharp a);
sharp_location_parser location_id_parser =
  xml_or
    (xml_change
      (location_id_parser
        ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n', 'D', 'u', 'p', 'l', 'i', 'c',
          'a', 't', 'e'])
      (xml_return . Sharpa))
    (xml_change
      (location_id_parser ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n', 'I', 'd'])
      (xml_return . Flat));

invariant_parser ::
  forall a b c d.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      ((Xml, ([([Prelude.Char], [Prelude.Char])],
               (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) (Formula (Term b (c, d)))) ->
        (Xml, ([([Prelude.Char], [Prelude.Char])],
                (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) (a, Formula (Term b (c, d)));
invariant_parser location_parser atom_parser =
  xml_do ['i', 'n', 'v', 'a', 'r', 'i', 'a', 'n', 't']
    (xml_take
      (xml_do ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n']
        (xml_take location_parser xml_return))
      (\ l ->
        xml_take
          (xml_do ['f', 'o', 'r', 'm', 'u', 'l', 'a']
            (xml_take (formula_parser atom_parser) xml_return))
          (\ phi -> xml_return (l, phi))));

invariants_parser ::
  forall a b c d.
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) a) ->
      ((Xml, ([([Prelude.Char], [Prelude.Char])],
               (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) (Formula (Term b (c, d)))) ->
        (Xml, ([([Prelude.Char], [Prelude.Char])],
                (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) [(a, Formula (Term b (c, d)))];
invariants_parser location_parser atom_parser =
  xml_do ['i', 'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (invariant_parser location_parser atom_parser) xml_return);

cooperation_proof_parser ::
  forall a b c d e f.
    (Ccompare a, Eq a, Default e, Ccompare f, Eq f,
      Mapping_impl f) => ([Prelude.Char] ->
                           (Xml, ([([Prelude.Char], [Prelude.Char])],
                                   (Bool,
                                     ([[Prelude.Char]], [[Prelude.Char]])))) ->
                             Sum (Xml_error [Prelude.Char]) a) ->
                           ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                    (Bool,
                                      ([[Prelude.Char]], [[Prelude.Char]])))) ->
                             Sum (Xml_error [Prelude.Char]) (Term b (c, d))) ->
                             ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                      (Bool,
([[Prelude.Char]], [[Prelude.Char]])))) ->
                               Sum (Xml_error [Prelude.Char])
                                 (Formula (Term b (c, d)))) ->
                               ((Xml, ([([Prelude.Char], [Prelude.Char])],
(Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                                 Sum (Xml_error [Prelude.Char])
                                   (Formula (Term b (Trans_var c, d)))) ->
                                 ((Xml, ([([Prelude.Char], [Prelude.Char])],
  (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                                   Sum (Xml_error [Prelude.Char]) c) ->
                                   ((Xml, ([([Prelude.Char], [Prelude.Char])],
    (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                                     Sum (Xml_error [Prelude.Char]) e) ->
                                     ((Xml,
([([Prelude.Char], [Prelude.Char])],
  (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                                       Sum (Xml_error [Prelude.Char]) d) ->
                                       d ->
 ((Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
   Sum (Xml_error [Prelude.Char]) f) ->
   (Xml, ([([Prelude.Char], [Prelude.Char])],
           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
     Sum (Xml_error [Prelude.Char]) (Cooperation_proof b c d a f e);
cooperation_proof_parser location_id_parser exp_parser atom_parser tatom_parser
  variable_parser hint_parser type_parser dom_type trans_parser xs =
  xml_or (xml_do ['t', 'r', 'i', 'v', 'i', 'a', 'l'] (xml_return Triviala))
    (xml_or
      (xml_do ['n', 'e', 'w', 'I', 'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', 's']
        (xml_take
          (invariants_parser (sharp_location_parser location_id_parser)
            atom_parser)
          (\ i ->
            xml_take
              (invariant_proof_parser (sharp_location_parser location_id_parser)
                trans_parser atom_parser hint_parser i)
              (\ p ->
                xml_take
                  (cooperation_proof_parser location_id_parser exp_parser
                    atom_parser tatom_parser variable_parser hint_parser
                    type_parser dom_type trans_parser)
                  (\ cp -> xml_return (Invariants_Update p cp))))))
      (xml_or
        (xml_do
          ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 'R', 'e', 'm', 'o',
            'v', 'a', 'l']
          (xml_take
            (xml_do
              ['r', 'a', 'n', 'k', 'i', 'n', 'g', 'F', 'u', 'n', 'c', 't', 'i',
                'o', 'n', 's']
              (xml_take_many_sub [] zero_nat Infinity_enat
                (xml_do
                  ['r', 'a', 'n', 'k', 'i', 'n', 'g', 'F', 'u', 'n', 'c', 't',
                    'i', 'o', 'n']
                  (xml_take
                    (xml_do ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n']
                      (xml_take (sharp_location_parser location_id_parser)
                        xml_return))
                    (\ l ->
                      xml_take
                        (xml_do
                          ['e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n']
                          (xml_take_many_sub [] one_nat Infinity_enat exp_parser
                            xml_return))
                        (\ es -> xml_return (l, es)))))
                xml_return))
            (\ rs ->
              xml_take
                (xml_do ['b', 'o', 'u', 'n', 'd']
                  (xml_take_many_sub [] zero_nat Infinity_enat exp_parser
                    xml_return))
                (\ bounds ->
                  xml_take
                    (xml_do ['r', 'e', 'm', 'o', 'v', 'e']
                      (xml_take_many_sub [] zero_nat Infinity_enat trans_parser
                        xml_return))
                    (\ removed ->
                      xml_take_default (\ _ -> default_hint)
                        (xml_do ['h', 'i', 'n', 't', 's']
                          (xml_take_many_sub [] zero_nat Infinity_enat
                            (xml_do ['h', 'i', 'n', 't']
                              (xml_take trans_parser
                                (\ tr ->
                                  xml_take_default default_hint
                                    (hints_parser hint_parser)
                                    (\ hint -> xml_return (tr, hint)))))
                            (\ pairs ->
                              xml_return (map_of_default default_hint pairs))))
                        (\ hinter ->
                          xml_take
                            (cooperation_proof_parser location_id_parser
                              exp_parser atom_parser tatom_parser
                              variable_parser hint_parser type_parser dom_type
                              trans_parser)
                            (\ inner ->
                              let {
                                rf = map_of_default [] rs;
                              } in xml_return
                                     (Transition_Removal
                                       (Transition_removal_info rf removed
 dom_type bounds hinter)
                                       inner))))))))
        (xml_or
          (xml_do
            ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n', 'A', 'd', 'd', 'i', 't',
              'i', 'o', 'n']
            (xml_take
              (transition_parser (sharp_location_parser location_id_parser)
                trans_parser tatom_parser)
              (\ tr ->
                xml_take
                  (cooperation_proof_parser location_id_parser exp_parser
                    atom_parser tatom_parser variable_parser hint_parser
                    type_parser dom_type trans_parser)
                  (\ prof ->
                    let {
                      (tr_id, tau) = tr;
                    } in xml_return
                           (Location_Addition
                             (Location_Addition_Info (source tau) (target tau)
                               tr_id tau)
                             prof)))))
          (xml_or
            (xml_do
              ['f', 'r', 'e', 's', 'h', 'V', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
                'A', 'd', 'd', 'i', 't', 'i', 'o', 'n']
              (xml_take variable_parser
                (\ x1 ->
                  xml_take type_parser
                    (\ x2 ->
                      xml_take
                        (xml_do
                          ['a', 'd', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l',
                            'F', 'o', 'r', 'm', 'u', 'l', 'a', 's']
                          (xml_take_many_sub [] zero_nat Infinity_enat
                            (xml_do
                              ['a', 'd', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l',
                                'F', 'o', 'r', 'm', 'u', 'l', 'a']
                              (xml_take trans_parser
                                (\ tr ->
                                  xml_take (formula_parser tatom_parser)
                                    (\ phi -> xml_return (tr, phi)))))
                            xml_return))
                        (\ x3 ->
                          xml_take
                            (cooperation_proof_parser location_id_parser
                              exp_parser atom_parser tatom_parser
                              variable_parser hint_parser type_parser dom_type
                              trans_parser)
                            (\ prof ->
                              xml_return
                                (Fresh_Variable_Addition
                                  (Fresh_Variable_Addition_Info x1 x2 x3)
                                  prof)))))))
            (xml_or
              (xml_do
                ['c', 'u', 't', 'T', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o',
                  'n', 'S', 'p', 'l', 'i', 't']
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (xml_do
                    ['c', 'u', 't', 'T', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o',
                      'n', 's', 'W', 'i', 't', 'h', 'P', 'r', 'o', 'o', 'f']
                    (xml_take
                      (xml_do
                        ['c', 'u', 't', 'T', 'r', 'a', 'n', 's', 'i', 't', 'i',
                          'o', 'n', 's']
                        (xml_take_many_sub [] zero_nat Infinity_enat
                          trans_parser xml_return))
                      (\ cuts ->
                        xml_take
                          (cooperation_proof_parser location_id_parser
                            exp_parser atom_parser tatom_parser variable_parser
                            hint_parser type_parser dom_type trans_parser)
                          (\ prof -> xml_return (cuts, prof)))))
                  (\ ps -> xml_return (Cut_Transition_Split ps))))
              (xml_do
                ['s', 'c', 'c', 'D', 'e', 'c', 'o', 'm', 'p', 'o', 's', 'i',
                  't', 'i', 'o', 'n']
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (xml_do
                    ['s', 'c', 'c', 'W', 'i', 't', 'h', 'P', 'r', 'o', 'o', 'f']
                    (xml_take
                      (xml_do ['s', 'c', 'c']
                        (xml_take_many_sub [] one_nat Infinity_enat
                          (sharp_location_parser location_id_parser)
                          xml_return))
                      (\ scc ->
                        xml_take
                          (cooperation_proof_parser location_id_parser
                            exp_parser atom_parser tatom_parser variable_parser
                            hint_parser type_parser dom_type trans_parser)
                          (\ prof -> xml_return (scc, prof)))))
                  (\ sccs -> xml_return (Scc_Decomp sccs)))))))))
    xs;

cut_points_to_transitions ::
  forall a b c d e.
    [(Sharp a, Transition_rule b c d (Sharp e))] ->
      [(e, (a, Formula (Term b (Trans_var c, d))))] ->
        [(Sharp a, Transition_rule b c d (Sharp e))];
cut_points_to_transitions ts [] = ts;
cut_points_to_transitions ts ((l, (tr, phi)) : cps) =
  cut_points_to_transitions ((Flat tr, Transition (Flat l) (Sharpa l) phi) : ts)
    cps;

cutPoints_parser ::
  forall a b c d e.
    ([Prelude.Char] ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char]) a) ->
      ([Prelude.Char] ->
        (Xml, ([([Prelude.Char], [Prelude.Char])],
                (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) b) ->
        ((Xml, ([([Prelude.Char], [Prelude.Char])],
                 (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
          Sum (Xml_error [Prelude.Char]) (Formula (Term c (Trans_var d, e)))) ->
          (Xml, ([([Prelude.Char], [Prelude.Char])],
                  (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
            Sum (Xml_error [Prelude.Char])
              [(Sharp b, Transition_rule c d e (Sharp a))];
cutPoints_parser location_id_parser trans_id_parser tatom_parser =
  xml_do ['c', 'u', 't', 'P', 'o', 'i', 'n', 't', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do ['c', 'u', 't', 'P', 'o', 'i', 'n', 't']
        (xml_take
          (location_id_parser
            ['l', 'o', 'c', 'a', 't', 'i', 'o', 'n', 'I', 'd'])
          (\ l ->
            xml_take (trans_id_parser ['s', 'k', 'i', 'p', 'I', 'd'])
              (\ tr ->
                xml_take
                  (xml_do
                    ['s', 'k', 'i', 'p', 'F', 'o', 'r', 'm', 'u', 'l', 'a']
                    (xml_take (formula_parser tatom_parser) xml_return))
                  (\ phi -> xml_return (l, (tr, phi)))))))
      (\ tuples -> xml_return (cut_points_to_transitions [] tuples)));

termination_proof_parser ::
  forall a b c d e f.
    (Ccompare a, Eq a, Ccompare b, Eq b,
      Default f) => ([Prelude.Char] ->
                      (Xml, ([([Prelude.Char], [Prelude.Char])],
                              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                        Sum (Xml_error [Prelude.Char]) a) ->
                      ([Prelude.Char] ->
                        (Xml, ([([Prelude.Char], [Prelude.Char])],
                                (Bool,
                                  ([[Prelude.Char]], [[Prelude.Char]])))) ->
                          Sum (Xml_error [Prelude.Char]) b) ->
                        ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                 (Bool,
                                   ([[Prelude.Char]], [[Prelude.Char]])))) ->
                          Sum (Xml_error [Prelude.Char]) (Term c (d, e))) ->
                          ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                   (Bool,
                                     ([[Prelude.Char]], [[Prelude.Char]])))) ->
                            Sum (Xml_error [Prelude.Char])
                              (Formula (Term c (d, e)))) ->
                            ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                     (Bool,
                                       ([[Prelude.Char]],
 [[Prelude.Char]])))) ->
                              Sum (Xml_error [Prelude.Char])
                                (Formula (Term c (Trans_var d, e)))) ->
                              ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                       (Bool,
 ([[Prelude.Char]], [[Prelude.Char]])))) ->
                                Sum (Xml_error [Prelude.Char]) d) ->
                                ((Xml, ([([Prelude.Char], [Prelude.Char])],
 (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                                  Sum (Xml_error [Prelude.Char]) f) ->
                                  ((Xml, ([([Prelude.Char], [Prelude.Char])],
   (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                                    Sum (Xml_error [Prelude.Char]) e) ->
                                    e -> (Xml,
   ([([Prelude.Char], [Prelude.Char])],
     (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
   Sum (Xml_error [Prelude.Char]) (Termination_proof c d e a b f);
termination_proof_parser location_id_parser trans_id_parser exp_parser
  atom_parser tatom_parser variable_parser hint_parser type_parser dom_type xml
  = xml_or (xml_do ['t', 'r', 'i', 'v', 'i', 'a', 'l'] (xml_return Trivialb))
      (xml_or
        (xml_do
          ['n', 'e', 'w', 'I', 'n', 'v', 'a', 'r', 'i', 'a', 'n', 't', 's']
          (xml_take
            (invariants_parser (location_parser location_id_parser) atom_parser)
            (\ i ->
              xml_take
                (invariant_proof_parser (location_parser location_id_parser)
                  (trans_id trans_id_parser) atom_parser hint_parser i)
                (\ p ->
                  xml_take
                    (termination_proof_parser location_id_parser trans_id_parser
                      exp_parser atom_parser tatom_parser variable_parser
                      hint_parser type_parser dom_type)
                    (\ cp -> xml_return (Invariants_Update_LTS p cp))))))
        (xml_do
          ['s', 'w', 'i', 't', 'c', 'h', 'T', 'o', 'C', 'o', 'o', 'p', 'e', 'r',
            'a', 't', 'i', 'o', 'n', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't',
            'i', 'o', 'n']
          (xml_take
            (cutPoints_parser location_id_parser trans_id_parser tatom_parser)
            (\ cp ->
              xml_take
                (cooperation_proof_parser location_id_parser exp_parser
                  atom_parser tatom_parser variable_parser hint_parser
                  type_parser dom_type (sharp_trans_id trans_id_parser))
                (\ p -> xml_return (Via_Cooperation [(cp, p)]))))))
      xml;

lts_termination_proof_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char])
      (Termination_proof Sig [Prelude.Char] Ty [Prelude.Char] [Prelude.Char]
        Hints);
lts_termination_proof_parser =
  termination_proof_parser xml_text xml_text exp_parser atom_parser tatom_parser
    variable_parser hint_parser type_parser IntT;

xml2dp_nontermination_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Dp_nontermination_proof a b [Prelude.Char]);
xml2dp_nontermination_proof xml2name x =
  xml_do
    ['d', 'p', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
      'n', 'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_do
          ['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
          (xml_take_optional
            (xml_do ['d', 'p', 's']
              (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
            (\ p ->
              xml_take_optional
                (xml_do ['t', 'r', 's']
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ r ->
                  xml_take (xml2dp_nontermination_proof xml2name)
                    (\ prf ->
                      xml_return
                        (DP_Rule_Removal (Rule_removal_nonterm_dp_prf p r)
                          prf))))))
        (xml_or
          (xml_change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              xml_return (DP_Loop (DP_loop_prf s rseq sigma c))))
          (xml_or (xml_change (nonloop xml2name) (xml_return . DP_Nonloop))
            (xml_or
              (xml_do
                ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's',
                  's', 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c']
                (xml_take (innermostLhss xml2name)
                  (\ a ->
                    xml_take (xml2dp_nontermination_proof xml2name)
                      (\ b ->
                        xml_return
                          (DP_Q_Reduction (DP_q_reduction_nonterm_prf a) b)))))
              (xml_or
                (xml_do
                  ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's',
                    's', 'I', 'n', 'c', 'r', 'e', 'a', 's', 'e', 'P', 'r', 'o',
                    'c']
                  (xml_take (innermostLhss xml2name)
                    (\ a ->
                      xml_take (xml2dp_nontermination_proof xml2name)
                        (\ b ->
                          xml_return
                            (DP_Q_Increase (Q_increase_nonterm_dp_prf a) b)))))
                (xml_or
                  (xml_do
                    ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o',
                      'n', 'P', 'r', 'o', 'c']
                    (xml_take
                      (xml_do ['d', 'p', 's']
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ a ->
                        xml_take (xml2dp_nontermination_proof xml2name)
                          (\ b ->
                            xml_return
                              (DP_Instantiation
                                (Instantiation_complete_proc_prf a) b)))))
                  (xml_or
                    (xml_do
                      ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 'P', 'r',
                        'o', 'c']
                      (xml_take (rule xml2name)
                        (\ a ->
                          xml_take pos
                            (\ b ->
                              xml_take
                                (xml_do
                                  ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g',
                                    's']
                                  (xml_take (rules xml2name)
                                    (\ xa -> xml_return (id xa))))
                                (\ c ->
                                  xml_take
                                    (xml2dp_nontermination_proof xml2name)
                                    (\ d ->
                                      xml_return
(DP_Narrowing (Narrowing_complete_proc_prf a b c) d)))))))
                    (xml_or
                      (xml_do
                        ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r',
                          'o', 'c']
                        (xml_take (rule xml2name)
                          (\ (s, t) ->
                            xml_take (rstep xml2name)
                              (\ (p, (lr, ta)) ->
                                xml_take_optional (rule xml2name)
                                  (\ c ->
                                    xml_take_optional
                                      (xml_do
['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
(xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                                      (\ uopt ->
xml_take (xml2dp_nontermination_proof xml2name)
  (\ prf ->
    let {
      st = (case c of {
             Nothing -> (s, ta);
             Just v -> v;
           });
    } in xml_return
           (DP_Rewriting
             (Rewriting_complete_proc_prf uopt (s, t) (s, ta) st lr p)
             prf))))))))
                      (xml_or
                        (xml_do
                          ['s', 'w', 'i', 't', 'c', 'h', 'F', 'u', 'l', 'l',
                            'S', 't', 'r', 'a', 't', 'e', 'g', 'y', 'P', 'r',
                            'o', 'c']
                          (xml_take (wcr_proof xml2name)
                            (\ a ->
                              xml_take (xml2dp_nontermination_proof xml2name)
                                (\ b ->
                                  xml_return (DP_Termination_Switch a b)))))
                        (xml_or
                          (xml_do
                            ['i', 'n', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e',
                              's', 's', 'A', 's', 's', 'u', 'm', 'p', 't', 'i',
                              'o', 'n']
                            (xml_take (xml2dp_inputa xml2name False)
                              (\ xa -> xml_return (DP_Assume_Infinite xa []))))
                          (xml_do
                            ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o',
                              'o', 'f']
                            (xml_take
                              (xml_text
                                ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i',
                                  'o', 'n'])
                              (\ _ ->
                                xml_take (xml2dp_inputa xml2name False)
                                  (\ b ->
                                    xml_take_many_sub [] zero_nat Infinity_enat
                                      (\ xa -> Inr (fst xa))
                                      (\ _ ->
xml_return (DP_Assume_Infinite b []))))))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2inn_nt_trs_assm ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Bool,
                          ([Term (Lab a b) [Prelude.Char]],
                            [(Term (Lab a b) [Prelude.Char],
                               Term (Lab a b) [Prelude.Char])]));
xml2inn_nt_trs_assm xml2name =
  xml_change (xml2_trs_input xml2name)
    (\ (Inn_TRS_input inn r s start) ->
      (if not (null s)
        then xml_error
               ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
                 'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r',
                 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e',
                 's', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd']
        else (if not (equal_start_term start Full)
               then xml_error
                      ['s', 't', 'a', 'r', 't', ' ', 't', 'e', 'r', 'm', ' ',
                        'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
                        'w', 'e', 'd', ' ', 'h', 'e', 'r', 'e']
               else xml_return
                      (default_nfs_nt_trs, (strategy_to_Q inn r, r)))));

xml2trs_nontermination_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Trs_nontermination_proof a b [Prelude.Char]);
xml2trs_nontermination_proof xml2name x =
  xml_do
    ['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
      'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_leaf
          ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i', 't',
            'i', 'o', 'n', 'V', 'i', 'o', 'l', 'a', 't', 'e', 'd']
          TRS_Not_Well_Formed)
        (xml_or
          (xml_change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              xml_return
                (TRS_Loop
                  (TRS_loop_prf s
                    (map (\ (xa, (y, (_, z))) -> (xa, (y, z))) rseq) sigma c))))
          (xml_or (xml_change (nonloop xml2name) (xml_return . TRS_Nonloop))
            (xml_or
              (xml_change (nonloop_srs xml2name) (xml_return . TRS_Nonloop_SRS))
              (xml_or
                (xml_do ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
                  (xml_take
                    (xml_do ['t', 'r', 's']
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ a ->
                      xml_take (xml2trs_nontermination_proof xml2name)
                        (\ b ->
                          xml_return
                            (TRS_Rule_Removal (Rule_removal_nonterm_trs_prf a)
                              b)))))
                (xml_or
                  (xml_do ['d', 'p', 'T', 'r', 'a', 'n', 's']
                    (xml_take
                      (xml_do ['d', 'p', 's']
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ a ->
                        xml_take
                          (xml_bool
                            ['m', 'a', 'r', 'k', 'e', 'd', 'S', 'y', 'm', 'b',
                              'o', 'l', 's'])
                          (\ _ ->
                            xml_take (xml2dp_nontermination_proof xml2name)
                              (\ c ->
                                xml_return
                                  (TRS_DP_Trans
                                    (DP_trans_nontermination_tt_prf a) c))))))
                  (xml_or
                    (xml_do
                      ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r',
                        's', 'a', 'l']
                      (xml_take
                        (xml_do ['t', 'r', 's']
                          (xml_take (rules xml2name)
                            (\ xa -> xml_return (id xa))))
                        (\ _ ->
                          xml_take (xml2trs_nontermination_proof xml2name)
                            (\ b -> xml_return (TRS_String_Reversal b)))))
                    (xml_or
                      (xml_do
                        ['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U',
                          'n', 'a', 'r', 'y']
                        (xml_take plain_var
                          (\ a ->
                            xml_take (renaming xml2name)
                              (\ b ->
                                xml_take
                                  (xml_do ['t', 'r', 's']
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ c ->
                                    xml_take
                                      (xml2trs_nontermination_proof xml2name)
                                      (\ d ->
xml_return (TRS_Constant_String (Const_string_complete_proof a b c) d)))))))
                      (xml_or
                        (xml_do
                          ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L',
                            'h', 's', 's', 'I', 'n', 'c', 'r', 'e', 'a', 's',
                            'e']
                          (xml_take (innermostLhss xml2name)
                            (\ a ->
                              xml_take (xml2trs_nontermination_proof xml2name)
                                (\ b ->
                                  xml_return
                                    (TRS_Q_Increase
                                      (Q_increase_nonterm_trs_prf a) b)))))
                        (xml_or
                          (xml_do
                            ['s', 'w', 'i', 't', 'c', 'h', 'F', 'u', 'l', 'l',
                              'S', 't', 'r', 'a', 't', 'e', 'g', 'y']
                            (xml_take (wcr_proof xml2name)
                              (\ a ->
                                xml_take (xml2trs_nontermination_proof xml2name)
                                  (\ b ->
                                    xml_return (TRS_Termination_Switch a b)))))
                          (xml_or
                            (xml_do ['u', 'n', 'c', 'u', 'r', 'r', 'y']
                              (xml_take (uncurry_info xml2name)
                                (\ a ->
                                  xml_take
                                    (xml_do ['t', 'r', 's']
                                      (xml_take (rules xml2name)
(\ xa -> xml_return (id xa))))
                                    (\ b ->
                                      xml_take
(xml2trs_nontermination_proof xml2name)
(\ c -> xml_return (TRS_Uncurry (Uncurry_nt_proof a b) c))))))
                            (xml_or
                              (xml_change (not_wn_ta xml2name)
                                (xml_return . TRS_Not_WN_Tree_Automaton))
                              (xml_or
                                (xml_do
                                  ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n',
                                    'a', 't', 'i', 'o', 'n', 'A', 's', 's', 'u',
                                    'm', 'p', 't', 'i', 'o', 'n']
                                  (xml_take (xml2inn_nt_trs_assm xml2name)
                                    (\ xa ->
                                      xml_return (TRS_Assume_Not_SN xa []))))
                                (xml_do
                                  ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r',
                                    'o', 'o', 'f']
                                  (xml_take
                                    (xml_text
                                      ['d', 'e', 's', 'c', 'r', 'i', 'p', 't',
'i', 'o', 'n'])
                                    (\ _ ->
                                      xml_take (xml2inn_nt_trs_assm xml2name)
(\ b ->
  xml_take_many_sub [] zero_nat Infinity_enat (\ xa -> Inr (fst xa))
    (\ _ -> xml_return (TRS_Assume_Not_SN b [])))))))))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2inn_rel_nt_trs_assm ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Bool,
                          ([Term (Lab a b) [Prelude.Char]],
                            ([(Term (Lab a b) [Prelude.Char],
                                Term (Lab a b) [Prelude.Char])],
                              [(Term (Lab a b) [Prelude.Char],
                                 Term (Lab a b) [Prelude.Char])])));
xml2inn_rel_nt_trs_assm xml2name =
  xml_change (xml2_trs_input xml2name)
    (\ (Inn_TRS_input inn r s start) ->
      (if not (equal_start_term start Full)
        then xml_error
               ['s', 't', 'a', 'r', 't', ' ', 't', 'e', 'r', 'm', ' ', 'i', 's',
                 ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd',
                 ' ', 'h', 'e', 'r', 'e']
        else xml_return (default_nfs_nt_trs, (strategy_to_Q inn r, (r, s)))));

xml2reltrs_nontermination_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Reltrs_nontermination_proof a b [Prelude.Char]);
xml2reltrs_nontermination_proof xml2name x =
  xml_do
    ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'N', 'o', 'n', 't', 'e', 'r', 'm',
      'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_leaf
          ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i', 't',
            'i', 'o', 'n', 'V', 'i', 'o', 'l', 'a', 't', 'e', 'd']
          Rel_Not_Well_Formed)
        (xml_or
          (xml_change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              xml_return (Rel_Loop (Rel_trs_loop_prf s rseq sigma c))))
          (xml_or
            (xml_change (xml2trs_nontermination_proof xml2name)
              (xml_return . Rel_R_Not_SN))
            (xml_or
              (xml_do ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
                (xml_take
                  (xml_do ['t', 'r', 's']
                    (xml_take (rules xml2name) (\ xa -> xml_return (Just xa))))
                  (\ a ->
                    xml_take
                      (xml_do ['t', 'r', 's']
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (Just xa))))
                      (\ b ->
                        xml_take (xml2reltrs_nontermination_proof xml2name)
                          (\ c ->
                            xml_return
                              (Rel_Rule_Removal
                                (Rule_removal_nonterm_reltrs_prf a b) c))))))
              (xml_or
                (xml_do
                  ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's',
                    'a', 'l']
                  (xml_take
                    (xml_do ['t', 'r', 's']
                      (xml_take (rules xml2name)
                        (\ xa -> xml_return (Just xa))))
                    (\ _ ->
                      xml_take
                        (xml_do ['t', 'r', 's']
                          (xml_take (rules xml2name)
                            (\ xa -> xml_return (Just xa))))
                        (\ _ ->
                          xml_take (xml2reltrs_nontermination_proof xml2name)
                            (\ c -> xml_return (Rel_TRS_String_Reversal c))))))
                (xml_or
                  (xml_do
                    ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                      'o', 'n', 'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                      'n']
                    (xml_take (xml2inn_rel_nt_trs_assm xml2name)
                      (\ xa -> xml_return (Rel_TRS_Assume_Not_SN xa []))))
                  (xml_do
                    ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
                    (xml_take
                      (xml_text
                        ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
                      (\ _ ->
                        xml_take (xml2inn_rel_nt_trs_assm xml2name)
                          (\ b ->
                            xml_take_many_sub [] zero_nat Infinity_enat
                              (\ xa -> Inr (fst xa))
                              (\ _ ->
                                xml_return
                                  (Rel_TRS_Assume_Not_SN b []))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

safety_proof_parser ::
  forall a b c d e f.
    (Default f) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char]) a) ->
                     ((Xml, ([([Prelude.Char], [Prelude.Char])],
                              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                       Sum (Xml_error [Prelude.Char]) b) ->
                       ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                (Bool,
                                  ([[Prelude.Char]], [[Prelude.Char]])))) ->
                         Sum (Xml_error [Prelude.Char])
                           (Formula (Term c (d, e)))) ->
                         ((Xml, ([([Prelude.Char], [Prelude.Char])],
                                  (Bool,
                                    ([[Prelude.Char]], [[Prelude.Char]])))) ->
                           Sum (Xml_error [Prelude.Char]) f) ->
                           (Xml, ([([Prelude.Char], [Prelude.Char])],
                                   (Bool,
                                     ([[Prelude.Char]], [[Prelude.Char]])))) ->
                             Sum (Xml_error [Prelude.Char])
                               (Safety_proof c d e a [Prelude.Char] b f);
safety_proof_parser location_parser trans_parser atom_parser hint_parser =
  xml_do
    ['s', 'a', 'f', 'e', 't', 'y', 'V', 'i', 'a', 'I', 'n', 'v', 'a', 'r', 'i',
      'a', 'n', 't', 's']
    (xml_take (invariants_parser location_parser atom_parser)
      (\ i ->
        xml_take
          (invariant_proof_parser location_parser trans_parser atom_parser
            hint_parser i)
          (\ p -> xml_return (Invariant_Assertion p Trivial))));

lts_safety_proof_parser ::
  (Xml, ([([Prelude.Char], [Prelude.Char])],
          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char])
      (Safety_proof Sig [Prelude.Char] Ty [Prelude.Char] [Prelude.Char]
        [Prelude.Char] Hints);
lts_safety_proof_parser =
  safety_proof_parser (location_parser xml_text) (trans_id xml_text) atom_parser
    hint_parser;

xml2quasi_reductive_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Quasi_reductive_proof a b [Prelude.Char]);
xml2quasi_reductive_proof xml2name =
  xml_do
    ['q', 'u', 'a', 's', 'i', 'R', 'e', 'd', 'u', 'c', 't', 'i', 'v', 'e', 'P',
      'r', 'o', 'o', 'f']
    (xml_take
      (xml_do ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g']
        (xml_take (unraveling_info xml2name)
          (\ a ->
            xml_take (xml2trs_termination_proof xml2name)
              (\ b -> xml_return (Unravel a b)))))
      (\ x -> xml_return (id x)));

map_r_states :: forall a b c. (a -> b) -> Ta_rule a c -> Ta_rule b c;
map_r_states f r = TA_rule (r_root r) (map f (r_lhs_states r)) (f (r_rhs r));

map_states_impl ::
  forall a b c. (a -> b) -> Tree_automaton a c -> Tree_automaton b c;
map_states_impl f (Tree_Automaton qs ts eps) =
  Tree_Automaton (map f qs) (map (map_r_states f) ts)
    (map (\ (p, q) -> (f p, f q)) eps);

xml2nonreachable_etac_info ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Nonreachability_proof (Lab a b) [Prelude.Char]);
xml2nonreachable_etac_info xml2name =
  xml_do
    ['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'E', 't', 'a',
      'c']
    (xml_take (cPFsignature xml2name)
      (\ a ->
        xml_take xml2name
          (\ b ->
            xml_take xml2name
              (\ c ->
                xml_take (tree_automaton (ta_normal_lhs xml2name))
                  (\ d ->
                    xml_take (xml2state_map xml2name)
                      (\ e ->
                        xml_return
                          (Nonreachable_ETAC a b c (map_states_impl e d))))))));

xml2nonreachability_proof ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Nonreachability_proof (Lab a b) [Prelude.Char]);
xml2nonreachability_proof xml2name x =
  xml_do
    ['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'i', 'l', 'i', 't', 'y',
      'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_leaf
          ['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'T', 'c',
            'a', 'p']
          Nonreachable_Gtcap)
        (xml_or (xml2nonreachable_etac_info xml2name)
          (xml_or
            (xml_do
              ['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'S',
                'u', 'b', 's', 't', 'A', 'p', 'p', 'r', 'o', 'x']
              (xml_take (rules xml2name)
                (\ a ->
                  xml_take (xml2nonreachability_proof xml2name)
                    (\ b -> xml_return (Nonreachable_Subst_Approx a b)))))
            (xml_do
              ['n', 'o', 'n', 'r', 'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', 'R',
                'e', 'v', 'e', 'r', 's', 'e']
              (xml_take (xml2nonreachability_proof xml2name)
                (\ xa -> xml_return (Nonreachable_Reverse xa)))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2nonjoinability_proof ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Nonjoinability_proof (Lab a b) [Prelude.Char]);
xml2nonjoinability_proof xml2name =
  xml_do
    ['n', 'o', 'n', 'j', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't', 'y', 'P',
      'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_leaf
          ['n', 'o', 'n', 'j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'T', 'c', 'a',
            'p']
          Nonjoinable_Tcap)
        (xml_change (xml2nonreachability_proof xml2name)
          (xml_return . Nonjoinable_Ground_NF)))
      (\ x -> xml_return (id x)));

xml2infeasibility_proof ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Infeasibility_proof (Lab a b) [Prelude.Char]);
xml2infeasibility_proof xml2name x =
  xml_do
    ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'i', 'l', 'i', 't', 'y', 'P', 'r',
      'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_do
          ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'o', 'm', 'p',
            'o', 'u', 'n', 'd', 'C', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
            's']
          (xml_take xml2name
            (\ a ->
              xml_take (xml2nonreachability_proof xml2name)
                (\ b -> xml_return (Infeasible_Compound_Conditions a b)))))
        (xml_or
          (xml_do
            ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'E', 'q', 'u',
              'a', 't', 'i', 'o', 'n']
            (xml_take (rule xml2name)
              (\ a ->
                xml_take (xml2nonreachability_proof xml2name)
                  (\ b -> xml_return (let {
(aa, ba) = a;
                                      } in Infeasible_Equation aa ba
                                       b)))))
          (xml_or
            (xml_do
              ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'S', 'u', 'b',
                's', 'e', 't']
              (xml_take (rules xml2name)
                (\ a ->
                  xml_take (xml2infeasibility_proof xml2name)
                    (\ b -> xml_return (Infeasible_Subset a b)))))
            (xml_do
              ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'R', 'h', 's',
                's', 'E', 'q', 'u', 'a', 'l']
              (xml_take (term xml2name)
                (\ a ->
                  xml_take (term xml2name)
                    (\ b ->
                      xml_take (term xml2name)
                        (\ c ->
                          xml_take (xml2nonjoinability_proof xml2name)
                            (\ d ->
                              xml_return
                                (Infeasible_Rhss_Equal a b c d))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2infeasible_rules_info ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        [(((Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char]),
                            [(Term (Lab a b) [Prelude.Char],
                               Term (Lab a b) [Prelude.Char])]),
                           Infeasibility_proof (Lab a b) [Prelude.Char])];
xml2infeasible_rules_info xml2name =
  xml_do
    ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'R', 'u', 'l', 'e']
        (xml_take (crule xml2name ['r', 'u', 'l', 'e'])
          (\ a ->
            xml_take (xml2infeasibility_proof xml2name)
              (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (id a)));

xml2inline_cond_info ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        [(((Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char]),
                            [(Term (Lab a b) [Prelude.Char],
                               Term (Lab a b) [Prelude.Char])]),
                           [(Term (Lab a b) [Prelude.Char],
                              Term (Lab a b) [Prelude.Char])])];
xml2inline_cond_info xml2name =
  xml_do ['i', 'n', 'l', 'i', 'n', 'e', 'd', 'R', 'u', 'l', 'e', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do ['i', 'n', 'l', 'i', 'n', 'e', 'd', 'R', 'u', 'l', 'e']
        (xml_take (crule xml2name ['r', 'u', 'l', 'e'])
          (\ rule ->
            xml_take
              (conditions xml2name
                ['i', 'n', 'l', 'i', 'n', 'e', 'd', 'C', 'o', 'n', 'd', 'i',
                  't', 'i', 'o', 'n', 's'])
              (\ conds -> xml_return (rule, conds)))))
      xml_return);

xml2conditional_ncr_proof ::
  ((Xml, ([([Prelude.Char], [Prelude.Char])],
           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) (Lab [Prelude.Char] [Nat])) ->
    (Xml, ([([Prelude.Char], [Prelude.Char])],
            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char])
        (Conditional_ncr_proof [Prelude.Char] [Nat] [Prelude.Char]
          [Prelude.Char]);
xml2conditional_ncr_proof xml2name x =
  xml_do
    ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'r', 'D', 'i',
      's', 'p', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_do
          ['u', 'n', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l']
          (xml_take (xml2ncr_proof xml2name)
            (\ xa -> xml_return (Unconditional_CNCR xa))))
        (xml_or
          (xml_do
            ['i', 'n', 'l', 'i', 'n', 'e', 'C', 'o', 'n', 'd', 'i', 't', 'i',
              'o', 'n', 's']
            (xml_take
              (xml_do ['r', 'u', 'l', 'e', 's']
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (crule xml2name ['r', 'u', 'l', 'e']) xml_return))
              (\ a ->
                xml_take (xml2inline_cond_info xml2name)
                  (\ b ->
                    xml_take (xml2conditional_ncr_proof xml2name)
                      (\ c ->
                        xml_return
                          ((Transformation_CNCR . Inline_Conditions_CCRT a) b
                            c))))))
          (xml_or
            (xml_do
              ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'R', 'u', 'l',
                'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
              (xml_take (xml2infeasible_rules_info xml2name)
                (\ a ->
                  xml_take (xml2conditional_ncr_proof xml2name)
                    (\ b ->
                      xml_return
                        ((Transformation_CNCR . Infeasible_Rule_Removal_CCRT) a
                          b)))))
            (xml_do
              ['n', 'o', 'n', 'J', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'F', 'o',
                'r', 'k']
              (xml_take
                (xml_do ['t', 'e', 'r', 'm', 's']
                  (xml_take (term xml2name)
                    (\ a ->
                      xml_take (term xml2name)
                        (\ b ->
                          xml_take (term xml2name)
                            (\ c -> xml_return (a, (b, c)))))))
                (\ a ->
                  xml_take (csteps xml2name)
                    (\ b ->
                      xml_take (csteps xml2name)
                        (\ c ->
                          xml_take (xml2non_join_info xml2name)
                            (\ d ->
                              xml_return
                                (let {
                                   (s, aa) = a;
                                   (ab, ba) = aa;
                                 } in Non_Join_CNCR s ab ba
                                   b
                                   c
                                  d))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2context_joinable_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Context_joinable_proof (Lab a b) [Prelude.Char]);
xml2context_joinable_proof xml2name =
  xml_do
    ['c', 'o', 'n', 't', 'e', 'x', 't', 'J', 'o', 'i', 'n', 'a', 'b', 'i', 'l',
      'i', 't', 'y', 'P', 'r', 'o', 'o', 'f']
    (xml_take (term xml2name)
      (\ a ->
        xml_take (csteps xml2name)
          (\ b ->
            xml_take (csteps xml2name)
              (\ c ->
                xml_take (xml2const_map xml2name)
                  (\ d ->
                    xml_return
                      (Contextual_Join (orig_term d a) (map (orig_cstep d) b)
                        (map (orig_cstep d) c)))))));

xml2context_joinable_ccps ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        [(Term (Lab a b) [Prelude.Char],
                           (Term (Lab a b) [Prelude.Char],
                             ([(Term (Lab a b) [Prelude.Char],
                                 Term (Lab a b) [Prelude.Char])],
                               Context_joinable_proof (Lab a b)
                                 [Prelude.Char])))];
xml2context_joinable_ccps xml2name =
  xml_do
    ['c', 'o', 'n', 't', 'e', 'x', 't', 'J', 'o', 'i', 'n', 'a', 'b', 'l', 'e',
      'C', 'C', 'P', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['c', 'o', 'n', 't', 'e', 'x', 't', 'J', 'o', 'i', 'n', 'a', 'b', 'l',
          'e', 'C', 'C', 'P']
        (xml_take (term xml2name)
          (\ s ->
            xml_take (term xml2name)
              (\ t ->
                xml_take
                  (conditions xml2name
                    ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's'])
                  (\ cs ->
                    xml_take (xml2context_joinable_proof xml2name)
                      (\ p -> xml_return (s, (t, (cs, p)))))))))
      xml_return);

xml2ao_infeasibility_proof ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Ao_infeasibility_proof (Lab a b) [Prelude.Char]);
xml2ao_infeasibility_proof xml2name =
  xml_do
    ['a', 'o', 'I', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'i', 'l', 'i', 't', 'y',
      'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_change (xml2infeasibility_proof xml2name)
          (xml_return . AO_Infeasibility_Proof))
        (xml_do ['a', 'o', 'L', 'h', 's', 's', 'E', 'q', 'u', 'a', 'l']
          (xml_take (term xml2name)
            (\ a ->
              xml_take (term xml2name)
                (\ b ->
                  xml_take (term xml2name)
                    (\ c ->
                      xml_take (xml2nonjoinability_proof xml2name)
                        (\ d -> xml_return (AO_Lhss_Equal a b c d))))))))
      (\ x -> xml_return (id x)));

xml2ao_infeasible_conds ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        [([(Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char])],
                           ([(Term (Lab a b) [Prelude.Char],
                               Term (Lab a b) [Prelude.Char])],
                             Ao_infeasibility_proof (Lab a b) [Prelude.Char]))];
xml2ao_infeasible_conds xml2name =
  xml_do
    ['a', 'o', 'I', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'o', 'n',
      'd', 'i', 't', 'i', 'o', 'n', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['a', 'o', 'I', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'o',
          'n', 'd', 'i', 't', 'i', 'o', 'n']
        (xml_take
          (conditions xml2name
            ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's'])
          (\ a ->
            xml_take
              (conditions xml2name
                ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's'])
              (\ b ->
                xml_take (xml2ao_infeasibility_proof xml2name)
                  (\ c -> xml_return (a, (b, c)))))))
      (\ a -> xml_return (id a)));

xml2infeasible_conds ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        [([(Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char])],
                           Infeasibility_proof (Lab a b) [Prelude.Char])];
xml2infeasible_conds xml2name =
  xml_do
    ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i',
      't', 'i', 'o', 'n', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'o', 'n', 'd',
          'i', 't', 'i', 'o', 'n']
        (xml_take
          (conditions xml2name
            ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's'])
          (\ a ->
            xml_take (xml2infeasibility_proof xml2name)
              (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (id a)));

xml2unfeasible_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Unfeasible_proof (Lab a b) [Prelude.Char]);
xml2unfeasible_proof xml2name =
  xml_do
    ['u', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'i', 'l', 'i', 't', 'y', 'P', 'r',
      'o', 'o', 'f']
    (xml_take
      (xml_do ['t', 'e', 'r', 'm', 's']
        (xml_take (term xml2name)
          (\ a ->
            xml_take (term xml2name)
              (\ b ->
                xml_take (term xml2name) (\ c -> xml_return (a, (b, c)))))))
      (\ a ->
        xml_take (csteps xml2name)
          (\ b ->
            xml_take (csteps xml2name)
              (\ c ->
                xml_take
                  (xml_do ['r', 'u', 'l', 'e', 's']
                    (xml_take (crule xml2name ['r', 'u', 'l', 'e'])
                      (\ aa ->
                        xml_take (crule xml2name ['r', 'u', 'l', 'e'])
                          (\ ba -> xml_return (aa, ba)))))
                  (\ d ->
                    xml_take (xml2const_map xml2name)
                      (\ e ->
                        xml_return
                          (let {
                             (t, (u, v)) = a;
                           } in (\ ps qs (r, ra) m ->
                                  UnfeasibleOverlap (orig_term m t)
                                    (orig_term m u) (orig_term m v)
                                    (map (orig_cstep m) ps)
                                    (map (orig_cstep m) qs) r ra)
                             b
                             c
                             d
                            e)))))));

xml2unfeasible_ccps ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        [([Prelude.Char] -> Term (Lab a b) [Prelude.Char],
                           Unfeasible_proof (Lab a b) [Prelude.Char])];
xml2unfeasible_ccps xml2name =
  xml_do ['u', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'C', 'P', 's']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do ['u', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'C', 'C', 'P']
        (xml_take (substa xml2name)
          (\ a ->
            xml_take (xml2unfeasible_proof xml2name)
              (\ b -> xml_return (subst_of a, b)))))
      (\ a -> xml_return (id a)));

xml2conditional_cr_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Conditional_cr_proof a b [Prelude.Char]);
xml2conditional_cr_proof xml2name x =
  xml_do
    ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'r', 'P', 'r',
      'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_do
          ['u', 'n', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l']
          (xml_take (xml2cr_proof xml2name)
            (\ xa -> xml_return (Unconditional_CR xa))))
        (xml_or
          (xml_do ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g']
            (xml_take (unraveling_info xml2name)
              (\ a ->
                xml_take (xml2cr_proof xml2name)
                  (\ b -> xml_return (Unravel_CR a b)))))
          (xml_or
            (xml_do
              ['i', 'n', 'l', 'i', 'n', 'e', 'C', 'o', 'n', 'd', 'i', 't', 'i',
                'o', 'n', 's']
              (xml_take
                (xml_do ['r', 'u', 'l', 'e', 's']
                  (xml_take_many_sub [] zero_nat Infinity_enat
                    (crule xml2name ['r', 'u', 'l', 'e']) xml_return))
                (\ a ->
                  xml_take (xml2inline_cond_info xml2name)
                    (\ b ->
                      xml_take (xml2conditional_cr_proof xml2name)
                        (\ c ->
                          xml_return
                            ((Transformation_CR . Inline_Conditions_CCRT a) b
                              c))))))
            (xml_or
              (xml_do
                ['i', 'n', 'f', 'e', 'a', 's', 'i', 'b', 'l', 'e', 'R', 'u',
                  'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
                (xml_take (xml2infeasible_rules_info xml2name)
                  (\ a ->
                    xml_take (xml2conditional_cr_proof xml2name)
                      (\ b ->
                        xml_return
                          ((Transformation_CR . Infeasible_Rule_Removal_CCRT) a
                            b)))))
              (xml_or
                (xml_leaf
                  ['a', 'l', 'm', 'o', 's', 't', 'O', 'r', 't', 'h', 'o', 'g',
                    'o', 'n', 'a', 'l']
                  Almost_Orthogonal_CR)
                (xml_or
                  (xml_do
                    ['a', 'l', 'm', 'o', 's', 't', 'O', 'r', 't', 'h', 'o', 'g',
                      'o', 'n', 'a', 'l', 'M', 'o', 'd', 'u', 'l', 'o', 'I',
                      'n', 'f', 'e', 'a', 's', 'i', 'b', 'i', 'l', 'i', 't',
                      'y']
                    (xml_take (xml2ao_infeasible_conds xml2name)
                      (\ xa ->
                        xml_return
                          (Almost_Orthogonal_Modulo_Infeasibility_CRa xa))))
                  (xml_do ['a', 'l', '9', '4']
                    (xml_take (xml2quasi_reductive_proof xml2name)
                      (\ a ->
                        xml_take (xml2context_joinable_ccps xml2name)
                          (\ b ->
                            xml_take (xml2infeasible_conds xml2name)
                              (\ c ->
                                xml_take (xml2unfeasible_ccps xml2name)
                                  (\ d ->
                                    xml_return (AL94_CR a b c d)))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2ac_dp_termination_proof ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Ac_dp_termination_proof (Lab a b) [Prelude.Char]);
xml2ac_dp_termination_proof xml2name x =
  xml_do
    ['a', 'c', 'D', 'P', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
      'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_do
          ['a', 'c', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c']
          (xml_take (ordering_constraint_proof xml2name False)
            (\ a ->
              xml_take
                (xml_do ['d', 'p', 's']
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ b ->
                  xml_take
                    (xml_do
                      ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ c ->
                      xml_take (xml2ac_dp_termination_proof xml2name)
                        (\ d -> xml_return (AC_Redpair_UR_Proc a b c d)))))))
        (xml_or
          (xml_do
            ['a', 'c', 'S', 'u', 'b', 't', 'e', 'r', 'm', 'P', 'r', 'o', 'c']
            (xml_take (multiset_af xml2name)
              (\ a ->
                xml_take
                  (xml_do ['d', 'p', 's']
                    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                  (\ b ->
                    xml_take (xml2ac_dp_termination_proof xml2name)
                      (\ c -> xml_return (AC_Subterm_Proc a b c))))))
          (xml_or
            (xml_leaf
              ['a', 'c', 'T', 'r', 'i', 'v', 'i', 'a', 'l', 'P', 'r', 'o', 'c']
              AC_P_is_Empty)
            (xml_or
              (xml_do
                ['a', 'c', 'M', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i',
                  'r', 'P', 'r', 'o', 'c']
                (xml_take (ordering_constraint_proof xml2name False)
                  (\ a ->
                    xml_take
                      (xml_do ['d', 'p', 's']
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ b ->
                        xml_take
                          (xml_do ['t', 'r', 's']
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ c ->
                            xml_take
                              (xml_do
                                ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l',
                                  'e', 's']
                                (xml_take (rules xml2name)
                                  (\ xa -> xml_return (id xa))))
                              (\ d ->
                                xml_take (xml2ac_dp_termination_proof xml2name)
                                  (\ e ->
                                    xml_return
                                      (AC_Mono_Redpair_UR_Proc a b c d e))))))))
              (xml_do
                ['a', 'c', 'D', 'e', 'p', 'G', 'r', 'a', 'p', 'h', 'P', 'r',
                  'o', 'c']
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (xml_do ['c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't']
                    (xml_take
                      (xml_do ['d', 'p', 's']
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ dps ->
                        xml_take_optional
                          (xml_bool ['r', 'e', 'a', 'l', 'S', 'c', 'c'])
                          (\ _ ->
                            xml_take_optional
                              (xml2ac_dp_termination_proof xml2name)
                              (\ prfOpt -> xml_return (prfOpt, dps))))))
                  (\ ret -> xml_return (AC_Dep_Graph_Proc ret))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2ac_termination_proof ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Ac_termination_proof a b [Prelude.Char]);
xml2ac_termination_proof xml2name x =
  xml_do
    ['a', 'c', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r',
      'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_do
          ['a', 'c', 'D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', 'P', 'a',
            'i', 'r', 's']
          (xml_take
            (xml_do ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's']
              (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
            (\ e ->
              xml_take
                (xml_do ['d', 'p', 'E', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's']
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ dpe ->
                  xml_take
                    (xml_do ['d', 'p', 's']
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ dp ->
                      xml_take
                        (xml_do
                          ['e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', 's']
                          (xml_take (rules xml2name)
                            (\ xa -> xml_return (id xa))))
                        (\ rext ->
                          xml_take (xml2ac_dp_termination_proof xml2name)
                            (\ p1 ->
                              xml_take_optional
                                (xml2ac_dp_termination_proof xml2name)
                                (\ a ->
                                  (case a of {
                                    Nothing ->
                                      xml_return
(AC_DP_Trans_Single (AC_dependency_pairs_proof e dp dpe rext) p1);
                                    Just p2 ->
                                      xml_return
(AC_DP_Trans (AC_dependency_pairs_proof e dp dpe rext) p1 p2);
                                  })))))))))
        (xml_or
          (xml_do
            ['a', 'c', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
            (xml_take (ordering_constraint_proof xml2name False)
              (\ a ->
                xml_take
                  (xml_do ['t', 'r', 's']
                    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                  (\ b ->
                    xml_take (xml2ac_termination_proof xml2name)
                      (\ c -> xml_return (AC_Rule_Removal a b c))))))
          (xml_leaf ['a', 'c', 'R', 'I', 's', 'E', 'm', 'p', 't', 'y']
            AC_R_is_Empty)))
      (\ xa -> xml_return (id xa)))
    x;

subsumption_proof ::
  forall a.
    (Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                          (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                   Sum (Xml_error [Prelude.Char]) a) ->
                   (Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                     Sum (Xml_error [Prelude.Char])
                       [((Term a [Prelude.Char], Term a [Prelude.Char]),
                          [(Pos, ((Term a [Prelude.Char],
                                    Term a [Prelude.Char]),
                                   (Bool, Term a [Prelude.Char])))])];
subsumption_proof xml2name =
  xml_do
    ['s', 'u', 'b', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o',
      'f']
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do
        ['r', 'u', 'l', 'e', 'S', 'u', 'b', 's', 'u', 'm', 'p', 't', 'i', 'o',
          'n', 'P', 'r', 'o', 'o', 'f']
        (xml_take (rule xml2name)
          (\ r ->
            xml_take (conversion xml2name) (\ (_, e) -> xml_return (r, e)))))
      xml_return);

xml2completion_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Completion_proof a b [Prelude.Char]);
xml2completion_proof xml2name =
  xml_do
    ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (xml_take (wcr_proof xml2name)
      (\ w ->
        xml_take (xml2trs_termination_proof xml2name)
          (\ t ->
            xml_take
              (xml_do
                ['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e', 'P',
                  'r', 'o', 'o', 'f']
                (xml_take (subsumption_proof xml2name)
                  (\ s1 ->
                    xml_take_optional (subsumption_proof xml2name)
                      (\ s2 -> xml_return (s1, s2)))))
              (\ (s1, s2) -> xml_return (SN_WCR_Eq w t s1 s2)))));

xml2equational_disproof ::
  forall a.
    (Eq a, Key a,
      Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a [Nat])) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Equational_disproof a [Nat] [Prelude.Char]);
xml2equational_disproof xml2name =
  xml_do
    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'D', 'i', 's', 'p', 'r',
      'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_do
          ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'A', 'n', 'd', 'N',
            'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n']
          (xml_take
            (xml_do ['t', 'r', 's']
              (xml_take (rules xml2name) (\ x -> xml_return (id x))))
            (\ a ->
              xml_take (xml2completion_proof xml2name)
                (\ b ->
                  xml_return (Completion_and_Normalization_Different a b)))))
        (xml_do
          ['c', 'o', 'n', 'v', 'e', 'r', 't', 'i', 'b', 'l', 'e', 'I', 'n', 's',
            't', 'a', 'n', 'c', 'e']
          (xml_take (subsumption_proof xml2name)
            (\ x -> xml_return (Convertible_Instance x)))))
      (\ x -> xml_return (id x)));

xml2unknown_disproof ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Neg_unknown_proof a b [Prelude.Char]);
xml2unknown_disproof xml2name x =
  xml_do
    ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't', 'P', 'r', 'o',
      'o', 'f']
    (xml_take
      (xml_or
        (xml_do
          ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 's', 's', 'u', 'm', 'p', 't',
            'i', 'o', 'n']
          (xml_take xml2unknown_input
            (\ xa -> xml_return (Assume_NT_Unknown xa []))))
        (xml_do ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
          (xml_take
            (xml_text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (\ _ ->
              xml_take xml2unknown_input
                (\ b ->
                  xml_take_many_sub [] zero_nat Infinity_enat
                    (\ xa -> Inr (fst xa))
                    (\ _ -> xml_return (Assume_NT_Unknown b [])))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2equational_proof ::
  forall a.
    (Eq a, Key a,
      Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a [Nat])) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Equational_proof a [Nat] [Prelude.Char]);
xml2equational_proof xml2name =
  xml_do
    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_do
          ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o', 'o',
            'f', 'T', 'r', 'e', 'e']
          (xml_take (xml2eq_proof xml2name)
            (\ x -> xml_return (Equational_Proof_Tree x))))
        (xml_or
          (xml_change (conversion xml2name)
            (\ (_, e) -> xml_return (Conversion e)))
          (xml_or
            (xml_change (subsumption_proof xml2name)
              (xml_return . Conversion_With_History))
            (xml_do
              ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'A', 'n', 'd',
                'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n']
              (xml_take
                (xml_do ['t', 'r', 's']
                  (xml_take (rules xml2name) (\ x -> xml_return (id x))))
                (\ a ->
                  xml_take (xml2completion_proof xml2name)
                    (\ b -> xml_return (Completion_and_Normalization a b))))))))
      (\ x -> xml_return (id x)));

xml2complexity_inputa ::
  forall a.
    (Eq a,
      Showa a) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) a) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        ([Term a [Prelude.Char]],
                          ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                              (Complexity_measure a [Prelude.Char],
                                Complexity_class))));
xml2complexity_inputa xml2name =
  xml_change (xml2complexity_input xml2name)
    (\ (CPX_input q s w cm cc) ->
      xml_return (strategy_to_Q q (s ++ w), (s, (w, (cm, cc)))));

xml2complexity_proof ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Complexity_proof a b [Prelude.Char]);
xml2complexity_proof xml2name x =
  xml_do
    ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'P', 'r', 'o', 'o', 'f']
    (xml_take
      (xml_or
        (xml_do ['r', 'u', 'l', 'e', 'S', 'h', 'i', 'f', 't', 'i', 'n', 'g']
          (xml_take (ordering_constraint_proof xml2name True)
            (\ rp ->
              xml_take
                (xml_do ['t', 'r', 's']
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ del ->
                  xml_take_optional
                    (xml_do
                      ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ ur ->
                      xml_take (xml2complexity_proof xml2name)
                        (\ prf ->
                          xml_return (Rule_Shift_Complexity rp del ur prf)))))))
        (xml_or
          (xml_do ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
            (xml_take
              (xml_do
                ['n', 'o', 'n', 'U', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l',
                  'e', 's']
                (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
              (\ a ->
                xml_take (xml2complexity_proof xml2name)
                  (\ b -> xml_return (Usable_Rules_Complexity a b)))))
          (xml_or
            (xml_do ['s', 'p', 'l', 'i', 't']
              (xml_take
                (xml_do ['t', 'r', 's']
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ a ->
                  xml_take (xml2complexity_proof xml2name)
                    (\ b ->
                      xml_take (xml2complexity_proof xml2name)
                        (\ c -> xml_return (Split_Complexity a b c))))))
            (xml_or
              (xml_do
                ['r', 'e', 'm', 'o', 'v', 'e', 'N', 'o', 'n', 'A', 'p', 'p',
                  'l', 'i', 'c', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                (xml_take
                  (xml_do ['t', 'r', 's']
                    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                  (\ a ->
                    xml_take (xml2complexity_proof xml2name)
                      (\ b ->
                        xml_return
                          (Remove_Nonapplicable_Rules_Complexity a b)))))
              (xml_or
                (xml_change (bounds_info xml2name)
                  (xml_return . Matchbounds_Complexity))
                (xml_or
                  (xml_do
                    ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'B', 'o', 'u', 'n',
                      'd', 's']
                    (xml_take (bounds_info xml2name)
                      (\ a ->
                        xml_take
                          (xml_do ['t', 'r', 's']
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ b ->
                            xml_take (xml2complexity_proof xml2name)
                              (\ c ->
                                xml_return
                                  (Matchbounds_Rel_Complexity a b c))))))
                  (xml_or
                    (xml_leaf ['r', 'I', 's', 'E', 'm', 'p', 't', 'y']
                      RisEmpty_Complexity)
                    (xml_or
                      (xml_do
                        ['d', 't', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm',
                          'a', 't', 'i', 'o', 'n']
                        (xml_take
                          (rule_pairs xml2name
                            ['s', 't', 'r', 'i', 'c', 't', 'D', 'T', 's']
                            ['r', 'u', 'l', 'e', 'W', 'i', 't', 'h', 'D', 'T'])
                          (\ a ->
                            xml_take
                              (rule_pairs xml2name
                                ['w', 'e', 'a', 'k', 'D', 'T', 's']
                                ['r', 'u', 'l', 'e', 'W', 'i', 't', 'h', 'D',
                                  'T'])
                              (\ b ->
                                xml_take (innermostLhss xml2name)
                                  (\ c ->
                                    xml_take (xml2complexity_proof xml2name)
                                      (\ d ->
xml_return (DT_Transformation (DT_Transformation_Info a b c) d)))))))
                      (xml_or
                        (xml_do
                          ['w', 'd', 'p', 'T', 'r', 'a', 'n', 's', 'f', 'o',
                            'r', 'm', 'a', 't', 'i', 'o', 'n']
                          (xml_take
                            (symbols xml2name
                              ['c', 'o', 'm', 'p', 'o', 'u', 'n', 'd', 'S', 'y',
                                'm', 'b', 'o', 'l', 's'])
                            (\ a ->
                              xml_take
                                (rule_pairs xml2name
                                  ['s', 't', 'r', 'i', 'c', 't', 'W', 'D', 'P',
                                    's']
                                  ['r', 'u', 'l', 'e', 'W', 'i', 't', 'h', 'W',
                                    'D', 'P'])
                                (\ b ->
                                  xml_take
                                    (rule_pairs xml2name
                                      ['w', 'e', 'a', 'k', 'W', 'D', 'P', 's']
                                      ['r', 'u', 'l', 'e', 'W', 'i', 't', 'h',
'W', 'D', 'P'])
                                    (\ c ->
                                      xml_take (innermostLhss xml2name)
(\ d ->
  xml_take (xml2complexity_proof xml2name)
    (\ e ->
      xml_return (WDP_Transformation (WDP_Trans_Info (set a) b c d) e))))))))
                        (xml_or
                          (xml_do
                            ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o',
                              'o', 'f']
                            (xml_take
                              (xml_text
                                ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i',
                                  'o', 'n'])
                              (\ _ ->
                                xml_take (xml2complexity_inputa xml2name)
                                  (\ b ->
                                    xml_take_many_sub [] zero_nat Infinity_enat
                                      (xml_do
['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
(xml_take (xml2complexity_inputa xml2name)
  (\ a ->
    xml_take (xml2complexity_proof xml2name)
      (\ ba -> xml_return (Complexity_assm_proof a ba)))))
                                      (\ c ->
xml_return (Complexity_Assumption b c))))))
                          (xml_do
                            ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y',
                              'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
                            (xml_take (xml2complexity_inputa xml2name)
                              (\ xa ->
                                xml_return
                                  (Complexity_Assumption xa []))))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2unknown_proof ::
  forall a b.
    (Key a, Showa a, Key b,
      Showa b) => ((Xml, ([([Prelude.Char], [Prelude.Char])],
                           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                    Sum (Xml_error [Prelude.Char]) (Lab a b)) ->
                    (Xml, ([([Prelude.Char], [Prelude.Char])],
                            (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
                      Sum (Xml_error [Prelude.Char])
                        (Unknown_proof a b [Prelude.Char]);
xml2unknown_proof xml2name x =
  xml_do
    ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't', 'P', 'r', 'o',
      'o', 'f']
    (xml_take
      (xml_or
        (xml_do
          ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 's', 's', 'u', 'm', 'p', 't',
            'i', 'o', 'n']
          (xml_take xml2unknown_input
            (\ xa -> xml_return (Assume_Unknown xa []))))
        (xml_do ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
          (xml_take
            (xml_text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (\ _ ->
              xml_take xml2unknown_input
                (\ b ->
                  xml_take_many_sub [] zero_nat Infinity_enat
                    (\ xa -> Inr (fst xa))
                    (\ _ -> xml_return (Assume_Unknown b [])))))))
      xml_return)
    x;

xml2cert_problem ::
  ((Xml, ([([Prelude.Char], [Prelude.Char])],
           (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
    Sum (Xml_error [Prelude.Char]) [Prelude.Char]) ->
    ((Xml, ([([Prelude.Char], [Prelude.Char])],
             (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
      Sum (Xml_error [Prelude.Char]) (Lab [Prelude.Char] [Nat])) ->
      (Xml, ([([Prelude.Char], [Prelude.Char])],
              (Bool, ([[Prelude.Char]], [[Prelude.Char]])))) ->
        Sum (Xml_error [Prelude.Char])
          (Maybe (Input (Lab [Prelude.Char] [Nat]) [Prelude.Char]),
            Proof [Prelude.Char] [Nat] [Prelude.Char]);
xml2cert_problem xml2uname xml2name =
  xml_do
    ['c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'P', 'r',
      'o', 'b', 'l', 'e', 'm']
    (xml_take_optional (xml2input xml2name)
      (\ inp ->
        xml_take_optional
          (xml_text ['c', 'p', 'f', 'V', 'e', 'r', 's', 'i', 'o', 'n'])
          (\ _ ->
            xml_take
              (xml_do ['p', 'r', 'o', 'o', 'f']
                (xml_take
                  (xml_or
                    (xml_change (xml2trs_termination_proof xml2name)
                      (xml_return . TRS_Termination_Proof))
                    (xml_or
                      (xml_change (xml2trs_nontermination_proof xml2name)
                        (xml_return . TRS_Nontermination_Proof))
                      (xml_or
                        (xml_change (xml2reltrs_nontermination_proof xml2name)
                          (xml_return . Relative_TRS_Nontermination_Proof))
                        (xml_or
                          (xml_change (xml2cr_proof xml2name)
                            (xml_return . TRS_Confluence_Proof))
                          (xml_or
                            (xml_change (xml2ncr_proof xml2name)
                              (xml_return . TRS_Non_Confluence_Proof))
                            (xml_or
                              (xml_change (xml2dp_termination_proof xml2name)
                                (xml_return . DP_Termination_Proof))
                              (xml_or
                                (xml_change
                                  (xml2dp_nontermination_proof xml2name)
                                  (xml_return . DP_Nontermination_Proof))
                                (xml_or
                                  (xml_change (xml2completion_proof xml2name)
                                    (xml_return . Completion_Proof))
                                  (xml_or
                                    (xml_change (xml2equational_proof xml2name)
                                      (xml_return . Equational_Proof))
                                    (xml_or
                                      (xml_change
(xml2equational_disproof xml2name) (xml_return . Equational_Disproof))
                                      (xml_or
(xml_change (xml2complexity_proof xml2name) (xml_return . Complexity_Proof))
(xml_or
  (xml_change (xml2quasi_reductive_proof xml2name)
    (xml_return . Quasi_Reductive_Proof))
  (xml_or
    (xml_change (xml2conditional_cr_proof xml2name)
      (xml_return . Conditional_CR_Proof))
    (xml_or
      (xml_change (xml2conditional_ncr_proof xml2name)
        (xml_return . Conditional_Non_CR_Proof))
      (xml_or
        (xml_do
          ['t', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', 'C',
            'l', 'o', 's', 'e', 'd', 'P', 'r', 'o', 'o', 'f']
          (xml_take closed_criterion
            (\ x -> xml_return (Tree_Automata_Closed_Proof x))))
        (xml_or
          (xml_change (xml2ac_termination_proof xml2name)
            (xml_return . AC_Termination_Proof))
          (xml_or
            (xml_do
              ['l', 't', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                'n', 'P', 'r', 'o', 'o', 'f']
              (xml_take lts_termination_proof_parser
                (\ x -> xml_return (LTS_Termination_Proof x))))
            (xml_or
              (xml_do
                ['l', 't', 's', 'S', 'a', 'f', 'e', 't', 'y', 'P', 'r', 'o',
                  'o', 'f']
                (xml_take lts_safety_proof_parser
                  (\ x -> xml_return (LTS_Safety_Proof x))))
              (xml_or
                (xml_change (xml2unknown_proof xml2name)
                  (xml_return . Unknown_Proof))
                (xml_change (xml2unknown_disproof xml2name)
                  (xml_return . Unknown_Disproof)))))))))))))))))))))
                  xml_return))
              (\ p ->
                xml_take_optional (\ x -> Inr (fst x))
                  (\ _ -> xml_return (inp, p))))));

impl_ofe ::
  forall b a.
    (Key b) => Ac_dpp b a ->
                 ([(Term b a, Term b a)],
                   ([(Term b a, Term b a)],
                     ([(Term b a, Term b a)],
                       ([(Term b a, Term b a)],
                         ([(Term b a, Term b a)],
                           Rbt (b, Nat) [((), (Term b a, Term b a))])))));
impl_ofe (AC_DPP x) = x;

rw_implb ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
rw_implb (p, (pw, (r, (rw, (e, uu))))) = rw;

rwb :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
rwb xa = rw_implb (impl_ofe xa);

r_implb ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
r_implb (p, (pw, (r, (rw, (e, uu))))) = r;

rb :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
rb xa = r_implb (impl_ofe xa);

e_impl ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
e_impl (p, (pw, (r, (rw, (e, uu))))) = e;

e :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
e xa = e_impl (impl_ofe xa);

eq_rules_non_collapsing :: forall a b. (Key a) => Ac_dpp a b -> Bool;
eq_rules_non_collapsing d = let {
                              t = all (\ (_, r) -> not (is_Var r));
                            } in t (rb d) && t (rwb d) && t (e d);

eq_rules_no_left_var :: forall a b. (Key a) => Ac_dpp a b -> Bool;
eq_rules_no_left_var d = let {
                           t = all (\ (l, _) -> not (is_Var l));
                         } in t (rb d) && t (rwb d) && t (e d);

mk_implb ::
  forall a b.
    (Eq a, Key a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     [(Term a b, Term a b)] ->
                       [(Term a b, Term a b)] ->
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   Rbt (a, Nat)
                                     [((), (Term a b, Term a b))])))));
mk_implb p pw r rw e =
  (p, (pw, (r, (rw, (e, insert_rules () (r ++ rw ++ e) empty)))));

delete_pairs_rules_impl ::
  forall a b.
    (Eq a, Key a,
      Eq b) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               Rbt (a, Nat) [((), (Term a b, Term a b))])))));
delete_pairs_rules_impl (p, (pw, (r, (rw, (e, m))))) pd rd =
  (if null rd then (list_diff p pd, (list_diff pw pd, (r, (rw, (e, m)))))
    else mk_implb (list_diff p pd) (list_diff pw pd) (list_diff r rd)
           (list_diff rw rd) e);

delete_pairs_rules ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Ac_dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Ac_dpp a b;
delete_pairs_rules xc xd xe =
  AC_DPP (delete_pairs_rules_impl (impl_ofe xc) xd xe);

reverse_rules_mapa ::
  forall a b. (Eq a, Key a) => Ac_dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_mapa d fn =
  concatMap (\ (l, r) -> (if root r == Just fn then [(r, l)] else []))
    (rb d ++ rwb d ++ e d);

intersect_pairs_impla ::
  forall a b.
    (Eq a, Key a,
      Eq b) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             Rbt (a, Nat) [((), (Term a b, Term a b))])))));
intersect_pairs_impla (p, (pw, (r, (rw, (e, m))))) pd =
  (list_inter p pd, (list_inter pw pd, (r, (rw, (e, m)))));

intersect_pairsa ::
  forall a b.
    (Eq a, Key a, Eq b) => Ac_dpp a b -> [(Term a b, Term a b)] -> Ac_dpp a b;
intersect_pairsa xb xc = AC_DPP (intersect_pairs_impla (impl_ofe xb) xc);

rules_map_implb ::
  forall a b.
    (Key a) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
rules_map_implb (p, (pw, (r, (rw, (e, m))))) fn = (case lookup m fn of {
            Nothing -> [];
            Just a -> map snd a;
          });

rules_mapb ::
  forall a b. (Key a) => Ac_dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_mapb xa = rules_map_implb (impl_ofe xa);

ac_dpp_impl ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 (Set (Term a b, Term a b),
                   (Set (Term a b, Term a b),
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b), Set (Term a b, Term a b)))));
ac_dpp_impl (p, (pw, (r, (rw, (e, uu))))) =
  (set p, (set pw, (set r, (set rw, set e))));

ac_dpp ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => Ac_dpp a b ->
                 (Set (Term a b, Term a b),
                   (Set (Term a b, Term a b),
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b), Set (Term a b, Term a b)))));
ac_dpp xa = ac_dpp_impl (impl_ofe xa);

rules_implc ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
rules_implc (p, (pw, (r, (rw, (e, uu))))) = r ++ rw;

rulesc :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
rulesc xa = rules_implc (impl_ofe xa);

pairs_impla ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
pairs_impla (p, (pw, (r, (rw, (e, uu))))) = p ++ pw;

pairsa :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
pairsa xa = pairs_impla (impl_ofe xa);

mkb ::
  forall a b.
    (Eq a, Key a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     [(Term a b, Term a b)] ->
                       [(Term a b, Term a b)] -> Ac_dpp a b;
mkb xc xd xe xf xg = AC_DPP (mk_implb xc xd xe xf xg);

pw_impla ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
pw_impla (p, (pw, (r, (rw, (e, uu))))) = pw;

pwa :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
pwa xa = pw_impla (impl_ofe xa);

p_impla ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
p_impla (p, (pw, (r, (rw, (e, uu))))) = p;

pa :: forall a b. (Key a) => Ac_dpp a b -> [(Term a b, Term a b)];
pa xa = p_impla (impl_ofe xa);

ac_dpp_rbt_impl ::
  forall a b.
    (Eq a, Key a, Compare b, Eq b) => Ac_dpp_ops_ext (Ac_dpp a b) a b ();
ac_dpp_rbt_impl =
  Ac_dpp_ops_ext ac_dpp pa pwa pairsa rb rwb rulesc e mkb rules_mapb
    reverse_rules_mapa delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairsa ();

c_rules_impl ::
  forall a. [a] -> [(Term a [Prelude.Char], Term a [Prelude.Char])];
c_rules_impl c = let {
                   x = Var ['x'];
                   y = Var ['y'];
                 } in map (\ f -> (Fun f [x, y], Fun f [y, x])) c;

a_trs_impl :: forall a. [a] -> [(Term a [Prelude.Char], Term a [Prelude.Char])];
a_trs_impl a =
  let {
    x = Var ['x'];
    y = Var ['y'];
    z = Var ['z'];
  } in map (\ f -> (Fun f [Fun f [x, y], z], Fun f [x, Fun f [y, z]])) a ++
         map (\ f -> (Fun f [x, Fun f [y, z]], Fun f [Fun f [x, y], z])) a;

aC_trs_impl ::
  forall a. [a] -> [a] -> [(Term a [Prelude.Char], Term a [Prelude.Char])];
aC_trs_impl a c = a_trs_impl a ++ c_rules_impl c;

ac_tp_list_impl ::
  forall a.
    (Ceq a, Ccompare a, Compare a, Eq a,
      Set_impl a) => Ac_tp_ops_ext
                       ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                         ([a], [a]))
                       a [Prelude.Char] ();
ac_tp_list_impl =
  Ac_tp_ops_ext (\ (r, a) -> let {
                               (aa, c) = a;
                             } in (set r, (set aa, set c)))
    (\ (r, (_, _)) -> r) (\ (_, a) -> let {
(aa, _) = a;
                                      } in aa)
    (\ (_, (_, c)) -> c) (\ r a c -> (r, (a, c)))
    (\ (r, a) -> let {
                   (aa, c) = a;
                 } in (\ dr -> (list_diff r dr, (aa, c))))
    (\ (_, a) -> let {
                   (aa, b) = a;
                 } in aC_trs_impl aa b)
    ();

rules_non_collapsing_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
rules_non_collapsing_impl (uu, (uv, (uw, (ux, (uy, (uz, (nc, va))))))) = nc;

impl_ofd ::
  forall b a.
    (Key b) => Dpp b a ->
                 (Bool,
                   (Bool,
                     ([(Term b a, Term b a)],
                       ([(Term b a, Term b a)],
                         ([Term b a],
                           (Bool,
                             (Bool,
                               ([(Term b a, Term b a)],
                                 ([(Term b a, Term b a)],
                                   (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                                     (Rbt (b, Nat)
[(Bool, (Term b a, Term b a))],
                                       (Bool, Term b a -> Bool))))))))))));
impl_ofd (DPP x) = x;

rules_non_collapsing :: forall a b. (Key a) => Dpp a b -> Bool;
rules_non_collapsing d = rules_non_collapsing_impl (impl_ofd d);

nFQ_subset_NF_rules_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
nFQ_subset_NF_rules_impla (uu, (uv, (uw, (ux, (uy, (b, uz)))))) = b;

nFQ_subset_NF_rulesa :: forall a b. (Key a) => Dpp a b -> Bool;
nFQ_subset_NF_rulesa d = nFQ_subset_NF_rules_impla (impl_ofd d);

rules_no_left_var_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
rules_no_left_var_impl (uu, (uv, (uw, (ux, (uy, (uz, (va, ([], ([], vb)))))))))
  = True;
rules_no_left_var_impl (v, (vb, (ve, (vg, (vi, (vk, (vm, (vq : vr, vp)))))))) =
  False;
rules_no_left_var_impl
  (v, (vb, (ve, (vg, (vi, (vk, (vm, (vo, (vs : vt, vr))))))))) = False;

rules_no_left_var :: forall a b. (Key a) => Dpp a b -> Bool;
rules_no_left_var d = rules_no_left_var_impl (impl_ofd d);

reverse_rules_map_impl ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_map_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (m, ve))))))))))) fn =
  (case lookup m fn of {
    Nothing -> [];
    Just a -> map snd a;
  });

reverse_rules_map ::
  forall a b. (Key a) => Dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_map d = reverse_rules_map_impl (impl_ofd d);

is_NF_trs_subset ::
  forall a b. (Term a b -> Bool) -> [(Term a b, Term a b)] -> Bool;
is_NF_trs_subset is_Q_nf r = is_NF_subset is_Q_nf (map fst r);

wwf_qtrs_impl ::
  forall a b. (Eq b) => (Term a b -> Bool) -> [(Term a b, Term a b)] -> Bool;
wwf_qtrs_impl nf r =
  all (\ ra -> wf_rule ra || not (applicable_rule_impl nf ra)) r;

intersect_rules_impl ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   (Bool,
                     (Bool,
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([Term a b],
                             (Bool,
                               (Bool,
                                 ([(Term a b, Term a b)],
                                   ([(Term a b, Term a b)],
                                     (Rbt (a, Nat)
[(Bool, (Term a b, Term a b))],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Bool, Term a b -> Bool))))))))))));
intersect_rules_impl d ri =
  let {
    (nfs, (mi, (p, (pw, (q, (nfq, (nc, (vR,
 (vRw, (m, (rm, (wwf, isnf))))))))))))
      = d;
    (vri, ria) = partition (is_Var . fst) ri;
    vr = list_inter vR vri;
    vrw = list_inter vRw vri;
    ma = intersect_rules ria m;
    rma = intersect_rules (reverse_rules ri) rm;
    rs = vr ++ vrw ++ map snd (values ma);
  } in (nfs, (mi, (p, (pw, (q, (nfq || is_NF_trs_subset isnf rs,
                                 (nc || all (\ r -> not (is_Var (snd r))) rs,
                                   (vr, (vrw,
  (ma, (rma, (wwf || wwf_qtrs_impl isnf rs, isnf))))))))))));

intersect_rulesa ::
  forall a b.
    (Eq a, Key a, Eq b) => Dpp a b -> [(Term a b, Term a b)] -> Dpp a b;
intersect_rulesa d rs = DPP (intersect_rules_impl (impl_ofd d) rs);

intersect_pairs_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   (Bool,
                     (Bool,
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([Term a b],
                             (Bool,
                               (Bool,
                                 ([(Term a b, Term a b)],
                                   ([(Term a b, Term a b)],
                                     (Rbt (a, Nat)
[(Bool, (Term a b, Term a b))],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Bool, Term a b -> Bool))))))))))));
intersect_pairs_impl (nfs, (mi, (p, (pw, rest)))) ps =
  (nfs, (mi, (list_inter p ps, (list_inter pw ps, rest))));

intersect_pairs ::
  forall a b.
    (Eq a, Key a, Eq b) => Dpp a b -> [(Term a b, Term a b)] -> Dpp a b;
intersect_pairs d ps = DPP (intersect_pairs_impl (impl_ofd d) ps);

replace_pair_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (Term a b, Term a b) ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
replace_pair_impl (nfs, (mi, (p, (pw, rest)))) pair ps =
  (nfs, (mi, (replace_impl pair ps p, (replace_impl pair ps pw, rest))));

replace_pair ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 (Term a b, Term a b) -> [(Term a b, Term a b)] -> Dpp a b;
replace_pair d pair ps = DPP (replace_pair_impl (impl_ofd d) pair ps);

rules_implb ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)];
rules_implb (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vrw, (m, vb)))))))))) =
  vr ++ vrw ++ map snd (values m);

split_rules_impla ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules_impla d rs = partition (membera rs) (rules_implb d);

split_rulesa ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rulesa d = split_rules_impla (impl_ofd d);

pairs_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
pairs_impl (uu, (uv, (p, (pw, uw)))) = p ++ pw;

split_pairs_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_pairs_impl d ps = partition (membera ps) (pairs_impl d);

split_pairs ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_pairs d = split_pairs_impl (impl_ofd d);

delete_R_Rw_impla ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
delete_R_Rw_impla d r rw =
  let {
    (nfs, (mi, (p, (pw, (q, (nfq, (nc, (vR,
 (vRw, (m, (rm, (wwf, isnf))))))))))))
      = d;
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    vra = list_diff vR vr;
    vrwa = list_diff vRw vrw;
    ma = delete_rules True ra (delete_rules False rwa m);
    rma = delete_rules True (reverse_rules r)
            (delete_rules False (reverse_rules rw) rm);
    rs = vra ++ vrwa ++ map snd (values ma);
  } in (nfs, (mi, (p, (pw, (q, (nfq || is_NF_trs_subset isnf rs,
                                 (nc || all (\ rb -> not (is_Var (snd rb))) rs,
                                   (vra, (vrwa,
   (ma, (rma, (wwf || wwf_qtrs_impl isnf rs, isnf))))))))))));

delete_R_Rwa ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Dpp a b;
delete_R_Rwa d r rw = DPP (delete_R_Rw_impla (impl_ofd d) r rw);

delete_P_Pw_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
delete_P_Pw_impl (nfs, (mi, (p, (pw, rest)))) pd pwd =
  (nfs, (mi, (list_diff p pd, (list_diff pw pwd, rest))));

delete_P_Pw ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Dpp a b;
delete_P_Pw d p pw = DPP (delete_P_Pw_impl (impl_ofd d) p pw);

rules_map_impla ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
rules_map_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (m, vd)))))))))) fn
  = (case lookup m fn of {
      Nothing -> [];
      Just a -> map snd a;
    });

rules_mapa ::
  forall a b. (Key a) => Dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_mapa d = rules_map_impla (impl_ofd d);

wwf_rules_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
wwf_rules_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, (wwf, vf)))))))))))) =
  wwf;

wwf_rules :: forall a b. (Key a) => Dpp a b -> Bool;
wwf_rules d = wwf_rules_impl (impl_ofd d);

q_empty_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
q_empty_impla (uu, (uv, (uw, (ux, (q, uy))))) = null q;

q_emptya :: forall a b. (Key a) => Dpp a b -> Bool;
q_emptya d = q_empty_impla (impl_ofd d);

is_QNF_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Term a b -> Bool;
is_QNF_impla
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, (vf, isnf)))))))))))) =
  isnf;

is_QNFa :: forall a b. (Key a) => Dpp a b -> Term a b -> Bool;
is_QNFa d = is_QNF_impla (impl_ofd d);

rulesb :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
rulesb d = rules_implb (impl_ofd d);

pairs :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
pairs d = pairs_impl (impl_ofd d);

dpp_impl ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (Bool,
                   (Bool,
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b),
                         (Set (Term a b),
                           (Set (Term a b, Term a b),
                             Set (Term a b, Term a b)))))));
dpp_impl (nfs, (mi, (p, (pw, (q, (uu, (uv, (vr, (vrw, (m, uw)))))))))) =
  (nfs, (mi, (set p,
               (set pw,
                 (set q,
                   (set (vr ++ rules_with id m),
                     set (vrw ++ rules_with not m)))))));

dpp ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => Dpp a b ->
                 (Bool,
                   (Bool,
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b),
                         (Set (Term a b),
                           (Set (Term a b, Term a b),
                             Set (Term a b, Term a b)))))));
dpp d = dpp_impl (impl_ofd d);

nfs_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
nfs_impla (nfs, uu) = nfs;

nfsa :: forall a b. (Key a) => Dpp a b -> Bool;
nfsa d = nfs_impla (impl_ofd d);

mk_impla ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 [Term a b] ->
                                   [(Term a b, Term a b)] ->
                                     [(Term a b, Term a b)] ->
                                       (Bool,
 (Bool,
   ([(Term a b, Term a b)],
     ([(Term a b, Term a b)],
       ([Term a b],
         (Bool,
           (Bool,
             ([(Term a b, Term a b)],
               ([(Term a b, Term a b)],
                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                     (Bool, Term a b -> Bool))))))))))));
mk_impla nfs mi p pw q r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    rs = r ++ rw;
    isnf = is_NF_terms q;
  } in (nfs, (mi, (p, (pw, (q, (is_NF_trs_subset isnf rs,
                                 (all (\ rb -> not (is_Var (snd rb))) rs,
                                   (vr, (vrw,
  (insert_rules True ra (insert_rules False rwa empty),
    (insert_rules True (reverse_rules r)
       (insert_rules False (reverse_rules rw) empty),
      (wwf_qtrs_impl isnf rs, isnf))))))))))));

mka ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 [Term a b] ->
                                   [(Term a b, Term a b)] ->
                                     [(Term a b, Term a b)] -> Dpp a b;
mka nfs mi p pw q r rw = DPP (mk_impla nfs mi p pw q r rw);

rw_impla ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)];
rw_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vrw, (m, vc)))))))))) =
  vrw ++ rules_with not m;

rwa :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
rwa d = rw_impla (impl_ofd d);

pw_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
pw_impl (uu, (uv, (uw, (pw, ux)))) = pw;

pw :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
pw d = pw_impl (impl_ofd d);

r_impla ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)];
r_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vb, (m, vc)))))))))) =
  vr ++ rules_with id m;

ra :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
ra d = r_impla (impl_ofd d);

q_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [Term a b];
q_impla (uu, (uv, (uw, (ux, (q, uy))))) = q;

qa :: forall a b. (Key a) => Dpp a b -> [Term a b];
qa d = q_impla (impl_ofd d);

p_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
p_impl (uu, (uv, (p, uw))) = p;

p :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
p d = p_impl (impl_ofd d);

m_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
m_impl (uu, (mi, uv)) = mi;

ma :: forall a b. (Key a) => Dpp a b -> Bool;
ma d = m_impl (impl_ofd d);

dpp_rbt_impl ::
  forall a b.
    (Eq a, Key a, Ccompare b, Compare b, Eq b,
      Mapping_impl b) => Dpp_ops_ext (Dpp a b) a b ();
dpp_rbt_impl =
  Dpp_ops_ext dpp p pw pairs qa ra rwa rulesb q_emptya rules_no_left_var
    rules_non_collapsing is_QNFa nFQ_subset_NF_rulesa rules_mapa
    reverse_rules_map intersect_pairs replace_pair intersect_rulesa delete_P_Pw
    delete_R_Rwa split_pairs split_rulesa mka ma nfsa wwf_rules ();

nFQ_subset_NF_rules_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Bool;
nFQ_subset_NF_rules_impl (uu, (uv, (b, uw))) = b;

nFQ_subset_NF_rules :: forall a b. (Key a, Key b) => Tp a b -> Bool;
nFQ_subset_NF_rules tp = nFQ_subset_NF_rules_impl (impl_ofc tp);

rules_impla ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)];
rules_impla (uu, (uv, (uw, (vR, (vRw, (m, ux)))))) =
  vR ++ vRw ++ map snd (values m);

split_rules_impl ::
  forall a b.
    (Key a,
      Key b) => (Bool,
                  ([Term a b],
                    (Bool,
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)],
                          (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                            Term a b -> Bool)))))) ->
                  [(Term a b, Term a b)] ->
                    ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules_impl tp rs = let {
                           m = ceta_set_of rs;
                         } in partition m (rules_impla tp);

split_rules ::
  forall a b.
    (Key a,
      Key b) => Tp a b ->
                  [(Term a b, Term a b)] ->
                    ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules tp = split_rules_impl (impl_ofc tp);

delete_R_Rw_impl ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       ([Term a b],
                         (Bool,
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                 Term a b -> Bool))))));
delete_R_Rw_impl (nfs, (q, (uu, (vR, (vRw, (m, isnf)))))) r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    vra = list_diff vR vr;
    vrwa = list_diff vRw vrw;
    ma = delete_rules True ra (delete_rules False rwa m);
  } in (nfs, (q, (is_NF_trs_subset isnf (vra ++ vrwa ++ map snd (values ma)),
                   (vra, (vrwa, (ma, isnf))))));

delete_R_Rw ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => Tp a b ->
                  [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Tp a b;
delete_R_Rw tp r rw = TP (delete_R_Rw_impl (impl_ofc tp) r rw);

rules_map_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
rules_map_impl (uu, (uv, (uw, (ux, (uy, (m, uz)))))) fn =
  (case lookup m fn of {
    Nothing -> [];
    Just a -> map snd a;
  });

rules_map ::
  forall a b. (Key a, Key b) => Tp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_map tp = rules_map_impl (impl_ofc tp);

qreltrs_impl ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 (Bool,
                   (Set (Term a b),
                     (Set (Term a b, Term a b), Set (Term a b, Term a b))));
qreltrs_impl (nfs, (q, (uu, (vR, (vRw, (m, isnf)))))) =
  (nfs, (set q, (set (vR ++ rules_with id m), set (vRw ++ rules_with not m))));

qreltrs ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => Tp a b ->
                  (Bool,
                    (Set (Term a b),
                      (Set (Term a b, Term a b), Set (Term a b, Term a b))));
qreltrs tp = qreltrs_impl (impl_ofc tp);

q_empty_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Bool;
q_empty_impl (uu, (q, uv)) = null q;

q_empty :: forall a b. (Key a, Key b) => Tp a b -> Bool;
q_empty tp = q_empty_impl (impl_ofc tp);

is_QNF_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Term a b -> Bool;
is_QNF_impl (uu, (uv, (uw, (ux, (uy, (uz, isnf)))))) = isnf;

is_QNF :: forall a b. (Key a, Key b) => Tp a b -> Term a b -> Bool;
is_QNF tp = is_QNF_impl (impl_ofc tp);

rulesa :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
rulesa tp = rules_impla (impl_ofc tp);

nfs_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 Bool;
nfs_impl (nfs, uu) = nfs;

nfs :: forall a b. (Key a, Key b) => Tp a b -> Bool;
nfs tp = nfs_impl (impl_ofc tp);

mk_impl ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           [Term a b] ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 (Bool,
                                   ([Term a b],
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Term a b -> Bool))))));
mk_impl nfs q r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    isnf = is_NF_terms q;
  } in (nfs, (q, (is_NF_trs_subset isnf (r ++ rw),
                   (vr, (vrw, (insert_rules True ra
                                 (insert_rules False rwa empty),
                                isnf))))));

mk :: forall a b.
        (Eq a, Key a, Ccompare b, Eq b, Key b,
          Mapping_impl b) => Bool ->
                               [Term a b] ->
                                 [(Term a b, Term a b)] ->
                                   [(Term a b, Term a b)] -> Tp a b;
mk nfs q r rw = TP (mk_impl nfs q r rw);

rw_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)];
rw_impl (uu, (uv, (uw, (ux, (vRw, (m, uy)))))) = vRw ++ rules_with not m;

rw :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
rw tp = rw_impl (impl_ofc tp);

tp_rbt_impl ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b, Key b,
      Mapping_impl b) => Tp_ops_ext (Tp a b) a b ();
tp_rbt_impl =
  Tp_ops_ext qreltrs q r rw rulesa q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs ();

certify_cert_problem ::
  forall a b c d e.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Ac_tp_ops_ext d (Lab b [Nat]) [Prelude.Char] () ->
                        Ac_dpp_ops_ext e (Lab b [Nat]) [Prelude.Char] () ->
                          Bool ->
                            Input (Lab b [Nat]) [Prelude.Char] ->
                              Claim (Lab b [Nat]) [Prelude.Char] ->
                                Proof b [Nat] [Prelude.Char] -> Cert_result;
certify_cert_problem i j k l a input claim proof =
  (case check_cert i j k l a input claim proof of {
    Inl err -> Error (err []);
    Inr _ -> Certified;
  });

parse_cert_problem ::
  [Prelude.Char] ->
    Sum [Prelude.Char]
      (Maybe (Input (Lab [Prelude.Char] [Nat]) [Prelude.Char]),
        Proof [Prelude.Char] [Nat] [Prelude.Char]);
parse_cert_problem =
  parse_xmlfile
    (debug ['0']
      ['p', 'a', 'r', 's', 'i', 'n', 'g', ' ', 'x', 'm', 'l', ' ', 't', 'o',
        ' ', 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n',
        ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm']
      (xml2cert_problem (xml_text ['n', 'a', 'm', 'e']) plain_name));

certify_proof ::
  Bool ->
    Maybe [Prelude.Char] ->
      Sum (Claim (Lab [Prelude.Char] [Nat]) [Prelude.Char]) [Prelude.Char] ->
        [Prelude.Char] -> Cert_result;
certify_proof a xtc_o claim_o cpf =
  (case (case xtc_o of {
          Nothing -> Inr Nothing;
          Just xtc -> (case parse_xmlfile (problem plain_name) xtc of {
                        Inl aa -> Inl aa;
                        Inr input -> Inr (Just input);
                      });
        })
    of {
    Inl aa -> Error aa;
    Inr input_o1 ->
      (case (case claim_o of {
              Inl aa -> Inr aa;
              Inr aa -> parse_claim plain_name aa;
            })
        of {
        Inl aa -> Error aa;
        Inr claim ->
          (case parse_cert_problem cpf of {
            Inl aa -> Error aa;
            Inr (input_o2, proof) ->
              (case (input_o1, input_o2) of {
                (Nothing, Nothing) ->
                  Error ['m', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 'n', 'p',
                          'u', 't', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'];
                (Nothing, Just input) ->
                  certify_cert_problem tp_rbt_impl dpp_rbt_impl ac_tp_list_impl
                    ac_dpp_rbt_impl a input claim proof;
                (Just input, _) ->
                  certify_cert_problem tp_rbt_impl dpp_rbt_impl ac_tp_list_impl
                    ac_dpp_rbt_impl a input claim proof;
              });
          });
      });
  });

}
