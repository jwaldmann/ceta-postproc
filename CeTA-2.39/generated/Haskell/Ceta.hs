{-# LANGUAGE EmptyDataDecls, RankNTypes, ScopedTypeVariables #-}

module
  Ceta(Nat, Char, Term, Sum(..), Lab, Xml, Xml_error, Claim(..), Input, Sum_bot,
        Proof, Cert_result(..), Tp, Dpp, Ac_dpp, Tp_ops_ext, Dpp_ops_ext,
        Ac_tp_ops_ext, Ac_dpp_ops_ext, explode, version, certify_proof,
        nat_of_integer
      )
  where {

import Prelude ((==), (/=), (<), (<=), (>=), (>), (+), (-), (*), (/), (**),
  (>>=), (>>), (=<<), (&&), (||), (^), (^^), (.), ($), ($!), (++), (!!), Eq,
  error, id, return, not, fst, snd, map, filter, concat, concatMap, reverse,
  zip, null, takeWhile, dropWhile, all, any, Integer, negate, abs, divMod,
  String, Bool(True, False), Maybe(Nothing, Just));
import qualified Prelude;
import qualified Uint;
import qualified Array;
import qualified IArray;
import qualified Uint32;
import qualified Uint64;
import qualified Data_Bits;

newtype Int = Int_of_integer Integer;

integer_of_int :: Int -> Integer;
integer_of_int (Int_of_integer k) = k;

equal_int :: Int -> Int -> Bool;
equal_int k l = integer_of_int k == integer_of_int l;

instance Eq Int where {
  a == b = equal_int a b;
};

times_int :: Int -> Int -> Int;
times_int k l = Int_of_integer (integer_of_int k * integer_of_int l);

class Times a where {
  times :: a -> a -> a;
};

class (Times a) => Dvd a where {
};

instance Times Int where {
  times = times_int;
};

instance Dvd Int where {
};

uminus_int :: Int -> Int;
uminus_int k = Int_of_integer (negate (integer_of_int k));

zero_int :: Int;
zero_int = Int_of_integer (0 :: Integer);

less_int :: Int -> Int -> Bool;
less_int k l = integer_of_int k < integer_of_int l;

abs_int :: Int -> Int;
abs_int i = (if less_int i zero_int then uminus_int i else i);

class Abs a where {
  absa :: a -> a;
};

instance Abs Int where {
  absa = abs_int;
};

data Num = One | Bit0 Num | Bit1 Num;

one_int :: Int;
one_int = Int_of_integer (1 :: Integer);

class One a where {
  onea :: a;
};

instance One Int where {
  onea = one_int;
};

sgn_int :: Int -> Int;
sgn_int i =
  (if equal_int i zero_int then zero_int
    else (if less_int zero_int i then one_int else uminus_int one_int));

class Sgn a where {
  sgn :: a -> a;
};

instance Sgn Int where {
  sgn = sgn_int;
};

minus_int :: Int -> Int -> Int;
minus_int k l = Int_of_integer (integer_of_int k - integer_of_int l);

plus_int :: Int -> Int -> Int;
plus_int k l = Int_of_integer (integer_of_int k + integer_of_int l);

class Uminus a where {
  uminus :: a -> a;
};

class Minus a where {
  minus :: a -> a -> a;
};

class Zero a where {
  zerob :: a;
};

class Plus a where {
  plus :: a -> a -> a;
};

class (Plus a) => Semigroup_add a where {
};

class (Semigroup_add a) => Cancel_semigroup_add a where {
};

class (Semigroup_add a) => Ab_semigroup_add a where {
};

class (Ab_semigroup_add a, Cancel_semigroup_add a,
        Minus a) => Cancel_ab_semigroup_add a where {
};

class (Semigroup_add a, Zero a) => Monoid_add a where {
};

class (Ab_semigroup_add a, Monoid_add a) => Comm_monoid_add a where {
};

class (Cancel_ab_semigroup_add a,
        Comm_monoid_add a) => Cancel_comm_monoid_add a where {
};

class (Times a, Zero a) => Mult_zero a where {
};

class (Times a) => Semigroup_mult a where {
};

class (Ab_semigroup_add a, Semigroup_mult a) => Semiring a where {
};

class (Comm_monoid_add a, Mult_zero a, Semiring a) => Semiring_0 a where {
};

class (Cancel_comm_monoid_add a, Semiring_0 a) => Semiring_0_cancel a where {
};

class (Semigroup_mult a) => Ab_semigroup_mult a where {
};

class (Ab_semigroup_mult a, Semiring a) => Comm_semiring a where {
};

class (Comm_semiring a, Semiring_0 a) => Comm_semiring_0 a where {
};

class (Comm_semiring_0 a,
        Semiring_0_cancel a) => Comm_semiring_0_cancel a where {
};

class (One a, Times a) => Power a where {
};

class (Semigroup_mult a, Power a) => Monoid_mult a where {
};

class (One a, Semigroup_add a) => Numeral a where {
};

class (Monoid_mult a, Numeral a, Semiring a) => Semiring_numeral a where {
};

class (One a, Zero a) => Zero_neq_one a where {
};

class (Semiring_numeral a, Semiring_0 a, Zero_neq_one a) => Semiring_1 a where {
};

class (Semiring_0_cancel a, Semiring_1 a) => Semiring_1_cancel a where {
};

class (Ab_semigroup_mult a, Monoid_mult a, Dvd a) => Comm_monoid_mult a where {
};

class (Comm_monoid_mult a, Comm_semiring_0 a,
        Semiring_1 a) => Comm_semiring_1 a where {
};

class (Comm_semiring_0_cancel a, Comm_semiring_1 a,
        Semiring_1_cancel a) => Comm_semiring_1_cancel a where {
};

class (Comm_semiring_1_cancel a) => Comm_semiring_1_cancel_crossproduct a where {
};

class (Semiring_0 a) => Semiring_no_zero_divisors a where {
};

class (Semiring_1 a,
        Semiring_no_zero_divisors a) => Semiring_1_no_zero_divisors a where {
};

class (Semiring_no_zero_divisors a) => Semiring_no_zero_divisors_cancel a where {
};

class (Cancel_semigroup_add a, Minus a, Monoid_add a,
        Uminus a) => Group_add a where {
};

class (Cancel_comm_monoid_add a, Group_add a) => Ab_group_add a where {
};

class (Ab_group_add a, Semiring_0_cancel a) => Ring a where {
};

class (Ring a,
        Semiring_no_zero_divisors_cancel a) => Ring_no_zero_divisors a where {
};

class (Group_add a, Numeral a) => Neg_numeral a where {
};

class (Neg_numeral a, Ring a, Semiring_1_cancel a) => Ring_1 a where {
};

class (Ring_1 a, Ring_no_zero_divisors a,
        Semiring_1_no_zero_divisors a) => Ring_1_no_zero_divisors a where {
};

class (Comm_semiring_0_cancel a, Ring a) => Comm_ring a where {
};

class (Comm_ring a, Comm_semiring_1_cancel a, Ring_1 a) => Comm_ring_1 a where {
};

class (Comm_semiring_1_cancel a,
        Semiring_1_no_zero_divisors a) => Semidom a where {
};

class (Comm_ring_1 a, Ring_1_no_zero_divisors a, Semidom a,
        Comm_semiring_1_cancel_crossproduct a) => Idom a where {
};

instance Plus Int where {
  plus = plus_int;
};

instance Semigroup_add Int where {
};

instance Cancel_semigroup_add Int where {
};

instance Ab_semigroup_add Int where {
};

instance Minus Int where {
  minus = minus_int;
};

instance Cancel_ab_semigroup_add Int where {
};

instance Zero Int where {
  zerob = zero_int;
};

instance Monoid_add Int where {
};

instance Comm_monoid_add Int where {
};

instance Cancel_comm_monoid_add Int where {
};

instance Mult_zero Int where {
};

instance Semigroup_mult Int where {
};

instance Semiring Int where {
};

instance Semiring_0 Int where {
};

instance Semiring_0_cancel Int where {
};

instance Ab_semigroup_mult Int where {
};

instance Comm_semiring Int where {
};

instance Comm_semiring_0 Int where {
};

instance Comm_semiring_0_cancel Int where {
};

instance Power Int where {
};

instance Monoid_mult Int where {
};

instance Numeral Int where {
};

instance Semiring_numeral Int where {
};

instance Zero_neq_one Int where {
};

instance Semiring_1 Int where {
};

instance Semiring_1_cancel Int where {
};

instance Comm_monoid_mult Int where {
};

instance Comm_semiring_1 Int where {
};

instance Comm_semiring_1_cancel Int where {
};

instance Comm_semiring_1_cancel_crossproduct Int where {
};

instance Semiring_no_zero_divisors Int where {
};

instance Semiring_1_no_zero_divisors Int where {
};

instance Semiring_no_zero_divisors_cancel Int where {
};

instance Uminus Int where {
  uminus = uminus_int;
};

instance Group_add Int where {
};

instance Ab_group_add Int where {
};

instance Ring Int where {
};

instance Ring_no_zero_divisors Int where {
};

instance Neg_numeral Int where {
};

instance Ring_1 Int where {
};

instance Ring_1_no_zero_divisors Int where {
};

instance Comm_ring Int where {
};

instance Comm_ring_1 Int where {
};

instance Semidom Int where {
};

instance Idom Int where {
};

less_eq_int :: Int -> Int -> Bool;
less_eq_int k l = integer_of_int k <= integer_of_int l;

class Ord a where {
  less_eq :: a -> a -> Bool;
  less :: a -> a -> Bool;
};

class (Abs a, Minus a, Uminus a, Zero a, Ord a) => Abs_if a where {
};

instance Ord Int where {
  less_eq = less_eq_int;
  less = less_int;
};

instance Abs_if Int where {
};

class (Semiring_1 a) => Semiring_char_0 a where {
};

class (Semiring_char_0 a, Ring_1 a) => Ring_char_0 a where {
};

instance Semiring_char_0 Int where {
};

instance Ring_char_0 Int where {
};

class (Ord a) => Quasi_order a where {
};

class (Quasi_order a) => Weak_order a where {
};

class (Ord a) => Preorder a where {
};

class (Preorder a, Weak_order a) => Order a where {
};

instance Quasi_order Int where {
};

instance Weak_order Int where {
};

instance Preorder Int where {
};

instance Order Int where {
};

ceq_int :: Maybe (Int -> Int -> Bool);
ceq_int = Just equal_int;

class Ceq a where {
  ceq :: Maybe (a -> a -> Bool);
};

instance Ceq Int where {
  ceq = ceq_int;
};

newtype Phantom a b = Phantom b;

data Set_impla = Set_Choose | Set_Collect | Set_DList | Set_RBT | Set_Monada;

set_impl_int :: Phantom Int Set_impla;
set_impl_int = Phantom Set_RBT;

class Set_impl a where {
  set_impl :: Phantom a Set_impla;
};

instance Set_impl Int where {
  set_impl = set_impl_int;
};

class (Order a) => Linorder a where {
};

instance Linorder Int where {
};

class (Abs a, Sgn a, Idom a) => Idom_abs_sgn a where {
};

instance Idom_abs_sgn Int where {
};

class (Ab_semigroup_add a, Order a) => Ordered_ab_semigroup_add a where {
};

class (Ordered_ab_semigroup_add a) => Strict_ordered_ab_semigroup_add a where {
};

class (Cancel_ab_semigroup_add a,
        Strict_ordered_ab_semigroup_add a) => Ordered_cancel_ab_semigroup_add a where {
};

class (Semigroup_mult a, Order a,
        Mult_zero a) => Ordered_semigroup_mult_zero a where {
};

class (Comm_monoid_add a,
        Ordered_ab_semigroup_add a) => Ordered_comm_monoid_add a where {
};

class (Ordered_comm_monoid_add a, Semiring a) => Ordered_semiring a where {
};

class (Ordered_semigroup_mult_zero a, Ordered_semiring a,
        Semiring_0 a) => Ordered_semiring_0 a where {
};

class (Ordered_cancel_ab_semigroup_add a, Ordered_semiring_0 a,
        Semiring_0_cancel a) => Ordered_cancel_semiring a where {
};

class (Ordered_cancel_ab_semigroup_add a) => Ordered_ab_semigroup_add_imp_le a where {
};

class (Comm_monoid_add a,
        Strict_ordered_ab_semigroup_add a) => Strict_ordered_comm_monoid_add a where {
};

class (Ordered_cancel_ab_semigroup_add a, Ordered_comm_monoid_add a,
        Strict_ordered_comm_monoid_add a) => Ordered_cancel_comm_monoid_add a where {
};

class (Cancel_comm_monoid_add a, Ordered_ab_semigroup_add_imp_le a,
        Ordered_cancel_comm_monoid_add a) => Ordered_ab_semigroup_monoid_add_imp_le a where {
};

class (Ab_group_add a,
        Ordered_ab_semigroup_monoid_add_imp_le a) => Ordered_ab_group_add a where {
};

class (Ordered_ab_group_add a, Ordered_cancel_semiring a,
        Ring a) => Ordered_ring a where {
};

instance Ordered_ab_semigroup_add Int where {
};

instance Strict_ordered_ab_semigroup_add Int where {
};

instance Ordered_cancel_ab_semigroup_add Int where {
};

instance Ordered_semigroup_mult_zero Int where {
};

instance Ordered_comm_monoid_add Int where {
};

instance Ordered_semiring Int where {
};

instance Ordered_semiring_0 Int where {
};

instance Ordered_cancel_semiring Int where {
};

instance Ordered_ab_semigroup_add_imp_le Int where {
};

instance Strict_ordered_comm_monoid_add Int where {
};

instance Ordered_cancel_comm_monoid_add Int where {
};

instance Ordered_ab_semigroup_monoid_add_imp_le Int where {
};

instance Ordered_ab_group_add Int where {
};

instance Ordered_ring Int where {
};

class (Order a, Zero_neq_one a) => Zero_less_one a where {
};

instance Zero_less_one Int where {
};

apsnd :: forall a b c. (a -> b) -> (c, a) -> (c, b);
apsnd f (x, y) = (x, f y);

divmod_integer :: Integer -> Integer -> (Integer, Integer);
divmod_integer k l =
  (if k == (0 :: Integer) then ((0 :: Integer), (0 :: Integer))
    else (if (0 :: Integer) < l
           then (if (0 :: Integer) < k then divMod ( k ) ( l )
                  else (case divMod ( (negate k) ) ( l ) of {
                         (r, s) ->
                           (if s == (0 :: Integer)
                             then (negate r, (0 :: Integer))
                             else (negate r - (1 :: Integer), l - s));
                       }))
           else (if l == (0 :: Integer) then ((0 :: Integer), k)
                  else apsnd negate
                         (if k < (0 :: Integer)
                           then divMod ( (negate k) ) ( (negate l) )
                           else (case divMod ( k ) ( (negate l) ) of {
                                  (r, s) ->
                                    (if s == (0 :: Integer)
                                      then (negate r, (0 :: Integer))
                                      else (negate r - (1 :: Integer),
     negate l - s));
                                })))));

modulo_integer :: Integer -> Integer -> Integer;
modulo_integer k l = snd (divmod_integer k l);

newtype Nat = Nat Integer;

integer_of_nat :: Nat -> Integer;
integer_of_nat (Nat x) = x;

modulo_nat :: Nat -> Nat -> Nat;
modulo_nat m n = Nat (modulo_integer (integer_of_nat m) (integer_of_nat n));

divide_integer :: Integer -> Integer -> Integer;
divide_integer k l = fst (divmod_integer k l);

divide_nat :: Nat -> Nat -> Nat;
divide_nat m n = Nat (divide_integer (integer_of_nat m) (integer_of_nat n));

max :: forall a. (Ord a) => a -> a -> a;
max a b = (if less_eq a b then b else a);

instance Ord Integer where {
  less_eq = (\ a b -> a <= b);
  less = (\ a b -> a < b);
};

nat_of_integer :: Integer -> Nat;
nat_of_integer k = Nat (max (0 :: Integer) k);

bit_cut_integer :: Integer -> (Integer, Bool);
bit_cut_integer k =
  (if k == (0 :: Integer) then ((0 :: Integer), False)
    else (case divMod (abs k) (abs (2 :: Integer)) of {
           (r, s) ->
             ((if (0 :: Integer) < k then r else negate r - s),
               s == (1 :: Integer));
         }));

data Char = Char Bool Bool Bool Bool Bool Bool Bool Bool;

char_of_integer :: Integer -> Char;
char_of_integer k =
  (case bit_cut_integer k of {
    (q0, b0) ->
      (case bit_cut_integer q0 of {
        (q1, b1) ->
          (case bit_cut_integer q1 of {
            (q2, b2) ->
              (case bit_cut_integer q2 of {
                (q3, b3) ->
                  (case bit_cut_integer q3 of {
                    (q4, b4) ->
                      (case bit_cut_integer q4 of {
                        (q5, b5) ->
                          (case bit_cut_integer q5 of {
                            (q6, b6) ->
                              let {
                                a = bit_cut_integer q6;
                              } in (case a of {
                                     (_, aa) -> Char b0 b1 b2 b3 b4 b5 b6 aa;
                                   });
                          });
                      });
                  });
              });
          });
      });
  });

of_bool :: forall a. (Zero_neq_one a) => Bool -> a;
of_bool True = onea;
of_bool False = zerob;

one_integer :: Integer;
one_integer = (1 :: Integer);

instance Zero Integer where {
  zerob = (0 :: Integer);
};

instance One Integer where {
  onea = one_integer;
};

instance Zero_neq_one Integer where {
};

integer_of_char :: Char -> Integer;
integer_of_char (Char b0 b1 b2 b3 b4 b5 b6 b7) =
  ((((((of_bool b7 * (2 :: Integer) + of_bool b6) * (2 :: Integer) +
        of_bool b5) *
        (2 :: Integer) +
       of_bool b4) *
       (2 :: Integer) +
      of_bool b3) *
      (2 :: Integer) +
     of_bool b2) *
     (2 :: Integer) +
    of_bool b1) *
    (2 :: Integer) +
    of_bool b0;

implode :: [Char] -> String;
implode cs =
  map (let chr k | (0 <= k && k < 128) = Prelude.toEnum k :: Prelude.Char in chr . Prelude.fromInteger)
    (map integer_of_char cs);

lit_of_digit :: Nat -> String;
lit_of_digit n = implode [char_of_integer ((48 :: Integer) + integer_of_nat n)];

less_nat :: Nat -> Nat -> Bool;
less_nat m n = integer_of_nat m < integer_of_nat n;

showsl_lit :: String -> String -> String;
showsl_lit = (\ a b -> a ++ b);

showsl_nat :: Nat -> String -> String;
showsl_nat n =
  (if less_nat n (nat_of_integer (10 :: Integer))
    then showsl_lit (lit_of_digit n)
    else showsl_nat (divide_nat n (nat_of_integer (10 :: Integer))) .
           showsl_lit
             (lit_of_digit (modulo_nat n (nat_of_integer (10 :: Integer)))));

nat :: Int -> Nat;
nat k = Nat (max (0 :: Integer) (integer_of_int k));

showsl_int :: Int -> String -> String;
showsl_int i =
  (if less_int i zero_int then showsl_lit "-" . showsl_nat (nat (uminus_int i))
    else showsl_nat (nat i));

showsl_sep ::
  forall a.
    (a -> String -> String) -> (String -> String) -> [a] -> String -> String;
showsl_sep s sep [] = showsl_lit "";
showsl_sep s sep [x] = s x;
showsl_sep s sep (x : v : va) = (s x . sep) . showsl_sep s sep (v : va);

showsl_list_gen ::
  forall a.
    (a -> String -> String) ->
      String -> String -> String -> String -> [a] -> String -> String;
showsl_list_gen showslx e l s r xs =
  (if null xs then showsl_lit e
    else (showsl_lit l . showsl_sep showslx (showsl_lit s) xs) . showsl_lit r);

default_showsl_list ::
  forall a. (a -> String -> String) -> [a] -> String -> String;
default_showsl_list sl = showsl_list_gen sl "[]" "[" ", " "]";

showsl_list_int :: [Int] -> String -> String;
showsl_list_int xs = default_showsl_list showsl_int xs;

class Showl a where {
  showsl :: a -> String -> String;
  showsl_list :: [a] -> String -> String;
};

instance Showl Int where {
  showsl = showsl_int;
  showsl_list = showsl_list_int;
};

cEnum_int :: Maybe ([Int], ((Int -> Bool) -> Bool, (Int -> Bool) -> Bool));
cEnum_int = Nothing;

class Cenum a where {
  cEnum :: Maybe ([a], ((a -> Bool) -> Bool, (a -> Bool) -> Bool));
};

instance Cenum Int where {
  cEnum = cEnum_int;
};

class (Ordered_ab_semigroup_add a,
        Linorder a) => Linordered_ab_semigroup_add a where {
};

class (Linordered_ab_semigroup_add a,
        Ordered_ab_semigroup_add_imp_le a) => Linordered_cancel_ab_semigroup_add a where {
};

class (Linordered_cancel_ab_semigroup_add a,
        Ordered_ab_semigroup_monoid_add_imp_le a,
        Ordered_cancel_semiring a) => Linordered_semiring a where {
};

class (Linordered_semiring a) => Linordered_semiring_strict a where {
};

class (Ordered_semiring_0 a, Semiring_1 a,
        Zero_less_one a) => Ordered_semiring_1a a where {
};

class (Ordered_semiring_1a a,
        Linordered_semiring a) => Linordered_semiring_1 a where {
};

class (Linordered_semiring_1 a,
        Linordered_semiring_strict a) => Linordered_semiring_1_strict a where {
};

class (Abs a, Ordered_ab_group_add a) => Ordered_ab_group_add_abs a where {
};

class (Linordered_cancel_ab_semigroup_add a,
        Ordered_ab_group_add a) => Linordered_ab_group_add a where {
};

class (Linordered_ab_group_add a, Ordered_ab_group_add_abs a, Abs_if a,
        Linordered_semiring a, Ordered_ring a) => Linordered_ring a where {
};

class (Linordered_ring a, Linordered_semiring_strict a,
        Ring_no_zero_divisors a) => Linordered_ring_strict a where {
};

class (Ordered_semiring_0 a, Semiring_1 a,
        Zero_less_one a) => Ordered_semiring_1b a where {
};

class (Ordered_cancel_ab_semigroup_add a, Ordered_semiring a,
        Semiring_0_cancel a) => Ordered_semiring_strict a where {
};

class (Ordered_semiring_strict a,
        Ordered_semiring_0 a) => Semiring_real_line a where {
};

class (Ordered_semiring_1b a,
        Semiring_real_line a) => Semiring_1_real_line a where {
};

class (Comm_semiring_0 a, Ordered_semiring a) => Ordered_comm_semiring a where {
};

class (Comm_semiring_0_cancel a, Ordered_cancel_semiring a,
        Ordered_comm_semiring a) => Ordered_cancel_comm_semiring a where {
};

class (Linordered_semiring_strict a,
        Ordered_cancel_comm_semiring a) => Linordered_comm_semiring_strict a where {
};

class (Semiring_char_0 a, Linorder a, Comm_semiring_1 a,
        Ordered_comm_semiring a,
        Zero_less_one a) => Linordered_nonzero_semiring a where {
};

class (Linordered_comm_semiring_strict a, Linordered_nonzero_semiring a,
        Semidom a) => Linordered_semidom a where {
};

class (Comm_ring a, Ordered_cancel_comm_semiring a,
        Ordered_ring a) => Ordered_comm_ring a where {
};

class (Ordered_ab_group_add_abs a, Ordered_ring a) => Ordered_ring_abs a where {
};

class (Ring_char_0 a, Semiring_1_real_line a, Idom_abs_sgn a,
        Linordered_ring_strict a, Linordered_semidom a,
        Linordered_semiring_1_strict a, Ordered_comm_ring a,
        Ordered_ring_abs a) => Linordered_idom a where {
};

instance Linordered_ab_semigroup_add Int where {
};

instance Linordered_cancel_ab_semigroup_add Int where {
};

instance Linordered_semiring Int where {
};

instance Linordered_semiring_strict Int where {
};

instance Ordered_semiring_1a Int where {
};

instance Linordered_semiring_1 Int where {
};

instance Linordered_semiring_1_strict Int where {
};

instance Ordered_ab_group_add_abs Int where {
};

instance Linordered_ab_group_add Int where {
};

instance Linordered_ring Int where {
};

instance Linordered_ring_strict Int where {
};

instance Ordered_semiring_1b Int where {
};

instance Ordered_semiring_strict Int where {
};

instance Semiring_real_line Int where {
};

instance Semiring_1_real_line Int where {
};

instance Ordered_comm_semiring Int where {
};

instance Ordered_cancel_comm_semiring Int where {
};

instance Linordered_comm_semiring_strict Int where {
};

instance Linordered_nonzero_semiring Int where {
};

instance Linordered_semidom Int where {
};

instance Ordered_comm_ring Int where {
};

instance Ordered_ring_abs Int where {
};

instance Linordered_idom Int where {
};

class (Ord a) => Non_strict_order a where {
};

class (Ab_semigroup_add a, Monoid_add a,
        Non_strict_order a) => Ordered_ab_semigroup a where {
};

class (Semiring_0 a, Ordered_ab_semigroup a) => Ordered_semiring_0a a where {
};

class (Semiring_1 a, Ordered_semiring_0a a) => Ordered_semiring_1 a where {
};

class (Comm_semiring_1 a, Ordered_semiring_1 a) => Poly_carrier a where {
};

instance Non_strict_order Int where {
};

instance Ordered_ab_semigroup Int where {
};

instance Ordered_semiring_0a Int where {
};

instance Ordered_semiring_1 Int where {
};

instance Poly_carrier Int where {
};

data Ordera = Eqa | Lt | Gt;

comparator_of :: forall a. (Eq a, Linorder a) => a -> a -> Ordera;
comparator_of x y = (if less x y then Lt else (if x == y then Eqa else Gt));

compare_int :: Int -> Int -> Ordera;
compare_int = comparator_of;

ccompare_int :: Maybe (Int -> Int -> Ordera);
ccompare_int = Just compare_int;

class Ccompare a where {
  ccompare :: Maybe (a -> a -> Ordera);
};

instance Ccompare Int where {
  ccompare = ccompare_int;
};

newtype Rat = Frct (Int, Int);

newtype Mini_alg = Abs_mini_alg (Rat, (Rat, Nat));

newtype Mini_alg_unique = Abs_mini_alg_unique Mini_alg;

zero_rat :: Rat;
zero_rat = Frct (zero_int, one_int);

zero_nat :: Nat;
zero_nat = Nat (0 :: Integer);

ma_of_rat :: Rat -> Mini_alg;
ma_of_rat xa = Abs_mini_alg (xa, (zero_rat, zero_nat));

mau_of_rat :: Rat -> Mini_alg_unique;
mau_of_rat xa = Abs_mini_alg_unique (ma_of_rat xa);

newtype Real = Real_of_u Mini_alg_unique;

ratreal :: Rat -> Real;
ratreal = Real_of_u . mau_of_rat;

of_int :: Int -> Rat;
of_int a = Frct (a, one_int);

real_of_int :: Int -> Real;
real_of_int x = ratreal (of_int x);

class (Linordered_idom a) => Real_embedding a where {
  real_of :: a -> Real;
};

instance Real_embedding Int where {
  real_of = real_of_int;
};

class (Poly_carrier a) => Large_ordered_semiring_1 a where {
};

instance Large_ordered_semiring_1 Int where {
};

class (Real_embedding a,
        Large_ordered_semiring_1 a) => Large_real_ordered_semiring_1 a where {
};

instance Large_real_ordered_semiring_1 Int where {
};

equal_nat :: Nat -> Nat -> Bool;
equal_nat m n = integer_of_nat m == integer_of_nat n;

instance Eq Nat where {
  a == b = equal_nat a b;
};

times_nat :: Nat -> Nat -> Nat;
times_nat m n = Nat (integer_of_nat m * integer_of_nat n);

instance Times Nat where {
  times = times_nat;
};

instance Dvd Nat where {
};

one_nat :: Nat;
one_nat = Nat (1 :: Integer);

instance One Nat where {
  onea = one_nat;
};

plus_nat :: Nat -> Nat -> Nat;
plus_nat m n = Nat (integer_of_nat m + integer_of_nat n);

instance Plus Nat where {
  plus = plus_nat;
};

instance Zero Nat where {
  zerob = zero_nat;
};

instance Semigroup_add Nat where {
};

instance Numeral Nat where {
};

instance Power Nat where {
};

minus_nat :: Nat -> Nat -> Nat;
minus_nat m n = Nat (max (0 :: Integer) (integer_of_nat m - integer_of_nat n));

instance Minus Nat where {
  minus = minus_nat;
};

min :: forall a. (Ord a) => a -> a -> a;
min a b = (if less_eq a b then a else b);

less_eq_nat :: Nat -> Nat -> Bool;
less_eq_nat m n = integer_of_nat m <= integer_of_nat n;

instance Ord Nat where {
  less_eq = less_eq_nat;
  less = less_nat;
};

inf_nat :: Nat -> Nat -> Nat;
inf_nat = min;

class Inf a where {
  inf :: a -> a -> a;
};

instance Inf Nat where {
  inf = inf_nat;
};

sup_nat :: Nat -> Nat -> Nat;
sup_nat = max;

class Sup a where {
  sup :: a -> a -> a;
};

instance Sup Nat where {
  sup = sup_nat;
};

class Divide a where {
  divide :: a -> a -> a;
};

instance Divide Nat where {
  divide = divide_nat;
};

class (Divide a, Dvd a) => Modulo a where {
  modulo :: a -> a -> a;
};

instance Modulo Nat where {
  modulo = modulo_nat;
};

instance Ab_semigroup_add Nat where {
};

instance Monoid_add Nat where {
};

instance Comm_monoid_add Nat where {
};

instance Mult_zero Nat where {
};

instance Semigroup_mult Nat where {
};

instance Semiring Nat where {
};

instance Semiring_0 Nat where {
};

instance Semiring_no_zero_divisors Nat where {
};

instance Monoid_mult Nat where {
};

instance Semiring_numeral Nat where {
};

instance Zero_neq_one Nat where {
};

instance Semiring_1 Nat where {
};

instance Semiring_1_no_zero_divisors Nat where {
};

instance Cancel_semigroup_add Nat where {
};

instance Cancel_ab_semigroup_add Nat where {
};

instance Cancel_comm_monoid_add Nat where {
};

instance Semiring_0_cancel Nat where {
};

instance Ab_semigroup_mult Nat where {
};

instance Comm_semiring Nat where {
};

instance Comm_semiring_0 Nat where {
};

instance Comm_semiring_0_cancel Nat where {
};

instance Semiring_1_cancel Nat where {
};

instance Comm_monoid_mult Nat where {
};

instance Comm_semiring_1 Nat where {
};

instance Comm_semiring_1_cancel Nat where {
};

instance Semidom Nat where {
};

instance Quasi_order Nat where {
};

instance Weak_order Nat where {
};

instance Preorder Nat where {
};

instance Order Nat where {
};

instance Linorder Nat where {
};

compare_nat :: Nat -> Nat -> Ordera;
compare_nat = comparator_of;

class Compare a where {
  compare :: a -> a -> Ordera;
};

instance Compare Nat where {
  compare = compare_nat;
};

class (Sup a, Quasi_order a) => Quasi_order_sup a where {
};

class (Quasi_order_sup a) => Quasi_semilattice_sup a where {
};

class (Order a, Quasi_semilattice_sup a) => Semilattice_sup a where {
};

class (Inf a, Order a) => Semilattice_inf a where {
};

class (Semilattice_inf a, Semilattice_sup a) => Lattice a where {
};

instance Quasi_order_sup Nat where {
};

instance Quasi_semilattice_sup Nat where {
};

instance Semilattice_sup Nat where {
};

instance Semilattice_inf Nat where {
};

instance Lattice Nat where {
};

ceq_nat :: Maybe (Nat -> Nat -> Bool);
ceq_nat = Just equal_nat;

instance Ceq Nat where {
  ceq = ceq_nat;
};

set_impl_nat :: Phantom Nat Set_impla;
set_impl_nat = Phantom Set_RBT;

instance Set_impl Nat where {
  set_impl = set_impl_nat;
};

showsl_list_nat :: [Nat] -> String -> String;
showsl_list_nat xs = default_showsl_list showsl_nat xs;

instance Showl Nat where {
  showsl = showsl_nat;
  showsl_list = showsl_list_nat;
};

class (Divide a, Semidom a,
        Semiring_no_zero_divisors_cancel a) => Semidom_divide a where {
};

instance Semiring_no_zero_divisors_cancel Nat where {
};

instance Semidom_divide Nat where {
};

class (Semidom_divide a) => Algebraic_semidom a where {
};

class (Comm_semiring_1_cancel a, Modulo a) => Semiring_modulo a where {
};

class (Algebraic_semidom a, Semiring_modulo a) => Semidom_modulo a where {
};

instance Algebraic_semidom Nat where {
};

instance Semiring_modulo Nat where {
};

instance Semidom_modulo Nat where {
};

finite_UNIV_nat :: Phantom Nat Bool;
finite_UNIV_nat = Phantom False;

card_UNIV_nat :: Phantom Nat Nat;
card_UNIV_nat = Phantom zero_nat;

class Finite_UNIV a where {
  finite_UNIV :: Phantom a Bool;
};

class (Finite_UNIV a) => Card_UNIV a where {
  card_UNIVa :: Phantom a Nat;
};

instance Finite_UNIV Nat where {
  finite_UNIV = finite_UNIV_nat;
};

instance Card_UNIV Nat where {
  card_UNIVa = card_UNIV_nat;
};

cEnum_nat :: Maybe ([Nat], ((Nat -> Bool) -> Bool, (Nat -> Bool) -> Bool));
cEnum_nat = Nothing;

instance Cenum Nat where {
  cEnum = cEnum_nat;
};

class (Compare a, Linorder a) => Compare_order a where {
};

instance Compare_order Nat where {
};

ccompare_nat :: Maybe (Nat -> Nat -> Ordera);
ccompare_nat = Just compare_nat;

instance Ccompare Nat where {
  ccompare = ccompare_nat;
};

data Mapping_impla = Mapping_Choose | Mapping_Assoc_List | Mapping_RBT
  | Mapping_Mapping;

mapping_impl_nat :: Phantom Nat Mapping_impla;
mapping_impl_nat = Phantom Mapping_RBT;

class Mapping_impl a where {
  mapping_impl :: Phantom a Mapping_impla;
};

instance Mapping_impl Nat where {
  mapping_impl = mapping_impl_nat;
};

proper_interval_nat :: Maybe Nat -> Maybe Nat -> Bool;
proper_interval_nat no Nothing = True;
proper_interval_nat Nothing (Just x) = less_nat zero_nat x;
proper_interval_nat (Just x) (Just y) = less_nat one_nat (minus_nat y x);

cproper_interval_nat :: Maybe Nat -> Maybe Nat -> Bool;
cproper_interval_nat = proper_interval_nat;

class (Ccompare a) => Cproper_interval a where {
  cproper_interval :: Maybe a -> Maybe a -> Bool;
};

instance Cproper_interval Nat where {
  cproper_interval = cproper_interval_nat;
};

quotient_of :: Rat -> (Int, Int);
quotient_of (Frct x) = x;

equal_rat :: Rat -> Rat -> Bool;
equal_rat a b = quotient_of a == quotient_of b;

instance Eq Rat where {
  a == b = equal_rat a b;
};

divide_int :: Int -> Int -> Int;
divide_int k l =
  Int_of_integer (divide_integer (integer_of_int k) (integer_of_int l));

gcd_int :: Int -> Int -> Int;
gcd_int (Int_of_integer x) (Int_of_integer y) =
  Int_of_integer (Prelude.gcd x y);

normalize :: (Int, Int) -> (Int, Int);
normalize p =
  (if less_int zero_int (snd p)
    then let {
           a = gcd_int (fst p) (snd p);
         } in (divide_int (fst p) a, divide_int (snd p) a)
    else (if equal_int (snd p) zero_int then (zero_int, one_int)
           else let {
                  a = uminus_int (gcd_int (fst p) (snd p));
                } in (divide_int (fst p) a, divide_int (snd p) a)));

times_rat :: Rat -> Rat -> Rat;
times_rat p q =
  Frct (let {
          a = quotient_of p;
        } in (case a of {
               (aa, c) ->
                 let {
                   b = quotient_of q;
                 } in (case b of {
                        (ba, d) -> normalize (times_int aa ba, times_int c d);
                      });
             }));

instance Times Rat where {
  times = times_rat;
};

instance Dvd Rat where {
};

abs_rat :: Rat -> Rat;
abs_rat p = Frct (let {
                    a = quotient_of p;
                  } in (case a of {
                         (aa, b) -> (abs_int aa, b);
                       }));

instance Abs Rat where {
  absa = abs_rat;
};

one_rat :: Rat;
one_rat = Frct (one_int, one_int);

instance One Rat where {
  onea = one_rat;
};

sgn_rat :: Rat -> Rat;
sgn_rat p = Frct (sgn_int (fst (quotient_of p)), one_int);

instance Sgn Rat where {
  sgn = sgn_rat;
};

uminus_rat :: Rat -> Rat;
uminus_rat p = Frct (let {
                       a = quotient_of p;
                     } in (case a of {
                            (aa, b) -> (uminus_int aa, b);
                          }));

minus_rat :: Rat -> Rat -> Rat;
minus_rat p q =
  Frct (let {
          a = quotient_of p;
        } in (case a of {
               (aa, c) ->
                 let {
                   b = quotient_of q;
                 } in (case b of {
                        (ba, d) ->
                          normalize
                            (minus_int (times_int aa d) (times_int ba c),
                              times_int c d);
                      });
             }));

plus_rat :: Rat -> Rat -> Rat;
plus_rat p q =
  Frct (let {
          a = quotient_of p;
        } in (case a of {
               (aa, c) ->
                 let {
                   b = quotient_of q;
                 } in (case b of {
                        (ba, d) ->
                          normalize
                            (plus_int (times_int aa d) (times_int ba c),
                              times_int c d);
                      });
             }));

instance Plus Rat where {
  plus = plus_rat;
};

instance Semigroup_add Rat where {
};

instance Cancel_semigroup_add Rat where {
};

instance Ab_semigroup_add Rat where {
};

instance Minus Rat where {
  minus = minus_rat;
};

instance Cancel_ab_semigroup_add Rat where {
};

instance Zero Rat where {
  zerob = zero_rat;
};

instance Monoid_add Rat where {
};

instance Comm_monoid_add Rat where {
};

instance Cancel_comm_monoid_add Rat where {
};

instance Mult_zero Rat where {
};

instance Semigroup_mult Rat where {
};

instance Semiring Rat where {
};

instance Semiring_0 Rat where {
};

instance Semiring_0_cancel Rat where {
};

instance Ab_semigroup_mult Rat where {
};

instance Comm_semiring Rat where {
};

instance Comm_semiring_0 Rat where {
};

instance Comm_semiring_0_cancel Rat where {
};

instance Power Rat where {
};

instance Monoid_mult Rat where {
};

instance Numeral Rat where {
};

instance Semiring_numeral Rat where {
};

instance Zero_neq_one Rat where {
};

instance Semiring_1 Rat where {
};

instance Semiring_1_cancel Rat where {
};

instance Comm_monoid_mult Rat where {
};

instance Comm_semiring_1 Rat where {
};

instance Comm_semiring_1_cancel Rat where {
};

instance Comm_semiring_1_cancel_crossproduct Rat where {
};

instance Semiring_no_zero_divisors Rat where {
};

instance Semiring_1_no_zero_divisors Rat where {
};

instance Semiring_no_zero_divisors_cancel Rat where {
};

instance Uminus Rat where {
  uminus = uminus_rat;
};

instance Group_add Rat where {
};

instance Ab_group_add Rat where {
};

instance Ring Rat where {
};

instance Ring_no_zero_divisors Rat where {
};

instance Neg_numeral Rat where {
};

instance Ring_1 Rat where {
};

instance Ring_1_no_zero_divisors Rat where {
};

instance Comm_ring Rat where {
};

instance Comm_ring_1 Rat where {
};

instance Semidom Rat where {
};

instance Idom Rat where {
};

inverse_rat :: Rat -> Rat;
inverse_rat p =
  Frct (let {
          a = quotient_of p;
        } in (case a of {
               (aa, b) ->
                 (if equal_int aa zero_int then (zero_int, one_int)
                   else (times_int (sgn_int aa) b, abs_int aa));
             }));

divide_rat :: Rat -> Rat -> Rat;
divide_rat p q =
  Frct (let {
          a = quotient_of p;
        } in (case a of {
               (aa, c) ->
                 let {
                   b = quotient_of q;
                 } in (case b of {
                        (ba, d) -> normalize (times_int aa d, times_int c ba);
                      });
             }));

class (Divide a) => Inverse a where {
  inverse :: a -> a;
};

class (Idom a) => Ufd a where {
};

class (Inverse a, Ring_1_no_zero_divisors a) => Division_ring a where {
};

class (Idom a, Semidom_divide a) => Idom_divide a where {
};

class (Division_ring a, Idom_divide a, Ufd a) => Field a where {
};

instance Ufd Rat where {
};

instance Divide Rat where {
  divide = divide_rat;
};

instance Inverse Rat where {
  inverse = inverse_rat;
};

instance Division_ring Rat where {
};

instance Semidom_divide Rat where {
};

instance Idom_divide Rat where {
};

instance Field Rat where {
};

less_eq_rat :: Rat -> Rat -> Bool;
less_eq_rat p q =
  let {
    a = quotient_of p;
  } in (case a of {
         (aa, c) ->
           let {
             b = quotient_of q;
           } in (case b of {
                  (ba, d) -> less_eq_int (times_int aa d) (times_int c ba);
                });
       });

less_rat :: Rat -> Rat -> Bool;
less_rat p q =
  let {
    a = quotient_of p;
  } in (case a of {
         (aa, c) ->
           let {
             b = quotient_of q;
           } in (case b of {
                  (ba, d) -> less_int (times_int aa d) (times_int c ba);
                });
       });

instance Ord Rat where {
  less_eq = less_eq_rat;
  less = less_rat;
};

inf_rat :: Rat -> Rat -> Rat;
inf_rat = min;

instance Inf Rat where {
  inf = inf_rat;
};

sup_rat :: Rat -> Rat -> Rat;
sup_rat = max;

instance Sup Rat where {
  sup = sup_rat;
};

instance Abs_if Rat where {
};

instance Quasi_order Rat where {
};

instance Weak_order Rat where {
};

instance Preorder Rat where {
};

instance Order Rat where {
};

instance Linorder Rat where {
};

compare_rat :: Rat -> Rat -> Ordera;
compare_rat = comparator_of;

instance Compare Rat where {
  compare = compare_rat;
};

instance Semiring_char_0 Rat where {
};

instance Ring_char_0 Rat where {
};

instance Quasi_order_sup Rat where {
};

instance Quasi_semilattice_sup Rat where {
};

instance Semilattice_sup Rat where {
};

instance Semilattice_inf Rat where {
};

instance Lattice Rat where {
};

class (Order a) => No_bot a where {
};

instance No_bot Rat where {
};

class (Order a) => No_top a where {
};

instance No_top Rat where {
};

ceq_rat :: Maybe (Rat -> Rat -> Bool);
ceq_rat = Just equal_rat;

instance Ceq Rat where {
  ceq = ceq_rat;
};

set_impl_rat :: Phantom Rat Set_impla;
set_impl_rat = Phantom Set_RBT;

instance Set_impl Rat where {
  set_impl = set_impl_rat;
};

instance Idom_abs_sgn Rat where {
};

instance Ordered_ab_semigroup_add Rat where {
};

instance Strict_ordered_ab_semigroup_add Rat where {
};

instance Ordered_cancel_ab_semigroup_add Rat where {
};

instance Ordered_semigroup_mult_zero Rat where {
};

instance Ordered_comm_monoid_add Rat where {
};

instance Ordered_semiring Rat where {
};

instance Ordered_semiring_0 Rat where {
};

instance Ordered_cancel_semiring Rat where {
};

instance Ordered_ab_semigroup_add_imp_le Rat where {
};

instance Strict_ordered_comm_monoid_add Rat where {
};

instance Ordered_cancel_comm_monoid_add Rat where {
};

instance Ordered_ab_semigroup_monoid_add_imp_le Rat where {
};

instance Ordered_ab_group_add Rat where {
};

instance Ordered_ring Rat where {
};

class (Field a, Ring_char_0 a) => Field_char_0 a where {
};

instance Field_char_0 Rat where {
};

instance Zero_less_one Rat where {
};

showsl_rat :: Rat -> String -> String;
showsl_rat x =
  (case quotient_of x of {
    (d, n) ->
      (if equal_int n one_int then showsl_int d
        else (showsl_int d . showsl_lit "/") . showsl_int n);
  });

showsl_list_rat :: [Rat] -> String -> String;
showsl_list_rat xs = default_showsl_list showsl_rat xs;

instance Showl Rat where {
  showsl = showsl_rat;
  showsl_list = showsl_list_rat;
};

class (Field a, Idom_abs_sgn a) => Field_abs_sgn a where {
};

instance Field_abs_sgn Rat where {
};

cEnum_rat :: Maybe ([Rat], ((Rat -> Bool) -> Bool, (Rat -> Bool) -> Bool));
cEnum_rat = Nothing;

instance Cenum Rat where {
  cEnum = cEnum_rat;
};

class (Order a) => Dense_order a where {
};

instance Dense_order Rat where {
};

instance Linordered_ab_semigroup_add Rat where {
};

instance Linordered_cancel_ab_semigroup_add Rat where {
};

instance Linordered_semiring Rat where {
};

instance Linordered_semiring_strict Rat where {
};

instance Ordered_semiring_1a Rat where {
};

instance Linordered_semiring_1 Rat where {
};

instance Linordered_semiring_1_strict Rat where {
};

instance Ordered_ab_group_add_abs Rat where {
};

instance Linordered_ab_group_add Rat where {
};

instance Linordered_ring Rat where {
};

instance Linordered_ring_strict Rat where {
};

instance Ordered_semiring_1b Rat where {
};

instance Ordered_semiring_strict Rat where {
};

instance Semiring_real_line Rat where {
};

instance Semiring_1_real_line Rat where {
};

instance Ordered_comm_semiring Rat where {
};

instance Ordered_cancel_comm_semiring Rat where {
};

instance Linordered_comm_semiring_strict Rat where {
};

instance Linordered_nonzero_semiring Rat where {
};

instance Linordered_semidom Rat where {
};

instance Ordered_comm_ring Rat where {
};

instance Ordered_ring_abs Rat where {
};

instance Linordered_idom Rat where {
};

instance Non_strict_order Rat where {
};

instance Ordered_ab_semigroup Rat where {
};

instance Ordered_semiring_0a Rat where {
};

instance Ordered_semiring_1 Rat where {
};

instance Poly_carrier Rat where {
};

class (Dense_order a, Linorder a) => Dense_linorder a where {
};

class (Dense_linorder a, No_bot a,
        No_top a) => Unbounded_dense_linorder a where {
};

class (Field_abs_sgn a, Field_char_0 a, Unbounded_dense_linorder a,
        Linordered_idom a) => Linordered_field a where {
};

instance Dense_linorder Rat where {
};

instance Unbounded_dense_linorder Rat where {
};

instance Linordered_field Rat where {
};

ccompare_rat :: Maybe (Rat -> Rat -> Ordera);
ccompare_rat = Just compare_rat;

instance Ccompare Rat where {
  ccompare = ccompare_rat;
};

real_of_rat :: Rat -> Real;
real_of_rat x = ratreal x;

instance Real_embedding Rat where {
  real_of = real_of_rat;
};

class (Linordered_field a) => Archimedean_field a where {
};

class (Archimedean_field a,
        Large_ordered_semiring_1 a) => Floor_ceiling a where {
  floor :: a -> Int;
};

floor_rat :: Rat -> Int;
floor_rat p = let {
                a = quotient_of p;
              } in (case a of {
                     (aa, b) -> divide_int aa b;
                   });

instance Archimedean_field Rat where {
};

instance Large_ordered_semiring_1 Rat where {
};

instance Floor_ceiling Rat where {
  floor = floor_rat;
};

instance Large_real_ordered_semiring_1 Rat where {
};

equal_order :: Ordera -> Ordera -> Bool;
equal_order Lt Gt = False;
equal_order Gt Lt = False;
equal_order Eqa Gt = False;
equal_order Gt Eqa = False;
equal_order Eqa Lt = False;
equal_order Lt Eqa = False;
equal_order Gt Gt = True;
equal_order Lt Lt = True;
equal_order Eqa Eqa = True;

newtype Generator a b = Generator (b -> Bool, b -> (a, b));

generator :: forall a b. Generator a b -> (b -> Bool, b -> (a, b));
generator (Generator x) = x;

has_next :: forall a b. Generator a b -> b -> Bool;
has_next g = fst (generator g);

next :: forall a b. Generator a b -> b -> (a, b);
next g = snd (generator g);

sorted_list_subset_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
sorted_list_subset_fusion less eq g1 g2 s1 s2 =
  (if has_next g1 s1
    then (case next g1 s1 of {
           (x, s1a) ->
             has_next g2 s2 &&
               (case next g2 s2 of {
                 (y, s2a) ->
                   (if eq x y
                     then sorted_list_subset_fusion less eq g1 g2 s1a s2a
                     else less y x &&
                            sorted_list_subset_fusion less eq g1 g2 s1 s2a);
               });
         })
    else True);

list_all_fusion :: forall a b. Generator a b -> (a -> Bool) -> b -> Bool;
list_all_fusion g p s =
  (if has_next g s then (case next g s of {
                          (x, sa) -> p x && list_all_fusion g p sa;
                        })
    else True);

data Color = R | B;

data Rbta a b = Empty | Branch Color (Rbta a b) a b (Rbta a b);

rbt_keys_next ::
  forall a b. ([(a, Rbta a b)], Rbta a b) -> (a, ([(a, Rbta a b)], Rbta a b));
rbt_keys_next ((k, t) : kts, Empty) = (k, (kts, t));
rbt_keys_next (kts, Branch c l k v r) = rbt_keys_next ((k, r) : kts, l);

rbt_has_next :: forall a b c. ([(a, Rbta b c)], Rbta b c) -> Bool;
rbt_has_next ([], Empty) = False;
rbt_has_next (vb : vc, va) = True;
rbt_has_next (v, Branch vb vc vd ve vf) = True;

rbt_keys_generator :: forall a b. Generator a ([(a, Rbta a b)], Rbta a b);
rbt_keys_generator = Generator (rbt_has_next, rbt_keys_next);

lt_of_comp :: forall a. (a -> a -> Ordera) -> a -> a -> Bool;
lt_of_comp acomp x y = (case acomp x y of {
                         Eqa -> False;
                         Lt -> True;
                         Gt -> False;
                       });

newtype Mapping_rbt b a = Mapping_RBTa (Rbta b a);

newtype Set_dlist a = Abs_dlist [a];

data Set a = Collect_set (a -> Bool) | DList_set (Set_dlist a)
  | RBT_set (Mapping_rbt a ()) | Set_Monad [a] | Complement (Set a);

list_of_dlist :: forall a. (Ceq a) => Set_dlist a -> [a];
list_of_dlist (Abs_dlist x) = x;

dlist_all :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Bool;
dlist_all x xc = all x (list_of_dlist xc);

impl_ofb :: forall b a. (Ccompare b) => Mapping_rbt b a -> Rbta b a;
impl_ofb (Mapping_RBTa x) = x;

rbt_init :: forall a b c. Rbta a b -> ([(c, Rbta a b)], Rbta a b);
rbt_init = (\ a -> ([], a));

init ::
  forall a b c. (Ccompare a) => Mapping_rbt a b -> ([(c, Rbta a b)], Rbta a b);
init xa = rbt_init (impl_ofb xa);

collect :: forall a. (Cenum a) => (a -> Bool) -> Set a;
collect p = (case cEnum of {
              Nothing -> Collect_set p;
              Just (enum, _) -> Set_Monad (filter p enum);
            });

list_member :: forall a. (a -> a -> Bool) -> [a] -> a -> Bool;
list_member equal (x : xs) y = equal x y || list_member equal xs y;
list_member equal [] y = False;

the :: forall a. Maybe a -> a;
the (Just x2) = x2;

memberc :: forall a. (Ceq a) => Set_dlist a -> a -> Bool;
memberc xa = list_member (the ceq) (list_of_dlist xa);

rbt_comp_lookup :: forall a b. (a -> a -> Ordera) -> Rbta a b -> a -> Maybe b;
rbt_comp_lookup c Empty k = Nothing;
rbt_comp_lookup c (Branch uu l x y r) k = (case c k x of {
    Eqa -> Just y;
    Lt -> rbt_comp_lookup c l k;
    Gt -> rbt_comp_lookup c r k;
  });

lookupd :: forall a b. (Ccompare a) => Mapping_rbt a b -> a -> Maybe b;
lookupd xa = rbt_comp_lookup (the ccompare) (impl_ofb xa);

memberb :: forall a. (Ccompare a) => Mapping_rbt a () -> a -> Bool;
memberb t x = lookupd t x == Just ();

member :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Bool;
member x (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "member Set_Monad: ceq = None" (\ _ -> member x (Set_Monad xs));
    Just eq -> list_member eq xs x;
  });
member xa (Complement x) = not (member xa x);
member x (RBT_set rbt) = memberb rbt x;
member x (DList_set dxs) = memberc dxs x;
member x (Collect_set a) = a x;

subset_eq :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
subset_eq (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset RBT_set RBT_set: ccompare = None"
        (\ _ -> subset_eq (RBT_set rbt1) (RBT_set rbt2));
    Just c ->
      (case ceq of {
        Nothing ->
          sorted_list_subset_fusion (lt_of_comp c)
            (\ x y -> equal_order (c x y) Eqa) rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
        Just eq ->
          sorted_list_subset_fusion (lt_of_comp c) eq rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
      });
  });
subset_eq (Complement a1) (Complement a2) = subset_eq a2 a1;
subset_eq (Collect_set p) (Complement a) =
  subset_eq a (collect (\ x -> not (p x)));
subset_eq (Set_Monad xs) c = all (\ x -> member x c) xs;
subset_eq (DList_set dxs) c =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset DList_set1: ceq = None" (\ _ -> subset_eq (DList_set dxs) c);
    Just _ -> dlist_all (\ x -> member x c) dxs;
  });
subset_eq (RBT_set rbt) b =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset RBT_set1: ccompare = None" (\ _ -> subset_eq (RBT_set rbt) b);
    Just _ -> list_all_fusion rbt_keys_generator (\ x -> member x b) (init rbt);
  });

less_eq_set :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
less_eq_set = subset_eq;

equal_set ::
  forall a. (Cenum a, Ceq a, Ccompare a, Eq a) => Set a -> Set a -> Bool;
equal_set a b = less_eq_set a b && less_eq_set b a;

instance (Cenum a, Ceq a, Ccompare a, Eq a) => Eq (Set a) where {
  a == b = equal_set a b;
};

uminus_set :: forall a. Set a -> Set a;
uminus_set (Complement b) = b;
uminus_set (Collect_set p) = Collect_set (\ x -> not (p x));
uminus_set a = Complement a;

balance :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance (Branch R a w x b) s t (Branch R c y z d) =
  Branch R (Branch B a w x b) s t (Branch B c y z d);
balance (Branch R (Branch R a w x b) s t c) y z Empty =
  Branch R (Branch B a w x b) s t (Branch B c y z Empty);
balance (Branch R (Branch R a w x b) s t c) y z (Branch B va vb vc vd) =
  Branch R (Branch B a w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch R Empty w x (Branch R b s t c)) y z Empty =
  Branch R (Branch B Empty w x b) s t (Branch B c y z Empty);
balance (Branch R (Branch B va vb vc vd) w x (Branch R b s t c)) y z Empty =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z Empty);
balance (Branch R Empty w x (Branch R b s t c)) y z (Branch B va vb vc vd) =
  Branch R (Branch B Empty w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch R (Branch B ve vf vg vh) w x (Branch R b s t c)) y z
  (Branch B va vb vc vd) =
  Branch R (Branch B (Branch B ve vf vg vh) w x b) s t
    (Branch B c y z (Branch B va vb vc vd));
balance Empty w x (Branch R b s t (Branch R c y z d)) =
  Branch R (Branch B Empty w x b) s t (Branch B c y z d);
balance (Branch B va vb vc vd) w x (Branch R b s t (Branch R c y z d)) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z d);
balance Empty w x (Branch R (Branch R b s t c) y z Empty) =
  Branch R (Branch B Empty w x b) s t (Branch B c y z Empty);
balance Empty w x (Branch R (Branch R b s t c) y z (Branch B va vb vc vd)) =
  Branch R (Branch B Empty w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch B va vb vc vd) w x (Branch R (Branch R b s t c) y z Empty) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z Empty);
balance (Branch B va vb vc vd) w x
  (Branch R (Branch R b s t c) y z (Branch B ve vf vg vh)) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t
    (Branch B c y z (Branch B ve vf vg vh));
balance Empty s t Empty = Branch B Empty s t Empty;
balance Empty s t (Branch B va vb vc vd) =
  Branch B Empty s t (Branch B va vb vc vd);
balance Empty s t (Branch v Empty vb vc Empty) =
  Branch B Empty s t (Branch v Empty vb vc Empty);
balance Empty s t (Branch v (Branch B ve vf vg vh) vb vc Empty) =
  Branch B Empty s t (Branch v (Branch B ve vf vg vh) vb vc Empty);
balance Empty s t (Branch v Empty vb vc (Branch B vf vg vh vi)) =
  Branch B Empty s t (Branch v Empty vb vc (Branch B vf vg vh vi));
balance Empty s t (Branch v (Branch B ve vj vk vl) vb vc (Branch B vf vg vh vi))
  = Branch B Empty s t
      (Branch v (Branch B ve vj vk vl) vb vc (Branch B vf vg vh vi));
balance (Branch B va vb vc vd) s t Empty =
  Branch B (Branch B va vb vc vd) s t Empty;
balance (Branch B va vb vc vd) s t (Branch B ve vf vg vh) =
  Branch B (Branch B va vb vc vd) s t (Branch B ve vf vg vh);
balance (Branch B va vb vc vd) s t (Branch v Empty vf vg Empty) =
  Branch B (Branch B va vb vc vd) s t (Branch v Empty vf vg Empty);
balance (Branch B va vb vc vd) s t (Branch v (Branch B vi vj vk vl) vf vg Empty)
  = Branch B (Branch B va vb vc vd) s t
      (Branch v (Branch B vi vj vk vl) vf vg Empty);
balance (Branch B va vb vc vd) s t (Branch v Empty vf vg (Branch B vj vk vl vm))
  = Branch B (Branch B va vb vc vd) s t
      (Branch v Empty vf vg (Branch B vj vk vl vm));
balance (Branch B va vb vc vd) s t
  (Branch v (Branch B vi vn vo vp) vf vg (Branch B vj vk vl vm)) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v (Branch B vi vn vo vp) vf vg (Branch B vj vk vl vm));
balance (Branch v Empty vb vc Empty) s t Empty =
  Branch B (Branch v Empty vb vc Empty) s t Empty;
balance (Branch v Empty vb vc (Branch B ve vf vg vh)) s t Empty =
  Branch B (Branch v Empty vb vc (Branch B ve vf vg vh)) s t Empty;
balance (Branch v (Branch B vf vg vh vi) vb vc Empty) s t Empty =
  Branch B (Branch v (Branch B vf vg vh vi) vb vc Empty) s t Empty;
balance (Branch v (Branch B vf vg vh vi) vb vc (Branch B ve vj vk vl)) s t Empty
  = Branch B (Branch v (Branch B vf vg vh vi) vb vc (Branch B ve vj vk vl)) s t
      Empty;
balance (Branch v Empty vf vg Empty) s t (Branch B va vb vc vd) =
  Branch B (Branch v Empty vf vg Empty) s t (Branch B va vb vc vd);
balance (Branch v Empty vf vg (Branch B vi vj vk vl)) s t (Branch B va vb vc vd)
  = Branch B (Branch v Empty vf vg (Branch B vi vj vk vl)) s t
      (Branch B va vb vc vd);
balance (Branch v (Branch B vj vk vl vm) vf vg Empty) s t (Branch B va vb vc vd)
  = Branch B (Branch v (Branch B vj vk vl vm) vf vg Empty) s t
      (Branch B va vb vc vd);
balance (Branch v (Branch B vj vk vl vm) vf vg (Branch B vi vn vo vp)) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v (Branch B vj vk vl vm) vf vg (Branch B vi vn vo vp)) s t
    (Branch B va vb vc vd);

rbt_comp_ins ::
  forall a b.
    (a -> a -> Ordera) -> (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_ins c f k v Empty = Branch R Empty k v Empty;
rbt_comp_ins c f k v (Branch B l x y r) =
  (case c k x of {
    Eqa -> Branch B l x (f k y v) r;
    Lt -> balance (rbt_comp_ins c f k v l) x y r;
    Gt -> balance l x y (rbt_comp_ins c f k v r);
  });
rbt_comp_ins c f k v (Branch R l x y r) =
  (case c k x of {
    Eqa -> Branch R l x (f k y v) r;
    Lt -> Branch R (rbt_comp_ins c f k v l) x y r;
    Gt -> Branch R l x y (rbt_comp_ins c f k v r);
  });

paint :: forall a b. Color -> Rbta a b -> Rbta a b;
paint c Empty = Empty;
paint c (Branch uu l k v r) = Branch c l k v r;

rbt_comp_insert_with_key ::
  forall a b.
    (a -> a -> Ordera) -> (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_insert_with_key c f k v t = paint B (rbt_comp_ins c f k v t);

rbt_comp_insert ::
  forall a b. (a -> a -> Ordera) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_insert c = rbt_comp_insert_with_key c (\ _ _ nv -> nv);

inserte ::
  forall a b. (Ccompare a) => a -> b -> Mapping_rbt a b -> Mapping_rbt a b;
inserte xc xd xe =
  Mapping_RBTa (rbt_comp_insert (the ccompare) xc xd (impl_ofb xe));

comp_sunion_with ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
comp_sunion_with c f ((ka, va) : asa) ((k, v) : bs) =
  (case c k ka of {
    Eqa -> (ka, f ka va v) : comp_sunion_with c f asa bs;
    Lt -> (k, v) : comp_sunion_with c f ((ka, va) : asa) bs;
    Gt -> (ka, va) : comp_sunion_with c f asa ((k, v) : bs);
  });
comp_sunion_with c f [] bs = bs;
comp_sunion_with c f asa [] = asa;

data Comparea = LT | GT | EQ;

skip_red :: forall a b. Rbta a b -> Rbta a b;
skip_red (Branch R l k v r) = l;
skip_red Empty = Empty;
skip_red (Branch B va vb vc vd) = Branch B va vb vc vd;

skip_black :: forall a b. Rbta a b -> Rbta a b;
skip_black t = let {
                 ta = skip_red t;
               } in (case ta of {
                      Empty -> ta;
                      Branch R _ _ _ _ -> ta;
                      Branch B l _ _ _ -> l;
                    });

compare_height ::
  forall a b. Rbta a b -> Rbta a b -> Rbta a b -> Rbta a b -> Comparea;
compare_height sx s t tx =
  (case (skip_red sx, (skip_red s, (skip_red t, skip_red tx))) of {
    (Empty, (Empty, (_, Empty))) -> EQ;
    (Empty, (Empty, (_, Branch _ _ _ _ _))) -> LT;
    (Empty, (Branch _ _ _ _ _, (Empty, _))) -> EQ;
    (Empty, (Branch _ _ _ _ _, (Branch _ _ _ _ _, Empty))) -> EQ;
    (Empty, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Branch _ txa _ _ _))) ->
      compare_height Empty sa ta (skip_black txa);
    (Branch _ _ _ _ _, (Empty, (Empty, Empty))) -> GT;
    (Branch _ _ _ _ _, (Empty, (Empty, Branch _ _ _ _ _))) -> LT;
    (Branch _ _ _ _ _, (Empty, (Branch _ _ _ _ _, Empty))) -> EQ;
    (Branch _ _ _ _ _, (Empty, (Branch _ _ _ _ _, Branch _ _ _ _ _))) -> LT;
    (Branch _ _ _ _ _, (Branch _ _ _ _ _, (Empty, _))) -> GT;
    (Branch _ sxa _ _ _, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Empty))) ->
      compare_height (skip_black sxa) sa ta Empty;
    (Branch _ sxa _ _ _,
      (Branch _ sa _ _ _, (Branch _ ta _ _ _, Branch _ txa _ _ _)))
      -> compare_height (skip_black sxa) sa ta (skip_black txa);
  });

suc :: Nat -> Nat;
suc n = plus_nat n one_nat;

gen_length :: forall a. Nat -> [a] -> Nat;
gen_length n (x : xs) = gen_length (suc n) xs;
gen_length n [] = n;

size_list :: forall a. [a] -> Nat;
size_list = gen_length zero_nat;

apfst :: forall a b c. (a -> b) -> (a, c) -> (b, c);
apfst f (x, y) = (f x, y);

map_prod :: forall a b c d. (a -> b) -> (c -> d) -> (a, c) -> (b, d);
map_prod f g (a, b) = (f a, g b);

divmod_nat :: Nat -> Nat -> (Nat, Nat);
divmod_nat m n =
  let {
    k = integer_of_nat m;
    l = integer_of_nat n;
  } in map_prod nat_of_integer nat_of_integer
         (if k == (0 :: Integer) then ((0 :: Integer), (0 :: Integer))
           else (if l == (0 :: Integer) then ((0 :: Integer), k)
                  else divMod ( k ) ( l )));

rbtreeify_g :: forall a b. Nat -> [(a, b)] -> (Rbta a b, [(a, b)]);
rbtreeify_g n kvs =
  (if equal_nat n zero_nat || equal_nat n one_nat then (Empty, kvs)
    else (case divmod_nat n (nat_of_integer (2 :: Integer)) of {
           (na, r) ->
             (if equal_nat r zero_nat
               then (case rbtreeify_g na kvs of {
                      (t1, (k, v) : kvsa) ->
                        apfst (Branch B t1 k v) (rbtreeify_g na kvsa);
                    })
               else (case rbtreeify_f na kvs of {
                      (t1, (k, v) : kvsa) ->
                        apfst (Branch B t1 k v) (rbtreeify_g na kvsa);
                    }));
         }));

rbtreeify_f :: forall a b. Nat -> [(a, b)] -> (Rbta a b, [(a, b)]);
rbtreeify_f n kvs =
  (if equal_nat n zero_nat then (Empty, kvs)
    else (if equal_nat n one_nat
           then (case kvs of {
                  (k, v) : kvsa -> (Branch R Empty k v Empty, kvsa);
                })
           else (case divmod_nat n (nat_of_integer (2 :: Integer)) of {
                  (na, r) ->
                    (if equal_nat r zero_nat
                      then (case rbtreeify_f na kvs of {
                             (t1, (k, v) : kvsa) ->
                               apfst (Branch B t1 k v) (rbtreeify_g na kvsa);
                           })
                      else (case rbtreeify_f na kvs of {
                             (t1, (k, v) : kvsa) ->
                               apfst (Branch B t1 k v) (rbtreeify_f na kvsa);
                           }));
                })));

rbtreeify :: forall a b. [(a, b)] -> Rbta a b;
rbtreeify kvs = fst (rbtreeify_g (suc (size_list kvs)) kvs);

gen_entries :: forall a b. [((a, b), Rbta a b)] -> Rbta a b -> [(a, b)];
gen_entries kvts (Branch c l k v r) = gen_entries (((k, v), r) : kvts) l;
gen_entries ((kv, t) : kvts) Empty = kv : gen_entries kvts t;
gen_entries [] Empty = [];

entries :: forall a b. Rbta a b -> [(a, b)];
entries = gen_entries [];

folda :: forall a b c. (a -> b -> c -> c) -> Rbta a b -> c -> c;
folda f (Branch c lt k v rt) x = folda f rt (f k v (folda f lt x));
folda f Empty x = x;

rbt_comp_union_with_key ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_comp_union_with_key c f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> folda (rbt_comp_insert_with_key c (\ k v w -> f k w v)) t1 t2;
    GT -> folda (rbt_comp_insert_with_key c f) t2 t1;
    EQ -> rbtreeify (comp_sunion_with c f (entries t1) (entries t2));
  });

join ::
  forall a b.
    (Ccompare a) => (a -> b -> b -> b) ->
                      Mapping_rbt a b -> Mapping_rbt a b -> Mapping_rbt a b;
join xc xd xe =
  Mapping_RBTa
    (rbt_comp_union_with_key (the ccompare) xc (impl_ofb xd) (impl_ofb xe));

list_insert :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
list_insert equal x xs = (if list_member equal xs x then xs else x : xs);

insertc :: forall a. (Ceq a) => a -> Set_dlist a -> Set_dlist a;
insertc xb xc = Abs_dlist (list_insert (the ceq) xb (list_of_dlist xc));

fold :: forall a b. (a -> b -> b) -> [a] -> b -> b;
fold f (x : xs) s = fold f xs (f x s);
fold f [] s = s;

foldc :: forall a b. (Ceq a) => (a -> b -> b) -> Set_dlist a -> b -> b;
foldc x xc = fold x (list_of_dlist xc);

uniona :: forall a. (Ceq a) => Set_dlist a -> Set_dlist a -> Set_dlist a;
uniona = foldc insertc;

is_none :: forall a. Maybe a -> Bool;
is_none (Just x) = False;
is_none Nothing = True;

inter_list ::
  forall a. (Ccompare a) => Mapping_rbt a () -> [a] -> Mapping_rbt a ();
inter_list xb xc =
  Mapping_RBTa
    (fold (\ k -> rbt_comp_insert (the ccompare) k ())
      (filter
        (\ x -> not (is_none (rbt_comp_lookup (the ccompare) (impl_ofb xb) x)))
        xc)
      Empty);

filterd ::
  forall a b.
    (Ccompare a) => ((a, b) -> Bool) -> Mapping_rbt a b -> Mapping_rbt a b;
filterd xb xc = Mapping_RBTa (rbtreeify (filter xb (entries (impl_ofb xc))));

comp_sinter_with ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
comp_sinter_with c f ((ka, va) : asa) ((k, v) : bs) =
  (case c k ka of {
    Eqa -> (ka, f ka va v) : comp_sinter_with c f asa bs;
    Lt -> comp_sinter_with c f ((ka, va) : asa) bs;
    Gt -> comp_sinter_with c f asa ((k, v) : bs);
  });
comp_sinter_with c f [] uu = [];
comp_sinter_with c f uv [] = [];

map_option :: forall a b. (a -> b) -> Maybe a -> Maybe b;
map_option f Nothing = Nothing;
map_option f (Just x2) = Just (f x2);

map_filter :: forall a b. (a -> Maybe b) -> [a] -> [b];
map_filter f [] = [];
map_filter f (x : xs) = (case f x of {
                          Nothing -> map_filter f xs;
                          Just y -> y : map_filter f xs;
                        });

rbt_comp_inter_with_key ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_comp_inter_with_key c f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> rbtreeify
            (map_filter
              (\ (k, v) ->
                map_option (\ w -> (k, f k v w)) (rbt_comp_lookup c t2 k))
              (entries t1));
    GT -> rbtreeify
            (map_filter
              (\ (k, v) ->
                map_option (\ w -> (k, f k w v)) (rbt_comp_lookup c t1 k))
              (entries t2));
    EQ -> rbtreeify (comp_sinter_with c f (entries t1) (entries t2));
  });

meet ::
  forall a b.
    (Ccompare a) => (a -> b -> b -> b) ->
                      Mapping_rbt a b -> Mapping_rbt a b -> Mapping_rbt a b;
meet xc xd xe =
  Mapping_RBTa
    (rbt_comp_inter_with_key (the ccompare) xc (impl_ofb xd) (impl_ofb xe));

filterc :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Set_dlist a;
filterc xb xc = Abs_dlist (filter xb (list_of_dlist xc));

inf_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
inf_set (RBT_set rbt1) (Set_Monad xs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set Set_Monad: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (Set_Monad xs));
    Just _ -> RBT_set (inter_list rbt1 xs);
  });
inf_set (RBT_set rbt) (DList_set dxs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set DList_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "inter RBT_set DList_set: ceq = None"
            (\ _ -> inf_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (inter_list rbt (list_of_dlist dxs));
      });
  });
inf_set (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set RBT_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (RBT_set rbt2));
    Just _ -> RBT_set (meet (\ _ _ -> id) rbt1 rbt2);
  });
inf_set (DList_set dxs1) (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set Set_Monad: ceq = None"
        (\ _ -> inf_set (DList_set dxs1) (Set_Monad xs));
    Just eq -> DList_set (filterc (list_member eq xs) dxs1);
  });
inf_set (DList_set dxs1) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set DList_set: ceq = None"
        (\ _ -> inf_set (DList_set dxs1) (DList_set dxs2));
    Just _ -> DList_set (filterc (memberc dxs2) dxs1);
  });
inf_set (DList_set dxs) (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set RBT_set: ccompare = None"
        (\ _ -> inf_set (DList_set dxs) (RBT_set rbt));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "inter DList_set RBT_set: ceq = None"
            (\ _ -> inf_set (DList_set dxs) (RBT_set rbt));
        Just _ -> RBT_set (inter_list rbt (list_of_dlist dxs));
      });
  });
inf_set (Set_Monad xs1) (Set_Monad xs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad Set_Monad: ceq = None"
        (\ _ -> inf_set (Set_Monad xs1) (Set_Monad xs2));
    Just eq -> Set_Monad (filter (list_member eq xs2) xs1);
  });
inf_set (Set_Monad xs) (DList_set dxs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad DList_set: ceq = None"
        (\ _ -> inf_set (Set_Monad xs) (DList_set dxs2));
    Just eq -> DList_set (filterc (list_member eq xs) dxs2);
  });
inf_set (Set_Monad xs) (RBT_set rbt1) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad RBT_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (Set_Monad xs));
    Just _ -> RBT_set (inter_list rbt1 xs);
  });
inf_set (Complement ba) (Complement b) = Complement (sup_set ba b);
inf_set g (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set2: ccompare = None" (\ _ -> inf_set g (RBT_set rbt2));
    Just _ -> RBT_set (filterd ((\ x -> member x g) . fst) rbt2);
  });
inf_set (RBT_set rbt1) g =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set1: ccompare = None" (\ _ -> inf_set (RBT_set rbt1) g);
    Just _ -> RBT_set (filterd ((\ x -> member x g) . fst) rbt1);
  });
inf_set h (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set2: ceq = None" (\ _ -> inf_set h (DList_set dxs2));
    Just _ -> DList_set (filterc (\ x -> member x h) dxs2);
  });
inf_set (DList_set dxs1) h =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set1: ceq = None" (\ _ -> inf_set (DList_set dxs1) h);
    Just _ -> DList_set (filterc (\ x -> member x h) dxs1);
  });
inf_set i (Set_Monad xs) = Set_Monad (filter (\ x -> member x i) xs);
inf_set (Set_Monad xs) i = Set_Monad (filter (\ x -> member x i) xs);
inf_set j (Collect_set a) = Collect_set (\ x -> a x && member x j);
inf_set (Collect_set a) j = Collect_set (\ x -> a x && member x j);

sup_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
sup_set ba (Complement b) = Complement (inf_set (uminus_set ba) b);
sup_set (Complement ba) b = Complement (inf_set ba (uminus_set b));
sup_set b (Collect_set a) = Collect_set (\ x -> a x || member x b);
sup_set (Collect_set a) b = Collect_set (\ x -> a x || member x b);
sup_set (Set_Monad xs) (Set_Monad ys) = Set_Monad (xs ++ ys);
sup_set (DList_set dxs1) (Set_Monad ws) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set Set_Monad: ceq = None"
        (\ _ -> sup_set (DList_set dxs1) (Set_Monad ws));
    Just _ -> DList_set (fold insertc ws dxs1);
  });
sup_set (Set_Monad ws) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union Set_Monad DList_set: ceq = None"
        (\ _ -> sup_set (Set_Monad ws) (DList_set dxs2));
    Just _ -> DList_set (fold insertc ws dxs2);
  });
sup_set (RBT_set rbt1) (Set_Monad zs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set Set_Monad: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt1) (Set_Monad zs));
    Just _ -> RBT_set (fold (\ k -> inserte k ()) zs rbt1);
  });
sup_set (Set_Monad zs) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union Set_Monad RBT_set: ccompare = None"
        (\ _ -> sup_set (Set_Monad zs) (RBT_set rbt2));
    Just _ -> RBT_set (fold (\ k -> inserte k ()) zs rbt2);
  });
sup_set (DList_set dxs1) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set DList_set: ceq = None"
        (\ _ -> sup_set (DList_set dxs1) (DList_set dxs2));
    Just _ -> DList_set (uniona dxs1 dxs2);
  });
sup_set (DList_set dxs) (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set RBT_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "union DList_set RBT_set: ceq = None"
            (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (foldc (\ k -> inserte k ()) dxs rbt);
      });
  });
sup_set (RBT_set rbt) (DList_set dxs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set DList_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "union RBT_set DList_set: ceq = None"
            (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (foldc (\ k -> inserte k ()) dxs rbt);
      });
  });
sup_set (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set RBT_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt1) (RBT_set rbt2));
    Just _ -> RBT_set (join (\ _ _ -> id) rbt1 rbt2);
  });

instance (Ceq a, Ccompare a) => Inf (Set a) where {
  inf = inf_set;
};

instance (Ceq a, Ccompare a) => Sup (Set a) where {
  sup = sup_set;
};

less_set :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
less_set a b = less_eq_set a b && not (less_eq_set b a);

instance (Cenum a, Ceq a, Ccompare a) => Ord (Set a) where {
  less_eq = less_eq_set;
  less = less_set;
};

instance (Cenum a, Ceq a, Ccompare a) => Quasi_order (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Weak_order (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Preorder (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Order (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Quasi_order_sup (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Quasi_semilattice_sup (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Semilattice_sup (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Semilattice_inf (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Lattice (Set a) where {
};

list_all2_fusion ::
  forall a b c d.
    (a -> b -> Bool) -> Generator a c -> Generator b d -> c -> d -> Bool;
list_all2_fusion p g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 &&
           (case next g1 s1 of {
             (x, s1a) ->
               (case next g2 s2 of {
                 (y, s2a) -> p x y && list_all2_fusion p g1 g2 s1a s2a;
               });
           })
    else not (has_next g2 s2));

set_eq :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
set_eq (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_eq RBT_set RBT_set: ccompare = None"
        (\ _ -> set_eq (RBT_set rbt1) (RBT_set rbt2));
    Just c ->
      (case ceq of {
        Nothing ->
          list_all2_fusion (\ x y -> equal_order (c x y) Eqa) rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
        Just eq ->
          list_all2_fusion eq rbt_keys_generator rbt_keys_generator (init rbt1)
            (init rbt2);
      });
  });
set_eq (Complement a) (Complement b) = set_eq a b;
set_eq a b = less_eq_set a b && less_eq_set b a;

ceq_set ::
  forall a. (Cenum a, Ceq a, Ccompare a) => Maybe (Set a -> Set a -> Bool);
ceq_set = (case (ceq :: Maybe (a -> a -> Bool)) of {
            Nothing -> Nothing;
            Just _ -> Just set_eq;
          });

instance (Cenum a, Ceq a, Ccompare a) => Ceq (Set a) where {
  ceq = ceq_set;
};

set_impl_set :: forall a. Phantom (Set a) Set_impla;
set_impl_set = Phantom Set_Choose;

instance Set_impl (Set a) where {
  set_impl = set_impl_set;
};

of_phantom :: forall a b. Phantom a b -> b;
of_phantom (Phantom x) = x;

emptye :: forall a b. (Ccompare a) => Mapping_rbt a b;
emptye = Mapping_RBTa Empty;

emptyc :: forall a. (Ceq a) => Set_dlist a;
emptyc = Abs_dlist [];

set_empty_choose :: forall a. (Ceq a, Ccompare a) => Set a;
set_empty_choose = (case (ccompare :: Maybe (a -> a -> Ordera)) of {
                     Nothing -> (case (ceq :: Maybe (a -> a -> Bool)) of {
                                  Nothing -> Set_Monad [];
                                  Just _ -> DList_set emptyc;
                                });
                     Just _ -> RBT_set emptye;
                   });

set_empty :: forall a. (Ceq a, Ccompare a) => Set_impla -> Set a;
set_empty Set_Choose = set_empty_choose;
set_empty Set_Monada = Set_Monad [];
set_empty Set_RBT = RBT_set emptye;
set_empty Set_DList = DList_set emptyc;
set_empty Set_Collect = Collect_set (\ _ -> False);

fun_upda :: forall a b. (a -> a -> Bool) -> (a -> b) -> a -> b -> a -> b;
fun_upda equal f aa b a = (if equal aa a then b else f a);

balance_right :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance_right a k x (Branch R b s y c) = Branch R a k x (Branch B b s y c);
balance_right (Branch B a k x b) s y Empty =
  balance (Branch R a k x b) s y Empty;
balance_right (Branch B a k x b) s y (Branch B va vb vc vd) =
  balance (Branch R a k x b) s y (Branch B va vb vc vd);
balance_right (Branch R a k x (Branch B b s y c)) t z Empty =
  Branch R (balance (paint R a) k x b) s y (Branch B c t z Empty);
balance_right (Branch R a k x (Branch B b s y c)) t z (Branch B va vb vc vd) =
  Branch R (balance (paint R a) k x b) s y
    (Branch B c t z (Branch B va vb vc vd));
balance_right Empty k x Empty = Empty;
balance_right (Branch R va vb vc Empty) k x Empty = Empty;
balance_right (Branch R va vb vc (Branch R ve vf vg vh)) k x Empty = Empty;
balance_right Empty k x (Branch B va vb vc vd) = Empty;
balance_right (Branch R ve vf vg Empty) k x (Branch B va vb vc vd) = Empty;
balance_right (Branch R ve vf vg (Branch R vi vj vk vl)) k x
  (Branch B va vb vc vd) = Empty;

balance_left :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance_left (Branch R a k x b) s y c = Branch R (Branch B a k x b) s y c;
balance_left Empty k x (Branch B a s y b) =
  balance Empty k x (Branch R a s y b);
balance_left (Branch B va vb vc vd) k x (Branch B a s y b) =
  balance (Branch B va vb vc vd) k x (Branch R a s y b);
balance_left Empty k x (Branch R (Branch B a s y b) t z c) =
  Branch R (Branch B Empty k x a) s y (balance b t z (paint R c));
balance_left (Branch B va vb vc vd) k x (Branch R (Branch B a s y b) t z c) =
  Branch R (Branch B (Branch B va vb vc vd) k x a) s y
    (balance b t z (paint R c));
balance_left Empty k x Empty = Empty;
balance_left Empty k x (Branch R Empty vb vc vd) = Empty;
balance_left Empty k x (Branch R (Branch R ve vf vg vh) vb vc vd) = Empty;
balance_left (Branch B va vb vc vd) k x Empty = Empty;
balance_left (Branch B va vb vc vd) k x (Branch R Empty vf vg vh) = Empty;
balance_left (Branch B va vb vc vd) k x
  (Branch R (Branch R vi vj vk vl) vf vg vh) = Empty;

combine :: forall a b. Rbta a b -> Rbta a b -> Rbta a b;
combine Empty x = x;
combine (Branch v va vb vc vd) Empty = Branch v va vb vc vd;
combine (Branch R a k x b) (Branch R c s y d) =
  (case combine b c of {
    Empty -> Branch R a k x (Branch R Empty s y d);
    Branch R b2 t z c2 -> Branch R (Branch R a k x b2) t z (Branch R c2 s y d);
    Branch B b2 t z c2 -> Branch R a k x (Branch R (Branch B b2 t z c2) s y d);
  });
combine (Branch B a k x b) (Branch B c s y d) =
  (case combine b c of {
    Empty -> balance_left a k x (Branch B Empty s y d);
    Branch R b2 t z c2 -> Branch R (Branch B a k x b2) t z (Branch B c2 s y d);
    Branch B b2 t z c2 ->
      balance_left a k x (Branch B (Branch B b2 t z c2) s y d);
  });
combine (Branch B va vb vc vd) (Branch R b k x c) =
  Branch R (combine (Branch B va vb vc vd) b) k x c;
combine (Branch R a k x b) (Branch B va vb vc vd) =
  Branch R a k x (combine b (Branch B va vb vc vd));

rbt_comp_del :: forall a b. (a -> a -> Ordera) -> a -> Rbta a b -> Rbta a b;
rbt_comp_del c x Empty = Empty;
rbt_comp_del c x (Branch uu a y s b) =
  (case c x y of {
    Eqa -> combine a b;
    Lt -> rbt_comp_del_from_left c x a y s b;
    Gt -> rbt_comp_del_from_right c x a y s b;
  });

rbt_comp_del_from_left ::
  forall a b.
    (a -> a -> Ordera) -> a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_del_from_left c x (Branch B lt z v rt) y s b =
  balance_left (rbt_comp_del c x (Branch B lt z v rt)) y s b;
rbt_comp_del_from_left c x Empty y s b =
  Branch R (rbt_comp_del c x Empty) y s b;
rbt_comp_del_from_left c x (Branch R va vb vc vd) y s b =
  Branch R (rbt_comp_del c x (Branch R va vb vc vd)) y s b;

rbt_comp_del_from_right ::
  forall a b.
    (a -> a -> Ordera) -> a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_del_from_right c x a y s (Branch B lt z v rt) =
  balance_right a y s (rbt_comp_del c x (Branch B lt z v rt));
rbt_comp_del_from_right c x a y s Empty =
  Branch R a y s (rbt_comp_del c x Empty);
rbt_comp_del_from_right c x a y s (Branch R va vb vc vd) =
  Branch R a y s (rbt_comp_del c x (Branch R va vb vc vd));

rbt_comp_delete :: forall a b. (a -> a -> Ordera) -> a -> Rbta a b -> Rbta a b;
rbt_comp_delete c k t = paint B (rbt_comp_del c k t);

deletec :: forall a b. (Ccompare a) => a -> Mapping_rbt a b -> Mapping_rbt a b;
deletec xb xc = Mapping_RBTa (rbt_comp_delete (the ccompare) xb (impl_ofb xc));

list_remove1 :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
list_remove1 equal x (y : xs) =
  (if equal x y then xs else y : list_remove1 equal x xs);
list_remove1 equal x [] = [];

removea :: forall a. (Ceq a) => a -> Set_dlist a -> Set_dlist a;
removea xb xc = Abs_dlist (list_remove1 (the ceq) xb (list_of_dlist xc));

inserta :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Set a;
inserta xa (Complement x) = Complement (remove xa x);
inserta x (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert RBT_set: ccompare = None" (\ _ -> inserta x (RBT_set rbt));
    Just _ -> RBT_set (inserte x () rbt);
  });
inserta x (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert DList_set: ceq = None" (\ _ -> inserta x (DList_set dxs));
    Just _ -> DList_set (insertc x dxs);
  });
inserta x (Set_Monad xs) = Set_Monad (x : xs);
inserta x (Collect_set a) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert Collect_set: ceq = None" (\ _ -> inserta x (Collect_set a));
    Just eq -> Collect_set (fun_upda eq a x True);
  });

remove :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Set a;
remove x (Complement a) = Complement (inserta x a);
remove x (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "remove RBT_set: ccompare = None" (\ _ -> remove x (RBT_set rbt));
    Just _ -> RBT_set (deletec x rbt);
  });
remove x (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "remove DList_set: ceq = None" (\ _ -> remove x (DList_set dxs));
    Just _ -> DList_set (removea x dxs);
  });
remove x (Collect_set a) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "remove Collect: ceq = None"
        (\ _ -> remove x (Collect_set a));
    Just eq -> Collect_set (fun_upda eq a x False);
  });

foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a;
foldl f a [] = a;
foldl f a (x : xs) = foldl f (f a x) xs;

set_aux :: forall a. (Ceq a, Ccompare a) => Set_impla -> [a] -> Set a;
set_aux Set_Monada = Set_Monad;
set_aux Set_Choose =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing -> (case (ceq :: Maybe (a -> a -> Bool)) of {
                 Nothing -> Set_Monad;
                 Just _ -> foldl (\ s x -> inserta x s) (DList_set emptyc);
               });
    Just _ -> foldl (\ s x -> inserta x s) (RBT_set emptye);
  });
set_aux impl = foldl (\ s x -> inserta x s) (set_empty impl);

set :: forall a. (Ceq a, Ccompare a, Set_impl a) => [a] -> Set a;
set xs = set_aux (of_phantom (set_impl :: Phantom a Set_impla)) xs;

subseqs :: forall a. [a] -> [[a]];
subseqs [] = [[]];
subseqs (x : xs) = let {
                     xss = subseqs xs;
                   } in map (\ a -> x : a) xss ++ xss;

cEnum_set ::
  forall a.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Maybe ([Set a],
                             ((Set a -> Bool) -> Bool,
                               (Set a -> Bool) -> Bool));
cEnum_set =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (_, _)) ->
      Just (map set (subseqs enum_a),
             ((\ p -> all p (map set (subseqs enum_a))),
               (\ p -> any p (map set (subseqs enum_a)))));
  });

instance (Cenum a, Ceq a, Ccompare a, Set_impl a) => Cenum (Set a) where {
  cEnum = cEnum_set;
};

finite_UNIV_set :: forall a. (Finite_UNIV a) => Phantom (Set a) Bool;
finite_UNIV_set = Phantom (of_phantom (finite_UNIV :: Phantom a Bool));

instance (Finite_UNIV a) => Finite_UNIV (Set a) where {
  finite_UNIV = finite_UNIV_set;
};

set_less_eq_aux_Compl_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
set_less_eq_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then (case next g1 s1 of {
                  (x, s1a) ->
                    (case next g2 s2 of {
                      (y, s2a) ->
                        (if less x y
                          then proper_interval ao (Just x) ||
                                 set_less_eq_aux_Compl_fusion less
                                   proper_interval g1 g2 (Just x) s1a s2
                          else (if less y x
                                 then proper_interval ao (Just y) ||
set_less_eq_aux_Compl_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                 else proper_interval ao (Just y)));
                    });
                })
           else True)
    else True);

compl_set_less_eq_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
compl_set_less_eq_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then (case next g1 s1 of {
           (x, s1a) ->
             (if has_next g2 s2
               then (case next g2 s2 of {
                      (y, s2a) ->
                        (if less x y
                          then not (proper_interval ao (Just x)) &&
                                 compl_set_less_eq_aux_fusion less
                                   proper_interval g1 g2 (Just x) s1a s2
                          else (if less y x
                                 then not (proper_interval ao (Just y)) &&
compl_set_less_eq_aux_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                 else not (proper_interval ao (Just y))));
                    })
               else not (proper_interval ao (Just x)) &&
                      compl_set_less_eq_aux_fusion less proper_interval g1 g2
                        (Just x) s1a s2);
         })
    else (if has_next g2 s2
           then (case next g2 s2 of {
                  (y, s2a) ->
                    not (proper_interval ao (Just y)) &&
                      compl_set_less_eq_aux_fusion less proper_interval g1 g2
                        (Just y) s1 s2a;
                })
           else not (proper_interval ao Nothing)));

set_less_eq_aux_Compl ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
set_less_eq_aux_Compl less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           set_less_eq_aux_Compl less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  set_less_eq_aux_Compl less proper_interval (Just y) (x : xs)
                    ys
           else proper_interval ao (Just y)));
set_less_eq_aux_Compl less proper_interval ao xs [] = True;
set_less_eq_aux_Compl less proper_interval ao [] ys = True;

compl_set_less_eq_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
compl_set_less_eq_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           compl_set_less_eq_aux less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  compl_set_less_eq_aux less proper_interval (Just y) (x : xs)
                    ys
           else not (proper_interval ao (Just y))));
compl_set_less_eq_aux less proper_interval ao (x : xs) [] =
  not (proper_interval ao (Just x)) &&
    compl_set_less_eq_aux less proper_interval (Just x) xs [];
compl_set_less_eq_aux less proper_interval ao [] (y : ys) =
  not (proper_interval ao (Just y)) &&
    compl_set_less_eq_aux less proper_interval (Just y) [] ys;
compl_set_less_eq_aux less proper_interval ao [] [] =
  not (proper_interval ao Nothing);

lexord_eq_fusion ::
  forall a b c.
    (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
lexord_eq_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 &&
           (case next g1 s1 of {
             (x, s1a) ->
               (case next g2 s2 of {
                 (y, s2a) ->
                   less x y ||
                     not (less y x) && lexord_eq_fusion less g1 g2 s1a s2a;
               });
           })
    else True);

remdups_sorted :: forall a. (a -> a -> Bool) -> [a] -> [a];
remdups_sorted less (x : y : xs) =
  (if less x y then x : remdups_sorted less (y : xs)
    else remdups_sorted less (y : xs));
remdups_sorted less [x] = [x];
remdups_sorted less [] = [];

quicksort_acc :: forall a. (a -> a -> Bool) -> [a] -> [a] -> [a];
quicksort_acc less ac (x : v : va) = quicksort_part less ac x [] [] [] (v : va);
quicksort_acc less ac [x] = x : ac;
quicksort_acc less ac [] = ac;

quicksort_part ::
  forall a. (a -> a -> Bool) -> [a] -> a -> [a] -> [a] -> [a] -> [a] -> [a];
quicksort_part less ac x lts eqs gts (z : zs) =
  (if less x z then quicksort_part less ac x lts eqs (z : gts) zs
    else (if less z x then quicksort_part less ac x (z : lts) eqs gts zs
           else quicksort_part less ac x lts (z : eqs) gts zs));
quicksort_part less ac x lts eqs gts [] =
  quicksort_acc less (eqs ++ x : quicksort_acc less ac gts) lts;

quicksort :: forall a. (a -> a -> Bool) -> [a] -> [a];
quicksort less = quicksort_acc less [];

gen_keys :: forall a b. [(a, Rbta a b)] -> Rbta a b -> [a];
gen_keys kts (Branch c l k v r) = gen_keys ((k, r) : kts) l;
gen_keys ((k, t) : kts) Empty = k : gen_keys kts t;
gen_keys [] Empty = [];

keys :: forall a b. Rbta a b -> [a];
keys = gen_keys [];

keysa :: forall a. (Ccompare a) => Mapping_rbt a () -> [a];
keysa xa = keys (impl_ofb xa);

csorted_list_of_set :: forall a. (Ceq a, Ccompare a) => Set a -> [a];
csorted_list_of_set (Set_Monad xs) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set Set_Monad: ccompare = None"
        (\ _ -> csorted_list_of_set (Set_Monad xs));
    Just c -> remdups_sorted (lt_of_comp c) (quicksort (lt_of_comp c) xs);
  });
csorted_list_of_set (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set DList_set: ceq = None"
        (\ _ -> csorted_list_of_set (DList_set dxs));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "csorted_list_of_set DList_set: ccompare = None"
            (\ _ -> csorted_list_of_set (DList_set dxs));
        Just c -> quicksort (lt_of_comp c) (list_of_dlist dxs);
      });
  });
csorted_list_of_set (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set RBT_set: ccompare = None"
        (\ _ -> csorted_list_of_set (RBT_set rbt));
    Just _ -> keysa rbt;
  });

bot_set :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set a;
bot_set = set_empty (of_phantom (set_impl :: Phantom a Set_impla));

top_set :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set a;
top_set = uminus_set bot_set;

le_of_comp :: forall a. (a -> a -> Ordera) -> a -> a -> Bool;
le_of_comp acomp x y = (case acomp x y of {
                         Eqa -> True;
                         Lt -> True;
                         Gt -> False;
                       });

lexordp_eq :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
lexordp_eq less (x : xs) (y : ys) =
  less x y || not (less y x) && lexordp_eq less xs ys;
lexordp_eq less (x : xs) [] = False;
lexordp_eq less xs [] = null xs;
lexordp_eq less [] ys = True;

finite :: forall a. (Finite_UNIV a, Ceq a, Ccompare a) => Set a -> Bool;
finite (Collect_set p) =
  of_phantom (finite_UNIV :: Phantom a Bool) ||
    (error :: forall a. String -> (() -> a) -> a) "finite Collect_set"
      (\ _ -> finite (Collect_set p));
finite (Set_Monad xs) = True;
finite (Complement a) =
  (if of_phantom (finite_UNIV :: Phantom a Bool) then True
    else (if finite a then False
           else (error :: forall a. String -> (() -> a) -> a)
                  "finite Complement: infinite set"
                  (\ _ -> finite (Complement a))));
finite (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "finite RBT_set: ccompare = None" (\ _ -> finite (RBT_set rbt));
    Just _ -> True;
  });
finite (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "finite DList_set: ceq = None" (\ _ -> finite (DList_set dxs));
    Just _ -> True;
  });

set_less_aux_Compl_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
set_less_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then (case next g1 s1 of {
           (x, s1a) ->
             (if has_next g2 s2
               then (case next g2 s2 of {
                      (y, s2a) ->
                        (if less x y
                          then proper_interval ao (Just x) ||
                                 set_less_aux_Compl_fusion less proper_interval
                                   g1 g2 (Just x) s1a s2
                          else (if less y x
                                 then proper_interval ao (Just y) ||
set_less_aux_Compl_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                 else proper_interval ao (Just y)));
                    })
               else proper_interval ao (Just x) ||
                      set_less_aux_Compl_fusion less proper_interval g1 g2
                        (Just x) s1a s2);
         })
    else (if has_next g2 s2
           then (case next g2 s2 of {
                  (y, s2a) ->
                    proper_interval ao (Just y) ||
                      set_less_aux_Compl_fusion less proper_interval g1 g2
                        (Just y) s1 s2a;
                })
           else proper_interval ao Nothing));

compl_set_less_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
compl_set_less_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 &&
    has_next g2 s2 &&
      (case next g1 s1 of {
        (x, s1a) ->
          (case next g2 s2 of {
            (y, s2a) ->
              (if less x y
                then not (proper_interval ao (Just x)) &&
                       compl_set_less_aux_fusion less proper_interval g1 g2
                         (Just x) s1a s2
                else (if less y x
                       then not (proper_interval ao (Just y)) &&
                              compl_set_less_aux_fusion less proper_interval g1
                                g2 (Just y) s1 s2a
                       else not (proper_interval ao (Just y))));
          });
      });

set_less_aux_Compl ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
set_less_aux_Compl less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           set_less_aux_Compl less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  set_less_aux_Compl less proper_interval (Just y) (x : xs) ys
           else proper_interval ao (Just y)));
set_less_aux_Compl less proper_interval ao (x : xs) [] =
  proper_interval ao (Just x) ||
    set_less_aux_Compl less proper_interval (Just x) xs [];
set_less_aux_Compl less proper_interval ao [] (y : ys) =
  proper_interval ao (Just y) ||
    set_less_aux_Compl less proper_interval (Just y) [] ys;
set_less_aux_Compl less proper_interval ao [] [] = proper_interval ao Nothing;

compl_set_less_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
compl_set_less_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           compl_set_less_aux less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  compl_set_less_aux less proper_interval (Just y) (x : xs) ys
           else not (proper_interval ao (Just y))));
compl_set_less_aux less proper_interval ao xs [] = False;
compl_set_less_aux less proper_interval ao [] ys = False;

lexord_fusion ::
  forall a b c.
    (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
lexord_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then (case next g1 s1 of {
                  (x, s1a) ->
                    (case next g2 s2 of {
                      (y, s2a) ->
                        less x y ||
                          not (less y x) && lexord_fusion less g1 g2 s1a s2a;
                    });
                })
           else False)
    else has_next g2 s2);

lexordp :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
lexordp less (x : xs) (y : ys) =
  less x y || not (less y x) && lexordp less xs ys;
lexordp less xs [] = False;
lexordp less [] ys = not (null ys);

comp_of_ords ::
  forall a. (a -> a -> Bool) -> (a -> a -> Bool) -> a -> a -> Ordera;
comp_of_ords le lt x y = (if lt x y then Lt else (if le x y then Eqa else Gt));

ccompare_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Maybe (Set a -> Set a -> Ordera);
ccompare_set = (case (ccompare :: Maybe (a -> a -> Ordera)) of {
                 Nothing -> Nothing;
                 Just _ -> Just (comp_of_ords cless_eq_set cless_set);
               });

cless_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Set a -> Set a -> Bool;
cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ -> cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        compl_set_less_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set RBT_set (Complement RBT_set): ccompare = None"
        (\ _ -> cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)));
    Just c ->
      (if (finite :: Set a -> Bool) (top_set :: Set a)
        then set_less_aux_Compl_fusion (lt_of_comp c) cproper_interval
               rbt_keys_generator rbt_keys_generator Nothing (init rbt1)
               (init rbt2)
        else True);
  });
cless_set (RBT_set rbta) (RBT_set rbt) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set RBT_set RBT_set: ccompare = None"
        (\ _ -> cless_set (RBT_set rbta) (RBT_set rbt));
    Just c ->
      lexord_fusion (\ x y -> lt_of_comp c y x) rbt_keys_generator
        rbt_keys_generator (init rbta) (init rbt);
  });
cless_set (Complement a) (Complement b) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement Complement: ccompare = None"
        (\ _ -> cless_set (Complement a) (Complement b));
    Just _ -> lt_of_comp (the ccompare_set) b a;
  });
cless_set (Complement a) b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement1: ccompare = None"
        (\ _ -> cless_set (Complement a) b);
    Just c ->
      (if finite a && finite b
        then (finite :: Set a -> Bool) (top_set :: Set a) &&
               compl_set_less_aux (lt_of_comp c) cproper_interval Nothing
                 (csorted_list_of_set a) (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set Complement1: infinite set"
               (\ _ -> cless_set (Complement a) b));
  });
cless_set a (Complement b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement2: ccompare = None"
        (\ _ -> cless_set a (Complement b));
    Just c ->
      (if finite a && finite b
        then (if (finite :: Set a -> Bool) (top_set :: Set a)
               then set_less_aux_Compl (lt_of_comp c) cproper_interval Nothing
                      (csorted_list_of_set a) (csorted_list_of_set b)
               else True)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set Complement2: infinite set"
               (\ _ -> cless_set a (Complement b)));
  });
cless_set a b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "cless_set: ccompare = None"
        (\ _ -> cless_set a b);
    Just c ->
      (if finite a && finite b
        then lexordp (\ x y -> lt_of_comp c y x) (csorted_list_of_set a)
               (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set: infinite set" (\ _ -> cless_set a b));
  });

cless_eq_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Set a -> Set a -> Bool;
cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ -> cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        compl_set_less_eq_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set RBT_set (Complement RBT_set): ccompare = None"
        (\ _ -> cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)));
    Just c ->
      (if (finite :: Set a -> Bool) (top_set :: Set a)
        then set_less_eq_aux_Compl_fusion (lt_of_comp c) cproper_interval
               rbt_keys_generator rbt_keys_generator Nothing (init rbt1)
               (init rbt2)
        else True);
  });
cless_eq_set (RBT_set rbta) (RBT_set rbt) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set RBT_set RBT_set: ccompare = None"
        (\ _ -> cless_eq_set (RBT_set rbta) (RBT_set rbt));
    Just c ->
      lexord_eq_fusion (\ x y -> lt_of_comp c y x) rbt_keys_generator
        rbt_keys_generator (init rbta) (init rbt);
  });
cless_eq_set (Complement a) (Complement b) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement Complement: ccompare = None"
        (\ _ -> le_of_comp (the ccompare_set) (Complement a) (Complement b));
    Just _ -> cless_eq_set b a;
  });
cless_eq_set (Complement a) b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement1: ccompare = None"
        (\ _ -> cless_eq_set (Complement a) b);
    Just c ->
      (if finite a && finite b
        then (finite :: Set a -> Bool) (top_set :: Set a) &&
               compl_set_less_eq_aux (lt_of_comp c) cproper_interval Nothing
                 (csorted_list_of_set a) (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set Complement1: infinite set"
               (\ _ -> cless_eq_set (Complement a) b));
  });
cless_eq_set a (Complement b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement2: ccompare = None"
        (\ _ -> cless_eq_set a (Complement b));
    Just c ->
      (if finite a && finite b
        then (if (finite :: Set a -> Bool) (top_set :: Set a)
               then set_less_eq_aux_Compl (lt_of_comp c) cproper_interval
                      Nothing (csorted_list_of_set a) (csorted_list_of_set b)
               else True)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set Complement2: infinite set"
               (\ _ -> cless_eq_set a (Complement b)));
  });
cless_eq_set a b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set: ccompare = None" (\ _ -> cless_eq_set a b);
    Just c ->
      (if finite a && finite b
        then lexordp_eq (\ x y -> lt_of_comp c y x) (csorted_list_of_set a)
               (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set: infinite set" (\ _ -> cless_eq_set a b));
  });

instance (Finite_UNIV a, Ceq a, Cproper_interval a,
           Set_impl a) => Ccompare (Set a) where {
  ccompare = ccompare_set;
};

fold_fusion :: forall a b c. Generator a b -> (a -> c -> c) -> b -> c -> c;
fold_fusion g f s b =
  (if has_next g s then (case next g s of {
                          (x, sa) -> fold_fusion g f sa (f x b);
                        })
    else b);

length_last_fusion :: forall a b. Generator a b -> b -> (Nat, a);
length_last_fusion g s =
  (if has_next g s
    then (case next g s of {
           (x, sa) ->
             fold_fusion g (\ xa (n, _) -> (plus_nat n one_nat, xa)) sa
               (one_nat, x);
         })
    else (zero_nat, error "undefined"));

gen_length_fusion :: forall a b. Generator a b -> Nat -> b -> Nat;
gen_length_fusion g n s =
  (if has_next g s then gen_length_fusion g (suc n) (snd (next g s)) else n);

length_fusion :: forall a b. Generator a b -> b -> Nat;
length_fusion g = gen_length_fusion g zero_nat;

card_UNIV :: forall a. (Card_UNIV a) => Phantom a Nat;
card_UNIV = card_UNIVa;

proper_interval_set_Compl_aux_fusion ::
  forall a b c.
    (Card_UNIV a) => (a -> a -> Bool) ->
                       (Maybe a -> Maybe a -> Bool) ->
                         Generator a b ->
                           Generator a c -> Maybe a -> Nat -> b -> c -> Bool;
proper_interval_set_Compl_aux_fusion less proper_interval g1 g2 ao n s1 s2 =
  (if has_next g1 s1
    then (case next g1 s1 of {
           (x, s1a) ->
             (if has_next g2 s2
               then (case next g2 s2 of {
                      (y, s2a) ->
                        (if less x y
                          then proper_interval ao (Just x) ||
                                 proper_interval_set_Compl_aux_fusion less
                                   proper_interval g1 g2 (Just x)
                                   (plus_nat n one_nat) s1a s2
                          else (if less y x
                                 then proper_interval ao (Just y) ||
proper_interval_set_Compl_aux_fusion less proper_interval g1 g2 (Just y)
  (plus_nat n one_nat) s1 s2a
                                 else proper_interval ao (Just x) &&
let {
  m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
} in not (equal_nat (minus_nat m (length_fusion g2 s2a))
           (nat_of_integer (2 :: Integer))) ||
       not (equal_nat (minus_nat m (length_fusion g1 s1a))
             (nat_of_integer (2 :: Integer)))));
                    })
               else let {
                      m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                    } in (case length_last_fusion g1 s1 of {
                           (len_x, xa) ->
                             not (equal_nat m len_x) &&
                               (if equal_nat m (plus_nat len_x one_nat)
                                 then not (proper_interval (Just xa) Nothing)
                                 else True);
                         }));
         })
    else (if has_next g2 s2
           then (case next g2 s2 of {
                  (_, _) ->
                    let {
                      m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                    } in (case length_last_fusion g2 s2 of {
                           (len_y, y) ->
                             not (equal_nat m len_y) &&
                               (if equal_nat m (plus_nat len_y one_nat)
                                 then not (proper_interval (Just y) Nothing)
                                 else True);
                         });
                })
           else less_nat (plus_nat n one_nat)
                  (of_phantom (card_UNIV :: Phantom a Nat))));

proper_interval_Compl_set_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
proper_interval_Compl_set_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 &&
    has_next g2 s2 &&
      (case next g1 s1 of {
        (x, s1a) ->
          (case next g2 s2 of {
            (y, s2a) ->
              (if less x y
                then not (proper_interval ao (Just x)) &&
                       proper_interval_Compl_set_aux_fusion less proper_interval
                         g1 g2 (Just x) s1a s2
                else (if less y x
                       then not (proper_interval ao (Just y)) &&
                              proper_interval_Compl_set_aux_fusion less
                                proper_interval g1 g2 (Just y) s1 s2a
                       else not (proper_interval ao (Just x)) &&
                              (has_next g2 s2a || has_next g1 s1a)));
          });
      });

exhaustive_above_fusion ::
  forall a b. (Maybe a -> Maybe a -> Bool) -> Generator a b -> a -> b -> Bool;
exhaustive_above_fusion proper_interval g y s =
  (if has_next g s
    then (case next g s of {
           (x, sa) ->
             not (proper_interval (Just y) (Just x)) &&
               exhaustive_above_fusion proper_interval g x sa;
         })
    else not (proper_interval (Just y) Nothing));

proper_interval_set_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> b -> c -> Bool;
proper_interval_set_aux_fusion less proper_interval g1 g2 s1 s2 =
  has_next g2 s2 &&
    (case next g2 s2 of {
      (y, s2a) ->
        (if has_next g1 s1
          then (case next g1 s1 of {
                 (x, s1a) ->
                   (if less x y then False
                     else (if less y x
                            then proper_interval (Just y) (Just x) ||
                                   (has_next g2 s2a ||
                                     not (exhaustive_above_fusion
   proper_interval g1 x s1a))
                            else proper_interval_set_aux_fusion less
                                   proper_interval g1 g2 s1a s2a));
               })
          else has_next g2 s2a || proper_interval (Just y) Nothing);
    });

length_last :: forall a. [a] -> (Nat, a);
length_last (x : xs) =
  fold (\ xa (n, _) -> (plus_nat n one_nat, xa)) xs (one_nat, x);
length_last [] = (zero_nat, error "undefined");

proper_interval_set_Compl_aux ::
  forall a.
    (Card_UNIV a) => (a -> a -> Bool) ->
                       (Maybe a -> Maybe a -> Bool) ->
                         Maybe a -> Nat -> [a] -> [a] -> Bool;
proper_interval_set_Compl_aux less proper_interval ao n (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           proper_interval_set_Compl_aux less proper_interval (Just x)
             (plus_nat n one_nat) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  proper_interval_set_Compl_aux less proper_interval (Just y)
                    (plus_nat n one_nat) (x : xs) ys
           else proper_interval ao (Just x) &&
                  let {
                    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                  } in not (equal_nat (minus_nat m (size_list ys))
                             (nat_of_integer (2 :: Integer))) ||
                         not (equal_nat (minus_nat m (size_list xs))
                               (nat_of_integer (2 :: Integer)))));
proper_interval_set_Compl_aux less proper_interval ao n (x : xs) [] =
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
  } in (case length_last (x : xs) of {
         (len_x, xa) ->
           not (equal_nat m len_x) &&
             (if equal_nat m (plus_nat len_x one_nat)
               then not (proper_interval (Just xa) Nothing) else True);
       });
proper_interval_set_Compl_aux less proper_interval ao n [] (y : ys) =
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
  } in (case length_last (y : ys) of {
         (len_y, ya) ->
           not (equal_nat m len_y) &&
             (if equal_nat m (plus_nat len_y one_nat)
               then not (proper_interval (Just ya) Nothing) else True);
       });
proper_interval_set_Compl_aux less proper_interval ao n [] [] =
  less_nat (plus_nat n one_nat) (of_phantom (card_UNIV :: Phantom a Nat));

proper_interval_Compl_set_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
proper_interval_Compl_set_aux less proper_interval ao uu [] = False;
proper_interval_Compl_set_aux less proper_interval ao [] uv = False;
proper_interval_Compl_set_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           proper_interval_Compl_set_aux less proper_interval (Just x) xs
             (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  proper_interval_Compl_set_aux less proper_interval (Just y)
                    (x : xs) ys
           else not (proper_interval ao (Just x)) &&
                  (if null ys then not (null xs) else True)));

exhaustive_above :: forall a. (Maybe a -> Maybe a -> Bool) -> a -> [a] -> Bool;
exhaustive_above proper_interval x (y : ys) =
  not (proper_interval (Just x) (Just y)) &&
    exhaustive_above proper_interval y ys;
exhaustive_above proper_interval x [] = not (proper_interval (Just x) Nothing);

proper_interval_set_aux ::
  forall a.
    (a -> a -> Bool) -> (Maybe a -> Maybe a -> Bool) -> [a] -> [a] -> Bool;
proper_interval_set_aux less proper_interval (x : xs) (y : ys) =
  (if less x y then False
    else (if less y x
           then proper_interval (Just y) (Just x) ||
                  (not (null ys) || not (exhaustive_above proper_interval x xs))
           else proper_interval_set_aux less proper_interval xs ys));
proper_interval_set_aux less proper_interval [] (y : ys) =
  not (null ys) || proper_interval (Just y) Nothing;
proper_interval_set_aux less proper_interval xs [] = False;

exhaustive_fusion ::
  forall a b. (Maybe a -> Maybe a -> Bool) -> Generator a b -> b -> Bool;
exhaustive_fusion proper_interval g s =
  has_next g s &&
    (case next g s of {
      (x, sa) ->
        not (proper_interval Nothing (Just x)) &&
          exhaustive_above_fusion proper_interval g x sa;
    });

list_remdups :: forall a. (a -> a -> Bool) -> [a] -> [a];
list_remdups equal (x : xs) =
  (if list_member equal xs x then list_remdups equal xs
    else x : list_remdups equal xs);
list_remdups equal [] = [];

lengtha :: forall a. (Ceq a) => Set_dlist a -> Nat;
lengtha xa = size_list (list_of_dlist xa);

card :: forall a. (Card_UNIV a, Ceq a, Ccompare a) => Set a -> Nat;
card (Complement a) =
  let {
    aa = card a;
    s = of_phantom (card_UNIV :: Phantom a Nat);
  } in (if less_nat zero_nat s then minus_nat s aa
         else (if finite a then zero_nat
                else (error :: forall a. String -> (() -> a) -> a)
                       "card Complement: infinite"
                       (\ _ -> card (Complement a))));
card (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "card Set_Monad: ceq = None"
        (\ _ -> card (Set_Monad xs));
    Just eq -> size_list (list_remdups eq xs);
  });
card (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "card RBT_set: ccompare = None" (\ _ -> card (RBT_set rbt));
    Just _ -> size_list (keysa rbt);
  });
card (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "card DList_set: ceq = None"
        (\ _ -> card (DList_set dxs));
    Just _ -> lengtha dxs;
  });

is_UNIV :: forall a. (Card_UNIV a, Ceq a, Cproper_interval a) => Set a -> Bool;
is_UNIV (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_UNIV RBT_set: ccompare = None" (\ _ -> is_UNIV (RBT_set rbt));
    Just _ ->
      of_phantom (finite_UNIV :: Phantom a Bool) &&
        exhaustive_fusion cproper_interval rbt_keys_generator (init rbt);
  });
is_UNIV a =
  let {
    aa = of_phantom (card_UNIV :: Phantom a Nat);
    b = card a;
  } in (if less_nat zero_nat aa then equal_nat aa b
         else (if less_nat zero_nat b then False
                else (error :: forall a. String -> (() -> a) -> a)
                       "is_UNIV called on infinite type and set"
                       (\ _ -> is_UNIV a)));

is_emptya :: forall a b. (Ccompare a) => Mapping_rbt a b -> Bool;
is_emptya xa = (case impl_ofb xa of {
                 Empty -> True;
                 Branch _ _ _ _ _ -> False;
               });

nulla :: forall a. (Ceq a) => Set_dlist a -> Bool;
nulla xa = null (list_of_dlist xa);

is_empty :: forall a. (Card_UNIV a, Ceq a, Cproper_interval a) => Set a -> Bool;
is_empty (Complement a) = is_UNIV a;
is_empty (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_empty RBT_set: ccompare = None" (\ _ -> is_empty (RBT_set rbt));
    Just _ -> is_emptya rbt;
  });
is_empty (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_empty DList_set: ceq = None" (\ _ -> is_empty (DList_set dxs));
    Just _ -> nulla dxs;
  });
is_empty (Set_Monad xs) = null xs;

cproper_interval_set ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Maybe (Set a) -> Maybe (Set a) -> Bool;
cproper_interval_set (Just (Complement (RBT_set rbt1))) (Just (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (Complement (RBT_set rbt1)))
            (Just (RBT_set rbt2)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_Compl_set_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cproper_interval_set (Just (RBT_set rbt1)) (Just (Complement (RBT_set rbt2))) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval RBT_set (Complement RBT_set): ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (RBT_set rbt1))
            (Just (Complement (RBT_set rbt2))));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_Compl_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing zero_nat (init rbt1)
          (init rbt2);
  });
cproper_interval_set (Just (RBT_set rbt1)) (Just (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval RBT_set RBT_set: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (RBT_set rbt1)) (Just (RBT_set rbt2)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator (init rbt1) (init rbt2);
  });
cproper_interval_set (Just (Complement a)) (Just (Complement b)) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement Complement: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (Complement a)) (Just (Complement b)));
    Just _ -> cproper_interval_set (Just b) (Just a);
  });
cproper_interval_set (Just (Complement a)) (Just b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement1: ccompare = None"
        (\ _ -> cproper_interval_set (Just (Complement a)) (Just b));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_Compl_set_aux (lt_of_comp c) cproper_interval Nothing
          (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) (Just (Complement b)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement2: ccompare = None"
        (\ _ -> cproper_interval_set (Just a) (Just (Complement b)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_Compl_aux (lt_of_comp c) cproper_interval Nothing
          zero_nat (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) (Just b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval: ccompare = None"
        (\ _ -> cproper_interval_set (Just a) (Just b));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_aux (lt_of_comp c) cproper_interval
          (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) Nothing = not (is_UNIV a);
cproper_interval_set Nothing (Just b) = not (is_empty b);
cproper_interval_set Nothing Nothing = True;

instance (Card_UNIV a, Ceq a, Cproper_interval a,
           Set_impl a) => Cproper_interval (Set a) where {
  cproper_interval = cproper_interval_set;
};

one_list :: forall a. [a];
one_list = [];

instance One [a] where {
  onea = one_list;
};

default_list :: forall a. [a];
default_list = [];

class Default a where {
  defaulta :: a;
};

instance Default [a] where {
  defaulta = default_list;
};

times_list :: forall a. [a] -> [a] -> [a];
times_list p q = p ++ q;

instance Times [a] where {
  times = times_list;
};

instance Power [a] where {
};

less_eq_list :: forall a. (Eq a, Order a) => [a] -> [a] -> Bool;
less_eq_list (x : xs) (y : ys) = less x y || x == y && less_eq_list xs ys;
less_eq_list [] xs = True;
less_eq_list (x : xs) [] = False;

less_list :: forall a. (Eq a, Order a) => [a] -> [a] -> Bool;
less_list (x : xs) (y : ys) = less x y || x == y && less_list xs ys;
less_list [] (x : xs) = True;
less_list xs [] = False;

instance (Eq a, Order a) => Ord [a] where {
  less_eq = less_eq_list;
  less = less_list;
};

comparator_list :: forall a. (a -> a -> Ordera) -> [a] -> [a] -> Ordera;
comparator_list comp_a (x : xa) (y : ya) =
  (case comp_a x y of {
    Eqa -> comparator_list comp_a xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_list comp_a (x : xa) [] = Gt;
comparator_list comp_a [] (y : ya) = Lt;
comparator_list comp_a [] [] = Eqa;

compare_list :: forall a. (Compare a) => [a] -> [a] -> Ordera;
compare_list = comparator_list compare;

instance (Compare a) => Compare [a] where {
  compare = compare_list;
};

instance (Eq a, Order a) => Quasi_order [a] where {
};

instance (Eq a, Order a) => Weak_order [a] where {
};

instance (Eq a, Order a) => Preorder [a] where {
};

instance (Eq a, Order a) => Order [a] where {
};

equality_list :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
equality_list eq_a (x : xa) (y : ya) = eq_a x y && equality_list eq_a xa ya;
equality_list eq_a (x : xa) [] = False;
equality_list eq_a [] (y : ya) = False;
equality_list eq_a [] [] = True;

ceq_list :: forall a. (Ceq a) => Maybe ([a] -> [a] -> Bool);
ceq_list = (case ceq of {
             Nothing -> Nothing;
             Just eq_a -> Just (equality_list eq_a);
           });

instance (Ceq a) => Ceq [a] where {
  ceq = ceq_list;
};

class Infinite a where {
};

instance Infinite [a] where {
};

set_impl_list :: forall a. Phantom [a] Set_impla;
set_impl_list = Phantom Set_Choose;

instance Set_impl [a] where {
  set_impl = set_impl_list;
};

instance (Eq a, Linorder a) => Linorder [a] where {
};

class Countable a where {
};

instance (Countable a) => Countable [a] where {
};

showsl_lista :: forall a. (Showl a) => [a] -> String -> String;
showsl_lista xs = showsl_list xs;

showsl_list_list :: forall a. (Showl a) => [[a]] -> String -> String;
showsl_list_list xs = default_showsl_list showsl_lista xs;

instance (Showl a) => Showl [a] where {
  showsl = showsl_lista;
  showsl_list = showsl_list_list;
};

finite_UNIV_list :: forall a. Phantom [a] Bool;
finite_UNIV_list = Phantom False;

card_UNIV_list :: forall a. Phantom [a] Nat;
card_UNIV_list = Phantom zero_nat;

instance Finite_UNIV [a] where {
  finite_UNIV = finite_UNIV_list;
};

instance Card_UNIV [a] where {
  card_UNIVa = card_UNIV_list;
};

cEnum_list ::
  forall a. Maybe ([[a]], (([a] -> Bool) -> Bool, ([a] -> Bool) -> Bool));
cEnum_list = Nothing;

instance Cenum [a] where {
  cEnum = cEnum_list;
};

instance (Compare_order a, Eq a) => Compare_order [a] where {
};

ccompare_list :: forall a. (Ccompare a) => Maybe ([a] -> [a] -> Ordera);
ccompare_list = (case ccompare of {
                  Nothing -> Nothing;
                  Just comp_a -> Just (comparator_list comp_a);
                });

instance (Ccompare a) => Ccompare [a] where {
  ccompare = ccompare_list;
};

mapping_impl_list :: forall a. Phantom [a] Mapping_impla;
mapping_impl_list = Phantom Mapping_Choose;

instance Mapping_impl [a] where {
  mapping_impl = mapping_impl_list;
};

cproper_interval_list ::
  forall a. (Ccompare a) => Maybe [a] -> Maybe [a] -> Bool;
cproper_interval_list xso yso = error "undefined";

instance (Ccompare a) => Cproper_interval [a] where {
  cproper_interval = cproper_interval_list;
};

class Unit_factor a where {
  unit_factor :: a -> a;
};

class (Semidom_divide a, Unit_factor a) => Semidom_divide_unit_factor a where {
};

class (Algebraic_semidom a,
        Semidom_divide_unit_factor a) => Normalization_semidom a where {
  normalizec :: a -> a;
};

class (Semidom_modulo a) => Euclidean_semiring a where {
  euclidean_size :: a -> Nat;
};

class (Normalization_semidom a) => Factorial_semiring a where {
};

class (Euclidean_semiring a,
        Factorial_semiring a) => Normalization_euclidean_semiring a where {
};

gcdc :: forall a. (Normalization_euclidean_semiring a, Eq a) => a -> a -> a;
gcdc a b = (if b == zerob then normalizec a else gcdc b (modulo a b));

lcmc :: forall a. (Normalization_euclidean_semiring a, Eq a) => a -> a -> a;
lcmc a b = normalizec (divide (times a b) (gcdc a b));

euclidean_size_field :: forall a. (Field a, Eq a) => a -> Nat;
euclidean_size_field x = (if x == zerob then zero_nat else one_nat);

rep_mini_alg_unique :: Mini_alg_unique -> Mini_alg;
rep_mini_alg_unique (Abs_mini_alg_unique x) = x;

rep_mini_alg :: Mini_alg -> (Rat, (Rat, Nat));
rep_mini_alg (Abs_mini_alg x) = x;

numeral :: forall a. (Numeral a) => Num -> a;
numeral (Bit1 n) = let {
                     m = numeral n;
                   } in plus (plus m m) onea;
numeral (Bit0 n) = let {
                     m = numeral n;
                   } in plus m m;
numeral One = onea;

of_nat :: forall a. (Semiring_1 a) => Nat -> a;
of_nat n =
  (if equal_nat n zero_nat then zerob
    else (case divmod_nat n (nat_of_integer (2 :: Integer)) of {
           (m, q) -> let {
                       ma = times (numeral (Bit0 One)) (of_nat m);
                     } in (if equal_nat q zero_nat then ma else plus ma onea);
         }));

ma_normalize :: (Rat, (Rat, Nat)) -> (Rat, (Rat, Nat));
ma_normalize x =
  (case x of {
    (a, b) ->
      (case b of {
        (ba, c) ->
          (if equal_rat ba zero_rat then (a, (zero_rat, zero_nat))
            else (a, (ba, c)));
      });
  });

ma_inverse :: Mini_alg -> Mini_alg;
ma_inverse xa =
  Abs_mini_alg
    (case rep_mini_alg xa of {
      (p, (q, b)) ->
        let {
          d = inverse_rat
                (minus_rat (times_rat p p)
                  (times_rat (times_rat (of_nat b) q) q));
        } in ma_normalize (times_rat p d, (times_rat (uminus_rat q) d, b));
    });

mau_inverse :: Mini_alg_unique -> Mini_alg_unique;
mau_inverse xa = Abs_mini_alg_unique (ma_inverse (rep_mini_alg_unique xa));

inverse_real :: Real -> Real;
inverse_real (Real_of_u r) = Real_of_u (mau_inverse r);

ma_uminus :: Mini_alg -> Mini_alg;
ma_uminus xa =
  Abs_mini_alg (case rep_mini_alg xa of {
                 (p1, (q1, b1)) -> (uminus_rat p1, (uminus_rat q1, b1));
               });

mau_uminus :: Mini_alg_unique -> Mini_alg_unique;
mau_uminus xa = Abs_mini_alg_unique (ma_uminus (rep_mini_alg_unique xa));

uminus_real :: Real -> Real;
uminus_real (Real_of_u r) = Real_of_u (mau_uminus r);

ma_compatible :: Mini_alg -> Mini_alg -> Bool;
ma_compatible xa xc =
  (case rep_mini_alg xa of {
    (_, (q1, b1)) ->
      (\ (_, (q2, b2)) ->
        equal_rat q1 zero_rat || (equal_rat q2 zero_rat || equal_nat b1 b2));
  })
    (rep_mini_alg xc);

mau_compatible :: Mini_alg_unique -> Mini_alg_unique -> Bool;
mau_compatible xa xc =
  ma_compatible (rep_mini_alg_unique xa) (rep_mini_alg_unique xc);

ma_times :: Mini_alg -> Mini_alg -> Mini_alg;
ma_times xb xc =
  Abs_mini_alg
    ((case rep_mini_alg xb of {
       (p1, (q1, b1)) ->
         (\ (p2, (q2, b2)) ->
           (if equal_rat q1 zero_rat
             then ma_normalize (times_rat p1 p2, (times_rat p1 q2, b2))
             else ma_normalize
                    (plus_rat (times_rat p1 p2)
                       (times_rat (times_rat (of_nat b2) q1) q2),
                      (plus_rat (times_rat p1 q2) (times_rat q1 p2), b1))));
     })
      (rep_mini_alg xc));

mau_times :: Mini_alg_unique -> Mini_alg_unique -> Mini_alg_unique;
mau_times xb xc =
  Abs_mini_alg_unique
    (ma_times (rep_mini_alg_unique xb) (rep_mini_alg_unique xc));

times_real :: Real -> Real -> Real;
times_real (Real_of_u r1) (Real_of_u r2) =
  (if mau_compatible r1 r2 then Real_of_u (mau_times r1 r2)
    else (error :: forall a. String -> (() -> a) -> a) "different base"
           (\ _ -> times_real (Real_of_u r1) (Real_of_u r2)));

divide_real :: Real -> Real -> Real;
divide_real x y = times_real x (inverse_real y);

ma_plus :: Mini_alg -> Mini_alg -> Mini_alg;
ma_plus xb xc =
  Abs_mini_alg
    ((case rep_mini_alg xb of {
       (p1, (q1, b1)) ->
         (\ (p2, (q2, b2)) ->
           (if equal_rat q1 zero_rat then (plus_rat p1 p2, (q2, b2))
             else ma_normalize (plus_rat p1 p2, (plus_rat q1 q2, b1))));
     })
      (rep_mini_alg xc));

mau_plus :: Mini_alg_unique -> Mini_alg_unique -> Mini_alg_unique;
mau_plus xb xc =
  Abs_mini_alg_unique
    (ma_plus (rep_mini_alg_unique xb) (rep_mini_alg_unique xc));

plus_real :: Real -> Real -> Real;
plus_real (Real_of_u r1) (Real_of_u r2) =
  (if mau_compatible r1 r2 then Real_of_u (mau_plus r1 r2)
    else (error :: forall a. String -> (() -> a) -> a) "different base"
           (\ _ -> plus_real (Real_of_u r1) (Real_of_u r2)));

minus_real :: Real -> Real -> Real;
minus_real x y = plus_real x (uminus_real y);

zero_real :: Real;
zero_real = Real_of_u (mau_of_rat zero_rat);

one_real :: Real;
one_real = Real_of_u (mau_of_rat one_rat);

instance Plus Real where {
  plus = plus_real;
};

instance Semigroup_add Real where {
};

instance Cancel_semigroup_add Real where {
};

instance Ab_semigroup_add Real where {
};

instance Minus Real where {
  minus = minus_real;
};

instance Cancel_ab_semigroup_add Real where {
};

instance Zero Real where {
  zerob = zero_real;
};

instance Monoid_add Real where {
};

instance Comm_monoid_add Real where {
};

instance Cancel_comm_monoid_add Real where {
};

instance Times Real where {
  times = times_real;
};

instance Mult_zero Real where {
};

instance Semigroup_mult Real where {
};

instance Semiring Real where {
};

instance Semiring_0 Real where {
};

instance Semiring_0_cancel Real where {
};

instance Ab_semigroup_mult Real where {
};

instance Comm_semiring Real where {
};

instance Comm_semiring_0 Real where {
};

instance Comm_semiring_0_cancel Real where {
};

instance One Real where {
  onea = one_real;
};

instance Power Real where {
};

instance Monoid_mult Real where {
};

instance Numeral Real where {
};

instance Semiring_numeral Real where {
};

instance Zero_neq_one Real where {
};

instance Semiring_1 Real where {
};

instance Semiring_1_cancel Real where {
};

instance Dvd Real where {
};

instance Comm_monoid_mult Real where {
};

instance Comm_semiring_1 Real where {
};

instance Comm_semiring_1_cancel Real where {
};

instance Comm_semiring_1_cancel_crossproduct Real where {
};

instance Semiring_no_zero_divisors Real where {
};

instance Semiring_1_no_zero_divisors Real where {
};

instance Semiring_no_zero_divisors_cancel Real where {
};

instance Uminus Real where {
  uminus = uminus_real;
};

instance Group_add Real where {
};

instance Ab_group_add Real where {
};

instance Ring Real where {
};

instance Ring_no_zero_divisors Real where {
};

instance Neg_numeral Real where {
};

instance Ring_1 Real where {
};

instance Ring_1_no_zero_divisors Real where {
};

instance Comm_ring Real where {
};

instance Comm_ring_1 Real where {
};

instance Semidom Real where {
};

instance Idom Real where {
};

instance Ufd Real where {
};

instance Divide Real where {
  divide = divide_real;
};

instance Inverse Real where {
  inverse = inverse_real;
};

instance Division_ring Real where {
};

instance Semidom_divide Real where {
};

instance Idom_divide Real where {
};

instance Field Real where {
};

ma_identity :: Mini_alg -> Mini_alg -> Bool;
ma_identity xa xc = rep_mini_alg xa == rep_mini_alg xc;

mau_equal :: Mini_alg_unique -> Mini_alg_unique -> Bool;
mau_equal xa xc = ma_identity (rep_mini_alg_unique xa) (rep_mini_alg_unique xc);

equal_real :: Real -> Real -> Bool;
equal_real (Real_of_u r1) (Real_of_u r2) = mau_equal r1 r2;

instance Eq Real where {
  a == b = equal_real a b;
};

euclidean_size_real :: Real -> Nat;
euclidean_size_real = euclidean_size_field;

normalize_field :: forall a. (Field a, Eq a) => a -> a;
normalize_field x = (if x == zerob then zerob else onea);

normalize_real :: Real -> Real;
normalize_real = normalize_field;

unit_factor_field :: forall a. (Field a) => a -> a;
unit_factor_field x = x;

unit_factor_real :: Real -> Real;
unit_factor_real = unit_factor_field;

mod_field :: forall a. (Field a, Eq a) => a -> a -> a;
mod_field x y = (if y == zerob then x else zerob);

modulo_real :: Real -> Real -> Real;
modulo_real = mod_field;

instance Algebraic_semidom Real where {
};

instance Modulo Real where {
  modulo = modulo_real;
};

instance Semiring_modulo Real where {
};

instance Semidom_modulo Real where {
};

instance Euclidean_semiring Real where {
  euclidean_size = euclidean_size_real;
};

instance Unit_factor Real where {
  unit_factor = unit_factor_real;
};

instance Semidom_divide_unit_factor Real where {
};

instance Normalization_semidom Real where {
  normalizec = normalize_real;
};

instance Factorial_semiring Real where {
};

instance Normalization_euclidean_semiring Real where {
};

lcm_reala :: Real -> Real -> Real;
lcm_reala = lcmc;

gcd_reala :: Real -> Real -> Real;
gcd_reala = gcdc;

lcmb :: forall a. Set a -> a;
lcmb _ = error "Euclidean_Algorithm.normalization_euclidean_semiring_class.Lcm";

lcm_real :: Set Real -> Real;
lcm_real = lcmb;

gcdb :: forall a. Set a -> a;
gcdb _ = error "Euclidean_Algorithm.normalization_euclidean_semiring_class.Gcd";

gcd_real :: Set Real -> Real;
gcd_real = gcdb;

class (One a, Zero a, Dvd a) => Gcda a where {
  gcda :: a -> a -> a;
  lcma :: a -> a -> a;
};

class (Gcda a) => Gcd a where {
  gcd :: Set a -> a;
  lcm :: Set a -> a;
};

instance Gcda Real where {
  gcda = gcd_reala;
  lcma = lcm_reala;
};

instance Gcd Real where {
  gcd = gcd_real;
  lcm = lcm_real;
};

sqrt_int_maina :: Int -> Int -> (Int, Bool);
sqrt_int_maina x n =
  let {
    x2 = times_int x x;
  } in (if less_eq_int x2 n then (x, equal_int x2 n)
         else sqrt_int_maina
                (divide_int (plus_int (divide_int n x) x)
                  (Int_of_integer (2 :: Integer)))
                n);

binary_power :: forall a. (Monoid_mult a) => a -> Nat -> a;
binary_power x n =
  (if equal_nat n zero_nat then onea
    else (case divmod_nat n (nat_of_integer (2 :: Integer)) of {
           (d, r) -> let {
                       rec = binary_power (times x x) d;
                     } in (if equal_nat r zero_nat then rec else times rec x);
         }));

ceiling :: forall a. (Floor_ceiling a) => a -> Int;
ceiling x = uminus_int (floor (uminus x));

newtype Proper_base = Abs_proper_base Int;

into_base :: Int -> Proper_base;
into_base xa =
  Abs_proper_base
    (if less_eq_int (Int_of_integer (2 :: Integer)) xa then xa
      else Int_of_integer (2 :: Integer));

rep_proper_base :: Proper_base -> Int;
rep_proper_base (Abs_proper_base x) = x;

square_base :: Proper_base -> Proper_base;
square_base xa =
  Abs_proper_base (times_int (rep_proper_base xa) (rep_proper_base xa));

get_base :: Proper_base -> Int;
get_base x = rep_proper_base x;

log_main :: Proper_base -> Int -> (Nat, Int);
log_main b x =
  (if less_int x (get_base b) then (zero_nat, one_int)
    else (case log_main (square_base b) x of {
           (z, bz) -> let {
                        l = times_nat (nat_of_integer (2 :: Integer)) z;
                        bz1 = times_int bz (get_base b);
                      } in (if less_int x bz1 then (l, bz) else (suc l, bz1));
         }));

log_ceiling :: Int -> Int -> Nat;
log_ceiling b x = (case log_main (into_base b) x of {
                    (y, by) -> (if equal_int x by then y else suc y);
                  });

start_value :: Int -> Nat -> Int;
start_value n p =
  binary_power (Int_of_integer (2 :: Integer))
    (nat (ceiling
           (divide_rat (of_nat (log_ceiling (Int_of_integer (2 :: Integer)) n))
             (of_nat p))));

sqrt_int_main :: Int -> (Int, Bool);
sqrt_int_main x =
  sqrt_int_maina (start_value x (nat_of_integer (2 :: Integer))) x;

sqrt_int_ceiling_pos :: Int -> Int;
sqrt_int_ceiling_pos x = (case sqrt_int_main x of {
                           (y, True) -> y;
                           (y, False) -> plus_int y one_int;
                         });

sqrt_int_floor_pos :: Int -> Int;
sqrt_int_floor_pos x = fst (sqrt_int_main x);

int_of_nat :: Nat -> Int;
int_of_nat n = Int_of_integer (integer_of_nat n);

ma_floor :: Mini_alg -> Int;
ma_floor xa =
  (case rep_mini_alg xa of {
    (p, (q, b)) ->
      (case (quotient_of p, quotient_of q) of {
        ((z1, n1), (z2, n2)) ->
          let {
            z2n1 = times_int z2 n1;
            z1n2 = times_int z1 n2;
            n12 = times_int n1 n2;
            prod = times_int (times_int z2n1 z2n1) (int_of_nat b);
          } in divide_int
                 (plus_int z1n2
                   (if less_eq_int zero_int z2n1 then sqrt_int_floor_pos prod
                     else uminus_int (sqrt_int_ceiling_pos prod)))
                 n12;
      });
  });

mau_floor :: Mini_alg_unique -> Int;
mau_floor xa = ma_floor (rep_mini_alg_unique xa);

floor_real :: Real -> Int;
floor_real (Real_of_u r) = mau_floor r;

real_lt :: Real -> Real -> Bool;
real_lt x y =
  let {
    fx = floor_real x;
    fy = floor_real y;
  } in (if less_int fx fy then True
         else (if less_int fy fx then False
                else real_lt
                       (times_real x
                         (ratreal (of_int (Int_of_integer (1024 :: Integer)))))
                       (times_real y
                         (ratreal
                           (of_int (Int_of_integer (1024 :: Integer)))))));

ma_ge_0 :: Mini_alg -> Bool;
ma_ge_0 xa =
  (case rep_mini_alg xa of {
    (p, (q, b)) ->
      let {
        bqq = times_rat (times_rat (of_nat b) q) q;
        pp = times_rat p p;
      } in less_eq_rat zero_rat p && less_eq_rat bqq pp ||
             less_eq_rat zero_rat q && less_eq_rat pp bqq;
  });

mau_ge_0 :: Mini_alg_unique -> Bool;
mau_ge_0 xa = ma_ge_0 (rep_mini_alg_unique xa);

ge_0 :: Real -> Bool;
ge_0 (Real_of_u x) = mau_ge_0 x;

less_real :: Real -> Real -> Bool;
less_real (Real_of_u x) (Real_of_u y) =
  not (equal_real (Real_of_u x) (Real_of_u y)) &&
    (if mau_compatible x y then ge_0 (minus_real (Real_of_u y) (Real_of_u x))
      else real_lt (Real_of_u x) (Real_of_u y));

abs_real :: Real -> Real;
abs_real a = (if less_real a zero_real then uminus_real a else a);

instance Abs Real where {
  absa = abs_real;
};

sgn_real :: Real -> Real;
sgn_real a =
  (if equal_real a zero_real then zero_real
    else (if less_real zero_real a then one_real else uminus_real one_real));

instance Sgn Real where {
  sgn = sgn_real;
};

class (Gcda a, Comm_semiring_1 a) => Comm_monoid_gcd a where {
};

class (Idom a, Comm_monoid_gcd a) => Idom_gcd a where {
};

class (Normalization_semidom a, Comm_monoid_gcd a) => Semiring_gcd a where {
};

class (Semiring_gcd a, Idom_gcd a) => Ring_gcd a where {
};

instance Comm_monoid_gcd Real where {
};

instance Idom_gcd Real where {
};

instance Semiring_gcd Real where {
};

instance Ring_gcd Real where {
};

less_eq_real :: Real -> Real -> Bool;
less_eq_real (Real_of_u x) (Real_of_u y) =
  equal_real (Real_of_u x) (Real_of_u y) ||
    (if mau_compatible x y then ge_0 (minus_real (Real_of_u y) (Real_of_u x))
      else real_lt (Real_of_u x) (Real_of_u y));

instance Ord Real where {
  less_eq = less_eq_real;
  less = less_real;
};

instance Abs_if Real where {
};

instance Semiring_char_0 Real where {
};

instance Ring_char_0 Real where {
};

instance Quasi_order Real where {
};

instance Weak_order Real where {
};

instance Preorder Real where {
};

instance Order Real where {
};

class (Gcd a, Semiring_gcd a) => Semiring_Gcd a where {
};

instance Semiring_Gcd Real where {
};

instance No_bot Real where {
};

instance No_top Real where {
};

ceq_real :: Maybe (Real -> Real -> Bool);
ceq_real = Just equal_real;

instance Ceq Real where {
  ceq = ceq_real;
};

set_impl_real :: Phantom Real Set_impla;
set_impl_real = Phantom Set_RBT;

instance Set_impl Real where {
  set_impl = set_impl_real;
};

instance Linorder Real where {
};

instance Idom_abs_sgn Real where {
};

instance Ordered_ab_semigroup_add Real where {
};

instance Strict_ordered_ab_semigroup_add Real where {
};

instance Ordered_cancel_ab_semigroup_add Real where {
};

instance Ordered_semigroup_mult_zero Real where {
};

instance Ordered_comm_monoid_add Real where {
};

instance Ordered_semiring Real where {
};

instance Ordered_semiring_0 Real where {
};

instance Ordered_cancel_semiring Real where {
};

instance Ordered_ab_semigroup_add_imp_le Real where {
};

instance Strict_ordered_comm_monoid_add Real where {
};

instance Ordered_cancel_comm_monoid_add Real where {
};

instance Ordered_ab_semigroup_monoid_add_imp_le Real where {
};

instance Ordered_ab_group_add Real where {
};

instance Ordered_ring Real where {
};

instance Field_char_0 Real where {
};

instance Zero_less_one Real where {
};

string_of_digit :: Nat -> [Char];
string_of_digit n =
  (if equal_nat n zero_nat
    then [Char False False False False True True False False]
    else (if equal_nat n one_nat
           then [Char True False False False True True False False]
           else (if equal_nat n (nat_of_integer (2 :: Integer))
                  then [Char False True False False True True False False]
                  else (if equal_nat n (nat_of_integer (3 :: Integer))
                         then [Char True True False False True True False False]
                         else (if equal_nat n (nat_of_integer (4 :: Integer))
                                then [Char False False True False True True
False False]
                                else (if equal_nat n
   (nat_of_integer (5 :: Integer))
                                       then [Char True False True False True
       True False False]
                                       else (if equal_nat n
          (nat_of_integer (6 :: Integer))
      then [Char False True True False True True False False]
      else (if equal_nat n (nat_of_integer (7 :: Integer))
             then [Char True True True False True True False False]
             else (if equal_nat n (nat_of_integer (8 :: Integer))
                    then [Char False False False True True True False False]
                    else [Char True False False True True True False
                            False])))))))));

shows_string :: [Char] -> [Char] -> [Char];
shows_string = (\ a b -> a ++ b);

showsp_nat :: Nat -> Nat -> [Char] -> [Char];
showsp_nat p n =
  (if less_nat n (nat_of_integer (10 :: Integer))
    then shows_string (string_of_digit n)
    else showsp_nat p (divide_nat n (nat_of_integer (10 :: Integer))) .
           shows_string
             (string_of_digit (modulo_nat n (nat_of_integer (10 :: Integer)))));

showsp_int :: Nat -> Int -> [Char] -> [Char];
showsp_int p i =
  (if less_int i zero_int
    then shows_string [Char True False True True False True False False] .
           showsp_nat p (nat (uminus_int i))
    else showsp_nat p (nat i));

showsp_rat :: Nat -> Rat -> [Char] -> [Char];
showsp_rat p x =
  (case quotient_of x of {
    (d, n) ->
      (if equal_int n one_int then showsp_int p d
        else (showsp_int p d .
               shows_string [Char True True True True False True False False]) .
               showsp_int p n);
  });

shows_prec_rat :: Nat -> Rat -> [Char] -> [Char];
shows_prec_rat = showsp_rat;

shows_prec_nat :: Nat -> Nat -> [Char] -> [Char];
shows_prec_nat = showsp_nat;

class Showa a where {
  shows_prec :: Nat -> a -> [Char] -> [Char];
  shows_list :: [a] -> [Char] -> [Char];
};

shows_prec_list :: forall a. (Showa a) => Nat -> [a] -> [Char] -> [Char];
shows_prec_list p xs = shows_list xs;

shows_prec_char :: Nat -> Char -> [Char] -> [Char];
shows_prec_char p c = (\ a -> c : a);

shows_list_char :: [Char] -> [Char] -> [Char];
shows_list_char cs = shows_string cs;

instance Showa Char where {
  shows_prec = shows_prec_char;
  shows_list = shows_list_char;
};

ma_show_real :: Mini_alg -> [Char];
ma_show_real xa =
  (case rep_mini_alg xa of {
    (p, (q, b)) ->
      let {
        sb = (shows_prec_list zero_nat
                [Char True True False False True True True False,
                  Char True False False False True True True False,
                  Char False True False False True True True False,
                  Char False False True False True True True False,
                  Char False False False True False True False False] .
               shows_prec_nat zero_nat b) .
               shows_prec_list zero_nat
                 [Char True False False True False True False False];
        qb = (if equal_rat q one_rat then sb
               else (if equal_rat q (uminus_rat one_rat)
                      then shows_prec_list zero_nat
                             [Char True False True True False True False
                                False] .
                             sb
                      else (shows_prec_rat zero_nat q .
                             shows_prec_list zero_nat
                               [Char False True False True False True False
                                  False]) .
                             sb));
      } in (if equal_rat q zero_rat then shows_prec_rat zero_nat p []
             else (if equal_rat p zero_rat then qb []
                    else (if less_rat q zero_rat
                           then shows_prec_rat zero_nat p (qb [])
                           else shows_prec_rat zero_nat p
                                  (shows_prec_list zero_nat
                                    [Char True True False True False True False
                                       False]
                                    (qb [])))));
  });

mau_show_real :: Mini_alg_unique -> [Char];
mau_show_real xa = ma_show_real (rep_mini_alg_unique xa);

show_real :: Real -> [Char];
show_real (Real_of_u x) = mau_show_real x;

showsl_real :: Real -> String -> String;
showsl_real x = showsl_lit (implode (show_real x));

showsl_list_real :: [Real] -> String -> String;
showsl_list_real xs = default_showsl_list showsl_real xs;

instance Showl Real where {
  showsl = showsl_real;
  showsl_list = showsl_list_real;
};

instance Field_abs_sgn Real where {
};

cEnum_real :: Maybe ([Real], ((Real -> Bool) -> Bool, (Real -> Bool) -> Bool));
cEnum_real = Nothing;

instance Cenum Real where {
  cEnum = cEnum_real;
};

instance Dense_order Real where {
};

instance Linordered_ab_semigroup_add Real where {
};

instance Linordered_cancel_ab_semigroup_add Real where {
};

instance Linordered_semiring Real where {
};

instance Linordered_semiring_strict Real where {
};

instance Ordered_semiring_1a Real where {
};

instance Linordered_semiring_1 Real where {
};

instance Linordered_semiring_1_strict Real where {
};

instance Ordered_ab_group_add_abs Real where {
};

instance Linordered_ab_group_add Real where {
};

instance Linordered_ring Real where {
};

instance Linordered_ring_strict Real where {
};

instance Ordered_semiring_1b Real where {
};

instance Ordered_semiring_strict Real where {
};

instance Semiring_real_line Real where {
};

instance Semiring_1_real_line Real where {
};

instance Ordered_comm_semiring Real where {
};

instance Ordered_cancel_comm_semiring Real where {
};

instance Linordered_comm_semiring_strict Real where {
};

instance Linordered_nonzero_semiring Real where {
};

instance Linordered_semidom Real where {
};

instance Ordered_comm_ring Real where {
};

instance Ordered_ring_abs Real where {
};

instance Linordered_idom Real where {
};

instance Non_strict_order Real where {
};

instance Ordered_ab_semigroup Real where {
};

instance Ordered_semiring_0a Real where {
};

instance Ordered_semiring_1 Real where {
};

instance Poly_carrier Real where {
};

instance Dense_linorder Real where {
};

instance Unbounded_dense_linorder Real where {
};

instance Linordered_field Real where {
};

dist_real :: Real -> Real -> Real;
dist_real x y = abs_real (minus_real x y);

class Dist a where {
  dist :: a -> a -> Real;
};

instance Dist Real where {
  dist = dist_real;
};

norm_real :: Real -> Real;
norm_real r = abs_real r;

class Norm a where {
  norm :: a -> Real;
};

instance Norm Real where {
  norm = norm_real;
};

open_real :: Set Real -> Bool;
open_real _ = error "Real_Vector_Spaces.open_real_inst.open_real";

class Open a where {
  open :: Set a -> Bool;
};

instance Open Real where {
  open = open_real;
};

compare_real :: Real -> Real -> Ordera;
compare_real = comparator_of;

ccompare_real :: Maybe (Real -> Real -> Ordera);
ccompare_real = Just compare_real;

instance Ccompare Real where {
  ccompare = ccompare_real;
};

scaleR_real :: Real -> Real -> Real;
scaleR_real a x = times_real a x;

class ScaleR a where {
  scaleR :: Real -> a -> a;
};

instance ScaleR Real where {
  scaleR = scaleR_real;
};

class (Open a) => Topological_space a where {
};

class (Topological_space a) => T0_space a where {
};

instance Topological_space Real where {
};

instance T0_space Real where {
};

class (T0_space a) => T1_space a where {
};

instance T1_space Real where {
};

class (T1_space a) => T2_space a where {
};

instance T2_space Real where {
};

class (T2_space a) => T3_space a where {
};

instance T3_space Real where {
};

class (T3_space a) => T4_space a where {
};

instance T4_space Real where {
};

class (Monoid_add a, Topological_space a) => Topological_monoid_add a where {
};

class (Group_add a, Topological_monoid_add a) => Topological_group_add a where {
};

instance Topological_monoid_add Real where {
};

instance Topological_group_add Real where {
};

class (Minus a, Dist a, Norm a) => Dist_norm a where {
};

instance Dist_norm Real where {
};

data Filter a = Principal (Set a) | Abstract_filter (() -> Filter a);

uniformity_real :: Filter (Real, Real);
uniformity_real =
  Abstract_filter
    (\ _ ->
      (error :: forall a. String -> (() -> a) -> a)
        "uniformity is not executable" (\ _ -> uniformity_real));

class Uniformity a where {
  uniformity :: Filter (a, a);
};

instance Uniformity Real where {
  uniformity = uniformity_real;
};

class (Ab_group_add a, ScaleR a) => Real_vector a where {
};

instance Real_vector Real where {
};

real_of_real :: Real -> Real;
real_of_real x = x;

instance Real_embedding Real where {
  real_of = real_of_real;
};

instance Archimedean_field Real where {
};

instance Large_ordered_semiring_1 Real where {
};

instance Floor_ceiling Real where {
  floor = floor_real;
};

class (Normalization_semidom a) => Normalization_semidom_multiplicative a where {
};

class (Semiring_gcd a,
        Normalization_semidom_multiplicative a) => Semiring_gcd_mult_normalize a where {
};

instance Normalization_semidom_multiplicative Real where {
};

instance Semiring_gcd_mult_normalize Real where {
};

class (Comm_monoid_add a,
        Topological_monoid_add a) => Topological_comm_monoid_add a where {
};

class (Ab_group_add a, Topological_comm_monoid_add a,
        Topological_group_add a) => Topological_ab_group_add a where {
};

instance Topological_comm_monoid_add Real where {
};

instance Topological_ab_group_add Real where {
};

class (Topological_space a) => First_countable_topology a where {
};

class (Dist a, Uniformity a) => Uniformity_dist a where {
};

class (Topological_space a, Uniformity a) => Open_uniformity a where {
};

class (Open_uniformity a) => Uniform_space a where {
};

class (Uniformity_dist a, First_countable_topology a, T4_space a,
        Uniform_space a) => Metric_space a where {
};

instance First_countable_topology Real where {
};

instance Uniformity_dist Real where {
};

instance Open_uniformity Real where {
};

instance Uniform_space Real where {
};

instance Metric_space Real where {
};

class (Sgn a, Norm a, ScaleR a) => Sgn_div_norm a where {
};

instance Sgn_div_norm Real where {
};

class (Factorial_semiring a, Semiring_Gcd a) => Factorial_semiring_gcd a where {
};

class (Factorial_semiring_gcd a, Ring_gcd a,
        Idom_divide a) => Factorial_ring_gcd a where {
};

instance Factorial_semiring_gcd Real where {
};

instance Factorial_ring_gcd Real where {
};

class (Topological_ab_group_add a, Dist_norm a, Metric_space a, Real_vector a,
        Sgn_div_norm a) => Real_normed_vector a where {
};

instance Real_normed_vector Real where {
};

instance Large_real_ordered_semiring_1 Real where {
};

data Term a b = Var b | Fun a [Term a b];

instance (Eq a, Eq b) => Eq (Term a b) where {
  a == b = equal_term a b;
};

equal_term :: forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Bool;
equal_term (Var x1) (Fun x21 x22) = False;
equal_term (Fun x21 x22) (Var x1) = False;
equal_term (Fun x21 x22) (Fun y21 y22) = x21 == y21 && x22 == y22;
equal_term (Var x1) (Var y1) = x1 == y1;

comparator_term ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Term a b -> Term a b -> Ordera;
comparator_term comp_f comp_v (Fun x xa) (Fun ya yb) =
  (case comp_f x ya of {
    Eqa -> comparator_list (comparator_term comp_f comp_v) xa yb;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_term comp_f comp_v (Fun x xa) (Var y) = Gt;
comparator_term comp_f comp_v (Var x) (Fun ya yb) = Lt;
comparator_term comp_f comp_v (Var x) (Var y) = comp_v x y;

compare_term ::
  forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Ordera;
compare_term = comparator_term compare compare;

less_eq_term ::
  forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Bool;
less_eq_term = le_of_comp compare_term;

less_term :: forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Bool;
less_term = lt_of_comp compare_term;

instance (Compare a, Compare b) => Ord (Term a b) where {
  less_eq = less_eq_term;
  less = less_term;
};

instance (Compare a, Compare b) => Compare (Term a b) where {
  compare = compare_term;
};

instance (Compare a, Compare b) => Quasi_order (Term a b) where {
};

instance (Compare a, Compare b) => Weak_order (Term a b) where {
};

instance (Compare a, Compare b) => Preorder (Term a b) where {
};

instance (Compare a, Compare b) => Order (Term a b) where {
};

ceq_term :: forall a b. (Eq a, Eq b) => Maybe (Term a b -> Term a b -> Bool);
ceq_term = Just equal_term;

instance (Eq a, Eq b) => Ceq (Term a b) where {
  ceq = ceq_term;
};

set_impl_term :: forall a b. Phantom (Term a b) Set_impla;
set_impl_term = Phantom Set_RBT;

instance Set_impl (Term a b) where {
  set_impl = set_impl_term;
};

instance (Compare a, Compare b) => Linorder (Term a b) where {
};

showsl_term ::
  forall a b.
    (a -> String -> String) ->
      (b -> String -> String) -> Term a b -> String -> String;
showsl_term fun var (Var x) = var x;
showsl_term fun var (Fun f ts) =
  fun f . showsl_list_gen id "" "(" ", " ")" (map (showsl_term fun var) ts);

showsl_terma :: forall a b. (Showl a, Showl b) => Term a b -> String -> String;
showsl_terma t = showsl_term showsl showsl t;

showsl_list_term ::
  forall a b. (Showl a, Showl b) => [Term a b] -> String -> String;
showsl_list_term xs = default_showsl_list showsl_terma xs;

instance (Showl a, Showl b) => Showl (Term a b) where {
  showsl = showsl_terma;
  showsl_list = showsl_list_term;
};

cEnum_term ::
  forall a b.
    Maybe ([Term a b],
            ((Term a b -> Bool) -> Bool, (Term a b -> Bool) -> Bool));
cEnum_term = Nothing;

instance Cenum (Term a b) where {
  cEnum = cEnum_term;
};

instance (Compare a, Compare b) => Compare_order (Term a b) where {
};

finite_UNIV_term :: forall a b. Phantom (Term a b) Bool;
finite_UNIV_term = Phantom False;

instance Finite_UNIV (Term a b) where {
  finite_UNIV = finite_UNIV_term;
};

ccompare_term ::
  forall a b. (Compare a, Compare b) => Maybe (Term a b -> Term a b -> Ordera);
ccompare_term = Just compare_term;

instance (Compare a, Compare b) => Ccompare (Term a b) where {
  ccompare = ccompare_term;
};

cproper_interval_term ::
  forall a b.
    (Compare a, Compare b) => Maybe (Term a b) -> Maybe (Term a b) -> Bool;
cproper_interval_term = (\ _ _ -> False);

instance (Compare a, Compare b) => Cproper_interval (Term a b) where {
  cproper_interval = cproper_interval_term;
};

newtype Mat_impl a = Abs_mat_impl (Nat, (Nat, IArray.IArray (IArray.IArray a)));

rep_mat_impl ::
  forall a. Mat_impl a -> (Nat, (Nat, IArray.IArray (IArray.IArray a)));
rep_mat_impl (Abs_mat_impl x) = x;

length :: forall a. IArray.IArray a -> Nat;
length asa = nat_of_integer (IArray.length asa);

sub :: forall a. IArray.IArray a -> Nat -> a;
sub asa n = IArray.sub (asa, integer_of_nat n);

upt :: Nat -> Nat -> [Nat];
upt i j = (if less_nat i j then i : upt (suc i) j else []);

list_of :: forall a. IArray.IArray a -> [a];
list_of asa = map (sub asa) (upt zero_nat (length asa));

equal_iarray :: forall a. (Eq a) => IArray.IArray a -> IArray.IArray a -> Bool;
equal_iarray asa bs = list_of asa == list_of bs;

instance (Eq a) => Eq (IArray.IArray a) where {
  a == b = equal_iarray a b;
};

mat_equal_impl :: forall a. (Eq a) => Mat_impl a -> Mat_impl a -> Bool;
mat_equal_impl xa xc =
  (case rep_mat_impl xa of {
    (nr1, (nc1, m1)) ->
      (\ (nr2, (nc2, m2)) ->
        equal_nat nr1 nr2 && equal_nat nc1 nc2 && equal_iarray m1 m2);
  })
    (rep_mat_impl xc);

newtype Mat a = Mat_impl (Mat_impl a);

equal_mat :: forall a. (Eq a) => Mat a -> Mat a -> Bool;
equal_mat (Mat_impl m1) (Mat_impl m2) = mat_equal_impl m1 m2;

instance (Eq a) => Eq (Mat a) where {
  a == b = equal_mat a b;
};

ceq_mat :: forall a. (Eq a) => Maybe (Mat a -> Mat a -> Bool);
ceq_mat = Just equal_mat;

instance (Eq a) => Ceq (Mat a) where {
  ceq = ceq_mat;
};

set_impl_mat :: forall a. Phantom (Mat a) Set_impla;
set_impl_mat = Phantom Set_DList;

instance Set_impl (Mat a) where {
  set_impl = set_impl_mat;
};

nth :: forall a. [a] -> Nat -> a;
nth (x : xs) n =
  (if equal_nat n zero_nat then x else nth xs (minus_nat n one_nat));

index_mat_impl :: forall a. Mat_impl a -> (Nat, Nat) -> a;
index_mat_impl xa =
  (case rep_mat_impl xa of {
    (nr, (_, m)) ->
      (\ (i, j) ->
        (if less_nat i nr then sub (sub m i) j
          else sub (IArray.of_list (nth [] (minus_nat i nr))) j));
  });

index_mat :: forall a. Mat a -> (Nat, Nat) -> a;
index_mat (Mat_impl m) ij = index_mat_impl m ij;

dim_row_impl :: forall a. Mat_impl a -> Nat;
dim_row_impl xa = fst (rep_mat_impl xa);

dim_row :: forall a. Mat a -> Nat;
dim_row (Mat_impl m) = dim_row_impl m;

dim_col_impl :: forall a. Mat_impl a -> Nat;
dim_col_impl xa = fst (snd (rep_mat_impl xa));

dim_col :: forall a. Mat a -> Nat;
dim_col (Mat_impl m) = dim_col_impl m;

mat_to_list :: forall a. Mat a -> [[a]];
mat_to_list a =
  map (\ i -> map (\ j -> index_mat a (i, j)) (upt zero_nat (dim_col a)))
    (upt zero_nat (dim_row a));

showsl_mat :: forall a. (Showl a) => Mat a -> String -> String;
showsl_mat a = default_showsl_list id (map showsl_list (mat_to_list a));

showsl_list_mat :: forall a. (Showl a) => [Mat a] -> String -> String;
showsl_list_mat xs = default_showsl_list showsl_mat xs;

instance (Showl a) => Showl (Mat a) where {
  showsl = showsl_mat;
  showsl_list = showsl_list_mat;
};

cEnum_mat ::
  forall a. Maybe ([Mat a], ((Mat a -> Bool) -> Bool, (Mat a -> Bool) -> Bool));
cEnum_mat = Nothing;

instance Cenum (Mat a) where {
  cEnum = cEnum_mat;
};

ccompare_mat :: forall a. Maybe (Mat a -> Mat a -> Ordera);
ccompare_mat = Nothing;

instance Ccompare (Mat a) where {
  ccompare = ccompare_mat;
};

equal_char :: Char -> Char -> Bool;
equal_char (Char x1 x2 x3 x4 x5 x6 x7 x8) (Char y1 y2 y3 y4 y5 y6 y7 y8) =
  x1 == y1 &&
    x2 == y2 &&
      x3 == y3 && x4 == y4 && x5 == y5 && x6 == y6 && x7 == y7 && x8 == y8;

instance Eq Char where {
  a == b = equal_char a b;
};

nat_of_char :: Char -> Nat;
nat_of_char c = Nat (integer_of_char c);

less_eq_char :: Char -> Char -> Bool;
less_eq_char c1 c2 = less_eq_nat (nat_of_char c1) (nat_of_char c2);

less_char :: Char -> Char -> Bool;
less_char c1 c2 = less_nat (nat_of_char c1) (nat_of_char c2);

instance Ord Char where {
  less_eq = less_eq_char;
  less = less_char;
};

instance Quasi_order Char where {
};

instance Weak_order Char where {
};

instance Preorder Char where {
};

instance Order Char where {
};

instance Linorder Char where {
};

compare_char :: Char -> Char -> Ordera;
compare_char = comparator_of;

instance Compare Char where {
  compare = compare_char;
};

ceq_char :: Maybe (Char -> Char -> Bool);
ceq_char = Just equal_char;

instance Ceq Char where {
  ceq = ceq_char;
};

instance Countable Char where {
};

showsl_list_char :: [Char] -> String -> String;
showsl_list_char cs s = showsl_lit (implode cs) s;

showsl_char :: Char -> String -> String;
showsl_char c = showsl_lit (implode [c]);

instance Showl Char where {
  showsl = showsl_char;
  showsl_list = showsl_list_char;
};

instance Compare_order Char where {
};

ccompare_char :: Maybe (Char -> Char -> Ordera);
ccompare_char = Just compare_char;

instance Ccompare Char where {
  ccompare = ccompare_char;
};

data Hint a = Default | Base a | Distribute Nat [Hint a] | Erase Nat (Hint a)
  | LexStrict [Hint a] | LexWeak [Hint a];

default_hint :: forall a. (Default a) => Hint a;
default_hint = Default;

instance (Default a) => Default (Hint a) where {
  defaulta = default_hint;
};

data Atom a = Leq Nat a | Geq Nat a;

equal_atom :: forall a. (Eq a) => Atom a -> Atom a -> Bool;
equal_atom (Leq x11 x12) (Geq x21 x22) = False;
equal_atom (Geq x21 x22) (Leq x11 x12) = False;
equal_atom (Geq x21 x22) (Geq y21 y22) = equal_nat x21 y21 && x22 == y22;
equal_atom (Leq x11 x12) (Leq y11 y12) = equal_nat x11 y11 && x12 == y12;

ceq_atom :: forall a. (Eq a) => Maybe (Atom a -> Atom a -> Bool);
ceq_atom = Just equal_atom;

instance (Eq a) => Ceq (Atom a) where {
  ceq = ceq_atom;
};

set_impl_atom :: forall a. Phantom (Atom a) Set_impla;
set_impl_atom = Phantom Set_RBT;

instance Set_impl (Atom a) where {
  set_impl = set_impl_atom;
};

comparator_atom :: forall a. (a -> a -> Ordera) -> Atom a -> Atom a -> Ordera;
comparator_atom comp_a (Geq x xa) (Geq yb yc) = (case comparator_of x yb of {
          Eqa -> comp_a xa yc;
          Lt -> Lt;
          Gt -> Gt;
        });
comparator_atom comp_a (Geq x xa) (Leq y ya) = Gt;
comparator_atom comp_a (Leq x xa) (Geq yb yc) = Lt;
comparator_atom comp_a (Leq x xa) (Leq y ya) = (case comparator_of x y of {
         Eqa -> comp_a xa ya;
         Lt -> Lt;
         Gt -> Gt;
       });

ccompare_atom :: forall a. (Ccompare a) => Maybe (Atom a -> Atom a -> Ordera);
ccompare_atom = (case ccompare of {
                  Nothing -> Nothing;
                  Just comp_a -> Just (comparator_atom comp_a);
                });

instance (Ccompare a) => Ccompare (Atom a) where {
  ccompare = ccompare_atom;
};

data Sum a b = Inl a | Inr b;

equal_sum :: forall a b. (Eq a, Eq b) => Sum a b -> Sum a b -> Bool;
equal_sum (Inl x1) (Inr x2) = False;
equal_sum (Inr x2) (Inl x1) = False;
equal_sum (Inr x2) (Inr y2) = x2 == y2;
equal_sum (Inl x1) (Inl y1) = x1 == y1;

instance (Eq a, Eq b) => Eq (Sum a b) where {
  a == b = equal_sum a b;
};

showsl_sum :: forall a b. (Showl a, Showl b) => Sum a b -> String -> String;
showsl_sum (Inl x) = (showsl_lit "Inl (" . showsl x) . showsl_lit ")";
showsl_sum (Inr x) = (showsl_lit "Inr (" . showsl x) . showsl_lit ")";

showsl_list_sum ::
  forall a b. (Showl a, Showl b) => [Sum a b] -> String -> String;
showsl_list_sum xs = default_showsl_list showsl_sum xs;

instance (Showl a, Showl b) => Showl (Sum a b) where {
  showsl = showsl_sum;
  showsl_list = showsl_list_sum;
};

data Trans_var a = Pre a | Post a | Intermediate a;

equal_trans_var :: forall a. (Eq a) => Trans_var a -> Trans_var a -> Bool;
equal_trans_var (Post x2) (Intermediate x3) = False;
equal_trans_var (Intermediate x3) (Post x2) = False;
equal_trans_var (Pre x1) (Intermediate x3) = False;
equal_trans_var (Intermediate x3) (Pre x1) = False;
equal_trans_var (Pre x1) (Post x2) = False;
equal_trans_var (Post x2) (Pre x1) = False;
equal_trans_var (Intermediate x3) (Intermediate y3) = x3 == y3;
equal_trans_var (Post x2) (Post y2) = x2 == y2;
equal_trans_var (Pre x1) (Pre y1) = x1 == y1;

instance (Eq a) => Eq (Trans_var a) where {
  a == b = equal_trans_var a b;
};

comparator_trans_var ::
  forall a. (a -> a -> Ordera) -> Trans_var a -> Trans_var a -> Ordera;
comparator_trans_var comp_v (Intermediate x) (Intermediate yb) = comp_v x yb;
comparator_trans_var comp_v (Intermediate x) (Post ya) = Gt;
comparator_trans_var comp_v (Intermediate x) (Pre y) = Gt;
comparator_trans_var comp_v (Post x) (Intermediate yb) = Lt;
comparator_trans_var comp_v (Post x) (Post ya) = comp_v x ya;
comparator_trans_var comp_v (Post x) (Pre y) = Gt;
comparator_trans_var comp_v (Pre x) (Intermediate yb) = Lt;
comparator_trans_var comp_v (Pre x) (Post ya) = Lt;
comparator_trans_var comp_v (Pre x) (Pre y) = comp_v x y;

compare_trans_var ::
  forall a. (Compare a) => Trans_var a -> Trans_var a -> Ordera;
compare_trans_var = comparator_trans_var compare;

less_eq_trans_var ::
  forall a. (Compare a) => Trans_var a -> Trans_var a -> Bool;
less_eq_trans_var = le_of_comp compare_trans_var;

less_trans_var :: forall a. (Compare a) => Trans_var a -> Trans_var a -> Bool;
less_trans_var = lt_of_comp compare_trans_var;

instance (Compare a) => Ord (Trans_var a) where {
  less_eq = less_eq_trans_var;
  less = less_trans_var;
};

instance (Compare a) => Quasi_order (Trans_var a) where {
};

instance (Compare a) => Weak_order (Trans_var a) where {
};

instance (Compare a) => Preorder (Trans_var a) where {
};

instance (Compare a) => Order (Trans_var a) where {
};

instance (Compare a) => Linorder (Trans_var a) where {
};

showsl_trans_var :: forall a. (Showl a) => Trans_var a -> String -> String;
showsl_trans_var (Pre v) = showsl v;
showsl_trans_var (Post v) = showsl v . showsl_lit "\'";
showsl_trans_var (Intermediate v) = showsl v . showsl_lit "#";

showsl_list_trans_var ::
  forall a. (Showl a) => [Trans_var a] -> String -> String;
showsl_list_trans_var xs = default_showsl_list showsl_trans_var xs;

instance (Showl a) => Showl (Trans_var a) where {
  showsl = showsl_trans_var;
  showsl_list = showsl_list_trans_var;
};

ccompare_trans_var ::
  forall a. (Ccompare a) => Maybe (Trans_var a -> Trans_var a -> Ordera);
ccompare_trans_var = (case ccompare of {
                       Nothing -> Nothing;
                       Just comp_v -> Just (comparator_trans_var comp_v);
                     });

instance (Ccompare a) => Ccompare (Trans_var a) where {
  ccompare = ccompare_trans_var;
};

mapping_impl_trans_var :: forall a. Phantom (Trans_var a) Mapping_impla;
mapping_impl_trans_var = Phantom Mapping_RBT;

instance Mapping_impl (Trans_var a) where {
  mapping_impl = mapping_impl_trans_var;
};

data Lab a b = Lab (Lab a b) b | FunLab (Lab a b) [Lab a b] | UnLab a
  | Sharp (Lab a b);

instance (Eq a, Eq b) => Eq (Lab a b) where {
  a == b = equal_lab a b;
};

equal_lab :: forall a b. (Eq a, Eq b) => Lab a b -> Lab a b -> Bool;
equal_lab (UnLab x3) (Sharp x4) = False;
equal_lab (Sharp x4) (UnLab x3) = False;
equal_lab (FunLab x21 x22) (Sharp x4) = False;
equal_lab (Sharp x4) (FunLab x21 x22) = False;
equal_lab (FunLab x21 x22) (UnLab x3) = False;
equal_lab (UnLab x3) (FunLab x21 x22) = False;
equal_lab (Lab x11 x12) (Sharp x4) = False;
equal_lab (Sharp x4) (Lab x11 x12) = False;
equal_lab (Lab x11 x12) (UnLab x3) = False;
equal_lab (UnLab x3) (Lab x11 x12) = False;
equal_lab (Lab x11 x12) (FunLab x21 x22) = False;
equal_lab (FunLab x21 x22) (Lab x11 x12) = False;
equal_lab (Sharp x4) (Sharp y4) = equal_lab x4 y4;
equal_lab (UnLab x3) (UnLab y3) = x3 == y3;
equal_lab (FunLab x21 x22) (FunLab y21 y22) = equal_lab x21 y21 && x22 == y22;
equal_lab (Lab x11 x12) (Lab y11 y12) = equal_lab x11 y11 && x12 == y12;

default_lab :: forall a b. (Default a) => Lab a b;
default_lab = UnLab defaulta;

instance (Default a) => Default (Lab a b) where {
  defaulta = default_lab;
};

comparator_lab ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Lab a b -> Lab a b -> Ordera;
comparator_lab comp_f comp_l (Sharp x) (Sharp ye) =
  comparator_lab comp_f comp_l x ye;
comparator_lab comp_f comp_l (Sharp x) (UnLab yd) = Gt;
comparator_lab comp_f comp_l (Sharp x) (FunLab yb yc) = Gt;
comparator_lab comp_f comp_l (Sharp x) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (UnLab x) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (UnLab x) (UnLab yd) = comp_f x yd;
comparator_lab comp_f comp_l (UnLab x) (FunLab yb yc) = Gt;
comparator_lab comp_f comp_l (UnLab x) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (FunLab x xa) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (FunLab x xa) (UnLab yd) = Lt;
comparator_lab comp_f comp_l (FunLab x xa) (FunLab yb yc) =
  (case comparator_lab comp_f comp_l x yb of {
    Eqa -> comparator_list (comparator_lab comp_f comp_l) xa yc;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_lab comp_f comp_l (FunLab x xa) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (Lab x xa) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (UnLab yd) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (FunLab yb yc) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (Lab y ya) =
  (case comparator_lab comp_f comp_l x y of {
    Eqa -> comp_l xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });

compare_lab ::
  forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Ordera;
compare_lab = comparator_lab compare compare;

less_eq_lab :: forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Bool;
less_eq_lab = le_of_comp compare_lab;

less_lab :: forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Bool;
less_lab = lt_of_comp compare_lab;

instance (Compare a, Compare b) => Ord (Lab a b) where {
  less_eq = less_eq_lab;
  less = less_lab;
};

instance (Compare a, Compare b) => Compare (Lab a b) where {
  compare = compare_lab;
};

instance (Compare a, Compare b) => Quasi_order (Lab a b) where {
};

instance (Compare a, Compare b) => Weak_order (Lab a b) where {
};

instance (Compare a, Compare b) => Preorder (Lab a b) where {
};

instance (Compare a, Compare b) => Order (Lab a b) where {
};

ceq_lab :: forall a b. (Eq a, Eq b) => Maybe (Lab a b -> Lab a b -> Bool);
ceq_lab = Just equal_lab;

instance (Eq a, Eq b) => Ceq (Lab a b) where {
  ceq = ceq_lab;
};

set_impl_lab :: forall a b. Phantom (Lab a b) Set_impla;
set_impl_lab = Phantom Set_RBT;

instance Set_impl (Lab a b) where {
  set_impl = set_impl_lab;
};

instance (Compare a, Compare b) => Linorder (Lab a b) where {
};

showsl_lab :: forall a b. (Showl a, Showl b) => Lab a b -> String -> String;
showsl_lab (UnLab f) = showsl f;
showsl_lab (Lab f l) =
  ((showsl_lab f . showsl_lit "[") . showsl l) . showsl_lit "]";
showsl_lab (Sharp f) = showsl_lab f . showsl_lit "#";
showsl_lab (FunLab f l) =
  showsl_lab f . default_showsl_list id (map showsl_lab l);

showsl_list_lab ::
  forall a b. (Showl a, Showl b) => [Lab a b] -> String -> String;
showsl_list_lab xs = default_showsl_list showsl_lab xs;

instance (Showl a, Showl b) => Showl (Lab a b) where {
  showsl = showsl_lab;
  showsl_list = showsl_list_lab;
};

finite_UNIV_lab :: forall a b. Phantom (Lab a b) Bool;
finite_UNIV_lab = Phantom False;

card_UNIV_lab :: forall a b. Phantom (Lab a b) Nat;
card_UNIV_lab = Phantom zero_nat;

instance Finite_UNIV (Lab a b) where {
  finite_UNIV = finite_UNIV_lab;
};

instance Card_UNIV (Lab a b) where {
  card_UNIVa = card_UNIV_lab;
};

cEnum_lab ::
  forall a b.
    Maybe ([Lab a b], ((Lab a b -> Bool) -> Bool, (Lab a b -> Bool) -> Bool));
cEnum_lab = Nothing;

instance Cenum (Lab a b) where {
  cEnum = cEnum_lab;
};

instance (Compare a, Compare b) => Compare_order (Lab a b) where {
};

ccompare_lab ::
  forall a b. (Compare a, Compare b) => Maybe (Lab a b -> Lab a b -> Ordera);
ccompare_lab = Just compare_lab;

instance (Compare a, Compare b) => Ccompare (Lab a b) where {
  ccompare = ccompare_lab;
};

mapping_impl_lab :: forall a b. Phantom (Lab a b) Mapping_impla;
mapping_impl_lab = Phantom Mapping_RBT;

instance Mapping_impl (Lab a b) where {
  mapping_impl = mapping_impl_lab;
};

cproper_interval_lab ::
  forall a b.
    (Compare a, Compare b) => Maybe (Lab a b) -> Maybe (Lab a b) -> Bool;
cproper_interval_lab = (\ _ _ -> False);

instance (Compare a, Compare b) => Cproper_interval (Lab a b) where {
  cproper_interval = cproper_interval_lab;
};

equality_option :: forall a. (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool;
equality_option eq_a (Just x) (Just y) = eq_a x y;
equality_option eq_a (Just x) Nothing = False;
equality_option eq_a Nothing (Just y) = False;
equality_option eq_a Nothing Nothing = True;

ceq_option :: forall a. (Ceq a) => Maybe (Maybe a -> Maybe a -> Bool);
ceq_option = (case ceq of {
               Nothing -> Nothing;
               Just eq_a -> Just (equality_option eq_a);
             });

instance (Ceq a) => Ceq (Maybe a) where {
  ceq = ceq_option;
};

set_impl_option :: forall a. (Set_impl a) => Phantom (Maybe a) Set_impla;
set_impl_option = Phantom (of_phantom (set_impl :: Phantom a Set_impla));

instance (Set_impl a) => Set_impl (Maybe a) where {
  set_impl = set_impl_option;
};

cEnum_option ::
  forall a.
    (Cenum a) => Maybe ([Maybe a],
                         ((Maybe a -> Bool) -> Bool,
                           (Maybe a -> Bool) -> Bool));
cEnum_option =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (enum_all_a, enum_ex_a)) ->
      Just (Nothing : map Just enum_a,
             ((\ p -> p Nothing && enum_all_a (\ x -> p (Just x))),
               (\ p -> p Nothing || enum_ex_a (\ x -> p (Just x)))));
  });

instance (Cenum a) => Cenum (Maybe a) where {
  cEnum = cEnum_option;
};

finite_UNIV_option :: forall a. (Finite_UNIV a) => Phantom (Maybe a) Bool;
finite_UNIV_option = Phantom (of_phantom (finite_UNIV :: Phantom a Bool));

instance (Finite_UNIV a) => Finite_UNIV (Maybe a) where {
  finite_UNIV = finite_UNIV_option;
};

comparator_option ::
  forall a. (a -> a -> Ordera) -> Maybe a -> Maybe a -> Ordera;
comparator_option comp_a (Just x) (Just y) = comp_a x y;
comparator_option comp_a (Just x) Nothing = Gt;
comparator_option comp_a Nothing (Just y) = Lt;
comparator_option comp_a Nothing Nothing = Eqa;

ccompare_option ::
  forall a. (Ccompare a) => Maybe (Maybe a -> Maybe a -> Ordera);
ccompare_option = (case ccompare of {
                    Nothing -> Nothing;
                    Just comp_a -> Just (comparator_option comp_a);
                  });

instance (Ccompare a) => Ccompare (Maybe a) where {
  ccompare = ccompare_option;
};

mapping_impl_option ::
  forall a. (Mapping_impl a) => Phantom (Maybe a) Mapping_impla;
mapping_impl_option =
  Phantom (of_phantom (mapping_impl :: Phantom a Mapping_impla));

instance (Mapping_impl a) => Mapping_impl (Maybe a) where {
  mapping_impl = mapping_impl_option;
};

cproper_interval_option ::
  forall a. (Cproper_interval a) => Maybe (Maybe a) -> Maybe (Maybe a) -> Bool;
cproper_interval_option Nothing Nothing = True;
cproper_interval_option Nothing (Just x) = not (is_none x);
cproper_interval_option (Just x) Nothing = cproper_interval x Nothing;
cproper_interval_option (Just x) (Just Nothing) = False;
cproper_interval_option (Just x) (Just (Just y)) = cproper_interval x (Just y);

instance (Cproper_interval a) => Cproper_interval (Maybe a) where {
  cproper_interval = cproper_interval_option;
};

data QDelta = QDelta Rat Rat;

equal_QDelta :: QDelta -> QDelta -> Bool;
equal_QDelta (QDelta x1 x2) (QDelta y1 y2) = equal_rat x1 y1 && equal_rat x2 y2;

instance Eq QDelta where {
  a == b = equal_QDelta a b;
};

one_QDelta :: QDelta;
one_QDelta = QDelta one_rat zero_rat;

instance One QDelta where {
  onea = one_QDelta;
};

qdsnd :: QDelta -> Rat;
qdsnd (QDelta a b) = b;

qdfst :: QDelta -> Rat;
qdfst (QDelta a b) = a;

plus_QDelta :: QDelta -> QDelta -> QDelta;
plus_QDelta qd1 qd2 =
  QDelta (plus_rat (qdfst qd1) (qdfst qd2)) (plus_rat (qdsnd qd1) (qdsnd qd2));

instance Plus QDelta where {
  plus = plus_QDelta;
};

zero_QDelta :: QDelta;
zero_QDelta = QDelta zero_rat zero_rat;

instance Zero QDelta where {
  zerob = zero_QDelta;
};

minus_QDelta :: QDelta -> QDelta -> QDelta;
minus_QDelta qd1 qd2 =
  QDelta (minus_rat (qdfst qd1) (qdfst qd2))
    (minus_rat (qdsnd qd1) (qdsnd qd2));

instance Minus QDelta where {
  minus = minus_QDelta;
};

uminus_QDelta :: QDelta -> QDelta;
uminus_QDelta qd = QDelta (uminus_rat (qdfst qd)) (uminus_rat (qdsnd qd));

instance Uminus QDelta where {
  uminus = uminus_QDelta;
};

less_eq_QDelta :: QDelta -> QDelta -> Bool;
less_eq_QDelta qd1 qd2 =
  less_rat (qdfst qd1) (qdfst qd2) ||
    equal_rat (qdfst qd1) (qdfst qd2) && less_eq_rat (qdsnd qd1) (qdsnd qd2);

less_QDelta :: QDelta -> QDelta -> Bool;
less_QDelta qd1 qd2 =
  less_rat (qdfst qd1) (qdfst qd2) ||
    equal_rat (qdfst qd1) (qdfst qd2) && less_rat (qdsnd qd1) (qdsnd qd2);

instance Ord QDelta where {
  less_eq = less_eq_QDelta;
  less = less_QDelta;
};

instance Quasi_order QDelta where {
};

instance Weak_order QDelta where {
};

instance Preorder QDelta where {
};

instance Order QDelta where {
};

instance Semigroup_add QDelta where {
};

instance Cancel_semigroup_add QDelta where {
};

instance Monoid_add QDelta where {
};

instance Group_add QDelta where {
};

instance Linorder QDelta where {
};

instance Ab_semigroup_add QDelta where {
};

instance Cancel_ab_semigroup_add QDelta where {
};

instance Comm_monoid_add QDelta where {
};

instance Cancel_comm_monoid_add QDelta where {
};

instance Ab_group_add QDelta where {
};

scaleRat_QDelta :: Rat -> QDelta -> QDelta;
scaleRat_QDelta r qd = QDelta (times_rat r (qdfst qd)) (times_rat r (qdsnd qd));

class ScaleRat a where {
  scaleRat :: Rat -> a -> a;
};

class (Ab_group_add a, ScaleRat a) => Rational_vector a where {
};

class (Order a, Rational_vector a) => Ordered_rational_vector a where {
};

class (Ordered_ab_semigroup_add a, Linorder a,
        Ordered_rational_vector a) => Linordered_rational_vector a where {
};

class (One a, Linordered_rational_vector a) => Lrv a where {
};

instance ScaleRat QDelta where {
  scaleRat = scaleRat_QDelta;
};

instance Rational_vector QDelta where {
};

instance Ordered_rational_vector QDelta where {
};

instance Ordered_ab_semigroup_add QDelta where {
};

instance Linordered_rational_vector QDelta where {
};

instance Lrv QDelta where {
};

ccompare_QDelta :: Maybe (QDelta -> QDelta -> Ordera);
ccompare_QDelta = Just comparator_of;

instance Ccompare QDelta where {
  ccompare = ccompare_QDelta;
};

data Formula a = Atom a | NegAtom a | Conjunction [Formula a]
  | Disjunction [Formula a];

instance (Eq a) => Eq (Formula a) where {
  a == b = equal_formula a b;
};

equal_formula :: forall a. (Eq a) => Formula a -> Formula a -> Bool;
equal_formula (Conjunction x3) (Disjunction x4) = False;
equal_formula (Disjunction x4) (Conjunction x3) = False;
equal_formula (NegAtom x2) (Disjunction x4) = False;
equal_formula (Disjunction x4) (NegAtom x2) = False;
equal_formula (NegAtom x2) (Conjunction x3) = False;
equal_formula (Conjunction x3) (NegAtom x2) = False;
equal_formula (Atom x1) (Disjunction x4) = False;
equal_formula (Disjunction x4) (Atom x1) = False;
equal_formula (Atom x1) (Conjunction x3) = False;
equal_formula (Conjunction x3) (Atom x1) = False;
equal_formula (Atom x1) (NegAtom x2) = False;
equal_formula (NegAtom x2) (Atom x1) = False;
equal_formula (Disjunction x4) (Disjunction y4) = x4 == y4;
equal_formula (Conjunction x3) (Conjunction y3) = x3 == y3;
equal_formula (NegAtom x2) (NegAtom y2) = x2 == y2;
equal_formula (Atom x1) (Atom y1) = x1 == y1;

newtype Poly a = Poly [a];

coeffs :: forall a. (Zero a) => Poly a -> [a];
coeffs (Poly x) = x;

equal_poly :: forall a. (Zero a, Eq a) => Poly a -> Poly a -> Bool;
equal_poly p q = coeffs p == coeffs q;

instance (Zero a, Eq a) => Eq (Poly a) where {
  a == b = equal_poly a b;
};

zero_polya :: forall a. (Zero a) => Poly a;
zero_polya = Poly [];

cCons :: forall a. (Zero a, Eq a) => a -> [a] -> [a];
cCons x xs = (if null xs && x == zerob then [] else x : xs);

plus_coeffs :: forall a. (Comm_monoid_add a, Eq a) => [a] -> [a] -> [a];
plus_coeffs xs [] = xs;
plus_coeffs [] (v : va) = v : va;
plus_coeffs (x : xs) (y : ys) = cCons (plus x y) (plus_coeffs xs ys);

plus_poly :: forall a. (Comm_monoid_add a, Eq a) => Poly a -> Poly a -> Poly a;
plus_poly p q = Poly (plus_coeffs (coeffs p) (coeffs q));

foldr :: forall a b. (a -> b -> b) -> [a] -> b -> b;
foldr f [] = id;
foldr f (x : xs) = f x . foldr f xs;

fold_coeffs :: forall a b. (Zero a) => (a -> b -> b) -> Poly a -> b -> b;
fold_coeffs f p = foldr f (coeffs p);

smult ::
  forall a.
    (Eq a, Comm_semiring_0 a,
      Semiring_no_zero_divisors a) => a -> Poly a -> Poly a;
smult a p = Poly (if a == zerob then [] else map (times a) (coeffs p));

pCons :: forall a. (Zero a, Eq a) => a -> Poly a -> Poly a;
pCons a p = Poly (cCons a (coeffs p));

times_poly ::
  forall a.
    (Eq a, Comm_semiring_0 a,
      Semiring_no_zero_divisors a) => Poly a -> Poly a -> Poly a;
times_poly p q =
  fold_coeffs (\ a pa -> plus_poly (smult a q) (pCons zerob pa)) p zero_polya;

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Times (Poly a) where {
  times = times_poly;
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Dvd (Poly a) where {
};

one_polya :: forall a. (Comm_semiring_1 a) => Poly a;
one_polya = Poly [onea];

instance (Comm_semiring_1 a) => One (Poly a) where {
  onea = one_polya;
};

uminus_poly :: forall a. (Ab_group_add a) => Poly a -> Poly a;
uminus_poly p = Poly (map uminus (coeffs p));

minus_poly :: forall a. (Ab_group_add a, Eq a) => Poly a -> Poly a -> Poly a;
minus_poly p q = plus_poly p (uminus_poly q);

instance (Comm_monoid_add a, Eq a) => Plus (Poly a) where {
  plus = plus_poly;
};

instance (Comm_monoid_add a, Eq a) => Semigroup_add (Poly a) where {
};

instance (Cancel_comm_monoid_add a,
           Eq a) => Cancel_semigroup_add (Poly a) where {
};

instance (Comm_monoid_add a, Eq a) => Ab_semigroup_add (Poly a) where {
};

instance (Ab_group_add a, Eq a) => Minus (Poly a) where {
  minus = minus_poly;
};

instance (Ab_group_add a, Eq a) => Cancel_ab_semigroup_add (Poly a) where {
};

instance (Zero a) => Zero (Poly a) where {
  zerob = zero_polya;
};

instance (Comm_monoid_add a, Eq a) => Monoid_add (Poly a) where {
};

instance (Comm_monoid_add a, Eq a) => Comm_monoid_add (Poly a) where {
};

instance (Ab_group_add a, Eq a) => Cancel_comm_monoid_add (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Mult_zero (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Semigroup_mult (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Semiring (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Semiring_0 (Poly a) where {
};

instance (Ab_group_add a, Eq a, Comm_semiring_0_cancel a,
           Semiring_no_zero_divisors a) => Semiring_0_cancel (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Ab_semigroup_mult (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Comm_semiring (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Comm_semiring_0 (Poly a) where {
};

instance (Ab_group_add a, Eq a, Comm_semiring_0_cancel a,
           Semiring_no_zero_divisors a) => Comm_semiring_0_cancel (Poly
                            a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Power (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Monoid_mult (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a) => Numeral (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Semiring_numeral (Poly a) where {
};

instance (Comm_semiring_1 a) => Zero_neq_one (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Semiring_1 (Poly a) where {
};

instance (Eq a, Comm_ring_1 a,
           Semiring_no_zero_divisors a) => Semiring_1_cancel (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Comm_monoid_mult (Poly a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_no_zero_divisors a) => Comm_semiring_1 (Poly a) where {
};

instance (Eq a, Comm_ring_1 a,
           Semiring_no_zero_divisors a) => Comm_semiring_1_cancel (Poly
                            a) where {
};

instance (Eq a, Idom a) => Comm_semiring_1_cancel_crossproduct (Poly a) where {
};

instance (Eq a, Comm_semiring_0 a,
           Semiring_no_zero_divisors a) => Semiring_no_zero_divisors (Poly
                               a) where {
};

instance (Eq a, Comm_semiring_1 a,
           Semiring_1_no_zero_divisors a) => Semiring_1_no_zero_divisors (Poly
                                   a) where {
};

instance (Eq a, Idom a) => Semiring_no_zero_divisors_cancel (Poly a) where {
};

instance (Ab_group_add a) => Uminus (Poly a) where {
  uminus = uminus_poly;
};

instance (Ab_group_add a, Eq a) => Group_add (Poly a) where {
};

instance (Ab_group_add a, Eq a) => Ab_group_add (Poly a) where {
};

instance (Eq a, Comm_ring a,
           Semiring_no_zero_divisors a) => Ring (Poly a) where {
};

instance (Eq a, Idom a) => Ring_no_zero_divisors (Poly a) where {
};

instance (Eq a, Comm_ring_1 a) => Neg_numeral (Poly a) where {
};

instance (Eq a, Comm_ring_1 a,
           Semiring_no_zero_divisors a) => Ring_1 (Poly a) where {
};

instance (Eq a, Idom a) => Ring_1_no_zero_divisors (Poly a) where {
};

instance (Eq a, Comm_ring a,
           Semiring_no_zero_divisors a) => Comm_ring (Poly a) where {
};

instance (Eq a, Comm_ring_1 a,
           Semiring_no_zero_divisors a) => Comm_ring_1 (Poly a) where {
};

instance (Eq a, Idom a) => Semidom (Poly a) where {
};

instance (Eq a, Idom a) => Idom (Poly a) where {
};

minus_poly_rev_list :: forall a. (Group_add a) => [a] -> [a] -> [a];
minus_poly_rev_list (x : xs) (y : ys) = minus x y : minus_poly_rev_list xs ys;
minus_poly_rev_list xs [] = xs;
minus_poly_rev_list [] (y : ys) = [];

tla :: forall a. [a] -> [a];
tla [] = [];
tla (x21 : x22) = x22;

hda :: forall a. [a] -> a;
hda (x21 : x22) = x21;

divide_poly_main_list ::
  forall a. (Eq a, Idom_divide a) => a -> [a] -> [a] -> [a] -> Nat -> [a];
divide_poly_main_list lc q r d n =
  (if equal_nat n zero_nat then q
    else let {
           cr = hda r;
         } in (if cr == zerob
                then divide_poly_main_list lc (cCons cr q) (tla r) d
                       (minus_nat n one_nat)
                else let {
                       a = divide cr lc;
                       qq = cCons a q;
                       rr = minus_poly_rev_list r (map (times a) d);
                     } in (if hda rr == zerob
                            then divide_poly_main_list lc qq (tla rr) d
                                   (minus_nat n one_nat)
                            else [])));

strip_while :: forall a. (a -> Bool) -> [a] -> [a];
strip_while p = (reverse . dropWhile p) . reverse;

poly_of_list :: forall a. (Comm_monoid_add a, Eq a) => [a] -> Poly a;
poly_of_list asa = Poly (strip_while (\ a -> zerob == a) asa);

divide_poly_list ::
  forall a. (Eq a, Idom_divide a) => Poly a -> Poly a -> Poly a;
divide_poly_list f g =
  let {
    cg = coeffs g;
  } in (if null cg then g
         else let {
                cf = coeffs f;
                cgr = reverse cg;
              } in poly_of_list
                     (divide_poly_main_list (hda cgr) [] (reverse cf) cgr
                       (minus_nat (plus_nat one_nat (size_list cf))
                         (size_list cg))));

divide_poly :: forall a. (Eq a, Idom_divide a) => Poly a -> Poly a -> Poly a;
divide_poly f g = divide_poly_list f g;

instance (Eq a, Idom_divide a) => Divide (Poly a) where {
  divide = divide_poly;
};

instance (Eq a, Idom_divide a) => Semidom_divide (Poly a) where {
};

instance (Eq a, Idom_divide a) => Idom_divide (Poly a) where {
};

data Hints = Hints [Int] | Branch_and_Bound;

default_hints :: Hints;
default_hints = Branch_and_Bound;

instance Default Hints where {
  defaulta = default_hints;
};

showsl_hints :: Hints -> String -> String;
showsl_hints (Hints xs) =
  showsl_lit "Linear-Combination: " . showsl_list_int xs;
showsl_hints Branch_and_Bound = showsl_lit "Simplex";

showsl_list_hints :: [Hints] -> String -> String;
showsl_list_hints xs = default_showsl_list showsl_hints xs;

instance Showl Hints where {
  showsl = showsl_hints;
  showsl_list = showsl_list_hints;
};

map_of :: forall a b. (Eq a) => [(a, b)] -> a -> Maybe b;
map_of ((l, v) : ps) k = (if l == k then Just v else map_of ps k);
map_of [] k = Nothing;

count_of :: forall a. (Eq a) => [(a, Nat)] -> a -> Nat;
count_of xs x = (case map_of xs x of {
                  Nothing -> zero_nat;
                  Just n -> n;
                });

newtype Alist b a = Alist [(b, a)];

impl_ofa :: forall b a. Alist b a -> [(b, a)];
impl_ofa (Alist x) = x;

newtype Multiset a = Bag (Alist a Nat);

count :: forall a. (Eq a) => Multiset a -> a -> Nat;
count (Bag xs) = count_of (impl_ofa xs);

subseteq_mset :: forall a. (Eq a) => Multiset a -> Multiset a -> Bool;
subseteq_mset (Bag xs) a =
  all (\ (x, n) -> less_eq_nat n (count a x)) (impl_ofa xs);

equal_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Bool;
equal_multiset m1 m2 = subseteq_mset m1 m2 && subseteq_mset m2 m1;

instance (Eq a) => Eq (Multiset a) where {
  a == b = equal_multiset a b;
};

map_default :: forall a b. (Eq a) => a -> b -> (b -> b) -> [(a, b)] -> [(a, b)];
map_default k v f [] = [(k, v)];
map_default k v f (p : ps) =
  (if fst p == k then (k, f (snd p)) : ps else p : map_default k v f ps);

join_raw ::
  forall a b. (Eq a) => (a -> (b, b) -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
join_raw f xs ys =
  foldr (\ (k, v) -> map_default k v (\ va -> f k (va, v))) ys xs;

joina ::
  forall a b.
    (Eq a) => (a -> (b, b) -> b) -> Alist a b -> Alist a b -> Alist a b;
joina xc xd xe = Alist (join_raw xc (impl_ofa xd) (impl_ofa xe));

plus_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
plus_multiset (Bag xs) (Bag ys) =
  Bag (joina (\ _ (a, b) -> plus_nat a b) xs ys);

instance (Eq a) => Plus (Multiset a) where {
  plus = plus_multiset;
};

emptya :: forall a b. Alist a b;
emptya = Alist [];

zero_multiset :: forall a. Multiset a;
zero_multiset = Bag emptya;

instance Zero (Multiset a) where {
  zerob = zero_multiset;
};

instance (Eq a) => Semigroup_add (Multiset a) where {
};

instance (Eq a) => Monoid_add (Multiset a) where {
};

instance (Eq a) => Ab_semigroup_add (Multiset a) where {
};

instance (Eq a) => Comm_monoid_add (Multiset a) where {
};

newtype Monom a = Abs_monom [(a, Nat)];

rep_monom :: forall a. (Linorder a) => Monom a -> [(a, Nat)];
rep_monom (Abs_monom x) = x;

equal_monom :: forall a. (Eq a, Linorder a) => Monom a -> Monom a -> Bool;
equal_monom xa xc = rep_monom xa == rep_monom xc;

instance (Eq a, Linorder a) => Eq (Monom a) where {
  a == b = equal_monom a b;
};

less_eq_prod :: forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Bool;
less_eq_prod (x1, y1) (x2, y2) = less x1 x2 || less_eq x1 x2 && less_eq y1 y2;

less_prod :: forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Bool;
less_prod (x1, y1) (x2, y2) = less x1 x2 || less_eq x1 x2 && less y1 y2;

instance (Ord a, Ord b) => Ord (a, b) where {
  less_eq = less_eq_prod;
  less = less_prod;
};

comparator_prod ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> (a, b) -> (a, b) -> Ordera;
comparator_prod comp_a comp_b (x, xa) (y, ya) = (case comp_a x y of {
          Eqa -> comp_b xa ya;
          Lt -> Lt;
          Gt -> Gt;
        });

compare_prod ::
  forall a b. (Compare a, Compare b) => (a, b) -> (a, b) -> Ordera;
compare_prod = comparator_prod compare compare;

instance (Compare a, Compare b) => Compare (a, b) where {
  compare = compare_prod;
};

instance (Order a, Order b) => Quasi_order (a, b) where {
};

instance (Order a, Order b) => Weak_order (a, b) where {
};

instance (Preorder a, Preorder b) => Preorder (a, b) where {
};

instance (Order a, Order b) => Order (a, b) where {
};

equality_prod ::
  forall a b. (a -> a -> Bool) -> (b -> b -> Bool) -> (a, b) -> (a, b) -> Bool;
equality_prod eq_a eq_b (x, xa) (y, ya) = eq_a x y && eq_b xa ya;

ceq_prod :: forall a b. (Ceq a, Ceq b) => Maybe ((a, b) -> (a, b) -> Bool);
ceq_prod = (case ceq of {
             Nothing -> Nothing;
             Just eq_a -> (case ceq of {
                            Nothing -> Nothing;
                            Just eq_b -> Just (equality_prod eq_a eq_b);
                          });
           });

instance (Ceq a, Ceq b) => Ceq (a, b) where {
  ceq = ceq_prod;
};

set_impl_choose2 :: Set_impla -> Set_impla -> Set_impla;
set_impl_choose2 Set_Monada Set_Monada = Set_Monada;
set_impl_choose2 Set_RBT Set_RBT = Set_RBT;
set_impl_choose2 Set_DList Set_DList = Set_DList;
set_impl_choose2 Set_Collect Set_Collect = Set_Collect;
set_impl_choose2 x y = Set_Choose;

set_impl_prod ::
  forall a b. (Set_impl a, Set_impl b) => Phantom (a, b) Set_impla;
set_impl_prod =
  Phantom
    (set_impl_choose2 (of_phantom (set_impl :: Phantom a Set_impla))
      (of_phantom (set_impl :: Phantom b Set_impla)));

instance (Set_impl a, Set_impl b) => Set_impl (a, b) where {
  set_impl = set_impl_prod;
};

instance (Linorder a, Linorder b) => Linorder (a, b) where {
};

showsl_prod :: forall a b. (Showl a, Showl b) => (a, b) -> String -> String;
showsl_prod (x, y) =
  (((showsl_lit "(" . showsl x) . showsl_lit ", ") . showsl y) . showsl_lit ")";

showsl_list_prod ::
  forall a b. (Showl a, Showl b) => [(a, b)] -> String -> String;
showsl_list_prod xs = default_showsl_list showsl_prod xs;

instance (Showl a, Showl b) => Showl (a, b) where {
  showsl = showsl_prod;
  showsl_list = showsl_list_prod;
};

finite_UNIV_prod ::
  forall a b. (Finite_UNIV a, Finite_UNIV b) => Phantom (a, b) Bool;
finite_UNIV_prod =
  Phantom
    (of_phantom (finite_UNIV :: Phantom a Bool) &&
      of_phantom (finite_UNIV :: Phantom b Bool));

card_UNIV_prod :: forall a b. (Card_UNIV a, Card_UNIV b) => Phantom (a, b) Nat;
card_UNIV_prod =
  Phantom
    (times_nat (of_phantom (card_UNIVa :: Phantom a Nat))
      (of_phantom (card_UNIVa :: Phantom b Nat)));

instance (Finite_UNIV a, Finite_UNIV b) => Finite_UNIV (a, b) where {
  finite_UNIV = finite_UNIV_prod;
};

instance (Card_UNIV a, Card_UNIV b) => Card_UNIV (a, b) where {
  card_UNIVa = card_UNIV_prod;
};

product :: forall a b. [a] -> [b] -> [(a, b)];
product [] uu = [];
product (x : xs) ys = map (\ a -> (x, a)) ys ++ product xs ys;

cEnum_prod ::
  forall a b.
    (Cenum a,
      Cenum b) => Maybe ([(a, b)],
                          (((a, b) -> Bool) -> Bool, ((a, b) -> Bool) -> Bool));
cEnum_prod =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (enum_all_a, enum_ex_a)) ->
      (case cEnum of {
        Nothing -> Nothing;
        Just (enum_b, (enum_all_b, enum_ex_b)) ->
          Just (product enum_a enum_b,
                 ((\ p -> enum_all_a (\ x -> enum_all_b (\ y -> p (x, y)))),
                   (\ p -> enum_ex_a (\ x -> enum_ex_b (\ y -> p (x, y))))));
      });
  });

instance (Cenum a, Cenum b) => Cenum (a, b) where {
  cEnum = cEnum_prod;
};

instance (Compare_order a, Compare_order b) => Compare_order (a, b) where {
};

ccompare_prod ::
  forall a b. (Ccompare a, Ccompare b) => Maybe ((a, b) -> (a, b) -> Ordera);
ccompare_prod =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_a -> (case ccompare of {
                     Nothing -> Nothing;
                     Just comp_b -> Just (comparator_prod comp_a comp_b);
                   });
  });

instance (Ccompare a, Ccompare b) => Ccompare (a, b) where {
  ccompare = ccompare_prod;
};

mapping_impl_choose2 :: Mapping_impla -> Mapping_impla -> Mapping_impla;
mapping_impl_choose2 Mapping_RBT Mapping_RBT = Mapping_RBT;
mapping_impl_choose2 Mapping_Assoc_List Mapping_Assoc_List = Mapping_Assoc_List;
mapping_impl_choose2 Mapping_Mapping Mapping_Mapping = Mapping_Mapping;
mapping_impl_choose2 x y = Mapping_Choose;

mapping_impl_prod ::
  forall a b. (Mapping_impl a, Mapping_impl b) => Phantom (a, b) Mapping_impla;
mapping_impl_prod =
  Phantom
    (mapping_impl_choose2 (of_phantom (mapping_impl :: Phantom a Mapping_impla))
      (of_phantom (mapping_impl :: Phantom b Mapping_impla)));

instance (Mapping_impl a, Mapping_impl b) => Mapping_impl (a, b) where {
  mapping_impl = mapping_impl_prod;
};

cproper_interval_prod ::
  forall a b.
    (Cproper_interval a,
      Cproper_interval b) => Maybe (a, b) -> Maybe (a, b) -> Bool;
cproper_interval_prod Nothing Nothing = True;
cproper_interval_prod Nothing (Just (y1, y2)) =
  cproper_interval Nothing (Just y1) || cproper_interval Nothing (Just y2);
cproper_interval_prod (Just (x1, x2)) Nothing =
  cproper_interval (Just x1) Nothing || cproper_interval (Just x2) Nothing;
cproper_interval_prod (Just (x1, x2)) (Just (y1, y2)) =
  cproper_interval (Just x1) (Just y1) ||
    (lt_of_comp (the ccompare) x1 y1 &&
       (cproper_interval (Just x2) Nothing ||
         cproper_interval Nothing (Just y2)) ||
      not (lt_of_comp (the ccompare) y1 x1) &&
        cproper_interval (Just x2) (Just y2));

instance (Cproper_interval a,
           Cproper_interval b) => Cproper_interval (a, b) where {
  cproper_interval = cproper_interval_prod;
};

comparator_unit :: () -> () -> Ordera;
comparator_unit x y = Eqa;

compare_unit :: () -> () -> Ordera;
compare_unit = comparator_unit;

instance Compare () where {
  compare = compare_unit;
};

data Transition_rule a b c d =
  Transition d d (Formula (Term a (Trans_var b, c)));

equal_transition_rule ::
  forall a b c d.
    (Eq a, Eq b, Eq c,
      Eq d) => Transition_rule a b c d -> Transition_rule a b c d -> Bool;
equal_transition_rule (Transition x1 x2 x3) (Transition y1 y2 y3) =
  x1 == y1 && x2 == y2 && equal_formula x3 y3;

ceq_transition_rule ::
  forall a b c d.
    (Eq a, Eq b, Eq c,
      Eq d) => Maybe (Transition_rule a b c d ->
                       Transition_rule a b c d -> Bool);
ceq_transition_rule = Just equal_transition_rule;

instance (Eq a, Eq b, Eq c, Eq d) => Ceq (Transition_rule a b c d) where {
  ceq = ceq_transition_rule;
};

set_impl_transition_rule ::
  forall a b c d. Phantom (Transition_rule a b c d) Set_impla;
set_impl_transition_rule = Phantom Set_RBT;

instance Set_impl (Transition_rule a b c d) where {
  set_impl = set_impl_transition_rule;
};

comparator_formula ::
  forall a. (a -> a -> Ordera) -> Formula a -> Formula a -> Ordera;
comparator_formula comp_a (Disjunction x) (Disjunction yc) =
  comparator_list (comparator_formula comp_a) x yc;
comparator_formula comp_a (Disjunction x) (Conjunction yb) = Gt;
comparator_formula comp_a (Disjunction x) (NegAtom ya) = Gt;
comparator_formula comp_a (Disjunction x) (Atom y) = Gt;
comparator_formula comp_a (Conjunction x) (Disjunction yc) = Lt;
comparator_formula comp_a (Conjunction x) (Conjunction yb) =
  comparator_list (comparator_formula comp_a) x yb;
comparator_formula comp_a (Conjunction x) (NegAtom ya) = Gt;
comparator_formula comp_a (Conjunction x) (Atom y) = Gt;
comparator_formula comp_a (NegAtom x) (Disjunction yc) = Lt;
comparator_formula comp_a (NegAtom x) (Conjunction yb) = Lt;
comparator_formula comp_a (NegAtom x) (NegAtom ya) = comp_a x ya;
comparator_formula comp_a (NegAtom x) (Atom y) = Gt;
comparator_formula comp_a (Atom x) (Disjunction yc) = Lt;
comparator_formula comp_a (Atom x) (Conjunction yb) = Lt;
comparator_formula comp_a (Atom x) (NegAtom ya) = Lt;
comparator_formula comp_a (Atom x) (Atom y) = comp_a x y;

comparator_transition_rule ::
  forall a b c d.
    (a -> a -> Ordera) ->
      (b -> b -> Ordera) ->
        (c -> c -> Ordera) ->
          (d -> d -> Ordera) ->
            Transition_rule a b c d -> Transition_rule a b c d -> Ordera;
comparator_transition_rule comp_f comp_v comp_t comp_l (Transition x xa xb)
  (Transition y ya yb) =
  (case comp_l x y of {
    Eqa ->
      (case comp_l xa ya of {
        Eqa ->
          comparator_formula
            (comparator_term comp_f
              (comparator_prod (comparator_trans_var comp_v) comp_t))
            xb yb;
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });

ccompare_transition_rule ::
  forall a b c d.
    (Ccompare a, Ccompare b, Ccompare c,
      Ccompare d) => Maybe (Transition_rule a b c d ->
                             Transition_rule a b c d -> Ordera);
ccompare_transition_rule =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_f ->
      (case ccompare of {
        Nothing -> Nothing;
        Just comp_v ->
          (case ccompare of {
            Nothing -> Nothing;
            Just comp_t ->
              (case ccompare of {
                Nothing -> Nothing;
                Just comp_l ->
                  Just (comparator_transition_rule comp_f comp_v comp_t comp_l);
              });
          });
      });
  });

instance (Ccompare a, Ccompare b, Ccompare c,
           Ccompare d) => Ccompare (Transition_rule a b c d) where {
  ccompare = ccompare_transition_rule;
};

data Gctxt a b = GCHole | GCFun a [Gctxt a b];

instance (Eq a) => Eq (Gctxt a b) where {
  a == b = equal_gctxt a b;
};

equal_gctxt :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Bool;
equal_gctxt GCHole (GCFun x21 x22) = False;
equal_gctxt (GCFun x21 x22) GCHole = False;
equal_gctxt (GCFun x21 x22) (GCFun y21 y22) = x21 == y21 && x22 == y22;
equal_gctxt GCHole GCHole = True;

ceq_gctxt :: forall a b. (Eq a) => Maybe (Gctxt a b -> Gctxt a b -> Bool);
ceq_gctxt = Just equal_gctxt;

instance (Eq a) => Ceq (Gctxt a b) where {
  ceq = ceq_gctxt;
};

set_impl_gctxt :: forall a b. Phantom (Gctxt a b) Set_impla;
set_impl_gctxt = Phantom Set_RBT;

instance Set_impl (Gctxt a b) where {
  set_impl = set_impl_gctxt;
};

comparator_gctxt ::
  forall a b. (a -> a -> Ordera) -> Gctxt a b -> Gctxt a b -> Ordera;
comparator_gctxt comp_f (GCFun x xa) (GCFun y ya) =
  (case comp_f x y of {
    Eqa -> comparator_list (comparator_gctxt comp_f) xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_gctxt comp_f (GCFun x xa) GCHole = Gt;
comparator_gctxt comp_f GCHole (GCFun y ya) = Lt;
comparator_gctxt comp_f GCHole GCHole = Eqa;

compare_gctxt :: forall a b. (Compare a) => Gctxt a b -> Gctxt a b -> Ordera;
compare_gctxt = comparator_gctxt compare;

ccompare_gctxt ::
  forall a b.
    (Compare a, Compare b) => Maybe (Gctxt a b -> Gctxt a b -> Ordera);
ccompare_gctxt = Just compare_gctxt;

instance (Compare a, Compare b) => Ccompare (Gctxt a b) where {
  ccompare = ccompare_gctxt;
};

data Acterm a b = AVar b | AFun a [Acterm a b] | AAC a (Multiset (Acterm a b));

instance (Eq a, Eq b) => Eq (Acterm a b) where {
  a == b = equal_acterm a b;
};

equal_acterm :: forall a b. (Eq a, Eq b) => Acterm a b -> Acterm a b -> Bool;
equal_acterm (AFun x21 x22) (AAC x31 x32) = False;
equal_acterm (AAC x31 x32) (AFun x21 x22) = False;
equal_acterm (AVar x1) (AAC x31 x32) = False;
equal_acterm (AAC x31 x32) (AVar x1) = False;
equal_acterm (AVar x1) (AFun x21 x22) = False;
equal_acterm (AFun x21 x22) (AVar x1) = False;
equal_acterm (AAC x31 x32) (AAC y31 y32) = x31 == y31 && equal_multiset x32 y32;
equal_acterm (AFun x21 x22) (AFun y21 y22) = x21 == y21 && x22 == y22;
equal_acterm (AVar x1) (AVar y1) = x1 == y1;

data Ta_rule a b = TA_rule b [a] a;

equal_ta_rule :: forall a b. (Eq a, Eq b) => Ta_rule a b -> Ta_rule a b -> Bool;
equal_ta_rule (TA_rule x1 x2 x3) (TA_rule y1 y2 y3) =
  x1 == y1 && x2 == y2 && x3 == y3;

instance (Eq a, Eq b) => Eq (Ta_rule a b) where {
  a == b = equal_ta_rule a b;
};

comparator_ta_rule ::
  forall a b.
    (a -> a -> Ordera) ->
      (b -> b -> Ordera) -> Ta_rule a b -> Ta_rule a b -> Ordera;
comparator_ta_rule comp_q comp_f (TA_rule x xa xb) (TA_rule y ya yb) =
  (case comp_f x y of {
    Eqa -> (case comparator_list comp_q xa ya of {
             Eqa -> comp_q xb yb;
             Lt -> Lt;
             Gt -> Gt;
           });
    Lt -> Lt;
    Gt -> Gt;
  });

compare_ta_rule ::
  forall a b. (Compare a, Compare b) => Ta_rule a b -> Ta_rule a b -> Ordera;
compare_ta_rule = comparator_ta_rule compare compare;

less_eq_ta_rule ::
  forall a b. (Compare a, Compare b) => Ta_rule a b -> Ta_rule a b -> Bool;
less_eq_ta_rule = le_of_comp compare_ta_rule;

less_ta_rule ::
  forall a b. (Compare a, Compare b) => Ta_rule a b -> Ta_rule a b -> Bool;
less_ta_rule = lt_of_comp compare_ta_rule;

instance (Compare a, Compare b) => Ord (Ta_rule a b) where {
  less_eq = less_eq_ta_rule;
  less = less_ta_rule;
};

instance (Compare a, Compare b) => Quasi_order (Ta_rule a b) where {
};

instance (Compare a, Compare b) => Weak_order (Ta_rule a b) where {
};

instance (Compare a, Compare b) => Preorder (Ta_rule a b) where {
};

instance (Compare a, Compare b) => Order (Ta_rule a b) where {
};

ceq_ta_rule ::
  forall a b. (Eq a, Eq b) => Maybe (Ta_rule a b -> Ta_rule a b -> Bool);
ceq_ta_rule = Just equal_ta_rule;

instance (Eq a, Eq b) => Ceq (Ta_rule a b) where {
  ceq = ceq_ta_rule;
};

set_impl_ta_rule :: forall a b. Phantom (Ta_rule a b) Set_impla;
set_impl_ta_rule = Phantom Set_RBT;

instance Set_impl (Ta_rule a b) where {
  set_impl = set_impl_ta_rule;
};

instance (Compare a, Compare b) => Linorder (Ta_rule a b) where {
};

showsl_ta_rule ::
  forall a b. (Showl a, Showl b) => Ta_rule a b -> String -> String;
showsl_ta_rule (TA_rule f qs q) =
  ((showsl f . showsl_list qs) . showsl_lit " -> ") . showsl q;

showsl_list_ta_rule ::
  forall a b. (Showl a, Showl b) => [Ta_rule a b] -> String -> String;
showsl_list_ta_rule xs = default_showsl_list showsl_ta_rule xs;

instance (Showl a, Showl b) => Showl (Ta_rule a b) where {
  showsl = showsl_ta_rule;
  showsl_list = showsl_list_ta_rule;
};

cEnum_ta_rule ::
  forall a b.
    Maybe ([Ta_rule a b],
            ((Ta_rule a b -> Bool) -> Bool, (Ta_rule a b -> Bool) -> Bool));
cEnum_ta_rule = Nothing;

instance Cenum (Ta_rule a b) where {
  cEnum = cEnum_ta_rule;
};

finite_UNIV_ta_rule :: forall a b. Phantom (Ta_rule a b) Bool;
finite_UNIV_ta_rule = Phantom False;

instance Finite_UNIV (Ta_rule a b) where {
  finite_UNIV = finite_UNIV_ta_rule;
};

ccompare_ta_rule ::
  forall a b.
    (Ccompare a, Ccompare b) => Maybe (Ta_rule a b -> Ta_rule a b -> Ordera);
ccompare_ta_rule =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_q -> (case ccompare of {
                     Nothing -> Nothing;
                     Just comp_f -> Just (comparator_ta_rule comp_q comp_f);
                   });
  });

instance (Ccompare a, Ccompare b) => Ccompare (Ta_rule a b) where {
  ccompare = ccompare_ta_rule;
};

cproper_interval_ta_rule ::
  forall a b.
    (Ccompare a,
      Ccompare b) => Maybe (Ta_rule a b) -> Maybe (Ta_rule a b) -> Bool;
cproper_interval_ta_rule = (\ _ _ -> False);

instance (Ccompare a, Ccompare b) => Cproper_interval (Ta_rule a b) where {
  cproper_interval = cproper_interval_ta_rule;
};

data Mctxt a b = MVar b | MHole | MFun a [Mctxt a b];

instance (Eq a, Eq b) => Eq (Mctxt a b) where {
  a == b = equal_mctxt a b;
};

equal_mctxt :: forall a b. (Eq a, Eq b) => Mctxt a b -> Mctxt a b -> Bool;
equal_mctxt MHole (MFun x31 x32) = False;
equal_mctxt (MFun x31 x32) MHole = False;
equal_mctxt (MVar x1) (MFun x31 x32) = False;
equal_mctxt (MFun x31 x32) (MVar x1) = False;
equal_mctxt (MVar x1) MHole = False;
equal_mctxt MHole (MVar x1) = False;
equal_mctxt (MFun x31 x32) (MFun y31 y32) = x31 == y31 && x32 == y32;
equal_mctxt (MVar x1) (MVar y1) = x1 == y1;
equal_mctxt MHole MHole = True;

ceq_mctxt :: forall a b. (Eq a, Eq b) => Maybe (Mctxt a b -> Mctxt a b -> Bool);
ceq_mctxt = Just equal_mctxt;

instance (Eq a, Eq b) => Ceq (Mctxt a b) where {
  ceq = ceq_mctxt;
};

set_impl_mctxt :: forall a b. Phantom (Mctxt a b) Set_impla;
set_impl_mctxt = Phantom Set_RBT;

instance Set_impl (Mctxt a b) where {
  set_impl = set_impl_mctxt;
};

comparator_mctxt ::
  forall a b.
    (a -> a -> Ordera) ->
      (b -> b -> Ordera) -> Mctxt a b -> Mctxt a b -> Ordera;
comparator_mctxt comp_f comp_v (MFun x xa) (MFun ya yb) =
  (case comp_f x ya of {
    Eqa -> comparator_list (comparator_mctxt comp_f comp_v) xa yb;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_mctxt comp_f comp_v (MFun x xa) MHole = Gt;
comparator_mctxt comp_f comp_v (MFun x xa) (MVar y) = Gt;
comparator_mctxt comp_f comp_v MHole (MFun ya yb) = Lt;
comparator_mctxt comp_f comp_v MHole MHole = Eqa;
comparator_mctxt comp_f comp_v MHole (MVar y) = Gt;
comparator_mctxt comp_f comp_v (MVar x) (MFun ya yb) = Lt;
comparator_mctxt comp_f comp_v (MVar x) MHole = Lt;
comparator_mctxt comp_f comp_v (MVar x) (MVar y) = comp_v x y;

compare_mctxt ::
  forall a b. (Compare a, Compare b) => Mctxt a b -> Mctxt a b -> Ordera;
compare_mctxt = comparator_mctxt compare compare;

ccompare_mctxt ::
  forall a b.
    (Compare a, Compare b) => Maybe (Mctxt a b -> Mctxt a b -> Ordera);
ccompare_mctxt = Just compare_mctxt;

instance (Compare a, Compare b) => Ccompare (Mctxt a b) where {
  ccompare = ccompare_mctxt;
};

data Arctic = MinInfty | Num_arc Int;

equal_arctic :: Arctic -> Arctic -> Bool;
equal_arctic MinInfty (Num_arc x2) = False;
equal_arctic (Num_arc x2) MinInfty = False;
equal_arctic (Num_arc x2) (Num_arc y2) = equal_int x2 y2;
equal_arctic MinInfty MinInfty = True;

instance Eq Arctic where {
  a == b = equal_arctic a b;
};

one_arctic :: Arctic;
one_arctic = Num_arc zero_int;

instance One Arctic where {
  onea = one_arctic;
};

plus_arctic :: Arctic -> Arctic -> Arctic;
plus_arctic MinInfty y = y;
plus_arctic (Num_arc v) MinInfty = Num_arc v;
plus_arctic (Num_arc x) (Num_arc y) = Num_arc (max x y);

instance Plus Arctic where {
  plus = plus_arctic;
};

zero_arctic :: Arctic;
zero_arctic = MinInfty;

instance Zero Arctic where {
  zerob = zero_arctic;
};

instance Semigroup_add Arctic where {
};

instance Numeral Arctic where {
};

times_arctic :: Arctic -> Arctic -> Arctic;
times_arctic MinInfty y = MinInfty;
times_arctic (Num_arc v) MinInfty = MinInfty;
times_arctic (Num_arc x) (Num_arc y) = Num_arc (plus_int x y);

instance Times Arctic where {
  times = times_arctic;
};

instance Power Arctic where {
};

less_eq_arctic :: Arctic -> Arctic -> Bool;
less_eq_arctic MinInfty x = True;
less_eq_arctic (Num_arc uu) MinInfty = False;
less_eq_arctic (Num_arc y) (Num_arc x) = less_eq_int y x;

less_arctic :: Arctic -> Arctic -> Bool;
less_arctic MinInfty x = True;
less_arctic (Num_arc uu) MinInfty = False;
less_arctic (Num_arc y) (Num_arc x) = less_int y x;

instance Ord Arctic where {
  less_eq = less_eq_arctic;
  less = less_arctic;
};

instance Ab_semigroup_add Arctic where {
};

instance Semigroup_mult Arctic where {
};

instance Semiring Arctic where {
};

instance Mult_zero Arctic where {
};

instance Monoid_add Arctic where {
};

instance Comm_monoid_add Arctic where {
};

instance Semiring_0 Arctic where {
};

instance Monoid_mult Arctic where {
};

instance Semiring_numeral Arctic where {
};

instance Zero_neq_one Arctic where {
};

instance Semiring_1 Arctic where {
};

ceq_arctic :: Maybe (Arctic -> Arctic -> Bool);
ceq_arctic = Just equal_arctic;

instance Ceq Arctic where {
  ceq = ceq_arctic;
};

set_impl_arctic :: Phantom Arctic Set_impla;
set_impl_arctic = Phantom Set_RBT;

instance Set_impl Arctic where {
  set_impl = set_impl_arctic;
};

showsl_arctic :: Arctic -> String -> String;
showsl_arctic MinInfty = showsl_lit "-infinity";
showsl_arctic (Num_arc i) = showsl_int i;

showsl_list_arctic :: [Arctic] -> String -> String;
showsl_list_arctic xs = default_showsl_list showsl_arctic xs;

instance Showl Arctic where {
  showsl = showsl_arctic;
  showsl_list = showsl_list_arctic;
};

cEnum_arctic ::
  Maybe ([Arctic], ((Arctic -> Bool) -> Bool, (Arctic -> Bool) -> Bool));
cEnum_arctic = Nothing;

instance Cenum Arctic where {
  cEnum = cEnum_arctic;
};

comparator_arctic :: Arctic -> Arctic -> Ordera;
comparator_arctic (Num_arc x) (Num_arc y) = comparator_of x y;
comparator_arctic (Num_arc x) MinInfty = Gt;
comparator_arctic MinInfty (Num_arc y) = Lt;
comparator_arctic MinInfty MinInfty = Eqa;

compare_arctic :: Arctic -> Arctic -> Ordera;
compare_arctic = comparator_arctic;

ccompare_arctic :: Maybe (Arctic -> Arctic -> Ordera);
ccompare_arctic = Just compare_arctic;

instance Ccompare Arctic where {
  ccompare = ccompare_arctic;
};

instance Non_strict_order Arctic where {
};

instance Ordered_ab_semigroup Arctic where {
};

instance Ordered_semiring_0a Arctic where {
};

instance Ordered_semiring_1 Arctic where {
};

data Filtered a = FPair a Nat;

equal_filtered :: forall a. (Eq a) => Filtered a -> Filtered a -> Bool;
equal_filtered (FPair x1 x2) (FPair y1 y2) = x1 == y1 && equal_nat x2 y2;

instance (Eq a) => Eq (Filtered a) where {
  a == b = equal_filtered a b;
};

comparator_filtered ::
  forall a. (a -> a -> Ordera) -> Filtered a -> Filtered a -> Ordera;
comparator_filtered comp_f (FPair x xa) (FPair y ya) =
  (case comp_f x y of {
    Eqa -> comparator_of xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });

compare_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Ordera;
compare_filtered = comparator_filtered compare;

less_eq_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Bool;
less_eq_filtered = le_of_comp compare_filtered;

less_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Bool;
less_filtered = lt_of_comp compare_filtered;

instance (Compare a) => Ord (Filtered a) where {
  less_eq = less_eq_filtered;
  less = less_filtered;
};

instance (Compare a) => Compare (Filtered a) where {
  compare = compare_filtered;
};

instance (Compare a) => Quasi_order (Filtered a) where {
};

instance (Compare a) => Weak_order (Filtered a) where {
};

instance (Compare a) => Preorder (Filtered a) where {
};

instance (Compare a) => Order (Filtered a) where {
};

equality_filtered ::
  forall a. (a -> a -> Bool) -> Filtered a -> Filtered a -> Bool;
equality_filtered eq_f (FPair x xa) (FPair y ya) = eq_f x y && equal_nat xa ya;

ceq_filtered :: forall a. (Ceq a) => Maybe (Filtered a -> Filtered a -> Bool);
ceq_filtered = (case ceq of {
                 Nothing -> Nothing;
                 Just eq_f -> Just (equality_filtered eq_f);
               });

instance (Ceq a) => Ceq (Filtered a) where {
  ceq = ceq_filtered;
};

set_impl_filtered :: forall a. (Set_impl a) => Phantom (Filtered a) Set_impla;
set_impl_filtered = Phantom (of_phantom (set_impl :: Phantom a Set_impla));

instance (Set_impl a) => Set_impl (Filtered a) where {
  set_impl = set_impl_filtered;
};

instance (Compare a) => Linorder (Filtered a) where {
};

filtered_fun :: forall a. Filtered a -> a;
filtered_fun (FPair f n) = f;

showsl_filtered :: forall a. (Showl a) => Filtered a -> String -> String;
showsl_filtered f = showsl (filtered_fun f);

showsl_list_filtered :: forall a. (Showl a) => [Filtered a] -> String -> String;
showsl_list_filtered xs = default_showsl_list showsl_filtered xs;

instance (Showl a) => Showl (Filtered a) where {
  showsl = showsl_filtered;
  showsl_list = showsl_list_filtered;
};

instance (Compare a) => Compare_order (Filtered a) where {
};

ccompare_filtered ::
  forall a. (Ccompare a) => Maybe (Filtered a -> Filtered a -> Ordera);
ccompare_filtered = (case ccompare of {
                      Nothing -> Nothing;
                      Just comp_f -> Just (comparator_filtered comp_f);
                    });

instance (Ccompare a) => Ccompare (Filtered a) where {
  ccompare = ccompare_filtered;
};

data L_poly a b = LPoly b [(a, b)];

cEnum_l_poly ::
  forall a b.
    Maybe ([L_poly a b],
            ((L_poly a b -> Bool) -> Bool, (L_poly a b -> Bool) -> Bool));
cEnum_l_poly = Nothing;

instance Cenum (L_poly a b) where {
  cEnum = cEnum_l_poly;
};

data Ctxt a b = Hole | More a [Term a b] (Ctxt a b) [Term a b];

equal_ctxt :: forall a b. (Eq a, Eq b) => Ctxt a b -> Ctxt a b -> Bool;
equal_ctxt Hole (More x21 x22 x23 x24) = False;
equal_ctxt (More x21 x22 x23 x24) Hole = False;
equal_ctxt (More x21 x22 x23 x24) (More y21 y22 y23 y24) =
  x21 == y21 && x22 == y22 && equal_ctxt x23 y23 && x24 == y24;
equal_ctxt Hole Hole = True;

instance (Eq a, Eq b) => Eq (Ctxt a b) where {
  a == b = equal_ctxt a b;
};

ceq_ctxt :: forall a b. (Eq a, Eq b) => Maybe (Ctxt a b -> Ctxt a b -> Bool);
ceq_ctxt = Just equal_ctxt;

instance (Eq a, Eq b) => Ceq (Ctxt a b) where {
  ceq = ceq_ctxt;
};

set_impl_ctxt :: forall a b. Phantom (Ctxt a b) Set_impla;
set_impl_ctxt = Phantom Set_RBT;

instance Set_impl (Ctxt a b) where {
  set_impl = set_impl_ctxt;
};

comparator_ctxt ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Ctxt a b -> Ctxt a b -> Ordera;
comparator_ctxt comp_f comp_v (More x xa xb xc) (More y ya yb yc) =
  (case comp_f x y of {
    Eqa ->
      (case comparator_list (comparator_term comp_f comp_v) xa ya of {
        Eqa -> (case comparator_ctxt comp_f comp_v xb yb of {
                 Eqa -> comparator_list (comparator_term comp_f comp_v) xc yc;
                 Lt -> Lt;
                 Gt -> Gt;
               });
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_ctxt comp_f comp_v (More x xa xb xc) Hole = Gt;
comparator_ctxt comp_f comp_v Hole (More y ya yb yc) = Lt;
comparator_ctxt comp_f comp_v Hole Hole = Eqa;

compare_ctxt ::
  forall a b. (Compare a, Compare b) => Ctxt a b -> Ctxt a b -> Ordera;
compare_ctxt = comparator_ctxt compare compare;

ccompare_ctxt ::
  forall a b. (Compare a, Compare b) => Maybe (Ctxt a b -> Ctxt a b -> Ordera);
ccompare_ctxt = Just compare_ctxt;

instance (Compare a, Compare b) => Ccompare (Ctxt a b) where {
  ccompare = ccompare_ctxt;
};

data Sharp a = Flat a | Sharpa a;

equal_sharp :: forall a. (Eq a) => Sharp a -> Sharp a -> Bool;
equal_sharp (Flat x1) (Sharpa x2) = False;
equal_sharp (Sharpa x2) (Flat x1) = False;
equal_sharp (Sharpa x2) (Sharpa y2) = x2 == y2;
equal_sharp (Flat x1) (Flat y1) = x1 == y1;

instance (Eq a) => Eq (Sharp a) where {
  a == b = equal_sharp a b;
};

comparator_sharp ::
  forall a. (a -> a -> Ordera) -> Sharp a -> Sharp a -> Ordera;
comparator_sharp comp_l (Sharpa x) (Sharpa ya) = comp_l x ya;
comparator_sharp comp_l (Sharpa x) (Flat y) = Gt;
comparator_sharp comp_l (Flat x) (Sharpa ya) = Lt;
comparator_sharp comp_l (Flat x) (Flat y) = comp_l x y;

compare_sharp :: forall a. (Compare a) => Sharp a -> Sharp a -> Ordera;
compare_sharp = comparator_sharp compare;

less_eq_sharp :: forall a. (Compare a) => Sharp a -> Sharp a -> Bool;
less_eq_sharp = le_of_comp compare_sharp;

less_sharp :: forall a. (Compare a) => Sharp a -> Sharp a -> Bool;
less_sharp = lt_of_comp compare_sharp;

instance (Compare a) => Ord (Sharp a) where {
  less_eq = less_eq_sharp;
  less = less_sharp;
};

instance (Compare a) => Compare (Sharp a) where {
  compare = compare_sharp;
};

instance (Compare a) => Quasi_order (Sharp a) where {
};

instance (Compare a) => Weak_order (Sharp a) where {
};

instance (Compare a) => Preorder (Sharp a) where {
};

instance (Compare a) => Order (Sharp a) where {
};

ceq_sharp :: forall a. (Eq a) => Maybe (Sharp a -> Sharp a -> Bool);
ceq_sharp = Just equal_sharp;

instance (Eq a) => Ceq (Sharp a) where {
  ceq = ceq_sharp;
};

set_impl_sharp :: forall a. Phantom (Sharp a) Set_impla;
set_impl_sharp = Phantom Set_RBT;

instance Set_impl (Sharp a) where {
  set_impl = set_impl_sharp;
};

instance (Compare a) => Linorder (Sharp a) where {
};

showsl_sharp :: forall a. (Showl a) => Sharp a -> String -> String;
showsl_sharp (Flat s) = showsl s;
showsl_sharp (Sharpa s) = showsl_lit "#" . showsl s;

showsl_list_sharp :: forall a. (Showl a) => [Sharp a] -> String -> String;
showsl_list_sharp xs = default_showsl_list showsl_sharp xs;

instance (Showl a) => Showl (Sharp a) where {
  showsl = showsl_sharp;
  showsl_list = showsl_list_sharp;
};

cEnum_sharp ::
  forall a.
    Maybe ([Sharp a], ((Sharp a -> Bool) -> Bool, (Sharp a -> Bool) -> Bool));
cEnum_sharp = Nothing;

instance Cenum (Sharp a) where {
  cEnum = cEnum_sharp;
};

instance (Compare a) => Compare_order (Sharp a) where {
};

ccompare_sharp ::
  forall a. (Ccompare a) => Maybe (Sharp a -> Sharp a -> Ordera);
ccompare_sharp = (case ccompare of {
                   Nothing -> Nothing;
                   Just comp_l -> Just (comparator_sharp comp_l);
                 });

instance (Ccompare a) => Ccompare (Sharp a) where {
  ccompare = ccompare_sharp;
};

mapping_impl_sharp :: forall a. Phantom (Sharp a) Mapping_impla;
mapping_impl_sharp = Phantom Mapping_RBT;

instance Mapping_impl (Sharp a) where {
  mapping_impl = mapping_impl_sharp;
};

data Location = H | A | Ba | Ra;

equal_location :: Location -> Location -> Bool;
equal_location Ba Ra = False;
equal_location Ra Ba = False;
equal_location A Ra = False;
equal_location Ra A = False;
equal_location A Ba = False;
equal_location Ba A = False;
equal_location H Ra = False;
equal_location Ra H = False;
equal_location H Ba = False;
equal_location Ba H = False;
equal_location H A = False;
equal_location A H = False;
equal_location Ra Ra = True;
equal_location Ba Ba = True;
equal_location A A = True;
equal_location H H = True;

instance Eq Location where {
  a == b = equal_location a b;
};

ceq_location :: Maybe (Location -> Location -> Bool);
ceq_location = Just equal_location;

instance Ceq Location where {
  ceq = ceq_location;
};

set_impl_location :: Phantom Location Set_impla;
set_impl_location = Phantom Set_RBT;

instance Set_impl Location where {
  set_impl = set_impl_location;
};

comparator_location :: Location -> Location -> Ordera;
comparator_location Ra Ra = Eqa;
comparator_location Ra Ba = Gt;
comparator_location Ra A = Gt;
comparator_location Ra H = Gt;
comparator_location Ba Ra = Lt;
comparator_location Ba Ba = Eqa;
comparator_location Ba A = Gt;
comparator_location Ba H = Gt;
comparator_location A Ra = Lt;
comparator_location A Ba = Lt;
comparator_location A A = Eqa;
comparator_location A H = Gt;
comparator_location H Ra = Lt;
comparator_location H Ba = Lt;
comparator_location H A = Lt;
comparator_location H H = Eqa;

compare_location :: Location -> Location -> Ordera;
compare_location = comparator_location;

ccompare_location :: Maybe (Location -> Location -> Ordera);
ccompare_location = Just compare_location;

instance Ccompare Location where {
  ccompare = ccompare_location;
};

data Scg a b = Null | Scg a a [(b, b)] [(b, b)];

equal_scg :: forall a b. (Eq a, Eq b) => Scg a b -> Scg a b -> Bool;
equal_scg Null (Scg x21 x22 x23 x24) = False;
equal_scg (Scg x21 x22 x23 x24) Null = False;
equal_scg (Scg x21 x22 x23 x24) (Scg y21 y22 y23 y24) =
  x21 == y21 && x22 == y22 && x23 == y23 && x24 == y24;
equal_scg Null Null = True;

instance (Eq a, Eq b) => Eq (Scg a b) where {
  a == b = equal_scg a b;
};

comparator_scg ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Scg a b -> Scg a b -> Ordera;
comparator_scg comp_p_p comp_a_p (Scg x xa xb xc) (Scg y ya yb yc) =
  (case comp_p_p x y of {
    Eqa ->
      (case comp_p_p xa ya of {
        Eqa ->
          (case comparator_list (comparator_prod comp_a_p comp_a_p) xb yb of {
            Eqa -> comparator_list (comparator_prod comp_a_p comp_a_p) xc yc;
            Lt -> Lt;
            Gt -> Gt;
          });
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_scg comp_p_p comp_a_p (Scg x xa xb xc) Null = Gt;
comparator_scg comp_p_p comp_a_p Null (Scg y ya yb yc) = Lt;
comparator_scg comp_p_p comp_a_p Null Null = Eqa;

compare_scg ::
  forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Ordera;
compare_scg = comparator_scg compare compare;

less_eq_scg :: forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Bool;
less_eq_scg = le_of_comp compare_scg;

less_scg :: forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Bool;
less_scg = lt_of_comp compare_scg;

instance (Compare a, Compare b) => Ord (Scg a b) where {
  less_eq = less_eq_scg;
  less = less_scg;
};

instance (Compare a, Compare b) => Compare (Scg a b) where {
  compare = compare_scg;
};

instance (Compare a, Compare b) => Quasi_order (Scg a b) where {
};

instance (Compare a, Compare b) => Weak_order (Scg a b) where {
};

instance (Compare a, Compare b) => Preorder (Scg a b) where {
};

instance (Compare a, Compare b) => Order (Scg a b) where {
};

instance (Compare a, Compare b) => Linorder (Scg a b) where {
};

instance (Compare a, Compare b) => Compare_order (Scg a b) where {
};

data Arctic_delta a = MinInfty_delta | Num_arc_delta a;

equal_arctic_delta ::
  forall a. (Eq a) => Arctic_delta a -> Arctic_delta a -> Bool;
equal_arctic_delta MinInfty_delta (Num_arc_delta x2) = False;
equal_arctic_delta (Num_arc_delta x2) MinInfty_delta = False;
equal_arctic_delta (Num_arc_delta x2) (Num_arc_delta y2) = x2 == y2;
equal_arctic_delta MinInfty_delta MinInfty_delta = True;

instance (Eq a) => Eq (Arctic_delta a) where {
  a == b = equal_arctic_delta a b;
};

one_arctic_delta :: forall a. (Linordered_field a) => Arctic_delta a;
one_arctic_delta = Num_arc_delta zerob;

instance (Linordered_field a) => One (Arctic_delta a) where {
  onea = one_arctic_delta;
};

plus_arctic_delta ::
  forall a.
    (Linordered_field a) => Arctic_delta a -> Arctic_delta a -> Arctic_delta a;
plus_arctic_delta MinInfty_delta y = y;
plus_arctic_delta (Num_arc_delta v) MinInfty_delta = Num_arc_delta v;
plus_arctic_delta (Num_arc_delta x) (Num_arc_delta y) = Num_arc_delta (max x y);

instance (Linordered_field a) => Plus (Arctic_delta a) where {
  plus = plus_arctic_delta;
};

zero_arctic_delta :: forall a. (Linordered_field a) => Arctic_delta a;
zero_arctic_delta = MinInfty_delta;

instance (Linordered_field a) => Zero (Arctic_delta a) where {
  zerob = zero_arctic_delta;
};

instance (Linordered_field a) => Semigroup_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Numeral (Arctic_delta a) where {
};

times_arctic_delta ::
  forall a.
    (Linordered_field a) => Arctic_delta a -> Arctic_delta a -> Arctic_delta a;
times_arctic_delta MinInfty_delta y = MinInfty_delta;
times_arctic_delta (Num_arc_delta v) MinInfty_delta = MinInfty_delta;
times_arctic_delta (Num_arc_delta x) (Num_arc_delta y) =
  Num_arc_delta (plus x y);

instance (Linordered_field a) => Times (Arctic_delta a) where {
  times = times_arctic_delta;
};

instance (Linordered_field a) => Power (Arctic_delta a) where {
};

less_eq_arctic_delta ::
  forall a. (Ord a) => Arctic_delta a -> Arctic_delta a -> Bool;
less_eq_arctic_delta MinInfty_delta x = True;
less_eq_arctic_delta (Num_arc_delta uu) MinInfty_delta = False;
less_eq_arctic_delta (Num_arc_delta y) (Num_arc_delta x) = less_eq y x;

less_arctic_delta ::
  forall a. (Ord a) => Arctic_delta a -> Arctic_delta a -> Bool;
less_arctic_delta MinInfty_delta x = True;
less_arctic_delta (Num_arc_delta uu) MinInfty_delta = False;
less_arctic_delta (Num_arc_delta y) (Num_arc_delta x) = less y x;

instance (Ord a) => Ord (Arctic_delta a) where {
  less_eq = less_eq_arctic_delta;
  less = less_arctic_delta;
};

instance (Linordered_field a) => Ab_semigroup_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Semigroup_mult (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring (Arctic_delta a) where {
};

instance (Linordered_field a) => Mult_zero (Arctic_delta a) where {
};

instance (Linordered_field a) => Monoid_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Comm_monoid_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_0 (Arctic_delta a) where {
};

instance (Linordered_field a) => Monoid_mult (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_numeral (Arctic_delta a) where {
};

instance (Linordered_field a) => Zero_neq_one (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_1 (Arctic_delta a) where {
};

ceq_arctic_delta ::
  forall a. (Eq a) => Maybe (Arctic_delta a -> Arctic_delta a -> Bool);
ceq_arctic_delta = Just equal_arctic_delta;

instance (Eq a) => Ceq (Arctic_delta a) where {
  ceq = ceq_arctic_delta;
};

set_impl_arctic_delta :: forall a. Phantom (Arctic_delta a) Set_impla;
set_impl_arctic_delta = Phantom Set_RBT;

instance Set_impl (Arctic_delta a) where {
  set_impl = set_impl_arctic_delta;
};

showsl_arctic_delta ::
  forall a. (Showl a) => Arctic_delta a -> String -> String;
showsl_arctic_delta MinInfty_delta = showsl_lit "-infinity";
showsl_arctic_delta (Num_arc_delta x) = showsl x;

showsl_list_arctic_delta ::
  forall a. (Showl a) => [Arctic_delta a] -> String -> String;
showsl_list_arctic_delta xs = default_showsl_list showsl_arctic_delta xs;

instance (Showl a) => Showl (Arctic_delta a) where {
  showsl = showsl_arctic_delta;
  showsl_list = showsl_list_arctic_delta;
};

cEnum_arctic_delta ::
  forall a.
    Maybe ([Arctic_delta a],
            ((Arctic_delta a -> Bool) -> Bool,
              (Arctic_delta a -> Bool) -> Bool));
cEnum_arctic_delta = Nothing;

instance Cenum (Arctic_delta a) where {
  cEnum = cEnum_arctic_delta;
};

comparator_arctic_delta ::
  forall a. (a -> a -> Ordera) -> Arctic_delta a -> Arctic_delta a -> Ordera;
comparator_arctic_delta comp_a (Num_arc_delta x) (Num_arc_delta y) = comp_a x y;
comparator_arctic_delta comp_a (Num_arc_delta x) MinInfty_delta = Gt;
comparator_arctic_delta comp_a MinInfty_delta (Num_arc_delta y) = Lt;
comparator_arctic_delta comp_a MinInfty_delta MinInfty_delta = Eqa;

compare_arctic_delta ::
  forall a. (Compare a) => Arctic_delta a -> Arctic_delta a -> Ordera;
compare_arctic_delta = comparator_arctic_delta compare;

ccompare_arctic_delta ::
  forall a. (Compare a) => Maybe (Arctic_delta a -> Arctic_delta a -> Ordera);
ccompare_arctic_delta = Just compare_arctic_delta;

instance (Compare a) => Ccompare (Arctic_delta a) where {
  ccompare = ccompare_arctic_delta;
};

instance (Linordered_field a) => Non_strict_order (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_ab_semigroup (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_semiring_0a (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_semiring_1 (Arctic_delta a) where {
};

data Ty = BoolT | IntT;

equal_ty :: Ty -> Ty -> Bool;
equal_ty BoolT IntT = False;
equal_ty IntT BoolT = False;
equal_ty IntT IntT = True;
equal_ty BoolT BoolT = True;

instance Eq Ty where {
  a == b = equal_ty a b;
};

ceq_ty :: Maybe (Ty -> Ty -> Bool);
ceq_ty = Just equal_ty;

instance Ceq Ty where {
  ceq = ceq_ty;
};

showsl_ty :: Ty -> String -> String;
showsl_ty BoolT = showsl_lit "Bool";
showsl_ty IntT = showsl_lit "Int";

showsl_list_ty :: [Ty] -> String -> String;
showsl_list_ty xs = default_showsl_list showsl_ty xs;

instance Showl Ty where {
  showsl = showsl_ty;
  showsl_list = showsl_list_ty;
};

comparator_ty :: Ty -> Ty -> Ordera;
comparator_ty IntT IntT = Eqa;
comparator_ty IntT BoolT = Gt;
comparator_ty BoolT IntT = Lt;
comparator_ty BoolT BoolT = Eqa;

ccompare_ty :: Maybe (Ty -> Ty -> Ordera);
ccompare_ty = Just comparator_ty;

instance Ccompare Ty where {
  ccompare = ccompare_ty;
};

rel_option :: forall a b. (a -> b -> Bool) -> Maybe a -> Maybe b -> Bool;
rel_option r Nothing (Just y2) = False;
rel_option r (Just y2) Nothing = False;
rel_option r Nothing Nothing = True;
rel_option r (Just x2) (Just y2) = r x2 y2;

newtype Fmap a b = Fmap_of_list [(a, b)];

fmlookup :: forall a b. (Eq a) => Fmap a b -> a -> Maybe b;
fmlookup (Fmap_of_list m) = map_of m;

newtype Fset a = Abs_fset (Set a);

fset_of_list :: forall a. (Ceq a, Ccompare a, Set_impl a) => [a] -> Fset a;
fset_of_list xa = Abs_fset (set xa);

fset :: forall a. Fset a -> Set a;
fset (Abs_fset x) = x;

foldb ::
  forall a b. (Ccompare a) => (a -> b -> b) -> Mapping_rbt a () -> b -> b;
foldb x xc = folda (\ a _ -> x a) (impl_ofb xc);

image ::
  forall a b.
    (Ceq a, Ccompare a, Ceq b, Ccompare b,
      Set_impl b) => (a -> b) -> Set a -> Set b;
image h (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "image RBT_set: ccompare = None" (\ _ -> image h (RBT_set rbt));
    Just _ -> foldb (inserta . h) rbt bot_set;
  });
image g (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "image DList_set: ceq = None" (\ _ -> image g (DList_set dxs));
    Just _ -> foldc (inserta . g) dxs bot_set;
  });
image f (Complement (Complement b)) = image f b;
image f (Collect_set a) =
  (error :: forall a. String -> (() -> a) -> a) "image Collect_set"
    (\ _ -> image f (Collect_set a));
image f (Set_Monad xs) = Set_Monad (map f xs);

fimage ::
  forall b a.
    (Ceq b, Ccompare b, Ceq a, Ccompare a,
      Set_impl a) => (b -> a) -> Fset b -> Fset a;
fimage xb xc = Abs_fset (image xb (fset xc));

fmdom ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Fmap a b -> Fset a;
fmdom (Fmap_of_list m) = fimage fst (fset_of_list m);

rBT_Impl_rbt_all :: forall a b. (a -> b -> Bool) -> Rbta a b -> Bool;
rBT_Impl_rbt_all p (Branch c l k v r) =
  p k v && rBT_Impl_rbt_all p l && rBT_Impl_rbt_all p r;
rBT_Impl_rbt_all p Empty = True;

alla :: forall a b. (Ccompare a) => (a -> b -> Bool) -> Mapping_rbt a b -> Bool;
alla xb xc = rBT_Impl_rbt_all xb (impl_ofb xc);

ball :: forall a. (Ceq a, Ccompare a) => Set a -> (a -> Bool) -> Bool;
ball (RBT_set rbt) p =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Ball RBT_set: ccompare = None" (\ _ -> ball (RBT_set rbt) p);
    Just _ -> alla (\ k _ -> p k) rbt;
  });
ball (DList_set dxs) p =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "Ball DList_set: ceq = None"
        (\ _ -> ball (DList_set dxs) p);
    Just _ -> dlist_all p dxs;
  });
ball (Set_Monad xs) p = all p xs;

fBall :: forall a. (Ceq a, Ccompare a) => Fset a -> (a -> Bool) -> Bool;
fBall xa = ball (fset xa);

fmrel ::
  forall a b c.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b, Set_impl b, Ceq c,
      Ccompare c, Eq c,
      Set_impl c) => (a -> b -> Bool) -> Fmap c a -> Fmap c b -> Bool;
fmrel r m n =
  fBall (fmdom m) (\ x -> rel_option r (fmlookup m x) (fmlookup n x)) &&
    fBall (fmdom n) (\ x -> rel_option r (fmlookup m x) (fmlookup n x));

equal_fmap ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ceq b, Ccompare b, Eq b,
      Set_impl b) => Fmap a b -> Fmap a b -> Bool;
equal_fmap = fmrel (\ a b -> a == b);

newtype Linear_poly = LinearPoly (Fmap Nat Rat);

linear_poly_map :: Linear_poly -> Fmap Nat Rat;
linear_poly_map (LinearPoly x) = x;

equal_linear_poly :: Linear_poly -> Linear_poly -> Bool;
equal_linear_poly x y = equal_fmap (linear_poly_map x) (linear_poly_map y);

instance Eq Linear_poly where {
  a == b = equal_linear_poly a b;
};

data Sig = LessF | LeF | SumF Nat | ConstF Int | ProdF Nat | EqF;

equal_siga :: Sig -> Sig -> Bool;
equal_siga (ProdF x5) EqF = False;
equal_siga EqF (ProdF x5) = False;
equal_siga (ConstF x4) EqF = False;
equal_siga EqF (ConstF x4) = False;
equal_siga (ConstF x4) (ProdF x5) = False;
equal_siga (ProdF x5) (ConstF x4) = False;
equal_siga (SumF x3) EqF = False;
equal_siga EqF (SumF x3) = False;
equal_siga (SumF x3) (ProdF x5) = False;
equal_siga (ProdF x5) (SumF x3) = False;
equal_siga (SumF x3) (ConstF x4) = False;
equal_siga (ConstF x4) (SumF x3) = False;
equal_siga LeF EqF = False;
equal_siga EqF LeF = False;
equal_siga LeF (ProdF x5) = False;
equal_siga (ProdF x5) LeF = False;
equal_siga LeF (ConstF x4) = False;
equal_siga (ConstF x4) LeF = False;
equal_siga LeF (SumF x3) = False;
equal_siga (SumF x3) LeF = False;
equal_siga LessF EqF = False;
equal_siga EqF LessF = False;
equal_siga LessF (ProdF x5) = False;
equal_siga (ProdF x5) LessF = False;
equal_siga LessF (ConstF x4) = False;
equal_siga (ConstF x4) LessF = False;
equal_siga LessF (SumF x3) = False;
equal_siga (SumF x3) LessF = False;
equal_siga LessF LeF = False;
equal_siga LeF LessF = False;
equal_siga (ProdF x5) (ProdF y5) = equal_nat x5 y5;
equal_siga (ConstF x4) (ConstF y4) = equal_int x4 y4;
equal_siga (SumF x3) (SumF y3) = equal_nat x3 y3;
equal_siga EqF EqF = True;
equal_siga LeF LeF = True;
equal_siga LessF LessF = True;

instance Eq Sig where {
  a == b = equal_siga a b;
};

showsl_siga :: Sig -> String -> String;
showsl_siga LessF = showsl_lit "<";
showsl_siga LeF = showsl_lit "<=";
showsl_siga EqF = showsl_lit "=";
showsl_siga (SumF n) = showsl_lit "+";
showsl_siga (ProdF n) = showsl_lit "*";
showsl_siga (ConstF n) = showsl_int n;

showsl_list_siga :: [Sig] -> String -> String;
showsl_list_siga xs = default_showsl_list showsl_siga xs;

instance Showl Sig where {
  showsl = showsl_siga;
  showsl_list = showsl_list_siga;
};

comparator_siga :: Sig -> Sig -> Ordera;
comparator_siga EqF EqF = Eqa;
comparator_siga EqF (ProdF yb) = Gt;
comparator_siga EqF (ConstF ya) = Gt;
comparator_siga EqF (SumF y) = Gt;
comparator_siga EqF LeF = Gt;
comparator_siga EqF LessF = Gt;
comparator_siga (ProdF x) EqF = Lt;
comparator_siga (ProdF x) (ProdF yb) = comparator_of x yb;
comparator_siga (ProdF x) (ConstF ya) = Gt;
comparator_siga (ProdF x) (SumF y) = Gt;
comparator_siga (ProdF x) LeF = Gt;
comparator_siga (ProdF x) LessF = Gt;
comparator_siga (ConstF x) EqF = Lt;
comparator_siga (ConstF x) (ProdF yb) = Lt;
comparator_siga (ConstF x) (ConstF ya) = comparator_of x ya;
comparator_siga (ConstF x) (SumF y) = Gt;
comparator_siga (ConstF x) LeF = Gt;
comparator_siga (ConstF x) LessF = Gt;
comparator_siga (SumF x) EqF = Lt;
comparator_siga (SumF x) (ProdF yb) = Lt;
comparator_siga (SumF x) (ConstF ya) = Lt;
comparator_siga (SumF x) (SumF y) = comparator_of x y;
comparator_siga (SumF x) LeF = Gt;
comparator_siga (SumF x) LessF = Gt;
comparator_siga LeF EqF = Lt;
comparator_siga LeF (ProdF yb) = Lt;
comparator_siga LeF (ConstF ya) = Lt;
comparator_siga LeF (SumF y) = Lt;
comparator_siga LeF LeF = Eqa;
comparator_siga LeF LessF = Gt;
comparator_siga LessF EqF = Lt;
comparator_siga LessF (ProdF yb) = Lt;
comparator_siga LessF (ConstF ya) = Lt;
comparator_siga LessF (SumF y) = Lt;
comparator_siga LessF LeF = Lt;
comparator_siga LessF LessF = Eqa;

ccompare_sig :: Maybe (Sig -> Sig -> Ordera);
ccompare_sig = Just comparator_siga;

instance Ccompare Sig where {
  ccompare = ccompare_sig;
};

data Siga = ConstFa Nat | SumFa | ProdFa | MaxF;

equal_sig :: Siga -> Siga -> Bool;
equal_sig ProdFa MaxF = False;
equal_sig MaxF ProdFa = False;
equal_sig SumFa MaxF = False;
equal_sig MaxF SumFa = False;
equal_sig SumFa ProdFa = False;
equal_sig ProdFa SumFa = False;
equal_sig (ConstFa x1) MaxF = False;
equal_sig MaxF (ConstFa x1) = False;
equal_sig (ConstFa x1) ProdFa = False;
equal_sig ProdFa (ConstFa x1) = False;
equal_sig (ConstFa x1) SumFa = False;
equal_sig SumFa (ConstFa x1) = False;
equal_sig (ConstFa x1) (ConstFa y1) = equal_nat x1 y1;
equal_sig MaxF MaxF = True;
equal_sig ProdFa ProdFa = True;
equal_sig SumFa SumFa = True;

instance Eq Siga where {
  a == b = equal_sig a b;
};

comparator_sig :: Siga -> Siga -> Ordera;
comparator_sig MaxF MaxF = Eqa;
comparator_sig MaxF ProdFa = Gt;
comparator_sig MaxF SumFa = Gt;
comparator_sig MaxF (ConstFa y) = Gt;
comparator_sig ProdFa MaxF = Lt;
comparator_sig ProdFa ProdFa = Eqa;
comparator_sig ProdFa SumFa = Gt;
comparator_sig ProdFa (ConstFa y) = Gt;
comparator_sig SumFa MaxF = Lt;
comparator_sig SumFa ProdFa = Lt;
comparator_sig SumFa SumFa = Eqa;
comparator_sig SumFa (ConstFa y) = Gt;
comparator_sig (ConstFa x) MaxF = Lt;
comparator_sig (ConstFa x) ProdFa = Lt;
comparator_sig (ConstFa x) SumFa = Lt;
comparator_sig (ConstFa x) (ConstFa y) = comparator_of x y;

compare_sig :: Siga -> Siga -> Ordera;
compare_sig = comparator_sig;

instance Compare Siga where {
  compare = compare_sig;
};

showsl_sig :: Siga -> String -> String;
showsl_sig (ConstFa n) = showsl_nat n;
showsl_sig MaxF = showsl_lit "max";
showsl_sig ProdFa = showsl_lit "prod";
showsl_sig SumFa = showsl_lit "sum";

showsl_list_sig :: [Siga] -> String -> String;
showsl_list_sig xs = default_showsl_list showsl_sig xs;

instance Showl Siga where {
  showsl = showsl_sig;
  showsl_list = showsl_list_sig;
};

data Cond_constraint a b = CC_cond Bool (Term a b, Term a b)
  | CC_rewr (Term a b) (Term a b)
  | CC_impl [Cond_constraint a b] (Cond_constraint a b)
  | CC_all b (Cond_constraint a b);

instance (Eq a, Eq b) => Eq (Cond_constraint a b) where {
  a == b = equal_cond_constraint a b;
};

equal_cond_constraint ::
  forall a b.
    (Eq a, Eq b) => Cond_constraint a b -> Cond_constraint a b -> Bool;
equal_cond_constraint (CC_impl x31 x32) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_impl x31 x32) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_impl x31 x32) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_all x41 x42) (CC_all y41 y42) =
  x41 == y41 && equal_cond_constraint x42 y42;
equal_cond_constraint (CC_impl x31 x32) (CC_impl y31 y32) =
  x31 == y31 && equal_cond_constraint x32 y32;
equal_cond_constraint (CC_rewr x21 x22) (CC_rewr y21 y22) =
  equal_term x21 y21 && equal_term x22 y22;
equal_cond_constraint (CC_cond x11 x12) (CC_cond y11 y12) =
  x11 == y11 && x12 == y12;

data Itself a = Type;

newtype Rbt b a = RBT (Rbta b a);

data Xml = XML [Char] [([Char], [Char])] [Xml] | XML_text [Char];

newtype Vec_impl a = Abs_vec_impl (Nat, IArray.IArray a);

newtype Vec a = Vec_impl (Vec_impl a);

data Xmldoc = XMLDOC [[Char]] Xml;

data Lts_impl a b c d e =
  Lts_Impl [d] [(e, Transition_rule a b c d)] [(d, Formula (Term a (b, c)))];

data Le_rel = Leq_Rel | Lt_Rel;

data Order_tag = Lex | Mul;

data Mapping a b = Assoc_List_Mapping (Alist a b)
  | RBT_Mapping (Mapping_rbt a b) | Mapping (a -> Maybe b);

data State a b =
  State [(Nat, Linear_poly)] (Mapping Nat (a, b)) (Mapping Nat (a, b))
    (Mapping Nat b) Bool (Maybe [a]);

data Istate a =
  IState Nat [(Nat, Linear_poly)] [(a, Atom QDelta)] (Linear_poly -> Maybe Nat)
    [a];

data Lts_ext a b c d e =
  Lts_ext (Set d) (Set (Transition_rule a b c d)) (d -> Formula (Term a (b, c)))
    e;

data Xml_error a = TagMismatch [String] | Fatal a;

data Domain = Natural Nat | Integera | Arctic | Arctic_rat | Int_mat Nat Nat
  | Arctic_mat Nat | Arctic_rat_mat Nat | Rational Rat Nat | Rat_mat Nat Nat
  | Mini_Alg Real Nat | Mini_Alg_mat Nat Nat;

data Enat = Enat Nat | Infinity_enat;

data Tpoly a b = PVar a | PNum b | PSum [Tpoly a b] | PMult [Tpoly a b];

data Direction a b =
  Direction (b -> b -> Bool) (State a b -> Mapping Nat (a, b))
    (State a b -> Mapping Nat (a, b)) (State a b -> Nat -> Maybe b)
    (State a b -> Nat -> Maybe b) (State a b -> Nat -> a)
    (State a b -> Nat -> a)
    ((Mapping Nat (a, b) -> Mapping Nat (a, b)) -> State a b -> State a b)
    (Nat -> b -> Atom b) (Nat -> b -> Atom b) (Rat -> Rat -> Bool);

newtype Status a = Abs_status ((a, Nat) -> [Nat]);

data Claim a b = Yes | No | Terminating | Upperbound Nat | Nonterminating
  | Confluent | Nonconfluent | Completed | Ordered_Completed | Anything;

data Reduction_order_input a = RPO_Input [((a, Nat), (Nat, Order_tag))]
  | KBO_Input ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat);

data Tree_automaton a b = Tree_Automaton [a] [Ta_rule a b] [(a, a)];

data Complexity_measure a b = Derivational_Complexity [(a, Nat)]
  | Runtime_Complexity [(a, Nat)] [(a, Nat)];

data Equation_literal a b = Equation (Term a b, Term a b)
  | Inequality (Term a b, Term a b);

newtype Complexity_class = Comp_Poly Nat;

data Fp_strategy a b = Outermost | Context_Sensitive [((a, Nat), [Nat])]
  | Forbidden_Patterns [(Ctxt a b, (Term a b, Location))];

data Start_term = Full | Constructor_Based;

data Strategy a b = No_Strategy | Innermost | Innermost_Q [Term a b];

data Input a b =
  DP_input Bool [(Term a b, Term a b)] (Strategy a b) [(Term a b, Term a b)]
  | Inn_TRS_input (Strategy a b) [(Term a b, Term a b)] [(Term a b, Term a b)]
      Start_term
  | CPX_input (Strategy a b) [(Term a b, Term a b)] [(Term a b, Term a b)]
      (Complexity_measure a b) Complexity_class
  | COMP_input [(Term a b, Term a b)] [(Term a b, Term a b)]
  | OCOMP_input [(Term a b, Term a b)] [(Term a b, Term a b)]
      [(Term a b, Term a b)] (Reduction_order_input a)
  | EQ_input [(Term a b, Term a b)] (Equation_literal a b)
  | FP_TRS_input (Fp_strategy a b) [(Term a b, Term a b)]
  | CTRS_input [((Term a b, Term a b), [(Term a b, Term a b)])]
  | TA_input (Tree_automaton [Char] a) [(Term a b, Term a b)]
  | AC_input [(Term a b, Term a b)] [a] [a]
  | LTS_input (Lts_impl Sig b Ty [Char] [Char])
  | LTS_safety_input (Lts_impl Sig b Ty [Char] [Char]) [[Char]]
  | Infeasibility_input [((Term a b, Term a b), [(Term a b, Term a b)])]
      [(Term a b, Term a b)]
  | Unknown_input [Char];

data Const_string_sound_proof a b =
  Const_string_sound_proof b [(a, a)] [(Term a b, Term a b)]
    [(Term a b, Term a b)];

data Af_entry = Collapse Nat | AFList [Nat];

data Redtriple_impl a = Int_carrier [((a, Nat), (Int, [Int]))]
  | Int_nl_carrier [((a, Nat), [(Monom Nat, Int)])]
  | Rat_carrier [((a, Nat), (Rat, [Rat]))]
  | Rat_nl_carrier Rat [((a, Nat), [(Monom Nat, Rat)])]
  | Real_carrier [((a, Nat), (Real, [Real]))]
  | Real_nl_carrier Real [((a, Nat), [(Monom Nat, Real)])]
  | Arctic_carrier [((a, Nat), (Arctic, [Arctic]))]
  | Arctic_rat_carrier [((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]))]
  | Int_mat_carrier Nat Nat [((a, Nat), (Mat Int, [Mat Int]))]
  | Rat_mat_carrier Nat Nat [((a, Nat), (Mat Rat, [Mat Rat]))]
  | Real_mat_carrier Nat Nat [((a, Nat), (Mat Real, [Mat Real]))]
  | Arctic_mat_carrier Nat [((a, Nat), (Mat Arctic, [Mat Arctic]))]
  | Arctic_rat_mat_carrier Nat
      [((a, Nat), (Mat (Arctic_delta Rat), [Mat (Arctic_delta Rat)]))]
  | RPO [((a, Nat), (Nat, Order_tag))] [((a, Nat), Af_entry)]
  | KBO ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) [((a, Nat), Af_entry)]
  | ACKBO ([((a, Nat), (Nat, (Nat, Bool)))], Nat) [((a, Nat), Af_entry)]
  | WPO [((a, Nat), (Nat, [Nat]))] (Redtriple_impl a)
  | Max_poly [((a, Nat), Term Siga Nat)]
  | Filtered_Redtriple [((a, Nat), Af_entry)] (Redtriple_impl a);

data Complex_constant_removal_prf a b =
  Complex_Constant_Removal_Proof (Term a b)
    [((Term a b, Term a b), (Term a b, Term a b))];

data List_order_type = MS_Ext | Max_Ext | Min_Ext | Dms_Ext;

data Root_redtriple_impl a =
  SCNP List_order_type [((a, Nat), [(Nat, Nat)])] (Redtriple_impl a);

data Cond_constraint_prf a b = Final
  | Delete_Condition (Cond_constraint a b) (Cond_constraint_prf a b)
  | Different_Constructor (Cond_constraint a b)
  | Same_Constructor (Cond_constraint a b) (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Variable_Equation b (Term a b) (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Funarg_Into_Var (Cond_constraint a b) Nat b (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Simplify_Condition (Cond_constraint a b) [(b, Term a b)]
      (Cond_constraint a b) (Cond_constraint_prf a b)
  | Induction (Cond_constraint a b) [Cond_constraint a b]
      [((Term a b, Term a b),
         ([(Term a b, [b])], (Cond_constraint a b, Cond_constraint_prf a b)))];

data Cond_red_pair_prf a b =
  Cond_Red_Pair_Prf a
    [(Cond_constraint a b, ([(Term a b, Term a b)], Cond_constraint_prf a b))]
    Nat Nat;

data ArithFun = Arg Nat | Const Nat | Sum [ArithFun] | Max [ArithFun]
  | Min [ArithFun] | Prod [ArithFun]
  | IfEqual ArithFun ArithFun ArithFun ArithFun;

data Sl_inter a = SL_Inter Nat [((a, Nat), ArithFun)];

data Sl_variant a b = Rootlab (Maybe (a, Nat)) | Finitelab (Sl_inter a)
  | QuasiFinitelab (Sl_inter a) b;

data Generic_assm_proof a b c d e f g h =
  SN_assm_proof
    (Bool,
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          [(Term (Lab a b) c, Term (Lab a b) c)])))
    d
  | Finite_assm_proof
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      e
  | SN_FP_assm_proof
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      f
  | Not_SN_assm_proof
      (Bool, ([Term (Lab a b) c], [(Term (Lab a b) c, Term (Lab a b) c)])) d
  | Infinite_assm_proof
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      e
  | Not_RelSN_assm_proof
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      f
  | Not_SN_FP_assm_proof
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      g
  | Complexity_assm_proof
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            (Complexity_measure (Lab a b) c, Complexity_class))))
      d
  | Unknown_assm_proof [Char] h;

data Join_info a =
  Guided
    [(Term a [Char],
       ([([Nat], ((Term a [Char], Term a [Char]), Term a [Char]))],
         (Term a [Char],
           [([Nat], ((Term a [Char], Term a [Char]), Term a [Char]))])))]
  | Join_NF | Join_BFS Nat;

newtype ProjL a = Projection [((a, Nat), Nat)];

data Ta_relation a = Decision_Proc_Old | Decision_Proc | Id_Relation
  | Some_Relation [(a, a)];

data Boundstype = Roof | Match;

data Bounds_info a b =
  Bounds_Info Boundstype Nat [b] (Tree_automaton b (a, Nat)) (Ta_relation b);

data Trs_termination_proof a b c =
  DP_Trans Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
    (Dp_termination_proof a b c)
  | Rule_Removal (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | String_Reversal (Trs_termination_proof a b c)
  | Constant_String (Const_string_sound_proof (Lab a b) c)
      (Trs_termination_proof a b c)
  | Bounds (Bounds_info (Lab a b) c)
  | Uncurry
      (Lab a b,
        ([((Lab a b, Nat), [Lab a b])],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | Semlab (Sl_variant (Lab a b) c) [Term (Lab a b) c]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | R_is_Empty
  | Fcc [Ctxt (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c)
  | Split [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
      (Trs_termination_proof a b c)
  | Switch_Innermost (Join_info (Lab a b)) (Trs_termination_proof a b c)
  | Drop_Equality (Trs_termination_proof a b c)
  | Remove_Nonapplicable_Rules [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c)
  | Permuting_AFS [((Lab a b, Nat), Af_entry)] (Trs_termination_proof a b c)
  | Assume_SN
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [Generic_assm_proof a b c (Trs_termination_proof a b c)
         (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
         (Unknown_proof a b c)];

data Fptrs_termination_proof a b c =
  Assume_FP_SN
    ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
      [(Term (Lab a b) c, Term (Lab a b) c)])
    [Generic_assm_proof a b c (Trs_termination_proof a b c)
       (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
       (Unknown_proof a b c)];

data Dp_termination_proof a b c = P_is_Empty
  | Subterm_Criterion_Proc (ProjL (Lab a b))
      [((Term (Lab a b) c, Term (Lab a b) c),
         [([Nat], ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Gen_Subterm_Criterion_Proc [((Lab a b, Nat), [Nat])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Redpair_Proc
      (Sum (Root_redtriple_impl (Lab a b)) (Redtriple_impl (Lab a b)))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Redpair_UR_Proc
      (Sum (Root_redtriple_impl (Lab a b)) (Redtriple_impl (Lab a b)))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Usable_Rules_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_termination_proof a b c)
  | Dep_Graph_Proc
      [(Maybe (Dp_termination_proof a b c),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
  | Mono_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Mono_URM_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Mono_Redpair_UR_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Size_Change_Subterm_Proc
      [((Term (Lab a b) c, Term (Lab a b) c), ([(Nat, Nat)], [(Nat, Nat)]))]
  | Size_Change_Redpair_Proc (Redtriple_impl (Lab a b))
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      [((Term (Lab a b) c, Term (Lab a b) c), ([(Nat, Nat)], [(Nat, Nat)]))]
  | Uncurry_Proc (Maybe Nat)
      (Lab a b,
        ([((Lab a b, Nat), [Lab a b])],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Fcc_Proc (Lab a b) [Ctxt (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Split_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
      (Dp_termination_proof a b c)
  | Semlab_Proc (Sl_variant (Lab a b) c) [(Term (Lab a b) c, Term (Lab a b) c)]
      [Term (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_termination_proof a b c)
  | Switch_Innermost_Proc (Join_info (Lab a b)) (Dp_termination_proof a b c)
  | Rewriting_Proc (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Term (Lab a b) c, Term (Lab a b) c) (Term (Lab a b) c, Term (Lab a b) c)
      (Term (Lab a b) c, Term (Lab a b) c) (Term (Lab a b) c, Term (Lab a b) c)
      [Nat] (Dp_termination_proof a b c)
  | Instantiation_Proc (Term (Lab a b) c, Term (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Forward_Instantiation_Proc (Term (Lab a b) c, Term (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Dp_termination_proof a b c)
  | Narrowing_Proc (Term (Lab a b) c, Term (Lab a b) c) [Nat]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Assume_Finite
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      [Generic_assm_proof a b c (Trs_termination_proof a b c)
         (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
         (Unknown_proof a b c)]
  | Unlab_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Q_Reduction_Proc [Term (Lab a b) c] (Dp_termination_proof a b c)
  | Complex_Constant_Removal_Proc (Complex_constant_removal_prf (Lab a b) c)
      (Dp_termination_proof a b c)
  | General_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Cond_red_pair_prf (Lab a b) c)
      [Dp_termination_proof a b c]
  | To_Trs_Proc (Trs_termination_proof a b c);

data Unknown_proof a b c =
  Assume_Unknown [Char]
    [Generic_assm_proof a b c (Trs_termination_proof a b c)
       (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
       (Unknown_proof a b c)];

data Cr_proof a b c = SN_WCR (Join_info (Lab a b)) (Trs_termination_proof a b c)
  | Weakly_Orthogonal | Strongly_Closed Nat
  | Rule_Labeling [((Term (Lab a b) c, Term (Lab a b) c), Nat)]
      [(Term (Lab a b) [Char],
         ([([Nat],
             ((Term (Lab a b) [Char], Term (Lab a b) [Char]),
               Term (Lab a b) [Char]))],
           (Term (Lab a b) [Char],
             [([Nat],
                ((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                  Term (Lab a b) [Char]))])))]
      (Maybe (Trs_termination_proof a b c))
  | Rule_Labeling_Conv [((Term (Lab a b) c, Term (Lab a b) c), Nat)]
      [(Term (Lab a b) [Char],
         (Term (Lab a b) [Char],
           ([([Nat],
               ((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                 (Bool, Term (Lab a b) [Char])))],
             ([([Nat],
                 ((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                   Term (Lab a b) [Char]))],
               ([([Nat],
                   ((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                     (Bool, Term (Lab a b) [Char])))],
                 (Term (Lab a b) [Char],
                   ([([Nat],
                       ((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                         (Bool, Term (Lab a b) [Char])))],
                     ([([Nat],
                         ((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                           Term (Lab a b) [Char]))],
                       [([Nat],
                          ((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                            (Bool, Term (Lab a b) [Char])))]))))))))]
      (Maybe (Nat, Trs_termination_proof a b c))
  | Redundant_Rules [(Term (Lab a b) c, Term (Lab a b) c)] Nat
      [[([Nat],
          ((Term (Lab a b) c, Term (Lab a b) c), (Bool, Term (Lab a b) c)))]]
      (Cr_proof a b c)
  | Parallel_Closed (Maybe Nat)
  | Critical_Pair_Closing_System [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c) Nat
  | Persistent_Decomposition [(Lab a b, ([[Char]], [Char]))]
      [([(Term (Lab a b) c, Term (Lab a b) c)], Cr_proof a b c)];

data Comp_res = LESS | EQUAL | GREATER;

newtype Multimap a b = Abs_multimap (b -> a, (Mapping a [b], [b]));

data Ring_ext a b = Ring_ext a (a -> a -> a) b;

data Constraint = LTa Linear_poly Rat | GTa Linear_poly Rat
  | LEQ Linear_poly Rat | GEQ Linear_poly Rat | EQa Linear_poly Rat
  | LTPP Linear_poly Linear_poly | GTPP Linear_poly Linear_poly
  | LEQPP Linear_poly Linear_poly | GEQPP Linear_poly Linear_poly
  | EQPP Linear_poly Linear_poly;

newtype Sum_bot a b = Sumbot (Sum a b);

newtype Afs a = Abs_afs ((a, Nat) -> Af_entry, Set (a, Nat));

data Non_join_info a b c = Diff_NFs
  | Tcap_Non_Unif (Term a b -> Term a b -> b -> Term a b)
  | Tree_Aut_Intersect_Empty (Tree_automaton c a) (Ta_relation c)
      (Tree_automaton c a) (Ta_relation c)
  | Finite_Model_Gt (Sl_variant a b) | Reduction_Pair_Gt (Redtriple_impl a)
  | Usable_Rules_Reach_NJ (Non_join_info a b c)
  | Usable_Rules_Reach_Unif_NJ
      (Sum [(Term a b, Term a b)] [(Term a b, Term a b)]) (Non_join_info a b c)
  | Argument_Filter_NJ [((a, Nat), Af_entry)] (Non_join_info a b c)
  | Grounding [(b, Term a b)] (Non_join_info a b c)
  | Subterm_NJ [Nat] (Non_join_info a b c);

data Ncr_proof a b c d = SN_NWCR (Trs_termination_proof a b c)
  | Non_Join (Term (Lab a b) c)
      [([Nat], ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))]
      [([Nat], ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))]
      (Non_join_info (Lab a b) c d)
  | NCR_Disj_Subtrs [(Term (Lab a b) c, Term (Lab a b) c)] (Ncr_proof a b c d)
  | NCR_Redundant_Rules [(Term (Lab a b) c, Term (Lab a b) c)] Nat
      (Ncr_proof a b c d)
  | NCR_Persistent_Decomposition [(Lab a b, ([[Char]], [Char]))]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Ncr_proof a b c d);

data Oc_irule a b = OC_Deduce (Term a b) (Term a b) (Term a b)
  | OC_Orientl (Term a b) (Term a b) | OC_Orientr (Term a b) (Term a b)
  | OC_Delete (Term a b) | OC_Compose (Term a b) (Term a b) (Term a b)
  | OC_Simplifyl (Term a b) (Term a b) (Term a b)
  | OC_Simplifyr (Term a b) (Term a b) (Term a b)
  | OC_Collapse (Term a b) (Term a b) (Term a b);

newtype Ordered_completion_proof a b = OKB [Oc_irule a b];

data Rule_removal_nonterm_reltrs_prf a b =
  Rule_removal_nonterm_reltrs_prf (Maybe [(Term a b, Term a b)])
    (Maybe [(Term a b, Term a b)]);

newtype Dp_trans_nontermination_tt_prf a b c = DP_trans_nontermination_tt_prf
  [(Term (Lab a b) c, Term (Lab a b) c)];

data Const_string_complete_proof a b =
  Const_string_complete_proof b [(a, a)] [(Term a b, Term a b)];

newtype Rule_removal_nonterm_trs_prf a b = Rule_removal_nonterm_trs_prf
  [(Term a b, Term a b)];

newtype Q_increase_nonterm_trs_prf a b = Q_increase_nonterm_trs_prf [Term a b];

newtype Dp_q_reduction_nonterm_prf a b = DP_q_reduction_nonterm_prf [Term a b];

newtype Instantiation_complete_proc_prf a b = Instantiation_complete_proc_prf
  [(Term a b, Term a b)];

data Rule_removal_nonterm_dp_prf a b =
  Rule_removal_nonterm_dp_prf (Maybe [(Term a b, Term a b)])
    (Maybe [(Term a b, Term a b)]);

newtype Q_increase_nonterm_dp_prf a b = Q_increase_nonterm_dp_prf [Term a b];

data Rewriting_complete_proc_prf a b =
  Rewriting_complete_proc_prf (Maybe [(Term a b, Term a b)])
    (Term a b, Term a b) (Term a b, Term a b) (Term a b, Term a b)
    (Term a b, Term a b) [Nat];

data Narrowing_complete_proc_prf a b =
  Narrowing_complete_proc_prf (Term a b, Term a b) [Nat] [(Term a b, Term a b)];

data Pat_rule_pos = Pat_Base | Pat_Pump | Pat_Close;

data Pat_eqv_prf a b = Pat_Dom_Renaming [(b, Term a b)]
  | Pat_Irrelevant [(b, Term a b)] [(b, Term a b)]
  | Pat_Simplify [(b, Term a b)] [(b, Term a b)];

data Pat_rule_prf a b = Pat_OrigRule (Term a b, Term a b) Bool
  | Pat_InitPump (Pat_rule_prf a b) [(b, Term a b)] [(b, Term a b)]
  | Pat_InitPumpCtxt (Pat_rule_prf a b) [(b, Term a b)] [Nat] b
  | Pat_Equiv (Pat_rule_prf a b) Bool (Pat_eqv_prf a b)
  | Pat_Narrow (Pat_rule_prf a b) (Pat_rule_prf a b) [Nat]
  | Pat_Inst (Pat_rule_prf a b) [(b, Term a b)] Pat_rule_pos
  | Pat_Rewr (Pat_rule_prf a b)
      (Term a b, [([Nat], ((Term a b, Term a b), Term a b))]) Pat_rule_pos b
  | Pat_Exp_Sigma (Pat_rule_prf a b) Nat;

data Non_loop_prf a b =
  Non_loop_prf (Pat_rule_prf a b) [(b, Term a b)] [(b, Term a b)] Nat Nat [Nat];

data Dp_loop_prf a b =
  DP_loop_prf (Term a b) [([Nat], ((Term a b, Term a b), (Bool, Term a b)))]
    [(b, Term a b)] (Ctxt a b);

data Not_wn_ta_prf a b = Not_wn_ta_prf (Tree_automaton b a) (Ta_relation b);

data Dp_proof_step a = OC1 ([a], [a]) Bool
  | OC2 ([a], [a]) ([a], [a]) ([a], [a]) [a] [a] [a]
  | OC2p ([a], [a]) ([a], [a]) ([a], [a]) [a] [a] [a]
  | OC3 ([a], [a]) ([a], [a]) ([a], [a]) [a] [a]
  | OC3p ([a], [a]) ([a], [a]) ([a], [a]) [a] [a]
  | OCDP1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a])
  | OCDP2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a])
  | WPEQ (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
  | Lift (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
  | DPOC1_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC1_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a] [a]
  | DPOC2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC3_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC3_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a] [a]
  | DPDP1_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP1_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP2_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP2_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a]
      [a];

data Non_loop_srs_proof a = SE_OC ([a], [a]) [a] [a] [Dp_proof_step a]
  | SE_DP (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a]
      [a] [Dp_proof_step a];

data Uncurry_nt_proof a b c =
  Uncurry_nt_proof
    (Lab a b,
      ([((Lab a b, Nat), [Lab a b])],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          [(Term (Lab a b) c, Term (Lab a b) c)])))
    [(Term (Lab a b) c, Term (Lab a b) c)];

data Trs_loop_prf a b =
  TRS_loop_prf (Term a b) [([Nat], ((Term a b, Term a b), Term a b))]
    [(b, Term a b)] (Ctxt a b);

data Rel_trs_loop_prf a b =
  Rel_trs_loop_prf (Term a b)
    [([Nat], ((Term a b, Term a b), (Bool, Term a b)))] [(b, Term a b)]
    (Ctxt a b);

data Reltrs_nontermination_proof a b c = Rel_Loop (Rel_trs_loop_prf (Lab a b) c)
  | Rel_TRS_String_Reversal (Reltrs_nontermination_proof a b c)
  | Rel_Not_Well_Formed
  | Rel_Rule_Removal (Rule_removal_nonterm_reltrs_prf (Lab a b) c)
      (Reltrs_nontermination_proof a b c)
  | Rel_R_Not_SN (Trs_nontermination_proof a b c)
  | Rel_TRS_Assume_Not_SN
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Trs_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Trs_nontermination_proof a b c = TRS_Loop (Trs_loop_prf (Lab a b) c)
  | TRS_Not_Well_Formed
  | TRS_Rule_Removal (Rule_removal_nonterm_trs_prf (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_String_Reversal (Trs_nontermination_proof a b c)
  | TRS_Constant_String (Const_string_complete_proof (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_DP_Trans (Dp_trans_nontermination_tt_prf a b c)
      (Dp_nontermination_proof a b c)
  | TRS_Termination_Switch (Join_info (Lab a b))
      (Trs_nontermination_proof a b c)
  | TRS_Nonloop (Non_loop_prf (Lab a b) c)
  | TRS_Nonloop_SRS (Non_loop_srs_proof (Lab a b))
  | TRS_Q_Increase (Q_increase_nonterm_trs_prf (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_Uncurry (Uncurry_nt_proof a b c) (Trs_nontermination_proof a b c)
  | TRS_Not_WN_Tree_Automaton (Not_wn_ta_prf (Lab a b) c)
  | TRS_Assume_Not_SN
      (Bool, ([Term (Lab a b) c], [(Term (Lab a b) c, Term (Lab a b) c)]))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Trs_nontermination_proof a b c) (Neg_unknown_proof a b c)]
  | FPTRS_Assume_Not_SN
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Trs_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Dp_nontermination_proof a b c = DP_Loop (Dp_loop_prf (Lab a b) c)
  | DP_Nonloop (Non_loop_prf (Lab a b) c)
  | DP_Rule_Removal (Rule_removal_nonterm_dp_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Q_Increase (Q_increase_nonterm_dp_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Q_Reduction (Dp_q_reduction_nonterm_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Termination_Switch (Join_info (Lab a b)) (Dp_nontermination_proof a b c)
  | DP_Instantiation (Instantiation_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Rewriting (Rewriting_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Narrowing (Narrowing_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Assume_Infinite
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Trs_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Neg_unknown_proof a b c =
  Assume_NT_Unknown [Char]
    [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
       (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
       (Trs_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Quasi_reductive_proof a b c =
  Unravel
    [(((Term (Lab a b) c, Term (Lab a b) c),
        [(Term (Lab a b) c, Term (Lab a b) c)]),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
    (Trs_termination_proof a b c);

data Nonreachability_proof a b = Nonreachable_Tcap | Nonreachable_Gtcap
  | Nonreachable_ETAC [(a, Nat)] a a (Tree_automaton (Term a b) a)
  | Nonreachable_Subst_Approx [(Term a b, Term a b)] (Nonreachability_proof a b)
  | Nonreachable_Reverse (Nonreachability_proof a b)
  | Nonreachable_FGCR a a a [(Term a b, Term a b)] [(Term a b, Term a b)]
      (Reduction_order_input a) (Ordered_completion_proof a b);

data Nonjoinability_proof a b = Nonjoinable_Tcap
  | Nonjoinable_Ground_NF (Nonreachability_proof a b);

data Infeasibility_proof a b =
  Infeasible_Compound_Conditions a (Nonreachability_proof a b)
  | Infeasible_Equation (Term a b) (Term a b) (Nonreachability_proof a b)
  | Infeasible_Subset [(Term a b, Term a b)] (Infeasibility_proof a b)
  | Infeasible_Rhss_Equal (Term a b) (Term a b) (Term a b)
      (Nonjoinability_proof a b)
  | Infeasible_Trans (Term a b) (Term a b) (Term a b)
      (Nonreachability_proof a b);

data Ccr_transformation a b c =
  Inline_Conditions_CCRT
    [((Term (Lab a b) c, Term (Lab a b) c),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
    [(((Term (Lab a b) c, Term (Lab a b) c),
        [(Term (Lab a b) c, Term (Lab a b) c)]),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
  | Infeasible_Rule_Removal_CCRT
      [(((Term (Lab a b) c, Term (Lab a b) c),
          [(Term (Lab a b) c, Term (Lab a b) c)]),
         Infeasibility_proof (Lab a b) c)];

data Cstep_proof a b =
  Cstep_step ((Term a b, Term a b), [(Term a b, Term a b)]) [Nat]
    (b -> Term a b) (Term a b) (Term a b) [[Cstep_proof a b]];

data Conditional_ncr_proof a b c d = Unconditional_CNCR (Ncr_proof a b c d)
  | Transformation_CNCR (Ccr_transformation a b c)
      (Conditional_ncr_proof a b c d)
  | Non_Join_CNCR (Term (Lab a b) c) (Term (Lab a b) c) (Term (Lab a b) c)
      [Cstep_proof (Lab a b) c] [Cstep_proof (Lab a b) c]
      (Non_join_info (Lab a b) c d);

data Completion_proof a b c =
  SN_WCR_Eq (Join_info (Lab a b)) (Trs_termination_proof a b c)
    [((Term (Lab a b) c, Term (Lab a b) c),
       [([Nat],
          ((Term (Lab a b) c, Term (Lab a b) c), (Bool, Term (Lab a b) c)))])]
    (Maybe [((Term (Lab a b) c, Term (Lab a b) c),
              [([Nat],
                 ((Term (Lab a b) c, Term (Lab a b) c),
                   (Bool, Term (Lab a b) c)))])]);

data Equational_disproof a b c =
  Completion_and_Normalization_Different [(Term (Lab a b) c, Term (Lab a b) c)]
    (Completion_proof a b c)
  | Ordered_Completion_and_Normalization_Different
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) [Char], Term (Lab a b) [Char])]
      (Reduction_order_input (Lab a b)) (Ordered_completion_proof (Lab a b) c)
  | Convertible_Instance
      [((Term (Lab a b) c, Term (Lab a b) c),
         [([Nat],
            ((Term (Lab a b) c, Term (Lab a b) c),
              (Bool, Term (Lab a b) c)))])];

data Ao_infeasibility_proof a b =
  AO_Infeasibility_Proof (Infeasibility_proof a b)
  | AO_Lhss_Equal (Term a b) (Term a b) (Term a b) (Nonjoinability_proof a b);

data Context_joinable_proof a b =
  Contextual_Join (Term a b) [Cstep_proof a b] [Cstep_proof a b];

data Unfeasible_proof a b =
  UnfeasibleOverlap (Term a b) (Term a b) (Term a b) [Cstep_proof a b]
    [Cstep_proof a b] ((Term a b, Term a b), [(Term a b, Term a b)])
    ((Term a b, Term a b), [(Term a b, Term a b)]);

data Conditional_cr_proof a b c = Unconditional_CR (Cr_proof a b c)
  | Unravel_CR
      [(((Term (Lab a b) c, Term (Lab a b) c),
          [(Term (Lab a b) c, Term (Lab a b) c)]),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
      (Cr_proof a b c)
  | Transformation_CR (Ccr_transformation a b c) (Conditional_cr_proof a b c)
  | Almost_Orthogonal_CR
  | Almost_Orthogonal_Modulo_Infeasibility_CR
      [([(Term (Lab a b) c, Term (Lab a b) c)],
         Infeasibility_proof (Lab a b) c)]
  | Almost_Orthogonal_Modulo_Infeasibility_CRa
      [([(Term (Lab a b) c, Term (Lab a b) c)],
         ([(Term (Lab a b) c, Term (Lab a b) c)],
           Ao_infeasibility_proof (Lab a b) c))]
  | AL94_CR (Quasi_reductive_proof a b c)
      [(Term (Lab a b) c,
         (Term (Lab a b) c,
           ([(Term (Lab a b) c, Term (Lab a b) c)],
             Context_joinable_proof (Lab a b) c)))]
      [([(Term (Lab a b) c, Term (Lab a b) c)],
         Infeasibility_proof (Lab a b) c)]
      [(c -> Term (Lab a b) c, Unfeasible_proof (Lab a b) c)];

data Ac_dependency_pairs_proof a b =
  AC_dependency_pairs_proof [(Term a b, Term a b)] [(Term a b, Term a b)]
    [(Term a b, Term a b)] [(Term a b, Term a b)];

data Ac_dp_termination_proof a b = AC_P_is_Empty
  | AC_Subterm_Proc [((a, Nat), [Nat])] [(Term a b, Term a b)]
      (Ac_dp_termination_proof a b)
  | AC_Redpair_UR_Proc (Redtriple_impl a) [(Term a b, Term a b)]
      [(Term a b, Term a b)] (Ac_dp_termination_proof a b)
  | AC_Mono_Redpair_UR_Proc (Redtriple_impl a) [(Term a b, Term a b)]
      [(Term a b, Term a b)] [(Term a b, Term a b)]
      (Ac_dp_termination_proof a b)
  | AC_Dep_Graph_Proc
      [(Maybe (Ac_dp_termination_proof a b), [(Term a b, Term a b)])];

data Ac_termination_proof a b c =
  AC_DP_Trans (Ac_dependency_pairs_proof (Lab a b) c)
    (Ac_dp_termination_proof (Lab a b) c) (Ac_dp_termination_proof (Lab a b) c)
  | AC_DP_Trans_Single (Ac_dependency_pairs_proof (Lab a b) c)
      (Ac_dp_termination_proof (Lab a b) c)
  | AC_Rule_Removal (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Ac_termination_proof a b c)
  | AC_R_is_Empty;

data Fresh_variable_addition_info a b c d =
  Fresh_Variable_Addition_Info b c [(d, Formula (Term a (Trans_var b, c)))];

data Transition_removal_info a b c d e =
  Transition_removal_info (Sharp c -> a) [d] b a (d -> Hint e);

data Location_addition_info a b c d e =
  Location_Addition_Info d d e (Transition_rule a b c d);

data Art_edge_impl a b c = Cover_Edge a c | Children_Edge [(b, (a, c))];

data Art_node_impl a b c d e f g =
  Art_Node e (Formula (Term a (b, c))) d (Art_edge_impl e f g);

data Art_impl_ext a b c d e f g h =
  Art_impl_ext [e] [Art_node_impl a b c d e f g] h;

data Invariant_proof a b c d e f g =
  Impact [(d, Formula (Term a (b, c)))] (Art_impl_ext a b c d e f (Hint g) ());

data Cooperation_proof a b c d e f = Triviala
  | Invariants_Update (Invariant_proof a b c (Sharp d) [Char] e f)
      (Cooperation_proof a b c d e f)
  | Location_Addition (Location_addition_info a b c (Sharp d) e)
      (Cooperation_proof a b c d e f)
  | Fresh_Variable_Addition (Fresh_variable_addition_info a b c e)
      (Cooperation_proof a b c d e f)
  | Transition_Removal (Transition_removal_info [Term a (b, c)] c d e f)
      (Cooperation_proof a b c d e f)
  | Scc_Decomp [([Sharp d], Cooperation_proof a b c d e f)]
  | Cut_Transition_Split [([e], Cooperation_proof a b c d e f)];

data Termination_proof a b c d e f = Trivialb
  | Via_Cooperation
      [([(Sharp e, Transition_rule a b c (Sharp d))],
         Cooperation_proof a b c d (Sharp e) f)]
  | Invariants_Update_LTS (Invariant_proof a b c d [Char] e f)
      (Termination_proof a b c d e f);

data Eq_proof a b = Refl (Term a b) | Sym (Eq_proof a b)
  | Trans (Eq_proof a b) (Eq_proof a b)
  | Assm (Term a b, Term a b) (b -> Term a b) | Cong a [Eq_proof a b];

data Equational_proof a b c = Equational_Proof_Tree (Eq_proof (Lab a b) c)
  | Completion_and_Normalization [(Term (Lab a b) c, Term (Lab a b) c)]
      (Completion_proof a b c)
  | Conversion
      [([Nat],
         ((Term (Lab a b) c, Term (Lab a b) c), (Bool, Term (Lab a b) c)))]
  | Conversion_With_History
      [((Term (Lab a b) c, Term (Lab a b) c),
         [([Nat],
            ((Term (Lab a b) c, Term (Lab a b) c),
              (Bool, Term (Lab a b) c)))])];

data Dt_transformation_info a b =
  DT_Transformation_Info [((Term a b, Term a b), (Term a b, Term a b))]
    [((Term a b, Term a b), (Term a b, Term a b))] [Term a b];

data Wdp_trans_info a b =
  WDP_Trans_Info (Set (a, Nat)) [((Term a b, Term a b), (Term a b, Term a b))]
    [((Term a b, Term a b), (Term a b, Term a b))] [Term a b];

data Complexity_proof a b c =
  Rule_Shift_Complexity (Redtriple_impl (Lab a b))
    [(Term (Lab a b) c, Term (Lab a b) c)]
    (Maybe [(Term (Lab a b) c, Term (Lab a b) c)]) (Complexity_proof a b c)
  | RisEmpty_Complexity
  | Remove_Nonapplicable_Rules_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c)
  | Matchbounds_Complexity (Bounds_info (Lab a b) c)
  | Matchbounds_Rel_Complexity (Bounds_info (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Complexity_proof a b c)
  | DT_Transformation (Dt_transformation_info (Lab a b) c)
      (Complexity_proof a b c)
  | WDP_Transformation (Wdp_trans_info (Lab a b) c) (Complexity_proof a b c)
  | Complexity_Assumption
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            (Complexity_measure (Lab a b) c, Complexity_class))))
      [Generic_assm_proof a b c (Complexity_proof a b c) () () () ()]
  | Usable_Rules_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c)
  | Split_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c) (Complexity_proof a b c);

data Safety_proof a b c d e f g = Trivial
  | Invariant_Assertion (Invariant_proof a b c d e f g)
      (Safety_proof a b c d e f g);

data Proof a b c = TRS_Termination_Proof (Trs_termination_proof a b c)
  | Complexity_Proof (Complexity_proof a b c)
  | DP_Termination_Proof (Dp_termination_proof a b c)
  | DP_Nontermination_Proof (Dp_nontermination_proof a b c)
  | TRS_Nontermination_Proof (Trs_nontermination_proof a b c)
  | FP_Termination_Proof (Fptrs_termination_proof a b c)
  | Relative_TRS_Nontermination_Proof (Reltrs_nontermination_proof a b c)
  | TRS_Confluence_Proof (Cr_proof a b c)
  | TRS_Non_Confluence_Proof (Ncr_proof a b c c)
  | Completion_Proof (Completion_proof a b c)
  | Ordered_Completion_Proof (Ordered_completion_proof (Lab a b) c)
  | Equational_Proof (Equational_proof a b c)
  | Equational_Disproof (Equational_disproof a b c)
  | Quasi_Reductive_Proof (Quasi_reductive_proof a b c)
  | Conditional_CR_Proof (Conditional_cr_proof a b c)
  | Conditional_Non_CR_Proof (Conditional_ncr_proof a b c c)
  | Tree_Automata_Closed_Proof (Ta_relation [Char])
  | AC_Termination_Proof (Ac_termination_proof a b c)
  | LTS_Termination_Proof (Termination_proof Sig c Ty [Char] [Char] Hints)
  | LTS_Safety_Proof (Safety_proof Sig c Ty [Char] [Char] [Char] Hints)
  | Infeasibility_Proof (Infeasibility_proof (Lab a b) c)
  | Unknown_Proof (Unknown_proof a b c)
  | Unknown_Disproof (Neg_unknown_proof a b c);

data Le_constraint a = Le_Constraint Le_rel Linear_poly a;

data Linearity a = Non_Linear | Onea | Variable a;

data Ns_constraint a = LEQ_ns Linear_poly a | GEQ_ns Linear_poly a;

newtype Comp_fun_idem b a = Abs_comp_fun_idem (b -> a -> a);

data Monoid_ext a b = Monoid_ext (a -> a -> a) a b;

data Ta_ext a b c = Ta_ext (Set a) (Set (Ta_rule a b)) (Set (a, a)) c;

data Dependance = Ignore | Increase | Decrease | Wild;

newtype Semilattice_set a = Abs_semilattice_set (a -> a -> a);

data Interpretation a = Int_linear_poly ((a, Nat), (Int, [Int]))
  | Rat_linear_poly ((a, Nat), (Rat, [Rat]))
  | Arctic_linear_poly ((a, Nat), (Arctic, [Arctic]))
  | Arctic_rat_linear_poly ((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]))
  | Real_linear_poly ((a, Nat), (Real, [Real]))
  | Int_matrix ((a, Nat), (Mat Int, [Mat Int]))
  | Rat_matrix ((a, Nat), (Mat Rat, [Mat Rat]))
  | Arctic_matrix ((a, Nat), (Mat Arctic, [Mat Arctic]))
  | Arctic_rat_matrix
      ((a, Nat), (Mat (Arctic_delta Rat), [Mat (Arctic_delta Rat)]))
  | Real_matrix ((a, Nat), (Mat Real, [Mat Real]))
  | Int_non_linear_poly ((a, Nat), [(Monom Nat, Int)])
  | Rat_non_linear_poly ((a, Nat), [(Monom Nat, Rat)])
  | Real_non_linear_poly ((a, Nat), [(Monom Nat, Real)]);

data Relation_kind = Strict_TRS | Weak_TRS (Maybe Nat);

data Cert_result = Certified | Unsupported String | Error String;

newtype Subst_incr a b = Abs_subst_incr
  (b -> Term a b, (Set b, Term a b -> [b]));

data Art_edge a b c d e = Cover e | Children [(Transition_rule a b c d, e)];

data Memory_ext a b c d =
  Memory_ext (() -> a) (a -> b -> Maybe c) (a -> (b, c) -> a) d;

data Ta_rule_impl a b = TA_rule_impl b [a] a (Rbt a ());

data Ta_impl a b =
  TA_Impl (Rbt a ()) (Rbt (b, Nat) [Ta_rule_impl a b]) [a] (Rbt a ()) [(a, a)]
    (a -> Rbt a ()) (a -> Rbt a ());

newtype Tp b a = TP
  (Bool,
    ([Term b a],
      (Bool,
        ([(Term b a, Term b a)],
          ([(Term b a, Term b a)],
            (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
              Term b a -> Bool))))));

data Art_ext a b c d e f =
  Art_ext [e] [e] (e -> Art_edge a b c d e) (e -> d)
    (e -> Formula (Term a (b, c))) f;

newtype Ta_code b a = Abs_ta_code
  (Rbta b (),
    (Rbta (Ta_rule b a) (),
      ([(b, b)],
        (Rbta b (),
          (Rbta (a, Nat) (Rbta ([b], b) ()),
            (Bool, (b -> Rbta b (), b -> Rbta b ())))))));

data C_constraint a b =
  Conditional_C Bool (Term a b, Term a b) (Term a b, Term a b)
  | Unconditional_C Bool (Term a b, Term a b);

newtype Dpp b a = DPP
  (Bool,
    (Bool,
      ([(Term b a, Term b a)],
        ([(Term b a, Term b a)],
          ([Term b a],
            (Bool,
              (Bool,
                ([(Term b a, Term b a)],
                  ([(Term b a, Term b a)],
                    (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                      (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                        (Bool, Term b a -> Bool))))))))))));

newtype Simplex_state a = Simplex_State
  ([Ns_constraint QDelta],
    ((Mapping a [(a, Atom QDelta)],
       (Mapping Nat QDelta -> Mapping Nat QDelta, [a])),
      State a QDelta));

data Poly_constraint a = Poly_Ge [(Monom a, Int)] | Poly_Eq [(Monom a, Int)];

data Hinter_ext a b c d e =
  Hinter_ext [c] (b -> [d]) (c -> a) (c -> Maybe [a]) e;

newtype Ac_dpp b a = AC_DPP
  ([(Term b a, Term b a)],
    ([(Term b a, Term b a)],
      ([(Term b a, Term b a)],
        ([(Term b a, Term b a)],
          ([(Term b a, Term b a)],
            Rbt (b, Nat) [((), (Term b a, Term b a))])))));

data Gen_g_impl_ext a b c d = Gen_g_impl_ext a b c d;

data Redord_ext a b c =
  Redord_ext (Sum (String -> String) ()) (Term a b -> Term a b -> Bool) a c;

data Condition_type = Bound | Strict | Non_Strict;

data Redtriple_ext a b c =
  Redtriple_ext (Sum (String -> String) ())
    ((Term a b, Term a b) -> Sum (String -> String) ())
    ((Term a b, Term a b) -> Sum (String -> String) ())
    ((Term a b, Term a b) -> Sum (String -> String) ()) ((a, Nat) -> Set Nat)
    ((a, Nat) -> Set Nat) ([(Term a b, Term a b)] -> Sum (String -> String) ())
    (String -> String) (Maybe [(a, Nat)]) (Maybe [(a, Nat)])
    (Complexity_measure a b -> Complexity_class -> Sum (String -> String) ()) c;

data Fp_loop_prf a b =
  FP_loop_prf (Ctxt a b) [(b, Term a b)] (Term a b)
    [([Nat], ((Term a b, Term a b), Term a b))];

data Sl_ops_ext a b c d e =
  Sl_ops_ext (a -> [b] -> c) (a -> Nat -> c -> Bool) (a -> [b] -> b) [b] b
    ([(Term a d, Term a d)] -> Sum (String -> String) ()) (a -> [b] -> c)
    (a -> Nat -> c -> Bool) (c -> [c]) (a -> Nat -> [c]) e;

data Slm_ops_ext a b c d =
  Slm_ops_ext (a -> [b] -> c) (a -> [b] -> b) [b] b (a -> [b] -> c) d;

data Tp_ops_ext a b c d =
  Tp_ops_ext
    (a -> (Bool,
            (Set (Term b c),
              (Set (Term b c, Term b c), Set (Term b c, Term b c)))))
    (a -> [Term b c]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)]) (a -> Bool)
    (a -> Term b c -> Bool) (a -> Bool)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (Bool ->
      [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> Bool) d;

data Partial_object_ext a b = Partial_object_ext (Set a) b;

newtype Cut_transition_split_info a = Cut_Transition_Split_Info [[a]];

data Dpp_ops_ext a b c d =
  Dpp_ops_ext
    (a -> (Bool,
            (Bool,
              (Set (Term b c, Term b c),
                (Set (Term b c, Term b c),
                  (Set (Term b c),
                    (Set (Term b c, Term b c), Set (Term b c, Term b c))))))))
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [Term b c])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> Bool) (a -> Bool) (a -> Bool)
    (a -> Term b c -> Bool) (a -> Bool)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> (b, Nat) -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)] -> a)
    (a -> (Term b c, Term b c) -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (Bool ->
      Bool ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] ->
            [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> Bool) (a -> Bool) (a -> Bool) d;

data Root_redtriple_ext a b c =
  Root_redtriple_ext (Sum (String -> String) ())
    ((Term a b, Term a b) -> Sum (String -> String) ())
    ((Term a b, Term a b) -> Sum (String -> String) ())
    ((Term a b, Term a b) -> Sum (String -> String) ()) ((a, Nat) -> Set Nat)
    ((a, Nat) -> Set Nat) (String -> String) c;

data Non_inf_order_ext a b c =
  Non_inf_order_ext (Sum (String -> String) ())
    ((Term a b, Term a b) -> Sum (String -> String) ())
    (C_constraint a b -> Sum (String -> String) ())
    ((a, Nat) -> Nat -> Dependance) (String -> String) c;

data Ac_tp_ops_ext a b c d =
  Ac_tp_ops_ext (a -> (Set (Term b c, Term b c), (Set b, Set b)))
    (a -> [(Term b c, Term b c)]) (a -> [b]) (a -> [b])
    ([(Term b c, Term b c)] -> [b] -> [b] -> a)
    (a -> [(Term b c, Term b c)] -> a) (a -> [(Term b c, Term b c)]) d;

data Ordered_semiring_ext a b =
  Ordered_semiring_ext (a -> a -> Bool) (a -> a -> Bool) (a -> a -> a) b;

data Ac_dpp_ops_ext a b c d =
  Ac_dpp_ops_ext
    (a -> (Set (Term b c, Term b c),
            (Set (Term b c, Term b c),
              (Set (Term b c, Term b c),
                (Set (Term b c, Term b c), Set (Term b c, Term b c))))))
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)])
    ([(Term b c, Term b c)] ->
      [(Term b c, Term b c)] ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a) (a -> Bool)
    (a -> Bool) (a -> [(Term b c, Term b c)] -> a) d;

data Redord_closure_ext a b c =
  Redord_closure_ext ([b] -> Term a b -> Term a b -> Bool)
    (Sum (String -> String) ()) c;

data Lpoly_order_semiring_ext a b =
  Lpoly_order_semiring_ext Bool a (a -> Bool) (a -> Bool) (a -> Nat)
    (a -> Nat -> Sum (String -> String) ()) (String -> String) b;

newtype X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a =
  Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
  (Maybe ((a, Nat) -> [Nat]));

newtype
  X_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
    a
  = Abs_x_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
  (Maybe ((a, Nat) -> Af_entry, Set (a, Nat)));

dom :: forall a b. (Cenum a) => (a -> Maybe b) -> Set a;
dom m = collect (\ a -> not (is_none (m a)));

dlist_ex :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Bool;
dlist_ex x xc = any x (list_of_dlist xc);

rBT_Impl_rbt_ex :: forall a b. (a -> b -> Bool) -> Rbta a b -> Bool;
rBT_Impl_rbt_ex p (Branch c l k v r) =
  p k v || (rBT_Impl_rbt_ex p l || rBT_Impl_rbt_ex p r);
rBT_Impl_rbt_ex p Empty = False;

ex :: forall a b. (Ccompare a) => (a -> b -> Bool) -> Mapping_rbt a b -> Bool;
ex xb xc = rBT_Impl_rbt_ex xb (impl_ofb xc);

bex :: forall a. (Ceq a, Ccompare a) => Set a -> (a -> Bool) -> Bool;
bex (RBT_set rbt) p =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Bex RBT_set: ccompare = None" (\ _ -> bex (RBT_set rbt) p);
    Just _ -> ex (\ k _ -> p k) rbt;
  });
bex (DList_set dxs) p =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "Bex DList_set: ceq = None"
        (\ _ -> bex (DList_set dxs) p);
    Just _ -> dlist_ex p dxs;
  });
bex (Set_Monad xs) p = any p xs;

skol ::
  forall a b. (Ceq a, Ccompare a) => Set a -> Term b a -> Term (Sum b a) a;
skol v (Var x) = (if member x v then Fun (Inr x) [] else Var x);
skol v (Fun f ts) = Fun (Inl f) (map (skol v) ts);

drop :: forall a. Nat -> [a] -> [a];
drop n [] = [];
drop n (x : xs) =
  (if equal_nat n zero_nat then x : xs else drop (minus_nat n one_nat) xs);

find :: forall a. (a -> Bool) -> [a] -> Maybe a;
find uu [] = Nothing;
find p (x : xs) = (if p x then Just x else find p xs);

last :: forall a. [a] -> a;
last (x : xs) = (if null xs then x else last xs);

take :: forall a. Nat -> [a] -> [a];
take n [] = [];
take n (x : xs) =
  (if equal_nat n zero_nat then [] else x : take (minus_nat n one_nat) xs);

empty :: forall a b. (Linorder a) => Rbt a b;
empty = RBT Empty;

bind :: forall a b. Maybe a -> (a -> Maybe b) -> Maybe b;
bind Nothing f = Nothing;
bind (Just x) f = f x;

zip_option :: forall a b. [a] -> [b] -> Maybe [(a, b)];
zip_option [] [] = Just [];
zip_option (x : xs) (y : ys) =
  bind (zip_option xs ys) (\ zs -> Just ((x, y) : zs));
zip_option (x : xs) [] = Nothing;
zip_option [] (y : ys) = Nothing;

guard :: Bool -> Maybe ();
guard b = (if b then Just () else Nothing);

match_lista ::
  forall a b. (Eq a) => [(Gctxt a b, Term a b)] -> Maybe [(Gctxt a b, b)];
match_lista ((GCFun f ss, Var x) : ps) =
  bind (match_lista ps) (\ psa -> Just ((GCFun f ss, x) : psa));
match_lista ((GCFun f ss, Fun g ts) : ps) =
  bind (guard (f == g))
    (\ _ -> bind (zip_option ss ts) (\ psa -> match_lista (psa ++ ps)));
match_lista ((GCHole, t) : ps) = match_lista ps;
match_lista [] = Just [];

merge_lists ::
  forall a b. (Eq a) => [Gctxt a b] -> [Gctxt a b] -> Maybe [Gctxt a b];
merge_lists (c : cs) [] = Nothing;
merge_lists [] (d : ds) = Nothing;
merge_lists (GCFun f ss : cs) (GCFun g ts : ds) =
  bind (guard (f == g))
    (\ _ ->
      bind (merge_lists ss ts)
        (\ us -> bind (merge_lists cs ds) (\ es -> Just (GCFun f us : es))));
merge_lists (c : cs) (GCHole : ds) =
  bind (merge_lists cs ds) (\ es -> Just (c : es));
merge_lists (GCHole : cs) (d : ds) =
  bind (merge_lists cs ds) (\ es -> Just (d : es));
merge_lists [] [] = Just [];

mergeb :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Maybe (Gctxt a b);
mergeb c d = bind (merge_lists [c] [d]) (\ es -> Just (nth es zero_nat));

merge_var ::
  forall a b.
    (Eq a,
      Eq b) => a -> Gctxt b a ->
                      [(Gctxt b a, a)] ->
                        Maybe ((Gctxt b a, a), [(Gctxt b a, a)]);
merge_var x c ((d, y) : ps) =
  (if x == y then bind (mergeb c d) (\ e -> merge_var x e ps)
    else bind (merge_var x c ps) (\ (b, psa) -> Just (b, (d, y) : psa)));
merge_var x c [] = Just ((c, x), []);

merge_alla ::
  forall a b. (Eq a, Eq b) => [(Gctxt a b, b)] -> Maybe [(Gctxt a b, b)];
merge_alla [] = Just [];
merge_alla ((c, x) : ps) =
  bind (merge_var x c ps)
    (\ (cx, psa) -> bind (merge_alla psa) (\ psb -> Just (cx : psb)));

matchc ::
  forall a b. (Eq a, Eq b) => (Gctxt a b, Term a b) -> Maybe [(Gctxt a b, b)];
matchc (c, t) = bind (match_lista [(c, t)]) merge_alla;

matchb :: forall a b. (Eq a, Eq b) => Gctxt a b -> Term a b -> Bool;
matchb c t = not (is_none (matchc (c, t)));

tcap ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Set (Term a b, Term a b) -> Term a b -> Gctxt a b;
tcap uu (Var uv) = GCHole;
tcap r (Fun f ts) =
  let {
    h = GCFun f (map (tcap r) ts);
  } in (if bex r (\ ra -> matchb h (fst ra)) then GCHole else h);

root :: forall a b. Term a b -> Maybe (a, Nat);
root (Var x) = Nothing;
root (Fun f ts) = Just (f, size_list ts);

transitions_impl ::
  forall a b c d e. Lts_impl a b c d e -> [(e, Transition_rule a b c d)];
transitions_impl (Lts_Impl x1 x2 x3) = x2;

initiala :: forall a b c d e. Lts_impl a b c d e -> [d];
initiala (Lts_Impl x1 x2 x3) = x1;

assertion_impl ::
  forall a b c d e. Lts_impl a b c d e -> [(d, Formula (Term a (b, c)))];
assertion_impl (Lts_Impl x1 x2 x3) = x3;

lookupa :: forall a b. (Eq a) => Alist a b -> a -> Maybe b;
lookupa xa = map_of (impl_ofa xa);

lookupb :: forall a b. (Ccompare a, Eq a) => Mapping a b -> a -> Maybe b;
lookupb (RBT_Mapping t) = lookupd t;
lookupb (Assoc_List_Mapping al) = lookupa al;

lookup_default :: forall a b. (Ccompare b, Eq b) => a -> Mapping b a -> b -> a;
lookup_default d m k = (case lookupb m k of {
                         Nothing -> d;
                         Just v -> v;
                       });

update :: forall a b. (Eq a) => a -> b -> [(a, b)] -> [(a, b)];
update k v [] = [(k, v)];
update k v (p : ps) = (if fst p == k then (k, v) : ps else p : update k v ps);

updatea :: forall a b. (Eq a) => a -> b -> Alist a b -> Alist a b;
updatea xc xd xe = Alist (update xc xd (impl_ofa xe));

fun_upd :: forall a b. (Eq a) => (a -> b) -> a -> b -> a -> b;
fun_upd f a b = (\ x -> (if x == a then b else f x));

updateb ::
  forall a b. (Ccompare a, Eq a) => a -> b -> Mapping a b -> Mapping a b;
updateb k v (RBT_Mapping t) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "update RBT_Mapping: ccompare = None"
        (\ _ -> updateb k v (RBT_Mapping t));
    Just _ -> RBT_Mapping (inserte k v t);
  });
updateb k v (Assoc_List_Mapping al) = Assoc_List_Mapping (updatea k v al);
updateb k v (Mapping m) = Mapping (fun_upd m k (Just v));

mapping_empty_choose :: forall a b. (Ccompare a) => Mapping a b;
mapping_empty_choose = (case (ccompare :: Maybe (a -> a -> Ordera)) of {
                         Nothing -> Assoc_List_Mapping emptya;
                         Just _ -> RBT_Mapping emptye;
                       });

mapping_empty :: forall a b. (Ccompare a) => Mapping_impla -> Mapping a b;
mapping_empty Mapping_RBT = RBT_Mapping emptye;
mapping_empty Mapping_Assoc_List = Assoc_List_Mapping emptya;
mapping_empty Mapping_Mapping = Mapping (\ _ -> Nothing);
mapping_empty Mapping_Choose = mapping_empty_choose;

emptyb :: forall a b. (Ccompare a, Mapping_impl a) => Mapping a b;
emptyb = mapping_empty (of_phantom (mapping_impl :: Phantom a Mapping_impla));

of_alist ::
  forall a b. (Ccompare a, Eq a, Mapping_impl a) => [(a, b)] -> Mapping a b;
of_alist xs = foldr (\ (a, b) -> updateb a b) xs emptyb;

map_of_default ::
  forall a b. (Ccompare b, Eq b, Mapping_impl b) => a -> [(b, a)] -> b -> a;
map_of_default d xs = lookup_default d (of_alist xs);

assertion_of ::
  forall a b c d e.
    (Ccompare d, Eq d,
      Mapping_impl d) => Lts_impl a b c d e -> d -> Formula (Term a (b, c));
assertion_of pi = map_of_default (Conjunction []) (assertion_impl pi);

lts_of ::
  forall a b c d e.
    (Ccompare a, Eq a, Ccompare b, Eq b, Ccompare c, Eq c, Ceq d, Ccompare d,
      Eq d, Mapping_impl d, Set_impl d, Ceq e, Ccompare e,
      Set_impl e) => Lts_impl a b c d e -> Lts_ext a b c d ();
lts_of pi =
  Lts_ext (set (initiala pi)) (image snd (set (transitions_impl pi)))
    (assertion_of pi) ();

source :: forall a b c d. Transition_rule a b c d -> d;
source (Transition l uu uv) = l;

target :: forall a b c d. Transition_rule a b c d -> d;
target (Transition uu r uv) = r;

membera :: forall a. (Eq a) => [a] -> a -> Bool;
membera [] y = False;
membera (x : xs) y = x == y || membera xs y;

insertb :: forall a. (Eq a) => a -> [a] -> [a];
insertb x xs = (if membera xs x then xs else x : xs);

union :: forall a. (Eq a) => [a] -> [a] -> [a];
union = fold insertb;

of_fun :: forall a. (Nat -> a) -> Nat -> IArray.IArray a;
of_fun f n = IArray.tabulate (integer_of_nat n, f . nat_of_integer);

vec_of_fun :: forall a. Nat -> (Nat -> a) -> Vec_impl a;
vec_of_fun xb xc = Abs_vec_impl (xb, of_fun xc xb);

vec :: forall a. Nat -> (Nat -> a) -> Vec a;
vec n f = Vec_impl (vec_of_fun n f);

col :: forall a. Mat a -> Nat -> Vec a;
col a j = vec (dim_row a) (\ i -> index_mat a (i, j));

mat_of_fun :: forall a. Nat -> Nat -> ((Nat, Nat) -> a) -> Mat_impl a;
mat_of_fun xc xd xe =
  Abs_mat_impl (xc, (xd, of_fun (\ i -> of_fun (\ j -> xe (i, j)) xd) xc));

mat :: forall a. Nat -> Nat -> ((Nat, Nat) -> a) -> Mat a;
mat nr nc f = Mat_impl (mat_of_fun nr nc f);

row :: forall a. Mat a -> Nat -> Vec a;
row a i = vec (dim_col a) (\ j -> index_mat a (i, j));

funpow :: forall a. Nat -> (a -> a) -> a -> a;
funpow n f =
  (if equal_nat n zero_nat then id else f . funpow (minus_nat n one_nat) f);

val :: QDelta -> Rat -> Rat;
val qd delta = plus_rat (qdfst qd) (times_rat delta (qdsnd qd));

rbt_del :: forall a b. (Compare_order a) => a -> Rbta a b -> Rbta a b;
rbt_del x (Branch c a y s b) = (case compare x y of {
                                 Eqa -> combine a b;
                                 Lt -> rbt_del_from_left x a y s b;
                                 Gt -> rbt_del_from_right x a y s b;
                               });
rbt_del x Empty = Empty;

rbt_del_from_left ::
  forall a b.
    (Compare_order a) => a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_left x (Branch B lt z v rt) y s b =
  balance_left (rbt_del x (Branch B lt z v rt)) y s b;
rbt_del_from_left x Empty y s b = Branch R (rbt_del x Empty) y s b;
rbt_del_from_left x (Branch R va vb vc vd) y s b =
  Branch R (rbt_del x (Branch R va vb vc vd)) y s b;

rbt_del_from_right ::
  forall a b.
    (Compare_order a) => a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_right x a y s (Branch B lt z v rt) =
  balance_right a y s (rbt_del x (Branch B lt z v rt));
rbt_del_from_right x a y s Empty = Branch R a y s (rbt_del x Empty);
rbt_del_from_right x a y s (Branch R va vb vc vd) =
  Branch R a y s (rbt_del x (Branch R va vb vc vd));

rbt_delete :: forall a b. (Compare_order a) => a -> Rbta a b -> Rbta a b;
rbt_delete k t = paint B (rbt_del k t);

impl_of :: forall b a. (Linorder b) => Rbt b a -> Rbta b a;
impl_of (RBT x) = x;

delete :: forall a b. (Compare_order a) => a -> Rbt a b -> Rbt a b;
delete xb xc = RBT (rbt_delete xb (impl_of xc));

rbt_ins ::
  forall a b.
    (Compare_order a) => (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_ins f k v (Branch R l x y r) = (case compare k x of {
                                     Eqa -> Branch R l x (f k y v) r;
                                     Lt -> Branch R (rbt_ins f k v l) x y r;
                                     Gt -> Branch R l x y (rbt_ins f k v r);
                                   });
rbt_ins f k v (Branch B l x y r) = (case compare k x of {
                                     Eqa -> Branch B l x (f k y v) r;
                                     Lt -> balance (rbt_ins f k v l) x y r;
                                     Gt -> balance l x y (rbt_ins f k v r);
                                   });
rbt_ins f k v Empty = Branch R Empty k v Empty;

rbt_insert_with_key ::
  forall a b.
    (Compare_order a) => (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_insert_with_key f k v t = paint B (rbt_ins f k v t);

rbt_insert :: forall a b. (Compare_order a) => a -> b -> Rbta a b -> Rbta a b;
rbt_insert = rbt_insert_with_key (\ _ _ nv -> nv);

insert :: forall a b. (Compare_order a) => a -> b -> Rbt a b -> Rbt a b;
insert xc xd xe = RBT (rbt_insert xc xd (impl_of xe));

rbt_lookup :: forall a b. (Compare_order a) => Rbta a b -> a -> Maybe b;
rbt_lookup (Branch uu l x y r) k = (case compare k x of {
                                     Eqa -> Just y;
                                     Lt -> rbt_lookup l k;
                                     Gt -> rbt_lookup r k;
                                   });
rbt_lookup Empty k = Nothing;

lookup :: forall a b. (Compare_order a) => Rbt a b -> a -> Maybe b;
lookup x = rbt_lookup (impl_of x);

proja :: forall a b. Term a b -> Nat -> Term a b;
proja (Fun f ts) i = (if less_nat i (size_list ts) then nth ts i else Fun f ts);

filtera :: forall a. (Ceq a, Ccompare a) => (a -> Bool) -> Set a -> Set a;
filtera p a = inf_set a (Collect_set p);

subst :: forall a b. (Eq a) => a -> Term b a -> a -> Term b a;
subst x t = fun_upd Var x t;

debug :: forall a. (String -> String) -> String -> a -> a;
debug i t x = x;

merge :: forall a b. (Eq a) => [(a, b)] -> [(a, b)] -> [(a, b)];
merge qs ps = foldr (\ (a, b) -> update a b) ps qs;

lterms ::
  forall a b. ((a, Nat) -> [(Nat, Nat)]) -> Term a b -> [(Term a b, Nat)];
lterms pi =
  (\ (Fun f ts) ->
    map (\ (i, a) -> (proja (Fun f ts) i, a)) (pi (f, size_list ts)));

lhs :: (Nat, Linear_poly) -> Nat;
lhs (l, r) = l;

rhs :: (Nat, Linear_poly) -> Linear_poly;
rhs (l, r) = r;

insert_vars_term :: forall a b. (Eq b) => Term a b -> [b] -> [b];
insert_vars_term (Var x) xs = insertb x xs;
insert_vars_term (Fun f ts) xs = foldr insert_vars_term ts xs;

is_Var :: forall a b. Term a b -> Bool;
is_Var (Var x1) = True;
is_Var (Fun x21 x22) = False;

wf_rule :: forall a b. (Eq b) => (Term a b, Term a b) -> Bool;
wf_rule r =
  not (is_Var (fst r)) &&
    all (membera (insert_vars_term (fst r) [])) (insert_vars_term (snd r) []);

fun_of :: forall a b. (Eq a) => [(a, b)] -> a -> b;
fun_of vec x = the (map_of vec x);

letters :: [Char];
letters =
  [Char True False False False False True True False,
    Char False True False False False True True False,
    Char True True False False False True True False,
    Char False False True False False True True False,
    Char True False True False False True True False,
    Char False True True False False True True False,
    Char True True True False False True True False,
    Char False False False True False True True False,
    Char True False False True False True True False,
    Char False True False True False True True False,
    Char True True False True False True True False,
    Char False False True True False True True False,
    Char True False True True False True True False,
    Char False True True True False True True False,
    Char True True True True False True True False,
    Char False False False False True True True False,
    Char True False False False True True True False,
    Char False True False False True True True False,
    Char True True False False True True True False,
    Char False False True False True True True False,
    Char True False True False True True True False,
    Char False True True False True True True False,
    Char True True True False True True True False,
    Char False False False True True True True False,
    Char True False False True True True True False,
    Char False True False True True True True False,
    Char True False False False False False True False,
    Char False True False False False False True False,
    Char True True False False False False True False,
    Char False False True False False False True False,
    Char True False True False False False True False,
    Char False True True False False False True False,
    Char True True True False False False True False,
    Char False False False True False False True False,
    Char True False False True False False True False,
    Char False True False True False False True False,
    Char True True False True False False True False,
    Char False False True True False False True False,
    Char True False True True False False True False,
    Char False True True True False False True False,
    Char True True True True False False True False,
    Char False False False False True False True False,
    Char True False False False True False True False,
    Char False True False False True False True False,
    Char True True False False True False True False,
    Char False False True False True False True False,
    Char True False True False True False True False,
    Char False True True False True False True False,
    Char True True True False True False True False,
    Char False False False True True False True False,
    Char True False False True True False True False,
    Char False True False True True False True False,
    Char True True True True True False True False,
    Char False False False False True True False False,
    Char True False False False True True False False,
    Char False True False False True True False False,
    Char True True False False True True False False,
    Char False False True False True True False False,
    Char True False True False True True False False,
    Char False True True False True True False False,
    Char True True True False True True False False,
    Char False False False True True True False False,
    Char True False False True True True False False,
    Char False True True False False True False False,
    Char True True False True True True False False,
    Char False True False True True True False False,
    Char True False True True False True False False];

bind2 ::
  forall a b c d.
    Sum_bot a b -> (a -> Sum_bot c d) -> (b -> Sum_bot c d) -> Sum_bot c d;
bind2 (Sumbot a) f g = (case a of {
                         Inl aa -> f aa;
                         Inr aa -> g aa;
                       });

hd :: forall a. (Ceq a) => Set_dlist a -> a;
hd xa = hda (list_of_dlist xa);

tl :: forall a. (Ceq a) => Set_dlist a -> Set_dlist a;
tl xa = Abs_dlist (tla (list_of_dlist xa));

foldli :: forall a b. [a] -> (b -> Bool) -> (a -> b -> b) -> b -> b;
foldli [] c f sigma = sigma;
foldli (x : xs) c f sigma =
  (if c sigma then foldli xs c f (f x sigma) else sigma);

replicate :: forall a. Nat -> a -> [a];
replicate n x =
  (if equal_nat n zero_nat then [] else x : replicate (minus_nat n one_nat) x);

scf_list :: forall a. (Nat -> Nat) -> [a] -> [a];
scf_list scf xs =
  concatMap (\ (x, i) -> replicate (scf i) x)
    (zip xs (upt zero_nat (size_list xs)));

scf_term :: forall a b. ((a, Nat) -> Nat -> Nat) -> Term a b -> Term a b;
scf_term scf (Var x) = Var x;
scf_term scf (Fun f ts) =
  Fun f (scf_list (scf (f, size_list ts)) (map (scf_term scf) ts));

butlast :: forall a. [a] -> [a];
butlast [] = [];
butlast (x : xs) = (if null xs then [] else x : butlast xs);

extract :: forall a. (a -> Bool) -> [a] -> Maybe ([a], (a, [a]));
extract p (x : xs) =
  (if p x then Just ([], (x, xs))
    else (case extract p xs of {
           Nothing -> Nothing;
           Just (ys, (y, zs)) -> Just (x : ys, (y, zs));
         }));
extract p [] = Nothing;

productb ::
  forall a b. (Ceq a, Ceq b) => Set_dlist a -> Set_dlist b -> Set_dlist (a, b);
productb dxs1 dxs2 =
  Abs_dlist (foldc (\ a -> foldc (\ c -> (\ b -> (a, c) : b)) dxs2) dxs1 []);

rbt_product ::
  forall a b c d e.
    (a -> b -> c -> d -> e) -> Rbta a b -> Rbta c d -> Rbta (a, c) e;
rbt_product f rbt1 rbt2 =
  rbtreeify
    (reverse
      (folda (\ a b -> folda (\ c d -> (\ e -> ((a, c), f a b c d) : e)) rbt2)
        rbt1 []));

productd ::
  forall a d b e c.
    (Ccompare a,
      Ccompare b) => (a -> d -> b -> e -> c) ->
                       Mapping_rbt a d ->
                         Mapping_rbt b e -> Mapping_rbt (a, b) c;
productd xc xd xe = Mapping_RBTa (rbt_product xc (impl_ofb xd) (impl_ofb xe));

producta ::
  forall a b.
    (Ccompare a,
      Ccompare b) => Mapping_rbt a () ->
                       Mapping_rbt b () -> Mapping_rbt (a, b) ();
producta rbt1 rbt2 = productd (\ _ _ _ _ -> ()) rbt1 rbt2;

productc ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Set a -> Set b -> Set (a, b);
productc (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set RBT_set: ccompare1 = None"
        (\ _ -> productc (RBT_set rbt1) (RBT_set rbt2));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "product RBT_set RBT_set: ccompare2 = None"
            (\ _ -> productc (RBT_set rbt1) (RBT_set rbt2));
        Just _ -> RBT_set (producta rbt1 rbt2);
      });
  });
productc a2 (RBT_set rbt2) =
  (case (ccompare :: Maybe (b -> b -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set: ccompare2 = None" (\ _ -> productc a2 (RBT_set rbt2));
    Just _ -> foldb (\ y -> sup_set (image (\ x -> (x, y)) a2)) rbt2 bot_set;
  });
productc (RBT_set rbt1) b2 =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set: ccompare1 = None" (\ _ -> productc (RBT_set rbt1) b2);
    Just _ -> foldb (\ x -> sup_set (image (\ a -> (x, a)) b2)) rbt1 bot_set;
  });
productc (DList_set dxs) (DList_set dys) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set DList_set: ceq1 = None"
        (\ _ -> productc (DList_set dxs) (DList_set dys));
    Just _ ->
      (case (ceq :: Maybe (b -> b -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "product DList_set DList_set: ceq2 = None"
            (\ _ -> productc (DList_set dxs) (DList_set dys));
        Just _ -> DList_set (productb dxs dys);
      });
  });
productc a1 (DList_set dys) =
  (case (ceq :: Maybe (b -> b -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set2: ceq = None" (\ _ -> productc a1 (DList_set dys));
    Just _ -> foldc (\ y -> sup_set (image (\ x -> (x, y)) a1)) dys bot_set;
  });
productc (DList_set dxs) b1 =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set1: ceq = None" (\ _ -> productc (DList_set dxs) b1);
    Just _ -> foldc (\ x -> sup_set (image (\ a -> (x, a)) b1)) dxs bot_set;
  });
productc (Set_Monad xs) (Set_Monad ys) =
  Set_Monad (fold (\ x -> fold (\ y -> (\ a -> (x, y) : a)) ys) xs []);
productc a b = Collect_set (\ (x, y) -> member x a && member y b);

set_Cons ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Set a -> Set [a] -> Set [a];
set_Cons a xs =
  image (\ (aa, b) -> aa : b)
    (productc (inf_set (image (\ x -> x) a) top_set)
      (inf_set top_set (image (\ xsa -> xsa) xs)));

listset :: forall a. (Ceq a, Ccompare a, Set_impl a) => [Set a] -> Set [a];
listset [] = inserta [] (set_empty (of_phantom set_impl_list));
listset (a : asa) = set_Cons a (listset asa);

remdups :: forall a. (Eq a) => [a] -> [a];
remdups [] = [];
remdups (x : xs) = (if membera xs x then remdups xs else x : remdups xs);

remove1 :: forall a. (Eq a) => a -> [a] -> [a];
remove1 x [] = [];
remove1 x (y : xs) = (if x == y then xs else y : remove1 x xs);

l2m_lookup ::
  forall a b c. (Eq a, Eq b) => [(a, [(b, c)])] -> (a, b) -> Maybe c;
l2m_lookup [] uu = Nothing;
l2m_lookup ((a, kvs) : rec) (k1, k2) = (case k1 == a of {
 True -> map_of kvs k2;
 False -> l2m_lookup rec (k1, k2);
                                       });

lm_store_acc ::
  forall a b. (Eq a) => [(a, b)] -> (a, b) -> [(a, b)] -> [(a, b)];
lm_store_acc [] kv accu = kv : accu;
lm_store_acc ((a, uu) : rec) (k, v) accu =
  (case k == a of {
    True -> accu;
    False -> lm_store_acc rec (k, v) accu;
  });

lm_store :: forall a b. (Eq a) => [(a, b)] -> (a, b) -> [(a, b)];
lm_store m kv = lm_store_acc m kv m;

l2m_store ::
  forall a b c.
    (Eq a, Eq b) => [(a, [(b, c)])] -> ((a, b), c) -> [(a, [(b, c)])];
l2m_store [] ((k1, k2), v) = [(k1, [(k2, v)])];
l2m_store ((a, kvs) : rec) ((k1, k2), v) =
  (case k1 == a of {
    True -> (a, lm_store kvs (k2, v)) : rec;
    False -> (a, kvs) : l2m_store rec ((k1, k2), v);
  });

l2m :: forall a b c. (Eq a, Eq b) => Memory_ext [(a, [(b, c)])] (a, b) c ();
l2m = Memory_ext (\ _ -> []) l2m_lookup l2m_store ();

aux ::
  forall a b.
    (Eq a,
      Compare_order b) => (a -> Maybe b) ->
                            Rbt b [a] -> a -> Rbt b [a] -> Rbt b [a];
aux key ma v m =
  (case key v of {
    Nothing -> m;
    Just k ->
      (case lookup ma k of {
        Nothing -> m;
        Just ws ->
          (if membera ws v then (case lookup m k of {
                                  Nothing -> insert k [v] m;
                                  Just vs -> insert k (insertb v vs) m;
                                })
            else m);
      });
  });

ma_coeff :: Mini_alg -> Rat;
ma_coeff xa = fst (snd (rep_mini_alg xa));

mau_coeff :: Mini_alg_unique -> Rat;
mau_coeff xa = ma_coeff (rep_mini_alg_unique xa);

root_int_maina :: Nat -> Int -> Int -> Int -> Int -> (Int, Bool);
root_int_maina pm ipm ip x n =
  let {
    xpm = binary_power x pm;
    xp = times_int xpm x;
  } in (if less_eq_int xp n then (x, equal_int xp n)
         else root_int_maina pm ipm ip
                (divide_int (plus_int (divide_int n xpm) (times_int x ipm)) ip)
                n);

root_int_main :: Nat -> Int -> (Int, Bool);
root_int_main p n =
  (if equal_nat p zero_nat then (one_int, equal_int n one_int)
    else let {
           pm = minus_nat p one_nat;
         } in root_int_maina pm (int_of_nat pm) (int_of_nat p) (start_value n p)
                n);

root_int_floor_pos :: Nat -> Int -> Int;
root_int_floor_pos p x =
  (if equal_nat p zero_nat then zero_int else fst (root_int_main p x));

root_nat_floor :: Nat -> Nat -> Int;
root_nat_floor p x = root_int_floor_pos p (int_of_nat x);

sqrt_int :: Int -> [Int];
sqrt_int x =
  (if less_int x zero_int then []
    else (case sqrt_int_main x of {
           (y, True) ->
             (if equal_int y zero_int then [zero_int] else [y, uminus_int y]);
           (_, False) -> [];
         }));

sqrt_nat :: Nat -> [Nat];
sqrt_nat x = map nat (take one_nat (sqrt_int (int_of_nat x)));

dvd :: forall a. (Eq a, Semidom_modulo a) => a -> a -> Bool;
dvd a b = modulo b a == zerob;

prime_product_factor_main :: Nat -> Nat -> Nat -> Nat -> Nat -> (Nat, Nat);
prime_product_factor_main factor_sq factor_pr limit n i =
  (if less_eq_nat i limit && less_eq_nat (nat_of_integer (2 :: Integer)) i
    then (if dvd i n
           then let {
                  na = divide_nat n i;
                } in (if dvd i na
                       then let {
                              nb = divide_nat na i;
                            } in prime_product_factor_main
                                   (times_nat factor_sq i) factor_pr
                                   (nat (root_nat_floor
  (nat_of_integer (3 :: Integer)) nb))
                                   nb i
                       else (case sqrt_nat na of {
                              [] -> prime_product_factor_main factor_sq
                                      (times_nat factor_pr i)
                                      (nat
(root_nat_floor (nat_of_integer (3 :: Integer)) na))
                                      na (suc i);
                              sn : _ ->
                                (times_nat factor_sq sn, times_nat factor_pr i);
                            }))
           else prime_product_factor_main factor_sq factor_pr limit n (suc i))
    else (factor_sq, times_nat factor_pr n));

prime_product_factor :: Nat -> (Nat, Nat);
prime_product_factor n =
  (case sqrt_nat n of {
    [] -> prime_product_factor_main one_nat one_nat
            (nat (root_nat_floor (nat_of_integer (3 :: Integer)) n)) n
            (nat_of_integer (2 :: Integer));
    s : _ -> (s, one_nat);
  });

ma_sqrt :: Mini_alg -> Mini_alg;
ma_sqrt xa =
  Abs_mini_alg
    (case rep_mini_alg xa of {
      (p, (_, _)) ->
        let {
          a = quotient_of p;
        } in (case a of {
               (aa, b) ->
                 let {
                   aaa = abs_int (times_int aa b);
                 } in (case sqrt_int aaa of {
                        [] -> (zero_rat, (inverse_rat (of_int b), nat aaa));
                        s : _ ->
                          (divide_rat (of_int s) (of_int b),
                            (zero_rat, zero_nat));
                      });
             });
    });

ma_rat :: Mini_alg -> Rat;
ma_rat xa = fst (rep_mini_alg xa);

mau_sqrt :: Mini_alg_unique -> Mini_alg_unique;
mau_sqrt xa =
  Abs_mini_alg_unique
    (let {
       a = quotient_of (ma_rat (rep_mini_alg_unique xa));
     } in (case a of {
            (aa, b) ->
              (case prime_product_factor (nat (times_int (abs_int aa) b)) of {
                (sq, fact) ->
                  let {
                    ma = ma_of_rat
                           (divide_rat
                             (times_rat (of_int (sgn_int aa)) (of_nat sq))
                             (of_int b));
                  } in ma_times ma (ma_sqrt (ma_of_rat (of_nat fact)));
              });
          }));

sqrt :: Real -> Real;
sqrt (Real_of_u r) =
  (if equal_rat (mau_coeff r) zero_rat then Real_of_u (mau_sqrt r)
    else (error :: forall a. String -> (() -> a) -> a)
           "cannot represent sqrt of irrational number"
           (\ _ -> sqrt (Real_of_u r)));

these :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set (Maybe a) -> Set a;
these a = image the (filtera (\ x -> not (is_none x)) a);

key :: forall a b c. (a, (Term b c, Term b c)) -> Maybe (b, Nat);
key (uu, (Fun f ts, uv)) = Just (f, size_list ts);
key (uw, (Var ux, uy)) = Nothing;

gelb :: forall a. (Eq a) => (a -> a -> Bool) -> a -> Maybe a -> Bool;
gelb lt c b = (case b of {
                Nothing -> True;
                Just ba -> lt ba c || ba == c;
              });

geub :: forall a. (Eq a) => (a -> a -> Bool) -> a -> Maybe a -> Bool;
geub lt c b = (case b of {
                Nothing -> False;
                Just ba -> lt ba c || ba == c;
              });

gtlb :: forall a b. (a -> b -> Bool) -> b -> Maybe a -> Bool;
gtlb lt c b = (case b of {
                Nothing -> True;
                Just ba -> lt ba c;
              });

leub :: forall a. (Eq a) => (a -> a -> Bool) -> a -> Maybe a -> Bool;
leub lt c b = (case b of {
                Nothing -> True;
                Just ba -> lt c ba || c == ba;
              });

ltlb :: forall a b. (a -> b -> Bool) -> a -> Maybe b -> Bool;
ltlb lt c b = (case b of {
                Nothing -> False;
                Just a -> lt c a;
              });

ltub :: forall a b. (a -> b -> Bool) -> a -> Maybe b -> Bool;
ltub lt c b = (case b of {
                Nothing -> True;
                Just a -> lt c a;
              });

poly :: forall a. Ns_constraint a -> Linear_poly;
poly (LEQ_ns p a) = p;
poly (GEQ_ns p a) = p;

comp_fun_idem_apply :: forall b a. Comp_fun_idem b a -> b -> a -> a;
comp_fun_idem_apply (Abs_comp_fun_idem x) = x;

set_fold_cfi ::
  forall a b. (Ceq a, Ccompare a) => Comp_fun_idem a b -> b -> Set a -> b;
set_fold_cfi f b (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold_cfi RBT_set: ccompare = None"
        (\ _ -> set_fold_cfi f b (RBT_set rbt));
    Just _ -> foldb (comp_fun_idem_apply f) rbt b;
  });
set_fold_cfi f b (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold_cfi DList_set: ceq = None"
        (\ _ -> set_fold_cfi f b (DList_set dxs));
    Just _ -> foldc (comp_fun_idem_apply f) dxs b;
  });
set_fold_cfi f b (Set_Monad xs) = fold (comp_fun_idem_apply f) xs b;
set_fold_cfi f b (Collect_set p) =
  (error :: forall a. String -> (() -> a) -> a)
    "set_fold_cfi not supported on Collect_set"
    (\ _ -> set_fold_cfi f b (Collect_set p));
set_fold_cfi f b (Complement a) =
  (error :: forall a. String -> (() -> a) -> a)
    "set_fold_cfi not supported on Complement"
    (\ _ -> set_fold_cfi f b (Complement a));

sup_cfi :: forall a. (Lattice a) => Comp_fun_idem a a;
sup_cfi = Abs_comp_fun_idem sup;

sup_seta ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a,
      Set_impl a) => Set (Set a) -> Set a;
sup_seta a =
  (if finite a then set_fold_cfi sup_cfi bot_set a
    else (error :: forall a. String -> (() -> a) -> a) "Sup: infinite"
           (\ _ -> sup_seta a));

vars_term ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => Term a b -> Set b;
vars_term (Var x1) = inserta x1 bot_set;
vars_term (Fun x21 x22) = sup_seta (image vars_term (set x22));

vars_rule ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Set b;
vars_rule r = sup_set (vars_term (fst r)) (vars_term (snd r));

vars_trs ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => Set (Term a b, Term a b) -> Set b;
vars_trs r = sup_seta (image vars_rule r);

explode :: String -> [Char];
explode s =
  map char_of_integer
    (map (let ord k | (k < 128) = Prelude.toInteger k in ord . (Prelude.fromEnum :: Prelude.Char -> Prelude.Int))
      s);

left :: forall a b. a -> Sum_bot a b;
left x = Sumbot (Inl x);

xml_error ::
  forall a b c d.
    String -> ([Xml], (a, (b, (c, [String])))) -> Sum_bot (Xml_error String) d;
xml_error str x =
  (case x of {
    (xmls, (_, (_, (_, pos)))) ->
      let {
        next =
          (case xmls of {
            [] -> "tag close";
            XML tag _ _ : _ -> ("<" ++ implode tag) ++ ">";
            XML_text stra : _ -> ("text element \"" ++ implode stra) ++ "\"";
          });
      } in left (Fatal
                  ((((("parse error on " ++ next) ++ " at ") ++
                      default_showsl_list showsl_lit pos "") ++
                     ":\n") ++
                    str));
  });

mismatch ::
  forall a b.
    String ->
      ([Xml], (a, (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) b;
mismatch tag x =
  (case x of {
    (_, (_, (True, (cands, _)))) -> left (TagMismatch (tag : cands));
    (_, (_, (False, (cands, _)))) ->
      xml_error
        ("expecting " ++ default_showsl_list showsl_lit (tag : cands) "") x;
  });

xml_do ::
  forall a.
    String ->
      (([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a) ->
        (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) a;
xml_do tag p x =
  (case x of {
    (XML nam atts xmls, (_, (_, (_, pos)))) ->
      (if nam == explode tag then p (xmls, (atts, (False, ([], tag : pos))))
        else mismatch tag ([fst x], snd x));
    (XML_text _, _) -> mismatch tag ([fst x], snd x);
  });

right :: forall a b. a -> Sum_bot b a;
right x = Sumbot (Inr x);

xml_or ::
  forall a b c d e f g.
    ((a, (b, (Bool, (c, d)))) -> Sum_bot (Xml_error e) f) ->
      ((a, (b, (g, ([String], d)))) -> Sum_bot (Xml_error e) f) ->
        (a, (b, (g, (c, d)))) -> Sum_bot (Xml_error e) f;
xml_or p1 p2 x =
  (case x of {
    (x1, (atts, (flag, (cands, rest)))) ->
      bind2 (p1 (x1, (atts, (True, (cands, rest)))))
        (\ a ->
          (case a of {
            TagMismatch cands1 -> p2 (x1, (atts, (flag, (cands1, rest))));
            Fatal aa -> left (Fatal aa);
          }))
        right;
  });

filterb :: forall a b. ((a, b) -> Bool) -> Alist a b -> Alist a b;
filterb xb xc = Alist (filter xb (impl_ofa xc));

distinct :: forall a. (Eq a) => [a] -> Bool;
distinct [] = True;
distinct (x : xs) = not (membera xs x) && distinct xs;

add_mset :: forall a. (Eq a) => a -> Multiset a -> Multiset a;
add_mset x (Bag xs) =
  Bag (joina (\ _ (a, b) -> plus_nat a b) (updatea x one_nat emptya) xs);

mset :: forall a. (Eq a) => [a] -> Multiset a;
mset (a : x) = add_mset a (mset x);
mset [] = zero_multiset;

add ::
  forall a b. Partial_object_ext a (Monoid_ext a (Ring_ext a b)) -> a -> a -> a;
add (Partial_object_ext carrier (Monoid_ext mult one (Ring_ext zero add more)))
  = add;

lvars :: [(Nat, Linear_poly)] -> Set Nat;
lvars t = set (map lhs t);

fmmap :: forall a b c. (a -> b) -> Fmap c a -> Fmap c b;
fmmap f (Fmap_of_list m) = Fmap_of_list (map (apsnd f) m);

fmempty :: forall a b. Fmap a b;
fmempty = Fmap_of_list [];

scale :: Rat -> Fmap Nat Rat -> Fmap Nat Rat;
scale r lp = (if equal_rat r zero_rat then fmempty else fmmap (times_rat r) lp);

scaleRat_linear_poly :: Rat -> Linear_poly -> Linear_poly;
scaleRat_linear_poly r p = LinearPoly (scale r (linear_poly_map p));

uminus_linear_poly :: Linear_poly -> Linear_poly;
uminus_linear_poly lp = scaleRat_linear_poly (uminus_rat one_rat) lp;

get_var_coeff :: Fmap Nat Rat -> Nat -> Rat;
get_var_coeff lp v = (case fmlookup lp v of {
                       Nothing -> zero_rat;
                       Just c -> c;
                     });

sequences :: forall a b. (Linorder b) => (a -> b) -> [a] -> [[a]];
sequences key (a : b : xs) =
  (if less (key b) (key a) then desc key b [a] xs
    else asc key b (\ ba -> a : ba) xs);
sequences key [x] = [[x]];
sequences key [] = [];

asc ::
  forall a b. (Linorder b) => (a -> b) -> a -> ([a] -> [a]) -> [a] -> [[a]];
asc key a asa (b : bs) =
  (if less_eq (key a) (key b) then asc key b (\ ys -> asa (a : ys)) bs
    else asa [a] : sequences key (b : bs));
asc key a asa [] = [asa [a]];

desc :: forall a b. (Linorder b) => (a -> b) -> a -> [a] -> [a] -> [[a]];
desc key a asa (b : bs) =
  (if less (key b) (key a) then desc key b (a : asa) bs
    else (a : asa) : sequences key (b : bs));
desc key a asa [] = [a : asa];

mergea :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a] -> [a];
mergea key (a : asa) (b : bs) =
  (if less (key b) (key a) then b : mergea key (a : asa) bs
    else a : mergea key asa (b : bs));
mergea key [] bs = bs;
mergea key (v : va) [] = v : va;

merge_pairs :: forall a b. (Linorder b) => (a -> b) -> [[a]] -> [[a]];
merge_pairs key (a : b : xs) = mergea key a b : merge_pairs key xs;
merge_pairs key [] = [];
merge_pairs key [v] = [v];

merge_all :: forall a b. (Linorder b) => (a -> b) -> [[a]] -> [a];
merge_all key [] = [];
merge_all key [x] = x;
merge_all key (v : vb : vc) = merge_all key (merge_pairs key (v : vb : vc));

msort_key :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a];
msort_key key xs = merge_all key (sequences key xs);

sort_key :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a];
sort_key key = msort_key key;

sorted_list_of_set ::
  forall a. (Ceq a, Ccompare a, Eq a, Linorder a) => Set a -> [a];
sorted_list_of_set (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "sorted_list_of_set RBT_set: ccompare = None"
        (\ _ -> sorted_list_of_set (RBT_set rbt));
    Just _ -> sort_key (\ x -> x) (keysa rbt);
  });
sorted_list_of_set (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "sorted_list_of_set DList_set: ceq = None"
        (\ _ -> sorted_list_of_set (DList_set dxs));
    Just _ -> sort_key (\ x -> x) (list_of_dlist dxs);
  });
sorted_list_of_set (Set_Monad xs) = sort_key (\ x -> x) (remdups xs);

ordered_keys ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Linorder a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Fmap a b -> [a];
ordered_keys m = sorted_list_of_set (fset (fmdom m));

fmfilter :: forall a b. (a -> Bool) -> Fmap a b -> Fmap a b;
fmfilter p (Fmap_of_list m) = Fmap_of_list (filter (\ (k, _) -> p k) m);

fmdrop :: forall a b. (Eq a) => a -> Fmap a b -> Fmap a b;
fmdrop a = fmfilter (\ aa -> not (aa == a));

fmadd :: forall a b. (Eq a) => Fmap a b -> Fmap a b -> Fmap a b;
fmadd (Fmap_of_list m) (Fmap_of_list n) = Fmap_of_list (merge m n);

fmupd :: forall a b. (Eq a) => a -> b -> Fmap a b -> Fmap a b;
fmupd k v m = fmadd m (Fmap_of_list [(k, v)]);

set_var_coeff :: Nat -> Rat -> Fmap Nat Rat -> Fmap Nat Rat;
set_var_coeff v c lp =
  (if equal_rat c zero_rat then fmdrop v lp else fmupd v c lp);

add_monom :: Rat -> Nat -> Fmap Nat Rat -> Fmap Nat Rat;
add_monom c v lp = set_var_coeff v (plus_rat c (get_var_coeff lp v)) lp;

adda :: Fmap Nat Rat -> Fmap Nat Rat -> Fmap Nat Rat;
adda lp1 lp2 =
  foldl (\ lp v -> add_monom (get_var_coeff lp1 v) v lp) lp2 (ordered_keys lp1);

plus_linear_poly :: Linear_poly -> Linear_poly -> Linear_poly;
plus_linear_poly p1 p2 =
  LinearPoly (adda (linear_poly_map p1) (linear_poly_map p2));

minus_linear_poly :: Linear_poly -> Linear_poly -> Linear_poly;
minus_linear_poly lp1 lp2 = plus_linear_poly lp1 (uminus_linear_poly lp2);

constraint_to_qdelta_constraint :: Constraint -> [Ns_constraint QDelta];
constraint_to_qdelta_constraint (LTa l r) =
  [LEQ_ns l (QDelta r (uminus_rat one_rat))];
constraint_to_qdelta_constraint (GTa l r) = [GEQ_ns l (QDelta r one_rat)];
constraint_to_qdelta_constraint (LEQ l r) = [LEQ_ns l (QDelta r zero_rat)];
constraint_to_qdelta_constraint (GEQ l r) = [GEQ_ns l (QDelta r zero_rat)];
constraint_to_qdelta_constraint (EQa l r) =
  [LEQ_ns l (QDelta r zero_rat), GEQ_ns l (QDelta r zero_rat)];
constraint_to_qdelta_constraint (LTPP l1 l2) =
  [LEQ_ns (minus_linear_poly l1 l2) (QDelta zero_rat (uminus_rat one_rat))];
constraint_to_qdelta_constraint (GTPP l1 l2) =
  [GEQ_ns (minus_linear_poly l1 l2) (QDelta zero_rat one_rat)];
constraint_to_qdelta_constraint (LEQPP l1 l2) =
  [LEQ_ns (minus_linear_poly l1 l2) zero_QDelta];
constraint_to_qdelta_constraint (GEQPP l1 l2) =
  [GEQ_ns (minus_linear_poly l1 l2) zero_QDelta];
constraint_to_qdelta_constraint (EQPP l1 l2) =
  [LEQ_ns (minus_linear_poly l1 l2) zero_QDelta,
    GEQ_ns (minus_linear_poly l1 l2) zero_QDelta];

i_constraint_to_qdelta_constraint ::
  forall a. (a, Constraint) -> [(a, Ns_constraint QDelta)];
i_constraint_to_qdelta_constraint (i, c) =
  map (\ a -> (i, a)) (constraint_to_qdelta_constraint c);

to_ns :: forall a. [(a, Constraint)] -> [(a, Ns_constraint QDelta)];
to_ns l = concatMap i_constraint_to_qdelta_constraint l;

funas_term ::
  forall a b. (Ceq a, Ccompare a, Set_impl a) => Term a b -> Set (a, Nat);
funas_term (Var uu) = bot_set;
funas_term (Fun f ts) =
  sup_set (inserta (f, size_list ts) bot_set)
    (foldr (sup_set . funas_term) ts bot_set);

funas_rule ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a) => (Term a b, Term a b) -> Set (a, Nat);
funas_rule r = sup_set (funas_term (fst r)) (funas_term (snd r));

funas_trs ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Set (Term a b, Term a b) -> Set (a, Nat);
funas_trs r = sup_seta (image funas_rule r);

unapp :: forall a b. (Eq a) => a -> Term a b -> (Term a b, [Term a b]);
unapp a (Var x) = (Var x, []);
unapp a (Fun f ss) =
  (if f == a && equal_nat (size_list ss) (nat_of_integer (2 :: Integer))
    then (case unapp a (nth ss zero_nat) of {
           (r, ts) -> (r, ts ++ [nth ss one_nat]);
         })
    else (Fun f ss, []));

is_letter :: Char -> Bool;
is_letter c =
  less_eq_char (Char True False False False False True True False) c &&
    less_eq_char c (Char False True False True True True True False) ||
    (less_eq_char (Char True False False False False False True False) c &&
       less_eq_char c (Char False True False True True False True False) ||
      (less_eq_char (Char False False False False True True False False) c &&
         less_eq_char c (Char True False False True True True False False) ||
        membera
          [Char True True True True True False True False,
            Char False True True False False True False False,
            Char True True False True True True False False,
            Char False True False True True True False False,
            Char True False True True False True False False]
          c));

update_tokens :: forall a. ([a] -> [a]) -> [a] -> Sum [Char] ([a], [a]);
update_tokens f ts = Inr (ts, f ts);

remove_comments_aux_acc :: [Char] -> Bool -> [Char] -> [Char];
remove_comments_aux_acc a False (c : cs) =
  (if equal_char c (Char False False True True True True False False) &&
        take (nat_of_integer (3 :: Integer)) cs ==
          [Char True False False False False True False False,
            Char True False True True False True False False,
            Char True False True True False True False False]
    then remove_comments_aux_acc a True (tla cs)
    else remove_comments_aux_acc (c : a) False cs);
remove_comments_aux_acc a True (c : cs) =
  (if equal_char c (Char True False True True False True False False) &&
        take (nat_of_integer (2 :: Integer)) cs ==
          [Char True False True True False True False False,
            Char False True True True True True False False]
    then remove_comments_aux_acc a False
           (drop (nat_of_integer (2 :: Integer)) cs)
    else remove_comments_aux_acc a True cs);
remove_comments_aux_acc a uu [] = a;

remove_comments_aux :: Bool -> [Char] -> [Char];
remove_comments_aux False (c : cs) =
  (if equal_char c (Char False False True True True True False False) &&
        take (nat_of_integer (3 :: Integer)) cs ==
          [Char True False False False False True False False,
            Char True False True True False True False False,
            Char True False True True False True False False]
    then remove_comments_aux True (tla cs)
    else c : remove_comments_aux False cs);
remove_comments_aux True (c : cs) =
  (if equal_char c (Char True False True True False True False False) &&
        take (nat_of_integer (2 :: Integer)) cs ==
          [Char True False True True False True False False,
            Char False True True True True True False False]
    then remove_comments_aux False (drop (nat_of_integer (2 :: Integer)) cs)
    else remove_comments_aux True cs);
remove_comments_aux uu [] = [];

remove_comments :: [Char] -> [Char];
remove_comments =
  (if False then reverse . remove_comments_aux_acc [] False
    else remove_comments_aux False);

returnb :: forall a b. a -> [b] -> Sum [Char] (a, [b]);
returnb x = (\ ts -> Inr (x, ts));

bindb :: forall a b c. Sum a b -> (b -> Sum a c) -> Sum a c;
bindb m f = (case m of {
              Inl a -> Inl a;
              Inr a -> f a;
            });

bindc ::
  forall a b c.
    ([a] -> Sum [Char] (b, [a])) ->
      (b -> [a] -> Sum [Char] (c, [a])) -> [a] -> Sum [Char] (c, [a]);
bindc m f ts = bindb (m ts) (\ (a, b) -> f a b);

shows_quote :: ([Char] -> [Char]) -> [Char] -> [Char];
shows_quote s =
  (shows_prec_char zero_nat (Char True True True False False True False False) .
    s) .
    shows_prec_char zero_nat (Char True True True False False True False False);

scan_upto :: [Char] -> [Char] -> Sum [Char] ([Char], [Char]);
scan_upto end (t : ts) =
  (if map snd (zip end (t : ts)) == end
    then Inr (end, drop (size_list end) (t : ts))
    else bindb (scan_upto end ts) (\ (res, tsa) -> Inr (t : res, tsa)));
scan_upto end [] =
  Inl ([Char False False True False False True True False,
         Char True False False True False True True False,
         Char False False True False False True True False,
         Char False False False False False True False False,
         Char False True True True False True True False,
         Char True True True True False True True False,
         Char False False True False True True True False,
         Char False False False False False True False False,
         Char False True True False False True True False,
         Char True False False True False True True False,
         Char False True True True False True True False,
         Char False False True False False True True False,
         Char False False False False False True False False,
         Char True False True False False True True False,
         Char False True True True False True True False,
         Char False False True False False True True False,
         Char True False True True False True False False,
         Char True False True True False True True False,
         Char True False False False False True True False,
         Char False True False False True True True False,
         Char True True False True False True True False,
         Char True False True False False True True False,
         Char False True False False True True True False,
         Char False False False False False True False False] ++
        shows_quote (shows_prec_list zero_nat end) []);

trim :: [Char] -> [Char];
trim =
  dropWhile
    (membera
      [Char False False False False False True False False,
        Char False True False True False False False False,
        Char True False False True False False False False,
        Char True False True True False False False False]);

many :: (Char -> Bool) -> [Char] -> Sum [Char] ([Char], [Char]);
many p (t : ts) =
  (if p t then bindb (many p ts) (\ (rs, tsa) -> Inr (t : rs, tsa))
    else Inr ([], t : ts));
many p [] = Inr ([], []);

parse_header :: [Char] -> Sum [Char] ([[Char]], [Char]);
parse_header ts =
  (if take (nat_of_integer (2 :: Integer)) (trim ts) ==
        [Char False False True True True True False False,
          Char True True True True True True False False]
    then bindc (scan_upto
                 [Char True True True True True True False False,
                   Char False True True True True True False False])
           (\ h -> bindc parse_header (\ hs -> returnb (h : hs))) ts
    else bindc (bindc
                 (many (membera
                         [Char False False False False False True False False,
                           Char False True False True False False False False,
                           Char True False False True False False False False,
                           Char True False True True False False False False]))
                 (\ _ -> returnb ()))
           (\ _ -> returnb []) ts);

err_expecting :: forall a b. (Showa a) => [Char] -> [a] -> Sum [Char] (b, [a]);
err_expecting msg ts =
  Inl ([Char True False True False False True True False,
         Char False False False True True True True False,
         Char False False False False True True True False,
         Char True False True False False True True False,
         Char True True False False False True True False,
         Char False False True False True True True False,
         Char True False False True False True True False,
         Char False True True True False True True False,
         Char True True True False False True True False,
         Char False False False False False True False False] ++
        msg ++
          [Char False False True True False True False False,
            Char False False False False False True False False,
            Char False True False False False True True False,
            Char True False True False True True True False,
            Char False False True False True True True False,
            Char False False False False False True False False,
            Char False True True False False True True False,
            Char True True True True False True True False,
            Char True False True False True True True False,
            Char False True True True False True True False,
            Char False False True False False True True False,
            Char False True False True True True False False,
            Char False False False False False True False False] ++
            shows_quote
              (shows_prec_list zero_nat
                (take (nat_of_integer (30 :: Integer)) ts))
              []);

eoi :: forall a. (Showa a) => [a] -> Sum [Char] ((), [a]);
eoi [] = Inr ((), []);
eoi (v : va) =
  err_expecting
    [Char True False True False False True True False,
      Char False True True True False True True False,
      Char False False True False False True True False,
      Char False False False False False True False False,
      Char True True True True False True True False,
      Char False True True False False True True False,
      Char False False False False False True False False,
      Char True False False True False True True False,
      Char False True True True False True True False,
      Char False False False False True True True False,
      Char True False True False True True True False,
      Char False False True False True True True False]
    (v : va);

exactly_aux ::
  [Char] -> [Char] -> [Char] -> [Char] -> Sum [Char] ([Char], [Char]);
exactly_aux s i (x : xs) (y : ys) =
  (if equal_char x y then exactly_aux s i xs ys
    else err_expecting
           ([Char False True False False False True False False] ++
             s ++ [Char False True False False False True False False])
           i);
exactly_aux s i [] xs = Inr (s, trim xs);
exactly_aux s i (x : xs) [] =
  err_expecting
    ([Char False True False False False True False False] ++
      s ++ [Char False True False False False True False False])
    i;

exactly :: [Char] -> [Char] -> Sum [Char] ([Char], [Char]);
exactly s x = exactly_aux s x s x;

parse_attribute_value :: [Char] -> Sum [Char] ([Char], [Char]);
parse_attribute_value =
  bindc (exactly [Char False True False False False True False False])
    (\ _ ->
      bindc (many (\ y ->
                    not (equal_char
                          (Char False True False False False True False False)
                          y)))
        (\ v ->
          bindc (exactly [Char False True False False False True False False])
            (\ _ -> returnb v)));

errorb :: forall a b. [Char] -> [a] -> Sum [Char] (b, [a]);
errorb e = (\ _ -> Inl e);

parse_name :: [Char] -> Sum [Char] ([Char], [Char]);
parse_name s =
  bindc (many is_letter)
    (\ n ->
      bindc (bindc
              (many (membera
                      [Char False False False False False True False False,
                        Char False True False True False False False False,
                        Char True False False True False False False False,
                        Char True False True True False False False False]))
              (\ _ -> returnb ()))
        (\ _ ->
          (if null n
            then errorb
                   ([Char True False True False False True True False,
                      Char False False False True True True True False,
                      Char False False False False True True True False,
                      Char True False True False False True True False,
                      Char True True False False False True True False,
                      Char False False True False True True True False,
                      Char True False True False False True True False,
                      Char False False True False False True True False,
                      Char False False False False False True False False,
                      Char False False True True False True True False,
                      Char True False True False False True True False,
                      Char False False True False True True True False,
                      Char False False True False True True True False,
                      Char True False True False False True True False,
                      Char False True False False True True True False,
                      Char False False False False False True False False] ++
                     letters ++
                       [Char False False False False False True False False,
                         Char False True False False False True True False,
                         Char True False True False True True True False,
                         Char False False True False True True True False,
                         Char False False False False False True False False,
                         Char False True True False False True True False,
                         Char True False False True False True True False,
                         Char False True False False True True True False,
                         Char True True False False True True True False,
                         Char False False True False True True True False,
                         Char False False False False False True False False,
                         Char True True False False True True True False,
                         Char True False False True True True True False,
                         Char True False True True False True True False,
                         Char False True False False False True True False,
                         Char True True True True False True True False,
                         Char False False True True False True True False,
                         Char False False False False False True False False,
                         Char True False False True False True True False,
                         Char True True False False True True True False,
                         Char False False False False False True False False,
                         Char False True False False False True False False] ++
                         take one_nat s ++
                           [Char False True False False False True False False])
            else returnb n)))
    s;

parse_attributes :: [Char] -> Sum [Char] ([([Char], [Char])], [Char]);
parse_attributes [] = Inr ([], []);
parse_attributes (c : s) =
  (if membera
        [Char True True True True False True False False,
          Char False True True True True True False False]
        c
    then Inr ([], c : s)
    else bindc parse_name
           (\ k ->
             bindc (exactly [Char True False True True True True False False])
               (\ _ ->
                 bindc parse_attribute_value
                   (\ v ->
                     bindc parse_attributes
                       (\ atts -> returnb ((k, v) : atts)))))
           (c : s));

oneof_closed :: [Char] -> Sum [Char] ([Char], [Char]);
oneof_closed (x : xs) =
  (if equal_char x (Char False True True True True True False False)
    then Inr ([Char False True True True True True False False], trim xs)
    else (if equal_char x (Char True True True True False True False False) &&
               (case xs of {
                 [] -> False;
                 y : _ ->
                   equal_char y
                     (Char False True True True True True False False);
               })
           then Inr ([Char True True True True False True False False,
                       Char False True True True True True False False],
                      trim (tla xs))
           else err_expecting
                  [Char True True True True False True True False,
                    Char False True True True False True True False,
                    Char True False True False False True True False,
                    Char False False False False False True False False,
                    Char True True True True False True True False,
                    Char False True True False False True True False,
                    Char False False False False False True False False,
                    Char True True False True True False True False,
                    Char True True True True False True False False,
                    Char False True True True True True False False,
                    Char False False True True False True False False,
                    Char False False False False False True False False,
                    Char False True True True True True False False,
                    Char True False True True True False True False]
                  (x : xs)));
oneof_closed [] =
  err_expecting
    [Char True True True True False True True False,
      Char False True True True False True True False,
      Char True False True False False True True False,
      Char False False False False False True False False,
      Char True True True True False True True False,
      Char False True True False False True True False,
      Char False False False False False True False False,
      Char True True False True True False True False,
      Char True True True True False True False False,
      Char False True True True True True False False,
      Char False False True True False True False False,
      Char False False False False False True False False,
      Char False True True True True True False False,
      Char True False True True True False True False]
    [];

parse_text :: [Char] -> Sum [Char] (Maybe [Char], [Char]);
parse_text =
  bindc (many (\ y ->
                not (equal_char
                      (Char False False True True True True False False) y)))
    (\ ts ->
      let {
        text = trim ts;
      } in (if null text then returnb Nothing
             else returnb (Just (reverse (trim (reverse text))))));

parse_nodes :: [Char] -> Sum [Char] ([Xml], [Char]);
parse_nodes ts =
  (if null ts ||
        take (nat_of_integer (2 :: Integer)) ts ==
          [Char False False True True True True False False,
            Char True True True True False True False False]
    then returnb [] ts
    else (if not (equal_char (hda ts)
                   (Char False False True True True True False False))
           then bindc parse_text
                  (\ t ->
                    bindc parse_nodes (\ ns -> returnb (XML_text (the t) : ns)))
                  ts
           else bindc (exactly
                        [Char False False True True True True False False])
                  (\ _ ->
                    bindc parse_name
                      (\ n ->
                        bindc parse_attributes
                          (\ atts ->
                            bindc oneof_closed
                              (\ e ->
                                (if e == [Char True True True True False True
    False False,
   Char False True True True True True False False]
                                  then bindc parse_nodes
 (\ cs -> returnb (XML n atts [] : cs))
                                  else bindc parse_nodes
 (\ cs ->
   bindc (exactly
           [Char False False True True True True False False,
             Char True True True True False True False False])
     (\ _ ->
       bindc (exactly n)
         (\ _ ->
           bindc (exactly [Char False True True True True True False False])
             (\ _ ->
               bindc parse_nodes (\ ns -> returnb (XML n atts cs : ns)))))))))))
                  ts));

parse_node :: [Char] -> Sum [Char] (Xml, [Char]);
parse_node =
  bindc (exactly [Char False False True True True True False False])
    (\ _ ->
      bindc parse_name
        (\ n ->
          bindc parse_attributes
            (\ atts ->
              bindc oneof_closed
                (\ e ->
                  (if e == [Char True True True True False True False False,
                             Char False True True True True True False False]
                    then returnb (XML n atts [])
                    else bindc parse_nodes
                           (\ cs ->
                             bindc (exactly
                                     [Char False False True True True True False
False,
                                       Char True True True True False True False
 False])
                               (\ _ ->
                                 bindc (exactly n)
                                   (\ _ ->
                                     bindc (exactly
     [Char False True True True True True False False])
                                       (\ _ -> returnb (XML n atts cs))))))))));

parse_doc :: [Char] -> Sum [Char] (Xmldoc, [Char]);
parse_doc =
  bindc (update_tokens remove_comments)
    (\ _ ->
      bindc parse_header
        (\ h ->
          bindc parse_node
            (\ xml -> bindc eoi (\ _ -> returnb (XMLDOC h xml)))));

pick_up ::
  forall a b. (Eq a) => [(a, b)] -> a -> [(a, b)] -> Maybe (b, [(a, b)]);
pick_up rest key [] = Nothing;
pick_up rest key ((l, r) : s) =
  (if key == l then Just (r, rest ++ s) else pick_up ((l, r) : rest) key s);

nat_of_digit :: Char -> Maybe Nat;
nat_of_digit x =
  (if equal_char x (Char False False False False True True False False)
    then Just zero_nat
    else (if equal_char x (Char True False False False True True False False)
           then Just one_nat
           else (if equal_char x
                      (Char False True False False True True False False)
                  then Just (nat_of_integer (2 :: Integer))
                  else (if equal_char x
                             (Char True True False False True True False False)
                         then Just (nat_of_integer (3 :: Integer))
                         else (if equal_char x
                                    (Char False False True False True True False
                                      False)
                                then Just (nat_of_integer (4 :: Integer))
                                else (if equal_char x
   (Char True False True False True True False False)
                                       then Just (nat_of_integer (5 :: Integer))
                                       else (if equal_char x
          (Char False True True False True True False False)
      then Just (nat_of_integer (6 :: Integer))
      else (if equal_char x (Char True True True False True True False False)
             then Just (nat_of_integer (7 :: Integer))
             else (if equal_char x
                        (Char False False False True True True False False)
                    then Just (nat_of_integer (8 :: Integer))
                    else (if equal_char x
                               (Char True False False True True True False
                                 False)
                           then Just (nat_of_integer (9 :: Integer))
                           else Nothing))))))))));

nat_of_string_aux :: Nat -> [Char] -> Maybe Nat;
nat_of_string_aux n [] = Just n;
nat_of_string_aux n (d : s) =
  bind (nat_of_digit d)
    (\ m ->
      nat_of_string_aux
        (plus_nat (times_nat (nat_of_integer (10 :: Integer)) n) m) s);

nat_of_string :: [Char] -> Sum String Nat;
nat_of_string s =
  (case (if null s then Nothing else nat_of_string_aux zero_nat s) of {
    Nothing -> Inl (("cannot convert \"" ++ implode s) ++ "\" to a number");
    Just a -> Inr a;
  });

safe_head :: forall a. [a] -> Maybe a;
safe_head [] = Nothing;
safe_head (x : xs) = Just x;

int_of_string :: [Char] -> Sum String Int;
int_of_string s =
  (if safe_head s == Just (Char True False True True False True False False)
    then bindb (nat_of_string (tla s)) (\ n -> Inr (uminus_int (int_of_nat n)))
    else bindb (nat_of_string s) (\ n -> Inr (int_of_nat n)));

xml_take_int ::
  forall a.
    (Int ->
      ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a) ->
      ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a;
xml_take_int p xs =
  (case xs of {
    ([], _) -> xml_error "expecting an integer" xs;
    (XML _ _ _ : _, _) -> xml_error "expecting an integer" xs;
    (XML_text text : xmls, s) -> (case int_of_string text of {
                                   Inl x -> xml_error x xs;
                                   Inr n -> p n (xmls, s);
                                 });
  });

xml_return ::
  forall a.
    a -> ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
           Sum_bot (Xml_error String) a;
xml_return v x = (case x of {
                   ([], _) -> right v;
                   (_ : _, _) -> xml_error "expecting tag close" x;
                 });

xml_int ::
  String ->
    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) Int;
xml_int tag = xml_do tag (xml_take_int xml_return);

xml_take_nat ::
  forall a.
    (Nat ->
      ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a) ->
      ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a;
xml_take_nat p xs =
  (case xs of {
    ([], _) -> xml_error "expecting a number" xs;
    (XML _ _ _ : _, _) -> xml_error "expecting a number" xs;
    (XML_text text : xmls, s) -> (case nat_of_string text of {
                                   Inl x -> xml_error x xs;
                                   Inr n -> p n (xmls, s);
                                 });
  });

xml_nat ::
  String ->
    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) Nat;
xml_nat tag = xml_do tag (xml_take_nat xml_return);

zero_enat :: Enat;
zero_enat = Enat zero_nat;

minus_enat :: Enat -> Enat -> Enat;
minus_enat (Enat a) Infinity_enat = zero_enat;
minus_enat Infinity_enat n = Infinity_enat;
minus_enat (Enat a) (Enat b) = Enat (minus_nat a b);

equal_enat :: Enat -> Enat -> Bool;
equal_enat (Enat nat) Infinity_enat = False;
equal_enat Infinity_enat (Enat nat) = False;
equal_enat (Enat nata) (Enat nat) = equal_nat nata nat;
equal_enat Infinity_enat Infinity_enat = True;

one_enat :: Enat;
one_enat = Enat one_nat;

xml_take_many_sub ::
  forall a b.
    [a] ->
      Nat ->
        Enat ->
          ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
            Sum_bot (Xml_error String) a) ->
            ([a] ->
              ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
                Sum_bot (Xml_error String) b) ->
              ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
                Sum_bot (Xml_error String) b;
xml_take_many_sub acc minOccurs maxOccurs p1 p2 ([], (atts, (allow, rest))) =
  (if equal_nat minOccurs zero_nat
    then p2 (reverse acc) ([], (atts, (allow, rest)))
    else bind2 (p1 (XML [] [] [], (atts, (False, rest)))) left
           (\ _ -> left (Fatal "unexpected")));
xml_take_many_sub acc minOccurs maxOccurs p1 p2
  (xml : xmls, (atts, (allow, (cands, rest)))) =
  (if equal_enat maxOccurs zero_enat
    then p2 (reverse acc) (xml : xmls, (atts, (allow, (cands, rest))))
    else bind2 (p1 (xml, (atts, (equal_nat minOccurs zero_nat, (cands, rest)))))
           (\ e ->
             (case e of {
               TagMismatch _ ->
                 p2 (reverse acc) (xml : xmls, (atts, (allow, (cands, rest))));
               Fatal _ -> left e;
             }))
           (\ a ->
             xml_take_many_sub (a : acc) (minus_nat minOccurs one_nat)
               (minus_enat maxOccurs one_enat) p1 p2
               (xmls, (atts, (False, ([], rest))))));

position ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Nat;
position =
  xml_do "position" (xml_take_nat (\ n -> xml_return (minus_nat n one_nat)));

xml_change ::
  forall a b.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (a -> ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
              Sum_bot (Xml_error String) b) ->
        (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) b;
xml_change p f x = bind2 (p x) left (\ a -> (case x of {
      (_, rest) -> f a ([], rest);
    }));

xml_take ::
  forall a b.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (a -> ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
              Sum_bot (Xml_error String) b) ->
        ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) b;
xml_take p1 p2 x =
  (case x of {
    ([], rest) ->
      bind2 (p1 (XML [] [] [], rest)) left (\ _ -> left (Fatal "unexpected"));
    (xa : xs, rest) ->
      (case rest of {
        (atts, (flag, (cands, resta))) ->
          bind2 (p1 (xa, (atts, (flag, (cands, resta))))) left
            (\ a -> p2 a (xs, (atts, (False, ([], resta)))));
      });
  });

afs ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [((a, Nat), Af_entry)];
afs xml2name =
  xml_do "argumentFilter"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "argumentFilterEntry"
        (xml_take xml2name
          (\ name ->
            xml_take (xml_nat "arity")
              (\ arity ->
                xml_take
                  (xml_or
                    (xml_change (xml_nat "collapsing")
                      (\ n -> xml_return (Collapse (minus_nat n one_nat))))
                    (xml_do "nonCollapsing"
                      (xml_take_many_sub [] zero_nat Infinity_enat position
                        (\ ls -> xml_return (AFList ls)))))
                  (\ main -> xml_return ((name, arity), main))))))
      xml_return);

scg_position ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Nat;
scg_position = xml_nat "position";

xml_take_default ::
  forall a b.
    a -> ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
           Sum_bot (Xml_error String) a) ->
           (a -> ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) b) ->
             ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
               Sum_bot (Xml_error String) b;
xml_take_default a p1 p2 xs =
  (case xs of {
    ([], _) -> p2 a xs;
    (xml : xmls, (atts, (allow, (cands, rest)))) ->
      bind2 (p1 (xml, (atts, (True, (cands, rest)))))
        (\ e ->
          (case e of {
            TagMismatch cands1 ->
              p2 a (xml : xmls, (atts, (allow, (cands1, rest))));
            Fatal _ -> left e;
          }))
        (\ aa -> p2 aa (xmls, (atts, (False, ([], rest)))));
  });

xml_take_text ::
  forall a.
    ([Char] ->
      ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a) ->
      ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a;
xml_take_text p xs = (case xs of {
                       ([], _) -> xml_error "expecting a text" xs;
                       (XML _ _ _ : _, _) -> xml_error "expecting a text" xs;
                       (XML_text text : xmls, s) -> p text (xmls, s);
                     });

xml_text ::
  String ->
    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) [Char];
xml_text tag = xml_do tag (xml_take_text xml_return);

plain_var ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) [Char];
plain_var = xml_text "var";

var ::
  forall a.
    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) (Term a [Char]);
var = xml_change plain_var (xml_return . Var);

term ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Term a [Char]);
term xml2name x =
  xml_or var
    (xml_do "funapp"
      (xml_take xml2name
        (\ name ->
          xml_take_many_sub [] zero_nat Infinity_enat
            (xml_or (term xml2name)
              (xml_do "arg" (xml_take (term xml2name) xml_return)))
            (\ args -> xml_return (Fun name args)))))
    x;

conditions ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   String ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String)
                         [(Term a [Char], Term a [Char])];
conditions xml2name tag =
  xml_do tag
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "condition"
        (xml_take (xml_do "lhs" (xml_take (term xml2name) xml_return))
          (\ l ->
            xml_take (xml_do "rhs" (xml_take (term xml2name) xml_return))
              (\ r -> xml_return (l, r)))))
      xml_return);

crule ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   String ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String)
                         ((Term a [Char], Term a [Char]),
                           [(Term a [Char], Term a [Char])]);
crule xml2name tag =
  xml_do tag
    (xml_take (xml_do "lhs" (xml_take (term xml2name) xml_return))
      (\ l ->
        xml_take (xml_do "rhs" (xml_take (term xml2name) xml_return))
          (\ r ->
            xml_take_default [] (conditions xml2name "conditions")
              (\ conds -> xml_return ((l, r), conds)))));

rule ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Term a [Char], Term a [Char]);
rule xml2name =
  xml_change (crule xml2name "rule")
    (\ (lr, conds) ->
      (if null conds then xml_return lr
        else xml_error "conditional rule is not allowed here"));

bool_of_string :: [Char] -> Sum String Bool;
bool_of_string s =
  (if s == [Char False False True False True True True False,
             Char False True False False True True True False,
             Char True False True False True True True False,
             Char True False True False False True True False]
    then Inr True
    else (if s == [Char False True True False False True True False,
                    Char True False False False False True True False,
                    Char False False True True False True True False,
                    Char True True False False True True True False,
                    Char True False True False False True True False]
           then Inr False
           else Inl (("cannot convert \"" ++ implode s) ++ "\" into Boolean")));

xml_bool ::
  String ->
    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) Bool;
xml_bool tag x =
  bind2 (xml_text tag x) left
    (\ str -> (case bool_of_string str of {
                Inl err -> xml_error err ([fst x], snd x);
                Inr a -> right a;
              }));

scg ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       ((Term a [Char], Term a [Char]),
                         ([(Nat, Nat)], [(Nat, Nat)]));
scg xml2name =
  xml_do "sizeChangeGraph"
    (xml_take (rule xml2name)
      (\ lr ->
        xml_take_many_sub [] zero_nat Infinity_enat
          (xml_do "edge"
            (xml_take scg_position
              (\ p ->
                xml_take (xml_bool "strict")
                  (\ s ->
                    xml_take scg_position (\ q -> xml_return (s, (p, q)))))))
          (\ edges ->
            xml_return
              (lr, (map_filter
                      (\ x -> (if fst x then Just (snd x) else Nothing)) edges,
                     map_filter
                       (\ x -> (if not (fst x) then Just (snd x) else Nothing))
                       edges)))));

gt1 ::
  forall a b c d. [(Term a b, Term c d)] -> [(Maybe (a, Nat), Maybe (c, Nat))];
gt1 = map (\ (s, t) -> (root s, root t));

map_term :: forall a b c d. (a -> b) -> (c -> d) -> Term a c -> Term b d;
map_term f1 f2 (Var x1) = Var (f2 x1);
map_term f1 f2 (Fun x21 x22) = Fun (f1 x21) (map (map_term f1 f2) x22);

class_to_term_intern ::
  forall a b. (Nat -> a) -> Nat -> Term b (Sum () a) -> (Nat, Term b a);
class_to_term_intern iv i (Fun f ts) =
  (case foldr (\ t (j, ss) -> (case class_to_term_intern iv j t of {
                                (k, s) -> (k, s : ss);
                              }))
          ts (i, [])
    of {
    (k, ss) -> (k, Fun f ss);
  });
class_to_term_intern iv i (Var (Inl uu)) = (plus_nat i one_nat, Var (iv i));
class_to_term_intern iv i (Var (Inr x)) = (i, Var x);

class_to_term :: forall a. Char -> Term a (Sum () [Char]) -> Term a [Char];
class_to_term c t =
  snd (class_to_term_intern (\ i -> c : shows_prec_nat zero_nat i []) zero_nat
        t);

subst_apply_term :: forall a b c. Term a b -> (b -> Term a c) -> Term a c;
subst_apply_term (Var x) alpha = alpha x;
subst_apply_term (Fun f ss) alpha =
  Fun f (map (\ s -> subst_apply_term s alpha) ss);

subst_compose ::
  forall a b c d. (a -> Term b c) -> (c -> Term b d) -> a -> Term b d;
subst_compose sigma tau = (\ x -> subst_apply_term (sigma x) tau);

subst_of :: forall a b. (Eq a) => [(a, Term b a)] -> a -> Term b a;
subst_of ss = foldr (\ (x, t) sigma -> subst_compose sigma (subst x t)) ss Var;

contains_var_term :: forall a b. (Eq a) => a -> Term b a -> Bool;
contains_var_term x (Var y) = x == y;
contains_var_term x (Fun uu ts) = any (contains_var_term x) ts;

subst_list ::
  forall a b.
    (a -> Term b a) -> [(Term b a, Term b a)] -> [(Term b a, Term b a)];
subst_list sigma ys =
  map (\ p -> (subst_apply_term (fst p) sigma, subst_apply_term (snd p) sigma))
    ys;

decompose ::
  forall a b c. (Eq a) => Term a b -> Term a c -> Maybe [(Term a b, Term a c)];
decompose s t =
  (case (s, t) of {
    (Var _, _) -> Nothing;
    (Fun _ _, Var _) -> Nothing;
    (Fun f ss, Fun g ts) -> (if f == g then zip_option ss ts else Nothing);
  });

unify ::
  forall a b.
    (Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(b, Term a b)] -> Maybe [(b, Term a b)];
unify [] bs = Just bs;
unify ((Fun f ss, Fun g ts) : e) bs =
  (case decompose (Fun f ss) (Fun g ts) of {
    Nothing -> Nothing;
    Just us -> unify (us ++ e) bs;
  });
unify ((Var x, t) : e) bs =
  (if equal_term t (Var x) then unify e bs
    else (if contains_var_term x t then Nothing
           else unify (subst_list (subst x t) e) ((x, t) : bs)));
unify ((Fun v va, Var x) : e) bs =
  (if contains_var_term x (Fun v va) then Nothing
    else unify (subst_list (subst x (Fun v va)) e) ((x, Fun v va) : bs));

mgu ::
  forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Maybe (b -> Term a b);
mgu s t = (case unify [(s, t)] [] of {
            Nothing -> Nothing;
            Just res -> Just (subst_of res);
          });

mgu_class ::
  forall a.
    (Eq a) => Term a (Sum () [Char]) ->
                Term a [Char] -> Maybe ([Char] -> Term a [Char]);
mgu_class cs t =
  mgu (class_to_term (Char False True False True True True True False) cs)
    (map_term (\ x -> x)
      (\ a -> Char True False False True True True True False : a) t);

enumerate :: forall a. Nat -> [a] -> [(Nat, a)];
enumerate n (x : xs) = (n, x) : enumerate (suc n) xs;
enumerate n [] = [];

partition :: forall a. (a -> Bool) -> [a] -> ([a], [a]);
partition p [] = ([], []);
partition p (x : xs) =
  (case partition p xs of {
    (yes, no) -> (if p x then (x : yes, no) else (yes, x : no));
  });

removeAll :: forall a. (Eq a) => a -> [a] -> [a];
removeAll x [] = [];
removeAll x (y : xs) = (if x == y then removeAll x xs else y : removeAll x xs);

delete_aux :: forall a b. (Eq a) => a -> [(a, b)] -> [(a, b)];
delete_aux k [] = [];
delete_aux ka ((k, v) : xs) =
  (if ka == k then xs else (k, v) : delete_aux ka xs);

deleteb :: forall a b. (Eq a) => a -> Alist a b -> Alist a b;
deleteb xb xc = Alist (delete_aux xb (impl_ofa xc));

deletea :: forall a b. (Ccompare a, Eq a) => a -> Mapping a b -> Mapping a b;
deletea k (RBT_Mapping t) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "delete RBT_Mapping: ccompare = None"
        (\ _ -> deletea k (RBT_Mapping t));
    Just _ -> RBT_Mapping (deletec k t);
  });
deletea k (Assoc_List_Mapping al) = Assoc_List_Mapping (deleteb k al);
deletea k (Mapping m) = Mapping (fun_upd m k Nothing);

match_term_list_code ::
  forall a b c.
    (Eq a, Ccompare b, Eq b,
      Eq c) => [(Term a b, Term a c)] ->
                 Mapping b (Term a c) -> Maybe (Mapping b (Term a c));
match_term_list_code ((Fun f ss, Var x) : p) sigma = Nothing;
match_term_list_code ((Fun f ss, Fun g ts) : p) sigma =
  (case decompose (Fun f ss) (Fun g ts) of {
    Nothing -> Nothing;
    Just us -> match_term_list_code (us ++ p) sigma;
  });
match_term_list_code ((Var x, t) : p) sigma =
  (if is_none (lookupb sigma x) || lookupb sigma x == Just t
    then match_term_list_code p (updateb x t sigma) else Nothing);
match_term_list_code [] sigma = Just sigma;

subst_of_map :: forall a b. (a -> b) -> (a -> Maybe b) -> a -> b;
subst_of_map d sigma x = (case sigma x of {
                           Nothing -> d x;
                           Just t -> t;
                         });

match_list ::
  forall a b c.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Eq c) => (a -> Term b c) ->
                 [(Term b a, Term b c)] -> Maybe (a -> Term b c);
match_list d p =
  map_option (subst_of_map d . lookupb) (match_term_list_code p emptyb);

match ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b -> Term a b -> Maybe (b -> Term a b);
match t l = match_list Var [(l, t)];

rep_vec_impl :: forall a. Vec_impl a -> (Nat, IArray.IArray a);
rep_vec_impl (Abs_vec_impl x) = x;

dim_vec_impl :: forall a. Vec_impl a -> Nat;
dim_vec_impl xa = fst (rep_vec_impl xa);

dim_vec :: forall a. Vec a -> Nat;
dim_vec (Vec_impl v) = dim_vec_impl v;

map_mat :: forall a b. (a -> b) -> Mat a -> Mat b;
map_mat f a = mat (dim_row a) (dim_col a) (\ ij -> f (index_mat a ij));

one_mat :: forall a. (One a, Zero a) => Nat -> Mat a;
one_mat n = mat n n (\ (i, j) -> (if equal_nat i j then onea else zerob));

sum_list :: forall a. (Monoid_add a) => [a] -> a;
sum_list xs = foldr plus xs zerob;

vec_index_impl :: forall a. Vec_impl a -> Nat -> a;
vec_index_impl xa = (case rep_vec_impl xa of {
                      (_, a) -> sub a;
                    });

vec_index :: forall a. Vec a -> Nat -> a;
vec_index (Vec_impl v) i = vec_index_impl v i;

scalar_prod :: forall a. (Semiring_0 a) => Vec a -> Vec a -> a;
scalar_prod v w =
  sum_list
    (map (\ i -> times (vec_index v i) (vec_index w i))
      (upt zero_nat (dim_vec w)));

times_mat :: forall a. (Semiring_0 a) => Mat a -> Mat a -> Mat a;
times_mat a b =
  mat (dim_row a) (dim_col b) (\ (i, j) -> scalar_prod (row a i) (col b j));

pow_mat :: forall a. (Semiring_1 a) => Mat a -> Nat -> Mat a;
pow_mat a k =
  (if equal_nat k zero_nat then one_mat (dim_row a)
    else times_mat (pow_mat a (minus_nat k one_nat)) a);

rBT_Impl_fold1 :: forall a. (a -> a -> a) -> Rbta a () -> a;
rBT_Impl_fold1 f (Branch ca (Branch c l ka va ra) k v r) =
  folda (\ kb _ -> f kb) r (f k (rBT_Impl_fold1 f (Branch c l ka va ra)));
rBT_Impl_fold1 f (Branch c Empty k v r) = folda (\ ka _ -> f ka) r k;
rBT_Impl_fold1 f Empty = error "undefined";

fold1 :: forall a. (Ccompare a) => (a -> a -> a) -> Mapping_rbt a () -> a;
fold1 x xc = rBT_Impl_fold1 x (impl_ofb xc);

imagea ::
  forall a b.
    (Ceq a, Ccompare a, Ceq b, Ccompare b,
      Set_impl b) => Set (a, b) -> Set a -> Set b;
imagea (RBT_set rbt) c =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Image RBT_set: ccompare1 = None" (\ _ -> imagea (RBT_set rbt) c);
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "Image RBT_set: ccompare2 = None" (\ _ -> imagea (RBT_set rbt) c);
        Just _ ->
          foldb (\ (x, y) acc -> (if member x c then inserta y acc else acc))
            rbt bot_set;
      });
  });
imagea (DList_set dxs) b =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Image DList_set: ceq1 = None" (\ _ -> imagea (DList_set dxs) b);
    Just _ ->
      (case (ceq :: Maybe (b -> b -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "Image DList_set: ceq2 = None" (\ _ -> imagea (DList_set dxs) b);
        Just _ ->
          foldc (\ (x, y) acc -> (if member x b then inserta y acc else acc))
            dxs bot_set;
      });
  });
imagea (Set_Monad rxs) a =
  Set_Monad
    (fold (\ (x, y) rest -> (if member x a then y : rest else rest)) rxs []);
imagea x y = image snd (filtera (\ (xa, _) -> member xa y) x);

zero :: forall a b. Partial_object_ext a (Monoid_ext a (Ring_ext a b)) -> a;
zero (Partial_object_ext carrier (Monoid_ext mult one (Ring_ext zero add more)))
  = zero;

b_i_l :: forall a b. State a b -> Mapping Nat (a, b);
b_i_l (State x1 x2 x3 x4 x5 x6) = x2;

indexl :: forall a b. State a b -> Nat -> a;
indexl s = (fst . the) . lookupb (b_i_l s);

b_i_u :: forall a b. State a b -> Mapping Nat (a, b);
b_i_u (State x1 x2 x3 x4 x5 x6) = x3;

indexu :: forall a b. State a b -> Nat -> a;
indexu s = (fst . the) . lookupb (b_i_u s);

args :: forall a b. Term a b -> [Term a b];
args (Var x1) = [];
args (Fun x21 x22) = x22;

aarity :: forall a. (a -> Nat -> [a]) -> a -> Nat -> Nat;
aarity sm f n = minus_nat (size_list (sm f n)) one_nat;

list2position :: [Nat] -> [Nat];
list2position [] = [];
list2position (n : ns) = n : list2position ns;

pos ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) [Nat];
pos = xml_do "positionInTerm"
        (xml_take_many_sub [] zero_nat Infinity_enat position
          (\ lst -> xml_return (list2position lst)));

xml_leaf ::
  forall a.
    String ->
      a -> (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
             Sum_bot (Xml_error String) a;
xml_leaf tag ret = xml_do tag (xml_return ret);

map_entry :: forall a b. (Eq a) => a -> (b -> b) -> [(a, b)] -> [(a, b)];
map_entry k f [] = [];
map_entry k f (p : ps) =
  (if fst p == k then (k, f (snd p)) : ps else p : map_entry k f ps);

ctxt ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Ctxt a [Char]);
ctxt xml2name x =
  xml_or (xml_do "box" (xml_return Hole))
    (xml_do "funContext"
      (xml_take xml2name
        (\ name ->
          xml_take
            (xml_do "before"
              (xml_take_many_sub [] zero_nat Infinity_enat (term xml2name)
                xml_return))
            (\ left ->
              xml_take (ctxt xml2name)
                (\ mid ->
                  xml_take
                    (xml_do "after"
                      (xml_take_many_sub [] zero_nat Infinity_enat
                        (term xml2name) xml_return))
                    (\ right -> xml_return (More name left mid right)))))))
    x;

xml_take_optional ::
  forall a b.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (Maybe a ->
        ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) b) ->
        ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) b;
xml_take_optional p1 p2 xs =
  (case xs of {
    ([], _) -> p2 Nothing xs;
    (xml : xmls, (atts, (allow, (cands, rest)))) ->
      bind2 (p1 (xml, (atts, (True, (cands, rest)))))
        (\ e ->
          (case e of {
            TagMismatch cands1 ->
              p2 Nothing (xml : xmls, (atts, (allow, (cands1, rest))));
            Fatal _ -> left e;
          }))
        (\ a -> p2 (Just a) (xmls, (atts, (False, ([], rest)))));
  });

relstep ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       ([Nat],
                         ((Term a [Char], Term a [Char]),
                           (Bool, Term a [Char])));
relstep xml2name =
  xml_do "rewriteStep"
    (xml_take pos
      (\ p ->
        xml_take (rule xml2name)
          (\ r ->
            xml_take_optional (xml_leaf "relative" ())
              (\ rel ->
                xml_take (term xml2name)
                  (\ t -> xml_return (p, (r, (is_none rel, t))))))));

relsteps ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (Term a [Char],
                         [([Nat],
                            ((Term a [Char], Term a [Char]),
                              (Bool, Term a [Char])))]);
relsteps xml2name =
  xml_do "rewriteSequence"
    (xml_take
      (xml_do "startTerm" (xml_take (term xml2name) (\ x -> xml_return (id x))))
      (\ start ->
        xml_take_many_sub [] zero_nat Infinity_enat (relstep xml2name)
          (\ steps -> xml_return (start, steps))));

substa ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [([Char], Term a [Char])];
substa xml2name =
  xml_do "substitution"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "substEntry"
        (xml_take (xml_do "var" (xml_take_text xml_return))
          (\ var -> xml_take (term xml2name) (\ trm -> xml_return (var, trm)))))
      xml_return);

loop ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (Term a [Char],
                         ([([Nat],
                             ((Term a [Char], Term a [Char]),
                               (Bool, Term a [Char])))],
                           ([([Char], Term a [Char])], Ctxt a [Char])));
loop xml2name =
  xml_do "loop"
    (xml_take (relsteps xml2name)
      (\ (s, rseq) ->
        xml_take (substa xml2name)
          (\ sigma ->
            xml_take (ctxt xml2name)
              (\ c -> xml_return (s, (rseq, (sigma, c)))))));

proj ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (ProjL a);
proj xml2name =
  xml_change (afs xml2name)
    (\ afl ->
      xml_return
        (Projection (map (\ (fa, a) -> (case a of {
 Collapse aa -> (fa, aa);
 AFList _ -> (fa, snd fa);
                                       }))
                      afl)));

proj_term :: forall a b. ((a, Nat) -> Nat) -> Term a b -> Term a b;
proj_term p (Var x) = Var x;
proj_term p (Fun f ts) = let {
                           n = size_list ts;
                           i = p (f, n);
                         } in (if less_nat i n then nth ts i else Fun f ts);

start_term ::
  forall a.
    (Eq a,
      Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) a) ->
                    Term a [Char] ->
                      (Xml, ([([Char], [Char])],
                              (Bool, ([String], [String])))) ->
                        Sum_bot (Xml_error String) (Term a [Char]);
start_term xml2name t =
  xml_do "startTerm"
    (xml_take (term xml2name)
      (\ s ->
        (if equal_term s t then xml_return t
          else xml_error "<startTerm> does not match lhs")));

rstep ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       ([Nat], ((Term a [Char], Term a [Char]), Term a [Char]));
rstep xml2name =
  xml_do "rewriteStep"
    (xml_take pos
      (\ p ->
        xml_take (rule xml2name)
          (\ r -> xml_take (term xml2name) (\ t -> xml_return (p, (r, t))))));

rseq ::
  forall a.
    (Eq a,
      Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) a) ->
                    ((a, Nat) -> Nat) ->
                      (Term a [Char], Term a [Char]) ->
                        (Xml, ([([Char], [Char])],
                                (Bool, ([String], [String])))) ->
                          Sum_bot (Xml_error String)
                            ((Term a [Char], Term a [Char]),
                              [([Nat],
                                 ((Term a [Char], Term a [Char]),
                                   Term a [Char]))]);
rseq xml2name pi r =
  xml_do "rewriteSequence"
    (xml_take (start_term xml2name (proj_term pi (fst r)))
      (\ _ ->
        xml_take_many_sub [] zero_nat Infinity_enat (rstep xml2name)
          (\ rseq -> xml_return (r, rseq))));

trivial_mute_fun :: forall a. (Comm_ring_1 a) => a -> a -> (a, (a, a));
trivial_mute_fun x y = (x, (y, onea));

fst_sel_fun :: forall a. [(Nat, a)] -> Nat;
fst_sel_fun x = fst (hda x);

prod_list :: forall a. (Monoid_mult a) => [a] -> a;
prod_list xs = foldr times xs onea;

list_update :: forall a. [a] -> Nat -> a -> [a];
list_update [] i y = [];
list_update (x : xs) i y =
  (if equal_nat i zero_nat then y : xs
    else x : list_update xs (minus_nat i one_nat) y);

mat_swaprows_impl :: forall a. Nat -> Nat -> Mat_impl a -> Mat_impl a;
mat_swaprows_impl xc xd xe =
  Abs_mat_impl
    (case rep_mat_impl xe of {
      (nr, a) ->
        (case a of {
          (nc, aa) ->
            (if less_nat xc nr && less_nat xd nr
              then let {
                     ai = sub aa xc;
                     aj = sub aa xd;
                     arows = list_of aa;
                     ab = IArray.of_list
                            (list_update (list_update arows xc aj) xd ai);
                   } in (nr, (nc, ab))
              else (nr, (nc, aa)));
        });
    });

mat_swaprows :: forall a. Nat -> Nat -> Mat a -> Mat a;
mat_swaprows k l (Mat_impl a) =
  let {
    nr = dim_row_impl a;
  } in (if less_nat l nr && less_nat k nr
         then Mat_impl (mat_swaprows_impl k l a)
         else (error :: forall a. String -> (() -> a) -> a)
                "index out of bounds in mat_swaprows"
                (\ _ -> mat_swaprows k l (Mat_impl a)));

find_non0 ::
  forall a.
    (Eq a, Idom_divide a) => ([(Nat, a)] -> Nat) -> Nat -> Mat a -> Maybe Nat;
find_non0 sel_fun l a =
  let {
    is = upt (suc l) (dim_row a);
    ais = filter (\ (_, ail) -> not (ail == zerob))
            (map (\ i -> (i, index_mat a (i, l))) is);
  } in (case ais of {
         [] -> Nothing;
         _ : _ -> Just (sel_fun ais);
       });

mat_multrow_gen_impl ::
  forall a. (a -> a -> a) -> Nat -> a -> Mat_impl a -> Mat_impl a;
mat_multrow_gen_impl xc xd xe xf =
  Abs_mat_impl
    (case rep_mat_impl xf of {
      (nr, a) ->
        (case a of {
          (nc, aa) -> let {
                        ak = sub aa xd;
                        arows = list_of aa;
                        aka = IArray.of_list (map (xc xe) (list_of ak));
                        ab = IArray.of_list (list_update arows xd aka);
                      } in (nr, (nc, ab));
        });
    });

mat_multrow_gen :: forall a. (a -> a -> a) -> Nat -> a -> Mat a -> Mat a;
mat_multrow_gen mul k aa (Mat_impl a) =
  Mat_impl (mat_multrow_gen_impl mul k aa a);

mat_addrow_gen_impl ::
  forall a.
    (a -> a -> a) ->
      (a -> a -> a) -> a -> Nat -> Nat -> Mat_impl a -> Mat_impl a;
mat_addrow_gen_impl xd xe xf xh xi xj =
  Abs_mat_impl
    (case rep_mat_impl xj of {
      (nr, a) ->
        (case a of {
          (nc, aa) ->
            (if less_nat xi nr
              then let {
                     ak = sub aa xh;
                     al = sub aa xi;
                     aka = of_fun (\ i -> xd (xe xf (sub al i)) (sub ak i))
                             (min (length ak) (length al));
                     ab = of_fun
                            (\ i -> (if equal_nat i xh then aka else sub aa i))
                            (length aa);
                   } in (nr, (nc, ab))
              else (nr, (nc, aa)));
        });
    });

mat_addrow_gen ::
  forall a. (a -> a -> a) -> (a -> a -> a) -> a -> Nat -> Nat -> Mat a -> Mat a;
mat_addrow_gen ad mul aa k l (Mat_impl a) =
  (if less_nat l (dim_row_impl a)
    then Mat_impl (mat_addrow_gen_impl ad mul aa k l a)
    else (error :: forall a. String -> (() -> a) -> a)
           "index out of bounds in mat_addrow"
           (\ _ -> mat_addrow_gen ad mul aa k l (Mat_impl a)));

mute ::
  forall a.
    (Eq a,
      Idom_divide a) => (a -> a -> (a, (a, a))) ->
                          a -> Nat -> Nat -> (a, Mat a) -> (a, Mat a);
mute mf a_ll k l (r, a) =
  let {
    p = index_mat a (k, l);
  } in (if p == zerob then (r, a)
         else (case mf a_ll p of {
                (q, (pa, _)) ->
                  (times r q,
                    mat_addrow_gen plus times (uminus pa) k l
                      (mat_multrow_gen times k q a));
              }));

sub1 ::
  forall a.
    (Eq a,
      Idom_divide a) => (a -> a -> (a, (a, a))) ->
                          a -> Nat -> Nat -> (a, Mat a) -> (a, Mat a);
sub1 mf q k l rA =
  (if equal_nat k zero_nat then rA
    else mute mf q (plus_nat l (suc (minus_nat k one_nat))) l
           (sub1 mf q (minus_nat k one_nat) l rA));

sub2 ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) ->
                            Nat -> Nat -> (a, Mat a) -> (a, Mat a);
sub2 sel_fun mf d l (r, a) =
  (case find_non0 sel_fun l a of {
    Nothing -> (r, a);
    Just m ->
      let {
        aa = mat_swaprows m l a;
      } in sub1 mf (index_mat aa (l, l)) (minus_nat d (suc l)) l (uminus r, aa);
  });

sub3 ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) ->
                            Nat -> Nat -> (a, Mat a) -> (a, Mat a);
sub3 sel_fun mf d l rA =
  (if equal_nat l zero_nat then rA
    else sub2 sel_fun mf d (minus_nat l one_nat)
           (sub3 sel_fun mf d (minus_nat l one_nat) rA));

triangulize ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) -> Mat a -> (a, Mat a);
triangulize sel_fun mf a = sub3 sel_fun mf (dim_row a) (dim_row a) (onea, a);

diag_mat :: forall a. Mat a -> [a];
diag_mat a = map (\ i -> index_mat a (i, i)) (upt zero_nat (dim_row a));

det_code ::
  forall a.
    (Eq a,
      Idom_divide a) => ([(Nat, a)] -> Nat) ->
                          (a -> a -> (a, (a, a))) -> Mat a -> a;
det_code sel_fun mf a =
  (if equal_nat (dim_row a) (dim_col a)
    then (case triangulize sel_fun mf a of {
           (m, aa) -> divide (prod_list (diag_mat aa)) m;
         })
    else zerob);

det :: forall a. (Eq a, Idom_divide a) => Mat a -> a;
det a = det_code fst_sel_fun trivial_mute_fun a;

form_or :: forall a. Formula a -> Formula a -> Formula a;
form_or (Disjunction []) psi = psi;
form_or (Atom v) (Disjunction []) = Atom v;
form_or (NegAtom v) (Disjunction []) = NegAtom v;
form_or (Conjunction v) (Disjunction []) = Conjunction v;
form_or (Disjunction (va : vb)) (Disjunction []) = Disjunction (va : vb);
form_or (Disjunction (v : va)) (Disjunction (vb : vc)) =
  Disjunction ((v : va) ++ vb : vc);
form_or (Disjunction (v : va)) (Atom vb) = Disjunction ((v : va) ++ [Atom vb]);
form_or (Disjunction (v : va)) (NegAtom vb) =
  Disjunction ((v : va) ++ [NegAtom vb]);
form_or (Disjunction (v : va)) (Conjunction vb) =
  Disjunction ((v : va) ++ [Conjunction vb]);
form_or (Atom v) (Disjunction (va : vb)) = Disjunction (Atom v : va : vb);
form_or (NegAtom v) (Disjunction (va : vb)) = Disjunction (NegAtom v : va : vb);
form_or (Conjunction v) (Disjunction (va : vb)) =
  Disjunction (Conjunction v : va : vb);
form_or (Atom v) (Atom va) = Disjunction [Atom v, Atom va];
form_or (Atom v) (NegAtom va) = Disjunction [Atom v, NegAtom va];
form_or (Atom v) (Conjunction va) = Disjunction [Atom v, Conjunction va];
form_or (NegAtom v) (Atom va) = Disjunction [NegAtom v, Atom va];
form_or (NegAtom v) (NegAtom va) = Disjunction [NegAtom v, NegAtom va];
form_or (NegAtom v) (Conjunction va) = Disjunction [NegAtom v, Conjunction va];
form_or (Conjunction v) (Atom va) = Disjunction [Conjunction v, Atom va];
form_or (Conjunction v) (NegAtom va) = Disjunction [Conjunction v, NegAtom va];
form_or (Conjunction v) (Conjunction va) =
  Disjunction [Conjunction v, Conjunction va];

cnf_form_or :: forall a. Formula a -> Formula a -> Formula a;
cnf_form_or (Conjunction phi_s) (Conjunction psi_s) =
  Conjunction (concatMap (\ phi -> map (form_or phi) psi_s) phi_s);
cnf_form_or (Atom v) psi = form_or (Atom v) psi;
cnf_form_or (NegAtom v) psi = form_or (NegAtom v) psi;
cnf_form_or (Disjunction v) psi = form_or (Disjunction v) psi;
cnf_form_or phi (Atom v) = form_or phi (Atom v);
cnf_form_or phi (NegAtom v) = form_or phi (NegAtom v);
cnf_form_or phi (Disjunction v) = form_or phi (Disjunction v);

form_cnf_ex :: forall a. [Formula a] -> Formula a;
form_cnf_ex [] = Conjunction [Disjunction []];
form_cnf_ex (phi : phi_s) = cnf_form_or phi (form_cnf_ex phi_s);

form_and :: forall a. Formula a -> Formula a -> Formula a;
form_and (Conjunction []) psi = psi;
form_and (Atom v) (Conjunction []) = Atom v;
form_and (NegAtom v) (Conjunction []) = NegAtom v;
form_and (Conjunction (va : vb)) (Conjunction []) = Conjunction (va : vb);
form_and (Disjunction v) (Conjunction []) = Disjunction v;
form_and (Conjunction (v : va)) (Conjunction (vb : vc)) =
  Conjunction ((v : va) ++ vb : vc);
form_and (Conjunction (v : va)) (Atom vb) = Conjunction ((v : va) ++ [Atom vb]);
form_and (Conjunction (v : va)) (NegAtom vb) =
  Conjunction ((v : va) ++ [NegAtom vb]);
form_and (Conjunction (v : va)) (Disjunction vb) =
  Conjunction ((v : va) ++ [Disjunction vb]);
form_and (Atom v) (Conjunction (va : vb)) = Conjunction (Atom v : va : vb);
form_and (NegAtom v) (Conjunction (va : vb)) =
  Conjunction (NegAtom v : va : vb);
form_and (Disjunction v) (Conjunction (va : vb)) =
  Conjunction (Disjunction v : va : vb);
form_and (Atom v) (Atom va) = Conjunction [Atom v, Atom va];
form_and (Atom v) (NegAtom va) = Conjunction [Atom v, NegAtom va];
form_and (Atom v) (Disjunction va) = Conjunction [Atom v, Disjunction va];
form_and (NegAtom v) (Atom va) = Conjunction [NegAtom v, Atom va];
form_and (NegAtom v) (NegAtom va) = Conjunction [NegAtom v, NegAtom va];
form_and (NegAtom v) (Disjunction va) = Conjunction [NegAtom v, Disjunction va];
form_and (Disjunction v) (Atom va) = Conjunction [Disjunction v, Atom va];
form_and (Disjunction v) (NegAtom va) = Conjunction [Disjunction v, NegAtom va];
form_and (Disjunction v) (Disjunction va) =
  Conjunction [Disjunction v, Disjunction va];

form_all :: forall a. [Formula a] -> Formula a;
form_all [] = Conjunction [];
form_all (phi : phi_s) = form_and phi (form_all phi_s);

flatten :: forall a. Formula a -> Formula a;
flatten (Conjunction phi_s) = form_all (map flatten phi_s);
flatten (Disjunction phi_s) = form_cnf_ex (map flatten phi_s);
flatten (Atom v) = Conjunction [Disjunction [Atom v]];
flatten (NegAtom v) = Conjunction [Disjunction [NegAtom v]];

is_Atom :: forall a. Formula a -> Bool;
is_Atom (Atom uu) = True;
is_Atom (NegAtom v) = False;
is_Atom (Conjunction v) = False;
is_Atom (Disjunction v) = False;

gen_set :: forall a b. a -> (b -> a -> a) -> [b] -> a;
gen_set emp ins l = fold ins l emp;

initial :: forall a b c d e. Lts_ext a b c d e -> Set d;
initial (Lts_ext initial transition_rules assertion more) = initial;

untrans_var :: forall a. Trans_var a -> a;
untrans_var (Pre x) = x;
untrans_var (Post x) = x;
untrans_var (Intermediate x) = x;

label :: forall a b. Lab a b -> Nat -> Sum b [Lab a b] -> Lab a b;
label f n (Inl l) = Lab f l;
label f n (Inr l) = FunLab f l;

unlab :: forall a b. Lab a b -> Lab a b;
unlab (Lab f l) = f;
unlab (FunLab f l) = f;
unlab (UnLab v) = UnLab v;
unlab (Sharp v) = Sharp v;

plus_mat :: forall a. (Plus a) => Mat a -> Mat a -> Mat a;
plus_mat a b =
  mat (dim_row b) (dim_col b) (\ ij -> plus (index_mat a ij) (index_mat b ij));

carrier_mat :: forall a. Nat -> Nat -> Set (Mat a);
carrier_mat nr nc =
  Collect_set (\ a -> equal_nat (dim_row a) nr && equal_nat (dim_col a) nc);

zero_mat :: forall a. (Zero a) => Nat -> Nat -> Mat a;
zero_mat nr nc = mat nr nc (\ _ -> zerob);

ring_mat ::
  forall a b.
    (Semiring_1 a) => Itself a ->
                        Nat ->
                          b -> Partial_object_ext (Mat a)
                                 (Monoid_ext (Mat a) (Ring_ext (Mat a) b));
ring_mat ty n b =
  Partial_object_ext (carrier_mat n n)
    (Monoid_ext times_mat (one_mat n) (Ring_ext (zero_mat n n) plus_mat b));

emptyd :: forall a b. (Ccompare b, Mapping_impl b) => (a -> b) -> Multimap b a;
emptyd xa = Abs_multimap (xa, (emptyb, []));

rm_iterateoi ::
  forall a b c. Rbta a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
rm_iterateoi Empty c f sigma = sigma;
rm_iterateoi (Branch col l k v r) c f sigma =
  (if c sigma
    then let {
           sigmaa = rm_iterateoi l c f sigma;
         } in (if c sigmaa then rm_iterateoi r c f (f (k, v) sigmaa)
                else sigmaa)
    else sigma);

iteratei_bmap_op_list_it_rm_basic_ops ::
  forall a b c.
    (Linorder a) => Rbt a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
iteratei_bmap_op_list_it_rm_basic_ops s = rm_iterateoi (impl_of s);

g_to_list_rm_basic_ops :: forall a b. (Linorder a) => Rbt a b -> [(a, b)];
g_to_list_rm_basic_ops m =
  iteratei_bmap_op_list_it_rm_basic_ops m (\ _ -> True) (\ a b -> a : b) [];

values :: forall a b. (Linorder a) => Rbt a [b] -> [b];
values m = concatMap snd (g_to_list_rm_basic_ops m);

polya :: forall a. (Comm_semiring_0 a) => Poly a -> a -> a;
polya p = fold_coeffs (\ a f x -> plus a (times x (f x))) p (\ _ -> zerob);

boundsl :: forall a b. State a b -> Nat -> Maybe b;
boundsl s = map_option snd . lookupb (b_i_l s);

boundsu :: forall a b. State a b -> Nat -> Maybe b;
boundsu s = map_option snd . lookupb (b_i_u s);

vars_list :: Linear_poly -> [Nat];
vars_list lp = ordered_keys (linear_poly_map lp);

valuate :: forall a. (Rational_vector a) => Linear_poly -> (Nat -> a) -> a;
valuate lp val =
  let {
    lpm = linear_poly_map lp;
  } in sum_list
         (map (\ x -> scaleRat (the (fmlookup lpm x)) (val x)) (vars_list lp));

delta_0 :: QDelta -> QDelta -> Rat;
delta_0 qd1 qd2 =
  let {
    c1 = qdfst qd1;
    c2 = qdfst qd2;
    k1 = qdsnd qd1;
    k2 = qdsnd qd2;
  } in (if less_rat c1 c2 && less_rat k2 k1
         then divide_rat (minus_rat c2 c1) (minus_rat k1 k2) else one_rat);

delta_0_val :: Ns_constraint QDelta -> (Nat -> QDelta) -> Rat;
delta_0_val (LEQ_ns lll rrr) vl = delta_0 (valuate lll vl) rrr;
delta_0_val (GEQ_ns lll rrr) vl = delta_0 rrr (valuate lll vl);

delta_0_val_min :: [Ns_constraint QDelta] -> (Nat -> QDelta) -> Rat;
delta_0_val_min [] vl = one_rat;
delta_0_val_min (h : t) vl = min (delta_0_val_min t vl) (delta_0_val h vl);

tabulate ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a) => [a] -> (a -> b) -> Mapping a b;
tabulate xs f = fold (\ k -> updateb k (f k)) xs emptyb;

map2fun :: forall a. (Zero a) => Mapping Nat a -> Nat -> a;
map2fun v = (\ x -> (case lookupb v x of {
                      Nothing -> zerob;
                      Just y -> y;
                    }));

from_ns :: Mapping Nat QDelta -> [Ns_constraint QDelta] -> Mapping Nat Rat;
from_ns vl cs =
  let {
    delta = delta_0_val_min cs (map2fun vl);
  } in tabulate (remdups (concatMap vars_list (map poly cs)))
         (\ var -> val (map2fun vl var) delta);

binda :: forall a b c. Sum_bot a b -> (b -> Sum_bot a c) -> Sum_bot a c;
binda (Sumbot a) f = (case a of {
                       Inl b -> Sumbot (Inl b);
                       Inr aa -> f aa;
                     });

tcapI ::
  forall a b. (Eq a, Eq b) => [(Term a b, Term a b)] -> Term a b -> Gctxt a b;
tcapI uu (Var uv) = GCHole;
tcapI r (Fun f ts) =
  let {
    h = GCFun f (map (tcapI r) ts);
  } in (if any (\ ra -> matchb h (fst ra)) r then GCHole else h);

ground :: forall a b. Term a b -> Bool;
ground (Var x) = False;
ground (Fun f ts) = all ground ts;

hvf_top :: forall a b. (Eq a) => a -> Nat -> Term a b -> Bool;
hvf_top a n (Fun f ts) =
  (if f == a && equal_nat (size_list ts) n then not (is_Var (hda ts))
    else True);
hvf_top a n (Var uu) = False;

version :: String;
version = " [hg: unknown]";

status :: forall a. Status a -> (a, Nat) -> [Nat];
status (Abs_status x) = x;

af_wpo :: forall a. ((a, Nat) -> Set Nat) -> Status a -> (a, Nat) -> Set Nat;
af_wpo pi sigma f = sup_set (set (status sigma f)) (pi f);

lex_ext_unbounded ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
lex_ext_unbounded f [] [] = (False, True);
lex_ext_unbounded f (uu : uv) [] = (True, True);
lex_ext_unbounded f [] (uw : ux) = (False, False);
lex_ext_unbounded f (a : asa) (b : bs) =
  (case f a b of {
    (True, _) -> (True, True);
    (False, True) -> lex_ext_unbounded f asa bs;
    (False, False) -> (False, False);
  });

wpo_ub ::
  forall a b.
    (Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool)) ->
                ((a, Nat) -> Bool) ->
                  Bool ->
                    ((a, Nat) -> Bool) ->
                      (Term a b -> Term a b -> Bool) ->
                        (Term a b -> Term a b -> Bool) ->
                          Status a -> Term a b -> Term a b -> (Bool, Bool);
wpo_ub pr prl ssimple large cS cNS sigma s t =
  (case s of {
    Var x ->
      (False,
        (case t of {
          Var a -> x == a;
          Fun g ts ->
            cNS s t &&
              null (status sigma (g, size_list ts)) && prl (g, size_list ts);
        }));
    Fun f ss ->
      (if cS s t then (True, True)
        else let {
               ff = (f, size_list ss);
               sf = status sigma ff;
             } in (if cNS s t
                    then (if any (\ i ->
                                   snd (wpo_ub pr prl ssimple large cS cNS sigma
 (nth ss i) t))
                               sf
                           then (True, True)
                           else (case t of {
                                  Var _ -> (False, ssimple && large ff);
                                  Fun g ts ->
                                    let {
                                      gg = (g, size_list ts);
                                      sg = status sigma gg;
                                    } in (case pr ff gg of {
   (prs, prns) ->
     (if prns &&
           all (\ j ->
                 fst (wpo_ub pr prl ssimple large cS cNS sigma s (nth ts j)))
             sg
       then (if prs then (True, True)
              else lex_ext_unbounded (wpo_ub pr prl ssimple large cS cNS sigma)
                     (map (nth ss) sf) (map (nth ts) sg))
       else (False, False));
 });
                                }))
                    else (False, False)));
  });

xml_error_to_string :: Xml_error String -> [Char];
xml_error_to_string (Fatal e) = explode ("Fatal: " ++ e);
xml_error_to_string (TagMismatch e) =
  explode ("tag mismatch: " ++ default_showsl_list showsl_lit e "");

parse_xml ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      Xml -> Sum_bot [Char] a;
parse_xml p xml =
  bind2 (xml_take p xml_return ([xml], ([], (False, ([], [])))))
    (left . xml_error_to_string) right;

mk_subst ::
  forall a b c. (Eq a) => (a -> Term b c) -> [(a, Term b c)] -> a -> Term b c;
mk_subst d xts = (\ x -> (case map_of xts x of {
                           Nothing -> d x;
                           Just t -> t;
                         }));

cstep ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) (Cstep_proof (Lab a b) [Char]);
cstep xml2name x =
  xml_do "conditionalRewriteStep"
    (xml_take (crule xml2name "rule")
      (\ a ->
        xml_take pos
          (\ b ->
            xml_take (substa xml2name)
              (\ c ->
                xml_take
                  (xml_do "source"
                    (xml_take (term xml2name) (\ xa -> xml_return (id xa))))
                  (\ d ->
                    xml_take
                      (xml_do "target"
                        (xml_take (term xml2name) (\ xa -> xml_return (id xa))))
                      (\ e ->
                        xml_take
                          (xml_do "conditions"
                            (xml_take_many_sub [] zero_nat Infinity_enat
                              (csteps xml2name) (\ aa -> xml_return (id aa))))
                          (\ f ->
                            xml_return
                              (Cstep_step a b (mk_subst Var c) d e f))))))))
    x;

csteps ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) [Cstep_proof (Lab a b) [Char]];
csteps xml2name x =
  xml_do "conditionalRewritingSequence"
    (xml_take_many_sub [] zero_nat Infinity_enat (cstep xml2name)
      (\ a -> xml_return (id a)))
    x;

estep ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       ([Nat],
                         ((Term a [Char], Term a [Char]),
                           (Bool, Term a [Char])));
estep xml2name =
  xml_do "equationStep"
    (xml_take pos
      (\ p ->
        xml_take (rule xml2name)
          (\ r ->
            xml_take
              (xml_or (xml_leaf "leftRight" True) (xml_leaf "rightLeft" False))
              (\ b ->
                xml_take (term xml2name)
                  (\ t -> xml_return (p, (r, (b, t))))))));

state ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) [Char];
state = xml_text "state";

isOK :: forall a b. Sum a b -> Bool;
isOK m = (case m of {
           Inl _ -> False;
           Inr _ -> True;
         });

mapM :: forall a b c. (a -> Sum b c) -> [a] -> Sum b [c];
mapM f [] = Inr [];
mapM f (x : xs) = bindb (f x) (\ y -> bindb (mapM f xs) (\ ys -> Inr (y : ys)));

form_not :: forall a. Formula a -> Formula a;
form_not (Atom a) = NegAtom a;
form_not (NegAtom a) = Atom a;
form_not (Conjunction phi_s) = Disjunction (map form_not phi_s);
form_not (Disjunction phi_s) = Conjunction (map form_not phi_s);

get_Atom :: forall a. Formula a -> a;
get_Atom (Atom a) = a;
get_Atom (NegAtom a) = a;

simplify :: forall a. Formula a -> Formula a;
simplify (Disjunction (phi : phi_s)) =
  form_or (simplify phi) (simplify (Disjunction phi_s));
simplify (Conjunction [phi]) = simplify phi;
simplify (Conjunction (phi : v : va)) =
  form_and (simplify phi) (simplify (Conjunction (v : va)));
simplify (Atom v) = Atom v;
simplify (NegAtom v) = NegAtom v;
simplify (Conjunction []) = Conjunction [];
simplify (Disjunction []) = Disjunction [];

gen_ball ::
  forall a b c d e f.
    (a -> (b -> b) -> (c -> d -> e) -> Bool -> f) -> a -> (c -> e) -> f;
gen_ball it m p = it m (\ x -> x) (\ x _ -> p x) True;

gen_balla ::
  forall a b c d e.
    (a -> (b -> b) -> (c -> d -> Bool) -> Bool -> e) -> a -> (c -> Bool) -> e;
gen_balla it s p = it s (\ x -> x) (\ x _ -> p x) True;

gen_pick ::
  forall a b c d e f.
    (a -> (Maybe b -> Bool) -> (c -> d -> Maybe c) -> Maybe e -> Maybe f) ->
      a -> f;
gen_pick it s =
  the (it s (\ a -> (case a of {
                      Nothing -> True;
                      Just _ -> False;
                    }))
         (\ x _ -> Just x)
        Nothing);

one :: forall a b. Partial_object_ext a (Monoid_ext a b) -> a;
one (Partial_object_ext carrier (Monoid_ext mult one more)) = one;

remdups_adj :: forall a. (Eq a) => [a] -> [a];
remdups_adj [] = [];
remdups_adj [x] = [x];
remdups_adj (x : y : xs) =
  (if x == y then remdups_adj (x : xs) else x : remdups_adj (y : xs));

base :: forall a. (a, Nat) -> a;
base (f, h) = f;

lift :: forall a. Nat -> a -> (a, Nat);
lift h f = (f, h);

add_vars_term :: forall a b. Term a b -> [b] -> [b];
add_vars_term (Var x) xs = x : xs;
add_vars_term (Fun uu ts) xs = foldr add_vars_term ts xs;

vars_term_list :: forall a b. Term a b -> [b];
vars_term_list t = add_vars_term t [];

roof ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Term a b -> Bool;
roof (l, r) = let {
                xs = vars_term_list r;
              } in (\ t -> let {
                             xt = vars_term t;
                           } in all (\ x -> member x xt) xs);

matches ::
  forall a b c.
    (Eq a, Eq b, Ccompare c, Eq c,
      Mapping_impl c) => Term a b -> Term a c -> Bool;
matches t p = (case match_list (\ _ -> t) [(p, t)] of {
                Nothing -> False;
                Just _ -> True;
              });

smult_mat :: forall a. (Times a) => a -> Mat a -> Mat a;
smult_mat aa a = map_mat (times aa) a;

rep_multimap :: forall a b. Multimap a b -> (b -> a, (Mapping a [b], [b]));
rep_multimap (Abs_multimap x) = x;

option_list_to_list :: forall a. Maybe [a] -> [a];
option_list_to_list Nothing = [];
option_list_to_list (Just asa) = asa;

insertd :: forall a b. (Ccompare b, Eq b) => a -> Multimap b a -> Multimap b a;
insertd xb xc =
  Abs_multimap (case rep_multimap xc of {
                 (f, (m, alla)) -> let {
                                     k = f xb;
                                     old = option_list_to_list (lookupb m k);
                                     new = xb : old;
                                   } in (f, (updateb k new m, xb : alla));
               });

lookupc :: forall a b. (Ccompare a, Eq a) => Multimap a b -> a -> [b];
lookupc xa = (case rep_multimap xa of {
               (_, (m, _)) -> (\ k -> option_list_to_list (lookupb m k));
             });

valuesa :: forall a b. Multimap a b -> [b];
valuesa xa = (case rep_multimap xa of {
               (_, (_, alla)) -> alla;
             });

subtract_entries_raw ::
  forall a b. (Eq a, Minus b) => [(a, b)] -> [(a, b)] -> [(a, b)];
subtract_entries_raw xs ys =
  foldr (\ (k, v) -> map_entry k (\ va -> minus va v)) ys xs;

subtract_entries ::
  forall a b. (Eq a, Minus b) => Alist a b -> Alist a b -> Alist a b;
subtract_entries xb xc =
  Alist (subtract_entries_raw (impl_ofa xb) (impl_ofa xc));

minus_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
minus_multiset (Bag xs) (Bag ys) = Bag (subtract_entries xs ys);

inf_subset_mset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
inf_subset_mset a b = minus_multiset a (minus_multiset a b);

fold_impl :: forall a b. (a -> Nat -> b -> b) -> b -> [(a, Nat)] -> b;
fold_impl fn e ((a, n) : ms) = fold_impl fn (fn a n e) ms;
fold_impl fn e [] = e;

foldd :: forall a b. (a -> Nat -> b -> b) -> b -> Alist a Nat -> b;
foldd f e al = fold_impl f e (impl_ofa al);

set_mset :: forall a. (Ceq a, Ccompare a, Set_impl a) => Multiset a -> Set a;
set_mset (Bag ms) =
  foldd (\ a n -> (if equal_nat n zero_nat then (\ m -> m) else inserta a))
    bot_set ms;

multeqp ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Set_impl a) => (a -> a -> Bool) -> Multiset a -> Multiset a -> Bool;
multeqp p n m = let {
                  z = inf_subset_mset m n;
                  x = minus_multiset m z;
                  y = minus_multiset n z;
                } in ball (set_mset y) (\ ya -> bex (set_mset x) (p ya));

is_Inr :: forall a b. Sum a b -> Bool;
is_Inr (Inr uu) = True;
is_Inr (Inl uv) = False;

one_monom :: forall a. (Linorder a) => Monom a;
one_monom = Abs_monom [];

poly_split ::
  forall a b.
    (Eq a, Linorder a,
      Zero b) => Monom a -> [(Monom a, b)] -> (b, [(Monom a, b)]);
poly_split m p = (case extract (\ (n, _) -> m == n) p of {
                   Nothing -> (zerob, p);
                   Just (p1, ((_, c), p2)) -> (c, p1 ++ p2);
                 });

max_v ::
  forall a b.
    (Zero a, Ord a) => a -> ((b, Nat) -> [(Monom Nat, a)]) -> [(b, Nat)] -> a;
max_v v i fs =
  max v (foldr (\ f m -> max m (fst (poly_split one_monom (i f)))) fs zerob);

is_zero :: forall a. (Zero a) => Poly a -> Bool;
is_zero p = null (coeffs p);

order :: forall a. (Eq a, Idom_divide a) => a -> Poly a -> Nat;
order a p =
  (if is_zero p
    then (error :: forall a. String -> (() -> a) -> a)
           "order of polynomial 0 undefined" (\ _ -> order a p)
    else (if not (polya p a == zerob) then zero_nat
           else suc (order a
                      (divide_poly p
                        (pCons (uminus a) (pCons onea zero_polya))))));

relcomp ::
  forall a b c.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b, Ceq c, Ccompare c,
      Set_impl c) => Set (a, b) -> Set (b, c) -> Set (a, c);
relcomp (Set_Monad xs6) (DList_set dxs4) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad DList_set: ceq1 = None"
        (\ _ -> relcomp (Set_Monad xs6) (DList_set dxs4));
    Just eq ->
      (case (ceq :: Maybe (c -> c -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp Set_Monad DList_set: ceq2 = None"
            (\ _ -> relcomp (Set_Monad xs6) (DList_set dxs4));
        Just _ ->
          fold (\ (x, y) ->
                 foldc (\ (ya, z) a ->
                         (if eq y ya then inserta (x, z) a else a))
                   dxs4)
            xs6 bot_set;
      });
  });
relcomp (DList_set dxs3) (Set_Monad xs5) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set Set_Monad: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs3) (Set_Monad xs5));
    Just _ ->
      (case ceq of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set Set_Monad: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs3) (Set_Monad xs5));
        Just eq ->
          foldc (\ (x, y) ->
                  fold (\ (ya, z) a ->
                         (if eq y ya then inserta (x, z) a else a))
                    xs5)
            dxs3 bot_set;
      });
  });
relcomp (Set_Monad xs4) (RBT_set rbt5) =
  (case (ccompare :: Maybe (c -> c -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad RBT_set: ccompare1 = None"
        (\ _ -> relcomp (Set_Monad xs4) (RBT_set rbt5));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp Set_Monad RBT_set: ccompare2 = None"
            (\ _ -> relcomp (Set_Monad xs4) (RBT_set rbt5));
        Just c_b ->
          fold (\ (x, y) ->
                 foldb (\ (ya, z) a ->
                         (if not (equal_order (c_b y ya) Eqa) then a
                           else inserta (x, z) a))
                   rbt5)
            xs4 bot_set;
      });
  });
relcomp (RBT_set rbt1) (Set_Monad xs3) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set Set_Monad: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt1) (Set_Monad xs3));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set Set_Monad: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt1) (Set_Monad xs3));
        Just c_b ->
          foldb (\ (x, y) ->
                  fold (\ (ya, z) a ->
                         (if not (equal_order (c_b y ya) Eqa) then a
                           else inserta (x, z) a))
                    xs3)
            rbt1 bot_set;
      });
  });
relcomp (Set_Monad xs1) (Set_Monad xs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad Set_Monad: ceq = None"
        (\ _ -> relcomp (Set_Monad xs1) (Set_Monad xs2));
    Just eq ->
      fold (\ (x, y) ->
             fold (\ (ya, z) a -> (if eq y ya then inserta (x, z) a else a))
               xs2)
        xs1 bot_set;
  });
relcomp (DList_set dxs3) (DList_set dxs4) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set DList_set: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
    Just _ ->
      (case ceq of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set DList_set: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
        Just eq ->
          (case (ceq :: Maybe (c -> c -> Bool)) of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp DList_set DList_set: ceq3 = None"
                (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
            Just _ ->
              foldc (\ (x, y) ->
                      foldc (\ (ya, z) a ->
                              (if eq y ya then inserta (x, z) a else a))
                        dxs4)
                dxs3 bot_set;
          });
      });
  });
relcomp (DList_set dxs2) (RBT_set rbt4) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set RBT_set: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set RBT_set: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
        Just _ ->
          (case ceq of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp DList_set RBT_set: ccompare2 = None"
                (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
            Just eq ->
              (case (ccompare :: Maybe (c -> c -> Ordera)) of {
                Nothing ->
                  (error :: forall a. String -> (() -> a) -> a)
                    "relcomp DList_set RBT_set: ccompare3 = None"
                    (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
                Just _ ->
                  foldc (\ (x, y) ->
                          foldb (\ (ya, z) a ->
                                  (if eq y ya then inserta (x, z) a else a))
                            rbt4)
                    dxs2 bot_set;
              });
          });
      });
  });
relcomp (RBT_set rbt3) (DList_set dxs1) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set DList_set: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set DList_set: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
        Just _ ->
          (case ceq of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp RBT_set DList_set: ceq2 = None"
                (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
            Just eq ->
              (case (ceq :: Maybe (c -> c -> Bool)) of {
                Nothing ->
                  (error :: forall a. String -> (() -> a) -> a)
                    "relcomp RBT_set DList_set: ceq3 = None"
                    (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
                Just _ ->
                  foldb (\ (x, y) ->
                          foldc (\ (ya, z) a ->
                                  (if eq y ya then inserta (x, z) a else a))
                            dxs1)
                    rbt3 bot_set;
              });
          });
      });
  });
relcomp (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set RBT_set: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set RBT_set: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
        Just c_b ->
          (case (ccompare :: Maybe (c -> c -> Ordera)) of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp RBT_set RBT_set: ccompare3 = None"
                (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
            Just _ ->
              foldb (\ (x, y) ->
                      foldb (\ (ya, z) a ->
                              (if not (equal_order (c_b y ya) Eqa) then a
                                else inserta (x, z) a))
                        rbt2)
                rbt1 bot_set;
          });
      });
  });

max_sls :: forall a. (Linorder a) => Semilattice_set a;
max_sls = Abs_semilattice_set max;

b_i_l_update ::
  forall a b.
    (Mapping Nat (a, b) -> Mapping Nat (a, b)) -> State a b -> State a b;
b_i_l_update up (State t bil biu v u uc) = State t (up bil) biu v u uc;

negative :: forall a b. (Linorder b) => Direction a b;
negative =
  Direction (\ x y -> less y x) b_i_u b_i_l boundsu boundsl indexu indexl
    b_i_l_update Geq Leq (\ x y -> less_eq_rat y x);

b_i_u_update ::
  forall a b.
    (Mapping Nat (a, b) -> Mapping Nat (a, b)) -> State a b -> State a b;
b_i_u_update up (State t bil biu v u uc) = State t bil (up biu) v u uc;

positive :: forall a b. (Linorder b) => Direction a b;
positive =
  Direction less b_i_l b_i_u boundsl boundsu indexl indexu b_i_u_update Leq Geq
    less_eq_rat;

atom_var :: forall a. Atom a -> Nat;
atom_var (Leq var a) = var;
atom_var (Geq var a) = var;

coeffa :: Linear_poly -> Nat -> Rat;
coeffa lp = get_var_coeff (linear_poly_map lp);

vara :: Nat -> Linear_poly;
vara x = LinearPoly (set_var_coeff x one_rat fmempty);

pivot_eq :: (Nat, Linear_poly) -> Nat -> (Nat, Linear_poly);
pivot_eq e y =
  let {
    cy = coeffa (rhs e) y;
  } in (y, plus_linear_poly
             (scaleRat_linear_poly (divide_rat (uminus_rat one_rat) cy)
               (minus_linear_poly (rhs e) (scaleRat_linear_poly cy (vara y))))
             (scaleRat_linear_poly (divide_rat one_rat cy) (vara (lhs e))));

errora :: forall a b. a -> Sum_bot a b;
errora x = Sumbot (Inl x);

tcapRM2 ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> [(Term a b, Term a b)]) -> Term a b -> Gctxt a b;
tcapRM2 uu (Var uv) = GCHole;
tcapRM2 rm (Fun f ts) =
  let {
    h = GCFun f (map (tcapRM2 rm) ts);
    n = size_list ts;
  } in (if any (\ r -> matchb h (fst r)) (rm (f, n)) then GCHole else h);

tcapRM ::
  forall a b.
    (Eq a,
      Eq b) => Bool ->
                 ((a, Nat) -> [(Term a b, Term a b)]) -> Term a b -> Gctxt a b;
tcapRM nlv rm = (if nlv then tcapRM2 rm else (\ _ -> GCHole));

funposs_list :: forall a b. Term a b -> [[Nat]];
funposs_list (Var x) = [];
funposs_list (Fun f ss) =
  [] : concatMap (\ (i, a) -> map (\ aa -> i : aa) a)
         (zip (upt zero_nat (size_list ss)) (map funposs_list ss));

ctxt_apply_term :: forall a b. Ctxt a b -> Term a b -> Term a b;
ctxt_apply_term Hole s = s;
ctxt_apply_term (More f ss1 c ss2) s = Fun f (ss1 ++ ctxt_apply_term c s : ss2);

ctxt_of_pos_term :: forall a b. [Nat] -> Term a b -> Ctxt a b;
ctxt_of_pos_term [] t = Hole;
ctxt_of_pos_term (i : ps) (Fun f ts) =
  More f (take i ts) (ctxt_of_pos_term ps (nth ts i)) (drop (suc i) ts);

poss_list :: forall a b. Term a b -> [[Nat]];
poss_list (Var x) = [[]];
poss_list (Fun f ss) =
  [] : concatMap (\ (i, a) -> map (\ aa -> i : aa) a)
         (zip (upt zero_nat (size_list ss)) (map poss_list ss));

subt_at :: forall a b. Term a b -> [Nat] -> Term a b;
subt_at s [] = s;
subt_at (Fun f ss) (i : p) = subt_at (nth ss i) p;

rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
rewrite r s =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ p ->
          (case match (subt_at s p) l of {
            Nothing -> [];
            Just sigma ->
              [ctxt_apply_term (ctxt_of_pos_term p s)
                 (subst_apply_term ra sigma)];
          }))
        (poss_list s))
    r;

hvf_term :: forall a b. (Eq a) => a -> Term a b -> Bool;
hvf_term a t = (case unapp a t of {
                 (Var _, ts) -> null ts;
                 (Fun _ us, ts) -> all (hvf_term a) (us ++ ts);
               });

max_list :: [Nat] -> Nat;
max_list [] = zero_nat;
max_list (x : xs) = max x (max_list xs);

rules ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       [(Term a [Char], Term a [Char])];
rules xml2name =
  xml_do "rules"
    (xml_take_many_sub [] zero_nat Infinity_enat (rule xml2name) xml_return);

string2xml :: [Char] -> Sum [Char] Xml;
string2xml str =
  (case bindc (update_tokens remove_comments)
          (\ _ -> bindc parse_node (\ xml -> bindc eoi (\ _ -> returnb xml)))
          str
    of {
    Inl a -> Inl a;
    Inr (xml, _) -> Inr xml;
  });

filter_mset :: forall a. (a -> Bool) -> Multiset a -> Multiset a;
filter_mset p (Bag xs) = Bag (filterb (p . fst) xs);

filter_fun ::
  forall a b.
    Multiset (Term a b) ->
      ((a, Nat) -> (a, Nat) -> Bool) -> (a, Nat) -> Multiset (Term a b);
filter_fun t p f = filter_mset (\ a -> (case a of {
 Var _ -> False;
 Fun g ts -> p (g, size_list ts) f;
                                       }))
                     t;

string ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) [Lab a b];
string xml2name =
  xml_do "string"
    (xml_take_many_sub [] zero_nat Infinity_enat xml2name
      (\ a -> xml_return (id a)));

oc_srs ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) ([Lab a b], [Lab a b]);
oc_srs xml2name =
  xml_do "overlapClosureSRS"
    (xml_take (string xml2name)
      (\ a -> xml_take (string xml2name) (\ b -> xml_return (a, b))));

rsteps ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (Term a [Char],
                         [([Nat],
                            ((Term a [Char], Term a [Char]), Term a [Char]))]);
rsteps xml2name =
  xml_do "rewriteSequence"
    (xml_take
      (xml_do "startTerm" (xml_take (term xml2name) (\ x -> xml_return (id x))))
      (\ start ->
        xml_take_many_sub [] zero_nat Infinity_enat (rstep xml2name)
          (\ steps -> xml_return (start, steps))));

check :: forall a. Bool -> a -> Sum a ();
check b e = (if b then Inr () else Inl e);

or_ok :: forall a. Sum a () -> Sum a () -> Sum a ();
or_ok (Inl a) b = b;
or_ok (Inr a) b = Inr a;

degree :: Complexity_class -> Nat;
degree (Comp_Poly d) = d;

gen_image ::
  forall a b c d e f g h.
    (a -> (b -> Bool) -> (c -> d -> e) -> f -> g) ->
      f -> (h -> d -> e) -> (c -> h) -> a -> g;
gen_image it1 emp2 ins2 f s1 = it1 s1 (\ _ -> True) (\ x -> ins2 (f x)) emp2;

catch_errora :: forall a b c. Sum a b -> (a -> Sum c b) -> Sum c b;
catch_errora m f = (case m of {
                     Inl a -> f a;
                     Inr a -> Inr a;
                   });

check_no_edge ::
  forall a.
    (a -> String -> String) ->
      ((a, a) -> Bool) -> a -> a -> Sum (String -> String) ();
check_no_edge ss g m n =
  check (not (g (m, n)))
    (((showsl_lit "edge from " . ss m) . showsl_lit " to ") . ss n);

forallM :: forall a b. (a -> Sum b ()) -> [a] -> Sum (a, b) ();
forallM f [] = Inr ();
forallM f (x : xs) =
  bindb (catch_errora (f x) (\ xa -> Inl (x, xa))) (\ _ -> forallM f xs);

check_edges ::
  forall a.
    (a -> String -> String) ->
      ((a, a) -> Bool) -> [a] -> [a] -> Sum (String -> String) ();
check_edges ss g c d =
  catch_errora
    (forallM
      (\ n ->
        catch_errora (forallM (check_no_edge ss g n) d) (\ x -> Inl (snd x)))
      c)
    (\ x -> Inl (snd x));

mult :: forall a b. Partial_object_ext a (Monoid_ext a b) -> a -> a -> a;
mult (Partial_object_ext carrier (Monoid_ext mult one more)) = mult;

comp2eq :: forall a b. (a -> b -> Comp_res) -> a -> b -> Bool;
comp2eq cmp a b = (case cmp a b of {
                    LESS -> False;
                    EQUAL -> True;
                    GREATER -> False;
                  });

prec_ext ::
  forall a b. (Eq a) => (a -> Maybe (Nat, b)) -> a -> a -> (Bool, Bool);
prec_ext prwm =
  (\ f g ->
    (case prwm f of {
      Nothing -> (False, f == g);
      Just pf ->
        (case prwm g of {
          Nothing -> (True, True);
          Just pg ->
            (less_nat (fst pg) (fst pf), less_eq_nat (fst pg) (fst pf));
        });
    }));

assertion ::
  forall a b c d e. Lts_ext a b c d e -> d -> Formula (Term a (b, c));
assertion (Lts_ext initial transition_rules assertion more) = assertion;

map_of_total ::
  forall a b.
    (Ccompare a, Eq a,
      Mapping_impl a) => (a -> String -> String) -> [(a, b)] -> a -> b;
map_of_total err xys =
  let {
    m = of_alist xys;
  } in (\ x ->
         (case lookupb m x of {
           Nothing ->
             (error :: forall a. String -> (() -> a) -> a) (err x "")
               (\ _ -> the Nothing);
           Just y -> y;
         }));

transition_of ::
  forall a b c d e.
    (Ccompare e, Eq e, Mapping_impl e,
      Showl e) => Lts_impl a b c d e -> e -> Transition_rule a b c d;
transition_of pi =
  map_of_total
    (\ a ->
      ((showsl_lit "access to non-existing transition " . showsl a) .
        showsl_lit "\navailable transitions:\n") .
        showsl_list (map fst (transitions_impl pi)))
    (transitions_impl pi);

matcha :: forall a b. (Term a b, Term a b) -> Term a b -> Bool;
matcha = (\ _ _ -> True);

span :: forall a. (a -> Bool) -> [a] -> ([a], [a]);
span p (x : xs) =
  (if p x then let {
                 a = span p xs;
               } in (case a of {
                      (ys, aa) -> (x : ys, aa);
                    })
    else ([], x : xs));
span uu [] = ([], []);

fresh_strings_list :: [Char] -> Nat -> [[Char]] -> Nat -> [[Char]];
fresh_strings_list name offset used n =
  take n
    (filter (\ s -> not (membera (remdups used) s))
      (map (\ i -> name ++ shows_prec_nat zero_nat (plus_nat i offset) [])
        (upt zero_nat (plus_nat n (size_list (remdups used))))));

fresh_string :: [Char] -> [[Char]] -> [Char];
fresh_string pre = (\ s -> hda (fresh_strings_list pre one_nat s one_nat));

mapMa :: forall a b. (a -> Maybe b) -> [a] -> Maybe [b];
mapMa f [] = Just [];
mapMa f (x : xs) =
  bind (f x) (\ y -> bind (mapMa f xs) (\ ys -> Just (y : ys)));

degreea :: forall a. (Zero a) => Poly a -> Nat;
degreea p = minus_nat (size_list (coeffs p)) one_nat;

pderiv_coeffs_code ::
  forall a.
    (Eq a, Comm_semiring_1 a, Semiring_no_zero_divisors a) => a -> [a] -> [a];
pderiv_coeffs_code f (x : xs) =
  cCons (times f x) (pderiv_coeffs_code (plus f onea) xs);
pderiv_coeffs_code f [] = [];

pderiv_coeffs ::
  forall a.
    (Eq a, Comm_semiring_1 a, Semiring_no_zero_divisors a) => [a] -> [a];
pderiv_coeffs xs = pderiv_coeffs_code onea (tla xs);

pderiv ::
  forall a.
    (Eq a, Comm_semiring_1 a, Semiring_no_zero_divisors a) => Poly a -> Poly a;
pderiv p = Poly (pderiv_coeffs (coeffs p));

less_eq_pos :: [Nat] -> [Nat] -> Bool;
less_eq_pos (i : q1) (j : q2) = equal_nat i j && less_eq_pos q1 q2;
less_eq_pos (i : q1) [] = False;
less_eq_pos [] p = True;

less_pos :: [Nat] -> [Nat] -> Bool;
less_pos p q = less_eq_pos p q && not (p == q);

equal_order_tag :: Order_tag -> Order_tag -> Bool;
equal_order_tag Lex Mul = False;
equal_order_tag Mul Lex = False;
equal_order_tag Mul Mul = True;
equal_order_tag Lex Lex = True;

any_nstri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> (Bool, b);
any_nstri_efficient_m f [] m = (False, m);
any_nstri_efficient_m f (a : asa) m =
  let {
    aa = f a m;
  } in (case aa of {
         (ab, b) ->
           (case ab of {
             (_, ns) ->
               (\ ma ->
                 (if ns then (True, ma) else any_nstri_efficient_m f asa ma));
           })
             b;
       });

all_stri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> (Bool, b);
all_stri_efficient_m f [] m = (True, m);
all_stri_efficient_m f (a : asa) m =
  let {
    aa = f a m;
  } in (case aa of {
         (ab, b) ->
           (case ab of {
             (s, _) ->
               (\ ma ->
                 (if s then all_stri_efficient_m f asa ma else (False, ma)));
           })
             b;
       });

filter_not_stri_efficient_m_aux ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ([a], b);
filter_not_stri_efficient_m_aux f [] bs m = (bs, m);
filter_not_stri_efficient_m_aux f (a : asa) bs m =
  let {
    b = f a m;
  } in (case b of {
         (ba, c) ->
           (case ba of {
             (s, _) ->
               (\ ma ->
                 (if s then filter_not_stri_efficient_m_aux f asa bs ma
                   else filter_not_stri_efficient_m_aux f asa (a : bs) ma));
           })
             c;
       });

filter_not_stri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> ([a], b);
filter_not_stri_efficient_m f asa m =
  let {
    a = filter_not_stri_efficient_m_aux f asa [] m;
  } in (case a of {
         (ys, aa) -> (reverse ys, aa);
       });

mul_ext_efficient_m ::
  forall a b.
    (a -> a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ((Bool, Bool), b);
mul_ext_efficient_m f [] [] m = ((False, True), m);
mul_ext_efficient_m f [] (v : va) m = ((False, False), m);
mul_ext_efficient_m f (v : va) [] m = ((True, True), m);
mul_ext_efficient_m f (v : va) (y : ys) m =
  mul_ex_dom_efficient_m f (v : va) [] y ys m;

mul_ex_dom_efficient_m ::
  forall a b.
    (a -> a -> b -> ((Bool, Bool), b)) ->
      [a] -> [a] -> a -> [a] -> b -> ((Bool, Bool), b);
mul_ex_dom_efficient_m f [] xs y ys m = ((False, False), m);
mul_ex_dom_efficient_m f (x : xsa) xs y ys m =
  let {
    a = f x y m;
  } in (case a of {
         (aa, b) ->
           (case aa of {
             (s, ns) ->
               (\ ma ->
                 (if s then (case filter_not_stri_efficient_m (f x) ys ma of {
                              (ysa, m2) ->
                                let {
                                  ab = mul_ext_efficient_m f (xsa ++ xs) ysa m2;
                                } in (case ab of {
                                       (ac, ba) ->
 (case ac of {
   (_, nsa) ->
     (\ m3 ->
       (if nsa then ((True, True), m3)
         else mul_ex_dom_efficient_m f xsa (x : xs) y ys m3));
 })
   ba;
                                     });
                            })
                   else (if ns
                          then let {
                                 ab = mul_ext_efficient_m f (xsa ++ xs) ys ma;
                               } in (case ab of {
                                      (ac, ba) ->
(case ac of {
  (s2, ns2) ->
    (\ m4 ->
      (if s2 then ((True, True), m4)
        else let {
               ad = mul_ex_dom_efficient_m f xsa (x : xs) y ys m4;
             } in (case ad of {
                    (ae, bb) ->
                      (case ae of {
                        (s3, ns3) ->
                          (\ m5 ->
                            (if s3 then ((True, True), m5)
                              else ((False, ns2 || ns3), m5)));
                      })
                        bb;
                  })));
})
  ba;
                                    })
                          else mul_ex_dom_efficient_m f xsa (x : xs) y ys ma)));
           })
             b;
       });

lex_ext_efficient_m ::
  forall a b.
    (a -> a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ((Bool, Bool), b);
lex_ext_efficient_m f [] [] m = ((False, True), m);
lex_ext_efficient_m f (uu : uv) [] m = ((True, True), m);
lex_ext_efficient_m f [] (uw : ux) m = ((False, False), m);
lex_ext_efficient_m f (a : asa) (b : bs) m =
  let {
    aa = f a b m;
  } in (case aa of {
         (ab, ba) ->
           (case ab of {
             (s, ns) ->
               (\ ma ->
                 (if s then ((True, True), ma)
                   else (if ns then lex_ext_efficient_m f asa bs ma
                          else ((False, False), ma))));
           })
             ba;
       });

lookupe :: forall a b c d. Memory_ext a b c d -> a -> b -> Maybe c;
lookupe (Memory_ext empty lookup store more) = lookup;

store :: forall a b c d. Memory_ext a b c d -> a -> (b, c) -> a;
store (Memory_ext empty lookup store more) = store;

diag_l :: forall a b. (a, b) -> ((a, a), b);
diag_l (a, b) = ((a, a), b);

rpo_efficient_m ::
  forall a b c.
    (Eq c) => Memory_ext a (Term b c, Term b c) (Bool, Bool) () ->
                ((b, Nat) -> (b, Nat) -> (Bool, Bool), (b, Nat) -> Bool) ->
                  ((b, Nat) -> Order_tag) ->
                    Term b c -> Term b c -> a -> ((Bool, Bool), a);
rpo_efficient_m model pr tag s t m =
  (case lookupe model m (s, t) of {
    Nothing ->
      (case (case (s, t) of {
              (Var x, Var y) -> ((False, x == y), m);
              (Var _, Fun g ts) ->
                ((False, null ts && snd pr (g, zero_nat)), m);
              (Fun _ ss, Var y) ->
                diag_l
                  (any_nstri_efficient_m
                    (\ sa -> rpo_efficient_m model pr tag sa (Var y)) ss m);
              (Fun f ss, Fun g ts) ->
                (case any_nstri_efficient_m
                        (\ sa -> rpo_efficient_m model pr tag sa (Fun g ts)) ss
                        m
                  of {
                  (True, ma) -> ((True, True), ma);
                  (False, ma) ->
                    let {
                      maa = size_list ss;
                      n = size_list ts;
                    } in (case fst pr (f, maa) (g, n) of {
                           (prs, True) ->
                             (case all_stri_efficient_m
                                     (rpo_efficient_m model pr tag (Fun f ss))
                                     ts ma
                               of {
                               (True, mb) ->
                                 (if prs then ((True, True), mb)
                                   else let {
  cf = tag (f, maa);
} in (if equal_order_tag cf (tag (g, n))
       then (if equal_order_tag cf Mul
              then mul_ext_efficient_m (rpo_efficient_m model pr tag) ss ts mb
              else lex_ext_efficient_m (rpo_efficient_m model pr tag) ss ts mb)
       else let {
              b = equal_nat n zero_nat;
            } in ((not (equal_nat maa zero_nat) && b, b), mb)));
                               (False, mb) -> ((False, False), mb);
                             });
                           (_, False) -> ((False, False), ma);
                         });
                });
            })
        of {
        (res, res_m) -> (res, store model res_m ((s, t), res));
      });
    Just v -> (v, m);
  });

emptyf :: forall a b c d. Memory_ext a b c d -> () -> a;
emptyf (Memory_ext empty lookup store more) = empty;

efficient_rpo_2 ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
efficient_rpo_2 pr tag p q =
  fst (rpo_efficient_m l2m pr tag p q (emptyf l2m ()));

rpo_unbounded_impl ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
rpo_unbounded_impl = efficient_rpo_2;

rpo_unbounded ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
rpo_unbounded = rpo_unbounded_impl;

converse ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Set (a, b) -> Set (b, a);
converse r = image (\ (x, y) -> (y, x)) r;

ge_lbound :: forall a. (Eq a, Linorder a) => a -> Maybe a -> Bool;
ge_lbound c b = gelb less c b;

le_ubound :: forall a. (Eq a, Linorder a) => a -> Maybe a -> Bool;
le_ubound c b = leub less c b;

in_bounds ::
  forall a b.
    (Eq b, Linorder b) => a -> (a -> b) -> (a -> Maybe b, a -> Maybe b) -> Bool;
in_bounds x v (lb, ub) = ge_lbound (v x) (lb x) && le_ubound (v x) (ub x);

lt_lbound :: forall a. (Linorder a) => a -> Maybe a -> Bool;
lt_lbound c b = ltlb less c b;

set_unsat :: forall a b. (Eq a) => [a] -> State a b -> State a b;
set_unsat i (State t bil biu v u uc) =
  State t bil biu v True (Just (remdups i));

subst_var :: Nat -> Linear_poly -> Linear_poly -> Linear_poly;
subst_var v lpa lp =
  minus_linear_poly
    (plus_linear_poly lp (scaleRat_linear_poly (coeffa lp v) lpa))
    (scaleRat_linear_poly (coeffa lp v) (vara v));

returna :: forall a b. a -> Sum_bot b a;
returna x = Sumbot (Inr x);

the_Var :: forall a b. Term a b -> b;
the_Var (Var x1) = x1;

in_poss :: forall a b. [Nat] -> Term a b -> Bool;
in_poss [] uu = True;
in_poss (i : p) (Fun f ts) = less_nat i (size_list ts) && in_poss p (nth ts i);
in_poss (i : p) (Var uv) = False;

varposs :: forall a b. Term a b -> Set [Nat];
varposs (Var x) = inserta [] (set_empty (of_phantom set_impl_list));
varposs (Fun f ts) =
  sup_seta
    (image (\ i -> image (\ a -> i : a) (varposs (nth ts i)))
      (set (upt zero_nat (size_list ts))));

add_funs_term :: forall a b. Term a b -> [a] -> [a];
add_funs_term (Var uu) fs = fs;
add_funs_term (Fun f ts) fs = f : foldr add_funs_term ts fs;

add_funs_rule :: forall a b. (Term a b, Term a b) -> [a] -> [a];
add_funs_rule r fs = add_funs_term (fst r) (add_funs_term (snd r) fs);

funs_trs_list :: forall a b. [(Term a b, Term a b)] -> [a];
funs_trs_list trs = foldr add_funs_rule trs [];

instance_rule ::
  forall a b c.
    (Eq a, Eq b, Ccompare c, Eq c,
      Mapping_impl c) => (Term a b, Term a b) -> (Term a c, Term a c) -> Bool;
instance_rule lr st =
  not (is_none
        (match_list (\ _ -> fst lr) [(fst st, fst lr), (snd st, snd lr)]));

map_funs_rule ::
  forall a b c. (a -> b) -> (Term a c, Term a c) -> (Term b c, Term b c);
map_funs_rule fg lr =
  (map_term fg (\ x -> x) (fst lr), map_term fg (\ x -> x) (snd lr));

add_vars_rule :: forall a b. (Term a b, Term a b) -> [b] -> [b];
add_vars_rule r xs = add_vars_term (fst r) (add_vars_term (snd r) xs);

vars_trs_list :: forall a b. [(Term a b, Term a b)] -> [b];
vars_trs_list trs = foldr add_vars_rule trs [];

elem_list_to_rm ::
  forall a b. (Compare_order b) => (a -> b) -> [a] -> Rbt b [a];
elem_list_to_rm key (d : ds) = let {
                                 rm = elem_list_to_rm key ds;
                                 k = key d;
                               } in (case lookup rm k of {
                                      Nothing -> insert k [d] rm;
                                      Just dataa -> insert k (d : dataa) rm;
                                    });
elem_list_to_rm key [] = empty;

fun_of_map :: forall a b. (a -> Maybe b) -> b -> a -> b;
fun_of_map m d a = (case m a of {
                     Nothing -> d;
                     Just b -> b;
                   });

term_map ::
  forall a b. (Compare_order a) => [Term a b] -> (a, Nat) -> [Term a b];
term_map ts = fun_of_map (lookup (elem_list_to_rm (the . root) ts)) [];

label_depth :: forall a b. Lab a b -> Nat;
label_depth (UnLab uu) = zero_nat;
label_depth (Lab f uv) = suc (label_depth f);
label_depth (FunLab f uw) = suc (label_depth f);
label_depth (Sharp f) = suc (label_depth f);

gen_label :: forall a b. Lab a b -> Nat -> Lab a b;
gen_label f n =
  (if equal_nat n zero_nat then f
    else FunLab (gen_label f (minus_nat n one_nat)) []);

fmap ::
  forall a b.
    (Eq a,
      Eq b) => Lab a b ->
                 Nat ->
                   [((Lab a b, Nat), [Lab a b])] -> Lab a b -> Nat -> Lab a b;
fmap a nn sml =
  let {
    m = suc (max_list (map label_depth (a : concatMap snd sml)));
  } in (\ f n -> (if (f, n) == (a, nn) then a else gen_label f m));

enum_vectors :: forall a b. [a] -> [b] -> [[(b, a)]];
enum_vectors c [] = [[]];
enum_vectors c (x : xs) =
  let {
    a = enum_vectors c xs;
  } in concatMap (\ vec -> map (\ ca -> (x, ca) : vec) c) a;

replace_impl :: forall a. (Eq a) => a -> [a] -> [a] -> [a];
replace_impl a bs m =
  (if membera m a then bs ++ filter (\ b -> not (b == a)) m else m);

large_of :: forall a. ((a, Nat) -> Nat) -> Status a -> [(a, Nat)] -> Maybe Nat;
large_of pr sigma fs =
  let {
    m = max_list (map pr fs);
    ls = filter (\ f -> equal_nat (pr f) m) fs;
  } in (if less_nat zero_nat m && all (\ f -> null (status sigma f)) ls
         then Just m else Nothing);

doc_of_string :: [Char] -> Sum [Char] Xmldoc;
doc_of_string s = bindb (parse_doc s) (\ (doc, _) -> Inr doc);

special_map :: [Char] -> Maybe [Char];
special_map =
  map_of
    [([Char True False False False True True True False,
        Char True False True False True True True False,
        Char True True True True False True True False,
        Char False False True False True True True False],
       [Char False True False False False True False False]),
      ([Char True True False False False True False False,
         Char True True False False True True False False,
         Char False False True False True True False False],
        [Char False True False False False True False False]),
      ([Char True False False False False True True False,
         Char True False True True False True True False,
         Char False False False False True True True False],
        [Char False True True False False True False False]),
      ([Char True True False False False True False False,
         Char True True False False True True False False,
         Char False False False True True True False False],
        [Char False True True False False True False False]),
      ([Char True False False False False True True False,
         Char False False False False True True True False,
         Char True True True True False True True False,
         Char True True False False True True True False],
        [Char True True True False False True False False]),
      ([Char True True False False False True False False,
         Char True True False False True True False False,
         Char True False False True True True False False],
        [Char True True True False False True False False]),
      ([Char False False True True False True True False,
         Char False False True False True True True False],
        [Char False False True True True True False False]),
      ([Char True True False False False True False False,
         Char False True True False True True False False,
         Char False False False False True True False False],
        [Char False False True True True True False False]),
      ([Char True True True False False True True False,
         Char False False True False True True True False],
        [Char False True True True True True False False]),
      ([Char True True False False False True False False,
         Char False True True False True True False False,
         Char False True False False True True False False],
        [Char False True True True True True False False])];

pat_eqv_prf ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Pat_eqv_prf a [Char]);
pat_eqv_prf xml2name =
  let {
    sub = substa xml2name;
  } in xml_do "patternEquivalence"
         (xml_take
           (xml_or
             (xml_do "domainRenaming"
               (xml_take sub (\ n -> xml_return (Pat_Dom_Renaming n))))
             (xml_or
               (xml_do "irrelevant"
                 (xml_take sub
                   (\ n ->
                     xml_take sub (\ n2 -> xml_return (Pat_Irrelevant n n2)))))
               (xml_do "simplification"
                 (xml_take sub
                   (\ n ->
                     xml_take sub (\ n2 -> xml_return (Pat_Simplify n n2)))))))
           (\ x -> xml_return (id x)));

pat_term ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (Term a [Char],
                         ([([Char], Term a [Char])],
                           [([Char], Term a [Char])]));
pat_term xml2name =
  xml_do "patternTerm"
    (xml_take (term xml2name)
      (\ t ->
        xml_take (substa xml2name)
          (\ s1 ->
            xml_take (substa xml2name) (\ s2 -> xml_return (t, (s1, s2))))));

pat_rule_prf ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Pat_rule_prf a [Char]);
pat_rule_prf xml2name x =
  let {
    pat = pat_rule_prf xml2name;
    sub = substa xml2name;
    pt = pat_term xml2name;
    var = xml_text "var";
  } in xml_do "patternRule"
         (xml_take pt
           (\ _ ->
             xml_take pt
               (\ _ ->
                 xml_take
                   (xml_or
                     (xml_do "originalRule"
                       (xml_take (rule xml2name)
                         (\ r ->
                           xml_take (xml_bool "isPair")
                             (\ b -> xml_return (Pat_OrigRule r b)))))
                     (xml_or
                       (xml_do "initialPumping"
                         (xml_take pat
                           (\ a ->
                             xml_take sub
                               (\ b ->
                                 xml_take sub
                                   (\ c -> xml_return (Pat_InitPump a b c))))))
                       (xml_or
                         (xml_do "initialPumpingContext"
                           (xml_take pat
                             (\ a ->
                               xml_take sub
                                 (\ b ->
                                   xml_take pos
                                     (\ c ->
                                       xml_take var
 (\ d -> xml_return (Pat_InitPumpCtxt a b c d)))))))
                         (xml_or
                           (xml_do "equivalence"
                             (xml_take pat
                               (\ a ->
                                 xml_take
                                   (xml_or (xml_leaf "left" True)
                                     (xml_leaf "right" False))
                                   (\ b ->
                                     xml_take (pat_eqv_prf xml2name)
                                       (\ c -> xml_return (Pat_Equiv a b c))))))
                           (xml_or
                             (xml_do "narrowing"
                               (xml_take pat
                                 (\ a ->
                                   xml_take pat
                                     (\ b ->
                                       xml_take pos
 (\ c -> xml_return (Pat_Narrow a b c))))))
                             (xml_or
                               (xml_do "instantiation"
                                 (xml_take pat
                                   (\ a ->
                                     xml_take sub
                                       (\ b ->
 xml_take
   (xml_or (xml_leaf "base" Pat_Base)
     (xml_or (xml_leaf "pumping" Pat_Pump) (xml_leaf "closing" Pat_Close)))
   (\ c -> xml_return (Pat_Inst a b c))))))
                               (xml_or
                                 (xml_do "instantiationPumping"
                                   (xml_take pat
                                     (\ a ->
                                       xml_take (xml_nat "power")
 (\ b -> xml_return (Pat_Exp_Sigma a b)))))
                                 (xml_do "rewriting"
                                   (xml_take pat
                                     (\ a ->
                                       xml_take (rsteps xml2name)
 (\ b ->
   xml_take
     (xml_or (xml_leaf "base" (Pat_Base, []))
       (xml_or
         (xml_do "pumping" (xml_take var (\ v -> xml_return (Pat_Pump, v))))
         (xml_do "closing" (xml_take var (\ v -> xml_return (Pat_Close, v))))))
     (\ (po, va) -> xml_return (Pat_Rewr a b po va)))))))))))))
                   xml_return)))
         x;

nonloop ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Non_loop_prf (Lab a b) [Char]);
nonloop xml2name =
  xml_do "nonLoop"
    (xml_take (pat_rule_prf xml2name)
      (\ a ->
        xml_take (substa xml2name)
          (\ b ->
            xml_take (substa xml2name)
              (\ c ->
                xml_take (xml_nat "natural")
                  (\ d ->
                    xml_take (xml_nat "natural")
                      (\ e ->
                        xml_take pos
                          (\ f -> xml_return (Non_loop_prf a b c d e f))))))));

xml_rat ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Rat;
xml_rat =
  xml_or (xml_change (xml_int "integer") (xml_return . of_int))
    (xml_do "rational"
      (xml_take (xml_int "numerator")
        (\ a ->
          xml_take (xml_int "denominator")
            (\ b -> xml_return (divide_rat (of_int a) (of_int b))))));

eq_set ::
  forall a. (Card_UNIV a, Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
eq_set = set_eq;

choice :: forall a b. [Sum a b] -> Sum [a] b;
choice [] = Inl [];
choice (x : xs) =
  catch_errora x (\ e -> catch_errora (choice xs) (\ xa -> Inl (e : xa)));

firstM :: forall a b c. (a -> Sum b c) -> [a] -> Sum [b] a;
firstM f [] = Inl [];
firstM f (x : xs) =
  catch_errora (bindb (f x) (\ _ -> Inr x))
    (\ e -> catch_errora (firstM f xs) (\ xa -> Inl (e : xa)));

gen_filter ::
  forall a b c d e f.
    (a -> (b -> Bool) -> (c -> d -> d) -> e -> f) ->
      e -> (c -> d -> d) -> (c -> Bool) -> a -> f;
gen_filter it1 emp2 ins2 p s1 =
  it1 s1 (\ _ -> True) (\ x s -> (if p x then ins2 x s else s)) emp2;

gt_term ::
  forall a b c d.
    (Eq a,
      Eq c) => Bool ->
                 Bool ->
                   (Maybe (a, Nat) -> Maybe (b, Nat) -> Bool) ->
                     ((a, Nat) -> [(Term a c, Term a c)]) ->
                       Term a c -> Term b d -> Bool;
gt_term nlv ne gt_fun rm s t =
  ne && let {
          root1 = root s;
          root2 = root t;
        } in (is_Var s ||
               (is_Var t ||
                 (gt_fun Nothing Nothing ||
                   (gt_fun root1 root2 ||
                     (gt_fun root1 Nothing || gt_fun Nothing root2))))) &&
               (if nlv
                 then (case root1 of {
                        Nothing -> True;
                        Just fn ->
                          any (\ r -> matchb (tcapRM nlv rm s) (fst r)) (rm fn);
                      })
                 else True);

rd_impl ::
  forall a b c.
    (Eq a) => (Term a b -> Term a c -> Bool) ->
                (Term a b, Term a c) -> [(Term a b, Term a c)];
rd_impl gt (Fun f ss, Fun g ts) =
  (if f == g &&
        equal_nat (size_list ss) (size_list ts) &&
          not (gt (Fun f ss) (Fun g ts))
    then concatMap (rd_impl gt) (zip ss ts) else [(Fun f ss, Fun g ts)]);
rd_impl uu (Var v, t) = [(Var v, t)];
rd_impl uu (s, Var v) = [(s, Var v)];

nodes_lts_impl :: forall a b c d e. (Eq d) => Lts_impl a b c d e -> [d];
nodes_lts_impl pi =
  remdups
    (map (source . snd) (transitions_impl pi) ++
      map (target . snd) (transitions_impl pi));

rec_list :: forall a b. a -> (b -> [b] -> a -> a) -> [b] -> a;
rec_list f1 f2 [] = f1;
rec_list f1 f2 (x21 : x22) = f2 x21 x22 (rec_list f1 f2 x22);

product_lists :: forall a. [[a]] -> [[a]];
product_lists [] = [[]];
product_lists (xs : xss) =
  concatMap (\ x -> map (\ a -> x : a) (product_lists xss)) xs;

height :: forall a. (a, Nat) -> Nat;
height (f, h) = h;

mat_of_cols :: forall a. Nat -> [Vec a] -> Mat a;
mat_of_cols n cs = mat n (size_list cs) (\ (i, j) -> vec_index (nth cs j) i);

vec_of_list_impl :: forall a. [a] -> Vec_impl a;
vec_of_list_impl xa = Abs_vec_impl (size_list xa, IArray.of_list xa);

vec_of_list :: forall a. [a] -> Vec a;
vec_of_list v = Vec_impl (vec_of_list_impl v);

showsl_literal :: String -> String -> String;
showsl_literal s = showsl_lit s;

showsl_monom_list ::
  forall a. (Linorder a, Showl a) => [(a, Nat)] -> String -> String;
showsl_monom_list [(x, p)] =
  (if equal_nat p one_nat then showsl_lit "x" . showsl x
    else ((showsl_lit "x" . showsl x) . showsl_lit "^") . showsl_nat p);
showsl_monom_list ((x, p) : v : va) =
  ((if equal_nat p one_nat then showsl_lit "x" . showsl x
     else ((showsl_lit "x" . showsl x) . showsl_literal "^") . showsl_nat p) .
    showsl_literal "*") .
    showsl_monom_list (v : va);
showsl_monom_list [] = showsl_literal "1";

showsl_monom :: forall a. (Linorder a, Showl a) => Monom a -> String -> String;
showsl_monom xa = showsl_monom_list (rep_monom xa);

showsl_poly ::
  forall a b.
    (Eq a, Linorder a, Showl a, One b, Eq b,
      Showl b) => [(Monom a, b)] -> String -> String;
showsl_poly [] = showsl_lit "0";
showsl_poly ((m, c) : p) =
  (if c == onea then showsl_monom m
    else (if m == one_monom then showsl c
           else (showsl c . showsl_lit "*") . showsl_monom m)) .
    (if null p then id else showsl_lit " + " . showsl_poly p);

check_poly_ge ::
  forall a b.
    (Eq a, Linorder a,
      Ordered_semiring_0a b) => [(Monom a, b)] -> [(Monom a, b)] -> Bool;
check_poly_ge [] q = all (\ (_, d) -> less_eq d zerob) q;
check_poly_ge ((m, c) : p) q =
  (case extract (\ nd -> fst nd == m) q of {
    Nothing -> less_eq zerob c && check_poly_ge p q;
    Just (q1, ((_, d), q2)) -> less_eq d c && check_poly_ge p (q1 ++ q2);
  });

check_poly_gt ::
  forall a b.
    (Ordered_semiring_0a a, Eq b,
      Linorder b) => (a -> a -> Bool) ->
                       [(Monom b, a)] -> [(Monom b, a)] -> Bool;
check_poly_gt gt p q =
  (case poly_split one_monom p of {
    (a1, p1) -> (case poly_split one_monom q of {
                  (b1, q1) -> gt a1 b1 && check_poly_ge p1 q1;
                });
  });

monom_mult_list ::
  forall a. (Eq a, Linorder a) => [(a, Nat)] -> [(a, Nat)] -> [(a, Nat)];
monom_mult_list [] n = n;
monom_mult_list ((x, p) : m) n =
  (case n of {
    [] -> (x, p) : m;
    (y, q) : na ->
      (if x == y then (x, plus_nat p q) : monom_mult_list m na
        else (if less x y then (x, p) : monom_mult_list m n
               else (y, q) : monom_mult_list ((x, p) : m) na));
  });

times_monom :: forall a. (Eq a, Linorder a) => Monom a -> Monom a -> Monom a;
times_monom xb xc = Abs_monom (monom_mult_list (rep_monom xb) (rep_monom xc));

monom_mult_poly ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Semiring_0 b) => (Monom a, b) -> [(Monom a, b)] -> [(Monom a, b)];
monom_mult_poly uu [] = [];
monom_mult_poly (ma, c) ((m, d) : p) =
  (if times c d == zerob then monom_mult_poly (ma, c) p
    else (times_monom ma m, times c d) : monom_mult_poly (ma, c) p);

poly_add ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Semiring_0 b) => [(Monom a, b)] -> [(Monom a, b)] -> [(Monom a, b)];
poly_add [] q = q;
poly_add ((m, c) : p) q =
  (case extract (\ mc -> fst mc == m) q of {
    Nothing -> (m, c) : poly_add p q;
    Just (q1, ((_, d), q2)) ->
      (if plus c d == zerob then poly_add p (q1 ++ q2)
        else (m, plus c d) : poly_add p (q1 ++ q2));
  });

poly_mult ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Semiring_0 b) => [(Monom a, b)] -> [(Monom a, b)] -> [(Monom a, b)];
poly_mult [] q = [];
poly_mult (mc : p) q = poly_add (monom_mult_poly mc q) (poly_mult p q);

one_poly :: forall a b. (Linorder a, Semiring_1 b) => [(Monom a, b)];
one_poly = [(one_monom, onea)];

poly_power ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Comm_semiring_1 b) => [(Monom a, b)] -> Nat -> [(Monom a, b)];
poly_power uu n =
  (if equal_nat n zero_nat then one_poly
    else poly_mult uu (poly_power uu (minus_nat n one_nat)));

monom_list_subst ::
  forall a b c.
    (Eq b, Linorder b, Eq c,
      Comm_semiring_1 c) => (a -> [(Monom b, c)]) ->
                              [(a, Nat)] -> [(Monom b, c)];
monom_list_subst sigma [] = one_poly;
monom_list_subst sigma ((x, p) : m) =
  poly_mult (poly_power (sigma x) p) (monom_list_subst sigma m);

monom_list :: forall a. (Linorder a) => Monom a -> [(a, Nat)];
monom_list x = rep_monom x;

monom_subst ::
  forall a b c.
    (Linorder a, Eq b, Linorder b, Eq c,
      Comm_semiring_1 c) => (a -> [(Monom b, c)]) -> Monom a -> [(Monom b, c)];
monom_subst sigma m = monom_list_subst sigma (monom_list m);

zero_poly :: forall a b. [(Monom a, b)];
zero_poly = [];

poly_subst ::
  forall a b c.
    (Linorder a, Eq b, Linorder b, Eq c,
      Comm_semiring_1 c) => (a -> [(Monom b, c)]) ->
                              [(Monom a, c)] -> [(Monom b, c)];
poly_subst sigma [] = zero_poly;
poly_subst sigma ((m, c) : p) =
  poly_add (poly_mult [(one_monom, c)] (monom_subst sigma m))
    (poly_subst sigma p);

var_monom :: forall a. (Linorder a) => a -> Monom a;
var_monom xa = Abs_monom [(xa, one_nat)];

eval_term ::
  forall a b c.
    (Eq b, Poly_carrier b, Eq c,
      Linorder c) => ((a, Nat) -> [(Monom Nat, b)]) ->
                       Term a c -> [(Monom c, b)];
eval_term uu (Var x) = [(var_monom x, onea)];
eval_term i (Fun f ts) =
  let {
    ps = map (eval_term i) ts;
    n = size_list ts;
  } in poly_subst (\ ia -> (if less_nat ia n then nth ps ia else zero_poly))
         (i (f, n));

check_s ::
  forall a b c.
    (Eq a, Poly_carrier a, Showl a, Showl b, Eq c, Linorder c,
      Showl c) => (a -> a -> Bool) ->
                    ((b, Nat) -> [(Monom Nat, a)]) ->
                      (Term b c, Term b c) -> Sum (String -> String) ();
check_s gt i =
  (\ (s, t) ->
    let {
      p = eval_term i s;
      q = eval_term i t;
    } in check (check_poly_gt gt p q)
           (((((((showsl_literal "could not ensure " . showsl_terma s) .
                  showsl_literal " > ") .
                 showsl_terma t) .
                showsl_literal " since we\ncould not ensure ") .
               showsl_poly p) .
              showsl_literal " > ") .
             showsl_poly q));

content :: forall a. (Semiring_gcd a) => Poly a -> a;
content p = fold_coeffs gcda p zerob;

curry :: forall a b c. ((a, b) -> c) -> a -> b -> c;
curry f a b = f (a, b);

scnp_af_to_af ::
  forall a.
    ((a, Nat) -> [(Nat, Nat)]) -> ((a, Nat) -> Set Nat) -> (a, Nat) -> Set Nat;
scnp_af_to_af pia pi =
  (\ (f, n) ->
    let {
      is = map fst (pia (f, n));
    } in (if any (less_eq_nat n) is then sup_set (pi (f, n)) (set is)
           else set is));

semilattice_set_apply :: forall a. Semilattice_set a -> a -> a -> a;
semilattice_set_apply (Abs_semilattice_set x) = x;

set_fold1 ::
  forall a. (Ceq a, Ccompare a, Lattice a) => Semilattice_set a -> Set a -> a;
set_fold1 f (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold1 RBT_set: ccompare = None" (\ _ -> set_fold1 f (RBT_set rbt));
    Just _ ->
      (if is_emptya rbt
        then (error :: forall a. String -> (() -> a) -> a)
               "set_fold1 RBT_set: empty set" (\ _ -> set_fold1 f (RBT_set rbt))
        else fold1 (semilattice_set_apply f) rbt);
  });
set_fold1 f (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold1 DList_set: ceq = None" (\ _ -> set_fold1 f (DList_set dxs));
    Just _ ->
      (if nulla dxs
        then (error :: forall a. String -> (() -> a) -> a)
               "set_fold1 DList_set: empty set"
               (\ _ -> set_fold1 f (DList_set dxs))
        else foldc (semilattice_set_apply f) (tl dxs) (hd dxs));
  });
set_fold1 f (Set_Monad (x : xs)) = fold (semilattice_set_apply f) xs x;
set_fold1 f (Collect_set p) =
  (error :: forall a. String -> (() -> a) -> a) "set_fold1: Collect_set"
    (\ _ -> set_fold1 f (Collect_set p));
set_fold1 f (Complement a) =
  (error :: forall a. String -> (() -> a) -> a) "set_fold1: Complement"
    (\ _ -> set_fold1 f (Complement a));

min_satisfying :: forall a. (Linorder a) => (a -> Bool) -> [a] -> Maybe a;
min_satisfying p l =
  let {
    xs = filter p l;
  } in (if null xs then Nothing else Just (foldl min (hda xs) (tla xs)));

v :: forall a b. State a b -> Mapping Nat b;
v (State x1 x2 x3 x4 x5 x6) = x4;

t :: forall a b. State a b -> [(Nat, Linear_poly)];
t (State x1 x2 x3 x4 x5 x6) = x1;

min_lvar_not_in_bounds ::
  forall a b. (Zero b, Eq b, Linorder b) => State a b -> Maybe Nat;
min_lvar_not_in_bounds s =
  min_satisfying
    (\ x -> not (in_bounds x (map2fun (v s)) (boundsl s, boundsu s)))
    (map lhs (t s));

v_update :: forall a b. Mapping Nat a -> State b a -> State b a;
v_update v (State t bil biu v_old u uc) = State t bil biu v u uc;

rhs_eq_val ::
  forall a.
    (Minus a, Plus a, Zero a,
      ScaleRat a) => Mapping Nat a -> Nat -> a -> (Nat, Linear_poly) -> a;
rhs_eq_val v x_i c e =
  let {
    x_j = lhs e;
    a_i_j = coeffa (rhs e) x_i;
  } in plus (map2fun v x_j) (scaleRat a_i_j (minus c (map2fun v x_i)));

update_code :: forall a b. (Lrv a) => Nat -> a -> State b a -> State b a;
update_code x c s =
  v_update
    (updateb x c
      (foldl (\ va e -> updateb (lhs e) (rhs_eq_val (v s) x c e) va) (v s)
        (t s)))
    s;

subst_var_eq_code ::
  Nat -> Linear_poly -> (Nat, Linear_poly) -> (Nat, Linear_poly);
subst_var_eq_code v lp eq = (lhs eq, subst_var v lp (rhs eq));

eq_idx_for_lvar_aux :: [(Nat, Linear_poly)] -> Nat -> Nat -> Nat;
eq_idx_for_lvar_aux [] x i = i;
eq_idx_for_lvar_aux (eq : t) x i =
  (if equal_nat (lhs eq) x then i
    else eq_idx_for_lvar_aux t x (plus_nat i one_nat));

eq_idx_for_lvar :: [(Nat, Linear_poly)] -> Nat -> Nat;
eq_idx_for_lvar t x = eq_idx_for_lvar_aux t x zero_nat;

eq_for_lvar_code :: [(Nat, Linear_poly)] -> Nat -> (Nat, Linear_poly);
eq_for_lvar_code t v = nth t (eq_idx_for_lvar t v);

pivot_tableau_code ::
  Nat -> Nat -> [(Nat, Linear_poly)] -> [(Nat, Linear_poly)];
pivot_tableau_code x_i x_j t =
  let {
    eq = eq_for_lvar_code t x_i;
    eqa = pivot_eq eq x_j;
  } in map (\ e ->
             (if equal_nat (lhs e) (lhs eq) then eqa
               else subst_var_eq_code x_j (rhs eqa) e))
         t;

t_update :: forall a b. [(Nat, Linear_poly)] -> State a b -> State a b;
t_update t (State t_old bil biu v u uc) = State t bil biu v u uc;

pivot_code :: forall a b. (Lrv b) => Nat -> Nat -> State a b -> State a b;
pivot_code x_i x_j s = t_update (pivot_tableau_code x_i x_j (t s)) s;

pivot_and_update_code ::
  forall a b. (Lrv a) => Nat -> Nat -> a -> State b a -> State b a;
pivot_and_update_code x_i x_j c s = update_code x_i c (pivot_code x_i x_j s);

ui :: forall a b. (Linorder b) => Direction a b -> State a b -> Nat -> a;
ui (Direction x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) = x7;

li :: forall a b. (Linorder b) => Direction a b -> State a b -> Nat -> a;
li (Direction x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) = x6;

unsat_indices ::
  forall a b.
    (Eq a,
      Linorder b) => Direction a b ->
                       State a b -> [Nat] -> (Nat, Linear_poly) -> [a];
unsat_indices dir s vs eq =
  let {
    r = rhs eq;
    lia = li dir s;
    uia = ui dir s;
  } in remdups
         (lia (lhs eq) :
           map (\ x ->
                 (if less_rat (coeffa r x) zero_rat then lia x else uia x))
             vs);

lt :: forall a b. (Linorder b) => Direction a b -> b -> b -> Bool;
lt (Direction x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) = x1;

ub :: forall a b. (Linorder b) => Direction a b -> State a b -> Nat -> Maybe b;
ub (Direction x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) = x5;

lb :: forall a b. (Linorder b) => Direction a b -> State a b -> Nat -> Maybe b;
lb (Direction x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) = x4;

min_rvar_incdec_eq ::
  forall a b.
    (Eq a,
      Lrv b) => Direction a b -> State a b -> (Nat, Linear_poly) -> Sum [a] Nat;
min_rvar_incdec_eq dir s eq =
  let {
    rvars = vars_list (rhs eq);
  } in (case min_satisfying
               (\ x ->
                 less_rat zero_rat (coeffa (rhs eq) x) &&
                   ltub (lt dir) (map2fun (v s) x) (ub dir s x) ||
                   less_rat (coeffa (rhs eq) x) zero_rat &&
                     gtlb (lt dir) (map2fun (v s) x) (lb dir s x))
               rvars
         of {
         Nothing -> Inl (unsat_indices dir s rvars eq);
         Just a -> Inr a;
       });

check_codea ::
  forall a b. (Eq a, Lrv b) => Direction a b -> Nat -> State a b -> State a b;
check_codea dir x_i s =
  let {
    l_i = the (lb dir s x_i);
  } in (case min_rvar_incdec_eq dir s (eq_for_lvar_code (t s) x_i) of {
         Inl i -> set_unsat i s;
         Inr x_j -> pivot_and_update_code x_i x_j l_i s;
       });

u :: forall a b. State a b -> Bool;
u (State x1 x2 x3 x4 x5 x6) = x5;

check_code :: forall a b. (Eq a, Eq b, Lrv b) => State a b -> State a b;
check_code s =
  (if u s then s
    else (case min_lvar_not_in_bounds s of {
           Nothing -> s;
           Just x_i ->
             let {
               dir = (if lt_lbound (map2fun (v s) x_i) (boundsl s x_i)
                       then positive else negative);
             } in check_code (check_codea dir x_i s);
         }));

init_state :: forall a b. (Zero b) => [(Nat, Linear_poly)] -> State a b;
init_state t =
  State t (mapping_empty (of_phantom mapping_impl_nat))
    (mapping_empty (of_phantom mapping_impl_nat))
    (tabulate (remdups (map lhs t ++ concatMap (vars_list . rhs) t))
      (\ _ -> zerob))
    False Nothing;

max_var :: Linear_poly -> Nat;
max_var lp = let {
               vl = vars_list lp;
             } in (if null vl then zero_nat else foldl max (hda vl) (tla vl));

normalize_ns_constraint ::
  forall a. (Lrv a) => Ns_constraint a -> Ns_constraint a;
normalize_ns_constraint (LEQ_ns l r) =
  let {
    v = max_var l;
    c = coeffa l v;
  } in (if equal_rat c zero_rat then LEQ_ns l r
         else let {
                ic = inverse_rat c;
              } in (if less_rat c zero_rat
                     then GEQ_ns (scaleRat_linear_poly ic l) (scaleRat ic r)
                     else LEQ_ns (scaleRat_linear_poly ic l) (scaleRat ic r)));
normalize_ns_constraint (GEQ_ns l r) =
  let {
    v = max_var l;
    c = coeffa l v;
  } in (if equal_rat c zero_rat then GEQ_ns l r
         else let {
                ic = inverse_rat c;
              } in (if less_rat c zero_rat
                     then LEQ_ns (scaleRat_linear_poly ic l) (scaleRat ic r)
                     else GEQ_ns (scaleRat_linear_poly ic l) (scaleRat ic r)));

pivot_tableau_eq ::
  [(Nat, Linear_poly)] ->
    (Nat, Linear_poly) ->
      [(Nat, Linear_poly)] ->
        Nat ->
          ([(Nat, Linear_poly)], ((Nat, Linear_poly), [(Nat, Linear_poly)]));
pivot_tableau_eq t1 eq t2 x = let {
                                eqa = pivot_eq eq x;
                                m = map (subst_var_eq_code x (rhs eqa));
                              } in (m t1, (eqa, m t2));

preprocess_opt ::
  forall a.
    (Lrv a) => Set Nat ->
                 [(Nat, Linear_poly)] ->
                   [(Nat, Linear_poly)] ->
                     ([(Nat, Linear_poly)], Mapping Nat a -> Mapping Nat a);
preprocess_opt x t1 [] = (t1, id);
preprocess_opt xa t1 ((x, p) : t2) =
  (if not (member x xa)
    then (case preprocess_opt xa t1 t2 of {
           (t, tv) -> (t, (\ v -> updateb x (valuate p (map2fun v)) v) . tv);
         })
    else (case find (\ xb -> not (member xb xa)) (vars_list p) of {
           Nothing -> preprocess_opt xa ((x, p) : t1) t2;
           Just y ->
             (case pivot_tableau_eq t1 (x, p) t2 y of {
               (tt1, ((z, q), tt2)) ->
                 (case preprocess_opt xa tt1 tt2 of {
                   (t, tv) ->
                     (t, (\ v -> updateb z (valuate q (map2fun v)) v) . tv);
                 });
             });
         }));

preprocess_part_2 ::
  forall a b c.
    (Ceq a, Ccompare a, Set_impl a, Ccompare b, Eq b,
      Lrv c) => [(a, Atom b)] ->
                  [(Nat, Linear_poly)] ->
                    ([(Nat, Linear_poly)], Mapping Nat c -> Mapping Nat c);
preprocess_part_2 asa t =
  preprocess_opt (image atom_var (image snd (set asa))) [] t;

start_fresh_variable :: forall a. [(a, Ns_constraint QDelta)] -> Nat;
start_fresh_variable [] = zero_nat;
start_fresh_variable ((i, h) : t) =
  max (plus_nat (max_var (poly h)) one_nat) (start_fresh_variable t);

unsatIndices :: forall a. Istate a -> [a];
unsatIndices (IState x1 x2 x3 x4 x5) = x5;

tableau :: forall a. Istate a -> [(Nat, Linear_poly)];
tableau (IState x1 x2 x3 x4 x5) = x2;

atoms :: forall a. Istate a -> [(a, Atom QDelta)];
atoms (IState x1 x2 x3 x4 x5) = x3;

zeroa :: Fmap Nat Rat;
zeroa = fmempty;

zero_linear_poly :: Linear_poly;
zero_linear_poly = LinearPoly zeroa;

qdelta_constraint_to_atom :: Ns_constraint QDelta -> Nat -> Atom QDelta;
qdelta_constraint_to_atom (LEQ_ns l r) v = Leq v r;
qdelta_constraint_to_atom (GEQ_ns l r) v = Geq v r;

firstFreshVariable :: forall a. Istate a -> Nat;
firstFreshVariable (IState x1 x2 x3 x4 x5) = x1;

is_monom :: Linear_poly -> Bool;
is_monom l = equal_nat (size_list (vars_list l)) one_nat;

poly_Mapping :: forall a. Istate a -> Linear_poly -> Maybe Nat;
poly_Mapping (IState x1 x2 x3 x4 x5) = x4;

linear_poly_to_eq :: Linear_poly -> Nat -> (Nat, Linear_poly);
linear_poly_to_eq p v = (v, p);

zero_satisfies :: forall a. (Lrv a) => Ns_constraint a -> Bool;
zero_satisfies (LEQ_ns l r) = less_eq zerob r;
zero_satisfies (GEQ_ns l r) = less_eq r zerob;

monom_var :: Linear_poly -> Nat;
monom_var l = max_var l;

monom_coeff :: Linear_poly -> Rat;
monom_coeff l = coeffa l (monom_var l);

monom_to_atom :: Ns_constraint QDelta -> Atom QDelta;
monom_to_atom (LEQ_ns l r) =
  (if less_rat (monom_coeff l) zero_rat
    then Geq (monom_var l) (scaleRat_QDelta (inverse_rat (monom_coeff l)) r)
    else Leq (monom_var l) (scaleRat_QDelta (inverse_rat (monom_coeff l)) r));
monom_to_atom (GEQ_ns l r) =
  (if less_rat (monom_coeff l) zero_rat
    then Leq (monom_var l) (scaleRat_QDelta (inverse_rat (monom_coeff l)) r)
    else Geq (monom_var l) (scaleRat_QDelta (inverse_rat (monom_coeff l)) r));

preprocessa :: forall a. [(a, Ns_constraint QDelta)] -> Nat -> Istate a;
preprocessa ((i, h) : t) v =
  let {
    s = preprocessa t v;
    p = poly h;
    is_monom_h = is_monom p;
    va = firstFreshVariable s;
    ta = tableau s;
    a = atoms s;
    m = poly_Mapping s;
    u = unsatIndices s;
  } in (if is_monom_h then IState va ta ((i, monom_to_atom h) : a) m u
         else (if equal_linear_poly p zero_linear_poly
                then (if zero_satisfies h then s else IState va ta a m (i : u))
                else (case m p of {
                       Nothing ->
                         IState (plus_nat va one_nat)
                           (linear_poly_to_eq p va : ta)
                           ((i, qdelta_constraint_to_atom h va) : a)
                           (fun_upd m p (Just va)) u;
                       Just vaa ->
                         IState va ta ((i, qdelta_constraint_to_atom h vaa) : a)
                           m u;
                     })));
preprocessa [] v = IState v [] [] (\ _ -> Nothing) [];

preprocess_part_1 ::
  forall a.
    [(a, Ns_constraint QDelta)] ->
      ([(Nat, Linear_poly)], ([(a, Atom QDelta)], [a]));
preprocess_part_1 l = let {
                        start = start_fresh_variable l;
                        is = preprocessa l start;
                      } in (tableau is, (atoms is, unsatIndices is));

preprocess ::
  forall a.
    (Ceq a, Ccompare a,
      Set_impl a) => [(a, Ns_constraint QDelta)] ->
                       ([(Nat, Linear_poly)],
                         ([(a, Atom QDelta)],
                           (Mapping Nat QDelta -> Mapping Nat QDelta, [a])));
preprocess l =
  (case preprocess_part_1 (map (map_prod id normalize_ns_constraint) l) of {
    (t, (asa, ui)) -> (case preprocess_part_2 asa t of {
                        (ta, tv) -> (ta, (asa, (tv, ui)));
                      });
  });

projr :: forall a b. Sum a b -> b;
projr (Inr x2) = x2;

rec_term ::
  forall a b c. (a -> b) -> (c -> [(Term c a, b)] -> b) -> Term c a -> b;
rec_term f1 f2 (Var x1) = f1 x1;
rec_term f1 f2 (Fun x21 x22) =
  f2 x21 (map (\ term -> (term, rec_term f1 f2 term)) x22);

mk_subst_domain ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)];
mk_subst_domain sigma =
  let {
    tau = mk_subst Var sigma;
  } in filter (\ (x, t) -> not (equal_term (Var x) t))
         (map (\ x -> (x, tau x)) (remdups (map fst sigma)));

subst_eq ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> Bool;
subst_eq sigma tau = let {
                       sigmaa = mk_subst_domain sigma;
                       taua = mk_subst_domain tau;
                     } in set_eq (set sigmaa) (set taua);

hole_pos :: forall a b. Ctxt a b -> [Nat];
hole_pos Hole = [];
hole_pos (More f ss d ts) = size_list ss : hole_pos d;

full_af :: forall a. (a, Nat) -> Set Nat;
full_af fn = set (upt zero_nat (snd fn));

add_funas_term :: forall a b. Term a b -> [(a, Nat)] -> [(a, Nat)];
add_funas_term (Var uu) fs = fs;
add_funas_term (Fun f ts) fs = (f, size_list ts) : foldr add_funas_term ts fs;

add_funas_rule :: forall a b. (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
add_funas_rule r fs = add_funas_term (fst r) (add_funas_term (snd r) fs);

funas_trs_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
funas_trs_list trs = foldr add_funas_rule trs [];

funs_rule_list :: forall a b. (Term a b, Term a b) -> [a];
funs_rule_list r = add_funs_rule r [];

vars_rule_list :: forall a b. (Term a b, Term a b) -> [b];
vars_rule_list r = add_vars_rule r [];

supteq_list :: forall a b. Term a b -> [Term a b];
supteq_list (Var x) = [Var x];
supteq_list (Fun f ts) = Fun f ts : concatMap supteq_list ts;

is_NF_main ::
  forall a b.
    (Compare_order a, Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool -> ((a, Nat) -> [Term a b]) -> Term a b -> Bool;
is_NF_main var_cond r_empty m =
  (if var_cond then (\ _ -> False)
    else (if r_empty then (\ _ -> True)
           else (\ t ->
                  all (\ u ->
                        (if not (is_Var u)
                          then all (\ l -> not (matches u l)) (m (the (root u)))
                          else True))
                    (supteq_list t))));

is_NF_trs ::
  forall a b c.
    (Compare_order a, Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, c)] -> Term a b -> Bool;
is_NF_trs r =
  is_NF_main (any (\ ra -> is_Var (fst ra)) r) (null r) (term_map (map fst r));

apply_args :: forall a b. a -> Term a b -> [Term a b] -> Term a b;
apply_args a t [] = t;
apply_args a t (s : ss) = apply_args a (Fun a [t, s]) ss;

get_symbol :: forall a. (a -> Nat -> [a]) -> a -> Nat -> Nat -> a;
get_symbol sm f n i = nth (sm f n) i;

strategy_of_string ::
  forall a b c d.
    [Char] ->
      ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Sum (Strategy a b) (Fp_strategy c d));
strategy_of_string str =
  (if str ==
        [Char False True True False False False True False,
          Char True False True False True False True False,
          Char False False True True False False True False,
          Char False False True True False False True False]
    then xml_return (Inl No_Strategy)
    else (if str ==
               [Char True False False True False False True False,
                 Char False True True True False False True False,
                 Char False True True True False False True False,
                 Char True False True False False False True False,
                 Char False True False False True False True False,
                 Char True False True True False False True False,
                 Char True True True True False False True False,
                 Char True True False False True False True False,
                 Char False False True False True False True False]
           then xml_return (Inl Innermost)
           else (if str ==
                      [Char True True True True False False True False,
                        Char True False True False True False True False,
                        Char False False True False True False True False,
                        Char True False True False False False True False,
                        Char False True False False True False True False,
                        Char True False True True False False True False,
                        Char True True True True False False True False,
                        Char True True False False True False True False,
                        Char False False True False True False True False]
                  then xml_return (Inr Outermost)
                  else xml_error
                         (("unknown strategy \"" ++ implode str) ++ "\""))));

signature_to_AC ::
  forall a b. (Showl a) => [a] -> [a] -> [(a, (b, (Bool, Bool)))] -> ([a], [a]);
signature_to_AC asa cs [] = (asa, cs);
signature_to_AC asa cs (fnac : sig) =
  (case fnac of {
    (f, a) ->
      (case a of {
        (_, aa) ->
          (case aa of {
            (ab, c) ->
              signature_to_AC (if ab then f : asa else asa)
                (if c then f : cs else cs) sig;
          });
      });
  });

xml_take_attribute ::
  forall a.
    String ->
      ([Char] ->
        ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) a) ->
        ([Xml], ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) a;
xml_take_attribute att p xs =
  (case xs of {
    (xmls, (atts, (allow, (cands, pos)))) ->
      (case pick_up [] (explode att) atts of {
        Nothing -> xml_error (("attribute \"" ++ att) ++ "\" not found") xs;
        Just (v, rest) -> p v (xmls, (rest, (allow, (cands, pos))));
      });
  });

signature ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [(a, (Nat, (Bool, Bool)))];
signature xml2name =
  xml_do "signature"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "funcsym"
        (xml_take xml2name
          (\ name ->
            xml_take (xml_nat "arity")
              (\ arity ->
                xml_take_optional (xml_text "theory")
                  (\ a ->
                    (case a of {
                      Nothing -> xml_return (name, (arity, (False, False)));
                      Just th ->
                        (if th == [Char True False False False False False True
                                     False]
                          then (if equal_nat arity
                                     (nat_of_integer (2 :: Integer))
                                 then xml_return (name, (arity, (True, False)))
                                 else xml_error
(((("wrong arity " ++ showsl_nat arity "") ++ " for associative symbol \"") ++
   showsl name "") ++
  "\""))
                          else (if th == [Char True False False False False
    False True False,
   Char True True False False False False True False]
                                 then (if equal_nat arity
    (nat_of_integer (2 :: Integer))
then xml_return (name, (arity, (True, True)))
else xml_error
       (((("wrong arity " ++ showsl_nat arity "") ++ " for AC symbol \"") ++
          showsl name "") ++
         "\""))
                                 else (if th ==
    [Char True True False False False False True False]
then (if equal_nat arity (nat_of_integer (2 :: Integer))
       then xml_return (name, (arity, (False, True)))
       else xml_error
              (((("wrong arity " ++ showsl_nat arity "") ++
                  " for commutative symbol \"") ++
                 showsl name "") ++
                "\""))
else xml_error (("unknown theory \"" ++ implode th) ++ "\""))));
                    }))))))
      xml_return);

problem ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
problem xml2name =
  xml_do "problem"
    (xml_take_attribute "type"
      (\ _ ->
        xml_take
          (xml_do "trs"
            (xml_take
              (xml_do "rules"
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (crule xml2name "rule")
                  (\ crules ->
                    xml_take_default []
                      (xml_do "relrules"
                        (xml_take_many_sub [] zero_nat Infinity_enat
                          (rule xml2name) xml_return))
                      (\ rel -> xml_return (crules, rel)))))
              (\ (crules, rel) ->
                xml_take (signature xml2name)
                  (\ sig ->
                    let {
                      a = signature_to_AC [] [] sig;
                    } in (case a of {
                           (aa, c) ->
                             xml_take_optional
                               (xml_do "comment"
                                 (xml_take_many_sub [] zero_nat Infinity_enat
                                   (\ x -> right (fst x))
                                   (\ _ -> xml_return ())))
                               (\ _ ->
                                 xml_take_optional
                                   (xml_do "conditiontype"
                                     (xml_take_many_sub [] zero_nat
                                       Infinity_enat (\ x -> right (fst x))
                                       (\ _ -> xml_return ())))
                                   (\ _ ->
                                     xml_return (crules, (rel, (aa, c)))));
                         })))))
          (\ (crules, a) ->
            (case a of {
              (rel, aa) ->
                (case aa of {
                  (ab, c) ->
                    xml_take
                      (xml_change (xml_text "strategy") strategy_of_string)
                      (\ strat ->
                        xml_take_default Full
                          (xml_do "startterm"
                            (xml_take
                              (xml_or
                                (xml_do "constructor-based"
                                  (xml_return Constructor_Based))
                                (xml_do "full" (xml_return Full)))
                              xml_return))
                          (\ start ->
                            xml_take_optional
                              (xml_do "status"
                                (xml_take_many_sub [] zero_nat Infinity_enat
                                  (\ x -> right (fst x))
                                  (\ _ -> xml_return ())))
                              (\ _ ->
                                xml_take_optional
                                  (xml_do "metainformation"
                                    (xml_take_many_sub [] zero_nat Infinity_enat
                                      (\ x -> right (fst x))
                                      (\ _ -> xml_return ())))
                                  (\ _ ->
                                    let {
                                      relative = not (null rel);
                                    } in (case
   (if all (\ (_, ac) -> null ac) crules then (False, map fst crules)
     else (True, []))
   of {
   (conditional, r) ->
     let {
       equational = not (null ab) || not (null c);
     } in (case (conditional, (equational, (relative, (strat, start)))) of {
            (True, (True, _)) -> xml_error "equational conditional system";
            (True, (False, (True, _))) ->
              xml_error "relative conditional system";
            (True, (False, (False, (Inl No_Strategy, Full)))) ->
              xml_return (CTRS_input crules);
            (True, (False, (False, (Inl No_Strategy, Constructor_Based)))) ->
              xml_error "unsupported combination";
            (True, (False, (False, (Inl Innermost, _)))) ->
              xml_error "unsupported combination";
            (True, (False, (False, (Inl (Innermost_Q _), _)))) ->
              xml_error "unsupported combination";
            (True, (False, (False, (Inr _, _)))) ->
              xml_error "unsupported combination";
            (False, (True, (True, _))) ->
              xml_error "relative equational system";
            (False, (True, (False, (Inl No_Strategy, Full)))) ->
              xml_return (AC_input r ab c);
            (False, (True, (False, (Inl No_Strategy, Constructor_Based)))) ->
              xml_error "unsupported combination";
            (False, (True, (False, (Inl Innermost, _)))) ->
              xml_error "unsupported combination";
            (False, (True, (False, (Inl (Innermost_Q _), _)))) ->
              xml_error "unsupported combination";
            (False, (True, (False, (Inr _, _)))) ->
              xml_error "unsupported combination";
            (False, (False, (True, (Inl istrat, _)))) ->
              xml_return (Inn_TRS_input istrat r rel start);
            (False, (False, (True, (Inr _, _)))) ->
              xml_error "unsupported combination";
            (False, (False, (False, (Inl istrat, _)))) ->
              xml_return (Inn_TRS_input istrat r rel start);
            (False, (False, (False, (Inr fpstrat, Full)))) ->
              xml_return (FP_TRS_input fpstrat r);
            (False, (False, (False, (Inr _, Constructor_Based)))) ->
              xml_error "unsupported combination";
          });
 })))));
                });
            }))));

symbols ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   String ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) [(a, Nat)];
symbols xml2name tagname =
  xml_do tagname
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "symbol"
        (xml_take xml2name
          (\ a -> xml_take (xml_nat "arity") (\ b -> xml_return (a, b)))))
      xml_return);

map_xml_text :: ([Char] -> [Char]) -> Xml -> Xml;
map_xml_text f (XML t asa cs) = XML t asa (map (map_xml_text f) cs);
map_xml_text f (XML_text txt) = XML_text (f txt);

orig_term :: forall a b. (a -> Maybe b) -> Term a b -> Term a b;
orig_term m (Var x) = Var x;
orig_term m (Fun f []) = (case m f of {
                           Nothing -> Fun f [];
                           Just a -> Var a;
                         });
orig_term m (Fun f (v : va)) = Fun f (map (orig_term m) (v : va));

prec_exta :: forall a b. (a -> Maybe (Nat, b)) -> a -> a -> Bool;
prec_exta prwm =
  (\ f g -> (case prwm f of {
              Nothing -> False;
              Just pf -> (case prwm g of {
                           Nothing -> True;
                           Just pg -> less_nat (fst pg) (fst pf);
                         });
            }));

rep_afs :: forall a. Afs a -> ((a, Nat) -> Af_entry, Set (a, Nat));
rep_afs (Abs_afs x) = x;

afsa :: forall a. Afs a -> (a, Nat) -> Af_entry;
afsa xa = fst (rep_afs xa);

sum_lpoly ::
  forall a.
    Partial_object_ext a (Monoid_ext a (Ring_ext a ())) -> [a] -> [a] -> [a];
sum_lpoly c [] ys = ys;
sum_lpoly c (v : va) [] = v : va;
sum_lpoly c (x : xs) (y : ys) = add c x y : sum_lpoly c xs ys;

lpoly_of ::
  forall a.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a ())) ->
                Tpoly Nat a -> Sum_bot String (a, [a]);
lpoly_of c (PNum i) = returna (i, []);
lpoly_of c (PVar x) = returna (zero c, replicate x (zero c) ++ [one c]);
lpoly_of c (PSum []) = returna (zero c, []);
lpoly_of c (PSum (p : ps)) =
  binda (lpoly_of c p)
    (\ (cp, ncp) ->
      binda (lpoly_of c (PSum ps))
        (\ (cq, ncq) -> returna (add c cp cq, sum_lpoly c ncp ncq)));
lpoly_of c (PMult []) = returna (one c, []);
lpoly_of c (PMult (p : ps)) =
  binda (lpoly_of c p)
    (\ (cp, ncp) ->
      binda (lpoly_of c (PMult ps))
        (\ (cq, ncq) ->
          (if all (\ a -> zero c == a) ncp
            then returna (mult c cp cq, map (mult c cp) ncq)
            else (if all (\ a -> zero c == a) ncq
                   then returna (mult c cp cq, map (\ x -> mult c x cq) ncp)
                   else errora
                          "cannot transform non-linear polynomial to linear polynomial"))));

renaming ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [(a, a)];
renaming xml2name =
  xml_do "renaming"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "renamingEntry"
        (xml_take xml2name
          (\ a -> xml_take xml2name (\ b -> xml_return (a, b)))))
      xml_return);

xml_real ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Real;
xml_real =
  xml_or (xml_change xml_rat (xml_return . ratreal))
    (xml_do "algebraic"
      (xml_take xml_rat
        (\ a ->
          xml_take xml_rat
            (\ b ->
              xml_take xml_rat
                (\ c ->
                  xml_return
                    (plus_real (ratreal a)
                      (times_real (ratreal b) (sqrt (ratreal c)))))))));

subset ::
  forall a. (Card_UNIV a, Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
subset = subset_eq;

char_poly_matrix ::
  forall a.
    (Eq a, Comm_ring_1 a, Semiring_no_zero_divisors a) => Mat a -> Mat (Poly a);
char_poly_matrix a =
  plus_mat
    (smult_mat (pCons zerob (pCons onea zero_polya)) (one_mat (dim_row a)))
    (map_mat (\ aa -> pCons (uminus aa) zero_polya) a);

char_poly :: forall a. (Eq a, Idom_divide a) => Mat a -> Poly a;
char_poly a = det (char_poly_matrix a);

existsM :: forall a b. (a -> Sum b ()) -> [a] -> Sum [b] ();
existsM f [] = Inl [];
existsM f (x : xs) =
  catch_errora (f x)
    (\ e -> catch_errora (existsM f xs) (\ xa -> Inl (e : xa)));

is_neg_atom :: forall a. Formula a -> Bool;
is_neg_atom (NegAtom uu) = True;
is_neg_atom (Atom v) = False;
is_neg_atom (Conjunction v) = False;
is_neg_atom (Disjunction v) = False;

showsl_hint :: forall a. (Showl a) => Hint a -> String -> String;
showsl_hint Default = showsl_lit " auto";
showsl_hint (Base raw) = showsl_lit " " . showsl raw;
showsl_hint (Distribute i hints) =
  (showsl_lit " Distribute " . showsl_nat i) .
    showsl_list_gen id " []" " [" ", " "]" (map showsl_hint hints);
showsl_hint (LexStrict hints) =
  showsl_lit " LexStrict" .
    showsl_list_gen id " []" " [" ", " "]" (map showsl_hint hints);
showsl_hint (LexWeak hints) =
  showsl_lit " LexWeak" .
    showsl_list_gen id " []" " [" ", " "]" (map showsl_hint hints);
showsl_hint (Erase i hint) =
  (((showsl_lit " Erase " . showsl_nat i) . showsl_lit " [") .
    showsl_hint hint) .
    showsl_lit " ]";

gen_isEmpty :: forall a b c. (a -> (b -> Bool) -> c) -> a -> c;
gen_isEmpty ball m = ball m (\ _ -> False);

gen_isEmptya :: forall a b. (a -> (b -> Bool) -> Bool) -> a -> Bool;
gen_isEmptya ball s = ball s (\ _ -> False);

nonreach ::
  forall a b c.
    (Eq a) => (Term a b -> Term a c -> Bool) -> Term a b -> Term a c -> Bool;
nonreach gt s t =
  (case (s, t) of {
    (Var _, _) -> False;
    (Fun _ _, Var _) -> False;
    (Fun f ss, Fun g ts) ->
      not ((f, size_list ss) == (g, size_list ts)) && not (gt s t);
  });

sum_mset :: forall a. (Comm_monoid_add a) => Multiset a -> a;
sum_mset (Bag ms) = foldd (\ a n -> funpow n (plus a)) zerob ms;

vars_term_ms :: forall a b. (Eq b) => Term a b -> Multiset b;
vars_term_ms (Var x) = add_mset x zero_multiset;
vars_term_ms (Fun f ts) = sum_mset (mset (map vars_term_ms ts));

weight ::
  forall a b.
    ((a, Nat) -> Nat) -> Nat -> ((a, Nat) -> Nat -> Nat) -> Term a b -> Nat;
weight w w0 scf (Fun f ts) =
  let {
    n = size_list ts;
    scff = scf (f, n);
  } in plus_nat (w (f, n))
         (sum_list
           (map (\ (ti, i) -> times_nat (weight w w0 scf ti) (scff i))
             (zip ts (upt zero_nat n))));
weight w w0 scf (Var x) = w0;

kbo_impl ::
  forall a b.
    (Eq b) => ((a, Nat) -> Nat) ->
                Nat ->
                  ((a, Nat) -> (a, Nat) -> (Bool, Bool)) ->
                    (a -> Bool) ->
                      ((a, Nat) -> Nat -> Nat) ->
                        Term a b -> Term a b -> (Bool, Bool);
kbo_impl w w0 prc least scf s t =
  let {
    wt = weight w w0 scf t;
    ws = weight w w0 scf s;
  } in (if subseteq_mset (vars_term_ms (scf_term scf t))
             (vars_term_ms (scf_term scf s)) &&
             less_eq_nat wt ws
         then (if less_nat wt ws then (True, True)
                else (case s of {
                       Var _ -> (False, (case t of {
  Var _ -> True;
  Fun g ts -> null ts && least g;
}));
                       Fun f ss ->
                         (case t of {
                           Var _ -> (True, True);
                           Fun g ts ->
                             let {
                               p = prc (f, size_list ss) (g, size_list ts);
                             } in (if fst p then (True, True)
                                    else (if snd p
   then lex_ext_unbounded (kbo_impl w w0 prc least scf) ss ts
   else (False, False)));
                         });
                     }))
         else (False, False));

kbo_strict ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool)) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        (a -> Bool) ->
                          ((a, Nat) -> Nat -> Nat) ->
                            (Term a b, Term a b) -> Sum (String -> String) ();
kbo_strict pr w w0 least scf =
  (\ (s, t) ->
    check (fst (kbo_impl w w0 pr least scf s t))
      ((((showsl_literal "could not orient " . showsl_terma s) .
          showsl_literal " >KBO ") .
         showsl_terma t) .
        showsl_literal "\n"));

trans_id ::
  forall a.
    (String ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a;
trans_id trans_id_parser = trans_id_parser "transitionId";

list_all2 :: forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool;
list_all2 p (x : xs) (y : ys) = p x y && list_all2 p xs ys;
list_all2 p xs [] = null xs;
list_all2 p [] ys = null ys;

elements_mat :: forall a. (Ceq a, Ccompare a, Set_impl a) => Mat a -> Set a;
elements_mat a =
  set (concatMap
        (\ i -> map (\ j -> index_mat a (i, j)) (upt zero_nat (dim_col a)))
        (upt zero_nat (dim_row a)));

single_alist_entry :: forall a b. a -> b -> Alist a b;
single_alist_entry xb xc = Alist [(xb, xc)];

image_mset :: forall a b. (Eq b) => (a -> b) -> Multiset a -> Multiset b;
image_mset f (Bag ms) =
  foldd (\ a n -> plus_multiset (Bag (single_alist_entry (f a) n)))
    zero_multiset ms;

eval :: forall a b c. (a -> [b] -> b) -> (c -> b) -> Term a c -> b;
eval i alpha (Var x) = alpha x;
eval i alpha (Fun f ts) = i f (map (eval i alpha) ts);

monom_vars_list :: forall a. (Linorder a) => Monom a -> [a];
monom_vars_list xa = map fst (rep_monom xa);

poly_vars_list :: forall a b. (Eq a, Linorder a) => [(Monom a, b)] -> [a];
poly_vars_list p = remdups (concatMap (monom_vars_list . fst) p);

concat_lists :: forall a. [[a]] -> [[a]];
concat_lists [] = [[]];
concat_lists (asa : xs) =
  concatMap (\ vec -> map (\ a -> a : vec) asa) (concat_lists xs);

poly_of ::
  forall a b.
    (Eq a, Linorder a, Eq b, Comm_semiring_1 b) => Tpoly a b -> [(Monom a, b)];
poly_of (PNum i) = (if i == zerob then [] else [(one_monom, i)]);
poly_of (PVar x) = [(var_monom x, onea)];
poly_of (PSum []) = zero_poly;
poly_of (PSum (p : ps)) = poly_add (poly_of p) (poly_of (PSum ps));
poly_of (PMult []) = one_poly;
poly_of (PMult (p : ps)) = poly_mult (poly_of p) (poly_of (PMult ps));

square_possibilities ::
  forall a b.
    (Eq a, Poly_carrier a, Eq b,
      Linorder b) => (a -> [a]) -> [(Monom b, a)] -> [[(Monom b, a)]];
square_possibilities sqrt p =
  let {
    roots =
      map (\ x ->
            map (\ a -> (x, a))
              (sqrt (fst (poly_split (times_monom (var_monom x) (var_monom x))
                           p))))
        (poly_vars_list p);
    choices = (if membera roots [] then [] else concat_lists roots);
    polys =
      map (\ xas ->
            poly_of (PSum (map (\ (x, a) -> PMult [PVar x, PNum a]) xas)))
        choices;
  } in polys;

check_poly_eq ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Semiring_0 b) => [(Monom a, b)] -> [(Monom a, b)] -> Bool;
check_poly_eq [] q = null q;
check_poly_eq ((m, c) : p) q =
  (case extract (\ nd -> fst nd == m) q of {
    Nothing -> False;
    Just (q1, ((_, d), q2)) -> c == d && check_poly_eq p (q1 ++ q2);
  });

monom_list_degree :: forall a. [(a, Nat)] -> Nat;
monom_list_degree xps = sum_list (map snd xps);

monom_degree :: forall a. (Linorder a) => Monom a -> Nat;
monom_degree xa = monom_list_degree (rep_monom xa);

poly_degree :: forall a b. (Linorder a) => [(Monom a, b)] -> Nat;
poly_degree p = max_list (map (\ (m, _) -> monom_degree m) p);

check_quadratic ::
  forall a.
    (Eq a,
      Poly_carrier a) => (a -> [a]) ->
                           [(Monom Nat, a)] -> Sum (String -> String) ();
check_quadratic sqrt p =
  bindb (check (equal_nat (poly_degree p) (nat_of_integer (2 :: Integer)))
          (showsl_literal "not quadratic"))
    (\ _ ->
      let {
        polys = square_possibilities sqrt p;
      } in check (any (\ q -> check_poly_eq (poly_mult q q) p) polys)
             (showsl_literal "could not find quadratic polynomial"));

check_quadratic_ge_const ::
  forall a b c.
    (Eq a, Poly_carrier a, Eq c,
      Linorder c) => (a -> [a]) ->
                       ((b, Nat) -> [(Monom Nat, a)]) ->
                         (Term b c, Term b c) -> Sum (String -> String) ();
check_quadratic_ge_const sq i st =
  (case st of {
    (s, t) ->
      bindb (check (not (is_Var s))
              (showsl_literal "require non-variables as arguments"))
        (\ _ ->
          let {
            pt = eval_term i t;
          } in (case poly_split one_monom pt of {
                 (c, p0) ->
                   bindb (check (p0 == zero_poly)
                           (showsl_literal "rhs must evaluate to constant"))
                     (\ _ ->
                       let {
                         ps = i (the (root s));
                       } in (case poly_split one_monom ps of {
                              (d, psx) ->
                                bindb (check (less_eq c d)
(showsl_literal "problem in comparing constants"))
                                  (\ _ -> check_quadratic sq psx);
                            }));
               }));
  });

check_ns ::
  forall a b c.
    (Showl a, Eq b, Poly_carrier b, Showl b, Eq c, Linorder c,
      Showl c) => ((a, Nat) -> [(Monom Nat, b)]) ->
                    (Term a c, Term a c) -> Sum (String -> String) ();
check_ns i =
  (\ (s, t) ->
    let {
      p = eval_term i s;
      q = eval_term i t;
    } in check (check_poly_ge p q)
           (((((((showsl_literal "could not ensure " . showsl_terma s) .
                  showsl_literal " >= ") .
                 showsl_terma t) .
                showsl_literal " since we\ncould not ensure ") .
               showsl_poly p) .
              showsl_literal " >= ") .
             showsl_poly q));

check_cc ::
  forall a b c.
    (Eq a, Poly_carrier a, Showl a, Showl b, Eq c, Linorder c,
      Showl c) => (a -> [a]) ->
                    (a -> a -> Bool) ->
                      ((b, Nat) -> [(Monom Nat, a)]) ->
                        C_constraint b c -> Sum (String -> String) ();
check_cc sq gt i (Unconditional_C False st) =
  (if isOK (check_quadratic_ge_const sq i st) then Inr () else check_ns i st);
check_cc sq gt i (Unconditional_C True st) = check_s gt i st;
check_cc sq gt i (Conditional_C True (u, v) (s, t)) =
  let {
    ss = eval_term i s;
    tt = eval_term i t;
    uu = eval_term i u;
    vv = eval_term i v;
  } in (if check_poly_gt gt ss tt then Inr ()
         else check (check_poly_ge (poly_add ss vv) (poly_add tt uu))
                (((((((showsl_literal "could not ensure " . showsl_terma u) .
                       showsl_literal " > ") .
                      showsl_terma v) .
                     showsl_literal " ==> ") .
                    showsl_terma s) .
                   showsl_literal " > ") .
                  showsl_terma t));
check_cc sq gt i (Conditional_C False (u, v) (s, t)) =
  (if isOK (check_quadratic_ge_const sq i (s, t)) then Inr ()
    else let {
           ss = eval_term i s;
           tt = eval_term i t;
           uu = eval_term i u;
           vv = eval_term i v;
         } in (if check_poly_ge ss tt then Inr ()
                else check (check_poly_ge (poly_add ss vv) (poly_add tt uu))
                       (((((((showsl_literal "could not ensure " .
                               showsl_terma u) .
                              showsl_literal " >= ") .
                             showsl_terma v) .
                            showsl_literal " ==> ") .
                           showsl_terma s) .
                          showsl_literal " >= ") .
                         showsl_terma t)));

map_poly :: forall b a. (Zero b, Zero a, Eq a) => (b -> a) -> Poly b -> Poly a;
map_poly f p = Poly (strip_while (\ a -> zerob == a) (map f (coeffs p)));

is_left_of :: [Nat] -> [Nat] -> Bool;
is_left_of [] q = False;
is_left_of (i : p) q =
  (case q of {
    [] -> False;
    j : qa ->
      (if less_nat i j then True
        else (if less_nat j i then False else is_left_of p qa));
  });

showsl_rpo_repr ::
  forall a. (Showl a) => [((a, Nat), (Nat, Order_tag))] -> String -> String;
showsl_rpo_repr prs =
  (((showsl_literal "RPO with the following precedence\n" .
      foldr (\ (a, b) ->
              (case a of {
                (f, n) ->
                  (\ (pr, _) ->
                    (((((showsl_literal "precedence(" . showsl f) .
                         showsl_literal "[") .
                        showsl_nat n) .
                       showsl_literal "]) = ") .
                      showsl_nat pr) .
                      showsl_literal "\n");
              })
                b)
        prs) .
     showsl_literal "\nprecedence(_) = 0\nand the following status\n") .
    foldr (\ (a, b) ->
            (case a of {
              (f, n) ->
                (\ (_, s) ->
                  (((((showsl_literal "status(" . showsl f) .
                       showsl_literal "[") .
                      showsl_nat n) .
                     showsl_literal "]) = ") .
                    showsl_literal (case s of {
                                     Lex -> "lex";
                                     Mul -> "mul";
                                   })) .
                    showsl_literal "\n");
            })
              b)
      prs) .
    showsl_literal "\nstatus(_) = lex\n";

rules_with ::
  forall a b c.
    (Linorder b) => (a -> Bool) ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        [(Term b c, Term b c)];
rules_with p m =
  map_filter (\ x -> (if (p . fst) x then Just (snd x) else Nothing))
    (values m);

scnp_desc ::
  forall a.
    (Showl a) => [((a, Nat), [(Nat, Nat)])] ->
                   (String -> String) -> String -> String;
scnp_desc af mu =
  (((showsl_lit "SCNP-version with mu = " . mu) .
     showsl_lit " and the level mapping defined by\n") .
    showsl_sep
      (\ (a, b) ->
        (case a of {
          (f, n) ->
            (\ asa ->
              ((showsl_lit "pi(" . showsl f) . showsl_lit ") = ") .
                default_showsl_list
                  (\ (p, l) ->
                    (((showsl_lit "(" .
                        (if less_nat p n then showsl_nat (suc p)
                          else showsl_lit "epsilon")) .
                       showsl_lit ",") .
                      showsl_nat l) .
                      showsl_lit ")")
                  asa);
        })
          b)
      (showsl_literal "\n") af) .
    showsl_literal "\n";

split_rulesb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_rulesb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = split_rules;

delete_R_Rwb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_R_Rwb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = delete_R_Rw;

nfsb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
nfsb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
       rules_map delete_R_Rw split_rules mk nfs more)
  = nfs;

mkc ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      Bool ->
        [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkc (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
      rules_map delete_R_Rw split_rules mk nfs more)
  = mk;

qb :: forall a b c d. Tp_ops_ext a b c d -> a -> [Term b c];
qb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
     delete_R_Rw split_rules mk nfs more)
  = q;

split_tt ::
  forall a b c.
    (Showl b,
      Showl c) => Tp_ops_ext a b c () -> a -> [(Term b c, Term b c)] -> (a, a);
split_tt i tp r_remove =
  (case split_rulesb i tp r_remove of {
    (r, rw) -> let {
                 tp1 = mkc i (nfsb i tp) (qb i tp) r rw;
                 a = delete_R_Rwb i tp r_remove r_remove;
               } in (tp1, a);
  });

mod_poly_one_main_list ::
  forall a. (Eq a, Comm_ring_1 a) => [a] -> [a] -> Nat -> [a];
mod_poly_one_main_list r d n =
  (if equal_nat n zero_nat then r
    else let {
           a = hda r;
           rr = tla (if a == zerob then r
                      else minus_poly_rev_list r (map (times a) d));
         } in mod_poly_one_main_list rr d (minus_nat n one_nat));

modulo_poly :: forall a. (Field a, Eq a) => Poly a -> Poly a -> Poly a;
modulo_poly f g =
  let {
    cg = coeffs g;
  } in (if null cg then f
         else let {
                cf = coeffs f;
                ilc = inverse (last cg);
                ch = map (times ilc) cg;
                r = mod_poly_one_main_list (reverse cf) (reverse ch)
                      (minus_nat (plus_nat one_nat (size_list cf))
                        (size_list cg));
              } in poly_of_list (reverse r));

sturm_aux :: Poly Real -> Poly Real -> [Poly Real];
sturm_aux p q =
  (if equal_nat (degreea q) zero_nat then [p, q]
    else p : sturm_aux q (uminus_poly (modulo_poly p q)));

sturm :: Poly Real -> [Poly Real];
sturm p = sturm_aux p (pderiv p);

supt_impl :: forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Bool;
supt_impl (Var x) t = False;
supt_impl (Fun f ss) t = membera ss t || any (\ s -> supt_impl s t) ss;

supt_list :: forall a b. Term a b -> [Term a b];
supt_list (Var x) = [];
supt_list (Fun f ts) = concatMap supteq_list ts;

af_inter ::
  forall a.
    ((a, Nat) -> Set Nat) -> ((a, Nat) -> Set Nat) -> (a, Nat) -> Set Nat;
af_inter pi mu f = inf_set (pi f) (mu f);

empty_af :: forall a. (a, Nat) -> Set Nat;
empty_af fn = set_empty (of_phantom set_impl_nat);

r_sym :: forall a b. Ta_rule a b -> (b, Nat);
r_sym (TA_rule f qs q) = (f, size_list qs);

funas_rule_list :: forall a b. (Term a b, Term a b) -> [(a, Nat)];
funas_rule_list r = add_funas_rule r [];

showsl_rulea ::
  forall a b.
    (a -> String -> String) ->
      (b -> String -> String) ->
        String -> (Term a b, Term a b) -> String -> String;
showsl_rulea fun var arr (l, r) =
  (showsl_term fun var l . showsl_literal arr) . showsl_term fun var r;

showsl_rulesa ::
  forall a b.
    (a -> String -> String) ->
      (b -> String -> String) ->
        String -> [(Term a b, Term a b)] -> String -> String;
showsl_rulesa fun var arr trs =
  showsl_list_gen (showsl_rulea fun var arr) "" "" "\n" "" trs .
    showsl_literal "\n";

showsl_trsa ::
  forall a b.
    (a -> String -> String) ->
      (b -> String -> String) ->
        String -> String -> [(Term a b, Term a b)] -> String -> String;
showsl_trsa fun var name arr r =
  (showsl_literal name . showsl_literal "\n\n") . showsl_rulesa fun var arr r;

showsl_trs ::
  forall a b. (Showl a, Showl b) => [(Term a b, Term a b)] -> String -> String;
showsl_trs = showsl_trsa showsl showsl "rewrite system:" " -> ";

aarity_term ::
  forall a b. (Eq a) => a -> (a -> Nat -> [a]) -> Term a b -> Maybe Nat;
aarity_term a sm t =
  (case unapp a t of {
    (Var _, _) -> Nothing;
    (Fun f ss, ts) ->
      Just (minus_nat (aarity sm f (size_list ss)) (size_list ts));
  });

map_funs_term_wa :: forall a b c. ((a, Nat) -> b) -> Term a c -> Term b c;
map_funs_term_wa fg (Var x) = Var x;
map_funs_term_wa fg (Fun f ts) =
  Fun (fg (f, size_list ts)) (map (map_funs_term_wa fg) ts);

uncurry_top ::
  forall a b. (Eq a) => a -> Nat -> (a -> Nat -> [a]) -> Term a b -> Term a b;
uncurry_top a n sm (Fun f ts) =
  let {
    mt = map (map_funs_term_wa (\ (fa, na) -> get_symbol sm fa na zero_nat));
    t = hda ts;
  } in (if f == a &&
             equal_nat (size_list ts) n &&
               not (is_Var t) &&
                 (case the (root t) of {
                   (h, m) -> not (equal_nat (aarity sm h m) zero_nat);
                 })
         then (case t of {
                Fun g ss ->
                  Fun (get_symbol sm g (size_list ss) one_nat)
                    (mt (ss ++ tla ts));
              })
         else Fun (case (f, size_list ts) of {
                    (fa, na) -> get_symbol sm fa na zero_nat;
                  })
                (mt ts));
uncurry_top a n sm (Var x) = Var x;

innermostLhss ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [Term a [Char]];
innermostLhss xml2name =
  xml_do "innermostLhss"
    (xml_take_many_sub [] zero_nat Infinity_enat (term xml2name) xml_return);

strategy ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Strategy a [Char]);
strategy xml2name =
  xml_do "strategy"
    (xml_take
      (xml_or (xml_leaf "innermost" Innermost)
        (xml_change (innermostLhss xml2name) (xml_return . Innermost_Q)))
      xml_return);

extract_special :: [Char] -> [Char] -> Maybe ([Char], [Char]);
extract_special acc [] = Nothing;
extract_special acc (x : xs) =
  (if equal_char x (Char True True False True True True False False)
    then map_option (\ s -> (s, xs)) (special_map (reverse acc))
    else extract_special (x : acc) xs);

normalize_special :: [Char] -> [Char];
normalize_special [] = [];
normalize_special (x : xs) =
  (if equal_char x (Char False True True False False True False False)
    then (case extract_special [] xs of {
           Nothing ->
             [Char False True True False False True False False] ++
               normalize_special xs;
           Just (spec, ys) -> spec ++ normalize_special ys;
         })
    else x : normalize_special xs);

parse_xmlfile ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      [Char] -> Sum_bot [Char] a;
parse_xmlfile p str =
  (case doc_of_string str of {
    Inl a -> left a;
    Inr (XMLDOC _ xml) -> parse_xml p (map_xml_text normalize_special xml);
  });

aABin :: forall a b. (Eq a) => a -> Acterm a b -> Acterm a b -> Acterm a b;
aABin f (AFun g [s, t]) u =
  (if f == g then AFun f [s, aABin f t u] else AFun f [AFun g [s, t], u]);
aABin f (AVar v) t = AFun f [AVar v, t];
aABin f (AFun v []) t = AFun f [AFun v [], t];
aABin f (AFun v [vb]) t = AFun f [AFun v [vb], t];
aABin f (AFun v (vb : vd : vf : vg)) t = AFun f [AFun v (vb : vd : vf : vg), t];
aABin f (AAC v va) t = AFun f [AAC v va, t];

actop :: forall a b. (Eq a, Eq b) => a -> Term a b -> Multiset (Term a b);
actop f (Fun g [s, t]) =
  (if f == g then plus_multiset (actop f s) (actop f t)
    else add_mset (Fun g [s, t]) zero_multiset);
actop f (Var v) = add_mset (Var v) zero_multiset;
actop f (Fun v []) = add_mset (Fun v []) zero_multiset;
actop f (Fun v [vb]) = add_mset (Fun v [vb]) zero_multiset;
actop f (Fun v (vb : vd : vf : vg)) =
  add_mset (Fun v (vb : vd : vf : vg)) zero_multiset;

aocnf ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Eq b) => Set a -> Set a -> Term a b -> Acterm a b;
aocnf f_A f_C (Fun f (s : t : u : us)) =
  AFun f
    (aocnf f_A f_C s :
      aocnf f_A f_C t : aocnf f_A f_C u : map (aocnf f_A f_C) us);
aocnf f_A f_C (Fun f [t]) = AFun f [aocnf f_A f_C t];
aocnf f_A f_C (Fun f []) = AFun f [];
aocnf f_A f_C (Fun f [s, t]) =
  let {
    a = member f f_A;
    c = member f f_C;
  } in (if a && c
         then AAC f (image_mset (aocnf f_A f_C) (actop f (Fun f [s, t])))
         else (if a then aABin f (aocnf f_A f_C s) (aocnf f_A f_C t)
                else (if c then AAC f (add_mset (aocnf f_A f_C s)
(add_mset (aocnf f_A f_C t) zero_multiset))
                       else AFun f [aocnf f_A f_C s, aocnf f_A f_C t])));
aocnf f_A f_C (Var x) = AVar x;

cstep_trg :: forall a b. Cstep_proof a b -> Term a b;
cstep_trg (Cstep_step x1 x2 x3 x4 x5 x6) = x5;

cstep_src :: forall a b. Cstep_proof a b -> Term a b;
cstep_src (Cstep_step x1 x2 x3 x4 x5 x6) = x4;

showsl_eqa ::
  forall a b. (Showl a, Showl b) => (Term a b, Term a b) -> String -> String;
showsl_eqa = showsl_rulea showsl showsl " ->* ";

showsl_conditions ::
  forall a b. (Showl a, Showl b) => [(Term a b, Term a b)] -> String -> String;
showsl_conditions = showsl_sep showsl_eqa (showsl_lit ", ");

showsl_rule ::
  forall a b. (Showl a, Showl b) => (Term a b, Term a b) -> String -> String;
showsl_rule = showsl_rulea showsl showsl " -> ";

showsl_crule ::
  forall a b c d.
    (Showl a, Showl b, Showl c,
      Showl d) => ((Term a b, Term a b), [(Term c d, Term c d)]) ->
                    String -> String;
showsl_crule cr =
  showsl_rule (fst cr) .
    (if null (snd cr) then id
      else showsl_lit " | " . showsl_conditions (snd cr));

match_rules ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] -> Maybe (b -> Term a b);
match_rules rs_1 rs_2 =
  bind (zip_option (map fst rs_2 ++ map snd rs_2)
         (map fst rs_1 ++ map snd rs_1))
    (match_list Var);

check_crule_variants ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Sum (String -> String) ();
check_crule_variants ra r =
  let {
    rs = fst ra : snd ra;
    rsa = fst r : snd r;
  } in check (not (is_none (match_rules rs rsa)) &&
               not (is_none (match_rules rsa rs)))
         (((showsl_crule ra . showsl_lit " and ") . showsl_crule r) .
           showsl_lit " are not variants of each other\n");

showsl_crules ::
  forall a b c d.
    (Showl a, Showl b, Showl c,
      Showl d) => [((Term a b, Term a b), [(Term c d, Term c d)])] ->
                    String -> String;
showsl_crules ctrs =
  showsl_list_gen showsl_crule "" "" "\n" "" ctrs . showsl_literal "\n";

showsl_ctrs ::
  forall a b c d.
    (Showl a, Showl b, Showl c,
      Showl d) => [((Term a b, Term a b), [(Term c d, Term c d)])] ->
                    String -> String;
showsl_ctrs r = showsl_lit "CTRS:\n\n" . showsl_crules r;

check_variant_in_ctrs ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Sum (String -> String) ();
check_variant_in_ctrs ra r =
  catch_errora
    (catch_errora (existsM (check_crule_variants r) ra)
      (\ x -> Inl (showsl_sep id id x)))
    (\ _ ->
      Inl (((showsl_lit "rule " . showsl_crule r) .
             showsl_lit " is not a variant of any rule in:\n") .
            showsl_ctrs ra));

check_csteps ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Term a b ->
                      Term a b ->
                        [Cstep_proof a b] -> Sum (String -> String) ();
check_csteps r s t [] =
  check (equal_term s t)
    ((((showsl_lit "empty rewrite sequence but source " . showsl_terma s) .
        showsl_lit " and target ") .
       showsl_terma t) .
      showsl_lit " differ");
check_csteps r s t [p] =
  bindb (check (equal_term (cstep_src p) s)
          ((showsl_terma (cstep_src p) .
             showsl_lit " does not match the source ") .
            showsl_terma s))
    (\ _ ->
      bindb (check (equal_term (cstep_trg p) t)
              ((showsl_terma (cstep_trg p) .
                 showsl_lit " does not match the target ") .
                showsl_terma t))
        (\ _ -> check_cstep r p));
check_csteps r s t (p : v : va) =
  bindb (check (equal_term (cstep_src p) s)
          ((showsl_terma (cstep_src p) .
             showsl_lit " does not match the source ") .
            showsl_terma s))
    (\ _ ->
      bindb (check_cstep r p) (\ _ -> check_csteps r (cstep_trg p) t (v : va)));

check_cstep ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Cstep_proof a b -> Sum (String -> String) ();
check_cstep ra (Cstep_step ((l, r), cs) p sigma s t pss) =
  bindb (check_variant_in_ctrs ra ((l, r), cs))
    (\ _ ->
      bindb (check (equal_nat (size_list pss) (size_list cs))
              (showsl_lit
                "mismatch between number of conditions and number of rewrite sequences"))
        (\ _ ->
          bindb (check
                  (equal_term s
                    (ctxt_apply_term (ctxt_of_pos_term p s)
                      (subst_apply_term l sigma)))
                  ((showsl_terma s .
                     showsl_lit " does not contain an instance of ") .
                    showsl_terma l))
            (\ _ ->
              bindb (check
                      (equal_term t
                        (ctxt_apply_term (ctxt_of_pos_term p s)
                          (subst_apply_term r sigma)))
                      ((showsl_terma t .
                         showsl_lit " does not contain an instance of ") .
                        showsl_terma r))
                (\ _ ->
                  catch_errora
                    (forallM
                      (\ i ->
                        check_csteps ra
                          (subst_apply_term (fst (nth cs i)) sigma)
                          (subst_apply_term (snd (nth cs i)) sigma) (nth pss i))
                      (upt zero_nat (size_list cs)))
                    (\ x -> Inl (snd x))))));

map_funs_crule ::
  forall a b c.
    (a -> b) ->
      ((Term a c, Term a c), [(Term a c, Term a c)]) ->
        ((Term b c, Term b c), [(Term b c, Term b c)]);
map_funs_crule f r =
  ((map_term f (\ x -> x) (fst (fst r)), map_term f (\ x -> x) (snd (fst r))),
    map (map_funs_rule f) (snd r));

skol_crule ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Set ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                 Set b ->
                   ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                     ((Term (Sum a b) b, Term (Sum a b) b),
                       [(Term (Sum a b) b, Term (Sum a b) b)]);
skol_crule ra v r =
  (if member r ra then map_funs_crule Inl r
    else ((skol v (fst (fst r)), skol v (snd (fst r))),
           map (\ (s, t) -> (skol v s, skol v t)) (snd r)));

skol_cstep_proof ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Set ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                 Set b -> Cstep_proof a b -> Cstep_proof (Sum a b) b;
skol_cstep_proof r v (Cstep_step rho p sigma s t pss) =
  Cstep_step (skol_crule r v rho) p (skol v . sigma) (skol v s) (skol v t)
    (map (map (skol_cstep_proof r v)) pss);

map_funs_crules ::
  forall a b c.
    (a -> b) ->
      [((Term a c, Term a c), [(Term a c, Term a c)])] ->
        [((Term b c, Term b c), [(Term b c, Term b c)])];
map_funs_crules f r = map (map_funs_crule f) r;

rules2crules ::
  forall a b.
    [(Term a b, Term a b)] -> [((Term a b, Term a b), [(Term a b, Term a b)])];
rules2crules rs = map (\ r -> (r, [])) rs;

skol_rules ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       [(Term (Sum a b) b, Term (Sum a b) b)];
skol_rules cs = let {
                  v = vars_trs (set cs);
                } in map (\ (l, r) -> (skol v l, skol v r)) cs;

check_context_joinablea ::
  forall a b.
    (Compare a, Eq a, Showl a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Mapping_impl b, Set_impl b,
      Showl b) => Context_joinable_proof a b ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Term a b ->
                        Term a b ->
                          [(Term a b, Term a b)] -> Sum (String -> String) ();
check_context_joinablea (Contextual_Join u ps qs) r s t cs =
  catch_errora
    (let {
       c = skol_rules cs;
       v = vars_trs (set cs);
       sa = skol v s;
       ta = skol v t;
       ua = skol v u;
       psa = map (skol_cstep_proof (set r) v) ps;
       qsa = map (skol_cstep_proof (set r) v) qs;
       ra = map_funs_crules Inl r ++ rules2crules c;
     } in bindb (check_csteps ra sa ua psa) (\ _ -> check_csteps ra ta ua qsa))
    (\ x ->
      Inl ((((showsl_terma s . showsl_lit " and ") . showsl_terma t) .
             showsl_lit " are not context-joinable\n") .
            x));

check_context_joinable ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Mapping_impl b, Infinite b,
      Set_impl b,
      Showl b) => [(Term a b,
                     (Term a b,
                       ([(Term a b, Term a b)],
                         Context_joinable_proof a b)))] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Term a b ->
                        Term a b ->
                          [(Term a b, Term a b)] -> Sum (String -> String) ();
check_context_joinable cj r s t cs =
  catch_errora
    (existsM
      (\ (sa, (ta, (csa, p))) ->
        bindb (check
                (not (is_none (match_rules ((s, t) : cs) ((sa, ta) : csa)))) id)
          (\ _ ->
            bindb (check
                    (not (is_none (match_rules ((sa, ta) : csa) ((s, t) : cs))))
                    id)
              (\ _ -> check_context_joinablea p r sa ta csa)))
      cj)
    (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));

showsl_pos :: [Nat] -> String -> String;
showsl_pos = showsl_list_gen (\ i -> showsl_nat (suc i)) "empty" "" "." "";

showsl_coverlap ::
  forall a b c d e f g h.
    (Showl a, Showl b, Showl c, Showl d, Showl e, Showl f, Showl g,
      Showl h) => ((Term a b, Term a b), [(Term c d, Term c d)]) ->
                    ((Term e f, Term e f), [(Term g h, Term g h)]) ->
                      [Nat] -> String -> String;
showsl_coverlap rho_1 rho_2 p =
  ((((showsl_lit "overlap of conditional rules " . showsl_crule rho_1) .
      showsl_lit " and ") .
     showsl_crule rho_2) .
    showsl_lit " at position ") .
    showsl_pos p;

mgu_var_disjoint_generic ::
  forall a b c d.
    (Eq b,
      Eq d) => (a -> b) ->
                 (c -> b) ->
                   Term d a -> Term d c -> Maybe (a -> Term d b, c -> Term d b);
mgu_var_disjoint_generic vu wu s t =
  (case mgu (map_term (\ x -> x) vu s) (map_term (\ x -> x) wu t) of {
    Nothing -> Nothing;
    Just gamma -> Just (gamma . vu, gamma . wu);
  });

check_overlap ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Infinite a, Showl a, Eq b,
      Showl b) => (a -> a) ->
                    (a -> a) ->
                      ([((Term b a, Term b a), [(Term b a, Term b a)])] ->
                        Term b a ->
                          Term b a ->
                            [(Term b a, Term b a)] ->
                              Sum (String -> String) ()) ->
                        ([((Term b a, Term b a), [(Term b a, Term b a)])] ->
                          [(Term b a, Term b a)] ->
                            Sum (String -> String) ()) ->
                          ([((Term b a, Term b a), [(Term b a, Term b a)])] ->
                            Term b a ->
                              (a -> Term b a) ->
                                [(Term b a, Term b a)] ->
                                  Sum (String -> String) ()) ->
                            [((Term b a, Term b a), [(Term b a, Term b a)])] ->
                              ((Term b a, Term b a), [(Term b a, Term b a)]) ->
                                ((Term b a, Term b a),
                                  [(Term b a, Term b a)]) ->
                                  [Nat] -> Sum (String -> String) ();
check_overlap xvar yvar check_context_joinable check_infeasible check_unfeasible
  r rho_1 rho_2 p =
  catch_errora
    (case mgu_var_disjoint_generic xvar yvar (subt_at (fst (fst rho_1)) p)
            (fst (fst rho_2))
      of {
      Nothing -> Inr ();
      Just (sigma_1, sigma_2) ->
        let {
          cs = subst_list sigma_1 (snd rho_1) ++ subst_list sigma_2 (snd rho_2);
          s = subst_apply_term (snd (fst rho_1)) sigma_1;
          t = ctxt_apply_term
                (ctxt_of_pos_term p
                  (subst_apply_term (fst (fst rho_1)) sigma_1))
                (subst_apply_term (snd (fst rho_2)) sigma_2);
        } in catch_errora
               (choice
                 [catch_errora
                    (bindb (check (null p) id)
                      (\ _ -> check_crule_variants rho_1 rho_2))
                    (\ x -> Inl (showsl_lit "the overlap is critical\n" . x)),
                   catch_errora (check_context_joinable r s t cs)
                     (\ x ->
                       Inl (showsl_lit
                              "could not be shown to be context-joinable\n" .
                             x)),
                   catch_errora (check_infeasible r cs)
                     (\ x ->
                       Inl (showsl_lit "could not be shown to be infeasible\n" .
                             x)),
                   catch_errora
                     (check_unfeasible r (fst (fst rho_1)) sigma_1 cs)
                     (\ x ->
                       Inl (showsl_lit "could not be shown to be unfeasible\n" .
                             x))])
               (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));
    })
    (\ x -> Inl ((showsl_coverlap rho_1 rho_2 p . showsl_lit ":\n\n") . x));

rule2 ::
  forall a b.
    Unfeasible_proof a b -> ((Term a b, Term a b), [(Term a b, Term a b)]);
rule2 (UnfeasibleOverlap x1 x2 x3 x4 x5 x6 x7) = x7;

rule1 ::
  forall a b.
    Unfeasible_proof a b -> ((Term a b, Term a b), [(Term a b, Term a b)]);
rule1 (UnfeasibleOverlap x1 x2 x3 x4 x5 x6 x7) = x6;

check_airr ::
  forall a.
    (Eq a,
      Showl a) => [((Term a [Char], Term a [Char]),
                     [(Term a [Char], Term a [Char])])] ->
                    Term a [Char] -> Sum (String -> String) ();
check_airr r t =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ p ->
                check (is_none
                        (mgu_var_disjoint_generic
                          (\ a ->
                            Char False False False True True True True False :
                              a)
                          (\ a ->
                            Char True False False True True True True False : a)
                          (subt_at t p) (fst (fst cr))))
                  (((((showsl_lit "the term " . showsl_terma t) .
                       showsl_lit
                         " is unifiable with the left-hand side of rule ") .
                      showsl_crule cr) .
                     showsl_lit " at position ") .
                    showsl_pos p))
              (funposs_list t))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (((showsl_lit "the term " . showsl_terma t) .
             showsl_lit " is not absolutely irreducible") .
            x));

check_unfeasiblea ::
  forall a.
    (Compare a, Eq a,
      Showl a) => Unfeasible_proof a [Char] ->
                    [((Term a [Char], Term a [Char]),
                       [(Term a [Char], Term a [Char])])] ->
                      Term a [Char] ->
                        ([Char] -> Term a [Char]) ->
                          [(Term a [Char], Term a [Char])] ->
                            Sum (String -> String) ();
check_unfeasiblea (UnfeasibleOverlap t u v ps qs rho_1 rho_2) r l mu cs =
  catch_errora
    (let {
       c = skol_rules cs;
       va = vars_trs (set cs);
       ta = skol va t;
       ua = skol va u;
       vb = skol va v;
       psa = map (skol_cstep_proof (set r) va) ps;
       qsa = map (skol_cstep_proof (set r) va) qs;
       ra = map_funs_crules Inl r ++ rules2crules c;
     } in bindb (check (equal_term l (fst (fst rho_1))) id)
            (\ _ ->
              bindb (check
                      (all (\ (a, b) ->
                             (case a of {
                               (la, _) -> (\ _ -> not (is_Var la));
                             })
                               b)
                        r)
                      (showsl_lit "variable left-hand side"))
                (\ _ ->
                  bindb (check_variant_in_ctrs r rho_1)
                    (\ _ ->
                      bindb (check_variant_in_ctrs r rho_2)
                        (\ _ ->
                          bindb (check
                                  (equal_term (subst_apply_term l mu)
                                     (subst_apply_term (fst (fst rho_2)) mu) ||
                                    supt_impl (subst_apply_term l mu)
                                      (subst_apply_term (fst (fst rho_2)) mu))
                                  id)
                            (\ _ ->
                              bindb (check (member t (image fst (set cs))) id)
                                (\ _ ->
                                  bindb (check
  (cs == subst_list mu (snd rho_1 ++ snd rho_2)) id)
                                    (\ _ ->
                                      bindb (check_csteps ra ta ua psa)
(\ _ ->
  bindb (check_csteps ra ta vb qsa)
    (\ _ ->
      bindb (check_airr r u)
        (\ _ ->
          bindb (check_airr r v)
            (\ _ ->
              check (is_none (mgu u v))
                (((showsl_terma u . showsl_lit " and ") . showsl_terma v) .
                  showsl_lit " are unifiable")))))))))))))
    (\ x ->
      Inl (((showsl_lit "conditions " . showsl_conditions cs) .
             showsl_lit " are not unfeasible\n") .
            x));

check_unfeasible ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => [([Char] -> Term a [Char], Unfeasible_proof a [Char])] ->
                    [((Term a [Char], Term a [Char]),
                       [(Term a [Char], Term a [Char])])] ->
                      Term a [Char] ->
                        ([Char] -> Term a [Char]) ->
                          [(Term a [Char], Term a [Char])] ->
                            Sum (String -> String) ();
check_unfeasible css r l mu cs =
  catch_errora
    (existsM
      (\ (mua, uo) ->
        let {
          cs_1 = snd (rule1 uo);
          cs_2 = snd (rule2 uo);
          csa = subst_list mua (cs_1 ++ cs_2);
          la = fst (fst (rule1 uo));
        } in bindb (check (equal_nat (size_list csa) (size_list cs))
                     (showsl_lit "lengths differ"))
               (\ _ ->
                 bindb (check
                         (not (is_none
                                (match_rules
                                  ((subst_apply_term l mu,
                                     subst_apply_term l mu) :
                                    cs)
                                  ((subst_apply_term la mua,
                                     subst_apply_term la mua) :
                                    csa))) &&
                           not (is_none
                                 (match_rules
                                   ((subst_apply_term la mua,
                                      subst_apply_term la mua) :
                                     csa)
                                   ((subst_apply_term l mu,
                                      subst_apply_term l mu) :
                                     cs))))
                         id)
                   (\ _ -> check_unfeasiblea uo r la mua csa)))
      css)
    (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));

ta_rules_implb :: forall a b. Tree_automaton a b -> [Ta_rule a b];
ta_rules_implb (Tree_Automaton x1 x2 x3) = x2;

check_subseteq :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_subseteq xs ys =
  catch_errora (forallM (\ x -> (if membera ys x then Inr () else Inl x)) xs)
    (\ x -> Inl (snd x));

check_rules_subseteq ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => [Ta_rule a b] ->
                    Tree_automaton a b -> Sum (String -> String) ();
check_rules_subseteq rs a =
  catch_errora (check_subseteq rs (ta_rules_implb a))
    (\ x ->
      Inl ((showsl_lit "rule " . showsl_ta_rule x) . showsl_lit " is missing"));

ta_rules :: forall a b c. Ta_ext a b c -> Set (Ta_rule a b);
ta_rules (Ta_ext ta_final ta_rules ta_eps more) = ta_rules;

ta_final :: forall a b c. Ta_ext a b c -> Set a;
ta_final (Ta_ext ta_final ta_rules ta_eps more) = ta_final;

ta_syms ::
  forall a b.
    (Ccompare a, Eq a, Ceq b, Ccompare b, Eq b,
      Set_impl b) => Ta_ext a b () -> Set (b, Nat);
ta_syms ta = image r_sym (ta_rules ta);

ta_inter_eps_empty ::
  forall a b c d.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ceq b, Ccompare b, Eq b, Set_impl b,
      Ceq c, Ccompare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Ta_ext c b d -> Ta_ext (a, c) b ();
ta_inter_eps_empty ta t =
  Ta_ext (productc (ta_final ta) (ta_final t))
    (image (\ (TA_rule f ps p, TA_rule _ qs q) -> TA_rule f (zip ps qs) (p, q))
      (sup_seta
        (image
          (\ f ->
            productc (filtera (\ r -> r_sym r == f) (ta_rules ta))
              (filtera (\ r -> r_sym r == f) (ta_rules t)))
          (ta_syms ta))))
    bot_set ();

add_rule_states :: forall a b. (Eq a) => [Ta_rule a b] -> [a] -> [a];
add_rule_states rs ss =
  fold (\ r ssa -> (case r of {
                     TA_rule _ qs q -> insertb q (fold insertb qs ssa);
                   }))
    rs ss;

sig_rules ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Ccompare b,
      Eq b) => Set (a, Nat) -> b -> Set (Ta_rule b a);
sig_rules f c = image (\ (fa, n) -> TA_rule fa (replicate n c) c) f;

star :: forall a b. a -> Term a b -> Term a b;
star c (Var x) = Fun c [];
star c (Fun f ts) = Fun f (map (star c) ts);

ground_instances_rules ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Set (a, Nat) -> a -> Term a b -> Set (Ta_rule (Term a b) a);
ground_instances_rules f c (Var x) = sig_rules f (Fun c []);
ground_instances_rules fa c (Fun f ts) =
  sup_set
    (inserta (TA_rule f (map (star c) ts) (star c (Fun f ts)))
      (set_empty (of_phantom set_impl_ta_rule)))
    (sup_seta (image (ground_instances_rules fa c) (set ts)));

ground_instances_ta ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Set (a, Nat) -> a -> Term a b -> Ta_ext (Term a b) a ();
ground_instances_ta f c t =
  Ta_ext (inserta (star c t) (set_empty (of_phantom set_impl_term)))
    (ground_instances_rules f c t)
    (set_empty
      (of_phantom (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla)))
    ();

sig_rules_list :: forall a b. [(a, Nat)] -> b -> [Ta_rule b a];
sig_rules_list f c = map (\ (fa, n) -> TA_rule fa (replicate n c) c) f;

gi_rules_list ::
  forall a b. [(a, Nat)] -> a -> Term a b -> [Ta_rule (Term a b) a];
gi_rules_list f c (Var x) = sig_rules_list f (Fun c []);
gi_rules_list fa c (Fun f ts) =
  TA_rule f (map (star c) ts) (star c (Fun f ts)) :
    concatMap (gi_rules_list fa c) ts;

growing_rule ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Bool;
growing_rule (l, r) =
  ball (vars_term r)
    (\ x ->
      ball (varposs l)
        (\ p ->
          (if equal_term (Var x) (subt_at l p)
            then less_eq_nat (size_list p) one_nat else True)));

growing ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => Set (Term a b, Term a b) -> Bool;
growing r = ball r growing_rule;

check_growing ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] -> Sum (String -> String) ();
check_growing r = check (growing (set r)) (showsl_lit "TRS is not growing");

combs :: forall a b. [a] -> [b] -> [[(a, b)]];
combs [] ys = [[]];
combs (x : xs) ys = concatMap (\ l -> map (\ y -> (x, y) : l) ys) (combs xs ys);

state_substs :: forall a b. [a] -> [b] -> [[(a, b)]];
state_substs v q = combs v q;

lhss_impl :: forall a b. (Eq a) => [(a, b)] -> [a];
lhss_impl r = remdups (map fst r);

mp_ta_rules ::
  forall a b c.
    (Eq a,
      Eq b) => [(Term a b, c)] -> [(a, Nat)] -> a -> [Ta_rule (Term a b) a];
mp_ta_rules r f c = concatMap (gi_rules_list f c) (lhss_impl r);

r_lhs_states :: forall a b. Ta_rule a b -> [a];
r_lhs_states (TA_rule x1 x2 x3) = x2;

r_root :: forall a b. Ta_rule a b -> b;
r_root (TA_rule x1 x2 x3) = x1;

r_rhs :: forall a b. Ta_rule a b -> a;
r_rhs (TA_rule x1 x2 x3) = x3;

all_interval_nat :: (Nat -> Bool) -> Nat -> Nat -> Bool;
all_interval_nat p i j = less_eq_nat j i || p i && all_interval_nat p (suc i) j;

reachable_states ::
  forall a b c.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Set (Ta_rule a b) -> Term (Sum b a) c -> Set a;
reachable_states delta (Fun (Inr q) []) = inserta q bot_set;
reachable_states delta (Fun (Inl f) ts) =
  image r_rhs
    (filtera
      (\ r ->
        r_root r == f &&
          equal_nat (size_list (r_lhs_states r)) (size_list ts) &&
            all_interval_nat
              (\ i ->
                member (nth (r_lhs_states r) i)
                  (reachable_states delta (nth ts i)))
              zero_nat (size_list ts))
      delta);
reachable_states delta (Var v) = bot_set;
reachable_states delta (Fun (Inr va) (vb : vc)) = bot_set;

qi :: forall a b.
        (Eq b) => a -> Term a b -> (b -> Term a b) -> Term a b -> Term a b;
qi c t g (Var x) = (if contains_var_term x t then g x else star c (Var x));
qi c t g (Fun f ts) = star c (Fun f ts);

inf_step ::
  forall a b.
    (Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => a -> [(Term a b, Term a b)] ->
                      [[(b, Term a b)]] ->
                        Set (Ta_rule (Term a b) a) ->
                          Set (Ta_rule (Term a b) a);
inf_step c r s delta =
  foldr (sup_set .
          (\ (a, b) ->
            (case a of {
              (l, ra) ->
                (\ theta ->
                  (case l of {
                    Fun f ls ->
                      image (TA_rule f (map (qi c ra (fun_of theta)) ls))
                        ((reachable_states ::
                           Set (Ta_rule (Term a b) a) ->
                             Term (Sum a (Term a b)) b -> Set (Term a b))
                          delta
                          (subst_apply_term (map_term Inl (\ x -> x) ra)
                            ((\ fa -> Fun (Inr fa) []) . fun_of theta)));
                  }));
            })
              b))
    (product r s) (set_empty (of_phantom set_impl_ta_rule));

funas_ta_rule ::
  forall a b. (Ceq b, Ccompare b, Set_impl b) => Ta_rule a b -> Set (b, Nat);
funas_ta_rule r = inserta (r_root r, size_list (r_lhs_states r)) bot_set;

funas_ta ::
  forall a b.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b,
      Set_impl b) => Ta_ext a b () -> Set (b, Nat);
funas_ta a = sup_seta (image funas_ta_rule (ta_rules a));

check_varcond_no_Var_lhs ::
  forall a b.
    (Showl a, Showl b) => [(Term a b, Term a b)] -> Sum (String -> String) ();
check_varcond_no_Var_lhs =
  (\ xs ->
    catch_errora
      (forallM
        (\ rule ->
          check (not (is_Var (fst rule)))
            ((showsl_literal "variable left-hand side in rule " .
               showsl_rule rule) .
              showsl_literal "\n"))
        xs)
      (\ x -> Inl (snd x)));

ta_of_ta ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Tree_automaton a b -> Ta_ext a b ();
ta_of_ta (Tree_Automaton fin rules eps) =
  Ta_ext (set fin) (set rules) (set eps) ();

insert_funas_term :: forall a b. (Eq a) => Term a b -> [(a, Nat)] -> [(a, Nat)];
insert_funas_term (Var x) fs = fs;
insert_funas_term (Fun f ts) fs =
  insertb (f, size_list ts) (foldr insert_funas_term ts fs);

insert_funas_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_funas_rule r fs =
  insert_funas_term (fst r) (insert_funas_term (snd r) fs);

insert_funas_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_funas_trs trs = foldr insert_funas_rule trs;

linear_term_impl ::
  forall a b. (Ceq a, Ccompare a) => Set a -> Term b a -> Maybe (Set a);
linear_term_impl xs (Var x) =
  (if member x xs then Nothing else Just (inserta x xs));
linear_term_impl xs (Fun uu []) = Just xs;
linear_term_impl xs (Fun f (t : ts)) =
  (case linear_term_impl xs t of {
    Nothing -> Nothing;
    Just ys -> linear_term_impl ys (Fun f ts);
  });

linear_term :: forall a b. (Ceq b, Ccompare b, Set_impl b) => Term a b -> Bool;
linear_term t = not (is_none (linear_term_impl bot_set t));

check_linear_trs ::
  forall a b.
    (Showl a, Ceq b, Ccompare b, Set_impl b,
      Showl b) => [(Term a b, Term a b)] -> Sum (String -> String) ();
check_linear_trs r =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if (case x of {
                (l, ra) -> linear_term l && linear_term ra;
              })
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ _ -> Inl (showsl_trs r . showsl_literal "\nis not linear\n"));

ta_eps :: forall a b c. Ta_ext a b c -> Set (a, a);
ta_eps (Ta_ext ta_final ta_rules ta_eps more) = ta_eps;

reduced_TA ::
  forall a b c.
    (Ccompare a, Eq a, Ceq b, Ccompare b, Eq b,
      Set_impl b) => a -> Ta_ext b a c -> Set b -> Ta_ext b a ();
reduced_TA f ta q =
  Ta_ext bot_set
    (sup_set
      (image
        (\ (TA_rule fa qs a) ->
          TA_rule fa (filter (\ qa -> not (member qa q)) qs) a)
        (filtera (\ r -> not (member (r_rhs r) q)) (ta_rules ta)))
      (image (\ p -> TA_rule f [] (snd p))
        (filtera (\ p -> member (fst p) q && not (member (snd p) q))
          (ta_eps ta))))
    (filtera (\ p -> not (member (fst p) q) && not (member (snd p) q))
      (ta_eps ta))
    ();

new_reach ::
  forall a b c.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b c -> Set a;
new_reach ta =
  image r_rhs (filtera (\ r -> null (r_lhs_states r)) (ta_rules ta));

ta_reachable ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Default b,
      Eq b) => Ta_ext a b () -> Set a;
ta_reachable ta =
  let {
    q = new_reach ta;
  } in (if less_eq_set q bot_set then bot_set
         else sup_set q (ta_reachable (reduced_TA defaulta ta q)));

ta_empty ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Default b,
      Eq b) => Ta_ext a b () -> Bool;
ta_empty ta = less_eq_set (inf_set (ta_reachable ta) (ta_final ta)) bot_set;

check_etac_nonreachable ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Default a,
      Eq a, Set_impl a, Showl a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showl b) => [(a, Nat)] ->
                    a -> a -> Tree_automaton (Term a b) a ->
                                [(Term a b, Term a b)] ->
                                  Term a b ->
                                    Term a b -> Sum (String -> String) ();
check_etac_nonreachable f aa c a r s t =
  let {
    fa = set f;
  } in bindb (check (member (aa, zero_nat) fa)
               ((showsl_lit "constant " . showsl aa) .
                 showsl_lit " is not in signature"))
         (\ _ ->
           bindb (check (not (member (c, zero_nat) fa))
                   (showsl_lit "star-symbol is not fresh w.r.t. signature"))
             (\ _ ->
               bindb (catch_errora (check_subseteq (insert_funas_term s []) f)
                       (\ _ -> Inl (showsl_lit "lhs violates signature")))
                 (\ _ ->
                   bindb (catch_errora
                           (check_subseteq (insert_funas_term t []) f)
                           (\ _ -> Inl (showsl_lit "rhs violates signature")))
                     (\ _ ->
                       let {
                         fs = insert_funas_trs r [];
                       } in bindb (catch_errora (check_subseteq fs f)
                                    (\ _ ->
                                      Inl
(showsl_lit "TRS violates signature")))
                              (\ _ ->
                                bindb (check_varcond_no_Var_lhs r)
                                  (\ _ ->
                                    bindb (check_linear_trs r)
                                      (\ _ ->
bindb (check_growing r)
  (\ _ ->
    let {
      aaa = ta_of_ta a;
    } in bindb (check
                 (set_eq (ta_eps aaa)
                   (set_empty
                     (of_phantom
                       (set_impl_prod ::
                         Phantom (Term a b, Term a b) Set_impla))))
                 (showsl_lit "no epsilon transitions allowed"))
           (\ _ ->
             bindb (check (member (star c t) (ta_final aaa))
                     ((showsl_lit "final state for " . showsl_terma t) .
                       showsl_lit " is missing"))
               (\ _ ->
                 bindb (check (less_eq_set (funas_ta aaa) fa)
                         (showsl_lit
                           "the given automaton does not respect the signature"))
                   (\ _ ->
                     let {
                       ts = gi_rules_list f c t;
                       ms = mp_ta_rules r f c;
                     } in bindb (check_rules_subseteq ts a)
                            (\ _ ->
                              bindb (check_rules_subseteq ms a)
                                (\ _ ->
                                  let {
                                    q = add_rule_states ts
  (add_rule_states ms []);
                                    ss = state_substs
   (remdups (concatMap (vars_term_list . snd) r)) q;
                                    d = set (ta_rules_implb a);
                                    da = inf_step c r ss d;
                                  } in bindb
 (check (less_eq_set da d)
   (showsl_lit "the given tree automaton is not closed under completion rules"))
 (\ _ ->
   check (ta_empty (ta_inter_eps_empty aaa (ground_instances_ta fa c s)))
     (showsl_lit
       "the given tree automaton does not certify non-reachability")))))))))))))));

check_variants_rule ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b, Term a b) ->
                    (Term a b, Term a b) -> Sum (String -> String) ();
check_variants_rule ra r =
  check (not (is_none (match_rules [ra] [r])) &&
          not (is_none (match_rules [r] [ra])))
    (((showsl_rule ra . showsl_literal " and ") . showsl_rule r) .
      showsl_literal " are not variants of each other\n");

find_variant_in_trs ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b, Term a b) ->
                    [(Term a b, Term a b)] ->
                      Sum (String -> String) (Term a b, Term a b);
find_variant_in_trs ra r =
  catch_errora (firstM (check_variants_rule ra) r)
    (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));

check_rstep_p ::
  forall a b c.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b -> Term a b -> Sum (String -> String) c) ->
                           (Term a b, Term a b) ->
                             [Nat] ->
                               Term a b -> Term a b -> Sum (String -> String) c;
check_rstep_p c rho p s t =
  (if not (membera (poss_list t) p)
    then Inl (showsl_literal "no step possible at this position")
    else (case rho of {
           (l, r) ->
             (case match_list Var [(l, subt_at s p), (r, subt_at t p)] of {
               Nothing -> Inl (showsl_literal "rule does not match");
               Just sigma ->
                 (if equal_term t
                       (ctxt_apply_term (ctxt_of_pos_term p s)
                         (subst_apply_term r sigma))
                   then c (subst_apply_term l sigma) (subst_apply_term r sigma)
                   else Inl (showsl_literal "result does not match"));
             });
         }));

check_step_rule ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Term a b -> Sum (String -> String) ()) ->
                    (Term a b, Term a b) ->
                      Term a b -> Term a b -> Sum (String -> String) ();
check_step_rule c rho s t =
  catch_errora (existsM (\ p -> check_rstep_p c rho p s t) (poss_list s))
    (\ _ ->
      Inl (((showsl_lit " is not a reduct with respect to " .
              showsl_terma (fst rho)) .
             showsl_lit " -> ") .
            showsl_terma (snd rho)));

check_step ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Term a b -> Sum (String -> String) ()) ->
                    [(Term a b, Term a b)] ->
                      Term a b -> Term a b -> Sum (String -> String) ();
check_step c (ea : e) s t =
  catch_errora (choice [check_step_rule c ea s t, check_step c e s t])
    (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));
check_step c [] s t =
  Inl ((((showsl_lit "no step from " . showsl_terma s) . showsl_lit " to ") .
         showsl_terma t) .
        showsl_lit " found\n");

sym_list :: forall a. (Eq a) => [(a, a)] -> [(a, a)];
sym_list xs = union xs (map (\ (x, y) -> (y, x)) xs);

check_stepa ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Term a b -> Sum (String -> String) ()) ->
                    ([(Term a b, Term a b)], [(Term a b, Term a b)]) ->
                      Oc_irule a b ->
                        Sum (String -> String)
                          ([(Term a b, Term a b)], [(Term a b, Term a b)]);
check_stepa check_ord (e, r) (OC_Collapse s t u) =
  catch_errora
    (bindb (find_variant_in_trs (t, s) r)
      (\ ts ->
        let {
          ra = removeAll ts r;
        } in bindb (catch_errora (check_step check_ord (ra ++ sym_list e) t u)
                     (\ x ->
                       Inl (((((showsl_lit " no ordstep from " .
                                 showsl_terma t) .
                                showsl_lit " to ") .
                               showsl_terma u) .
                              showsl_literal "\n") .
                             x)))
               (\ _ -> Inr ((u, s) : e, ra))))
    (\ x ->
      Inl (((((((((showsl_lit "error in collapse step from " . showsl_terma s) .
                   showsl_lit " -> ") .
                  showsl_terma t) .
                 showsl_lit " to ") .
                showsl_terma u) .
               showsl_lit " = ") .
              showsl_terma t) .
             showsl_literal "\n") .
            x));
check_stepa check_ord (e, r) (OC_Simplifyr s t u) =
  catch_errora
    (bindb (find_variant_in_trs (s, t) e)
      (\ st ->
        let {
          ea = removeAll st e;
        } in bindb (catch_errora (check_step check_ord (r ++ sym_list ea) t u)
                     (\ x ->
                       Inl (((((showsl_lit " no ordstep from " .
                                 showsl_terma t) .
                                showsl_lit " to ") .
                               showsl_terma u) .
                              showsl_literal "\n") .
                             x)))
               (\ _ -> Inr ((s, u) : ea, r))))
    (\ x ->
      Inl (((((((((showsl_lit "error in simplifyr step from " .
                    showsl_terma s) .
                   showsl_lit " = ") .
                  showsl_terma t) .
                 showsl_lit " to ") .
                showsl_terma s) .
               showsl_lit " = ") .
              showsl_terma u) .
             showsl_literal "\n") .
            x));
check_stepa check_ord (e, r) (OC_Simplifyl s t u) =
  catch_errora
    (bindb (find_variant_in_trs (s, t) e)
      (\ st ->
        let {
          ea = removeAll st e;
        } in bindb (catch_errora (check_step check_ord (r ++ sym_list ea) s u)
                     (\ x ->
                       Inl (((((showsl_lit " no ordstep from " .
                                 showsl_terma s) .
                                showsl_lit " to ") .
                               showsl_terma u) .
                              showsl_literal "\n") .
                             x)))
               (\ _ -> Inr ((u, t) : ea, r))))
    (\ x ->
      Inl (((((((((showsl_lit "error in simplifyl step from " .
                    showsl_terma s) .
                   showsl_lit " = ") .
                  showsl_terma t) .
                 showsl_lit " to ") .
                showsl_terma u) .
               showsl_lit " = ") .
              showsl_terma t) .
             showsl_literal "\n") .
            x));
check_stepa check_ord (e, r) (OC_Compose s t u) =
  catch_errora
    (bindb (find_variant_in_trs (s, t) r)
      (\ st ->
        let {
          ra = removeAll st r;
        } in bindb (catch_errora (check_step check_ord (ra ++ sym_list e) t u)
                     (\ x ->
                       Inl (((((showsl_lit " no ordstep from " .
                                 showsl_terma t) .
                                showsl_lit " to ") .
                               showsl_terma u) .
                              showsl_literal "\n") .
                             x)))
               (\ _ -> Inr (e, (s, u) : ra))))
    (\ x ->
      Inl (((((((((showsl_lit "error in compose step from " . showsl_terma s) .
                   showsl_lit " -> ") .
                  showsl_terma t) .
                 showsl_lit " to ") .
                showsl_terma s) .
               showsl_lit " -> ") .
              showsl_terma u) .
             showsl_literal "\n") .
            x));
check_stepa check_ord (e, r) (OC_Delete s) =
  catch_errora
    (bindb (find_variant_in_trs (s, s) e) (\ ss -> Inr (removeAll ss e, r)))
    (\ x ->
      Inl (((((showsl_lit "error in delete step for " . showsl_terma s) .
               showsl_lit " = ") .
              showsl_terma s) .
             showsl_literal "\n") .
            x));
check_stepa check_ord (e, r) (OC_Orientr s t) =
  catch_errora
    (bindb (check_ord t s)
      (\ _ ->
        bindb (find_variant_in_trs (s, t) e)
          (\ st -> Inr (removeAll st e, (t, s) : r))))
    (\ x ->
      Inl (((((showsl_lit "error in orientr step for " . showsl_terma s) .
               showsl_lit " -> ") .
              showsl_terma t) .
             showsl_literal "\n") .
            x));
check_stepa check_ord (e, r) (OC_Orientl s t) =
  catch_errora
    (bindb (check_ord s t)
      (\ _ ->
        bindb (find_variant_in_trs (s, t) e)
          (\ st -> Inr (removeAll st e, (s, t) : r))))
    (\ x ->
      Inl (((((showsl_lit "error in orientl step for " . showsl_terma s) .
               showsl_lit " -> ") .
              showsl_terma t) .
             showsl_literal "\n") .
            x));
check_stepa check_ord (e, r) (OC_Deduce s t u) =
  catch_errora
    (let {
       sa = r ++ sym_list e;
     } in bindb (catch_errora (check_step (\ _ _ -> Inr ()) sa s t)
                  (\ x ->
                    Inl (((((showsl_lit " no step from " . showsl_terma s) .
                             showsl_lit " to ") .
                            showsl_terma t) .
                           showsl_literal "\n") .
                          x)))
            (\ _ ->
              bindb (catch_errora (check_step (\ _ _ -> Inr ()) sa s u)
                      (\ x ->
                        Inl (((((showsl_lit " no step from " . showsl_terma s) .
                                 showsl_lit " to ") .
                                showsl_terma u) .
                               showsl_literal "\n") .
                              x)))
                (\ _ -> Inr ((t, u) : e, r))))
    (\ x ->
      Inl (((((((showsl_lit "error in deduce step " . showsl_terma t) .
                 showsl_lit " <- ") .
                showsl_terma s) .
               showsl_lit " -> ") .
              showsl_terma u) .
             showsl_literal "\n") .
            x));

showsl_eqs ::
  forall a b. (Showl a, Showl b) => [(Term a b, Term a b)] -> String -> String;
showsl_eqs = showsl_trsa showsl showsl "equational system:" " = ";

check_variant_in_trs ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    (Term a b, Term a b) -> Sum (String -> String) ();
check_variant_in_trs ra r =
  catch_errora
    (catch_errora (existsM (check_variants_rule r) ra)
      (\ x -> Inl (showsl_sep id id x)))
    (\ _ ->
      Inl ((showsl_rule r .
             showsl_literal " is not a variant of any rule in ") .
            showsl_trs ra));

check_variants_trs ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] -> Sum (String -> String) ();
check_variants_trs ra r =
  catch_errora (forallM (check_variant_in_trs r) ra) (\ x -> Inl (snd x));

check_oc ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Term a b -> Sum (String -> String) ()) ->
                    ([(Term a b, Term a b)], [(Term a b, Term a b)]) ->
                      ([(Term a b, Term a b)], [(Term a b, Term a b)]) ->
                        [Oc_irule a b] -> Sum (String -> String) ();
check_oc check_ord (ea, ra) (e, r) (x : xs) =
  bindb (check_stepa check_ord (ea, ra) x)
    (\ (eaa, raa) -> check_oc check_ord (eaa, raa) (e, r) xs);
check_oc check_ord (ea, ra) (e, r) [] =
  let {
    err = (\ f x y -> (f x . showsl_lit "\nis not a variant of\n") . f y);
  } in bindb (catch_errora (check_variants_trs ea e)
               (\ _ -> Inl (err showsl_eqs ea e)))
         (\ _ ->
           bindb (catch_errora (check_variants_trs e ea)
                   (\ _ -> Inl (err showsl_eqs ea e)))
             (\ _ ->
               bindb (catch_errora (check_variants_trs ra r)
                       (\ _ -> Inl (err showsl_trs ra r)))
                 (\ _ ->
                   catch_errora (check_variants_trs r ra)
                     (\ _ -> Inl (err showsl_trs ra r)))));

ext_subst ::
  forall a b c d.
    (Showl a, Eq b) => a -> (b -> Term a c) -> Term d b -> b -> Term a c;
ext_subst least sigma l =
  (\ x ->
    (if membera (insert_vars_term l []) x then sigma x else Fun least []));

mord_rewrite ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Term a b -> Bool) ->
                    a -> [(Term a b, Term a b)] -> Term a b -> [Term a b];
mord_rewrite check_ord least r s =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ p ->
          (case match (subt_at s p) l of {
            Nothing -> [];
            Just sigma ->
              let {
                sigmaa = ext_subst least sigma l;
              } in (if check_ord (subst_apply_term l sigmaa)
                         (subst_apply_term ra sigmaa)
                     then [ctxt_apply_term (ctxt_of_pos_term p s)
                             (subst_apply_term ra sigmaa)]
                     else []);
          }))
        (poss_list s))
    r;

first_mord_rewrite ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Term a b -> Bool) ->
                    a -> [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
first_mord_rewrite check_ord least r s =
  (case mord_rewrite check_ord least r s of {
    [] -> Nothing;
    t : _ -> Just t;
  });

compute_NF :: forall a. (a -> Maybe a) -> a -> Maybe a;
compute_NF f a = (case f a of {
                   Nothing -> Just a;
                   Just aa -> compute_NF f aa;
                 });

compute_mordstep_NF ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Term a b -> Bool) ->
                    a -> [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
compute_mordstep_NF check_ord least r s =
  compute_NF (first_mord_rewrite check_ord least r) s;

check_instance_joinable ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Term a b -> Bool) ->
                    a -> [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Term a b -> Term a b -> Sum (String -> String) ();
check_instance_joinable check_ord least e r s t =
  (case (compute_mordstep_NF check_ord least (e ++ r) s,
          compute_mordstep_NF check_ord least (e ++ r) t)
    of {
    (Nothing, _) -> Inl (showsl_literal "error: check_instance_joinable");
    (Just _, Nothing) -> Inl (showsl_literal "error: check_instance_joinable");
    (Just u, Just v) ->
      catch_errora
        (choice
          [check (equal_term u v) (showsl_lit "normal forms differ"),
            check_step (\ _ _ -> Inr ()) e u v])
        (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));
  });

check_var_order_joinable ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b, Linorder b, Infinite b,
      Showl b) => a -> ([b] -> Term a b -> Term a b -> Bool) ->
                         [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Term a b ->
                               Term a b -> [b] -> Sum (String -> String) ();
check_var_order_joinable least ext_check_ord e r s t vperm =
  check_instance_joinable (ext_check_ord vperm) least e r s t;

var_tuples_of_partitioning ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Eq a, Linorder a) => [Set a] -> [(a, a)];
var_tuples_of_partitioning ps =
  concatMap (\ p -> (case sorted_list_of_set p of {
                      [] -> [];
                      x : xs -> map (\ y -> (y, x)) (x : xs);
                    }))
    (remdups ps);

var_subst_of_partitioning ::
  forall a. (Cenum a, Ceq a, Ccompare a, Eq a, Linorder a) => [Set a] -> a -> a;
var_subst_of_partitioning p =
  (\ x -> (case map_of (var_tuples_of_partitioning p) x of {
            Nothing -> x;
            Just y -> y;
          }));

subst_of_partitioning ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Linorder a) => [Set a] -> a -> Term b a;
subst_of_partitioning p = (\ x -> Var (var_subst_of_partitioning p x));

insert_into_member_list ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Eq a,
      Set_impl a) => a -> [Set a] -> Set a -> [Set a];
insert_into_member_list new_el sets s =
  sup_set s (inserta new_el bot_set) : remove1 s sets;

coarser_partitions_with_list ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a) => a -> [Set a] -> [[Set a]];
coarser_partitions_with_list new_el p =
  (inserta new_el bot_set : p) : map (insert_into_member_list new_el p) p;

all_coarser_partitions_with_list ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Eq a,
      Set_impl a) => a -> [[Set a]] -> [[Set a]];
all_coarser_partitions_with_list elem ps =
  concatMap (coarser_partitions_with_list elem) ps;

all_partitions_list ::
  forall a. (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a) => [a] -> [[Set a]];
all_partitions_list [] = [[]];
all_partitions_list (e : x) =
  all_coarser_partitions_with_list e (all_partitions_list x);

inserts :: forall a. a -> [a] -> [[a]];
inserts x [] = [[x]];
inserts x (y : ys) = (x : y : ys) : map (\ a -> y : a) (inserts x ys);

perms :: forall a. [a] -> [[a]];
perms [] = [[]];
perms (x : xs) = concatMap (inserts x) (perms xs);

insert_vars_rule :: forall a b. (Eq b) => (Term a b, Term a b) -> [b] -> [b];
insert_vars_rule r xs = insert_vars_term (fst r) (insert_vars_term (snd r) xs);

check_var_orders_joinable ::
  forall a b.
    (Eq a, Showl a, Cenum b, Ceq b, Ccompare b, Eq b, Mapping_impl b,
      Linorder b, Infinite b, Set_impl b,
      Showl b) => a -> ([b] -> Term a b -> Term a b -> Bool) ->
                         [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Term a b -> Term a b -> Sum (String -> String) ();
check_var_orders_joinable least ext_check_ord e r s t =
  let {
    xs = remdups (insert_vars_rule (s, t) []);
  } in catch_errora
         (forallM
           (\ ps ->
             let {
               sigma = subst_of_partitioning ps;
             } in (case (subst_apply_term s sigma, subst_apply_term t sigma) of
                    {
                    (sa, ta) ->
                      let {
                        orders = perms (remdups (insert_vars_rule (sa, ta) []));
                      } in catch_errora
                             (forallM
                               (check_var_order_joinable least ext_check_ord e r
                                 sa ta)
                               orders)
                             (\ x -> Inl (snd x));
                  }))
           (all_partitions_list xs))
         (\ x -> Inl (snd x));

check_rule_instance ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b, Term a b) ->
                           (Term a b, Term a b) -> Sum (String -> String) ();
check_rule_instance ra r =
  (case match_list Var [(fst r, fst ra), (snd r, snd ra)] of {
    Nothing -> Inl (showsl_lit "rules do not match");
    Just _ -> Inr ();
  });

check_instancea ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Sum (String -> String) ();
check_instancea e s t =
  catch_errora (existsM (check_rule_instance (s, t)) e)
    (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));

catch_error :: forall a b c. Sum_bot a b -> (a -> Sum_bot c b) -> Sum_bot c b;
catch_error (Sumbot a) f = (case a of {
                             Inl aa -> f aa;
                             Inr aa -> Sumbot (Inr aa);
                           });

forallM_bot :: forall a b. (a -> Sum_bot b ()) -> [a] -> Sum_bot (a, b) ();
forallM_bot f (x : xs) =
  binda (catch_error (f x) (\ e -> errora (x, e))) (\ _ -> forallM_bot f xs);
forallM_bot f [] = returna ();

existsM_bot :: forall a b. (a -> Sum_bot b ()) -> [a] -> Sum_bot [b] ();
existsM_bot f (x : xs) =
  catch_error (f x)
    (\ e -> catch_error (existsM_bot f xs) (\ ea -> errora (e : ea)));
existsM_bot f [] = errora [];

choice_bot :: forall a b. [Sum_bot a b] -> Sum_bot [a] b;
choice_bot (x : xs) =
  catch_error x (\ e -> catch_error (choice_bot xs) (\ ea -> errora (e : ea)));
choice_bot [] = errora [];

lifta :: forall a. Sum a () -> Sum_bot a ();
lifta c = (case c of {
            Inl a -> errora a;
            Inr a -> returna a;
          });

check_ground_join_rel_bot ::
  forall a b.
    (Eq a, Showl a, Cenum b, Ceq b, Ccompare b, Eq b, Mapping_impl b,
      Linorder b, Infinite b, Set_impl b,
      Showl b) => (Term a b -> Term a b -> Bool) ->
                    a -> ([b] -> Term a b -> Term a b -> Bool) ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] ->
                               Term a b ->
                                 Term a b -> Sum_bot (String -> String) ();
check_ground_join_rel_bot check_ord least ext_check_ord e r s t =
  (case (s, t) of {
    (Var x, _) ->
      catch_error
        (choice_bot
          [lifta (check (equal_term (Var x) t)
                   (showsl_lit "The terms are different.")),
            catch_error
              (existsM_bot
                (check_ground_join_rel_bot check_ord least ext_check_ord e r
                  (Var x))
                (mord_rewrite check_ord least (e ++ r) t))
              (\ _ -> errora (showsl_lit "No right-rewrite is possible."))])
        (\ ea -> errora (showsl_sep id (showsl_literal "\n") ea));
    (Fun _ _, Var x) ->
      catch_error
        (choice_bot
          [lifta (check (equal_term (Var x) s)
                   (showsl_lit "The terms are different.")),
            catch_error
              (existsM_bot
                (\ u ->
                  check_ground_join_rel_bot check_ord least ext_check_ord e r u
                    (Var x))
                (mord_rewrite check_ord least (e ++ r) s))
              (\ _ -> errora (showsl_lit "No left-rewrite is possible."))])
        (\ ea -> errora (showsl_sep id (showsl_literal "\n") ea));
    (Fun f ss, Fun g ts) ->
      catch_error
        (choice_bot
          [lifta (check (equal_term (Fun f ss) (Fun g ts))
                   (showsl_lit "terms differ")),
            lifta (check_instancea (e ++ r) (Fun f ss) (Fun g ts)),
            catch_error
              (existsM_bot
                (\ u ->
                  check_ground_join_rel_bot check_ord least ext_check_ord e r u
                    (Fun g ts))
                (mord_rewrite check_ord least (e ++ r) (Fun f ss)))
              (\ _ -> errora (showsl_literal "No left-rewrite is possible.")),
            catch_error
              (existsM_bot
                (check_ground_join_rel_bot check_ord least ext_check_ord e r
                  (Fun f ss))
                (mord_rewrite check_ord least (e ++ r) (Fun g ts)))
              (\ _ -> errora (showsl_literal "No right-rewrite is possible.")),
            (if f == g && equal_nat (size_list ss) (size_list ts)
              then catch_error
                     (forallM_bot
                       (\ (a, b) ->
                         check_ground_join_rel_bot check_ord least ext_check_ord
                           e r a b)
                       (zip ss ts))
                     (\ _ ->
                       errora
                         (showsl_literal "Arguments are not ground-joinable."))
              else errora
                     (showsl_literal "The congruence rule does not apply.")),
            lifta (check_var_orders_joinable least ext_check_ord e r (Fun f ss)
                    (Fun g ts))])
        (\ ea -> errora (showsl_sep id (showsl_literal "\n") ea));
  });

case_sum_bot :: forall a b c. a -> (b -> a) -> (c -> a) -> Sum_bot b c -> a;
case_sum_bot f g h (Sumbot p) = (case p of {
                                  Inl a -> g a;
                                  Inr a -> h a;
                                });

check_ground_join_rel ::
  forall a b.
    (Eq a, Showl a, Cenum b, Ceq b, Ccompare b, Eq b, Mapping_impl b,
      Linorder b, Infinite b, Set_impl b,
      Showl b) => (Term a b -> Term a b -> Bool) ->
                    a -> ([b] -> Term a b -> Term a b -> Bool) ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] ->
                               Term a b ->
                                 Term a b -> Sum (String -> String) ();
check_ground_join_rel check_ord least ext_check_ord e r s t =
  case_sum_bot
    (Inl (showsl_literal "Ground joinability could not be established."))
    (\ _ ->
      Inl ((((showsl_lit "The equation " . showsl_terma s) . showsl_lit " = ") .
             showsl_terma t) .
            showsl_lit " is not ground joinable\n"))
    Inr (check_ground_join_rel_bot check_ord least ext_check_ord e r s t);

check_ooverlap_gj ::
  forall a b.
    (Eq a, Showl a, Cenum b, Ceq b, Ccompare b, Eq b, Mapping_impl b,
      Linorder b, Infinite b, Set_impl b,
      Showl b) => (Term a b -> Term a b -> Bool) ->
                    a -> (b -> b) ->
                           (b -> b) ->
                             ([b] -> Term a b -> Term a b -> Bool) ->
                               [(Term a b, Term a b)] ->
                                 [(Term a b, Term a b)] ->
                                   (Term a b, Term a b) ->
                                     (Term a b, Term a b) ->
                                       [Nat] -> Sum (String -> String) ();
check_ooverlap_gj check_ord least xvar yvar ext_check_ord e r rho_1 rho_2 p =
  (case mgu_var_disjoint_generic xvar yvar (fst rho_1) (subt_at (fst rho_2) p)
    of {
    Nothing -> Inr ();
    Just (sigma_1, sigma_2) ->
      let {
        s = ctxt_apply_term
              (ctxt_of_pos_term p (subst_apply_term (fst rho_2) sigma_2))
              (subst_apply_term (snd rho_1) sigma_1);
        a = subst_apply_term (snd rho_2) sigma_2;
      } in check_ground_join_rel check_ord least ext_check_ord e r s a;
  });

check_ECPs_gj ::
  forall a b.
    (Eq a, Showl a, Cenum b, Ceq b, Ccompare b, Eq b, Mapping_impl b,
      Linorder b, Infinite b, Set_impl b,
      Showl b) => (Term a b -> Term a b -> Bool) ->
                    a -> (b -> b) ->
                           (b -> b) ->
                             ([b] -> Term a b -> Term a b -> Bool) ->
                               [(Term a b, Term a b)] ->
                                 [(Term a b, Term a b)] ->
                                   Sum (String -> String) ();
check_ECPs_gj check_ord least xvar yvar ext_check_ord e r =
  catch_errora
    (let {
       ea = sym_list e;
       s = union r ea;
     } in catch_errora
            (forallM
              (\ rho_2 ->
                let {
                  l_2 = fst rho_2;
                } in catch_errora
                       (forallM
                         (\ rho_1 ->
                           catch_errora
                             (forallM
                               (check_ooverlap_gj check_ord least xvar yvar
                                 ext_check_ord ea r rho_1 rho_2)
                               (funposs_list l_2))
                             (\ x -> Inl (snd x)))
                         s)
                       (\ x -> Inl (snd x)))
              s)
            (\ x -> Inl (snd x)))
    (\ x -> Inl (showsl_lit "Not all extended CPs are ground joinable." . x));

ext_less ::
  forall a b c. Redord_closure_ext a b c -> [b] -> Term a b -> Term a b -> Bool;
ext_less (Redord_closure_ext ext_less valid more) = ext_less;

validd :: forall a b c. Redord_closure_ext a b c -> Sum (String -> String) ();
validd (Redord_closure_ext ext_less valid more) = valid;

min_const :: forall a b c. Redord_ext a b c -> a;
min_const (Redord_ext valid less min_const more) = min_const;

valida :: forall a b c. Redord_ext a b c -> Sum (String -> String) ();
valida (Redord_ext valid less min_const more) = valid;

lessa :: forall a b c. Redord_ext a b c -> Term a b -> Term a b -> Bool;
lessa (Redord_ext valid less min_const more) = less;

check_FGCR_gj ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => Redord_ext a [Char] () ->
                    Redord_closure_ext a [Char] () ->
                      [(a, Nat)] ->
                        [(Term a [Char], Term a [Char])] ->
                          [(Term a [Char], Term a [Char])] ->
                            Sum (String -> String) ();
check_FGCR_gj ro rc f e r =
  bindb (valida ro)
    (\ _ ->
      bindb (validd rc)
        (\ _ ->
          bindb (catch_errora (check_subseteq (funas_trs_list (union e r)) f)
                  (\ x ->
                    Inl ((showsl_lit "the function symbol " . showsl_prod x) .
                          showsl_lit " does not occur in the TRS\n")))
            (\ _ ->
              check_ECPs_gj (lessa ro) (min_const ro)
                (\ a -> Char False False False True True True True False : a)
                (\ a -> Char True False False True True True True False : a)
                (ext_less rc) e r)));

check_FGCR_run_with_closure ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => Redord_ext a [Char] () ->
                    Redord_closure_ext a [Char] () ->
                      [(a, Nat)] ->
                        [(Term a [Char], Term a [Char])] ->
                          [(Term a [Char], Term a [Char])] ->
                            [(Term a [Char], Term a [Char])] ->
                              [(Term a [Char], Term a [Char])] ->
                                [Oc_irule a [Char]] ->
                                  Sum (String -> String) ();
check_FGCR_run_with_closure ro rc f e_0 r_0 e r steps =
  let {
    check_ord =
      (\ s t ->
        check (lessa ro s t) (showsl_lit "Term pair cannot be oriented."));
  } in bindb (catch_errora (forallM (\ (a, b) -> check_ord a b) r_0)
               (\ x -> Inl (snd x)))
         (\ _ ->
           bindb (catch_errora (check_oc check_ord (e_0, r_0) (e, r) steps)
                   (\ x ->
                     Inl (showsl_lit
                            "The oKB run could not be reconstructed.\n\n" .
                           x)))
             (\ _ ->
               catch_errora (check_FGCR_gj ro rc f e r)
                 (\ x ->
                   Inl (showsl_lit
                          "Ground confluence could not be verified.\n\n" .
                         x))));

order_set_of_permx ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => [a] -> Set (a, a);
order_set_of_permx [] = bot_set;
order_set_of_permx (x : xs) =
  sup_set (set (map (\ a -> (x, a)) xs)) (order_set_of_permx xs);

term_order_of_permx ::
  forall a b c.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b, Eq b, Compare c,
      Eq c) => [a] -> Set (Term b a, Term c a);
term_order_of_permx p =
  image (\ (x, y) -> (Var x, Var y)) (order_set_of_permx p);

fun_of_map_funa ::
  forall a b c. (a -> Maybe b) -> (a -> c) -> (b -> c) -> a -> c;
fun_of_map_funa m d f a = (case m a of {
                            Nothing -> d a;
                            Just aa -> f aa;
                          });

g_list_to_map_rm_basic_ops ::
  forall a b. (Compare_order a) => [(a, b)] -> Rbt a b;
g_list_to_map_rm_basic_ops l =
  foldl (\ m (k, v) -> insert k v m) empty (reverse l);

ceta_map_of :: forall a b. (Compare_order a) => [(a, b)] -> a -> Maybe b;
ceta_map_of ps = lookup (g_list_to_map_rm_basic_ops ps);

prec_weight_repr_to_prec_weight_funs ::
  forall a.
    (Compare_order a,
      Eq a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                 ((a, Nat) -> (a, Nat) -> (Bool, Bool),
                   ((a, Nat) -> Nat, (Nat, ([a], (a, Nat) -> Maybe [Nat]))));
prec_weight_repr_to_prec_weight_funs prw_w0 =
  (case prw_w0 of {
    (prw, w0) ->
      let {
        prwm = ceta_map_of prw;
        w_fun = fun_of_map_funa prwm (\ _ -> suc w0) (fst . snd);
        p_fun = prec_ext prwm;
        scf_fun = fun_of_map_funa prwm (\ _ -> Nothing) (snd . snd);
        fs = map fst prw;
        cs = filter
               (\ fn -> equal_nat (snd fn) zero_nat && equal_nat (w_fun fn) w0)
               fs;
        lcs = map_filter
                (\ x ->
                  (if all (\ c -> snd (p_fun c x)) cs then Just (fst x)
                    else Nothing))
                cs;
      } in (p_fun, (w_fun, (w0, (lcs, scf_fun))));
  });

scf_repr_to_scf ::
  forall a. ((a, Nat) -> Maybe [Nat]) -> (a, Nat) -> Nat -> Nat;
scf_repr_to_scf scf fn i = (case scf fn of {
                             Nothing -> one_nat;
                             Just xs -> nth xs i;
                           });

check_scf_entry ::
  forall a. (Showl a) => (a, Nat) -> Maybe [Nat] -> Sum (String -> String) ();
check_scf_entry fn Nothing = Inr ();
check_scf_entry (f, n) (Just es) =
  catch_errora
    (bindb
      (check (equal_nat (size_list es) n)
        (showsl_literal "nr of entries should be " . showsl_nat n))
      (\ _ ->
        check (all (less_nat zero_nat) es)
          (showsl_literal "all entries must be non-zero")))
    (\ x ->
      Inl ((((showsl_literal "problem with subterm coefficients for " .
               showsl_prod (f, n)) .
              showsl_literal ": ") .
             x) .
            showsl_literal "\n"));

prec_weight_repr_to_prec_weight ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    (Sum (String -> String) (),
                      ((a, Nat) -> (a, Nat) -> (Bool, Bool),
                        ((a, Nat) -> Nat,
                          (Nat, ([a], (a, Nat) -> Nat -> Nat)))));
prec_weight_repr_to_prec_weight prw_w0 =
  (case prec_weight_repr_to_prec_weight_funs prw_w0 of {
    (p_fun, (w_fun, (_, (lcs, scf_fun)))) ->
      (case prw_w0 of {
        (prw, w0) ->
          let {
            fs = map fst prw;
            cw_okay =
              catch_errora
                (forallM
                  (\ fn ->
                    check (if equal_nat (snd fn) zero_nat
                            then less_eq_nat w0 (w_fun fn) else True)
                      ((showsl_literal "weight of constant " .
                         showsl (fst fn)) .
                        showsl_literal " must be at least w0"))
                  (map fst prw))
                (\ x -> Inl (snd x));
            adm = catch_errora
                    (forallM
                      (\ fn ->
                        check (if equal_nat (snd fn) one_nat
                                then (if equal_nat (w_fun fn) zero_nat
                                       then all (snd . p_fun fn) fs else True)
                                else True)
                          ((showsl_literal "unary symbol " . showsl (fst fn)) .
                            showsl_literal
                              " with weight 0 does not have maximal precedence"))
                      (map fst prw))
                    (\ x -> Inl (snd x));
            scf_ok =
              catch_errora
                (forallM (\ fn -> check_scf_entry fn (scf_fun fn))
                  (map fst prw))
                (\ x -> Inl (snd x));
            ok = bindb (check (less_nat zero_nat w0)
                         (showsl_literal "w0 must be larger than 0"))
                   (\ _ -> bindb adm (\ _ -> bindb cw_okay (\ _ -> scf_ok)));
          } in (ok, (p_fun, (w_fun, (w0, (lcs, scf_repr_to_scf scf_fun)))));
      });
  });

check_same_set :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_same_set xs ys =
  bindb (check_subseteq xs ys) (\ _ -> check_subseteq ys xs);

create_KBO_redord ::
  forall a b.
    (Compare_order a, Eq a, Showl a,
      Eq b) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                 [(a, Nat)] -> Redord_ext a b ();
create_KBO_redord pr fs =
  (case prec_weight_repr_to_prec_weight pr of {
    (ch, (p, (w, (w0, (lcs, scf))))) ->
      let {
        valid =
          bindb ch
            (\ _ ->
              bindb (catch_errora (check_same_set fs (map fst (fst pr)))
                      (\ _ ->
                        Inl (showsl_literal " signature does not match ")))
                (\ _ ->
                  bindb (check (less_nat zero_nat (size_list lcs))
                          (showsl_literal
                            "there must be a minimal constant with weight w0"))
                    (\ _ ->
                      check (distinct (map (fst . snd) (fst pr)))
                        (showsl_literal
                          "the given precedence is not injective"))));
      } in Redord_ext valid
             (\ s t -> fst (kbo_impl w w0 p (membera lcs) scf s t))
             (nth lcs zero_nat) ();
  });

kbo_closure ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => ((a, Nat) -> Nat) ->
                 Nat ->
                   ((a, Nat) -> Nat -> Nat) ->
                     (a -> Bool) ->
                       ((a, Nat) -> (a, Nat) -> Bool) ->
                         ((a, Nat) -> (a, Nat) -> Bool) ->
                           Set (Term a b, Term a b) ->
                             Term a b -> Term a b -> (Bool, Bool);
kbo_closure w w0 scf least pr_strict pr_weak gt s t =
  (if member (s, t) gt then (True, True)
    else (if subseteq_mset (vars_term_ms (scf_term scf t))
               (vars_term_ms (scf_term scf s)) &&
               less_eq_nat (weight w w0 scf t) (weight w w0 scf s)
           then (if less_nat (weight w w0 scf t) (weight w w0 scf s)
                  then (True, True)
                  else (case s of {
                         Var y -> (False, (case t of {
    Var x -> x == y;
    Fun g ts -> null ts && least g;
  }));
                         Fun f ss ->
                           (case t of {
                             Var _ -> (True, True);
                             Fun g ts ->
                               (if pr_strict (f, size_list ss) (g, size_list ts)
                                 then (True, True)
                                 else (if pr_weak (f, size_list ss)
    (g, size_list ts)
then lex_ext_unbounded (kbo_closure w w0 scf least pr_strict pr_weak gt) ss ts
else (False, False)));
                           });
                       }))
           else (False, False)));

create_KBO_redord_closure ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    [(a, Nat)] -> Redord_closure_ext a [Char] ();
create_KBO_redord_closure pr fs =
  (case prec_weight_repr_to_prec_weight pr of {
    (_, (p, (w, (w0, (lcs, scf))))) ->
      let {
        ro = (create_KBO_redord ::
               ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                 [(a, Nat)] -> Redord_ext a [Char] ())
               pr fs;
      } in Redord_closure_ext
             (\ vp s t ->
               fst (kbo_closure w w0 scf (membera lcs) (\ f g -> fst (p f g))
                     (\ f g -> snd (p f g)) (term_order_of_permx vp) s t))
             (valida ro) ();
  });

check_ordered_completion_proof_ext ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => (String -> String) ->
                    [(Term a [Char], Term a [Char])] ->
                      [(Term a [Char], Term a [Char])] ->
                        [(Term a [Char], Term a [Char])] ->
                          Reduction_order_input a ->
                            Ordered_completion_proof a [Char] ->
                              Sum (String -> String) ();
check_ordered_completion_proof_ext i e_0 e r ro (OKB steps) =
  debug i "OKB"
    (case ro of {
      RPO_Input _ -> Inl (showsl_lit "unsupported reduction order\n");
      KBO_Input precw ->
        let {
          f = map fst (fst precw);
        } in catch_errora
               (check_FGCR_run_with_closure (create_KBO_redord precw f)
                 (create_KBO_redord_closure precw f) f e_0 [] e r steps)
               (\ x ->
                 Inl ((i . showsl_lit
                             ": error in ground completeness proof with closure\n") .
                       x));
    });

precw_w0_sig :: forall a b c. ([(a, b)], c) -> [a];
precw_w0_sig precw_w0 = map fst (fst precw_w0);

rulesa :: forall a. (Eq a) => [(a, a)] -> [(a, a)] -> [(a, a)];
rulesa e r = union r (sym_list e);

check_ground_term ::
  forall a b. (Showl a, Showl b) => Term a b -> Sum (String -> String) ();
check_ground_term s =
  check (ground s)
    ((showsl_literal "the term " . showsl_terma s) .
      showsl_literal " is not a ground term\n");

check_equational_disproof_oc ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => (String -> String) ->
                    (Term a [Char], Term a [Char]) ->
                      [(Term a [Char], Term a [Char])] ->
                        [(Term a [Char], Term a [Char])] ->
                          [(Term a [Char], Term a [Char])] ->
                            Reduction_order_input a ->
                              Ordered_completion_proof a [Char] ->
                                Sum (String -> String) ();
check_equational_disproof_oc i eq e_0 e r ro p =
  (case ro of {
    RPO_Input _ -> Inl (showsl_lit "unsupported reduction order");
    KBO_Input precw ->
      bindb (check_ordered_completion_proof_ext i e_0 e r ro p)
        (\ _ ->
          let {
            roa = create_KBO_redord precw (precw_w0_sig precw);
          } in (case eq of {
                 (s, t) ->
                   bindb (catch_errora (check_ground_term s)
                           (\ _ ->
                             Inl (showsl_terma s .
                                   showsl_lit " is not a ground term\n")))
                     (\ _ ->
                       bindb (catch_errora (check_ground_term t)
                               (\ _ ->
                                 Inl (showsl_terma t .
                                       showsl_lit " is not a ground term\n")))
                         (\ _ ->
                           bindb (catch_errora
                                   (check_subseteq (funas_rule_list (s, t))
                                     (precw_w0_sig precw))
                                   (\ _ ->
                                     Inl (showsl_lit
   " goal is not over expected signature\n")))
                             (\ _ ->
                               bindb (catch_errora
                                       (check_subseteq
 (funas_trs_list (e_0 ++ e ++ r)) (precw_w0_sig precw))
                                       (\ _ ->
 Inl (showsl_lit " system is not over expected signature\n")))
                                 (\ _ ->
                                   let {
                                     nf = compute_mordstep_NF (lessa roa)
    (min_const roa) (rulesa e r);
                                   } in (case (nf s, nf t) of {
  (Nothing, _) ->
    Inl (((showsl_lit "error when computing normal forms of " .
            showsl_terma s) .
           showsl_lit " and ") .
          showsl_terma t);
  (Just _, Nothing) ->
    Inl (((showsl_lit "error when computing normal forms of " .
            showsl_terma s) .
           showsl_lit " and ") .
          showsl_terma t);
  (Just sa, Just ta) ->
    (if not (equal_term sa ta) then Inr ()
      else Inl ((((showsl_terma s . showsl_lit " and ") . showsl_terma t) .
                  showsl_lit " have same normal form ") .
                 showsl_terma sa));
})))));
               }));
  });

is_instance_rule ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b, Term a b) -> (Term a b, Term a b) -> Bool;
is_instance_rule ra r =
  (case match_list Var [(fst r, fst ra), (snd r, snd ra)] of {
    Nothing -> False;
    Just _ -> True;
  });

check_subst_overapproximation ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] -> Sum (String -> String) ();
check_subst_overapproximation ra r =
  catch_errora
    (catch_errora
      (forallM
        (\ raa ->
          catch_errora (existsM (\ rb -> check (is_instance_rule raa rb) id) r)
            (\ _ ->
              Inl ((showsl_lit "growing rule for " . showsl_rule raa) .
                    showsl_lit " is missing\n")))
        ra)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((((showsl_trs r . showsl_lit "\nis not an overapproximation of\n") .
              showsl_trs ra) .
             showsl_literal "\n") .
            x));

group_key :: forall a b. (Eq b) => (a -> b) -> [a] -> [[a]];
group_key f [] = [];
group_key f (x : xs) =
  (x : takeWhile (\ y -> f x == f y) xs) :
    group_key f (dropWhile (\ y -> f x == f y) xs);

nonlinear_var_nonreach ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Compare b, Eq b, Compare c,
      Eq c) => [(a, Nat)] ->
                 (Maybe (a, Nat) -> Maybe (a, Nat) -> Bool) ->
                   [(Term b c, Term a d)] -> Bool;
nonlinear_var_nonreach f gt_fun xs =
  let {
    xs1 = filter (is_Var . fst) xs;
    xs2 = sort_key fst xs1;
    a = group_key fst xs2;
  } in any (\ xts ->
             less_nat one_nat (size_list xts) &&
               all (\ fa ->
                     not (gt_fun (Just fa) Nothing) &&
                       any (\ (_, v) ->
                             not (is_Var v) &&
                               less_eq_set (funas_term v) (set f) &&
                                 not (root v == Just fa) &&
                                   not (gt_fun (Just fa) (root v)))
                         xts)
                 f)
         a;

nonreachable_gtcapRM ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Nat)] ->
                 Bool ->
                   Bool ->
                     (Maybe (a, Nat) -> Maybe (a, Nat) -> Bool) ->
                       ((a, Nat) -> [(Term a b, Term a b)]) ->
                         Term a b -> Term a c -> Bool;
nonreachable_gtcapRM fs nlv ne gt_fun rm s t =
  let {
    gt = gt_term nlv ne gt_fun rm;
    rs = rd_impl gt (s, t);
  } in any (\ (a, b) -> nonreach gt a b) rs ||
         nlv && ne && nonlinear_var_nonreach fs gt_fun rs;

insert_value ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> a -> Rbt b [a] -> Rbt b [a];
insert_value key v m = (case key v of {
                         Nothing -> m;
                         Just k -> (case lookup m k of {
                                     Nothing -> insert k [v] m;
                                     Just vs -> insert k (insertb v vs) m;
                                   });
                       });

insert_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
insert_values uu [] m = m;
insert_values key (v : vs) m = insert_value key v (insert_values key vs m);

insert_rules ::
  forall a b c.
    (Eq a, Compare_order b, Eq b,
      Eq c) => a -> [(Term b c, Term b c)] ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        Rbt (b, Nat) [(a, (Term b c, Term b c))];
insert_rules a rs = insert_values key (map (\ b -> (a, b)) rs);

rule_map ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => [(Term a b, Term a b)] -> (a, Nat) -> [(Term a b, Term a b)];
rule_map r fn = (case lookup (insert_rules () r empty) fn of {
                  Nothing -> [];
                  Just a -> map snd a;
                });

req_list ::
  forall a b.
    a -> [(Term b a, Term b a)] ->
           b -> b -> b -> Term b a -> Term b a -> [(Term b a, Term b a)];
req_list x r eq true false s t =
  (Fun eq [Var x, Var x], Fun true []) : (Fun eq [s, t], Fun false []) : r;

relpow_impl ::
  forall a b.
    ([a] -> [a]) -> ([a] -> b -> b) -> (a -> b -> Bool) -> [a] -> b -> Nat -> b;
relpow_impl succ un memb new have m =
  (if equal_nat m zero_nat then un new have
    else (if null new then have
           else let {
                  maybe = succ new;
                  havea = un new have;
                  newa = filter (\ n -> not (memb n havea)) maybe;
                } in relpow_impl succ un memb newa havea
                       (minus_nat m one_nat)));

trancl_impl ::
  forall a b.
    ([(a, a)] -> [a] -> [a]) ->
      ([a] -> b -> b) -> (a -> b -> Bool) -> b -> [(a, a)] -> [a] -> b;
trancl_impl gen_succ un memb emp rel =
  let {
    succ = gen_succ rel;
    n = size_list rel;
  } in (\ asa -> relpow_impl succ un memb (succ asa) emp n);

trancl_list_impl :: forall a. (Eq a) => [(a, a)] -> [a] -> [a];
trancl_list_impl =
  trancl_impl
    (\ r asa ->
      remdups
        (map_filter
          (\ x ->
            (if (case x of {
                  (a, _) -> membera asa a;
                })
              then Just (snd x) else Nothing))
          r))
    (\ xs ys -> filter (\ x -> not (membera ys x)) xs ++ ys)
    (\ x xs -> membera xs x) [];

memo_list_trancl :: forall a. (Eq a) => [(a, a)] -> a -> [a];
memo_list_trancl r = let {
                       tr = trancl_list_impl r;
                       rm = map (\ a -> (a, tr [a])) ((remdups . map fst) r);
                     } in (\ a -> (case map_of rm a of {
                                    Nothing -> [];
                                    Just asa -> asa;
                                  }));

mk_gt_fun ::
  forall a b c.
    (Eq a) => [(Term a b, Term a c)] ->
                Maybe (a, Nat) -> Maybe (a, Nat) -> Bool;
mk_gt_fun rs = let {
                 in_trancl = memo_list_trancl (gt1 rs);
               } in (\ f -> membera (in_trancl f));

check_nonreachable ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    Term a [Char] ->
                      Term a [Char] ->
                        Nonreachability_proof a [Char] ->
                          Sum (String -> String) ();
check_nonreachable r s t Nonreachable_Tcap =
  check (not (matchb (tcapI r s) t))
    (showsl_lit "could not show nonreachability via tcap");
check_nonreachable r s t Nonreachable_Gtcap =
  let {
    nlv = all (\ lr -> not (is_Var (fst lr))) r;
    fs = funas_trs_list r;
  } in check (not (matchb (tcapI r s) t) ||
               nonreachable_gtcapRM fs nlv (not (null r)) (mk_gt_fun r)
                 (rule_map r) s t)
         (showsl_lit "could not show nonreachability via generalized tcap");
check_nonreachable r s t (Nonreachable_ETAC f aa c a) =
  check_etac_nonreachable f aa c a r s t;
check_nonreachable ra s t (Nonreachable_Subst_Approx r p) =
  bindb (check_subst_overapproximation ra r)
    (\ _ -> check_nonreachable r s t p);
check_nonreachable r s t (Nonreachable_Reverse p) =
  check_nonreachable (map (\ (x, y) -> (y, x)) r) t s p;
check_nonreachable ra s t (Nonreachable_FGCR eq tr fa e r ro ocp) =
  let {
    r_eq =
      req_list [Char False False False True True True True False] ra eq tr fa s
        t;
  } in check_equational_disproof_oc (\ a -> "" ++ a) (Fun tr [], Fun fa []) r_eq
         e r ro ocp;

unifiable :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Bool;
unifiable s t = not (is_none (mergeb s t));

check_nonjoinable ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    Term a [Char] ->
                      Term a [Char] ->
                        Nonjoinability_proof a [Char] ->
                          Sum (String -> String) ();
check_nonjoinable r s t Nonjoinable_Tcap =
  check (not (unifiable (tcapI r s) (tcapI r t)))
    (showsl_lit "could not show nonjoinability via tcap");
check_nonjoinable r s t (Nonjoinable_Ground_NF p) =
  (if is_NF_trs r s && ground s then check_nonreachable r t s p
    else (if is_NF_trs r t && ground t then check_nonreachable r s t p
           else Inl (showsl_lit "non NF")));

check_infeasibleb ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [((Term a [Char], Term a [Char]), b)] ->
                    [(Term a [Char], Term a [Char])] ->
                      Infeasibility_proof a [Char] -> Sum (String -> String) ();
check_infeasibleb r cs (Infeasible_Compound_Conditions f p) =
  check_nonreachable (map fst r) (Fun f (map fst cs)) (Fun f (map snd cs)) p;
check_infeasibleb r cs (Infeasible_Equation s t p) =
  bindb (check (membera cs (s, t))
          ((showsl_lit "equation " . showsl_eqa (s, t)) .
            showsl_lit " is not in list of conditions\n"))
    (\ _ -> check_nonreachable (map fst r) s t p);
check_infeasibleb r csa (Infeasible_Subset cs p) =
  bindb (catch_errora (check_subseteq cs csa)
          (\ x ->
            Inl ((showsl_lit "equation " . showsl_eqa x) .
                  showsl_lit " is not in list of conditions\n")))
    (\ _ -> check_infeasibleb r cs p);
check_infeasibleb r cs (Infeasible_Rhss_Equal s t u p) =
  bindb (check (membera cs (s, u))
          ((showsl_lit "equation " . showsl_eqa (s, u)) .
            showsl_lit " is not in list of conditions\n"))
    (\ _ ->
      bindb (check (membera cs (t, u))
              ((showsl_lit "equation " . showsl_eqa (t, u)) .
                showsl_lit " is not in list of conditions\n"))
        (\ _ -> check_nonjoinable (map fst r) s t p));
check_infeasibleb r cs (Infeasible_Trans s t u p) =
  bindb (check (membera cs (s, t))
          ((showsl_lit "equation " . showsl_eqa (s, t)) .
            showsl_lit " is not in list of conditions\n"))
    (\ _ ->
      bindb (check (membera cs (t, u))
              ((showsl_lit "equation " . showsl_eqa (t, u)) .
                showsl_lit " is not in list of conditions\n"))
        (\ _ -> check_nonreachable (map fst r) s u p));

check_infeasible ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [([(Term a [Char], Term a [Char])],
                     Infeasibility_proof a [Char])] ->
                    [((Term a [Char], Term a [Char]),
                       [(Term a [Char], Term a [Char])])] ->
                      [(Term a [Char], Term a [Char])] ->
                        Sum (String -> String) ();
check_infeasible css r cs =
  catch_errora
    (existsM
      (\ (csa, p) ->
        bindb (check (equal_nat (size_list csa) (size_list cs))
                (showsl_lit "lengths differ"))
          (\ _ ->
            bindb (check
                    (not (is_none (match_rules cs csa)) &&
                      not (is_none (match_rules csa cs)))
                    id)
              (\ _ -> check_infeasibleb r csa p)))
      css)
    (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));

check_CCPs ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [(Term a [Char],
                     (Term a [Char],
                       ([(Term a [Char], Term a [Char])],
                         Context_joinable_proof a [Char])))] ->
                    [([(Term a [Char], Term a [Char])],
                       Infeasibility_proof a [Char])] ->
                      [([Char] -> Term a [Char], Unfeasible_proof a [Char])] ->
                        [((Term a [Char], Term a [Char]),
                           [(Term a [Char], Term a [Char])])] ->
                          Sum (String -> String) ();
check_CCPs cj css uo r =
  catch_errora
    (forallM
      (\ rho_1 ->
        let {
          l_1 = fst (fst rho_1);
        } in catch_errora
               (forallM
                 (\ rho_2 ->
                   catch_errora
                     (forallM
                       (check_overlap
                         (\ a ->
                           Char False False False True True True True False : a)
                         (\ a ->
                           Char True False False True True True True False : a)
                         (check_context_joinable cj) (check_infeasible css)
                         (check_unfeasible uo) r rho_1 rho_2)
                       (funposs_list l_1))
                     (\ x -> Inl (snd x)))
                 r)
               (\ x -> Inl (snd x)))
      r)
    (\ x -> Inl (snd x));

check_type3 ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum (String -> String) ();
check_type3 r =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (check_subseteq (vars_term_list (snd (fst cr)))
              (vars_term_list (fst (fst cr)) ++ vars_trs_list (snd cr)))
            (\ x ->
              Inl ((((showsl_lit "variable " . showsl x) .
                      showsl_lit " occurs only in right-hand side of rule ") .
                     showsl_crule cr) .
                    showsl_literal "\n")))
        r)
      (\ x -> Inl (snd x)))
    (\ x -> Inl (showsl_lit "the CTRS is not of type 3\n" . x));

x_impl ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> [b];
x_impl cr i =
  concat
    (vars_term_list (fst (fst cr)) :
      map (vars_term_list . snd) (take i (snd cr)));

check_dctrs ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum (String -> String) ();
check_dctrs r =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                catch_errora
                  (check_subseteq (vars_term_list (fst (nth (snd cr) i)))
                    (x_impl cr i))
                  (\ x ->
                    Inl ((((((showsl_lit "variable " . showsl x) .
                              showsl_lit " in condition ") .
                             showsl_rule (nth (snd cr) i)) .
                            showsl_lit " of rule ") .
                           showsl_crule cr) .
                          showsl_lit "violates DCTRS condition\n")))
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x -> Inl (showsl_lit "the CTRS is not deterministic\n" . x));

check_wf_ctrs ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum (String -> String) ();
check_wf_ctrs r =
  catch_errora
    (bindb (check_varcond_no_Var_lhs (map fst r))
      (\ _ -> bindb (check_dctrs r) (\ _ -> check_type3 r)))
    (\ x -> Inl (showsl_lit "the CTRS is not well-formed\n" . x));

check_adtrs ::
  forall a.
    (Eq a,
      Showl a) => [((Term a [Char], Term a [Char]),
                     [(Term a [Char], Term a [Char])])] ->
                    Sum (String -> String) ();
check_adtrs r =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM (\ i -> let {
                               a = snd (nth (snd cr) i);
                             } in check_airr r a)
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x -> Inl (showsl_lit "the CTRS is not absolutely deterministic\n" . x));

check_al94 ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [(Term a [Char],
                     (Term a [Char],
                       ([(Term a [Char], Term a [Char])],
                         Context_joinable_proof a [Char])))] ->
                    [([(Term a [Char], Term a [Char])],
                       Infeasibility_proof a [Char])] ->
                      [([Char] -> Term a [Char], Unfeasible_proof a [Char])] ->
                        [((Term a [Char], Term a [Char]),
                           [(Term a [Char], Term a [Char])])] ->
                          Sum (String -> String) ();
check_al94 cj css uo r =
  catch_errora
    (bindb (check_wf_ctrs r)
      (\ _ -> bindb (check_adtrs r) (\ _ -> check_CCPs cj css uo r)))
    (\ x ->
      Inl (showsl_lit "Avenhaus & Loria-Saenz 1994 does not apply\n" . x));

orig_crule ::
  forall a b.
    (a -> Maybe b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) ->
        ((Term a b, Term a b), [(Term a b, Term a b)]);
orig_crule m r =
  ((orig_term m (fst (fst r)), orig_term m (snd (fst r))),
    map (\ (s, t) -> (orig_term m s, orig_term m t)) (snd r));

orig_cstep :: forall a b. (a -> Maybe b) -> Cstep_proof a b -> Cstep_proof a b;
orig_cstep m (Cstep_step rho p sigma s t css) =
  Cstep_step (orig_crule m rho) p (orig_term m . sigma) (orig_term m s)
    (orig_term m t) (map (map (orig_cstep m)) css);

arith_fun ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) ArithFun;
arith_fun xml =
  xml_do "arithFunction"
    (xml_take
      (xml_or (xml_change (xml_nat "natural") (\ n -> xml_return (Const n)))
        (xml_or
          (xml_change (xml_nat "variable")
            (\ n -> xml_return (Arg (minus_nat n one_nat))))
          (xml_or
            (xml_do "sum"
              (xml_take_many_sub [] zero_nat Infinity_enat arith_fun
                (\ asa -> xml_return (Sum asa))))
            (xml_or
              (xml_do "product"
                (xml_take_many_sub [] zero_nat Infinity_enat arith_fun
                  (\ asa -> xml_return (Prod asa))))
              (xml_or
                (xml_do "max"
                  (xml_take_many_sub [] zero_nat Infinity_enat arith_fun
                    (\ asa -> xml_return (Max asa))))
                (xml_or
                  (xml_do "min"
                    (xml_take_many_sub [] zero_nat Infinity_enat arith_fun
                      (\ a -> xml_return (Min a))))
                  (xml_do "ifEqual"
                    (xml_take arith_fun
                      (\ a ->
                        xml_take arith_fun
                          (\ b ->
                            xml_take arith_fun
                              (\ c ->
                                xml_take arith_fun
                                  (\ d ->
                                    xml_return (IfEqual a b c d)))))))))))))
      xml_return)
    xml;

int_coeff ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Int;
int_coeff = xml_int "integer";

vec_coeff ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Vec a);
vec_coeff xml2coeff =
  xml_do "vector"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "coefficient" (xml_take xml2coeff (\ x -> xml_return (id x))))
      (\ a -> xml_return (vec_of_list a)));

mat_coeff ::
  forall a.
    Nat ->
      a -> ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
             Sum_bot (Xml_error String) a) ->
             (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
               Sum_bot (Xml_error String) (Mat a);
mat_coeff n ze xml2coeff =
  xml_or
    (xml_do "matrix"
      (xml_take_many_sub [] zero_nat Infinity_enat (vec_coeff xml2coeff)
        (\ a -> xml_return (mat_of_cols n a))))
    (xml_change (vec_coeff xml2coeff)
      (\ v ->
        xml_return
          (mat n n
            (\ (i, j) ->
              (if equal_nat j zero_nat then vec_index v i else ze)))));

closed_criterion ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Ta_relation [Char]);
closed_criterion =
  xml_do "criterion"
    (xml_take
      (xml_or (xml_leaf "compatibility" Id_Relation)
        (xml_or
          (xml_do "stateCompatibility"
            (xml_take
              (xml_do "relation"
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (xml_do "entry"
                    (xml_take state
                      (\ a -> xml_take state (\ b -> xml_return (a, b)))))
                  xml_return))
              (\ x -> xml_return (Some_Relation x))))
          (xml_or (xml_leaf "decisionProcedure" Decision_Proc)
            (xml_leaf "decisionProcedureOld" Decision_Proc_Old))))
      xml_return);

final_states ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) [[Char]];
final_states =
  xml_do "finalStates"
    (xml_take_many_sub [] zero_nat Infinity_enat state xml_return);

transition ::
  forall a b.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) (Sum (a, [[Char]]) b)) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Sum (Ta_rule [Char] a) (b, [Char]));
transition xml2lhs =
  xml_do "transition"
    (xml_take xml2lhs
      (\ a ->
        xml_take (xml_do "rhs" (xml_take state (\ x -> xml_return (id x))))
          (\ b -> xml_return (case a of {
                               Inl (f, qs) -> Inl (TA_rule f qs b);
                               Inr q -> Inr (q, b);
                             }))));

transitions ::
  forall a b.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) (Sum (a, [[Char]]) b)) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) ([Ta_rule [Char] a], [(b, [Char])]);
transitions xml2lhs =
  xml_do "transitions"
    (xml_take_many_sub [] zero_nat Infinity_enat (transition xml2lhs)
      (\ rls -> (case partition (\ a -> (case a of {
  Inl _ -> True;
  Inr _ -> False;
}))
                        rls
                  of {
                  (rules, eps) -> let {
                                    ruls = map (\ (Inl r) -> r) rules;
                                    ep = map (\ (Inr e) -> e) eps;
                                  } in xml_return (ruls, ep);
                })));

tree_automaton ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) (Sum (a, [[Char]]) [Char])) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Tree_automaton [Char] a);
tree_automaton xml2lhs =
  xml_do "treeAutomaton"
    (xml_take final_states
      (\ a ->
        xml_take (transitions xml2lhs)
          (\ b -> xml_return (case b of {
                               (ba, c) -> Tree_Automaton a ba c;
                             }))));

ta_normal_lhs ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Sum (a, [[Char]]) [Char]);
ta_normal_lhs xml2name =
  xml_do "lhs"
    (xml_or (xml_take state (\ a -> xml_return (Inr a)))
      (xml_take xml2name
        (\ a ->
          xml_take_many_sub [] zero_nat Infinity_enat state
            (\ b -> xml_return (Inl (a, b))))));

not_wn_ta ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Not_wn_ta_prf (Lab a b) [Char]);
not_wn_ta xml2name =
  xml_do "notWNTreeAutomaton"
    (xml_take (tree_automaton (ta_normal_lhs xml2name))
      (\ a ->
        xml_take closed_criterion (\ b -> xml_return (Not_wn_ta_prf a b))));

precedence_weight_ac ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (Nat -> ([((a, Nat), (Nat, (Nat, Bool)))], Nat));
precedence_weight_ac xml2name =
  xml_do "precedenceWeight"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "precedenceWeightEntry"
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat "arity")
              (\ a ->
                xml_take (xml_nat "precedence")
                  (\ p ->
                    xml_take (xml_nat "weight")
                      (\ w ->
                        xml_take_default False (xml_bool "isAC")
                          (\ e -> xml_return ((f, a), (p, (w, e))))))))))
      (\ ret -> xml_return (\ a -> (ret, a))));

ac_knuth_bendix_order ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Redtriple_impl a);
ac_knuth_bendix_order xml2name =
  xml_do "ACKBO"
    (xml_take (xml_nat "w0")
      (\ w0 ->
        xml_take (precedence_weight_ac xml2name)
          (\ prw ->
            xml_take_default [] (afs xml2name)
              (\ afsa -> xml_return (ACKBO (prw w0) afsa)))));

precedence_weight ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (Nat -> ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat));
precedence_weight xml2name =
  xml_do "precedenceWeight"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "precedenceWeightEntry"
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat "arity")
              (\ a ->
                xml_take (xml_nat "precedence")
                  (\ p ->
                    xml_take (xml_nat "weight")
                      (\ w ->
                        xml_take_optional
                          (xml_do "subtermCoefficientEntries"
                            (xml_take_many_sub [] zero_nat Infinity_enat
                              (xml_nat "entry") xml_return))
                          (\ e -> xml_return ((f, a), (p, (w, e))))))))))
      (\ ret -> xml_return (\ a -> (ret, a))));

knuth_bendix_order ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Redtriple_impl a);
knuth_bendix_order xml2name =
  xml_do "knuthBendixOrder"
    (xml_take (xml_nat "w0")
      (\ w0 ->
        xml_take (precedence_weight xml2name)
          (\ prw ->
            xml_take_default [] (afs xml2name)
              (\ afsa -> xml_return (KBO (prw w0) afsa)))));

exp_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Term Siga Nat);
exp_parser xml =
  xml_or
    (xml_do "product"
      (xml_take_many_sub [] zero_nat Infinity_enat exp_parser
        (\ exps -> xml_return (Fun ProdFa exps))))
    (xml_or
      (xml_do "sum"
        (xml_take_many_sub [] zero_nat Infinity_enat exp_parser
          (\ exps -> xml_return (Fun SumFa exps))))
      (xml_or
        (xml_do "max"
          (xml_take_many_sub [] zero_nat Infinity_enat exp_parser
            (\ exps -> xml_return (Fun MaxF exps))))
        (xml_or
          (xml_change (xml_nat "constant")
            (\ i -> xml_return (Fun (ConstFa i) [])))
          (xml_change (xml_nat "variable")
            (\ i -> xml_return (Var (minus_nat i one_nat)))))))
    xml;

max_poly_order ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Redtriple_impl a);
max_poly_order xml2name =
  xml_do "maxPoly"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "interpret"
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat "arity")
              (\ a -> xml_take exp_parser (\ e -> xml_return ((f, a), e))))))
      (\ inters -> xml_return (Max_poly inters)));

arctic_rat_linear_poly ::
  forall a.
    Interpretation a -> ((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]));
arctic_rat_linear_poly (Arctic_rat_linear_poly x4) = x4;

real_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [(Monom Nat, Real)]);
real_non_linear_poly (Real_non_linear_poly x13) = x13;

rat_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [(Monom Nat, Rat)]);
rat_non_linear_poly (Rat_non_linear_poly x12) = x12;

int_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [(Monom Nat, Int)]);
int_non_linear_poly (Int_non_linear_poly x11) = x11;

arctic_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), (Arctic, [Arctic]));
arctic_linear_poly (Arctic_linear_poly x3) = x3;

arctic_rat_matrix ::
  forall a.
    Interpretation a ->
      ((a, Nat), (Mat (Arctic_delta Rat), [Mat (Arctic_delta Rat)]));
arctic_rat_matrix (Arctic_rat_matrix x9) = x9;

real_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Real, [Real]));
real_linear_poly (Real_linear_poly x5) = x5;

rat_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Rat, [Rat]));
rat_linear_poly (Rat_linear_poly x2) = x2;

int_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Int, [Int]));
int_linear_poly (Int_linear_poly x1) = x1;

arctic_matrix ::
  forall a. Interpretation a -> ((a, Nat), (Mat Arctic, [Mat Arctic]));
arctic_matrix (Arctic_matrix x8) = x8;

real_matrix :: forall a. Interpretation a -> ((a, Nat), (Mat Real, [Mat Real]));
real_matrix (Real_matrix x10) = x10;

rat_matrix :: forall a. Interpretation a -> ((a, Nat), (Mat Rat, [Mat Rat]));
rat_matrix (Rat_matrix x7) = x7;

int_matrix :: forall a. Interpretation a -> ((a, Nat), (Mat Int, [Mat Int]));
int_matrix (Int_matrix x6) = x6;

class_semiring ::
  forall a b.
    (Ceq a, Ccompare a, One a, Plus a, Times a, Zero a,
      Set_impl a) => Itself a ->
                       b -> Partial_object_ext a (Monoid_ext a (Ring_ext a b));
class_semiring uu b =
  Partial_object_ext top_set (Monoid_ext times onea (Ring_ext zerob plus b));

real_domain ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Real;
real_domain =
  xml_do "algebraicNumbers"
    (xml_take (xml_do "delta" (xml_take xml_real (\ x -> xml_return (id x))))
      (\ x -> xml_return (id x)));

rat_domain ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Rat;
rat_domain =
  xml_do "rationals"
    (xml_take (xml_do "delta" (xml_take xml_rat (\ x -> xml_return (id x))))
      (\ x -> xml_return (id x)));

basic_domain ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Nat -> Domain);
basic_domain =
  xml_or (xml_leaf "naturals" Natural)
    (xml_or (xml_leaf "integers" (\ _ -> Integera))
      (xml_or (xml_change rat_domain (xml_return . Rational))
        (xml_or (xml_change real_domain (xml_return . Mini_Alg))
          (xml_do "arctic"
            (xml_take
              (xml_do "domain"
                (xml_take
                  (xml_or (xml_leaf "naturals" (\ _ -> Arctic))
                    (xml_or (xml_leaf "integers" (\ _ -> Arctic))
                      (xml_change rat_domain
                        (\ _ -> xml_return (\ _ -> Arctic_rat)))))
                  (\ x -> xml_return (id x))))
              (\ x -> xml_return (id x)))))));

interpretation_type ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Domain;
interpretation_type =
  xml_do "type"
    (xml_take
      (xml_or
        (xml_do "matrixInterpretation"
          (xml_take
            (xml_do "domain" (xml_take basic_domain (\ x -> xml_return (id x))))
            (\ a ->
              xml_take (xml_nat "dimension")
                (\ b ->
                  xml_take (xml_nat "strictDimension")
                    (\ c -> xml_return (case a zero_nat of {
 Natural _ -> Int_mat b c;
 Integera -> Int_mat b c;
 Arctic -> Arctic_mat b;
 Arctic_rat -> Arctic_rat_mat b;
 Rational _ _ -> Rat_mat b c;
 Mini_Alg _ _ -> Mini_Alg_mat b c;
                                       }))))))
        (xml_do "polynomial"
          (xml_take
            (xml_do "domain"
              (xml_take
                (xml_or basic_domain
                  (xml_do "matrices"
                    (xml_take (xml_nat "dimension")
                      (\ a ->
                        xml_take (xml_nat "strictDimension")
                          (\ b ->
                            xml_take
                              (xml_do "domain"
                                (xml_take basic_domain
                                  (\ x -> xml_return (id x))))
                              (\ c ->
                                xml_return
                                  (\ d ->
                                    (case c d of {
                                      Natural _ -> Int_mat a b;
                                      Integera -> Int_mat a b;
                                      Arctic -> Arctic_mat a;
                                      Arctic_rat -> Arctic_rat_mat a;
                                      Rational _ _ -> Rat_mat a b;
                                      Mini_Alg _ _ -> Mini_Alg_mat a b;
                                    }))))))))
                (\ x -> xml_return (id x))))
            (\ a -> xml_take (xml_nat "degree") (\ b -> xml_return (a b))))))
      (\ x -> xml_return (id x)));

arctic_rat_coeff ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Arctic_delta Rat);
arctic_rat_coeff =
  xml_or (xml_change xml_rat (xml_return . Num_arc_delta))
    (xml_leaf "minusInfinity" MinInfty_delta);

arctic_coeff ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Arctic;
arctic_coeff =
  xml_or (xml_change int_coeff (xml_return . Num_arc))
    (xml_leaf "minusInfinity" MinInfty);

xml_changea ::
  forall a b c d e.
    (a -> Sum_bot String b) ->
      a -> ([Xml], (c, (d, (e, [String])))) -> Sum_bot (Xml_error String) b;
xml_changea f p x = bind2 (f p) (\ e -> xml_error e x) right;

polynomial ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Tpoly Nat a);
polynomial xml2coeff x =
  xml_do "polynomial"
    (xml_take
      (xml_or
        (xml_do "coefficient"
          (xml_take xml2coeff (\ xa -> xml_return (PNum xa))))
        (xml_or
          (xml_change (xml_nat "variable")
            (\ n -> xml_return (PVar (minus_nat n one_nat))))
          (xml_or
            (xml_do "sum"
              (xml_take_many_sub [] zero_nat Infinity_enat
                (polynomial xml2coeff) (\ a -> xml_return (PSum a))))
            (xml_do "product"
              (xml_take_many_sub [] zero_nat Infinity_enat
                (polynomial xml2coeff) (\ a -> xml_return (PMult a)))))))
      (\ xa -> xml_return (id xa)))
    x;

fit_length ::
  forall a.
    Partial_object_ext a (Monoid_ext a (Ring_ext a ())) -> Nat -> [a] -> [a];
fit_length c n uu =
  (if equal_nat n zero_nat then []
    else (case uu of {
           [] -> replicate (suc (minus_nat n one_nat)) (zero c);
           b : bs -> b : fit_length c (minus_nat n one_nat) bs;
         }));

interpretation ::
  forall a.
    Bool ->
      ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a) ->
        (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) (Redtriple_impl a);
interpretation bi xml2name =
  xml_do "interpretation"
    (xml_take interpretation_type
      (\ typea ->
        xml_take_many_sub [] zero_nat Infinity_enat
          (xml_do "interpret"
            (xml_take xml2name
              (\ f ->
                xml_take (xml_nat "arity")
                  (\ a ->
                    (case typea of {
                      Natural deg ->
                        (if less_eq_nat deg one_nat && not bi
                          then let {
                                 c = class_semiring Type ();
                               } in xml_take
                                      (xml_change (polynomial int_coeff)
(xml_changea (lpoly_of c)))
                                      (\ poly ->
xml_return (Int_linear_poly ((f, a), (fst poly, fit_length c a (snd poly)))))
                          else xml_take
                                 (xml_change (polynomial int_coeff)
                                   (xml_return . poly_of))
                                 (\ poly ->
                                   xml_return
                                     (Int_non_linear_poly ((f, a), poly))));
                      Integera ->
                        xml_take
                          (xml_change (polynomial int_coeff)
                            (xml_return . poly_of))
                          (\ poly ->
                            xml_return (Int_non_linear_poly ((f, a), poly)));
                      Arctic ->
                        let {
                          c = class_semiring Type ();
                        } in xml_take
                               (xml_change (polynomial arctic_coeff)
                                 (xml_changea (lpoly_of c)))
                               (\ poly ->
                                 xml_return
                                   (Arctic_linear_poly
                                     ((f, a),
                                       (fst poly, fit_length c a (snd poly)))));
                      Arctic_rat ->
                        let {
                          c = class_semiring Type ();
                        } in xml_take
                               (xml_change (polynomial arctic_rat_coeff)
                                 (xml_changea (lpoly_of c)))
                               (\ poly ->
                                 xml_return
                                   (Arctic_rat_linear_poly
                                     ((f, a),
                                       (fst poly, fit_length c a (snd poly)))));
                      Int_mat n _ ->
                        let {
                          c = ring_mat Type n ();
                        } in xml_take
                               (xml_change
                                 (polynomial (mat_coeff n zero_int int_coeff))
                                 (xml_changea (lpoly_of c)))
                               (\ poly ->
                                 xml_return
                                   (Int_matrix
                                     ((f, a),
                                       (fst poly, fit_length c a (snd poly)))));
                      Arctic_mat n ->
                        let {
                          c = ring_mat Type n ();
                        } in xml_take
                               (xml_change
                                 (polynomial
                                   (mat_coeff n zero_arctic arctic_coeff))
                                 (xml_changea (lpoly_of c)))
                               (\ poly ->
                                 xml_return
                                   (Arctic_matrix
                                     ((f, a),
                                       (fst poly, fit_length c a (snd poly)))));
                      Arctic_rat_mat n ->
                        let {
                          c = ring_mat Type n ();
                        } in xml_take
                               (xml_change
                                 (polynomial
                                   (mat_coeff n zero_arctic_delta
                                     arctic_rat_coeff))
                                 (xml_changea (lpoly_of c)))
                               (\ poly ->
                                 xml_return
                                   (Arctic_rat_matrix
                                     ((f, a),
                                       (fst poly, fit_length c a (snd poly)))));
                      Rational _ deg ->
                        (if less_eq_nat deg one_nat && not bi
                          then let {
                                 c = class_semiring Type ();
                               } in xml_take
                                      (xml_change (polynomial xml_rat)
(xml_changea (lpoly_of c)))
                                      (\ poly ->
xml_return (Rat_linear_poly ((f, a), (fst poly, fit_length c a (snd poly)))))
                          else xml_take
                                 (xml_change (polynomial xml_rat)
                                   (xml_return . poly_of))
                                 (\ poly ->
                                   xml_return
                                     (Rat_non_linear_poly ((f, a), poly))));
                      Rat_mat n _ ->
                        let {
                          c = ring_mat Type n ();
                        } in xml_take
                               (xml_change
                                 (polynomial (mat_coeff n zero_rat xml_rat))
                                 (xml_changea (lpoly_of c)))
                               (\ poly ->
                                 xml_return
                                   (Rat_matrix
                                     ((f, a),
                                       (fst poly, fit_length c a (snd poly)))));
                      Mini_Alg _ deg ->
                        (if less_eq_nat deg one_nat && not bi
                          then let {
                                 c = class_semiring Type ();
                               } in xml_take
                                      (xml_change (polynomial xml_real)
(xml_changea (lpoly_of c)))
                                      (\ poly ->
xml_return (Real_linear_poly ((f, a), (fst poly, fit_length c a (snd poly)))))
                          else xml_take
                                 (xml_change (polynomial xml_real)
                                   (xml_return . poly_of))
                                 (\ poly ->
                                   xml_return
                                     (Real_non_linear_poly ((f, a), poly))));
                      Mini_Alg_mat n _ ->
                        let {
                          c = ring_mat Type n ();
                        } in xml_take
                               (xml_change
                                 (polynomial (mat_coeff n zero_real xml_real))
                                 (xml_changea (lpoly_of c)))
                               (\ poly ->
                                 xml_return
                                   (Real_matrix
                                     ((f, a),
                                       (fst poly, fit_length c a (snd poly)))));
                    })))))
          (\ pi ->
            xml_return
              (case typea of {
                Natural deg ->
                  (if less_eq_nat deg one_nat && not bi
                    then Int_carrier (map int_linear_poly pi)
                    else Int_nl_carrier (map int_non_linear_poly pi));
                Integera -> Int_nl_carrier (map int_non_linear_poly pi);
                Arctic -> Arctic_carrier (map arctic_linear_poly pi);
                Arctic_rat ->
                  Arctic_rat_carrier (map arctic_rat_linear_poly pi);
                Int_mat n sd -> Int_mat_carrier n sd (map int_matrix pi);
                Arctic_mat n -> Arctic_mat_carrier n (map arctic_matrix pi);
                Arctic_rat_mat n ->
                  Arctic_rat_mat_carrier n (map arctic_rat_matrix pi);
                Rational d deg ->
                  (if less_eq_nat deg one_nat && not bi
                    then Rat_carrier (map rat_linear_poly pi)
                    else Rat_nl_carrier d (map rat_non_linear_poly pi));
                Rat_mat n sd -> Rat_mat_carrier n sd (map rat_matrix pi);
                Mini_Alg d deg ->
                  (if less_eq_nat deg one_nat && not bi
                    then Real_carrier (map real_linear_poly pi)
                    else Real_nl_carrier d (map real_non_linear_poly pi));
                Mini_Alg_mat n sd -> Real_mat_carrier n sd (map real_matrix pi);
              }))));

wpo_params ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [((a, Nat), (Nat, [Nat]))];
wpo_params xml2name =
  xml_do "precedenceStatus"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "precedenceStatusEntry"
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat "arity")
              (\ a ->
                xml_take (xml_nat "precedence")
                  (\ p ->
                    xml_take
                      (xml_do "status"
                        (xml_take_many_sub [] zero_nat Infinity_enat position
                          xml_return))
                      (\ s -> xml_return ((f, a), (p, s))))))))
      xml_return);

status_precedence ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [((a, Nat), (Nat, Order_tag))];
status_precedence xml2name =
  xml_do "statusPrecedence"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "statusPrecedenceEntry"
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat "arity")
              (\ a ->
                xml_take (xml_nat "precedence")
                  (\ p ->
                    xml_take (xml_or (xml_leaf "lex" Lex) (xml_leaf "mul" Mul))
                      (\ s -> xml_return ((f, a), (p, s))))))))
      xml_return);

path_order ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Redtriple_impl a);
path_order xml2name =
  xml_do "pathOrder"
    (xml_take (status_precedence xml2name)
      (\ prec_tau ->
        xml_take_default [] (afs xml2name)
          (\ af -> xml_return (RPO prec_tau af))));

redtriple ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   Bool ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) (Redtriple_impl a);
redtriple xml2name bi x =
  xml_or (path_order xml2name)
    (xml_or (knuth_bendix_order xml2name)
      (xml_or (ac_knuth_bendix_order xml2name)
        (xml_or
          (xml_do "weightedPathOrder"
            (xml_take (wpo_params xml2name)
              (\ a ->
                xml_take (redtriple xml2name bi)
                  (\ b -> xml_return (WPO a b)))))
          (xml_or
            (xml_do "filteredRedPair"
              (xml_take_default [] (afs xml2name)
                (\ af ->
                  xml_take (redtriple xml2name bi)
                    (\ b -> xml_return (Filtered_Redtriple af b)))))
            (xml_or (interpretation bi xml2name) (max_poly_order xml2name))))))
    x;

joinable_critical_pairs ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       [(Term a [Char],
                          ([([Nat],
                              ((Term a [Char], Term a [Char]), Term a [Char]))],
                            (Term a [Char],
                              [([Nat],
                                 ((Term a [Char], Term a [Char]),
                                   Term a [Char]))])))];
joinable_critical_pairs xml2name =
  let {
    rew = rsteps xml2name;
  } in xml_do "joinableCriticalPairs"
         (xml_take_many_sub [] zero_nat Infinity_enat
           (xml_do "joinableCriticalPair"
             (xml_take rew
               (\ (s, sseq) ->
                 xml_take rew
                   (\ (t, tseq) -> xml_return (s, (sseq, (t, tseq)))))))
           xml_return);

wcr_proof ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Join_info a);
wcr_proof xml2name =
  xml_do "wcrProof"
    (xml_take
      (xml_or
        (xml_change (joinable_critical_pairs xml2name) (xml_return . Guided))
        (xml_or
          (xml_change (xml_nat "joinableCriticalPairsBFS")
            (xml_return . Join_BFS))
          (xml_leaf "joinableCriticalPairsAuto" Join_NF)))
      (\ x -> xml_return (id x)));

precedence_weighta ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (Nat -> ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat));
precedence_weighta xml2name =
  xml_do "precedenceWeight"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "precedenceWeightEntry"
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat "arity")
              (\ a ->
                xml_take (xml_nat "precedence")
                  (\ p ->
                    xml_take (xml_nat "weight")
                      (\ w ->
                        xml_take_optional
                          (xml_do "subtermCoefficientEntries"
                            (xml_take_many_sub [] zero_nat Infinity_enat
                              (xml_nat "entry") xml_return))
                          (\ e -> xml_return ((f, a), (p, (w, e))))))))))
      (\ ret -> xml_return (\ a -> (ret, a))));

kbo_input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Reduction_order_input a);
kbo_input xml2name =
  xml_do "knuthBendixOrder"
    (xml_take (xml_nat "w0")
      (\ w0 ->
        xml_take (precedence_weighta xml2name)
          (\ prw -> xml_return (KBO_Input (prw w0)))));

xml2ordered_completion_result ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       ([(Term a [Char], Term a [Char])],
                         ([(Term a [Char], Term a [Char])],
                           Reduction_order_input a));
xml2ordered_completion_result xml2name =
  xml_do "orderedCompletionResult"
    (xml_take (xml_do "trs" (xml_take (rules xml2name) xml_return))
      (\ rs ->
        xml_take (xml_do "equations" (xml_take (rules xml2name) xml_return))
          (\ es ->
            xml_take
              (xml_do "reductionOrder"
                (xml_take (kbo_input xml2name) xml_return))
              (\ ro -> xml_return (rs, (es, ro))))));

xml2ordered_completion_input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
xml2ordered_completion_input xml2name =
  xml_do "orderedCompletionInput"
    (xml_take (xml_do "equations" (xml_take (rules xml2name) xml_return))
      (\ es0 ->
        xml_take (xml2ordered_completion_result xml2name)
          (\ (rs, (es, ro)) -> xml_return (OCOMP_input es0 es rs ro))));

xml2infeasibility_input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
xml2infeasibility_input xml2name =
  xml_do "infeasibilityInput"
    (xml_take
      (xml_do "rules"
        (xml_take_many_sub [] zero_nat Infinity_enat (crule xml2name "rule")
          xml_return))
      (\ c ->
        xml_take (xml_do "probs" (xml_take (rules xml2name) xml_return))
          (\ r -> xml_return (Infeasibility_input c r))));

formula_parser ::
  forall a b c.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) (Formula (Term a (b, c)))) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Formula (Term a (b, c)));
formula_parser atom_parser x =
  xml_or
    (xml_do "disjunction"
      (xml_take_many_sub [] zero_nat Infinity_enat (formula_parser atom_parser)
        (\ fs -> xml_return (Disjunction fs))))
    (xml_or
      (xml_do "conjunction"
        (xml_take_many_sub [] zero_nat Infinity_enat
          (formula_parser atom_parser) (\ fs -> xml_return (Conjunction fs))))
      atom_parser)
    x;

transition_parser ::
  forall a b c d e.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) b) ->
        ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) (Formula (Term c (Trans_var d, e)))) ->
          (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
            Sum_bot (Xml_error String) (b, Transition_rule c d e a);
transition_parser location_parser trans_parser tatom_parser =
  xml_do "transition"
    (xml_take trans_parser
      (\ tr ->
        xml_take (xml_do "source" (xml_take location_parser xml_return))
          (\ l ->
            xml_take (xml_do "target" (xml_take location_parser xml_return))
              (\ r ->
                xml_take
                  (xml_do "formula"
                    (xml_take (formula_parser tatom_parser) xml_return))
                  (\ phi -> xml_return (tr, Transition l r phi))))));

lts_parser ::
  forall a b c d e.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) b) ->
        ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) (Formula (Term c (Trans_var d, e)))) ->
          String ->
            (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
              Sum_bot (Xml_error String) (Lts_impl c d e a b);
lts_parser location_parser trans_parser tatom_parser tag =
  xml_do tag
    (xml_take
      (xml_do "initial"
        (xml_take_many_sub [] one_nat Infinity_enat location_parser xml_return))
      (\ i ->
        xml_take_many_sub [] zero_nat Infinity_enat
          (transition_parser location_parser trans_parser tatom_parser)
          (\ t -> xml_return (Lts_Impl i t []))));

safety_input_parser ::
  forall a b c d e.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) b) ->
        ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) (Formula (Term c (Trans_var d, e)))) ->
          (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
            Sum_bot (Xml_error String) (Lts_impl c d e a b, [a]);
safety_input_parser location_parser trans_parser tatom_parser =
  xml_do "ltsSafetyInput"
    (xml_take (lts_parser location_parser trans_parser tatom_parser "lts")
      (\ lts ->
        xml_take
          (xml_do "error"
            (xml_take_many_sub [] one_nat Infinity_enat location_parser
              xml_return))
          (\ err -> xml_return (lts, err))));

location_parser ::
  forall a.
    (String ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a;
location_parser location_id_parser = location_id_parser "locationId";

variable_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) [Char];
variable_parser = xml_text "variableId";

trans_var_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Trans_var [Char]);
trans_var_parser =
  xml_or (xml_do "post" (xml_take variable_parser (\ v -> xml_return (Post v))))
    (xml_or (xml_change (xml_text "aux") (xml_return . Intermediate))
      (xml_change variable_parser (xml_return . Pre)));

exp_parserb ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Term Sig (a, Ty));
exp_parserb v xml =
  xml_or
    (xml_do "product"
      (xml_take_many_sub [] zero_nat Infinity_enat (exp_parserb v)
        (\ exps -> xml_return (Fun (ProdF (size_list exps)) exps))))
    (xml_or
      (xml_do "sum"
        (xml_take_many_sub [] zero_nat Infinity_enat (exp_parserb v)
          (\ exps -> xml_return (Fun (SumF (size_list exps)) exps))))
      (xml_or
        (xml_change (xml_int "constant")
          (\ i -> xml_return (Fun (ConstF i) [])))
        (xml_change v (\ x -> xml_return (Var (x, IntT))))))
    xml;

bexp_parser ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Term Sig (a, Ty));
bexp_parser v =
  xml_or
    (xml_do "leq"
      (xml_take (exp_parserb v)
        (\ l -> xml_take (exp_parserb v) (\ r -> xml_return (Fun LeF [l, r])))))
    (xml_or
      (xml_do "less"
        (xml_take (exp_parserb v)
          (\ l ->
            xml_take (exp_parserb v) (\ r -> xml_return (Fun LessF [l, r])))))
      (xml_do "eq"
        (xml_take (exp_parserb v)
          (\ l ->
            xml_take (exp_parserb v) (\ r -> xml_return (Fun EqF [l, r]))))));

tatom_parsera ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Formula (Term Sig (Trans_var [Char], Ty)));
tatom_parsera = xml_change (bexp_parser trans_var_parser) (xml_return . Atom);

lts_safety_input_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Lts_impl Sig [Char] Ty [Char] [Char], [[Char]]);
lts_safety_input_parser =
  safety_input_parser (location_parser xml_text) (trans_id xml_text)
    tatom_parsera;

xml2equational_input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
xml2equational_input xml2name =
  xml_do "equationalReasoningInput"
    (xml_take (xml_do "equations" (xml_take (rules xml2name) xml_return))
      (\ eqs ->
        xml_take
          (xml_or
            (xml_do "equation"
              (xml_take (term xml2name)
                (\ a ->
                  xml_take (term xml2name)
                    (\ b -> xml_return (Equation (a, b))))))
            (xml_do "inequality"
              (xml_take (term xml2name)
                (\ a ->
                  xml_take (term xml2name)
                    (\ b -> xml_return (Inequality (a, b)))))))
          (\ goal -> xml_return (EQ_input eqs goal))));

xml2completion_input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
xml2completion_input xml2name =
  xml_do "completionInput"
    (xml_take (xml_do "equations" (xml_take (rules xml2name) xml_return))
      (\ a ->
        xml_take (xml_do "trs" (xml_take (rules xml2name) xml_return))
          (\ b -> xml_return (COMP_input a b))));

cPFsignature ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [(a, Nat)];
cPFsignature xml2name = symbols xml2name "signature";

complexity_measure ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Complexity_measure a [Char]);
complexity_measure xml2name =
  xml_or
    (xml_do "derivationalComplexity"
      (xml_take (cPFsignature xml2name)
        (\ a -> xml_return (Derivational_Complexity a))))
    (xml_do "runtimeComplexity"
      (xml_take (cPFsignature xml2name)
        (\ a ->
          xml_take (cPFsignature xml2name)
            (\ b -> xml_return (Runtime_Complexity a b)))));

complexity_class ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Complexity_class;
complexity_class = xml_change (xml_nat "polynomial") (xml_return . Comp_Poly);

forbidden_pattern ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (Ctxt a [Char], (Term a [Char], Location));
forbidden_pattern xml2name =
  xml_do "forbiddenPattern"
    (xml_take (term xml2name)
      (\ t ->
        xml_take pos
          (\ p ->
            xml_take
              (xml_or (xml_leaf "here" H)
                (xml_or (xml_leaf "above" A)
                  (xml_or (xml_leaf "below" Ba) (xml_leaf "below" Ra))))
              (\ l ->
                (if in_poss p t
                  then xml_return (ctxt_of_pos_term p t, (subt_at t p, l))
                  else xml_error "position does not exist in term")))));

forbidden_patterns ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       [(Ctxt a [Char], (Term a [Char], Location))];
forbidden_patterns xml2name =
  xml_do "forbiddenPatterns"
    (xml_take_many_sub [] zero_nat Infinity_enat (forbidden_pattern xml2name)
      xml_return);

replacement_map ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [((a, Nat), [Nat])];
replacement_map xml2name =
  xml_do "contextSensitive"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "replacementMapEntry"
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat "arity")
              (\ a ->
                xml_take_many_sub [] zero_nat Infinity_enat position
                  (\ is -> xml_return ((f, a), is))))))
      xml_return);

inn_fp_strategy ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (Sum (Strategy a [Char]) (Fp_strategy a [Char]));
inn_fp_strategy xml2name =
  xml_do "strategy"
    (xml_take
      (xml_or (xml_leaf "innermost" (Inl Innermost))
        (xml_or (xml_leaf "outermost" (Inr Outermost))
          (xml_or
            (xml_change (replacement_map xml2name)
              (\ p -> xml_return (Inr (Context_Sensitive p))))
            (xml_or
              (xml_change (forbidden_patterns xml2name)
                (\ p -> xml_return (Inr (Forbidden_Patterns p))))
              (xml_change (innermostLhss xml2name)
                (\ q -> xml_return (Inl (Innermost_Q q))))))))
      xml_return);

xml2_trs_input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
xml2_trs_input xml2name =
  xml_do "trsInput"
    (xml_take (xml_do "trs" (xml_take (rules xml2name) xml_return))
      (\ r ->
        xml_take_default (Inl No_Strategy) (inn_fp_strategy xml2name)
          (\ str ->
            xml_take_default []
              (xml_do "relativeRules" (xml_take (rules xml2name) xml_return))
              (\ rel ->
                (case str of {
                  Inl istrat -> xml_return (Inn_TRS_input istrat r rel Full);
                  Inr fpstrat ->
                    (if null rel then xml_return (FP_TRS_input fpstrat r)
                      else xml_error
                             "the combination of relative rules with strategies is only supported for innermost");
                })))));

xml2complexity_input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
xml2complexity_input xml2name =
  xml_do "complexityInput"
    (xml_take
      (xml_change (xml2_trs_input xml2name)
        (\ a ->
          (case a of {
            DP_input _ _ _ _ -> xml_error "require innermost trs at this point";
            Inn_TRS_input q r s start -> xml_return (q, (r, (s, start)));
            CPX_input _ _ _ _ _ ->
              xml_error "require innermost trs at this point";
            COMP_input _ _ -> xml_error "require innermost trs at this point";
            OCOMP_input _ _ _ _ ->
              xml_error "require innermost trs at this point";
            EQ_input _ _ -> xml_error "require innermost trs at this point";
            FP_TRS_input _ _ -> xml_error "require innermost trs at this point";
            CTRS_input _ -> xml_error "require innermost trs at this point";
            TA_input _ _ -> xml_error "require innermost trs at this point";
            AC_input _ _ _ -> xml_error "require innermost trs at this point";
            LTS_input _ -> xml_error "require innermost trs at this point";
            LTS_safety_input _ _ ->
              xml_error "require innermost trs at this point";
            Infeasibility_input _ _ ->
              xml_error "require innermost trs at this point";
            Unknown_input _ -> xml_error "require innermost trs at this point";
          })))
      (\ (q, (r, (s, _))) ->
        xml_take (complexity_measure xml2name)
          (\ cm ->
            xml_take complexity_class
              (\ cc -> xml_return (CPX_input q r s cm cc)))));

xml2unknown_input ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) [Char];
xml2unknown_input = xml_text "unknownInput";

lts_input_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Lts_impl Sig [Char] Ty [Char] [Char]);
lts_input_parser =
  lts_parser (location_parser xml_text) (trans_id xml_text) tatom_parsera "lts";

symbols_no_arity ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   String ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) [a];
symbols_no_arity xml2name tagname =
  xml_do tagname
    (xml_take_many_sub [] zero_nat Infinity_enat xml2name xml_return);

xml2ac_tp_input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
xml2ac_tp_input xml2name =
  xml_do "acRewriteSystem"
    (xml_take
      (xml_do "trs" (xml_take (rules xml2name) (\ x -> xml_return (id x))))
      (\ a ->
        xml_take (symbols_no_arity xml2name "Asymbols")
          (\ b ->
            xml_take (symbols_no_arity xml2name "Csymbols")
              (\ c -> xml_return (AC_input a b c)))));

xml2ctrs_input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
xml2ctrs_input xml2name =
  xml_do "ctrsInput"
    (xml_take
      (xml_do "rules"
        (xml_take_many_sub [] zero_nat Infinity_enat (crule xml2name "rule")
          xml_return))
      (\ a -> xml_return (CTRS_input a)));

xml2dp_input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
xml2dp_input xml2name =
  xml_do "dpInput"
    (xml_take
      (xml_do "trs" (xml_take (rules xml2name) (\ x -> xml_return (id x))))
      (\ r ->
        xml_take
          (xml_do "dps" (xml_take (rules xml2name) (\ x -> xml_return (id x))))
          (\ p ->
            xml_take_default No_Strategy (strategy xml2name)
              (\ s ->
                xml_take (xml_bool "minimal")
                  (\ m -> xml_return (DP_input m p s r))))));

xml2input ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Input a [Char]);
xml2input xml2name =
  xml_do "input"
    (xml_take
      (xml_or (xml2dp_input xml2name)
        (xml_or (xml2completion_input xml2name)
          (xml_or (xml2ordered_completion_input xml2name)
            (xml_or (xml2_trs_input xml2name)
              (xml_or (xml2equational_input xml2name)
                (xml_or (xml2complexity_input xml2name)
                  (xml_or (xml2ctrs_input xml2name)
                    (xml_or
                      (xml_do "treeAutomatonProblem"
                        (xml_take (tree_automaton (ta_normal_lhs xml2name))
                          (\ a ->
                            xml_take
                              (xml_do "trs"
                                (xml_take (rules xml2name)
                                  (\ x -> xml_return (id x))))
                              (\ b -> xml_return (TA_input a b)))))
                      (xml_or (xml2ac_tp_input xml2name)
                        (xml_or
                          (xml_change lts_input_parser (xml_return . LTS_input))
                          (xml_or
                            (xml_change lts_safety_input_parser
                              (\ (x, y) -> xml_return (LTS_safety_input x y)))
                            (xml_or (xml2infeasibility_input xml2name)
                              (xml_change xml2unknown_input
                                (xml_return . Unknown_input))))))))))))))
      (\ x -> xml_return (id x)));

bind2a ::
  forall a b.
    Sum_bot a b -> (a -> Cert_result) -> (b -> Cert_result) -> Cert_result;
bind2a (Sumbot a) f g = (case a of {
                          Inl aa -> f aa;
                          Inr aa -> g aa;
                        });

missing :: String -> (String -> String) -> String -> String;
missing s x =
  (((showsl_literal "the " . showsl_literal s) . showsl_literal " ") . x) .
    showsl_literal " is missing";

toomuch :: String -> (String -> String) -> String -> String;
toomuch s x = ((showsl_lit "superfluous " . showsl_lit s) . showsl_lit " ") . x;

array_get :: forall a. Array.Array a -> Nat -> a;
array_get (Array.Array a) n = nth a n;

array_set :: forall a. Array.Array a -> Nat -> a -> Array.Array a;
array_set (Array.Array aa) n a = Array.Array (list_update aa n a);

as_length :: forall a. (Array.Array a, Nat) -> Nat;
as_length = snd;

array_shrink :: forall a. Array.Array a -> Nat -> Array.Array a;
array_shrink (Array.Array a) sz =
  (if less_nat (size_list a) sz then error "undefined"
    else Array.Array (take sz a));

array_length :: forall a. Array.Array a -> Nat;
array_length (Array.Array a) = size_list a;

as_shrink :: forall a. (Array.Array a, Nat) -> (Array.Array a, Nat);
as_shrink s =
  let {
    a = s;
  } in (case a of {
         (aa, n) ->
           let {
             ab = (if less_eq_nat
                        (times_nat (nat_of_integer (128 :: Integer)) n)
                        (array_length aa) &&
                        less_nat (nat_of_integer (4 :: Integer)) n
                    then array_shrink aa n else aa);
           } in (ab, n);
       });

as_take :: forall a. Nat -> (Array.Array a, Nat) -> (Array.Array a, Nat);
as_take m s =
  let {
    a = s;
  } in (case a of {
         (aa, n) -> (if less_nat m n then as_shrink (aa, m) else (aa, n));
       });

as_top :: forall a. (Array.Array a, Nat) -> a;
as_top s = let {
             a = s;
           } in (case a of {
                  (aa, n) -> array_get aa (minus_nat n one_nat);
                });

as_pop :: forall a. (Array.Array a, Nat) -> (Array.Array a, Nat);
as_pop s = let {
             a = s;
           } in (case a of {
                  (aa, n) -> as_shrink (aa, minus_nat n one_nat);
                });

as_get :: forall a. (Array.Array a, Nat) -> Nat -> a;
as_get s i = let {
               a = s;
             } in (case a of {
                    (aa, _) -> array_get aa i;
                  });

while :: forall a. (a -> Bool) -> (a -> a) -> a -> a;
while b c s = (if b s then while b c (c s) else s);

pop_tr ::
  forall a.
    (Compare_order a) => ((Array.Array a, Nat),
                           ((Array.Array Nat, Nat),
                             (Rbta a Int, (Array.Array (Nat, [a]), Nat)))) ->
                           ((Array.Array a, Nat),
                             ((Array.Array Nat, Nat),
                               (Rbta a Int, (Array.Array (Nat, [a]), Nat))));
pop_tr s =
  (case s of {
    (a, (aa, (ab, bb))) ->
      let {
        x = minus_nat (as_length aa) one_nat;
        xa = (case while (\ (xe, _) ->
                           less_nat xe
                             (if equal_nat (plus_nat x one_nat) (as_length aa)
                               then as_length a
                               else as_get aa (plus_nat x one_nat)))
                     (\ (ac, bc) ->
                       (suc ac,
                         rbt_insert (as_get a ac) (uminus_int one_int) bc))
                     (as_get aa x, ab)
               of {
               (_, bc) -> bc;
             });
        xb = as_take (as_top aa) a;
        xc = as_pop aa;
      } in (xb, (xc, (xa, bb)));
  });

gen_disjoint ::
  forall a b c d e f.
    (a -> (b -> b) -> (c -> d -> Bool) -> Bool -> e) ->
      (c -> f -> Bool) -> a -> f -> e;
gen_disjoint it1 mem2 s1 s2 = it1 s1 (\ x -> x) (\ x _ -> not (mem2 x s2)) True;

is_NF_subset :: forall a b. (Term a b -> Bool) -> [Term a b] -> Bool;
is_NF_subset is_Q_nf q = all (\ qa -> not (is_Q_nf qa)) q;

icap_impl_gen ::
  forall a.
    (Eq a) => Bool ->
                (Term a [Char] -> Bool) ->
                  [Term a [Char]] ->
                    [Term a [Char]] ->
                      ([Char] -> Bool) ->
                        Term a [Char] -> Term a (Sum () [Char]);
icap_impl_gen nf isQnf ls s sx (Var x) =
  (if nf && sx x then Var (Inr x) else Var (Inl ()));
icap_impl_gen nf isQnf ls s sx (Fun f ts) =
  let {
    t = Fun f (map (icap_impl_gen nf isQnf ls s sx) ts);
  } in (if any (\ l ->
                 (case mgu_class t l of {
                   Nothing -> False;
                   Just mu ->
                     all (\ u ->
                           isQnf (subst_apply_term
                                   (map_term (\ x -> x)
                                     (\ a ->
                                       Char True False False True True True True
 False :
 a)
                                     u)
                                   mu))
                       (args l) &&
                       all (\ u -> isQnf (subst_apply_term u mu)) s;
                 }))
             ls
         then Var (Inl ()) else t);

ins_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
ins_rm_basic_ops x s = insert x () s;

g_from_list_aux_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> [a] -> Rbt a ();
g_from_list_aux_dflt_basic_oops_rm_basic_ops accs (x : l) =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops (ins_rm_basic_ops x accs) l;
g_from_list_aux_dflt_basic_oops_rm_basic_ops y [] = y;

empty_rm_basic_ops :: forall a. (Linorder a) => () -> Rbt a ();
empty_rm_basic_ops = (\ _ -> empty);

g_from_list_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => [a] -> Rbt a ();
g_from_list_dflt_basic_oops_rm_basic_ops l =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops (empty_rm_basic_ops ()) l;

memb_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Bool;
memb_rm_basic_ops x s = not (is_none (lookup s x));

ceta_set_of :: forall a. (Compare_order a) => [a] -> a -> Bool;
ceta_set_of ps = let {
                   tree = g_from_list_dflt_basic_oops_rm_basic_ops ps;
                 } in (\ a -> memb_rm_basic_ops a tree);

icap_impl ::
  forall a.
    (Eq a) => (Term a [Char] -> Bool) ->
                [(Term a [Char], Term a [Char])] ->
                  [Term a [Char]] -> Term a [Char] -> Term a (Sum () [Char]);
icap_impl isnf r =
  let {
    ls = map fst r;
    nf = is_NF_subset isnf ls;
    ic = icap_impl_gen nf isnf ls;
  } in (\ s ->
         let {
           sa = map (map_term (\ x -> x)
                      (\ a ->
                        Char False False False True True True True False : a))
                  s;
           sx = ceta_set_of (concatMap vars_term_list sa);
         } in (\ t ->
                ic sa sx
                  (map_term (\ x -> x)
                    (\ a ->
                      Char False False False True True True True False : a)
                    t)));

rep_subst_incr ::
  forall a b. Subst_incr a b -> (b -> Term a b, (Set b, Term a b -> [b]));
rep_subst_incr (Abs_subst_incr x) = x;

si_W :: forall a b. Subst_incr a b -> Term a b -> [b];
si_W xa = snd (snd (rep_subst_incr xa));

kbo_nstrict ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool)) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        (a -> Bool) ->
                          ((a, Nat) -> Nat -> Nat) ->
                            (Term a b, Term a b) -> Sum (String -> String) ();
kbo_nstrict pr w w0 least scf =
  (\ (s, t) ->
    check (snd (kbo_impl w w0 pr least scf s t))
      ((((showsl_literal "could not orient " . showsl_terma s) .
          showsl_literal " >=KBO ") .
         showsl_terma t) .
        showsl_literal "\n"));

succ_transitions ::
  forall a b c d e.
    (Eq d) => Lts_impl a b c d e -> d -> [Transition_rule a b c d];
succ_transitions (Lts_Impl i ts lc) l =
  concatMap (\ (_, tau) -> (if source tau == l then [tau] else [])) ts;

default_I :: forall a. (Poly_carrier a) => a -> Nat -> [(Monom Nat, a)];
default_I def n =
  (one_monom, def) : map (\ i -> (var_monom i, onea)) (upt zero_nat n);

proper_prefix_list :: [Nat] -> [[Nat]];
proper_prefix_list [] = [];
proper_prefix_list (i : p) = [] : map (\ a -> i : a) (proper_prefix_list p);

prefix_list :: [Nat] -> [[Nat]];
prefix_list p = p : proper_prefix_list p;

scnp_arity :: forall a. [((a, Nat), [(Nat, Nat)])] -> Nat;
scnp_arity af = max_list (map (\ (_, a) -> size_list a) af);

check_supt ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => Term a b -> Term a b -> Sum (String -> String) ();
check_supt s t =
  check (supt_impl s t)
    ((showsl_terma t . showsl_literal " is not a proper subterm of ") .
      showsl_terma s);

sharp_term :: forall a b. (a -> a) -> Term a b -> Term a b;
sharp_term shp (Var x) = Var x;
sharp_term shp (Fun f ss) = Fun (shp f) ss;

compute_trancl ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Set_impl a) => Set a -> Set (a, a) -> Set a;
compute_trancl a r =
  let {
    b = imagea r a;
  } in (if less_eq_set b bot_set then bot_set
         else sup_set b
                (compute_trancl b
                  (filtera
                    (\ ab -> not (member (fst ab) a) && not (member (snd ab) b))
                    r)));

ta_res ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b () -> Term b a -> Set a;
ta_res ta (Fun f ts) =
  let {
    qs = map (ta_res ta) ts;
    g = (f, size_list ts);
  } in sup_set
         (image r_rhs
           (filtera
             (\ r ->
               r_sym r == g &&
                 all (\ qq -> member (snd qq) (fst qq))
                   (zip qs (r_lhs_states r)))
             (ta_rules ta)))
         (compute_trancl
           (image r_rhs
             (filtera
               (\ r ->
                 r_sym r == g &&
                   all (\ qq -> member (snd qq) (fst qq))
                     (zip qs (r_lhs_states r)))
               (ta_rules ta)))
           (ta_eps ta));
ta_res ta (Var q) =
  sup_set (inserta q bot_set) (compute_trancl (inserta q bot_set) (ta_eps ta));

eq_rule_mod_vars ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b, Term a b) -> (Term a b, Term a b) -> Bool;
eq_rule_mod_vars lr st = instance_rule lr st && instance_rule st lr;

is_NF_terms ::
  forall a b.
    (Compare_order a, Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> Term a b -> Bool;
is_NF_terms q = is_NF_main (any is_Var q) (null q) (term_map q);

generate_var :: Nat -> [Char];
generate_var i =
  Char False False False True True True True False :
    shows_prec_nat zero_nat i [];

uncurry_term ::
  forall a b. (Eq a) => a -> (a -> Nat -> [a]) -> Term a b -> Term a b;
uncurry_term a sm t =
  (case unapp a t of {
    (Var x, ts) -> apply_args a (Var x) (map (uncurry_term a sm) ts);
    (Fun f ss, ts) ->
      let {
        n = size_list ss;
        uss = map (uncurry_term a sm) ss;
        uts = map (uncurry_term a sm) ts;
        aa = aarity sm f n;
        m = min (size_list ts) aa;
        fm = get_symbol sm f n m;
      } in apply_args a (Fun fm (uss ++ take m uts)) (drop m uts);
  });

showsl_funa :: forall a. (Showl a) => (a, Nat) -> String -> String;
showsl_funa (f, n) = (showsl f . showsl_lit "/") . showsl_nat n;

xml2claim ::
  forall a b.
    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) (Claim a b);
xml2claim =
  xml_or
    (xml_do "terminating"
      (xml_take_optional
        (xml_do "upperbound"
          (xml_take
            (xml_do "polynomial"
              (xml_take_attribute "degree"
                (\ deg_s -> (case nat_of_string deg_s of {
                              Inl a -> xml_error a;
                              Inr deg -> xml_return (Upperbound deg);
                            }))))
            xml_return))
        (\ a -> (case a of {
                  Nothing -> xml_return Terminating;
                  Just aa -> xml_return aa;
                }))))
    (xml_or (xml_leaf "nonterminating" Nonterminating)
      (xml_or (xml_leaf "confluent" Confluent)
        (xml_leaf "nonconfluent" Nonconfluent)));

conversion ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (Term a [Char],
                         [([Nat],
                            ((Term a [Char], Term a [Char]),
                              (Bool, Term a [Char])))]);
conversion xml2name =
  xml_do "conversion"
    (xml_take
      (xml_do "startTerm" (xml_take (term xml2name) (\ x -> xml_return (id x))))
      (\ a ->
        xml_take_many_sub [] zero_nat Infinity_enat (estep xml2name)
          (\ b -> xml_return (a, b))));

plain_name ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Lab [Char] [Nat]);
plain_name x =
  xml_or (xml_change (xml_text "name") (xml_return . UnLab))
    (xml_or
      (xml_do "sharp" (xml_take plain_name (\ xa -> xml_return (Sharp xa))))
      (xml_do "labeledSymbol"
        (xml_take plain_name
          (\ a ->
            xml_take
              (xml_or
                (xml_do "numberLabel"
                  (xml_take_many_sub [] zero_nat Infinity_enat
                    (xml_nat "number") (\ aa -> xml_return (Inl aa))))
                (xml_do "symbolLabel"
                  (xml_take_many_sub [] zero_nat Infinity_enat plain_name
                    (\ aa -> xml_return (Inr aa)))))
              (\ b -> xml_return (case b of {
                                   Inl ba -> Lab a ba;
                                   Inr ba -> FunLab a ba;
                                 }))))))
    x;

level_mapping ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [((a, Nat), [(Nat, Nat)])];
level_mapping xml2name =
  xml_do "levelMapping"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "levelMappingEntry"
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat "arity")
              (\ a ->
                xml_take_many_sub [] zero_nat Infinity_enat
                  (xml_do "positionLevelEntry"
                    (xml_take (xml_nat "position")
                      (\ aa ->
                        xml_take (xml_nat "level")
                          (\ b -> xml_return (aa, b)))))
                  (\ ps ->
                    xml_return
                      ((f, a),
                        map (\ (p, b) ->
                              ((if equal_nat p zero_nat then a
                                 else minus_nat p one_nat),
                                b))
                          ps))))))
      xml_return);

redtriplea ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   Bool ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String)
                         (Sum (Root_redtriple_impl a) (Redtriple_impl a));
redtriplea xml2name bi =
  xml_do "redPair"
    (xml_take
      (xml_or
        (xml_do "scnp"
          (xml_take
            (xml_do "status"
              (xml_take
                (xml_or (xml_leaf "ms" MS_Ext)
                  (xml_or (xml_leaf "min" Min_Ext)
                    (xml_or (xml_leaf "dms" Dms_Ext) (xml_leaf "max" Max_Ext))))
                xml_return))
            (\ a ->
              xml_take (level_mapping xml2name)
                (\ b ->
                  xml_take
                    (xml_do "redPair"
                      (xml_take (redtriple xml2name False)
                        (\ x -> xml_return (id x))))
                    (\ c -> xml_return (Inl (SCNP a b c)))))))
        (xml_change (redtriple xml2name bi) (xml_return . Inr)))
      xml_return);

rule_pairs ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   String ->
                     String ->
                       (Xml, ([([Char], [Char])],
                               (Bool, ([String], [String])))) ->
                         Sum_bot (Xml_error String)
                           [((Term a [Char], Term a [Char]),
                              (Term a [Char], Term a [Char]))];
rule_pairs xml2name s p =
  xml_do s
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do p
        (xml_take (rule xml2name)
          (\ a -> xml_take (rule xml2name) (\ b -> xml_return (a, b)))))
      xml_return);

sl_variant ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Sl_variant a [Char]);
sl_variant xml2name =
  xml_do "model"
    (xml_take
      (xml_or
        (xml_do "rootLabeling"
          (xml_take_optional xml2name
            (\ fo -> xml_return (Rootlab (case fo of {
   Nothing -> Nothing;
   Just f -> Just (f, one_nat);
 })))))
        (xml_do "finiteModel"
          (xml_take
            (xml_change (xml_nat "carrierSize")
              (\ n -> xml_return (minus_nat n one_nat)))
            (\ n ->
              xml_take_optional
                (xml_do "tupleOrder"
                  (xml_take (xml_leaf "pointWise" ())
                    (\ x -> xml_return (id x))))
                (\ to ->
                  xml_take_many_sub [] zero_nat Infinity_enat
                    (xml_do "interpret"
                      (xml_take xml2name
                        (\ a ->
                          xml_take (xml_nat "arity")
                            (\ b ->
                              xml_take arith_fun
                                (\ c -> xml_return ((a, b), c))))))
                    (\ inter ->
                      xml_return
                        (case to of {
                          Nothing -> Finitelab (SL_Inter n inter);
                          Just _ -> QuasiFinitelab (SL_Inter n inter) [];
                        })))))))
      (\ x -> xml_return (id x)));

array_grow :: forall a. Array.Array a -> Nat -> a -> Array.Array a;
array_grow (Array.Array a) inc x = Array.Array (a ++ replicate inc x);

diff_by_label ::
  forall a b. (Ceq a, Ccompare a) => [(a, b)] -> Set a -> [(a, b)];
diff_by_label pairs l = filter (\ v -> not (member (fst v) l)) pairs;

formula_pos_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Nat;
formula_pos_parser =
  xml_or (xml_do "conclusion" (xml_return zero_nat))
    (xml_or (xml_do "assertion" (xml_return (nat_of_integer (2 :: Integer))))
      (xml_or (xml_do "transition" (xml_return (nat_of_integer (3 :: Integer))))
        (xml_do "targetAssertion"
          (xml_return (nat_of_integer (4 :: Integer))))));

hints_parser ::
  forall a.
    (Default a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) a) ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) (Hint a);
hints_parser hint_parser xml =
  xml_or (xml_do "auto" (xml_return default_hint))
    (xml_or
      (xml_do "distribute"
        (xml_take formula_pos_parser
          (\ pos ->
            xml_take_many_sub [] zero_nat Infinity_enat
              (hints_parser hint_parser)
              (\ hints -> xml_return (Distribute pos hints)))))
      (xml_or
        (xml_do "erase"
          (xml_take formula_pos_parser
            (\ pos ->
              xml_take (hints_parser hint_parser)
                (\ hint -> xml_return (Erase pos hint)))))
        (xml_or
          (xml_do "lexWeak"
            (xml_take_many_sub [] zero_nat Infinity_enat
              (hints_parser hint_parser)
              (\ hints -> xml_return (LexWeak hints))))
          (xml_or
            (xml_do "lexStrict"
              (xml_take_many_sub [] zero_nat Infinity_enat
                (hints_parser hint_parser)
                (\ hints -> xml_return (LexStrict hints))))
            (xml_change hint_parser (xml_return . Base))))))
    xml;

art_node_parser ::
  forall a b c d e f g.
    (Default g) => (String ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) a) ->
                     ((Xml, ([([Char], [Char])],
                              (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) b) ->
                       ((Xml, ([([Char], [Char])],
                                (Bool, ([String], [String])))) ->
                         Sum_bot (Xml_error String) c) ->
                         ((Xml, ([([Char], [Char])],
                                  (Bool, ([String], [String])))) ->
                           Sum_bot (Xml_error String)
                             (Formula (Term d (e, f)))) ->
                           ((Xml, ([([Char], [Char])],
                                    (Bool, ([String], [String])))) ->
                             Sum_bot (Xml_error String) g) ->
                             (Xml, ([([Char], [Char])],
                                     (Bool, ([String], [String])))) ->
                               Sum_bot (Xml_error String)
                                 (Art_node_impl d e f b a c (Hint g), [a]);
art_node_parser art_node_id_parser location_parser trans_parser atom_parser
  hint_parser =
  xml_do "node"
    (xml_take_default False (xml_do "initial" (xml_return True))
      (\ init ->
        xml_take (art_node_id_parser "nodeId")
          (\ nodeId ->
            xml_take
              (xml_do "invariant"
                (xml_take (formula_parser atom_parser) xml_return))
              (\ invariant ->
                xml_take
                  (xml_do "location" (xml_take location_parser xml_return))
                  (\ location ->
                    xml_take
                      (xml_or
                        (xml_do "children"
                          (xml_take_many_sub [] zero_nat Infinity_enat
                            (xml_do "child"
                              (xml_take trans_parser
                                (\ tr ->
                                  xml_take (art_node_id_parser "nodeId")
                                    (\ n ->
                                      xml_take_default default_hint
(xml_do "hints" (xml_take (hints_parser hint_parser) xml_return))
(\ h -> xml_return (tr, (n, h)))))))
                            (\ chs -> xml_return (Children_Edge chs))))
                        (xml_do "coverEdge"
                          (xml_take (art_node_id_parser "nodeId")
                            (\ n ->
                              xml_take_default default_hint
                                (xml_do "hints"
                                  (xml_take (hints_parser hint_parser)
                                    xml_return))
                                (\ h -> xml_return (Cover_Edge n h))))))
                      (\ edges ->
                        xml_return
                          (Art_Node nodeId invariant location edges,
                            (if init then [nodeId] else []))))))));

art_parser ::
  forall a b c d e f g.
    (Default g) => (String ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) a) ->
                     ((Xml, ([([Char], [Char])],
                              (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) b) ->
                       ((Xml, ([([Char], [Char])],
                                (Bool, ([String], [String])))) ->
                         Sum_bot (Xml_error String) c) ->
                         ((Xml, ([([Char], [Char])],
                                  (Bool, ([String], [String])))) ->
                           Sum_bot (Xml_error String)
                             (Formula (Term d (e, f)))) ->
                           ((Xml, ([([Char], [Char])],
                                    (Bool, ([String], [String])))) ->
                             Sum_bot (Xml_error String) g) ->
                             (Xml, ([([Char], [Char])],
                                     (Bool, ([String], [String])))) ->
                               Sum_bot (Xml_error String)
                                 (Art_impl_ext d e f b a c (Hint g) ());
art_parser art_node_id_parser location_parser trans_parser atom_parser
  hint_parser =
  xml_do "impact"
    (xml_take_default []
      (xml_change (art_node_id_parser "initial") (\ x -> xml_return [x]))
      (\ init ->
        xml_take
          (xml_do "nodes"
            (xml_take_many_sub [] zero_nat Infinity_enat
              (art_node_parser art_node_id_parser location_parser trans_parser
                atom_parser hint_parser)
              xml_return))
          (\ pairs -> let {
                        nodes = map fst pairs;
                        inits = init ++ concatMap snd pairs;
                      } in xml_return (Art_impl_ext inits nodes ()))));

exp_parsera ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Term Sig ([Char], Ty));
exp_parsera = exp_parserb variable_parser;

check_prop_rstep_rule ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => Bool ->
                    (Term a b -> Sum (String -> String) ()) ->
                      [Nat] ->
                        (Term a b, Term a b) ->
                          Term a b -> Term a b -> Sum (String -> String) ();
check_prop_rstep_rule nfs pa p rule s t =
  bindb (check (in_poss p s)
          (((showsl_pos p . showsl_literal " is not a position of ") .
             showsl_terma s) .
            showsl_literal "\n"))
    (\ _ ->
      bindb (check (in_poss p t)
              (((showsl_pos p . showsl_literal " is not a position of ") .
                 showsl_terma t) .
                showsl_literal "\n"))
        (\ _ ->
          let {
            c = ctxt_of_pos_term p s;
            d = ctxt_of_pos_term p t;
            u = subt_at s p;
            v = subt_at t p;
          } in (case match_list Var [(fst rule, u), (snd rule, v)] of {
                 Nothing ->
                   Inl ((((((showsl_literal "the term " . showsl_terma t) .
                             showsl_literal
                               " does not result from a proper application of rule\n") .
                            showsl_rule rule) .
                           showsl_literal " at position ") .
                          showsl_pos p) .
                         showsl_literal "\n");
                 Just tau ->
                   bindb (catch_errora
                           (forallM pa
                             (args u ++
                               (if nfs then map tau (vars_rule_list rule)
                                 else [])))
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       check (equal_ctxt c d)
                         ((((((showsl_literal "the term " . showsl_terma t) .
                               showsl_literal
                                 " does not result from a proper application of rule\n") .
                              showsl_rule rule) .
                             showsl_literal " at position ") .
                            showsl_pos p) .
                           showsl_literal "\n"));
               })));

check_prop_rstep ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => Bool ->
                    (Term a b -> Sum (String -> String) ()) ->
                      [(Term a b, Term a b)] ->
                        [Nat] ->
                          (Term a b, Term a b) ->
                            Term a b -> Term a b -> Sum (String -> String) ();
check_prop_rstep nfs pa r p rule s t =
  check (any (\ ra ->
               eq_rule_mod_vars rule ra &&
                 isOK (check_prop_rstep_rule nfs pa p ra s t))
          r)
    ((((((((showsl_literal "the step from " . showsl_terma s) .
            showsl_literal " to ") .
           showsl_terma t) .
          showsl_literal " via rule ") .
         showsl_rule rule) .
        showsl_literal " at position ") .
       showsl_pos p) .
      showsl_literal " is problematic\n");

check_qrstep ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [Nat] ->
                          (Term a b, Term a b) ->
                            Term a b -> Term a b -> Sum (String -> String) ();
check_qrstep nf nfs =
  check_prop_rstep nfs
    (\ t ->
      check (nf t)
        (showsl_terma t . showsl_literal " is not in Q-normal form"));

check_rqrstep ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        (Term a b, Term a b) ->
                          Term a b -> Term a b -> Sum (String -> String) ();
check_rqrstep nf nfs r rule s t = check_qrstep nf nfs r [] rule s t;

check_qsteps ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          [([Nat], ((Term a b, Term a b), (Bool, Term a b)))] ->
                            Term a b -> Term a b -> Sum (String -> String) ();
check_qsteps nf nfs p r [] s u =
  check (equal_term s u)
    ((((showsl_literal "the last term of the rewrite sequence\n" .
         showsl_terma s) .
        showsl_literal "\ndoes not correspond to the goal term\n") .
       showsl_terma u) .
      showsl_literal "\n");
check_qsteps nf nfs p ra ((uu, (r, (True, t))) : prts) s u =
  bindb (check_rqrstep nf nfs p r s t)
    (\ _ -> check_qsteps nf nfs p ra prts t u);
check_qsteps nf nfs pa ra ((p, (r, (False, t))) : prts) s u =
  bindb (check_qrstep nf nfs ra p r s t)
    (\ _ -> check_qsteps nf nfs pa ra prts t u);

check_qrsteps ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [([Nat], ((Term a b, Term a b), Term a b))] ->
                          Term a b -> Term a b -> Sum (String -> String) ();
check_qrsteps nf nfs r prts s u =
  check_qsteps nf nfs [] r (map (\ (p, (ra, t)) -> (p, (ra, (False, t)))) prts)
    s u;

check_qrstep_subst ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [Nat] ->
                          (Term a b, Term a b) ->
                            Term a b -> Term a b -> Sum (String -> String) ();
check_qrstep_subst cni nfs =
  let {
    main =
      check_prop_rstep nfs
        (\ t ->
          catch_errora (cni t)
            (\ _ ->
              Inl (showsl_terma t .
                    showsl_lit " mu ^^ i is not in Q-normal form for all i")));
  } in (\ r p ra s t ->
         bindb (check (not (is_Var (fst ra)))
                 (showsl_lit "loop check requires lhss to be non-variable"))
           (\ _ -> main r p ra s t));

check_rqrstep_subst ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        (Term a b, Term a b) ->
                          Term a b -> Term a b -> Sum (String -> String) ();
check_rqrstep_subst cni nfs = (\ r -> check_qrstep_subst cni nfs r []);

check_qsteps_subst ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          [([Nat], ((Term a b, Term a b), (Bool, Term a b)))] ->
                            Term a b -> Term a b -> Sum (String -> String) ();
check_qsteps_subst cni nfs p r [] s u =
  check (equal_term s u)
    ((((showsl_lit "the last term of the rewrite sequence\n" . showsl_terma s) .
        showsl_lit "\ndoes not correspond to the goal term\n") .
       showsl_terma u) .
      showsl_literal "\n");
check_qsteps_subst cni nfs p ra ((uu, (r, (True, t))) : prts) s u =
  bindb (check_rqrstep_subst cni nfs p r s t)
    (\ _ -> check_qsteps_subst cni nfs p ra prts t u);
check_qsteps_subst cni nfs pa ra ((p, (r, (False, t))) : prts) s u =
  bindb (check_qrstep_subst cni nfs ra p r s t)
    (\ _ -> check_qsteps_subst cni nfs pa ra prts t u);

check_qrsteps_subst ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [([Nat], ((Term a b, Term a b), Term a b))] ->
                          Term a b -> Term a b -> Sum (String -> String) ();
check_qrsteps_subst cni nfs r prts s u =
  check_qsteps_subst cni nfs [] r
    (map (\ (p, (ra, t)) -> (p, (ra, (False, t)))) prts) s u;

si_subst :: forall a b. Subst_incr a b -> b -> Term a b;
si_subst xa = fst (rep_subst_incr xa);

match_prob_of_rp_impl ::
  forall a b.
    (Eq a,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> [(Term a b, Term a b)];
match_prob_of_rp_impl mu (t, Var x) = [(t, Var x)];
match_prob_of_rp_impl mu (t, Fun v va) =
  let {
    sterms = remdups (t : map (si_subst mu) (si_W mu t));
    uterms = concatMap (filter (\ ta -> not (is_Var ta)) . supteq_list) sterms;
  } in map (\ u -> (u, Fun v va)) (remdups uterms);

si_v_incr :: forall a b. Subst_incr a b -> Set b;
si_v_incr xa = fst (snd (rep_subst_incr xa));

simplify_mp ::
  forall a b.
    (Eq a, Ceq b,
      Ccompare b) => Subst_incr a b ->
                       [(Term a b, Term a b)] ->
                         [(Term a b, Term a b)] ->
                           Maybe ([(Term a b, Term a b)], Nat);
simplify_mp mu_incr ((Var x, Fun f ls) : mp) solved =
  bind (guard (member x (si_v_incr mu_incr)))
    (\ _ ->
      let {
        m = map (\ (s, a) -> (subst_apply_term s (si_subst mu_incr), a));
      } in bind (simplify_mp mu_incr (m ((Var x, Fun f ls) : mp)) (m solved))
             (\ (smp, i) -> Just (smp, suc i)));
simplify_mp mu_incr ((Fun g ts, Fun f ls) : mp) solved =
  bind (guard (f == g))
    (\ _ ->
      bind (zip_option ts ls)
        (\ pairs -> simplify_mp mu_incr (pairs ++ mp) solved));
simplify_mp mu_incr ((s, Var x) : mp) solved =
  simplify_mp mu_incr mp ((s, Var x) : solved);
simplify_mp mu_incr [] solved = Just (solved, zero_nat);

conflicts ::
  forall a b.
    (Eq a,
      Eq b) => (a -> Term b a) ->
                 (Term b a, (Term b a, Nat)) -> [(Term b a, (Term b a, Nat))];
conflicts mu (Fun f ts, (Fun g ss, n)) =
  (if f == g && equal_nat (size_list ts) (size_list ss)
    then concatMap (\ (s, t) -> conflicts mu (s, (t, n))) (zip ts ss)
    else [(Fun f ts, (Fun g ss, n))]);
conflicts mu (Var x, (Fun g ss, n)) = [(Var x, (Fun g ss, n))];
conflicts mu (Fun f ts, (Var y, n)) =
  (if equal_nat n zero_nat then [(Var y, (Fun f ts, zero_nat))]
    else conflicts mu (Fun f ts, (mu y, minus_nat n one_nat)));
conflicts mu (Var x, (Var y, n)) =
  (if equal_nat n zero_nat
    then (if x == y then [] else [(Var x, (Var y, zero_nat))])
    else conflicts mu (Var x, (mu y, minus_nat n one_nat)));

ident_solvea ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b ->
                 Set (Term a b, (Term a b, Nat)) ->
                   (Term a b, (Term a b, Nat)) -> Maybe Nat;
ident_solvea mu_incr cps st =
  let {
    cp = conflicts (si_subst mu_incr) st;
  } in (if any (\ (u, (_, _)) -> not (is_Var u)) cp then Nothing
         else (if any (\ (u, (v, _)) ->
                        member (u, v) (image (\ (ua, (va, _)) -> (ua, va)) cps))
                    cp
                then Nothing
                else bind (mapMa
                            (\ (u, (v, m)) ->
                              ident_solvea mu_incr (inserta (u, (v, m)) cps)
                                (subst_apply_term u (si_subst mu_incr),
                                  (v, suc m)))
                            (conflicts (si_subst mu_incr) st))
                       (\ is -> Just (max_list (map suc is)))));

ident_solve ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Maybe Nat;
ident_solve mu_incr =
  (\ (s, t) ->
    ident_solvea mu_incr
      (set_empty
        (of_phantom
          (set_impl_prod :: Phantom (Term a b, (Term a b, Nat)) Set_impla)))
      (s, (t, zero_nat)));

ident_decision ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
ident_decision sigma ip = not (is_none (ident_solve sigma ip));

ident_prob_of_smp ::
  forall a b. (Eq a, Eq b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)];
ident_prob_of_smp [] = [];
ident_prob_of_smp ((t, l) : other) =
  map_filter
    (\ x ->
      (if (case x of {
            (_, s) -> equal_term s l;
          })
        then Just (case x of {
                    (s, _) -> (t, s);
                  })
        else Nothing))
    other ++
    ident_prob_of_smp other;

gmatch_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> [(Term a b, Term a b)] -> Bool;
gmatch_decision sigma mp =
  not (is_none
        (bind (simplify_mp sigma mp [])
          (\ (smp, _) ->
            guard (all (ident_decision sigma) (ident_prob_of_smp smp)))));

match_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
match_decision mu mp = gmatch_decision mu [mp];

redex_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
redex_decision mu rp = any (match_decision mu) (match_prob_of_rp_impl mu rp);

new_as :: forall a b. (a -> b -> Bool) -> [a] -> [b] -> [b];
new_as p bs asa = filter (\ a -> any (\ b -> p b a) bs) asa;

list_diff :: forall a. (Eq a) => [a] -> [a] -> [a];
list_diff [] ys = [];
list_diff (x : xs) ys = let {
                          zs = list_diff xs ys;
                        } in (if membera ys x then zs else x : zs);

the_set_impl_main ::
  forall a b.
    (Eq a, Eq b) => (a -> b -> Bool) -> (b -> [a]) -> [b] -> [b] -> [a] -> [b];
the_set_impl_main p q remain have bs =
  let {
    new = new_as p bs remain;
  } in (if null new then have
         else the_set_impl_main p q (list_diff remain new) (new ++ have)
                (remdups (concatMap q new)));

the_set_impl ::
  forall a b.
    (Eq a, Eq b) => [a] -> (b -> a -> Bool) -> (a -> [b]) -> [b] -> [a];
the_set_impl r p q bs = the_set_impl_main p q r [] bs;

inductive_set_impl ::
  forall a b.
    (Eq a, Eq b) => [a] -> (b -> a -> Bool) -> (a -> [b]) -> [b] -> [a];
inductive_set_impl = the_set_impl;

v_incr_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
v_incr_impl mu =
  inductive_set_impl (map fst mu) (\ a b -> a == b)
    (\ x ->
      concatMap (\ (y, t) -> (if equal_term t (Var x) then [y] else [])) mu)
    (concatMap (\ (y, t) -> (if not (is_Var t) then [y] else [])) mu);

rtrancl_impl ::
  forall a b.
    ([(a, a)] -> [a] -> [a]) ->
      ([a] -> b -> b) -> (a -> b -> Bool) -> b -> [(a, a)] -> [a] -> b;
rtrancl_impl gen_succ un memb emp rel =
  let {
    succ = gen_succ rel;
    n = size_list rel;
  } in (\ asa -> relpow_impl succ un memb asa emp n);

rtrancl_list_impl :: forall a. (Eq a) => [(a, a)] -> [a] -> [a];
rtrancl_list_impl =
  rtrancl_impl
    (\ r asa ->
      remdups
        (map_filter
          (\ x ->
            (if (case x of {
                  (a, _) -> membera asa a;
                })
              then Just (snd x) else Nothing))
          r))
    (\ xs ys -> filter (\ x -> not (membera ys x)) xs ++ ys)
    (\ x xs -> membera xs x) [];

w_impl :: forall a b. (Eq a) => [(a, Term b a)] -> Term b a -> [a];
w_impl d =
  let {
    filt = filter (\ (x, y) -> not (x == y));
    xvs = concatMap (\ (x, t) -> map (\ a -> (x, a)) (vars_term_list t)) d;
    rel = filt xvs;
    rtran = rtrancl_list_impl rel;
  } in (\ t -> rtran (vars_term_list t));

subst_incr ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq b) => [(a, Term b a)] -> Subst_incr b a;
subst_incr xa =
  Abs_subst_incr (let {
                    dom = mk_subst_domain xa;
                  } in (mk_subst Var xa, (set (v_incr_impl dom), w_impl dom)));

redex_rps_decision ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] ->
                 [(Term b a, Term b a)] -> Sum (Term b a, Term b a) ();
redex_rps_decision mu =
  let {
    mua = subst_incr mu;
    main = redex_decision mua;
  } in (\ xs ->
         catch_errora (forallM (\ tl -> check (not (main tl)) tl) xs)
           (\ x -> Inl (snd x)));

check_NF_iteration ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] ->
                 [Term b a] -> Term b a -> Sum (Term b a, Term b a) ();
check_NF_iteration mu = let {
                          dec = redex_rps_decision mu;
                        } in (\ q t -> dec (map (\ a -> (t, a)) q));

check_loop ::
  forall a b.
    (Compare a, Eq a, Showl a, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showl b) => [Term a b] ->
                    Bool ->
                      Term a b ->
                        [([Nat], ((Term a b, Term a b), Term a b))] ->
                          [(b, Term a b)] ->
                            Ctxt a b ->
                              [(Term a b, Term a b)] ->
                                Sum (String -> String) ();
check_loop q nfs s rseq sigma c r =
  bindb (check (not (null rseq))
          (showsl_lit "rewrite sequence must be non-empty"))
    (\ _ ->
      (if null q
        then check_qrsteps (\ _ -> True) nfs r rseq s
               (ctxt_apply_term c (subst_apply_term s (mk_subst Var sigma)))
        else check_qrsteps_subst (check_NF_iteration sigma q) nfs r rseq s
               (ctxt_apply_term c (subst_apply_term s (mk_subst Var sigma)))));

min_list :: forall a. (Linorder a) => [a] -> a;
min_list [x] = x;
min_list (x : v : va) = min x (min_list (v : va));

nth_default :: forall a. a -> [a] -> Nat -> a;
nth_default dflt xs n = (if less_nat n (size_list xs) then nth xs n else dflt);

delete_value ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> a -> Rbt b [a] -> Rbt b [a];
delete_value key v m = (case key v of {
                         Nothing -> m;
                         Just k -> (case lookup m k of {
                                     Nothing -> m;
                                     Just vs -> insert k (removeAll v vs) m;
                                   });
                       });

check_ge_v :: forall a. (Poly_carrier a) => a -> [(Monom Nat, a)] -> Bool;
check_ge_v v p = (case p of {
                   [] -> True;
                   [(m, c)] -> equal_monom m one_monom && less_eq c v;
                   (_, _) : _ : _ -> False;
                 });

check_poly_weak_anti_mono_discrete ::
  forall a b.
    (Eq a, Linorder a, Eq b, Poly_carrier b) => [(Monom a, b)] -> a -> Bool;
check_poly_weak_anti_mono_discrete p v =
  check_poly_ge p
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p);

monom_vars ::
  forall a. (Ceq a, Ccompare a, Linorder a, Set_impl a) => Monom a -> Set a;
monom_vars m = set (monom_vars_list m);

check_poly_weak_anti_mono ::
  forall a b.
    (Ceq a, Ccompare a, Linorder a, Set_impl a,
      Ordered_semiring_0a b) => [(Monom a, b)] -> a -> Bool;
check_poly_weak_anti_mono p v =
  all (\ (m, c) -> less_eq c zerob || not (member v (monom_vars m))) p;

check_poly_weak_anti_mono_smart ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Linorder a, Set_impl a, Eq b,
      Poly_carrier b) => Bool -> [(Monom a, b)] -> a -> Bool;
check_poly_weak_anti_mono_smart discrete =
  (if discrete then check_poly_weak_anti_mono_discrete
    else check_poly_weak_anti_mono);

check_poly_weak_mono_discrete ::
  forall a b.
    (Eq a, Linorder a, Eq b, Poly_carrier b) => [(Monom a, b)] -> a -> Bool;
check_poly_weak_mono_discrete p v =
  check_poly_ge
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p)
    p;

check_poly_weak_mono ::
  forall a b.
    (Ceq a, Ccompare a, Linorder a, Set_impl a,
      Ordered_semiring_0a b) => [(Monom a, b)] -> a -> Bool;
check_poly_weak_mono p v =
  all (\ (m, c) -> less_eq zerob c || not (member v (monom_vars m))) p;

check_poly_weak_mono_smart ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Linorder a, Set_impl a, Eq b,
      Poly_carrier b) => Bool -> [(Monom a, b)] -> a -> Bool;
check_poly_weak_mono_smart discrete =
  (if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono);

fun_of_map_fun :: forall a b. (a -> Maybe b) -> (a -> b) -> a -> b;
fun_of_map_fun m d a = (case m a of {
                         Nothing -> d a;
                         Just b -> b;
                       });

poly_inter_list_to_inter ::
  forall a b.
    (Poly_carrier a,
      Compare_order b) => a -> [((b, Nat), [(Monom Nat, a)])] ->
                                 (b, Nat) -> [(Monom Nat, a)];
poly_inter_list_to_inter def i =
  fun_of_map_fun (ceta_map_of i) (\ fn -> default_I def (snd fn));

create_dep ::
  forall a b.
    (Eq a, Poly_carrier a, Compare_order b,
      Eq b) => Bool ->
                 a -> [((b, Nat), [(Monom Nat, a)])] ->
                        (b, Nat) -> Nat -> Dependance;
create_dep discrete def i =
  let {
    fs = remdups (map fst i);
    ii = poly_inter_list_to_inter def i;
    fsres =
      map (\ fn ->
            let {
              p = ii fn;
              vars = poly_vars_list p;
              is = upt zero_nat (snd fn);
              a = map (\ ia ->
                        (if membera vars ia
                          then (if check_poly_weak_mono_smart discrete p ia
                                 then Increase
                                 else (if check_poly_weak_anti_mono_smart
    discrete p ia
then Decrease else Wild))
                          else Ignore))
                    is;
            } in (fn, a))
        fs;
    iii = fun_of_map_funa (ceta_map_of fsres) (\ _ _ -> Increase) nth;
  } in iii;

coeff :: forall a. (Zero a) => Poly a -> Nat -> a;
coeff p = nth_default zerob (coeffs p);

pseudo_mod_main_list ::
  forall a. (Eq a, Comm_ring_1 a) => a -> [a] -> [a] -> Nat -> [a];
pseudo_mod_main_list lc r d n =
  (if equal_nat n zero_nat then r
    else let {
           rr = map (times lc) r;
           a = hda r;
           rrr = tla (if a == zerob then rr
                       else minus_poly_rev_list rr (map (times a) d));
         } in pseudo_mod_main_list lc rrr d (minus_nat n one_nat));

pseudo_mod_list :: forall a. (Eq a, Comm_ring_1 a) => [a] -> [a] -> [a];
pseudo_mod_list p q =
  (if null q then p
    else let {
           rq = reverse q;
           a = pseudo_mod_main_list (hda rq) (reverse p) rq
                 (minus_nat (plus_nat one_nat (size_list p)) (size_list q));
         } in reverse a);

pseudo_mod ::
  forall a.
    (Eq a, Comm_ring_1 a,
      Semiring_1_no_zero_divisors a) => Poly a -> Poly a -> Poly a;
pseudo_mod f g = poly_of_list (pseudo_mod_list (coeffs f) (coeffs g));

eval_monom_list ::
  forall a b. (Linorder a, Comm_semiring_1 b) => (a -> b) -> [(a, Nat)] -> b;
eval_monom_list alpha [] = onea;
eval_monom_list alpha ((x, p) : m) =
  times (eval_monom_list alpha m) (binary_power (alpha x) p);

eval_monom ::
  forall a b. (Linorder a, Comm_semiring_1 b) => (a -> b) -> Monom a -> b;
eval_monom x xc = eval_monom_list x (rep_monom xc);

eval_poly ::
  forall a b.
    (Linorder a, Comm_semiring_1 b) => (a -> b) -> [(Monom a, b)] -> b;
eval_poly alpha [] = zerob;
eval_poly alpha (mc : p) =
  plus (times (eval_monom alpha (fst mc)) (snd mc)) (eval_poly alpha p);

poly_vars ::
  forall a b.
    (Ceq a, Ccompare a, Linorder a, Set_impl a) => [(Monom a, b)] -> Set a;
poly_vars p = set (concatMap (monom_vars_list . fst) p);

enfc_q ::
  forall a.
    (Eq a) => (Term a [Char] -> Bool) ->
                (Term a [Char] -> Bool) ->
                  [(Term a [Char], Term a [Char])] ->
                    [Term a [Char]] -> [Term a [Char]] -> Term a [Char] -> Bool;
enfc_q isQnf isRnf r q s (Var x) = True;
enfc_q isQnf isRnf r q s (Fun f ts) =
  all (\ qa ->
        (case mgu_class (Fun f (map (icap_impl isQnf r s) ts)) qa of {
          Nothing -> True;
          Just mu ->
            not (all (\ u ->
                       isQnf (subst_apply_term
                               (map_term (\ x -> x)
                                 (\ a ->
                                   Char False False False True True True True
                                     False :
                                     a)
                                 u)
                               mu))
                   s &&
                  isRnf (subst_apply_term
                          (map_term (\ x -> x)
                            (\ a ->
                              Char True False False True True True True False :
                                a)
                            qa)
                          mu));
        }))
    q;

delete_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
delete_values uu [] m = m;
delete_values key (v : vs) m = delete_value key v (delete_values key vs m);

delete_rules ::
  forall a b c.
    (Eq a, Compare_order b, Eq b,
      Eq c) => a -> [(Term b c, Term b c)] ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        Rbt (b, Nat) [(a, (Term b c, Term b c))];
delete_rules a rs = delete_values key (map (\ b -> (a, b)) rs);

split_rulesc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_rulesc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = split_rules;

split_pairsa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_pairsa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = split_pairs;

delete_R_Rwc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_R_Rwc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = delete_R_Rw;

delete_P_Pwa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_P_Pwa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = delete_P_Pw;

minimal :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
minimal
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = minimal;

nfsc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
nfsc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
       rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
       reverse_rules_map intersect_pairs replace_pair intersect_rules
       delete_P_Pw delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules
       more)
  = nfs;

mkd ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      Bool ->
        Bool ->
          [(Term b c, Term b c)] ->
            [(Term b c, Term b c)] ->
              [Term b c] ->
                [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkd (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = mk;

qc :: forall a b c d. Dpp_ops_ext a b c d -> a -> [Term b c];
qc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = q;

split_proc ::
  forall a b c.
    (Showl b,
      Showl c) => Dpp_ops_ext a b c () ->
                    a -> [(Term b c, Term b c)] ->
                           [(Term b c, Term b c)] -> (a, a);
split_proc i d p_remove r_remove =
  (case split_pairsa i d p_remove of {
    (p, pw) ->
      (case split_rulesc i d r_remove of {
        (r, rw) ->
          let {
            dpp1 = mkd i (nfsc i d) (minimal i d) p pw (qc i d) r rw;
            a = delete_R_Rwc i (delete_P_Pwa i d p_remove p_remove) r_remove
                  r_remove;
          } in (dpp1, a);
      });
  });

rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a ->
      Maybe ((a, Nat) -> [Nat]);
rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
  (Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option x) = x;

sel21 ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a -> Status a;
sel21 xa =
  Abs_status
    (case rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option xa of {
      Nothing -> status (error "undefined");
      Just x2 -> x2;
    });

dis1 ::
  forall a. X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a -> Bool;
dis1 xa =
  (case rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option xa of {
    Nothing -> True;
    Just _ -> False;
  });

rep_isom ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a ->
      Maybe (Status a);
rep_isom x = (if dis1 x then Nothing else Just (sel21 x));

status_of_aux ::
  forall a.
    (Eq a) => [((a, Nat), [Nat])] ->
                X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a;
status_of_aux xa =
  Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
    (if all (\ fidx -> all (\ i -> less_nat i (snd (fst fidx))) (snd fidx)) xa
      then Just (fun_of_map_fun (map_of xa) (\ (_, a) -> upt zero_nat a))
      else Nothing);

status_of :: forall a. (Eq a) => [((a, Nat), [Nat])] -> Maybe (Status a);
status_of x = rep_isom (status_of_aux x);

r_states :: forall a b. (Ceq a, Ccompare a, Set_impl a) => Ta_rule a b -> Set a;
r_states = (\ ta_rule -> inserta (r_rhs ta_rule) (set (r_lhs_states ta_rule)));

ta_states ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set a;
ta_states ta =
  sup_set
    (sup_set (sup_seta (image r_states (ta_rules ta)))
      (sup_seta
        (image (\ (q, qa) -> inserta q (inserta qa bot_set)) (ta_eps ta))))
    (ta_final ta);

prod_ta ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Set_impl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Ta_ext c b () -> Set (a, c) -> Ta_ext (a, c) b ();
prod_ta tA1 tA2 f =
  Ta_ext f
    (image
      (\ (TA_rule fa qs1 q1, TA_rule _ qs2 q2) ->
        TA_rule fa (zip qs1 qs2) (q1, q2))
      (sup_seta
        (image
          (\ fa ->
            productc (filtera (\ r -> r_sym r == fa) (ta_rules tA1))
              (filtera (\ r -> r_sym r == fa) (ta_rules tA2)))
          (ta_syms tA1))))
    (sup_set
      (image (\ (a, b) -> (case a of {
                            (q, qa) -> (\ p -> ((q, p), (qa, p)));
                          })
                            b)
        (productc (ta_eps tA1) (ta_states tA2)))
      (image (\ (p, (q, qa)) -> ((p, q), (p, qa)))
        (productc (ta_states tA1) (ta_eps tA2))))
    ();

productive_relation ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set (a, a);
productive_relation ta =
  sup_set (image (\ (a, b) -> (b, a)) (ta_eps ta))
    (sup_seta
      (image (\ r -> image (\ a -> (r_rhs r, a)) (set (r_lhs_states r)))
        (ta_rules ta)));

ta_productive ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set a;
ta_productive ta =
  sup_set (ta_final ta) (compute_trancl (ta_final ta) (productive_relation ta));

ta_restrict ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b c -> Set a -> Ta_ext a b ();
ta_restrict ta q =
  Ta_ext (inf_set (ta_final ta) q)
    (filtera (\ r -> less_eq_set (r_states r) q) (ta_rules ta))
    (inf_set (ta_eps ta) (productc q q)) ();

trim_ta ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Default b, Eq b) => Ta_ext a b () -> Ta_ext a b ();
trim_ta ta =
  ta_restrict (ta_restrict ta (ta_reachable ta))
    (ta_productive (ta_restrict ta (ta_reachable ta)));

check_varcond_subset ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => [(Term a b, Term a b)] -> Sum (String -> String) ();
check_varcond_subset r =
  catch_errora
    (forallM
      (\ rule ->
        catch_errora
          (check_subseteq (insert_vars_term (snd rule) [])
            (insert_vars_term (fst rule) []))
          (\ x ->
            Inl ((((showsl_literal "free variable " . showsl x) .
                    showsl_literal " in right-hand side of rule ") .
                   showsl_rule rule) .
                  showsl_literal "\n")))
      r)
    (\ x -> Inl (snd x));

check_wf_trs ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => [(Term a b, Term a b)] -> Sum (String -> String) ();
check_wf_trs r =
  catch_errora
    (bindb (check_varcond_no_Var_lhs r) (\ _ -> check_varcond_subset r))
    (\ x -> Inl (showsl_literal "the TRS is not well-formed\n" . x));

defined_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
defined_list r =
  concatMap (\ (l, _) -> (if not (is_Var l) then [the (root l)] else [])) r;

showsl_rules ::
  forall a b. (Showl a, Showl b) => [(Term a b, Term a b)] -> String -> String;
showsl_rules = showsl_rulesa showsl showsl " -> ";

generate_f_xs :: forall a. a -> Nat -> Term a [Char];
generate_f_xs f n = Fun f (map (\ i -> Var (generate_var i)) (upt zero_nat n));

num_symbs :: forall a b. Term a b -> Nat;
num_symbs (Var x) = one_nat;
num_symbs (Fun f ts) = plus_nat (sum_list (map num_symbs ts)) one_nat;

showsl_funaa :: forall a. (Showl a) => (a, Nat) -> String -> String;
showsl_funaa (f, n) = (showsl f . showsl_lit "/") . showsl_nat n;

rep_x_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option ::
  forall a.
    (Compare_order a) => X_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
                           a ->
                           Maybe ((a, Nat) -> Af_entry, Set (a, Nat));
rep_x_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
  (Abs_x_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
    x)
  = x;

sel21a ::
  forall a.
    (Compare_order a) => X_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
                           a ->
                           Afs a;
sel21a xa =
  Abs_afs
    (case rep_x_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
            xa
      of {
      Nothing -> rep_afs (error "undefined");
      Just x2 -> x2;
    });

dis1a ::
  forall a.
    (Compare_order a) => X_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
                           a ->
                           Bool;
dis1a xa =
  (case rep_x_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
          xa
    of {
    Nothing -> True;
    Just _ -> False;
  });

rep_isoma ::
  forall a.
    (Compare_order a) => X_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
                           a ->
                           Maybe (Afs a);
rep_isoma x = (if dis1a x then Nothing else Just (sel21a x));

default_af_entry :: Nat -> Af_entry;
default_af_entry n = AFList (upt zero_nat n);

wf_af_entry :: Nat -> Af_entry -> Bool;
wf_af_entry n (Collapse i) = less_nat i n;
wf_af_entry n (AFList is) = all (\ i -> less_nat i n) is;

afs_of_aux ::
  forall a.
    (Ceq a, Ccompare a, Compare_order a,
      Set_impl a) => [((a, Nat), Af_entry)] ->
                       X_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
                         a;
afs_of_aux xa =
  Abs_x_compare_order_x_x_f_afs_option_x_x_nat_x_compare_order_x_x_f_prod_set_af_entry_nat_x_compare_order_x_x_f_prod_fun_prod_option
    (if all (\ ((_, n), e) -> wf_af_entry n e) xa
      then Just (fun_of_map_fun (ceta_map_of xa)
                   (\ fn -> default_af_entry (snd fn)),
                  set (map fst xa))
      else Nothing);

afs_of ::
  forall a.
    (Ceq a, Ccompare a, Compare_order a,
      Set_impl a) => [((a, Nat), Af_entry)] -> Maybe (Afs a);
afs_of x = rep_isoma (afs_of_aux x);

ta_bounds_lhs ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Sum ((a, Nat), [[Char]]) [Char]);
ta_bounds_lhs xml2name =
  xml_do "lhs"
    (xml_or (xml_take state (\ a -> xml_return (Inr a)))
      (xml_take xml2name
        (\ f ->
          xml_take (xml_nat "height")
            (\ h ->
              xml_take_many_sub [] zero_nat Infinity_enat state
                (\ qs -> xml_return (Inl ((f, h), qs)))))));

bounds_bound ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Nat;
bounds_bound = xml_nat "bound";

bounds_type ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Boundstype;
bounds_type =
  xml_do "type"
    (xml_take (xml_or (xml_leaf "roof" Roof) (xml_leaf "match" Match))
      (\ x -> xml_return (id x)));

bounds_info ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Bounds_info a [Char]);
bounds_info xml2name =
  xml_do "bounds"
    (xml_take bounds_type
      (\ a ->
        xml_take bounds_bound
          (\ b ->
            xml_take final_states
              (\ c ->
                xml_take (tree_automaton (ta_bounds_lhs xml2name))
                  (\ d ->
                    xml_take_default Id_Relation closed_criterion
                      (\ e -> xml_return (Bounds_Info a b c d e)))))));

multiset_af ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [((a, Nat), [Nat])];
multiset_af xml2name =
  xml_do "multisetArgumentFilter"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "multisetArgumentFilterEntry"
        (xml_take xml2name
          (\ f ->
            xml_take (xml_nat "arity")
              (\ a ->
                xml_take
                  (xml_do "status"
                    (xml_take_many_sub [] zero_nat Infinity_enat position
                      xml_return))
                  (\ p -> xml_return ((f, a), p))))))
      xml_return);

word_pattern ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        ([Lab a b], ((Nat, (Nat, [Lab a b])), [Lab a b]));
word_pattern xml2name =
  xml_do "wordPattern"
    (xml_take (string xml2name)
      (\ l ->
        xml_take (string xml2name)
          (\ m ->
            xml_take (xml_nat "factor")
              (\ f ->
                xml_take (xml_nat "constant")
                  (\ c ->
                    xml_take (string xml2name)
                      (\ r -> xml_return (l, ((f, (c, m)), r))))))));

derivation_pattern ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (([Lab a b], ((Nat, (Nat, [Lab a b])), [Lab a b])),
                          ([Lab a b], ((Nat, (Nat, [Lab a b])), [Lab a b])));
derivation_pattern xml2name =
  xml_do "derivationPattern"
    (xml_take (word_pattern xml2name)
      (\ a -> xml_take (word_pattern xml2name) (\ b -> xml_return (a, b))));

derivation_pattern_proof ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) (Dp_proof_step (Lab a b));
derivation_pattern_proof xml2name =
  let {
    oc = oc_srs xml2name;
    dp = derivation_pattern xml2name;
    s = string xml2name;
  } in xml_do "derivationPatternProof"
         (xml_take
           (xml_or
             (xml_do "OC1"
               (xml_take oc
                 (\ a ->
                   xml_take (xml_bool "isPair") (\ b -> xml_return (OC1 a b)))))
             (xml_or
               (xml_do "OC2"
                 (xml_take oc
                   (\ a ->
                     xml_take oc
                       (\ b ->
                         xml_take oc
                           (\ c ->
                             xml_take s
                               (\ d ->
                                 xml_take s
                                   (\ e ->
                                     xml_take s
                                       (\ f ->
 xml_return (OC2 a b c d e f)))))))))
               (xml_or
                 (xml_do "OC2prime"
                   (xml_take oc
                     (\ a ->
                       xml_take oc
                         (\ b ->
                           xml_take oc
                             (\ c ->
                               xml_take s
                                 (\ d ->
                                   xml_take s
                                     (\ e ->
                                       xml_take s
 (\ f -> xml_return (OC2p a b c d e f)))))))))
                 (xml_or
                   (xml_do "OC3"
                     (xml_take oc
                       (\ a ->
                         xml_take oc
                           (\ b ->
                             xml_take oc
                               (\ c ->
                                 xml_take s
                                   (\ d ->
                                     xml_take s
                                       (\ e -> xml_return (OC3 a b c d e))))))))
                   (xml_or
                     (xml_do "OC3prime"
                       (xml_take oc
                         (\ a ->
                           xml_take oc
                             (\ b ->
                               xml_take oc
                                 (\ c ->
                                   xml_take s
                                     (\ d ->
                                       xml_take s
 (\ e -> xml_return (OC3p a b c d e))))))))
                     (xml_or
                       (xml_do "OCintoDP1"
                         (xml_take dp
                           (\ a ->
                             xml_take oc (\ b -> xml_return (OCDP1 a b)))))
                       (xml_or
                         (xml_do "OCintoDP2"
                           (xml_take dp
                             (\ a ->
                               xml_take oc (\ b -> xml_return (OCDP2 a b)))))
                         (xml_or
                           (xml_do "equivalent"
                             (xml_take dp
                               (\ a ->
                                 xml_take dp (\ b -> xml_return (WPEQ a b)))))
                           (xml_or
                             (xml_do "lift"
                               (xml_take dp
                                 (\ a ->
                                   xml_take dp (\ b -> xml_return (Lift a b)))))
                             (xml_or
                               (xml_do "DP_OC_1_1"
                                 (xml_take dp
                                   (\ a ->
                                     xml_take dp
                                       (\ b ->
 xml_take oc
   (\ c ->
     xml_take s (\ d -> xml_take s (\ e -> xml_return (DPOC1_1 a b c d e))))))))
                               (xml_or
                                 (xml_do "DP_OC_1_2"
                                   (xml_take dp
                                     (\ a ->
                                       xml_take dp
 (\ b ->
   xml_take oc
     (\ c ->
       xml_take s
         (\ d ->
           xml_take s
             (\ e -> xml_take s (\ f -> xml_return (DPOC1_2 a b c d e f)))))))))
                                 (xml_or
                                   (xml_do "DP_OC_2"
                                     (xml_take dp
                                       (\ a ->
 xml_take dp
   (\ b ->
     xml_take oc
       (\ c ->
         xml_take s
           (\ d -> xml_take s (\ e -> xml_return (DPOC2 a b c d e))))))))
                                   (xml_or
                                     (xml_do "DP_OC_3_1"
                                       (xml_take dp
 (\ a ->
   xml_take dp
     (\ b ->
       xml_take oc
         (\ c ->
           xml_take s
             (\ d -> xml_take s (\ e -> xml_return (DPOC3_1 a b c d e))))))))
                                     (xml_or
                                       (xml_do "DP_OC_3_2"
 (xml_take dp
   (\ a ->
     xml_take dp
       (\ b ->
         xml_take oc
           (\ c ->
             xml_take s
               (\ d ->
                 xml_take s
                   (\ e ->
                     xml_take s (\ f -> xml_return (DPOC3_2 a b c d e f)))))))))
                                       (xml_or
 (xml_do "DP_DP_1_1"
   (xml_take dp
     (\ a ->
       xml_take dp
         (\ b ->
           xml_take dp
             (\ c ->
               xml_take s
                 (\ d ->
                   xml_take s (\ e -> xml_return (DPDP1_1 a b c d e))))))))
 (xml_or
   (xml_do "DP_DP_1_2"
     (xml_take dp
       (\ a ->
         xml_take dp
           (\ b ->
             xml_take dp
               (\ c ->
                 xml_take s
                   (\ d ->
                     xml_take s (\ e -> xml_return (DPDP1_2 a b c d e))))))))
   (xml_or
     (xml_do "DP_DP_2_1"
       (xml_take dp
         (\ a ->
           xml_take dp
             (\ b ->
               xml_take dp
                 (\ c ->
                   xml_take s
                     (\ d ->
                       xml_take s (\ e -> xml_return (DPDP2_1 a b c d e))))))))
     (xml_do "DP_DP_2_2"
       (xml_take dp
         (\ a ->
           xml_take dp
             (\ b ->
               xml_take dp
                 (\ c ->
                   xml_take s
                     (\ d ->
                       xml_take s
                         (\ e ->
                           xml_return
                             (DPDP2_2 a b c d e)))))))))))))))))))))))))
           (\ x -> xml_return (id x)));

nonloop_srs_reason ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        ([Dp_proof_step (Lab a b)] ->
                          Non_loop_srs_proof (Lab a b));
nonloop_srs_reason xml2name =
  xml_or
    (xml_do "selfEmbeddingOC"
      (xml_take (string xml2name)
        (\ a ->
          xml_take (string xml2name)
            (\ b ->
              xml_take (string xml2name)
                (\ c -> xml_return (SE_OC (b, a ++ b ++ c) a c))))))
    (xml_do "selfEmbeddingDP"
      (xml_take (derivation_pattern xml2name)
        (\ a ->
          xml_take (string xml2name)
            (\ b ->
              xml_take (string xml2name) (\ c -> xml_return (SE_DP a b c))))));

nonloop_srs ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) (Non_loop_srs_proof (Lab a b));
nonloop_srs xml2name =
  xml_do "nonterminatingSRS"
    (xml_take
      (xml_do "derivationPatterns"
        (xml_take_many_sub [] zero_nat Infinity_enat
          (derivation_pattern_proof xml2name) (\ a -> xml_return (id a))))
      (\ a ->
        xml_take (nonloop_srs_reason xml2name) (\ b -> xml_return (b a))));

evala :: forall a b c. (a -> [b] -> b) -> Term a c -> (c -> b) -> b;
evala i (Fun f ss) alpha = i f (map (\ s -> evala i s alpha) ss);
evala i (Var x) alpha = alpha x;

nFQ_subset_NF_rulesb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
nFQ_subset_NF_rulesb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = nFQ_subset_NF_rules;

is_QNFb :: forall a b c d. Tp_ops_ext a b c d -> a -> Term b c -> Bool;
is_QNFb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = is_QNF;

rulese :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulese
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = rules;

icap_impl_tp ::
  forall a b.
    (Eq b) => Tp_ops_ext a b [Char] () ->
                a -> [Term b [Char]] -> Term b [Char] -> Term b (Sum () [Char]);
icap_impl_tp i d =
  let {
    qr = nFQ_subset_NF_rulesb i d;
    qnf = is_QNFb i d;
    r = rulese i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s -> let {
                 a = ceta_set_of (concatMap vars_term_list s);
               } in ic s a);

has_type ::
  forall a b c. (Eq b) => (a -> ([b], b)) -> Term a (c, b) -> b -> Bool;
has_type type_of_fun (Fun f es) ty =
  ty == snd (type_of_fun f) &&
    equal_nat (size_list es) (size_list (fst (type_of_fun f))) &&
      all_interval_nat
        (\ i -> has_type type_of_fun (nth es i) (nth (fst (type_of_fun f)) i))
        zero_nat (size_list es);
has_type type_of_fun (Var v) ty = snd v == ty;

is_bool ::
  forall a b c.
    (Ceq b, Ccompare b,
      Eq b) => (a -> ([b], b)) -> Set b -> Term a (c, b) -> Bool;
is_bool type_of_fun bool_types e =
  bex bool_types (has_type type_of_fun e) && not (is_Var e);

formula :: forall a. (a -> Bool) -> Formula a -> Bool;
formula atom (Disjunction phi_s) = all (formula atom) phi_s;
formula atom (Conjunction phi_s) = all (formula atom) phi_s;
formula atom (NegAtom a) = atom a;
formula atom (Atom a) = atom a;

transition_rule ::
  forall a b c d.
    (Ceq b, Ccompare b,
      Eq b) => (a -> ([b], b)) -> Set b -> Transition_rule a c b d -> Bool;
transition_rule type_of_fun bool_types (Transition l r phi) =
  formula (is_bool type_of_fun bool_types) phi;

check_lts_impl ::
  forall a b c d e.
    (Ceq b, Ccompare b,
      Eq b) => (a -> ([b], b)) ->
                 Set b -> Lts_impl a c b d e -> Sum (String -> String) ();
check_lts_impl type_of_fun bool_types pi =
  (case pi of {
    Lts_Impl _ ti lc ->
      bindb (catch_errora
              (forallM
                (\ (_, t) ->
                  check (transition_rule type_of_fun bool_types t)
                    (showsl_lit "ill-formed transition in LTS"))
                ti)
              (\ x -> Inl (snd x)))
        (\ _ ->
          catch_errora
            (forallM
              (\ (_, f) ->
                check (formula (is_bool type_of_fun bool_types) f)
                  (showsl_lit "ill-formed location condition in LTS"))
              lc)
            (\ x -> Inl (snd x)));
  });

atom_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Formula (Term Sig ([Char], Ty)));
atom_parser = xml_change (bexp_parser variable_parser) (xml_return . Atom);

hint_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Hints;
hint_parser =
  xml_do "linearCombination"
    (xml_take_many_sub [] zero_nat Infinity_enat (xml_int "constant")
      (\ xs -> xml_return (Hints xs)));

type_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) Ty;
type_parser =
  xml_or (xml_do "int" (xml_return IntT)) (xml_do "bool" (xml_return BoolT));

label_decomp :: forall a b. Lab a b -> (Lab a b, Sum b [Lab a b]);
label_decomp (Lab f l) = (f, Inl l);
label_decomp (FunLab f l) = (f, Inr l);

list_all_rec :: forall a. (a -> Bool) -> [a] -> Bool;
list_all_rec p [] = True;
list_all_rec p (a : l) = p a && list_all_rec p l;

poly_const :: forall a b. (Zero a, Eq a, Linorder b) => a -> [(Monom b, a)];
poly_const a = (if a == zerob then [] else [(one_monom, a)]);

poly_minus ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Ring_1 b) => [(Monom a, b)] -> [(Monom a, b)] -> [(Monom a, b)];
poly_minus f g = poly_add f (monom_mult_poly (one_monom, uminus onea) g);

remove_prefix :: forall a. (Eq a) => [a] -> [a] -> Maybe [a];
remove_prefix [] ys = Just ys;
remove_prefix (x : xs) (y : ys) =
  (if x == y then remove_prefix xs ys else Nothing);
remove_prefix (v : va) [] = Nothing;

remove_suffix :: forall a. (Eq a) => [a] -> [a] -> Maybe [a];
remove_suffix p q = (case remove_prefix (reverse p) (reverse q) of {
                      Nothing -> Nothing;
                      Just r -> Just (reverse r);
                    });

swap :: forall a b. (a, b) -> (b, a);
swap p = (snd p, fst p);

set_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
set_ext s_ns =
  (\ asa bs ->
    (not (null asa) && all (\ b -> any (\ a -> fst (s_ns a b)) asa) bs,
      all (\ b -> any (\ a -> snd (s_ns a b)) asa) bs));

update_B_I ::
  forall a b c d e.
    (Ccompare a,
      Eq a) => ((Mapping a (b, c) -> Mapping a (b, c)) -> d -> e) ->
                 b -> a -> c -> d -> e;
update_B_I field_update i x c s = field_update (updateb x (i, c)) s;

check_no_var ::
  forall a b. (Showl a, Showl b) => Term a b -> Sum (String -> String) ();
check_no_var t = check (not (is_Var t)) (showsl_literal "variable found\n");

check_supteq ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => Term a b -> Term a b -> Sum (String -> String) ();
check_supteq s t =
  check (equal_term s t || supt_impl s t)
    ((showsl_terma t . showsl_literal " is not a subterm of ") .
      showsl_terma s);

showsl_ctxt ::
  forall a b.
    (a -> String -> String) ->
      (b -> String -> String) -> Ctxt a b -> String -> String;
showsl_ctxt fun var Hole = showsl_lit "[]";
showsl_ctxt fun var (More f ss1 d ss2) =
  (((fun f . showsl_literal "(") .
     showsl_list_gen (showsl_term fun var) "" "" ", " ", " ss1) .
    showsl_ctxt fun var d) .
    showsl_list_gen (showsl_term fun var) ")" ", " ", " ")" ss2;

funs_term_ms :: forall a b. (Eq a) => Term a b -> Multiset a;
funs_term_ms (Var x) = zero_multiset;
funs_term_ms (Fun f ts) =
  plus_multiset (add_mset f zero_multiset)
    (sum_mset (mset (map funs_term_ms ts)));

subt_at_ctxt :: forall a b. Ctxt a b -> [Nat] -> Ctxt a b;
subt_at_ctxt c [] = c;
subt_at_ctxt (More f bef c aft) (i : p) = subt_at_ctxt c p;

ta_match ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Eq b, Ceq c,
      Ccompare c) => Ta_ext a b () ->
                       Set a -> Term b c -> Set a -> Set [(c, a)];
ta_match ta qsig (Fun f ts) q =
  let {
    n = size_list ts;
    rls = filtera
            (\ rule ->
              r_sym rule == (f, n) &&
                bex (sup_set (inserta (r_rhs rule) bot_set)
                      (compute_trancl (inserta (r_rhs rule) bot_set)
                        (ta_eps ta)))
                  (\ qa -> member qa q))
            (ta_rules ta);
  } in sup_seta
         (image
           (\ (TA_rule _ qs _) ->
             image concat
               (listset
                 (map (\ (tsi, qsi) ->
                        ta_match ta qsig tsi (inserta qsi bot_set))
                   (zip ts qs))))
           rls);
ta_match ta qsig (Var x) q =
  image (\ qa -> [(x, qa)])
    (filtera (\ qa -> member qa qsig)
      (sup_set q (compute_trancl q (converse (ta_eps ta)))));

generate_listset ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Nat -> Set a -> Set [a];
generate_listset n s =
  (if equal_nat n zero_nat
    then inserta [] (set_empty (of_phantom set_impl_list))
    else set_Cons s (generate_listset (minus_nat n one_nat) s));

minus_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
minus_set a b = inf_set a (uminus_set b);

mergec :: forall a. (Eq a) => Term a () -> Term a () -> Maybe (Term a ());
mergec (Fun fa tsa) (Fun f ts) =
  bind (guard (fa == f))
    (\ _ ->
      bind (guard (equal_nat (size_list tsa) (size_list ts)))
        (\ _ ->
          bind (mapMa (\ (a, b) -> mergec a b) (zip tsa ts))
            (\ tsb -> Just (Fun fa tsb))));
mergec (Var ()) x = Just x;
mergec (Fun v va) (Var ()) = Just (Fun v va);

merge_cl :: forall a. (Compare a, Eq a) => Set (Term a ()) -> Set (Term a ());
merge_cl s =
  let {
    new = minus_set (these (image (\ (a, b) -> mergec a b) (productc s s))) s;
  } in (if set_eq new (set_empty (of_phantom set_impl_term)) then s
         else merge_cl (sup_set s new));

subt_merge_cl ::
  forall a b.
    (Compare a, Eq a, Compare b, Eq b) => Set (Term a b) -> Set (Term a ());
subt_merge_cl s =
  merge_cl
    (sup_set (inserta (Var ()) (set_empty (of_phantom set_impl_term)))
      (sup_seta
        (image (\ t -> set (supt_list t))
          (image (map_term (\ x -> x) (\ _ -> ())) s))));

maxa :: forall a. (Ceq a, Ccompare a, Lattice a, Linorder a) => Set a -> a;
maxa a = set_fold1 max_sls a;

matchd :: forall a b. (Eq a) => Term a () -> Term a b -> Bool;
matchd (Var ()) x = True;
matchd (Fun fa tsa) (Fun f ts) = fa == f && list_all2 matchd tsa ts;
matchd (Fun v va) (Var vb) = False;

funs_term_list :: forall a b. Term a b -> [a];
funs_term_list t = add_funs_term t [];

shrinks ::
  forall a.
    (Compare a, Eq a) => Term a () -> Set (Term a ()) -> Set (Term a ());
shrinks ta t =
  let {
    s = filtera (\ s -> matchd s ta) t;
    max = maxa (image (size_list . funs_term_list) s);
  } in filtera (\ sa -> equal_nat ((size_list . funs_term_list) sa) max) s;

nf_rules_states_impl ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Set (Term a b) ->
                 Set (a, Nat) -> (Set (Ta_rule (Term a ()) a), Set (Term a ()));
nf_rules_states_impl t sig =
  let {
    mcl = subt_merge_cl t;
    states =
      filtera
        (\ q ->
          ball t (\ ta -> not (matchd (map_term (\ x -> x) (\ _ -> ()) ta) q)))
        mcl;
    lhss =
      sup_seta
        (image (\ (f, n) -> image (\ a -> (f, a)) (generate_listset n states))
          sig);
    flhss =
      filtera
        (\ q ->
          ball t
            (\ ta ->
              not (matchd (map_term (\ x -> x) (\ _ -> ()) ta)
                    (Fun (fst q) (snd q)))))
        lhss;
    rules =
      image (\ (f, qs) -> image (TA_rule f qs) (shrinks (Fun f qs) mcl)) flhss;
  } in (sup_seta rules, states);

ta_nf ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Set (Term a b) -> Set (a, Nat) -> Ta_ext (Term a ()) a ();
ta_nf t sig =
  (case nf_rules_states_impl t sig of {
    (rules, states) ->
      Ta_ext states rules
        (set_empty
          (of_phantom
            (set_impl_prod :: Phantom (Term a (), Term a ()) Set_impla)))
        ();
  });

first_rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
first_rewrite r s = (case rewrite r s of {
                      [] -> Nothing;
                      t : _ -> Just t;
                    });

compute_rstep_NF ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
compute_rstep_NF r s = compute_NF (first_rewrite r) s;

check_join_NF ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    Term a b -> Term a b -> Sum (String -> String) ();
check_join_NF r s t =
  (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
    (Nothing, _) ->
      Inl (showsl_literal "strange error in normal form computation");
    (Just _, Nothing) ->
      Inl (showsl_literal "strange error in normal form computation");
    (Just sa, Just ta) ->
      check (equal_term sa ta)
        (((((((showsl_literal "the normal form " . showsl_terma sa) .
               showsl_literal " of ") .
              showsl_terma s) .
             showsl_literal " differs from\nthe normal form ") .
            showsl_terma ta) .
           showsl_literal " of ") .
          showsl_terma t);
  });

in_rstep_impl ::
  forall a b.
    (Compare a, Eq a, Ccompare b, Compare b, Eq b,
      Mapping_impl b) => Term a b ->
                           Term a b -> Set (Term a b, Term a b) -> Bool;
in_rstep_impl s t r =
  any (\ p ->
        in_poss p t &&
          equal_ctxt (ctxt_of_pos_term p s) (ctxt_of_pos_term p t) &&
            let {
              sp = subt_at s p;
              tp = subt_at t p;
            } in bex r (\ lr ->
                         not (is_none
                               (match_list Var [(fst lr, sp), (snd lr, tp)]))))
    (poss_list s);

reverse_rules :: forall a b. [(Term a b, Term a b)] -> [(Term a b, Term a b)];
reverse_rules rs = map swap rs;

wf_rules_impl ::
  forall a b. (Eq b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)];
wf_rules_impl r = filter wf_rule r;

check_pairwise :: forall a b. (a -> a -> Sum b ()) -> [a] -> Sum b ();
check_pairwise c [] = Inr ();
check_pairwise c (x : xs) =
  bindb (catch_errora (forallM (c x) xs) (\ xa -> Inl (snd xa)))
    (\ _ -> check_pairwise c xs);

check_disjoint :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_disjoint xs ys =
  catch_errora
    (forallM (\ x -> (if not (membera ys x) then Inr () else Inl x)) xs)
    (\ x -> Inl (snd x));

check_partition :: forall a. (Eq a) => [[a]] -> Sum a ();
check_partition xss = check_pairwise check_disjoint xss;

check_inj ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => Lab a b ->
                    Nat ->
                      [((Lab a b, Nat), [Lab a b])] ->
                        Sum (String -> String) ();
check_inj a nn sml =
  let {
    symbols =
      map (\ (aa, b) ->
            (case aa of {
              (_, n) ->
                (\ fs ->
                  map (\ (g, i) ->
                        (g, plus_nat n (times_nat i (minus_nat nn one_nat))))
                    (zip fs (upt zero_nat (size_list fs))));
            })
              b)
        sml;
    fsymbols = concat symbols;
  } in bindb (catch_errora (check_partition symbols)
               (\ x ->
                 Inl ((showsl_lit "symbol " . showsl_prod x) .
                       showsl_lit " occurs twice)")))
         (\ _ ->
           bindb (check (not (membera fsymbols (a, nn)))
                   ((showsl_lit "application symbol" . showsl_lab a) .
                     showsl_lit " must not occur as new symbol"))
             (\ _ ->
               bindb (check (not (membera (map fst sml) (a, nn)))
                       ((showsl_lit "application symbol" . showsl_lab a) .
                         showsl_lit " must not be uncurried"))
                 (\ _ ->
                   (if less_eq_nat nn one_nat
                     then catch_errora
                            (forallM
                              (check_pairwise
                                (\ gn1 gn2 ->
                                  check (not (gn1 == gn2))
                                    ((showsl_lit "symbol " . showsl_prod gn1) .
                                      showsl_lit " occurs twice")))
                              symbols)
                            (\ x -> Inl (snd x))
                     else Inr ()))));

no_complexity_check :: forall a b. a -> b -> Sum (String -> String) ();
no_complexity_check =
  (\ _ _ -> Inl (showsl_literal "complexity analysis unsupported"));

not_wst :: forall a b c. Redtriple_ext a b c -> Maybe [(a, Nat)];
not_wst
  (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx more) =
  not_wst;

not_sst :: forall a b c. Redtriple_ext a b c -> Maybe [(a, Nat)];
not_sst
  (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx more) =
  not_sst;

valid :: forall a b c. Redtriple_ext a b c -> Sum (String -> String) ();
valid (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx
        more)
  = valid;

desca :: forall a b c. Redtriple_ext a b c -> String -> String;
desca (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx
        more)
  = desc;

check_status_ws_info ::
  forall a.
    (Showl a) => Status a ->
                   ((Term a [Char], Term a [Char]) ->
                     Sum (String -> String) ()) ->
                     Maybe [(a, Nat)] -> Sum (String -> String) ();
check_status_ws_info sigma cns Nothing =
  Inl (showsl_lit "missing weak-subterm status of base reduction pair");
check_status_ws_info sigma cns (Just fs) =
  catch_errora
    (forallM
      (\ (f, n) ->
        catch_errora
          (forallM
            (\ i ->
              let {
                s = Fun f (map (\ ia ->
                                 Var ([Char False False False True True True
 True False] ++
                                       shows_prec_nat zero_nat ia []))
                            (upt zero_nat n));
                t = Var ([Char False False False True True True True False] ++
                          shows_prec_nat zero_nat i []);
              } in catch_errora (cns (s, t))
                     (\ _ ->
                       Inl (((((((((showsl_lit "argument #" .
                                     showsl_nat (suc i)) .
                                    showsl_lit " is in status of ") .
                                   showsl_funa (f, n)) .
                                  showsl_literal "\n") .
                                 showsl_lit "but ") .
                                showsl_terma s) .
                               showsl_lit " >= ") .
                              showsl_lit "x" . showsl_nat i) .
                             showsl_lit " is not satisfied")))
            (status sigma (f, n)))
          (\ x -> Inl (snd x)))
      fs)
    (\ x -> Inl (snd x));

ns :: forall a b c.
        Redtriple_ext a b c ->
          (Term a b, Term a b) -> Sum (String -> String) ();
ns (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx more)
  = ns;

af :: forall a b c. Redtriple_ext a b c -> (a, Nat) -> Set Nat;
af (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx more)
  = af;

is_None :: forall a. Maybe a -> Bool;
is_None a = (case a of {
              Nothing -> True;
              Just _ -> False;
            });

s :: forall a b c.
       Redtriple_ext a b c -> (Term a b, Term a b) -> Sum (String -> String) ();
s (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx more) =
  s;

showsl_wpo_params ::
  forall a. (Showl a) => [((a, Nat), (Nat, [Nat]))] -> String -> String;
showsl_wpo_params params =
  showsl_lit "status and precedence:\n" .
    showsl_sep
      (\ (f, (p, s)) ->
        (((((((showsl_lit "precedence(" . showsl_funa f) . showsl_lit ") = ") .
              showsl_nat p) .
             showsl_literal "\n") .
            showsl_lit "  status(") .
           showsl_funa f) .
          showsl_lit ") = ") .
          showsl_list_nat s)
      (showsl_literal "\n") params;

faulty_redtriple ::
  forall a b.
    Itself a ->
      Itself b ->
        (String -> String) -> (String -> String) -> Redtriple_ext a b ();
faulty_redtriple uu uv err desc =
  Redtriple_ext (Inl err) (\ _ -> Inr ()) (\ _ -> Inr ()) (\ _ -> Inr ())
    full_af empty_af (\ _ -> Inr ()) desc Nothing Nothing no_complexity_check
    ();

prl_nat :: forall a. ((a, Nat) -> Nat) -> (a, Nat) -> Bool;
prl_nat pr = (\ f -> equal_nat (pr f) zero_nat);

prc_nat :: forall a. ((a, Nat) -> Nat) -> (a, Nat) -> (a, Nat) -> (Bool, Bool);
prc_nat pr = (\ f g -> let {
                         pf = pr f;
                         pg = pr g;
                       } in (less_nat pg pf, less_eq_nat pg pf));

wpo_redtriple ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => Redtriple_ext a [Char] () ->
                    [((a, Nat), (Nat, [Nat]))] -> Redtriple_ext a [Char] ();
wpo_redtriple rt params =
  let {
    stat = map (\ (f, ps) -> (f, snd ps)) params;
    pr = fun_of_map_funa (ceta_map_of params) (\ _ -> zero_nat) fst;
    desc1 = showsl_lit "WPO ";
    desc2 =
      ((showsl_lit "with " . showsl_wpo_params params) .
        showsl_lit "\nover the following reduction pair:\n") .
        desca rt;
  } in (case status_of stat of {
         Nothing ->
           faulty_redtriple Type Type
             (showsl_lit "problem with indices in status of WPO!")
             (desc1 . desc2);
         Just sigma ->
           let {
             large_opt = large_of pr sigma (map fst params);
             ssimple =
               not (is_None large_opt) &&
                 isOK (check_status_ws_info sigma (s rt) (not_sst rt));
             large =
               (if ssimple then (\ f -> equal_nat (pr f) (the large_opt))
                 else (\ _ -> False));
             sa = (\ sa t -> isOK (s rt (sa, t)));
             nsa = (\ sb t -> isOK (ns rt (sb, t)));
             wpo = wpo_ub (prc_nat pr) (prl_nat pr) ssimple large sa nsa sigma;
             wpo_s =
               (\ (sb, t) ->
                 check (fst (wpo sb t))
                   (((showsl_terma sb . showsl_lit " >wpo ") . showsl_terma t) .
                     showsl_lit " could not be ensured"));
             wpo_ns =
               (\ (sb, t) ->
                 check (snd (wpo sb t))
                   (((showsl_terma sb . showsl_lit " >=wpo ") .
                      showsl_terma t) .
                     showsl_lit " could not be ensured"));
           } in Redtriple_ext
                  (bindb (valid rt)
                    (\ _ -> check_status_ws_info sigma (ns rt) (not_wst rt)))
                  wpo_s wpo_ns wpo_ns (af_wpo (af rt) sigma) empty_af
                  (\ _ ->
                    catch_errora
                      (forallM
                        (\ (a, b) ->
                          (case a of {
                            (f, n) ->
                              (\ idx ->
                                check (eq_set (set idx) (set (upt zero_nat n)))
                                  (((showsl_lit
                                       "for monotonicity, status must be complete, but status of " .
                                      showsl_funa (f, n)) .
                                     showsl_lit " is ") .
                                    showsl_lista (map suc idx)));
                          })
                            b)
                        stat)
                      (\ x -> Inl (snd x)))
                  (if ssimple
                    then (desc1 . showsl_lit "(strictly simple) ") . desc2
                    else desc1 . desc2)
                  (Just (map fst stat)) (Just (map fst stat))
                  no_complexity_check ();
       });

parse_xml_string ::
  forall a.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      [Char] -> Sum_bot [Char] a;
parse_xml_string p str = (case string2xml str of {
                           Inl a -> left a;
                           Inr a -> parse_xml p a;
                         });

parse_claim :: forall a b c. a -> [Char] -> Sum_bot [Char] (Claim b c);
parse_claim f = parse_xml_string xml2claim;

size_multiset :: forall a. Multiset a -> Nat;
size_multiset (Bag ms) = foldd (\ _ -> plus_nat) zero_nat ms;

lex_ext ::
  forall a. (a -> a -> (Bool, Bool)) -> Nat -> [a] -> [a] -> (Bool, Bool);
lex_ext f n ss ts =
  let {
    lts = size_list ts;
  } in (if equal_nat (size_list ss) lts || less_eq_nat lts n
         then lex_ext_unbounded f ss ts else (False, False));

ass_list_to_single_list :: forall a. [(a, Nat)] -> [a];
ass_list_to_single_list [] = [];
ass_list_to_single_list ((x, n) : xs) =
  replicate n x ++ ass_list_to_single_list xs;

or2 :: (Bool, Bool) -> (Bool, Bool) -> (Bool, Bool);
or2 a b = (fst a || fst b, snd a || snd b);

mul_ext_impl ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
mul_ext_impl sns [] [] = (False, True);
mul_ext_impl sns [] (v : va) = (False, False);
mul_ext_impl sns (v : va) [] = (True, True);
mul_ext_impl sns (v : va) (y : ys) = mul_ex_dom sns (v : va) [] y ys;

mul_ex_dom ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> a -> [a] -> (Bool, Bool);
mul_ex_dom sns [] xs y ys = (False, False);
mul_ex_dom sns (x : xsa) xs y ys =
  (case sns x y of {
    (True, _) ->
      (if snd (mul_ext_impl sns (xsa ++ xs)
                (filter (\ ya -> not (fst (sns x ya))) ys))
        then (True, True) else mul_ex_dom sns xsa (x : xs) y ys);
    (False, True) ->
      or2 (mul_ext_impl sns (xsa ++ xs) ys) (mul_ex_dom sns xsa (x : xs) y ys);
    (False, False) -> mul_ex_dom sns xsa (x : xs) y ys;
  });

mul_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
mul_ext = mul_ext_impl;

smulextp ::
  forall a. (a -> a -> (Bool, Bool)) -> Multiset a -> Multiset a -> Bool;
smulextp f (Bag xs) (Bag ys) =
  fst (mul_ext f (ass_list_to_single_list (impl_ofa xs))
        (ass_list_to_single_list (impl_ofa ys)));

mulextp ::
  forall a.
    (a -> a -> (Bool, Bool)) -> Multiset a -> Multiset a -> (Bool, Bool);
mulextp f (Bag xs) (Bag ys) =
  mul_ext f (ass_list_to_single_list (impl_ofa xs))
    (ass_list_to_single_list (impl_ofa ys));

weighta :: forall a b. ((a, Nat) -> Nat) -> Nat -> Term a b -> Nat;
weighta w w0 (Fun f ts) =
  plus_nat (w (f, size_list ts)) (sum_list (map (weighta w w0) ts));
weighta w w0 (Var x) = w0;

ackbo_impl ::
  forall a b.
    (Ceq a, Ccompare a, Eq a,
      Eq b) => ((a, Nat) -> Nat) ->
                 Nat ->
                   ((a, Nat) -> (a, Nat) -> Bool) ->
                     Set a -> Term a b -> Term a b -> Bool;
ackbo_impl w w0 pr_strict ac s t =
  (if subseteq_mset (vars_term_ms t) (vars_term_ms s) &&
        less_eq_nat (weighta w w0 t) (weighta w w0 s)
    then (if less_nat (weighta w w0 t) (weighta w w0 s) then True
           else (case s of {
                  Var _ -> False;
                  Fun f ss ->
                    (case t of {
                      Var _ -> True;
                      Fun g ts ->
                        (if pr_strict (f, size_list ss) (g, size_list ts)
                          then True
                          else (if (f, size_list ss) == (g, size_list ts)
                                 then (if not (member f ac) ||
    not (equal_nat (size_list ss) (nat_of_integer (2 :: Integer)))
then fst (lex_ext
           (\ x y ->
             (ackbo_impl w w0 pr_strict ac x y,
               equal_acterm (aocnf ac ac x) (aocnf ac ac y)))
           (size_list ss) ss ts)
else (case (actop f (Fun f ss), actop f (Fun g ts)) of {
       (sa, ta) ->
         (case mulextp
                 (\ tb u ->
                   (ackbo_impl w w0 pr_strict ac tb u,
                     equal_acterm (aocnf ac ac tb) (aocnf ac ac u)))
                 (filter_fun sa (\ x y -> not (pr_strict y x))
                   (f, nat_of_integer (2 :: Integer)))
                 (plus_multiset
                   (filter_fun ta (\ x y -> not (pr_strict y x))
                     (f, nat_of_integer (2 :: Integer)))
                   (minus_multiset (filter_mset is_Var ta)
                     (filter_mset is_Var sa)))
           of {
           (True, _) -> True;
           (False, ns) ->
             (if ns && less_nat (size_multiset ta) (size_multiset sa) then True
               else (if ns && equal_nat (size_multiset sa) (size_multiset ta)
                      then smulextp
                             (\ tb u ->
                               (ackbo_impl w w0 pr_strict ac tb u,
                                 equal_acterm (aocnf ac ac tb) (aocnf ac ac u)))
                             (filter_fun sa (\ x y -> pr_strict y x)
                               (f, nat_of_integer (2 :: Integer)))
                             (filter_fun ta (\ x y -> pr_strict y x)
                               (f, nat_of_integer (2 :: Integer)))
                      else False));
         });
     }))
                                 else False));
                    });
                }))
    else False);

ackbo_strict ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Showl a, Eq b,
      Showl b) => ((a, Nat) -> (a, Nat) -> Bool) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        Set a ->
                          (Term a b, Term a b) -> Sum (String -> String) ();
ackbo_strict pr w w0 acset =
  (\ (s, t) ->
    check (ackbo_impl w w0 pr acset s t)
      ((((showsl_lit "could not orient " . showsl_terma s) .
          showsl_lit " >ACKBO ") .
         showsl_terma t) .
        showsl_literal "\n"));

apply_af_entry :: forall a b. a -> Af_entry -> [Term a b] -> Term a b;
apply_af_entry uu (Collapse i) ts = nth ts i;
apply_af_entry f (AFList is) ts = Fun f (map (nth ts) is);

afs_term :: forall a b. Afs a -> Term a b -> Term (Filtered a) b;
afs_term pi (Fun f ts) =
  let {
    l = size_list ts;
  } in apply_af_entry (FPair f l) (afsa pi (f, l)) (map (afs_term pi) ts);
afs_term pi (Var x) = Var x;

afs_rule ::
  forall a b.
    Afs a -> (Term a b, Term a b) -> (Term (Filtered a) b, Term (Filtered a) b);
afs_rule pi lr = (afs_term pi (fst lr), afs_term pi (snd lr));

af_rule :: forall a b. Afs a -> (Term a b, Term a b) -> (Term a b, Term a b);
af_rule pi = (\ t -> map_funs_rule filtered_fun (afs_rule pi t));

af_term :: forall a b. Afs a -> Term a b -> Term a b;
af_term pi (Fun f ts) =
  apply_af_entry f (afsa pi (f, size_list ts)) (map (af_term pi) ts);
af_term pi (Var x) = Var x;

nat_or_empty ::
  forall a b c.
    ([Xml], (a, (b, (c, [String])))) -> Sum_bot (Xml_error String) (Maybe Nat);
nat_or_empty ([], s) = right Nothing;
nat_or_empty ([XML_text txt], s) = (case int_of_string txt of {
                                     Inl err -> xml_error err ([], s);
                                     Inr n -> right (Just (nat n));
                                   });

uncurry_info ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       (a, ([((a, Nat), [a])],
                             ([(Term a [Char], Term a [Char])],
                               [(Term a [Char], Term a [Char])])));
uncurry_info xml2name =
  xml_do "uncurryInformation"
    (xml_take xml2name
      (\ a ->
        xml_take
          (xml_do "uncurriedSymbols"
            (xml_take_many_sub [] zero_nat Infinity_enat
              (xml_do "uncurriedSymbolEntry"
                (xml_take xml2name
                  (\ f ->
                    xml_take (xml_nat "arity")
                      (\ n ->
                        xml_take_many_sub [] zero_nat Infinity_enat xml2name
                          (\ fs -> xml_return ((f, n), fs))))))
              xml_return))
          (\ sml ->
            xml_take
              (xml_do "uncurryRules"
                (xml_take (rules xml2name) (\ x -> xml_return (id x))))
              (\ u ->
                xml_take
                  (xml_do "etaRules"
                    (xml_take (rules xml2name) (\ x -> xml_return (id x))))
                  (\ e -> xml_return (a, (sml, (u, e))))))));

convertible_critical_peaks ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       [(Term a [Char],
                          (Term a [Char],
                            ([([Nat],
                                ((Term a [Char], Term a [Char]),
                                  (Bool, Term a [Char])))],
                              ([([Nat],
                                  ((Term a [Char], Term a [Char]),
                                    Term a [Char]))],
                                ([([Nat],
                                    ((Term a [Char], Term a [Char]),
                                      (Bool, Term a [Char])))],
                                  (Term a [Char],
                                    ([([Nat],
((Term a [Char], Term a [Char]), (Bool, Term a [Char])))],
                                      ([([Nat],
  ((Term a [Char], Term a [Char]), Term a [Char]))],
[([Nat], ((Term a [Char], Term a [Char]), (Bool, Term a [Char])))]))))))))];
convertible_critical_peaks xml2name =
  let {
    rew = rsteps xml2name;
    conv = conversion xml2name;
  } in xml_do "convertibleCriticalPeaks"
         (xml_take_many_sub [] zero_nat Infinity_enat
           (xml_do "convertibleCriticalPeak"
             (xml_take
               (xml_do "source"
                 (xml_take (term xml2name) (\ x -> xml_return (id x))))
               (\ s ->
                 xml_take
                   (xml_do "conversionLeft"
                     (xml_take conv
                       (\ (sa, c1) ->
                         xml_take rew
                           (\ (_, r) ->
                             xml_take conv
                               (\ (_, c2) -> xml_return (sa, (c1, (r, c2))))))))
                   (\ (s1, (cl1, (sl, cl2))) ->
                     xml_take
                       (xml_do "conversionRight"
                         (xml_take conv
                           (\ (sa, c1) ->
                             xml_take rew
                               (\ (_, r) ->
                                 xml_take conv
                                   (\ (_, c2) ->
                                     xml_return (sa, (c1, (r, c2))))))))
                       (\ (s2, (cr1, (sr, cr2))) ->
                         xml_return
                           (s, (s1, (cl1, (sl,
    (cl2, (s2, (cr1, (sr, cr2)))))))))))))
           xml_return);

ordering_constraint_proof ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   Bool ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) (Redtriple_impl a);
ordering_constraint_proof xml2name bi =
  xml_do "orderingConstraintProof"
    (xml_take
      (xml_do "redPair"
        (xml_take (redtriple xml2name bi) (\ x -> xml_return (id x))))
      (\ x -> xml_return (id x)));

ordering_constraint_proofa ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   Bool ->
                     (Xml, ([([Char], [Char])],
                             (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String)
                         (Sum (Root_redtriple_impl a) (Redtriple_impl a));
ordering_constraint_proofa xml2name bi =
  xml_do "orderingConstraintProof"
    (xml_take (redtriplea xml2name bi) (\ x -> xml_return (id x)));

create_proj :: forall a. (Compare_order a) => ProjL a -> (a, Nat) -> Nat;
create_proj (Projection p) = let {
                               i = ceta_map_of p;
                             } in (\ f -> (case i f of {
    Nothing -> zero_nat;
    Just n -> n;
  }));

xml2cond_constraint ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Cond_constraint a [Char]);
xml2cond_constraint xml2name x =
  xml_do "conditionalConstraint"
    (xml_take
      (xml_or
        (xml_do "all"
          (xml_take (xml_text "var")
            (\ a ->
              xml_take (xml2cond_constraint xml2name)
                (\ b -> xml_return (CC_all a b)))))
        (xml_or
          (xml_do "implication"
            (xml_take (xml2cond_constraint xml2name)
              (\ c ->
                xml_take_many_sub [] zero_nat Infinity_enat
                  (xml2cond_constraint xml2name)
                  (\ cs ->
                    let {
                      ccs = c : cs;
                    } in xml_return
                           (CC_impl (take (size_list cs) ccs) (last ccs))))))
          (xml_do "constraint"
            (xml_take (term xml2name)
              (\ s ->
                xml_take
                  (xml_or (xml_leaf "rewrite" Nothing)
                    (xml_or (xml_leaf "strict" (Just True))
                      (xml_leaf "nonStrict" (Just False))))
                  (\ rel ->
                    xml_take (term xml2name)
                      (\ t ->
                        xml_return (case rel of {
                                     Nothing -> CC_rewr s t;
                                     Just stri -> CC_cond stri (s, t);
                                   }))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2cond_constraint_prf ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Cond_constraint_prf a [Char]);
xml2cond_constraint_prf xml2name x =
  let {
    cc = xml2cond_constraint xml2name;
  } in xml_do "conditionalConstraintProof"
         (xml_take
           (xml_or (xml_leaf "final" Final)
             (xml_or
               (xml_do "differentConstructor"
                 (xml_take cc (\ a -> xml_return (Different_Constructor a))))
               (xml_or
                 (xml_do "sameConstructor"
                   (xml_take cc
                     (\ a ->
                       xml_take cc
                         (\ b ->
                           xml_take (xml2cond_constraint_prf xml2name)
                             (\ c -> xml_return (Same_Constructor a b c))))))
                 (xml_or
                   (xml_do "variableEquation"
                     (xml_take (xml_text "var")
                       (\ a ->
                         xml_take (term xml2name)
                           (\ b ->
                             xml_take cc
                               (\ c ->
                                 xml_take (xml2cond_constraint_prf xml2name)
                                   (\ d ->
                                     xml_return
                                       (Variable_Equation a b c d)))))))
                   (xml_or
                     (xml_do "funargIntoVar"
                       (xml_take cc
                         (\ a ->
                           xml_take position
                             (\ b ->
                               xml_take (xml_text "var")
                                 (\ c ->
                                   xml_take cc
                                     (\ d ->
                                       xml_take
 (xml2cond_constraint_prf xml2name)
 (\ e -> xml_return (Funarg_Into_Var a b c d e))))))))
                     (xml_or
                       (xml_do "simplifyCondition"
                         (xml_take cc
                           (\ a ->
                             xml_take (substa xml2name)
                               (\ b ->
                                 xml_take cc
                                   (\ c ->
                                     xml_take (xml2cond_constraint_prf xml2name)
                                       (\ d ->
 xml_return (Simplify_Condition a b c d)))))))
                       (xml_or
                         (xml_do "induction"
                           (xml_take cc
                             (\ a ->
                               xml_take
                                 (xml_do "conjuncts"
                                   (xml_take_many_sub [] zero_nat Infinity_enat
                                     cc xml_return))
                                 (\ b ->
                                   xml_take
                                     (xml_do "ruleConstraintProofs"
                                       (xml_take_many_sub [] zero_nat
 Infinity_enat
 (xml_do "ruleConstraintProof"
   (xml_take (rule xml2name)
     (\ lr ->
       xml_take
         (xml_do "subtermVarEntries"
           (xml_take_many_sub [] zero_nat Infinity_enat
             (xml_do "subtermVarEntry"
               (xml_take (term xml2name)
                 (\ aa ->
                   xml_take_many_sub [] zero_nat Infinity_enat (xml_text "var")
                     (\ ba -> xml_return (aa, ba)))))
             xml_return))
         (\ rys ->
           xml_take cc
             (\ cca ->
               xml_take (xml2cond_constraint_prf xml2name)
                 (\ p -> xml_return (lr, (rys, (cca, p)))))))))
 xml_return))
                                     (\ c -> xml_return (Induction a b c))))))
                         (xml_do "deleteCondition"
                           (xml_take cc
                             (\ a ->
                               xml_take (xml2cond_constraint_prf xml2name)
                                 (\ b ->
                                   xml_return (Delete_Condition a b))))))))))))
           (\ xa -> xml_return (id xa)))
         x;

xml2cond_red_pair_proof ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Cond_red_pair_prf a [Char]);
xml2cond_red_pair_proof xml2name =
  xml_do "condRedPairProof"
    (xml_take xml2name
      (\ c ->
        xml_take (xml_nat "before")
          (\ b ->
            xml_take (xml_nat "after")
              (\ a ->
                xml_take
                  (xml_do "conditions"
                    (xml_take_many_sub [] zero_nat Infinity_enat
                      (xml_do "condition"
                        (xml_take (xml2cond_constraint xml2name)
                          (\ ca ->
                            xml_take
                              (xml_do "dpSequence"
                                (xml_take (rules xml2name)
                                  (\ x -> xml_return (id x))))
                              (\ s ->
                                xml_take (xml2cond_constraint_prf xml2name)
                                  (\ p -> xml_return (ca, (s, p)))))))
                      xml_return))
                  (\ ccs -> xml_return (Cond_Red_Pair_Prf c ccs b a))))));

projected_rseq ::
  forall a.
    (Eq a,
      Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) a) ->
                    ((a, Nat) -> Nat) ->
                      (Xml, ([([Char], [Char])],
                              (Bool, ([String], [String])))) ->
                        Sum_bot (Xml_error String)
                          ((Term a [Char], Term a [Char]),
                            [([Nat],
                               ((Term a [Char], Term a [Char]),
                                 Term a [Char]))]);
projected_rseq xml2name pi =
  xml_do "projectedRewriteSequence"
    (xml_take (rule xml2name)
      (\ r -> xml_take (rseq xml2name pi r) xml_return));

default_nfs_nt_dp :: Bool;
default_nfs_nt_dp = False;

strategy_to_Q ::
  forall a b.
    (Eq a, Eq b) => Strategy a b -> [(Term a b, Term a b)] -> [Term a b];
strategy_to_Q No_Strategy uu = [];
strategy_to_Q Innermost r = remdups (map fst r);
strategy_to_Q (Innermost_Q q) uv = q;

default_nfs_dp :: Bool;
default_nfs_dp = True;

xml2dp_inputa ::
  forall a b c.
    (Eq a,
      Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) a) ->
                    Bool ->
                      (Xml, ([([Char], [Char])],
                              (Bool, ([String], [String])))) ->
                        Sum_bot (Xml_error String)
                          (Bool,
                            (Bool,
                              ([(Term a [Char], Term a [Char])],
                                ([b], ([Term a [Char]],
([c], [(Term a [Char], Term a [Char])]))))));
xml2dp_inputa xml2name termination =
  xml_change (xml2dp_input xml2name)
    (\ (DP_input m p q r) ->
      xml_return
        ((if termination then default_nfs_dp else default_nfs_nt_dp),
          (m, (p, ([], (strategy_to_Q q r, ([], r)))))));

flat_contexts ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) [Ctxt a [Char]];
flat_contexts xml2name =
  xml_do "flatContexts"
    (xml_take_many_sub [] zero_nat Infinity_enat (ctxt xml2name) xml_return);

equal_start_term :: Start_term -> Start_term -> Bool;
equal_start_term Full Constructor_Based = False;
equal_start_term Constructor_Based Full = False;
equal_start_term Constructor_Based Constructor_Based = True;
equal_start_term Full Full = True;

o_to_fp_term :: forall a b. Term a b -> (Ctxt a b, (Term a b, Location));
o_to_fp_term t = (Hole, (t, Ba));

o_to_fp_impl :: forall a b. [Term a b] -> [(Ctxt a b, (Term a b, Location))];
o_to_fp_impl = map o_to_fp_term;

mu_to_fp_impl ::
  forall a.
    (Eq a) => [((a, Nat), [Nat])] ->
                [(Ctxt a [Char], (Term a [Char], Location))];
mu_to_fp_impl mu =
  let {
    fs = remdups (map fst mu);
    m = map_of mu;
    a = concatMap
          (\ f ->
            let {
              xs = map Var
                     (fresh_strings_list
                       [Char False False False True True True True False]
                       zero_nat [] (snd f));
            } in map (\ i -> (f, (xs, i)))
                   (concatMap
                     (\ i -> (if not (membera (the (m f)) i) then [i] else []))
                     (upt zero_nat (snd f))))
          fs;
  } in concatMap
         (\ (aa, b) ->
           (case aa of {
             (f, _) ->
               (\ (xs, i) ->
                 map (\ loc ->
                       (ctxt_of_pos_term [i] (Fun f xs), (nth xs i, loc)))
                   [Ba, H]);
           })
             b)
         a;

strategy_to_fp ::
  forall a.
    (Eq a) => Fp_strategy a [Char] ->
                [(Term a [Char], Term a [Char])] ->
                  [(Ctxt a [Char], (Term a [Char], Location))];
strategy_to_fp (Forbidden_Patterns p) r = p;
strategy_to_fp Outermost r = o_to_fp_impl (map fst r);
strategy_to_fp (Context_Sensitive mu) r = mu_to_fp_impl mu;

default_nfs_trs :: Bool;
default_nfs_trs = False;

xml2inn_fp_trs_assm ::
  forall a.
    (Eq a,
      Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) a) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Sum (Bool,
                               ([Term a [Char]],
                                 ([(Term a [Char], Term a [Char])],
                                   [(Term a [Char], Term a [Char])])))
                          ([(Ctxt a [Char], (Term a [Char], Location))],
                            [(Term a [Char], Term a [Char])]));
xml2inn_fp_trs_assm xml2name =
  xml_change (xml2_trs_input xml2name)
    (\ a ->
      (case a of {
        DP_input _ _ _ _ -> xml_error "trs as input required";
        Inn_TRS_input inn r s start ->
          (if not (equal_start_term start Full)
            then xml_error "start term is not allowed here"
            else xml_return
                   (Inl (default_nfs_trs, (strategy_to_Q inn r, (r, s)))));
        CPX_input _ _ _ _ _ -> xml_error "trs as input required";
        COMP_input _ _ -> xml_error "trs as input required";
        OCOMP_input _ _ _ _ -> xml_error "trs as input required";
        EQ_input _ _ -> xml_error "trs as input required";
        FP_TRS_input fp r -> xml_return (Inr (strategy_to_fp fp r, r));
        CTRS_input _ -> xml_error "trs as input required";
        TA_input _ _ -> xml_error "trs as input required";
        AC_input _ _ _ -> xml_error "trs as input required";
        LTS_input _ -> xml_error "trs as input required";
        LTS_safety_input _ _ -> xml_error "trs as input required";
        Infeasibility_input _ _ -> xml_error "trs as input required";
        Unknown_input _ -> xml_error "trs as input required";
      }));

xml2fp_trs_assm ::
  forall a.
    (Eq a,
      Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) a) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        ([(Ctxt a [Char], (Term a [Char], Location))],
                          [(Term a [Char], Term a [Char])]);
xml2fp_trs_assm xml2name =
  xml_change (xml2inn_fp_trs_assm xml2name)
    (\ a -> (case a of {
              Inl _ -> xml_error "FP TRS expected at this point";
              Inr aa -> xml_return aa;
            }));

xml2inn_trs_assm ::
  forall a.
    (Eq a,
      Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) a) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Bool,
                          ([Term a [Char]],
                            ([(Term a [Char], Term a [Char])],
                              [(Term a [Char], Term a [Char])])));
xml2inn_trs_assm xml2name =
  xml_change (xml2inn_fp_trs_assm xml2name)
    (\ a ->
      (case a of {
        Inl aa -> xml_return aa;
        Inr _ -> xml_error "innermost (relative) TRS expected at this point";
      }));

xml2trs_termination_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Trs_termination_proof a b [Char]);
xml2trs_termination_proof xml2name x =
  xml_or
    (xml_do "trsTerminationProof"
      (xml_take (xml2trs_termination_proof_inner xml2name)
        (\ xa -> xml_return (id xa))))
    (xml_do "relativeTerminationProof"
      (xml_take (xml2trs_termination_proof_inner xml2name)
        (\ xa -> xml_return (id xa))))
    x;

xml2dp_termination_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Dp_termination_proof a b [Char]);
xml2dp_termination_proof xml2name x =
  xml_do "dpProof"
    (xml_take
      (xml_or (xml_do "pIsEmpty" (xml_return P_is_Empty))
        (xml_or
          (xml_do "depGraphProc"
            (xml_take_many_sub [] zero_nat Infinity_enat
              (xml_do "component"
                (xml_take
                  (xml_do "dps"
                    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                  (\ dps ->
                    xml_take_optional (xml_bool "realScc")
                      (\ _ ->
                        xml_take_optional
                          (xml_do "arcs"
                            (xml_take_many_sub [] zero_nat Infinity_enat
                              (\ xa -> right (fst xa)) (\ _ -> xml_return ())))
                          (\ _ ->
                            xml_take_optional
                              (xml2dp_termination_proof xml2name)
                              (\ prfOpt -> xml_return (prfOpt, dps)))))))
              (\ a -> xml_return (Dep_Graph_Proc a))))
          (xml_or
            (xml_do "redPairProc"
              (xml_take (ordering_constraint_proofa xml2name False)
                (\ a ->
                  xml_take
                    (xml_do "dps"
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ b ->
                      xml_take (xml2dp_termination_proof xml2name)
                        (\ c -> xml_return (Redpair_Proc a b c))))))
            (xml_or
              (xml_do "usableRulesProc"
                (xml_take
                  (xml_do "usableRules"
                    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                  (\ a ->
                    xml_take (xml2dp_termination_proof xml2name)
                      (\ b -> xml_return (Usable_Rules_Proc a b)))))
              (xml_or
                (xml_do "innermostLhssRemovalProc"
                  (xml_take (innermostLhss xml2name)
                    (\ a ->
                      xml_take (xml2dp_termination_proof xml2name)
                        (\ b -> xml_return (Q_Reduction_Proc a b)))))
                (xml_or
                  (xml_do "rewritingProc"
                    (xml_take (rule xml2name)
                      (\ (s, t) ->
                        xml_take (rstep xml2name)
                          (\ (p, (lr, ta)) ->
                            xml_take_default (s, ta) (rule xml2name)
                              (\ st ->
                                xml_take_optional
                                  (xml_do "usableRules"
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ ur ->
                                    xml_take (xml2dp_termination_proof xml2name)
                                      (\ prof ->
xml_return (Rewriting_Proc ur (s, t) (s, ta) st lr p prof))))))))
                  (xml_or
                    (xml_do "narrowingProc"
                      (xml_take (rule xml2name)
                        (\ a ->
                          xml_take pos
                            (\ b ->
                              xml_take
                                (xml_do "narrowings"
                                  (xml_take (rules xml2name)
                                    (\ xa -> xml_return (id xa))))
                                (\ c ->
                                  xml_take (xml2dp_termination_proof xml2name)
                                    (\ d ->
                                      xml_return (Narrowing_Proc a b c d)))))))
                    (xml_or
                      (xml_do "instantiationProc"
                        (xml_take (rule xml2name)
                          (\ a ->
                            xml_take
                              (xml_do "instantiations"
                                (xml_take (rules xml2name)
                                  (\ xa -> xml_return (id xa))))
                              (\ b ->
                                xml_take (xml2dp_termination_proof xml2name)
                                  (\ c ->
                                    xml_return (Instantiation_Proc a b c))))))
                      (xml_or
                        (xml_do "forwardInstantiationProc"
                          (xml_take (rule xml2name)
                            (\ a ->
                              xml_take
                                (xml_do "instantiations"
                                  (xml_take (rules xml2name)
                                    (\ xa -> xml_return (id xa))))
                                (\ b ->
                                  xml_take_optional
                                    (xml_do "usableRules"
                                      (xml_take (rules xml2name)
(\ xa -> xml_return (id xa))))
                                    (\ c ->
                                      xml_take
(xml2dp_termination_proof xml2name)
(\ d -> xml_return (Forward_Instantiation_Proc a b c d)))))))
                        (xml_or
                          (xml_do "semlabProc"
                            (xml_take (sl_variant xml2name)
                              (\ sli ->
                                xml_take
                                  (xml_do "dps"
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ lp ->
                                    xml_take
                                      (xml_do "trs"
(xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                                      (\ lr ->
xml_take_default [] (innermostLhss xml2name)
  (\ lq ->
    xml_take (xml2dp_termination_proof xml2name)
      (\ p -> xml_return (Semlab_Proc sli lp lq lr p))))))))
                          (xml_or
                            (xml_do "subtermProc"
                              (xml_take
                                (xml_or
                                  (xml_change (proj xml2name)
                                    (xml_return . Inl))
                                  (xml_change (multiset_af xml2name)
                                    (xml_return . Inr)))
                                (\ pi_mpi ->
                                  xml_take_many_sub [] zero_nat Infinity_enat
                                    (projected_rseq xml2name
                                      (create_proj (case pi_mpi of {
             Inl lpi -> lpi;
             Inr _ -> Projection [];
           })))
                                    (\ seq ->
                                      xml_take
(xml_do "dps" (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
(\ dps ->
  xml_take (xml2dp_termination_proof xml2name)
    (\ prf ->
      xml_return (case pi_mpi of {
                   Inl lpi -> Subterm_Criterion_Proc lpi seq dps prf;
                   Inr mpi -> Gen_Subterm_Criterion_Proc mpi dps prf;
                 })))))))
                            (xml_or
                              (xml_do "redPairUrProc"
                                (xml_take
                                  (ordering_constraint_proofa xml2name False)
                                  (\ a ->
                                    xml_take
                                      (xml_do "dps"
(xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                                      (\ b ->
xml_take
  (xml_do "usableRules"
    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
  (\ c ->
    xml_take (xml2dp_termination_proof xml2name)
      (\ d -> xml_return (Redpair_UR_Proc a b c d)))))))
                              (xml_or
                                (xml_do "monoRedPairUrProc"
                                  (xml_take
                                    (ordering_constraint_proof xml2name False)
                                    (\ a ->
                                      xml_take
(xml_do "dps" (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
(\ b ->
  xml_take
    (xml_do "trs" (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
    (\ c ->
      xml_take
        (xml_do "usableRules"
          (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
        (\ d ->
          xml_take (xml2dp_termination_proof xml2name)
            (\ e -> xml_return (Mono_Redpair_UR_Proc a b c d e))))))))
                                (xml_or
                                  (xml_do "monoRedPairProc"
                                    (xml_take
                                      (ordering_constraint_proof xml2name False)
                                      (\ a ->
xml_take (xml_do "dps" (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
  (\ b ->
    xml_take
      (xml_do "trs" (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
      (\ c ->
        xml_take (xml2dp_termination_proof xml2name)
          (\ d -> xml_return (Mono_Redpair_Proc a b c d)))))))
                                  (xml_or
                                    (xml_do "innermostMonoRedPairProc"
                                      (xml_take
(ordering_constraint_proof xml2name False)
(\ rp ->
  xml_take
    (xml_do "deleted"
      (xml_take
        (xml_do "dps" (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
        (\ xa ->
          xml_take
            (xml_do "trs"
              (xml_take (rules xml2name) (\ xb -> xml_return (id xb))))
            (\ y -> xml_return (xa, y)))))
    (\ (p, r) ->
      xml_take (xml2dp_termination_proof xml2name)
        (\ c -> xml_return (Mono_URM_Redpair_Proc rp p r c))))))
                                    (xml_or
                                      (xml_do "uncurryProc"
(xml_take_optional (xml_nat "applicativeTop")
  (\ a ->
    xml_take (uncurry_info xml2name)
      (\ b ->
        xml_take
          (xml_do "dps"
            (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
          (\ c ->
            xml_take
              (xml_do "trs"
                (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
              (\ d ->
                xml_take (xml2dp_termination_proof xml2name)
                  (\ e -> xml_return (Uncurry_Proc a b c d e))))))))
                                      (xml_or
(xml_do "flatContextClosureProc"
  (xml_take
    (xml_do "freshSymbol" (xml_take xml2name (\ xa -> xml_return (id xa))))
    (\ a ->
      xml_take (flat_contexts xml2name)
        (\ b ->
          xml_take
            (xml_do "dps"
              (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
            (\ c ->
              xml_take
                (xml_do "trs"
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ d ->
                  xml_take (xml2dp_termination_proof xml2name)
                    (\ e -> xml_return (Fcc_Proc a b c d e))))))))
(xml_or
  (xml_do "switchInnermostProc"
    (xml_take (wcr_proof xml2name)
      (\ a ->
        xml_take (xml2dp_termination_proof xml2name)
          (\ b -> xml_return (Switch_Innermost_Proc a b)))))
  (xml_or
    (xml_do "splitProc"
      (xml_take
        (xml_do "dps" (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
        (\ a ->
          xml_take
            (xml_do "trs"
              (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
            (\ b ->
              xml_take (xml2dp_termination_proof xml2name)
                (\ c ->
                  xml_take (xml2dp_termination_proof xml2name)
                    (\ d -> xml_return (Split_Proc a b c d)))))))
    (xml_or
      (xml_do "finitenessAssumption"
        (xml_take (xml2dp_inputa xml2name True)
          (\ dpp -> xml_return (Assume_Finite dpp []))))
      (xml_or
        (xml_do "unknownProof"
          (xml_take (xml_text "description")
            (\ _ ->
              xml_take (xml2dp_inputa xml2name True)
                (\ b ->
                  xml_take_many_sub [] zero_nat Infinity_enat
                    (xml2subproof xml2name)
                    (\ c -> xml_return (Assume_Finite b c))))))
        (xml_or
          (xml_do "switchToTRS"
            (xml_take (xml2trs_termination_proof xml2name)
              (\ a -> xml_return (To_Trs_Proc a))))
          (xml_or
            (xml_do "unlabProc"
              (xml_take
                (xml_do "dps"
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ a ->
                  xml_take
                    (xml_do "trs"
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ b ->
                      xml_take (xml2dp_termination_proof xml2name)
                        (\ c -> xml_return (Unlab_Proc a b c))))))
            (xml_or
              (xml_do "generalRedPairProc"
                (xml_take (ordering_constraint_proof xml2name True)
                  (\ rp ->
                    xml_take
                      (xml_do "strict"
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ s ->
                        xml_take
                          (xml_do "bound"
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ b ->
                            xml_take (xml2cond_red_pair_proof xml2name)
                              (\ c ->
                                xml_take (xml2dp_termination_proof xml2name)
                                  (\ ps ->
                                    xml_take_optional
                                      (xml2dp_termination_proof xml2name)
                                      (\ pbo ->
xml_return (General_Redpair_Proc rp s b c (case pbo of {
    Nothing -> [ps];
    Just pb -> [ps, pb];
  }))))))))))
              (xml_or
                (xml_do "complexConstantRemovalProc"
                  (xml_take (term xml2name)
                    (\ t ->
                      xml_take
                        (xml_do "ruleMap"
                          (xml_take_many_sub [] zero_nat Infinity_enat
                            (xml_do "ruleMapEntry"
                              (xml_take (rule xml2name)
                                (\ a ->
                                  xml_take (rule xml2name)
                                    (\ b -> xml_return (a, b)))))
                            xml_return))
                        (\ rls ->
                          xml_take (xml2dp_termination_proof xml2name)
                            (\ prf ->
                              xml_return
                                (Complex_Constant_Removal_Proc
                                  (Complex_Constant_Removal_Proof t rls)
                                  prf))))))
                (xml_do "sizeChangeProc"
                  (xml_take
                    (xml_or (xml_leaf "subtermCriterion" Nothing)
                      (xml_do "reductionPair"
                        (xml_take (ordering_constraint_proof xml2name False)
                          (\ redp ->
                            xml_take_optional
                              (xml_do "usableRules"
                                (xml_take (rules xml2name)
                                  (\ xa -> xml_return (id xa))))
                              (\ ur -> xml_return (Just (redp, ur)))))))
                    (\ version ->
                      xml_take_many_sub [] zero_nat Infinity_enat (scg xml2name)
                        (\ b ->
                          (case version of {
                            Nothing -> xml_return (Size_Change_Subterm_Proc b);
                            Just redp_ur ->
                              xml_return
                                (Size_Change_Redpair_Proc (fst redp_ur)
                                  (snd redp_ur) b);
                          }))))))))))))))))))))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2subproof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Generic_assm_proof a b [Char]
                          (Trs_termination_proof a b [Char])
                          (Dp_termination_proof a b [Char])
                          (Fptrs_termination_proof a b [Char]) ()
                          (Unknown_proof a b [Char]));
xml2subproof xml2name x =
  xml_do "subProof"
    (xml_or
      (xml_take (xml2dp_inputa xml2name True)
        (\ inp ->
          xml_take (xml2dp_termination_proof xml2name)
            (\ prf -> xml_return (Finite_assm_proof inp prf))))
      (xml_take (xml2inn_fp_trs_assm xml2name)
        (\ a ->
          (case a of {
            Inl qtrs ->
              xml_take (xml2trs_termination_proof xml2name)
                (\ prf -> xml_return (SN_assm_proof qtrs prf));
            Inr fptrs ->
              xml_take (xml2fptrs_termination_proof xml2name)
                (\ prf -> xml_return (SN_FP_assm_proof fptrs prf));
          }))))
    x;

xml2fptrs_termination_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Fptrs_termination_proof a b [Char]);
xml2fptrs_termination_proof xml2name x =
  xml_do "trsTerminationProof"
    (xml_take
      (xml_or
        (xml_do "terminationAssumption"
          (xml_take (xml2fp_trs_assm xml2name)
            (\ inp -> xml_return (Assume_FP_SN inp []))))
        (xml_do "unknownProof"
          (xml_take (xml2fp_trs_assm xml2name)
            (\ inp ->
              xml_take_many_sub [] zero_nat Infinity_enat
                (xml2subproof xml2name)
                (\ subprfs -> xml_return (Assume_FP_SN inp subprfs))))))
      xml_return)
    x;

xml2trs_termination_proof_inner ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Trs_termination_proof a b [Char]);
xml2trs_termination_proof_inner xml2name x =
  xml_or (xml_do "rIsEmpty" (xml_return R_is_Empty))
    (xml_or
      (xml_do "sIsEmpty"
        (xml_take (xml2trs_termination_proof xml2name) xml_return))
      (xml_or
        (xml_do "semlab"
          (xml_take (sl_variant xml2name)
            (\ sli ->
              xml_take
                (xml_do "trs"
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ lr ->
                  xml_take_default []
                    (xml_do "trs"
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ lrw ->
                      xml_take_default [] (innermostLhss xml2name)
                        (\ lq ->
                          xml_take (xml2trs_termination_proof xml2name)
                            (\ p ->
                              xml_return (Semlab sli lq (lr ++ lrw) p))))))))
        (xml_or
          (xml_do "split"
            (xml_take
              (xml_do "trs"
                (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
              (\ a ->
                xml_take (xml2trs_termination_proof xml2name)
                  (\ b ->
                    xml_take (xml2trs_termination_proof xml2name)
                      (\ c -> xml_return (Split a b c))))))
          (xml_or
            (xml_do "dpTrans"
              (xml_take
                (xml_do "dps"
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ dps ->
                  xml_take (xml_bool "markedSymbols")
                    (\ _ ->
                      xml_take (xml2dp_termination_proof xml2name)
                        (\ prf ->
                          xml_return (DP_Trans default_nfs_dp True dps prf))))))
            (xml_or
              (xml_do "ruleRemoval"
                (xml_take (ordering_constraint_proof xml2name False)
                  (\ ord ->
                    xml_take
                      (xml_do "trs"
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ r ->
                        xml_take_default []
                          (xml_do "trs"
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ s ->
                            xml_take (xml2trs_termination_proof xml2name)
                              (\ p ->
                                xml_return (Rule_Removal ord (r ++ s) p)))))))
              (xml_or (xml_change (bounds_info xml2name) (xml_return . Bounds))
                (xml_or
                  (xml_do "stringReversal"
                    (xml_take
                      (xml_do "trs"
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ _ ->
                        xml_take_optional
                          (xml_do "trs"
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ _ ->
                            xml_take (xml2trs_termination_proof xml2name)
                              (\ prf -> xml_return (String_Reversal prf))))))
                  (xml_or
                    (xml_do "equalityRemoval"
                      (xml_take (xml2trs_termination_proof xml2name)
                        (\ a -> xml_return (Drop_Equality a))))
                    (xml_or
                      (xml_do "constantToUnary"
                        (xml_take plain_var
                          (\ v ->
                            xml_take (renaming xml2name)
                              (\ ren ->
                                xml_take
                                  (xml_do "trs"
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ s ->
                                    xml_take_default []
                                      (xml_do "trs"
(xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                                      (\ sw ->
xml_take (xml2trs_termination_proof xml2name)
  (\ p ->
    xml_return (Constant_String (Const_string_sound_proof v ren s sw) p))))))))
                      (xml_or
                        (xml_do "removeNonApplicableRules"
                          (xml_take
                            (xml_do "trs"
                              (xml_take (rules xml2name)
                                (\ xa -> xml_return (id xa))))
                            (\ a ->
                              xml_take (xml2trs_termination_proof xml2name)
                                (\ b ->
                                  xml_return
                                    (Remove_Nonapplicable_Rules a b)))))
                        (xml_or
                          (xml_do "uncurry"
                            (xml_take (uncurry_info xml2name)
                              (\ i ->
                                xml_take
                                  (xml_do "trs"
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ r ->
                                    xml_take_default []
                                      (xml_do "trs"
(xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                                      (\ s ->
xml_take (xml2trs_termination_proof xml2name)
  (\ p -> xml_return (Uncurry i (r ++ s) p)))))))
                          (xml_or
                            (xml_do "flatContextClosure"
                              (xml_take (flat_contexts xml2name)
                                (\ i ->
                                  xml_take
                                    (xml_do "trs"
                                      (xml_take (rules xml2name)
(\ xa -> xml_return (id xa))))
                                    (\ r ->
                                      xml_take_default []
(xml_do "trs" (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
(\ s ->
  xml_take (xml2trs_termination_proof xml2name)
    (\ p -> xml_return (Fcc i (r ++ s) p)))))))
                            (xml_or
                              (xml_do "switchInnermost"
                                (xml_take (wcr_proof xml2name)
                                  (\ a ->
                                    xml_take
                                      (xml2trs_termination_proof xml2name)
                                      (\ b ->
xml_return (Switch_Innermost a b)))))
                              (xml_or
                                (xml_do "permutingArgumentFilter"
                                  (xml_take (afs xml2name)
                                    (\ a ->
                                      xml_take
(xml2trs_termination_proof xml2name) (\ b -> xml_return (Permuting_AFS a b)))))
                                (xml_or
                                  (xml_do "terminationAssumption"
                                    (xml_take (xml2inn_trs_assm xml2name)
                                      (\ qtrs ->
xml_return (Assume_SN qtrs []))))
                                  (xml_or
                                    (xml_do "relativeTerminationAssumption"
                                      (xml_take
(xml_do "trsInput"
  (xml_take
    (xml_do "trs" (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
    (\ r ->
      xml_take_default []
        (xml_do "relativeRules"
          (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
        (\ rw -> xml_return (Assume_SN (default_nfs_trs, ([], (r, rw))) [])))))
xml_return))
                                    (xml_do "unknownProof"
                                      (xml_take (xml_text "description")
(\ _ ->
  xml_take (xml2inn_trs_assm xml2name)
    (\ b ->
      xml_take_many_sub [] zero_nat Infinity_enat (xml2subproof xml2name)
        (\ c -> xml_return (Assume_SN b c))))))))))))))))))))))
    x;

rule_labeling_function ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        [((Term (Lab a b) [Char], Term (Lab a b) [Char]), Nat)];
rule_labeling_function xml2name =
  xml_do "ruleLabelingFunction"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "ruleLabelingFunctionEntry"
        (xml_take (rule xml2name)
          (\ a -> xml_take (xml_nat "label") (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (id a)));

add_source_lab_proof ::
  forall a b c.
    Cr_proof a b c ->
      Maybe Nat -> Trs_termination_proof a b c -> Cr_proof a b c;
add_source_lab_proof (Rule_Labeling rl js uu) uv prf =
  Rule_Labeling rl js (Just prf);
add_source_lab_proof (Rule_Labeling_Conv rl cs uw) (Just n) prf =
  Rule_Labeling_Conv rl cs (Just (n, prf));

xml2ms_signature ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        [(Lab a b, ([[Char]], [Char]))];
xml2ms_signature xml2name =
  xml_do "manySortedSignature"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "manySortedFunction"
        (xml_take xml2name
          (\ a ->
            xml_take
              (xml_do "args"
                (xml_take_many_sub [] zero_nat Infinity_enat (xml_text "sort")
                  (\ aa -> xml_return (id aa))))
              (\ b ->
                xml_take
                  (xml_do "result"
                    (xml_take (xml_text "sort") (\ x -> xml_return (id x))))
                  (\ c -> xml_return (a, (b, c)))))))
      (\ a -> xml_return (id a)));

xml2cr_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) (Cr_proof a b [Char]);
xml2cr_proof xml2name x =
  xml_do "crProof"
    (xml_take
      (xml_or
        (xml_do "wcrAndSN"
          (xml_take (wcr_proof xml2name)
            (\ a ->
              xml_take (xml2trs_termination_proof xml2name)
                (\ b -> xml_return (SN_WCR a b)))))
        (xml_or (xml_leaf "orthogonal" Weakly_Orthogonal)
          (xml_or
            (xml_change (xml_nat "stronglyClosed")
              (xml_return . Strongly_Closed))
            (xml_or
              (xml_change (xml_do "parallelClosed" nat_or_empty)
                (xml_return . Parallel_Closed))
              (xml_or
                (xml_do "criticalPairClosingSystem"
                  (xml_take
                    (xml_do "trs"
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ a ->
                      xml_take (xml2trs_termination_proof xml2name)
                        (\ b ->
                          xml_take (xml_nat "nrSteps")
                            (\ c ->
                              xml_return
                                (Critical_Pair_Closing_System a b c))))))
                (xml_or
                  (xml_do "ruleLabeling"
                    (xml_take (rule_labeling_function xml2name)
                      (\ a ->
                        xml_take (joinable_critical_pairs xml2name)
                          (\ b -> xml_return (Rule_Labeling a b Nothing)))))
                  (xml_or
                    (xml_do "decreasingDiagrams"
                      (xml_take_optional (xml2trs_termination_proof xml2name)
                        (\ a ->
                          xml_take
                            (xml_or
                              (xml_do "ruleLabeling"
                                (xml_take (rule_labeling_function xml2name)
                                  (\ rl ->
                                    xml_take (joinable_critical_pairs xml2name)
                                      (\ js ->
(case a of {
  Nothing -> xml_return (Rule_Labeling rl js Nothing);
  Just prf ->
    xml_return (add_source_lab_proof (Rule_Labeling rl js Nothing) Nothing prf);
})))))
                              (xml_do "ruleLabelingConv"
                                (xml_take (rule_labeling_function xml2name)
                                  (\ rl ->
                                    xml_take
                                      (convertible_critical_peaks xml2name)
                                      (\ cs ->
(case a of {
  Nothing -> xml_return (Rule_Labeling_Conv rl cs Nothing);
  Just prf ->
    xml_take (xml_nat "nrSteps")
      (\ n ->
        xml_return
          (add_source_lab_proof (Rule_Labeling_Conv rl cs Nothing) (Just n)
            prf));
}))))))
                            xml_return)))
                    (xml_or
                      (xml_do "redundantRules"
                        (xml_take
                          (xml_do "trs"
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ trs ->
                            xml_take (xml_nat "nrSteps")
                              (\ n ->
                                xml_take_default []
                                  (xml_do "conversions"
                                    (xml_take_many_sub [] zero_nat Infinity_enat
                                      (conversion xml2name)
                                      (\ a -> xml_return (map snd a))))
                                  (\ cs ->
                                    xml_take (xml2cr_proof xml2name)
                                      (\ prf ->
xml_return (Redundant_Rules trs n cs prf)))))))
                      (xml_do "persistentDecomposition"
                        (xml_take (xml2ms_signature xml2name)
                          (\ sig ->
                            xml_take_many_sub [] zero_nat Infinity_enat
                              (xml_do "component"
                                (xml_take
                                  (xml_do "trs"
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ a ->
                                    xml_take (xml2cr_proof xml2name)
                                      (\ b -> xml_return (a, b)))))
                              (\ subs ->
                                xml_return
                                  (Persistent_Decomposition sig
                                    subs)))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2eq_proof ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) (Eq_proof a [Char]);
xml2eq_proof xml2name x =
  xml_or
    (xml_do "refl" (xml_take (term xml2name) (\ xa -> xml_return (Refl xa))))
    (xml_or
      (xml_do "sym"
        (xml_take (xml2eq_proof xml2name) (\ xa -> xml_return (Sym xa))))
      (xml_or
        (xml_do "trans"
          (xml_take (xml2eq_proof xml2name)
            (\ a ->
              xml_take (xml2eq_proof xml2name)
                (\ b -> xml_return (Trans a b)))))
        (xml_or
          (xml_do "assm"
            (xml_take (rule xml2name)
              (\ a ->
                xml_take (substa xml2name)
                  (\ b -> xml_return (Assm a (mk_subst Var b))))))
          (xml_do "cong"
            (xml_take xml2name
              (\ a ->
                xml_take_many_sub [] zero_nat Infinity_enat
                  (xml2eq_proof xml2name) (\ b -> xml_return (Cong a b))))))))
    x;

mk_cpx ::
  forall a b c d e.
    (Compare_order b, Showl b, Compare_order c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    ([Term (Lab b c) [Char]],
                      ([(Term (Lab b c) [Char], Term (Lab b c) [Char])],
                        ([(Term (Lab b c) [Char], Term (Lab b c) [Char])],
                          (d, e)))) ->
                      (a, (d, e));
mk_cpx i (q, (s, (w, (cm, cc)))) = (mkc i False q s w, (cm, cc));

mk_tp ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      (Bool, ([Term b c], ([(Term b c, Term b c)], [(Term b c, Term b c)]))) ->
        a;
mk_tp i (nfs, (q, (r, rw))) = mkc i nfs q r rw;

in_vars_formula :: forall a b. (Eq a) => a -> Formula (Term b a) -> Bool;
in_vars_formula x (Atom a) = membera (vars_term_list a) x;
in_vars_formula x (NegAtom a) = membera (vars_term_list a) x;
in_vars_formula x (Conjunction phi_s) = any (in_vars_formula x) phi_s;
in_vars_formula x (Disjunction phi_s) = any (in_vars_formula x) phi_s;

trivial_checker :: forall a. (Eq a) => [Formula a] -> Bool;
trivial_checker lits = (case partition is_Atom lits of {
                         (asa, nas) -> let {
 pos = map get_Atom asa;
 neg = map get_Atom nas;
                                       } in any (membera neg) pos;
                       });

trivial_formula :: forall a. Formula a -> Bool;
trivial_formula (Disjunction phi_s) = any trivial_formula phi_s;
trivial_formula (Conjunction phi_s) = all trivial_formula phi_s;
trivial_formula (Atom v) = False;
trivial_formula (NegAtom v) = False;

find_max_nat :: Nat -> (Nat -> Bool) -> Nat;
find_max_nat n uu =
  (if equal_nat n zero_nat then zero_nat
    else (if uu (minus_nat n one_nat) then minus_nat n one_nat
           else find_max_nat (minus_nat n one_nat) uu));

idx_of_tr ::
  forall a.
    (Compare_order a) => a -> ((Array.Array a, Nat),
                                ((Array.Array Nat, Nat),
                                  (Rbta a Int,
                                    (Array.Array (Nat, [a]), Nat)))) ->
                                Nat;
idx_of_tr s v =
  (case v of {
    (_, (aa, (ab, _))) ->
      let {
        x = (case rbt_lookup ab s of {
              Just i ->
                (if less_eq_int zero_int i then nat i else error "undefined");
            });
        xa = find_max_nat (as_length aa) (\ j -> less_eq_nat (as_get aa j) x);
      } in xa;
  });

gi_E :: forall a b c d. Gen_g_impl_ext a b c d -> b;
gi_E (Gen_g_impl_ext gi_V gi_E gi_V0 more) = gi_E;

stat_newnode :: () -> ();
stat_newnode = (\ _ -> ());

is_Nil :: forall a. [a] -> Bool;
is_Nil a = (case a of {
             [] -> True;
             _ : _ -> False;
           });

as_push :: forall a. (Array.Array a, Nat) -> a -> (Array.Array a, Nat);
as_push s x =
  let {
    a = s;
  } in (case a of {
         (aa, n) ->
           let {
             ab = (if equal_nat n (array_length aa)
                    then array_grow aa
                           (max (nat_of_integer (4 :: Integer))
                             (times_nat (nat_of_integer (2 :: Integer)) n))
                           x
                    else aa);
             ac = array_set ab n x;
           } in (ac, plus_nat n one_nat);
       });

push_code ::
  forall a b.
    (Compare_order a) => Gen_g_impl_ext (a -> Bool) (a -> [a]) [a] b ->
                           a -> ((Array.Array a, Nat),
                                  ((Array.Array Nat, Nat),
                                    (Rbta a Int,
                                      (Array.Array (Nat, [a]), Nat)))) ->
                                  ((Array.Array a, Nat),
                                    ((Array.Array Nat, Nat),
                                      (Rbta a Int,
(Array.Array (Nat, [a]), Nat))));
push_code g_impl =
  (\ x (xa, (xb, (xc, xd))) ->
    let {
      _ = stat_newnode ();
      y_a = as_length xa;
      y_b = as_push xa x;
      y_c = as_push xb y_a;
      y_d = rbt_insert x (int_of_nat y_a) xc;
      y_e = (if is_Nil (gi_E g_impl x) then xd
              else as_push xd (y_a, gi_E g_impl x));
    } in (y_b, (y_c, (y_d, y_e))));

nFQ_subset_NF_rulesc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
nFQ_subset_NF_rulesc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = nFQ_subset_NF_rules;

is_QNFc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Term b c -> Bool;
is_QNFc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = is_QNF;

rulesf :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulesf
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules;

icap_impl_dpp ::
  forall a b.
    (Eq b) => Dpp_ops_ext a b [Char] () ->
                a -> [Term b [Char]] -> Term b [Char] -> Term b (Sum () [Char]);
icap_impl_dpp i d =
  let {
    qr = nFQ_subset_NF_rulesc i d;
    qnf = is_QNFc i d;
    r = rulesf i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s -> let {
                 a = ceta_set_of (concatMap vars_term_list s);
               } in ic s a);

as_set :: forall a. (Array.Array a, Nat) -> Nat -> a -> (Array.Array a, Nat);
as_set s i x = let {
                 a = s;
               } in (case a of {
                      (aa, b) -> (array_set aa i x, b);
                    });

shows_kbo_repr ::
  forall a.
    (Showl a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                   String -> String;
shows_kbo_repr (prs, w0) =
  (((((((((showsl_literal
             "KBO with the following precedence and weight function\n" .
            foldr (\ (a, b) ->
                    (case a of {
                      (f, n) ->
                        (\ (pr, (_, _)) ->
                          (((((showsl_literal "precedence(" . showsl f) .
                               showsl_literal "[") .
                              showsl_nat n) .
                             showsl_literal "]) = ") .
                            showsl_nat pr) .
                            showsl_literal "\n");
                    })
                      b)
              prs) .
           showsl_literal "\nprecedence(_) = 0\nand the following weight\n") .
          foldr (\ (a, b) ->
                  (case a of {
                    (f, n) ->
                      (\ (_, (w, _)) ->
                        (((((showsl_literal "weight(" . showsl f) .
                             showsl_literal "[") .
                            showsl_nat n) .
                           showsl_literal "]) = ") .
                          showsl_nat w) .
                          showsl_literal "\n");
                  })
                    b)
            prs) .
         showsl_literal "\nweight(_) = ") .
        showsl_nat (suc w0)) .
       showsl_literal "\nw0 = ") .
      showsl_nat w0) .
     showsl_literal "\nand the following subterm coefficient functions\n") .
    foldr (\ (a, b) ->
            (case a of {
              (f, n) ->
                (\ (_, (_, scf)) ->
                  (((((showsl_literal "scf(" . showsl f) . showsl_literal "[") .
                      showsl_nat n) .
                     showsl_literal "]) = ") .
                    (if is_none scf then showsl_literal "all 1"
                      else showsl_list_nat (the scf))) .
                    showsl_literal "\n");
            })
              b)
      prs) .
    showsl_literal "\nscf(_) = all 1\n";

tatom_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Formula (Term Sig (Trans_var [Char], Ty)));
tatom_parser = xml_change (bexp_parser trans_var_parser) (xml_return . Atom);

roots_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
roots_of_cm (Derivational_Complexity f) = f;
roots_of_cm (Runtime_Complexity c d) = d;

sym_collect :: forall a b. (Term a b -> Bool) -> Term a b -> [a];
sym_collect p (Var x) = [];
sym_collect p (Fun f ts) =
  (if p (Fun f ts) then [f] else []) ++ concatMap (sym_collect p) ts;

upper_triangular :: forall a. (Zero a, Eq a) => Mat a -> Bool;
upper_triangular a =
  all_interval_nat
    (\ i -> all_interval_nat (\ j -> index_mat a (i, j) == zerob) zero_nat i)
    zero_nat (dim_row a);

list_inter :: forall a. (Eq a) => [a] -> [a] -> [a];
list_inter [] bs = [];
list_inter (a : asa) bs =
  (if membera bs a then a : list_inter asa bs else list_inter asa bs);

list_union :: forall a. (Eq a) => [a] -> [a] -> [a];
list_union [] ys = ys;
list_union (x : xs) ys = let {
                           zs = list_union xs ys;
                         } in (if membera zs x then zs else x : zs);

pat_of ::
  forall a.
    Dp_proof_step a ->
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])));
pat_of (OC1 rl uu) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC2 rl uv uw ux uy uz) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC2p rl va vb vc vd ve) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC3 rl vf vg vh vi) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OC3p rl vj vk vl vm) =
  (([], ((zero_nat, (zero_nat, [])), fst rl)),
    ([], ((zero_nat, (zero_nat, [])), snd rl)));
pat_of (OCDP1 p vn) = p;
pat_of (OCDP2 p vo) = p;
pat_of (WPEQ p vp) = p;
pat_of (Lift p vq) = p;
pat_of (DPOC1_1 p vr vs vt vu) = p;
pat_of (DPOC1_2 p vv vw vx vy vz) = p;
pat_of (DPOC2 p wa wb wc wd) = p;
pat_of (DPOC3_1 p we wf wg wh) = p;
pat_of (DPOC3_2 p wi wj wk wl wm) = p;
pat_of (DPDP1_1 p wn wo wp wq) = p;
pat_of (DPDP1_2 p wr ws wt wu) = p;
pat_of (DPDP2_1 p wv ww wx wy) = p;
pat_of (DPDP2_2 p wz xa xb xc) = p;

power :: forall a. (Power a) => a -> Nat -> a;
power a n =
  (if equal_nat n zero_nat then onea
    else times a (power a (minus_nat n one_nat)));

mk_rtrancl_list_main ::
  forall a. (a -> a -> Bool) -> (a -> [a]) -> [a] -> [a] -> [a];
mk_rtrancl_list_main subsumes r todo fin =
  (case todo of {
    [] -> fin;
    a : tod ->
      (if any (\ b -> subsumes b a) fin
        then mk_rtrancl_list_main subsumes r tod fin
        else mk_rtrancl_list_main subsumes r (r a ++ tod) (a : fin));
  });

mk_rtrancl_list :: forall a. (a -> a -> Bool) -> (a -> [a]) -> [a] -> [a];
mk_rtrancl_list subsumes r init = mk_rtrancl_list_main subsumes r init [];

ins_dj_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
ins_dj_rm_basic_ops x s = insert x () s;

mk_rtrancl_set_main ::
  forall a. (Compare_order a) => (a -> [a]) -> [a] -> Rbt a () -> Rbt a ();
mk_rtrancl_set_main r todo fin =
  (case todo of {
    [] -> fin;
    a : tod ->
      (if memb_rm_basic_ops a fin then mk_rtrancl_set_main r tod fin
        else mk_rtrancl_set_main r (r a ++ tod) (ins_dj_rm_basic_ops a fin));
  });

mk_rtrancl_set :: forall a. (Compare_order a) => (a -> [a]) -> [a] -> Rbt a ();
mk_rtrancl_set r init = mk_rtrancl_set_main r init (empty_rm_basic_ops ());

add_index :: (String -> String) -> Nat -> String -> String;
add_index s i = (s . showsl_lit ".") . showsl_nat i;

subst_compose_impl ::
  forall a b.
    (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> [(a, Term b a)];
subst_compose_impl sigma tau =
  let {
    sigmaa = mk_subst_domain sigma;
    taua = mk_subst_domain tau;
    d_sigma = map fst sigmaa;
  } in map (\ (x, t) -> (x, subst_apply_term t (mk_subst Var taua))) sigmaa ++
         filter (\ (x, _) -> not (membera d_sigma x)) taua;

commutes_impl ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> Bool;
commutes_impl sigma mu =
  subst_eq (subst_compose_impl sigma mu) (subst_compose_impl mu sigma);

mk_subst_case ::
  forall a b.
    (Eq a,
      Eq b) => [a] -> (a -> Term b a) -> [(a, Term b a)] -> [(a, Term b a)];
mk_subst_case xs sigma tau =
  subst_compose_impl (map (\ x -> (x, sigma x)) xs) tau;

ta_matcha ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b, Eq b, Ceq c,
      Ccompare c) => Ta_ext a b () -> Set a -> Term b c -> Set [(c, a)];
ta_matcha ta q t = ta_match ta q t q;

adapt_vars :: forall a b c. Term a b -> Term a c;
adapt_vars (Fun f ts) = Fun f (map adapt_vars ts);

ta_member ::
  forall a b c.
    (Ccompare a, Eq a, Cenum c, Ceq c, Ccompare c, Eq c,
      Set_impl c) => Term a b -> Ta_ext c a () -> Bool;
ta_member t ta =
  ground t &&
    not (less_eq_set (inf_set (ta_final ta) (ta_res ta (adapt_vars t)))
          bot_set);

rhs_eps_cl_memo ::
  forall a b c.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Set_impl b, Ccompare c,
      Eq c) => (a -> Set b) -> Set (Ta_rule a c) -> Set b;
rhs_eps_cl_memo memo rules = sup_seta (image (memo . r_rhs) rules);

list_intera :: forall a. (Ceq a, Ccompare a, Set_impl a) => [Set a] -> Set a;
list_intera [] = top_set;
list_intera [x] = x;
list_intera (x : v : va) = inf_set x (list_intera (v : va));

ps_states_cons_impl ::
  forall a b c d e.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Set_impl b, Ceq c,
      Ccompare c, Ccompare d,
      Eq d) => (a -> Set b) ->
                 Set (c, (Nat, Set (Ta_rule a d))) ->
                   e -> Set (Set a) -> Set (Set b);
ps_states_cons_impl meps parts rules q =
  let {
    lhs_nth_in_Q =
      (\ (n, rs) ->
        map (\ i ->
              minus_set
                (image
                  (\ p -> filtera (\ r -> member (nth (r_lhs_states r) i) p) rs)
                  q)
                (inserta (set_empty (of_phantom set_impl_ta_rule))
                  (set_empty (of_phantom set_impl_set))))
          (upt zero_nat n));
  } in sup_seta
         (image
           (\ (_, nrs) ->
             minus_set
               (image (\ rs -> rhs_eps_cl_memo meps (list_intera rs))
                 (listset (lhs_nth_in_Q nrs)))
               (inserta bot_set (set_empty (of_phantom set_impl_set))))
           parts);

ps_states_nil_impl ::
  forall a b c.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Set_impl b, Ceq c, Ccompare c, Eq c,
      Set_impl c) => (a -> Set b) -> Set (Ta_rule a c) -> Set (Set b);
ps_states_nil_impl meps rules =
  let {
    rsz = filtera (\ r -> null (r_lhs_states r)) rules;
  } in image (\ f -> rhs_eps_cl_memo meps (filtera (\ r -> r_root r == f) rsz))
         (image r_root rsz);

ps_rules_cons_impl ::
  forall a b c d.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Ccompare c,
      Eq c) => (a -> Set a) ->
                 Set (b, (Nat, Set (Ta_rule a c))) ->
                   d -> Set (Set a) -> Set (Ta_rule (Set a) b);
ps_rules_cons_impl meps parts rules q =
  let {
    lhs_nth =
      (\ (n, rs) ->
        map (\ i ->
              filtera
                (\ x ->
                  not (set_eq (snd x)
                        (set_empty (of_phantom set_impl_ta_rule))))
                (image
                  (\ p ->
                    (p, filtera (\ r -> member (nth (r_lhs_states r) i) p) rs))
                  q))
          (upt zero_nat n));
  } in sup_seta
         (image
           (\ (f, nrs) ->
             filtera (\ r -> not (is_empty (r_rhs r)))
               (image
                 (\ rs ->
                   TA_rule f (map fst rs)
                     (rhs_eps_cl_memo meps (list_intera (map snd rs))))
                 (listset (lhs_nth nrs))))
           parts);

ps_rules_nil_impl ::
  forall a b c.
    (Ccompare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b,
      Set_impl b, Ceq c, Ccompare c, Eq c,
      Set_impl c) => (a -> Set b) ->
                       Set (Ta_rule a c) -> Set (Ta_rule (Set b) c);
ps_rules_nil_impl meps rules =
  let {
    rsz = filtera (\ r -> null (r_lhs_states r)) rules;
  } in image (\ f ->
               TA_rule f []
                 (rhs_eps_cl_memo meps (filtera (\ r -> r_root r == f) rsz)))
         (image r_root rsz);

memo_list_rtrancl_set ::
  forall a. (Ceq a, Ccompare a, Eq a, Set_impl a) => [(a, a)] -> a -> Set a;
memo_list_rtrancl_set r =
  let {
    tr = rtrancl_list_impl r;
    rm = map_of (map (\ a -> (a, set (tr [a]))) ((remdups . map fst) r));
  } in (\ a -> (case rm a of {
                 Nothing -> inserta a bot_set;
                 Just asa -> asa;
               }));

memo_rtrancl ::
  forall a. (Ceq a, Ccompare a, Eq a, Set_impl a) => Set (a, a) -> a -> Set a;
memo_rtrancl (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "memo_rtrancl RBT_set: ccompare = None"
        (\ _ -> memo_rtrancl (RBT_set rbt));
    Just _ -> memo_list_rtrancl_set (keysa rbt);
  });
memo_rtrancl (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "memo_rtrancl DList_set: ceq = None"
        (\ _ -> memo_rtrancl (DList_set dxs));
    Just _ -> memo_list_rtrancl_set (list_of_dlist dxs);
  });
memo_rtrancl (Set_Monad xs) = memo_list_rtrancl_set xs;

sym_parts ::
  forall a b.
    (Ccompare a, Eq a, Ceq b, Ccompare b, Eq b,
      Set_impl b) => Set (Ta_rule a b) -> Set (b, (Nat, Set (Ta_rule a b)));
sym_parts rules =
  image (\ (f, n) -> (f, (n, filtera (\ r -> r_sym r == (f, n)) rules)))
    (image r_sym rules);

ps_ta ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Set_impl b) => Ta_ext a b () -> Ta_ext (Set a) b ();
ps_ta ta =
  let {
    eps = ta_eps ta;
    rules = ta_rules ta;
  } in (if finite eps && finite rules
         then let {
                meps = memo_rtrancl eps;
                parts =
                  sym_parts
                    (filtera (\ r -> not (null (r_lhs_states r))) rules);
                qinit = ps_states_nil_impl meps rules;
                q = fst (while (\ (qold, qnew) -> not (less_eq_set qnew qold))
                          (\ (_, qnew) ->
                            (qnew,
                              sup_set qinit
                                (ps_states_cons_impl meps parts rules qnew)))
                          (set_empty (of_phantom set_impl_set), qinit));
                final =
                  filtera (\ qa -> not (is_empty (inf_set qa (ta_final ta)))) q;
                rulesa =
                  sup_set (ps_rules_nil_impl meps rules)
                    (ps_rules_cons_impl meps parts rules q);
              } in Ta_ext final rulesa
                     (set_empty
                       (of_phantom
                         (set_impl_prod :: Phantom (Set a, Set a) Set_impla)))
                     ()
         else ps_ta ta);

add_funas_args_term :: forall a b. Term a b -> [(a, Nat)] -> [(a, Nat)];
add_funas_args_term t fs = foldr add_funas_term (args t) fs;

add_funas_args_rule ::
  forall a b. (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
add_funas_args_rule r fs =
  add_funas_args_term (fst r) (add_funas_args_term (snd r) fs);

funas_args_trs_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
funas_args_trs_list trs = foldr add_funas_args_rule trs [];

rwc :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwc (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
      rules_map delete_R_Rw split_rules mk nfs more)
  = rw;

rc :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rc (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
     delete_R_Rw split_rules mk nfs more)
  = r;

uncurry_of_sig_list ::
  forall a.
    a -> [((a, Nat), [a])] ->
           (a -> Nat -> [a]) -> [(Term a [Char], Term a [Char])];
uncurry_of_sig_list a sml sm =
  concatMap
    (\ (b, c) ->
      (case b of {
        (f, n) ->
          (\ _ ->
            let {
              g = get_symbol sm f n;
            } in map (\ i ->
                       (Fun a [generate_f_xs (g i) (plus_nat n i),
                                Var (generate_var (plus_nat n i))],
                         generate_f_xs (g (suc i)) (plus_nat n (suc i))))
                   (upt zero_nat (aarity sm f n)));
      })
        c)
    sml;

sig_list_to_sig_map ::
  forall a.
    (Eq a) => a -> [((a, Nat), [a])] ->
                     ([((a, Nat), [a])] -> a -> Nat -> a) -> a -> Nat -> [a];
sig_list_to_sig_map a sml fmap =
  let {
    fm = fmap sml;
  } in (\ f n -> (case map_of sml (f, n) of {
                   Nothing -> [fm f n];
                   Just xs -> (if null xs then [fm f n] else xs);
                 }));

uncurry_eta_split ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             ([(Term a b, Term a b)], [(Term a b, Term a b)]);
uncurry_eta_split eboth rtest =
  let {
    test =
      (\ (l, r) ->
        less_nat zero_nat (size_list (args l)) &&
          less_nat zero_nat (size_list (args r)) &&
            any (eq_rule_mod_vars (hda (args l), hda (args r))) rtest);
  } in partition test eboth;

eta_closed_rules ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => a -> (a -> Nat -> [a]) ->
                         [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] -> Sum (String -> String) ();
eta_closed_rules a sm ra r =
  catch_errora
    (forallM
      (\ (l, raa) ->
        (case aarity_term a sm l of {
          Nothing -> Inr ();
          Just ab ->
            (if equal_nat ab zero_nat then Inr ()
              else check (any (\ (lll, rrr) ->
                                (case (lll, rrr) of {
                                  (Var _, _) -> False;
                                  (Fun _ [], _) -> False;
                                  (Fun _ [_], _) -> False;
                                  (Fun _ [_, Var _], Var _) -> False;
                                  (Fun _ [_, Var _], Fun _ []) -> False;
                                  (Fun _ [_, Var _], Fun _ [_]) -> False;
                                  (Fun f [ll, Var x], Fun g [rr, Var y]) ->
                                    f == a &&
                                      g == a &&
x == y &&
  not (membera (insert_vars_rule (ll, rr) []) x) &&
    instance_rule (l, raa) (ll, rr);
                                  (Fun _ [_, Var _], Fun _ (_ : Var _ : _ : _))
                                    -> False;
                                  (Fun _ [_, Var _], Fun _ (_ : Fun _ _ : _)) ->
                                    False;
                                  (Fun _ (_ : Var _ : _ : _), _) -> False;
                                  (Fun _ (_ : Fun _ _ : _), _) -> False;
                                }))
                           r)
                     ((showsl_lit "eta expansion of " . showsl_rule (l, raa)) .
                       showsl_lit " missing"));
        }))
      ra)
    (\ x -> Inl (snd x));

uncurry_rules ::
  forall a b.
    (Eq a) => a -> (a -> Nat -> [a]) ->
                     [(Term a b, Term a b)] -> [(Term a b, Term a b)];
uncurry_rules a sm =
  map (\ (l, r) -> (uncurry_term a sm l, uncurry_term a sm r));

check_CS_subseteq ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Sum (Term a b, Term a b) ();
check_CS_subseteq r s =
  catch_errora
    (forallM (\ (l, ra) -> check (any (instance_rule (l, ra)) s) (l, ra)) r)
    (\ x -> Inl (snd x));

uncurry_tt ::
  forall a b.
    (Eq b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Char], Term b [Char])],
                            [(Term b [Char], Term b [Char])]))) ->
                      [(Term b [Char], Term b [Char])] ->
                        a -> Sum (String -> String) a;
uncurry_tt i info r tp =
  (case info of {
    (a, (sml, (u, eb))) ->
      let {
        ra = rc i tp;
        rw = rwc i tp;
      } in (case uncurry_eta_split eb ra of {
             (e, ew) ->
               let {
                 r_eta = e ++ ra;
                 rw_eta = ew ++ rw;
                 rb_eta = r_eta ++ rw_eta;
                 fmap = (\ _ f _ -> f);
                 sm = sig_list_to_sig_map a sml fmap;
                 uR = uncurry_rules a sm r_eta;
                 uRw = uncurry_rules a sm rw_eta;
               } in (case let {
                            s = uncurry_of_sig_list a sml sm;
                          } in bindb (catch_errora
                                       (forallM
 (\ (l, _) ->
   check (hvf_term a l)
     ((showsl_lit "head variable in lhs " . showsl_terma l) .
       showsl_lit " not allowed"))
 r_eta)
                                       (\ x -> Inl (snd x)))
                                 (\ _ ->
                                   bindb (catch_errora
   (forallM
     (\ (l, _) ->
       check (hvf_term a l)
         ((showsl_lit "head variable in lhs " . showsl_terma l) .
           showsl_lit " not allowed"))
     rw_eta)
   (\ x -> Inl (snd x)))
                                     (\ _ ->
                                       bindb (eta_closed_rules a sm r_eta r_eta)
 (\ _ ->
   bindb (eta_closed_rules a sm rb_eta rb_eta)
     (\ _ ->
       bindb (catch_errora
               (forallM
                 (\ (l, rb) ->
                   check (not (is_Var l))
                     (showsl_lit "lhs must not be a variable in rule " .
                       showsl_rule (l, rb)))
                 rw_eta)
               (\ x -> Inl (snd x)))
         (\ _ ->
           bindb (catch_errora (check_subseteq uR r)
                   (\ x ->
                     Inl ((showsl_lit "uncurried rule " . showsl_rule x) .
                           showsl_lit " is missing")))
             (\ _ ->
               bindb (catch_errora (check_subseteq uRw r)
                       (\ x ->
                         Inl ((showsl_lit "uncurried rule " . showsl_rule x) .
                               showsl_lit " is missing")))
                 (\ _ ->
                   bindb (catch_errora (check_CS_subseteq s u)
                           (\ x ->
                             Inl ((showsl_lit "uncurry rule " . showsl_rule x) .
                                   showsl_lit " is missing")))
                     (\ _ ->
                       catch_errora (check_subseteq u r)
                         (\ x ->
                           Inl ((showsl_lit "uncurry rule " . showsl_rule x) .
                                 showsl_lit " is missing in new TRS"))))))))))
                      of {
                      Inl aa -> Inl aa;
                      Inr _ -> Inr (mkc i (nfsb i tp) [] uR (uRw ++ u));
                    });
           });
  });

check_prefix_equivalent ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> Sum (String -> String) ();
check_prefix_equivalent rhoa rho n =
  catch_errora
    (bindb
      (check (less_nat n (size_list (snd rhoa)))
        (((showsl_lit "There are fewer than " . showsl_nat n) .
           showsl_lit " conditions in ") .
          showsl_crule rhoa))
      (\ _ ->
        bindb (check (less_nat n (size_list (snd rho)))
                (((showsl_lit "There are fewer than " . showsl_nat n) .
                   showsl_lit " conditions in ") .
                  showsl_crule rho))
          (\ _ ->
            bindb (check (equal_term (fst (fst rhoa)) (fst (fst rho)))
                    (showsl_lit "Left-hand sides are different."))
              (\ _ ->
                bindb (catch_errora
                        (forallM
                          (\ i ->
                            check (equal_term (snd (nth (snd rhoa) i))
                                    (snd (nth (snd rho) i)))
                              (showsl_lit "Rhs of conditions are different\n"))
                          (upt zero_nat n))
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    catch_errora
                      (forallM
                        (\ i ->
                          check (equal_term (fst (nth (snd rhoa) i))
                                  (fst (nth (snd rho) i)))
                            (showsl_lit "Lhs of conditions are different\n"))
                        (upt zero_nat (suc n)))
                      (\ x -> Inl (snd x)))))))
    (\ x ->
      Inl (((((((showsl_lit "Rules" . showsl_crule rhoa) . showsl_lit " and ") .
                showsl_crule rho) .
               showsl_lit " are not ") .
              showsl_nat n) .
             showsl_lit " equivalent.\n") .
            x));

check_f ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    Nat ->
                      a -> [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                             (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                               Nat -> Ctxt a b) ->
                               Sum (String -> String) ();
check_f cr j f crs u =
  catch_errora
    (forallM
      (\ cra ->
        catch_errora
          (forallM
            (\ i ->
              (case u cra i of {
                Hole -> Inr ();
                More g _ _ _ ->
                  (if f == g
                    then catch_errora
                           (bindb
                             (check (equal_nat i j)
                               (showsl_lit
                                 "Same symbol occurs at different levels\n"))
                             (\ _ ->
                               bindb (catch_errora
                                       (forallM
 (\ k ->
   check (equal_ctxt (u cra k) (u cr k))
     (showsl_lit "Contexts are different\n"))
 (upt zero_nat (suc j)))
                                       (\ x -> Inl (snd x)))
                                 (\ _ -> check_prefix_equivalent cra cr j)))
                           (\ x ->
                             Inl (((((showsl_lit "Rules" . showsl_crule cra) .
                                      showsl_lit " and ") .
                                     showsl_crule cr) .
                                    showsl_lit " share a symbol.\n") .
                                   x))
                    else Inr ());
              }))
            (upt zero_nat (size_list (snd cra))))
          (\ x -> Inl (snd x)))
      crs)
    (\ x -> Inl (snd x));

ackbo_nstrict ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Showl a, Eq b,
      Showl b) => ((a, Nat) -> (a, Nat) -> Bool) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        Set a ->
                          (Term a b, Term a b) -> Sum (String -> String) ();
ackbo_nstrict pr w w0 acset =
  (\ (s, t) ->
    check (ackbo_impl w w0 pr acset s t ||
            equal_acterm (aocnf acset acset s) (aocnf acset acset t))
      ((((showsl_lit "could not orient " . showsl_terma s) .
          showsl_lit " >=ACKBO ") .
         showsl_terma t) .
        showsl_literal "\n"));

af_check ::
  forall a b.
    (Showl a,
      Showl b) => (String -> String) ->
                    Afs a ->
                      ((Term a b, Term a b) -> Sum (String -> String) ()) ->
                        (Term a b, Term a b) -> Sum (String -> String) ();
af_check r pi g lr =
  let {
    pl = af_term pi (fst lr);
    pr = af_term pi (snd lr);
  } in catch_errora (g (pl, pr))
         (\ x ->
           Inl (((((((((((((((showsl_literal "could not orient " .
                               showsl_terma (fst lr)) .
                              showsl_literal " ") .
                             r) .
                            showsl_literal " ") .
                           showsl_terma (snd lr)) .
                          showsl_literal "\npi( ") .
                         showsl_terma (fst lr)) .
                        showsl_literal " ) = ") .
                       showsl_terma pl) .
                      showsl_literal "\npi( ") .
                     showsl_terma (snd lr)) .
                    showsl_literal " ) = ") .
                   showsl_terma pr) .
                  showsl_literal "\n") .
                 x));

af_rules ::
  forall a b. Afs a -> [(Term a b, Term a b)] -> [(Term a b, Term a b)];
af_rules pi r = map (af_rule pi) r;

afs_syms :: forall a. Afs a -> Set (a, Nat);
afs_syms xa = snd (rep_afs xa);

mono_af_entry :: Nat -> Af_entry -> Bool;
mono_af_entry n (Collapse i) = less_eq_nat n one_nat;
mono_af_entry n (AFList ids) = all_interval_nat (membera ids) zero_nat n;

mono_afs :: forall a. (Ceq a, Ccompare a) => Afs a -> Bool;
mono_afs pi = ball (afs_syms pi) (\ (f, n) -> mono_af_entry n (afsa pi (f, n)));

compatible_ta ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    String ->
                      (Xml, ([([Char], [Char])],
                              (Bool, ([String], [String])))) ->
                        Sum_bot (Xml_error String)
                          (Tree_automaton [Char] (Lab a b), Ta_relation [Char]);
compatible_ta xml2name tag =
  xml_do tag
    (xml_take (tree_automaton (ta_normal_lhs xml2name))
      (\ a ->
        xml_take_default Id_Relation closed_criterion
          (\ b -> xml_return (a, b))));

xml2const_map ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) (Lab a b -> Maybe [Char]);
xml2const_map xml2name =
  xml_do "constMap"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "entry"
        (xml_take
          (xml_do "symbol" (xml_take xml2name (\ x -> xml_return (id x))))
          (\ a -> xml_take (xml_text "const") (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (map_of a)));

default_grd_fun ::
  forall a.
    Term (Lab [Char] a) [Char] ->
      Term (Lab [Char] a) [Char] -> [Char] -> Term (Lab [Char] a) [Char];
default_grd_fun s t =
  let {
    f = funs_rule_list (s, t);
    m = fold (\ fa m -> (case fa of {
                          Lab _ _ -> m;
                          FunLab _ _ -> m;
                          UnLab _ -> m;
                          Sharp (Lab _ _) -> m;
                          Sharp (FunLab _ _) -> m;
                          Sharp (UnLab g) -> max (size_list g) m;
                          Sharp (Sharp _) -> m;
                        }))
          f zero_nat;
    suffix =
      replicate (suc m) (Char True False False False False True True False);
  } in (\ x -> Fun (Sharp (UnLab (x ++ suffix))) []);

xml2non_join_info ::
  ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Lab [Char] [Nat])) ->
    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String)
        (Non_join_info (Lab [Char] [Nat]) [Char] [Char]);
xml2non_join_info xml2name x =
  xml_or (xml_leaf "distinctNormalForms" Diff_NFs)
    (xml_or (xml_leaf "capNotUnif" (Tcap_Non_Unif default_grd_fun))
      (xml_or
        (xml_do "subterm"
          (xml_take pos
            (\ a ->
              xml_take (xml2non_join_info xml2name)
                (\ b -> xml_return (Subterm_NJ a b)))))
        (xml_or
          (xml_do "grounding"
            (xml_take (substa xml2name)
              (\ a ->
                xml_take (xml2non_join_info xml2name)
                  (\ b -> xml_return (Grounding a b)))))
          (xml_or
            (xml_do "emptyTreeAutomataIntersection"
              (xml_take (compatible_ta xml2name "firstAutomaton")
                (\ a ->
                  xml_take (compatible_ta xml2name "secondAutomaton")
                    (\ b ->
                      xml_return
                        ((case a of {
                           (ta1, rel1) ->
                             (\ (aa, ba) ->
                               Tree_Aut_Intersect_Empty ta1 rel1 aa ba);
                         })
                          b)))))
            (xml_or
              (xml_do "differentInterpretation"
                (xml_take (sl_variant xml2name)
                  (\ xa -> xml_return (Finite_Model_Gt xa))))
              (xml_or
                (xml_do "strictDecrease"
                  (xml_take (ordering_constraint_proof xml2name False)
                    (\ xa -> xml_return (Reduction_Pair_Gt xa))))
                (xml_or
                  (xml_do "argumentFilterNonJoin"
                    (xml_take (afs xml2name)
                      (\ a ->
                        xml_take (xml2non_join_info xml2name)
                          (\ b -> xml_return (Argument_Filter_NJ a b)))))
                  (xml_do "usableRulesNonJoin"
                    (xml_take_optional
                      (xml_or (xml_leaf "left" True) (xml_leaf "right" False))
                      (\ a ->
                        (case a of {
                          Nothing ->
                            xml_take (xml2non_join_info xml2name)
                              (\ b -> xml_return (Usable_Rules_Reach_NJ b));
                          Just left ->
                            xml_take
                              (xml_do "usableRules"
                                (xml_take (rules xml2name)
                                  (\ xa -> xml_return (id xa))))
                              (\ u ->
                                xml_take (xml2non_join_info xml2name)
                                  (\ p ->
                                    xml_return
                                      (Usable_Rules_Reach_Unif_NJ
(if left then Inl u else Inr u) p)));
                        })))))))))))
    x;

xml2ncr_proof ::
  ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Lab [Char] [Nat])) ->
    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) (Ncr_proof [Char] [Nat] [Char] [Char]);
xml2ncr_proof xml2name x =
  let {
    rew = rsteps xml2name;
  } in xml_do "crDisproof"
         (xml_take
           (xml_or
             (xml_do "nonWcrAndSN"
               (xml_take (\ xa -> right (fst xa))
                 (\ _ ->
                   xml_take (xml2trs_termination_proof xml2name)
                     (\ prf -> xml_return (SN_NWCR prf)))))
             (xml_or
               (xml_do "nonJoinableFork"
                 (xml_take rew
                   (\ a ->
                     xml_take rew
                       (\ b ->
                         xml_take (xml2non_join_info xml2name)
                           (\ c ->
                             xml_return
                               ((case a of {
                                  (s, seq1) ->
                                    (\ (_, aa) -> Non_Join s seq1 aa);
                                })
                                  b
                                 c))))))
               (xml_or
                 (xml_do "modularityDisjoint"
                   (xml_take
                     (xml_do "trs"
                       (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                     (\ a ->
                       xml_take (xml2ncr_proof xml2name)
                         (\ b -> xml_return (NCR_Disj_Subtrs a b)))))
                 (xml_or
                   (xml_do "redundantRules"
                     (xml_take
                       (xml_do "trs"
                         (xml_take (rules xml2name)
                           (\ xa -> xml_return (id xa))))
                       (\ a ->
                         xml_take (xml_nat "nrSteps")
                           (\ b ->
                             xml_take (xml2ncr_proof xml2name)
                               (\ c ->
                                 xml_return (NCR_Redundant_Rules a b c))))))
                   (xml_do "persistentDecomposition"
                     (xml_take (xml2ms_signature xml2name)
                       (\ a ->
                         xml_take
                           (xml_do "component"
                             (xml_take
                               (xml_do "trs"
                                 (xml_take (rules xml2name)
                                   (\ xa -> xml_return (id xa))))
                               (\ aa ->
                                 xml_take (xml2ncr_proof xml2name)
                                   (\ b -> xml_return (aa, b)))))
                           (\ b ->
                             xml_return
                               (case b of {
                                 (ba, c) -> NCR_Persistent_Decomposition a ba c;
                               })))))))))
           (\ xa -> xml_return (id xa)))
         x;

xml2state_map ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        ([Char] -> Term (Lab a b) [Char]);
xml2state_map xml2name =
  xml_do "stateMap"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "entry"
        (xml_take state
          (\ a -> xml_take (term xml2name) (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (\ x -> the (map_of a x))));

is_root_step ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Term a b -> Bool;
is_root_step r s t =
  any (\ (l, ra) -> (case match s l of {
                      Nothing -> False;
                      Just sigma -> equal_term (subst_apply_term ra sigma) t;
                    }))
    r;

is_par_rstep ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Term a b -> Bool;
is_par_rstep r (Var x) (Var y) = x == y;
is_par_rstep r (Fun f ss) (Fun g ts) =
  equal_term (Fun f ss) (Fun g ts) ||
    (is_root_step r (Fun f ss) (Fun g ts) ||
      (if f == g && equal_nat (size_list ss) (size_list ts)
        then list_all2 (is_par_rstep r) ss ts else False));
is_par_rstep r (Fun v va) (Var vb) = is_root_step r (Fun v va) (Var vb);
is_par_rstep r (Var vb) (Fun v va) = is_root_step r (Var vb) (Fun v va);

reachable_terms ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Nat -> [Term a b];
reachable_terms r s n =
  (if equal_nat n zero_nat then [s]
    else let {
           ts = reachable_terms r s (minus_nat n one_nat);
         } in remdups (ts ++ concatMap (rewrite r) ts));

is_critical_pair_closing_cp ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Nat -> (Bool, (Term a b, Term a b)) -> Bool;
is_critical_pair_closing_cp c n (False, (s, t)) =
  not (is_none (find (is_par_rstep c t) (reachable_terms c s n)));
is_critical_pair_closing_cp c n (True, (s, t)) =
  not (is_none
        (find (membera (reachable_terms c s n)) (reachable_terms c t n)));

subst_apply_ctxt :: forall a b c. Ctxt a b -> (b -> Term a c) -> Ctxt a c;
subst_apply_ctxt Hole sigma = Hole;
subst_apply_ctxt (More f ss1 d ss2) sigma =
  More f (map (\ t -> subst_apply_term t sigma) ss1) (subst_apply_ctxt d sigma)
    (map (\ t -> subst_apply_term t sigma) ss2);

critical_pairs_impl ::
  forall a.
    (Eq a) => [(Term a [Char], Term a [Char])] ->
                [(Term a [Char], Term a [Char])] ->
                  [(Bool, (Term a [Char], Term a [Char]))];
critical_pairs_impl p r =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ pa ->
          let {
            c = ctxt_of_pos_term pa l;
            la = subt_at l pa;
            b = equal_ctxt c Hole;
          } in (if is_Var la then []
                 else concatMap
                        (\ (laa, rb) ->
                          (case mgu_var_disjoint_generic
                                  (\ a ->
                                    Char False False False True True True True
                                      False :
                                      a)
                                  (\ a ->
                                    Char True False False True True True True
                                      False :
                                      a)
                                  la laa
                            of {
                            Nothing -> [];
                            Just (sigma, tau) ->
                              [(b, (subst_apply_term ra sigma,
                                     ctxt_apply_term (subst_apply_ctxt c sigma)
                                       (subst_apply_term rb tau)))];
                          }))
                        r))
        (poss_list l))
    p;

check_left_linear_trs ::
  forall a b.
    (Showl a, Ceq b, Ccompare b, Set_impl b,
      Showl b) => [(Term a b, Term a b)] -> Sum (String -> String) ();
check_left_linear_trs trs =
  catch_errora
    (catch_errora
      (forallM (\ x -> (if linear_term (fst x) then Inr () else Inl x)) trs)
      (\ x -> Inl (snd x)))
    (\ _ -> Inl (showsl_trs trs . showsl_literal "\nis not left-linear\n"));

check_critical_pair_closing ::
  forall a.
    (Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    [(Term a [Char], Term a [Char])] ->
                      Nat -> Sum (String -> String) ();
check_critical_pair_closing r c n =
  catch_errora
    (bindb (check_left_linear_trs r)
      (\ _ ->
        bindb (catch_errora (check_subseteq c r)
                (\ _ -> Inl (showsl_lit "C not a subsystem of R")))
          (\ _ ->
            catch_errora
              (forallM
                (\ (b, (s, t)) ->
                  check (is_critical_pair_closing_cp c n (b, (s, t)))
                    ((((((showsl_lit "the critical pair " . showsl_terma s) .
                          showsl_lit " <- . -> ") .
                         showsl_terma t) .
                        showsl_lit " is not closed within ") .
                       showsl_nat n) .
                      showsl_lit " steps."))
                (critical_pairs_impl r r))
              (\ x -> Inl (snd x)))))
    (\ x ->
      Inl ((x . showsl_lit
                  "\nhence the following TRS is not critical pair closing\n") .
            showsl_trs r));

check_strongly_closed ::
  forall a.
    (Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    Nat -> Sum (String -> String) ();
check_strongly_closed r n =
  catch_errora
    (bindb (check_linear_trs r)
      (\ _ ->
        catch_errora
          (forallM
            (\ (_, (s, t)) ->
              check (not (is_none
                           (find (membera (reachable_terms r s n))
                             (reachable_terms r t (suc zero_nat)))) &&
                      not (is_none
                            (find (membera (reachable_terms r t n))
                              (reachable_terms r s (suc zero_nat)))))
                ((((((showsl_lit "the critical pair " . showsl_terma s) .
                      showsl_lit " <- . -> ") .
                     showsl_terma t) .
                    showsl_lit " is not strongly closed within ") .
                   showsl_nat n) .
                  showsl_lit " steps."))
            (critical_pairs_impl r r))
          (\ x -> Inl (snd x))))
    (\ x ->
      Inl ((x . showsl_lit
                  "\nhence the following TRS is not strongly closed\n") .
            showsl_trs r));

root_rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
root_rewrite r s =
  concatMap (\ (l, ra) -> (case match s l of {
                            Nothing -> [];
                            Just sigma -> [subst_apply_term ra sigma];
                          }))
    r;

parallel_rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
parallel_rewrite r (Var x) = [Var x];
parallel_rewrite r (Fun f ss) =
  remdups
    (root_rewrite r (Fun f ss) ++
      map (Fun f) (product_lists (map (parallel_rewrite r) ss)));

is_parallel_closed_cp ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Maybe Nat -> (Bool, (Term a b, Term a b)) -> Bool;
is_parallel_closed_cp r uu (False, (s, t)) = is_par_rstep r t s;
is_parallel_closed_cp r (Just n) (True, (s, t)) =
  not (is_none (find (is_par_rstep r t) (reachable_terms r s n)));
is_parallel_closed_cp r Nothing (True, (s, t)) =
  not (is_none (find (is_par_rstep r t) (parallel_rewrite r s)));

showsl_option :: forall a. (Showl a) => Maybe a -> String -> String;
showsl_option Nothing = showsl_lit "None";
showsl_option (Just x) = (showsl_lit "Some (" . showsl x) . showsl_lit ")";

check_parallel_closed ::
  forall a.
    (Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    Maybe Nat -> Sum (String -> String) ();
check_parallel_closed r n =
  catch_errora
    (bindb (check_left_linear_trs r)
      (\ _ ->
        catch_errora
          (forallM
            (\ (b, (s, t)) ->
              check (is_parallel_closed_cp r n (b, (s, t)))
                ((((((showsl_lit "the critical pair " . showsl_terma s) .
                      showsl_lit " <- . -> ") .
                     showsl_terma t) .
                    showsl_lit " is not (almost) parallel closed within ") .
                   showsl_option n) .
                  showsl_lit " steps."))
            (critical_pairs_impl r r))
          (\ x -> Inl (snd x))))
    (\ x ->
      Inl ((x . showsl_lit
                  "\nhence the following TRS is not (almost) parallel closed\n") .
            showsl_trs r));

applicable_rule_impl ::
  forall a b. (Term a b -> Bool) -> (Term a b, Term a b) -> Bool;
applicable_rule_impl isNF = (\ (l, _) -> all isNF (args l));

check_non_applicable_rules ::
  forall a b.
    (Term a b -> Bool) -> [(Term a b, Term a b)] -> Sum (Term a b, Term a b) ();
check_non_applicable_rules isNF r =
  catch_errora
    (forallM
      (\ x -> (if not (applicable_rule_impl isNF x) then Inr () else Inl x)) r)
    (\ x -> Inl (snd x));

rule_match_impl_aux ::
  forall a.
    (Eq a) => (Term a [Char] -> Bool) ->
                [Term a [Char]] -> Term a [Char] -> Term a [Char] -> Bool;
rule_match_impl_aux nfq s fts l =
  (case mgu fts
          (map_term (\ x -> x)
            (\ a -> Char True False False True True True True False : a) l)
    of {
    Nothing -> False;
    Just mu ->
      all (\ u ->
            nfq (subst_apply_term
                  (map_term (\ x -> x)
                    (\ a -> Char True False False True True True True False : a)
                    u)
                  mu))
        (args l) &&
        all (\ u -> nfq (subst_apply_term u mu)) s;
  });

is_ur_closed_term_af_impl ::
  forall a b c.
    (Compare a, Eq a, Ceq c,
      Ccompare c) => (Term a [Char] -> Bool) ->
                       (Term a b -> Term a (Sum () [Char])) ->
                         ((a, Nat) -> Set Nat) ->
                           [(Term a [Char], c)] ->
                             Set (Term a [Char], c) ->
                               [Term a [Char]] -> Term a b -> Bool;
is_ur_closed_term_af_impl nfq e_cap pi r u s (Fun f ts) =
  let {
    n = size_list ts;
    pi_f = pi (f, n);
  } in all (\ (i, t) ->
             (if member i pi_f
               then is_ur_closed_term_af_impl nfq e_cap pi r u s t else True))
         (zip (upt zero_nat n) ts) &&
         let {
           fts = class_to_term (Char False True False True True True True False)
                   (Fun f (map e_cap ts));
         } in all (\ (l, ra) ->
                    member (l, ra) u || not (rule_match_impl_aux nfq s fts l))
                r;
is_ur_closed_term_af_impl nfq e_cap pi r u s (Var x) = True;

is_ur_closed_af_impl_dpp_mv ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           [(Term b [Char], Term b [Char])] ->
                             [Term b [Char]] -> Term b [Char] -> Bool;
is_ur_closed_af_impl_dpp_mv i d pi u =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulesf i d;
    urc = (\ s -> is_ur_closed_term_af_impl qnf (ic s) pi r (set u));
  } in (\ s ->
         let {
           sa = map (map_term (\ x -> x)
                      (\ a ->
                        Char False False False True True True True False : a))
                  s;
         } in (\ t ->
                urc sa sa
                  (map_term (\ x -> x)
                    (\ a ->
                      Char False False False True True True True False : a)
                    t)));

wwf_rulesa :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
wwf_rulesa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = wwf_rules;

rules_mapc ::
  forall a b c d.
    Dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
rules_mapc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_map;

q_emptyc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
q_emptyc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = q_empty;

matchCapRMBelow ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                 Term a b -> Term a b -> Bool;
matchCapRMBelow rm l (Fun f ts) = matchb (GCFun f (map (tcapRM2 rm) ts)) l;

forallM_index_aux ::
  forall a b. (a -> Nat -> Sum b ()) -> Nat -> [a] -> Sum ((a, Nat), b) ();
forallM_index_aux p i [] = Inr ();
forallM_index_aux p i (x : xs) =
  bindb (catch_errora (p x i) (\ xa -> Inl ((x, i), xa)))
    (\ _ -> forallM_index_aux p (suc i) xs);

forallM_index ::
  forall a b. (a -> Nat -> Sum b ()) -> [a] -> Sum ((a, Nat), b) ();
forallM_index p xs = forallM_index_aux p zero_nat xs;

check_ur_closed_term_rm_af ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                    [(Term a b, Term a b)] ->
                      ((a, Nat) -> Set Nat) ->
                        Term a b -> Sum (String -> String) ();
check_ur_closed_term_rm_af uu uv uw (Var x) = Inr ();
check_ur_closed_term_rm_af rm ur pi (Fun f ts) =
  let {
    n = size_list ts;
    pia = pi (f, n);
  } in bindb (catch_errora
               (forallM_index
                 (\ t i ->
                   (if member i pia then check_ur_closed_term_rm_af rm ur pi t
                     else Inr ()))
                 ts)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ lr ->
                 check (membera ur lr ||
                         not (matchCapRMBelow rm (fst lr) (Fun f ts)))
                   ((((showsl_lit "due to the subterm " .
                        showsl_terma (Fun f ts)) .
                       showsl_lit " of some usable rhs, rule ") .
                      showsl_rule lr) .
                     showsl_lit " should be usable."))
               (rm (f, n)))
             (\ x -> Inl (snd x)));

check_ur_P_closed_rm_af ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                    [(Term a b, Term a b)] ->
                      ((a, Nat) -> Set Nat) ->
                        [(Term a b, Term a b)] -> Sum (String -> String) ();
check_ur_P_closed_rm_af rm ur pi p =
  bindb (catch_errora
          (catch_errora
            (forallM (\ lr -> check_ur_closed_term_rm_af rm ur pi (snd lr)) ur)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (showsl_lit
                   "error when checking closure properties of rhs of usable rules\n" .
                  x)))
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM (\ st -> check_ur_closed_term_rm_af rm ur pi (snd st)) p)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl (showsl_lit
                 "error when checking closure properties of rhs of DPs\n" .
                x)));

smart_usable_rules_checker_impl ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           Maybe [(Term b [Char], Term b [Char])] ->
                             [(Term b [Char], Term b [Char])] ->
                               Sum (String -> String)
                                 [(Term b [Char], Term b [Char])];
smart_usable_rules_checker_impl i d pi u_opt sts =
  let {
    nfs = nfsc i d;
    m = minimal i d;
    wwf = wwf_rulesa i d;
    qempty = q_emptyc i d;
  } in (case u_opt of {
         Nothing -> Inr (rulesf i d);
         Just u ->
           (if nFQ_subset_NF_rulesc i d &&
                 (nfs || isOK (check_varcond_subset sts)) && (nfs || (m || wwf))
             then let {
                    urc = is_ur_closed_af_impl_dpp_mv i d pi u;
                    check_urc =
                      (\ s t ->
                        check (urc s t)
                          ((showsl_lit "term " . showsl_terma t) .
                            showsl_lit " is not closed under usable rules"));
                  } in bindb (catch_errora
                               (forallM (\ (s, a) -> check_urc [s] a) sts)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM (\ (l, a) -> check_urc (args l) a)
                                     u)
                                   (\ x -> Inl (snd x)))
                             (\ _ -> Inr u))
             else bindb (check (m && (if nfs then qempty || wwf else True))
                          (showsl_lit
                            "minimality and well formedness required"))
                    (\ _ ->
                      bindb (catch_errora
                              (forallM
                                (\ (l, _) ->
                                  check (not (is_Var l))
                                    (showsl_lit
                                      "variables as lhss not allowed"))
                                (rulesf i d))
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          let {
                            rm = rules_mapc i d;
                          } in bindb (check_ur_P_closed_rm_af rm u pi sts)
                                 (\ _ -> Inr u))));
       });

root_aft_to_entry ::
  forall a b c. a -> Term b c -> ((b, Nat) -> Set Nat) -> [(a, Term b c)];
root_aft_to_entry s t pi =
  let {
    rt = the (root t);
    pi_t = pi rt;
    ts = args t;
  } in map_filter
         (\ x -> (if member x pi_t then Just (s, nth ts x) else Nothing))
         (upt zero_nat (snd rt));

check_no_defined_root ::
  forall a b.
    (Showl a,
      Showl b) => ((a, Nat) -> Bool) -> Term a b -> Sum (String -> String) ();
check_no_defined_root isdef t =
  check (not (isdef (the (root t))))
    ((showsl_literal "the root of " . showsl_terma t) .
      showsl_literal " is defined");

pairsb :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pairsb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = pairs;

validb :: forall a b c. Root_redtriple_ext a b c -> Sum (String -> String) ();
validb (Root_redtriple_ext valid s ns nst af aft desc more) = valid;

descb :: forall a b c. Root_redtriple_ext a b c -> String -> String;
descb (Root_redtriple_ext valid s ns nst af aft desc more) = desc;

nsta ::
  forall a b c.
    Root_redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum (String -> String) ();
nsta (Root_redtriple_ext valid s ns nst af aft desc more) = nst;

aft :: forall a b c. Root_redtriple_ext a b c -> (a, Nat) -> Set Nat;
aft (Root_redtriple_ext valid s ns nst af aft desc more) = aft;

nsa ::
  forall a b c.
    Root_redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum (String -> String) ();
nsa (Root_redtriple_ext valid s ns nst af aft desc more) = ns;

afa :: forall a b c. Root_redtriple_ext a b c -> (a, Nat) -> Set Nat;
afa (Root_redtriple_ext valid s ns nst af aft desc more) = af;

sa :: forall a b c.
        Root_redtriple_ext a b c ->
          (Term a b, Term a b) -> Sum (String -> String) ();
sa (Root_redtriple_ext valid s ns nst af aft desc more) = s;

generic_ur_af_root_redtriple_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Root_redtriple_ext b [Char] () ->
                      Maybe [(Term b [Char], Term b [Char])] ->
                        [(Term b [Char], Term b [Char])] ->
                          a -> Sum (String -> String) a;
generic_ur_af_root_redtriple_proc i rp u_opt premove dpp =
  (case catch_errora
          (bindb (validb rp)
            (\ _ ->
              (case split_pairsa i dpp premove of {
                (ps, pns) ->
                  let {
                    p = pairsb i dpp;
                    pi = afa rp;
                    pia = aft rp;
                    is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
                  } in bindb (catch_errora
                               (forallM
                                 (\ (l, r) ->
                                   bindb (check_no_var l)
                                     (\ _ ->
                                       bindb (check_no_var r)
 (\ _ -> check_no_defined_root is_def r)))
                                 p)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM (\ (l, _) -> check_no_var l)
                                     (rulesf i dpp))
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               bindb (smart_usable_rules_checker_impl i dpp pi
                                       u_opt
                                       (concatMap
 (\ (s, t) -> root_aft_to_entry s t pia) p))
                                 (\ u ->
                                   bindb (catch_errora
   (catch_errora (forallM (nsa rp) u) (\ x -> Inl (snd x)))
   (\ x -> Inl (showsl_lit "problem when orienting (usable) rules\n" . x)))
                                     (\ _ ->
                                       bindb
 (catch_errora (catch_errora (forallM (nsta rp) pns) (\ x -> Inl (snd x)))
   (\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x)))
 (\ _ ->
   catch_errora (catch_errora (forallM (sa rp) ps) (\ x -> Inl (snd x)))
     (\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x)))))));
              })))
          (\ x ->
            Inl (((showsl_lit
                     "could not apply the generic root reduction pair processor with the following\n" .
                    descb rp) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp premove premove);
  });

nst ::
  forall a b c.
    Redtriple_ext a b c -> (Term a b, Term a b) -> Sum (String -> String) ();
nst (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx more)
  = nst;

generic_ur_af_redtriple_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Redtriple_ext b [Char] () ->
                      Maybe [(Term b [Char], Term b [Char])] ->
                        [(Term b [Char], Term b [Char])] ->
                          a -> Sum (String -> String) a;
generic_ur_af_redtriple_proc i rp u_opt premove dpp =
  (case catch_errora
          (bindb (valid rp)
            (\ _ ->
              (case split_pairsa i dpp premove of {
                (ps, pns) ->
                  let {
                    p = pairsb i dpp;
                  } in bindb (smart_usable_rules_checker_impl i dpp (af rp)
                               u_opt p)
                         (\ u ->
                           bindb (catch_errora
                                   (catch_errora (forallM (ns rp) u)
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (showsl_lit
    "problem when orienting (usable) rules\n" .
   x)))
                             (\ _ ->
                               bindb (catch_errora
                                       (catch_errora (forallM (nst rp) pns)
 (\ x -> Inl (snd x)))
                                       (\ x ->
 Inl (showsl_lit "problem when orienting DPs\n" . x)))
                                 (\ _ ->
                                   catch_errora
                                     (catch_errora (forallM (s rp) ps)
                                       (\ x -> Inl (snd x)))
                                     (\ x ->
                                       Inl
 (showsl_lit "problem when orienting DPs\n" . x)))));
              })))
          (\ x ->
            Inl (((showsl_lit
                     "could not apply the generic reduction pair processor with the following\n" .
                    desca rp) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp premove premove);
  });

is_ur_closed_term_impl ::
  forall a b c.
    (Compare a, Eq a, Ceq c,
      Ccompare c) => (Term a [Char] -> Bool) ->
                       (Term a b -> Term a (Sum () [Char])) ->
                         [(Term a [Char], c)] ->
                           Set (Term a [Char], c) ->
                             [Term a [Char]] -> Term a b -> Bool;
is_ur_closed_term_impl nfq e_cap r u s (Fun f ts) =
  all (is_ur_closed_term_impl nfq e_cap r u s) ts &&
    let {
      fts = class_to_term (Char False True False True True True True False)
              (Fun f (map e_cap ts));
    } in all (\ (l, ra) ->
               member (l, ra) u || not (rule_match_impl_aux nfq s fts l))
           r;
is_ur_closed_term_impl nfq e_cap r u s (Var x) = True;

is_ur_closed_impl_dpp_mv ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    a -> [(Term b [Char], Term b [Char])] ->
                           [Term b [Char]] -> Term b [Char] -> Bool;
is_ur_closed_impl_dpp_mv i d u =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulesf i d;
    urc = (\ s -> is_ur_closed_term_impl qnf (ic s) r (set u));
  } in (\ s ->
         let {
           sa = map (map_term (\ x -> x)
                      (\ a ->
                        Char False False False True True True True False : a))
                  s;
         } in (\ t ->
                urc sa sa
                  (map_term (\ x -> x)
                    (\ a ->
                      Char False False False True True True True False : a)
                    t)));

intersect_rulesb ::
  forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_rulesb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = intersect_rules;

usable_rules_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    [(Term b [Char], Term b [Char])] ->
                      a -> Sum (String -> String) a;
usable_rules_proc i u dpp =
  (case bindb (check (nFQ_subset_NF_rulesc i dpp)
                (showsl_lit "innermost rewriting required"))
          (\ _ ->
            bindb (check (nfsc i dpp || (minimal i dpp || wwf_rulesa i dpp))
                    (showsl_lit
                      "normal form subst, minimality or well-formedness required"))
              (\ _ ->
                let {
                  p = pairsb i dpp;
                  urc = is_ur_closed_impl_dpp_mv i dpp u;
                  check_urc =
                    (\ s t ->
                      check (urc s t)
                        ((showsl_lit "term " . showsl_terma t) .
                          showsl_lit " is not closed under usable rules"));
                  nfs = nfsc i dpp;
                } in bindb (catch_errora
                             (forallM
                               (\ (l, r) ->
                                 bindb (if nfs then Inr ()
 else catch_errora (check_subseteq (vars_term_list r) (vars_term_list l))
        (\ _ -> Inl (showsl_lit "variable condition in P violated")))
                                   (\ _ -> check_urc [l] r))
                               p)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         catch_errora
                           (forallM (\ (l, a) -> check_urc (args l) a) u)
                           (\ x -> Inl (snd x)))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (intersect_rulesb i dpp u);
  });

mono ::
  forall a b c.
    Redtriple_ext a b c -> [(Term a b, Term a b)] -> Sum (String -> String) ();
mono (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx
       more)
  = mono;

mono_inn_usable_rules_ce_proc ::
  forall a b.
    (Ceq b, Ccompare b, Compare_order b, Eq b, Set_impl b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Redtriple_ext b [Char] () ->
                      [(Term b [Char], Term b [Char])] ->
                        [(Term b [Char], Term b [Char])] ->
                          [(Term b [Char], Term b [Char])] ->
                            a -> Sum (String -> String) a;
mono_inn_usable_rules_ce_proc i rp premove rremove ur dpp =
  (case catch_errora
          (bindb (usable_rules_proc i ur dpp)
            (\ _ ->
              let {
                p = pairsb i dpp;
                us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
                filt =
                  (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
              } in (case split_pairsa i dpp premove of {
                     (pms, pns) ->
                       (case partition filt pms of {
                         (ps, pnwf) ->
                           (case partition (membera rremove) ur of {
                             (urms, urns) ->
                               (case partition filt urms of {
                                 (urs, urnwf) ->
                                   bindb (valid rp)
                                     (\ _ ->
                                       bindb
 (mono rp (ps ++ urs ++ urns ++ urnwf ++ pns ++ pnwf))
 (\ _ ->
   bindb (catch_errora
           (catch_errora (forallM (ns rp) (urns ++ urnwf)) (\ x -> Inl (snd x)))
           (\ x ->
             Inl (showsl_lit "problem when orienting usable rules\n" . x)))
     (\ _ ->
       bindb (catch_errora
               (catch_errora (forallM (s rp) urs) (\ x -> Inl (snd x)))
               (\ x ->
                 Inl (showsl_lit "problem when orienting usable rules\n" . x)))
         (\ _ ->
           bindb (catch_errora
                   (catch_errora (forallM (ns rp) (pns ++ pnwf))
                     (\ x -> Inl (snd x)))
                   (\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x)))
             (\ _ ->
               catch_errora
                 (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (showsl_lit "problem when orienting DPs\n" . x)))))));
                               });
                           });
                       });
                   })))
          (\ x ->
            Inl (((showsl_lit
                     "could not apply the innermost usable rules reduction pair processor with the following\n" .
                    desca rp) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

mono_ur_redpair_proc ::
  forall a b c.
    (Ceq b, Ccompare b, Eq b, Set_impl b, Showl b, Eq c,
      Showl c) => Dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          [(Term b c, Term b c)] ->
                            a -> Sum (String -> String) a;
mono_ur_redpair_proc i rp premove rremove ur dpp =
  (case catch_errora
          (bindb (check (minimal i dpp) (showsl_lit "minimality required"))
            (\ _ ->
              bindb (check
                      (if nfsc i dpp
                        then (if not (q_emptyc i dpp) then wwf_rulesa i dpp
                               else True)
                        else True)
                      (showsl_lit "well formedness required"))
                (\ _ ->
                  let {
                    p = pairsb i dpp;
                    us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
                    filt =
                      (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
                  } in (case split_pairsa i dpp premove of {
                         (pms, pns) ->
                           (case partition filt pms of {
                             (ps, pnwf) ->
                               (case partition (membera rremove) ur of {
                                 (urms, urns) ->
                                   (case partition filt urms of {
                                     (urs, urnwf) ->
                                       let {
 rm = rules_mapc i dpp;
                                       } in
 bindb (valid rp)
   (\ _ ->
     bindb (mono rp (ps ++ urs ++ urns ++ urnwf ++ pns ++ pnwf))
       (\ _ ->
         bindb (check_ur_P_closed_rm_af rm ur full_af p)
           (\ _ ->
             bindb (catch_errora
                     (forallM
                       (\ (l, _) ->
                         check (not (is_Var l))
                           (showsl_lit "variables as lhss not allowed"))
                       (rulesf i dpp))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (catch_errora
                         (catch_errora (forallM (ns rp) (urns ++ urnwf))
                           (\ x -> Inl (snd x)))
                         (\ x ->
                           Inl (showsl_lit
                                  "problem when orienting usable rules\n" .
                                 x)))
                   (\ _ ->
                     bindb (catch_errora
                             (catch_errora (forallM (s rp) urs)
                               (\ x -> Inl (snd x)))
                             (\ x ->
                               Inl (showsl_lit
                                      "problem when orienting usable rules\n" .
                                     x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (catch_errora (forallM (ns rp) (pns ++ pnwf))
                                   (\ x -> Inl (snd x)))
                                 (\ x ->
                                   Inl (showsl_lit
  "problem when orienting DPs\n" .
 x)))
                           (\ _ ->
                             catch_errora
                               (catch_errora (forallM (s rp) ps)
                                 (\ x -> Inl (snd x)))
                               (\ x ->
                                 Inl (showsl_lit
"problem when orienting DPs\n" .
                                       x)))))))));
                                   });
                               });
                           });
                       }))))
          (\ x ->
            Inl (((showsl_lit
                     "could not apply the monotonic reduction pair processor with the following\n" .
                    desca rp) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

generic_mono_ur_redpair_proc ::
  forall a b.
    (Ceq b, Ccompare b, Compare_order b, Eq b, Set_impl b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Redtriple_ext b [Char] () ->
                      [(Term b [Char], Term b [Char])] ->
                        [(Term b [Char], Term b [Char])] ->
                          [(Term b [Char], Term b [Char])] ->
                            a -> Sum (String -> String) a;
generic_mono_ur_redpair_proc i rp premove rremove ur dpp =
  (if nFQ_subset_NF_rulesc i dpp
    then mono_inn_usable_rules_ce_proc i rp premove rremove ur dpp
    else bindb (check (minimal i dpp)
                 (showsl_lit
                   "minimality or innermost required for mon. red. pair proc. with usable rules"))
           (\ _ -> mono_ur_redpair_proc i rp premove rremove ur dpp));

compat_roota :: forall a b. (Eq a) => Term a b -> Maybe (a, Nat) -> Bool;
compat_roota uu Nothing = False;
compat_roota (Var uv) (Just v) = False;
compat_roota (Fun va vb) (Just v) = root (Fun va vb) == Just v;

usable_rules_gen2 ::
  forall a b.
    (Eq a) => [(Term a b, Term a b)] ->
                (Maybe (a, Nat), Bool) -> [(Term a b, Term a b)];
usable_rules_gen2 r (fn, b) =
  let {
    rr = concatMap (\ (l, ra) -> (if compat_roota l fn then [(l, ra)] else []))
           r;
  } in (if b then rr else map (\ (l, ra) -> (ra, l)) rr);

rel_dep_prod :: Bool -> Dependance -> [Bool];
rel_dep_prod uu Ignore = [];
rel_dep_prod b Increase = [b];
rel_dep_prod b Decrease = [not b];
rel_dep_prod uv Wild = [True, False];

compat_root :: forall a b c. (Eq a) => Term a b -> Term a c -> Bool;
compat_root uu (Var uv) = False;
compat_root (Var uw) (Fun v va) = False;
compat_root (Fun vb vc) (Fun v va) = root (Fun vb vc) == root (Fun v va);

usable_rules_gen1 ::
  forall a b.
    (Eq a) => ((a, Nat) -> Nat -> Dependance) ->
                [(Term a b, Term a b)] ->
                  (Term a b, Bool) -> [(Term a b, Bool)];
usable_rules_gen1 pi r (Var uu, uv) = [];
usable_rules_gen1 pi r (Fun f ts, b) =
  let {
    n = size_list ts;
  } in concatMap
         (\ (l, ra) -> (if compat_root l (Fun f ts) then [(ra, b)] else []))
         r ++
         concatMap
           (\ i -> map (\ a -> (nth ts i, a)) (rel_dep_prod b (pi (f, n) i)))
           (upt zero_nat n);

usable_rules_gen ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> Nat -> Dependance) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] -> [(Term a b, Term a b)];
usable_rules_gen pi r p =
  concatMap (usable_rules_gen2 r)
    (remdups
      (map (\ (t, a) -> (root t, a))
        (mk_rtrancl_list (\ a b -> a == b) (usable_rules_gen1 pi r)
          (map (\ (_, t) -> (t, True)) p))));

generate_lists :: forall a. Nat -> [a] -> [[a]];
generate_lists n xs = concat_lists (map (\ _ -> xs) (upt zero_nat n));

initial_conditions_gen_impl ::
  forall a. (a -> a -> Bool) -> Nat -> Nat -> [a] -> a -> [[a]];
initial_conditions_gen_impl pa bef_len aft_len p st =
  let {
    pairs = (\ n -> generate_lists n p);
    a = concatMap (\ bef -> map (\ aft -> bef ++ st : aft) (pairs aft_len))
          (pairs bef_len);
  } in filter
         (\ bef_st_aft ->
           all_interval_nat
             (\ i -> pa (nth bef_st_aft i) (nth bef_st_aft (suc i))) zero_nat
             (plus_nat bef_len aft_len))
         a;

is_partition_impl ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => [Set a] -> Maybe (Set a);
is_partition_impl [] = Just bot_set;
is_partition_impl (asa : rest) =
  bind (is_partition_impl rest)
    (\ alla ->
      (if is_empty (inf_set asa alla) then Just (sup_set alla asa)
        else Nothing));

is_partition ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a, Set_impl a) => [Set a] -> Bool;
is_partition asa = not (is_none (is_partition_impl asa));

disjoint_variant ::
  forall a b.
    (Compare a, Eq a, Card_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Mapping_impl b,
      Set_impl b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Bool;
disjoint_variant sts uvs =
  equal_nat (size_list sts) (size_list uvs) &&
    all_interval_nat (\ i -> eq_rule_mod_vars (nth sts i) (nth uvs i)) zero_nat
      (size_list sts) &&
      is_partition (map vars_rule uvs);

condition_of ::
  forall a b.
    a -> Condition_type -> (Term a b, Term a b) -> Cond_constraint a b;
condition_of c Bound (s, uu) = CC_cond False (s, Fun c []);
condition_of c Strict st = CC_cond True st;
condition_of c Non_Strict st = CC_cond False st;

constraint_of ::
  forall a b.
    a -> Condition_type -> [(Term a b, Term a b)] -> Nat -> Cond_constraint a b;
constraint_of c ctype uvs bef =
  CC_impl
    (map (\ i -> CC_rewr (snd (nth uvs i)) (fst (nth uvs (suc i))))
      (upt zero_nat (minus_nat (size_list uvs) one_nat)))
    (condition_of c ctype (nth uvs bef));

the_set_impl_main_lazy ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Eq b) => (a -> [b]) -> (b -> [a]) -> [a] -> Set a -> [b] -> [a];
the_set_impl_main_lazy q gen_as have_asa have_as bs =
  let {
    new_as =
      concatMap
        (\ b ->
          concatMap (\ a -> (if not (member a have_as) then [a] else []))
            (gen_as b))
        bs;
  } in (if null new_as then have_asa
         else the_set_impl_main_lazy q gen_as (new_as ++ have_asa)
                (sup_set (set new_as) have_as) (remdups (concatMap q new_as)));

the_set_impl_lazy ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Eq b) => (a -> [b]) -> (b -> [a]) -> [b] -> [a];
the_set_impl_lazy q gen_as bs = the_set_impl_main_lazy q gen_as [] bot_set bs;

inductive_set_impl_lazy ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Set_impl b) => (a -> [b]) -> (b -> [a]) -> [a] -> [b];
inductive_set_impl_lazy q p = the_set_impl_lazy p q;

rule_match_impl ::
  forall a b.
    (Eq a) => (Term a [Char] -> Bool) ->
                (b -> Term a (Sum () [Char])) ->
                  [Term a [Char]] -> a -> [b] -> Term a [Char] -> Bool;
rule_match_impl nfq e_cap s f ts l =
  (case mgu_class (Fun f (map e_cap ts)) l of {
    Nothing -> False;
    Just mu ->
      all (\ u ->
            nfq (subst_apply_term
                  (map_term (\ x -> x)
                    (\ a -> Char True False False True True True True False : a)
                    u)
                  mu))
        (args l) &&
        all (\ u -> nfq (subst_apply_term u mu)) s;
  });

ur_term_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Char])) ->
                   [(Term a [Char], c)] ->
                     ((a, Nat) -> Set Nat) ->
                       [Term a [Char]] -> Term a b -> [(Term a [Char], c)];
ur_term_impl nfq e_cap r pi s (Var x) = [];
ur_term_impl nfq e_cap r pi s (Fun f ts) =
  let {
    n = size_list ts;
    rec = map (ur_term_impl nfq e_cap r pi s) ts;
  } in remdups
         (concatMap (\ (i, urs) -> (if member i (pi (f, n)) then urs else []))
            (zip (upt zero_nat n) rec) ++
           filter (\ (l, _) -> rule_match_impl nfq e_cap s f ts l) r);

precompute_fun :: forall a b. (Compare_order a) => (a -> b) -> [a] -> a -> b;
precompute_fun f asa =
  fun_of_map_fun (ceta_map_of (map (\ a -> (a, f a)) asa)) f;

usable_rules_calc_impl ::
  forall a.
    (Compare_order a,
      Eq a) => (Term a [Char] -> Bool) ->
                 ([Term a [Char]] -> Term a [Char] -> Term a (Sum () [Char])) ->
                   [(Term a [Char], Term a [Char])] ->
                     [([Term a [Char]], Term a [Char])] ->
                       [(Term a [Char], Term a [Char])];
usable_rules_calc_impl nfq e_cap r =
  let {
    urt = (\ (s, t) ->
            let {
              sa = map (map_term (\ x -> x)
                         (\ a ->
                           Char False False False True True True True False :
                             a))
                     s;
            } in ur_term_impl nfq (e_cap sa) r full_af sa
                   (map_term (\ x -> x)
                     (\ a ->
                       Char False False False True True True True False : a)
                     t));
    urules = map (\ (l, a) -> (args l, a)) r;
    ufun = precompute_fun urt urules;
  } in inductive_set_impl_lazy ufun (\ (l, ra) -> [(args l, ra)]);

ur_calc_singleton ::
  forall a.
    (Compare_order a,
      Eq a) => (Term a [Char] -> Bool) ->
                 ([Term a [Char]] -> Term a [Char] -> Term a (Sum () [Char])) ->
                   [(Term a [Char], Term a [Char])] ->
                     ([Term a [Char]], Term a [Char]) ->
                       [(Term a [Char], Term a [Char])];
ur_calc_singleton nfq e_cap r st = usable_rules_calc_impl nfq e_cap r [st];

inn_usable_rules_pair ::
  forall a b.
    (Compare_order b,
      Eq b) => Dpp_ops_ext a b [Char] () ->
                 a -> (Term b [Char], Term b [Char]) ->
                        [(Term b [Char], Term b [Char])];
inn_usable_rules_pair i d =
  let {
    inn = nFQ_subset_NF_rulesc i d;
    r = rulesf i d;
    qnf = is_QNFc i d;
    ic = icap_impl_dpp i d;
    calc = ur_calc_singleton qnf ic r;
    nfs = nfsc i d;
    wwf = wwf_rulesa i d;
    m = minimal i d;
  } in (\ (s, t) ->
         (if inn &&
               (nfs || subset (vars_term t) (vars_term s)) &&
                 (nfs || (m || wwf))
           then calc ([s], t) else r));

icap_impl_dpp_mv ::
  forall a b.
    (Eq b) => Dpp_ops_ext a b [Char] () ->
                a -> [Term b [Char]] -> Term b [Char] -> Term b (Sum () [Char]);
icap_impl_dpp_mv i d =
  let {
    qr = nFQ_subset_NF_rulesc i d;
    qnf = is_QNFc i d;
    r = rulesf i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s ->
         let {
           sa = map (map_term (\ x -> x)
                      (\ a ->
                        Char False False False True True True True False : a))
                  s;
           sx = ceta_set_of (concatMap vars_term_list sa);
         } in (\ t ->
                ic sa sx
                  (map_term (\ x -> x)
                    (\ a ->
                      Char False False False True True True True False : a)
                    t)));

is_iedg_edge_dpp ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    a -> (Term b [Char], Term b [Char]) ->
                           Term b [Char] -> Bool;
is_iedg_edge_dpp i d =
  let {
    qnf = is_QNFc i d;
    ic = icap_impl_dpp_mv i d;
    _ = rulesf i d;
    urules = inn_usable_rules_pair i d;
  } in (\ (s, t) ->
         let {
           cst = ic [s] t;
           urls = reverse_rules (urules (s, t));
           ica = icap_impl (is_NF_terms []) urls;
         } in (\ u ->
                (case mgu_class cst u of {
                  Nothing -> False;
                  Just mu ->
                    qnf (subst_apply_term
                          (map_term (\ x -> x)
                            (\ a ->
                              Char False False False True True True True False :
                                a)
                            s)
                          mu) &&
                      qnf (subst_apply_term
                            (map_term (\ x -> x)
                              (\ a ->
                                Char True False False True True True True
                                  False :
                                  a)
                              u)
                            mu);
                }) &&
                  let {
                    cu = ica [] u;
                  } in (case mgu_class cu t of {
                         Nothing -> False;
                         Just mu ->
                           qnf (subst_apply_term
                                 (map_term (\ x -> x)
                                   (\ a ->
                                     Char True False False True True True True
                                       False :
                                       a)
                                   s)
                                 mu);
                       })));

deep_normalize_cca :: forall a b. Cond_constraint a b -> Cond_constraint a b;
deep_normalize_cca (CC_impl [] c) = deep_normalize_cca c;
deep_normalize_cca (CC_impl (v : va) c) =
  CC_impl (map deep_normalize_cca (v : va)) (deep_normalize_cca c);
deep_normalize_cca (CC_cond s c) = CC_cond s c;
deep_normalize_cca (CC_all s c) = CC_all s (deep_normalize_cca c);
deep_normalize_cca (CC_rewr s c) = CC_rewr s c;

vars_cc_list :: forall a b. (Eq b) => Cond_constraint a b -> [b];
vars_cc_list (CC_cond ct (s, t)) = vars_term_list s ++ vars_term_list t;
vars_cc_list (CC_rewr s t) = vars_term_list s ++ vars_term_list t;
vars_cc_list (CC_impl c1 c2) = concatMap vars_cc_list c1 ++ vars_cc_list c2;
vars_cc_list (CC_all x c) =
  concatMap (\ y -> (if not (y == x) then [y] else [])) (vars_cc_list c);

cc_subst_apply ::
  forall a b.
    (Eq a) => ([a] -> a) ->
                Cond_constraint b a ->
                  (a -> Term b a, [a]) -> Cond_constraint b a;
cc_subst_apply fresh (CC_all x c) (sigma, vs) =
  let {
    y = fresh (vs ++ vars_cc_list (CC_all x c));
  } in CC_all y (cc_subst_apply fresh c (fun_upd sigma x (Var y), y : vs));
cc_subst_apply fresh (CC_impl c1 c2) sigma =
  CC_impl (map (\ c -> cc_subst_apply fresh c sigma) c1)
    (cc_subst_apply fresh c2 sigma);
cc_subst_apply fresh (CC_rewr s t) (sigma, uv) =
  CC_rewr (subst_apply_term s sigma) (subst_apply_term t sigma);
cc_subst_apply fresh (CC_cond ct (s, t)) (sigma, uu) =
  CC_cond ct (subst_apply_term s sigma, subst_apply_term t sigma);

normalize_alpha ::
  forall a b.
    (Eq a) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a;
normalize_alpha fresh c = cc_subst_apply fresh c (Var, []);

deep_normalize_cc ::
  forall a b.
    (Eq a) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a;
deep_normalize_cc fresh c = normalize_alpha fresh (deep_normalize_cca c);

check_subsumesa ::
  forall a b.
    (Eq a, Eq b) => Cond_constraint a b -> Cond_constraint a b -> Bool;
check_subsumesa (CC_impl cs c) (CC_impl ds d) =
  check_subsumesa c d &&
    all (\ ca -> any (\ da -> check_subsumesa da ca) ds) cs;
check_subsumesa (CC_cond v va) (CC_impl ds d) =
  check_subsumesa (CC_cond v va) d;
check_subsumesa (CC_rewr v va) (CC_impl ds d) =
  check_subsumesa (CC_rewr v va) d;
check_subsumesa (CC_all v va) (CC_impl ds d) = check_subsumesa (CC_all v va) d;
check_subsumesa (CC_all x c) (CC_all y d) = x == y && check_subsumesa c d;
check_subsumesa (CC_cond v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_cond vb vc);
check_subsumesa (CC_cond v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_rewr vb vc);
check_subsumesa (CC_cond v va) (CC_all vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_all vb vc);
check_subsumesa (CC_rewr v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_cond vb vc);
check_subsumesa (CC_rewr v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_rewr vb vc);
check_subsumesa (CC_rewr v va) (CC_all vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_all vb vc);
check_subsumesa (CC_all v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_all v va) (CC_cond vb vc);
check_subsumesa (CC_all v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_all v va) (CC_rewr vb vc);
check_subsumesa c (CC_cond v va) = equal_cond_constraint c (CC_cond v va);
check_subsumesa c (CC_rewr v va) = equal_cond_constraint c (CC_rewr v va);
check_subsumesa (CC_impl vb vc) (CC_all v va) =
  equal_cond_constraint (CC_impl vb vc) (CC_all v va);

check_subsumes ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a -> Bool;
check_subsumes fresh c d = let {
                             n = deep_normalize_cc fresh;
                           } in check_subsumesa (n c) (n d);

check_constraint_present ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    a -> b -> [(Term b [Char], Term b [Char])] ->
                                Nat ->
                                  Nat ->
                                    [(Cond_constraint b [Char],
                                       [(Term b [Char], Term b [Char])])] ->
                                      Condition_type ->
(Term b [Char], Term b [Char]) -> Sum (String -> String) ();
check_constraint_present i dpp constant p bef aft ccs =
  let {
    edg = is_iedg_edge_dpp i dpp;
    init_conds =
      initial_conditions_gen_impl (\ st uv -> edg st (fst uv)) bef aft p;
  } in (\ ct st ->
         catch_errora
           (forallM
             (\ sts ->
               check (any (\ (c, uvs) ->
                            disjoint_variant sts uvs &&
                              check_subsumes
                                (fresh_string
                                  [Char False False False True True True True
                                     False,
                                    Char False False False True True True True
                                      False])
                                c (constraint_of constant ct uvs bef))
                       ccs)
                 (((showsl_lit "did not find " .
                     showsl_lit (case ct of {
                                  Bound -> "bound";
                                  Strict -> "strict";
                                  Non_Strict -> "non-strict";
                                })) .
                    showsl_lit " constraint for sequence ") .
                   showsl_rules sts))
             (init_conds st))
           (\ x -> Inl (snd x)));

check_weakly_orthogonal ::
  forall a.
    (Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] -> Sum (String -> String) ();
check_weakly_orthogonal r =
  catch_errora
    (bindb (check_left_linear_trs r)
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ (l, _) ->
                    check (not (is_Var l))
                      (showsl_lit "the TRS has variables as left-hand sides"))
                  r)
                (\ x -> Inl (snd x)))
          (\ _ ->
            catch_errora
              (forallM
                (\ (_, (s, t)) ->
                  check (equal_term s t)
                    (((showsl_lit "there is a non-trivial critical pair: " .
                        showsl_terma s) .
                       showsl_lit " <- . -> ") .
                      showsl_terma t))
                (critical_pairs_impl r r))
              (\ x -> Inl (snd x)))))
    (\ x ->
      Inl ((x . showsl_lit
                  "\nhence, the following TRS is not weakly orthogonal\n") .
            showsl_trs r));

validc :: forall a b c. Non_inf_order_ext a b c -> Sum (String -> String) ();
validc (Non_inf_order_ext valid ns cc af desc more) = valid;

descc :: forall a b c. Non_inf_order_ext a b c -> String -> String;
descc (Non_inf_order_ext valid ns cc af desc more) = desc;

nsb ::
  forall a b c.
    Non_inf_order_ext a b c ->
      (Term a b, Term a b) -> Sum (String -> String) ();
nsb (Non_inf_order_ext valid ns cc af desc more) = ns;

cc :: forall a b c.
        Non_inf_order_ext a b c ->
          C_constraint a b -> Sum (String -> String) ();
cc (Non_inf_order_ext valid ns cc af desc more) = cc;

afb :: forall a b c. Non_inf_order_ext a b c -> (a, Nat) -> Nat -> Dependance;
afb (Non_inf_order_ext valid ns cc af desc more) = af;

range_vars_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
range_vars_impl sigma = let {
                          a = mk_subst_domain sigma;
                        } in concatMap (vars_term_list . snd) a;

cc_bound :: forall a b. [a] -> Cond_constraint b a -> Cond_constraint b a;
cc_bound [] c = c;
cc_bound (x : xs) c = CC_all x (cc_bound xs c);

cc_ih_prems ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) ->
                 b -> Term b a ->
                        [a] ->
                          [Cond_constraint b a] ->
                            Cond_constraint b a ->
                              [(Term b a, [a])] -> [Cond_constraint b a];
cc_ih_prems fresh f q xs phi psi rs_ys_list =
  map (\ (r, ys) ->
        let {
          rs = args r;
          mu = mk_subst Var (zip xs rs);
          vs = range_vars_impl (zip xs rs);
          mua = (\ c -> cc_subst_apply fresh c (mu, vs));
          a = CC_impl (CC_rewr r (subst_apply_term q mu) : map mua phi)
                (mua psi);
        } in cc_bound ys a)
    rs_ys_list;

cc_rule_constraint ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) ->
                 b -> [Term b a] ->
                        Term b a ->
                          Term b a ->
                            [a] ->
                              [Cond_constraint b a] ->
                                Cond_constraint b a ->
                                  [(Term b a, [a])] -> Cond_constraint b a;
cc_rule_constraint fresh f ls r q xs phi psi rs_ys_list =
  let {
    sigma = mk_subst Var (zip xs ls);
    vs = range_vars_impl (zip xs ls);
    rew = CC_rewr r (subst_apply_term q sigma);
    phi_sig = map (\ c -> cc_subst_apply fresh c (sigma, vs)) phi;
    psi_sig = cc_subst_apply fresh psi (sigma, vs);
    ihs = cc_ih_prems fresh f q xs phi psi rs_ys_list;
  } in CC_impl (rew : phi_sig ++ ihs) psi_sig;

cc_unbound :: forall a b. Cond_constraint a b -> ([b], Cond_constraint a b);
cc_unbound (CC_all x c) = (case cc_unbound c of {
                            (xs, a) -> (x : xs, a);
                          });
cc_unbound (CC_cond v va) = ([], CC_cond v va);
cc_unbound (CC_rewr v va) = ([], CC_rewr v va);
cc_unbound (CC_impl v va) = ([], CC_impl v va);

showsl_cc_aux ::
  forall a b.
    (Showl a, Showl b) => Bool -> Cond_constraint a b -> String -> String;
showsl_cc_aux b (CC_rewr s t) =
  (showsl_terma s . showsl_lit " = ") . showsl_terma t;
showsl_cc_aux b (CC_cond stri (s, t)) =
  (showsl_terma s . showsl_lit (if stri then " > " else " >= ")) .
    showsl_terma t;
showsl_cc_aux b (CC_all x c) =
  let {
    s = ((showsl_lit "ALL " . showsl x) . showsl_lit ". ") .
          showsl_cc_aux False c;
  } in (if b then (showsl_lit "(" . s) . showsl_lit ")" else s);
showsl_cc_aux b (CC_impl cs c2) =
  (((showsl_lit "(" .
      showsl_list_gen id "True" "" " and " "" (map (showsl_cc_aux True) cs)) .
     showsl_lit " => ") .
    showsl_cc_aux True c2) .
    showsl_lit ")";

showsl_cc ::
  forall a b. (Showl a, Showl b) => Cond_constraint a b -> String -> String;
showsl_cc = showsl_cc_aux False;

funas_term_list :: forall a b. Term a b -> [(a, Nat)];
funas_term_list (Var uu) = [];
funas_term_list (Fun f ts) = (f, size_list ts) : concatMap funas_term_list ts;

funas_args_term_list :: forall a b. Term a b -> [(a, Nat)];
funas_args_term_list t = concatMap funas_term_list (args t);

check_rys ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => ((a, Nat) -> Bool) ->
                    Maybe (a, Nat) ->
                      Term a b -> (Term a b, [b]) -> Sum (String -> String) ();
check_rys d rt r rys =
  (case rys of {
    (ra, ys) ->
      bindb (check (root ra == rt)
              (((showsl_lit "root of " . showsl_terma ra) .
                 showsl_lit " is not ") .
                showsl_prod (the rt)))
        (\ _ ->
          bindb (check (equal_term r ra || supt_impl r ra)
                  ((showsl_terma ra . showsl_lit " is not a subterm of ") .
                    showsl_terma r))
            (\ _ ->
              bindb (catch_errora
                      (forallM
                        (\ f ->
                          check (not (d f))
                            ((((showsl_lit "the defined symbol " .
                                 showsl_prod f) .
                                showsl_lit " occurs in the subterm ") .
                               showsl_terma ra) .
                              showsl_lit " of the rhs"))
                        (funas_args_term_list ra))
                      (\ x -> Inl (snd x)))
                (\ _ ->
                  catch_errora (check_disjoint ys (vars_term_list r))
                    (\ x ->
                      Inl ((showsl x . showsl_lit " occurs in ") .
                            showsl_terma r)))));
  });

prems_of :: forall a b. Cond_constraint a b -> [Cond_constraint a b];
prems_of (CC_impl c1 c2) = c1;
prems_of (CC_cond v va) = [];
prems_of (CC_rewr v va) = [];
prems_of (CC_all v va) = [];

concl_of :: forall a b. Cond_constraint a b -> Cond_constraint a b;
concl_of (CC_impl c1 c2) = c2;
concl_of (CC_cond v va) = CC_cond v va;
concl_of (CC_rewr v va) = CC_rewr v va;
concl_of (CC_all v va) = CC_all v va;

normalize_cc :: forall a b. Cond_constraint a b -> Cond_constraint a b;
normalize_cc c = CC_impl (prems_of c) (concl_of c);

check_cc_prf ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    ((a, Nat) -> Bool) ->
                      [(a, Nat)] ->
                        Bool ->
                          Cond_constraint a [Char] ->
                            Cond_constraint_prf a [Char] ->
                              Sum (String -> String) [C_constraint a [Char]];
check_cc_prf r d f m_ortho cc Final =
  (case normalize_cc cc of {
    CC_cond _ _ ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_rewr _ _ ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_impl [] (CC_cond stri st) -> Inr [Unconditional_C stri st];
    CC_impl [] (CC_rewr _ _) ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_impl [] (CC_impl _ _) ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_impl [] (CC_all _ _) ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_impl [CC_cond stri uv] (CC_cond stria st) ->
      (if stri == stria then Inr [Conditional_C stri uv st]
        else Inl (showsl_lit
                    "problem in final constraint: different relations for finalizing " .
                   showsl_cc cc));
    CC_impl [CC_cond _ _] (CC_rewr _ _) ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_impl [CC_cond _ _] (CC_impl _ _) ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_impl [CC_cond _ _] (CC_all _ _) ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_impl (CC_cond _ _ : _ : _) _ ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_impl (CC_rewr _ _ : _) _ ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_impl (CC_impl _ _ : _) _ ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_impl (CC_all _ _ : _) _ ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
    CC_all _ _ ->
      Inl (showsl_lit
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is\n" .
            showsl_cc cc);
  });
check_cc_prf r da f m_ortho c (Delete_Condition d prf) =
  bindb (check
          (check_subsumes
            (fresh_string
              [Char False False False True True True True False,
                Char False False False True True True True False])
            d c)
          (((showsl_lit "problem in delete conditions when switching from\n" .
              showsl_cc c) .
             showsl_lit " to\n") .
            showsl_cc d))
    (\ _ -> check_cc_prf r da f m_ortho d prf);
check_cc_prf r da f m_ortho c (Different_Constructor d) =
  (case normalize_cc c of {
    CC_impl cs _ ->
      catch_errora
        (bindb
          (check (membera cs d)
            ((showsl_cc d . showsl_lit "\nis not a premise of ") . showsl_cc c))
          (\ _ ->
            (case d of {
              CC_cond _ _ ->
                Inl (showsl_cc d .
                      showsl_lit
                        " is not a rewrite condition of the correct shape");
              CC_rewr (Var _) _ ->
                Inl (showsl_cc d .
                      showsl_lit
                        " is not a rewrite condition of the correct shape");
              CC_rewr (Fun _ _) (Var _) ->
                Inl (showsl_cc d .
                      showsl_lit
                        " is not a rewrite condition of the correct shape");
              CC_rewr (Fun fa ss) (Fun g ts) ->
                bindb (check (not (da (fa, size_list ss)))
                        (showsl fa . showsl_lit " is defined"))
                  (\ _ ->
                    bindb (check (not ((fa, size_list ss) == (g, size_list ts)))
                            ((showsl_lit "the root " . showsl fa) .
                              showsl_lit " is identical on both sides"))
                      (\ _ -> Inr []));
              CC_impl _ _ ->
                Inl (showsl_cc d .
                      showsl_lit
                        " is not a rewrite condition of the correct shape");
              CC_all _ _ ->
                Inl (showsl_cc d .
                      showsl_lit
                        " is not a rewrite condition of the correct shape");
            })))
        (\ x ->
          Inl (((((showsl_lit
                     "problem in Different Constructor with rewrite condition " .
                    showsl_cc d) .
                   showsl_lit "\non input constraint\n") .
                  showsl_cc c) .
                 showsl_literal "\n") .
                x));
  });
check_cc_prf r da f m_ortho ca (Same_Constructor d c p) =
  (case normalize_cc ca of {
    CC_impl cs con ->
      bindb (catch_errora
              (bindb
                (check (membera cs d)
                  ((showsl_cc d . showsl_lit "\nis not a premise of ") .
                    showsl_cc ca))
                (\ _ ->
                  (case d of {
                    CC_cond _ _ ->
                      Inl (showsl_cc d .
                            showsl_lit
                              " is not a rewrite condition of the correct shape");
                    CC_rewr (Var _) _ ->
                      Inl (showsl_cc d .
                            showsl_lit
                              " is not a rewrite condition of the correct shape");
                    CC_rewr (Fun _ _) (Var _) ->
                      Inl (showsl_cc d .
                            showsl_lit
                              " is not a rewrite condition of the correct shape");
                    CC_rewr (Fun fa ss) (Fun g ts) ->
                      bindb (check (not (da (fa, size_list ss)))
                              (showsl fa . showsl_lit " is defined"))
                        (\ _ ->
                          bindb (check ((fa, size_list ss) == (g, size_list ts))
                                  (((showsl fa . showsl_lit " and ") .
                                     showsl g) .
                                    showsl_lit " are not identical"))
                            (\ _ ->
                              let {
                                ds = cs ++ map (\ (a, b) -> CC_rewr a b)
     (zip ss ts);
                                db = CC_impl ds con;
                              } in check (check_subsumes
   (fresh_string
     [Char False False False True True True True False,
       Char False False False True True True True False])
   c db)
                                     (((showsl_lit "new constraint is " .
 showsl_cc c) .
showsl_lit "\nbut expected was ") .
                                       showsl_cc db)));
                    CC_impl _ _ ->
                      Inl (showsl_cc d .
                            showsl_lit
                              " is not a rewrite condition of the correct shape");
                    CC_all _ _ ->
                      Inl (showsl_cc d .
                            showsl_lit
                              " is not a rewrite condition of the correct shape");
                  })))
              (\ x ->
                Inl (((((((showsl_lit
                             "problem in Same Constructor with rewrite condition " .
                            showsl_cc d) .
                           showsl_lit "\n when switching from\n") .
                          showsl_cc ca) .
                         showsl_lit " to\n") .
                        showsl_cc c) .
                       showsl_literal "\n") .
                      x)))
        (\ _ -> check_cc_prf r da f m_ortho c p);
  });
check_cc_prf r da f m_ortho c (Variable_Equation x t d p) =
  (case normalize_cc c of {
    CC_impl cs _ ->
      bindb (catch_errora
              (bindb
                (check
                  (membera cs (CC_rewr (Var x) t) ||
                    membera cs (CC_rewr t (Var x)) &&
                      ball (funas_term t) (\ fa -> not (da fa)))
                  (((showsl_lit "could not find " .
                      showsl_cc (CC_rewr (Var x) t)) .
                     showsl_lit " or reversed as a premise of\n") .
                    showsl_cc c))
                (\ _ ->
                  let {
                    ca = cc_subst_apply
                           (fresh_string
                             [Char False False False True True True True False,
                               Char False False False True True True True
                                 False])
                           c (fun_upd Var x t, vars_term_list t);
                  } in check (check_subsumes
                               (fresh_string
                                 [Char False False False True True True True
                                    False,
                                   Char False False False True True True True
                                     False])
                               d ca)
                         (((showsl_lit "new constraint is " . showsl_cc d) .
                            showsl_lit "\nbut expected was ") .
                           showsl_cc ca)))
              (\ xa ->
                Inl (((((((((showsl_lit
                               "problem in Variable Equation with substitution " .
                              showsl_lista x) .
                             showsl_lit "/") .
                            showsl_terma t) .
                           showsl_lit " to switch from\n") .
                          showsl_cc c) .
                         showsl_lit "\nto\n") .
                        showsl_cc d) .
                       showsl_literal "\n") .
                      xa)))
        (\ _ -> check_cc_prf r da f m_ortho d p);
  });
check_cc_prf r da f m_ortho ca (Funarg_Into_Var c i x d p) =
  (case normalize_cc ca of {
    CC_impl cs con ->
      bindb (catch_errora
              (bindb
                (check (membera cs c)
                  ((showsl_cc c . showsl_lit "\nis not a premise of ") .
                    showsl_cc ca))
                (\ _ ->
                  bindb (check (not (membera (vars_cc_list ca) x))
                          ((showsl_lit "variable " . showsl_lista x) .
                            showsl_lit " is not fresh"))
                    (\ _ ->
                      (case c of {
                        CC_cond _ _ ->
                          Inl (showsl_cc c .
                                showsl_lit
                                  " is not a rewrite condition of the correct shape");
                        CC_rewr (Var _) _ ->
                          Inl (showsl_cc c .
                                showsl_lit
                                  " is not a rewrite condition of the correct shape");
                        CC_rewr (Fun fa ss) q ->
                          bindb (check (less_nat i (size_list ss))
                                  (showsl_lit "invalid position"))
                            (\ _ ->
                              (case (take i ss, (nth ss i, drop (suc i) ss)) of
                                {
                                (bef, (pa, aft)) ->
                                  bindb (catch_errora
  (check_subseteq (funas_term_list pa) f)
  (\ xa ->
    Inl ((showsl_lit "function symbol " . showsl_prod xa) .
          showsl_lit " is not allowed in argument")))
                                    (\ _ ->
                                      let {
px = CC_rewr pa (Var x);
fq = CC_rewr (Fun fa (bef ++ Var x : aft)) q;
ds = px : fq : cs;
daa = CC_impl ds con;
                                      } in
check (check_subsumes
        (fresh_string
          [Char False False False True True True True False,
            Char False False False True True True True False])
        d daa)
  (((showsl_lit "new constraint is " . showsl_cc d) .
     showsl_lit "\nbut expected was ") .
    showsl_cc daa));
                              }));
                        CC_impl _ _ ->
                          Inl (showsl_cc c .
                                showsl_lit
                                  " is not a rewrite condition of the correct shape");
                        CC_all _ _ ->
                          Inl (showsl_cc c .
                                showsl_lit
                                  " is not a rewrite condition of the correct shape");
                      }))))
              (\ xa ->
                Inl (((((((((((showsl_lit
                                 "problem in introducing fresh variable " .
                                showsl_lista x) .
                               showsl_lit " on ") .
                              showsl_nat (suc i)) .
                             showsl_lit "-th argument of lhs of ") .
                            showsl_cc c) .
                           showsl_lit " to switch from ") .
                          showsl_cc ca) .
                         showsl_lit "to\n") .
                        showsl_cc d) .
                       showsl_literal "\n") .
                      xa)))
        (\ _ -> check_cc_prf r da f m_ortho d p);
  });
check_cc_prf r da f m_ortho c (Simplify_Condition bc sigma d p) =
  (case normalize_cc c of {
    CC_impl cs psi ->
      bindb (catch_errora
              (bindb
                (check (membera cs bc)
                  ((showsl_cc bc . showsl_lit "\nis not a premise of ") .
                    showsl_cc c))
                (\ _ ->
                  (case cc_unbound bc of {
                    (ys, cc) ->
                      (case (case normalize_cc cc of {
                              CC_impl a b -> (a, b);
                            })
                        of {
                        (phi, psia) ->
                          let {
                            dom_ran = mk_subst_domain sigma;
                          } in bindb (catch_errora
                                       (check_subseteq (map fst dom_ran) ys)
                                       (\ x ->
 Inl (showsl_lista x .
       showsl_lit " is in the domain of sigma, but not a bound variable ")))
                                 (\ _ ->
                                   bindb (catch_errora
   (forallM
     (\ fn ->
       bindb (check (not (da fn))
               ((showsl_lit "symbol " . showsl_prod fn) .
                 showsl_lit
                   " is not allowed in range of sigma, as it is defined"))
         (\ _ ->
           check (membera f fn)
             ((showsl_lit "symbol " . showsl_prod fn) .
               showsl_lit
                 " is not allowed in range of sigma, as it is not in F")))
     (concatMap (\ x_t -> funas_term_list (snd x_t)) dom_ran))
   (\ x -> Inl (snd x)))
                                     (\ _ ->
                                       let {
 vs = remdups (concatMap (\ x_t -> vars_term_list (snd x_t)) dom_ran);
 sigmaa =
   (\ ca ->
     cc_subst_apply
       (fresh_string
         [Char False False False True True True True False,
           Char False False False True True True True False])
       ca (mk_subst Var sigma, vs));
                                       } in
 bindb (catch_errora
         (forallM
           (\ ca ->
             check (any (\ caa ->
                          check_subsumes
                            (fresh_string
                              [Char False False False True True True True False,
                                Char False False False True True True True
                                  False])
                            caa (sigmaa ca))
                     cs)
               (showsl_cc (sigmaa ca) .
                 showsl_lit
                   "\nis not contained as premise of the input implication"))
           phi)
         (\ x -> Inl (snd x)))
   (\ _ ->
     let {
       daa = CC_impl (sigmaa psia : cs) psi;
     } in check (check_subsumes
                  (fresh_string
                    [Char False False False True True True True False,
                      Char False False False True True True True False])
                  d daa)
            (((showsl_lit "new constraint is " . showsl_cc d) .
               showsl_lit "\nbut expected was ") .
              showsl_cc daa))));
                      });
                  })))
              (\ x ->
                Inl (((((((((showsl_lit
                               "problem in Simplify Condition with substitution " .
                              showsl_lista sigma) .
                             showsl_lit " on IH\n") .
                            showsl_cc bc) .
                           showsl_lit "\nto switch from\n") .
                          showsl_cc c) .
                         showsl_lit "\nto\n") .
                        showsl_cc d) .
                       showsl_literal "\n") .
                      x)))
        (\ _ -> check_cc_prf r da f m_ortho d p);
  });
check_cc_prf r da f m_ortho c (Induction d ccs ihs) =
  (case normalize_cc c of {
    CC_impl cs ca ->
      bindb (catch_errora
              (bindb (check m_ortho (showsl_lit "CR or minimality required"))
                (\ _ ->
                  bindb (catch_errora
                          (forallM
                            (\ cc ->
                              check (membera cs cc)
                                ((showsl_cc cc .
                                   showsl_lit "\nis not a premise of ") .
                                  showsl_cc c))
                            (d : ccs))
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      (case d of {
                        CC_cond _ _ ->
                          Inl (showsl_cc d .
                                showsl_lit
                                  " is not a rewrite condition of the correct shape");
                        CC_rewr (Var _) _ ->
                          Inl (showsl_cc d .
                                showsl_lit
                                  " is not a rewrite condition of the correct shape");
                        CC_rewr (Fun fa xs) q ->
                          let {
                            csa = vars_cc_list
                                    (CC_impl (CC_rewr (Fun fa xs) q : ccs) ca);
                          } in bindb (check
                                       (all is_Var xs &&
 distinct (map the_Var xs))
                                       ((showsl_lit "arguments of " .
  showsl_terma (Fun fa xs)) .
 showsl_lit " are not different variables"))
                                 (\ _ ->
                                   let {
                                     xsa = map the_Var xs;
                                     rt = root (Fun fa xs);
                                   } in bindb
  (check (is_none (mgu (Fun fa xs) q)) (showsl_lit "lhs and rhs unify"))
  (\ _ ->
    bindb (catch_errora
            (forallM
              (\ lr ->
                check (if root (fst lr) == rt
                        then any (\ lra ->
                                   eq_rule_mod_vars lr lra &&
                                     isOK (check_disjoint csa
    (vars_rule_list lra)))
                               (map (\ (ra, _) -> ra) ihs)
                        else True)
                  (showsl_lit
                     "could not find variable renamed version of rule " .
                    showsl_rule lr))
              r)
            (\ x -> Inl (snd x)))
      (\ _ ->
        catch_errora
          (forallM
            (\ (a, b) ->
              (case a of {
                (l, ra) ->
                  (\ (rys, (cc, _)) ->
                    catch_errora
                      (let {
                         cca = cc_rule_constraint
                                 (fresh_string
                                   [Char False False False True True True True
                                      False,
                                     Char False False False True True True True
                                       False])
                                 fa (args l) ra q xsa ccs ca rys;
                       } in bindb (catch_errora
                                    (forallM (check_rys da rt ra) rys)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                check (check_subsumes
(fresh_string
  [Char False False False True True True True False,
    Char False False False True True True True False])
cc cca)
                                  (((showsl_lit "new constraint is " .
                                      showsl_cc cc) .
                                     showsl_lit "\nbut expected was ") .
                                    showsl_cc cca)))
                      (\ x ->
                        Inl (((showsl_lit "problem in constraint for rule " .
                                showsl_rule (l, ra)) .
                               showsl_literal "\n") .
                              x)));
              })
                b)
            ihs)
          (\ x -> Inl (snd x)))));
                        CC_impl _ _ ->
                          Inl (showsl_cc d .
                                showsl_lit
                                  " is not a rewrite condition of the correct shape");
                        CC_all _ _ ->
                          Inl (showsl_cc d .
                                showsl_lit
                                  " is not a rewrite condition of the correct shape");
                      }))))
              (\ x ->
                Inl ((((((showsl_lit
                            "problem in Induction rule with rewrite condition " .
                           showsl_cc d) .
                          showsl_lit " to switch from\n") .
                         showsl_cc c) .
                        showsl_lit "\nto\n") .
                       showsl_list_gen
                         (\ (_, (_, (cb, _))) ->
                           showsl_cc cb . showsl_literal "\n")
                         "" "" "" "" ihs) .
                      x)))
        (\ _ ->
          bindb (mapM (\ (_, a) ->
                        (case a of {
                          (_, aa) ->
                            (case aa of {
                              (ab, b) -> check_cc_prf r da f m_ortho ab b;
                            });
                        }))
                  ihs)
            (\ fcss -> Inr (concat fcss)));
  });

check_cc_prfs ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    ((a, Nat) -> Bool) ->
                      [(a, Nat)] ->
                        Bool ->
                          [(Cond_constraint a [Char],
                             (b, Cond_constraint_prf a [Char]))] ->
                            Sum (String -> String) [C_constraint a [Char]];
check_cc_prfs r d f m_ortho [] = Inr [];
check_cc_prfs r d f m_ortho ((c, (uu, prf)) : cpfs) =
  bindb (check_cc_prf r d f m_ortho c prf)
    (\ l1 -> bindb (check_cc_prfs r d f m_ortho cpfs) (\ l2 -> Inr (l1 ++ l2)));

conditional_general_reduction_pair_proc ::
  forall a b.
    (Ceq b, Ccompare b, Compare_order b, Eq b, Set_impl b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    ([(b, Nat)] -> Non_inf_order_ext b [Char] ()) ->
                      [(Term b [Char], Term b [Char])] ->
                        [(Term b [Char], Term b [Char])] ->
                          Cond_red_pair_prf b [Char] ->
                            Bool -> a -> Sum (String -> String) [a];
conditional_general_reduction_pair_proc i grp pstrict pbound prof merge dpp =
  (case prof of {
    Cond_Red_Pair_Prf c ccs bef aft ->
      let {
        p = pairsb i dpp;
        r = rulesf i dpp;
        f = remdups
              (funas_trs_list r ++
                funas_args_trs_list p ++ concatMap funas_term_list (qc i dpp));
        rp = grp f;
      } in (case catch_errora
                   (bindb (validc rp)
                     (\ _ ->
                       bindb (check (wwf_rulesa i dpp)
                               (showsl_lit "require well-formedness of TRS"))
                         (\ _ ->
                           let {
                             is_def =
                               (\ fn -> not (null (rules_mapc i dpp fn)));
                           } in bindb (check_varcond_subset p)
                                  (\ _ ->
                                    bindb (catch_errora
    (forallM
      (\ (l, ra) ->
        bindb (check_no_var l)
          (\ _ ->
            bindb (check_no_var ra) (\ _ -> check_no_defined_root is_def ra)))
      p)
    (\ x -> Inl (snd x)))
                                      (\ _ ->
let {
  ccsa = map (\ (ca, (uvs, _)) -> (ca, uvs)) ccs;
  check_present = check_constraint_present i dpp c p bef aft ccsa;
} in (case split_pairsa i dpp pstrict of {
       (ps, pns) ->
         (case split_pairsa i dpp pbound of {
           (pb, _) ->
             let {
               pi = afb rp;
               us = usable_rules_gen pi r p;
             } in bindb (catch_errora (forallM (check_present Strict) ps)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (catch_errora
                              (forallM (check_present Non_Strict) pns)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          bindb (catch_errora (forallM (check_present Bound) pb)
                                  (\ x -> Inl (snd x)))
                            (\ _ ->
                              bindb (check (nFQ_subset_NF_rulesc i dpp)
                                      (showsl_lit "innermost required"))
                                (\ _ ->
                                  bindb (catch_errora
  (catch_errora (forallM (nsb rp) us) (\ x -> Inl (snd x)))
  (\ x -> Inl (showsl_lit "problem when orienting usable rules\n" . x)))
                                    (\ _ ->
                                      let {
m = minimal i dpp;
ortho = isOK (check_weakly_orthogonal r);
                                      } in
bindb (catch_errora
        (check_cc_prfs r (\ fn -> not (null (rules_mapc i dpp fn))) f
          (m || ortho) ccs)
        (\ x ->
          Inl (showsl_lit "problem when simplifying conditional constraints\n" .
                x)))
  (\ fcs ->
    catch_errora (catch_errora (forallM (cc rp) fcs) (\ x -> Inl (snd x)))
      (\ x ->
        Inl (showsl_lit
               "problem when orienting final (conditional) constraints for pairs\n" .
              x))))))));
         });
     }))))))
                   (\ x ->
                     Inl (((showsl_lit
                              "could not apply the bounded increase processor with the following\n" .
                             descc rp) .
                            showsl_literal "\n") .
                           x))
             of {
             Inl a -> Inl a;
             Inr _ ->
               Inr (if merge
                     then [delete_P_Pwa i dpp (list_inter pstrict pbound)
                             (list_inter pstrict pbound)]
                     else [delete_P_Pwa i dpp pstrict pstrict,
                            delete_P_Pwa i dpp pbound pbound]);
           });
  });

rules_no_left_vara :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
rules_no_left_vara
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_no_left_var;

critical_pairs_top_impl ::
  forall a.
    (Eq a) => [(Term a [Char], Term a [Char])] ->
                [(Term a [Char], Term a [Char])] ->
                  [(Term a [Char], Term a [Char])];
critical_pairs_top_impl p r =
  concatMap
    (\ (l, ra) ->
      (if is_Var l then []
        else concatMap
               (\ (la, rb) ->
                 (case mgu_var_disjoint_generic
                         (\ a ->
                           Char False False False True True True True False : a)
                         (\ a ->
                           Char True False False True True True True False : a)
                         l la
                   of {
                   Nothing -> [];
                   Just (sigma, tau) ->
                     [(subst_apply_term ra sigma, subst_apply_term rb tau)];
                 }))
               r))
    p;

showsl_crit_pair ::
  forall a b. (Showl a, Showl b) => (Term a b, Term a b) -> String -> String;
showsl_crit_pair lr =
  (((showsl_lit "(" . showsl_terma (fst lr)) . showsl_lit ", ") .
    showsl_terma (snd lr)) .
    showsl_lit ")";

check_critical_pairs_innermost ::
  forall a.
    (Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] -> Sum (String -> String) ();
check_critical_pairs_innermost r =
  catch_errora
    (forallM
      (\ (l, ra) ->
        check (equal_term l ra)
          (showsl_lit "there is a non-trivial critical pair " .
            showsl_crit_pair (l, ra)))
      (critical_pairs_top_impl r r))
    (\ x -> Inl (snd x));

extract_fresh_var ::
  forall a b.
    [((Term a b, Term a b), (Term a b, Term a b))] -> Sum (String -> String) b;
extract_fresh_var sts =
  (case (case sts of {
          [] -> Nothing;
          (_, (Var _, _)) : _ -> Nothing;
          (_, (Fun _ ss, _)) : _ ->
            (if null ss then Nothing else (case last ss of {
    Var a -> Just a;
    Fun _ _ -> Nothing;
  }));
        })
    of {
    Nothing ->
      Inl (showsl_lit
            "could not extract fresh variable (as last argument from some lhs of new pairs)");
    Just a -> Inr a;
  });

extract_ren ::
  forall a b.
    (Eq a) => [((Term a b, Term a b), (Term a b, Term a b))] ->
                Sum (String -> String) ((a, Nat) -> a);
extract_ren ps_ps =
  bindb (check
          (all (\ (a, b) ->
                 (case a of {
                   (s, t) ->
                     (\ (sa, ta) ->
                       not (is_Var s) &&
                         not (is_Var t) && not (is_Var sa) && not (is_Var ta));
                 })
                   b)
            ps_ps)
          (showsl_lit "all lhss and rhss of pairs must be non-variables"))
    (\ _ ->
      let {
        rt = (\ t -> the (root t));
        pair = (\ s sa -> (rt s, fst (rt sa)));
        pairs =
          (\ (st, sta) -> [pair (fst st) (fst sta), pair (snd st) (snd sta)]);
        ren = map_of (remdups (concatMap pairs ps_ps));
        a = (\ fn -> (case ren fn of {
                       Nothing -> fst fn;
                       Just f -> f;
                     }));
      } in Inr a);

check_drop ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => a -> Term b a ->
                         ((b, Nat) -> b) ->
                           ((Term b a, Term b a), (Term b a, Term b a)) ->
                             Sum (String -> String) ();
check_drop x c ren st_st =
  (case st_st of {
    ((s, t), (sa, ta)) ->
      (case s of {
        Fun f ss ->
          (case t of {
            Fun g ts ->
              bindb (check
                      (equal_term sa
                        (Fun (ren (f, size_list ss)) (ss ++ [Var x])))
                      (((showsl_lit "could not relate " . showsl_terma s) .
                         showsl_lit " with ") .
                        showsl_terma sa))
                (\ _ ->
                  let {
                    tsa = args ta;
                    tsaa = take (minus_nat (size_list tsa) one_nat) tsa;
                  } in check (equal_term ta
                                (Fun (ren (g, size_list ts))
                                  (tsaa ++ [Var x])) &&
                               ts == map (\ tb ->
   subst_apply_term tb (subst x c))
                                       tsaa)
                         (((showsl_lit "could not relate " . showsl_terma t) .
                            showsl_lit " with ") .
                           showsl_terma ta));
          });
      });
  });

rwd :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwd (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = rw;

pwb :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pwb (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = pw;

rd :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rd (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = r;

pb :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pb (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = p;

complex_constant_removal_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Complex_constant_removal_prf b [Char] ->
                      a -> Sum (String -> String) a;
complex_constant_removal_proc i (Complex_Constant_Removal_Proof c ps) dpp =
  catch_errora
    (let {
       p = pb i dpp;
       pw = pwb i dpp;
       r = rwd i dpp;
       q = qc i dpp;
       pairs = pairsb i dpp;
     } in bindb (extract_fresh_var ps)
            (\ x ->
              bindb (extract_ren ps)
                (\ ren ->
                  let {
                    is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
                    rQs = remdups (map root q);
                  } in bindb (catch_errora
                               (forallM
                                 (\ (s, t) ->
                                   bindb (check_no_var s)
                                     (\ _ ->
                                       bindb (check_no_var t)
 (\ _ ->
   bindb (check_no_defined_root is_def t)
     (\ _ ->
       bindb (check (not (membera (vars_rule_list (s, t)) x))
               ((showsl_lista x . showsl_lit " is not fresh for pair ") .
                 showsl_rule (s, t)))
         (\ _ ->
           let {
             f = the (root s);
             fa = (ren f, suc (snd f));
           } in bindb (check (not (membera rQs (Just fa)))
                        (showsl_lit "renaming delivers defined symbol of Q"))
                  (\ _ ->
                    check (not (is_def fa))
                      (showsl_lit "renaming delivers defined symbol of R")))))))
                                 pairs)
                               (\ xa -> Inl (snd xa)))
                         (\ _ ->
                           let {
                             pps = filter (\ st_st -> membera p (fst st_st)) ps;
                             pwps =
                               filter (\ st_st -> membera pw (fst st_st)) ps;
                           } in bindb (catch_errora
(forallM
  (\ st ->
    check (membera (map fst pps) st)
      (showsl_lit "could not find entry for pair " . showsl_rule st))
  p)
(\ xa -> Inl (snd xa)))
                                  (\ _ ->
                                    bindb (catch_errora
    (forallM
      (\ st ->
        check (membera (map fst pwps) st)
          (showsl_lit "could not find entry for pair " . showsl_rule st))
      pw)
    (\ xa -> Inl (snd xa)))
                                      (\ _ ->
bindb (check (ground c)
        ((showsl_lit "the term " . showsl_terma c) .
          showsl_lit " is not ground"))
  (\ _ ->
    bindb (check (nFQ_subset_NF_rulesc i dpp) (showsl_lit "innermost required"))
      (\ _ ->
        bindb (check (null (rd i dpp)) (showsl_lit "strict rules not allowed"))
          (\ _ ->
            bindb (check (rules_no_left_vara i dpp)
                    (showsl_lit "rules may not have variables as lhss"))
              (\ _ ->
                bindb (if is_NF_trs r c then Inr ()
                        else catch_errora (check_critical_pairs_innermost r)
                               (\ xa ->
                                 Inl (showsl_lit
"could not ensure confluence\n" .
                                       xa)))
                  (\ _ ->
                    bindb (catch_errora
                            (forallM
                              (\ st_st ->
                                catch_errora (check_drop x c ren st_st)
                                  (\ xa ->
                                    Inl (((((showsl_lit
       "problem in finding correspondence between rule " .
      showsl_rule (fst st_st)) .
     showsl_lit " and rule ") .
    showsl_rule (snd st_st)) .
   showsl_literal "\n") .
  xa)))
                              ps)
                            (\ xa -> Inl (snd xa)))
                      (\ _ ->
                        Inr (mkd i (nfsc i dpp) (minimal i dpp) (map snd pps)
                              (map snd pwps) q [] r)))))))))))))
    (\ x -> Inl (showsl_lit "problem in complex constant removal proc:\n" . x));

fun_of_default :: forall a b. (Eq a) => [(a, b)] -> b -> a -> b;
fun_of_default m d = let {
                       mm = map_of m;
                     } in (\ i -> (case mm i of {
                                    Nothing -> d;
                                    Just e -> e;
                                  }));

get_arg :: forall a b. Term a b -> Nat -> Term a b;
get_arg t n =
  (if equal_nat n zero_nat then t else nth (args t) (minus_nat n one_nat));

iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops ::
  forall a b.
    (Linorder a) => Rbt a () -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s =
  (\ c f -> rm_iterateoi (impl_of s) c (f . fst));

g_ball_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> (a -> Bool) -> Bool;
g_ball_dflt_basic_oops_rm_basic_ops s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ c -> c)
    (\ x _ -> p x) True;

subtract_list_sorted :: forall a. (Eq a, Linorder a) => [a] -> [a] -> [a];
subtract_list_sorted (x : xs) (y : ys) =
  (if x == y then subtract_list_sorted xs (y : ys)
    else (if less x y then x : subtract_list_sorted xs (y : ys)
           else subtract_list_sorted (x : xs) ys));
subtract_list_sorted [] ys = [];
subtract_list_sorted (v : va) [] = v : va;

remdups_sort :: forall a. (Eq a, Linorder a) => [a] -> [a];
remdups_sort xs = remdups_adj (sort_key (\ x -> x) xs);

comp :: forall a. (Eq a, Linorder a) => [(a, a)] -> [(a, a)] -> [(a, a)];
comp esa es =
  remdups_sort
    (concatMap
      (\ (x, y) ->
        concatMap (\ (ya, z) -> (if y == ya then [(x, z)] else [])) es)
      esa);

scg_comp ::
  forall a b.
    (Eq b, Linorder b) => (a -> a -> Bool) -> Scg a b -> Scg a b -> Scg a b;
scg_comp conn (Scg pa qa stra wka) (Scg p q str wk) =
  (if not (conn qa p) then Null
    else let {
           strs = remdups_sort (comp stra str ++ comp stra wk ++ comp wka str);
           a = subtract_list_sorted (remdups_sort (comp wka wk)) strs;
         } in Scg pa q strs a);
scg_comp conn Null g = Null;
scg_comp conn (Scg v va vb vc) Null = Null;

generate_scgs ::
  forall a b.
    (Eq a, Eq b,
      Linorder b) => (a -> a -> Bool) -> [Scg a b] -> Scg a b -> [Scg a b];
generate_scgs conn base g =
  filter (\ ga -> not (equal_scg ga Null)) (map (scg_comp conn g) base);

subsumes :: forall a b. (Eq a, Eq b) => Scg a b -> Scg a b -> Bool;
subsumes (Scg pa qa stra wka) (Scg p q str wk) =
  pa == p && qa == q && all (membera str) stra && all (membera (str ++ wk)) wka;
subsumes g Null = True;
subsumes Null (Scg v va vb vc) = False;

in_situ :: forall a b. (Eq b) => Scg a b -> Bool;
in_situ Null = True;
in_situ (Scg p q str wk) = any (\ (a, b) -> a == b) str;

union_list_sorted :: forall a. (Eq a, Ord a) => [a] -> [a] -> [a];
union_list_sorted (x : xs) (y : ys) =
  (if x == y then x : union_list_sorted xs ys
    else (if less x y then x : union_list_sorted xs (y : ys)
           else y : union_list_sorted (x : xs) ys));
union_list_sorted [] ys = ys;
union_list_sorted (v : va) [] = v : va;

combinea :: forall a b. (Eq b, Linorder b) => Scg a b -> Scg a b -> Scg a b;
combinea (Scg pa qa stra wka) (Scg p q str wk) =
  Scg pa qa (union_list_sorted stra str) (union_list_sorted wka wk);
combinea Null s = Null;
combinea (Scg v va vb vc) Null = Null;

sagiv ::
  forall a b. (Eq a, Eq b, Linorder b) => (a -> a -> Bool) -> Scg a b -> Bool;
sagiv conn g =
  (if in_situ g then True
    else let {
           gg = scg_comp conn g g;
         } in (if subsumes gg g then False else sagiv conn (combinea g gg)));

check_SCT ::
  forall a b.
    (Compare_order a, Eq a, Compare_order b,
      Eq b) => (a -> a -> Bool) -> [Scg a b] -> Bool;
check_SCT conn gs =
  g_ball_dflt_basic_oops_rm_basic_ops
    (mk_rtrancl_set (generate_scgs conn gs) gs) (sagiv conn);

sct_subterm_precise_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    [((Term b [Char], Term b [Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum (String -> String) ();
sct_subterm_precise_proc i gs dpp =
  catch_errora
    (let {
       p = pairsb i dpp;
       is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
       eidg = is_iedg_edge_dpp i dpp;
     } in bindb (catch_errora (check_subseteq p (map fst gs))
                  (\ x ->
                    Inl (showsl_lit
                           "there is no size-change graph for the pair " .
                          showsl_rule x)))
            (\ _ ->
              let {
                gGs = filter (\ g -> membera p (fst g)) gs;
              } in bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                           (showsl_lit "minimality or innermost required"))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulesf i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ (a, b) ->
                                       (case a of {
 (s, t) ->
   (\ (stri, nstri) ->
     catch_errora
       (bindb (check_no_var s)
         (\ _ ->
           bindb (check_no_var t)
             (\ _ ->
               bindb (check_no_defined_root is_def t)
                 (\ _ ->
                   let {
                     m = size_list (args t);
                     n = size_list (args s);
                   } in bindb (catch_errora
                                (forallM
                                  (\ (ia, j) ->
                                    check (less_eq_nat ia n &&
    less_eq_nat j m && isOK (check_supt (get_arg s ia) (get_arg t j)))
                                      ((((showsl_lit "problem with edge " .
   showsl_nat ia) .
  showsl_lit " |> ") .
 showsl_nat j) .
showsl_literal "\n"))
                                  stri)
                                (\ x -> Inl (snd x)))
                          (\ _ ->
                            catch_errora
                              (forallM
                                (\ (ia, j) ->
                                  check (less_eq_nat ia n &&
  less_eq_nat j m && isOK (check_supteq (get_arg s ia) (get_arg t j)))
                                    ((((showsl_lit "problem with edge " .
 showsl_nat ia) .
showsl_lit " |>= ") .
                                       showsl_nat j) .
                                      showsl_literal "\n"))
                                nstri)
                              (\ x -> Inl (snd x)))))))
       (\ x ->
         Inl (((showsl_lit "problem with pair " . showsl_rule (s, t)) .
                showsl_literal "\n") .
               x)));
                                       })
 b)
                                     gGs)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               let {
                                 n = size_list p;
                                 nums = upt zero_nat n;
                                 numPs = zip p nums;
                                 num_of = fun_of_default numPs n;
                               } in check (check_SCT
    (\ (_, succs) (uv, _) -> membera succs uv)
    (map (\ (st, (stri, nstri)) ->
           let {
             eidg_st = eidg st;
             ia = num_of st;
             e = (ia, map_filter
                        (\ x ->
                          (if ((eidg_st . fst) . fst) x then Just (snd x)
                            else Nothing))
                        numPs);
           } in Scg e e (remdups_sort stri) (remdups_sort nstri))
      gGs))
                                      (showsl_lit
"size-change analysis failed\n"))))))
    (\ x ->
      Inl (showsl_lit
             "could not apply the size-change processor based on the subterm-relation\n" .
            x));

sct_subterm_approx_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    [((Term b [Char], Term b [Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum (String -> String) ();
sct_subterm_approx_proc i gs dpp =
  catch_errora
    (let {
       p = pairsb i dpp;
       is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
     } in bindb (catch_errora (check_subseteq p (map fst gs))
                  (\ x ->
                    Inl (showsl_lit
                           "there is no size-change graph for the pair " .
                          showsl_rule x)))
            (\ _ ->
              let {
                gGs = filter (\ g -> membera p (fst g)) gs;
              } in bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                           (showsl_lit "minimality or innermost required"))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulesf i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ (a, b) ->
                                       (case a of {
 (s, t) ->
   (\ (stri, nstri) ->
     catch_errora
       (bindb (check_no_var s)
         (\ _ ->
           bindb (check_no_var t)
             (\ _ ->
               bindb (check_no_defined_root is_def t)
                 (\ _ ->
                   let {
                     m = size_list (args t);
                     n = size_list (args s);
                   } in bindb (catch_errora
                                (forallM
                                  (\ (ia, j) ->
                                    check (less_eq_nat ia n &&
    less_eq_nat j m && isOK (check_supt (get_arg s ia) (get_arg t j)))
                                      ((((showsl_lit "problem with edge " .
   showsl_nat ia) .
  showsl_lit " |> ") .
 showsl_nat j) .
showsl_literal "\n"))
                                  stri)
                                (\ x -> Inl (snd x)))
                          (\ _ ->
                            catch_errora
                              (forallM
                                (\ (ia, j) ->
                                  check (less_eq_nat ia n &&
  less_eq_nat j m && isOK (check_supteq (get_arg s ia) (get_arg t j)))
                                    ((((showsl_lit "problem with edge " .
 showsl_nat ia) .
showsl_lit " |>= ") .
                                       showsl_nat j) .
                                      showsl_literal "\n"))
                                nstri)
                              (\ x -> Inl (snd x)))))))
       (\ x ->
         Inl (((showsl_lit "problem with pair " . showsl_rule (s, t)) .
                showsl_literal "\n") .
               x)));
                                       })
 b)
                                     gGs)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               check (check_SCT (\ (_, g) (h, _) -> g == h)
                                       (remdups
 (map (\ (st, (stri, nstri)) ->
        let {
          e = (the (root (fst st)), the (root (snd st)));
        } in Scg e e (remdups_sort stri) (remdups_sort nstri))
   gGs)))
                                 (showsl_lit
                                   "size-change analysis failed\n"))))))
    (\ x ->
      Inl (showsl_lit
             "could not apply the size-change processor based on the subterm-relation\n" .
            x));

sct_subterm_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    [((Term b [Char], Term b [Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum (String -> String) ();
sct_subterm_proc i gs dpp =
  (if isOK (sct_subterm_approx_proc i gs dpp) then Inr ()
    else sct_subterm_precise_proc i gs dpp);

sct_entry_to_sts ::
  forall a b c d. a -> Term b c -> [(d, Nat)] -> [(d, Nat)] -> [(a, Term b c)];
sct_entry_to_sts s t stri nstri = let {
                                    a = remdups (map snd (stri ++ nstri));
                                  } in map (\ j -> (s, get_arg t j)) a;

check_sct_entry ::
  forall a b c d e f.
    (Showl a,
      Showl b) => ((a, Nat) -> Bool) ->
                    ((Term a b, Term a b) -> Sum c d) ->
                      ((Term a b, Term a b) -> Sum e f) ->
                        Term a b ->
                          Term a b ->
                            [(Nat, Nat)] ->
                              [(Nat, Nat)] -> Sum (String -> String) ();
check_sct_entry is_def sa nst s t stri nstri =
  catch_errora
    (bindb (check_no_var s)
      (\ _ ->
        bindb (check_no_var t)
          (\ _ ->
            bindb (check_no_defined_root is_def t)
              (\ _ ->
                let {
                  m = size_list (args t);
                  n = size_list (args s);
                } in bindb (catch_errora
                             (forallM
                               (\ i ->
                                 check (less_eq_nat i n)
                                   ((showsl_lit "left-index to large" .
                                      showsl_nat i) .
                                     showsl_literal "\n"))
                               (remdups (map fst (stri ++ nstri))))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM
                                   (\ j ->
                                     check (less_eq_nat j m)
                                       (showsl_lit
  "right-index to large or argument violates usable-rules condition" .
 showsl_nat j))
                                   (remdups (map snd (stri ++ nstri))))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             let {
                               _ = args s;
                               _ = args t;
                             } in bindb (catch_errora
  (forallM
    (\ (i, j) ->
      check (isOK (sa (get_arg s i, get_arg t j)))
        (((showsl_lit "problem with edge " . showsl_nat i) .
           showsl_lit " -S-> ") .
          showsl_nat j))
    stri)
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      catch_errora
(forallM
  (\ (i, j) ->
    check (isOK (nst (get_arg s i, get_arg t j)))
      (((showsl_lit "problem with edge " . showsl_nat i) .
         showsl_lit " -NS-> ") .
        showsl_nat j))
  nstri)
(\ x -> Inl (snd x)))))))))
    (\ x ->
      Inl (((showsl_lit "problems with DP " . showsl_rule (s, t)) .
             showsl_literal "\n") .
            x));

sct_ur_af_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Redtriple_ext b [Char] () ->
                      [((Term b [Char], Term b [Char]),
                         ([(Nat, Nat)], [(Nat, Nat)]))] ->
                        Maybe [(Term b [Char], Term b [Char])] ->
                          a -> Sum (String -> String) ();
sct_ur_af_proc i rp gs u_opt dpp =
  catch_errora
    (bindb (valid rp)
      (\ _ ->
        let {
          is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
          pi = af rp;
          sa = s rp;
          nsa = ns rp;
          nsta = nst rp;
          p = pairsb i dpp;
          gGs = filter (\ g -> membera p (fst g)) gs;
        } in bindb (catch_errora
                     (forallM (\ (l, _) -> check_no_var l) (rulesf i dpp))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (catch_errora
                         (forallM
                           (\ (a, b) ->
                             (case a of {
                               (saa, t) ->
                                 (\ (aa, ba) ->
                                   check_sct_entry is_def sa nsta saa t aa ba);
                             })
                               b)
                           gGs)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     let {
                       sts = concatMap
                               (\ (a, b) ->
                                 (case a of {
                                   (sb, t) ->
                                     (\ (aa, ba) ->
                                       sct_entry_to_sts sb t aa ba);
                                 })
                                   b)
                               gGs;
                     } in bindb (smart_usable_rules_checker_impl i dpp pi u_opt
                                  sts)
                            (\ u ->
                              bindb (catch_errora
                                      (catch_errora (forallM nsa u)
(\ x -> Inl (snd x)))
                                      (\ x ->
Inl (showsl_lit "problem when orienting usable rules\n" . x)))
                                (\ _ ->
                                  let {
                                    eidg = is_iedg_edge_dpp i dpp;
                                  } in bindb
 (catch_errora (check_subseteq p (map fst gs))
   (\ x ->
     Inl (showsl_lit "there is no size-change graph for DP " . showsl_rule x)))
 (\ _ ->
   let {
     n = size_list p;
     nums = upt zero_nat n;
     numPs = zip p nums;
     num_of = fun_of_default numPs n;
   } in check (check_SCT (\ (_, succs) (uv, _) -> membera succs uv)
                (map (\ (st, (stri, nstri)) ->
                       let {
                         eidg_st = eidg st;
                         ia = num_of st;
                         e = (ia, map_filter
                                    (\ x ->
                                      (if ((eidg_st . fst) . fst) x
then Just (snd x) else Nothing))
                                    numPs);
                       } in Scg e e stri nstri)
                  gGs))
          (showsl_lit "size-change analysis failed\n"))))))))
    (\ x ->
      Inl (((showsl_lit
               "could not apply the size-change processor with the following\n" .
              desca rp) .
             showsl_lit "\nfor the following reason\n") .
            x));

proj_terma ::
  forall a b.
    (Ceq a, Ccompare a, Eq a,
      Eq b) => Status a -> Set (a, Nat) -> Term a b -> Multiset (Term a b);
proj_terma proj f (Var x) = add_mset (Var x) zero_multiset;
proj_terma proj fa (Fun f ts) =
  (if member (f, size_list ts) fa
    then sum_mset
           (mset (map (\ i -> proj_terma proj fa (nth ts i))
                   (status proj (f, size_list ts))))
    else add_mset (Fun f ts) zero_multiset);

weak_supt_mul ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Status a -> Set (a, Nat) -> Term a b -> Term a b -> Bool;
weak_supt_mul =
  (\ proj f s t ->
    multeqp (\ x y -> supt_impl y x) (proj_terma proj f t)
      (proj_terma proj f s));

check_supteqproj_pred ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Showl a, Compare b, Eq b,
      Showl b) => Status a ->
                    Set (a, Nat) ->
                      (Term a b, Term a b) -> Sum (String -> String) ();
check_supteqproj_pred pi f lr =
  check (case lr of {
          (a, b) -> weak_supt_mul pi f a b;
        })
    ((showsl_lit "could not orient rule " . showsl_rule lr) .
      showsl_lit " by supteq^mul");

strict_supt_mul ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Compare b,
      Eq b) => Status a -> Set (a, Nat) -> Term a b -> Term a b -> Bool;
strict_supt_mul =
  (\ proj f s t ->
    multeqp (\ x y -> supt_impl y x) (proj_terma proj f t)
      (proj_terma proj f s) &&
      not (equal_multiset (proj_terma proj f s) (proj_terma proj f t)));

check_suptproj_pred ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Showl a, Compare b, Eq b,
      Showl b) => Status a ->
                    Set (a, Nat) ->
                      (Term a b, Term a b) -> Sum (String -> String) ();
check_suptproj_pred pi f lr =
  check (case lr of {
          (a, b) -> strict_supt_mul pi f a b;
        })
    ((showsl_lit "could not orient rule " . showsl_rule lr) .
      showsl_lit " by supt^mul");

generalized_subterm_proc ::
  forall a b c.
    (Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showl b, Compare c, Eq c,
      Showl c) => Dpp_ops_ext a b c () ->
                    [((b, Nat), [Nat])] ->
                      [(Term b c, Term b c)] -> a -> Sum (String -> String) a;
generalized_subterm_proc i pi p_remove dpp =
  (case catch_errora
          (let {
             p = pairsb i dpp;
             r = rulesf i dpp;
             f = map fst pi;
             ff = set f;
             pi_opt = status_of pi;
           } in bindb (check (null (qc i dpp))
                        (showsl_lit
                          "currently generalized subterm criterion does not support strategies"))
                  (\ _ ->
                    bindb (check (minimal i dpp)
                            (showsl_lit "minimality required"))
                      (\ _ ->
                        bindb (check (not (is_none pi_opt))
                                (showsl_lit
                                  "argument filter lists invalid positions"))
                          (\ _ ->
                            let {
                              pia = the pi_opt;
                              premove = set p_remove;
                            } in (case partition (\ lr -> member lr premove) p
                                   of {
                                   (ps, pns) ->
                                     bindb (catch_errora
     (forallM
       (\ fa ->
         check (not (null (status pia fa)))
           ((showsl_lit "status of symbol " . showsl_prod fa) .
             showsl_lit " in F must be non-empty"))
       f)
     (\ x -> Inl (snd x)))
                                       (\ _ ->
 bindb (catch_errora
         (forallM
           (\ (l, _) ->
             check (not (is_Var l))
               (showsl_lit "variables as lhss not allowed"))
           r)
         (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (catch_errora
             (catch_errora
               (forallM (check_supteqproj_pred pia ff)
                 (filter (\ lr -> member (the (root (fst lr))) ff) r))
               (\ x -> Inl (snd x)))
             (\ x ->
               Inl (showsl_lit "problem when orienting rules with root in F\n" .
                     x)))
       (\ _ ->
         bindb (catch_errora
                 (catch_errora (forallM (check_supteqproj_pred pia ff) pns)
                   (\ x -> Inl (snd x)))
                 (\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x)))
           (\ _ ->
             catch_errora
               (catch_errora (forallM (check_suptproj_pred pia ff) ps)
                 (\ x -> Inl (snd x)))
               (\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x))))));
                                 })))))
          (\ x ->
            Inl (showsl_lit "could not apply the subterm processor\n" . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp p_remove p_remove);
  });

simplifya :: forall a. (Eq a) => Term Siga a -> Term Siga a;
simplifya (Var x) = Var x;
simplifya (Fun (ConstFa n) ss) = Fun (ConstFa n) [];
simplifya (Fun SumFa ss) =
  let {
    ssa = filter (\ s -> not (equal_term s (Fun (ConstFa zero_nat) [])))
            (map simplifya ss);
  } in (case ssa of {
         [] -> Fun (ConstFa zero_nat) [];
         [s] -> s;
         _ : _ : _ -> Fun SumFa ssa;
       });
simplifya (Fun ProdFa ss) =
  let {
    ssa = filter (\ s -> not (equal_term s (Fun (ConstFa one_nat) [])))
            (map simplifya ss);
  } in (if membera ssa (Fun (ConstFa zero_nat) [])
         then Fun (ConstFa zero_nat) [] else (case ssa of {
       [] -> Fun (ConstFa one_nat) [];
       [s] -> s;
       _ : _ : _ -> Fun ProdFa ssa;
     }));
simplifya (Fun MaxF ss) =
  let {
    ssa = filter (\ s -> not (equal_term s (Fun (ConstFa zero_nat) [])))
            (map simplifya ss);
  } in (case ssa of {
         [] -> Fun (ConstFa zero_nat) [];
         [s] -> s;
         _ : _ : _ -> Fun MaxF ssa;
       });

simplified_alist ::
  forall a.
    (Showl a) => [((a, Nat), Term Siga Nat)] -> [((a, Nat), Term Siga Nat)];
simplified_alist alist = map (map_prod id simplifya) alist;

iA_exp_to_tpoly :: forall a. Term Sig (a, Ty) -> Tpoly a Int;
iA_exp_to_tpoly (Var (a, ty)) = PVar a;
iA_exp_to_tpoly (Fun (SumF uu) asa) = PSum (map iA_exp_to_tpoly asa);
iA_exp_to_tpoly (Fun (ConstF a) []) = PNum a;
iA_exp_to_tpoly (Fun (ProdF uv) asa) = PMult (map iA_exp_to_tpoly asa);

iA_exp_to_poly ::
  forall a. (Eq a, Linorder a) => Term Sig (a, Ty) -> [(Monom a, Int)];
iA_exp_to_poly = poly_of . iA_exp_to_tpoly;

showsl_IA_exp ::
  forall a. (Eq a, Linorder a, Showl a) => Term Sig (a, Ty) -> String -> String;
showsl_IA_exp (Fun LessF [s, t]) =
  (showsl_IA_exp s . showsl_lit " < ") . showsl_IA_exp t;
showsl_IA_exp (Fun LeF [s, t]) =
  (showsl_IA_exp s . showsl_lit " <= ") . showsl_IA_exp t;
showsl_IA_exp (Fun EqF [s, t]) =
  (showsl_IA_exp s . showsl_lit " = ") . showsl_IA_exp t;
showsl_IA_exp (Var v) = showsl_poly (iA_exp_to_poly (Var v));
showsl_IA_exp (Fun LeF []) =
  (showsl_poly :: [(Monom a, Int)] -> String -> String)
    ((iA_exp_to_poly :: Term Sig (a, Ty) -> [(Monom a, Int)]) (Fun LeF []));
showsl_IA_exp (Fun LeF [v]) = showsl_poly (iA_exp_to_poly (Fun LeF [v]));
showsl_IA_exp (Fun LeF (v : vc : ve : vf)) =
  showsl_poly (iA_exp_to_poly (Fun LeF (v : vc : ve : vf)));
showsl_IA_exp (Fun (SumF vb) va) =
  showsl_poly (iA_exp_to_poly (Fun (SumF vb) va));
showsl_IA_exp (Fun (ConstF vb) va) =
  showsl_poly (iA_exp_to_poly (Fun (ConstF vb) va));
showsl_IA_exp (Fun (ProdF vb) va) =
  showsl_poly (iA_exp_to_poly (Fun (ProdF vb) va));
showsl_IA_exp (Fun EqF []) =
  (showsl_poly :: [(Monom a, Int)] -> String -> String)
    ((iA_exp_to_poly :: Term Sig (a, Ty) -> [(Monom a, Int)]) (Fun EqF []));
showsl_IA_exp (Fun EqF [v]) = showsl_poly (iA_exp_to_poly (Fun EqF [v]));
showsl_IA_exp (Fun EqF (v : vc : ve : vf)) =
  showsl_poly (iA_exp_to_poly (Fun EqF (v : vc : ve : vf)));
showsl_IA_exp (Fun v []) =
  (showsl_poly :: [(Monom a, Int)] -> String -> String)
    ((iA_exp_to_poly :: Term Sig (a, Ty) -> [(Monom a, Int)]) (Fun v []));
showsl_IA_exp (Fun v [vb]) = showsl_poly (iA_exp_to_poly (Fun v [vb]));
showsl_IA_exp (Fun v (vb : vd : vf : vg)) =
  showsl_poly (iA_exp_to_poly (Fun v (vb : vd : vf : vg)));

to_IA :: forall a. Term Siga a -> [Term Sig (a, Ty)];
to_IA (Var x) = [Var (x, IntT)];
to_IA (Fun f ss) =
  (case f of {
    ConstFa n -> [Fun (ConstF (int_of_nat n)) []];
    SumFa ->
      (if null ss then [Fun (SumF zero_nat) []]
        else map (Fun (SumF (size_list ss))) (product_lists (map to_IA ss)));
    ProdFa ->
      (if null ss then [Fun (ProdF zero_nat) []]
        else map (Fun (ProdF (size_list ss))) (product_lists (map to_IA ss)));
    MaxF ->
      (if null ss then [Fun (ConstF zero_int) []] else concatMap to_IA ss);
  });

le_via_IA :: forall a. Term Siga a -> Term Siga a -> Formula (Term Sig (a, Ty));
le_via_IA s t =
  form_or
    (form_not
      (Conjunction
        (map (\ x -> Atom (Fun LeF [Fun (ConstF zero_int) [], Var (x, IntT)]))
          (vars_term_list s ++ vars_term_list t))))
    (Conjunction
      (map (\ sa ->
             Disjunction (map (\ ta -> Atom (Fun LeF [sa, ta])) (to_IA t)))
        (to_IA s)));

is_or_and_shape :: forall a. Formula a -> Bool;
is_or_and_shape (Disjunction (va : vc : ve : vf)) = False;
is_or_and_shape (Disjunction (va : Disjunction ve : vd)) = False;
is_or_and_shape (Disjunction (va : Conjunction (vf : vh : vj : vk) : vd)) =
  False;
is_or_and_shape (Disjunction (va : Conjunction [vf] : vd)) = False;
is_or_and_shape (Disjunction (va : Conjunction [] : vd)) = False;
is_or_and_shape (Disjunction (va : NegAtom ve : vd)) = False;
is_or_and_shape (Disjunction (va : Atom ve : vd)) = False;
is_or_and_shape (Disjunction [va]) = False;
is_or_and_shape (Disjunction []) = False;
is_or_and_shape (Conjunction v) = False;
is_or_and_shape (NegAtom v) = False;
is_or_and_shape (Atom v) = False;
is_or_and_shape (Disjunction [phi_1, Conjunction [phi_2, phi_3]]) = True;

showsl_formula ::
  forall a. (a -> String -> String) -> Formula a -> String -> String;
showsl_formula showsl_atom (Disjunction fs) =
  let {
    a = map (showsl_formula showsl_atom) fs;
  } in showsl_list_gen id "False" "Disj[" ", " "]" a;
showsl_formula showsl_atom (Conjunction fs) =
  let {
    a = map (showsl_formula showsl_atom) fs;
  } in showsl_list_gen id "True" "Conj[" ", " "]" a;
showsl_formula showsl_atom (NegAtom a) =
  (showsl_literal "! (" . showsl_atom a) . showsl_literal ")";
showsl_formula showsl_atom (Atom a) = showsl_atom a;

remove_Atom ::
  forall a b c.
    (Showl b) => (Term a (b, c) -> Formula (Term a (b, c))) ->
                   Formula (Term a (b, c)) -> Formula (Term a (b, c));
remove_Atom negate_atom (Atom phi) = form_not (negate_atom phi);
remove_Atom negate_atom (NegAtom phi) = NegAtom phi;
remove_Atom negate_atom (Disjunction phi_s) =
  Disjunction (map (remove_Atom negate_atom) phi_s);
remove_Atom negate_atom (Conjunction phi_s) =
  Conjunction (map (remove_Atom negate_atom) phi_s);

trivial_clause_checker :: forall a. (Eq a) => Formula a -> Bool;
trivial_clause_checker f = (case f of {
                             Disjunction a -> trivial_checker a;
                           });

check_valid_formula ::
  forall a b c d.
    (Eq a, Eq b, Showl b, Eq c, Default d,
      Showl d) => (Term a (b, c) -> String -> String) ->
                    (d -> Formula (Term a (b, c)) ->
                            Sum (String -> String) ()) ->
                      (Term a (b, c) -> Formula (Term a (b, c))) ->
                        Formula (Term a (b, c)) -> Sum (String -> String) ();
check_valid_formula showsl_atom logic_checker negate_atom phi =
  catch_errora
    (case flatten phi of {
      Conjunction phi_s ->
        catch_errora
          (forallM
            (\ phia ->
              catch_errora
                (check (trivial_clause_checker phia)
                  "trivial clause checker failed")
                (\ _ ->
                  (case flatten (remove_Atom negate_atom phia) of {
                    Conjunction phi_sa ->
                      catch_errora (forallM (logic_checker defaulta) phi_sa)
                        (\ x -> Inl (snd x));
                  })))
            phi_s)
          (\ x -> Inl (snd x));
    })
    (\ x ->
      Inl (((showsl_lit "problem in checking validity of formula " .
              showsl_formula showsl_atom phi) .
             showsl_literal "\n") .
            x));

is_disj_shape :: forall a b. [a] -> Formula b -> Bool;
is_disj_shape uu (Disjunction (va : vc : ve : vf)) = False;
is_disj_shape uu (Disjunction (va : Disjunction ve : vd)) = False;
is_disj_shape uu (Disjunction (va : Conjunction (vf : vh : vj : vk) : vd)) =
  False;
is_disj_shape uu (Disjunction (va : Conjunction [vf] : vd)) = False;
is_disj_shape uu (Disjunction (va : Conjunction [] : vd)) = False;
is_disj_shape uu (Disjunction (va : NegAtom ve : vd)) = False;
is_disj_shape uu (Disjunction (va : Atom ve : vd)) = False;
is_disj_shape uu (Disjunction [va]) = False;
is_disj_shape uu (Disjunction (Disjunction vc : vb)) = False;
is_disj_shape uu (Disjunction (Conjunction (vd : vf : vh : vi) : vb)) = False;
is_disj_shape uu (Disjunction (Conjunction [vd] : vb)) = False;
is_disj_shape uu (Disjunction (Conjunction [] : vb)) = False;
is_disj_shape uu (Disjunction (NegAtom vc : vb)) = False;
is_disj_shape uu (Disjunction (Atom vc : vb)) = False;
is_disj_shape uu (Disjunction []) = False;
is_disj_shape uu (Conjunction v) = False;
is_disj_shape uu (NegAtom v) = False;
is_disj_shape uu (Atom v) = False;
is_disj_shape [] uv = False;
is_disj_shape (hint1 : hints)
  (Disjunction [Conjunction [phi_1, phi_2], Conjunction [phi_3, phi_4]]) = True;

is_conj_shape :: forall a b. [a] -> Formula b -> Bool;
is_conj_shape uu (Disjunction v) = False;
is_conj_shape uu (Conjunction (va : vc : ve : vf)) = False;
is_conj_shape uu (Conjunction [va]) = False;
is_conj_shape uu (Conjunction []) = False;
is_conj_shape uu (NegAtom v) = False;
is_conj_shape uu (Atom v) = False;
is_conj_shape (v : vb : vd : ve) uv = False;
is_conj_shape [v] uv = False;
is_conj_shape [] uv = False;
is_conj_shape [hint1, hint2] (Conjunction [phi_1, phi_2]) = True;

is_neg_atom_clause :: forall a. Formula a -> Bool;
is_neg_atom_clause (NegAtom a) = False;
is_neg_atom_clause (Atom a) = False;
is_neg_atom_clause (Conjunction xs) = False;
is_neg_atom_clause (Disjunction ls) = all is_neg_atom ls;

check_formula ::
  forall a b c d.
    (Eq a, Eq b, Showl b, Eq c, Default d,
      Showl d) => (Term a (b, c) -> String -> String) ->
                    (d -> Formula (Term a (b, c)) ->
                            Sum (String -> String) ()) ->
                      (Term a (b, c) -> Formula (Term a (b, c))) ->
                        Hint d ->
                          Formula (Term a (b, c)) -> Sum (String -> String) ();
check_formula showsl_atom logic_checker negate_atom (LexStrict hints) psi =
  (case psi of {
    Atom _ ->
      Inl (showsl_literal "LexStrict hint applied on " .
            showsl_formula showsl_atom psi);
    NegAtom _ ->
      Inl (showsl_literal "LexStrict hint applied on " .
            showsl_formula showsl_atom psi);
    Conjunction _ ->
      Inl (showsl_literal "LexStrict hint applied on " .
            showsl_formula showsl_atom psi);
    Disjunction a ->
      (case a of {
        [] -> Inl (showsl_literal "LexStrict hint applied on " .
                    showsl_formula showsl_atom psi);
        aa : b ->
          check_formula_lex showsl_atom logic_checker negate_atom hints aa b;
      });
  });
check_formula showsl_atom logic_checker negate_atom (LexWeak hints) psi =
  (case psi of {
    Atom _ ->
      Inl (showsl_literal "LexWeak hint applied on " .
            showsl_formula showsl_atom psi);
    NegAtom _ ->
      Inl (showsl_literal "LexWeak hint applied on " .
            showsl_formula showsl_atom psi);
    Conjunction _ ->
      Inl (showsl_literal "LexWeak hint applied on " .
            showsl_formula showsl_atom psi);
    Disjunction a ->
      (case a of {
        [] -> Inl (showsl_literal "LexWeak hint applied on " .
                    showsl_formula showsl_atom psi);
        aa : b ->
          check_formula_lex_weak showsl_atom logic_checker negate_atom hints aa
            b;
      });
  });
check_formula showsl_atom logic_checker negate_atom (Distribute n hints) phi =
  (case phi of {
    Atom _ ->
      Inl (showsl_literal "Distribute hint for non Disjunction " .
            showsl_formula showsl_atom phi);
    NegAtom _ ->
      Inl (showsl_literal "Distribute hint for non Disjunction " .
            showsl_formula showsl_atom phi);
    Conjunction _ ->
      Inl (showsl_literal "Distribute hint for non Disjunction " .
            showsl_formula showsl_atom phi);
    Disjunction phi_s ->
      let {
        l = size_list phi_s;
      } in bindb (check (less_nat n l)
                   (((showsl_literal "distribute hint at position " .
                       showsl_nat n) .
                      showsl_literal " while goal is length ") .
                     showsl_nat l))
             (\ _ ->
               let {
                 pre = take n phi_s;
                 post = drop (suc n) phi_s;
               } in (case nth phi_s n of {
                      Atom _ ->
                        Inl (((showsl_literal "Distribute hint in: \n" .
                                showsl_formula showsl_atom phi) .
                               showsl_literal
                                 "\n at non-Conjunction position:\n") .
                              showsl_formula showsl_atom (nth phi_s n));
                      NegAtom _ ->
                        Inl (((showsl_literal "Distribute hint in: \n" .
                                showsl_formula showsl_atom phi) .
                               showsl_literal
                                 "\n at non-Conjunction position:\n") .
                              showsl_formula showsl_atom (nth phi_s n));
                      Conjunction a ->
                        check_formula_dist showsl_atom logic_checker negate_atom
                          hints pre post a;
                      Disjunction _ ->
                        Inl (((showsl_literal "Distribute hint in: \n" .
                                showsl_formula showsl_atom phi) .
                               showsl_literal
                                 "\n at non-Conjunction position:\n") .
                              showsl_formula showsl_atom (nth phi_s n));
                    }));
  });
check_formula showsl_atom logic_checker negate_atom (Erase n hint) phi =
  (case phi of {
    Atom _ -> Inl (showsl_literal "Erase hint to non-Disjunction");
    NegAtom _ -> Inl (showsl_literal "Erase hint to non-Disjunction");
    Conjunction _ -> Inl (showsl_literal "Erase hint to non-Disjunction");
    Disjunction phi_s ->
      let {
        l = size_list phi_s;
      } in bindb (check (less_nat n l)
                   (((showsl_literal "erase hint at position " . showsl_nat n) .
                      showsl_literal " while goal is length ") .
                     showsl_nat l))
             (\ _ ->
               let {
                 pre = take n phi_s;
                 post = drop (suc n) phi_s;
               } in check_formula showsl_atom logic_checker negate_atom hint
                      (Disjunction (pre ++ Disjunction [] : post)));
  });
check_formula showsl_atom logic_checker negate_atom (Base h) phi =
  let {
    psi = remove_Atom negate_atom (simplify phi);
  } in bindb (check (is_neg_atom_clause psi)
               (showsl_literal "base hint given to " .
                 showsl_formula showsl_atom psi))
         (\ _ ->
           catch_errora (logic_checker h psi)
             (\ x ->
               Inl (((showsl_literal "problem in checking " .
                       showsl_formula showsl_atom phi) .
                      showsl_literal "\n") .
                     x)));
check_formula showsl_atom logic_checker negate_atom Default phi =
  check_valid_formula showsl_atom logic_checker negate_atom phi;

check_formula_lex ::
  forall a b c d.
    (Eq a, Eq b, Showl b, Eq c, Default d,
      Showl d) => (Term a (b, c) -> String -> String) ->
                    (d -> Formula (Term a (b, c)) ->
                            Sum (String -> String) ()) ->
                      (Term a (b, c) -> Formula (Term a (b, c))) ->
                        [Hint d] ->
                          Formula (Term a (b, c)) ->
                            [Formula (Term a (b, c))] ->
                              Sum (String -> String) ();
check_formula_lex showsl_atom logic_checker negate_atom hints phi phi_s =
  (if is_conj_shape hints phi
    then (case hints of {
           [hint1, hint2] ->
             (case phi of {
               Conjunction [phi_1, phi_2] ->
                 bindb (check_formula showsl_atom logic_checker negate_atom
                         hint1 (Disjunction (phi_1 : phi_s)))
                   (\ _ ->
                     check_formula showsl_atom logic_checker negate_atom hint2
                       (Disjunction (phi_2 : phi_s)));
             });
         })
    else (if is_disj_shape hints phi
           then (case hints of {
                  hint1 : hints2 ->
                    (case phi of {
                      Disjunction
                        [Conjunction [phi_1, phi_2], Conjunction [phi_3, phi_4]]
                        -> (case hints2 of {
                             [] -> bindb (check_formula showsl_atom
   logic_checker negate_atom hint1 (Disjunction (phi_3 : phi_s)))
                                     (\ _ ->
                                       check_formula_lex showsl_atom
 logic_checker negate_atom hints2 phi_4 phi_s);
                             [hint2] ->
                               bindb (check_formula showsl_atom logic_checker
                                       negate_atom hint1
                                       (Disjunction (phi_1 : phi_s)))
                                 (\ _ ->
                                   check_formula showsl_atom logic_checker
                                     negate_atom hint2
                                     (Disjunction (phi_2 : phi_s)));
                             _ : _ : _ ->
                               bindb (check_formula showsl_atom logic_checker
                                       negate_atom hint1
                                       (Disjunction (phi_3 : phi_s)))
                                 (\ _ ->
                                   check_formula_lex showsl_atom logic_checker
                                     negate_atom hints2 phi_4 phi_s);
                           });
                    });
                })
           else Inl (((showsl_literal "LexStrict hint application error: " .
                        showsl_hint (LexStrict hints)) .
                       showsl_literal "\napplied on ") .
                      showsl_formula showsl_atom phi)));

check_formula_dist ::
  forall a b c d.
    (Eq a, Eq b, Showl b, Eq c, Default d,
      Showl d) => (Term a (b, c) -> String -> String) ->
                    (d -> Formula (Term a (b, c)) ->
                            Sum (String -> String) ()) ->
                      (Term a (b, c) -> Formula (Term a (b, c))) ->
                        [Hint d] ->
                          [Formula (Term a (b, c))] ->
                            [Formula (Term a (b, c))] ->
                              [Formula (Term a (b, c))] ->
                                Sum (String -> String) ();
check_formula_dist showsl_atom logic_checker negate_atom [] uv uw (v : va) =
  Inl (showsl_literal "Length mismatch in Distribute hints");
check_formula_dist showsl_atom logic_checker negate_atom (v : va) uv uw [] =
  Inl (showsl_literal "Length mismatch in Distribute hints");
check_formula_dist showsl_atom logic_checker negate_atom (h : hs) pre post
  (phi : phi_s) =
  bindb (check_formula showsl_atom logic_checker negate_atom h
          (Disjunction (pre ++ phi : post)))
    (\ _ ->
      check_formula_dist showsl_atom logic_checker negate_atom hs pre post
        phi_s);
check_formula_dist showsl_atom logic_checker negate_atom [] pre post [] =
  Inr ();

check_formula_lex_weak ::
  forall a b c d.
    (Eq a, Eq b, Showl b, Eq c, Default d,
      Showl d) => (Term a (b, c) -> String -> String) ->
                    (d -> Formula (Term a (b, c)) ->
                            Sum (String -> String) ()) ->
                      (Term a (b, c) -> Formula (Term a (b, c))) ->
                        [Hint d] ->
                          Formula (Term a (b, c)) ->
                            [Formula (Term a (b, c))] ->
                              Sum (String -> String) ();
check_formula_lex_weak showsl_atom logic_checker negate_atom (hint : hints) phi
  phi_s =
  (if is_or_and_shape phi
    then (case phi of {
           Disjunction [_, Conjunction [phi_2, phi_3]] ->
             bindb (check_formula showsl_atom logic_checker negate_atom hint
                     (Disjunction (phi_2 : phi_s)))
               (\ _ ->
                 check_formula_lex_weak showsl_atom logic_checker negate_atom
                   hints phi_3 phi_s);
         })
    else (case hints of {
           [] -> check_formula showsl_atom logic_checker negate_atom hint
                   (Disjunction (phi : phi_s));
           _ : _ -> Inl (showsl_literal "LexWeak hint application error");
         }));
check_formula_lex_weak showsl_atom logic_checker negate_atom [] phi phi_s =
  check (trivial_formula phi)
    (showsl_literal "LexWeak base case error: " .
      showsl_formula showsl_atom phi);

ea :: forall a b.
        (Eq a, Showl a,
          Showl b) => [((a, Nat), Term b Nat)] ->
                        (Nat -> b) -> a -> Nat -> Term b Nat;
ea alist default_fun =
  curry (fun_of_map_fun (map_of alist)
          (\ (_, n) -> Fun (default_fun n) (map Var (upt zero_nat n))));

iA_exp_to_poly_constraint ::
  forall a. (Eq a, Linorder a) => Term Sig (a, Ty) -> Poly_constraint a;
iA_exp_to_poly_constraint (Fun LeF [a, b]) =
  Poly_Ge (poly_minus (iA_exp_to_poly b) (iA_exp_to_poly a));
iA_exp_to_poly_constraint (Fun EqF [a, b]) =
  Poly_Eq (poly_minus (iA_exp_to_poly b) (iA_exp_to_poly a));
iA_exp_to_poly_constraint (Fun LessF [a, b]) =
  Poly_Ge
    (poly_minus (poly_minus (iA_exp_to_poly b) (iA_exp_to_poly a)) one_poly);

showsl_poly_constraint ::
  forall a.
    (Eq a, Linorder a, Showl a) => Poly_constraint a -> String -> String;
showsl_poly_constraint (Poly_Ge p) = showsl_poly p . showsl_lit " >= 0";
showsl_poly_constraint (Poly_Eq p) = showsl_poly p . showsl_lit " = 0";

translate_atom :: forall a. Formula a -> a;
translate_atom (Atom e) = e;

translate_atoms :: forall a. [Formula a] -> [a];
translate_atoms = map translate_atom;

translate_conj :: forall a. Formula a -> [a];
translate_conj (Conjunction phi_s) = translate_atoms phi_s;

vars_poly_constraint_list ::
  forall a. (Eq a, Linorder a) => Poly_constraint a -> [a];
vars_poly_constraint_list (Poly_Ge p) = poly_vars_list p;
vars_poly_constraint_list (Poly_Eq p) = poly_vars_list p;

lp_monom :: Rat -> Nat -> Linear_poly;
lp_monom c x =
  LinearPoly (if equal_rat c zero_rat then fmempty else fmupd x c fmempty);

monom_list_linearity :: forall a. [(a, Nat)] -> Linearity a;
monom_list_linearity [] = Onea;
monom_list_linearity [(x, n)] =
  (if equal_nat n one_nat then Variable x else Non_Linear);
monom_list_linearity (v : vb : vc) = Non_Linear;

monom_linearity :: forall a. (Linorder a) => Monom a -> Linearity a;
monom_linearity xa = monom_list_linearity (rep_monom xa);

ipoly_to_linear_poly ::
  forall a.
    (Linorder a) => (a -> Nat) -> [(Monom a, Int)] -> Maybe (Linear_poly, Int);
ipoly_to_linear_poly rho [] = Just (zero_linear_poly, zero_int);
ipoly_to_linear_poly rho ((monomial, c) : rest) =
  bind (ipoly_to_linear_poly rho rest)
    (\ (p, d) ->
      (case monom_linearity monomial of {
        Non_Linear -> Nothing;
        Onea -> Just (p, plus_int c d);
        Variable x ->
          Just (plus_linear_poly (lp_monom (of_int c) (rho x)) p, d);
      }));

to_linear_constraints ::
  forall a. (Linorder a) => (a -> Nat) -> Poly_constraint a -> [Constraint];
to_linear_constraints rho (Poly_Ge p) =
  (case ipoly_to_linear_poly rho p of {
    Nothing -> [];
    Just (q, c) -> [GEQ q (of_int (uminus_int c))];
  });
to_linear_constraints rho (Poly_Eq p) =
  (case ipoly_to_linear_poly rho p of {
    Nothing -> [];
    Just (q, c) -> [EQa q (of_int (uminus_int c))];
  });

lec_poly :: forall a. Le_constraint a -> Linear_poly;
lec_poly (Le_Constraint x1 x2 x3) = x2;

constraint_to_le_constraint :: Constraint -> [Le_constraint Rat];
constraint_to_le_constraint (LEQ l x) = [Le_Constraint Leq_Rel l x];
constraint_to_le_constraint (GEQ l x) =
  [Le_Constraint Leq_Rel (uminus_linear_poly l) (uminus_rat x)];
constraint_to_le_constraint (LTa l x) = [Le_Constraint Lt_Rel l x];
constraint_to_le_constraint (GTa l x) =
  [Le_Constraint Lt_Rel (uminus_linear_poly l) (uminus_rat x)];
constraint_to_le_constraint (EQa l x) =
  [Le_Constraint Leq_Rel l x,
    Le_Constraint Leq_Rel (uminus_linear_poly l) (uminus_rat x)];
constraint_to_le_constraint (LEQPP l0 l1) =
  [Le_Constraint Leq_Rel (minus_linear_poly l0 l1) zero_rat];
constraint_to_le_constraint (GEQPP l0 l1) =
  [Le_Constraint Leq_Rel (minus_linear_poly l1 l0) zero_rat];
constraint_to_le_constraint (LTPP l0 l1) =
  [Le_Constraint Lt_Rel (minus_linear_poly l0 l1) zero_rat];
constraint_to_le_constraint (GTPP l0 l1) =
  [Le_Constraint Lt_Rel (minus_linear_poly l1 l0) zero_rat];
constraint_to_le_constraint (EQPP l0 l1) =
  [Le_Constraint Leq_Rel (minus_linear_poly l0 l1) zero_rat,
    Le_Constraint Leq_Rel (minus_linear_poly l1 l0) zero_rat];

normalizea :: [Constraint] -> [Le_constraint Rat];
normalizea cs = concatMap constraint_to_le_constraint cs;

vars_of_constraints :: [Constraint] -> [Nat];
vars_of_constraints cs =
  remdups (concatMap (vars_list . lec_poly) (normalizea cs));

vars :: Linear_poly -> Set Nat;
vars lp = fset (fmdom (linear_poly_map lp));

max_coeff :: Le_constraint Rat -> Rat;
max_coeff (Le_Constraint uu l c) =
  maxa (sup_set (inserta (abs_rat c) (set_empty (of_phantom set_impl_rat)))
         (image (\ x -> abs_rat (coeffa l x)) (vars l)));

max_coeff_constraints :: [Le_constraint Rat] -> Rat;
max_coeff_constraints cs = maxa (set (zero_rat : map max_coeff cs));

fold_atLeastAtMost_nat :: forall a. (Nat -> a -> a) -> Nat -> Nat -> a -> a;
fold_atLeastAtMost_nat f a b acc =
  (if less_nat b a then acc
    else fold_atLeastAtMost_nat f (plus_nat a one_nat) b (f a acc));

fact :: forall a. (Semiring_char_0 a) => Nat -> a;
fact n =
  of_nat
    (fold_atLeastAtMost_nat times_nat (nat_of_integer (2 :: Integer)) n
      one_nat);

lcm_integer :: Integer -> Integer -> Integer;
lcm_integer a b =
  divide_integer (Prelude.abs a * Prelude.abs b) (Prelude.gcd a b);

lcm_int :: Int -> Int -> Int;
lcm_int (Int_of_integer x) (Int_of_integer y) =
  Int_of_integer (lcm_integer x y);

common_denominator :: Le_constraint Rat -> Int;
common_denominator (Le_Constraint uu l c) =
  let {
    coeffs_list = map (coeffa l) (vars_list l);
    denominators = map (snd . quotient_of) (c : coeffs_list);
  } in fold lcm_int denominators one_int;

mul_constraint :: Rat -> Le_constraint Rat -> Le_constraint Rat;
mul_constraint x (Le_Constraint r l c) =
  Le_Constraint r (scaleRat_linear_poly x l) (times_rat x c);

constraint_to_ints :: Le_constraint Rat -> Le_constraint Rat;
constraint_to_ints c = mul_constraint (of_int (common_denominator c)) c;

var_list :: [Constraint] -> [Nat];
var_list cs = let {
                lecs = concatMap constraint_to_le_constraint cs;
                polys = map lec_poly lecs;
              } in remdups (concatMap vars_list polys);

compute_bound_num_of_vars :: [Constraint] -> Int;
compute_bound_num_of_vars cs =
  let {
    le_cs = normalizea cs;
    le_csa = map constraint_to_ints le_cs;
    max_coeff = max_coeff_constraints le_csa;
    n = plus_nat one_nat (size_list (var_list cs));
  } in times_int (fact (plus_nat n one_nat))
         (binary_power (floor_rat max_coeff) n);

solution_simplex :: forall a. Simplex_state a -> Nat -> Rat;
solution_simplex (Simplex_State (cs, ((asi, (tv, ui)), s))) =
  map2fun (from_ns (tv (v s)) cs);

i_bounds_to_constraints ::
  forall a.
    [Nat] -> (Nat -> (a, Int)) -> (Nat -> (a, Int)) -> [(a, Constraint)];
i_bounds_to_constraints is lb ub =
  map (\ x -> (fst (lb x), GEQ (vara x) (of_int (snd (lb x))))) is ++
    map (\ x -> (fst (ub x), LEQ (vara x) (of_int (snd (ub x))))) is;

atom_to_qdnsconstr :: Atom Rat -> Ns_constraint QDelta;
atom_to_qdnsconstr atm =
  (case atm of {
    Leq x qdcnst -> LEQ_ns (vara x) (QDelta qdcnst zero_rat);
    Geq x qdcnst -> GEQ_ns (vara x) (QDelta qdcnst zero_rat);
  });

atom_to_qdatom :: Atom Rat -> Atom QDelta;
atom_to_qdatom atm = (case atm of {
                       Leq vr c -> Leq vr (QDelta c zero_rat);
                       Geq vr c -> Geq vr (QDelta c zero_rat);
                     });

update_iatom_in_state ::
  Simplex_state Nat -> (Nat, Atom Rat) -> Simplex_state Nat;
update_iatom_in_state s iatm =
  (case s of {
    Simplex_State (cs, ((asi, (tv, ui)), l3s)) ->
      let {
        csa = list_update cs (fst iatm) (atom_to_qdnsconstr (snd iatm));
        asia = updateb (fst iatm) [(fst iatm, atom_to_qdatom (snd iatm))] asi;
      } in Simplex_State (csa, ((asia, (tv, ui)), l3s));
  });

list_map_to_fun ::
  forall a b. (Ccompare a, Eq a) => Mapping a [(a, b)] -> a -> [(a, b)];
list_map_to_fun m i = (case lookupb m i of {
                        Nothing -> [];
                        Just ias -> ias;
                      });

u_c :: forall a b. State a b -> Maybe [a];
u_c (State x1 x2 x3 x4 x5 x6) = x6;

uBI_upd ::
  forall a b.
    (Linorder b) => Direction a b ->
                      (Mapping Nat (a, b) -> Mapping Nat (a, b)) ->
                        State a b -> State a b;
uBI_upd (Direction x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11) = x8;

assert_bound_codea ::
  forall a b.
    (Eq a, Eq b,
      Lrv b) => Direction a b -> a -> Nat -> b -> State a b -> State a b;
assert_bound_codea dir i x c s =
  (if geub (lt dir) c (ub dir s x) then s
    else let {
           sa = update_B_I (uBI_upd dir) i x c s;
         } in (if ltlb (lt dir) c (lb dir s x) then set_unsat [i, li dir s x] sa
                else (if not (member x (lvars (t sa))) &&
                           lt dir c (map2fun (v s) x)
                       then update_code x c sa else sa)));

assert_bound_code ::
  forall a b. (Eq a, Eq b, Lrv b) => (a, Atom b) -> State a b -> State a b;
assert_bound_code (i, Leq x c) s = assert_bound_codea positive i x c s;
assert_bound_code (i, Geq x c) s = assert_bound_codea negative i x c s;

assert_s ::
  forall a b.
    (Eq a, Eq b, Lrv b) => (a, Atom b) -> State a b -> Sum [a] (State a b);
assert_s a s = let {
                 sa = assert_bound_code a s;
               } in (if u sa then Inl (the (u_c sa)) else Inr sa);

assert_all_s ::
  forall a b.
    (Eq a, Eq b, Lrv b) => [(a, Atom b)] -> State a b -> Sum [a] (State a b);
assert_all_s [] s = Inr s;
assert_all_s (a : asa) s = (case assert_s a s of {
                             Inl aa -> Inl aa;
                             Inr aa -> assert_all_s asa aa;
                           });

assert_simplex ::
  forall a.
    (Ccompare a, Eq a) => a -> Simplex_state a -> Sum [a] (Simplex_state a);
assert_simplex i (Simplex_State (cs, ((asi, (tv, ui)), s))) =
  (if membera ui i then Inl [i]
    else (case assert_all_s (list_map_to_fun asi i) s of {
           Inl a -> Inl a;
           Inr sa -> Inr (Simplex_State (cs, ((asi, (tv, ui)), sa)));
         }));

assert_all_simplex ::
  forall a.
    (Ccompare a, Eq a) => [a] -> Simplex_state a -> Sum [a] (Simplex_state a);
assert_all_simplex [] s = Inr s;
assert_all_simplex (ja : j) s = (case assert_simplex ja s of {
                                  Inl a -> Inl a;
                                  Inr a -> assert_all_simplex j a;
                                });

del_atom_from_state ::
  Simplex_state Nat -> (Nat, Atom Rat) -> Simplex_state Nat;
del_atom_from_state s iatm =
  (case s of {
    Simplex_State (l1, (l2, State t bl bu v c uc)) ->
      let {
        bua = deletea (atom_var (snd iatm)) bu;
        bla = deletea (atom_var (snd iatm)) bl;
      } in Simplex_State (l1, (l2, State t bla bua v c uc));
  });

sum_to_option :: forall a b. Sum a b -> Maybe b;
sum_to_option (Inr x) = Just x;
sum_to_option (Inl uu) = Nothing;

bnb_update_state ::
  [(Nat, Constraint)] ->
    [Nat] ->
      (Nat -> (Nat, Int)) ->
        (Nat -> (Nat, Int)) ->
          Simplex_state Nat -> (Nat, Atom Rat) -> Maybe (Simplex_state Nat);
bnb_update_state cs is lb ub s iatm =
  let {
    idx_list = map fst (i_bounds_to_constraints is lb ub ++ cs);
  } in (case assert_all_simplex (remove1 (fst iatm) idx_list)
               (del_atom_from_state s iatm)
         of {
         Inl _ -> Nothing;
         Inr sa ->
           sum_to_option
             (assert_simplex (fst iatm) (update_iatom_in_state sa iatm));
       });

check_sa :: forall a b. (Eq a, Eq b, Lrv b) => State a b -> Sum [a] (State a b);
check_sa s = let {
               sa = check_code s;
             } in (if u sa then Inl (the (u_c sa)) else Inr sa);

check_simplex ::
  forall a. (Eq a) => Simplex_state a -> Sum [a] (Simplex_state a);
check_simplex (Simplex_State (cs, (asi_tv, s))) =
  (case check_sa s of {
    Inl a -> Inl a;
    Inr sa -> Inr (Simplex_State (cs, (asi_tv, sa)));
  });

is_int_rat :: Rat -> Bool;
is_int_rat x = equal_int (snd (quotient_of x)) one_int;

bnb_state_core_p ::
  [(Nat, Constraint)] ->
    [Nat] ->
      Mapping Nat (Nat, Int) ->
        Mapping Nat (Nat, Int) ->
          Simplex_state Nat -> Maybe (Maybe (Nat -> Rat));
bnb_state_core_p cs is lb ub s =
  (case check_simplex s of {
    Inl _ -> Just Nothing;
    Inr sa ->
      let {
        v = solution_simplex sa;
      } in (case find (\ x -> not (is_int_rat (v x))) is of {
             Nothing -> Just (Just v);
             Just x ->
               let {
                 new_leq =
                   (fst (the (lookupb ub x)), Leq x (of_int (floor_rat (v x))));
                 new_geq =
                   (fst (the (lookupb lb x)), Geq x (of_int (ceiling (v x))));
                 uba = updateb x (fst (the (lookupb ub x)), floor_rat (v x)) ub;
                 lba = updateb x (fst (the (lookupb lb x)), ceiling (v x)) lb;
               } in bind (case bnb_update_state cs is (the . lookupb lb)
                                 (the . lookupb uba) sa new_leq
                           of {
                           Nothing -> Just Nothing;
                           Just a -> bnb_state_core_p cs is lb uba a;
                         })
                      (\ a ->
                        (case a of {
                          Nothing ->
                            (case bnb_update_state cs is (the . lookupb lba)
                                    (the . lookupb ub) sa new_geq
                              of {
                              Nothing -> Just Nothing;
                              Just aa -> bnb_state_core_p cs is lba ub aa;
                            });
                          Just va -> Just (Just va);
                        }));
           });
  });

create_map ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a) => [(a, b)] -> Mapping a [(a, b)];
create_map [] = emptyb;
create_map ((i, a) : xs) = let {
                             m = create_map xs;
                           } in (case lookupb m i of {
                                  Nothing -> updateb i [(i, a)] m;
                                  Just ias -> updateb i ((i, a) : ias) m;
                                });

init_simplex ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Mapping_impl a,
      Set_impl a) => [(a, Constraint)] -> Simplex_state a;
init_simplex cs =
  let {
    tons_cs = to_ns cs;
  } in Simplex_State
         (map snd tons_cs,
           (case preprocess tons_cs of {
             (t, (asa, (trans_v, ui))) ->
               ((create_map asa, (trans_v, remdups ui)), init_state t);
           }));

bnb_state_init ::
  [Constraint] ->
    [Nat] ->
      (Nat -> Int) ->
        (Nat -> Int) ->
          ([(Nat, Constraint)],
            (Mapping Nat (Nat, Int),
              (Mapping Nat (Nat, Int), Sum [Nat] (Simplex_state Nat))));
bnb_state_init cs is lb ub =
  let {
    lba = zip is (upt zero_nat (size_list is));
    uba = zip is (upt (size_list is) (plus_nat (size_list is) (size_list is)));
    lbb = map (\ (x, y) -> (x, (y, lb x))) lba;
    ubb = map (\ (x, y) -> (x, (y, ub x))) uba;
    lb_m = of_alist lbb;
    ub_m = of_alist ubb;
    csa = zip (upt (plus_nat (size_list is) (size_list is))
                (plus_nat (plus_nat (size_list is) (size_list is))
                  (size_list cs)))
            cs;
    bs = i_bounds_to_constraints is (the . lookupb lb_m) (the . lookupb ub_m) ++
           csa;
    s = assert_all_simplex (map fst bs) (init_simplex bs);
  } in (csa, (lb_m, (ub_m, s)));

bnb_incr :: [Constraint] -> [Nat] -> Maybe (Nat -> Rat);
bnb_incr cs is =
  let {
    bnd = compute_bound_num_of_vars cs;
  } in (case bnb_state_init cs is (\ _ -> uminus_int bnd) (\ _ -> bnd) of {
         (_, (_, (_, Inl _))) -> Nothing;
         (csa, (lb_m, (ub_m, Inr s))) ->
           the (bnb_state_core_p csa is lb_m ub_m s);
       });

int_of_rat :: Rat -> Int;
int_of_rat x = fst (quotient_of x);

bnb_incr_int :: [Constraint] -> Maybe (Nat -> Int);
bnb_incr_int cs =
  let {
    vs = vars_of_constraints cs;
  } in (case bnb_incr cs vs of {
         Nothing -> Nothing;
         Just v ->
           Just (\ x -> (if membera vs x then int_of_rat (v x) else zero_int));
       });

unsat_via_branch_and_bound ::
  forall a.
    (Ccompare a, Eq a, Mapping_impl a,
      Linorder a) => [Poly_constraint a] -> Bool;
unsat_via_branch_and_bound les =
  let {
    vs = remdups (concatMap vars_poly_constraint_list les);
    ren_map = of_alist (zip vs (upt zero_nat (size_list vs)));
    ren_fun = (\ v -> (case lookupb ren_map v of {
                        Nothing -> zero_nat;
                        Just n -> n;
                      }));
    cs = concatMap (to_linear_constraints ren_fun) les;
  } in (case bnb_incr_int cs of {
         Nothing -> True;
         Just _ -> False;
       });

poly_is_negative_constant ::
  forall a.
    (Eq a, Linorder a,
      Showl a) => [(Monom a, Int)] -> Sum (String -> String) ();
poly_is_negative_constant f =
  catch_errora
    (bindb
      (check (null (poly_vars_list f))
        (showsl_lit "polynomial is not a constant"))
      (\ _ ->
        check (less_int (eval_poly (\ _ -> zero_int) f) zero_int)
          (showsl_lit "polynomial is not a negative constant")))
    (\ x ->
      Inl (((showsl_lit "could not that " . showsl_poly f) .
             showsl_lit " is a negative constant\n") .
            x));

apply_hint ::
  forall a.
    (Eq a, Linorder a) => [Int] -> [Poly_constraint a] -> [(Monom a, Int)];
apply_hint (n : ns) (Poly_Ge a : asa) =
  poly_add (poly_mult (poly_const (abs_int n)) a) (apply_hint ns asa);
apply_hint (n : ns) (Poly_Eq a : asa) =
  poly_add (poly_mult (poly_const n) a) (apply_hint ns asa);
apply_hint [] (Poly_Ge a : asa) = poly_add a (apply_hint [] asa);
apply_hint [] (Poly_Eq a : asa) = poly_add a (apply_hint [] asa);
apply_hint uu [] = poly_const zero_int;

unsat_checker ::
  forall a.
    (Ccompare a, Eq a, Mapping_impl a, Linorder a,
      Showl a) => Hints -> [Poly_constraint a] -> Sum (String -> String) ();
unsat_checker hints cnjs =
  catch_errora
    (case hints of {
      Hints hintsa ->
        or_ok (poly_is_negative_constant (apply_hint (zero_int : hintsa) cnjs))
          (poly_is_negative_constant (apply_hint (one_int : hintsa) cnjs));
      Branch_and_Bound ->
        check (unsat_via_branch_and_bound cnjs)
          (showsl_lit
            "could not use simplex algorithm to prove unsatisfiability");
    })
    (\ x ->
      Inl (((((showsl_lit "The linear inequalities\n  " .
                showsl_sep showsl_poly_constraint (showsl_lit "\n  ") cnjs) .
               showsl_lit "\ncannot be proved unsatisfiable via hints\n  ") .
              showsl_hints hints) .
             showsl_literal "\n") .
            x));

check_clause ::
  forall a.
    (Ccompare a, Eq a, Mapping_impl a, Linorder a,
      Showl a) => Hints ->
                    Formula (Term Sig (a, Ty)) -> Sum (String -> String) ();
check_clause hints phi =
  let {
    es = map iA_exp_to_poly_constraint (translate_conj (form_not phi));
  } in catch_errora (unsat_checker hints es)
         (\ x ->
           Inl (((showsl_lit
                    "Could not prove unsatisfiability of IA conjunction\n" .
                   showsl_list_gen showsl_poly_constraint "False" "" " && " ""
                     es) .
                  showsl_literal "\n") .
                 x));

negatea :: forall a. Term Sig (a, Ty) -> Formula (Term Sig (a, Ty));
negatea (Fun LessF [a, b]) = Atom (Fun LeF [b, a]);
negatea (Fun LeF [a, b]) = Atom (Fun LessF [b, a]);
negatea (Fun EqF [a, b]) =
  Disjunction [Atom (Fun LessF [a, b]), Atom (Fun LessF [b, a])];
negatea (Var v) = Conjunction [];
negatea (Fun LeF []) = Conjunction [];
negatea (Fun LeF [v]) = Conjunction [];
negatea (Fun LeF (v : vc : ve : vf)) = Conjunction [];
negatea (Fun (SumF vb) va) = Conjunction [];
negatea (Fun (ConstF vb) va) = Conjunction [];
negatea (Fun (ProdF vb) va) = Conjunction [];
negatea (Fun EqF []) = Conjunction [];
negatea (Fun EqF [v]) = Conjunction [];
negatea (Fun EqF (v : vc : ve : vf)) = Conjunction [];
negatea (Fun v []) = Conjunction [];
negatea (Fun v [vb]) = Conjunction [];
negatea (Fun v (vb : vd : vf : vg)) = Conjunction [];

check_less_eq_term ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b, Linorder b,
      Showl b) => [((a, Nat), Term Siga Nat)] ->
                    Hint Hints ->
                      Term a b -> Term a b -> Sum (String -> String) ();
check_less_eq_term alist h s t =
  check_formula showsl_IA_exp check_clause negatea h
    (le_via_IA
      (evala
        (\ f ss ->
          subst_apply_term
            (ea (simplified_alist alist) (\ _ -> MaxF) f (size_list ss))
            (nth ss))
        s Var)
      (evala
        (\ f ss ->
          subst_apply_term
            (ea (simplified_alist alist) (\ _ -> MaxF) f (size_list ss))
            (nth ss))
        t Var));

less_via_IA ::
  forall a. Term Siga a -> Term Siga a -> Formula (Term Sig (a, Ty));
less_via_IA s t =
  form_or
    (form_not
      (Conjunction
        (map (\ x -> Atom (Fun LeF [Fun (ConstF zero_int) [], Var (x, IntT)]))
          (vars_term_list s ++ vars_term_list t))))
    (Conjunction
      (map (\ sa ->
             Disjunction (map (\ ta -> Atom (Fun LessF [sa, ta])) (to_IA t)))
        (to_IA s)));

check_less_term ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b, Linorder b,
      Showl b) => [((a, Nat), Term Siga Nat)] ->
                    Hint Hints ->
                      Term a b -> Term a b -> Sum (String -> String) ();
check_less_term alist h s t =
  check_formula showsl_IA_exp check_clause negatea h
    (less_via_IA
      (evala
        (\ f ss ->
          subst_apply_term
            (ea (simplified_alist alist) (\ _ -> MaxF) f (size_list ss))
            (nth ss))
        s Var)
      (evala
        (\ f ss ->
          subst_apply_term
            (ea (simplified_alist alist) (\ _ -> MaxF) f (size_list ss))
            (nth ss))
        t Var));

showsl_encoding ::
  forall a b.
    (Showl a, Showl b) => [((a, Nat), Term b Nat)] -> String -> String;
showsl_encoding alist =
  showsl_sep
    (\ (a, b) ->
      (case a of {
        (f, n) ->
          (\ e ->
            (showsl f .
              showsl_list_gen (\ i -> showsl_lit "x" . showsl_nat i) " = " "("
                "," ") = " (upt zero_nat n)) .
              showsl_term showsl (\ i -> showsl_lit "x" . showsl_nat i) e);
      })
        b)
    (showsl_literal "\n") alist;

check_encoding ::
  forall a b.
    (Showl a, Compare b, Eq b,
      Showl b) => [((a, Nat), Term b Nat)] -> Sum (String -> String) ();
check_encoding alist =
  catch_errora
    (forallM
      (\ (a, b) ->
        (case a of {
          (f, n) ->
            (\ t ->
              check (subset (vars_term t) (set (upt zero_nat n)))
                ((((showsl_lit "interpretation of " . showsl f) .
                    showsl_lit " arity ") .
                   showsl_nat n) .
                  showsl_lit " has extra parameter"));
        })
          b)
      alist)
    (\ x -> Inl (snd x));

constant_positions :: forall a b. (a -> Nat -> Term b Nat) -> a -> Nat -> [Nat];
constant_positions e f n =
  filter (\ i -> not (contains_var_term i (e f n))) (upt zero_nat n);

create_max_poly_redtriple ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b, Linorder b,
      Showl b) => [((a, Nat), Term Siga Nat)] -> Redtriple_ext a b ();
create_max_poly_redtriple alist =
  Redtriple_ext (check_encoding (simplified_alist alist))
    (\ (s, t) -> check_less_term alist default_hint t s)
    (\ (s, t) -> check_less_eq_term alist default_hint t s)
    (\ (s, t) -> check_less_eq_term alist default_hint t s)
    (\ (f, n) ->
      minus_set (set (upt zero_nat n))
        (set (constant_positions (ea (simplified_alist alist) (\ _ -> MaxF)) f
               n)))
    empty_af
    (\ _ -> Inl (showsl_lit "monotonicity of max-poly is not yet supported"))
    ((showsl_lit "max-polynomial interpretations:" . showsl_literal "\n") .
      showsl_encoding (simplified_alist alist))
    (Just (map fst (simplified_alist alist))) Nothing no_complexity_check ();

filter_prec_weight_ac_repr ::
  forall a.
    ((a, Nat) -> Af_entry) ->
      ([((a, Nat), (Nat, (Nat, Bool)))], Nat) ->
        ([((Filtered a, Nat), (Nat, (Nat, Bool)))], Nat);
filter_prec_weight_ac_repr pi (prw, w0) =
  let {
    fprw = filter (\ (fn, _) -> (case pi fn of {
                                  Collapse _ -> False;
                                  AFList _ -> True;
                                }))
             prw;
    mprw =
      map (\ (a, b) ->
            (case a of {
              (f, n) ->
                (\ aa -> ((FPair f n, (case pi (f, n) of {
Collapse _ -> zero_nat;
AFList ab -> size_list ab;
                                      })),
                           aa));
            })
              b)
        fprw;
  } in (mprw, w0);

filter_prec_weight_repr ::
  forall a.
    ((a, Nat) -> Af_entry) ->
      ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
        ([((Filtered a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat);
filter_prec_weight_repr pi (prw, w0) =
  let {
    fprw = filter (\ (fn, _) -> (case pi fn of {
                                  Collapse _ -> False;
                                  AFList _ -> True;
                                }))
             prw;
    mprw =
      map (\ (a, b) ->
            (case a of {
              (f, n) ->
                (\ aa -> ((FPair f n, (case pi (f, n) of {
Collapse _ -> zero_nat;
AFList ab -> size_list ab;
                                      })),
                           aa));
            })
              b)
        fprw;
  } in (mprw, w0);

prec_repr_to_status ::
  forall a.
    (Compare_order a) => [((a, Nat), (Nat, Order_tag))] ->
                           (Filtered a, Nat) -> Order_tag;
prec_repr_to_status prs = let {
                            m = ceta_map_of prs;
                          } in (\ (FPair f a, _) -> (case m (f, a) of {
              Nothing -> Lex;
              Just aa -> snd aa;
            }));

prec_repr_to_pr ::
  forall a.
    (Compare_order a) => [((a, Nat), (Nat, Order_tag))] ->
                           (Filtered a, Nat) -> Nat;
prec_repr_to_pr prs = let {
                        m = ceta_map_of prs;
                      } in (\ (FPair f a, _) -> (case m (f, a) of {
          Nothing -> zero_nat;
          Just aa -> fst aa;
        }));

plus_single_mono ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      Bool;
plus_single_mono
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = plus_single_mono;

check_complexity ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Nat -> Sum (String -> String) ();
check_complexity
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = check_complexity;

maxb ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      a -> a -> a;
maxb (Partial_object_ext carrier
       (Monoid_ext mult one
         (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = max;

poly_c_max_inter_bcoeff_strict ::
  forall a b c.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      [(c, Nat)] -> ((c, Nat) -> (a, [a])) -> a;
poly_c_max_inter_bcoeff_strict r f pi =
  foldr (maxb r) (concatMap (\ fn -> snd (pi fn)) f) (zero r);

geq ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      a -> a -> Bool;
geq (Partial_object_ext carrier
      (Monoid_ext mult one
        (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = geq;

poly_c_max_inter_bcoeff ::
  forall a b c.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      [(c, Nat)] -> ((c, Nat) -> (a, [a])) -> a;
poly_c_max_inter_bcoeff r f pi =
  foldr (maxb r)
    (concatMap (\ fn -> filter (\ b -> not (geq r (one r) b)) (snd (pi fn))) f)
    (zero r);

convert_lpoly_complexity ::
  forall a b c d.
    (Eq a) => Partial_object_ext a
                (Monoid_ext a
                  (Ring_ext a
                    (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
                ((c, Nat) -> (a, [a])) ->
                  Complexity_measure c d ->
                    Complexity_class -> Sum (String -> String) ();
convert_lpoly_complexity r pi cm (Comp_Poly deg) =
  let {
    f = (case cm of {
          Derivational_Complexity f -> f;
          Runtime_Complexity c _ -> c;
        });
    bc = poly_c_max_inter_bcoeff r f pi;
    bca = poly_c_max_inter_bcoeff_strict r f pi;
  } in bindb (check (less_nat zero_nat deg || bca == zero r)
               (showsl_literal
                 "constant complexity not fully supported for linear (poly/matrix)-interpretations"))
         (\ _ -> check_complexity r bc (minus_nat deg one_nat));

check_poly_mono_npsm ::
  forall a b c.
    (Eq a, Showl a, Eq c,
      Showl c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [(c, Nat)] ->
                      [((c, Nat), (a, [a]))] -> Sum (String -> String) ();
check_poly_mono_npsm r f pi =
  bindb (catch_errora
          (forallM
            (\ (a, b) ->
              (case a of {
                (fa, n) ->
                  (\ (c, cs) ->
                    catch_errora
                      (bindb
                        (check
                          (if equal_nat n (suc zero_nat) then c == zero r
                            else True)
                          ((showsl_literal "constant part " . showsl c) .
                            showsl_literal " must be 0\n"))
                        (\ _ ->
                          bindb (check (equal_nat n (size_list cs))
                                  (showsl_literal
                                    "the arity is not the same as the number of arguments\n"))
                            (\ _ ->
                              check (less_eq_nat n (suc zero_nat))
                                (showsl_literal
                                  "symbol has arity larger than 1\n"))))
                      (\ x ->
                        Inl (((((showsl_literal
                                   "problem with monotonicity due to interpretation of " .
                                  showsl fa) .
                                 showsl_literal "/") .
                                showsl_nat n) .
                               showsl_literal "\n") .
                              x)));
              })
                b)
            pi)
          (\ x -> Inl (snd x)))
    (\ _ ->
      catch_errora (check_subseteq f (map fst pi))
        (\ x ->
          Inl ((showsl_literal "unknown interpretation for " . showsl_prod x) .
                showsl_literal "\n")));

arcpos ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Bool;
arcpos
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = arcpos;

carrier :: forall a b. Partial_object_ext a b -> Set a;
carrier (Partial_object_ext carrier more) = carrier;

check_lpoly_coeffs ::
  forall a b c.
    (Ceq a, Ccompare a, Showl a,
      Showl c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [((c, Nat), (a, [a]))] -> Sum (String -> String) ();
check_lpoly_coeffs r i =
  catch_errora
    (forallM
      (\ (a, b) ->
        (case a of {
          (f, n) ->
            (\ (c, cs) ->
              catch_errora
                (bindb
                  (check (member c (carrier r))
                    ((showsl_literal "constant part " . showsl c) .
                      showsl_literal " is not well-formed\n"))
                  (\ _ ->
                    bindb (check (less_eq_nat (size_list cs) n)
                            (showsl_literal
                               "number of coefficients exceeds arity of symbol " .
                              showsl f))
                      (\ _ ->
                        bindb (check (arcpos r c || any (arcpos r) cs)
                                (showsl_literal
                                  "could not find positive entry which is required for arctic interpretations\n"))
                          (\ _ ->
                            catch_errora
                              (forallM
                                (\ aa ->
                                  check (geq r aa (zero r) &&
  member aa (carrier r))
                                    ((showsl_literal "coefficient " .
                                       showsl aa) .
                                      showsl_literal " is not allowed\n"))
                                cs)
                              (\ x -> Inl (snd x))))))
                (\ x ->
                  Inl (((((showsl_literal "problem with interpretation of " .
                            showsl f) .
                           showsl_literal "/") .
                          showsl_nat n) .
                         showsl_literal "\n") .
                        x)));
        })
          b)
      i)
    (\ x -> Inl (snd x));

description ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      String -> String;
description
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = description;

defaultb ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a;
defaultb
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = defaulta;

to_lpoly_inter ::
  forall a b c.
    (Compare_order c) => Partial_object_ext a
                           (Monoid_ext a
                             (Ring_ext a
                               (Ordered_semiring_ext a
                                 (Lpoly_order_semiring_ext a b)))) ->
                           [((c, Nat), (a, [a]))] -> (c, Nat) -> (a, [a]);
to_lpoly_inter r i =
  fun_of_map_fun (ceta_map_of i)
    (\ fn -> (defaultb r, replicate (snd fn) (one r)));

showl_pvars ::
  forall a b c.
    (Eq a, Showl a,
      Showl c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                    [(c, a)] -> [String];
showl_pvars r [] = [];
showl_pvars r ((x, c) : vas) =
  (if c == one r then id else showsl c) (showsl x "") : showl_pvars r vas;

showsl_lpoly ::
  forall a b c.
    (Eq a, Showl a,
      Showl c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                    L_poly c a -> String -> String;
showsl_lpoly r (LPoly c cs) =
  (case showl_pvars r cs of {
    [] -> showsl c;
    a : list ->
      (if c == zero r then id else showsl c . showsl_literal " + ") .
        showsl_list_gen showsl_literal "" "" " + " "" (a : list);
  });

add_var ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 c -> a -> [(c, a)] -> [(c, a)];
add_var r x a [] = [(x, a)];
add_var r x a ((y, b) : vas) =
  (if x == y then let {
                    s = add r a b;
                  } in (if s == zero r then vas else (x, s) : vas)
    else (y, b) : add_var r x a vas);

sum_pvars ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 [(c, a)] -> [(c, a)] -> [(c, a)];
sum_pvars r [] vbs = vbs;
sum_pvars r ((x, a) : vas) vbs =
  (if a == zero r then sum_pvars r vas vbs
    else sum_pvars r vas (add_var r x a vbs));

sum_lpolya ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 L_poly c a -> L_poly c a -> L_poly c a;
sum_lpolya r (LPoly a vas) (LPoly b vbs) =
  LPoly (add r a b) (sum_pvars r vas vbs);

mul_pvars ::
  forall a b c.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                a -> [(c, a)] -> [(c, a)];
mul_pvars r a [] = [];
mul_pvars r a ((x, b) : vas) = let {
                                 p = mult r a b;
                                 res = mul_pvars r a vas;
                               } in (if p == zero r then res else (x, p) : res);

mul_lpoly ::
  forall a b c.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                a -> L_poly c a -> L_poly c a;
mul_lpoly r a (LPoly b vas) = LPoly (mult r a b) (mul_pvars r a vas);

list_prod :: forall a b. Partial_object_ext a (Monoid_ext a b) -> [a] -> a;
list_prod r [] = one r;
list_prod r (x : xs) = mult r x (list_prod r xs);

wf_pvars ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Partial_object_ext a b -> [(c, a)] -> Bool;
wf_pvars r vas = less_eq_set (set (map snd vas)) (carrier r);

wf_lpoly ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Partial_object_ext a b -> L_poly c a -> Bool;
wf_lpoly r (LPoly a vas) = member a (carrier r) && wf_pvars r vas;

pleftI ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq d) => Partial_object_ext a
                 (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                 ((c, Nat) -> (a, [a])) -> Term c d -> L_poly d a;
pleftI r pi (Var x) = LPoly (zero r) [(x, one r)];
pleftI r pi (Fun f ts) =
  (case pi (f, size_list ts) of {
    (c, asa) ->
      (case sum_lpolya r (LPoly c [])
              (list_prod
                (Partial_object_ext (collect (wf_lpoly r))
                  (Monoid_ext (sum_lpolya r) (LPoly (zero r) []) ()))
                (map (\ at -> mul_lpoly r (fst at) (pleftI r pi (snd at)))
                  (zip asa ts)))
        of {
        LPoly d [] -> LPoly (maxb r (zero r) d) [];
        LPoly d (ab : lista) -> LPoly d (ab : lista);
      });
  });

create_lpoly_repr ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showl a, Compare_order b,
      Eq b,
      Showl b) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a ())))) ->
                    [((b, Nat), (a, [a]))] -> String -> String;
create_lpoly_repr c i =
  let {
    pi = to_lpoly_inter c i;
  } in ((showsl_literal "polynomial interpretation over " . description c) .
         showsl_literal "\n") .
         showsl_sep
           (\ (f, n) ->
             let {
               t = Fun f (map Var
                           (fresh_strings_list
                             [Char False False False True True True True False,
                               Char True True True True True False True False]
                             one_nat [] n));
             } in ((showsl_literal "Pol(" . showsl_terma t) .
                    showsl_literal ") = ") .
                    showsl_lpoly c (pleftI c pi t))
           (showsl_literal "\n") (remdups (map fst i));

checkmono ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Bool;
checkmono
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound check_complexity description more)))))
  = checkmono;

check_poly_mono ::
  forall a b c.
    (Showl a,
      Showl c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [((c, Nat), (a, [a]))] -> Sum (String -> String) ();
check_poly_mono r =
  (\ xs ->
    catch_errora
      (forallM
        (\ (a, b) ->
          (case a of {
            (f, n) ->
              (\ (c, cs) ->
                catch_errora
                  (bindb
                    (check (geq r c (zero r))
                      ((((showsl_literal "constant part " . showsl c) .
                          showsl_literal " must be at least ") .
                         showsl (zero r)) .
                        showsl_literal "\n"))
                    (\ _ ->
                      bindb (check (less_eq_nat n (size_list cs))
                              (showsl_literal "the last argument is ignored\n"))
                        (\ _ ->
                          catch_errora
                            (forallM
                              (\ d ->
                                check (checkmono r d)
                                  ((showsl_literal "coefficient " . showsl d) .
                                    showsl_literal " is not allowed\n"))
                              cs)
                            (\ x -> Inl (snd x)))))
                  (\ x ->
                    Inl (((((showsl_literal
                               "problem with monotonicity due to interpretation of " .
                              showsl f) .
                             showsl_literal "/") .
                            showsl_nat n) .
                           showsl_literal "\n") .
                          x)));
          })
            b)
        xs)
      (\ x -> Inl (snd x)));

create_mono_af ::
  forall a b c.
    (Eq a,
      Compare_order c) => Partial_object_ext a
                            (Monoid_ext a
                              (Ring_ext a
                                (Ordered_semiring_ext a
                                  (Lpoly_order_semiring_ext a b)))) ->
                            [((c, Nat), (a, [a]))] -> (c, Nat) -> Set Nat;
create_mono_af r i =
  (if plus_single_mono r
    then fun_of_map_funa (ceta_map_of i) (\ (_, n) -> set (upt zero_nat n))
           (\ (c, coeffs) ->
             set (if geq r c (zero r)
                   then concatMap
                          (\ (ca, ia) ->
                            (if ca == one r || checkmono r ca then [ia]
                              else []))
                          (zip coeffs (upt zero_nat (size_list coeffs)))
                   else []))
    else empty_af);

lookup_rest :: forall a b. (Eq a) => a -> [(a, b)] -> Maybe (b, [(a, b)]);
lookup_rest x [] = Nothing;
lookup_rest x ((y, c) : ycs) =
  (if x == y then Just (c, ycs)
    else (case lookup_rest x ycs of {
           Nothing -> Nothing;
           Just (d, yccs) -> Just (d, (y, c) : yccs);
         }));

check_pvars ::
  forall a b c.
    (Showl a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 (a -> a -> Bool) -> [(c, a)] -> [(c, a)] -> Sum c ();
check_pvars r rel vas [] =
  catch_errora (forallM (\ va -> check (rel (snd va) (zero r)) (fst va)) vas)
    (\ x -> Inl (snd x));
check_pvars r rel vas ((x, b) : vbs) =
  let {
    a = (case lookup_rest x vas of {
          Nothing -> (zero r, vas);
          Just a -> (case a of {
                      (aa, ba) -> (aa, ba);
                    });
        });
  } in (case a of {
         (aa, vasa) ->
           bindb (check (rel aa b) x) (\ _ -> check_pvars r rel vasa vbs);
       });

check_lpoly_ns ::
  forall a b c.
    (Eq a, Showl a, Eq c,
      Showl c) => Partial_object_ext a
                    (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                    L_poly c a -> L_poly c a -> Sum (String -> String) ();
check_lpoly_ns r (LPoly a vas) (LPoly b vbs) =
  catch_errora
    (bindb
      (check (geq r a b)
        (showsl_literal "problem when comparing constant parts"))
      (\ _ ->
        catch_errora (check_pvars r (geq r) vas vbs)
          (\ x ->
            Inl (showsl_literal
                   "problem when comparing coefficients of variable " .
                  showsl x))))
    (\ x ->
      Inl (((((showsl_literal "problem when comparing " .
                showsl_lpoly r (LPoly a vas)) .
               showsl_literal " >= ") .
              showsl_lpoly r (LPoly b vbs)) .
             showsl_literal "\n") .
            x));

prightI ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq d) => Partial_object_ext a
                 (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                 ((c, Nat) -> (a, [a])) -> Term c d -> L_poly d a;
prightI r pi (Var x) = LPoly (zero r) [(x, one r)];
prightI r pi (Fun f ts) =
  (case pi (f, size_list ts) of {
    (c, asa) ->
      (case sum_lpolya r (LPoly c [])
              (list_prod
                (Partial_object_ext (collect (wf_lpoly r))
                  (Monoid_ext (sum_lpolya r) (LPoly (zero r) []) ()))
                (map (\ at -> mul_lpoly r (fst at) (prightI r pi (snd at)))
                  (zip asa ts)))
        of {
        LPoly d a -> LPoly (maxb r (zero r) d) a;
      });
  });

check_polo_ns ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showl a, Showl c, Eq d,
      Showl d) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    ((c, Nat) -> (a, [a])) ->
                      (Term c d, Term c d) -> Sum (String -> String) ();
check_polo_ns r pi (s, t) =
  let {
    left = pleftI r pi s;
    right = prightI r pi t;
  } in catch_errora (check_lpoly_ns r left right)
         (\ x ->
           Inl (((((showsl_literal "could not ensure " . showsl_terma s) .
                    showsl_literal " >= ") .
                   showsl_terma t) .
                  showsl_literal "\n") .
                 x));

gt :: forall a b.
        Partial_object_ext a
          (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
          a -> a -> Bool;
gt (Partial_object_ext carrier
     (Monoid_ext mult one
       (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = gt;

check_lpoly_s ::
  forall a b c.
    (Eq a, Showl a, Eq c,
      Showl c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    L_poly c a -> L_poly c a -> Sum (String -> String) ();
check_lpoly_s r (LPoly a vas) (LPoly b vbs) =
  catch_errora
    (bindb
      (check (gt r a b) (showsl_literal "problem when comparing constant part"))
      (\ _ ->
        catch_errora
          (check_pvars r (if plus_single_mono r then geq r else gt r) vas vbs)
          (\ x ->
            Inl (showsl_literal
                   "problem when comparing coefficients of variable " .
                  showsl x))))
    (\ x ->
      Inl (((((showsl_literal "problem when comparing " .
                showsl_lpoly r (LPoly a vas)) .
               showsl_literal " > ") .
              showsl_lpoly r (LPoly b vbs)) .
             showsl_literal "\n") .
            x));

check_polo_s ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showl a, Showl c, Eq d,
      Showl d) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    ((c, Nat) -> (a, [a])) ->
                      (Term c d, Term c d) -> Sum (String -> String) ();
check_polo_s r pi (s, t) =
  let {
    left = pleftI r pi s;
    right = prightI r pi t;
  } in catch_errora (check_lpoly_s r left right)
         (\ x ->
           Inl (((((showsl_literal "could not ensure " . showsl_terma s) .
                    showsl_literal " > ") .
                   showsl_terma t) .
                  showsl_literal "\n") .
                 x));

create_af ::
  forall a b c.
    (Eq a,
      Compare_order c) => Partial_object_ext a
                            (Monoid_ext a
                              (Ring_ext a
                                (Ordered_semiring_ext a
                                  (Lpoly_order_semiring_ext a b)))) ->
                            [((c, Nat), (a, [a]))] -> (c, Nat) -> Set Nat;
create_af r i =
  fun_of_map_funa (ceta_map_of i) (\ (_, n) -> set (upt zero_nat n))
    (\ (_, coeffs) ->
      set (concatMap (\ (c, ia) -> (if not (c == zero r) then [ia] else []))
            (zip coeffs (upt zero_nat (size_list coeffs)))));

create_poly_redtriple ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showl a, Compare_order b,
      Eq b, Showl b, Eq c,
      Showl c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a ())))) ->
                    Sum (String -> String) () ->
                      [((b, Nat), (a, [a]))] -> Redtriple_ext b c ();
create_poly_redtriple c cI i =
  let {
    pi = to_lpoly_inter c i;
    ns = check_polo_ns c pi;
  } in Redtriple_ext (bindb cI (\ _ -> check_lpoly_coeffs c i))
         (check_polo_s c pi) ns ns (create_af c i) (create_mono_af c i)
         (\ s_ns_nst ->
           (if plus_single_mono c then check_poly_mono c i
             else check_poly_mono_npsm c (funas_trs_list s_ns_nst) i))
         (create_lpoly_repr c i) (Just (map fst i))
         (if plus_single_mono c then Just (map fst i) else Nothing)
         (if plus_single_mono c then convert_lpoly_complexity c pi
           else no_complexity_check)
         ();

weak_gt_arctic_delta ::
  forall a. (Floor_ceiling a) => Arctic_delta a -> Arctic_delta a -> Bool;
weak_gt_arctic_delta uu MinInfty_delta = True;
weak_gt_arctic_delta MinInfty_delta (Num_arc_delta uv) = False;
weak_gt_arctic_delta (Num_arc_delta x) (Num_arc_delta y) = less y x;

check_mono_afs ::
  forall a. (Ceq a, Ccompare a) => Afs a -> Sum (String -> String) ();
check_mono_afs pi =
  check (mono_afs pi) (showsl_literal "argument filter is not monotone");

afs_with_af ::
  forall a.
    (Compare_order a) => Afs a -> ((a, Nat) -> Set Nat) -> (a, Nat) -> Set Nat;
afs_with_af pia pi fn =
  (case afsa pia fn of {
    Collapse j -> inserta j (set_empty (of_phantom set_impl_nat));
    AFList ids -> (if ids == upt zero_nat (snd fn) then pi fn else set ids);
  });

showsl_afs :: forall a. (Showl a) => [((a, Nat), Af_entry)] -> String -> String;
showsl_afs af =
  foldr (\ (a, b) ->
          (case a of {
            (f, n) ->
              (\ e ->
                (((((showsl_literal "pi(" . showsl f) . showsl_literal "/") .
                    showsl_nat n) .
                   showsl_literal ") = ") .
                  (case e of {
                    Collapse i -> showsl_nat (suc i);
                    AFList ids -> showsl_list_nat (map suc ids);
                  })) .
                  showsl_literal "\n");
          })
            b)
    af;

filtered_redtriple_af ::
  forall a b.
    (Ceq a, Ccompare a, Compare_order a, Set_impl a, Showl a,
      Showl b) => [((a, Nat), Af_entry)] ->
                    Redtriple_ext a b () -> Redtriple_ext a b ();
filtered_redtriple_af pi rp =
  let {
    afso = afs_of pi;
    afs = the afso;
    afa = afs_with_af afs (af rp);
  } in Redtriple_ext
         (bindb
           (check (not (is_none afso))
             (showsl_literal "invalid positions in argument filter"))
           (\ _ -> valid rp))
         (af_check (showsl_literal ">") afs (s rp))
         (af_check (showsl_literal ">=") afs (ns rp))
         (af_check (showsl_literal ">=") afs (nst rp)) afa empty_af
         (\ cs ->
           bindb (check_mono_afs afs) (\ _ -> mono rp (map (af_rule afs) cs)))
         (((showsl_literal "Argument Filter:\n" . showsl_afs pi) .
            showsl_literal "\n") .
           desca rp)
         (map_option (\ a -> map fst pi ++ a) (not_wst rp)) Nothing
         no_complexity_check ();

check_poly_strict_mono_discrete ::
  forall a b.
    (Eq a, Poly_carrier a, Eq b,
      Linorder b) => (a -> a -> Bool) -> [(Monom b, a)] -> b -> Bool;
check_poly_strict_mono_discrete gt p v =
  check_poly_gt gt
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p)
    p;

univariate_power_list :: forall a. (Eq a) => a -> [(a, Nat)] -> Maybe Nat;
univariate_power_list x [(y, n)] = (if x == y then Just n else Nothing);
univariate_power_list uu [] = Nothing;
univariate_power_list uu (v : vb : vc) = Nothing;

univariate_power :: forall a. (Eq a, Linorder a) => a -> Monom a -> Maybe Nat;
univariate_power x xc = univariate_power_list x (rep_monom xc);

check_monom_strict_mono ::
  forall a. (Eq a, Linorder a) => Bool -> Monom a -> a -> Bool;
check_monom_strict_mono pm m v = (case univariate_power v m of {
                                   Nothing -> False;
                                   Just p -> pm || equal_nat p one_nat;
                                 });

check_poly_strict_mono ::
  forall a b.
    (Eq a, Linorder a, Poly_carrier b) => Bool -> [(Monom a, b)] -> a -> Bool;
check_poly_strict_mono pm p v =
  any (\ (m, c) -> less_eq onea c && check_monom_strict_mono pm m v) p;

check_poly_strict_mono_smart ::
  forall a b.
    (Eq a, Poly_carrier a, Eq b,
      Linorder b) => Bool ->
                       Bool -> (a -> a -> Bool) -> [(Monom b, a)] -> b -> Bool;
check_poly_strict_mono_smart discrete pm gt p v =
  (if discrete then check_poly_strict_mono_discrete gt p v
    else check_poly_strict_mono pm p v);

check_poly_weak_mono_all ::
  forall a b. (Ordered_semiring_0a b) => [(Monom a, b)] -> Bool;
check_poly_weak_mono_all p = all (\ (_, a) -> less_eq zerob a) p;

check_poly_weak_mono_and_pos ::
  forall a b.
    (Eq a, Linorder a, Eq b, Poly_carrier b) => Bool -> [(Monom a, b)] -> Bool;
check_poly_weak_mono_and_pos discrete p =
  (if discrete
    then all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&
           less_eq zerob (eval_poly (\ _ -> zerob) p)
    else check_poly_weak_mono_all p);

poly_inter_to_mono_af ::
  forall a b.
    (Eq a, Poly_carrier a,
      Compare_order b) => Bool ->
                            Bool ->
                              (a -> a -> Bool) ->
                                [((b, Nat), [(Monom Nat, a)])] ->
                                  (b, Nat) -> Set Nat;
poly_inter_to_mono_af discrete power_mono gt i =
  fun_of_map_fun
    (ceta_map_of
      (map (\ (a, b) ->
             (case a of {
               (f, n) ->
                 (\ e ->
                   ((f, n),
                     set (filter
                           (\ ia ->
                             check_poly_weak_mono_and_pos discrete e &&
                               check_poly_strict_mono_smart discrete power_mono
                                 gt e ia)
                           (upt zero_nat n))));
             })
               b)
        i))
    (\ fn -> set (upt zero_nat (snd fn)));

check_poly_inter_list ::
  forall a b.
    (Eq a, Eq b,
      Poly_carrier b) => Bool ->
                           [((a, Nat), [(Monom Nat, b)])] ->
                             Sum (Sum (String -> String) (a, [(Monom Nat, b)]))
                               ();
check_poly_inter_list discrete i =
  bindb (check (distinct (map fst i))
          (Inl (showsl_literal "some symbol has two interpretations")))
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM
            (\ x ->
              (if (case x of {
                    (_, a) -> check_poly_weak_mono_and_pos discrete a;
                  })
                then Inr () else Inl x))
            i)
          (\ x -> Inl (snd x)))
        (\ x -> Inl (case x of {
                      (a, b) -> (case a of {
                                  (f, _) -> (\ p -> Inr (f, p));
                                })
                                  b;
                    })));

less_eq_complexity_class :: Complexity_class -> Complexity_class -> Bool;
less_eq_complexity_class x y = less_eq_nat (degree x) (degree y);

strongly_linear ::
  forall a. (Poly_carrier a) => Nat -> [(Monom Nat, a)] -> a -> Bool;
strongly_linear x p v =
  (if equal_nat x zero_nat then check_ge_v v p
    else let {
           a = poly_split (var_monom (minus_nat x one_nat)) p;
         } in (case a of {
                (aa, pa) ->
                  less_eq aa onea && strongly_linear (minus_nat x one_nat) pa v;
              }));

sl_complexity_sig_check ::
  forall a b.
    (Poly_carrier b) => ((a, Nat) -> [(Monom Nat, b)]) ->
                          b -> [(a, Nat)] -> Sum (a, Nat) ();
sl_complexity_sig_check i v f =
  catch_errora
    (forallM (\ (fa, n) -> check (strongly_linear n (i (fa, n)) v) (fa, n)) f)
    (\ x -> Inl (snd x));

sl_complexity_check ::
  forall a b.
    (Poly_carrier a,
      Showl b) => a -> ((b, Nat) -> [(Monom Nat, a)]) ->
                         [(b, Nat)] -> Sum (String -> String) ();
sl_complexity_check v i f =
  let {
    w = max_v v i f;
  } in catch_errora (sl_complexity_sig_check i w f)
         (\ x ->
           Inl (case x of {
                 (fa, _) ->
                   (showsl_literal "symbol " . showsl fa) .
                     showsl_literal
                       " does not possess a strongly linear interpretation";
               }));

nl_complexity_check ::
  forall a b c.
    (Showl a,
      Poly_carrier b) => ((a, Nat) -> [(Monom Nat, b)]) ->
                           Complexity_measure a c ->
                             Complexity_class -> Sum (String -> String) ();
nl_complexity_check i (Derivational_Complexity f) cc =
  bindb (sl_complexity_check zerob i f)
    (\ _ ->
      check (less_eq_complexity_class (Comp_Poly one_nat) cc)
        (showsl_literal
          "cannot deduce constant complexity for derivational complexity"));
nl_complexity_check i (Runtime_Complexity c d) (Comp_Poly deg) =
  bindb (sl_complexity_check onea i c)
    (\ _ ->
      catch_errora
        (forallM
          (\ f ->
            check (less_eq_nat (poly_degree (i f)) deg)
              ((showsl_literal "degree of interpretation for " .
                 showsl_prod f) .
                showsl_literal " exceeds bound "))
          d)
        (\ x -> Inl (snd x)));

poly_inter_to_af ::
  forall a b.
    (Compare_order a) => [((a, Nat), [(Monom Nat, b)])] -> (a, Nat) -> Set Nat;
poly_inter_to_af i =
  fun_of_map_fun (ceta_map_of (map (\ (fn, e) -> (fn, poly_vars e)) i))
    (\ fn -> set (upt zero_nat (snd fn)));

create_nlpoly_redtriple ::
  forall a b c.
    (Eq a, Poly_carrier a, Showl a, Compare_order b, Eq b, Showl b, Eq c,
      Linorder c,
      Showl c) => Sum (String -> String) () ->
                    a -> (a -> a -> Bool) ->
                           Bool ->
                             Bool ->
                               [((b, Nat), [(Monom Nat, a)])] ->
                                 Redtriple_ext b c ();
create_nlpoly_redtriple cI def gt power_mono discrete i =
  let {
    j = poly_inter_list_to_inter def i;
    x = poly_subst
          (\ n ->
            poly_of
              (PVar ([Char False False False True True True True False,
                       Char True True True True True False True False] ++
                      shows_prec_nat zero_nat n [])));
  } in Redtriple_ext
         (bindb cI
           (\ _ ->
             catch_errora (check_poly_inter_list discrete i)
               (\ xa ->
                 Inl (case xa of {
                       Inl a -> id a;
                       Inr (f, p) ->
                         (((showsl_literal "interpretation " .
                             showsl_poly (x p)) .
                            showsl_literal " of ") .
                           showsl f) .
                           showsl_literal " invalid ";
                     }))))
         (check_s gt j) (check_ns j) (check_ns j) (poly_inter_to_af i)
         (poly_inter_to_mono_af discrete power_mono gt i)
         (\ _ ->
           catch_errora
             (catch_errora
               (forallM
                 (\ xa ->
                   (if (case xa of {
                         (a, b) ->
                           (case a of {
                             (_, n) ->
                               (\ p ->
                                 all_interval_nat
                                   (check_poly_strict_mono_smart discrete
                                     power_mono gt p)
                                   zero_nat n);
                           })
                             b;
                       })
                     then Inr () else Inl xa))
                 i)
               (\ xa -> Inl (snd xa)))
             (\ xa ->
               Inl (case xa of {
                     (a, b) ->
                       (case a of {
                         (f, _) ->
                           (\ p ->
                             ((showsl_literal
                                 "could not ensure monotonicty of " .
                                showsl_poly (x p)) .
                               showsl_literal " as interpretation of ") .
                               showsl f);
                       })
                         b;
                   })))
         (showsl_literal "polynomial interpretation\n" .
           showsl_sep
             (\ (a, b) ->
               (case a of {
                 (f, n) ->
                   (\ p ->
                     ((((showsl_literal "Pol(" . showsl f) .
                         showsl_literal "/") .
                        showsl_nat n) .
                       showsl_literal ") = ") .
                       showsl_poly (x p));
               })
                 b)
             (showsl_literal "\n") i)
         (Just (map fst i)) (Just (map fst i)) (nl_complexity_check j) ();

fpair_f :: forall a. Filtered a -> a;
fpair_f (FPair x1 x2) = x1;

afs_to_af :: forall a. (Compare_order a) => Afs a -> (a, Nat) -> Set Nat;
afs_to_af pi fn =
  (case afsa pi fn of {
    Collapse j -> inserta j (set_empty (of_phantom set_impl_nat));
    AFList a -> set a;
  });

afs_check ::
  forall a b.
    (Showl a,
      Showl b) => (String -> String) ->
                    Afs a ->
                      ((Term (Filtered a) b, Term (Filtered a) b) ->
                        Sum (String -> String) ()) ->
                        (Term a b, Term a b) -> Sum (String -> String) ();
afs_check r pi g lr =
  let {
    pl = afs_term pi (fst lr);
    pr = afs_term pi (snd lr);
  } in catch_errora (g (pl, pr))
         (\ x ->
           Inl (((((((((((((((showsl_literal "could not orient " .
                               showsl_terma (fst lr)) .
                              showsl_literal " ") .
                             r) .
                            showsl_literal " ") .
                           showsl_terma (snd lr)) .
                          showsl_literal "\npi( ") .
                         showsl_terma (fst lr)) .
                        showsl_literal " ) = ") .
                       showsl_terma pl) .
                      showsl_literal "\npi( ") .
                     showsl_terma (snd lr)) .
                    showsl_literal " ) = ") .
                   showsl_terma pr) .
                  showsl_literal "\n") .
                 x));

filtered_redtriple ::
  forall a b.
    (Ceq a, Ccompare a, Compare_order a, Set_impl a, Showl a,
      Showl b) => [((a, Nat), Af_entry)] ->
                    Redtriple_ext (Filtered a) b () -> Redtriple_ext a b ();
filtered_redtriple pi rp =
  let {
    afso = afs_of pi;
    afs = the afso;
    af = afs_to_af afs;
  } in Redtriple_ext
         (bindb
           (check (not (is_none afso))
             (showsl_literal "invalid positions in argument filter"))
           (\ _ -> valid rp))
         (afs_check (showsl_literal ">") afs (s rp))
         (afs_check (showsl_literal ">=") afs (ns rp))
         (afs_check (showsl_literal ">=") afs (nst rp)) af empty_af
         (\ cs ->
           bindb (check_mono_afs afs) (\ _ -> mono rp (map (afs_rule afs) cs)))
         (((showsl_literal "Argument Filter:\n" . showsl_afs pi) .
            showsl_literal "\n") .
           desca rp)
         (map_option (\ fs -> map fst pi ++ map (\ (f, a) -> (fpair_f f, a)) fs)
           (not_wst rp))
         Nothing no_complexity_check ();

pos_arctic_delta :: forall a. (Floor_ceiling a) => Arctic_delta a -> Bool;
pos_arctic_delta MinInfty_delta = False;
pos_arctic_delta (Num_arc_delta n) = less_eq zerob n;

class_ordered_semiring ::
  forall a b.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => Itself a ->
                       (a -> a -> Bool) ->
                         b -> Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a (Ordered_semiring_ext a b)));
class_ordered_semiring a gt b =
  class_semiring a (Ordered_semiring_ext (\ x y -> less_eq y x) gt max b);

class_arc_complexity :: forall a. a -> Nat -> Sum (String -> String) ();
class_arc_complexity a deg =
  Inl (showsl_literal "complexity for arctic semirings not supported");

class_arc_lpoly_order ::
  forall a.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => a -> (a -> Bool) ->
                            (a -> a -> Bool) ->
                              Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a
                                    (Ordered_semiring_ext a
                                      (Lpoly_order_semiring_ext a ()))));
class_arc_lpoly_order def apos gtt =
  class_ordered_semiring Type gtt
    (Lpoly_order_semiring_ext False def apos (\ _ -> False) (\ _ -> zero_nat)
      class_arc_complexity
      (showsl_lit "polynomial interpretation over arctic semiring") ());

prec_weight_ac_repr_to_prec_weight_funs ::
  forall a.
    (Ceq a, Ccompare a, Compare_order a,
      Set_impl a) => ([((a, Nat), (Nat, (Nat, Bool)))], Nat) ->
                       ((a, Nat) -> (a, Nat) -> Bool,
                         ((a, Nat) -> Nat, (Nat, Set a)));
prec_weight_ac_repr_to_prec_weight_funs prw_w0 =
  (case prw_w0 of {
    (prw, w0) ->
      let {
        prwm = ceta_map_of prw;
        w_fun = fun_of_map_funa prwm (\ _ -> suc w0) (fst . snd);
        p_fun = prec_exta prwm;
        acset =
          set (map_filter
                (\ x ->
                  (if (case x of {
                        (a, b) -> (case a of {
                                    (_, _) -> (\ (_, (_, ac)) -> ac);
                                  })
                                    b;
                      })
                    then Just ((fst . fst) x) else Nothing))
                prw);
      } in (p_fun, (w_fun, (w0, acset)));
  });

prec_weight_ac_repr_to_prec_weight ::
  forall a.
    (Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showl a) => ([((a, Nat), (Nat, (Nat, Bool)))], Nat) ->
                    (Sum (String -> String) (),
                      ((a, Nat) -> (a, Nat) -> Bool,
                        ((a, Nat) -> Nat, (Nat, Set a))));
prec_weight_ac_repr_to_prec_weight prw_w0 =
  (case prec_weight_ac_repr_to_prec_weight_funs prw_w0 of {
    (p_fun, (w_fun, (_, acset))) ->
      (case prw_w0 of {
        (prw, w0) ->
          let {
            fs = map fst prw;
            cw_okay =
              catch_errora
                (forallM
                  (\ fn ->
                    check (if equal_nat (snd fn) zero_nat
                            then less_eq_nat w0 (w_fun fn) else True)
                      ((showsl_lit "weight of constant " . showsl (fst fn)) .
                        showsl_lit " must be at least w0"))
                  fs)
                (\ x -> Inl (snd x));
            adm = catch_errora
                    (forallM
                      (\ fn ->
                        check (if equal_nat (snd fn) one_nat
                                then (if equal_nat (w_fun fn) zero_nat
                                       then all (\ x -> p_fun fn x || x == fn)
      fs
                                       else True)
                                else True)
                          ((showsl_lit "unary symbol " . showsl (fst fn)) .
                            showsl_lit
                              " with weight 0 does not have maximal precedence"))
                      (map fst prw))
                    (\ x -> Inl (snd x));
            irr = catch_errora
                    (forallM
                      (\ fn ->
                        check (not (p_fun fn fn))
                          ((showsl_lit "function symbol " . showsl (fst fn)) .
                            showsl_lit " violates irreflexibity"))
                      fs)
                    (\ x -> Inl (snd x));
            ok = bindb (check (less_nat zero_nat w0)
                         (showsl_lit "w0 must be larger than 0"))
                   (\ _ -> bindb adm (\ _ -> bindb cw_okay (\ _ -> irr)));
          } in (ok, (p_fun, (w_fun, (w0, acset))));
      });
  });

showsl_ackbo_repr ::
  forall a.
    (Showl a) => ([((a, Nat), (Nat, (Nat, Bool)))], Nat) -> String -> String;
showsl_ackbo_repr (prs, w0) =
  ((((((((((((showsl_lit
                "ACKBO with the following precedence and weight function:\n" .
               foldr (\ (fn, (pr, (_, _))) ->
                       (((showsl_lit "precedence(" . showsl_funaa fn) .
                          showsl_lit ") = ") .
                         showsl_nat pr) .
                         showsl_literal "\n")
                 prs) .
              showsl_lit "precedence(_) = 0\n\n") .
             foldr (\ (fn, (_, (w, _))) ->
                     (((showsl_lit "weight(" . showsl_funaa fn) .
                        showsl_lit ") = ") .
                       showsl_nat w) .
                       showsl_literal "\n")
               prs) .
            showsl_lit "weight(_) = ") .
           showsl_nat (suc w0)) .
          showsl_lit "\nw0 = ") .
         showsl_nat w0) .
        showsl_literal "\n") .
       showsl_literal "\n") .
      showsl_list_gen (\ (fn, _) -> showsl_funaa fn) "no AC function symbols"
        "AC function symbols: " ", " ""
        (filter (\ (_, (_, (_, ac))) -> ac) prs)) .
     showsl_literal "\n") .
    showsl_list_gen (\ (fn, _) -> showsl_funaa fn) "no non AC function symbols"
      "non AC function symbols: " ", " ""
      (filter (\ (_, a) -> (case a of {
                             (_, aa) -> (case aa of {
  (_, ab) -> not ab;
});
                           }))
        prs)) .
    showsl_literal "\n";

create_ACKBO_redtriple ::
  forall a b c.
    (Showl a, Ceq b, Ccompare b, Compare_order b, Eq b, Set_impl b, Showl b,
      Eq c,
      Showl c) => (([((a, Nat), (Nat, (Nat, Bool)))], Nat) ->
                    ([((b, Nat), (Nat, (Nat, Bool)))], Nat)) ->
                    ([((a, Nat), (Nat, (Nat, Bool)))], Nat) ->
                      Redtriple_ext b c ();
create_ACKBO_redtriple f_to_g pr =
  (case prec_weight_ac_repr_to_prec_weight (f_to_g pr) of {
    (ch, (p, (w, (w0, ac)))) ->
      let {
        ns = ackbo_nstrict p w w0 ac;
        s = ackbo_strict p w w0 ac;
      } in Redtriple_ext ch s ns ns full_af full_af (\ _ -> Inr ())
             (showsl_ackbo_repr pr) (Just []) (Just []) no_complexity_check ();
  });

mat_max :: forall a. (Ord a) => Mat a -> Mat a -> Mat a;
mat_max a b =
  mat (dim_row a) (dim_col a) (\ ij -> max (index_mat a ij) (index_mat b ij));

mat_ge :: forall a. (Ord a) => Mat a -> Mat a -> Bool;
mat_ge a b =
  all_interval_nat
    (\ i ->
      all_interval_nat
        (\ j -> less_eq (index_mat b (i, j)) (index_mat a (i, j))) zero_nat
        (dim_col a))
    zero_nat (dim_row a);

mat_comp_all :: forall a. (a -> a -> Bool) -> Mat a -> Mat a -> Bool;
mat_comp_all r a b =
  all_interval_nat
    (\ i ->
      all_interval_nat (\ j -> r (index_mat a (i, j)) (index_mat b (i, j)))
        zero_nat (dim_col a))
    zero_nat (dim_row a);

mat_both_ordered_semiring ::
  forall a b.
    (Ordered_semiring_1 a) => Nat ->
                                (a -> a -> Bool) ->
                                  b -> Partial_object_ext (Mat a)
 (Monoid_ext (Mat a) (Ring_ext (Mat a) (Ordered_semiring_ext (Mat a) b)));
mat_both_ordered_semiring n gt b =
  ring_mat Type n (Ordered_semiring_ext mat_ge (mat_comp_all gt) mat_max b);

mat_default :: forall a. (Zero a) => a -> Nat -> Mat a;
mat_default d n = mat n n (\ (i, j) -> (if equal_nat i j then d else zerob));

mat_arc_complexity :: forall a. a -> Nat -> Sum (String -> String) ();
mat_arc_complexity m deg =
  Inl (showsl_lit "complexity for arctic matrices not supported");

mat_arc_posI :: forall a. (a -> Bool) -> Mat a -> Bool;
mat_arc_posI ap a = ap (index_mat a (zero_nat, zero_nat));

mat_arc_lpoly_order ::
  forall a.
    (Ordered_semiring_1 a) => Nat ->
                                a -> (a -> Bool) ->
                                       (a -> a -> Bool) ->
 Partial_object_ext (Mat a)
   (Monoid_ext (Mat a)
     (Ring_ext (Mat a)
       (Ordered_semiring_ext (Mat a) (Lpoly_order_semiring_ext (Mat a) ()))));
mat_arc_lpoly_order n def apos gtt =
  mat_both_ordered_semiring n gtt
    (Lpoly_order_semiring_ext False (mat_default def n) (mat_arc_posI apos)
      (\ _ -> False) (\ _ -> zero_nat) mat_arc_complexity
      (showsl_lit "arctic matrix interpretation") ());

check_arc_dimension ::
  forall a. (Zero a, Ord a) => a -> Sum (String -> String) ();
check_arc_dimension n =
  check (less zerob n) (showsl_lit "dimension must be at least 1");

class_complexity ::
  forall a. (Ordered_semiring_1 a) => a -> Nat -> Sum (String -> String) ();
class_complexity a deg =
  check (less_eq a onea) (showsl_literal "value is larger than 1");

class_lpoly_order ::
  forall a.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => a -> (a -> Bool) ->
                            (a -> a -> Bool) ->
                              Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a
                                    (Ordered_semiring_ext a
                                      (Lpoly_order_semiring_ext a ()))));
class_lpoly_order def cmon gtt =
  class_ordered_semiring Type gtt
    (Lpoly_order_semiring_ext True def (\ _ -> True) cmon (\ _ -> zero_nat)
      class_complexity (showsl_literal "polynomial interpretation") ());

create_KBO_redtriple ::
  forall a b c.
    (Showl a, Compare_order b, Eq b, Showl b, Eq c,
      Showl c) => (([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    ([((b, Nat), (Nat, (Nat, Maybe [Nat])))], Nat)) ->
                    ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                      Redtriple_ext b c ();
create_KBO_redtriple f_to_g pr =
  (case prec_weight_repr_to_prec_weight (f_to_g pr) of {
    (ch, (p, (w, (w0, (lcs, scf))))) ->
      let {
        ns = kbo_nstrict p w w0 (membera lcs) scf;
        s = kbo_strict p w w0 (membera lcs) scf;
      } in Redtriple_ext ch s ns ns full_af full_af (\ _ -> Inr ())
             (shows_kbo_repr pr) (Just []) (Just []) no_complexity_check ();
  });

check_dimensions ::
  Nat -> Nat -> Sum (String -> String) () -> Sum (String -> String) ();
check_dimensions n sd c =
  bindb c
    (\ _ ->
      check (less_eq_nat sd n && less_nat zero_nat sd)
        (showsl_literal
          "strict dimension must be at least 1 and less than total dimension"));

pos_arctic :: Arctic -> Bool;
pos_arctic MinInfty = False;
pos_arctic (Num_arc n) = less_eq_int zero_int n;

delta_mono :: forall a. (Floor_ceiling a) => a -> Bool;
delta_mono x = less_eq onea x;

mat_gt ::
  forall a. (Ord a) => (a -> a -> Bool) -> Nat -> Mat a -> Mat a -> Bool;
mat_gt gt sd a b =
  mat_ge a b &&
    not (all_interval_nat
          (not .
            (\ i ->
              not (all_interval_nat
                    (not .
                      (\ j -> gt (index_mat a (i, j)) (index_mat b (i, j))))
                    zero_nat sd)))
          zero_nat sd);

mat_ordered_semiring ::
  forall a b.
    (Ordered_semiring_1 a) => Nat ->
                                Nat ->
                                  (a -> a -> Bool) ->
                                    b -> Partial_object_ext (Mat a)
   (Monoid_ext (Mat a) (Ring_ext (Mat a) (Ordered_semiring_ext (Mat a) b)));
mat_ordered_semiring n sd gt b =
  ring_mat Type n (Ordered_semiring_ext mat_ge (mat_gt gt sd) mat_max b);

normalize_poly ::
  forall a.
    (Eq a, Idom_divide a, Semidom_divide_unit_factor a) => Poly a -> Poly a;
normalize_poly p =
  divide_poly p (pCons (unit_factor (coeff p (degreea p))) zero_polya);

primitive_part :: forall a. (Semiring_gcd a, Eq a) => Poly a -> Poly a;
primitive_part p = map_poly (\ x -> divide x (content p)) p;

gcd_poly_code_aux ::
  forall a. (Factorial_ring_gcd a, Eq a) => Poly a -> Poly a -> Poly a;
gcd_poly_code_aux p q =
  (if is_zero q then normalize_poly p
    else gcd_poly_code_aux q (primitive_part (pseudo_mod p q)));

gcd_poly_code ::
  forall a. (Factorial_ring_gcd a, Eq a) => Poly a -> Poly a -> Poly a;
gcd_poly_code p q =
  (if is_zero p then normalize_poly q
    else (if is_zero q then normalize_poly p
           else let {
                  c1 = content p;
                  c2 = content q;
                  pa = map_poly (\ x -> divide x c1) p;
                  qa = map_poly (\ x -> divide x c2) q;
                } in smult (gcda c1 c2) (gcd_poly_code_aux pa qa)));

gcd_poly ::
  forall a.
    (Factorial_ring_gcd a, Semiring_gcd_mult_normalize a,
      Eq a) => Poly a -> Poly a -> Poly a;
gcd_poly p q = gcd_poly_code p q;

divmod_poly_one_main_list ::
  forall a. (Eq a, Comm_ring_1 a) => [a] -> [a] -> [a] -> Nat -> ([a], [a]);
divmod_poly_one_main_list q r d n =
  (if equal_nat n zero_nat then (q, r)
    else let {
           a = hda r;
           qqq = cCons a q;
           rr = tla (if a == zerob then r
                      else minus_poly_rev_list r (map (times a) d));
         } in divmod_poly_one_main_list qqq rr d (minus_nat n one_nat));

div_field_poly_impl :: forall a. (Field a, Eq a) => Poly a -> Poly a -> Poly a;
div_field_poly_impl f g =
  let {
    cg = coeffs g;
  } in (if null cg then zero_polya
         else let {
                cf = coeffs f;
                ilc = inverse (last cg);
                ch = map (times ilc) cg;
                q = fst (divmod_poly_one_main_list [] (reverse cf) (reverse ch)
                          (minus_nat (plus_nat one_nat (size_list cf))
                            (size_list cg)));
              } in poly_of_list (map (times ilc) q));

sturm_squarefree :: Poly Real -> [Poly Real];
sturm_squarefree p = sturm (div_field_poly_impl p (gcd_poly p (pderiv p)));

poly_inf :: forall a. (Real_normed_vector a) => Poly a -> a;
poly_inf p = sgn (coeff p (degreea p));

sign_changes_inf :: forall a. (Eq a, Real_normed_vector a) => [Poly a] -> Nat;
sign_changes_inf ps =
  minus_nat
    (size_list
      (remdups_adj (filter (\ x -> not (x == zerob)) (map poly_inf ps))))
    one_nat;

sign_changes :: [Poly Real] -> Real -> Nat;
sign_changes ps x =
  minus_nat
    (size_list
      (remdups_adj
        (filter (\ xa -> not (equal_real xa zero_real))
          (map (\ p -> sgn_real (polya p x)) ps))))
    one_nat;

count_roots_above :: Poly Real -> Real -> Nat;
count_roots_above p a =
  let {
    q = pderiv p;
  } in (if equal_poly p zero_polya then zero_nat
         else (if not (equal_real (polya p a) zero_real) ||
                    not (equal_real (polya q a) zero_real)
                then let {
                       ps = sturm p;
                     } in minus_nat (sign_changes ps a) (sign_changes_inf ps)
                else let {
                       ps = sturm_squarefree p;
                     } in minus_nat (sign_changes ps a) (sign_changes_inf ps)));

minus_mat :: forall a. (Minus a) => Mat a -> Mat a -> Mat a;
minus_mat a b =
  mat (dim_row b) (dim_col b) (\ ij -> minus (index_mat a ij) (index_mat b ij));

pivot_positions_main_gen ::
  forall a. (Eq a) => a -> Mat a -> Nat -> Nat -> Nat -> Nat -> [(Nat, Nat)];
pivot_positions_main_gen zero a nr nc i j =
  (if less_nat i nr
    then (if less_nat j nc
           then (if index_mat a (i, j) == zero
                  then pivot_positions_main_gen zero a nr nc i (suc j)
                  else (i, j) :
                         pivot_positions_main_gen zero a nr nc (suc i) (suc j))
           else [])
    else []);

pivot_positions_gen :: forall a. (Eq a) => a -> Mat a -> [(Nat, Nat)];
pivot_positions_gen zer a =
  pivot_positions_main_gen zer a (dim_row a) (dim_col a) zero_nat zero_nat;

eliminate_entries_gen ::
  forall a.
    (a -> a -> a) ->
      (a -> a -> a) -> (Nat -> a) -> Mat a -> Nat -> Nat -> Mat a;
eliminate_entries_gen minus times v a i j =
  mat (dim_row a) (dim_col a)
    (\ (ia, ja) ->
      (if not (equal_nat ia i)
        then minus (index_mat a (ia, ja)) (times (v ia) (index_mat a (i, ja)))
        else index_mat a (ia, ja)));

gauss_jordan_main ::
  forall a. (Field a, Eq a) => Mat a -> Mat a -> Nat -> Nat -> (Mat a, Mat a);
gauss_jordan_main a b i j =
  let {
    nr = dim_row a;
    nc = dim_col a;
  } in (if less_nat i nr && less_nat j nc
         then let {
                aij = index_mat a (i, j);
              } in (if aij == zerob
                     then (case concatMap
                                  (\ ia ->
                                    (if not (index_mat a (ia, j) == zerob)
                                      then [ia] else []))
                                  (upt (suc i) nr)
                            of {
                            [] -> gauss_jordan_main a b i (suc j);
                            ia : _ ->
                              gauss_jordan_main (mat_swaprows i ia a)
                                (mat_swaprows i ia b) i j;
                          })
                     else (if aij == onea
                            then let {
                                   v = (\ ia -> index_mat a (ia, j));
                                 } in gauss_jordan_main
(eliminate_entries_gen minus times v a i j)
(eliminate_entries_gen minus times v b i j) (suc i) (suc j)
                            else let {
                                   iaij = inverse aij;
                                   aa = mat_multrow_gen times i iaij a;
                                   ba = mat_multrow_gen times i iaij b;
                                   v = (\ ia -> index_mat aa (ia, j));
                                 } in gauss_jordan_main
(eliminate_entries_gen minus times v aa i j)
(eliminate_entries_gen minus times v ba i j) (suc i) (suc j)))
         else (a, b));

gauss_jordan :: forall a. (Field a, Eq a) => Mat a -> Mat a -> (Mat a, Mat a);
gauss_jordan a b = gauss_jordan_main a b zero_nat zero_nat;

gauss_jordan_single :: forall a. (Field a, Eq a) => Mat a -> Mat a;
gauss_jordan_single a = fst (gauss_jordan a (zero_mat (dim_row a) zero_nat));

kernel_dim :: forall a. (Field a, Eq a) => Mat a -> Nat;
kernel_dim a =
  minus_nat (dim_col a)
    (size_list (pivot_positions_gen zerob (gauss_jordan_single a)));

check_matrix_complexity :: Mat Real -> Poly Real -> Nat -> Bool;
check_matrix_complexity a cp d =
  equal_nat (count_roots_above cp one_real) zero_nat &&
    (if equal_real (polya cp one_real) zero_real
      then let {
             ord = order one_real cp;
           } in (if less_nat (plus_nat d one_nat) ord
                  then equal_nat
                         (kernel_dim
                           (pow_mat (minus_mat a (one_mat (dim_row a)))
                             (plus_nat d one_nat)))
                         ord
                  else True)
      else True);

nonneg_mat ::
  forall a. (Ceq a, Ccompare a, Linordered_idom a, Set_impl a) => Mat a -> Bool;
nonneg_mat a = ball (elements_mat a) (less_eq zerob);

complexity_via_perron_frobenius :: Nat -> Poly Real -> Mat Real -> Bool;
complexity_via_perron_frobenius d cp a =
  nonneg_mat a && check_matrix_complexity a cp (minus_nat d one_nat);

count_ones_check :: [Real] -> Nat -> Bool;
count_ones_check diag d =
  all (\ a ->
        let {
          aa = abs_real a;
        } in less_eq_real aa one_real &&
               (if equal_real aa one_real
                 then less_eq_nat (size_list (filter (equal_real a) diag)) d
                 else True))
    diag;

combined_growth_check_real_mat :: Nat -> Mat Real -> Sum (String -> String) ();
combined_growth_check_real_mat d a =
  catch_errora
    (if upper_triangular a && count_ones_check (diag_mat a) d then Inr ()
      else (if complexity_via_perron_frobenius d (char_poly a) a then Inr ()
             else Inl (if nonneg_mat a
                        then showsl_lit
                               "matrix does not have intended growth rate"
                        else showsl_lit
                               "only non-negative matrices supported")))
    (\ x ->
      Inl (((((showsl_lit "could not deduce that " . showsl_mat a) .
               showsl_literal " in O(n^") .
              showsl_nat (minus_nat d one_nat)) .
             showsl_lit ")\n") .
            x));

mat_estimate_complexity_jb ::
  forall a.
    (Large_real_ordered_semiring_1 a) => Nat ->
   Mat a -> Sum (String -> String) ();
mat_estimate_complexity_jb d a =
  let {
    b = map_mat real_of a;
  } in bindb (check (equal_nat (dim_row a) (dim_col a))
               (showsl_lit "expected square matrix but got \n" . showsl_mat b))
         (\ _ -> combined_growth_check_real_mat d b);

mat_complexity ::
  forall a.
    (Large_real_ordered_semiring_1 a) => Nat ->
   Mat a -> Nat -> Sum (String -> String) ();
mat_complexity n m d = mat_estimate_complexity_jb (suc d) m;

mat_mono :: forall a. (a -> Bool) -> Nat -> Mat a -> Bool;
mat_mono p sd a =
  all_interval_nat
    (\ j ->
      not (all_interval_nat (not . (\ i -> p (index_mat a (i, j)))) zero_nat
            sd))
    zero_nat sd;

mat_lpoly_order ::
  forall a.
    (Large_real_ordered_semiring_1 a) => Nat ->
   Nat ->
     a -> (a -> Bool) ->
            (a -> a -> Bool) ->
              Partial_object_ext (Mat a)
                (Monoid_ext (Mat a)
                  (Ring_ext (Mat a)
                    (Ordered_semiring_ext (Mat a)
                      (Lpoly_order_semiring_ext (Mat a) ()))));
mat_lpoly_order n sd def cmon gtt =
  mat_ordered_semiring n sd gtt
    (Lpoly_order_semiring_ext True (mat_default def n) (\ _ -> True)
      (mat_mono cmon sd) (\ _ -> zero_nat) (mat_complexity n)
      (showsl_lit "matrix interpretation") ());

int_mono :: Int -> Bool;
int_mono x = less_eq_int one_int x;

delta_gt :: forall a. (Floor_ceiling a) => a -> a -> a -> Bool;
delta_gt delta = (\ x y -> less_eq delta (minus x y));

check_def_pos :: forall a. (Zero a, Ord a) => a -> Sum (String -> String) ();
check_def_pos d =
  check (less zerob d) (showsl_lit "default value must be positive");

rpo_nstrict_unbounded ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                    ((a, Nat) -> Order_tag) ->
                      (Term a b, Term a b) -> Sum (String -> String) ();
rpo_nstrict_unbounded pr c =
  (\ (s, t) ->
    check (snd (rpo_unbounded pr c s t))
      ((((showsl_literal "could not orient " . showsl_terma s) .
          showsl_literal " >=RPO ") .
         showsl_terma t) .
        showsl_literal "\n"));

rpo_strict_unbounded ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                    ((a, Nat) -> Order_tag) ->
                      (Term a b, Term a b) -> Sum (String -> String) ();
rpo_strict_unbounded pr c =
  (\ (s, t) ->
    check (fst (rpo_unbounded pr c s t))
      ((((showsl_literal "could not orient " . showsl_terma s) .
          showsl_literal " >RPO ") .
         showsl_terma t) .
        showsl_literal "\n"));

create_RPO_redtriple ::
  forall a b c.
    (Showl a, Eq b, Showl b, Eq c,
      Showl c) => ([((a, Nat), (Nat, Order_tag))] ->
                    ((b, Nat) -> Nat, (b, Nat) -> Order_tag)) ->
                    [((a, Nat), (Nat, Order_tag))] -> Redtriple_ext b c ();
create_RPO_redtriple prec_repr_to_pr pr =
  (case prec_repr_to_pr pr of {
    (p, tau) ->
      let {
        ns = rpo_nstrict_unbounded (prc_nat p, prl_nat p) tau;
      } in Redtriple_ext (Inr ())
             (rpo_strict_unbounded (prc_nat p, prl_nat p) tau) ns ns full_af
             full_af (\ _ -> Inr ()) (showsl_rpo_repr pr) (Just []) (Just [])
             no_complexity_check ();
  });

get_redtriple ::
  forall a.
    (Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showl a) => Redtriple_impl a -> Redtriple_ext a [Char] ();
get_redtriple (Int_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_int int_mono (\ x y -> less_int y x)) (Inr ()) i;
get_redtriple (Int_nl_carrier i) =
  create_nlpoly_redtriple (Inr ()) one_int (\ x y -> less_int y x) True True i;
get_redtriple (Rat_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_rat delta_mono (\ x y -> less_rat y x))
    (check_def_pos one_rat) i;
get_redtriple (Rat_nl_carrier d i) =
  create_nlpoly_redtriple (check_def_pos d) d (delta_gt d)
    (less_eq_rat one_rat d) False i;
get_redtriple (Real_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_real delta_mono (\ x y -> less_real y x))
    (check_def_pos one_real) i;
get_redtriple (Real_nl_carrier d i) =
  create_nlpoly_redtriple (check_def_pos d) d (delta_gt d)
    (less_eq_real one_real d) False i;
get_redtriple (Arctic_carrier i) =
  create_poly_redtriple
    (class_arc_lpoly_order one_arctic pos_arctic (\ x y -> less_arctic y x))
    (Inr ()) i;
get_redtriple (Arctic_rat_carrier i) =
  create_poly_redtriple
    (class_arc_lpoly_order one_arctic_delta pos_arctic_delta
      weak_gt_arctic_delta)
    (Inr ()) i;
get_redtriple (Int_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_int int_mono (\ x y -> less_int y x))
    (check_dimensions n sd (Inr ())) i;
get_redtriple (Rat_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_rat delta_mono (\ x y -> less_rat y x))
    (check_dimensions n sd (check_def_pos one_rat)) i;
get_redtriple (Real_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_real delta_mono (\ x y -> less_real y x))
    (check_dimensions n sd (check_def_pos one_real)) i;
get_redtriple (Arctic_mat_carrier n i) =
  create_poly_redtriple
    (mat_arc_lpoly_order n one_arctic pos_arctic (\ x y -> less_arctic y x))
    (check_arc_dimension n) i;
get_redtriple (Arctic_rat_mat_carrier n i) =
  create_poly_redtriple
    (mat_arc_lpoly_order n one_arctic_delta pos_arctic_delta
      weak_gt_arctic_delta)
    (check_arc_dimension n) i;
get_redtriple (RPO prec_tau pi) =
  filtered_redtriple pi
    (create_RPO_redtriple (\ pr -> (prec_repr_to_pr pr, prec_repr_to_status pr))
      prec_tau);
get_redtriple (KBO precw pi) =
  filtered_redtriple pi
    (create_KBO_redtriple
      (filter_prec_weight_repr
        (fun_of_map_fun (ceta_map_of pi) (\ fn -> default_af_entry (snd fn))))
      precw);
get_redtriple (ACKBO precw pi) =
  filtered_redtriple pi
    (create_ACKBO_redtriple
      (filter_prec_weight_ac_repr
        (fun_of_map_fun (ceta_map_of pi) (\ fn -> default_af_entry (snd fn))))
      precw);
get_redtriple (WPO params rp) = wpo_redtriple (get_redtriple rp) params;
get_redtriple (Max_poly alist) = create_max_poly_redtriple alist;
get_redtriple (Filtered_Redtriple alist rp) =
  filtered_redtriple_af alist (get_redtriple rp);

list_ext_name :: List_order_type -> String;
list_ext_name MS_Ext = "MS";
list_ext_name Dms_Ext = "DMS";
list_ext_name Min_Ext = "MIN";
list_ext_name Max_Ext = "MAX";

dms_preprocess :: [[(Nat, (Bool, Bool))]] -> [[(Nat, (Bool, Bool))]];
dms_preprocess p = map (filter (\ (_, a) -> (case a of {
      (aa, b) -> aa || b;
    })))
                     p;

dms_simplify ::
  Bool -> [Nat] -> [[(Nat, (Bool, Bool))]] -> [[(Nat, (Bool, Bool))]];
dms_simplify stri is p = (if any (\ i -> null (nth p i)) is then [[]] else p);

dms_decide_singletons :: Bool -> Nat -> [(Nat, (Bool, Bool))] -> Bool;
dms_decide_singletons stri n p =
  all_interval_nat
    (\ i ->
      (case nth p i of {
        (j, (s, ns)) ->
          s && not (membera (drop (suc i) p) (j, (False, True))) ||
            ns && not (membera (map fst (drop (suc i) p)) j);
      }))
    zero_nat (size_list p) &&
    (if stri
      then not (all_interval_nat
                 (not . (\ j -> not (membera p (j, (False, True))))) zero_nat n)
      else True);

dms_select :: Bool -> [[(Nat, (Bool, Bool))]] -> Nat;
dms_select stri p =
  snd (hda (sort_key fst
             (filter (\ (l, _) -> less_nat one_nat l)
               (zip (map size_list p) (upt zero_nat (size_list p))))));

dms_solve_or_select :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Sum Bool Nat;
dms_solve_or_select stri n p =
  (if all (\ jsns -> less_eq_nat (size_list jsns) one_nat) p
    then Inl (if membera p [] then False
               else dms_decide_singletons stri n (map hda p))
    else Inr (dms_select stri p));

dms_solve :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_solve stri n p =
  (case dms_solve_or_select stri n p of {
    Inl res -> res;
    Inr k ->
      let {
        ksns = nth p k;
      } in dms_solve stri n
             (dms_simplify stri [k] (list_update p k [hda ksns])) ||
             dms_solve stri n
               (dms_simplify stri [k] (list_update p k (tla ksns)));
  });

dms_bool_ex_idx_impl :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_bool_ex_idx_impl stri n p =
  dms_solve stri n
    (dms_simplify stri (upt zero_nat (size_list p)) (dms_preprocess p));

dms_bool_ex_idx :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_bool_ex_idx = dms_bool_ex_idx_impl;

dms_convert ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> [[(Nat, (Bool, Bool))]];
dms_convert f asa bs = let {
                         jbs = zip (upt zero_nat (size_list bs)) bs;
                       } in map (\ a -> map (\ (j, b) -> (j, f a b)) jbs) asa;

dms_order_ext ::
  forall a. Nat -> (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
dms_order_ext n f asa bs =
  let {
    p = dms_convert f asa bs;
    lts = size_list bs;
    len = less_eq_nat lts n || equal_nat (size_list asa) lts;
  } in (len && dms_bool_ex_idx True lts p, len && dms_bool_ex_idx False lts p);

min_set_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
min_set_ext s_ns =
  (\ asa bs ->
    (not (null bs) && all (\ a -> any (\ b -> fst (s_ns a b)) bs) asa,
      all (\ a -> any (\ b -> snd (s_ns a b)) bs) asa));

list_ext ::
  forall a.
    Nat ->
      List_order_type -> (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
list_ext uu MS_Ext = mul_ext;
list_ext uv Max_Ext = set_ext;
list_ext uw Min_Ext = min_set_ext;
list_ext n Dms_Ext = dms_order_ext n;

label_s_ns_impl ::
  forall a b.
    (Showl a,
      Showl b) => ((Term a b, Term a b) -> Sum (String -> String) ()) ->
                    ((Term a b, Term a b) -> Sum (String -> String) ()) ->
                      (Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool);
label_s_ns_impl cS cNS s t =
  (case s of {
    (sa, i) ->
      (case t of {
        (ta, j) ->
          (if isOK (cS (sa, ta)) then (True, True)
            else (if isOK (cNS (sa, ta)) then (less_nat j i, less_eq_nat j i)
                   else (False, False)));
      });
  });

nST_label_mul_impl ::
  forall a b.
    (Showl a,
      Showl b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    ((a, Nat) -> [(Nat, Nat)]) ->
                      ((Term a b, Term a b) -> Sum (String -> String) ()) ->
                        ((Term a b, Term a b) -> Sum (String -> String) ()) ->
                          (Term a b, Term a b) -> Sum (String -> String) ();
nST_label_mul_impl list_ext af cS cNS st =
  (case st of {
    (Var _, _) ->
      Inl ((showsl_literal "roots of " . showsl_rule st) .
            showsl_literal " must be non-variable");
    (Fun _ _, Var _) ->
      Inl ((showsl_literal "roots of " . showsl_rule st) .
            showsl_literal " must be non-variable");
    (Fun f ss, Fun g ts) ->
      check (snd (list_ext (label_s_ns_impl cS cNS) (lterms af (Fun f ss))
                   (lterms af (Fun g ts))))
        ((((((showsl_literal "cannot orient pair " . showsl_rule st) .
              showsl_literal " weakly:\n") .
             showsl_list_prod (lterms af (Fun f ss))) .
            showsl_literal " >=mu ") .
           showsl_list_prod (lterms af (Fun g ts))) .
          showsl_literal " could not be ensured");
  });

s_label_mul_impl ::
  forall a b.
    (Showl a,
      Showl b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    ((a, Nat) -> [(Nat, Nat)]) ->
                      ((Term a b, Term a b) -> Sum (String -> String) ()) ->
                        ((Term a b, Term a b) -> Sum (String -> String) ()) ->
                          (Term a b, Term a b) -> Sum (String -> String) ();
s_label_mul_impl list_ext af cS cNS st =
  (case st of {
    (Var _, _) ->
      Inl ((showsl_lit "roots of " . showsl_rule st) .
            showsl_lit " must be non-variable");
    (Fun _ _, Var _) ->
      Inl ((showsl_lit "roots of " . showsl_rule st) .
            showsl_lit " must be non-variable");
    (Fun f ss, Fun g ts) ->
      check (fst (list_ext (label_s_ns_impl cS cNS) (lterms af (Fun f ss))
                   (lterms af (Fun g ts))))
        ((((((showsl_lit "cannot orient pair " . showsl_rule st) .
              showsl_lit " strictly:\n") .
             showsl_list_prod (lterms af (Fun f ss))) .
            showsl_lit " >mu ") .
           showsl_list_prod (lterms af (Fun g ts))) .
          showsl_lit " could not be ensured");
  });

generate_scnp_rp ::
  forall a b c.
    (Compare_order a, Showl a,
      Showl b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    (String -> String) ->
                      [((a, Nat), [(Nat, Nat)])] ->
                        (c -> Redtriple_ext a b ()) ->
                          c -> Root_redtriple_ext a b ();
generate_scnp_rp list_ext list_ext_name afa rti x =
  let {
    rt = rti x;
    afaa = fun_of_map (ceta_map_of afa) [];
    pi = af rt;
    cS = s rt;
    cNS = ns rt;
  } in Root_redtriple_ext (valid rt) (s_label_mul_impl list_ext afaa cS cNS)
         (ns rt) (nST_label_mul_impl list_ext afaa cS cNS) pi
         (scnp_af_to_af afaa pi) (scnp_desc afa list_ext_name . desca rt) ();

get_root_redtriple ::
  forall a.
    (Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showl a) => Root_redtriple_impl a -> Root_redtriple_ext a [Char] ();
get_root_redtriple (SCNP typea af rp) =
  generate_scnp_rp (list_ext (scnp_arity af) typea)
    (showsl_lit (list_ext_name typea)) af get_redtriple rp;

faulty_non_inf_order ::
  forall a b c. (Showl b, Showl c) => String -> a -> Non_inf_order_ext b c ();
faulty_non_inf_order s f =
  Non_inf_order_ext (Inl (showsl_lit s)) (\ _ -> Inr ()) (\ _ -> Inr ())
    (\ _ _ -> Wild) id ();

sqrt_real :: Real -> [Real];
sqrt_real x =
  (if less_eq_real zero_real x then let {
                                      y = sqrt x;
                                    } in remdups [y, uminus_real y]
    else []);

check_non_inf_poly_inter_list ::
  forall a b.
    (Eq a, Eq b,
      Poly_carrier b) => Bool ->
                           [(a, Nat)] ->
                             [((a, Nat), [(Monom Nat, b)])] ->
                               Sum (a, [(Monom Nat, b)]) ();
check_non_inf_poly_inter_list discrete f i =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if (case x of {
                (_, a) -> check_poly_weak_mono_and_pos discrete a;
              })
            then Inr () else Inl x))
        (filter (\ (fn, _) -> membera f fn) i))
      (\ x -> Inl (snd x)))
    (\ x -> Inl (case x of {
                  (a, b) -> (case a of {
                              (fa, _) -> (\ aa -> (fa, aa));
                            })
                              b;
                }));

create_nlpoly_non_inf_order ::
  forall a b c.
    (Eq a, Poly_carrier a, Showl a, Compare_order b, Eq b, Showl b, Eq c,
      Linorder c,
      Showl c) => Sum (String -> String) () ->
                    a -> (a -> a -> Bool) ->
                           Bool ->
                             Bool ->
                               (a -> [a]) ->
                                 [((b, Nat), [(Monom Nat, a)])] ->
                                   [(b, Nat)] -> Non_inf_order_ext b c ();
create_nlpoly_non_inf_order cI def gt power_mono discrete sqrt i f =
  let {
    j = poly_inter_list_to_inter def i;
    x = poly_subst
          (\ n ->
            poly_of
              (PVar ([Char False False False True True True True False,
                       Char True True True True True False True False] ++
                      shows_prec_nat zero_nat n [])));
  } in Non_inf_order_ext
         (bindb cI
           (\ _ ->
             catch_errora (check_non_inf_poly_inter_list discrete f i)
               (\ xa ->
                 Inl (case xa of {
                       (fa, p) ->
                         (((showsl_literal "interpretation " .
                             showsl_poly (x p)) .
                            showsl_literal " of ") .
                           showsl fa) .
                           showsl_literal " invalid ";
                     }))))
         (check_ns j) (check_cc sqrt gt j) (create_dep discrete def i)
         (showsl_literal "polynomial interpretation\n" .
           showsl_sep
             (\ (a, b) ->
               (case a of {
                 (fa, n) ->
                   (\ p ->
                     ((((showsl_literal "Pol(" . showsl fa) .
                         showsl_literal "/") .
                        showsl_nat n) .
                       showsl_literal ") = ") .
                       showsl_poly (x p));
               })
                 b)
             (showsl_literal "\n") i)
         ();

sqrt_rat :: Rat -> [Rat];
sqrt_rat x =
  (case quotient_of x of {
    (z, n) ->
      (case sqrt_int n of {
        [] -> [];
        sn : _ -> map (\ sz -> divide_rat (of_int sz) (of_int sn)) (sqrt_int z);
      });
  });

get_non_inf_order ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Eq b, Linorder b,
      Showl b) => Redtriple_impl a -> [(a, Nat)] -> Non_inf_order_ext a b ();
get_non_inf_order (Int_nl_carrier i) =
  create_nlpoly_non_inf_order (Inr ()) one_int (\ x y -> less_int y x) True True
    sqrt_int i;
get_non_inf_order (Rat_nl_carrier d i) =
  create_nlpoly_non_inf_order (check_def_pos d) d (delta_gt d)
    (less_eq_rat one_rat d) False sqrt_rat i;
get_non_inf_order (Real_nl_carrier d i) =
  create_nlpoly_non_inf_order (check_def_pos d) d (delta_gt d)
    (less_eq_real one_real d) False sqrt_real i;
get_non_inf_order (Int_carrier v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Rat_carrier v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Real_carrier v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Arctic_carrier v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Arctic_rat_carrier v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Int_mat_carrier v va vb) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Rat_mat_carrier v va vb) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Real_mat_carrier v va vb) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Arctic_mat_carrier v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Arctic_rat_mat_carrier v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (RPO v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (KBO v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (ACKBO v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (WPO v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Max_poly v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Filtered_Redtriple v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";

all_terms_impl ::
  forall a.
    (Compare_order a,
      Eq a) => [(Term a [Char], Term a [Char])] ->
                 [([Term a [Char]],
                    (Term a [Char], (Term a [Char], Term a [Char])))] ->
                   [([Term a [Char]], Term a [Char])];
all_terms_impl rr initt =
  remdups
    (map (\ (ss, (t, _)) -> (ss, t)) initt ++ map (\ (l, a) -> (args l, a)) rr);

all_subterms_impl ::
  forall a.
    (Compare_order a,
      Eq a) => [(Term a [Char], Term a [Char])] ->
                 [([Term a [Char]],
                    (Term a [Char], (Term a [Char], Term a [Char])))] ->
                   [([Term a [Char]], Term a [Char])];
all_subterms_impl rr initt =
  remdups
    (concatMap (\ (ss, s) -> map (\ a -> (ss, a)) (supteq_list s))
      (all_terms_impl rr initt));

everything_impl ::
  forall a.
    (Compare_order a,
      Eq a) => [(Term a [Char], Term a [Char])] ->
                 [([Term a [Char]],
                    (Term a [Char], (Term a [Char], Term a [Char])))] ->
                   [Sum ([Term a [Char]],
                          (Term a [Char], (Term a [Char], Term a [Char])))
                      ((a, Nat), Nat)];
everything_impl rr initt =
  map Inl
    (concatMap
      (\ (ss, t) ->
        map (\ lr -> (ss, (t, lr))) (remdups (map (snd . snd) initt)))
      (all_subterms_impl rr initt)) ++
    remdups
      (map Inr
        (concatMap
          (\ t ->
            (if not (is_Var t)
              then concatMap
                     (\ (f, ts) ->
                       map (\ a -> ((f, size_list ts), a))
                         (upt zero_nat (size_list ts)))
                     (case t of {
                       Fun f ts -> [(f, ts)];
                     })
              else []))
          (remdups (map snd (all_subterms_impl rr initt)))));

generate_impl ::
  forall a b c d.
    (Compare_order a, Eq a, Eq b,
      Eq c) => [(Term a [Char], Term a [Char])] ->
                 (Term a [Char] -> Bool) ->
                   ([Term a [Char]] ->
                     Term a [Char] -> Term a (Sum () [Char])) ->
                     ([Term a [Char]] -> Term a [Char] -> [(b, c)]) ->
                       Sum ([Term a [Char]], (Term a [Char], (b, c))) d ->
                         [Sum ([Term a [Char]], (Term a [Char], (b, c)))
                            ((a, Nat), Nat)];
generate_impl rr nfq e_cap uu (Inr v) = [];
generate_impl rr nfq e_cap uu (Inl (va, (Var ve, vd))) = [];
generate_impl rr nfq e_cap uu (Inl (ss, (Fun f ts, (l, r)))) =
  concatMap
    (\ i ->
      (if membera (uu ss (nth ts i)) (l, r)
        then map (\ u -> u)
               [Inl (ss, (nth ts i, (l, r))), Inr ((f, size_list ts), i)]
        else []))
    (upt zero_nat (size_list ts)) ++
    concatMap
      (\ (la, ra) ->
        concatMap
          (\ mss ->
            (if rule_match_impl nfq (e_cap mss) mss f
                  (map (map_term (\ x -> x)
                         (\ a ->
                           Char False False False True True True True False :
                             a))
                    ts)
                  la
              then (if membera (uu (args la) ra) (l, r)
                     then [Inl (args la, (ra, (l, r)))] else [])
              else []))
          [map (map_term (\ x -> x)
                 (\ a -> Char False False False True True True True False : a))
             ss])
      rr;

mu_approx_impl ::
  forall a.
    (Compare_order a,
      Eq a) => [(Term a [Char], Term a [Char])] ->
                 [([Term a [Char]],
                    (Term a [Char], (Term a [Char], Term a [Char])))] ->
                   ([Term a [Char]] ->
                     Term a [Char] -> [(Term a [Char], Term a [Char])]) ->
                     (Term a [Char] -> Bool) ->
                       ([Term a [Char]] ->
                         Term a [Char] -> Term a (Sum () [Char])) ->
                         ([(a, Nat)], ((a, Nat) -> Set Nat, String));
mu_approx_impl rr initt u_impl nfq e_cap =
  let {
    uu = precompute_fun (\ (a, b) -> u_impl a b) (all_subterms_impl rr initt);
    uua = (\ s t -> uu (s, t));
    fis = remdups
            (concatMap (\ entry -> map (\ fi -> fi) (case entry of {
              Inl _ -> [];
              Inr fi -> [fi];
            }))
              (inductive_set_impl (everything_impl rr initt) equal_sum
                (generate_impl rr nfq e_cap uua) (map Inl initt)));
    fs = remdups (map fst fis);
    mu = (\ f ->
           set (map_filter
                 (\ x ->
                   (if (case x of {
                         (g, _) -> g == f;
                       })
                     then Just (snd x) else Nothing))
                 fis));
  } in (fs, (precompute_fun mu fs, "innermost URM wrt. specific rules"));

inn_usable_rules_wf ::
  forall a.
    (Compare_order a,
      Eq a) => (Term a [Char] -> Bool) ->
                 ([Term a [Char]] -> Term a [Char] -> Term a (Sum () [Char])) ->
                   [(Term a [Char], Term a [Char])] ->
                     Bool ->
                       ([Term a [Char]], Term a [Char]) ->
                         [(Term a [Char], Term a [Char])];
inn_usable_rules_wf nfq e_cap r nfs =
  (\ (ss, t) ->
    (if nfs ||
          all (\ x -> any (contains_var_term x) ss) (remdups (vars_term_list t))
      then ur_calc_singleton nfq e_cap r (ss, t) else r));

inn_usable_rules_wf_dpp ::
  forall a b.
    (Compare_order b,
      Eq b) => Dpp_ops_ext a b [Char] () ->
                 a -> Bool ->
                        ([Term b [Char]], Term b [Char]) ->
                          [(Term b [Char], Term b [Char])];
inn_usable_rules_wf_dpp i d nfs =
  inn_usable_rules_wf (is_QNFc i d) (icap_impl_dpp i d) (rulesf i d) nfs;

get_innermost_strict_repl_map_dpp ::
  forall a b.
    (Compare_order b,
      Eq b) => Dpp_ops_ext a b [Char] () ->
                 a -> [(Term b [Char], Term b [Char])] ->
                        ([(b, Nat)], ((b, Nat) -> Set Nat, String));
get_innermost_strict_repl_map_dpp i d s =
  let {
    r = rulesf i d;
    p = pairsb i d;
    isNF = is_QNFc i d;
    u = inn_usable_rules_wf_dpp i d True;
    a = icap_impl_dpp i d;
  } in mu_approx_impl r
         (concatMap (\ (sa, t) -> map (\ lr -> ([sa], (t, lr))) s) p)
         (\ ss t -> u (ss, t)) isNF a;

showsl_position_set :: forall a. (a, Nat) -> Set Nat -> String -> String;
showsl_position_set f s =
  showsl_list_nat
    (concatMap (\ i -> (if member i s then [suc i] else []))
      (upt zero_nat (snd f)));

mono_af :: forall a b c. Redtriple_ext a b c -> (a, Nat) -> Set Nat;
mono_af
  (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx more) =
  mono_af;

mono_urm_redpair_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Redtriple_ext b [Char] () ->
                      [(Term b [Char], Term b [Char])] ->
                        [(Term b [Char], Term b [Char])] ->
                          a -> Sum (String -> String) a;
mono_urm_redpair_proc i rp premove rremove dpp =
  (case catch_errora
          (case split_pairsa i dpp premove of {
            (ps, pns) ->
              (case split_rulesc i dpp rremove of {
                (rs, rns) ->
                  let {
                    r = rulesf i dpp;
                    _ = qc i dpp;
                    p = pairsb i dpp;
                  } in bindb (check_wf_trs p)
                         (\ _ ->
                           bindb (check_wf_trs r)
                             (\ _ ->
                               bindb (check (nFQ_subset_NF_rulesc i dpp)
                                       (showsl_lit "innermost required"))
                                 (\ _ ->
                                   (case get_innermost_strict_repl_map_dpp i dpp
   rs
                                     of {
                                     (fs, (mu, info)) ->
                                       bindb (valid rp)
 (\ _ ->
   let {
     mua = mono_af rp;
   } in bindb (catch_errora
                (catch_errora
                  (forallM
                    (\ f ->
                      check (subset (mu f) (mua f))
                        (((((showsl_lit
                               "error in monotonicity: strict order for " .
                              showsl_prod f) .
                             showsl_lit " ensures monotonicity in positions ") .
                            showsl_position_set f (mua f)) .
                           showsl_lit "\nbut usable replacement map is ") .
                          showsl_position_set f (mu f)))
                    fs)
                  (\ x -> Inl (snd x)))
                (\ x ->
                  Inl (((((x . showsl_lit
                                 "\nthe computed usable replacement map (") .
                           showsl_literal info) .
                          showsl_lit ") is\n") .
                         showsl_sep
                           (\ f ->
                             ((showsl_lit "mu(" . showsl_prod f) .
                               showsl_lit ") = ") .
                               showsl_position_set f (mu f))
                           (showsl_literal "\n") fs) .
                        showsl_lit "\nand mu(f) = {} for all other symbols f")))
          (\ _ ->
            bindb (catch_errora
                    (catch_errora (forallM (ns rp) rns) (\ x -> Inl (snd x)))
                    (\ x ->
                      Inl (showsl_lit "problem when orienting TRS\n" . x)))
              (\ _ ->
                bindb (catch_errora
                        (catch_errora (forallM (s rp) rs) (\ x -> Inl (snd x)))
                        (\ x ->
                          Inl (showsl_lit "problem when orienting TRS\n" . x)))
                  (\ _ ->
                    bindb (catch_errora
                            (catch_errora (forallM (ns rp) pns)
                              (\ x -> Inl (snd x)))
                            (\ x ->
                              Inl (showsl_lit "problem when orienting DPs\n" .
                                    x)))
                      (\ _ ->
                        catch_errora
                          (catch_errora (forallM (s rp) ps)
                            (\ x -> Inl (snd x)))
                          (\ x ->
                            Inl (showsl_lit "problem when orienting DPs\n" .
                                  x)))))));
                                   }))));
              });
          })
          (\ x ->
            Inl (((showsl_lit
                     "could not apply the reduction pair processor with usable repl. maps and the following\n" .
                    desca rp) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

check_strict_one_rstep ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    ((Term a b, Term a b) ->
                      Maybe [([Nat], ((Term a b, Term a b), Term a b))]) ->
                      ((a, Nat) -> Nat) ->
                        (Term a b, Term a b) -> Sum (String -> String) ();
check_strict_one_rstep ra rseqm p r =
  let {
    s = proj_term p (fst r);
    t = proj_term p (snd r);
  } in (case rseqm r of {
         Nothing -> check_supt s t;
         Just [] ->
           Inl (showsl_lit "more than a single rewrite step is not allowed");
         Just [(pos, (rule, u))] ->
           bindb (check_qrstep (\ _ -> True) False ra pos rule s u)
             (\ _ -> check_supteq u t);
         Just ((_, (_, _)) : _ : _) ->
           Inl (showsl_lit "more than a single rewrite step is not allowed");
       });

check_rsteps ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [([Nat], ((Term a b, Term a b), Term a b))] ->
                      Term a b -> Term a b -> Sum (String -> String) ();
check_rsteps = check_qrsteps (\ _ -> True) False;

rseq_last ::
  forall a b.
    Term a b -> [([Nat], ((Term a b, Term a b), Term a b))] -> Term a b;
rseq_last s steps = last (s : map (\ (_, (_, sa)) -> sa) steps);

check_rsteps_last ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      [([Nat], ((Term a b, Term a b), Term a b))] ->
                        Sum (String -> String) ();
check_rsteps_last = (\ r s steps -> check_rsteps r steps s (rseq_last s steps));

check_strict_rstep ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    ((Term a b, Term a b) ->
                      Maybe [([Nat], ((Term a b, Term a b), Term a b))]) ->
                      ((a, Nat) -> Nat) ->
                        (Term a b, Term a b) -> Sum (String -> String) ();
check_strict_rstep ra rseqm p r =
  let {
    s = proj_term p (fst r);
    t = proj_term p (snd r);
  } in (case rseqm r of {
         Nothing -> check_supt s t;
         Just rseq ->
           (if equal_nat (size_list rseq) zero_nat then check_supt s t
             else bindb (check_rsteps_last ra s rseq)
                    (\ _ -> check_supteq (rseq_last s rseq) t));
       });

create_rseq_map ::
  forall a b.
    (Compare_order a,
      Compare_order b) => [((Term a b, Term a b),
                             [([Nat], ((Term a b, Term a b), Term a b))])] ->
                            (Term a b, Term a b) ->
                              Maybe [([Nat], ((Term a b, Term a b), Term a b))];
create_rseq_map rseqs = ceta_map_of rseqs;

check_weak ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => ((a, Nat) -> Nat) ->
                    (Term a b, Term a b) -> Sum (String -> String) ();
check_weak p r =
  catch_errora
    (check (equal_term (proj_term p (fst r)) (proj_term p (snd r)))
      (showsl_lit "the projected lhs is not equal to the projected rhs\n"))
    (\ x ->
      Inl (((((((showsl_lit "Could not orient rule " . showsl_rule r) .
                 showsl_lit ", since\n") .
                showsl_terma (proj_term p (fst r))) .
               showsl_lit " != ") .
              showsl_terma (proj_term p (snd r))) .
             showsl_literal "\n") .
            x));

subterm_criterion_proc ::
  forall a b c.
    (Compare_order b, Eq b, Showl b, Ccompare c, Compare_order c, Eq c,
      Mapping_impl c,
      Showl c) => Dpp_ops_ext a b c () ->
                    ProjL b ->
                      [((Term b c, Term b c),
                         [([Nat], ((Term b c, Term b c), Term b c))])] ->
                        [(Term b c, Term b c)] -> a -> Sum (String -> String) a;
subterm_criterion_proc i pL rseqmL prm dpp =
  (case let {
          p = create_proj pL;
          rseqm = create_rseq_map rseqmL;
          pa = pairsb i dpp;
          _ = nfsc i dpp;
          r = rulesf i dpp;
          pb = snd (split_pairsa i dpp prm);
          wfR = wf_rules_impl r;
        } in bindb (catch_errora
                     (forallM
                       (\ (l, ra) ->
                         bindb (check_no_var l)
                           (\ _ ->
                             bindb (check_no_var ra)
                               (\ _ ->
                                 check_no_defined_root
                                   (\ fn -> not (null (rules_mapc i dpp fn)))
                                   ra)))
                       pa)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                         (showsl_lit "minimality or innermost required"))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM (\ (l, _) -> check_no_var l) r)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (if q_emptyc i dpp
                                 then catch_errora
(forallM (check_strict_rstep r rseqm p) prm) (\ x -> Inl (snd x))
                                 else catch_errora
(forallM (check_strict_one_rstep wfR rseqm p) prm) (\ x -> Inl (snd x)))
                           (\ _ ->
                             catch_errora (forallM (check_weak p) pb)
                               (\ x -> Inl (snd x))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp prm prm);
  });

replace_paira ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> (Term b c, Term b c) -> [(Term b c, Term b c)] -> a;
replace_paira
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = replace_pair;

forward_instantiation_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    (Term b [Char], Term b [Char]) ->
                      [(Term b [Char], Term b [Char])] ->
                        Maybe [(Term b [Char], Term b [Char])] ->
                          a -> Sum (String -> String) a;
forward_instantiation_proc i st sts u_opt dpp =
  (case let {
          isnf = is_QNFc i dpp;
        } in (case st of {
               (s, t) ->
                 let {
                   iedg = is_iedg_edge_dpp i dpp (s, t);
                   sy = map_term (\ x -> x)
                          (\ a ->
                            Char True False False True True True True False : a)
                          s;
                   ty = map_term (\ x -> x)
                          (\ a ->
                            Char True False False True True True True False : a)
                          t;
                   u = (case u_opt of {
                         Nothing -> rulesf i dpp;
                         Just u -> u;
                       });
                 } in bindb (if is_none u_opt then Inr ()
                              else let {
                                     urc = is_ur_closed_impl_dpp_mv i dpp u;
                                     check_urc =
                                       (\ sa ta ->
 check (urc sa ta)
   ((showsl_lit "term " . showsl_terma ta) .
     showsl_lit " is not closed under usable rules"));
                                   } in bindb
  (check (nfsc i dpp || minimal i dpp)
    (showsl_lit "minimality or normal subst required"))
  (\ _ ->
    bindb (check (nFQ_subset_NF_rulesc i dpp)
            (showsl_lit "innermost rewriting required"))
      (\ _ ->
        bindb (catch_errora (forallM (\ (l, a) -> check_urc (args l) a) u)
                (\ x -> Inl (snd x)))
          (\ _ ->
            bindb (check_urc [s] t)
              (\ _ ->
                (if nfsc i dpp then Inr ()
                  else catch_errora
                         (check_subseteq (vars_term_list t) (vars_term_list s))
                         (\ _ ->
                           Inl (showsl_lit
                                 "variable condition in pair violated"))))))))
                        (\ _ ->
                          let {
                            ur = map (\ (l, r) -> (r, l)) u;
                            ic = icap_impl (is_NF_terms []) ur [];
                          } in catch_errora
                                 (forallM
                                   (\ (ua, v) ->
                                     (case mgu_class (ic ua) t of {
                                       Nothing -> Inr ();
                                       Just mu ->
 check (not (isnf (subst_apply_term sy mu)) ||
         (not (isnf (subst_apply_term
                      (map_term (\ x -> x)
                        (\ a ->
                          Char False False False True True True True False : a)
                        ua)
                      mu)) ||
           any (\ sta ->
                 instance_rule sta st &&
                   instance_rule
                     (subst_apply_term sy mu, subst_apply_term ty mu) sta)
             sts))
   (((showsl_lit "could not find instance of pair " .
       showsl_rule (subst_apply_term sy mu, subst_apply_term ty mu)) .
      showsl_lit "\nwhich resulted from DP ") .
     showsl_rule (ua, v));
                                     }))
                                   (filter (\ (ua, _) -> iedg ua)
                                     (pairsb i dpp)))
                                 (\ x -> Inl (snd x)));
             })
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

check_join ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      [([Nat], ((Term a b, Term a b), Term a b))] ->
                        Term a b ->
                          [([Nat], ((Term a b, Term a b), Term a b))] ->
                            Sum (String -> String) ();
check_join r s sseq t tseq =
  let {
    chk = check_rsteps_last r;
  } in bindb (chk s sseq)
         (\ _ ->
           bindb (chk t tseq)
             (\ _ ->
               let {
                 u = rseq_last s sseq;
                 v = rseq_last t tseq;
               } in check (equal_term u v)
                      (((showsl_lit
                           "the rewrite sequences end in different terms " .
                          showsl_terma u) .
                         showsl_lit " and ") .
                        showsl_terma v)));

check_critical_pairs_guided ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Bool, (Term a b, Term a b))] ->
                      [(Term a b,
                         ([([Nat], ((Term a b, Term a b), Term a b))],
                           (Term a b,
                             [([Nat], ((Term a b, Term a b), Term a b))])))] ->
                        Sum (String -> String) ();
check_critical_pairs_guided r cp joins =
  bindb (catch_errora
          (forallM
            (\ (s, a) ->
              (case a of {
                (sseq, aa) -> (case aa of {
                                (ab, b) -> check_join r s sseq ab b;
                              });
              }))
            joins)
          (\ x -> Inl (snd x)))
    (\ _ ->
      let {
        cpa = map (\ (s, (_, (t, _))) -> (s, t)) joins;
      } in catch_errora
             (forallM
               (\ (_, (s, t)) ->
                 check (equal_term s t ||
                         any (\ st ->
                               instance_rule (s, t) st ||
                                 instance_rule (t, s) st)
                           cpa)
                   ((showsl_lit "critical pair " . showsl_crit_pair (s, t)) .
                     showsl_lit " missing"))
               cp)
             (\ x -> Inl (snd x)));

iterative_join_search_main ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Nat -> Nat -> Bool;
iterative_join_search_main r s t i n =
  (if less_eq_nat i n
    then not (null (list_inter (reachable_terms r s i)
                     (reachable_terms r t i))) ||
           iterative_join_search_main r s t (suc i) n
    else False);

iterative_join_search ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Nat -> Bool;
iterative_join_search r s t n = iterative_join_search_main r s t zero_nat n;

check_join_BFS_limit ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => Nat ->
                    [(Term a b, Term a b)] ->
                      Term a b -> Term a b -> Sum (String -> String) ();
check_join_BFS_limit n r s t =
  check (iterative_join_search r s t n)
    ((((((showsl_literal
            "could not find a joining sequence of length at most " .
           showsl_nat n) .
          showsl_literal " for the terms ") .
         showsl_terma s) .
        showsl_literal " and ") .
       showsl_terma t) .
      showsl_literal "\n");

check_critical_pairs_BFS ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => Nat ->
                    [(Term a b, Term a b)] ->
                      [(Bool, (Term a b, Term a b))] ->
                        Sum (String -> String) ();
check_critical_pairs_BFS n r cp =
  catch_errora
    (forallM
      (\ (_, (s, t)) ->
        (if equal_term s t then Inr ()
          else catch_errora (check_join_BFS_limit n r s t)
                 (\ x ->
                   Inl (((showsl_lit "problem when joining critical pair " .
                           showsl_crit_pair (s, t)) .
                          showsl_literal "\n") .
                         x))))
      cp)
    (\ x -> Inl (snd x));

check_critical_pairs_NF ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Bool, (Term a b, Term a b))] -> Sum (String -> String) ();
check_critical_pairs_NF r cp =
  catch_errora
    (forallM
      (\ (_, (s, t)) ->
        (if equal_term s t then Inr ()
          else catch_errora (check_join_NF r s t)
                 (\ x ->
                   Inl (((showsl_lit "problem when joining critical pair " .
                           showsl_crit_pair (s, t)) .
                          showsl_literal "\n") .
                         x))))
      cp)
    (\ x -> Inl (snd x));

check_critical_pairs ::
  forall a.
    (Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    [(Bool, (Term a [Char], Term a [Char]))] ->
                      Join_info a -> Sum (String -> String) ();
check_critical_pairs r cp join_info =
  (case join_info of {
    Guided a -> check_critical_pairs_guided r cp a;
    Join_NF -> check_critical_pairs_NF r cp;
    Join_BFS n -> check_critical_pairs_BFS n r cp;
  });

switch_innermost_proc ::
  forall a b.
    (Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Join_info b -> a -> Sum (String -> String) a;
switch_innermost_proc i joins_i dpp =
  let {
    r = rwd i dpp;
    p = pb i dpp;
    pw = pwb i dpp;
    nfs = nfsc i dpp;
  } in (case bindb (catch_errora
                     (forallM
                       (\ (l, _) ->
                         check (not (is_Var l))
                           (showsl_lit "left variables in R forbidden"))
                       (if nfs then r else []))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check (minimal i dpp)
                         (showsl_lit "minimality required"))
                   (\ _ ->
                     bindb (check (null (qc i dpp))
                             (showsl_lit "non-empty Q not yet supported"))
                       (\ _ ->
                         bindb (check (null (rd i dpp))
                                 (showsl_lit "strict rules not allowed"))
                           (\ _ ->
                             bindb (check
                                     (null (critical_pairs_impl (p ++ pw) r))
                                     (showsl_lit
                                       "overlaps between P and R not allowed"))
                               (\ _ ->
                                 check_critical_pairs r
                                   (critical_pairs_impl r r) joins_i)))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i nfs True p pw (map fst r) [] r);
       });

mono_redpair_proc ::
  forall a b c.
    (Showl b,
      Showl c) => Dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] -> a -> Sum (String -> String) a;
mono_redpair_proc i rp premove rremove dpp =
  (case catch_errora
          (case split_pairsa i dpp premove of {
            (ps, pns) ->
              (case split_rulesc i dpp rremove of {
                (rs, rns) ->
                  bindb (valid rp)
                    (\ _ ->
                      bindb (catch_errora (mono rp (ps ++ rs ++ pns ++ rns))
                              (\ x ->
                                Inl (showsl_lit
                                       "problem with monotonicity of strict order\n" .
                                      x)))
                        (\ _ ->
                          bindb (catch_errora
                                  (catch_errora (forallM (ns rp) rns)
                                    (\ x -> Inl (snd x)))
                                  (\ x ->
                                    Inl (showsl_lit
   "problem when orienting TRS\n" .
  x)))
                            (\ _ ->
                              bindb (catch_errora
                                      (catch_errora (forallM (s rp) rs)
(\ x -> Inl (snd x)))
                                      (\ x ->
Inl (showsl_lit "problem when orienting TRS\n" . x)))
                                (\ _ ->
                                  bindb (catch_errora
  (catch_errora (forallM (ns rp) pns) (\ x -> Inl (snd x)))
  (\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x)))
                                    (\ _ ->
                                      catch_errora
(catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
(\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x)))))));
              });
          })
          (\ x ->
            Inl (((showsl_lit
                     "could not apply the reduction pair processor with the following\n" .
                    desca rp) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

mk_dpp ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      (Bool,
        (Bool,
          ([(Term b c, Term b c)],
            ([(Term b c, Term b c)],
              ([Term b c],
                ([(Term b c, Term b c)], [(Term b c, Term b c)])))))) ->
        a;
mk_dpp i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkd i nfs m p pw q r rw;

check_assma ::
  forall a b c d e f g.
    (Compare_order b, Countable b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      (a -> d -> Sum (String -> String) ()) ->
                        (c -> e -> Sum (String -> String) ()) ->
                          (([(Ctxt (Lab b [Nat]) [Char],
                               (Term (Lab b [Nat]) [Char], Location))],
                             [(Term (Lab b [Nat]) [Char],
                                Term (Lab b [Nat]) [Char])]) ->
                            f -> Sum (String -> String) ()) ->
                            ([Char] -> g -> Sum (String -> String) ()) ->
                              Generic_assm_proof b [Nat] [Char] d e f () g ->
                                Sum (String -> String) ();
check_assma j i tp_check dp_check fptp_check unk_check (SN_assm_proof t prf) =
  tp_check (mk_tp j t) prf;
check_assma j i tp_check dp_check fptp_check unk_check (Finite_assm_proof t prf)
  = dp_check (mk_dpp i t) prf;
check_assma j i tp_check dp_check fptp_check unk_check
  (Unknown_assm_proof t prf) = unk_check t prf;
check_assma j i tp_check dp_check fptp_check unk_check (SN_FP_assm_proof t prf)
  = fptp_check t prf;
check_assma j i uu uv uw ux (Not_SN_assm_proof v va) =
  Inl (showsl_lit
        "no support for non-termination assumptions in termination proof");
check_assma j i uu uv uw ux (Infinite_assm_proof v va) =
  Inl (showsl_lit
        "no support for non-termination assumptions in termination proof");
check_assma j i uu uv uw ux (Not_RelSN_assm_proof v va) =
  Inl (showsl_lit
        "no support for non-termination assumptions in termination proof");
check_assma j i uu uv uw ux (Not_SN_FP_assm_proof v va) =
  Inl (showsl_lit
        "no support for non-termination assumptions in termination proof");
check_assma j i uu uv uw ux (Complexity_assm_proof v va) =
  Inl (showsl_lit
        "no support for non-termination assumptions in termination proof");

quasi_splitter ::
  forall a b c.
    (Compare a, Eq a, Compare c,
      Eq c) => (a -> (a, b)) ->
                 [(Term a c, Term a c)] ->
                   Set (Term a c, Term a c) ->
                     ([(Term a c, Term a c)],
                       ([(Term a c, Term a c)], [(Term a c, Term a c)]));
quasi_splitter ld lAll uRw =
  let {
    unlab = (\ lf -> fst (ld lf));
    la = map (\ r -> (r, map_funs_rule unlab r)) lAll;
  } in (case partition
               (\ (r, ur) ->
                 equal_term (fst ur) (snd ur) &&
                   not (equal_term (fst r) (snd r)))
               la
         of {
         (d, nD) -> (case partition (\ (_, ur) -> member ur uRw) nD of {
                      (rw, r) -> (map fst r, (map fst rw, map fst d));
                    });
       });

model_splitter ::
  forall a b c.
    (Compare a, Eq a, Compare c,
      Eq c) => (a -> (a, b)) ->
                 [(Term a c, Term a c)] ->
                   Set (Term a c, Term a c) ->
                     ([(Term a c, Term a c)],
                       ([(Term a c, Term a c)], [(Term a c, Term a c)]));
model_splitter ld lAll uRw =
  let {
    unlab = (\ lf -> fst (ld lf));
    la = map (\ r -> (r, map_funs_rule unlab r)) lAll;
  } in (case partition (\ (_, ur) -> member ur uRw) la of {
         (rw, r) -> (map fst r, (map fst rw, []));
       });

check_sl_Q ::
  forall a b c.
    (Eq a, Showl a, Ccompare c, Eq c, Mapping_impl c,
      Showl c) => (a -> (a, b)) ->
                    [Term a c] -> [Term a c] -> Sum (String -> String) ();
check_sl_Q ld lQ q =
  let {
    u = (\ l -> fst (ld l));
  } in catch_errora
         (forallM
           (\ lq ->
             check (let {
                      mlq = map_term u (\ x -> x) lq;
                    } in any (\ qa -> matches mlq qa && matches qa mlq) q)
               ((showsl_lit "unlabeling " . showsl_terma lq) .
                 showsl_lit " yields a term not in Q"))
           lQ)
         (\ x -> Inl (snd x));

sem_lab_quasi_root_proc ::
  forall a b c d.
    (Compare a, Eq a, Showl a, Ceq d, Ccompare d, Compare d, Eq d,
      Mapping_impl d, Set_impl d,
      Showl d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum (String -> String) () ->
                        ([(Term a d, Term a d)] -> Sum (String -> String) ()) ->
                          ([(Term a d, Term a d)] ->
                            Sum (String -> String) ()) ->
                            ([Term a d] ->
                              [Term a d] -> Sum (String -> String) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum (String -> String) ()) ->
                                ([(Term a d, Term a d)] ->
                                  [(Term a d, Term a d)] ->
                                    Sum (String -> String) ()) ->
                                  (Set (Term a d, Term a d) ->
                                    [(Term a d, Term a d)] ->
                                      Sum (String -> String) ()) ->
                                    [(Term a d, Term a d)] ->
                                      [Term a d] ->
[(Term a d, Term a d)] -> c -> Sum (String -> String) c;
sem_lab_quasi_root_proc ld i valid check_decra check_decr check_lhss_more
  check_lab_all check_lab_all_trs check_model_lab lPAll lQ lRAll dpp =
  let {
    r = rd i dpp;
    rw = rwd i dpp;
    pw = pwb i dpp;
    p = pb i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
  } in (case model_splitter ld lPAll (set pw) of {
         (lP, (lPw, _)) ->
           (case quasi_splitter ld lRAll (set rw) of {
             (lR, (lRw, d)) ->
               let {
                 qempty = q_emptyc i dpp;
               } in (case bindb valid
                            (\ _ ->
                              bindb (check
                                      (if nfs
then (if not qempty then wwf_rulesa i dpp else True) else True)
                                      (showsl_lit "well formedness required"))
                                (\ _ ->
                                  bindb (catch_errora
  (forallM
    (\ (l, ra) ->
      bindb (check_no_var l)
        (\ _ ->
          bindb (check_no_var ra)
            (\ _ ->
              check_no_defined_root (\ fn -> not (null (rules_mapc i dpp fn)))
                ra)))
    (pairsb i dpp))
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora (forallM (\ (l, _) -> check_no_var l) (rulesf i dpp))
  (\ x -> Inl (snd x)))
(\ _ ->
  let {
    q = qc i dpp;
  } in bindb (if nfs && not qempty then check_wf_trs d else Inr ())
         (\ _ ->
           bindb (check_decra d)
             (\ _ ->
               bindb (check_decr d)
                 (\ _ ->
                   bindb (catch_errora
                           (forallM
                             (\ qa ->
                               check (linear_term qa)
                                 (showsl_lit
                                   "Q must not contain non-linear terms"))
                             q)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       catch_errora
                         (bindb (check_lhss_more lQ q)
                           (\ _ ->
                             bindb (check_sl_Q ld lQ q)
                               (\ _ ->
                                 bindb (check_lab_all (set lP) p)
                                   (\ _ ->
                                     bindb (check_lab_all (set lPw) pw)
                                       (\ _ ->
 bindb (check_model_lab (set lR) r)
   (\ _ ->
     bindb (check_model_lab (set lRw) rw)
       (\ _ ->
         bindb (check_lab_all_trs lR r) (\ _ -> check_lab_all_trs lRw rw))))))))
                         (\ x ->
                           Inl (showsl_lit "problem during labeling:\n" .
                                 x))))))))))
                      of {
                      Inl a -> Inl a;
                      Inr _ -> Inr (mkd i nfs m lP lPw lQ lR (lRw ++ d));
                    });
           });
       });

eval_lab ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> Nat -> c -> d) -> (e -> b) -> Term a e -> (b, Term d e);
eval_lab i l lc alpha (Var x) = (alpha x, Var x);
eval_lab i l lc alpha (Fun f ts) =
  let {
    clts = map (eval_lab i l lc alpha) ts;
    cs = map fst clts;
    c = i f cs;
    lts = map snd clts;
  } in (c, Fun (lc f (size_list ts) (l f cs)) lts);

check_sl_rule_ass ::
  forall a b c d e.
    (Showl a, Showl b, Compare d, Eq d, Showl d, Compare e, Eq e,
      Showl e) => Bool ->
                    (a -> [b] -> b) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          (b -> b -> Bool) ->
                            Set (Term d e, Term d e) ->
                              (e -> b) ->
                                (Term a e, Term a e) ->
                                  Sum (String -> String) ();
check_sl_rule_ass mc i la lc cge lR alpha (l, r) =
  let {
    cl_ll = eval_lab i la lc alpha l;
    cr_lr = eval_lab i la lc alpha r;
  } in bindb (check (if mc then cge (fst cl_ll) (fst cr_lr) else True)
               (((((showsl_lit "rule " . showsl_rule (l, r)) .
                    showsl_lit " violates the model condition, [lhs] = ") .
                   showsl (fst cl_ll)) .
                  showsl_lit ", [rhs] = ") .
                 showsl (fst cr_lr)))
         (\ _ ->
           check (member (snd cl_ll, snd cr_lr) lR)
             ((showsl_lit "labeled rule " .
                showsl_rule (snd cl_ll, snd cr_lr)) .
               showsl_lit " missing"));

check_sl_rule ::
  forall a b c d e.
    (Showl a, Showl b, Compare d, Eq d, Showl d, Compare e, Eq e,
      Showl e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> d) ->
                        [b] ->
                          (b -> b -> Bool) ->
                            Bool ->
                              Set (Term d e, Term d e) ->
                                (Term a e, Term a e) ->
                                  Sum (String -> String) ();
check_sl_rule i l lc c cge mc lR lr =
  catch_errora
    (forallM (\ alpha -> check_sl_rule_ass mc i l lc cge lR alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_model_lab_trs_set ::
  forall a b c d.
    (Compare a, Eq a, Showl a, Showl b, Compare d, Eq d,
      Showl d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum (String -> String) ();
check_sl_model_lab_trs_set i l c cge labl lR r =
  catch_errora (forallM (check_sl_rule i l labl c cge True lR) r)
    (\ x -> Inl (snd x));

check_sl_model_lab_trs ::
  forall a b c d.
    (Compare a, Eq a, Showl a, Showl b, Compare d, Eq d,
      Showl d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum (String -> String) ();
check_sl_model_lab_trs i l c cge labl lR r =
  check_sl_model_lab_trs_set i l c cge labl lR r;

check_NF_vars_subset ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_vars_subset qa q =
  catch_errora (forallM (\ qaa -> check (any (matches qaa) q) qaa) qa)
    (\ x -> Inl (snd x));

flatten_term_enum :: forall a b. Term [a] b -> [Term a b];
flatten_term_enum (Var x) = [Var x];
flatten_term_enum (Fun fs ts) = let {
                                  lts = map flatten_term_enum ts;
                                  ss = concat_lists lts;
                                } in concatMap (\ f -> map (Fun f) ss) fs;

lab_lhss_more_impl ::
  forall a b c d.
    (a -> Nat -> b -> c) -> (a -> Nat -> [b]) -> [Term a d] -> [Term c d];
lab_lhss_more_impl lc lS_gen q =
  let {
    f_all = (\ (f, n) -> map (lc f n) (lS_gen f n));
  } in concatMap (\ qa -> flatten_term_enum (map_funs_term_wa f_all qa)) q;

check_sl_lab_lhss_more ::
  forall a b c.
    (Eq a, Showl a, Ccompare c, Eq c, Mapping_impl c,
      Showl c) => (a -> Nat -> b -> a) ->
                    (a -> Nat -> [b]) ->
                      [Term a c] -> [Term a c] -> Sum (String -> String) ();
check_sl_lab_lhss_more lc lS_gen lQ q =
  catch_errora (check_NF_vars_subset (lab_lhss_more_impl lc lS_gen q) lQ)
    (\ x -> Inl (showsl_terma x . showsl_lit " is missing in labeled Q"));

sl_check_decr ::
  forall a b c d e.
    Sl_ops_ext a b c d e -> [(Term a d, Term a d)] -> Sum (String -> String) ();
sl_check_decr
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_check_decr;

lab_root ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> [b] -> c) ->
          (a -> Nat -> c -> d) -> (e -> b) -> Term a e -> Term d e;
lab_root i la l lc alpha (Fun f ts) = let {
clts = map (eval_lab i la lc alpha) ts;
cs = map fst clts;
a = map snd clts;
                                      } in Fun (lc f (size_list ts) (l f cs)) a;
lab_root uu uv uw ux uy (Var x) = Var x;

check_sl_rule_all_ass ::
  forall a b c d e.
    (Showl a, Showl b, Compare d, Eq d, Showl d, Compare e, Eq e,
      Showl e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          (c -> [c]) ->
                            Set (Term d e, Term d e) ->
                              (e -> b) ->
                                (Term a e, Term a e) ->
                                  Sum (String -> String) ();
check_sl_rule_all_ass i lb la lc gen_smaller lR alpha (l, Fun f ts) =
  let {
    ll = lab_root i lb la lc alpha l;
    clts = map (eval_lab i lb lc alpha) ts;
    lts = map snd clts;
    ld = la f (map fst clts);
    n = size_list ts;
    small = gen_smaller ld;
  } in catch_errora
         (forallM
           (\ le ->
             check (member (ll, Fun (lc f n le) lts) lR)
               ((showsl_lit "labeled rule " .
                  showsl_rule (ll, Fun (lc f n le) lts)) .
                 showsl_lit " missing"))
           small)
         (\ x -> Inl (snd x));
check_sl_rule_all_ass i lb la lc gen_smaller lR alpha (l, Var x) =
  let {
    ll = lab_root i lb la lc alpha l;
    lr = lab_root i lb la lc alpha (Var x);
  } in check (member (ll, lr) lR)
         ((showsl_lit "labeled rule " . showsl_rule (ll, lr)) .
           showsl_lit " missing");

check_sl_rule_all ::
  forall a b c d e.
    (Showl a, Showl b, Compare d, Eq d, Showl d, Compare e, Eq e,
      Showl e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          [b] ->
                            (c -> [c]) ->
                              Set (Term d e, Term d e) ->
                                (Term a e, Term a e) ->
                                  Sum (String -> String) ();
check_sl_rule_all i la l lc c gen_smaller lR lr =
  catch_errora
    (forallM
      (\ alpha -> check_sl_rule_all_ass i la l lc gen_smaller lR alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_lab_all_trs ::
  forall a b c d e.
    (Showl a, Showl b, Compare d, Eq d, Showl d, Compare e, Eq e,
      Showl e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        [b] ->
                          (c -> [c]) ->
                            (a -> Nat -> c -> d) ->
                              Set (Term d e, Term d e) ->
                                [(Term a e, Term a e)] ->
                                  Sum (String -> String) ();
check_sl_lab_all_trs i la l c gen labl lP p =
  catch_errora (forallM (check_sl_rule_all i la l labl c gen lP) p)
    (\ x -> Inl (snd x));

check_wf_sym_F_all ::
  forall a b c.
    (Eq c,
      Showl c) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        (c, Nat) -> Sum (String -> String) ();
check_wf_sym_F_all lc ld ls =
  (\ (lf, n) ->
    (case ld lf of {
      (f, l) ->
        check (ls f n l && lf == lc f n l)
          ((showsl_lit "labeled symbol " . showsl lf) .
            showsl_lit " not allowed");
    }));

check_wf_terms_F_all ::
  forall a b c d.
    (Eq c,
      Showl c) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        Term c d -> Sum (String -> String) ();
check_wf_terms_F_all lc ld ls lt =
  let {
    lfs = insert_funas_term lt [];
  } in catch_errora (forallM (check_wf_sym_F_all lc ld ls) lfs)
         (\ x -> Inl (snd x));

check_Lab_all_trs ::
  forall a b c.
    (Eq a, Showl a, Eq c,
      Showl c) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        [(Term a c, Term a c)] ->
                          [(Term a c, Term a c)] -> Sum (String -> String) ();
check_Lab_all_trs lc ld ls lR r =
  catch_errora
    (forallM
      (\ (l, ra) ->
        catch_errora
          (bindb (check_wf_terms_F_all lc ld ls ra)
            (\ _ ->
              check (membera r (map_funs_rule (\ lf -> fst (ld lf)) (l, ra)))
                (showsl_lit
                  "unlabeling of the rule does not yield original rule")))
          (\ x ->
            Inl (((showsl_lit "problem with labeled rule" .
                    showsl_rule (l, ra)) .
                   showsl_literal "\n") .
                  x)))
      lR)
    (\ x -> Inl (snd x));

sl_LS_gen :: forall a b c d e. Sl_ops_ext a b c d e -> a -> Nat -> [c];
sl_LS_gen
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_LS_gen;

sl_lgen :: forall a b c d e. Sl_ops_ext a b c d e -> c -> [c];
sl_lgen
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_lgen;

lge_to_lgr ::
  forall a b.
    (Eq b) => (a -> Nat -> b -> b -> Bool) ->
                (a -> Nat -> b -> Bool) -> a -> Nat -> b -> b -> Bool;
lge_to_lgr lge ls f n =
  let {
    lSfn = ls f n;
    lgefn = lge f n;
  } in (\ l la -> not (l == la) && lSfn l && lSfn la && lgefn l la);

check_sl_decr_rule ::
  forall a b c d.
    (Eq a, Eq b, Eq c,
      Eq d) => (a -> Nat -> b -> c) ->
                 (c -> (a, b)) ->
                   (a -> Nat -> b -> Bool) ->
                     (a -> Nat -> b -> b -> Bool) ->
                       (Term c d, Term c d) -> Bool;
check_sl_decr_rule lc ld ls lge (Fun lf ts, Fun lg us) =
  (case ld lf of {
    (f, l1) ->
      (case ld lg of {
        (g, l2) ->
          let {
            n = size_list ts;
          } in f == g &&
                 ts == us &&
                   lf == lc f n l1 &&
                     lg == lc f n l2 &&
                       ls f n l1 && ls f n l2 && lge_to_lgr lge ls f n l1 l2;
      });
  });
check_sl_decr_rule uu uv uw ux (Var vb, va) = False;
check_sl_decr_rule uu uv uw ux (v, Var vb) = False;

check_sl_decr ::
  forall a b c d.
    (Eq a, Eq b, Eq c, Showl c, Eq d,
      Showl d) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        (a -> Nat -> b -> b -> Bool) ->
                          [(Term c d, Term c d)] -> Sum (String -> String) ();
check_sl_decr lc ld ls lge d =
  catch_errora
    (forallM
      (\ lr ->
        check (check_sl_decr_rule lc ld ls lge lr)
          (showsl_rule lr . showsl_lit " is not a decreasing rule"))
      d)
    (\ x -> Inl (snd x));

sl_La :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> c;
sl_La (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
        sl_LS_gen more)
  = sl_L;

sl_LS :: forall a b c d e. Sl_ops_ext a b c d e -> a -> Nat -> c -> Bool;
sl_LS (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
        sl_LS_gen more)
  = sl_LSa;

sl_L :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> c;
sl_L (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_La;

sl_I :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> b;
sl_I (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_I;

sl_C :: forall a b c d e. Sl_ops_ext a b c d e -> [b];
sl_C (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_C;

insert_funas_args_term ::
  forall a b. (Eq a) => Term a b -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_term t fs = foldr insert_funas_term (args t) fs;

insert_funas_args_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_rule r fs =
  insert_funas_args_term (fst r) (insert_funas_args_term (snd r) fs);

insert_funas_args_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_trs trs = foldr insert_funas_args_rule trs;

option_to_list :: forall a. Maybe a -> [a];
option_to_list (Just a) = [a];
option_to_list Nothing = [];

insert_roots_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_roots_rule r fs =
  foldr insertb (option_to_list (root (fst r)) ++ option_to_list (root (snd r)))
    fs;

insert_roots_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_roots_trs trs = foldr insert_roots_rule trs;

sem_lab_fin_quasi_root_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showl a, Eq b, Showl c, Ceq e, Ccompare e, Compare e,
      Eq e, Mapping_impl e, Set_impl e,
      Showl e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      (c -> c -> Bool) ->
                        (a -> Nat -> b -> b -> Bool) ->
                          Dpp_ops_ext d a e () ->
                            ([(a, Nat)] ->
                              [(a, Nat)] ->
                                Sum (String -> String)
                                  (Sl_ops_ext a c b e ())) ->
                              [(Term a e, Term a e)] ->
                                [Term a e] ->
                                  [(Term a e, Term a e)] ->
                                    d -> Sum (String -> String) d;
sem_lab_fin_quasi_root_proc lc ld cge lge i gen lPAll lQ lRAll dp =
  let {
    pairs = pairsb i dp;
  } in bindb (gen (list_union (insert_funas_trs (rulesf i dp) [])
                    (insert_funas_args_trs pairs []))
               (insert_roots_trs pairs []))
         (\ ops ->
           let {
             check_d = sl_check_decr ops;
             check_da = check_sl_decr lc ld (sl_LS ops) lge;
             check_q = check_sl_lab_lhss_more lc (sl_LS_gen ops);
             check_ml =
               check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) cge lc;
             check_l =
               check_sl_lab_all_trs (sl_I ops) (sl_L ops) (sl_La ops) (sl_C ops)
                 (sl_lgen ops) lc;
             check_la = check_Lab_all_trs lc ld (sl_LS ops);
           } in sem_lab_quasi_root_proc ld i (Inr ()) check_d check_da check_q
                  check_l check_la check_ml lPAll lQ lRAll dp);

check_sl_rule_root ::
  forall a b c d e.
    (Showl a, Showl b, Compare d, Eq d, Showl d, Compare e, Eq e,
      Showl e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          [b] ->
                            Set (Term d e, Term d e) ->
                              (Term a e, Term a e) -> Sum (String -> String) ();
check_sl_rule_root i la l lc c lR lr =
  catch_errora
    (forallM
      (\ alpha ->
        let {
          laa = lab_root i la l lc alpha;
          lb = laa (fst lr);
          r = laa (snd lr);
        } in check (member (lb, r) lR)
               ((showsl_lit "labeled rule " . showsl_rule (lb, r)) .
                 showsl_lit " is missing"))
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_lab_root_trs ::
  forall a b c d e.
    (Showl a, Showl b, Compare d, Eq d, Showl d, Compare e, Eq e,
      Showl e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        [b] ->
                          (a -> Nat -> c -> d) ->
                            Set (Term d e, Term d e) ->
                              [(Term a e, Term a e)] ->
                                Sum (String -> String) ();
check_sl_lab_root_trs i la l c labl lP p =
  catch_errora (forallM (check_sl_rule_root i la l labl c lP) p)
    (\ x -> Inl (snd x));

sem_lab_root_proc ::
  forall a b c d.
    (Compare a, Eq a, Showl a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showl d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum (String -> String) () ->
                        ([Term a d] ->
                          [Term a d] -> Sum (String -> String) ()) ->
                          (Set (Term a d, Term a d) ->
                            [(Term a d, Term a d)] ->
                              Sum (String -> String) ()) ->
                            ([(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum (String -> String) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum (String -> String) ()) ->
                                [(Term a d, Term a d)] ->
                                  [Term a d] ->
                                    [(Term a d, Term a d)] ->
                                      c -> Sum (String -> String) c;
sem_lab_root_proc ld i valid check_Q check_laba check_lab check_model_lab lPAll
  lQ lRAll dpp =
  let {
    r = rd i dpp;
    rw = rwd i dpp;
    pw = pwb i dpp;
    p = pb i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
  } in (case model_splitter ld lPAll (set pw) of {
         (lP, (lPw, _)) ->
           (case model_splitter ld lRAll (set rw) of {
             (lR, (lRw, _)) ->
               (case bindb valid
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM
                                   (\ (l, ra) ->
                                     bindb (check_no_var l)
                                       (\ _ ->
 bindb (check_no_var ra)
   (\ _ ->
     check_no_defined_root (\ fn -> not (null (rules_mapc i dpp fn))) ra)))
                                   (pairsb i dpp))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             bindb (catch_errora
                                     (forallM (\ (l, _) -> check_no_var l)
                                       (rulesf i dpp))
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 let {
                                   q = qc i dpp;
                                 } in catch_errora
(bindb
  (check
    (if nfs then (if not (q_emptyc i dpp) then wwf_rulesa i dpp else True)
      else True)
    (showsl_lit "well formedness required"))
  (\ _ ->
    bindb (check_Q lQ q)
      (\ _ ->
        bindb (check_sl_Q ld lQ q)
          (\ _ ->
            bindb (check_laba (set lP) p)
              (\ _ ->
                bindb (check_laba (set lPw) pw)
                  (\ _ ->
                    bindb (check_model_lab (set lR) r)
                      (\ _ ->
                        bindb (check_model_lab (set lRw) rw)
                          (\ _ ->
                            bindb (check_lab lR r)
                              (\ _ -> check_lab lRw rw)))))))))
(\ x -> Inl (showsl_lit "problem during labeling:\n" . x)))))
                 of {
                 Inl a -> Inl a;
                 Inr _ -> Inr (mkd i nfs m lP lPw lQ lR lRw);
               });
           });
       });

lab_rule_ass ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> Nat -> c -> d) ->
          (e -> b) -> (Term a e, Term a e) -> (Term d e, Term d e);
lab_rule_ass i l lc alpha rule =
  (snd (eval_lab i l lc alpha (fst rule)),
    snd (eval_lab i l lc alpha (snd rule)));

lab_rule_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) ->
                    [b] -> (Term a e, Term a e) -> [(Term d e, Term d e)];
lab_rule_list i l lc c lr =
  map (\ alpha -> lab_rule_ass i l lc alpha lr)
    (map fun_of (enum_vectors c (insert_vars_rule lr [])));

lab_trs_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) ->
                    [b] -> [(Term a e, Term a e)] -> [(Term d e, Term d e)];
lab_trs_list i l lc c r = concatMap (lab_rule_list i l lc c) r;

check_sl_lab ::
  forall a b c d.
    (Eq a, Showl a, Eq d,
      Showl d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> a) ->
                        [b] ->
                          [(Term a d, Term a d)] ->
                            [(Term a d, Term a d)] -> Sum (String -> String) ();
check_sl_lab i l lc c lR r =
  bindb (check (not (null c)) (showsl_lit "carrier must be non-empty"))
    (\ _ ->
      catch_errora (check_subseteq lR (lab_trs_list i l lc c r))
        (\ x ->
          Inl ((showsl_lit "labeled rule " . showsl_rule x) .
                showsl_lit " is not allowed")));

lab_lhs_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) -> [b] -> Term a e -> [Term d e];
lab_lhs_list i l lc c t =
  map (\ alpha -> snd (eval_lab i l lc alpha t))
    (map fun_of (enum_vectors c (insert_vars_term t [])));

lab_lhss_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) -> [b] -> [Term a e] -> [Term d e];
lab_lhss_list i l lc c q = concatMap (lab_lhs_list i l lc c) q;

check_sl_Qa ::
  forall a b c d.
    (Eq a, Showl a, Ccompare d, Eq d, Mapping_impl d,
      Showl d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> a) ->
                        [b] ->
                          [Term a d] -> [Term a d] -> Sum (String -> String) ();
check_sl_Qa i l lc c lQ q =
  bindb (check (not (null c)) (showsl_lit "carrier must be non-empty"))
    (\ _ ->
      catch_errora (check_NF_vars_subset (lab_lhss_list i l lc c q) lQ)
        (\ x ->
          Inl ((showsl_lit "labeled term " . showsl_terma x) .
                showsl_lit " is missing")));

sem_lab_fin_root_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showl a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showl d, Eq e,
      Showl e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      Dpp_ops_ext c a d () ->
                        ([(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum (String -> String) (Sl_ops_ext a e b d ())) ->
                          [(Term a d, Term a d)] ->
                            [Term a d] ->
                              [(Term a d, Term a d)] ->
                                c -> Sum (String -> String) c;
sem_lab_fin_root_proc lc ld i gen lPAll lQ lRAll dp =
  let {
    pairs = pairsb i dp;
  } in bindb (gen (list_union (insert_funas_trs (rulesf i dp) [])
                    (insert_funas_args_trs pairs []))
               (insert_roots_trs pairs []))
         (\ ops ->
           let {
             check_q = check_sl_Qa (sl_I ops) (sl_L ops) lc (sl_C ops);
             check_ml =
               check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops)
                 (\ a b -> a == b) lc;
             check_l =
               check_sl_lab_root_trs (sl_I ops) (sl_L ops) (sl_La ops)
                 (sl_C ops) lc;
             check_la = check_sl_lab (sl_I ops) (sl_L ops) lc (sl_C ops);
           } in sem_lab_root_proc ld i (Inr ()) check_q check_l check_la
                  check_ml lPAll lQ lRAll dp);

slm_La :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> c;
slm_La (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_L;

slm_c :: forall a b c d. Slm_ops_ext a b c d -> b;
slm_c (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_c;

slm_L :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> c;
slm_L (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_La;

slm_I :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> b;
slm_I (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_I;

slm_C :: forall a b c d. Slm_ops_ext a b c d -> [b];
slm_C (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_C;

slm_to_sl :: forall a b c d. Slm_ops_ext a b c () -> Sl_ops_ext a b c d ();
slm_to_sl ops =
  Sl_ops_ext (slm_L ops) (\ _ _ _ -> True) (slm_I ops) (slm_C ops) (slm_c ops)
    (\ _ -> Inr ()) (slm_La ops) (\ _ _ _ -> True) (\ l -> [l]) (\ _ _ -> [])
    ();

slm_gen_to_sl_gen ::
  forall a b c d.
    ([(a, Nat)] ->
      [(a, Nat)] -> Sum (String -> String) (Slm_ops_ext a b c ())) ->
      [(a, Nat)] ->
        [(a, Nat)] -> Sum (String -> String) (Sl_ops_ext a b c d ());
slm_gen_to_sl_gen gen =
  (\ f g -> bindb (gen f g) (\ ops -> Inr (slm_to_sl ops)));

check_sl_lab_trs_set ::
  forall a b c d.
    (Compare a, Eq a, Showl a, Showl b, Compare d, Eq d,
      Showl d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum (String -> String) ();
check_sl_lab_trs_set i l c cge labl lP p =
  catch_errora (forallM (check_sl_rule i l labl c cge False lP) p)
    (\ x -> Inl (snd x));

check_sl_lab_trs ::
  forall a b c d.
    (Compare a, Eq a, Showl a, Showl b, Compare d, Eq d,
      Showl d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum (String -> String) ();
check_sl_lab_trs i l c cge labl lP p = check_sl_lab_trs_set i l c cge labl lP p;

sem_lab_proc ::
  forall a b c d.
    (Compare a, Eq a, Showl a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showl d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum (String -> String) () ->
                        ([Term a d] ->
                          [Term a d] -> Sum (String -> String) ()) ->
                          (Set (Term a d, Term a d) ->
                            [(Term a d, Term a d)] ->
                              Sum (String -> String) ()) ->
                            ([(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum (String -> String) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum (String -> String) ()) ->
                                [(Term a d, Term a d)] ->
                                  [Term a d] ->
                                    [(Term a d, Term a d)] ->
                                      c -> Sum (String -> String) c;
sem_lab_proc ld i valid check_Q check_laba check_lab check_model_lab lPAll lQ
  lRAll dpp =
  let {
    r = rd i dpp;
    rw = rwd i dpp;
    pw = pwb i dpp;
    p = pb i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
  } in (case model_splitter ld lPAll (set pw) of {
         (lP, (lPw, _)) ->
           (case model_splitter ld lRAll (set rw) of {
             (lR, (lRw, _)) ->
               (case bindb valid
                       (\ _ ->
                         let {
                           q = qc i dpp;
                         } in catch_errora
                                (bindb
                                  (check
                                    (if nfs
                                      then (if not (q_emptyc i dpp)
     then wwf_rulesa i dpp else True)
                                      else True)
                                    (showsl_lit "well formedness required"))
                                  (\ _ ->
                                    bindb (check_Q lQ q)
                                      (\ _ ->
bindb (check_sl_Q ld lQ q)
  (\ _ ->
    bindb (check_laba (set lP) p)
      (\ _ ->
        bindb (check_laba (set lPw) pw)
          (\ _ ->
            bindb (check_model_lab (set lR) r)
              (\ _ ->
                bindb (check_model_lab (set lRw) rw)
                  (\ _ ->
                    bindb (check_lab lR r) (\ _ -> check_lab lRw rw)))))))))
                                (\ x ->
                                  Inl (showsl_lit "problem during labeling:\n" .
x)))
                 of {
                 Inl a -> Inl a;
                 Inr _ -> Inr (mkd i nfs m lP lPw lQ lR lRw);
               });
           });
       });

sem_lab_fin_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showl a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showl d, Eq e,
      Showl e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      Dpp_ops_ext c a d () ->
                        ([(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum (String -> String) (Sl_ops_ext a e b d ())) ->
                          [(Term a d, Term a d)] ->
                            [Term a d] ->
                              [(Term a d, Term a d)] ->
                                c -> Sum (String -> String) c;
sem_lab_fin_proc lc ld i gen lPAll lQ lRAll dp =
  bindb (gen (list_union (insert_funas_trs (rulesf i dp) [])
               (insert_funas_args_trs (pairsb i dp) []))
          [])
    (\ ops ->
      let {
        check_q = check_sl_Qa (sl_I ops) (sl_L ops) lc (sl_C ops);
        check_ml =
          check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops)
            (\ a b -> a == b) lc;
        check_l =
          check_sl_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) (\ a b -> a == b)
            lc;
        check_la = check_sl_lab (sl_I ops) (sl_L ops) lc (sl_C ops);
      } in sem_lab_proc ld i (Inr ()) check_q check_l check_la check_ml lPAll lQ
             lRAll dp);

get_largest_element :: forall a. Sl_inter a -> Nat;
get_largest_element (SL_Inter n uu) = n;

take_default :: forall a. a -> [a] -> Nat -> a;
take_default def [] uu = def;
take_default uv (x : xs) i =
  (if equal_nat i zero_nat then x
    else take_default uv xs (minus_nat i one_nat));

eval_arithFun :: Nat -> [Nat] -> ArithFun -> Nat;
eval_arithFun c nats f = modulo_nat (eval_arithFun_unbound c nats f) c;

eval_arithFun_unbound :: Nat -> [Nat] -> ArithFun -> Nat;
eval_arithFun_unbound c nats (Arg i) = take_default zero_nat nats i;
eval_arithFun_unbound c nats (Const n) = n;
eval_arithFun_unbound c nats (Sum []) = zero_nat;
eval_arithFun_unbound c nats (Sum (f : fs)) =
  plus_nat (eval_arithFun c nats f) (eval_arithFun c nats (Sum fs));
eval_arithFun_unbound c nats (Prod []) = one_nat;
eval_arithFun_unbound c nats (Prod (f : fs)) =
  times_nat (eval_arithFun c nats f) (eval_arithFun c nats (Prod fs));
eval_arithFun_unbound c nats (Max [f]) = eval_arithFun c nats f;
eval_arithFun_unbound c nats (Max (f : v : va)) =
  max (eval_arithFun c nats f) (eval_arithFun c nats (Max (v : va)));
eval_arithFun_unbound c nats (Min [f]) = eval_arithFun c nats f;
eval_arithFun_unbound c nats (Min (f : v : va)) =
  min (eval_arithFun c nats f) (eval_arithFun c nats (Min (v : va)));
eval_arithFun_unbound c nats (IfEqual f1 f2 ft fe) =
  (if equal_nat (eval_arithFun c nats f1) (eval_arithFun c nats f2)
    then eval_arithFun c nats ft else eval_arithFun c nats fe);

sl_inter_to_inter :: forall a. (Eq a) => Sl_inter a -> a -> [Nat] -> Nat;
sl_inter_to_inter (SL_Inter c ls) fl cs =
  (case map_of ls (fl, size_list cs) of {
    Nothing -> zero_nat;
    Just a -> eval_arithFun (suc c) cs a;
  });

sli_to_slm ::
  forall a.
    (Eq a) => Sl_inter (Lab a [Nat]) ->
                Slm_ops_ext (Lab a [Nat]) Nat (Sum [Nat] [Lab a [Nat]]) ();
sli_to_slm sli =
  let {
    c = get_largest_element sli;
  } in Slm_ops_ext (\ _ -> Inl) (sl_inter_to_inter sli) (upt zero_nat (suc c)) c
         (\ _ -> Inl) ();

enum_vectors_nat :: forall a. [a] -> Nat -> [[a]];
enum_vectors_nat c n =
  (if equal_nat n zero_nat then [[]]
    else let {
           a = enum_vectors_nat c (minus_nat n one_nat);
         } in concatMap (\ vec -> map (\ ca -> ca : vec) c) a);

qmodel_check_interpretation ::
  ArithFun -> Nat -> Nat -> Sum (String -> String) ();
qmodel_check_interpretation f n c =
  let {
    ca = upt zero_nat (suc c);
    css = enum_vectors_nat ca n;
  } in catch_errora
         (forallM
           (\ cs ->
             catch_errora
               (forallM
                 (\ i ->
                   catch_errora
                     (forallM
                       (\ l ->
                         check (less_eq_nat (eval_arithFun (suc c) cs f)
                                 (eval_arithFun (suc c) (list_update cs i l) f))
                           ((showsl_lit "not monotone in " .
                              showsl_nat (suc i)) .
                             showsl_lit ". argument"))
                       (upt (nth cs i) (suc c)))
                     (\ x -> Inl (snd x)))
                 (upt zero_nat n))
               (\ x -> Inl (snd x)))
           css)
         (\ x -> Inl (snd x));

qmodel_check_valid ::
  forall a. (Showl a) => Sl_inter a -> Sum (String -> String) ();
qmodel_check_valid (SL_Inter c ls) =
  catch_errora
    (forallM
      (\ (a, b) ->
        (case a of {
          (f, n) ->
            (\ g ->
              catch_errora (qmodel_check_interpretation g n c)
                (\ x ->
                  Inl (((showsl_lit
                           "problem in weak-monotonicity of interpretation of " .
                          showsl f) .
                         showsl_literal "\n") .
                        x)));
        })
          b)
      ls)
    (\ x -> Inl (snd x));

check_decr_present_aux_1 ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a (b, Nat), Term a (b, Nat))] ->
                           b -> a -> a -> Nat ->
    Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present_aux_1 r v f1 f2 n =
  let {
    vs = map (\ na -> Var (v, na)) (upt zero_nat n);
    rule = (Fun f1 vs, Fun f2 vs);
  } in check (not (is_none (find (instance_rule rule) r))) rule;

check_decr_present_aux_2 ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           b -> [(a, (a, Nat))] ->
                                  Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present_aux_2 r v req =
  let {
    add_nats = map_term (\ x -> x) (\ va -> (va, zero_nat));
    ra = map (\ (l, ra) -> (add_nats l, add_nats ra)) r;
  } in catch_errora
         (forallM
           (\ (f1, a) -> (case a of {
                           (aa, b) -> check_decr_present_aux_1 ra v f1 aa b;
                         }))
           req)
         (\ x -> Inl (snd x));

check_decr_present ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(a, Nat)] ->
                           (a -> [Nat] -> a) ->
                             b -> Nat ->
                                    [(Term a b, Term a b)] ->
                                      Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present sig l v c r =
  let {
    ca = upt zero_nat (suc c);
    ls = (\ (f, n) ->
           concatMap
             (\ cs ->
               concatMap
                 (\ i ->
                   let {
                     ci = nth cs i;
                   } in (if less_nat ci c
                          then [(l f (list_update cs i (suc ci)), (l f cs, n))]
                          else []))
                 (upt zero_nat n))
             (enum_vectors_nat ca n));
  } in check_decr_present_aux_2 r v (concatMap ls sig);

qmodel_check_decr ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b,
      Mapping_impl b) => [(Lab a [Nat], Nat)] ->
                           b -> Nat ->
                                  [(Term (Lab a [Nat]) b,
                                     Term (Lab a [Nat]) b)] ->
                                    Sum (String -> String) ();
qmodel_check_decr sig v c =
  (\ lR ->
    catch_errora (check_decr_present sig Lab v c lR)
      (\ x ->
        Inl (let {
               display =
                 map_term (\ xa -> xa)
                   (\ (_, n) ->
                     (shows_prec_list zero_nat
                        [Char False False False True True True True False] .
                       shows_prec_nat zero_nat n)
                       []);
             } in (showsl_lit "decreasing rule " .
                    showsl_rule (display (fst x), display (snd x))) .
                    showsl_lit " missing")));

qmodel_LS_gen ::
  forall a b c. (Eq a) => [(a, Nat)] -> [b] -> a -> Nat -> [Sum [b] c];
qmodel_LS_gen sig ls =
  (\ f n ->
    (if membera sig (f, n) then map Inl (enum_vectors_nat ls n) else [Inl []]));

pointwise_lgen :: [Nat] -> [[Nat]];
pointwise_lgen ns = concat_lists (map (\ n -> upt zero_nat (suc n)) ns);

qmodel_lgen :: forall a. Sum [Nat] a -> [Sum [Nat] a];
qmodel_lgen l = (case l of {
                  Inl ns -> map Inl (pointwise_lgen ns);
                  Inr _ -> [];
                });

qmodel_LSa :: forall a. Lab a [Nat] -> Nat -> Sum [Nat] [Lab a [Nat]] -> Bool;
qmodel_LSa = (\ _ _ a -> (case a of {
                           Inl _ -> True;
                           Inr _ -> False;
                         }));

qmodel_LS ::
  forall a b c.
    (Eq a, Eq b, Eq c) => [(a, Nat)] -> [b] -> a -> Nat -> Sum [b] c -> Bool;
qmodel_LS sig ls = (\ f n -> membera (qmodel_LS_gen sig ls f n));

qmodel_L ::
  forall a b c d.
    (Eq a, Eq b) => [(Lab a b, Nat)] -> Lab a b -> [c] -> Sum [c] d;
qmodel_L sig =
  (\ f cs -> (if membera sig (f, size_list cs) then Inl cs else Inl []));

qsli_to_sl_unsafe ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Showl b) => a -> [(Lab b [Nat], Nat)] ->
                         [(Lab b [Nat], Nat)] ->
                           Sl_inter (Lab b [Nat]) ->
                             Sl_ops_ext (Lab b [Nat]) Nat
                               (Sum [Nat] [Lab b [Nat]]) a ();
qsli_to_sl_unsafe v f g sli =
  let {
    c = get_largest_element sli;
    ca = upt zero_nat (suc c);
  } in Sl_ops_ext (qmodel_L f) (qmodel_LS f ca) (sl_inter_to_inter sli) ca c
         (qmodel_check_decr f v c) (qmodel_L g) qmodel_LSa qmodel_lgen
         (qmodel_LS_gen f ca) ();

qsli_to_sl ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Showl b) => a -> [(Lab b [Nat], Nat)] ->
                         [(Lab b [Nat], Nat)] ->
                           Sl_inter (Lab b [Nat]) ->
                             Sum (String -> String)
                               (Sl_ops_ext (Lab b [Nat]) Nat
                                 (Sum [Nat] [Lab b [Nat]]) a ());
qsli_to_sl v f g sli =
  bindb (qmodel_check_valid sli) (\ _ -> Inr (qsli_to_sl_unsafe v f g sli));

pointwise_ext ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
pointwise_ext f [] [] = (False, True);
pointwise_ext f (uu : uv) [] = (False, False);
pointwise_ext f [] (uw : ux) = (False, False);
pointwise_ext f (a : asa) (b : bs) =
  (case f a b of {
    (stri, True) -> (case pointwise_ext f asa bs of {
                      (strir, True) -> (stri || strir, True);
                      (_, False) -> (False, False);
                    });
    (_, False) -> (False, False);
  });

qmodel_lge :: forall a b c d. a -> b -> Sum [Nat] c -> Sum [Nat] d -> Bool;
qmodel_lge f n =
  (\ l r ->
    (case (l, r) of {
      (Inl cs1, Inl cs2) ->
        snd (pointwise_ext (\ x y -> (less_nat y x, less_eq_nat y x)) cs1 cs2);
      (Inl _, Inr _) -> False;
      (Inr _, _) -> False;
    }));

qmodel_cge :: Nat -> Nat -> Bool;
qmodel_cge = (\ x y -> less_eq_nat y x);

rl_slm ::
  forall a b.
    (Eq a,
      Eq b) => Maybe (Lab a b, Nat) ->
                 [(Lab a b, Nat)] ->
                   [(Lab a b, Nat)] ->
                     Sum (String -> String)
                       (Slm_ops_ext (Lab a b) (Lab a b) (Sum b [Lab a b]) ());
rl_slm delt_opt pre_fs g =
  let {
    fs = (if is_none delt_opt then pre_fs
           else filter (\ f -> not (f == the delt_opt)) pre_fs);
  } in bindb (check (not (null fs))
               (showsl_lit
                 "root-labeling requires at least one function symbol in the signature\n"))
         (\ _ ->
           let {
             f = fst (hda fs);
           } in Inr (Slm_ops_ext (\ _ -> Inr)
                      (\ ga cs ->
                        (if membera fs (ga, size_list cs) then ga else f))
                      (map fst fs) f
                      (if is_none delt_opt then (\ _ -> Inr)
                        else (\ _ gs ->
                               Inr (replicate (size_list gs)
                                     (fst (the delt_opt)))))
                      ()));

semlab_fin_proc ::
  forall a b c.
    (Compare b, Eq b, Showl b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showl c) => Dpp_ops_ext a (Lab b [Nat]) c () ->
                    Sl_variant (Lab b [Nat]) c ->
                      [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                        [Term (Lab b [Nat]) c] ->
                          [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                            a -> Sum (String -> String) a;
semlab_fin_proc j (Rootlab Nothing) =
  sem_lab_fin_proc label label_decomp j (slm_gen_to_sl_gen (rl_slm Nothing));
semlab_fin_proc j (Rootlab (Just d)) =
  sem_lab_fin_root_proc label label_decomp j
    (slm_gen_to_sl_gen (rl_slm (Just d)));
semlab_fin_proc j (Finitelab sli) =
  sem_lab_fin_proc label label_decomp j
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli)));
semlab_fin_proc j (QuasiFinitelab sli v) =
  sem_lab_fin_quasi_root_proc label label_decomp qmodel_cge qmodel_lge j
    (\ f g -> qsli_to_sl v f g sli);

partition_rules ::
  forall a b.
    (Eq a,
      Eq b) => [Ctxt a b] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     ([(Term a b, Term a b)], [(Term a b, Term a b)]);
partition_rules cs r =
  partition
    (\ lr ->
      any (\ (u, v) ->
            any (\ c -> lr == (ctxt_apply_term c u, ctxt_apply_term c v))
              (Hole : cs))
        r);

strip_unary_root :: forall a b. (Eq a) => a -> Term a b -> Term a b;
strip_unary_root f (Fun g [t]) = (if f == g then t else Fun g [t]);
strip_unary_root f (Var v) = Var v;
strip_unary_root f (Fun v []) = Fun v [];
strip_unary_root f (Fun v (vb : vd : ve)) = Fun v (vb : vd : ve);

has_unary_root :: forall a b. (Eq a) => a -> Term a b -> Bool;
has_unary_root f (Fun g [t]) = f == g;
has_unary_root f (Var v) = False;
has_unary_root f (Fun v []) = False;
has_unary_root f (Fun v (vb : vd : ve)) = False;

unblock_term :: forall a b. (Eq a) => a -> Term a b -> Term a b;
unblock_term f (Fun g ts) =
  (if all (has_unary_root f) ts then Fun g (map (strip_unary_root f) ts)
    else Fun g ts);
unblock_term f (Var v) = Var v;

unblock_rule ::
  forall a b. (Eq a) => a -> (Term a b, Term a b) -> (Term a b, Term a b);
unblock_rule f r = (unblock_term f (fst r), unblock_term f (snd r));

partition_pairs ::
  forall a b.
    (Eq a,
      Eq b) => a -> [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]);
partition_pairs f p = partition (\ r -> membera p (unblock_rule f r));

check_no_defined_root_defined ::
  forall a b.
    (Eq a, Showl a,
      Showl b) => [(a, Nat)] -> Term a b -> Sum (String -> String) ();
check_no_defined_root_defined f t =
  check (not (membera f (the (root t))))
    ((showsl_lit "the root of " . showsl_terma t) . showsl_lit " is defined");

block_term :: forall a b. a -> Term a b -> Term a b;
block_term f (Var x) = Var x;
block_term f (Fun g ts) = Fun g (map (\ t -> Fun f [t]) ts);

block_rule :: forall a b. a -> (Term a b, Term a b) -> (Term a b, Term a b);
block_rule f r = (block_term f (fst r), block_term f (snd r));

check_superset_of_blocked ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => a -> [(Term a b, Term a b)] ->
                         [(Term a b, Term a b)] -> Sum (String -> String) ();
check_superset_of_blocked f pa p =
  catch_errora
    (catch_errora
      (catch_errora
        (forallM
          (\ x -> (if membera pa (block_rule f x) then Inr () else Inl x)) p)
        (\ x -> Inl (snd x)))
      (\ x ->
        Inl ((showsl_lit "the rule " . showsl_rule (block_rule f x)) .
              showsl_lit " is missing\n")))
    (\ x ->
      Inl ((((showsl_trs p . showsl_lit "is not a subset of") . showsl_trs pa) .
             x) .
            showsl_literal "\n"));

hole_at :: forall a b. (Eq a) => Nat -> Nat -> a -> Ctxt a b -> Bool;
hole_at n i f (More g ss1 Hole ss2) =
  g == f &&
    equal_nat (size_list ss1) i &&
      equal_nat (size_list ss2) (minus_nat (minus_nat n i) one_nat);
hole_at n i f Hole = False;
hole_at n i f (More v va (More vd ve vf vg) vc) = False;

check_flat_ctxt_complete ::
  forall a b.
    (Eq a, Showl a,
      Showl b) => [Ctxt a b] -> (a, Nat) -> Sum (String -> String) ();
check_flat_ctxt_complete fcs fa =
  check (all_interval_nat (\ i -> any (hole_at (snd fa) i (fst fa)) fcs)
          zero_nat (snd fa))
    (showsl_lit "the list of flat contexts is incomplete\n");

check_rule_reflecting ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => [Ctxt a b] ->
                    [(Term a b, Term a b)] ->
                      (Term a b, Term a b) -> Sum (String -> String) ();
check_rule_reflecting fcs rs rule =
  check (any (\ (l, r) ->
               any (\ c ->
                     equal_term (fst rule) (ctxt_apply_term c l) &&
                       equal_term (snd rule) (ctxt_apply_term c r))
                 (Hole : fcs))
          rs)
    ((showsl_lit "the rule " . showsl_rule rule) .
      showsl_lit
        " is neither contained in the original set of rules nor obtained by applying a flat context\n");

check_rule_preserving ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [Ctxt a b] ->
                    [(Term a b, Term a b)] ->
                      (Term a b, Term a b) -> Sum (String -> String) ();
check_rule_preserving fcs rs rule =
  check (any (instance_rule rule) rs ||
          all (\ c ->
                any (instance_rule
                      (ctxt_apply_term c (fst rule),
                        ctxt_apply_term c (snd rule)))
                  rs)
            fcs)
    ((showsl_lit "the rule " . showsl_rule rule) .
      showsl_lit
        " is neither contained in the resulting set of rules nor closed under all flat contexts\n");

is_flat_ctxt_list ::
  forall a b. (Eq a, Eq b) => [a] -> [(b, Nat)] -> Ctxt b a -> Bool;
is_flat_ctxt_list vs fas (More f ss1 Hole ss2) =
  let {
    ss = ss1 ++ ss2;
  } in membera fas (f, suc (size_list ss)) &&
         all is_Var ss && distinct ss && null (list_inter (map the_Var ss) vs);
is_flat_ctxt_list vs fas Hole = False;
is_flat_ctxt_list vs fas (More v va (More vd ve vf vg) vc) = False;

showsl_ctxta :: forall a b. (Showl a, Showl b) => Ctxt a b -> String -> String;
showsl_ctxta t = showsl_ctxt showsl showsl t;

check_is_flat_ctxt ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => [a] -> [(b, Nat)] -> Ctxt b a -> Sum (String -> String) ();
check_is_flat_ctxt vs fas c =
  check (is_flat_ctxt_list vs fas c)
    (showsl_ctxta c . showsl_lit " is not a flat context\n");

check_flat_ctxt ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => [a] -> Ctxt b a -> Sum (String -> String) ();
check_flat_ctxt vs c =
  (case c of {
    Hole -> Inl (showsl_ctxta c . showsl_lit " is not a flat context\n");
    More _ ss1 Hole ss2 ->
      let {
        ss = ss1 ++ ss2;
      } in bindb (check (distinct ss)
                   (showsl_ctxta c .
                     showsl_lit " contains duplicate variables\n"))
             (\ _ ->
               bindb (check (all is_Var ss)
                       (showsl_ctxta c .
                         showsl_lit
                           " is not flat, i.e., has depth greater than one\n"))
                 (\ _ ->
                   check (all (\ t -> not (membera vs (the_Var t)))
                           (ss1 ++ ss2))
                     (showsl_ctxta c .
                       showsl_lit " has to contain only fresh variables\n")));
    More _ _ (More _ _ _ _) _ ->
      Inl (showsl_ctxta c . showsl_lit " is not a flat context\n");
  });

showsl_terms :: forall a. (Showl a) => String -> [a] -> String -> String;
showsl_terms name ts =
  (showsl_lit name . showsl_literal "\n") .
    showsl_list_gen showsl "" "" "\n" "" ts;

showsl_dpp ::
  forall a b c.
    (Showl b, Showl c) => Dpp_ops_ext a b c () -> a -> String -> String;
showsl_dpp i d =
  let {
    m = minimal i d;
    nfs = nfsc i d;
    p = pb i d;
    pw = pwb i d;
    r = rd i d;
    rw = rwd i d;
    q = qc i d;
  } in (((((showsl_trsa showsl showsl "pairs:" " -> " p .
             (if null pw then id
               else showsl_trsa showsl showsl "weak pairs:" " ->= " pw)) .
            (if null r then id
              else showsl_trsa showsl showsl "strict rules:" " ->! " r)) .
           showsl_trsa showsl showsl "rules:" " -> " rw) .
          (if null q then id else showsl_terms "Q-component:" q)) .
         (if m then showsl_lit "\n(minimal)" else id)) .
         (if nfs && not (null q) then showsl_lit "\n(normal form substitutions)"
           else id);

fcc_proc_cond ::
  forall a b c.
    (Eq b, Showl b, Ccompare c, Eq c, Mapping_impl c,
      Showl c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               [(Term b c, Term b c)] ->
                                 [(Term b c, Term b c)] ->
                                   a -> Sum (String -> String) a;
fcc_proc_cond i f fcs p pw r rw dpp =
  let {
    pa = pb i dpp;
    pwa = pwb i dpp;
    ra = rd i dpp;
    rwa = rwd i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    new_dpp = mkd i nfs m p pw [] r rw;
  } in (case catch_errora
               (let {
                  pba = list_union pa pwa;
                  rb = list_union ra rwa;
                  rba = list_union r rw;
                  fa = (f, one_nat);
                  cf = More f [] Hole [];
                  fcsa = cf : fcs;
                  vs = vars_trs_list rb;
                  fs = list_union (funas_trs_list rb) (funas_args_trs_list pba);
                  fas = fa : fs;
                  ds = defined_list rb;
                } in bindb (check (not (membera ds fa))
                             (showsl f . showsl_lit "is not fresh\n"))
                       (\ _ ->
                         bindb (check_wf_trs rb)
                           (\ _ ->
                             bindb (catch_errora
                                     (forallM
                                       (\ rc ->
 bindb (bindb (check_no_var (fst rc)) (\ _ -> check_no_var (snd rc)))
   (\ _ -> check_no_defined_root_defined ds (snd rc)))
                                       pba)
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 bindb (catch_errora
 (forallM (check_flat_ctxt vs) fcsa) (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (catch_errora
     (forallM (check_is_flat_ctxt vs fas) fcsa) (\ x -> Inl (snd x)))
                                       (\ _ ->
 bindb (catch_errora (forallM (check_flat_ctxt_complete fcsa) fas)
         (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (catch_errora (forallM (check_rule_preserving fcsa r) ra)
             (\ x -> Inl (snd x)))
       (\ _ ->
         bindb (catch_errora (forallM (check_rule_preserving fcsa rba) rwa)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             bindb (catch_errora (forallM (check_rule_reflecting fcsa rb) rba)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check_superset_of_blocked f p pa)
                   (\ _ -> check_superset_of_blocked f pw pwa)))))))))))
               (\ x ->
                 Inl (((((showsl_lit
                            "problem when checking flat context closure conditions to switch from\n" .
                           showsl_dpp i dpp) .
                          showsl_lit "\nto the DP problem\n") .
                         showsl_dpp i new_dpp) .
                        showsl_literal "\n") .
                       x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr new_dpp;
       });

g_to_list_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> [a];
g_to_list_dflt_basic_oops_rm_basic_ops s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ _ -> True)
    (\ a b -> a : b) [];

delete_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
delete_rm_basic_ops x s = delete x s;

ceta_list_diff :: forall a. (Compare_order a) => [a] -> [a] -> [a];
ceta_list_diff xs ys =
  g_to_list_dflt_basic_oops_rm_basic_ops
    (foldl (\ a b -> delete_rm_basic_ops b a)
      (g_from_list_dflt_basic_oops_rm_basic_ops xs) ys);

fcc_split_proc ::
  forall a b c.
    (Compare_order b, Eq b, Showl b, Ceq c, Ccompare c, Compare_order c, Eq c,
      Mapping_impl c, Set_impl c,
      Showl c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               [(Term b c, Term b c)] ->
                                 [(Term b c, Term b c)] ->
                                   a -> Sum (String -> String) (a, a);
fcc_split_proc i f fcs pba rb ps rs dpp =
  let {
    p = pb i dpp;
    pw = pwb i dpp;
    r = rd i dpp;
    rw = rwd i dpp;
    q = qc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    pbaa = list_union p pw;
    rba = rw;
    pns = ceta_list_diff pbaa ps;
    rns = ceta_list_diff rba rs;
  } in (case partition_pairs f ps pba of {
         (pa, pwa) ->
           (case partition_rules (More f [] Hole [] : fcs) rs rb of {
             (ra, rwa) ->
               let {
                 two = mkd i nfs m (ceta_list_diff p ps) (ceta_list_diff pw ps)
                         [] [] rns;
                 dpp_mid = mkd i nfs m ps pns [] rs rns;
               } in bindb (bindb
                            (catch_errora (check_subseteq ps pbaa)
                              (\ x ->
                                Inl ((showsl_lit "pair " . showsl_rule x) .
                                      showsl_lit
" should be deleted but is not present")))
                            (\ _ ->
                              bindb (catch_errora (check_subseteq rs rba)
                                      (\ x ->
Inl ((showsl_lit "rule " . showsl_rule x) .
      showsl_lit " should be deleted but is not present")))
                                (\ _ ->
                                  bindb (check (null q)
  (showsl_lit "Q is not empty\n"))
                                    (\ _ ->
                                      bindb
(check (null r) (showsl_lit "strict rules not allowed\n"))
(\ _ ->
  bindb (check_left_linear_trs rw)
    (\ _ -> fcc_proc_cond i f fcs pa pwa ra rwa dpp_mid))))))
                      (\ one -> Inr (one, two));
           });
       });

instantiation_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    (Term b [Char], Term b [Char]) ->
                      [(Term b [Char], Term b [Char])] ->
                        a -> Sum (String -> String) a;
instantiation_proc i st sts dpp =
  (case let {
          ic = icap_impl_dpp_mv i dpp;
          isnf = is_QNFc i dpp;
        } in (case st of {
               (s, t) ->
                 let {
                   sy = map_term (\ x -> x)
                          (\ a ->
                            Char True False False True True True True False : a)
                          s;
                   ty = map_term (\ x -> x)
                          (\ a ->
                            Char True False False True True True True False : a)
                          t;
                   iedg = is_iedg_edge_dpp i dpp;
                 } in catch_errora
                        (forallM
                          (\ (u, v) ->
                            (case mgu_class (ic [u] v) s of {
                              Nothing -> Inr ();
                              Just mu ->
                                check (not (isnf (subst_apply_term sy mu)) ||
(not (isnf (subst_apply_term
             (map_term (\ x -> x)
               (\ a -> Char False False False True True True True False : a) u)
             mu)) ||
  any (\ sta ->
        instance_rule sta st &&
          instance_rule (subst_apply_term sy mu, subst_apply_term ty mu) sta)
    sts))
                                  (((showsl_lit
                                       "could not find instance of pair " .
                                      showsl_rule
(subst_apply_term sy mu, subst_apply_term ty mu)) .
                                     showsl_lit "\nwhich resulted from DP ") .
                                    showsl_rule (u, v));
                            }))
                          (filter (\ (u, v) -> iedg (u, v) s) (pairsb i dpp)))
                        (\ x -> Inl (snd x));
             })
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

intersect_pairsb ::
  forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_pairsb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = intersect_pairs;

graph_approx_rt_sym_main ::
  forall a b c.
    (Ccompare a, Eq a) => Multimap (Maybe (a, Nat)) b -> Gctxt a c -> [b];
graph_approx_rt_sym_main m (GCFun f ts) =
  lookupc m Nothing ++ lookupc m (Just (f, size_list ts));
graph_approx_rt_sym_main m GCHole = valuesa m;

graph_approx_rt_sym ::
  forall a b c d e f.
    (Ccompare a,
      Eq a) => Multimap (Maybe (a, Nat)) b -> (c, (d, (Gctxt a e, f))) -> [b];
graph_approx_rt_sym m (uu, (uv, (ct, uw))) = graph_approx_rt_sym_main m ct;

rules_non_collapsinga :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
rules_non_collapsinga
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_non_collapsing;

reverse_rules_mapb ::
  forall a b c d.
    Dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
reverse_rules_mapb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = reverse_rules_map;

reverse_tcapRM_dpp ::
  forall a b c.
    (Eq b, Eq c) => Dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
reverse_tcapRM_dpp i dpp =
  tcapRM (rules_non_collapsinga i dpp) (reverse_rules_mapb i dpp);

tcapRM_dpp ::
  forall a b c.
    (Eq b, Eq c) => Dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
tcapRM_dpp i dpp = tcapRM (rules_no_left_vara i dpp) (rules_mapc i dpp);

check_no_back_edges ::
  forall a b.
    (a -> String -> String) ->
      (b -> a -> [a]) ->
        (a -> b -> b) ->
          ((a, a) -> Bool) -> b -> [[a]] -> Sum (String -> String) ();
check_no_back_edges ss candidates add_index g i [] = Inr ();
check_no_back_edges ss candidates add_index g i (asa : cs) =
  bindb (catch_errora
          (forallM
            (\ a ->
              catch_errora (forallM (check_no_edge ss g a) (candidates i a))
                (\ x -> Inl (snd x)))
            asa)
          (\ x -> Inl (snd x)))
    (\ _ ->
      check_no_back_edges ss candidates add_index g (foldr add_index asa i) cs);

check_graph_decomp ::
  forall a b.
    (a -> String -> String) ->
      b -> (b -> a -> [a]) ->
             (a -> b -> b) ->
               ((a, a) -> Bool) -> [(Bool, [a])] -> Sum (String -> String) ();
check_graph_decomp ss empty_index candidates add_index g rcs =
  bindb (check_no_back_edges ss candidates add_index g empty_index
          (map snd rcs))
    (\ _ ->
      catch_errora
        (forallM (\ c -> check_edges ss g c c)
          (map_filter (\ x -> (if not (fst x) then Just (snd x) else Nothing))
            rcs))
        (\ x -> Inl (snd x)));

check_dep_graph_proc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b, Mapping_impl b,
      Set_impl b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    a -> [(Maybe c, [(Term b [Char], Term b [Char])])] ->
                           Sum (String -> String) ();
check_dep_graph_proc i dpp dps =
  let {
    c = tcapRM_dpp i dpp;
    rc = reverse_tcapRM_dpp i dpp;
    iedg = is_iedg_edge_dpp i dpp;
    p = pairsb i dpp;
    r = rulesf i dpp;
    f = funas_trs_list r;
    gt_fun = mk_gt_fun r;
    rm = rules_mapc i dpp;
    nlv = rules_no_left_vara i dpp;
  } in bindb (catch_errora (check_subseteq p (concatMap snd dps))
               (\ x ->
                 Inl ((showsl_lit "Dependency Pair " . showsl_rule x) .
                       showsl_lit " is missing in decomposition\n")))
         (\ _ ->
           catch_errora
             (check_graph_decomp (showsl_prod . fst)
               (emptyd ((root . fst) . fst)) graph_approx_rt_sym insertd
               (\ (a, b) ->
                 (case a of {
                   (aa, ba) ->
                     (case aa of {
                       (_, t) ->
                         (\ (_, (ct, ict)) (ab, bb) ->
                           (case ab of {
                             (u, _) ->
                               (\ (cu, (_, _)) ->
                                 matchb ct u &&
                                   matchb cu t &&
                                     ict u &&
                                       not
 (nonreachable_gtcapRM f nlv (not (null r)) gt_fun rm t u));
                           })
                             bb);
                     })
                       ba;
                 })
                   b)
               (map (\ (real, cs) ->
                      (not (is_none real),
                        map (\ (s, t) -> ((s, t), (rc s, (c t, iedg (s, t)))))
                          cs))
                 dps))
             (\ x ->
               Inl ((showsl_lit
                       "our estimation (EDG*** + IEDG***) could not show that you have a valid decomposition " .
                      showsl_lit "due to the following reason\n") .
                     x)));

dep_graph_proc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b, Mapping_impl b,
      Set_impl b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    a -> [(Maybe c, [(Term b [Char], Term b [Char])])] ->
                           Sum (String -> String) [(c, a)];
dep_graph_proc i d dps =
  (case check_dep_graph_proc i d dps of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (map_filter
            (\ x ->
              (if not (is_none (fst x))
                then Just (the (fst x), intersect_pairsb i d (snd x))
                else Nothing))
            dps);
  });

check_NF_terms_subset ::
  forall a b. (Term a b -> Bool) -> [Term a b] -> Sum (Term a b) ();
check_NF_terms_subset is_Q_nf =
  (\ q ->
    catch_errora
      (forallM (\ x -> (if not (is_Q_nf x) then Inr () else Inl x)) q)
      (\ x -> Inl (snd x)));

check_NF_terms_eq ::
  forall a b.
    (Compare_order a, Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_terms_eq qa q =
  bindb (check_NF_terms_subset (is_NF_terms qa) q)
    (\ _ -> check_NF_terms_subset (is_NF_terms q) qa);

check_dpp_subsumes ::
  forall a b c d.
    (Compare_order b, Eq b, Showl b, Compare_order c, Eq c, Showl c, Ccompare d,
      Eq d, Mapping_impl d,
      Showl d) => Dpp_ops_ext a (Lab b c) d () ->
                    (Bool,
                      (Bool,
                        ([(Term (Lab b c) d, Term (Lab b c) d)],
                          ([(Term (Lab b c) d, Term (Lab b c) d)],
                            ([Term (Lab b c) d],
                              ([(Term (Lab b c) d, Term (Lab b c) d)],
                                [(Term (Lab b c) d, Term (Lab b c) d)])))))) ->
                      a -> Sum (String -> String) ();
check_dpp_subsumes i (nfs, (m, (p, (pw, (q, (r, rw)))))) d =
  catch_errora
    (let {
       pa = pb i d;
       pwa = pwb i d;
       qa = qc i d;
       ra = rd i d;
       rwa = rwd i d;
       nfsa = nfsc i d;
       ma = minimal i d;
       pba = p ++ pw;
       rb = ra ++ rwa;
       rba = r ++ rw;
     } in bindb (check (ma == m) (showsl_lit "incompatible minimality flags"))
            (\ _ ->
              bindb (check (nfsa == nfs)
                      (showsl_lit
                        "incompatible substitutions-in-normal-form flags"))
                (\ _ ->
                  bindb (catch_errora (check_subseteq pa p)
                          (\ x -> Inl (toomuch "pair" (showsl_rule x))))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq pwa pba)
                              (\ x ->
                                Inl (toomuch "weak pair" (showsl_rule x))))
                        (\ _ ->
                          bindb (catch_errora (check_NF_terms_eq qa q)
                                  (\ x ->
                                    Inl (showsl_lit
   "NF(Q) differs due to term " .
  showsl_terma x)))
                            (\ _ ->
                              bindb (catch_errora (check_subseteq ra r)
                                      (\ x ->
Inl (toomuch "strict rule" (showsl_rule x))))
                                (\ _ ->
                                  bindb (catch_errora (check_subseteq rb rba)
  (\ x -> Inl (toomuch "strict/weak rule" (showsl_rule x))))
                                    (\ _ ->
                                      bindb
(catch_errora (check_subseteq rba rb)
  (\ x -> Inl (missing "strict/weak rule" (showsl_rule x))))
(\ _ -> Inr ())))))))))
    (\ x ->
      Inl ((((((showsl_lit "finiteness of the problem\n" . showsl_dpp i d) .
                showsl_lit
                  "\nmay not be concluded from assuming finiteness of the problem\n") .
               showsl_dpp i (mkd i nfs m p pw q r rw)) .
              showsl_literal "\n") .
             x) .
            showsl_literal "\n"));

fcc_proc ::
  forall a b c.
    (Eq b, Showl b, Ceq c, Ccompare c, Eq c, Mapping_impl c, Set_impl c,
      Showl c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               a -> Sum (String -> String) a;
fcc_proc i f fcs pba rw dpp =
  let {
    p = pb i dpp;
    q = qc i dpp;
    r = rd i dpp;
  } in (case partition_pairs f p pba of {
         (pa, pw) ->
           bindb (check (null q) (showsl_lit "Q is not empty"))
             (\ _ ->
               bindb (check (null r) (showsl_lit "strict rules not allowed"))
                 (\ _ ->
                   bindb (check_left_linear_trs (rwd i dpp))
                     (\ _ -> fcc_proc_cond i f fcs pa pw [] rw dpp)));
       });

q_reduction_proc_non_min ::
  forall a b c.
    (Showl b,
      Showl c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum (String -> String) a;
q_reduction_proc_non_min i q dpp =
  (case catch_errora
          (bindb
            (catch_errora (check_NF_terms_subset (is_QNFc i dpp) q)
              (\ x ->
                Inl ((showsl_lit "the term " . showsl_terma x) .
                      showsl_lit " is not allowed in Q\' ")))
            (\ _ -> Inr ()))
          (\ x ->
            Inl (((((showsl_lit "problem when reducing Q in the DP problem\n" .
                      showsl_dpp i dpp) .
                     showsl_lit "\nto the set\n") .
                    showsl_terms "Q\':" q) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (mkd i (nfsc i dpp) False (pb i dpp) (pwb i dpp) q (rd i dpp)
            (rwd i dpp));
  });

q_reduction_proc_min_inn ::
  forall a b c.
    (Compare_order b, Eq b, Showl b, Ccompare c, Eq c, Mapping_impl c,
      Showl c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum (String -> String) a;
q_reduction_proc_min_inn i q dpp =
  let {
    pba = pairsb i dpp;
    rb = rulesf i dpp;
    f = map Just (funas_trs_list (pba ++ rb));
    qa = qc i dpp;
    isnf = is_QNFc i dpp;
    qq = filter (\ qb -> all isnf (args qb)) qa;
    rQ = filter (\ qb -> membera f (root qb)) qq;
  } in (case catch_errora
               (bindb
                 (check (nFQ_subset_NF_rulesc i dpp)
                   (showsl_lit "innermost rewriting required"))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       bindb (catch_errora
                               (check_NF_terms_subset (is_NF_terms q) rQ)
                               (\ x ->
                                 Inl ((showsl_lit "the term " .
showsl_terma x) .
                                       showsl_lit " is missing in Q\' ")))
                         (\ _ ->
                           bindb (catch_errora
                                   (check_NF_terms_subset (is_NF_terms qq) q)
                                   (\ x ->
                                     Inl ((showsl_lit "the term " .
    showsl_terma x) .
   showsl_lit " is not allowed in Q\' ")))
                             (\ _ ->
                               (if nfsc i dpp then Inr ()
                                 else check_varcond_subset pba))))))
               (\ x ->
                 Inl (((((showsl_lit
                            "problem when reducing Q in the DP problem\n" .
                           showsl_dpp i dpp) .
                          showsl_lit "\nto the set\n") .
                         showsl_terms "Q\':" q) .
                        showsl_literal "\n") .
                       x))
         of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (mkd i (nfsc i dpp) (minimal i dpp) (pb i dpp) (pwb i dpp) q
                 (rd i dpp) (rwd i dpp));
       });

q_reduction_proc ::
  forall a b c.
    (Compare_order b, Eq b, Showl b, Ccompare c, Eq c, Mapping_impl c,
      Showl c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum (String -> String) a;
q_reduction_proc i q dpp = (case q_reduction_proc_min_inn i q dpp of {
                             Inl _ -> q_reduction_proc_non_min i q dpp;
                             Inr a -> Inr a;
                           });

get_fcc_option ::
  forall a b c.
    Dp_termination_proof a b c ->
      Maybe (Lab a b,
              ([Ctxt (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  ([(Term (Lab a b) c, Term (Lab a b) c)],
                    Dp_termination_proof a b c))));
get_fcc_option (Fcc_Proc f fcs pb rb prf) = Just (f, (fcs, (pb, (rb, prf))));
get_fcc_option P_is_Empty = Nothing;
get_fcc_option (Subterm_Criterion_Proc v va vb vc) = Nothing;
get_fcc_option (Gen_Subterm_Criterion_Proc v va vb) = Nothing;
get_fcc_option (Redpair_Proc v va vb) = Nothing;
get_fcc_option (Redpair_UR_Proc v va vb vc) = Nothing;
get_fcc_option (Usable_Rules_Proc v va) = Nothing;
get_fcc_option (Dep_Graph_Proc v) = Nothing;
get_fcc_option (Mono_Redpair_Proc v va vb vc) = Nothing;
get_fcc_option (Mono_URM_Redpair_Proc v va vb vc) = Nothing;
get_fcc_option (Mono_Redpair_UR_Proc v va vb vc vd) = Nothing;
get_fcc_option (Size_Change_Subterm_Proc v) = Nothing;
get_fcc_option (Size_Change_Redpair_Proc v va vb) = Nothing;
get_fcc_option (Uncurry_Proc v va vb vc vd) = Nothing;
get_fcc_option (Split_Proc v va vb vc) = Nothing;
get_fcc_option (Semlab_Proc v va vb vc vd) = Nothing;
get_fcc_option (Switch_Innermost_Proc v va) = Nothing;
get_fcc_option (Rewriting_Proc v va vb vc vd ve vf) = Nothing;
get_fcc_option (Instantiation_Proc v va vb) = Nothing;
get_fcc_option (Forward_Instantiation_Proc v va vb vc) = Nothing;
get_fcc_option (Narrowing_Proc v va vb vc) = Nothing;
get_fcc_option (Assume_Finite v va) = Nothing;
get_fcc_option (Unlab_Proc v va vb) = Nothing;
get_fcc_option (Q_Reduction_Proc v va) = Nothing;
get_fcc_option (Complex_Constant_Removal_Proc v va) = Nothing;
get_fcc_option (General_Redpair_Proc v va vb vc vd) = Nothing;
get_fcc_option (To_Trs_Proc v) = Nothing;

uncurry_of_top_sig_list ::
  forall a.
    a -> Nat ->
           [((a, Nat), [a])] ->
             (a -> Nat -> [a]) -> [(Term a [Char], Term a [Char])];
uncurry_of_top_sig_list a m sml sm =
  concatMap
    (\ (b, c) ->
      (case b of {
        (f, n) ->
          (\ _ ->
            let {
              g = get_symbol sm f n;
            } in map (\ i ->
                       (Fun a (generate_f_xs (g i) (plus_nat n i) :
                                map (\ ia -> Var (generate_var ia))
                                  (upt (plus_nat n i)
                                    (plus_nat (plus_nat n i)
                                      (minus_nat m one_nat)))),
                         generate_f_xs (g (suc i))
                           (plus_nat (plus_nat n i) (minus_nat m one_nat))))
                   (upt zero_nat (aarity sm f n)));
      })
        c)
    sml;

eta_closed_top_rules ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => a -> Nat ->
                         (a -> Nat -> [a]) ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] ->
                               Sum (String -> String) ();
eta_closed_top_rules a n sm r p =
  catch_errora
    (forallM
      (\ (l, ra) ->
        (case l of {
          Var _ -> Inr ();
          Fun ff ls ->
            check (equal_nat (aarity sm ff (size_list ls)) zero_nat ||
                    any (\ (lll, rrr) ->
                          (case (lll, rrr) of {
                            (Var _, _) -> False;
                            (Fun _ [], _) -> False;
                            (Fun _ (_ : _), Var _) -> False;
                            (Fun _ (_ : _), Fun _ []) -> False;
                            (Fun f (ll : yy), Fun g (rr : zz)) ->
                              f == a &&
                                g == a &&
                                  zz == yy &&
                                    equal_nat (size_list yy)
                                      (minus_nat n one_nat) &&
                                      distinct yy &&
all is_Var yy &&
  null (list_inter (map the_Var yy) (insert_vars_rule (ll, rr) [])) &&
    instance_rule (l, ra) (ll, rr);
                          }))
                      p)
              ((showsl_lit "eta expansion of " . showsl_rule (l, ra)) .
                showsl_lit " missing");
        }))
      r)
    (\ x -> Inl (snd x));

uncurry_top_rules ::
  forall a b.
    (Eq a) => a -> Nat ->
                     (a -> Nat -> [a]) ->
                       [(Term a b, Term a b)] -> [(Term a b, Term a b)];
uncurry_top_rules a n sm =
  map (\ (l, r) -> (uncurry_top a n sm l, uncurry_top a n sm r));

map_funs_rules_wa ::
  forall a b c.
    ((a, Nat) -> b) -> [(Term a c, Term a c)] -> [(Term b c, Term b c)];
map_funs_rules_wa fg r =
  map (\ (l, ra) -> (map_funs_term_wa fg l, map_funs_term_wa fg ra)) r;

uncurry_top_proc ::
  forall a b.
    (Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Char], Term b [Char])],
                            [(Term b [Char], Term b [Char])]))) ->
                      Nat ->
                        ([((b, Nat), [b])] -> b -> Nat -> b) ->
                          (b -> Nat ->
                                  [((b, Nat), [b])] ->
                                    Sum (String -> String) ()) ->
                            [(Term b [Char], Term b [Char])] ->
                              [(Term b [Char], Term b [Char])] ->
                                a -> Sum (String -> String) a;
uncurry_top_proc i info n fmap check_inj p r dpp =
  (case info of {
    (a, (sml, (u, eb))) ->
      let {
        pa = pb i dpp;
        pw = pwb i dpp;
        ra = rd i dpp;
        rw = rwd i dpp;
        nfs = nfsc i dpp;
        m = minimal i dpp;
      } in (case uncurry_eta_split eb ra of {
             (e, ew) ->
               let {
                 sm = sig_list_to_sig_map a sml fmap;
                 p_eta = e ++ pa;
                 pw_eta = ew ++ pw;
                 uP = uncurry_top_rules a n sm p_eta;
                 uPw = uncurry_top_rules a n sm pw_eta;
                 uR = map_funs_rules_wa
                        (\ (f, na) -> get_symbol sm f na zero_nat) ra;
                 uRw = map_funs_rules_wa
                         (\ (f, na) -> get_symbol sm f na zero_nat) rw;
               } in (case bindb (check (null (qc i dpp))
                                  (showsl_lit "strategy currently unsupported"))
                            (\ _ ->
                              bindb (check (not (equal_nat n zero_nat))
                                      (showsl_lit
"the arity of the uncurried symbol must be at least 1"))
                                (\ _ ->
                                  bindb (check_inj a n sml)
                                    (\ _ ->
                                      let {
pba = pairsb i dpp;
is_def = (\ fn -> not (null (rules_mapc i dpp fn)));
rm = rules_mapc i dpp;
                                      } in
bindb (catch_errora
        (forallM
          (\ (l, _) ->
            check (not (is_Var l))
              (showsl_lit "lhs as variable is not allowed"))
          (ra ++ rw))
        (\ x -> Inl (snd x)))
  (\ _ ->
    bindb (catch_errora
            (forallM
              (\ (l, rb) ->
                bindb (check (hvf_top a n l)
                        ((showsl_lit "head variable in lhs " . showsl_terma l) .
                          showsl_lit " not allowed"))
                  (\ _ -> check_no_var rb))
              (pw_eta ++ p_eta))
            (\ x -> Inl (snd x)))
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ (_, rb) ->
                    check (not (is_def (the (root rb))))
                      ((showsl_lit "root of " . showsl_terma rb) .
                        showsl_lit " must not be defined"))
                  pba)
                (\ x -> Inl (snd x)))
          (\ _ ->
            bindb (check (not (is_def (a, n)))
                    ((showsl_lit "application symbol " . showsl a) .
                      showsl_lit " must not be defined in R"))
              (\ _ ->
                bindb (if any (\ (_, rb) ->
                                the (root rb) == (a, n) &&
                                  equal_gctxt (tcapRM2 rm (hda (args rb)))
                                    GCHole)
                            pba
                        then bindb (catch_errora
                                     (check_CS_subseteq
                                       (uncurry_of_top_sig_list a n sml sm) u)
                                     (\ x ->
                                       Inl
 (((showsl_lit "uncurrying pair " . showsl_rule x) .
    showsl_lit " is missing in\n") .
   showsl_rules u)))
                               (\ _ ->
                                 bindb (eta_closed_top_rules a n sm ra p_eta)
                                   (\ _ ->
                                     eta_closed_top_rules a n sm rw pw_eta))
                        else Inr ())
                  (\ _ ->
                    bindb (catch_errora (check_subseteq uP p)
                            (\ x ->
                              Inl ((showsl_lit "uncurried pair " .
                                     showsl_rule x) .
                                    showsl_lit " is missing")))
                      (\ _ ->
                        bindb (catch_errora (check_subseteq uPw p)
                                (\ x ->
                                  Inl ((showsl_lit "uncurried pair " .
 showsl_rule x) .
showsl_lit " is missing")))
                          (\ _ ->
                            bindb (catch_errora (check_subseteq u p)
                                    (\ x ->
                                      Inl
((showsl_lit "uncurrying pair " . showsl_rule x) .
  showsl_lit " is missing in new pairs")))
                              (\ _ ->
                                bindb (catch_errora (check_subseteq uR r)
(\ x ->
  Inl ((showsl_lit "rule " . showsl_rule x) .
        showsl_lit " is missing in new rules")))
                                  (\ _ ->
                                    catch_errora (check_subseteq uRw r)
                                      (\ x ->
Inl ((showsl_lit "rule " . showsl_rule x) .
      showsl_lit " is missing in new rules"))))))))))))))
                      of {
                      Inl aa -> Inl aa;
                      Inr _ -> Inr (mkd i nfs m uP (uPw ++ u) [] uR uRw);
                    });
           });
  });

only_eta_rules ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] -> Sum (String -> String) ();
only_eta_rules e r_eta =
  catch_errora
    (forallM
      (\ (l, r) ->
        check (case (l, r) of {
                (Var _, _) -> False;
                (Fun _ _, Var _) -> False;
                (Fun f ls, Fun g rs) ->
                  f == g &&
                    equal_nat (size_list ls) (nat_of_integer (2 :: Integer)) &&
                      equal_nat (size_list rs)
                        (nat_of_integer (2 :: Integer)) &&
                        equal_term (nth ls one_nat) (nth rs one_nat) &&
                          any (\ (la, ra) ->
                                instance_rule (hda ls, hda rs) (la, ra))
                            r_eta;
              })
          ((showsl_lit "rule " . showsl_rule (l, r)) .
            showsl_lit " is not an (eta-expanded) original rule"))
      e)
    (\ x -> Inl (snd x));

uncurry_proc ::
  forall a b.
    (Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Char], Term b [Char])],
                            [(Term b [Char], Term b [Char])]))) ->
                      ([((b, Nat), [b])] -> b -> Nat -> b) ->
                        (b -> Nat ->
                                [((b, Nat), [b])] ->
                                  Sum (String -> String) ()) ->
                          [(Term b [Char], Term b [Char])] ->
                            [(Term b [Char], Term b [Char])] ->
                              a -> Sum (String -> String) a;
uncurry_proc i info fmap check_inj p r dpp =
  (case info of {
    (a, (sml, (u, eb))) ->
      let {
        pa = pb i dpp;
        pw = pwb i dpp;
        ra = rd i dpp;
        rw = rwd i dpp;
        nfs = nfsc i dpp;
        m = minimal i dpp;
      } in (case uncurry_eta_split eb ra of {
             (e, ew) ->
               let {
                 sm = sig_list_to_sig_map a sml fmap;
                 uP = uncurry_rules a sm pa;
                 uPw = uncurry_rules a sm pw;
                 r_eta = e ++ ra;
                 rw_eta = ew ++ rw;
                 uR = uncurry_rules a sm r_eta;
                 uRw = uncurry_rules a sm rw_eta;
               } in (case let {
                            s = uncurry_of_sig_list a sml sm;
                          } in bindb (check (null (qc i dpp))
                                       (showsl_lit
 "strategy not supported for uncurrying"))
                                 (\ _ ->
                                   bindb (only_eta_rules e r_eta)
                                     (\ _ ->
                                       bindb (only_eta_rules ew rw_eta)
 (\ _ ->
   bindb (check_inj a (nat_of_integer (2 :: Integer)) sml)
     (\ _ ->
       bindb (catch_errora
               (forallM
                 (\ (l, _) ->
                   check (not (is_Var l))
                     (showsl_lit "lhs as variable is not allowed"))
                 (ra ++ rw))
               (\ x -> Inl (snd x)))
         (\ _ ->
           bindb (catch_errora
                   (forallM
                     (\ (l, _) ->
                       check (hvf_term a l)
                         ((showsl_lit "head variable in lhs " .
                            showsl_terma l) .
                           showsl_lit " not allowed"))
                     pa)
                   (\ x -> Inl (snd x)))
             (\ _ ->
               bindb (catch_errora
                       (forallM
                         (\ (l, _) ->
                           check (hvf_term a l)
                             ((showsl_lit "head variable in lhs " .
                                showsl_terma l) .
                               showsl_lit " not allowed"))
                         pw)
                       (\ x -> Inl (snd x)))
                 (\ _ ->
                   bindb (catch_errora
                           (forallM
                             (\ (l, _) ->
                               check (hvf_term a l)
                                 ((showsl_lit "head variable in lhs " .
                                    showsl_terma l) .
                                   showsl_lit " not allowed"))
                             r_eta)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ (l, _) ->
                                   check (hvf_term a l)
                                     ((showsl_lit "head variable in lhs " .
showsl_terma l) .
                                       showsl_lit " not allowed"))
                                 rw_eta)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (eta_closed_rules a sm r_eta r_eta)
                             (\ _ ->
                               bindb (eta_closed_rules a sm rw_eta rw_eta)
                                 (\ _ ->
                                   bindb (catch_errora (check_subseteq uP p)
   (\ x ->
     Inl ((showsl_lit "uncurried pair " . showsl_rule x) .
           showsl_lit " is missing")))
                                     (\ _ ->
                                       bindb
 (catch_errora (check_subseteq uPw p)
   (\ x ->
     Inl ((showsl_lit "uncurried pair " . showsl_rule x) .
           showsl_lit " is missing")))
 (\ _ ->
   bindb (catch_errora (check_subseteq uR r)
           (\ x ->
             Inl ((showsl_lit "uncurried rule " . showsl_rule x) .
                   showsl_lit " is missing")))
     (\ _ ->
       bindb (catch_errora (check_subseteq uRw r)
               (\ x ->
                 Inl ((showsl_lit "uncurried rule " . showsl_rule x) .
                       showsl_lit " is missing")))
         (\ _ ->
           bindb (catch_errora (check_CS_subseteq s u)
                   (\ x ->
                     Inl ((showsl_lit "uncurry rule " . showsl_rule x) .
                           showsl_lit " is missing")))
             (\ _ ->
               bindb (catch_errora (check_CS_subseteq u s)
                       (\ x ->
                         Inl ((showsl_lit "rule " . showsl_rule x) .
                               showsl_lit " is not an uncurry rule")))
                 (\ _ ->
                   catch_errora (check_subseteq u r)
                     (\ x ->
                       Inl ((showsl_lit "uncurry rule " . showsl_rule x) .
                             showsl_lit
                               " is missing in new TRS")))))))))))))))))))
                      of {
                      Inl aa -> Inl aa;
                      Inr _ -> Inr (mkd i nfs m uP uPw [] uR (uRw ++ u));
                    });
           });
  });

uncurry_proc_both ::
  forall a b c.
    (Eq b, Showl b, Eq c,
      Showl c) => Dpp_ops_ext a (Lab b c) [Char] () ->
                    Maybe Nat ->
                      (Lab b c,
                        ([((Lab b c, Nat), [Lab b c])],
                          ([(Term (Lab b c) [Char], Term (Lab b c) [Char])],
                            [(Term (Lab b c) [Char],
                               Term (Lab b c) [Char])]))) ->
                        [(Term (Lab b c) [Char], Term (Lab b c) [Char])] ->
                          [(Term (Lab b c) [Char], Term (Lab b c) [Char])] ->
                            a -> Sum (String -> String) a;
uncurry_proc_both i Nothing (a, (sml, (u, eb))) =
  uncurry_proc i (a, (sml, (u, eb))) (fmap a (nat_of_integer (2 :: Integer)))
    check_inj;
uncurry_proc_both i (Just n) (a, (sml, (u, eb))) =
  uncurry_top_proc i (a, (sml, (u, eb))) n (fmap a n) check_inj;

check_rewrite_common_preconditions ::
  forall a b c d.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Maybe [(Term b [Char], Term b [Char])] ->
                      (Term b [Char], Term c [Char]) ->
                        [Term b [Char]] ->
                          [Term b [Char]] ->
                            d -> (Term b [Char], Term b [Char]) ->
                                   [Nat] ->
                                     Bool -> a -> Sum (String -> String) ();
check_rewrite_common_preconditions i u_opt st ss ts t lr p sound dpp =
  let {
    r = rulesf i dpp;
    s = fst st;
    ta = snd st;
    tp = subt_at ta p;
    u = (case u_opt of {
          Nothing -> concatMap (\ tb -> inn_usable_rules_pair i dpp (s, tb)) ts;
          Just u -> u;
        });
  } in bindb (catch_errora (check_subseteq u r)
               (\ x ->
                 Inl (showsl_rule x .
                       showsl_lit " is not a rule of the rewrite system ")))
         (\ _ ->
           let {
             urc = is_ur_closed_impl_dpp_mv i dpp u;
             check_urc =
               (\ sa tb ->
                 check (urc sa tb)
                   ((showsl_lit "term " . showsl_terma tb) .
                     showsl_lit " is not closed under usable rules"));
             nfs = nfsc i dpp;
           } in bindb (catch_errora
                        (forallM
                          (\ (l, _) ->
                            check (not (is_Var l))
                              (showsl_lit "lhss must not be variables"))
                          u)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    bindb (check (wf_rule lr)
                            (showsl_rule lr .
                              showsl_lit " is not a well formed rule"))
                      (\ _ ->
                        bindb (if nfs && sound then Inr ()
                                else catch_errora
                                       (check_subseteq (vars_term_list tp)
 (vars_term_list s))
                                       (\ _ ->
 Inl (showsl_lit "variable condition in pair violated")))
                          (\ _ ->
                            bindb (catch_errora (forallM (check_urc ss) ts)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (catch_errora
(forallM (\ (l, a) -> check_urc (args l) a) u) (\ x -> Inl (snd x)))
                                  (\ _ ->
                                    bindb (catch_errora
    (check_critical_pairs_innermost u)
    (\ x -> Inl (showsl_lit "problem in showing UNF of usable rules\n" . x)))
                                      (\ _ ->
catch_errora
  (forallM
    (\ (_, (sa, tb)) ->
      check (equal_term sa tb)
        (showsl_lit
          "non-trivial critical pair between rule to rewrite and usable rules"))
    (critical_pairs_impl [lr] u))
  (\ x -> Inl (snd x)))))))));

check_prop_rstepa ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => Bool ->
                    (Term a b -> Sum (String -> String) ()) ->
                      [(Term a b, Term a b)] ->
                        [Nat] ->
                          (Term a b, Term a b) ->
                            Term a b -> Term a b -> Sum (String -> String) ();
check_prop_rstepa nfs pa r p rule s t =
  bindb (check (membera r rule)
          (((showsl_rule rule . showsl_literal " is not a rule of\n") .
             showsl_trs r) .
            showsl_literal "\n"))
    (\ _ -> check_prop_rstep_rule nfs pa p rule s t);

check_rstep ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [Nat] ->
                      (Term a b, Term a b) ->
                        Term a b -> Term a b -> Sum (String -> String) ();
check_rstep = check_prop_rstepa False (\ _ -> Inr ());

rewriting_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Maybe [(Term b [Char], Term b [Char])] ->
                      (Term b [Char], Term b [Char]) ->
                        (Term b [Char], Term b [Char]) ->
                          (Term b [Char], Term b [Char]) ->
                            (Term b [Char], Term b [Char]) ->
                              [Nat] -> a -> Sum (String -> String) a;
rewriting_proc i u stb sta st lr p dpp =
  (case let {
          s = fst stb;
          t = snd sta;
        } in bindb (check_rstep (rulesf i dpp) p lr (snd stb) t)
               (\ _ ->
                 bindb (check (nFQ_subset_NF_rulesc i dpp)
                         (showsl_lit "innermost rewriting required"))
                   (\ _ ->
                     bindb (check_rewrite_common_preconditions i u stb [s]
                             [subt_at (snd stb) p] t lr p True dpp)
                       (\ _ ->
                         bindb (check (eq_rule_mod_vars sta st)
                                 (((showsl_lit "the rule " . showsl_rule sta) .
                                    showsl_lit
                                      " is not a renamed variant of ") .
                                   showsl_rule st))
                           (\ _ ->
                             bindb (check (equal_term s (fst sta))
                                     (showsl_lit
                                       "left-hand sides of old and new pair differ"))
                               (\ _ ->
                                 bindb (check
 (membera (pb i dpp) stb || null (rd i dpp))
 (showsl_lit "strict DP or no strict rules required"))
                                   (\ _ ->
                                     check (nfsc i dpp || wwf_rulesa i dpp)
                                       (showsl_lit
 "well-formed rules or normal subst. required")))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp stb [st]);
  });

nF_subst_impl ::
  forall a b.
    (Term a b -> Bool) ->
      Bool -> (Term a b, Term a b) -> (b -> Term a b) -> Bool;
nF_subst_impl nf nfs r sigma =
  (if nfs then all (\ x -> nf (sigma x)) (vars_rule_list r) else True);

qnarrows_impl ::
  forall a.
    (Eq a) => (Term a [Char] -> Bool) ->
                Bool ->
                  [(Term a [Char], Term a [Char])] ->
                    Term a [Char] -> [(Term a [Char], [Char] -> Term a [Char])];
qnarrows_impl isnf nfs r t =
  concatMap
    (\ p ->
      let {
        tp = subt_at t p;
      } in (if not (is_Var tp)
             then concatMap
                    (\ (l, ra) ->
                      concatMap
                        (\ (mu_1, mu_2) ->
                          (if nF_subst_impl isnf nfs (l, ra) mu_2
                            then (if all isnf (args (subst_apply_term l mu_2))
                                   then [(ctxt_apply_term
    (ctxt_of_pos_term p (subst_apply_term t mu_1)) (subst_apply_term ra mu_2),
   mu_1)]
                                   else [])
                            else []))
                        (option_to_list
                          (mgu_var_disjoint_generic
                            (\ a ->
                              Char False False False True True True True False :
                                a)
                            (\ a ->
                              Char True False False True True True True False :
                                a)
                            tp l)))
                    r
             else []))
    (poss_list t);

narrowing_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    (Term b [Char], Term b [Char]) ->
                      [Nat] ->
                        [(Term b [Char], Term b [Char])] ->
                          a -> Sum (String -> String) a;
narrowing_proc i st p sts dpp =
  (case (case st of {
          (s, t) ->
            let {
              q = qc i dpp;
            } in bindb (check
                         (nFQ_subset_NF_rulesc i dpp || null q && linear_term t)
                         (showsl_lit
                           "innermost or full rewriting required (and linearity of t in full rewriting case)"))
                   (\ _ ->
                     let {
                       ic = icap_impl_dpp_mv i dpp;
                       isnf = is_QNFc i dpp;
                       pairs = pairsb i dpp;
                     } in bindb (check (membera (poss_list t) p)
                                  (showsl_lit "position not contained in " .
                                    showsl_terma t))
                            (\ _ ->
                              let {
                                tp = subt_at t p;
                                nftp = isnf tp;
                              } in bindb (check
   (membera (poss_list (ic [s] t)) p || not nftp)
   (showsl_lit
     "neither is position contained in capped term of t, nor is t|_p not in Q-normal form"))
                                     (\ _ ->
                                       let {
 nfs = nfsc i dpp;
 narrows = qnarrows_impl isnf nfs (rulesf i dpp) tp;
 stsa =
   filter (\ (smu, _) -> isnf smu)
     (map (\ (ta, mu) ->
            (subst_apply_term s mu,
              ctxt_apply_term (ctxt_of_pos_term p (subst_apply_term t mu)) ta))
       narrows);
                                       } in
 bindb (catch_errora
         (forallM
           (\ new ->
             check (any (\ sta ->
                          instance_rule new sta &&
                            (not nfs || (null q || wf_rule sta)))
                     sts)
               (showsl_lit "could not find narrowed pair " . showsl_rule new))
           stsa)
         (\ x -> Inl (snd x)))
   (\ _ ->
     let {
       iedg = is_iedg_edge_dpp i dpp (s, t);
     } in bindb (catch_errora
                  (check_subseteq (vars_term_list tp) (vars_term_list s))
                  (\ x ->
                    Inl ((showsl_lit "variable " . showsl_lista x) .
                          showsl_lit " only occurs on rhs of pair")))
            (\ _ ->
              bindb (check (membera (pb i dpp) st || null (rd i dpp))
                      (showsl_lit "strict DP or no strict rules required"))
                (\ _ ->
                  (if nftp
                    then catch_errora
                           (forallM
                             (\ (u, v) ->
                               bindb (check (membera (poss_list u) p)
                                       (showsl_lit
  "position not contained in lhs of pair " .
 showsl_rule (u, v)))
                                 (\ _ ->
                                   (case mgu_var_disjoint_generic
   (\ a -> Char False False False True True True True False : a)
   (\ a -> Char True False False True True True True False : a) tp (subt_at u p)
                                     of {
                                     Nothing -> Inr ();
                                     Just (mu_1, mu_2) ->
                                       check
 (not (isnf (subst_apply_term s mu_1)) || not (isnf (subst_apply_term u mu_2)))
 (showsl_lit
    "t |_ p and u |_ p unify and satisfy variable condition for pair (u,v) = " .
   showsl_rule (u, v));
                                   })))
                             (filter (\ (u, _) -> iedg u) pairs))
                           (\ x -> Inl (snd x))
                    else Inr ())))))));
        })
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

extract_renamings :: forall a. (Eq a) => [(a, a)] -> (a -> a, a -> a);
extract_renamings old_new =
  (fun_of_map_fun (map_of old_new) id,
    fun_of_map_fun (map_of (map swap old_new)) id);

extract_components ::
  forall a. (Eq a) => [(a, Nat)] -> [(a, a)] -> (a -> a, (a -> a, [a]));
extract_components mu old_new =
  (case extract_renamings old_new of {
    (d, da) ->
      let {
        c = map_filter
              (\ x ->
                (if (case x of {
                      (_, a) -> equal_nat a zero_nat;
                    })
                  then Just (fst x) else Nothing))
              mu;
        nu = map d c;
      } in (d, (da, nu));
  });

check_components ::
  forall a.
    (Eq a,
      Showl a) => [(a, Nat)] ->
                    (a -> a, (a -> a, [a])) -> Sum (String -> String) ();
check_components mu ddNU =
  (case ddNU of {
    (d, (da, nu)) ->
      bindb (catch_errora
              (forallM
                (\ f ->
                  bindb (check (not (membera mu (f, one_nat)))
                          ((showsl_lit "new unary symbol " . showsl f) .
                            showsl_lit " clashes with old symbol"))
                    (\ _ ->
                      bindb (check (d (da f) == f)
                              (showsl_lit
                                 "problem with bijection for renaming of " .
                                showsl f))
                        (\ _ ->
                          check (membera mu (da f, zero_nat))
                            (showsl_lit "problem with inverse renaming of " .
                              showsl f))))
                nu)
              (\ x -> Inl (snd x)))
        (\ _ ->
          catch_errora
            (forallM
              (\ (f, n) ->
                bindb (check (less_eq_nat n one_nat)
                        (showsl_lit "arity > 1 for symbol " . showsl f))
                  (\ _ ->
                    check (if equal_nat n zero_nat
                            then membera nu (d f) && da (d f) == f else True)
                      (showsl_lit
                         "problem with bijection for renaming of constant " .
                        showsl f)))
              mu)
            (\ x -> Inl (snd x)));
  });

str :: forall a b. (a -> a) -> b -> Term a b -> Term a b;
str d x (Fun f (v : vb : vc)) = Fun (d f) [Var x];
str d x (Fun f []) = Fun (d f) [Var x];
str d x (Fun f [t]) = Fun f [str d x t];
str d uu (Var x) = Var x;

choose_var :: forall a b. a -> Term b a -> a;
choose_var x l = hda (vars_term_list l ++ [x]);

check_to_srs_sound ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showl a, Compare b, Eq b,
      Showl b) => a -> [(b, b)] ->
                         [(Term b a, Term b a)] ->
                           [(Term b a, Term b a)] ->
                             [(Term b a, Term b a)] ->
                               [(Term b a, Term b a)] ->
                                 Sum (String -> String) ();
check_to_srs_sound v old_new r s rw sw =
  let {
    mu = funas_trs_list (r ++ rw);
  } in (case extract_components mu old_new of {
         (d, (da, nu)) ->
           bindb (check_components mu (d, (da, nu)))
             (\ _ ->
               bindb (check_varcond_subset r)
                 (\ _ ->
                   bindb (check_varcond_subset rw)
                     (\ _ ->
                       let {
                         checka =
                           (\ ra sa ->
                             catch_errora
                               (forallM
                                 (\ (l, rb) ->
                                   let {
                                     y = choose_var v l;
                                     stra = str d y;
                                     slr = (stra l, stra rb);
                                   } in check
  (less_eq_set (vars_term l) (inserta y bot_set) && membera sa slr)
  (showsl_lit "problem with new rule " . showsl_rule slr))
                                 ra)
                               (\ x -> Inl (snd x)));
                       } in bindb (checka r s) (\ _ -> checka rw sw))));
       });

const_to_string_sound_tt ::
  forall a b c.
    (Compare a, Eq a, Showl a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showl b) => Const_string_sound_proof a b ->
                    Tp_ops_ext c a b () -> c -> Sum (String -> String) c;
const_to_string_sound_tt (Const_string_sound_proof v old_new s sw) i tp =
  bindb (check_to_srs_sound v old_new (rc i tp) s (rwc i tp) sw)
    (\ _ -> Inr (mkc i False [] s sw));

dP_list ::
  forall a b.
    (Eq a,
      Eq b) => (a -> a) ->
                 [(Term a b, Term a b)] -> [(a, Nat)] -> [(Term a b, Term a b)];
dP_list shp r d_list =
  concatMap
    (\ lr ->
      let {
        l = fst lr;
        s = sharp_term shp l;
      } in map_filter
             (\ x ->
               (if not (supt_impl l x) &&
                     not (is_Var x) && membera d_list (the (root x))
                 then Just (s, sharp_term shp x) else Nothing))
             (supteq_list (snd lr)))
    r;

dependency_pairs_tt ::
  forall a b c d.
    (Compare a, Eq a, Linorder a, Showl a, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Linorder c,
      Showl c) => (a -> a) ->
                    Tp_ops_ext b a c () ->
                      Dpp_ops_ext d a c () ->
                        b -> Bool ->
                               Bool ->
                                 [(Term a c, Term a c)] ->
                                   Sum (String -> String) d;
dependency_pairs_tt shp i j tp nfs m p =
  let {
    r = rulese i tp;
    q = qb i tp;
    iQ = is_QNFb i tp;
    u = filter (applicable_rule_impl iQ) r;
  } in (case catch_errora
               (bindb
                 (if isOK (check_wf_trs u) then Inr ()
                   else check (nfs &&
                                nfsb i tp &&
                                  nFQ_subset_NF_rulesb i tp &&
                                    all (\ l -> not (is_Var l)) (map fst r))
                          (showsl_lit
                            "neither is the TRS well-formed, nor is the restriction to innermost with normal form substitutions present"))
                 (\ _ ->
                   bindb (catch_errora (forallM check_no_var q)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       let {
                         qr = map (\ (Fun f ss) -> (f, size_list ss)) q;
                         d = defined_list u;
                       } in bindb (catch_errora
                                    (forallM
                                      (\ (f, n) ->
check (not (membera d (shp f, n)))
  (((showsl_lit "sharping " . showsl f) .
     showsl_lit " yields the defined symbol ") .
    showsl (shp f)))
                                      d)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (catch_errora
(forallM
  (\ (f, n) ->
    check (not (membera qr (shp f, n)))
      ((((showsl_lit "sharping " . showsl f) .
          showsl_lit " yields the symbol ") .
         showsl (shp f)) .
        showsl_lit " which is a root of Q"))
  d)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    let {
                                      pa = set p;
                                    } in catch_errora
   (catch_errora
     (forallM
       (\ x ->
         (if member x pa || any (eq_rule_mod_vars x) p then Inr () else Inl x))
       (dP_list shp u d))
     (\ x -> Inl (snd x)))
   (\ x ->
     Inl ((showsl_lit "the DP " . showsl_rule x) .
           showsl_lit " does not appear in the DP problem\n")))))))
               (\ x ->
                 Inl (showsl_lit
                        "the DP-transformation is not applied correctly.\n" .
                       x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd j nfs m p [] q [] r);
       });

switch_innermost_tt ::
  forall a b.
    (Eq b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    Join_info b -> a -> Sum (String -> String) a;
switch_innermost_tt i joins_i trs =
  let {
    r = rulese i trs;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b (showsl_lit "rules are not overlay"))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_critical_pairs r cp joins_i)
                        (\ _ -> check_wf_trs r))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i True (map fst r) r []);
       });

rule_removal_tt ::
  forall a b c.
    (Showl b,
      Showl c) => Tp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] -> a -> Sum (String -> String) a;
rule_removal_tt i rp rremove trs =
  (case catch_errora
          (case split_rulesb i trs rremove of {
            (rs, rns) ->
              bindb (valid rp)
                (\ _ ->
                  bindb (catch_errora (mono rp (rs ++ rns))
                          (\ x ->
                            Inl (showsl_lit
                                   "problem with monotonicity of strict order\n" .
                                  x)))
                    (\ _ ->
                      bindb (catch_errora
                              (catch_errora (forallM (ns rp) rns)
                                (\ x -> Inl (snd x)))
                              (\ x ->
                                Inl (showsl_lit "problem when orienting TRS\n" .
                                      x)))
                        (\ _ ->
                          catch_errora
                            (catch_errora (forallM (s rp) rs)
                              (\ x -> Inl (snd x)))
                            (\ x ->
                              Inl (showsl_lit "problem when orienting TRS\n" .
                                    x)))));
          })
          (\ x ->
            Inl (((showsl_lit
                     "could not apply the reduction pair processor with the following\n" .
                    desca rp) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_R_Rwb i trs rremove rremove);
  });

unary_term :: forall a b. Term a b -> Bool;
unary_term (Var x) = True;
unary_term (Fun f [t]) = unary_term t;
unary_term (Fun v []) = False;
unary_term (Fun v (vb : vd : ve)) = False;

check_unary_signature ::
  forall a b.
    (Showl a, Showl b) => [(Term a b, Term a b)] -> Sum (String -> String) ();
check_unary_signature r =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if (case x of {
                (l, ra) -> unary_term l && unary_term ra;
              })
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl ((showsl_lit "the rule\n" . showsl_rule x) .
            showsl_lit
              "\nviolates the condition that all function symbols\nhave to be unary"));

rev_term :: forall a b. Ctxt a b -> Term a b -> Term a b;
rev_term c (Var x) = ctxt_apply_term c (Var x);
rev_term c (Fun f [t]) = rev_term (More f [] c []) t;

rev_rule :: forall a b. (Term a b, Term a b) -> (Term a b, Term a b);
rev_rule (l, r) = (rev_term Hole l, rev_term Hole r);

string_reversal_tt ::
  forall a b c.
    (Showl b, Showl c) => Tp_ops_ext a b c () -> a -> Sum (String -> String) a;
string_reversal_tt i trs =
  let {
    rs = rulese i trs;
    r = rc i trs;
    s = rwc i trs;
  } in (case check_unary_signature rs of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (mkc i default_nfs_trs [] (map rev_rule r) (map rev_rule s));
       });

q_emptyb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
q_emptyb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = q_empty;

sem_lab_rel_tt ::
  forall a b c d.
    (Compare a, Eq a, Showl a, Ccompare b, Compare b, Eq b, Mapping_impl b,
      Showl b) => ([(Term a b, Term a b)] ->
                    Set (Term a b, Term a b) ->
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]))) ->
                    (a -> (a, c)) ->
                      Tp_ops_ext d a b () ->
                        Sum (String -> String) () ->
                          ([(Term a b, Term a b)] ->
                            Sum (String -> String) ()) ->
                            (Set (Term a b, Term a b) ->
                              [(Term a b, Term a b)] ->
                                Sum (String -> String) ()) ->
                              [Term a b] ->
                                [(Term a b, Term a b)] ->
                                  d -> Sum (String -> String) d;
sem_lab_rel_tt splitter ld i valid check_decr check_model_lab lQ lAll tp =
  let {
    r = rc i tp;
    rw = rwc i tp;
    nfs = nfsb i tp;
  } in (case splitter lAll (set rw) of {
         (lR, (lRw, d)) ->
           (case bindb valid
                   (\ _ ->
                     let {
                       q = qb i tp;
                     } in catch_errora
                            (bindb
                              (if nfs && not (q_emptyb i tp) then check_wf_trs d
                                else Inr ())
                              (\ _ ->
                                bindb (check_decr d)
                                  (\ _ ->
                                    bindb (check_sl_Q ld lQ q)
                                      (\ _ ->
bindb (check_model_lab (set lR) r) (\ _ -> check_model_lab (set lRw) rw)))))
                            (\ x ->
                              Inl (showsl_lit "problem with labeled TRS:\n" .
                                    x)))
             of {
             Inl a -> Inl a;
             Inr _ -> Inr (mkc i nfs lQ lR (lRw ++ d));
           });
       });

sem_lab_fin_tt ::
  forall a b c d e.
    (Compare a, Eq a, Showl a, Ccompare b, Compare b, Eq b, Mapping_impl b,
      Showl b,
      Showl d) => ([(Term a b, Term a b)] ->
                    Set (Term a b, Term a b) ->
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]))) ->
                    (a -> Nat -> c -> a) ->
                      (a -> (a, c)) ->
                        (d -> d -> Bool) ->
                          Tp_ops_ext e a b () ->
                            ([(a, Nat)] ->
                              [(a, Nat)] ->
                                Sum (String -> String)
                                  (Sl_ops_ext a d c b ())) ->
                              [Term a b] ->
                                [(Term a b, Term a b)] ->
                                  e -> Sum (String -> String) e;
sem_lab_fin_tt splitter lc ld cge i gen lQ lAll tp =
  bindb (gen (insert_funas_trs (rulese i tp) []) [])
    (\ ops ->
      let {
        check_ml =
          check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) cge lc;
        check_d = sl_check_decr ops;
      } in sem_lab_rel_tt splitter ld i (Inr ()) check_d check_ml lQ lAll tp);

semlab_fin_tt ::
  forall a b c.
    (Compare b, Eq b, Showl b, Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showl c) => Tp_ops_ext a (Lab b [Nat]) c () ->
                    Sl_variant (Lab b [Nat]) c ->
                      [Term (Lab b [Nat]) c] ->
                        [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                          a -> Sum (String -> String) a;
semlab_fin_tt j (Rootlab uu) =
  sem_lab_fin_tt (model_splitter label_decomp) label label_decomp equal_lab j
    (slm_gen_to_sl_gen (rl_slm Nothing));
semlab_fin_tt j (Finitelab sli) =
  sem_lab_fin_tt (model_splitter label_decomp) label label_decomp equal_nat j
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli)));
semlab_fin_tt j (QuasiFinitelab sli v) =
  sem_lab_fin_tt (quasi_splitter label_decomp) label label_decomp qmodel_cge j
    (\ f g -> qsli_to_sl v f g sli);

permutation_afs :: forall a. (Ceq a, Ccompare a) => Afs a -> Bool;
permutation_afs pi =
  ball (afs_syms pi)
    (\ (f, n) ->
      (case afsa pi (f, n) of {
        Collapse _ -> False;
        AFList xs -> eq_set (set xs) (set (upt zero_nat n)) && distinct xs;
      }));

argument_filter_tt ::
  forall a b c.
    (Ceq b, Ccompare b, Compare_order b,
      Set_impl b) => Tp_ops_ext a b c () ->
                       [((b, Nat), Af_entry)] -> a -> Sum (String -> String) a;
argument_filter_tt i pi tp =
  (case afs_of pi of {
    Nothing -> Inl (showsl_lit "invalid argument filter");
    Just af ->
      bindb (check (permutation_afs af)
              (showsl_lit "argument filter is not a permutation"))
        (\ _ ->
          let {
            pia = af_rules af;
          } in Inr (mkc i default_nfs_trs [] (pia (rc i tp)) (pia (rwc i tp))));
  });

check_wwf_qtrs ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => (Term a b -> Bool) ->
                    [(Term a b, Term a b)] -> Sum (String -> String) ();
check_wwf_qtrs nf r =
  catch_errora
    (catch_errora
      (forallM
        (\ ra ->
          (if applicable_rule_impl nf ra
            then catch_errora
                   (bindb
                     (check (not (is_Var (fst ra)))
                       (showsl_literal "variable left-hand side in"))
                     (\ _ ->
                       catch_errora
                         (check_subseteq (vars_term_list (snd ra))
                           (vars_term_list (fst ra)))
                         (\ x ->
                           Inl ((showsl_literal "free variable " . showsl x) .
                                 showsl_literal " in right-hand side of"))))
                   (\ x ->
                     Inl (((x . showsl_literal " rule ") . showsl_rule ra) .
                           showsl_literal "\n"))
            else Inr ()))
        r)
      (\ x -> Inl (snd x)))
    (\ x -> Inl (showsl_literal "the Q-TRS is not weakly well-formed\n" . x));

check_compatible_nfs ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => Bool ->
                    (Term a b -> Bool) ->
                      [(Term a b, Term a b)] -> Bool -> [Term a b] -> Bool;
check_compatible_nfs nfs1 nf1 r1 nfs2 q2 =
  nfs1 == nfs2 || (null q2 || isOK (check_wwf_qtrs nf1 r1));

showsl_tp ::
  forall a b c.
    (Showl b, Showl c) => Tp_ops_ext a b c () -> a -> String -> String;
showsl_tp i t =
  let {
    nfs = nfsb i t;
    r = rc i t;
    rw = rwc i t;
    q = qb i t;
  } in ((showsl_trsa showsl showsl "rules:" " -> " r .
          (if null rw then id
            else showsl_trsa showsl showsl "relative rules:" " ->= " rw)) .
         (if null q then id else showsl_terms "Q-component:" q)) .
         (if nfs
           then showsl_lit "substitutions are assumed to be in normal form\n"
           else id);

check_tp_subsumes ::
  forall a b c d.
    (Eq b, Showl b, Eq c, Showl c, Eq d,
      Showl d) => Tp_ops_ext a (Lab b c) d () ->
                    (Bool,
                      ([Term (Lab b c) d],
                        ([(Term (Lab b c) d, Term (Lab b c) d)],
                          [(Term (Lab b c) d, Term (Lab b c) d)]))) ->
                      a -> Sum (String -> String) ();
check_tp_subsumes i (nfs, (q, (r, rw))) tp =
  catch_errora
    (let {
       nfsa = nfsb i tp;
       qa = is_QNFb i tp;
       ra = rc i tp;
       rwa = rwc i tp;
       rb = r ++ rw;
       nf1 = is_QNFb i tp;
     } in bindb (check (check_compatible_nfs nfsa nf1 (ra ++ rwa) nfs q)
                  (showsl_lit
                    "incompatible substitutions-in-normal-form flags"))
            (\ _ ->
              bindb (catch_errora (check_NF_terms_subset qa q)
                      (\ x ->
                        Inl (showsl_lit
                               "problem with innermost strategy due to term " .
                              showsl_terma x)))
                (\ _ ->
                  bindb (catch_errora (check_subseteq ra r)
                          (\ x -> Inl (toomuch "rule" (showsl_rule x))))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq rwa rb)
                              (\ x ->
                                Inl (toomuch "relative rule" (showsl_rule x))))
                        (\ _ -> Inr ())))))
    (\ x ->
      Inl ((((((showsl_lit "termination of the problem\n" . showsl_tp i tp) .
                showsl_lit
                  "\nmay not be concluded from assuming termination of the problem\n") .
               showsl_tp i (mkc i nfs q r rw)) .
              showsl_literal "\n") .
             x) .
            showsl_literal "\n"));

fcc_tt ::
  forall a b c.
    (Eq b, Showl b, Ccompare c, Eq c, Mapping_impl c,
      Showl c) => Tp_ops_ext a b c () ->
                    [Ctxt b c] ->
                      [(Term b c, Term b c)] -> a -> Sum (String -> String) a;
fcc_tt i fcs cRb tp =
  let {
    r = rc i tp;
    rw = rwc i tp;
    nfs = nfsb i tp;
    rb = r ++ rw;
  } in (case partition_rules fcs r cRb of {
         (cR, cRw) ->
           let {
             _ = qb i tp;
             vs = vars_trs_list rb;
             fas = funas_trs_list rb;
           } in (case bindb (check (not (null fcs))
                              (showsl_lit
                                "at least one flat context is required for flat context closure\n"))
                        (\ _ ->
                          bindb (catch_errora (forallM (check_flat_ctxt vs) fcs)
                                  (\ x -> Inl (snd x)))
                            (\ _ ->
                              bindb (catch_errora
                                      (forallM (check_is_flat_ctxt vs fas) fcs)
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  bindb (catch_errora
  (forallM (check_flat_ctxt_complete fcs) fas) (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora (forallM (check_rule_preserving fcs cR) r) (\ x -> Inl (snd x)))
(\ _ ->
  catch_errora (forallM (check_rule_preserving fcs cRb) rw)
    (\ x -> Inl (snd x)))))))
                  of {
                  Inl a -> Inl a;
                  Inr _ -> Inr (mkc i nfs [] cR cRw);
                });
       });

g_isEmpty_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> Bool;
g_isEmpty_dflt_basic_oops_rm_basic_ops s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ c -> c)
    (\ _ _ -> False) True;

ta_rhs_states_set :: forall a b. Ta_impl a b -> Rbt a ();
ta_rhs_states_set (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x4;

ta_rules_impl :: forall a b. Ta_impl a b -> Rbt (b, Nat) [Ta_rule_impl a b];
ta_rules_impl (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x2;

r_lhs_states_impl :: forall a b. Ta_rule_impl a b -> [a];
r_lhs_states_impl (TA_rule_impl f qsa q qs) = qsa;

rm_set_lookup :: forall a b. (Compare_order a) => Rbt a [b] -> a -> [b];
rm_set_lookup rm = (\ a -> (case lookup rm a of {
                             Nothing -> [];
                             Just rules -> rules;
                           }));

g_union_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Rbt a ();
g_union_dflt_basic_oops_rm_basic_ops s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s1 (\ _ -> True)
    ins_rm_basic_ops s2;

rs_Union :: forall a. (Compare_order a) => [Rbt a ()] -> Rbt a ();
rs_Union = foldl g_union_dflt_basic_oops_rm_basic_ops (empty_rm_basic_ops ());

rqss_impl :: forall a b. Ta_rule_impl a b -> Rbt a ();
rqss_impl (TA_rule_impl f qsa q qs) = qs;

ta_res_impl_all ::
  forall a b c.
    (Compare_order a,
      Compare_order b) => Rbt a () ->
                            Rbt (b, Nat) [Ta_rule_impl a b] ->
                              Term b c -> Rbt a ();
ta_res_impl_all q ta (Var uu) = q;
ta_res_impl_all q ta (Fun f ts) =
  let {
    rec = map (ta_res_impl_all q ta) ts;
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    arules =
      filter
        (\ rule ->
          let {
            qs = r_lhs_states_impl rule;
          } in all_interval_nat
                 (\ i -> memb_rm_basic_ops (nth qs i) (nth rec i)) zero_nat n)
        rules;
    a = map rqss_impl arules;
  } in rs_Union a;

rule_state_compatible_heuristic ::
  forall a b c.
    (Compare_order a, Compare_order b,
      Linorder c) => Ta_impl a b -> Term b c -> Bool;
rule_state_compatible_heuristic ta l =
  g_isEmpty_dflt_basic_oops_rm_basic_ops
    (ta_res_impl_all (ta_rhs_states_set ta) (ta_rules_impl ta) l);

check_state_raise_consistent ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Linorder a, Set_impl a, Showl a, Eq b,
      Showl b) => Tree_automaton a (b, Nat) ->
                    [(a, a)] -> Sum (String -> String) ();
check_state_raise_consistent ta rel =
  let {
    rels = set rel;
    rls = ta_rules_implb ta;
  } in catch_errora
         (forallM
           (\ r1 ->
             (case r1 of {
               TA_rule (f1, i1) qs1 q1 ->
                 catch_errora
                   (forallM
                     (\ r2 ->
                       (case r2 of {
                         TA_rule (f2, i2) qs2 q2 ->
                           (if f1 == f2 && less_nat i1 i2 && qs1 == qs2
                             then check (member (q1, q2) rels)
                                    (((((((showsl_lit
     "problem with raise consistency because of automaton-rules\n " .
    showsl_ta_rule r1) .
   showsl_literal "\n") .
  showsl_ta_rule r2) .
 showsl_literal "\n") .
showsl q1) .
                                       showsl_lit " is not >>^* ") .
                                      showsl q2)
                             else Inr ());
                       }))
                     rls)
                   (\ x -> Inl (snd x));
             }))
           rls)
         (\ x -> Inl (snd x));

ta_epsrs_impl :: forall a b. Ta_impl a b -> a -> Rbt a ();
ta_epsrs_impl (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x7;

ta_epss_impl :: forall a b. Ta_impl a b -> a -> Rbt a ();
ta_epss_impl (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x6;

g_inter_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Rbt a ();
g_inter_dflt_basic_oops_rm_basic_ops s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s1 (\ _ -> True)
    (\ x s -> (if memb_rm_basic_ops x s2 then ins_dj_rm_basic_ops x s else s))
    (empty_rm_basic_ops ());

ta_match_impl ::
  forall a b c.
    (Compare_order a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                 Rbt b () ->
                   (b -> Rbt b ()) -> Term a c -> [b] -> Rbt [(c, b)] ();
ta_match_impl ta qsig eps (Var x) q =
  g_from_list_dflt_basic_oops_rm_basic_ops
    (map (\ qa -> [(x, qa)])
      (g_to_list_dflt_basic_oops_rm_basic_ops
        (g_inter_dflt_basic_oops_rm_basic_ops (rs_Union (map eps q)) qsig)));
ta_match_impl ta qsig eps (Fun f ts) q =
  let {
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    ep = rs_Union (map eps q);
    fa = (\ rule ->
           g_from_list_dflt_basic_oops_rm_basic_ops
             (case rule of {
               TA_rule_impl _ qs qa _ ->
                 (if memb_rm_basic_ops qa ep
                   then let {
                          rec = map (\ (tsi, qsi) ->
                                      g_to_list_dflt_basic_oops_rm_basic_ops
(ta_match_impl ta qsig eps tsi [qsi]))
                                  (zip ts qs);
                        } in map concat (concat_lists rec)
                   else []);
             }));
  } in rs_Union (map fa rules);

ta_match_impla ::
  forall a b c.
    (Compare_order a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                 Rbt b () ->
                   (b -> Rbt b ()) -> [b] -> Term a c -> Rbt [(c, b)] ();
ta_match_impla ta qsig eps rhs t = ta_match_impl ta qsig eps t rhs;

ta_res_impl ::
  forall a b.
    (Compare_order a,
      Compare_order b) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                            (b -> Rbt b ()) -> Term a b -> Rbt b ();
ta_res_impl ta eps (Var q) = eps q;
ta_res_impl ta eps (Fun f ts) =
  let {
    rec = map (ta_res_impl ta eps) ts;
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    arules =
      filter
        (\ rule ->
          let {
            qs = r_lhs_states_impl rule;
          } in all_interval_nat
                 (\ i -> memb_rm_basic_ops (nth qs i) (nth rec i)) zero_nat n)
        rules;
    a = map rqss_impl arules;
  } in rs_Union a;

rule_state_compatible_eff_list ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => Ta_impl a b ->
                 (Rbt a () -> Rbt a () -> Maybe a) ->
                   (Term b c, Term b c) -> Sum ((Term b a, Term b a), a) ();
rule_state_compatible_eff_list ta rel =
  let {
    rm = ta_rules_impl ta;
    eps = ta_epss_impl ta;
    epsa = ta_epsrs_impl ta;
    ta_res = ta_res_impl rm eps;
    rhs_rbt = ta_rhs_states_set ta;
    rhs = g_to_list_dflt_basic_oops_rm_basic_ops rhs_rbt;
  } in (\ (l, r) ->
         catch_errora
           (forallM (\ sigma -> let {
                                  sigmaa = fun_of sigma;
                                  l_sigma = map_term (\ x -> x) sigmaa l;
                                  r_sigma = map_term (\ x -> x) sigmaa r;
                                  qsl = ta_res l_sigma;
                                  qsr = ta_res r_sigma;
                                } in (case rel qsl qsr of {
                                       Nothing -> Inr ();
                                       Just q -> Inl ((l_sigma, r_sigma), q);
                                     }))
             (g_to_list_dflt_basic_oops_rm_basic_ops
               (ta_match_impla rm rhs_rbt epsa rhs l)))
           (\ x -> Inl (snd x)));

state_compatible_eff_list ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => Ta_impl a b ->
                 (Rbt a () -> Rbt a () -> Maybe a) ->
                   [(Term b c, Term b c)] ->
                     Sum ((Term b c, Term b c), ((Term b a, Term b a), a)) ();
state_compatible_eff_list ta rel r =
  let {
    check = rule_state_compatible_eff_list ta rel;
  } in catch_errora
         (forallM (\ lr -> catch_errora (check lr) (\ x -> Inl (lr, x))) r)
         (\ x -> Inl (snd x));

ta_final_impl :: forall a b. Ta_impl a b -> Rbt a ();
ta_final_impl (TA_Impl x1 x2 x3 x4 x5 x6 x7) = x1;

flatten_term_enum_filter ::
  forall a b. (Term a b -> Bool) -> Term [a] b -> [Term a b];
flatten_term_enum_filter f (Var x) = let {
                                       tx = Var x;
                                     } in (if f tx then [tx] else []);
flatten_term_enum_filter f (Fun fs ts) =
  let {
    lts = map (flatten_term_enum_filter f) ts;
  } in (if any null lts then []
         else let {
                ss = concat_lists lts;
              } in filter f (concatMap (\ fa -> map (Fun fa) ss) fs));

inverse_base_term_filter ::
  forall a b. (Term (a, Nat) b -> Bool) -> Term a b -> Nat -> [Term (a, Nat) b];
inverse_base_term_filter filt l c =
  let {
    hs = upt zero_nat (suc c);
  } in flatten_term_enum_filter filt
         (map_term (\ f -> map (\ h -> lift h f) hs) (\ x -> x) l);

compute_height ::
  forall a b.
    (Eq a,
      Eq b) => Relation_kind ->
                 Term a b -> Term a b -> Term (a, Nat) b -> Nat -> Nat;
compute_height (Weak_TRS Nothing) bl br =
  (if less_eq_nat (size_multiset (funs_term_ms br))
        (size_multiset (funs_term_ms bl))
    then (\ l x ->
           (if equal_term (map_term (lift x) (\ xa -> xa) bl) l then x
             else suc x))
    else (\ _ -> suc));
compute_height (Weak_TRS (Just c)) bl br =
  (if less_eq_nat (size_multiset (funs_term_ms br))
        (size_multiset (funs_term_ms bl))
    then (\ l x ->
           (if equal_term (map_term (lift x) (\ xa -> xa) bl) l then min c x
             else min c (suc x)))
    else (\ _ x -> min c (suc x)));
compute_height Strict_TRS bl br = (\ _ -> suc);

cover_bound_list_filter ::
  forall a b.
    (Eq a,
      Eq b) => (Term (a, Nat) b -> Bool) ->
                 ((Term a b, Term a b) -> Term a b -> Bool) ->
                   Relation_kind ->
                     Nat ->
                       [(Term a b, Term a b)] ->
                         [(Term (a, Nat) b, Term (a, Nat) b)];
cover_bound_list_filter filt ff gg c r =
  concatMap
    (\ (l, ra) ->
      let {
        ch = compute_height gg l ra;
        ee = ff (l, ra);
      } in map (\ la ->
                 (la, map_term
                        (lift (ch la
                                (min_list
                                  (map height
                                    (sym_collect
                                      (\ t -> ee (map_term base (\ x -> x) t))
                                      la)))))
                        (\ x -> x) ra))
             (inverse_base_term_filter filt l c))
    r;

g_bex_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> (a -> Bool) -> Bool;
g_bex_dflt_basic_oops_rm_basic_ops s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s not (\ x _ -> p x)
    False;

ta_contains_aux_impl ::
  forall a b.
    (Compare_order a, Ceq b, Ccompare b, Eq b,
      Linorder b) => [(a, Nat)] ->
                       [b] -> Ta_impl b a -> Set b -> Sum (Term a b) ();
ta_contains_aux_impl f qs ta q =
  let {
    _ = ta_final_impl ta;
    look = rm_set_lookup (ta_rules_impl ta);
    _ = ta_epss_impl ta;
  } in catch_errora
         (forallM
           (\ (fa, n) ->
             let {
               rules = look (fa, n);
             } in catch_errora
                    (catch_errora
                      (forallM
                        (\ x ->
                          (if any (\ rule ->
                                    r_lhs_states_impl rule == x &&
                                      let {
qq = rqss_impl rule;
                                      } in
g_bex_dflt_basic_oops_rm_basic_ops qq (\ qa -> member qa q))
                                rules
                            then Inr () else Inl x))
                        (concat_lists (replicate n qs)))
                      (\ x -> Inl (snd x)))
                    (\ x -> Inl (Fun fa (map Var x))))
           f)
         (\ x -> Inl (snd x));

alpha_rm_basic_ops :: forall a. (Cenum a, Compare_order a) => Rbt a () -> Set a;
alpha_rm_basic_ops s = dom (lookup s);

ta_contains_impl ::
  forall a b.
    (Compare_order a, Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b,
      Set_impl b) => [(a, Nat)] ->
                       [(a, Nat)] -> Ta_impl b a -> [b] -> Sum (Term a b) ();
ta_contains_impl f g ta qs =
  bindb (ta_contains_aux_impl f qs ta (set qs))
    (\ _ ->
      ta_contains_aux_impl g qs ta (alpha_rm_basic_ops (ta_final_impl ta)));

check_coherent_rule ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Eq b,
      Showl b) => (a -> [a]) ->
                    Rbt (a, a) () ->
                      [Ta_rule a b] -> Ta_rule a b -> Sum (String -> String) ();
check_coherent_rule iter rel rules (TA_rule f qs q) =
  catch_errora
    (forallM
      (\ i ->
        let {
          qi = nth qs i;
        } in catch_errora
               (forallM
                 (\ qia ->
                   let {
                     qsa = list_update qs i qia;
                   } in check (not (null (filter
   (\ (TA_rule g qsb qa) ->
     f == g && qsa == qsb && memb_rm_basic_ops (q, qa) rel)
   rules)))
                          ((((((((((showsl_lit "rule " . showsl f) .
                                    showsl_lit "(") .
                                   showsl_list qs) .
                                  showsl_lit ") -> ") .
                                 showsl q) .
                                showsl_lit " with ") .
                               showsl_nat (suc i)) .
                              showsl_lit ". argument decreased to ") .
                             showsl qia) .
                            showsl_lit " has no counterpart"))
                 (iter qi))
               (\ x -> Inl (snd x)))
      (upt zero_nat (size_list qs)))
    (\ x -> Inl (snd x));

ntrancl ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Nat -> Set (a, a) -> Set (a, a);
ntrancl n r =
  (if equal_nat n zero_nat then r else let {
 ra = ntrancl (minus_nat n one_nat) r;
                                       } in sup_set ra (relcomp ra r));

trancl ::
  forall a.
    (Card_UNIV a, Ceq a, Ccompare a, Set_impl a) => Set (a, a) -> Set (a, a);
trancl a =
  (if finite a then ntrancl (minus_nat (card a) one_nat) a
    else (error :: forall a. String -> (() -> a) -> a) "trancl: infinite set"
           (\ _ -> trancl a));

check_coherent ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showl a, Eq b,
      Showl b) => Tree_automaton a b ->
                    Ta_relation a -> Sum (String -> String) ();
check_coherent (Tree_Automaton fin rules eps) (Some_Relation rel) =
  let {
    iter =
      (\ q ->
        map_filter
          (\ x -> (if (case x of {
                        (a, _) -> a == q;
                      })
                    then Just (snd x) else Nothing))
          rel);
    rs = g_from_list_dflt_basic_oops_rm_basic_ops rel;
    ep = set eps;
    rell = converse (set rel);
  } in bindb (catch_errora (check_subseteq (concatMap iter fin) fin)
               (\ x ->
                 Inl (showsl x .
                       showsl_lit
                         " is in relation to a final state, but not a final state itself")))
         (\ _ ->
           bindb (catch_errora
                   (forallM (check_coherent_rule iter rs rules) rules)
                   (\ x -> Inl (snd x)))
             (\ _ ->
               check (less_eq_set (relcomp rell ep)
                       (sup_set (relcomp (trancl ep) rell) rell))
                 (showsl_lit "problem in coherence of epsilon rules")));
check_coherent uu Decision_Proc_Old = Inr ();
check_coherent uu Decision_Proc = Inr ();
check_coherent uu Id_Relation = Inr ();

rtrancl_rbt_impl :: forall a. (Compare_order a) => [(a, a)] -> [a] -> Rbt a ();
rtrancl_rbt_impl =
  rtrancl_impl
    (\ r ->
      let {
        rm = elem_list_to_rm fst r;
      } in (\ asa ->
             g_to_list_dflt_basic_oops_rm_basic_ops
               (rs_Union
                 (map (\ a ->
                        g_from_list_dflt_basic_oops_rm_basic_ops
                          (map snd (rm_set_lookup rm a)))
                   asa))))
    (\ asa bs ->
      g_union_dflt_basic_oops_rm_basic_ops bs
        (g_from_list_dflt_basic_oops_rm_basic_ops asa))
    memb_rm_basic_ops (empty_rm_basic_ops ());

memo_rbt_rtrancl :: forall a. (Compare_order a) => [(a, a)] -> a -> Rbt a ();
memo_rbt_rtrancl r =
  let {
    tr = rtrancl_rbt_impl r;
    rm = g_list_to_map_rm_basic_ops
           (map (\ a -> (a, tr [a]))
             (((g_to_list_dflt_basic_oops_rm_basic_ops .
                 g_from_list_dflt_basic_oops_rm_basic_ops) .
                map fst)
               r));
  } in (\ a -> (case lookup rm a of {
                 Nothing -> g_from_list_dflt_basic_oops_rm_basic_ops [a];
                 Just asa -> asa;
               }));

conv_ta_rule :: forall a b. (a -> Rbt a ()) -> Ta_rule a b -> Ta_rule_impl a b;
conv_ta_rule eps (TA_rule f qs q) = TA_rule_impl f qs q (eps q);

r_sym_impl :: forall a b. Ta_rule_impl a b -> (b, Nat);
r_sym_impl (TA_rule_impl f qsa q qs) = (f, size_list qsa);

generate_ta ::
  forall a b.
    (Compare_order a, Compare_order b) => Tree_automaton a b -> Ta_impl a b;
generate_ta (Tree_Automaton fin rules eps) =
  let {
    ep = memo_rbt_rtrancl eps;
    epr = memo_rbt_rtrancl (map (\ (q, qa) -> (qa, q)) eps);
    rqs_rs = rs_Union (map (\ rule -> ep (r_rhs rule)) rules);
    rrules = map (conv_ta_rule ep) rules;
  } in TA_Impl (g_from_list_dflt_basic_oops_rm_basic_ops fin)
         (elem_list_to_rm r_sym_impl rrules)
         (g_to_list_dflt_basic_oops_rm_basic_ops rqs_rs) rqs_rs eps ep epr;

generate_ta_cond ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showl a, Compare_order b, Eq b,
      Showl b) => Tree_automaton a b ->
                    Ta_relation a -> Sum (String -> String) (Ta_impl a b);
generate_ta_cond ta rel =
  bindb (catch_errora (check_coherent ta rel)
          (\ x ->
            Inl (showsl_lit "automaton is not coherent w.r.t. relation\n" . x)))
    (\ _ -> Inr (generate_ta ta));

relation_as_list :: forall a. Ta_relation a -> Sum (String -> String) [(a, a)];
relation_as_list (Some_Relation rel) = Inr rel;
relation_as_list Id_Relation = Inr [];
relation_as_list Decision_Proc =
  Inl (showsl_lit "decision procedure not available for non-left linear TRSs");
relation_as_list Decision_Proc_Old =
  Inl (showsl_lit "decision procedure not available for non-left linear TRSs");

check_ta_bounded ::
  forall a b.
    (Linorder b,
      Showl b) => Ta_impl a (b, Nat) -> Nat -> Sum (String -> String) ();
check_ta_bounded ta c =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if (case x of {
                (f, _) -> less_eq_nat (height f) c;
              })
            then Inr () else Inl x))
        (map fst (g_to_list_rm_basic_ops (ta_rules_impl ta))))
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (case x of {
            (f, _) ->
              (showsl_prod f .
                showsl_lit " is symbol in TA with height larger than c = ") .
                showsl_nat c;
          }));

bounds_condition ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => Boundstype ->
                    [(Term a b, Term a b)] -> Sum (String -> String) ();
bounds_condition Roof uu = Inr ();
bounds_condition Match r =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if (case x of {
                (l, ra) -> subseteq_mset (vars_term_ms ra) (vars_term_ms l);
              })
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (case x of {
            (l, ra) ->
              (showsl_lit "rule " . showsl_rule (l, ra)) .
                showsl_lit " is duplicating";
          }));

non_collapsing_impl :: forall a b c. [(a, Term b c)] -> Bool;
non_collapsing_impl r = all ((\ t -> not (is_Var t)) . snd) r;

construct_c_opt :: forall a b. Nat -> [(Term a b, Term a b)] -> Maybe Nat;
construct_c_opt c r = (if non_collapsing_impl r then Just c else Nothing);

boundstype_fun ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => Boundstype -> (Term a b, Term a b) -> Term a b -> Bool;
boundstype_fun Roof = roof;
boundstype_fun Match = matcha;

iteratei_set_op_list_it_rs_ops ::
  forall a b.
    (Linorder a) => Rbt a () -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_set_op_list_it_rs_ops s =
  (\ c f -> rm_iterateoi (impl_of s) c (f . fst));

rs_subset :: forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Maybe a;
rs_subset asa bs =
  iteratei_set_op_list_it_rs_ops asa (\ a -> (case a of {
       Nothing -> True;
       Just _ -> False;
     }))
    (\ a _ -> (if memb_rm_basic_ops a bs then Nothing else Just a)) Nothing;

rel_checker ::
  forall a.
    (Compare_order a, Eq a) => Ta_relation a -> Rbt a () -> Rbt a () -> Maybe a;
rel_checker (Some_Relation rel) =
  (\ lhs rhs ->
    let {
      rlist = g_to_list_dflt_basic_oops_rm_basic_ops rhs;
    } in (case catch_errora
                 (forallM
                   (\ l -> check (any (\ r -> membera rel (l, r)) rlist) l)
                   (g_to_list_dflt_basic_oops_rm_basic_ops lhs))
                 (\ x -> Inl (snd x))
           of {
           Inl a -> Just a;
           Inr _ -> Nothing;
         }));
rel_checker Id_Relation = rs_subset;
rel_checker Decision_Proc = rs_subset;
rel_checker Decision_Proc_Old = rs_subset;

check_det ::
  forall a b. (Eq a, Eq b) => Tree_automaton a b -> Sum (String -> String) ();
check_det (Tree_Automaton fin rules eps) =
  catch_errora
    (bindb (check (null eps) (showsl_lit "epsilon transitions not allowed"))
      (\ _ ->
        check (distinct (map (\ (TA_rule f qs _) -> (f, qs)) (remdups rules)))
          (showsl_lit "some lhs occurs twice")))
    (\ x ->
      Inl (showsl_lit "problem when ensuring determinism of automata\n" . x));

check_bounds_generic ::
  forall a b c.
    (Compare_order a, Eq a, Showl a, Card_UNIV b, Cenum b, Ceq b, Ccompare b,
      Compare_order b, Eq b, Set_impl b, Showl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c,
      Showl c) => Bounds_info a b ->
                    [(Term a c, Term a c)] ->
                      [(Term a c, Term a c)] ->
                        [(a, Nat)] -> [(a, Nat)] -> Sum (String -> String) ();
check_bounds_generic (Bounds_Info typea c qfin preTA rel) r s f g =
  let {
    c_opt = construct_c_opt c r;
    rs = r ++ s;
  } in bindb (generate_ta_cond preTA rel)
         (\ ta ->
           let {
             rell = rel_checker rel;
           } in bindb (check_wf_trs rs)
                  (\ _ ->
                    bindb (check
                            (less_eq_set (set qfin)
                              (alpha_rm_basic_ops (ta_final_impl ta)))
                            (showsl_lit
                              "explicitly mentioned final states must be final"))
                      (\ _ ->
                        bindb (if isOK (check_left_linear_trs rs) then Inr ()
                                else bindb (catch_errora (check_det preTA)
     (\ x ->
       Inl (showsl_lit "for non left-linear TRS we require det. automaton\n" .
             x)))
                                       (\ _ ->
 bindb (relation_as_list rel) (check_state_raise_consistent preTA)))
                          (\ _ ->
                            bindb (bounds_condition typea rs)
                              (\ _ ->
                                bindb (check_ta_bounded ta c)
                                  (\ _ ->
                                    bindb (check
    (any (\ q -> memb_rm_basic_ops q (ta_rhs_states_set ta)) qfin)
    (showsl_lit "did not find mentioned final state in TA"))
                                      (\ _ ->
bindb (catch_errora
        (ta_contains_impl (map (\ (fa, a) -> (lift zero_nat fa, a)) f)
          (map (\ (fa, a) -> (lift zero_nat fa, a)) g) ta qfin)
        (\ x ->
          Inl (showsl_lit
                 "it could not be guaranteed that lift0(T(Sigma)) is accepted by TA\n" .
                (showsl_lit "there is no transition from " . showsl_terma x) .
                  showsl_lit " to a final state")))
  (\ _ ->
    bindb (catch_errora
            (state_compatible_eff_list ta rell
              (cover_bound_list_filter
                (\ l -> not (rule_state_compatible_heuristic ta l))
                (boundstype_fun typea) Strict_TRS c r))
            (\ x ->
              Inl (case x of {
                    (lr, (lr_rhs, q)) ->
                      ((((((showsl_lit "TA is not compatible with TRS\n" .
                             showsl_lit "for rule ") .
                            showsl_rule lr) .
                           showsl_lit "\nwhich is instantiated by states to ") .
                          showsl_rule lr_rhs) .
                         showsl_lit "\nthe state ") .
                        showsl q) .
                        showsl_lit " is only reachable from the lhs\n";
                  })))
      (\ _ ->
        catch_errora
          (state_compatible_eff_list ta rell
            (cover_bound_list_filter
              (\ l -> not (rule_state_compatible_heuristic ta l)) matcha
              (Weak_TRS c_opt) c s))
          (\ x ->
            Inl (case x of {
                  (lr, (lr_rhs, q)) ->
                    ((((((showsl_lit
                            "TA is not compatible with relative TRS\n" .
                           showsl_lit "for rule ") .
                          showsl_rule lr) .
                         showsl_lit "\nwhich is instantiated by states to ") .
                        showsl_rule lr_rhs) .
                       showsl_lit "\nthe state ") .
                      showsl q) .
                      showsl_lit " is only reachable from the lhs\n";
                })))))))))));

bounds_tt ::
  forall a b c d.
    (Compare_order b, Eq b, Showl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showl c,
      Card_UNIV d, Cenum d, Ceq d, Ccompare d, Compare_order d, Eq d,
      Set_impl d,
      Showl d) => Tp_ops_ext a b c () ->
                    Bounds_info b d -> a -> Sum (String -> String) ();
bounds_tt i info tp = let {
                        r = rulese i tp;
                        f = funas_trs_list r;
                      } in check_bounds_generic info r [] f f;

check_trs_termination_proof_main ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          a -> Trs_termination_proof b [Nat] [Char] ->
                                 Sum (String -> String) ();
check_trs_termination_proof_main j ia assms i tp R_is_Empty =
  debug i "R is empty"
    (if null (rc j tp) then Inr ()
      else Inl ((i . showsl_lit
                       ": R is not empty in the following termination-problem \n") .
                 showsl_tp j tp));
check_trs_termination_proof_main j ia assms i tp (Rule_Removal redp rR prf) =
  debug i "Rule Removal"
    (let {
       r = rulese j tp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora (rule_removal_tt j (get_redtriple redp) rr tp)
                  (\ x ->
                    Inl ((((((i . showsl_lit
                                    ": error when applying the rule removal technique on \n") .
                              showsl_tp j tp) .
                             showsl_lit "\n to remove the rules \n") .
                            showsl_rules rr) .
                           showsl_literal "\n") .
                          x)))
            (\ tpa ->
              catch_errora
                (check_trs_termination_proof_main j ia assms
                  (add_index i one_nat) tpa prf)
                (\ x ->
                  Inl ((i . showsl_lit
                              ": error below the rule removal technique\n") .
                        x))));
check_trs_termination_proof_main j ia assms i tp (DP_Trans nfs m p prf) =
  debug i "DP trans"
    (bindb
      (catch_errora (dependency_pairs_tt Sharp j ia tp nfs m p)
        (\ x ->
          Inl ((((((i . showsl_lit ": error when switching from the TRS\n") .
                    showsl_tp j tp) .
                   showsl_lit "\nto the initial DP problem with pairs \n") .
                  showsl_rules p) .
                 showsl_literal "\n") .
                x)))
      (\ dpp ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dpp
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below switch to dependency pairs\n") .
                  x))));
check_trs_termination_proof_main j ia assms i tp (String_Reversal prf) =
  debug i "String Reversal"
    (bindb
      (catch_errora (string_reversal_tt j tp)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error when applying string reversal on \n") .
                  showsl_tp j tp) .
                 showsl_literal "\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the string reversal technique\n") .
                  x))));
check_trs_termination_proof_main j ia assms i tp (Constant_String p prf) =
  debug i "Constant to Unary"
    (bindb
      (catch_errora (const_to_string_sound_tt p j tp)
        (\ x ->
          Inl (((((i . showsl_lit
                         ": error when turning constants into unary symbols on ") .
                   showsl_literal "\n") .
                  showsl_tp j tp) .
                 showsl_literal "\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the constant to unary technique\n") .
                  x))));
check_trs_termination_proof_main j ia assms i tp (Semlab sli lQ lAll prf) =
  debug i "Semlab"
    (bindb
      (catch_errora (semlab_fin_tt j sli lQ lAll tp)
        (\ x ->
          Inl (((((i . showsl_lit
                         ": error when applying semantic labelling on ") .
                   showsl_literal "\n") .
                  showsl_tp j tp) .
                 showsl_literal "\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the sem.lab technique\n") .
                  x))));
check_trs_termination_proof_main j ia assms i tp (Bounds info) =
  debug i "Bounds"
    (catch_errora (bounds_tt j info tp)
      (\ x ->
        Inl ((((i . showsl_lit
                      ": error when applying bounds on the termination problem \n") .
                showsl_tp j tp) .
               showsl_literal "\n") .
              x)));
check_trs_termination_proof_main j ia assms i tp (Uncurry u_info rR prf) =
  debug i "Uncurry"
    (bindb
      (catch_errora (uncurry_tt j u_info rR tp)
        (\ x ->
          Inl ((i . showsl_lit
                      ": error when applying currying transformation\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the uncurrying technique\n") .
                  x))));
check_trs_termination_proof_main j ia assms i tp (Fcc fcs r prf) =
  debug i "Fcc"
    (bindb
      (catch_errora (fcc_tt j fcs r tp)
        (\ x ->
          Inl ((i . showsl_lit ": error when applying flat context closure\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below flat context closure\n") .
                  x))));
check_trs_termination_proof_main j ia assms i tp (Split rrem prf1 prf2) =
  debug i "Split"
    (case split_tt j tp rrem of {
      (tp1, tp2) ->
        bindb (catch_errora
                (check_trs_termination_proof_main j ia assms
                  (add_index i one_nat) tp1 prf1)
                (\ x ->
                  Inl ((i . showsl_lit ": error below the splitting\n") . x)))
          (\ _ ->
            catch_errora
              (check_trs_termination_proof_main j ia assms
                (add_index i (nat_of_integer (2 :: Integer))) tp2 prf2)
              (\ x ->
                Inl ((i . showsl_lit ": error below the splitting\n") . x)));
    });
check_trs_termination_proof_main j ia assms i tp (Switch_Innermost joins prf) =
  debug i "Switch Innermost"
    (bindb
      (catch_errora (switch_innermost_tt j joins tp)
        (\ x ->
          Inl ((((i . showsl_lit ": error when switching to innermost on \n") .
                  showsl_tp j tp) .
                 showsl_literal "\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the switch to innermost\n") .
                  x))));
check_trs_termination_proof_main j ia assms i tp (Drop_Equality prf) =
  debug i "Drop Equality"
    (let {
       tpa = mkc j (nfsb j tp) (qb j tp) (rc j tp)
               (filter (\ (l, r) -> not (equal_term l r)) (rwc j tp));
     } in catch_errora
            (check_trs_termination_proof_main j ia assms (add_index i one_nat)
              tpa prf)
            (\ x ->
              Inl ((i . showsl_lit ": error below dropping equality rules\n") .
                    x)));
check_trs_termination_proof_main j ia assms i tp
  (Remove_Nonapplicable_Rules r prf) =
  debug i "Removing non-applicable rules"
    (let {
       _ = rc j tp;
     } in bindb (catch_errora (check_non_applicable_rules (is_QNFb j tp) r)
                  (\ x ->
                    Inl ((i . showsl_lit
                                ": error when removing non-applicable rules\n") .
                          showsl_rule x . showsl_lit " is applicable")))
            (\ _ ->
              let {
                tpa = delete_R_Rwb j tp r r;
              } in catch_errora
                     (check_trs_termination_proof_main j ia assms
                       (add_index i one_nat) tpa prf)
                     (\ x ->
                       Inl ((i . showsl_lit
                                   ": error below the non-applicable rules removal\n") .
                             x))));
check_trs_termination_proof_main j ia assms i tp (Permuting_AFS pi prf) =
  debug i "Permuting some rules"
    (bindb
      (catch_errora (argument_filter_tt j pi tp)
        (\ x ->
          Inl ((((i . showsl_lit ": error when permuting arguments on \n") .
                  showsl_tp j tp) .
                 showsl_literal "\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the permutation of arguments\n") .
                  x))));
check_trs_termination_proof_main j ia assms i tpa (Assume_SN tp ass) =
  debug i "Termination Assumption or Unknown Proof"
    (if assms
      then bindb (catch_errora (check_tp_subsumes j tp tpa)
                   (\ x ->
                     Inl (((i . showsl_lit
                                  ": error in termination assumption or unknown proof\n") .
                            x) .
                           showsl_literal "\n")))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (add_index i (suc ja)))
                       (check_dp_termination_proof_main j ia assms
                         (add_index i (suc ja)))
                       (check_fptrs_termination_proof_main j ia assms
                         (add_index i (suc ja)))
                       (check_unknown_proof_main j ia assms
                         (add_index i (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . showsl_lit
                      ": the proof contains a termination assumption or unknown proof\n"));

check_fptrs_termination_proof_main ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          ([(Ctxt (Lab b [Nat]) [Char],
                              (Term (Lab b [Nat]) [Char], Location))],
                            [(Term (Lab b [Nat]) [Char],
                               Term (Lab b [Nat]) [Char])]) ->
                            Fptrs_termination_proof b [Nat] [Char] ->
                              Sum (String -> String) ();
check_fptrs_termination_proof_main j ia assms i tpa (Assume_FP_SN tp ass) =
  debug i "Outermost Termination Assumption or Unknown Proof"
    (if assms
      then bindb (check (tpa == tp)
                   (showsl_lit
                     "outermost assumption does not match current goal"))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (add_index i (suc ja)))
                       (check_dp_termination_proof_main j ia assms
                         (add_index i (suc ja)))
                       (check_fptrs_termination_proof_main j ia assms
                         (add_index i (suc ja)))
                       (check_unknown_proof_main j ia assms
                         (add_index i (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . showsl_lit
                      ": the proof contains a termination assumption or unknown proof\n"));

check_dp_termination_proof_main ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          c -> Dp_termination_proof b [Nat] [Char] ->
                                 Sum (String -> String) ();
check_dp_termination_proof_main j ia assms i dpp P_is_Empty =
  debug i "P is empty"
    (if null (pb ia dpp) && (null (pwb ia dpp) || null (rd ia dpp)) then Inr ()
      else Inl ((i . showsl_lit
                       ": P is not empty in the following DP-problem\n") .
                 showsl_dpp ia dpp));
check_dp_termination_proof_main j ia assms i dpp
  (Subterm_Criterion_Proc p rseq rP prf) =
  debug i "Subterm_Criterion_Proc"
    (let {
       pa = pairsb ia dpp;
       pr = ceta_list_diff pa rP;
     } in bindb (catch_errora (subterm_criterion_proc ia p rseq pr dpp)
                  (\ x ->
                    Inl ((((((i . showsl_lit
                                    ": error when applying the subterm criterion to the DP problem\n") .
                              showsl_dpp ia dpp) .
                             showsl_lit "\nand trying to remove the pairs\n") .
                            showsl_rules pr) .
                           showsl_literal "\n") .
                          x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (add_index i one_nat) dppa prf)
                (\ x ->
                  Inl ((i . showsl_lit
                              ": error below the subterm criterion\n") .
                        x))));
check_dp_termination_proof_main j ia assms i dpp
  (Gen_Subterm_Criterion_Proc p pr prf) =
  debug i "Gen_Subterm_Criterion_Proc"
    (bindb
      (catch_errora (generalized_subterm_proc ia p pr dpp)
        (\ x ->
          Inl ((((((i . showsl_lit
                          ": error when applying the generalized subterm criterion to the DP problem\n") .
                    showsl_dpp ia dpp) .
                   showsl_lit "\nand trying to remove the pairs\n") .
                  showsl_rules pr) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the generalized subterm criterion\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp (Redpair_Proc redp rP prf) =
  debug i "Redpair_Proc"
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       proc =
         (case redp of {
           Inl rrp ->
             generic_ur_af_root_redtriple_proc ia (get_root_redtriple rrp)
               Nothing;
           Inr rp -> generic_ur_af_redtriple_proc ia (get_redtriple rp) Nothing;
         });
     } in bindb (catch_errora (proc pr dpp)
                  (\ x ->
                    Inl ((((((i . showsl_lit
                                    ": error when applying the reduction pair processor to remove from the DP problem\n") .
                              showsl_dpp ia dpp) .
                             showsl_lit "\n the pairs\n") .
                            showsl_rules pr) .
                           showsl_literal "\n") .
                          x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (add_index i one_nat) dppa prf)
                (\ x ->
                  Inl ((i . showsl_lit
                              ": error below the reduction pair processor\n") .
                        x))));
check_dp_termination_proof_main j ia assms i dpp (Usable_Rules_Proc u prf) =
  debug i "Usable_Rules_Proc"
    (bindb
      (catch_errora (usable_rules_proc ia u dpp)
        (\ x ->
          Inl ((((((i . showsl_lit
                          ": error when applying the usable rules processor to restrict the DP problem\n") .
                    showsl_dpp ia dpp) .
                   showsl_lit "\nto the usable rules\n") .
                  showsl_rules u) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the usable rules processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp (Q_Reduction_Proc q prf) =
  debug i "Q_Reduction_Proc"
    (bindb
      (catch_errora (q_reduction_proc ia q dpp)
        (\ x ->
          Inl ((i . showsl_lit
                      ": error when applying the Q-reduction processor\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the Q-reduction processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_Redpair_Proc redp rP rR prf) =
  debug i "Mono_Redpair_Proc"
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       r = rulesf ia dpp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora
                  (mono_redpair_proc ia (get_redtriple redp) pr rr dpp)
                  (\ x ->
                    Inl ((((((((i . showsl_lit
                                      ": error when applying the mono reduction pair processor to remove from the DP problem\n") .
                                showsl_dpp ia dpp) .
                               showsl_lit "\n the pairs\n") .
                              showsl_rules pr) .
                             showsl_lit "\n and the rules\n") .
                            showsl_rules rr) .
                           showsl_literal "\n") .
                          x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (add_index i one_nat) dppa prf)
                (\ x ->
                  Inl ((i . showsl_lit
                              ": error below the mono reduction pair processor\n") .
                        x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_URM_Redpair_Proc redp pr rr prf) =
  debug i "Mono_URM_Redpair_Proc"
    (bindb
      (catch_errora (mono_urm_redpair_proc ia (get_redtriple redp) pr rr dpp)
        (\ x ->
          Inl ((((((((i . showsl_lit
                            ": error when applying the mono reduction pair processor with usable repl. map to remove from the DP problem\n") .
                      showsl_dpp ia dpp) .
                     showsl_lit "\n the pairs\n") .
                    showsl_rules pr) .
                   showsl_lit "\n and the rules\n") .
                  showsl_rules rr) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the mono reduction pair processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp (Dep_Graph_Proc edpts) =
  debug i "Dep_Graph_Proc"
    (bindb
      (catch_errora (dep_graph_proc ia dpp edpts)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error while trying to perform Sctxt_closure-decomposition  on\n") .
                  showsl_dpp ia dpp) .
                 showsl_literal "\n") .
                x)))
      (\ pdpps ->
        catch_errora
          (catch_errora
            (forallM_index
              (\ (prof, dppa) ja ->
                check_dp_termination_proof_main j ia assms
                  (add_index i (suc ja)) dppa prof)
              pdpps)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the dependency graph processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp
  (Redpair_UR_Proc redp rP ur prf) =
  debug i "Redpair_UR_Proc"
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       proc =
         (case redp of {
           Inl rrp ->
             generic_ur_af_root_redtriple_proc ia (get_root_redtriple rrp)
               (Just ur);
           Inr rp ->
             generic_ur_af_redtriple_proc ia (get_redtriple rp) (Just ur);
         });
     } in bindb (catch_errora (proc pr dpp)
                  (\ x ->
                    Inl ((((((i . showsl_lit
                                    ": error when applying the reduction pair processor with usable rules to remove from the DP problem\n") .
                              showsl_dpp ia dpp) .
                             showsl_lit "\n the pairs\n") .
                            showsl_rules pr) .
                           showsl_literal "\n") .
                          x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (add_index i one_nat) dppa prf)
                (\ x ->
                  Inl ((i . showsl_lit
                              ": error below the reduction pair processor\n") .
                        x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_Redpair_UR_Proc redp rP rR ur prf) =
  debug i "Mono_Redpair_UR_Proc"
    (let {
       p = pairsb ia dpp;
       pr = ceta_list_diff p rP;
       r = rulesf ia dpp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora
                  (generic_mono_ur_redpair_proc ia (get_redtriple redp) pr rr ur
                    dpp)
                  (\ x ->
                    Inl ((((((((i . showsl_lit
                                      ": error when applying the mono reduction pair processor with usable rules to remove from the DP problem\n") .
                                showsl_dpp ia dpp) .
                               showsl_lit "\n the pairs\n") .
                              showsl_rules pr) .
                             showsl_lit "\n and the rules\n") .
                            showsl_rules rr) .
                           showsl_literal "\n") .
                          x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (add_index i one_nat) dppa prf)
                (\ x ->
                  Inl ((i . showsl_lit
                              ": error below the mono reduction pair processor with usable rules\n") .
                        x))));
check_dp_termination_proof_main j ia assms i dpp
  (Uncurry_Proc mode u_info p r prf) =
  debug i "Uncurry_Proc"
    (bindb
      (catch_errora (uncurry_proc_both ia mode u_info p r dpp)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error when applying the uncurrying processor on the DP problem\n") .
                  showsl_dpp ia dpp) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the uncurrying processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp
  (Size_Change_Subterm_Proc graphs) =
  debug i "Size_Change_Subterm_Proc"
    (catch_errora (sct_subterm_proc ia graphs dpp)
      (\ x ->
        Inl ((((i . showsl_lit
                      ": error when applying the size-change (subterm) processor on the DP problem\n") .
                showsl_dpp ia dpp) .
               showsl_literal "\n") .
              x)));
check_dp_termination_proof_main j ia assms i dpp
  (Size_Change_Redpair_Proc redp u_opt graphs) =
  debug i "Size_Change_Redpair_Proc"
    (catch_errora (sct_ur_af_proc ia (get_redtriple redp) graphs u_opt dpp)
      (\ x ->
        Inl ((((i . showsl_lit
                      ": error when applying the size-change (redpair) processor on the DP problem\n") .
                showsl_dpp ia dpp) .
               showsl_literal "\n") .
              x)));
check_dp_termination_proof_main j ia assms i dpp (Fcc_Proc f fcs pb r prf) =
  debug i "Fcc_Proc"
    (bindb
      (catch_errora (fcc_proc ia f fcs pb r dpp)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error when applying the flat context closure processor on the DP problem\n") .
                  showsl_dpp ia dpp) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the flat context closure processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp
  (Split_Proc prem rrem prf1 prf2) =
  debug i "Split_Proc"
    (case get_fcc_option prf1 of {
      Nothing ->
        (case split_proc ia dpp prem rrem of {
          (dpp1, dpp2) ->
            bindb (catch_errora
                    (check_dp_termination_proof_main j ia assms
                      (add_index i one_nat) dpp1 prf1)
                    (\ x ->
                      Inl ((i . showsl_lit
                                  ": error below the split processor\n") .
                            x)))
              (\ _ ->
                catch_errora
                  (check_dp_termination_proof_main j ia assms
                    (add_index i (nat_of_integer (2 :: Integer))) dpp2 prf2)
                  (\ x ->
                    Inl ((i . showsl_lit
                                ": error below the split processor\n") .
                          x)));
        });
      Just (f, (fcs, (pb, (rb, prf1a)))) ->
        debug i "Split_ProcFcc"
          (bindb (fcc_split_proc ia f fcs pb rb prem rrem dpp)
            (\ (dpp1, dpp2) ->
              bindb (catch_errora
                      (check_dp_termination_proof_main j ia assms
                        (add_index (add_index i one_nat) one_nat) dpp1 prf1a)
                      (\ x ->
                        Inl ((i . showsl_lit
                                    ": error below the split and fcc processor\n") .
                              x)))
                (\ _ ->
                  catch_errora
                    (check_dp_termination_proof_main j ia assms
                      (add_index i (nat_of_integer (2 :: Integer))) dpp2 prf2)
                    (\ x ->
                      Inl ((i . showsl_lit
                                  ": error below the split processor\n") .
                            x)))));
    });
check_dp_termination_proof_main j ia assms i dpp (Semlab_Proc sli lP lQ lR prf)
  = debug i "Semlab_Proc"
      (bindb
        (catch_errora (semlab_fin_proc ia sli lP lQ lR dpp)
          (\ x ->
            Inl ((((i . showsl_lit
                          ": error when applying the semlab processor on the DP problem\n") .
                    showsl_dpp ia dpp) .
                   showsl_literal "\n") .
                  x)))
        (\ dppa ->
          catch_errora
            (check_dp_termination_proof_main j ia assms (add_index i one_nat)
              dppa prf)
            (\ x ->
              Inl ((i . showsl_lit ": error below the semlab processor\n") .
                    x))));
check_dp_termination_proof_main j ia assms i dpp
  (Switch_Innermost_Proc joins prf) =
  debug i "Switch_Innermost_Proc"
    (bindb
      (catch_errora (switch_innermost_proc ia joins dpp)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error when applying the processor to switch to innermost on the DP problem\n") .
                  showsl_dpp ia dpp) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the switch to innermost processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dppa (Assume_Finite dpp ass) =
  debug i "Finiteness Assumption or Unknown Proof"
    (if assms
      then bindb (catch_errora (check_dpp_subsumes ia dpp dppa)
                   (\ x ->
                     Inl (((i . showsl_lit
                                  ": error in finiteness assumption or unknown proof\n") .
                            x) .
                           showsl_literal "\n")))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assma j ia
                         (check_trs_termination_proof_main j ia assms
                           (add_index i (suc ja)))
                         (check_dp_termination_proof_main j ia assms
                           (add_index i (suc ja)))
                         (check_fptrs_termination_proof_main j ia assms
                           (add_index i (suc ja)))
                         (check_unknown_proof_main j ia assms
                           (add_index i (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl ((i . showsl_lit ": error below unknown proof\n") . x)))
      else Inl (i . showsl_lit
                      ": the proof contains a finiteness assumption or unknown proof\n"));
check_dp_termination_proof_main j ia assms i dpp
  (Rewriting_Proc u_opt stb sta st lr p prf) =
  debug i "Rewriting_Proc"
    (bindb
      (catch_errora (rewriting_proc ia u_opt stb sta st lr p dpp)
        (\ x ->
          Inl ((((((i . showsl_lit
                          ": error when applying the rewriting processor to rewrite the pair \n") .
                    showsl_rule stb) .
                   showsl_lit "\n to the pair \n") .
                  showsl_rule st) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the rewriting processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp (Narrowing_Proc st p sts prf) =
  debug i "Narrowing_Proc"
    (bindb
      (catch_errora (narrowing_proc ia st p sts dpp)
        (\ x ->
          Inl ((((((i . showsl_lit
                          ": error when applying the narrowing processor to narrow the pair \n") .
                    showsl_rule st) .
                   showsl_lit "\n to the pairs \n") .
                  showsl_trs sts) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the narrowing processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp (Instantiation_Proc st sts prf)
  = debug i "Instantiation_Proc"
      (bindb
        (catch_errora (instantiation_proc ia st sts dpp)
          (\ x ->
            Inl ((((((i . showsl_lit
                            ": error when applying the instantiation processor to instantiate the pair \n") .
                      showsl_rule st) .
                     showsl_lit "\n to the pairs \n") .
                    showsl_trs sts) .
                   showsl_literal "\n") .
                  x)))
        (\ dppa ->
          catch_errora
            (check_dp_termination_proof_main j ia assms (add_index i one_nat)
              dppa prf)
            (\ x ->
              Inl ((i . showsl_lit
                          ": error below the instantiation processor\n") .
                    x))));
check_dp_termination_proof_main j ia assms i dpp
  (Forward_Instantiation_Proc st sts u_opt prf) =
  debug i "Forward_Instantiation_Proc"
    (bindb
      (catch_errora (forward_instantiation_proc ia st sts u_opt dpp)
        (\ x ->
          Inl ((((((i . showsl_lit
                          ": error when applying the forward_instantiation processor to instantiate the pair \n") .
                    showsl_rule st) .
                   showsl_lit "\n to the pairs \n") .
                  showsl_trs sts) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the forward instantiation processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp (Unlab_Proc p r prf) =
  debug i "Unlab_Proc" (Inl (showsl_lit "unlabeling processor not supported"));
check_dp_termination_proof_main j ia assms i dpp
  (General_Redpair_Proc rp ps pb prof prfs) =
  debug i "General_Redpair_ProcProc"
    (let {
       n = size_list prfs;
     } in bindb (check (less_nat zero_nat n)
                  (showsl_lit "at least one subproof is required"))
            (\ _ ->
              let {
                merge = equal_nat n one_nat;
              } in bindb (catch_errora
                           (conditional_general_reduction_pair_proc ia
                             (get_non_inf_order rp) ps pb prof merge dpp)
                           (\ x ->
                             Inl ((((i . showsl_lit
   ": error when applying the generic reduction pair processor to the DP problem\n") .
                                     showsl_dpp ia dpp) .
                                    showsl_literal "\n") .
                                   x)))
                     (\ dpps ->
                       bindb (catch_errora
                               (check_dp_termination_proof_main j ia assms
                                 (add_index i one_nat) (nth dpps zero_nat)
                                 (nth prfs zero_nat))
                               (\ x ->
                                 Inl ((i .
showsl_lit ": error below the generic reduction pair processor\n") .
                                       x)))
                         (\ _ ->
                           (if merge then Inr ()
                             else catch_errora
                                    (check_dp_termination_proof_main j ia assms
                                      (add_index i
(nat_of_integer (2 :: Integer)))
                                      (nth dpps one_nat) (nth prfs one_nat))
                                    (\ x ->
                                      Inl
((i . showsl_lit ": error below the generic reduction pair processor\n") .
  x)))))));
check_dp_termination_proof_main j ia assms i dpp
  (Complex_Constant_Removal_Proc p prf) =
  debug i "Complex_Constant_Removal_Proc"
    (bindb
      (catch_errora (complex_constant_removal_proc ia p dpp)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error when applying the complex constant removal processor to the DP problem\n") .
                  showsl_dpp ia dpp) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the complex constant removal processor\n") .
                  x))));
check_dp_termination_proof_main j ia assms i dpp (To_Trs_Proc prf) =
  debug i "To_Trs_Proc"
    (catch_errora
      (check_trs_termination_proof_main j ia assms (add_index i one_nat)
        (mk_tp j
          (nfsc ia dpp,
            (qc ia dpp, (pb ia dpp ++ rd ia dpp, pwb ia dpp ++ rwd ia dpp))))
        prf)
      (\ x ->
        Inl ((i . showsl_lit ": error below the To-Trs processor\n") . x)));

check_unknown_proof_main ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          [Char] ->
                            Unknown_proof b [Nat] [Char] ->
                              Sum (String -> String) ();
check_unknown_proof_main j ia assms i tpa (Assume_Unknown tp ass) =
  debug i "Unknown Proof"
    (if assms
      then bindb (catch_errora
                   (check (tpa == tp)
                     ((((showsl_lit "unknown problems are not identical: \n" .
                          showsl_lista tpa) .
                         showsl_literal "\n") .
                        showsl_lit " vs \n") .
                       showsl_lista tp))
                   (\ x ->
                     Inl (((i . showsl_lit
                                  ": error in termination assumption or unknown proof\n") .
                            x) .
                           showsl_literal "\n")))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (add_index i (suc ja)))
                       (check_dp_termination_proof_main j ia assms
                         (add_index i (suc ja)))
                       (check_fptrs_termination_proof_main j ia assms
                         (add_index i (suc ja)))
                       (check_unknown_proof_main j ia assms
                         (add_index i (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . showsl_lit ": the proof contains an unknown proof\n"));

map_assm_proof ::
  forall a b c d e f g.
    (a -> a) ->
      (b -> b) ->
        (c -> c) ->
          (d -> d) ->
            Generic_assm_proof e f g a b c () d ->
              Generic_assm_proof e f g a b c () d;
map_assm_proof tp dpp fptp unk (SN_assm_proof r p) = SN_assm_proof r (tp p);
map_assm_proof tp dpp fptp unk (Finite_assm_proof d p) =
  Finite_assm_proof d (dpp p);
map_assm_proof tp dpp fptp unk (SN_FP_assm_proof r p) =
  SN_FP_assm_proof r (fptp p);
map_assm_proof tp dpp fptp unk (Unknown_assm_proof u p) =
  Unknown_assm_proof u (unk p);
map_assm_proof tp dpp fptp unk (Not_SN_assm_proof v va) =
  Not_SN_assm_proof v va;
map_assm_proof tp dpp fptp unk (Infinite_assm_proof v va) =
  Infinite_assm_proof v va;
map_assm_proof tp dpp fptp unk (Not_RelSN_assm_proof v va) =
  Not_RelSN_assm_proof v va;
map_assm_proof tp dpp fptp unk (Not_SN_FP_assm_proof v va) =
  Not_SN_FP_assm_proof v va;
map_assm_proof tp dpp fptp unk (Complexity_assm_proof v va) =
  Complexity_assm_proof v va;

no_decr ::
  forall a b c.
    (Eq a, Eq b,
      Eq c) => [(Term (Lab a b) c, Term (Lab a b) c)] ->
                 [(Term (Lab a b) c, Term (Lab a b) c)];
no_decr =
  filter
    (\ (l, r) ->
      not (not (equal_term l r) &&
            equal_term (map_term unlab (\ x -> x) l)
              (map_term unlab (\ x -> x) r)));

unlab_of_trs ::
  forall a b c.
    (Eq a, Eq b,
      Eq c) => [(Term (Lab a b) c, Term (Lab a b) c)] ->
                 [(Term (Lab a b) c, Term (Lab a b) c)];
unlab_of_trs r = map (map_funs_rule unlab) (no_decr r);

updatec :: forall a b c. (a -> b) -> (a, c) -> (b, c);
updatec p_to_p (p, info) = (p_to_p p, info);

unlab_to_split_trs ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Trs_termination_proof a b c -> Trs_termination_proof a b c;
unlab_to_split_trs (DP_Trans a1 a2 a3 p) =
  DP_Trans a1 a2 a3 (fst (unlab_to_split_dp p));
unlab_to_split_trs (Rule_Removal a1 a2 p) =
  Rule_Removal a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (String_Reversal p) = String_Reversal (unlab_to_split_trs p);
unlab_to_split_trs (Constant_String a1 p) =
  Constant_String a1 (unlab_to_split_trs p);
unlab_to_split_trs (Bounds a) = Bounds a;
unlab_to_split_trs (Uncurry a1 a2 p) = Uncurry a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (Semlab a1 a2 a3 p) = Semlab a1 a2 a3 (unlab_to_split_trs p);
unlab_to_split_trs R_is_Empty = R_is_Empty;
unlab_to_split_trs (Fcc a1 a2 p) = Fcc a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (Split a1 p q) =
  Split a1 (unlab_to_split_trs p) (unlab_to_split_trs q);
unlab_to_split_trs (Switch_Innermost a1 p) =
  Switch_Innermost a1 (unlab_to_split_trs p);
unlab_to_split_trs (Drop_Equality p) = Drop_Equality (unlab_to_split_trs p);
unlab_to_split_trs (Remove_Nonapplicable_Rules a1 p) =
  Remove_Nonapplicable_Rules a1 (unlab_to_split_trs p);
unlab_to_split_trs (Permuting_AFS a1 p) =
  Permuting_AFS a1 (unlab_to_split_trs p);
unlab_to_split_trs (Assume_SN a p) =
  Assume_SN a
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_unknown ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Unknown_proof a b c -> Unknown_proof a b c;
unlab_to_split_unknown (Assume_Unknown a1 p) =
  Assume_Unknown a1
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_otrs ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Fptrs_termination_proof a b c -> Fptrs_termination_proof a b c;
unlab_to_split_otrs (Assume_FP_SN a p) =
  Assume_FP_SN a
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_dp ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Dp_termination_proof a b c ->
                 (Dp_termination_proof a b c,
                   [([(Term (Lab a b) c, Term (Lab a b) c)],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        Dp_termination_proof a b c))]);
unlab_to_split_dp P_is_Empty = (P_is_Empty, []);
unlab_to_split_dp (Dep_Graph_Proc ps) =
  (Dep_Graph_Proc
     (map (\ (po, a) -> (map_option (fst . unlab_to_split_dp) po, a)) ps),
    []);
unlab_to_split_dp (Subterm_Criterion_Proc a1 a2 a3 p) =
  updatec (Subterm_Criterion_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Gen_Subterm_Criterion_Proc a1 a2 p) =
  updatec (Gen_Subterm_Criterion_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Redpair_Proc a1 a2 p) =
  updatec (Redpair_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Redpair_UR_Proc a1 a2 a3 p) =
  updatec (Redpair_UR_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Usable_Rules_Proc a1 p) =
  updatec (Usable_Rules_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Q_Reduction_Proc a1 p) =
  updatec (Q_Reduction_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_Redpair_Proc a1 a2 a3 p) =
  updatec (Mono_Redpair_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_URM_Redpair_Proc a1 a2 a3 p) =
  updatec (Mono_URM_Redpair_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_Redpair_UR_Proc a1 a2 a3 a4 p) =
  updatec (Mono_Redpair_UR_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Size_Change_Subterm_Proc a1) =
  (Size_Change_Subterm_Proc a1, []);
unlab_to_split_dp (Size_Change_Redpair_Proc a1 a2 a3) =
  (Size_Change_Redpair_Proc a1 a2 a3, []);
unlab_to_split_dp (Uncurry_Proc a1 a2 a3 a4 p) =
  updatec (Uncurry_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Fcc_Proc a1 a2 a3 a4 p) =
  updatec (Fcc_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Switch_Innermost_Proc a1 p) =
  updatec (Switch_Innermost_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Rewriting_Proc a1 a2 a3 a4 a5 a6 p) =
  updatec (Rewriting_Proc a1 a2 a3 a4 a5 a6) (unlab_to_split_dp p);
unlab_to_split_dp (Narrowing_Proc a1 a2 a3 p) =
  updatec (Narrowing_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Instantiation_Proc a1 a2 p) =
  updatec (Instantiation_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Forward_Instantiation_Proc a1 a2 a3 p) =
  updatec (Forward_Instantiation_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Assume_Finite d p) =
  (Assume_Finite d
     (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
            unlab_to_split_otrs unlab_to_split_unknown)
       p),
    []);
unlab_to_split_dp (To_Trs_Proc p) = (To_Trs_Proc (unlab_to_split_trs p), []);
unlab_to_split_dp (Unlab_Proc pa r p) =
  (case unlab_to_split_dp p of {
    (pb, list) -> (P_is_Empty, (pa, (r, pb)) : list);
  });
unlab_to_split_dp (Split_Proc a1 a2 p q) =
  (Split_Proc a1 a2 (fst (unlab_to_split_dp p)) (fst (unlab_to_split_dp q)),
    []);
unlab_to_split_dp (Semlab_Proc a1 lP a2 lR p) =
  (case unlab_to_split_dp p of {
    (pa, list) ->
      let {
        sl = Semlab_Proc a1 lP a2 lR pa;
      } in (case list of {
             [] -> (sl, list);
             (pb, (r, prof)) : lista -> let {
  ulP = unlab_of_trs lP;
  ulR = unlab_of_trs lR;
  pr = ceta_list_diff ulP pb;
  rr = ceta_list_diff ulR r;
} in (Split_Proc pr rr sl prof, lista);
           });
  });
unlab_to_split_dp (General_Redpair_Proc a1 a2 a3 a4 ps) =
  (General_Redpair_Proc a1 a2 a3 a4 ps, []);
unlab_to_split_dp (Complex_Constant_Removal_Proc a1 p) =
  updatec (Complex_Constant_Removal_Proc a1) (unlab_to_split_dp p);

check_trs_termination_proof ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          a -> Trs_termination_proof b [Nat] [Char] ->
                                 Sum (String -> String) ();
check_trs_termination_proof ia j a i tp prf =
  check_trs_termination_proof_main ia j a i tp (unlab_to_split_trs prf);

rule_lab_repr_to_lab ::
  forall a b.
    (Compare_order a,
      Compare_order b) => [((Term a b, Term a b), Nat)] ->
                            (Term a b, Term a b) -> Nat;
rule_lab_repr_to_lab ps = fun_of_map (ceta_map_of ps) zero_nat;

critical_peaks_impl ::
  forall a.
    (Eq a) => [(Term a [Char], Term a [Char])] ->
                [(Term a [Char], Term a [Char])] ->
                  [(Bool,
                     ((Term a [Char],
                        ((Term a [Char], Term a [Char]),
                          ([Nat],
                            ([Char] -> Term a [Char], (Bool, Term a [Char]))))),
                       (Term a [Char],
                         ((Term a [Char], Term a [Char]),
                           ([Nat],
                             ([Char] -> Term a [Char],
                               (Bool, Term a [Char])))))))];
critical_peaks_impl p r =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ pa ->
          let {
            c = ctxt_of_pos_term pa l;
            la = subt_at l pa;
            b = equal_ctxt c Hole;
          } in (if is_Var la then []
                 else concatMap
                        (\ (lb, rb) ->
                          (case mgu_var_disjoint_generic
                                  (\ a ->
                                    Char False False False True True True True
                                      False :
                                      a)
                                  (\ a ->
                                    Char True False False True True True True
                                      False :
                                      a)
                                  la lb
                            of {
                            Nothing -> [];
                            Just (sigma, tau) ->
                              [(b, ((subst_apply_term l sigma,
                                      ((l, ra),
([], (sigma, (True, subst_apply_term ra sigma))))),
                                     (subst_apply_term l sigma,
                                       ((lb, rb),
 (pa, (tau, (True,
              ctxt_apply_term (subst_apply_ctxt c sigma)
                (subst_apply_term rb tau))))))))];
                          }))
                        r))
        (poss_list l))
    p;

check_rstepsa ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [([Nat], ((Term a b, Term a b), Term a b))] ->
                      Term a b -> Term a b -> Sum (String -> String) ();
check_rstepsa r [] s u =
  check (equal_term s u)
    ((((showsl_literal "the last term of the rewrite sequence\n" .
         showsl_terma s) .
        showsl_literal "\ndoes not correspond to the goal term\n") .
       showsl_terma u) .
      showsl_literal "\n");
check_rstepsa r ((p, (lr, t)) : rs) s u =
  bindb (check_rstep r p lr s t) (\ _ -> check_rstepsa r rs t u);

showsl_eq ::
  forall a b. (Showl a, Showl b) => (Term a b, Term a b) -> String -> String;
showsl_eq = showsl_rulea showsl showsl " = ";

check_estep ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [Nat] ->
                      (Term a b, Term a b) ->
                        Bool ->
                          Term a b -> Term a b -> Sum (String -> String) ();
check_estep e p rule l_to_r s t =
  bindb (check (membera e rule)
          ((((showsl_rule rule . showsl_lit "is not an equation of") .
              showsl_literal "\n") .
             showsl_eqs e) .
            showsl_literal "\n"))
    (\ _ ->
      bindb (check (in_poss p s)
              (((showsl_lista p . showsl_lit " is not a position of ") .
                 showsl_terma s) .
                showsl_literal "\n"))
        (\ _ ->
          bindb (check (in_poss p t)
                  (((showsl_lista p . showsl_lit " is not a position of ") .
                     showsl_terma t) .
                    showsl_literal "\n"))
            (\ _ ->
              let {
                c = ctxt_of_pos_term p s;
                d = ctxt_of_pos_term p t;
                u = subt_at s p;
                v = subt_at t p;
                rrule = (if l_to_r then rule else (snd rule, fst rule));
                err = ((((((((showsl_lit "the term " . showsl_terma t) .
                              showsl_lit
                                " does not result from a proper application of term ") .
                             showsl_terma s) .
                            showsl_lit " using equation ") .
                           showsl_literal "\n") .
                          showsl_eq rrule) .
                         showsl_lit " at position ") .
                        showsl_lista p) .
                        showsl_literal "\n";
              } in (case match_list Var [(fst rrule, u), (snd rrule, v)] of {
                     Nothing -> Inl err;
                     Just _ -> check (equal_ctxt c d) err;
                   }))));

check_conversion ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [([Nat], ((Term a b, Term a b), (Bool, Term a b)))] ->
                      Term a b -> Term a b -> Sum (String -> String) ();
check_conversion e [] s u =
  check (equal_term s u)
    (((((((showsl_lit "the last term of the conversion " .
            showsl_literal "\n") .
           showsl_terma s) .
          showsl_literal "\n") .
         showsl_lit "does not correspond to the goal term") .
        showsl_literal "\n") .
       showsl_terma u) .
      showsl_literal "\n");
check_conversion e ((p, (r, (l_to_r, t))) : c) s u =
  bindb (check_estep e p r l_to_r s t) (\ _ -> check_conversion e c t u);

check_ELD_1_nat ::
  Nat -> Nat -> [Nat] -> [Nat] -> [Nat] -> Sum (String -> String) ();
check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3 =
  bindb (catch_errora
          (forallM
            (\ x ->
              check (less_nat x beta)
                ((((showsl_lit "the labels are not decreasing: " .
                     showsl_nat x) .
                    showsl_lit " is not smaller ") .
                   showsl_nat beta) .
                  showsl_literal "\n"))
            sigma_1)
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ x ->
                  check (less_eq_nat x alpha)
                    ((((showsl_lit "the labels are not decreasing: " .
                         showsl_nat x) .
                        showsl_lit " is not smaller equal ") .
                       showsl_nat alpha) .
                      showsl_literal "\n"))
                sigma_2)
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (check (less_eq_nat (size_list sigma_2) one_nat)
                  (showsl_lit
                    "  the length of the middle sequence is greater 1\n"))
            (\ _ ->
              catch_errora
                (forallM
                  (\ x ->
                    check (less_nat x alpha || less_nat x beta)
                      ((((((showsl_lit "the labels are not decreasing: " .
                             showsl_nat x) .
                            showsl_lit " is not smaller ") .
                           showsl_nat alpha) .
                          showsl_lit " or smaller ") .
                         showsl_nat beta) .
                        showsl_literal "\n"))
                  sigma_3)
                (\ x -> Inl (snd x)))));

rule_labeling ::
  forall a b.
    ((Term a b, Term a b) -> Nat) ->
      (Term a b,
        ((Term a b, Term a b), ([Nat], (b -> Term a b, (Bool, Term a b))))) ->
        Nat;
rule_labeling i (s, (rl, (p, (sigma, t)))) = i rl;

eseq_to_step_list ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b ->
                           [([Nat],
                              ((Term a b, Term a b), (Bool, Term a b)))] ->
                             [(Term a b,
                                ((Term a b, Term a b),
                                  ([Nat], (b -> Term a b, (Bool, Term a b)))))];
eseq_to_step_list s [] = [];
eseq_to_step_list s ((p, (lr, (b, t))) : steps) =
  let {
    u = subt_at s p;
    v = subt_at t p;
  } in (if b then let {
                    sigma =
                      (case match_list Var [(fst lr, u), (snd lr, v)] of {
                        Just tau -> tau;
                      });
                  } in (s, (lr, (p, (sigma, (b, t))))) :
                         eseq_to_step_list t steps
         else let {
                sigma = (case match_list Var [(snd lr, u), (fst lr, v)] of {
                          Just tau -> tau;
                        });
              } in (t, (lr, (p, (sigma, (b, s))))) : eseq_to_step_list t steps);

eseq_to_ddconv ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b,
                           [([Nat],
                              ((Term a b, Term a b), (Bool, Term a b)))]) ->
                           (Term a b,
                             [(Term a b,
                                ((Term a b, Term a b),
                                  ([Nat],
                                    (b -> Term a b, (Bool, Term a b)))))]);
eseq_to_ddconv (s, eseq) = (s, eseq_to_step_list s eseq);

cpeak_instance ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b ->
                           (Term a b, Term a b) ->
                             Term a b -> (Term a b, Term a b) -> Bool;
cpeak_instance sa cpa s cp =
  not (is_none
        (match_list (\ _ -> sa)
          [(sa, s), (fst cpa, fst cp), (snd cpa, snd cp)]));

rseq_to_step_list ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b ->
                           [([Nat], ((Term a b, Term a b), Term a b))] ->
                             [(Term a b,
                                ((Term a b, Term a b),
                                  ([Nat], (b -> Term a b, (Bool, Term a b)))))];
rseq_to_step_list s [] = [];
rseq_to_step_list s ((p, (lr, t)) : steps) =
  let {
    u = subt_at s p;
    v = subt_at t p;
    sigma = (case match_list Var [(fst lr, u), (snd lr, v)] of {
              Just tau -> tau;
            });
  } in (s, (lr, (p, (sigma, (True, t))))) : rseq_to_step_list t steps;

rseq_to_ddseq ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b,
                           [([Nat], ((Term a b, Term a b), Term a b))]) ->
                           (Term a b,
                             [(Term a b,
                                ((Term a b, Term a b),
                                  ([Nat],
                                    (b -> Term a b, (Bool, Term a b)))))]);
rseq_to_ddseq (s, rseq) = (s, rseq_to_step_list s rseq);

get_source ::
  forall a b.
    (Term a b,
      ((Term a b, Term a b), ([Nat], (b -> Term a b, (Bool, Term a b))))) ->
      Term a b;
get_source s = fst s;

eseq_last ::
  forall a b.
    Term a b -> [([Nat], ((Term a b, Term a b), (Bool, Term a b)))] -> Term a b;
eseq_last s steps = last (s : map (\ (_, (_, (_, sa))) -> sa) steps);

check_cpeak_eldc ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    ((Term a b,
                       ((Term a b, Term a b),
                         ([Nat], (b -> Term a b, (Bool, Term a b))))),
                      (Term a b,
                        ((Term a b, Term a b),
                          ([Nat], (b -> Term a b, (Bool, Term a b)))))) ->
                      Term a b ->
                        (Term a b, Term a b) ->
                          [([Nat], ((Term a b, Term a b), (Bool, Term a b)))] ->
                            [([Nat], ((Term a b, Term a b), Term a b))] ->
                              [([Nat],
                                 ((Term a b, Term a b), (Bool, Term a b)))] ->
                                [([Nat],
                                   ((Term a b, Term a b), (Bool, Term a b)))] ->
                                  [([Nat], ((Term a b, Term a b), Term a b))] ->
                                    [([Nat],
                                       ((Term a b, Term a b),
 (Bool, Term a b)))] ->
                                      ((Term a b, Term a b) -> Nat) ->
Maybe Nat -> Sum (String -> String) ();
check_cpeak_eldc r p s cp cl_1 sl cl_2 cr_1 sr cr_2 lab n =
  (case p of {
    ((s1, (r1, (_, (_, (True, t1))))), (_, (r2, (_, (_, (True, t2)))))) ->
      bindb (check (cpeak_instance s cp s1 (t1, t2)) id)
        (\ _ ->
          let {
            u_1 = eseq_last (fst cp) cl_1;
            v_1 = eseq_last (snd cp) cr_1;
            u_2 = rseq_last u_1 sl;
            v_2 = rseq_last v_1 sr;
            u_3 = eseq_last u_2 cl_2;
            v_3 = eseq_last v_2 cr_2;
          } in bindb (check_conversion r cl_1 (fst cp) u_1)
                 (\ _ ->
                   bindb (check_rstepsa r sl u_1 u_2)
                     (\ _ ->
                       bindb (check_conversion r cl_2 u_2 u_3)
                         (\ _ ->
                           bindb (check_conversion r cr_1 (snd cp) v_1)
                             (\ _ ->
                               bindb (check_rstepsa r sr v_1 v_2)
                                 (\ _ ->
                                   bindb (check_conversion r cr_2 v_2 v_3)
                                     (\ _ ->
                                       bindb
 (check (equal_term u_3 v_3)
   ((((showsl_lit "the conversions end in different terms: " .
        showsl_terma u_3) .
       showsl_lit " and ") .
      showsl_terma v_3) .
     showsl_literal "\n"))
 (\ _ ->
   let {
     alpha = lab r1;
     beta = lab r2;
     cl_1a = snd (eseq_to_ddconv (fst cp, cl_1));
     sla = snd (rseq_to_ddseq (u_1, sl));
     cl_2a = snd (eseq_to_ddconv (u_2, cl_2));
     cr_1a = snd (eseq_to_ddconv (snd cp, cr_1));
     sra = snd (rseq_to_ddseq (v_1, sr));
     cr_2a = snd (eseq_to_ddconv (v_2, cr_2));
     tau_1 = map (rule_labeling lab) cl_1a;
     tau_2 = map (rule_labeling lab) sla;
     tau_3 = map (rule_labeling lab) cl_2a;
     sigma_1 = map (rule_labeling lab) cr_1a;
     sigma_2 = map (rule_labeling lab) sra;
     sigma_3 = map (rule_labeling lab) cr_2a;
   } in bindb (check_ELD_1_nat alpha beta tau_1 tau_2 tau_3)
          (\ _ ->
            bindb (check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3)
              (\ _ ->
                (case n of {
                  Nothing -> Inr ();
                  Just na ->
                    let {
                      check_reachable =
                        (\ t ->
                          check (membera (reachable_terms r s na) t)
                            ((((((showsl_lit "the fan property is violated: " .
                                   showsl_terma t) .
                                  showsl_lit " is not reachable from ") .
                                 showsl_terma s) .
                                showsl_lit " in ") .
                               showsl_nat na) .
                              showsl_lit " steps\n"));
                    } in bindb (catch_errora
                                 (forallM check_reachable
                                   (map get_source cl_1a))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             bindb (catch_errora
                                     (forallM check_reachable
                                       (map get_source sla))
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 bindb (catch_errora
 (forallM check_reachable (map get_source cl_2a)) (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (catch_errora
     (forallM check_reachable (map get_source cr_1a)) (\ x -> Inl (snd x)))
                                       (\ _ ->
 bindb (catch_errora (forallM check_reachable (map get_source sra))
         (\ x -> Inl (snd x)))
   (\ _ ->
     catch_errora (forallM check_reachable (map get_source cr_2a))
       (\ x -> Inl (snd x)))))));
                })))))))))));
  });

check_rule_labeling_eldc ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    [((Term a [Char], Term a [Char]), Nat)] ->
                      [(Term a [Char],
                         (Term a [Char],
                           ([([Nat],
                               ((Term a [Char], Term a [Char]),
                                 (Bool, Term a [Char])))],
                             ([([Nat],
                                 ((Term a [Char], Term a [Char]),
                                   Term a [Char]))],
                               ([([Nat],
                                   ((Term a [Char], Term a [Char]),
                                     (Bool, Term a [Char])))],
                                 (Term a [Char],
                                   ([([Nat],
                                       ((Term a [Char], Term a [Char]),
 (Bool, Term a [Char])))],
                                     ([([Nat],
 ((Term a [Char], Term a [Char]), Term a [Char]))],
                                       [([Nat],
  ((Term a [Char], Term a [Char]), (Bool, Term a [Char])))]))))))))] ->
                        Maybe Nat -> Sum (String -> String) ();
check_rule_labeling_eldc r lab cs n =
  let {
    cps = critical_peaks_impl r r;
    l = rule_lab_repr_to_lab lab;
    convs =
      cs ++ map (\ (s, (u, (cl_1, (sl, (cl_2, (v, (cr_1, (sr, cr_2)))))))) ->
                  (s, (v, (cr_1, (sr, (cr_2, (u, (cl_1, (sl, cl_2)))))))))
              cs;
  } in catch_errora
         (forallM
           (\ (_, a) ->
             (case a of {
               (aa, b) ->
                 (case aa of {
                   (s1, (r1, (p1, (sigma_1, (_, t1))))) ->
                     (\ (s2, (r2, (p2, (sigma_2, (true, t2))))) ->
                       catch_errora
                         (check (equal_term t1 t2)
                           (showsl_lit " pair non-trivial "))
                         (\ _ ->
                           catch_errora
                             (existsM
                               (\ (s, (u,
(cl_1, (sl, (cl_2, (v, (cr_1, (sr, cr_2))))))))
                                 -> check_cpeak_eldc r
                                      ((s1, (r1, (p1, (sigma_1, (true, t1))))),
(s2, (r2, (p2, (sigma_2, (true, t2))))))
                                      s (u, v) cl_1 sl cl_2 cr_1 sr cr_2 l n)
                               convs)
                             (\ x ->
                               Inl (((((((((showsl_literal "\n" .
     showsl_lit "the critical peak ") .
    showsl_terma t1) .
   showsl_lit " <- ") .
  showsl_terma s1) .
 showsl_lit " -> ") .
showsl_terma t2) .
                                       showsl_lit
 " could not be joined decreasingly:") .
                                      showsl_literal "\n") .
                                     showsl_sep id id x))));
                 })
                   b;
             }))
           cps)
         (\ x -> Inl (snd x));

split_seq :: Nat -> Nat -> [Nat] -> ([Nat], ([Nat], [Nat]));
split_seq alpha beta ss =
  (case span (\ n -> less_nat n alpha) ss of {
    (ssa, r) ->
      (case r of {
        [] -> (ssa, ([], []));
        h : t ->
          (if less_eq_nat h beta then (ssa, ([h], t)) else (ssa, ([], r)));
      });
  });

check_cpeak_eld ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    ((Term a b,
                       ((Term a b, Term a b),
                         ([Nat], (b -> Term a b, (Bool, Term a b))))),
                      (Term a b,
                        ((Term a b, Term a b),
                          ([Nat], (b -> Term a b, (Bool, Term a b)))))) ->
                      (Term a b, Term a b) ->
                        [([Nat], ((Term a b, Term a b), Term a b))] ->
                          [([Nat], ((Term a b, Term a b), Term a b))] ->
                            ((Term a b, Term a b) -> Nat) ->
                              Sum (String -> String) ();
check_cpeak_eld r p cp j1 j2 lab =
  (case p of {
    ((_, (r1, (_, (_, (True, t1))))), (_, (r2, (_, (_, (True, t2)))))) ->
      bindb (check (instance_rule (t1, t2) cp) id)
        (\ _ ->
          let {
            u = rseq_last (fst cp) j1;
            v = rseq_last (snd cp) j2;
          } in bindb (check_rstepsa r j1 (fst cp) u)
                 (\ _ ->
                   bindb (check_rstepsa r j2 (snd cp) v)
                     (\ _ ->
                       bindb (check (equal_term u v)
                               ((((showsl_lit
                                     "the rewrite sequences end in different terms: " .
                                    showsl_terma u) .
                                   showsl_lit " and ") .
                                  showsl_terma v) .
                                 showsl_literal "\n"))
                         (\ _ ->
                           let {
                             alpha = lab r1;
                             beta = lab r2;
                             tau = map (rule_labeling lab)
                                     (snd (rseq_to_ddseq (t1, j1)));
                             sigma =
                               map (rule_labeling lab)
                                 (snd (rseq_to_ddseq (t2, j2)));
                           } in (case split_seq alpha beta tau of {
                                  (tau_1, (tau_2, tau_3)) ->
                                    (case split_seq beta alpha sigma of {
                                      (sigma_1, (sigma_2, sigma_3)) ->
bindb (check_ELD_1_nat alpha beta tau_1 tau_2 tau_3)
  (\ _ -> check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3);
                                    });
                                })))));
  });

check_rule_labeling_eld ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    [((Term a [Char], Term a [Char]), Nat)] ->
                      [(Term a [Char],
                         ([([Nat],
                             ((Term a [Char], Term a [Char]), Term a [Char]))],
                           (Term a [Char],
                             [([Nat],
                                ((Term a [Char], Term a [Char]),
                                  Term a [Char]))])))] ->
                        Sum (String -> String) ();
check_rule_labeling_eld r lab js =
  let {
    cps = critical_peaks_impl r r;
    l = rule_lab_repr_to_lab lab;
    joins = js ++ map (\ (u, (j1, (v, j2))) -> (v, (j2, (u, j1)))) js;
  } in catch_errora
         (forallM
           (\ (_, a) ->
             (case a of {
               (aa, b) ->
                 (case aa of {
                   (s1, (r1, (p1, (sigma_1, (_, t1))))) ->
                     (\ (s2, (r2, (p2, (sigma_2, (true, t2))))) ->
                       catch_errora
                         (check (equal_term t1 t2)
                           (showsl_lit " pair non-trivial "))
                         (\ _ ->
                           catch_errora
                             (existsM
                               (\ (u, (j1, (v, j2))) ->
                                 check_cpeak_eld r
                                   ((s1, (r1, (p1, (sigma_1, (true, t1))))),
                                     (s2, (r2, (p2, (sigma_2, (true, t2))))))
                                   (u, v) j1 j2 l)
                               joins)
                             (\ x ->
                               Inl (((showsl_lit "\nthe critical peak " .
                                       showsl_rulea showsl showsl_lista
 " <- . -> " (t1, t2)) .
                                      showsl_lit
" could not be joined decreasingly:\n") .
                                     showsl_sep id id x))));
                 })
                   b;
             }))
           cps)
         (\ x -> Inl (snd x));

check_estepa ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [Nat] ->
                      (Term a b, Term a b) ->
                        Bool ->
                          Term a b -> Term a b -> Sum (String -> String) ();
check_estepa e p rule l_to_r s t =
  bindb (check (any (eq_rule_mod_vars rule) e)
          (((showsl_rule rule . showsl_lit " is not an equation of\n") .
             showsl_eqs e) .
            showsl_literal "\n"))
    (\ _ ->
      bindb (check (in_poss p s)
              (((showsl_pos p . showsl_lit " is not a position of ") .
                 showsl_terma s) .
                showsl_literal "\n"))
        (\ _ ->
          bindb (check (in_poss p t)
                  (((showsl_pos p . showsl_lit " is not a position of ") .
                     showsl_terma t) .
                    showsl_literal "\n"))
            (\ _ ->
              let {
                c = ctxt_of_pos_term p s;
                d = ctxt_of_pos_term p t;
                u = subt_at s p;
                v = subt_at t p;
                rrule = (if l_to_r then rule else (snd rule, fst rule));
                err = (((((((showsl_lit "the term " . showsl_terma t) .
                             showsl_lit
                               " does not result from a proper application of term ") .
                            showsl_terma s) .
                           showsl_lit " using equation\n") .
                          showsl_eq rrule) .
                         showsl_lit " at position ") .
                        showsl_pos p) .
                        showsl_literal "\n";
              } in (case match_list Var [(fst rrule, u), (snd rrule, v)] of {
                     Nothing -> Inl err;
                     Just _ -> check (equal_ctxt c d) err;
                   }))));

check_conversiona ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [([Nat], ((Term a b, Term a b), (Bool, Term a b)))] ->
                      Term a b -> Term a b -> Sum (String -> String) ();
check_conversiona e [] s u =
  check (equal_term s u)
    ((((showsl_lit "the last term of the conversion\n" . showsl_terma s) .
        showsl_lit "\ndoes not correspond to the goal term\n") .
       showsl_terma u) .
      showsl_literal "\n");
check_conversiona e ((p, (r, (l_to_r, t))) : c) s u =
  bindb (check_estepa e p r l_to_r s t) (\ _ -> check_conversiona e c t u);

check_redundant_rules ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Nat ->
                        [[([Nat], ((Term a b, Term a b), (Bool, Term a b)))]] ->
                          Sum (String -> String) ();
check_redundant_rules ra r n convs =
  let {
    s = list_diff r ra;
    t = list_diff ra r;
  } in bindb (catch_errora
               (forallM
                 (\ (l, rb) ->
                   check (membera (reachable_terms ra l n) rb)
                     (showsl_lit "could not simulate rule " .
                       showsl_rule (l, rb)))
                 s)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ (l, raa) ->
                 catch_errora
                   (existsM (\ conv -> check_conversiona r conv l raa) convs)
                   (\ _ -> check_join_BFS_limit n r l raa))
               t)
             (\ x -> Inl (snd x)));

sig_is_clean :: forall a b. (Eq a, Showl a, Showl b) => [(a, ([b], b))] -> Bool;
sig_is_clean sig = distinct (map (\ (f, (tys, _)) -> (f, size_list tys)) sig);

annotate_term ::
  forall a b c.
    (Showl a, Eq b,
      Showl c) => ((a, Nat) -> Maybe ([b], b)) ->
                    b -> Term a c -> Sum (String -> String) (Term a (c, b));
annotate_term sigF alpha (Var x) = Inr (Var (x, alpha));
annotate_term sigF alpha (Fun f ts) =
  (case sigF (f, size_list ts) of {
    Nothing ->
      Inl (showsl_lit "persistent decomposition: no signature for symbol " .
            showsl f);
    Just (tys, ty) ->
      (if not (alpha == ty)
        then Inl (((showsl_lit "persistent decomposition: " . showsl f) .
                    showsl_lit " has wrong type in ") .
                   showsl_terma (Fun f ts))
        else bindb (mapM (\ (a, b) -> annotate_term sigF a b) (zip tys ts))
               (\ tsa -> Inr (Fun f tsa)));
  });

annotate_terma ::
  forall a b c.
    (Showl a, Eq b,
      Showl c) => ((a, Nat) -> Maybe ([b], b)) ->
                    Term a c -> Sum (String -> String) (b, Term a (c, b));
annotate_terma sigF t =
  (case root t of {
    Nothing -> Inl id;
    Just fn ->
      (case sigF fn of {
        Nothing ->
          Inl (showsl_lit "persistent decomposition: no signature for symbol " .
                showsl_prod fn);
        Just (_, alpha) ->
          bindb (annotate_term sigF alpha t) (\ ta -> Inr (alpha, ta));
      });
  });

check_rule ::
  forall a b c.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b, Showl b, Ccompare c, Eq c,
      Mapping_impl c,
      Showl c) => ((a, Nat) -> Maybe ([b], b)) ->
                    (Term a c, Term a c) ->
                      Sum (String -> String) (Term a (c, b), Term a (c, b));
check_rule sigF rl =
  (case rl of {
    (l, r) ->
      bindb (annotate_terma sigF l)
        (\ (alpha, la) ->
          bindb (annotate_term sigF alpha r)
            (\ ra ->
              bindb (catch_errora
                      (check_variants_rule
                        (map_term (\ x -> x) (\ x -> (x, alpha)) l,
                          map_term (\ x -> x) (\ x -> (x, alpha)) r)
                        (la, ra))
                      (\ _ ->
                        Inl (showsl_lit
                               "persistent decomposition: inconsistent types of variables in rule " .
                              showsl_rule (l, r))))
                (\ _ -> Inr (la, ra))));
  });

mk_sigF :: forall a b. (Eq a) => [(a, ([b], b))] -> (a, Nat) -> Maybe ([b], b);
mk_sigF sig (f, a) =
  map_option snd
    (find (\ (fa, (tys, _)) -> f == fa && equal_nat a (size_list tys)) sig);

check_persistence1 ::
  forall a b c d.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b, Showl b, Ccompare c, Eq c,
      Mapping_impl c, Showl c, Ccompare d, Eq d, Mapping_impl d,
      Showl d) => [(a, ([b], b))] ->
                    [(Term a c, Term a c)] ->
                      [[(Term a d, Term a d)]] ->
                        Sum (String -> String)
                          ([(Term a (c, b), Term a (c, b))],
                            [[(Term a (d, b), Term a (d, b))]]);
check_persistence1 sig r rs =
  bindb (check (sig_is_clean sig)
          (showsl_lit
            "persistent decomposition: duplicate function symbol in signature"))
    (\ _ ->
      bindb (check_wf_trs r)
        (\ _ ->
          bindb (mapM check_wf_trs rs)
            (\ _ ->
              let {
                sigF = mk_sigF sig;
              } in bindb (mapM (check_rule sigF) r)
                     (\ ra ->
                       bindb (mapM (mapM (check_rule sigF)) rs)
                         (\ rsa -> Inr (ra, rsa))))));

memo_list_rtrancl :: forall a. (Eq a) => [(a, a)] -> a -> [a];
memo_list_rtrancl r = let {
                        tr = rtrancl_list_impl r;
                        rm = map (\ a -> (a, tr [a])) ((remdups . map fst) r);
                      } in (\ a -> (case map_of rm a of {
                                     Nothing -> [a];
                                     Just asa -> asa;
                                   }));

sigF_arcs_code :: forall a b. (Showl a, Showl b) => [(a, ([b], b))] -> [(b, b)];
sigF_arcs_code sig =
  concatMap (\ (_, (tys, ty)) -> map (\ a -> (ty, a)) tys) sig;

needed_types_code ::
  forall a b. (Showl a, Eq b, Showl b) => [(a, ([b], b))] -> b -> [b];
needed_types_code sig = memo_list_rtrancl (sigF_arcs_code sig);

maximal_types_loop :: forall a. (Eq a) => (a -> [a]) -> [a] -> [a];
maximal_types_loop nt [] = [];
maximal_types_loop nt (beta : tys) =
  let {
    mt = maximal_types_loop nt tys;
    nt_beta = nt beta;
  } in (if any (\ alpha -> membera (nt alpha) beta) mt then mt
         else beta : filter (\ alpha -> not (membera nt_beta alpha)) mt);

maximal_types ::
  forall a b. (Showl a, Eq b, Showl b) => [(a, ([b], b))] -> (b -> [b]) -> [b];
maximal_types sig nt = maximal_types_loop nt (map (snd . snd) sig);

check_litsim_trs ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] -> Sum (String -> String) ();
check_litsim_trs ra r =
  catch_errora
    (bindb (check_variants_trs ra r) (\ _ -> check_variants_trs r ra))
    (\ x ->
      Inl (((showsl_trs ra . showsl_lit "\nis not literally similar to ") .
             showsl_trs r) .
            x));

type_of_rule ::
  forall a b c d e. ((a, Nat) -> Maybe (b, c)) -> (Term a d, e) -> c;
type_of_rule sigF r = snd (the (sigF (the (root (fst r)))));

check_persistence_cr ::
  forall a b c.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b, Showl b, Ccompare c, Eq c,
      Mapping_impl c,
      Showl c) => [(a, ([b], b))] ->
                    [(Term a c, Term a c)] ->
                      [[(Term a c, Term a c)]] -> Sum (String -> String) ();
check_persistence_cr sig r rs =
  bindb (check_persistence1 sig r rs)
    (\ (ra, rsa) ->
      let {
        sigF = mk_sigF sig;
        needed_types = needed_types_code sig;
        types = maximal_types sig needed_types;
      } in catch_errora
             (forallM
               (\ ty ->
                 let {
                   s = filter
                         (\ rb ->
                           membera (needed_types ty) (type_of_rule sigF rb))
                         ra;
                 } in catch_errora (existsM (check_litsim_trs s) ([] : rsa))
                        (\ _ ->
                          Inl ((((showsl_lit
                                    "persistent decomposition: missing system induced by sort " .
                                   showsl ty) .
                                  showsl_lit ":") .
                                 showsl_literal "\n") .
                                showsl_trs
                                  (map (\ (l, rb) ->
 (map_term (\ x -> x) snd l, map_term (\ x -> x) snd rb))
                                    s))))
               types)
             (\ x -> Inl (snd x)));

check_cr_proof ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Bool ->
                    (String -> String) ->
                      Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                          [(Term (Lab b [Nat]) [Char],
                             Term (Lab b [Nat]) [Char])] ->
                            Cr_proof b [Nat] [Char] ->
                              Sum (String -> String) ();
check_cr_proof a ia i j r (SN_WCR joins_i prf) =
  debug ia "SN_WCR"
    (let {
       tp = mkc i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a (add_index ia one_nat) tp
                    prf)
                  (\ x ->
                    Inl ((ia . showsl_lit
                                 ": error below strong normalization + wcr\n") .
                          x)))
            (\ _ ->
              catch_errora
                (check_critical_pairs r (critical_pairs_impl r r) joins_i)
                (\ x ->
                  Inl ((((ia . showsl_lit
                                 ": error when proving local confluence of ") .
                          showsl_tp i tp) .
                         showsl_literal "\n") .
                        x))));
check_cr_proof a ia i j r Weakly_Orthogonal =
  debug ia "Weakly Orthogonal"
    (catch_errora (check_weakly_orthogonal r)
      (\ x ->
        Inl (((ia . showsl_lit
                      ": error in checking weakly orthogonality of the ") .
               showsl_trs r) .
              x)));
check_cr_proof a ia i j r (Strongly_Closed n) =
  debug ia "Strongly Closed"
    (catch_errora (check_strongly_closed r n)
      (\ x ->
        Inl (((ia . showsl_lit
                      ": error in checking strong closedness for the ") .
               showsl_trs r) .
              x)));
check_cr_proof a ia i j r (Rule_Labeling rl joins prf) =
  debug ia "Rule Labeling"
    (bindb
      (case prf of {
        Nothing -> check_linear_trs r;
        Just prfa ->
          bindb (check_left_linear_trs r)
            (\ _ ->
              (case partition (\ lr -> linear_term (snd lr)) r of {
                (rnd, rd) ->
                  let {
                    tp = mkc i False [] rd rnd;
                  } in catch_errora
                         (check_trs_termination_proof i j a
                           (add_index ia one_nat) tp prfa)
                         (\ x ->
                           Inl ((ia . showsl_lit
": error below relative termination for rule labeling\n") .
                                 x));
              }));
      })
      (\ _ ->
        catch_errora (check_rule_labeling_eld r rl joins)
          (\ x ->
            Inl (((ia . showsl_lit
                          ": error in checking decreasingness of CPs using rule labeling for the ") .
                   showsl_trs r) .
                  x))));
check_cr_proof a ia i j r (Rule_Labeling_Conv rl convs nprf) =
  debug ia "Rule Labeling"
    (case nprf of {
      Nothing ->
        bindb (check_linear_trs r)
          (\ _ ->
            catch_errora (check_rule_labeling_eldc r rl convs Nothing)
              (\ x ->
                Inl (((ia . showsl_lit
                              ": error in checking decreasingness of CPs using rule labeling for the ") .
                       showsl_trs r) .
                      x)));
      Just (n, prf) ->
        bindb (check_left_linear_trs r)
          (\ _ ->
            (case partition (\ lr -> linear_term (snd lr)) r of {
              (rnd, rd) ->
                let {
                  tp = mkc i False [] rd rnd;
                } in bindb (catch_errora
                             (check_trs_termination_proof i j a
                               (add_index ia one_nat) tp prf)
                             (\ x ->
                               Inl ((ia . showsl_lit
    ": error below relative termination for rule labeling\n") .
                                     x)))
                       (\ _ ->
                         catch_errora
                           (check_rule_labeling_eldc r rl convs (Just n))
                           (\ x ->
                             Inl (((ia . showsl_lit
   ": error in checking decreasingness of CPs using rule labeling for the ") .
                                    showsl_trs r) .
                                   x)));
            }));
    });
check_cr_proof a ia i j r (Redundant_Rules rs n convs prf) =
  debug ia "Redundant Rules"
    (bindb
      (catch_errora (check_cr_proof a (add_index ia one_nat) i j rs prf)
        (\ x ->
          Inl (((ia . showsl_lit ": error below confluence of modified TRS\n") .
                 showsl_trs rs) .
                x)))
      (\ _ ->
        catch_errora (check_redundant_rules r rs n convs)
          (\ x ->
            Inl (((((ia . showsl_lit
                            ": error in checking redundant rules transformation of the ") .
                     showsl_trs r) .
                    showsl_lit "transformed to the ") .
                   showsl_trs rs) .
                  x))));
check_cr_proof a ia i j r (Parallel_Closed n) =
  debug ia "Parallel Closed"
    (catch_errora (check_parallel_closed r n)
      (\ x ->
        Inl (((ia . showsl_lit
                      ": error in checking parallel closedness for the ") .
               showsl_trs r) .
              x)));
check_cr_proof a ia i j r (Critical_Pair_Closing_System c prf n) =
  debug ia "Critical-Pair-Closing System"
    (let {
       tp = mkc i False [] c [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a (add_index ia one_nat) tp
                    prf)
                  (\ x ->
                    Inl ((ia . showsl_lit
                                 ": error below strong normalization of CPCS\n") .
                          x)))
            (\ _ ->
              catch_errora (check_critical_pair_closing r c n)
                (\ x ->
                  Inl ((((ia . showsl_lit
                                 ": error when closing critical pairs of ") .
                          showsl_tp i tp) .
                         showsl_literal "\n") .
                        x))));
check_cr_proof a ia i j r (Persistent_Decomposition sig ps) =
  debug ia "Persistent Decomposition"
    (let {
       checks =
         map (map_prod id (\ prf iaa p -> check_cr_proof a iaa i j p prf)) ps;
     } in bindb (catch_errora
                  (forallM
                    (\ (n, (prf, f)) ->
                      catch_errora (f (add_index ia n) prf)
                        (\ x ->
                          Inl ((ia . showsl_lit
                                       ": error while checking confluence of subproblems\n") .
                                x)))
                    (enumerate one_nat checks))
                  (\ x -> Inl (snd x)))
            (\ _ ->
              catch_errora (check_persistence_cr sig r (map fst ps))
                (\ x ->
                  Inl (((ia . showsl_lit
                                ": error in checking persistent decomposition of ") .
                         showsl_trs r) .
                        x))));

edges_to_adj_fun :: forall a. (Compare_order a, Eq a) => [(a, a)] -> a -> [a];
edges_to_adj_fun e =
  precompute_fun
    (\ a ->
      remdups (concatMap (\ ea -> (if fst ea == a then [snd ea] else [])) e))
    (remdups (map fst e ++ map snd e));

create_graph_impl ::
  forall a.
    (Compare_order a,
      Eq a) => [(a, a)] -> Gen_g_impl_ext (a -> Bool) (a -> [a]) [a] ();
create_graph_impl e =
  Gen_g_impl_ext (membera (map fst e ++ map snd e)) (edges_to_adj_fun e)
    (remdups (map fst e ++ map snd e)) ();

as_singleton :: forall a b. (One b) => a -> (Array.Array a, b);
as_singleton x = (Array.Array [x], onea);

gi_V0 :: forall a b c d. Gen_g_impl_ext a b c d -> c;
gi_V0 (Gen_g_impl_ext gi_V gi_E gi_V0 more) = gi_V0;

as_is_empty :: forall a. (Array.Array a, Nat) -> Bool;
as_is_empty s = equal_nat (snd s) zero_nat;

rev_append :: forall a. [a] -> [a] -> [a];
rev_append [] ac = ac;
rev_append (x : xs) ac = rev_append xs (x : ac);

glist_delete_aux :: forall a. (a -> a -> Bool) -> a -> [a] -> [a] -> [a];
glist_delete_aux eq x [] asa = asa;
glist_delete_aux eq x (y : ys) asa =
  (if eq x y then rev_append asa ys else glist_delete_aux eq x ys (y : asa));

glist_delete :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
glist_delete eq x l = glist_delete_aux eq x l [];

select_edge_tr ::
  forall a.
    (Eq a,
      Linorder a) => ((Array.Array a, Nat),
                       ((Array.Array Nat, Nat),
                         (Rbta a Int, (Array.Array (Nat, [a]), Nat)))) ->
                       (Maybe a,
                         ((Array.Array a, Nat),
                           ((Array.Array Nat, Nat),
                             (Rbta a Int, (Array.Array (Nat, [a]), Nat)))));
select_edge_tr s =
  (case s of {
    (a, (aa, (ab, bb))) ->
      (if as_is_empty bb then (Nothing, (a, (aa, (ab, bb))))
        else (case as_top bb of {
               (ac, bc) ->
                 (if less_eq_nat (as_get aa (minus_nat (as_length aa) one_nat))
                       ac
                   then let {
                          xa = gen_pick (\ x -> foldli (id x)) bc;
                          xb = glist_delete (\ ad b -> ad == b) xa bc;
                          xc = (if is_Nil xb then as_pop bb
                                 else as_set bb
(minus_nat (as_length bb) one_nat) (ac, xb));
                        } in (Just xa, (a, (aa, (ab, xc))))
                   else (Nothing, (a, (aa, (ab, bb)))));
             }));
  });

as_empty :: forall a b. (Zero b) => () -> (Array.Array a, b);
as_empty uu = (Array.Array [], zerob);

stat_start :: () -> ();
stat_start = (\ _ -> ());

last_seg_tr ::
  forall a.
    (Linorder a) => ((Array.Array a, Nat),
                      ((Array.Array Nat, Nat),
                        (Rbta a Int, (Array.Array (Nat, [a]), Nat)))) ->
                      [a];
last_seg_tr s =
  (case s of {
    (a, (aa, (_, _))) ->
      (case while (\ (xe, _) ->
                    less_nat xe
                      (if equal_nat
                            (plus_nat (minus_nat (as_length aa) one_nat)
                              one_nat)
                            (as_length aa)
                        then as_length a
                        else as_get aa
                               (plus_nat (minus_nat (as_length aa) one_nat)
                                 one_nat)))
              (\ (ac, bc) -> let {
                               xa = as_get a ac;
                             } in (suc ac, xa : bc))
              (as_get aa (minus_nat (as_length aa) one_nat), [])
        of {
        (_, bc) -> bc;
      });
  });

collapse_tr ::
  forall a.
    (Compare_order a) => a -> ((Array.Array a, Nat),
                                ((Array.Array Nat, Nat),
                                  (Rbta a Int,
                                    (Array.Array (Nat, [a]), Nat)))) ->
                                ((Array.Array a, Nat),
                                  ((Array.Array Nat, Nat),
                                    (Rbta a Int,
                                      (Array.Array (Nat, [a]), Nat))));
collapse_tr v s =
  (case s of {
    (a, (aa, (ab, bb))) -> let {
                             x = idx_of_tr v (a, (aa, (ab, bb)));
                             xa = as_take (plus_nat x one_nat) aa;
                           } in (a, (xa, (ab, bb)));
  });

stat_stop :: () -> ();
stat_stop = (\ _ -> ());

compute_SCC_tr ::
  forall a b.
    (Compare_order a,
      Eq a) => Gen_g_impl_ext (a -> Bool) (a -> [a]) [a] b -> [[a]];
compute_SCC_tr g =
  let {
    _ = stat_start ();
    xa = ([], Empty);
    a = foldli (id (gi_V0 g)) (\ _ -> True)
          (\ xb (a, b) ->
            (if not (case rbt_lookup b xb of {
                      Nothing -> False;
                      Just i ->
                        (if less_eq_int zero_int i then False else True);
                    })
              then let {
                     xc = (a, (as_singleton xb,
                                (as_singleton zero_nat,
                                  (rbt_insert xb (int_of_nat zero_nat) b,
                                    (if is_Nil (gi_E g xb) then as_empty ()
                                      else as_singleton
     (zero_nat, gi_E g xb))))));
                   } in (case while (\ (_, xf) ->
                                      not
(as_is_empty (case xf of {
               (xg, (_, (_, _))) -> xg;
             })))
                                (\ (aa, ba) ->
                                  (case select_edge_tr ba of {
                                    (Nothing, bb) -> let {
               xf = last_seg_tr bb;
               xg = pop_tr bb;
               xh = xf : aa;
             } in (xh, xg);
                                    (Just xf, bb) ->
                                      (if (case
    rbt_lookup (case bb of {
                 (_, (_, (xl, _))) -> xl;
               })
      xf
    of {
    Nothing -> False;
    Just i -> (if less_eq_int zero_int i then True else False);
  })
then let {
       ab = collapse_tr xf bb;
     } in (aa, ab)
else (if not (case rbt_lookup (case bb of {
                                (_, (_, (xl, _))) -> xl;
                              })
                     xf
               of {
               Nothing -> False;
               Just i -> (if less_eq_int zero_int i then False else True);
             })
       then (aa, push_code g xf bb) else (aa, bb)));
                                  }))
                                xc
                          of {
                          (aa, (_, (_, (ad, _)))) -> (aa, ad);
                        })
              else (a, b)))
          xa;
  } in (case a of {
         (aa, _) -> let {
                      _ = stat_stop ();
                    } in aa;
       });

scc_decomp ::
  forall a.
    (Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a) => [(a, a)] -> [[a]];
scc_decomp e =
  let {
    ee = set e;
  } in filter (\ a -> (case a of {
                        [] -> True;
                        [v] -> member (v, v) ee;
                        _ : _ : _ -> True;
                      }))
         (compute_SCC_tr (create_graph_impl e));

check_acyclic ::
  forall a.
    (Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showl a) => [(a, a)] -> Sum (String -> String) ();
check_acyclic r =
  catch_errora
    (catch_errora
      (forallM
        (\ scc ->
          Inl ((showsl_lit "SCC " . showsl_list scc) . showsl_lit " detected "))
        (scc_decomp r))
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (((showsl_lit "\ngraph " . showsl_list_prod r) .
             showsl_lit " not acyclic\n") .
            x));

get_conjunctions :: forall a. Formula a -> [Formula a];
get_conjunctions (Conjunction phis) = concatMap get_conjunctions phis;
get_conjunctions (Atom v) = [Atom v];
get_conjunctions (NegAtom v) = [NegAtom v];
get_conjunctions (Disjunction v) = [Disjunction v];

get_disjunctions :: forall a. Formula a -> [Formula a];
get_disjunctions (Disjunction phis) = concatMap get_disjunctions phis;
get_disjunctions (Atom v) = [Atom v];
get_disjunctions (NegAtom v) = [NegAtom v];
get_disjunctions (Conjunction v) = [Conjunction v];

pos_gctxt :: forall a b. (Compare a, Eq a, Compare b) => Gctxt a b -> Set [Nat];
pos_gctxt GCHole = inserta [] (set_empty (of_phantom set_impl_list));
pos_gctxt (GCFun f cs) =
  sup_set (inserta [] (set_empty (of_phantom set_impl_list)))
    (sup_seta
      (image (\ (c, i) -> image (\ a -> i : a) (pos_gctxt c))
        (set (zip cs (upt zero_nat (size_list cs))))));

inline ::
  forall a b.
    (Eq b) => Nat ->
                ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                  ((Term a b, Term a b), [(Term a b, Term a b)]);
inline i rho =
  let {
    cs = snd rho;
  } in (case nth cs i of {
         (s, t) ->
           let {
             sigma = subst (the_Var t) s;
             csa = take i cs ++ drop (suc i) cs;
           } in ((fst (fst rho), subst_apply_term (snd (fst rho)) sigma),
                  map (\ (sa, a) -> (subst_apply_term sa sigma, a)) csa);
       });

invariant ::
  forall a b c d e f g. Art_node_impl a b c d e f g -> Formula (Term a (b, c));
invariant (Art_Node x1 x2 x3 x4) = x2;

location :: forall a b c d e f g. Art_node_impl a b c d e f g -> d;
location (Art_Node x1 x2 x3 x4) = x3;

initial_nodesa :: forall a b c d e f g h. Art_impl_ext a b c d e f g h -> [e];
initial_nodesa (Art_impl_ext initial_nodes nodes more) = initial_nodes;

name :: forall a b c d e f g. Art_node_impl a b c d e f g -> e;
name (Art_Node x1 x2 x3 x4) = x1;

edgea ::
  forall a b c d e f g. Art_node_impl a b c d e f g -> Art_edge_impl e f g;
edgea (Art_Node x1 x2 x3 x4) = x4;

nodesb ::
  forall a b c d e f g h.
    Art_impl_ext a b c d e f g h -> [Art_node_impl a b c d e f g];
nodesb (Art_impl_ext initial_nodes nodes more) = nodes;

art_edge_of ::
  forall a b c d e f g.
    (Ccompare e, Eq e, Mapping_impl e,
      Showl e) => Lts_impl a b c d e ->
                    Art_edge_impl f e g -> Art_edge a b c d f;
art_edge_of pi (Cover_Edge an uu) = Cover an;
art_edge_of pi (Children_Edge ans) =
  Children (map (\ (t, a) -> (case a of {
                               (aa, _) -> (transition_of pi t, aa);
                             }))
             ans);

art_nodes :: forall a b c d e f g. Art_impl_ext a b c d e f g () -> [e];
art_nodes ai = map name (nodesb ai);

art_of ::
  forall a b c d e f g.
    (Ccompare e, Eq e, Mapping_impl e, Showl e, Ccompare f, Eq f,
      Mapping_impl f,
      Showl f) => Lts_impl a b c d e ->
                    Art_impl_ext a b c d f e g () -> Art_ext a b c d f ();
art_of pi ai =
  let {
    ans = nodesb ai;
  } in Art_ext (initial_nodesa ai) (art_nodes ai)
         (map_of_total
           (\ a -> showsl_lit "error in looking up art edge " . showsl a)
           (map (\ a -> (name a, art_edge_of pi (edgea a))) ans))
         (map_of_total
           (\ a -> showsl_lit "error in looking up node location " . showsl a)
           (map (\ a -> (name a, location a)) ans))
         (map_of_total
           (\ a -> showsl_lit "error in looking up node invariant " . showsl a)
           (map (\ a -> (name a, invariant a)) ans))
         ();

check_dp_loop ::
  forall a b c.
    (Compare b, Eq b, Showl b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showl c) => Dpp_ops_ext a b c () ->
                    a -> Dp_loop_prf b c -> Sum (String -> String) ();
check_dp_loop i dpp (DP_loop_prf s prseq sigma c) =
  let {
    p = pairsb i dpp;
    r = rulesf i dpp;
    nfs = nfsc i dpp;
    q = qc i dpp;
  } in (if equal_ctxt c Hole
         then bindb (check (not (null prseq))
                      (showsl_lit "rewrite sequence must be non-empty"))
                (\ _ ->
                  (if null q
                    then check_qsteps (\ _ -> True) nfs p r prseq s
                           (subst_apply_term s (mk_subst Var sigma))
                    else check_qsteps_subst (check_NF_iteration sigma q) nfs p r
                           prseq s (subst_apply_term s (mk_subst Var sigma))))
         else check_loop q nfs s (map (\ (x, (y, (_, z))) -> (x, (y, z))) prseq)
                sigma c r);

check_rel_seq ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      [([Nat], ((Term a b, Term a b), (Bool, Term a b)))] ->
                        Term a b ->
                          Term a b -> Bool -> Sum (String -> String) ();
check_rel_seq r sa [] s u True =
  check (equal_term s u)
    ((((showsl_lit "the last term of the rewrite sequence\n" . showsl_terma s) .
        showsl_lit "\ndoes not correspond to the goal term\n") .
       showsl_terma u) .
      showsl_literal "\n");
check_rel_seq r sa [] s u False =
  Inl (showsl_lit "did not find strict step in rewrite sequence");
check_rel_seq ra sa ((p, (r, (True, t))) : prts) s u b =
  bindb (check_qrstep (\ _ -> True) False ra p r s t)
    (\ _ -> check_rel_seq ra sa prts t u True);
check_rel_seq ra sa ((p, (r, (False, t))) : prts) s u b =
  bindb (check_qrstep (\ _ -> True) False sa p r s t)
    (\ _ -> check_rel_seq ra sa prts t u b);

pat_dv_impl ::
  forall a b.
    (Eq a, Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) -> [b];
pat_dv_impl p =
  (case p of {
    (_, (sigma, mu)) ->
      remdups (map fst (mk_subst_domain sigma ++ mk_subst_domain mu));
  });

set_option :: forall a. (Ceq a, Ccompare a, Set_impl a) => Maybe a -> Set a;
set_option Nothing = bot_set;
set_option (Just x2) = inserta x2 bot_set;

equal_complexity_class :: Complexity_class -> Complexity_class -> Bool;
equal_complexity_class (Comp_Poly x) (Comp_Poly ya) = equal_nat x ya;

default_nfs_nt_trs :: Bool;
default_nfs_nt_trs = False;

string_reversal_complete_rel_tt ::
  forall a b c d.
    (Showl b, Showl c) => Tp_ops_ext a b c d -> a -> Sum (String -> String) a;
string_reversal_complete_rel_tt i tp =
  bindb (check (q_emptyb i tp) (showsl_lit "Q is not empty"))
    (\ _ ->
      bindb (check_unary_signature (rulese i tp))
        (\ _ ->
          Inr (mkc i default_nfs_nt_trs [] (map rev_rule (rc i tp))
                (map rev_rule (rwc i tp)))));

check_to_srs_complete ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => a -> [(b, b)] ->
                         [(Term b a, Term b a)] ->
                           [(Term b a, Term b a)] -> Sum (String -> String) ();
check_to_srs_complete v old_new r s =
  let {
    mu = funas_trs_list r;
  } in (case extract_components mu old_new of {
         (d, (da, nu)) ->
           bindb (check_components mu (d, (da, nu)))
             (\ _ ->
               bindb (check_varcond_subset s)
                 (\ _ ->
                   catch_errora
                     (forallM
                       (\ slr ->
                         let {
                           y = choose_var v (fst slr);
                           stra = str d y;
                           to_slr = (\ (l, ra) -> (stra l, stra ra));
                         } in check (any (\ lr -> to_slr lr == slr) r)
                                (showsl_lit
                                   "could not find original rule for " .
                                  showsl_rule slr))
                       s)
                     (\ x -> Inl (snd x))));
       });

const_to_string_complete_tt ::
  forall a b c d.
    (Eq b, Showl b, Eq c,
      Showl c) => Tp_ops_ext a b c d ->
                    a -> Const_string_complete_proof b c ->
                           Sum (String -> String) a;
const_to_string_complete_tt i tp (Const_string_complete_proof v old_new s) =
  bindb (check (q_emptyb i tp) (showsl_lit "Q is not empty"))
    (\ _ ->
      bindb (check_to_srs_complete v old_new (rulese i tp) s)
        (\ _ -> Inr (mkc i False [] s [])));

check_NF_trs_subset ::
  forall a b.
    (Compare_order a, Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [Term a b] -> Sum (Term a b) ();
check_NF_trs_subset r = check_NF_terms_subset (is_NF_trs r);

switch_termination_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Join_info b -> a -> Sum (String -> String) a;
switch_termination_proc i joins_i dpp =
  let {
    p = pairsb i dpp;
    r = rulesf i dpp;
    q = qc i dpp;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b (showsl_lit "rules are not overlay"))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_wf_trs r)
                        (\ _ ->
                          bindb (check_critical_pairs r cp joins_i)
                            (\ _ ->
                              bindb (check (null (critical_pairs_impl p r))
                                      (showsl_lit
"there are overlaps between P and R"))
                                (\ _ ->
                                  catch_errora (check_NF_trs_subset r q)
                                    (\ x ->
                                      Inl
(showsl_terma x . showsl_lit " is not in normal form w.r.t. R"))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkd i (nfsc i dpp) False p [] [] [] r);
       });

dp_q_reduction_nonterm ::
  forall a b c d.
    (Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b, Set_impl b, Showl b,
      Ccompare c, Eq c, Mapping_impl c,
      Showl c) => Dpp_ops_ext a b c d ->
                    a -> Dp_q_reduction_nonterm_prf b c ->
                           Sum (String -> String) a;
dp_q_reduction_nonterm i dpp (DP_q_reduction_nonterm_prf q) =
  let {
    p = pairsb i dpp;
    r = rulesf i dpp;
    qa = qc i dpp;
    nfs = nfsc i dpp;
    f = set (funas_trs_list (p ++ r));
    rQ = filter (\ qb -> less_eq_set (funas_term qb) f) qa;
  } in bindb (catch_errora (check_NF_terms_subset (is_NF_terms q) rQ)
               (\ x ->
                 Inl ((showsl_lit "the term " . showsl_terma x) .
                       showsl_lit " is missing in Q\' ")))
         (\ _ -> Inr (mkd i nfs False p [] q [] r));

check_instance ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] -> Sum (String -> String) ();
check_instance pa p =
  catch_errora
    (forallM
      (\ st ->
        check (any (instance_rule st) pa)
          (showsl_rule st .
            showsl_lit " is not an instance of any original pair"))
      p)
    (\ x -> Inl (snd x));

instantiation_complete_proc ::
  forall a b c d.
    (Eq b, Showl b, Ccompare c, Eq c, Mapping_impl c,
      Showl c) => Dpp_ops_ext a b c d ->
                    a -> Instantiation_complete_proc_prf b c ->
                           Sum (String -> String) a;
instantiation_complete_proc i dpp (Instantiation_complete_proc_prf p) =
  let {
    pa = pairsb i dpp;
    q = qc i dpp;
    r = rulesf i dpp;
    nfs = nfsc i dpp;
  } in bindb (check (not nfs || null q)
               (showsl_lit
                 "normal form subst. currently not supported for innermost"))
         (\ _ ->
           bindb (check_instance pa p)
             (\ _ -> Inr (mkd i nfs False p [] q [] r)));

rule_removal_nonterm_dp ::
  forall a b c.
    (Compare_order b, Showl b, Compare_order c,
      Showl c) => Dpp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_dp_prf b c ->
                           Sum (String -> String) a;
rule_removal_nonterm_dp i dpp (Rule_removal_nonterm_dp_prf p r) =
  let {
    prm = (if is_none p then [] else ceta_list_diff (pairsb i dpp) (the p));
    rrm = (if is_none r then [] else ceta_list_diff (rulesf i dpp) (the r));
  } in Inr (delete_R_Rwc i (delete_P_Pwa i dpp prm prm) rrm rrm);

mk_rel_tp ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      (Bool, ([Term b c], ([(Term b c, Term b c)], [(Term b c, Term b c)]))) ->
        a;
mk_rel_tp i (nfs, (q, (r, rw))) = mkc i nfs q r rw;

mk_dppa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      (Bool,
        (Bool,
          ([(Term b c, Term b c)],
            ([(Term b c, Term b c)],
              ([Term b c],
                ([(Term b c, Term b c)], [(Term b c, Term b c)])))))) ->
        a;
mk_dppa i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkd i nfs m p pw q r rw;

mk_tpa ::
  forall a b c d.
    Tp_ops_ext a b c d -> (Bool, ([Term b c], [(Term b c, Term b c)])) -> a;
mk_tpa i (nfs, (q, r)) = mkc i nfs q r [];

check_assmb ::
  forall a b c d e f g h i.
    (Compare_order b, Showl b, Compare_order c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    Dpp_ops_ext d (Lab b c) [Char] () ->
                      (a -> e -> Sum (String -> String) ()) ->
                        (d -> f -> Sum (String -> String) ()) ->
                          (a -> g -> Sum (String -> String) ()) ->
                            (([(Ctxt (Lab b c) [Char],
                                 (Term (Lab b c) [Char], Location))],
                               [(Term (Lab b c) [Char],
                                  Term (Lab b c) [Char])]) ->
                              h -> Sum (String -> String) ()) ->
                              ([Char] -> i -> Sum (String -> String) ()) ->
                                Generic_assm_proof b c [Char] e f g h i ->
                                  Sum (String -> String) ();
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_SN_assm_proof t prf) = tp_check (mk_tpa i t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_RelSN_assm_proof t prf) = rtp_check (mk_rel_tp i t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Infinite_assm_proof t prf) = dp_check (mk_dppa j t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_SN_FP_assm_proof t prf) = fptp_check t prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Unknown_assm_proof t prf) = unk_check t prf;
check_assmb i j uu uv uw ux uy (SN_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination assumptions in non-termination proof");
check_assmb i j uu uv uw ux uy (Finite_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination assumptions in non-termination proof");
check_assmb i j uu uv uw ux uy (SN_FP_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination assumptions in non-termination proof");
check_assmb i j uu uv uw ux uy (Complexity_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination assumptions in non-termination proof");

q_increase_nonterm_dp ::
  forall a b c.
    (Eq b,
      Eq c) => Dpp_ops_ext a b c () ->
                 a -> Q_increase_nonterm_dp_prf b c -> Sum (String -> String) a;
q_increase_nonterm_dp i dpp (Q_increase_nonterm_dp_prf q) =
  let {
    p = pairsb i dpp;
    r = rulesf i dpp;
    qa = qc i dpp;
    nfs = nfsc i dpp;
  } in Inr (mkd i nfs False p [] (list_union qa q) [] r);

check_dpp_subsumesa ::
  forall a b c.
    (Compare_order b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Dpp_ops_ext a (Lab b c) [Char] () ->
                    (Bool,
                      (Bool,
                        ([(Term (Lab b c) [Char], Term (Lab b c) [Char])],
                          ([(Term (Lab b c) [Char], Term (Lab b c) [Char])],
                            ([Term (Lab b c) [Char]],
                              ([(Term (Lab b c) [Char], Term (Lab b c) [Char])],
                                [(Term (Lab b c) [Char],
                                   Term (Lab b c) [Char])])))))) ->
                      a -> Sum (String -> String) ();
check_dpp_subsumesa j dp dpp =
  (case dp of {
    (nfsa, (_, (p, (pw, (q, (r, rw)))))) ->
      let {
        pairsa = p ++ pw;
        rulesa = r ++ rw;
        nfs = nfsc j dpp;
        pairs = pairsb j dpp;
        rules = rulesf j dpp;
        qa = qc j dpp;
      } in catch_errora
             (bindb
               (check
                 (if not (null q) then (if nfs then nfsa else True) else True)
                 (showsl_lit "incompatible substitutions-in-normal-form flags"))
               (\ _ ->
                 bindb (catch_errora (check_subseteq pairsa pairs)
                         (\ x -> Inl (toomuch "pair" (showsl_rule x))))
                   (\ _ ->
                     bindb (catch_errora (check_subseteq rulesa rules)
                             (\ x -> Inl (toomuch "rule" (showsl_rule x))))
                       (\ _ ->
                         catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                           (\ x ->
                             Inl (showsl_lit "NF(Q) differs due to term " .
                                   showsl_terma x))))))
             (\ x ->
               Inl (showsl_lit
                      "problem is showing subsumption for non-termination\n" .
                     x));
  });

enfc_cand ::
  forall a b.
    (Eq a) => (Term a [Char] -> Bool) ->
                [(Term a [Char], Term a [Char])] ->
                  b -> ([Term a [Char]], Term a [Char]) ->
                         [([Term a [Char]], Term a [Char])];
enfc_cand isQnf r q (uu, Var uv) = [];
enfc_cand isQnf r q (s, Fun f ts) =
  map (\ a -> (s, a)) ts ++
    concatMap
      (\ (l, ra) ->
        (if (case mgu_class (Fun f (map (icap_impl isQnf r s) ts)) l of {
              Nothing -> False;
              Just mu ->
                all (\ u ->
                      isQnf (subst_apply_term
                              (map_term (\ x -> x)
                                (\ a ->
                                  Char True False False True True True True
                                    False :
                                    a)
                                u)
                              mu))
                  (args l) &&
                  all (\ u ->
                        isQnf (subst_apply_term
                                (map_term (\ x -> x)
                                  (\ a ->
                                    Char False False False True True True True
                                      False :
                                      a)
                                  u)
                                mu))
                    s;
            })
          then [(args l, ra)] else []))
      r;

enfc_impl ::
  forall a.
    (Eq a) => (Term a [Char] -> Bool) ->
                (Term a [Char] -> Bool) ->
                  [(Term a [Char], Term a [Char])] ->
                    [Term a [Char]] -> [Term a [Char]] -> Term a [Char] -> Bool;
enfc_impl isQnf isRnf r q s t =
  all (\ (a, b) -> enfc_q isQnf isRnf r q a b)
    (mk_rtrancl_list (\ a b -> a == b) (enfc_cand isQnf r q) [(s, t)]);

check_nfc ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => Bool ->
                    [(Term a [Char], Term a [Char])] ->
                      [Term a [Char]] ->
                        (Term a [Char] -> Bool) ->
                          [Term a [Char]] ->
                            Bool -> Term a [Char] -> Sum (String -> String) ();
check_nfc inn r q isQnf ss nfs t =
  bindb (check_wf_trs r)
    (\ _ ->
      (if inn then Inr ()
        else catch_errora
               (forallM
                 (\ ta ->
                   check (enfc_impl isQnf (is_NF_trs r) r q ss ta)
                     (showsl_lit " nfc not satisfied for " . showsl_terma ta))
                 (supteq_list t))
               (\ x -> Inl (snd x))));

rewriting_complete_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Rewriting_complete_proc_prf b [Char] ->
                      a -> Sum (String -> String) a;
rewriting_complete_proc i (Rewriting_complete_proc_prf u_opt stb sta st lr p)
  dpp =
  (case catch_errora
          (let {
             s = fst stb;
             t = snd stb;
             ta = snd sta;
             r = rulesf i dpp;
           } in bindb (check_rstep r p lr t ta)
                  (\ _ ->
                    bindb (check (nFQ_subset_NF_rulesc i dpp)
                            (showsl_lit "innermost rewriting required"))
                      (\ _ ->
                        bindb (check_rewrite_common_preconditions i u_opt stb
                                (args s) (args (subt_at t p)) ta lr p False dpp)
                          (\ _ ->
                            bindb (check (not (is_Var s))
                                    (showsl_lit
                                      "lhs of pair must not be variable"))
                              (\ _ ->
                                bindb (check (eq_rule_mod_vars sta st)
(((showsl_lit "the rule " . showsl_rule sta) .
   showsl_lit " is not a renamed variant of ") .
  showsl_rule st))
                                  (\ _ ->
                                    bindb (check (equal_term s (fst sta))
    (showsl_lit "left-hand sides of old and new pair differ"))
                                      (\ _ ->
let {
  q = qc i dpp;
  inn = isOK (check_NF_trs_subset r q);
} in bindb (check_nfc inn r q (is_QNFc i dpp) (args s) (nfsc i dpp)
             (subt_at t p))
       (\ _ ->
         bindb (catch_errora
                 (forallM
                   (\ (l, _) ->
                     check (not (is_Var l))
                       (showsl_lit "lhss must not be variables"))
                   r)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             (if not (is_Var t)
               then check (not (not (null (rules_mapc i dpp (the (root t))))))
                      ((showsl_lit "root of " . showsl_terma t) .
                        showsl_lit " must not be defined")
               else Inr ()))))))))))
          (\ x ->
            Inl (((((showsl_lit "error when rewriting the pair\n" .
                      showsl_rule stb) .
                     showsl_lit "\n to the pair\n") .
                    showsl_rule st) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp stb [st]);
  });

rstep_enum_impl ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b ->
                             Term a b ->
                               [Nat] ->
                                 [((Term a b, Term a b),
                                    (b -> Term a b, [Nat]))];
rstep_enum_impl r ta t p =
  concat
    (map_filter
      (\ x ->
        (if less_eq_list p x
          then Just (let {
                       tp = subt_at ta x;
                     } in (if membera (poss_list t) x
                            then (if equal_ctxt (ctxt_of_pos_term x ta)
                                       (ctxt_of_pos_term x t)
                                   then concatMap
  (\ tpa ->
    concatMap
      (\ (l, ra) ->
        map (\ mu -> ((l, ra), (mu, x)))
          (option_to_list (match_list Var [(l, tp), (ra, tpa)])))
      r)
  [subt_at t x]
                                   else [])
                            else []))
          else Nothing))
      (poss_list ta));

narrow_enum_impl ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           (Term a b, Term a b) ->
                             (Term a b, Term a b) ->
                               [Nat] ->
                                 [(b -> Term a b,
                                    ((Term a b, Term a b),
                                      ([Nat], b -> Term a b)))];
narrow_enum_impl r sta st p =
  (case sta of {
    (s, t) ->
      (case st of {
        (sa, ta) ->
          concatMap
            (\ mu ->
              map (\ (lr, (tau, q)) -> (mu, (lr, (q, tau))))
                (rstep_enum_impl r (subst_apply_term t mu) ta p))
            (option_to_list (match sa s));
      });
  });

check_narrow ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Bool ->
                    Dpp_ops_ext a b [Char] () ->
                      a -> [(Term b [Char], Term b [Char])] ->
                             [Term b [Char]] ->
                               Bool ->
                                 (Term b [Char], Term b [Char]) ->
                                   (Term b [Char], Term b [Char]) ->
                                     ([Char] -> Term b [Char],
                                       ((Term b [Char], Term b [Char]),
 ([Nat], [Char] -> Term b [Char]))) ->
                                       Sum (String -> String) ();
check_narrow inn i dpp r q nfs sta st quad =
  (case (sta, (st, quad)) of {
    ((_, t), ((s, ta), (mu, (lr, (p, _))))) ->
      bindb (check_nfc inn r q (is_QNFc i dpp) (args s) nfs
              (subt_at (subst_apply_term t mu) p))
        (\ _ ->
          check_rewrite_common_preconditions i Nothing
            (s, subst_apply_term t mu) (args s)
            (args (subt_at (subst_apply_term t mu) p)) ta lr p False dpp);
  });

narrowing_complete_proc ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Dpp_ops_ext a b [Char] () ->
                    Narrowing_complete_proc_prf b [Char] ->
                      a -> Sum (String -> String) a;
narrowing_complete_proc i (Narrowing_complete_proc_prf st p sts) dpp =
  (case catch_errora
          (case st of {
            (s, t) ->
              let {
                q = qc i dpp;
                nfs = nfsc i dpp;
                rules = rulesf i dpp;
                check_ndef =
                  check_no_defined_root
                    (\ fn -> not (null (rules_mapc i dpp fn)));
                inn = isOK (check_NF_trs_subset rules q);
                cnarrow = check_narrow inn i dpp rules q nfs st;
              } in bindb (check (null q || nFQ_subset_NF_rulesc i dpp)
                           (showsl_lit "full or innermost rewriting required"))
                     (\ _ ->
                       bindb (if null q then Inr ()
                               else bindb (check_no_var s)
                                      (\ _ ->
bindb (check_no_var t)
  (\ _ ->
    bindb (check_ndef t)
      (\ _ ->
        (if nfs
          then bindb (catch_errora (forallM (\ (l, _) -> check_no_var l) rules)
                       (\ x -> Inl (snd x)))
                 (\ _ ->
                   check (wf_rule (s, t))
                     (showsl_rule (s, t) . showsl_lit " is not well formed"))
          else Inr ())))))
                         (\ _ ->
                           catch_errora
                             (forallM
                               (\ sta ->
                                 let {
                                   quads = narrow_enum_impl rules st sta p;
                                 } in catch_errora
(existsM
  (\ quad ->
    catch_errora (check (null q) (showsl_lit "q not empty"))
      (\ _ -> cnarrow sta quad))
  quads)
(\ x ->
  Inl ((showsl_rule sta .
         showsl_lit (case quads of {
                      [] -> " does not seem to be narrowed pair";
                      _ : _ -> " violates side conditions for completeness";
                    })) .
        showsl_list_gen id "" "" "" "" x)))
                               sts)
                             (\ x -> Inl (snd x))));
          })
          (\ x ->
            Inl (((((showsl_lit "error when narrowing\n" . showsl_rule st) .
                     showsl_lit "\n to the pairs\n") .
                    showsl_trs sts) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

is_inverse_renaming_impl ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)];
is_inverse_renaming_impl sigma = let {
                                   a = mk_subst_domain sigma;
                                 } in map (\ (x, y) -> (the_Var y, Var x)) a;

vars_subst_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
vars_subst_impl sigma =
  let {
    sigmaa = mk_subst_domain sigma;
  } in map fst sigmaa ++ concatMap (vars_term_list . snd) sigmaa;

vars_pat_term_impl ::
  forall a b.
    (Eq a, Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) -> [b];
vars_pat_term_impl p =
  (case p of {
    (s, (sigma, mu)) ->
      remdups (vars_term_list s ++ vars_subst_impl sigma ++ vars_subst_impl mu);
  });

is_renaming_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> Bool;
is_renaming_impl sigma = let {
                           sigmaa = map snd (mk_subst_domain sigma);
                         } in all is_Var sigmaa && distinct sigmaa;

pat_dom_renaming_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                 [(b, Term a b)] -> Bool;
pat_dom_renaming_impl p rho =
  let {
    rhoa = mk_subst_domain rho;
    xs = map Var (vars_pat_term_impl p);
  } in is_renaming_impl rho &&
         all (membera (pat_dv_impl p)) (map fst rhoa) &&
           all (\ t -> not (membera xs t)) (map snd rhoa);

check_pat_eqv_prf ::
  forall a b.
    (Compare a, Eq a, Showl a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Set_impl b,
      Showl b) => Pat_eqv_prf a b ->
                    (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                      Sum (String -> String)
                        (Term a b, ([(b, Term a b)], [(b, Term a b)]));
check_pat_eqv_prf (Pat_Irrelevant sigmaa mua) (t, (sigma, mu)) =
  let {
    w = w_impl (mk_subst_domain sigma) t;
    sig = mk_subst Var sigma;
    siga = mk_subst Var sigmaa;
    mub = mk_subst Var mu;
    muba = mk_subst Var mua;
  } in bindb (catch_errora
               (catch_errora
                 (forallM
                   (\ x ->
                     bindb (check (equal_term (sig x) (siga x))
                             (x, (sig x,
                                   (siga x,
                                     [Char False False False False True True
True False,
                                       Char True False True False True True True
 False,
                                       Char True False True True False True True
 False,
                                       Char False False False False True True
 True False,
                                       Char True False False True False True
 True False,
                                       Char False True True True False True True
 False,
                                       Char True True True False False True True
 False]))))
                       (\ _ ->
                         check (equal_term (mub x) (muba x))
                           (x, (mub x,
                                 (muba x,
                                   [Char True True False False False True True
                                      False,
                                     Char False False True True False True True
                                       False,
                                     Char True True True True False True True
                                       False,
                                     Char True True False False True True True
                                       False,
                                     Char True False False True False True True
                                       False,
                                     Char False True True True False True True
                                       False,
                                     Char True True True False False True True
                                       False])))))
                   w)
                 (\ x -> Inl (snd x)))
               (\ x ->
                 Inl (case x of {
                       (xa, (tb, (ta, sub))) ->
                         ((((((showsl_lit
                                 "error in equivalence (irrelevant): for variable " .
                                showsl xa) .
                               showsl_lit " obtain different values for ") .
                              showsl_lista sub) .
                             showsl_lit " substitution: ") .
                            showsl_terma tb) .
                           showsl_lit " != ") .
                           showsl_terma ta;
                     })))
         (\ _ -> Inr (t, (sigmaa, mua)));
check_pat_eqv_prf (Pat_Simplify mu_1 mu_2) (t, (sigma, mu)) =
  bindb (check (subst_eq mu (subst_compose_impl mu_1 mu_2))
          (showsl_lit "mu != mu1 mu2"))
    (\ _ ->
      bindb (check (commutes_impl mu_1 sigma)
              (showsl_lit "sigma and mu1 do not commute"))
        (\ _ -> Inr (subst_apply_term t (mk_subst Var mu_1), (sigma, mu_2))));
check_pat_eqv_prf (Pat_Dom_Renaming rho) (t, (sigma, mu)) =
  bindb (check (pat_dom_renaming_impl (t, (sigma, mu)) rho)
          (showsl_lit "rho is not a domain renaming for p"))
    (\ _ ->
      let {
        i_rho = is_inverse_renaming_impl rho;
        sigmaa =
          mk_subst_case
            (map (the_Var . mk_subst Var rho) (map fst (mk_subst_domain sigma)))
            (\ x ->
              subst_apply_term
                (subst_apply_term
                  (subst_apply_term (Var x) (mk_subst Var i_rho))
                  (mk_subst Var sigma))
                (mk_subst Var rho))
            [];
        mua = mk_subst_case
                (map (the_Var . mk_subst Var rho)
                  (map fst (mk_subst_domain mu)))
                (\ x ->
                  subst_apply_term
                    (subst_apply_term (Var x) (mk_subst Var i_rho))
                    (mk_subst Var mu))
                i_rho;
      } in Inr (subst_apply_term t (mk_subst Var rho), (sigmaa, mua)));

subst_compose_impla ::
  forall a b.
    (Eq a, Eq b) => [(a, Term b a)] -> (a -> Term b a) -> [(a, Term b a)];
subst_compose_impla sigma rho =
  map (\ (x, s) -> (x, subst_apply_term s rho)) (mk_subst_domain sigma);

subst_replace_impl ::
  forall a b. (Eq a) => [(a, Term b a)] -> a -> Term b a -> [(a, Term b a)];
subst_replace_impl sigma x t = (x, t) : filter (\ (y, _) -> not (y == x)) sigma;

showsl_pat_term ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                    String -> String;
showsl_pat_term p =
  (case p of {
    (s, (sigma, tau)) ->
      showsl_prod (s, (mk_subst_domain sigma, mk_subst_domain tau));
  });

showsl_pat_rule ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                    ((Term a b, ([(b, Term a b)], [(b, Term a b)])), Bool)) ->
                    String -> String;
showsl_pat_rule pr =
  (case pr of {
    (p1, (p2, _)) ->
      (showsl_pat_term p1 . showsl_lit " --> ") . showsl_pat_term p2;
  });

subst_power_impl ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> Nat -> [(a, Term b a)];
subst_power_impl sigma n =
  (if equal_nat n zero_nat then []
    else subst_compose_impl sigma
           (subst_power_impl sigma (minus_nat n one_nat)));

check_pat_rule_prf ::
  forall a b.
    (Compare a, Eq a, Showl a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Pat_rule_prf a b ->
                        Sum (String -> String)
                          ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                            ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                              Bool));
check_pat_rule_prf ra p (Pat_OrigRule (l, r) isPair) =
  (if isPair
    then bindb (check (membera p (l, r))
                 (showsl_rule (l, r) . showsl_lit " is not a pair"))
           (\ _ -> Inr ((l, ([], [])), ((r, ([], [])), isPair)))
    else bindb (check (membera ra (l, r))
                 (showsl_rule (l, r) . showsl_lit " is not a rule"))
           (\ _ -> Inr ((l, ([], [])), ((r, ([], [])), isPair))));
check_pat_rule_prf r p (Pat_InitPump pat sigma theta) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      (case a of {
        (s, (sig, tau)) ->
          (\ (aa, ba) ->
            (case aa of {
              (t, (siga, taua)) ->
                (\ bb ->
                  catch_errora
                    (bindb
                      (check (null (sig ++ tau ++ siga ++ taua))
                        (showsl_lit "substitutions must be empty"))
                      (\ _ ->
                        bindb (check
                                (equal_term
                                  (subst_apply_term s (mk_subst Var theta))
                                  (subst_apply_term t (mk_subst Var sigma)))
                                (showsl_lit "s theta != t sigma"))
                          (\ _ ->
                            bindb (check (commutes_impl theta sigma)
                                    (showsl_lit
                                      "sigma and theta do not commute"))
                              (\ _ ->
                                Inr ((s, (sigma, [])),
                                      ((t, (theta, [])), bb))))))
                    (\ x ->
                      Inl ((showsl_lit
                              "problem with initial pumping after deriving correct pattern rule\n" .
                             showsl_pat_rule
                               ((s, (sig, tau)), ((t, (siga, taua)), bb))) .
                            x)));
            })
              ba);
      })
        b);
check_pat_rule_prf r pa (Pat_InitPumpCtxt pat sigma p z) =
  bindb (check_pat_rule_prf r pa pat)
    (\ (a, b) ->
      (case a of {
        (s, (sig, tau)) ->
          (\ (aa, ba) ->
            (case aa of {
              (t, (siga, taua)) ->
                (\ bb ->
                  catch_errora
                    (bindb
                      (check (not bb)
                        (showsl_lit "pairs not allowed in init pump ctxt"))
                      (\ _ ->
                        bindb (check (null (sig ++ tau ++ siga ++ taua))
                                (showsl_lit "substitutions must be empty"))
                          (\ _ ->
                            bindb (check (in_poss p t)
                                    (showsl_lit "p is not a valid position"))
                              (\ _ ->
                                bindb (check
(equal_term s (subst_apply_term (subt_at t p) (mk_subst Var sigma)))
(showsl_lit "s != t |_ p sigma"))
                                  (\ _ ->
                                    bindb (check
    (not (membera
           (vars_term_list s ++ vars_term_list t ++ vars_subst_impl sigma) z))
    (showsl_lit "z is not fresh"))
                                      (\ _ ->
let {
  tz = ctxt_apply_term (ctxt_of_pos_term p t) (Var z);
} in Inr ((s, (sigma, [])),
           ((tz, ((z, tz) : sigma, [(z, subt_at t p)])), bb))))))))
                    (\ x ->
                      Inl ((showsl_lit
                              "problem with initial pumping (with ctxt) after deriving correct pattern rule\n" .
                             showsl_pat_rule
                               ((s, (sig, tau)), ((t, (siga, taua)), bb))) .
                            x)));
            })
              ba);
      })
        b);
check_pat_rule_prf r p (Pat_Equiv pat left eqv) =
  bindb (check_pat_rule_prf r p pat)
    (\ (pleft, (pright, b)) ->
      catch_errora
        (bindb (check_pat_eqv_prf eqv (if left then pleft else pright))
          (\ pnew ->
            Inr (if left then (pnew, (pright, b)) else (pleft, (pnew, b)))))
        (\ x ->
          Inl ((showsl_lit
                  "problem with pattern equivalence after deriving correct pattern rule\n" .
                 showsl_pat_rule (pleft, (pright, b))) .
                x)));
check_pat_rule_prf r pa (Pat_Narrow pat1 pat2 p) =
  bindb (check_pat_rule_prf r pa pat1)
    (\ (a, b) ->
      (case a of {
        (s, (sigma, mu)) ->
          (\ (aa, ba) ->
            (case aa of {
              (t, (sig, mua)) ->
                (\ b1 ->
                  bindb (check_pat_rule_prf r pa pat2)
                    (\ (ab, bb) ->
                      (case ab of {
                        (u, (sig1, mu1)) ->
                          (\ (ac, bc) ->
                            (case ac of {
                              (v, (sig2, mu2)) ->
                                (\ b2 ->
                                  catch_errora
                                    (bindb
                                      (check
(subst_eq sig sigma &&
  subst_eq sig1 sigma &&
    subst_eq sig2 sigma &&
      subst_eq mua mu && subst_eq mu1 mu && subst_eq mu2 mu)
(showsl_lit "substitutions are not identical"))
                                      (\ _ ->
bindb (check (in_poss p t) (showsl_lit "p is not a valid position"))
  (\ _ ->
    bindb (check (equal_term (subt_at t p) u) (showsl_lit "t |_ p != u"))
      (\ _ ->
        bindb (check (if b2 then null p else True)
                (showsl_lit "there is a P step, so p must be epsilon"))
          (\ _ ->
            Inr ((s, (sigma, mu)),
                  ((ctxt_apply_term (ctxt_of_pos_term p t) v, (sigma, mu)),
                    b1 || b2)))))))
                                    (\ x ->
                                      Inl
((((showsl_lit
      "problem with pattern narrowing after deriving correct pattern rules\n" .
     showsl_pat_rule ((s, (sigma, mu)), ((t, (sig, mua)), b1))) .
    showsl_lit "\nand\n") .
   showsl_pat_rule ((u, (sig1, mu1)), ((v, (sig2, mu2)), b2))) .
  x)));
                            })
                              bc);
                      })
                        bb));
            })
              ba);
      })
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Base) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      (case a of {
        (s, (sigma_s, mu_s)) ->
          (\ (aa, ba) ->
            (case aa of {
              (t, (sigma_t, mu_t)) ->
                (\ bb ->
                  catch_errora
                    (let {
                       xs = map fst
                              (mk_subst_domain sigma_s ++
                                mk_subst_domain mu_s ++
                                  mk_subst_domain sigma_t ++
                                    mk_subst_domain mu_t);
                     } in bindb (catch_errora
                                  (forallM
                                    (\ x ->
                                      check (not (membera xs x))
(showsl_lit "domains not disjoint"))
                                    (vars_subst_impl rho))
                                  (\ x -> Inl (snd x)))
                            (\ _ ->
                              let {
                                rhoa = mk_subst Var rho;
                              } in Inr ((subst_apply_term s rhoa,
  (subst_compose_impla sigma_s rhoa, subst_compose_impla mu_s rhoa)),
 ((subst_apply_term t rhoa,
    (subst_compose_impla sigma_t rhoa, subst_compose_impla mu_t rhoa)),
   bb))))
                    (\ x ->
                      Inl ((showsl_lit
                              "problem with pattern instantiation (base) after deriving correct pattern rule\n" .
                             showsl_pat_rule
                               ((s, (sigma_s, mu_s)),
                                 ((t, (sigma_t, mu_t)), bb))) .
                            x)));
            })
              ba);
      })
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Pump) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      (case a of {
        (s, (sigma_s, mu_s)) ->
          (\ (aa, ba) ->
            (case aa of {
              (t, (sigma_t, mu_t)) ->
                (\ bb ->
                  catch_errora
                    (bindb
                      (check (commutes_impl rho sigma_s)
                        (showsl_lit "rho does not commute with sigma_s"))
                      (\ _ ->
                        bindb (check (commutes_impl rho mu_s)
                                (showsl_lit "rho does not commute with mu_s"))
                          (\ _ ->
                            bindb (check (commutes_impl rho sigma_t)
                                    (showsl_lit
                                      "rho does not commute with sigma_t"))
                              (\ _ ->
                                bindb (check (commutes_impl rho mu_t)
(showsl_lit "rho does not commute with mu_t"))
                                  (\ _ ->
                                    Inr ((s,
   (subst_compose_impl sigma_s rho, mu_s)),
  ((t, (subst_compose_impl sigma_t rho, mu_t)), bb)))))))
                    (\ x ->
                      Inl ((showsl_lit
                              "problem with pattern instantiation (pumping) after deriving correct pattern rule\n" .
                             showsl_pat_rule
                               ((s, (sigma_s, mu_s)),
                                 ((t, (sigma_t, mu_t)), bb))) .
                            x)));
            })
              ba);
      })
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Close) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      (case a of {
        (s, (sigma_s, mu_s)) ->
          (\ (aa, ba) ->
            (case aa of {
              (t, (sigma_t, mu_t)) ->
                (\ bb ->
                  Inr ((s, (sigma_s, subst_compose_impl mu_s rho)),
                        ((t, (sigma_t, subst_compose_impl mu_t rho)), bb)));
            })
              ba);
      })
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Base uu) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      (case a of {
        (s, (sigma_s, mu_s)) ->
          (\ (aa, ba) ->
            (case aa of {
              (t, (sigma_t, mu_t)) ->
                (\ bb ->
                  catch_errora
                    (case rewr of {
                      (ta, rseq) ->
                        let {
                          tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                        } in bindb (check (equal_term t ta)
                                     (showsl_lit "terms t do not match"))
                               (\ _ ->
                                 bindb (check_rsteps r rseq ta tb)
                                   (\ _ ->
                                     Inr ((s, (sigma_s, mu_s)),
   ((tb, (sigma_t, mu_t)), bb))));
                    })
                    (\ x ->
                      Inl ((showsl_lit
                              "problem with pattern rewriting (base) after deriving correct pattern rule\n" .
                             showsl_pat_rule
                               ((s, (sigma_s, mu_s)),
                                 ((t, (sigma_t, mu_t)), bb))) .
                            x)));
            })
              ba);
      })
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Pump x) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      (case a of {
        (s, (sigma_s, mu_s)) ->
          (\ (aa, ba) ->
            (case aa of {
              (t, (sigma_t, mu_t)) ->
                (\ bb ->
                  catch_errora
                    (case rewr of {
                      (ta, rseq) ->
                        let {
                          tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                        } in bindb (check
                                     (equal_term (mk_subst Var sigma_t x) ta)
                                     (showsl_lit
                                       "sigma_t x does not match starting term"))
                               (\ _ ->
                                 bindb (check_rsteps r rseq ta tb)
                                   (\ _ ->
                                     Inr ((s, (sigma_s, mu_s)),
   ((t, (subst_replace_impl sigma_t x tb, mu_t)), bb))));
                    })
                    (\ xa ->
                      Inl ((showsl_lit
                              "problem with pattern rewriting (pumping) after deriving correct pattern rule\n" .
                             showsl_pat_rule
                               ((s, (sigma_s, mu_s)),
                                 ((t, (sigma_t, mu_t)), bb))) .
                            xa)));
            })
              ba);
      })
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Close x) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      (case a of {
        (s, (sigma_s, mu_s)) ->
          (\ (aa, ba) ->
            (case aa of {
              (t, (sigma_t, mu_t)) ->
                (\ bb ->
                  catch_errora
                    (case rewr of {
                      (ta, rseq) ->
                        let {
                          tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                        } in bindb (check (equal_term (mk_subst Var mu_t x) ta)
                                     (showsl_lit
                                       "sigma_t x does not match starting term"))
                               (\ _ ->
                                 bindb (check_rsteps r rseq ta tb)
                                   (\ _ ->
                                     Inr ((s, (sigma_s, mu_s)),
   ((t, (sigma_t, subst_replace_impl mu_t x tb)), bb))));
                    })
                    (\ xa ->
                      Inl ((showsl_lit
                              "problem with pattern rewriting (closing) after deriving correct pattern rule\n" .
                             showsl_pat_rule
                               ((s, (sigma_s, mu_s)),
                                 ((t, (sigma_t, mu_t)), bb))) .
                            xa)));
            })
              ba);
      })
        b);
check_pat_rule_prf r p (Pat_Exp_Sigma pat k) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      (case a of {
        (s, (sigma_s, mu_s)) ->
          (\ (aa, ba) ->
            (case aa of {
              (t, (sigma_t, mu_t)) ->
                (\ bb ->
                  Inr ((subst_apply_term s
                          (mk_subst Var (subst_power_impl sigma_s k)),
                         (sigma_s, mu_s)),
                        ((subst_apply_term t
                            (mk_subst Var (subst_power_impl sigma_t k)),
                           (sigma_t, mu_t)),
                          bb)));
            })
              ba);
      })
        b);

check_non_loop_prf ::
  forall a b.
    (Compare a, Eq a, Showl a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Non_loop_prf a b -> Sum (String -> String) ();
check_non_loop_prf r pa (Non_loop_prf pat sigma mu m b p) =
  bindb (check_pat_rule_prf r pa pat)
    (\ (a, c) ->
      (case a of {
        (s, (sigmaa, mua)) ->
          (\ (aa, ca) ->
            (case aa of {
              (t, (sigma_t, mu_t)) ->
                (\ is_pair ->
                  catch_errora
                    (bindb
                      (check (if is_pair then null p else True)
                        (showsl_lit
                          "p must be empty, since pairs are contained"))
                      (\ _ ->
                        bindb (check (commutes_impl sigmaa sigma)
                                (showsl_lit "sigma and sigma\' do not commute"))
                          (\ _ ->
                            bindb (check (commutes_impl mua sigma)
                                    (showsl_lit
                                      "mu and sigma\' do not commute"))
                              (\ _ ->
                                bindb (check
(subst_eq sigma_t (subst_compose_impl (subst_power_impl sigmaa m) sigma))
(showsl_lit "sigma_t != sigma^m sigma\' "))
                                  (\ _ ->
                                    bindb (check
    (subst_eq mu_t (subst_compose_impl mua mu)) (showsl_lit "mu_t != mu mu\' "))
                                      (\ _ ->
bindb (check (in_poss p t) (showsl_lit "p is not a position in t"))
  (\ _ ->
    check (equal_term
            (subst_apply_term s (mk_subst Var (subst_power_impl sigmaa b)))
            (subt_at t p))
      (showsl_lit "s sigma^b != t |_ p"))))))))
                    (\ x ->
                      Inl ((showsl_lit
                              "problem with application condition of non-loop theorem after deriving correct pattern rule\n" .
                             showsl_pat_rule
                               ((s, (sigmaa, mua)),
                                 ((t, (sigma_t, mu_t)), is_pair))) .
                            x)));
            })
              ca);
      })
        c);

check_non_loop_dp_prf ::
  forall a b c d.
    (Compare b, Eq b, Showl b, Cenum c, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showl c) => Dpp_ops_ext a b c d ->
                    a -> Non_loop_prf b c -> Sum (String -> String) ();
check_non_loop_dp_prf i dpp prf =
  let {
    p = pairsb i dpp;
    r = rulesf i dpp;
  } in bindb (check (null (qc i dpp))
               (showsl_lit "strategy for non-loops unsupported"))
         (\ _ -> check_non_loop_prf r p prf);

rule_removal_nonterm_trs ::
  forall a b c.
    (Compare_order b, Showl b, Compare_order c,
      Showl c) => Tp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_trs_prf b c ->
                           Sum (String -> String) a;
rule_removal_nonterm_trs i tp (Rule_removal_nonterm_trs_prf r) =
  let {
    ra = rulese i tp;
    rrm = ceta_list_diff ra r;
  } in Inr (delete_R_Rwb i tp rrm rrm);

showsl_location :: Location -> String -> String;
showsl_location A = showsl_lit "above";
showsl_location Ba = showsl_lit "below";
showsl_location H = showsl_lit "here";
showsl_location Ra = showsl_lit "right";

showsl_pattern ::
  forall a b.
    (Showl a, Showl b) => (Ctxt a b, (Term a b, Location)) -> String -> String;
showsl_pattern (c, (s, p)) =
  (((((showsl_lit "(" . showsl_terma (ctxt_apply_term c s)) . showsl_lit ", ") .
      showsl_pos (hole_pos c)) .
     showsl_lit ", ") .
    showsl_location p) .
    showsl_lit ")";

fp_R_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> [Nat] -> [Nat] -> Ctxt a b -> Term a b -> Bool;
fp_R_decide mu l oo q c t =
  not (bex (let {
              h = hole_pos c;
              q_s = filter (\ qa -> is_left_of qa q) (poss_list t);
              m1 = map (\ qa -> (subt_at t qa, l)) q_s;
              sterms =
                remdups
                  (map (si_subst mu)
                    (remdups (concatMap (\ qa -> si_W mu (subt_at t qa)) q_s)));
              uterms = concatMap supteq_list sterms;
              m2 = map (\ u -> (u, l)) (remdups uterms);
              p_s = filter (\ qa -> is_left_of qa h)
                      (poss_list (ctxt_apply_term c t));
              m3 = map (\ p -> (subt_at (ctxt_apply_term c t) p, l)) p_s;
              stermsa =
                remdups
                  (map (si_subst mu)
                    (remdups
                      (concatMap
                        (\ p -> si_W mu (subt_at (ctxt_apply_term c t) p))
                        p_s)));
              utermsa = concatMap supteq_list stermsa;
              m4 = map (\ u -> (u, l)) (remdups utermsa);
            } in set (m1 ++ m2 ++ m3 ++ m4))
        (match_decision mu));

pos_dec :: [Nat] -> [Nat] -> [Nat] -> Maybe (Nat, [Nat]);
pos_dec p q oo =
  (if null p then (case remove_suffix oo q of {
                    Nothing -> Nothing;
                    Just r -> Just (zero_nat, r);
                  })
    else let {
           n0 = nat (ceiling
                      (divide_rat
                        (of_nat (minus_nat (size_list oo) (size_list q)))
                        (of_nat (size_list p))));
         } in (case remove_suffix oo (power p n0 ++ q) of {
                Nothing -> Nothing;
                Just r -> Just (n0, r);
              }));

ctxt_subst ::
  forall a b. Ctxt a b -> (b -> Term a b) -> Nat -> Term a b -> Term a b;
ctxt_subst uu uv n t =
  (if equal_nat n zero_nat then t
    else ctxt_apply_term uu
           (subst_apply_term (ctxt_subst uu uv (minus_nat n one_nat) t) uv));

h_match_probs ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => (a -> Term b a) ->
                 Term b a ->
                   [Nat] ->
                     [Nat] -> Ctxt b a -> Term b a -> Set (Term b a, Term b a);
h_match_probs mu l oo q c t =
  (case pos_dec (hole_pos c) q oo of {
    Nothing ->
      set_empty
        (of_phantom (set_impl_prod :: Phantom (Term b a, Term b a) Set_impla));
    Just (n, o) ->
      inserta (subt_at (ctxt_subst c mu n t) o, l)
        (set_empty
          (of_phantom
            (set_impl_prod :: Phantom (Term b a, Term b a) Set_impla)));
  });

fp_H_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> [Nat] -> [Nat] -> Ctxt a b -> Term a b -> Bool;
fp_H_decide mu l oo q c t =
  not (bex (h_match_probs (si_subst mu) l oo q c t) (match_decision mu));

decompositions :: [Nat] -> [([Nat], [Nat])];
decompositions p = map (\ pa -> (pa, the (remove_prefix pa p))) (prefix_list p);

simplify_emp_main ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b,
                   (Term a b,
                     (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                   [(Term a b, Term a b)] ->
                     Maybe (Maybe (Ctxt a b,
                                    (Term a b,
                                      (Ctxt a b,
(Term a b, [(Term a b, Term a b)])))));
simplify_emp_main mu_incr (Hole, (Fun g ls, (c, (t, [])))) solved =
  (if gmatch_decision mu_incr ((t, Fun g ls) : solved) then Just Nothing
    else (if equal_ctxt c Hole then Nothing
           else simplify_emp_main mu_incr
                  (c, (Fun g ls,
                        (subst_apply_ctxt c (si_subst mu_incr),
                          (subst_apply_term t (si_subst mu_incr), []))))
                  solved));
simplify_emp_main mu_incr (More f bef d aft, (Fun g ls, (c, (t, [])))) solved =
  bind (guard (f == g))
    (\ _ ->
      bind (guard
             (equal_nat (size_list ls)
               (suc (plus_nat (size_list bef) (size_list aft)))))
        (\ _ ->
          let {
            pairs_bef = zip bef (take (size_list bef) ls);
            pairs_aft = zip aft (drop (suc (size_list bef)) ls);
          } in simplify_emp_main mu_incr
                 (d, (nth ls (size_list bef), (c, (t, pairs_bef ++ pairs_aft))))
                 solved));
simplify_emp_main mu_incr (d, (Var x, (c, (t, [])))) solved =
  Just (Just (d, (Var x, (c, (t, solved)))));
simplify_emp_main mu_incr (d, (l, (c, (t, (Var x, Fun f ls) : mp)))) solved =
  bind (guard (member x (si_v_incr mu_incr)))
    (\ _ ->
      let {
        m = map (\ (s, a) -> (subst_apply_term s (si_subst mu_incr), a));
      } in simplify_emp_main mu_incr
             (subst_apply_ctxt d (si_subst mu_incr),
               (l, (subst_apply_ctxt c (si_subst mu_incr),
                     (subst_apply_term t (si_subst mu_incr),
                       m ((Var x, Fun f ls) : mp)))))
             (m solved));
simplify_emp_main mu_incr (d, (l, (c, (t, (Fun g ts, Fun f ls) : mp)))) solved =
  bind (guard (f == g))
    (\ _ ->
      bind (zip_option ts ls)
        (\ pairs ->
          simplify_emp_main mu_incr (d, (l, (c, (t, pairs ++ mp)))) solved));
simplify_emp_main mu_incr (d, (l, (c, (t, (s, Var x) : mp)))) solved =
  simplify_emp_main mu_incr (d, (l, (c, (t, mp)))) ((s, Var x) : solved);

simplify_emp ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) ->
                   Sum (Ctxt a b,
                         (Term a b,
                           (Ctxt a b, (Term a b, [(Term a b, Term a b)]))))
                     Bool;
simplify_emp mu_incr emp =
  (case emp of {
    (d, (l, (c, t))) ->
      (case simplify_emp_main mu_incr (d, (l, (c, (t, [])))) [] of {
        Nothing -> Inr False;
        Just a -> (case a of {
                    Nothing -> Inr True;
                    Just aa -> Inl aa;
                  });
      });
  });

eident_prob_to_ident_prob ::
  forall a b.
    (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) -> (Term a b, Term a b);
eident_prob_to_ident_prob (d, (si, (c, t))) = (ctxt_apply_term d t, si);

eident_prob_of_semp ::
  forall a b.
    (Eq a,
      Eq b) => (Ctxt a b,
                 (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                 Maybe (Ctxt a b, (Term a b, (Ctxt a b, Term a b)));
eident_prob_of_semp (d, (l, (c, (t, mp)))) =
  bind (map_of (reverse_rules mp) l) (\ si -> Just (d, (si, (c, t))));

ident_prob_of_semp ::
  forall a b.
    (Eq a,
      Eq b) => (Ctxt a b,
                 (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                 [(Term a b, Term a b)];
ident_prob_of_semp (d, (l, (c, (t, mp)))) = ident_prob_of_smp mp;

ident_prob_of_emp ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) ->
                   Maybe [(Term a b, Term a b)];
ident_prob_of_emp mu_incr emp =
  (case simplify_emp mu_incr emp of {
    Inl semp ->
      Just (map eident_prob_to_ident_prob
              (option_to_list (eident_prob_of_semp semp)) ++
             ident_prob_of_semp semp);
    Inr True -> Just [];
    Inr False -> Nothing;
  });

n0b :: [Nat] -> [Nat] -> [Nat] -> Nat;
n0b p q oo =
  nat (ceiling
        (divide_rat (of_nat (minus_nat (suc (size_list oo)) (size_list q)))
          (of_nat (size_list p))));

fp_B_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> [Nat] -> [Nat] -> Ctxt a b -> Term a b -> Bool;
fp_B_decide mu l oo q c t =
  not (bex (foldr (sup_set . (\ qa -> h_match_probs (si_subst mu) l oo qa c t))
             (proper_prefix_list q)
             (set_empty
               (of_phantom
                 (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla))))
        (match_decision mu)) &&
    not (bex (let {
                p = hole_pos c;
                n = (\ pa -> n0b p pa oo);
                ps = filter
                       (\ (pa, pb) ->
                         less_pos oo (pb ++ power p (n pb)) && less_pos pa p)
                       (remdups (decompositions p));
              } in set (map (\ (pb, pa) ->
                              (subt_at_ctxt c pb,
                                (l, (subst_apply_ctxt c (si_subst mu),
                                      subst_apply_term
(ctxt_subst c (si_subst mu) (n pa) t) (si_subst mu)))))
                         (remdups ps)))
          (\ ep ->
            bex (set_option (ident_prob_of_emp mu ep))
              (all (ident_decision mu))));

n0 :: [Nat] -> [Nat] -> [Nat] -> Nat;
n0 p q oo =
  nat (ceiling
        (divide_rat (of_nat (minus_nat (size_list oo) (size_list q)))
          (of_nat (size_list p))));

bounded_postfixes :: [Nat] -> [[Nat]] -> [[Nat]];
bounded_postfixes p ps =
  map_filter (\ x -> (if not (is_none x) then Just (the x) else Nothing))
    (map (remove_prefix p) ps);

fp_A_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> [Nat] -> [Nat] -> Ctxt a b -> Term a b -> Bool;
fp_A_decide mu l oo q c t =
  not (bex (case subt_at t q of {
             Var _ ->
               set_empty
                 (of_phantom
                   (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla));
             Fun _ _ ->
               let {
                 h = hole_pos c;
                 n = n0 h q oo;
                 hn = power h n;
                 cs = ctxt_subst c (si_subst mu) n t;
                 q_s = bounded_postfixes q (poss_list t);
                 qoo_s =
                   concatMap
                     (\ qa ->
                       map (\ a -> (qa, a)) (prefix_list (hn ++ q ++ qa)))
                     q_s;
                 qoo_sf =
                   filter (\ qoo -> less_pos (hn ++ q) (snd qoo ++ oo)) qoo_s;
                 m1 = map (\ qoo -> (subt_at cs (snd qoo), l)) qoo_sf;
                 sterms = remdups (map (si_subst mu) (si_W mu (subt_at t q)));
                 uterms =
                   concatMap (filter (\ ta -> not (is_Var ta)) . supteq_list)
                     sterms;
                 m2 = map (\ u -> (u, l)) (remdups uterms);
               } in set (m1 ++ m2);
           })
        (match_decision mu));

fp_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 ([Nat], (Ctxt a b, Term a b)) ->
                   (Ctxt a b, (Term a b, Location)) -> Bool;
fp_decide mu =
  (\ (q, (c, t)) (l, (la, loc)) ->
    (if equal_location loc H
      then fp_H_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
      else True) &&
      (if equal_location loc A
        then fp_A_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
        else True) &&
        (if equal_location loc Ba
          then fp_B_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
          else True) &&
          (if equal_location loc Ra
            then fp_R_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
            else True));

fp_valid ::
  forall a b c.
    (Compare a, Eq a, Compare b, Eq b, Ceq c,
      Ccompare c) => Set (Ctxt a b, (Term a b, c)) -> Bool;
fp_valid p = ball p (\ (l, (la, _)) -> not (is_Var (ctxt_apply_term l la)));

check_fploop ::
  forall a b.
    (Compare a, Eq a, Showl a, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Ctxt a b, (Term a b, Location))] ->
                      Fp_loop_prf a b -> Sum (String -> String) ();
check_fploop r p (FP_loop_prf c sigma t seq) =
  let {
    mu = subst_incr sigma;
    mua = si_subst mu;
  } in bindb (check (not (null seq))
               (showsl_lit "looping reduction must not be empty"))
         (\ _ ->
           bindb (check
                   (equal_term (case last seq of {
                                 (_, (_, ta)) -> ta;
                               })
                     (ctxt_apply_term c (subst_apply_term t mua)))
                   (showsl_lit "last term in sequence is not C[t sigma]"))
             (\ _ ->
               bindb (check (fp_valid (set p))
                       (showsl_lit
                         "lhss in forbidden patterns must not be variables"))
                 (\ _ ->
                   bindb (catch_errora
                           (forallM
                             (\ (l, _) ->
                               check (not (is_Var l))
                                 (showsl_lit
                                   "lhss of TRS must not be variables"))
                             r)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       let {
                         seqa = zip (t : map (\ (_, (_, ta)) -> ta) seq) seq;
                       } in catch_errora
                              (forallM
                                (\ (ta, (q, (ra, s))) ->
                                  bindb (check_rstep r q ra ta s)
                                    (\ _ ->
                                      let {
check_fpstep = fp_decide mu (q, (c, ta));
                                      } in
catch_errora
  (forallM
    (\ pt ->
      check (check_fpstep pt)
        (((((((showsl_lit "iterating reduction " . showsl_terma ta) .
               showsl_lit " -->") .
              showsl_pos q) .
             showsl_lit " ") .
            showsl_terma s) .
           showsl_lit " does not respect forbidden pattern ") .
          showsl_pattern pt))
    p)
  (\ x -> Inl (snd x))))
                                seqa)
                              (\ x -> Inl (snd x))))));

check_fp_tp_subsumes ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ([(Ctxt (Lab a b) [Char], (Term (Lab a b) [Char], Location))],
                    [(Term (Lab a b) [Char], Term (Lab a b) [Char])]) ->
                    ([(Ctxt (Lab a b) [Char],
                        (Term (Lab a b) [Char], Location))],
                      [(Term (Lab a b) [Char], Term (Lab a b) [Char])]) ->
                      Sum (String -> String) ();
check_fp_tp_subsumes ta t =
  (case (ta, t) of {
    ((p, r), (pa, ra)) ->
      catch_errora
        (bindb
          (check (p == pa)
            (showsl_lit "difference in forbidden patterns strategy"))
          (\ _ ->
            catch_errora (check_subseteq r ra)
              (\ x -> Inl (toomuch "rule" (showsl_rule x)))))
        (\ x ->
          Inl (showsl_lit
                 "problem in showing subsumption for non-termination\n" .
                x));
  });

string_reversal_complete_tt ::
  forall a b c d.
    (Showl b, Showl c) => Tp_ops_ext a b c d -> a -> Sum (String -> String) a;
string_reversal_complete_tt i tp =
  let {
    r = rulese i tp;
  } in bindb (check (q_emptyb i tp) (showsl_lit "Q is not empty"))
         (\ _ ->
           bindb (check_unary_signature r)
             (\ _ -> Inr (mkc i default_nfs_nt_trs [] (map rev_rule r) [])));

showsl_lines :: forall a. (Showl a) => String -> [a] -> String -> String;
showsl_lines desc_empty = showsl_list_gen showsl desc_empty "" "\n" "";

showsl_tree_automaton ::
  forall a b. (Showl a, Showl b) => Tree_automaton a b -> String -> String;
showsl_tree_automaton (Tree_Automaton fin rules eps) =
  (((((showsl_lit "final: " . showsl_list fin) . showsl_lit "\nrules: ") .
      showsl_lines "empty" rules) .
     showsl_lit "\nepsilon: ") .
    showsl_list_prod eps) .
    showsl_literal "\n";

ta_idx_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> e;
ta_idx_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = idx;

comp_res_of_order :: Ordera -> Comp_res;
comp_res_of_order Eqa = EQUAL;
comp_res_of_order Lt = LESS;
comp_res_of_order Gt = GREATER;

compare_res :: forall a. (Compare a) => a -> a -> Comp_res;
compare_res x y = comp_res_of_order (compare x y);

set_iterator_image ::
  forall a b c.
    (a -> b) ->
      ((c -> Bool) -> (a -> c -> c) -> c -> c) ->
        (c -> Bool) -> (b -> c -> c) -> c -> c;
set_iterator_image g it = (\ c f -> it c (\ x -> f (g x)));

map_iterator_dom ::
  forall a b c.
    ((a -> Bool) -> ((b, c) -> a -> a) -> a -> a) ->
      (a -> Bool) -> (b -> a -> a) -> a -> a;
map_iterator_dom it = set_iterator_image fst it;

list_eq :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
list_eq eq [] [] = True;
list_eq eq (aa : la) (a : l) = (if eq aa a then list_eq eq la l else False);
list_eq uu (v : va) [] = False;
list_eq uu [] (v : va) = False;

rule_filter_opt_code ::
  forall a b.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            b -> [a] -> Rbta a ();
rule_filter_opt_code a b c =
  (case rbt_comp_lookup compare_prod (ta_idx_impl a) (b, size_list c) of {
    Nothing -> Empty;
    Just xc ->
      gen_image (map_iterator_dom . rm_iterateoi) Empty
        (\ k -> rbt_comp_insert compare k ()) snd
        (gen_filter (map_iterator_dom . rm_iterateoi) Empty
          (\ k -> rbt_comp_insert compare_prod k ())
          (\ (xd, _) -> list_eq (comp2eq compare_res) xd c) xc);
  });

ta_rhs_states_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> d;
ta_rhs_states_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = rhs;

update_all_code ::
  forall a b. (Compare a) => Rbta a b -> Rbta a () -> b -> Rbta a b;
update_all_code m s v =
  (map_iterator_dom . rm_iterateoi) s (\ _ -> True)
    (\ x -> rbt_comp_insert compare x v) m;

update_all2_code ::
  forall a b c.
    (Compare a,
      Compare b) => Rbta a (Rbta b c) ->
                      Rbta a () -> Rbta b () -> c -> Rbta a (Rbta b c);
update_all2_code m s1 s2 v =
  (map_iterator_dom . rm_iterateoi) s1 (\ _ -> True)
    (\ x sigma ->
      let {
        xa = update_all_code (case rbt_comp_lookup compare sigma x of {
                               Nothing -> Empty;
                               Just a -> id a;
                             })
               s2 v;
      } in rbt_comp_insert compare x xa sigma)
    m;

union_image_rs_code ::
  forall a b.
    (Compare a, Compare b) => Rbta a () -> (a -> Rbta b ()) -> Rbta b ();
union_image_rs_code s f =
  (map_iterator_dom . rm_iterateoi) s (\ _ -> True)
    (\ x -> rbt_comp_union_with_key compare (\ _ _ rv -> rv) (f x)) Empty;

ta_eps_cl_impl ::
  forall a b c d e f g h i. (a, (b, (c, (d, (e, (f, (g -> h, i))))))) -> g -> h;
ta_eps_cl_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) q = efcl q;

ta_match_var_ref_code ::
  forall a b c.
    (Compare_order a, Compare_order b,
      Compare c) => (Rbta a (),
                      (Rbta (Ta_rule a b) (),
                        ([(a, a)],
                          (Rbta a (),
                            (Rbta (b, Nat) (Rbta ([a], a) ()),
                              (Bool, (a -> Rbta a (), a -> Rbta a ()))))))) ->
                      Rbta a () -> c -> Rbta a () -> Rbta [(c, a)] ();
ta_match_var_ref_code ta qsig x q =
  (map_iterator_dom . rm_iterateoi) qsig (\ _ -> True)
    (\ xa sigma ->
      (if not (gen_disjoint (map_iterator_dom . rm_iterateoi)
                (\ k s -> (case rbt_comp_lookup compare s k of {
                            Nothing -> False;
                            Just _ -> True;
                          }))
                (ta_eps_cl_impl ta xa) q)
        then rbt_comp_insert compare_list [(x, xa)] () sigma else sigma))
    Empty;

set_App_code ::
  forall a. (Compare a) => Rbta [a] () -> Rbta [a] () -> Rbta [a] ();
set_App_code x xs =
  (map_iterator_dom . rm_iterateoi) x (\ _ -> True)
    (\ xa ->
      (map_iterator_dom . rm_iterateoi) xs (\ _ -> True)
        (\ xaa -> rbt_comp_insert compare_list (xa ++ xaa) ()))
    Empty;

concat_listset_code :: forall a. (Compare a) => [Rbta [a] ()] -> Rbta [a] ();
concat_listset_code =
  rec_list (rbt_comp_insert compare_list [] () Empty) (\ x _ -> set_App_code x);

map2 :: forall a b c. (a -> b -> c) -> [a] -> [b] -> [c];
map2 f [] ys = [];
map2 f (v : va) [] = [];
map2 f (x : xs) (y : ys) = f x y : map2 f xs ys;

ta_match_code ::
  forall a b c.
    (Compare_order a, Compare_order b,
      Compare c) => (Rbta a (),
                      (Rbta (Ta_rule a b) (),
                        ([(a, a)],
                          (Rbta a (),
                            (Rbta (b, Nat) (Rbta ([a], a) ()),
                              (Bool, (a -> Rbta a (), a -> Rbta a ()))))))) ->
                      Rbta a () -> Term b c -> Rbta a () -> Rbta [(c, a)] ();
ta_match_code ta qsig (Var x) q = ta_match_var_ref_code ta qsig x q;
ta_match_code a b (Fun c d) e =
  (case rbt_comp_lookup compare_prod (ta_idx_impl a) (c, size_list d) of {
    Nothing -> Empty;
    Just xe ->
      union_image_rs_code xe
        (\ (xf, xg) ->
          (if not (gen_disjoint (map_iterator_dom . rm_iterateoi)
                    (\ k s -> (case rbt_comp_lookup compare s k of {
                                Nothing -> False;
                                Just _ -> True;
                              }))
                    (ta_eps_cl_impl a xg) e)
            then concat_listset_code
                   (map2 (\ t q ->
                           ta_match_code a b t
                             (rbt_comp_insert compare q () Empty))
                     d xf)
            else Empty));
  });

ta_res_args_aux_code ::
  forall a b.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            b -> [Rbta a ()] -> Rbta a ();
ta_res_args_aux_code =
  (\ x xa xb ->
    (case rbt_comp_lookup compare_prod (ta_idx_impl x) (xa, size_list xb) of {
      Nothing -> Empty;
      Just xc ->
        union_image_rs_code xc
          (\ (xd, xe) ->
            (if list_all2 (\ xf s -> (case rbt_comp_lookup compare s xf of {
                                       Nothing -> False;
                                       Just _ -> True;
                                     }))
                  xd xb
              then ta_eps_cl_impl x xe else Empty));
    }));

ta_res_code ::
  forall a b.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            Term b a -> Rbta a ();
ta_res_code =
  (\ x xa ->
    rec_term (\ xb xc -> ta_eps_cl_impl xc xb)
      (\ xb xc xd -> let {
                       a = map (\ xe -> snd xe xd) xc;
                     } in ta_res_args_aux_code xd xb a)
      xa x);

is_compatible_code ::
  forall a b c.
    (Compare_order a, Compare_order b, Compare c,
      Eq c) => (Rbta a (),
                 (Rbta (Ta_rule a b) (),
                   ([(a, a)],
                     (Rbta a (),
                       (Rbta (b, Nat) (Rbta ([a], a) ()),
                         (Bool, (a -> Rbta a (), a -> Rbta a ()))))))) ->
                 Rbta (Term b c, Term b c) () ->
                   Sum (a, (Term b a, Term b a))
                     (Rbta a (Rbta a (Term b a, Term b a)));
is_compatible_code ta r =
  (map_iterator_dom . rm_iterateoi) r is_Inr
    (\ x sigma ->
      (case x of {
        (a, b) ->
          let {
            xa = ta_match_code ta (ta_rhs_states_impl ta) a
                   (ta_rhs_states_impl ta);
          } in (map_iterator_dom . rm_iterateoi) xa is_Inr
                 (\ xb sigmaa ->
                   let {
                     xc = map_term (\ xg -> xg) (fun_of xb) a;
                     xd = ta_res_code ta xc;
                   } in (if gen_isEmptya
                              (gen_balla (map_iterator_dom . rm_iterateoi)) xd
                          then sigmaa
                          else let {
                                 xe = map_term (\ xg -> xg) (fun_of xb) b;
                                 xf = ta_res_code ta xe;
                               } in (if gen_isEmptya
  (gen_balla (map_iterator_dom . rm_iterateoi)) xf
                                      then let {
     xg = gen_pick (map_iterator_dom . rm_iterateoi) xd;
   } in Inl (xg, (xc, xe))
                                      else let {
     aa = update_all2_code (projr sigmaa) xd xf (xc, xe);
   } in Inr aa)))
                 sigma;
      }))
    (Inr Empty);

ta_rules_impla ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> b;
ta_rules_impla (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = r;

ta_final_impla ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> a;
ta_final_impla (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = f;

ta_idx_rhs_init_code ::
  forall a b c.
    (Compare a, Compare b,
      Compare c) => Bool ->
                      Rbta (Ta_rule a b) () ->
                        (a -> Rbta c ()) ->
                          (Rbta (b, Nat) (Rbta ([a], a) ()), (Bool, Rbta c ()));
ta_idx_rhs_init_code det rs efcl =
  (map_iterator_dom . rm_iterateoi) rs (\ _ -> True)
    (\ x (a, (aa, ba)) ->
      (case x of {
        TA_rule xg xh xi ->
          let {
            y = size_list xh;
          } in (case rbt_comp_lookup compare_prod a (xg, y) of {
                 Nothing ->
                   (rbt_comp_insert compare_prod (xg, y)
                      (rbt_comp_insert compare_prod (xh, xi) () Empty) a,
                     (aa, rbt_comp_union_with_key compare (\ _ _ rv -> rv)
                            (efcl xi) ba));
                 Just xj ->
                   (rbt_comp_insert compare_prod (xg, y)
                      (rbt_comp_insert compare_prod (xh, xi) () xj) a,
                     ((if aa
                        then gen_balla (map_iterator_dom . rm_iterateoi) xj
                               (\ (xk, _) ->
                                 not (list_eq (comp2eq compare_res) xh xk))
                        else False),
                       rbt_comp_union_with_key compare (\ _ _ rv -> rv)
                         (efcl xi) ba));
               });
      }))
    (Empty, (det, Empty));

prod_eq ::
  forall a b c d.
    (a -> b -> Bool) -> (c -> d -> Bool) -> (a, c) -> (b, d) -> Bool;
prod_eq eqa eqb x1 x2 = (case x1 of {
                          (a1, b1) -> (case x2 of {
(a2, b2) -> eqa a1 a2 && eqb b1 b2;
                                      });
                        });

glist_member :: forall a. (a -> a -> Bool) -> a -> [a] -> Bool;
glist_member eq x [] = False;
glist_member eq x (y : ys) = eq x y || glist_member eq x ys;

glist_insert :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
glist_insert eq x xs = (if glist_member eq x xs then xs else x : xs);

ta_make_code ::
  forall a b c.
    (Compare a, Compare_order b,
      Compare c) => Rbta a () ->
                      Rbta (Ta_rule b c) () ->
                        [(b, b)] ->
                          (Rbta a (),
                            (Rbta (Ta_rule b c) (),
                              ([(b, b)],
                                (Rbta b (),
                                  (Rbta (c, Nat) (Rbta ([b], b) ()),
                                    (Bool,
                                      (b -> Rbta b (), b -> Rbta b ())))))));
ta_make_code f r e =
  let {
    a = ta_idx_rhs_init_code (is_Nil e) r
          (\ xi -> impl_of (memo_rbt_rtrancl e xi));
  } in (case a of {
         (ab, (aa, ba)) ->
           (f, (r, (e, (ba, (ab, (aa, ((\ s -> impl_of (memo_rbt_rtrancl e s)),
(\ s ->
  impl_of
    (memo_rbt_rtrancl
      (gen_image foldli []
        (glist_insert (prod_eq (comp2eq compare_res) (comp2eq compare_res)))
        (\ xc -> (snd xc, fst xc)) e)
      s)))))))));
       });

ta_eps_impl ::
  forall a b c d e f g h. (a, (b, (c, (d, (e, (f, (g, h))))))) -> c;
ta_eps_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) = e;

ta_only_res_wits_code ::
  forall a b c d.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            Rbta a (Term c d) ->
                              (Rbta a (),
                                (Rbta (Ta_rule a b) (),
                                  ([(a, a)],
                                    (Rbta a (),
                                      (Rbta (b, Nat) (Rbta ([a], a) ()),
(Bool, (a -> Rbta a (), a -> Rbta a ())))))));
ta_only_res_wits_code a b =
  let {
    y = gen_filter (map_iterator_dom . rm_iterateoi) Empty
          (\ k -> rbt_comp_insert compare k ())
          (\ xb -> not (is_None (rbt_comp_lookup compare b xb)))
          (ta_final_impla a);
    y_a = gen_filter (map_iterator_dom . rm_iterateoi) Empty
            (\ k -> rbt_comp_insert compare_ta_rule k ())
            (\ xb ->
              list_all_rec
                (\ xc -> not (is_None (rbt_comp_lookup compare b xc)))
                (r_lhs_states xb))
            (ta_rules_impla a);
    aa = filter (\ xb -> not (is_None (rbt_comp_lookup compare b (fst xb))))
           (ta_eps_impl a);
  } in ta_make_code y y_a aa;

ta_only_prs_wits_code ::
  forall a b c d.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            Rbta a (Ctxt c d) ->
                              (Rbta a (),
                                (Rbta (Ta_rule a b) (),
                                  ([(a, a)],
                                    (Rbta a (),
                                      (Rbta (b, Nat) (Rbta ([a], a) ()),
(Bool, (a -> Rbta a (), a -> Rbta a ())))))));
ta_only_prs_wits_code a b =
  let {
    y = gen_filter (map_iterator_dom . rm_iterateoi) Empty
          (\ k -> rbt_comp_insert compare k ())
          (\ xb -> not (is_None (rbt_comp_lookup compare b xb)))
          (ta_final_impla a);
    y_a = gen_filter (map_iterator_dom . rm_iterateoi) Empty
            (\ k -> rbt_comp_insert compare_ta_rule k ())
            (\ xb -> not (is_None (rbt_comp_lookup compare b (r_rhs xb))))
            (ta_rules_impla a);
    aa = filter (\ xb -> not (is_None (rbt_comp_lookup compare b (snd xb))))
           (ta_eps_impl a);
  } in ta_make_code y y_a aa;

next_res_wit_code ::
  forall a b c.
    (Compare a,
      Compare b) => Rbta (Ta_rule a b) () ->
                      Rbta a (Term b c) -> Maybe (a, Term b c);
next_res_wit_code r m =
  (map_iterator_dom . rm_iterateoi) r is_None
    (\ x _ ->
      (case x of {
        TA_rule xb xc xd ->
          bind (mapMa (rbt_comp_lookup compare m) xc)
            (\ xe -> Just (xd, Fun xb xe));
      }))
    Nothing;

res_wits_code ::
  forall a b c.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            Rbta a (Term b c);
res_wits_code tAi =
  let {
    x = (ta_rules_impla tAi, Empty);
  } in (case while (\ (xb, _) ->
                     not (gen_isEmptya
                           (gen_balla (map_iterator_dom . rm_iterateoi)) xb))
               (\ (a, b) ->
                 (case next_res_wit_code a b of {
                   Nothing -> (Empty, b);
                   Just (aa, ba) ->
                     let {
                       xd = ta_eps_cl_impl tAi aa;
                       xe = update_all_code b xd ba;
                       xf = gen_filter (map_iterator_dom . rm_iterateoi) Empty
                              (\ k -> rbt_comp_insert compare_ta_rule k ())
                              (\ xf ->
                                not (case rbt_comp_lookup compare xd (r_rhs xf)
                                      of {
                                      Nothing -> False;
                                      Just _ -> True;
                                    }))
                              a;
                     } in (xf, xe);
                 }))
               x
         of {
         (_, b) -> b;
       });

ta_eps_icl_impl ::
  forall a b c d e f g h i. (a, (b, (c, (d, (e, (f, (g, h -> i))))))) -> h -> i;
ta_eps_icl_impl (f, (r, (e, (rhs, (idx, (det, (efcl, eicl))))))) q = eicl q;

ctxt_compose :: forall a b. Ctxt a b -> Ctxt a b -> Ctxt a b;
ctxt_compose Hole d = d;
ctxt_compose (More f ss1 c ss2) d = More f ss1 (ctxt_compose c d) ss2;

prs_wits_code ::
  forall a b.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            Rbta a (Ctxt b a);
prs_wits_code tAi =
  let {
    x = update_all_code Empty
          (union_image_rs_code (ta_final_impla tAi) (ta_eps_icl_impl tAi)) Hole;
    xa = (False, (ta_rules_impla tAi, x));
  } in (case while (\ (xb, (_, _)) -> not xb)
               (\ (_, (aa, ba)) ->
                 (map_iterator_dom . rm_iterateoi) aa (\ _ -> True)
                   (\ xc (ab, (ac, bc)) ->
                     (case rbt_comp_lookup compare bc (r_rhs xc) of {
                       Nothing ->
                         (ab, (rbt_comp_insert compare_ta_rule xc () ac, bc));
                       Just xd ->
                         (False,
                           (ac, (case xc of {
                                  TA_rule xj xk _ ->
                                    rec_list (\ _ xn _ _ _ -> xn)
                                      (\ xm xn xo xp xq xr xs xt ->
let {
  y_b = update_all_code xq (ta_eps_icl_impl xp (the_Var xm))
          (ctxt_compose xr (More xs xt Hole xn));
} in xo xp y_b xr xs (xt ++ [xm]))
                                      (map Var xk) tAi bc xd xj [];
                                })));
                     }))
                   (True, (Empty, ba)))
               xa
         of {
         (_, (_, ba)) -> ba;
       });

trim_ta_wits_code ::
  forall a b c.
    (Compare_order a,
      Compare_order b) => (Rbta a (),
                            (Rbta (Ta_rule a b) (),
                              ([(a, a)],
                                (Rbta a (),
                                  (Rbta (b, Nat) (Rbta ([a], a) ()),
                                    (Bool,
                                      (a -> Rbta a (), a -> Rbta a ()))))))) ->
                            ((Rbta a (),
                               (Rbta (Ta_rule a b) (),
                                 ([(a, a)],
                                   (Rbta a (),
                                     (Rbta (b, Nat) (Rbta ([a], a) ()),
                                       (Bool,
 (a -> Rbta a (), a -> Rbta a ()))))))),
                              (Rbta a (Term b c), Rbta a (Ctxt b a)));
trim_ta_wits_code tAi = let {
                          x = res_wits_code tAi;
                          xa = ta_only_res_wits_code tAi x;
                          xb = prs_wits_code xa;
                          xc = ta_only_prs_wits_code xa xb;
                        } in (xc, (x, xb));

is_coh_final_code ::
  forall a b c d e.
    (Compare a) => Rbta a () ->
                     Rbta a (Rbta a (Term b c, Term d e)) ->
                       Maybe (Term b c, Term d e);
is_coh_final_code fin rel =
  rm_iterateoi rel is_None
    (\ x _ ->
      (case x of {
        (a, b) ->
          (if (case rbt_comp_lookup compare fin a of {
                Nothing -> False;
                Just _ -> True;
              })
            then rm_iterateoi b is_None
                   (\ xa _ ->
                     (case xa of {
                       (aa, (ab, bb)) ->
                         (if (case rbt_comp_lookup compare fin aa of {
                               Nothing -> False;
                               Just _ -> True;
                             })
                           then Nothing else Just (ab, bb));
                     }))
                   Nothing
            else Nothing);
      }))
    Nothing;

map_add2_code ::
  forall a b c.
    (Compare a,
      Compare b) => Rbta a (Rbta b c) -> Rbta a (Rbta b c) -> Rbta a (Rbta b c);
map_add2_code m1 m2 =
  rm_iterateoi m2 (\ _ -> True)
    (\ x sigma ->
      (case x of {
        (a, b) ->
          (case rbt_comp_lookup compare sigma a of {
            Nothing -> rbt_comp_insert compare a b sigma;
            Just xc ->
              rbt_comp_insert compare a
                (rbt_comp_union_with_key compare (\ _ _ rv -> rv) xc b) sigma;
          });
      }))
    m1;

ta_check_comcoh_code ::
  forall a b c d.
    (Compare_order a, Compare_order b, Compare c,
      Eq c) => (Rbta a (),
                 (Rbta (Ta_rule a b) (),
                   ([(a, a)],
                     (Rbta a (),
                       (Rbta (b, Nat) (Rbta ([a], a) ()),
                         (Bool, (a -> Rbta a (), a -> Rbta a ()))))))) ->
                 Rbta (Term b c, Term b c) () -> Maybe (Term b d, Term b d);
ta_check_comcoh_code ta r =
  let {
    a = trim_ta_wits_code ta;
  } in (case a of {
         (ab, (aa, ba)) ->
           let {
             xa = is_compatible_code ab r;
             xb = (\ xf xg ->
                    subst_apply_term
                      (ctxt_apply_term (the (rbt_comp_lookup compare ba xf)) xg)
                      (\ xh -> the (rbt_comp_lookup compare aa xh)));
           } in (case xa of {
                  Inl (aba, (ac, bc)) -> Just (xb aba ac, xb aba bc);
                  Inr ra ->
                    (case (case while (\ ac ->
(case ac of {
  (Inl _, _) -> False;
  (Inr xj, _) -> not (gen_isEmpty (gen_ball rm_iterateoi) xj);
}))
                                  (\ (aba, bb) ->
                                    let {
                                      xd =
(map_iterator_dom . rm_iterateoi) (ta_rules_impla ab) is_Inr
  (\ xd sigma ->
    (case xd of {
      TA_rule xe y z ->
        foldli (upt zero_nat (size_list y)) is_Inr
          (\ xf s ->
            let {
              xg = nth y xf;
            } in (case rbt_comp_lookup compare (projr aba) xg of {
                   Nothing -> s;
                   Just xh ->
                     rm_iterateoi xh is_Inr
                       (\ xi sigmaa ->
                         (case xi of {
                           (ac, (ad, bd)) ->
                             let {
                               xj = map Var (take xf y);
                               xk = map Var (drop (suc xf) y);
                               xl = Fun xe (xj ++ ad : xk);
                               xm = Fun xe (xj ++ bd : xk);
                               xn = list_update y xf ac;
                               xo = rule_filter_opt_code ab xe xn;
                             } in (if gen_isEmptya
(gen_balla (map_iterator_dom . rm_iterateoi)) xo
                                    then Inl (z, (xl, xm))
                                    else let {
   xp = gen_filter (map_iterator_dom . rm_iterateoi) Empty
          (\ k -> rbt_comp_insert compare k ())
          (\ xv ->
            is_None
              (bind (rbt_comp_lookup compare bb z)
                (\ xw -> rbt_comp_lookup compare xw xv)))
          xo;
 } in (if gen_isEmptya (gen_balla (map_iterator_dom . rm_iterateoi)) xp
        then sigmaa
        else Inr (update_all2_code (projr sigmaa)
                   (rbt_comp_insert compare z () Empty) xp (xl, xm))));
                         }))
                       s;
                 }))
          sigma;
    }))
  (Inr Empty);
                                    } in (if is_Inr xd
   then (xd, map_add2_code bb (projr xd)) else (xd, bb)))
                                  (Inr ra, ra)
                            of {
                            (aba, bb) -> (if is_Inr aba then Inr bb else aba);
                          })
                      of {
                      Inl (aba, (ac, bc)) -> Just (xb aba ac, xb aba bc);
                      Inr raa ->
                        (case is_coh_final_code (ta_final_impla ab) raa of {
                          Nothing -> Nothing;
                          Just (aba, bb) ->
                            Just (subst_apply_term aba
                                    (\ xj ->
                                      the (rbt_comp_lookup compare aa xj)),
                                   subst_apply_term bb
                                     (\ xj ->
                                       the (rbt_comp_lookup compare aa xj)));
                        });
                    });
                });
       });

rep_ta_code ::
  forall b a.
    (Compare_order b,
      Compare_order a) => Ta_code b a ->
                            (Rbta b (),
                              (Rbta (Ta_rule b a) (),
                                ([(b, b)],
                                  (Rbta b (),
                                    (Rbta (a, Nat) (Rbta ([b], b) ()),
                                      (Bool,
(b -> Rbta b (), b -> Rbta b ())))))));
rep_ta_code (Abs_ta_code x) = x;

check_comcoh_wit ::
  forall a b c.
    (Compare_order a, Compare_order b, Compare_order c,
      Eq c) => Ta_code a b ->
                 Rbt (Term b c, Term b c) () -> Maybe (Term b c, Term b c);
check_comcoh_wit x xa = ta_check_comcoh_code (rep_ta_code x) (impl_of xa);

check_comcoh_wit_ls ::
  forall a b c.
    (Compare_order a, Compare_order b, Compare_order c,
      Eq c) => Ta_code a b ->
                 [(Term b c, Term b c)] -> Maybe (Term b c, Term b c);
check_comcoh_wit_ls ta r =
  check_comcoh_wit ta (g_from_list_dflt_basic_oops_rm_basic_ops r);

ta_make_ls_code ::
  forall a b.
    (Compare_order a,
      Compare_order b) => [a] ->
                            [Ta_rule a b] ->
                              [(a, a)] ->
                                (Rbta a (),
                                  (Rbta (Ta_rule a b) (),
                                    ([(a, a)],
                                      (Rbta a (),
(Rbta (b, Nat) (Rbta ([a], a) ()),
  (Bool, (a -> Rbta a (), a -> Rbta a ())))))));
ta_make_ls_code =
  (\ x xa xb ->
    ta_make_code (gen_set Empty (\ k -> rbt_comp_insert compare k ()) x)
      (gen_set Empty (\ k -> rbt_comp_insert compare_ta_rule k ()) xa)
      (gen_set []
        (glist_insert (prod_eq (comp2eq compare_res) (comp2eq compare_res)))
        xb));

make_ls ::
  forall a b.
    (Compare_order a,
      Compare_order b) => [a] -> [Ta_rule a b] -> [(a, a)] -> Ta_code a b;
make_ls x xa xb = Abs_ta_code (ta_make_ls_code x xa xb);

ta_code_make_impl ::
  forall a b.
    (Compare_order a, Compare_order b) => Tree_automaton a b -> Ta_code a b;
ta_code_make_impl (Tree_Automaton fin rs eps) = make_ls fin rs eps;

ta_rhs_states ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Ccompare b,
      Eq b) => Ta_ext a b () -> Set a;
ta_rhs_states ta =
  sup_set (image r_rhs (ta_rules ta))
    (compute_trancl (image r_rhs (ta_rules ta)) (ta_eps ta));

initial_rel ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) -> Set (a, Set a);
initial_rel ta r =
  let {
    rhs = ta_rhs_states ta;
    match = ta_matcha ta rhs;
    analyze_rule =
      (\ (l, ra) ->
        let {
          _ = vars_term l;
        } in sup_seta
               (image
                 (\ sigma ->
                   let {
                     qr = ta_res ta (map_term (\ x -> x) (fun_of sigma) ra);
                   } in image (\ q -> (q, qr))
                          (ta_res ta (map_term (\ x -> x) (fun_of sigma) l)))
                 (match l)));
  } in sup_seta (image analyze_rule r);

initial_relation ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) -> Maybe (Set (a, a));
initial_relation ta r =
  let {
    q_qs = initial_rel ta r;
  } in (if member bot_set (image snd q_qs) then Nothing
         else Just (sup_seta
                     (image (\ (q, a) -> image (\ aa -> (q, aa)) a) q_qs)));

decide_coherent_compatible_main ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) ->
                         (Maybe (Set (a, a)) -> Maybe (Set (a, a))) -> Bool;
decide_coherent_compatible_main ta r normalizer =
  (case normalizer (initial_relation ta r) of {
    Nothing -> False;
    Just rel -> less_eq_set (imagea rel (ta_final ta)) (ta_final ta);
  });

coherent_rule ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b,
      Eq b) => Set (a, a) ->
                 Set (Ta_rule a b) -> Ta_rule a b -> Set (a, Maybe a);
coherent_rule rel rules (TA_rule f qs q) =
  foldr (sup_set .
          (\ i ->
            let {
              qi = nth qs i;
              qi_s = image snd (filtera (\ qq -> fst qq == qi) rel);
              a = sup_seta
                    (image
                      (\ qia ->
                        let {
                          qsa = list_update qs i qia;
                          rls = filtera
                                  (\ (TA_rule g qsaa _) ->
                                    g == f && qsaa == qsa)
                                  rules;
                        } in (if less_eq_set rls
                                   (set_empty (of_phantom set_impl_ta_rule))
                               then inserta Nothing bot_set
                               else image (Just . r_rhs) rls))
                      qi_s);
            } in image (\ aa -> (q, aa)) a))
    (upt zero_nat (size_list qs)) bot_set;

new_states ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Eq b) => Ta_ext a b () -> Set (a, a) -> Set (a, Maybe a);
new_states ta rel = let {
                      rules = ta_rules ta;
                    } in sup_seta (image (coherent_rule rel rules) rules);

normalize_main ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b,
      Eq b) => Ta_ext a b () -> Set (a, a) -> Set (a, a) -> Maybe (Set (a, a));
normalize_main ta rel accu =
  let {
    new = new_states ta rel;
  } in (if member Nothing (image snd new) then Nothing
         else let {
                new_rel = image (\ (x, y) -> (x, the y)) new;
                new_accu = sup_set accu rel;
                todo = minus_set new_rel new_accu;
              } in (if less_eq_set todo bot_set then Just new_accu
                     else normalize_main ta todo new_accu));

normalizeb ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b,
      Eq b) => Ta_ext a b () -> Maybe (Set (a, a)) -> Maybe (Set (a, a));
normalizeb ta (Just rel) = normalize_main ta rel bot_set;
normalizeb ta Nothing = Nothing;

decide_coherent_compatible ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
decide_coherent_compatible ta r =
  decide_coherent_compatible_main ta r (normalizeb ta);

closed_under_rewriting ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Ccompare b, Compare b, Default b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
closed_under_rewriting ta r = decide_coherent_compatible (trim_ta ta) r;

ta_det_impl :: forall a b c d e f g. (a, (b, (c, (d, (e, (f, g)))))) -> f;
ta_det_impl (f, (r, (e, (rhs, (idx, (det, x)))))) = det;

deta :: forall a b. (Compare_order a, Compare_order b) => Ta_code a b -> Bool;
deta x = ta_det_impl (rep_ta_code x);

sorted_ps_ta ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Linorder a, Set_impl a, Ceq b, Ccompare b, Compare b, Eq b,
      Set_impl b) => Ta_ext a b () -> Tree_automaton [a] b;
sorted_ps_ta ta =
  Tree_Automaton
    (sorted_list_of_set (image sorted_list_of_set (ta_final (ps_ta ta))))
    (sorted_list_of_set
      (image
        (\ (TA_rule g qs q) ->
          TA_rule g (map sorted_list_of_set qs) (sorted_list_of_set q))
        (ta_rules (ps_ta ta))))
    [];

tree_aut_trs_closed ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a, Showl a, Ceq b, Ccompare b, Compare_order b, Default b, Eq b,
      Set_impl b, Showl b, Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c,
      Compare_order c, Eq c, Set_impl c,
      Showl c) => Tree_automaton a b ->
                    Ta_relation a ->
                      [(Term b c, Term b c)] -> Sum (String -> String) ();
tree_aut_trs_closed ta rel r =
  bindb (check_varcond_subset r)
    (\ _ ->
      catch_errora
        (case rel of {
          Decision_Proc_Old ->
            bindb (catch_errora (check_det ta)
                    (\ x ->
                      Inl (showsl_lit
                             "decision procedure requires det. TA as input\n" .
                            x)))
              (\ _ ->
                check (closed_under_rewriting (ta_of_ta ta) (set r))
                  (showsl_lit "TA is not closed under rewriting"));
          Decision_Proc ->
            let {
              tc = ta_code_make_impl ta;
            } in (if deta tc
                   then (case check_comcoh_wit_ls tc r of {
                          Nothing -> Inr ();
                          Just (wl, wr) ->
                            Inl ((((showsl_lit
                                      "TA is not closed under rewriting\n" .
                                     showsl_terma wl) .
                                    showsl_lit
                                      " is accepted by TA and rewrites to\n") .
                                   showsl_terma wr) .
                                  showsl_lit " which is not accepted by TA");
                        })
                   else let {
                          tca = ta_code_make_impl
                                  (sorted_ps_ta (trim_ta (ta_of_ta ta)));
                        } in (case check_comcoh_wit_ls tca r of {
                               Nothing -> Inr ();
                               Just (wl, wr) ->
                                 Inl ((((showsl_lit
   "TA is not closed under rewriting\n" .
  showsl_terma wl) .
 showsl_lit " is accepted by TA and rewrites to\n") .
showsl_terma wr) .
                                       showsl_lit
 " which is not accepted by TA");
                             }));
          Id_Relation ->
            bindb (generate_ta_cond ta rel)
              (\ taa ->
                bindb (catch_errora
                        (if isOK (check_left_linear_trs r) then Inr ()
                          else check_det ta)
                        (\ x ->
                          Inl (showsl_lit
                                 "could not ensure left-linearity or determinism\n" .
                                x)))
                  (\ _ ->
                    catch_errora
                      (state_compatible_eff_list taa (rel_checker rel) r)
                      (\ x ->
                        Inl (case x of {
                              (lr, (lrq, q)) ->
                                ((((((showsl_lit
"TA is not compatible with R\n" .
                                       showsl_lit "for rule ") .
                                      showsl_rule lr) .
                                     showsl_lit
                                       "\nwhich is instantiated by states to ") .
                                    showsl_rule lrq) .
                                   showsl_lit "\nthe state ") .
                                  showsl q) .
                                  showsl_lit
                                    " is only reachable from the lhs\n";
                            }))));
          Some_Relation _ ->
            bindb (generate_ta_cond ta rel)
              (\ taa ->
                bindb (catch_errora
                        (if isOK (check_left_linear_trs r) then Inr ()
                          else check_det ta)
                        (\ x ->
                          Inl (showsl_lit
                                 "could not ensure left-linearity or determinism\n" .
                                x)))
                  (\ _ ->
                    catch_errora
                      (state_compatible_eff_list taa (rel_checker rel) r)
                      (\ x ->
                        Inl (case x of {
                              (lr, (lrq, q)) ->
                                ((((((showsl_lit
"TA is not compatible with R\n" .
                                       showsl_lit "for rule ") .
                                      showsl_rule lr) .
                                     showsl_lit
                                       "\nwhich is instantiated by states to ") .
                                    showsl_rule lrq) .
                                   showsl_lit "\nthe state ") .
                                  showsl q) .
                                  showsl_lit
                                    " is only reachable from the lhs\n";
                            }))));
        })
        (\ x ->
          Inl (((showsl_lit
                   "problem when ensuring (state-)compatibility of TRS with TA\n" .
                  showsl_tree_automaton ta) .
                 showsl_literal "\n") .
                x)));

intersect_ta ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Ceq b,
      Ccompare b, Eq b, Set_impl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Eq c,
      Set_impl c) => Ta_ext a b () -> Ta_ext c b () -> Ta_ext (a, c) b ();
intersect_ta tA1 tA2 = prod_ta tA1 tA2 (productc (ta_final tA1) (ta_final tA2));

ta_contains_nf ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a,
      Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare b, Default b,
      Eq b, Set_impl b, Compare c,
      Eq c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
ta_contains_nf ta r =
  not (ta_empty (intersect_ta (ta_nf (image fst r) (ta_syms ta)) ta));

check_trs_not_wn ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a, Showl a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b, Showl b,
      Card_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare_order c, Eq c,
      Set_impl c,
      Showl c) => [(Term a b, Term a b)] ->
                    Not_wn_ta_prf a c -> Sum (String -> String) ();
check_trs_not_wn r (Not_wn_ta_prf ta rel) =
  bindb (check_varcond_subset r)
    (\ _ ->
      bindb (check_left_linear_trs r)
        (\ _ ->
          let {
            tA_trim = trim_ta (ta_of_ta ta);
          } in bindb (check (not (ta_empty tA_trim)) (showsl_lit "TA is empty"))
                 (\ _ ->
                   bindb (tree_aut_trs_closed ta rel r)
                     (\ _ ->
                       check (not (ta_contains_nf tA_trim (set r)))
                         (showsl_lit "TA accepts some normal form")))));

check_not_wn_ta_prf ::
  forall a b c d e.
    (Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare_order b,
      Default b, Eq b, Set_impl b, Showl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showl c,
      Card_UNIV e, Cenum e, Ceq e, Cproper_interval e, Compare_order e, Eq e,
      Set_impl e,
      Showl e) => Tp_ops_ext a b c d ->
                    a -> Not_wn_ta_prf b e -> Sum (String -> String) ();
check_not_wn_ta_prf i tp prf =
  let {
    r = rulese i tp;
  } in bindb (check (null (qb i tp))
               (showsl_lit
                 "strategy is unsupported for tree automata based nontermination"))
         (\ _ -> check_trs_not_wn r prf);

check_dps ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => (a -> a) ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] -> Sum (Term a b, Term a b) ();
check_dps unshp r p =
  let {
    d = defined_list r;
  } in catch_errora
         (forallM
           (\ x ->
             (if (case x of {
                   (ll, rr) ->
                     not (is_Var rr) &&
                       not (membera d (the (root rr))) &&
                         any (\ (l, ra) ->
                               equal_term l (sharp_term unshp ll) &&
                                 (equal_term ra (sharp_term unshp rr) ||
                                   supt_impl ra (sharp_term unshp rr)))
                           r;
                 })
               then Inr () else Inl x))
           p)
         (\ x -> Inl (snd x));

unsharp :: forall a b. Lab a b -> Lab a b;
unsharp (Sharp f) = f;
unsharp (Lab v va) = Lab v va;
unsharp (FunLab v va) = FunLab v va;
unsharp (UnLab v) = UnLab v;

dp_trans_nontermination_tt ::
  forall a b c d e f g.
    (Eq b, Showl b, Eq c, Showl c, Eq d,
      Showl d) => Tp_ops_ext a (Lab b c) d e ->
                    Dpp_ops_ext f (Lab b c) d g ->
                      a -> Dp_trans_nontermination_tt_prf b c d ->
                             Sum (String -> String) f;
dp_trans_nontermination_tt i j tp (DP_trans_nontermination_tt_prf p) =
  let {
    r = rulese i tp;
    q = qb i tp;
  } in bindb (check (null q || not (nfsb i tp))
               (showsl_lit "strategies and normal form substitutions problem"))
         (\ _ ->
           bindb (catch_errora (check_dps unsharp r p)
                   (\ x ->
                     Inl (showsl_lit "problematic rule: " . showsl_rule x)))
             (\ _ -> Inr (mkd j False False p [] q [] r)));

switch_termination_tt ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    Join_info b -> a -> Sum (String -> String) a;
switch_termination_tt i joins_i tp =
  let {
    r = rulese i tp;
    q = qb i tp;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b (showsl_lit "rules are not overlay"))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_wf_trs r)
                        (\ _ ->
                          bindb (check_critical_pairs r cp joins_i)
                            (\ _ ->
                              catch_errora (check_NF_trs_subset r q)
                                (\ x ->
                                  Inl (showsl_terma x .
showsl_lit " is not in normal form w.r.t. R")))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsb i tp) [] r []);
       });

q_increase_nonterm_trs ::
  forall a b c.
    (Compare_order b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a b c () ->
                    a -> Q_increase_nonterm_trs_prf b c ->
                           Sum (String -> String) a;
q_increase_nonterm_trs i dpp (Q_increase_nonterm_trs_prf q) =
  let {
    r = rulese i dpp;
    qa = qb i dpp;
    nfs = nfsb i dpp;
  } in Inr (mkc i nfs (list_union qa q) r []);

showsl_srs_rule :: forall a b. (Showl a, Showl b) => (a, b) -> String -> String;
showsl_srs_rule (l, r) = (showsl l . showsl_lit " -> ") . showsl r;

showsl_exp :: forall a b. (Showl a, Showl b) => (a, b) -> String -> String;
showsl_exp (f, c) = (showsl f . showsl_lit "n+ ") . showsl c;

showsl_p ::
  forall a b c d e.
    (Showl a, Showl b, Showl c, Showl d,
      Showl e) => (a, ((b, (c, d)), e)) -> String -> String;
showsl_p (b, ((f, (c, m)), a)) =
  ((((showsl b . showsl m) . showsl_lit " ^ (") . showsl_exp (f, c)) .
    showsl_lit ")") .
    showsl a;

showsl_pat ::
  forall a b c d e f g h i j.
    (Showl a, Showl b, Showl c, Showl d, Showl e, Showl f, Showl g, Showl h,
      Showl i,
      Showl j) => ((a, ((b, (c, d)), e)), (f, ((g, (h, i)), j))) ->
                    String -> String;
showsl_pat (p1, p2) = (showsl_p p1 . showsl_lit " ->+ ") . showsl_p p2;

showsl_oc :: forall a b. (Showl a, Showl b) => (a, b) -> String -> String;
showsl_oc (l, r) = (showsl l . showsl_lit " ->+ ") . showsl r;

normalize_wp ::
  forall a.
    (Eq a) => ([a], ((Nat, (Nat, [a])), [a])) ->
                ([a], ((Nat, (Nat, [a])), [a]));
normalize_wp xa =
  (case xa of {
    (x5a, a) ->
      (case a of {
        (aa, x1ca) ->
          (case aa of {
            (x4ba, ab) ->
              (if equal_nat x4ba zero_nat
                then (case ab of {
                       (ac, x2ca) ->
                         (if equal_nat ac zero_nat
                           then ([], ((zero_nat, (zero_nat, [])), x5a ++ x1ca))
                           else normalize_wp
                                  (x5a ++
                                     concat
                                       (replicate (suc (minus_nat ac one_nat))
 x2ca),
                                    ((zero_nat, (zero_nat, x2ca)), x1ca)));
                     })
                else (if equal_nat (minus_nat x4ba one_nat) zero_nat
                       then (case ab of {
                              (ac, x2ca) ->
                                (if equal_nat ac zero_nat
                                  then (case x2ca of {
 [] -> ([], ((zero_nat, (zero_nat, [])), x5a ++ x1ca));
 x4a : x3a ->
   (case x1ca of {
     [] -> (x5a, ((suc zero_nat, (zero_nat, x4a : x3a)), []));
     x2a : x1a ->
       (if x4a == x2a
         then normalize_wp
                (x5a ++ [x2a], ((suc zero_nat, (zero_nat, x3a ++ [x2a])), x1a))
         else (x5a, ((suc zero_nat, (zero_nat, x4a : x3a)), x2a : x1a)));
   });
                                       })
                                  else normalize_wp
 (x5a ++ concat (replicate (suc (minus_nat ac one_nat)) x2ca),
   ((suc zero_nat, (zero_nat, x2ca)), x1ca)));
                            })
                       else (case ab of {
                              (ac, x2ca) ->
                                (if equal_nat ac zero_nat
                                  then (case x2ca of {
 [] -> ([], ((zero_nat, (zero_nat, [])), x5a ++ x1ca));
 x3fa : x2fa ->
   normalize_wp
     (x5a, ((suc zero_nat,
              (zero_nat,
                concat
                  (replicate
                    (suc (suc (minus_nat (minus_nat x4ba one_nat) one_nat)))
                    (x3fa : x2fa)))),
             x1ca));
                                       })
                                  else normalize_wp
 (x5a ++ concat (replicate (suc (minus_nat ac one_nat)) x2ca),
   ((suc (suc (minus_nat (minus_nat x4ba one_nat) one_nat)), (zero_nat, x2ca)),
     x1ca)));
                            })));
          });
      });
  });

word_pat_equiv ::
  forall a.
    (Eq a) => ([a], ((Nat, (Nat, [a])), [a])) ->
                ([a], ((Nat, (Nat, [a])), [a])) -> Bool;
word_pat_equiv wp1 wp2 = wp1 == wp2 || normalize_wp wp1 == normalize_wp wp2;

check_stepb ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showl a) => Set ([a], [a]) ->
                    Dp_proof_step a -> Sum (String -> String) ();
check_stepb r step =
  (case step of {
    OC1 uv _ ->
      check (member uv r)
        (showsl_srs_rule uv . showsl_lit " is not an original rule");
    OC2 oc_new oc1 oc2 t x l ->
      (case oc_new of {
        (wl, tr) ->
          (case oc1 of {
            (w, tx) ->
              (case oc2 of {
                (xl, ra) ->
                  catch_errora
                    (bindb
                      (check (xl == x ++ l) (showsl_lit "problem: xl != x l"))
                      (\ _ ->
                        bindb (check (tx == t ++ x)
                                (showsl_lit "problem: tx != t x"))
                          (\ _ ->
                            bindb (check (wl == w ++ l)
                                    (showsl_lit "problem: wl != w l"))
                              (\ _ ->
                                check (tr == t ++ ra)
                                  (showsl_lit "problem: tr != t r")))))
                    (\ xa ->
                      Inl (((((((showsl_lit
                                   "problem in checking overlap OC2 of\n" .
                                  showsl_oc oc1) .
                                 showsl_literal "\n") .
                                showsl_oc oc2) .
                               showsl_lit "\nto yield\n") .
                              showsl_oc oc_new) .
                             showsl_literal "\n") .
                            xa));
              });
          });
      });
    OC2p oc_new oc1 oc2 x t l ->
      (case oc_new of {
        (lw, rt) ->
          (case oc1 of {
            (w, xt) ->
              (case oc2 of {
                (lx, ra) ->
                  catch_errora
                    (bindb
                      (check (lx == l ++ x) (showsl_lit "problem: lx != l x"))
                      (\ _ ->
                        bindb (check (lw == l ++ w)
                                (showsl_lit "problem: lw != l w"))
                          (\ _ ->
                            bindb (check (rt == ra ++ t)
                                    (showsl_lit "problem: rt != r t"))
                              (\ _ ->
                                check (xt == x ++ t)
                                  (showsl_lit "problem: xt != x t")))))
                    (\ xa ->
                      Inl (((((((showsl_lit
                                   "problem in checking overlap OC2\' of\n" .
                                  showsl_oc oc1) .
                                 showsl_literal "\n") .
                                showsl_oc oc2) .
                               showsl_lit "\nto yield\n") .
                              showsl_oc oc_new) .
                             showsl_literal "\n") .
                            xa));
              });
          });
      });
    OC3 oc_new oc1 oc2 t1 t2 ->
      (case oc_new of {
        (w, t1rt2) ->
          (case oc1 of {
            (wa, t1xt2) ->
              (case oc2 of {
                (x, ra) ->
                  catch_errora
                    (bindb
                      (check (t1rt2 == t1 ++ ra ++ t2)
                        (showsl_lit "problem: t1_r_t2 != t1 r t2"))
                      (\ _ ->
                        bindb (check (t1xt2 == t1 ++ x ++ t2)
                                (showsl_lit "problem: t1_x_t2 != t1 x t2"))
                          (\ _ ->
                            check (w == wa) (showsl_lit "problem: w differs"))))
                    (\ xa ->
                      Inl (((((((showsl_lit
                                   "problem in checking overlap OC3 of\n" .
                                  showsl_oc oc1) .
                                 showsl_literal "\n") .
                                showsl_oc oc2) .
                               showsl_lit "\nto yield\n") .
                              showsl_oc oc_new) .
                             showsl_literal "\n") .
                            xa));
              });
          });
      });
    OC3p oc_new oc1 oc2 t1 t2 ->
      (case oc_new of {
        (t1wt2, ra) ->
          (case oc1 of {
            (t1xt2, raa) ->
              (case oc2 of {
                (w, x) ->
                  catch_errora
                    (bindb
                      (check (t1wt2 == t1 ++ w ++ t2)
                        (showsl_lit "problem: t1_w_t2 != t1 w t2"))
                      (\ _ ->
                        bindb (check (t1xt2 == t1 ++ x ++ t2)
                                (showsl_lit "problem: t1_x_t2 != t1 x t2"))
                          (\ _ ->
                            check (ra == raa)
                              (showsl_lit "problem: r differs"))))
                    (\ xa ->
                      Inl (((((((showsl_lit
                                   "problem in checking overlap OC3\' of\n" .
                                  showsl_oc oc1) .
                                 showsl_literal "\n") .
                                showsl_oc oc2) .
                               showsl_lit "\nto yield\n") .
                              showsl_oc oc_new) .
                             showsl_literal "\n") .
                            xa));
              });
          });
      });
    OCDP1 p oc1 ->
      (case oc1 of {
        (lc, cr) ->
          let {
            a = p;
          } in (case a of {
                 (aa, b) ->
                   (case aa of {
                     (e1, ab) ->
                       (case ab of {
                         (ac, ba) ->
                           (case ac of {
                             (f, (d, l)) ->
                               (\ c1 (c2, ad) ->
                                 (case ad of {
                                   (ae, bb) ->
                                     (case ae of {
                                       (fa, (da, ra)) ->
 (\ e2 ->
   catch_errora
     (bindb (check (null e1) (showsl_lit "problem: e1 not empty"))
       (\ _ ->
         bindb (check (null e2) (showsl_lit "problem: e2 not empty"))
           (\ _ ->
             bindb (check (c1 == c2) (showsl_lit "problem: c not equal"))
               (\ _ ->
                 bindb (check
                         (equal_nat f one_nat &&
                           equal_nat fa one_nat &&
                             equal_nat d zero_nat && equal_nat da zero_nat)
                         (showsl_lit "problem: 0 and 1 conditions not met"))
                   (\ _ ->
                     bindb (check (lc == l ++ c1)
                             (showsl_lit "problem: lc != l c"))
                       (\ _ ->
                         check (cr == c1 ++ ra)
                           (showsl_lit "problem: cr != c r")))))))
     (\ x ->
       Inl (((((showsl_lit "problem in checking overlap OCDP1 of\n" .
                 showsl_oc oc1) .
                showsl_lit "\nto yield\n") .
               showsl_pat p) .
              showsl_literal "\n") .
             x)));
                                     })
                                       bb;
                                 }));
                           })
                             ba;
                       });
                   })
                     b;
               });
      });
    OCDP2 p oc1 ->
      (case oc1 of {
        (cl, rc) ->
          let {
            a = p;
          } in (case a of {
                 (aa, b) ->
                   (case aa of {
                     (c1, ab) ->
                       (case ab of {
                         (ac, ba) ->
                           (case ac of {
                             (f, (d, l)) ->
                               (\ e1 (e2, ad) ->
                                 (case ad of {
                                   (ae, bb) ->
                                     (case ae of {
                                       (fa, (da, ra)) ->
 (\ c2 ->
   catch_errora
     (bindb
       (check (null e1 && null e2) (showsl_lit "problem: e1 or e2 not empty"))
       (\ _ ->
         bindb (check (c1 == c2) (showsl_lit "problem: c not equal"))
           (\ _ ->
             bindb (check
                     (equal_nat f one_nat &&
                       equal_nat fa one_nat &&
                         equal_nat d zero_nat && equal_nat da zero_nat)
                     (showsl_lit "problem: 0 and 1 conditions not met"))
               (\ _ ->
                 bindb (check (cl == c1 ++ l) (showsl_lit "problem: lc != l c"))
                   (\ _ ->
                     check (rc == ra ++ c1)
                       (showsl_lit "problem: cr != c r"))))))
     (\ x ->
       Inl (((((showsl_lit "problem in checking overlap OCDP1 of\n" .
                 showsl_oc oc1) .
                showsl_lit "\nto yield\n") .
               showsl_pat p) .
              showsl_literal "\n") .
             x)));
                                     })
                                       bb;
                                 }));
                           })
                             ba;
                       });
                   })
                     b;
               });
      });
    WPEQ p_new p ->
      (case p of {
        (left, right) ->
          (case p_new of {
            (lefta, righta) ->
              catch_errora
                (bindb
                  (check (word_pat_equiv left lefta)
                    (showsl_lit "problem: lhss are not equivalent"))
                  (\ _ ->
                    check (word_pat_equiv right righta)
                      (showsl_lit "problem: rhss are not equivalent")))
                (\ x ->
                  Inl (((((showsl_lit "problem in checking equivalence of\n" .
                            showsl_pat p) .
                           showsl_lit "\nand\n") .
                          showsl_pat p_new) .
                         showsl_literal "\n") .
                        x));
          });
      });
    Lift p_new p ->
      let {
        a = p;
      } in (case a of {
             (aa, b) ->
               (case aa of {
                 (l1, ab) ->
                   (case ab of {
                     (ac, ba) ->
                       (case ac of {
                         (f1, (c1, m1)) ->
                           (\ r1 (l2, ad) ->
                             (case ad of {
                               (ae, bb) ->
                                 (case ae of {
                                   (f2, (c2, m2)) ->
                                     (\ r2 ->
                                       let {
 af = p_new;
                                       } in
 (case af of {
   (ag, bc) ->
     (case ag of {
       (l1a, ah) ->
         (case ah of {
           (ai, bd) ->
             (case ai of {
               (f1a, (c1a, m1a)) ->
                 (\ r1a (l2a, aj) ->
                   (case aj of {
                     (ak, be) ->
                       (case ak of {
                         (f2a, (c2a, m2a)) ->
                           (\ r2a ->
                             catch_errora
                               (bindb
                                 (check (l1 == l1a && l2 == l2a)
                                   (showsl_lit
                                     "problem: l and l\' do not match"))
                                 (\ _ ->
                                   bindb (check (r1 == r1a && r2 == r2a)
   (showsl_lit "problem: r and r\' do not match"))
                                     (\ _ ->
                                       bindb
 (check (equal_nat f1 f1a && equal_nat f2 f2a)
   (showsl_lit "problem: f and f\' do not match"))
 (\ _ ->
   bindb (check (m1 == m1a && m2 == m2a)
           (showsl_lit "problem: m and m\' do not match"))
     (\ _ ->
       bindb (check (equal_nat c1a (plus_nat c1 f1))
               (showsl_lit
                 "problem: constant factor on the left not properly increased"))
         (\ _ ->
           check (equal_nat c2a (plus_nat c2 f2))
             (showsl_lit
               "problem: constant factor on the right not properly increased")))))))
                               (\ x ->
                                 Inl (((((showsl_lit
    "problem in checking lifting of\n" .
   showsl_pat p) .
  showsl_lit "\nto yield\n") .
 showsl_pat p_new) .
showsl_literal "\n") .
                                       x)));
                       })
                         be;
                   }));
             })
               bd;
         });
     })
       bc;
 }));
                                 })
                                   bb;
                             }));
                       })
                         ba;
                   });
               })
                 b;
           });
    DPOC1_1 p_new p1 oc1 l ra ->
      (case p1 of {
        (left, (lxr, (m2, r2))) ->
          (case oc1 of {
            (x, v) ->
              (case p_new of {
                (lefta, (lvr, (m2a, r2a))) ->
                  catch_errora
                    (bindb
                      (check (left == lefta)
                        (showsl_lit "problem: lhss are not equal"))
                      (\ _ ->
                        bindb (check (m2 == m2a)
                                (showsl_lit
                                  "problem: m2 and m2\' do not match"))
                          (\ _ ->
                            bindb (check (r2 == r2a)
                                    (showsl_lit
                                      "problem: r2 and r2\' do not match"))
                              (\ _ ->
                                bindb (check (lxr == l ++ x ++ ra)
(showsl_lit "problem: l_x_r != l @ x @ r"))
                                  (\ _ ->
                                    check (lvr == l ++ v ++ ra)
                                      (showsl_lit
"problem: l_v_r != l @ v @ r"))))))
                    (\ xa ->
                      Inl (((((((showsl_lit
                                   "problem in checking overlap DPOC1_1 of\n" .
                                  showsl_pat p1) .
                                 showsl_literal "\n") .
                                showsl_oc oc1) .
                               showsl_lit "\nto yield\n") .
                              showsl_pat p_new) .
                             showsl_literal "\n") .
                            xa));
              });
          });
      });
    DPOC1_2 p_new p1 oc1 l ra x ->
      let {
        a = p1;
      } in (case a of {
             (aa, b) ->
               (case aa of {
                 (l1, (m1, r1)) ->
                   (\ (xr, (m2, r2)) ->
                     (case oc1 of {
                       (lx, v) ->
                         let {
                           ab = p_new;
                         } in (case ab of {
                                (ac, ba) ->
                                  (case ac of {
                                    (ll1, (m1a, r1a)) ->
                                      (\ (vr, (m2a, r2a)) ->
catch_errora
  (bindb
    (check (m1 == m1a && m2 == m2a)
      (showsl_lit "problem: m components modified"))
    (\ _ ->
      bindb (check (r1 == r1a && r2 == r2a)
              (showsl_lit "problem: r components modified"))
        (\ _ ->
          bindb (check (ll1 == l ++ l1) (showsl_lit "problem: l_l1 != l @ ll1"))
            (\ _ ->
              bindb (check (xr == x ++ ra) (showsl_lit "problem: x_r != x @ r"))
                (\ _ ->
                  bindb (check (lx == l ++ x)
                          (showsl_lit "problem: l_x != l @ x"))
                    (\ _ ->
                      check (vr == v ++ ra)
                        (showsl_lit "problem: v_r != v @ r")))))))
  (\ xa ->
    Inl (((((((showsl_lit "problem in checking overlap DPOC1_2 of\n" .
                showsl_pat p1) .
               showsl_literal "\n") .
              showsl_oc oc1) .
             showsl_lit "\nto yield\n") .
            showsl_pat p_new) .
           showsl_literal "\n") .
          xa)));
                                  })
                                    ba;
                              });
                     }));
               })
                 b;
           });
    DPOC2 p_new p1 oc1 l ra ->
      let {
        a = p1;
      } in (case a of {
             (left, aa) ->
               (case aa of {
                 (l2, ab) ->
                   (case ab of {
                     (ac, b) ->
                       (case ac of {
                         (f2, (c2, lxr)) ->
                           (\ r2 ->
                             (case oc1 of {
                               (x, v) ->
                                 let {
                                   ad = p_new;
                                 } in (case ad of {
(lefta, ae) ->
  (case ae of {
    (l2a, af) ->
      (case af of {
        (ag, ba) ->
          (case ag of {
            (f2a, (c2a, lvr)) ->
              (\ r2a ->
                catch_errora
                  (bindb
                    (check (left == lefta)
                      (showsl_lit "problem: left components modified"))
                    (\ _ ->
                      bindb (check (equal_nat f2 f2a)
                              (showsl_lit "problem: f components modified"))
                        (\ _ ->
                          bindb (check (equal_nat c2 c2a)
                                  (showsl_lit "problem: c components modified"))
                            (\ _ ->
                              bindb (check (l2 == l2a)
                                      (showsl_lit
"problem: l components modified"))
                                (\ _ ->
                                  bindb (check (r2 == r2a)
  (showsl_lit "problem: r components modified"))
                                    (\ _ ->
                                      bindb
(check (lxr == l ++ x ++ ra) (showsl_lit "problem: l_x_r != l @ x @ r"))
(\ _ ->
  check (lvr == l ++ v ++ ra) (showsl_lit "problem: l_v_r != l @ v @ r"))))))))
                  (\ xa ->
                    Inl (((((((showsl_lit
                                 "problem in checking overlap DPOC2 of\n" .
                                showsl_pat p1) .
                               showsl_literal "\n") .
                              showsl_oc oc1) .
                             showsl_lit "\nto yield\n") .
                            showsl_pat p_new) .
                           showsl_literal "\n") .
                          xa)));
          })
            ba;
      });
  });
                                      });
                             }));
                       })
                         b;
                   });
               });
           });
    DPOC3_1 p_new p1 oc1 l ra ->
      (case p1 of {
        (left, (l2, (m2, lxr))) ->
          (case oc1 of {
            (x, v) ->
              (case p_new of {
                (lefta, (l2a, (m2a, lvr))) ->
                  catch_errora
                    (bindb
                      (check (left == lefta)
                        (showsl_lit "problem: left components modified"))
                      (\ _ ->
                        bindb (check (m2 == m2a)
                                (showsl_lit "problem: m components modified"))
                          (\ _ ->
                            bindb (check (l2 == l2a)
                                    (showsl_lit
                                      "problem: l components modified"))
                              (\ _ ->
                                bindb (check (lxr == l ++ x ++ ra)
(showsl_lit "problem: l_x_r != l @ x @ r"))
                                  (\ _ ->
                                    check (lvr == l ++ v ++ ra)
                                      (showsl_lit
"problem: l_v_r != l @ v @ r"))))))
                    (\ xa ->
                      Inl (((((((showsl_lit
                                   "problem in checking overlap DPOC3_1 of\n" .
                                  showsl_pat p1) .
                                 showsl_literal "\n") .
                                showsl_oc oc1) .
                               showsl_lit "\nto yield\n") .
                              showsl_pat p_new) .
                             showsl_literal "\n") .
                            xa));
              });
          });
      });
    DPOC3_2 p_new p1 oc1 l ra x ->
      let {
        a = p1;
      } in (case a of {
             (aa, b) ->
               (case aa of {
                 (l1, (m1, r1)) ->
                   (\ (l2, (m2, lx)) ->
                     (case oc1 of {
                       (xr, v) ->
                         let {
                           ab = p_new;
                         } in (case ab of {
                                (ac, ba) ->
                                  (case ac of {
                                    (l1a, (m1a, r1r)) ->
                                      (\ (l2a, (m2a, lv)) ->
catch_errora
  (bindb
    (check (m2 == m2a && m1 == m1a)
      (showsl_lit "problem: m components modified"))
    (\ _ ->
      bindb (check (l1 == l1a) (showsl_lit "problem: l components modified"))
        (\ _ ->
          bindb (check (l2 == l2a)
                  (showsl_lit "problem: l2 components modified"))
            (\ _ ->
              bindb (check (lx == l ++ x) (showsl_lit "problem: l_x != l @ x"))
                (\ _ ->
                  bindb (check (xr == x ++ ra)
                          (showsl_lit "problem: x_r != x @ r"))
                    (\ _ ->
                      bindb (check (r1r == r1 ++ ra)
                              (showsl_lit "problem: r1_r != r1 @ r"))
                        (\ _ ->
                          check (lv == l ++ v)
                            (showsl_lit "problem: l_v != l @ v"))))))))
  (\ xa ->
    Inl (((((((showsl_lit "problem in checking overlap DPOC3_2 of\n" .
                showsl_pat p1) .
               showsl_literal "\n") .
              showsl_oc oc1) .
             showsl_lit "\nto yield\n") .
            showsl_pat p_new) .
           showsl_literal "\n") .
          xa)));
                                  })
                                    ba;
                              });
                     }));
               })
                 b;
           });
    DPDP1_1 p_new p1 p2 l ra ->
      (case p1 of {
        (left, (ll2, (mm, r2r))) ->
          let {
            a = p2;
          } in (case a of {
                 (aa, b) ->
                   (case aa of {
                     (l2, (mma, r2)) ->
                       (\ (l2a, (mm2, r2a)) ->
                         (case p_new of {
                           (lefta, (ll2a, (mm2a, r2pr))) ->
                             catch_errora
                               (bindb
                                 (check (left == lefta)
                                   (showsl_lit
                                     "problem: left components modified"))
                                 (\ _ ->
                                   bindb (check (mm == mma)
   (showsl_lit "problem: mm components modified"))
                                     (\ _ ->
                                       bindb
 (check (mm2 == mm2a) (showsl_lit "problem: mm2 components modified"))
 (\ _ ->
   bindb (check (ll2 == l ++ l2) (showsl_lit "problem: l_l2 != l @ l2"))
     (\ _ ->
       bindb (check (r2r == r2 ++ ra) (showsl_lit "problem: r2_r != r2 @ r"))
         (\ _ ->
           bindb (check (r2pr == r2a ++ ra)
                   (showsl_lit "problem: r2pr != r2\' @ r"))
             (\ _ ->
               check (ll2a == l ++ l2a)
                 (showsl_lit "problem: l_l2 != l @ l2 "))))))))
                               (\ x ->
                                 Inl (((((((showsl_lit
      "problem in checking overlap DPDP1_1 of\n" .
     showsl_pat p1) .
    showsl_literal "\n") .
   showsl_pat p2) .
  showsl_lit "\nto yield\n") .
 showsl_pat p_new) .
showsl_literal "\n") .
                                       x));
                         }));
                   })
                     b;
               });
      });
    DPDP1_2 p_new p1 p2 l ra ->
      let {
        a = p1;
      } in (case a of {
             (aa, b) ->
               (case aa of {
                 (l1, (mm1, r1)) ->
                   (\ (ll2, (mm, r1a)) ->
                     let {
                       ab = p2;
                     } in (case ab of {
                            (ac, ba) ->
                              (case ac of {
                                (l2, (mm2, r1r)) ->
                                  (\ (l2a, (mm2a, r2)) ->
                                    let {
                                      ad = p_new;
                                    } in (case ad of {
   (ae, bb) ->
     (case ae of {
       (l3, (mm3, r1pr)) ->
         (\ (ll2a, (mm3a, r3)) ->
           catch_errora
             (bindb
               (check (l1 == l3)
                 (showsl_lit "problem: l1\' components modified"))
               (\ _ ->
                 bindb (check (mm1 == mm3)
                         (showsl_lit "problem: mm1\' components modified"))
                   (\ _ ->
                     bindb (check (mm == mm2)
                             (showsl_lit "problem: mm components modified"))
                       (\ _ ->
                         bindb (check (mm2a == mm3a)
                                 (showsl_lit
                                   "problem: mm2\' components modified"))
                           (\ _ ->
                             bindb (check (r2 == r3)
                                     (showsl_lit
                                       "problem: r2\' components modified"))
                               (\ _ ->
                                 bindb (check (ll2 == l ++ l2)
 (showsl_lit "problem: l_l2 != l @ l2"))
                                   (\ _ ->
                                     bindb (check (r1pr == r1 ++ ra)
     (showsl_lit "problem: r1\'r != r1\' @ r"))
                                       (\ _ ->
 bindb (check (r1r == r1a ++ ra) (showsl_lit "problem: r1r != r1 @ r"))
   (\ _ ->
     check (ll2a == l ++ l2a) (showsl_lit "problem: l_l2 != l @ l2 "))))))))))
             (\ x ->
               Inl (((((((showsl_lit
                            "problem in checking overlap DPDP1_2 of\n" .
                           showsl_pat p1) .
                          showsl_literal "\n") .
                         showsl_pat p2) .
                        showsl_lit "\nto yield\n") .
                       showsl_pat p_new) .
                      showsl_literal "\n") .
                     x)));
     })
       bb;
 }));
                              })
                                ba;
                          }));
               })
                 b;
           });
    DPDP2_1 p_new p1 p2 l ra ->
      let {
        a = p1;
      } in (case a of {
             (aa, b) ->
               (case aa of {
                 (l1, (mm1, r1)) ->
                   (\ (l1a, (mm, r2r)) ->
                     let {
                       ab = p2;
                     } in (case ab of {
                            (ac, ba) ->
                              (case ac of {
                                (ll1, (mm2, r2)) ->
                                  (\ (l2, (mm2a, r2a)) ->
                                    let {
                                      ad = p_new;
                                    } in (case ad of {
   (ae, bb) ->
     (case ae of {
       (ll1a, (mm3, r3)) ->
         (\ (l3, (mm3a, r2pr)) ->
           catch_errora
             (bindb
               (check (r2r == r2 ++ ra) (showsl_lit "problem: r2r != r2 @ r"))
               (\ _ ->
                 bindb (check (ll1 == l ++ l1a)
                         (showsl_lit "problem: l_l1 != l @ l1"))
                   (\ _ ->
                     bindb (check (ll1a == l ++ l1)
                             (showsl_lit "problem: l_l1\' != l @ l1\' "))
                       (\ _ ->
                         bindb (check (mm1 == mm3)
                                 (showsl_lit
                                   "problem: mm1\' component modified"))
                           (\ _ ->
                             bindb (check (r1 == r3)
                                     (showsl_lit
                                       "problem: r1\' component modified"))
                               (\ _ ->
                                 bindb (check (l2 == l3)
 (showsl_lit "problem: l2\' component modified"))
                                   (\ _ ->
                                     bindb (check (mm2a == mm3a)
     (showsl_lit "problem: mm2\' components modified"))
                                       (\ _ ->
 bindb (check (mm == mm2) (showsl_lit "problem: mm components modified"))
   (\ _ ->
     check (r2pr == r2a ++ ra)
       (showsl_lit "problem: r2\'r != r2\' @ r"))))))))))
             (\ x ->
               Inl (((((((showsl_lit
                            "problem in checking overlap DPDP2_1 of\n" .
                           showsl_pat p1) .
                          showsl_literal "\n") .
                         showsl_pat p2) .
                        showsl_lit "\nto yield\n") .
                       showsl_pat p_new) .
                      showsl_literal "\n") .
                     x)));
     })
       bb;
 }));
                              })
                                ba;
                          }));
               })
                 b;
           });
    DPDP2_2 p_new p1 p2 l ra ->
      let {
        a = p1;
      } in (case a of {
             (aa, b) ->
               (case aa of {
                 (l1, (mm1, r1)) ->
                   (\ (l1a, (mm1a, r1a)) ->
                     let {
                       ab = p2;
                     } in (case ab of {
                            (ac, ba) ->
                              (case ac of {
                                (ll1, (mm2, r1r)) ->
                                  (\ right ->
                                    let {
                                      ad = p_new;
                                    } in (case ad of {
   (ae, bb) ->
     (case ae of {
       (ll1a, (mm3, r1pr)) ->
         (\ righta ->
           catch_errora
             (bindb
               (check (r1r == r1a ++ ra) (showsl_lit "problem: r1r != r1 @ r"))
               (\ _ ->
                 bindb (check (ll1 == l ++ l1a)
                         (showsl_lit "problem: l_l1 != l @ l1"))
                   (\ _ ->
                     bindb (check (ll1a == l ++ l1)
                             (showsl_lit "problem: l_l1\' != l @ l1\' "))
                       (\ _ ->
                         bindb (check (r1pr == r1 ++ ra)
                                 (showsl_lit "problem: r1\'_r != r1\' @ r "))
                           (\ _ ->
                             bindb (check (mm1 == mm3)
                                     (showsl_lit
                                       "problem: mm1\' component modified"))
                               (\ _ ->
                                 bindb (check (mm1a == mm2)
 (showsl_lit "problem: mm components modified"))
                                   (\ _ ->
                                     check (right == righta)
                                       (showsl_lit
 "problem: right components modified"))))))))
             (\ x ->
               Inl (((((((showsl_lit "problem in checking overlap DPDP2_ of\n" .
                           showsl_pat p1) .
                          showsl_literal "\n") .
                         showsl_pat p2) .
                        showsl_lit "\nto yield\n") .
                       showsl_pat p_new) .
                      showsl_literal "\n") .
                     x)));
     })
       bb;
 }));
                              })
                                ba;
                          }));
               })
                 b;
           });
  });

prems_ofa ::
  forall a.
    Dp_proof_step a ->
      [(([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))];
prems_ofa step =
  (case step of {
    OC1 _ _ -> [];
    OC2 _ p pa _ _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OC2p _ p pa _ _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OC3 _ p pa _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OC3p _ p pa _ _ ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p))),
        (([], ((zero_nat, (zero_nat, [])), fst pa)),
          ([], ((zero_nat, (zero_nat, [])), snd pa)))];
    OCDP1 _ p ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p)))];
    OCDP2 _ p ->
      [(([], ((zero_nat, (zero_nat, [])), fst p)),
         ([], ((zero_nat, (zero_nat, [])), snd p)))];
    WPEQ _ p -> [p];
    Lift _ p -> [p];
    DPOC1_1 _ p rl _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC1_2 _ p rl _ _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC2 _ p rl _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC3_1 _ p rl _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPOC3_2 _ p rl _ _ _ ->
      [p, (([], ((zero_nat, (zero_nat, [])), fst rl)),
            ([], ((zero_nat, (zero_nat, [])), snd rl)))];
    DPDP1_1 _ p1 p2 _ _ -> [p1, p2];
    DPDP1_2 _ p1 p2 _ _ -> [p1, p2];
    DPDP2_1 _ p1 p2 _ _ -> [p1, p2];
    DPDP2_2 _ p1 p2 _ _ -> [p1, p2];
  });

check_proof ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showl a) => Set ([a], [a]) ->
                    Set (([a], ((Nat, (Nat, [a])), [a])),
                          ([a], ((Nat, (Nat, [a])), [a]))) ->
                      [Dp_proof_step a] -> Sum (String -> String) ();
check_proof r delta (p : ps) =
  bindb (check_stepb r p)
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ pa ->
                  check (member pa delta)
                    (showsl_lit "problem: nothing known about premise " .
                      showsl_pat pa))
                (prems_ofa p))
              (\ x -> Inl (snd x)))
        (\ _ ->
          check_proof r
            (sup_set delta
              (inserta (pat_of p)
                (set_empty
                  (of_phantom
                    (set_impl_prod ::
                      Phantom
                        (([a], ((Nat, (Nat, [a])), [a])),
                          ([a], ((Nat, (Nat, [a])), [a])))
                        Set_impla)))))
            ps));
check_proof r delta [] = Inr ();

check_non_loop_srs_proof ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showl a) => Set ([a], [a]) ->
                    Non_loop_srs_proof a -> Sum (String -> String) ();
check_non_loop_srs_proof ra (SE_OC (m, lmr) l r steps) =
  bindb (check
          (membera (map pat_of steps)
            (([], ((zero_nat, (zero_nat, [])), m)),
              ([], ((zero_nat, (zero_nat, [])), lmr))))
          (showsl_lit "overlap closure not derived within proof"))
    (\ _ ->
      bindb (check (lmr == l ++ m ++ r) (showsl_lit "no selfoverlap"))
        (\ _ ->
          check_proof ra
            (set_empty
              (of_phantom
                (set_impl_prod ::
                  Phantom
                    (([a], ((Nat, (Nat, [a])), [a])),
                      ([a], ((Nat, (Nat, [a])), [a])))
                    Set_impla)))
            steps));
check_non_loop_srs_proof ra (SE_DP (left, right) l r steps) =
  bindb (check (membera (map pat_of steps) (left, right))
          (showsl_lit "overlap closure not derived within proof"))
    (\ _ ->
      let {
        a = left;
      } in (case a of {
             (l1, aa) ->
               (case aa of {
                 (ab, b) ->
                   (case ab of {
                     (f1, (c1, m1)) ->
                       (\ r1 ->
                         let {
                           ac = right;
                         } in (case ac of {
                                (l2, ad) ->
                                  (case ad of {
                                    (ae, ba) ->
                                      (case ae of {
(f2, (c2, m2)) ->
  (\ r2 ->
    bindb (check (m1 == m2 && l2 == l ++ l1 && r2 == r1 ++ r)
            (showsl_lit "problem with selfoverlap"))
      (\ _ ->
        bindb (check
                (less_eq_nat f1 f2 &&
                  equal_nat
                    (modulo_nat (max (minus_nat c2 c1) (minus_nat c1 c2)) f1)
                    zero_nat &&
                    (if less_nat f1 f2
                      then equal_nat (modulo_nat f2 f1) zero_nat else True) &&
                      (if equal_nat f1 f2 then less_eq_nat c1 c2 else True))
                (showsl_lit
                  "could not ensure fitting condition for selfoverlap"))
          (\ _ ->
            check_proof ra
              (set_empty
                (of_phantom
                  (set_impl_prod ::
                    Phantom
                      (([a], ((Nat, (Nat, [a])), [a])),
                        ([a], ((Nat, (Nat, [a])), [a])))
                      Set_impla)))
              steps)));
                                      })
ba;
                                  });
                              }));
                   })
                     b;
               });
           }));

term_to_string :: forall a b. Term a b -> [a];
term_to_string (Fun f [t]) = f : term_to_string t;
term_to_string (Var v) = [];
term_to_string (Fun v []) = [];
term_to_string (Fun v (vb : vd : ve)) = [];

srs_of_trs_impl :: forall a b. [(Term a b, Term a b)] -> [([a], [a])];
srs_of_trs_impl r =
  concatMap
    (\ (l, ra) ->
      (if unary_term l
        then (if unary_term ra then [(term_to_string l, term_to_string ra)]
               else [])
        else []))
    r;

check_non_loop_srs_prf ::
  forall a b c d.
    (Ceq b, Ccompare b, Eq b,
      Showl b) => Tp_ops_ext a b c d ->
                    a -> Non_loop_srs_proof b -> Sum (String -> String) ();
check_non_loop_srs_prf i tp prf =
  let {
    r = rulese i tp;
    s = set (srs_of_trs_impl r);
  } in bindb (check (null (qb i tp))
               (showsl_lit "strategy for non-loops unsupported"))
         (\ _ -> check_non_loop_srs_proof s prf);

check_not_wwf_qtrs ::
  forall a b c.
    (Compare_order b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a b c () -> a -> Sum (String -> String) ();
check_not_wwf_qtrs i tp =
  bindb (check (null (qb i tp) || not (nfsb i tp))
          (showsl_lit "strategies and normal form substitutions problem"))
    (\ _ ->
      check (not (isOK (check_wwf_qtrs (is_QNFb i tp) (rulese i tp))))
        (showsl_lit "The Q-TRS is well formed" . showsl_literal "\n"));

check_tp_subsumesa ::
  forall a b c.
    (Compare_order b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    (Bool,
                      ([Term (Lab b c) [Char]],
                        [(Term (Lab b c) [Char], Term (Lab b c) [Char])])) ->
                      a -> Sum (String -> String) ();
check_tp_subsumesa i t tp =
  (case t of {
    (nfsa, (q, rs)) ->
      let {
        nfs = nfsb i tp;
        rsa = rulese i tp;
        qa = qb i tp;
      } in catch_errora
             (bindb
               (check
                 (if not (null q) then (if nfs then nfsa else True) else True)
                 (showsl_lit "incompatible substitutions-in-normal-form flags"))
               (\ _ ->
                 bindb (catch_errora (check_subseteq rs rsa)
                         (\ x -> Inl (toomuch "rule" (showsl_rule x))))
                   (\ _ ->
                     catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                       (\ x ->
                         Inl (showsl_lit "NF(Q) differs due to term " .
                               showsl_terma x)))))
             (\ x ->
               Inl (showsl_lit
                      "problem in showing subsumption for non-termination\n" .
                     x));
  });

check_non_loop_trs_prf ::
  forall a b c d.
    (Compare b, Eq b, Showl b, Cenum c, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showl c) => Tp_ops_ext a b c d ->
                    a -> Non_loop_prf b c -> Sum (String -> String) ();
check_non_loop_trs_prf i tp prf =
  let {
    r = rulese i tp;
  } in bindb (check (null (qb i tp))
               (showsl_lit "strategy for non-loops unsupported"))
         (\ _ -> check_non_loop_prf r [] prf);

uncurry_nonterm_tt_check ::
  forall a b.
    (Eq b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Char], Term b [Char])],
                            [(Term b [Char], Term b [Char])]))) ->
                      ([((b, Nat), [b])] -> b -> Nat -> b) ->
                        (b -> Nat ->
                                [((b, Nat), [b])] ->
                                  Sum (String -> String) ()) ->
                          [(Term b [Char], Term b [Char])] ->
                            a -> Sum (String -> String) a;
uncurry_nonterm_tt_check i info fmap check_inj r dpp =
  (case info of {
    (a, (sml, (u, e))) ->
      let {
        ra = rulese i dpp;
        nfs = nfsb i dpp;
        sm = sig_list_to_sig_map a sml fmap;
        r_eta = e ++ ra;
        uR = uncurry_rules a sm r_eta;
      } in (case bindb (check (null (qb i dpp))
                         (showsl_lit "strategy not supported for uncurrying"))
                   (\ _ ->
                     let {
                       s = uncurry_of_sig_list a sml sm;
                     } in bindb (only_eta_rules e r_eta)
                            (\ _ ->
                              bindb (check_inj a (nat_of_integer (2 :: Integer))
                                      sml)
                                (\ _ ->
                                  bindb (catch_errora (check_CS_subseteq u s)
  (\ x ->
    Inl ((showsl_lit "rule " . showsl_rule x) .
          showsl_lit " is not an uncurry rule")))
                                    (\ _ ->
                                      catch_errora (check_subseteq r (u ++ uR))
(\ x ->
  Inl ((showsl_lit "rule " . showsl_rule x) .
        showsl_lit " is neither uncurried rules nor uncurry rule"))))))
             of {
             Inl aa -> Inl aa;
             Inr _ -> Inr (mkc i nfs [] r []);
           });
  });

uncurry_nonterm_tt ::
  forall a b c.
    (Eq b, Showl b, Eq c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    Uncurry_nt_proof b c [Char] ->
                      a -> Sum (String -> String) a;
uncurry_nonterm_tt i (Uncurry_nt_proof (a, (sml, (u, e))) r) tp =
  uncurry_nonterm_tt_check i (a, (sml, (u, e)))
    (fmap a (nat_of_integer (2 :: Integer))) check_inj r tp;

check_trs_loop ::
  forall a b c.
    (Compare b, Eq b, Showl b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showl c) => Tp_ops_ext a b c () ->
                    a -> Trs_loop_prf b c -> Sum (String -> String) ();
check_trs_loop i tp (TRS_loop_prf s rseq sigma c) =
  check_loop (qb i tp) (nfsb i tp) s rseq sigma c (rulese i tp);

rule_removal_nonterm_reltrs ::
  forall a b c.
    (Compare_order b, Showl b, Compare_order c,
      Showl c) => Tp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_reltrs_prf b c ->
                           Sum (String -> String) a;
rule_removal_nonterm_reltrs i tp (Rule_removal_nonterm_reltrs_prf r s) =
  let {
    rrm = (if is_none r then [] else ceta_list_diff (rc i tp) (the r));
    srm = (if is_none s then [] else ceta_list_diff (rwc i tp) (the s));
  } in Inr (delete_R_Rwb i tp rrm srm);

check_rel_tp_subsumes ::
  forall a b c.
    (Compare_order b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    (Bool,
                      ([Term (Lab b c) [Char]],
                        ([(Term (Lab b c) [Char], Term (Lab b c) [Char])],
                          [(Term (Lab b c) [Char], Term (Lab b c) [Char])]))) ->
                      a -> Sum (String -> String) ();
check_rel_tp_subsumes i t tp =
  (case t of {
    (nfsa, (q, (r, rw))) ->
      let {
        nfs = nfsb i tp;
        rules = rulese i tp;
        ra = rc i tp;
        qa = qb i tp;
      } in catch_errora
             (bindb
               (check
                 (if not (null q) then (if nfs then nfsa else True) else True)
                 (showsl_lit "incompatible substitutions-in-normal-form flags"))
               (\ _ ->
                 bindb (catch_errora (check_subseteq rw rules)
                         (\ x -> Inl (toomuch "rule" (showsl_rule x))))
                   (\ _ ->
                     bindb (catch_errora (check_subseteq r ra)
                             (\ x -> Inl (toomuch "rule" (showsl_rule x))))
                       (\ _ ->
                         catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                           (\ x ->
                             Inl (showsl_lit "NF(Q) differs due to term " .
                                   showsl_terma x))))))
             (\ x ->
               Inl (showsl_lit
                      "problem in showing subsumption for non-termination\n" .
                     x));
  });

check_wf_reltrs ::
  forall a b c d.
    (Showl a, Eq b, Showl b, Showl c, Eq d,
      Showl d) => ([(Term a b, Term a b)], [(Term c d, Term c d)]) ->
                    Sum (String -> String) ();
check_wf_reltrs (r, s) =
  bindb (check_wf_trs r)
    (\ _ -> (if null r then Inr () else check_varcond_subset s));

check_not_wf_reltrs ::
  forall a b c.
    (Compare_order b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a b c () -> a -> Sum (String -> String) ();
check_not_wf_reltrs i tp =
  bindb (check (q_emptyb i tp)
          (showsl_lit "currently only empty Q is supported"))
    (\ _ ->
      check (not (isOK (check_wf_reltrs (rc i tp, rwc i tp))))
        (showsl_lit "The TRSs R and S are well formed" . showsl_literal "\n"));

reltrs_as_trs ::
  forall a b c. Tp_ops_ext a b c () -> a -> Sum (String -> String) a;
reltrs_as_trs i tp = let {
                       q = qb i tp;
                       r = rc i tp;
                       nfs = nfsb i tp;
                       a = mkc i nfs q r [];
                     } in Inr a;

check_rel_loop ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => Term a b ->
                    [([Nat], ((Term a b, Term a b), (Bool, Term a b)))] ->
                      [(b, Term a b)] ->
                        Ctxt a b ->
                          [(Term a b, Term a b)] ->
                            [(Term a b, Term a b)] -> Sum (String -> String) ();
check_rel_loop sa rseq sigma c r s =
  check_rel_seq r s rseq sa
    (ctxt_apply_term c (subst_apply_term sa (mk_subst Var sigma))) False;

check_rel_trs_loop ::
  forall a b c.
    (Eq b, Showl b, Ccompare c, Eq c, Mapping_impl c,
      Showl c) => Tp_ops_ext a b c () ->
                    a -> Rel_trs_loop_prf b c -> Sum (String -> String) ();
check_rel_trs_loop i tp (Rel_trs_loop_prf s rseq sigma c) =
  bindb (check (q_emptyb i tp) (showsl_lit "Q is not empty"))
    (\ _ -> check_rel_loop s rseq sigma c (rc i tp) (rwc i tp));

check_reltrs_nontermination_proof ::
  forall a b c d.
    (Compare_order b, Default b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    Dpp_ops_ext d (Lab b c) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          a -> Reltrs_nontermination_proof b c [Char] ->
                                 Sum (String -> String) ();
check_reltrs_nontermination_proof ia j assms i tp (Rel_Loop p) =
  debug i "Loop"
    (catch_errora (check_rel_trs_loop ia tp p)
      (\ x -> Inl ((i . showsl_lit ": error in loop proof\n") . x)));
check_reltrs_nontermination_proof ia j assms i tp (Rel_R_Not_SN prf) =
  bindb (reltrs_as_trs ia tp)
    (\ tpa ->
      catch_errora
        (check_trs_nontermination_proof ia j assms (add_index i one_nat) tpa
          prf)
        (\ x ->
          Inl ((i . showsl_lit
                      ": error below the nontermination proof for R\n") .
                x)));
check_reltrs_nontermination_proof ia j assms i tp Rel_Not_Well_Formed =
  debug i "Not Well-Formed"
    (catch_errora (check_not_wf_reltrs ia tp)
      (\ x -> Inl ((i . showsl_lit ": error in not-well-formed proof\n") . x)));
check_reltrs_nontermination_proof ia j assms i tp (Rel_TRS_String_Reversal prf)
  = debug i "String Reversal"
      (bindb
        (catch_errora (string_reversal_complete_rel_tt ia tp)
          (\ x ->
            Inl ((((i . showsl_lit
                          ": error when applying string reversal on\n") .
                    showsl_tp ia tp) .
                   showsl_literal "\n") .
                  x)))
        (\ tpa ->
          catch_errora
            (check_reltrs_nontermination_proof ia j assms (add_index i one_nat)
              tpa prf)
            (\ x ->
              Inl ((i . showsl_lit
                          ": error below the string reversal technique\n") .
                    x))));
check_reltrs_nontermination_proof ia j assms i tp (Rel_Rule_Removal p prf) =
  debug i "Rule Removal"
    (bindb (rule_removal_nonterm_reltrs ia tp p)
      (\ tpa ->
        catch_errora
          (check_reltrs_nontermination_proof ia j assms (add_index i one_nat)
            tpa prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the rule removal\n") . x))));
check_reltrs_nontermination_proof ia j assms i tp (Rel_TRS_Assume_Not_SN t ass)
  = debug i "Finiteness Assumption or Unknown Proof"
      (if assms
        then bindb (catch_errora (check_rel_tp_subsumes ia t tp)
                     (\ x ->
                       Inl (((i . showsl_lit
                                    ": error in non-termination assumption or unknown proof\n") .
                              x) .
                             showsl_literal "\n")))
               (\ _ ->
                 catch_errora
                   (catch_errora
                     (forallM_index
                       (\ asa ja ->
                         check_assmb ia j
                           (check_trs_nontermination_proof ia j assms
                             (add_index i (suc ja)))
                           (check_dp_nontermination_proof ia j assms
                             (add_index i (suc ja)))
                           (check_reltrs_nontermination_proof ia j assms
                             (add_index i (suc ja)))
                           (check_fp_nontermination_proof ia j assms
                             (add_index i (suc ja)))
                           (check_unknown_disproof ia j assms
                             (add_index i (suc ja)))
                           asa)
                       ass)
                     (\ x -> Inl (snd x)))
                   (\ x ->
                     Inl ((i . showsl_lit ": error below unknown proof\n") .
                           x)))
        else Inl (i . showsl_lit
                        ": the proof contains an assumption or unknown proof\n"));

check_trs_nontermination_proof ::
  forall a b c d.
    (Compare_order b, Default b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    Dpp_ops_ext d (Lab b c) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          a -> Trs_nontermination_proof b c [Char] ->
                                 Sum (String -> String) ();
check_trs_nontermination_proof ia j assms i tp (TRS_Loop p) =
  debug i "Loop"
    (catch_errora (check_trs_loop ia tp p)
      (\ x ->
        Inl ((((i . showsl_lit ": error when checking loop of\n") .
                showsl_tp ia tp) .
               showsl_literal "\n") .
              x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Nonloop p) =
  debug i "Nonloop"
    (catch_errora (check_non_loop_trs_prf ia tp p)
      (\ x ->
        Inl ((showsl_lit
                "problem in checking possibly non-looping infinite reduction for\n" .
               showsl_tp ia tp) .
              x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Nonloop_SRS p) =
  debug i "Nonloop SRS"
    (catch_errora (check_non_loop_srs_prf ia tp p)
      (\ x ->
        Inl ((showsl_lit
                "problem in checking possibly non-looping infinite reduction for\n" .
               showsl_tp ia tp) .
              x)));
check_trs_nontermination_proof ia j assms i tp TRS_Not_Well_Formed =
  debug i "Not Well-Formed"
    (catch_errora (check_not_wwf_qtrs ia tp)
      (\ x -> Inl ((i . showsl_lit ": error in not well-formed proof\n") . x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Termination_Switch p prf) =
  debug i "Switch to Termination"
    (bindb
      (catch_errora (switch_termination_tt ia p tp)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error in switching to full strategy for the DP-problem\n") .
                  showsl_tp ia tp) .
                 showsl_literal "\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the termination switch technique\n") .
                  x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Rule_Removal p prf) =
  debug i "Rule Removal"
    (bindb (rule_removal_nonterm_trs ia tp p)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the rule removal\n") . x))));
check_trs_nontermination_proof ia j assms i tp (TRS_String_Reversal prf) =
  debug i "String Reversal"
    (bindb
      (catch_errora (string_reversal_complete_tt ia tp)
        (\ x ->
          Inl ((((i . showsl_lit ": error when applying string reversal on\n") .
                  showsl_tp ia tp) .
                 showsl_literal "\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the string reversal technique\n") .
                  x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Constant_String p prf) =
  debug i "Constants into Unary"
    (bindb
      (catch_errora (const_to_string_complete_tt ia tp p)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error when turning constants into strings on\n") .
                  showsl_tp ia tp) .
                 showsl_literal "\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the constants into string technique\n") .
                  x))));
check_trs_nontermination_proof ia j assms i tp (TRS_DP_Trans p prf) =
  debug i "DP Transformation"
    (bindb
      (catch_errora (dp_trans_nontermination_tt ia j tp p)
        (\ x ->
          Inl ((((i . showsl_lit ": error in DP transformation on\n") .
                  showsl_tp ia tp) .
                 showsl_literal "\n") .
                x)))
      (\ dpp ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (add_index i one_nat) dpp
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the DP transformation\n") .
                  x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Q_Increase p prf) =
  debug i "Q increase"
    (bindb (q_increase_nonterm_trs ia tp p)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the Q increase technique\n") .
                  x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Uncurry p prf) =
  debug i "Uncurrying"
    (bindb (uncurry_nonterm_tt ia p tp)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (add_index i one_nat) tpa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the uncurrying technique\n") .
                  x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Not_WN_Tree_Automaton prf) =
  catch_errora (check_not_wn_ta_prf ia tp prf)
    (\ x ->
      Inl ((showsl_lit
              "error in tree automaton based non-termination proof for\n" .
             showsl_tp ia tp) .
            x));
check_trs_nontermination_proof ia j assms i tp (TRS_Assume_Not_SN t ass) =
  debug i "Finiteness Assumption or Unknown Proof"
    (if assms
      then bindb (catch_errora (check_tp_subsumesa ia t tp)
                   (\ x ->
                     Inl (((i . showsl_lit
                                  ": error in non-termination assumption or unknown proof\n") .
                            x) .
                           showsl_literal "\n")))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_dp_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_reltrs_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_fp_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_unknown_disproof ia j assms
                           (add_index i (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl ((i . showsl_lit ": error below unknown proof\n") . x)))
      else Inl (i . showsl_lit
                      ": the proof contains an assumption or unknown proof\n"));
check_trs_nontermination_proof ia j assms i tp (FPTRS_Assume_Not_SN t ass) =
  Inl (i . showsl_lit ": encountered unexpected FPTRS_Assume_Not_SN\n");

check_fp_nontermination_proof ::
  forall a b c d.
    (Compare_order b, Default b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    Dpp_ops_ext d (Lab b c) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          ([(Ctxt (Lab b c) [Char],
                              (Term (Lab b c) [Char], Location))],
                            [(Term (Lab b c) [Char], Term (Lab b c) [Char])]) ->
                            Trs_nontermination_proof b c [Char] ->
                              Sum (String -> String) ();
check_fp_nontermination_proof ia j assms i (pa, r) (TRS_Loop p) =
  (case p of {
    TRS_loop_prf a b c d ->
      debug i "Loop"
        (catch_errora (check_fploop r pa (FP_loop_prf d c a b))
          (\ x ->
            Inl ((i . showsl_lit
                        ": error when checking forbidden pattern loop\n") .
                  x)));
  });
check_fp_nontermination_proof ia j assms i (pa, r) (TRS_Rule_Removal p prf) =
  debug i "Rule Removal"
    (bindb (rule_removal_nonterm_trs ia (mkc ia False [] r []) p)
      (\ tp ->
        catch_errora
          (check_fp_nontermination_proof ia j assms (add_index i one_nat)
            (pa, rulese ia tp) prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the rule removal\n") . x))));
check_fp_nontermination_proof ia j assms i tp (FPTRS_Assume_Not_SN t ass) =
  debug i "Finiteness Assumption or Unknown Proof"
    (if assms
      then bindb (catch_errora (check_fp_tp_subsumes t tp)
                   (\ x ->
                     Inl (((i . showsl_lit
                                  ": error in non-termination assumption or unknown proof\n") .
                            x) .
                           showsl_literal "\n")))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_dp_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_reltrs_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_fp_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_unknown_disproof ia j assms
                           (add_index i (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl ((i . showsl_lit ": error below unknown proof\n") . x)))
      else Inl (i . showsl_lit
                      ": the proof contains an assumption or unknown proof\n"));
check_fp_nontermination_proof ia j assms i tp TRS_Not_Well_Formed =
  Inl (i . showsl_lit ": encountered unexpected proof\n");
check_fp_nontermination_proof ia j assms i tp (TRS_String_Reversal v) =
  Inl (i . showsl_lit ": encountered unexpected proof\n");
check_fp_nontermination_proof ia j assms i tp (TRS_Constant_String v va) =
  Inl (i . showsl_lit ": encountered unexpected proof\n");
check_fp_nontermination_proof ia j assms i tp (TRS_DP_Trans v va) =
  Inl (i . showsl_lit ": encountered unexpected proof\n");
check_fp_nontermination_proof ia j assms i tp (TRS_Termination_Switch v va) =
  Inl (i . showsl_lit ": encountered unexpected proof\n");
check_fp_nontermination_proof ia j assms i tp (TRS_Nonloop v) =
  Inl (i . showsl_lit ": encountered unexpected proof\n");
check_fp_nontermination_proof ia j assms i tp (TRS_Nonloop_SRS v) =
  Inl (i . showsl_lit ": encountered unexpected proof\n");
check_fp_nontermination_proof ia j assms i tp (TRS_Q_Increase v va) =
  Inl (i . showsl_lit ": encountered unexpected proof\n");
check_fp_nontermination_proof ia j assms i tp (TRS_Uncurry v va) =
  Inl (i . showsl_lit ": encountered unexpected proof\n");
check_fp_nontermination_proof ia j assms i tp (TRS_Not_WN_Tree_Automaton v) =
  Inl (i . showsl_lit ": encountered unexpected proof\n");
check_fp_nontermination_proof ia j assms i tp (TRS_Assume_Not_SN v va) =
  Inl (i . showsl_lit ": encountered unexpected proof\n");

check_dp_nontermination_proof ::
  forall a b c d.
    (Compare_order b, Default b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    Dpp_ops_ext d (Lab b c) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          d -> Dp_nontermination_proof b c [Char] ->
                                 Sum (String -> String) ();
check_dp_nontermination_proof ia j assms i dpp (DP_Loop p) =
  debug i "Loop"
    (catch_errora (check_dp_loop j dpp p)
      (\ x ->
        Inl ((((i . showsl_lit
                      ": error in checking loop for the following DP-problem\n") .
                showsl_dpp j dpp) .
               showsl_literal "\n") .
              x)));
check_dp_nontermination_proof ia j assms i dpp (DP_Nonloop p) =
  debug i "Nonloop"
    (catch_errora (check_non_loop_dp_prf j dpp p)
      (\ x ->
        Inl ((((i . showsl_lit
                      ": error in checking nonloop for the following DP-problem\n") .
                showsl_dpp j dpp) .
               showsl_literal "\n") .
              x)));
check_dp_nontermination_proof ia j assms i dpp (DP_Rule_Removal p prf) =
  debug i "Rule Removal"
    (bindb (rule_removal_nonterm_dp j dpp p)
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the pair and rule removal\n") .
                  x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Q_Reduction p prf) =
  debug i "Q reduction"
    (bindb
      (catch_errora (dp_q_reduction_nonterm j dpp p)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error in reducing the innermost lhss in the following DP-problem\n") .
                  showsl_dpp j dpp) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the Q reduction\n") . x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Q_Increase p prf) =
  debug i "Q increase"
    (bindb (q_increase_nonterm_dp j dpp p)
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the Q increase\n") . x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Termination_Switch p prf) =
  debug i "Switch to Termination"
    (bindb
      (catch_errora (switch_termination_proc j p dpp)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error in switching to full strategy for the DP-problem\n") .
                  showsl_dpp j dpp) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the termination switch processor\n") .
                  x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Instantiation p prf) =
  debug i "Instantiation"
    (bindb
      (catch_errora (instantiation_complete_proc j dpp p)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error when applying the instantiation processor on\n") .
                  showsl_dpp j dpp) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the instantiation processor\n") .
                  x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Rewriting p prf) =
  debug i "Rewriting"
    (bindb
      (catch_errora (rewriting_complete_proc j p dpp)
        (\ x ->
          Inl ((i . showsl_lit
                      ": error when applying the rewriting processor\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the rewriting processor\n") .
                  x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Narrowing p prf) =
  debug i "Narrowing"
    (bindb
      (catch_errora (narrowing_complete_proc j p dpp)
        (\ x ->
          Inl ((i . showsl_lit
                      ": error when applying the narrowing processor\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (add_index i one_nat) dppa
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the rewriting processor") .
                  x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Assume_Infinite dp ass) =
  debug i "Finiteness Assumption or Unknown Proof"
    (if assms
      then bindb (catch_errora (check_dpp_subsumesa j dp dpp)
                   (\ x ->
                     Inl (((i . showsl_lit
                                  ": error in finiteness assumption or unknown proof\n") .
                            x) .
                           showsl_literal "\n")))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_dp_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_reltrs_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_fp_nontermination_proof ia j assms
                           (add_index i (suc ja)))
                         (check_unknown_disproof ia j assms
                           (add_index i (suc ja)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl ((i . showsl_lit ": error below unknown proof\n") . x)))
      else Inl (i . showsl_lit
                      ": the proof contains an assumption or unknown proof\n"));

check_unknown_disproof ::
  forall a b c d.
    (Compare_order b, Default b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    Dpp_ops_ext d (Lab b c) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          [Char] ->
                            Neg_unknown_proof b c [Char] ->
                              Sum (String -> String) ();
check_unknown_disproof ia j assms i tpa (Assume_NT_Unknown tp ass) =
  debug i "Unknown Proof"
    (if assms
      then bindb (catch_errora
                   (check (tpa == tp)
                     (((showsl_lit "unknown problems are not identical:\n" .
                         showsl_lista tpa) .
                        showsl_lit "\n vs\n") .
                       showsl_lista tp))
                   (\ x ->
                     Inl (((i . showsl_lit
                                  ": error in nontermination assumption or unknown proof\n") .
                            x) .
                           showsl_literal "\n")))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assmb ia j
                       (check_trs_nontermination_proof ia j assms
                         (add_index i (suc ja)))
                       (check_dp_nontermination_proof ia j assms
                         (add_index i (suc ja)))
                       (check_reltrs_nontermination_proof ia j assms
                         (add_index i (suc ja)))
                       (check_fp_nontermination_proof ia j assms
                         (add_index i (suc ja)))
                       (check_unknown_disproof ia j assms
                         (add_index i (suc ja)))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . showsl_lit ": the proof contains an unknown proof\n"));

rhs_n ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Term a b;
rhs_n u (lr, cs) n =
  (if less_nat n (size_list cs)
    then ctxt_apply_term (u (lr, cs) n) (fst (nth cs n)) else snd lr);

lhs_n ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Term a b;
lhs_n u (lr, cs) n =
  (if equal_nat n zero_nat then fst lr
    else ctxt_apply_term (u (lr, cs) (minus_nat n one_nat))
           (snd (nth cs (minus_nat n one_nat))));

rules_impl ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> [(Term a b, Term a b)];
rules_impl u cr =
  map (\ i -> (lhs_n u cr i, rhs_n u cr i))
    (upt zero_nat (suc (size_list (snd cr))));

create_ctxts :: forall a b. [(Term a b, Term a b)] -> Maybe (Nat -> Ctxt a b);
create_ctxts r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      bind (mapMa (\ a -> (case a of {
                            (Var _, _) -> Nothing;
                            (Fun _ [], _) -> Nothing;
                            (Fun u (_ : ts), _) -> Just (More u [] Hole ts);
                          }))
             rr)
        (\ cs ->
          let {
            _ = size_list cs;
          } in Just (\ i ->
                      (if less_nat i (size_list cs) then nth cs i else Hole)));
  });

create_U ::
  forall a b.
    (Eq a,
      Eq b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                  [(Term a b, Term a b)])] ->
                 Maybe (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                         Nat -> Ctxt a b);
create_U c_rs =
  bind (mapMa
         (\ (cr, rs) ->
           bind (guard (equal_nat (size_list rs) (suc (size_list (snd cr)))))
             (\ _ -> bind (create_ctxts rs) (\ ctxt -> Just (cr, ctxt))))
         c_rs)
    (\ cr_ctxts -> let {
                     m = map_of cr_ctxts;
                   } in Just (\ cr -> (case m cr of {
Nothing -> (\ _ -> Hole);
Just ctxt -> ctxt;
                                      })));

check_unraveling ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                     [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum (String -> String) [(Term a b, Term a b)];
check_unraveling c_rs ctrs =
  catch_errora
    (bindb
      (catch_errora (check_subseteq ctrs (map fst c_rs))
        (\ x ->
          Inl ((showsl_lit "did not find rule " . showsl_crule x) .
                showsl_literal "\n")))
      (\ _ ->
        bindb (case create_U c_rs of {
                Nothing ->
                  Inl (showsl_lit "unable to extract unraveling contexts");
                Just a -> Inr a;
              })
          (\ u ->
            bindb (catch_errora
                    (forallM
                      (\ (c, rs) ->
                        check (rules_impl u c == rs)
                          ((showsl_lit "problem with rules of " .
                             showsl_crule c) .
                            showsl_literal "\n"))
                      c_rs)
                    (\ x -> Inl (snd x)))
              (\ _ -> Inr (concatMap snd c_rs)))))
    (\ x -> Inl (showsl_lit "problem in unraveling\n" . x));

check_quasi_reductive_proof ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Bool ->
                    (String -> String) ->
                      Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                          [((Term (Lab b [Nat]) [Char],
                              Term (Lab b [Nat]) [Char]),
                             [(Term (Lab b [Nat]) [Char],
                                Term (Lab b [Nat]) [Char])])] ->
                            Quasi_reductive_proof b [Nat] [Char] ->
                              Sum (String -> String) ();
check_quasi_reductive_proof a ia i j ctrs (Unravel u_info prf) =
  debug ia "Unravel"
    (bindb
      (catch_errora (check_unraveling u_info ctrs)
        (\ x -> Inl ((ia . showsl_lit ": error in unraveling\n") . x)))
      (\ r ->
        let {
          tp = mkc i False [] r [];
        } in catch_errora
               (check_trs_termination_proof i j a (ia . showsl_lit ".1") tp prf)
               (\ x ->
                 Inl ((ia . showsl_lit
                              ": error below strong normalization + wcr\n") .
                       x))));

showsl_gctxt :: forall a b. (Showl a) => Gctxt a b -> String -> String;
showsl_gctxt GCHole = showsl_literal "_";
showsl_gctxt (GCFun f ts) =
  showsl f . showsl_list_gen id "" "(" ", " ")" (map showsl_gctxt ts);

gctxts_to_terms_intern ::
  forall a b. (Nat -> a) -> Nat -> [Gctxt b a] -> (Nat, [Term b a]);
gctxts_to_terms_intern iv i (GCFun f ts : cs) =
  (case gctxts_to_terms_intern iv i ts of {
    (i1, res1) -> (case gctxts_to_terms_intern iv i1 cs of {
                    (i2, res2) -> (i2, Fun f res1 : res2);
                  });
  });
gctxts_to_terms_intern iv i (GCHole : cs) =
  (case gctxts_to_terms_intern iv (plus_nat i one_nat) cs of {
    (ia, res) -> (ia, Var (iv i) : res);
  });
gctxts_to_terms_intern iv i [] = (i, []);

gc_matcher ::
  forall a.
    (Eq a) => Gctxt a [Char] ->
                Term a [Char] -> Maybe ([Char] -> Term a [Char]);
gc_matcher c l =
  map_option fst
    (mgu_var_disjoint_generic
      (\ a -> Char False False False True True True True False : a)
      (\ a -> Char True False False True True True True False : a) l
      (hda (snd (gctxts_to_terms_intern
                  (\ i ->
                    Char False False False True True True True False :
                      shows_prec_nat zero_nat i [])
                  zero_nat [c]))));

check_contains_U0 ::
  forall a.
    (Compare a, Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    Set (Term a [Char], Term a [Char]) ->
                      Term a [Char] -> Sum (String -> String) ();
check_contains_U0 r u s =
  catch_errora
    (forallM
      (\ fts ->
        (case fts of {
          Var _ -> Inr ();
          Fun f ts ->
            let {
              tcapb = GCFun f (map (tcap u) ts);
            } in catch_errora
                   (forallM
                     (\ lr ->
                       (case gc_matcher tcapb (fst lr) of {
                         Nothing -> Inr ();
                         Just sigma ->
                           let {
                             irule =
                               (subst_apply_term (fst lr) sigma,
                                 subst_apply_term (snd lr) sigma);
                           } in check (in_rstep_impl (fst irule) (snd irule) u)
                                  ((((((((((showsl_literal
      "When considering the subterm " .
     showsl_terma fts) .
    showsl_literal "\nand the rule ") .
   showsl_rule lr) .
  showsl_literal "\nthe capped subterm is ") .
 showsl_gctxt tcapb) .
showsl_literal "\nleading to the mgu with the lhs: ") .
                                       showsl_list_prod
 (map (\ x -> (x, sigma x)) (vars_term_list (fst lr)))) .
                                      showsl_literal
"\nThe instantiated rule ") .
                                     showsl_rule irule) .
                                    showsl_literal
                                      "\ncannot be simulated by the given set of usable rules");
                       }))
                     r)
                   (\ x -> Inl (snd x));
        }))
      (supteq_list s))
    (\ x -> Inl (snd x));

check_usable_instantiation ::
  forall a.
    (Compare a, Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    [(Term a [Char], Term a [Char])] ->
                      Term a [Char] -> Sum (String -> String) ();
check_usable_instantiation r u s =
  let {
    uu = set u;
  } in bindb (catch_errora (check_contains_U0 r uu s)
               (\ x -> Inl (showsl_literal "U <= U0(R,s) required\n" . x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ ra ->
                 catch_errora (check_contains_U0 r uu ra)
                   (\ x ->
                     Inl (((showsl_literal "U <= U0(R,r) for rhs r = " .
                             showsl_terma ra) .
                            showsl_literal " required\n") .
                           x)))
               (map snd u))
             (\ x -> Inl (snd x)));

check_usable_rules_unif ::
  forall a.
    (Compare a, Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    [(Term a [Char], Term a [Char])] ->
                      Term a [Char] -> Sum (String -> String) ();
check_usable_rules_unif r u s =
  catch_errora
    (bindb
      (check (ground s || all (\ l -> not (is_Var l)) (map fst r))
        ((showsl_literal "since " . showsl_terma s) .
          showsl_literal
            " is not ground, left-hand sides of R must not be variables"))
      (\ _ ->
        bindb (check_varcond_subset u)
          (\ _ ->
            catch_errora (check_usable_instantiation r u s)
              (\ x ->
                Inl (showsl_literal
                       "closure properties of usable rules not satisfied\n" .
                      x)))))
    (\ x ->
      Inl (((((((showsl_literal
                   "problem in checking validity of usable rules U =\n" .
                  showsl_trs u) .
                 showsl_literal "\nfor term ") .
                showsl_terma s) .
               showsl_literal "\nwrt TRS R =\n") .
              showsl_trs r) .
             showsl_literal "\n") .
            x));

sl_c :: forall a b c d e. Sl_ops_ext a b c d e -> b;
sl_c (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_c;

check_qmodel_rule_ass ::
  forall a b c.
    (Showl a, Showl b,
      Showl c) => (a -> [b] -> b) ->
                    (b -> b -> Bool) ->
                      (c -> b) ->
                        (Term a c, Term a c) -> Sum (String -> String) ();
check_qmodel_rule_ass i cge alpha (l, r) =
  let {
    cl = eval i alpha l;
    cr = eval i alpha r;
  } in check (cge cl cr)
         (((((showsl_lit "rule " . showsl_rule (l, r)) .
              showsl_lit " violates the model condition, [lhs] = ") .
             showsl cl) .
            showsl_lit ", [rhs] = ") .
           showsl cr);

check_qmodel_rule ::
  forall a b c.
    (Showl a, Showl b, Eq c,
      Showl c) => (a -> [b] -> b) ->
                    [b] ->
                      (b -> b -> Bool) ->
                        (Term a c, Term a c) -> Sum (String -> String) ();
check_qmodel_rule i c cge lr =
  catch_errora
    (forallM (\ alpha -> check_qmodel_rule_ass i cge alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_qmodel ::
  forall a b c.
    (Showl a, Showl b, Eq c,
      Showl c) => (a -> [b] -> b) ->
                    [b] ->
                      (b -> b -> Bool) ->
                        [(Term a c, Term a c)] -> Sum (String -> String) ();
check_qmodel i c cge r =
  catch_errora (forallM (check_qmodel_rule i c cge) r) (\ x -> Inl (snd x));

check_non_join_model ::
  forall a b c d.
    (Showl a, Showl b, Eq d,
      Showl d) => (a -> a -> Bool) ->
                    ([(b, Nat)] ->
                      [(b, Nat)] ->
                        Sum (String -> String) (Sl_ops_ext b a c d ())) ->
                      [(Term b d, Term b d)] ->
                        [(Term b d, Term b d)] ->
                          Term b d -> Term b d -> Sum (String -> String) ();
check_non_join_model cge gen rs rt s t =
  catch_errora
    (bindb (gen (funas_trs_list (rs ++ rt)) [])
      (\ ops ->
        let {
          i = sl_I ops;
          e = eval i (\ _ -> sl_c ops);
          es = e s;
          et = e t;
        } in bindb (check (not (cge et es))
                     ((((((((showsl_lit "the inequality must not hold: [" .
                              showsl_terma t) .
                             showsl_lit "] = ") .
                            showsl et) .
                           showsl_lit " >= ") .
                          showsl es) .
                         showsl_lit " = [") .
                        showsl_terma s) .
                       showsl_lit "]"))
               (\ _ -> check_qmodel i (sl_C ops) cge (reverse_rules rs ++ rt))))
    (\ x ->
      Inl ((showsl_lit
              "problem in disproving non-joinability via interpretations" .
             showsl_literal "\n") .
            x));

check_non_join_finite_model ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => Sl_variant (Lab a [Nat]) b ->
                    [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                      [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                        Term (Lab a [Nat]) b ->
                          Term (Lab a [Nat]) b -> Sum (String -> String) ();
check_non_join_finite_model (Rootlab x) rs rt s t =
  check_non_join_model equal_lab (slm_gen_to_sl_gen (rl_slm x)) rs rt s t;
check_non_join_finite_model (Finitelab sli) rs rt s t =
  check_non_join_model equal_nat
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli))) rs rt s t;
check_non_join_finite_model (QuasiFinitelab sli v) rs rt s t =
  check_non_join_model qmodel_cge (\ f g -> qsli_to_sl v f g sli) rs rt s t;

match_tcap_below_impl ::
  forall a b.
    (Eq a, Eq b) => Term a b -> [(Term a b, Term a b)] -> Term a b -> Bool;
match_tcap_below_impl l r (Fun f ts) = matchb (GCFun f (map (tcapI r) ts)) l;
match_tcap_below_impl l r (Var x) = False;

usable_rules_reach_U0_impl ::
  forall a b.
    (Eq a,
      Eq b) => [(Term a b, Term a b)] -> Term a b -> [(Term a b, Term a b)];
usable_rules_reach_U0_impl r t =
  inductive_set_impl r
    (\ ta (l, _) ->
      is_Var l ||
        any (\ u -> not (is_Var u) && match_tcap_below_impl l r u)
          (supteq_list ta))
    (\ lr -> [snd lr]) [t];

usable_rules_reach_impl ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       Term a b -> [(Term a b, Term a b)];
usable_rules_reach_impl r t =
  let {
    u0t = usable_rules_reach_U0_impl r t;
  } in (if all (\ (l, ra) -> less_eq_set (vars_term ra) (vars_term l)) u0t
         then u0t else r);

check_non_join_redpair ::
  forall a b.
    (Compare_order a, Showl a,
      Showl b) => Redtriple_ext a b () ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        Term a b -> Term a b -> Sum (String -> String) ();
check_non_join_redpair rp rs rt sa t =
  catch_errora
    (bindb (valid rp)
      (\ _ ->
        bindb (catch_errora (forallM (ns rp) (reverse_rules rs ++ rt))
                (\ x -> Inl (snd x)))
          (\ _ -> s rp (sa, t))))
    (\ x ->
      Inl ((showsl_lit
              "problem in disproving non-joinability via discrimination pairs" .
             showsl_literal "\n") .
            x));

non_join_with_ta ::
  forall a b c d e f g.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a, Showl a, Ceq b, Ccompare b, Compare_order b, Default b, Eq b,
      Set_impl b, Showl b, Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c,
      Compare_order c, Eq c, Set_impl c, Showl c, Showl d, Card_UNIV e, Cenum e,
      Ceq e, Cproper_interval e, Compare_order e, Eq e, Set_impl e, Showl e,
      Finite_UNIV f, Cenum f, Ceq f, Cproper_interval f, Compare_order f, Eq f,
      Set_impl f, Showl f,
      Showl g) => Tree_automaton a b ->
                    Ta_relation a ->
                      [(Term b c, Term b c)] ->
                        Term b d ->
                          Tree_automaton e b ->
                            Ta_relation e ->
                              [(Term b f, Term b f)] ->
                                Term b g -> Sum (String -> String) ();
non_join_with_ta ta1 rel1 r1 t1 ta2 rel2 r2 t2 =
  let {
    tA1 = ta_of_ta ta1;
    tA2 = ta_of_ta ta2;
  } in bindb (check (ta_member t1 tA1)
               (showsl_terma t1 .
                 showsl_lit " is not accepted by first automaton"))
         (\ _ ->
           bindb (check (ta_member t2 tA2)
                   (showsl_terma t2 .
                     showsl_lit " is not accepted by second automaton"))
             (\ _ ->
               bindb (check (ta_empty (intersect_ta tA1 tA2))
                       (showsl_lit "intersection of automata is non-empty"))
                 (\ _ ->
                   bindb (catch_errora (tree_aut_trs_closed ta1 rel1 r1)
                           (\ x ->
                             Inl (showsl_lit
                                    "could not ensure closure under rewriting for first automaton\n" .
                                   x)))
                     (\ _ ->
                       catch_errora (tree_aut_trs_closed ta2 rel2 r2)
                         (\ x ->
                           Inl (showsl_lit
                                  "could not ensure closure under rewriting for second automaton\n" .
                                 x))))));

check_non_join ::
  forall a b.
    (Compare_order a, Default a, Eq a, Showl a, Card_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b,
      Showl b) => [(Term (Lab a [Nat]) [Char], Term (Lab a [Nat]) [Char])] ->
                    [(Term (Lab a [Nat]) [Char], Term (Lab a [Nat]) [Char])] ->
                      Term (Lab a [Nat]) [Char] ->
                        Term (Lab a [Nat]) [Char] ->
                          Non_join_info (Lab a [Nat]) [Char] b ->
                            Sum (String -> String) ();
check_non_join rs rt s t Diff_NFs =
  bindb (check (not (equal_term s t))
          ((((showsl_lit "the terms " . showsl_terma s) . showsl_lit " and ") .
             showsl_terma t) .
            showsl_lit " are identical"))
    (\ _ ->
      let {
        chknf =
          (\ sa r ->
            check (is_NF_trs r sa)
              ((showsl_lit "the term " . showsl_terma sa) .
                showsl_lit " is not in normal form"));
      } in bindb (chknf s rs) (\ _ -> chknf t rt));
check_non_join rs rt s t (Grounding sigma prf) =
  let {
    sigmaa = mk_subst Var sigma;
  } in check_non_join rs rt (subst_apply_term s sigmaa)
         (subst_apply_term t sigmaa) prf;
check_non_join rs rt s t (Subterm_NJ p prf) =
  bindb (check (member p (pos_gctxt (tcapI rs s)))
          (((showsl_lit "position " . showsl_pos p) .
             showsl_lit " not in capped term  of ") .
            showsl_terma s))
    (\ _ ->
      bindb (check (member p (pos_gctxt (tcapI rt t)))
              (((showsl_lit "position " . showsl_pos p) .
                 showsl_lit " not in capped term  of ") .
                showsl_terma t))
        (\ _ -> check_non_join rs rt (subt_at s p) (subt_at t p) prf));
check_non_join rs rt s t (Tcap_Non_Unif grd_subst) =
  let {
    sigma = grd_subst s t;
    cs = tcapI rs (subst_apply_term s sigma);
    ct = tcapI rt (subst_apply_term t sigma);
  } in check (is_none (mergeb cs ct))
         ((((showsl_lit "could not infer that " . showsl_terma s) .
             showsl_lit " and ") .
            showsl_terma t) .
           showsl_lit " are not joinable");
check_non_join rs rt s t (Tree_Aut_Intersect_Empty ta1 rel1 ta2 rel2) =
  catch_errora (non_join_with_ta ta1 rel1 rs s ta2 rel2 rt t)
    (\ x ->
      Inl ((((((showsl_lit "could not infer that " . showsl_terma s) .
                showsl_lit " and ") .
               showsl_terma t) .
              showsl_lit " are not joinable") .
             showsl_literal "\n") .
            x));
check_non_join rs rt s t (Finite_Model_Gt i) =
  catch_errora (check_non_join_finite_model i rs rt s t)
    (\ x ->
      Inl ((((((showsl_lit "could not infer that " . showsl_terma s) .
                showsl_lit " and ") .
               showsl_terma t) .
              showsl_lit " are not joinable") .
             showsl_literal "\n") .
            x));
check_non_join rs rt s t (Reduction_Pair_Gt rp) =
  catch_errora (check_non_join_redpair (get_redtriple rp) rs rt s t)
    (\ x ->
      Inl ((((((showsl_lit "could not infer that " . showsl_terma s) .
                showsl_lit " and ") .
               showsl_terma t) .
              showsl_lit " are not joinable") .
             showsl_literal "\n") .
            x));
check_non_join rs rt s t (Usable_Rules_Reach_NJ prf) =
  check_non_join (usable_rules_reach_impl rs s) (usable_rules_reach_impl rt t) s
    t prf;
check_non_join rs rt s t (Usable_Rules_Reach_Unif_NJ u_sum prf) =
  (case u_sum of {
    Inl u ->
      bindb (check_usable_rules_unif rs u s)
        (\ _ -> check_non_join u rt s t prf);
    Inr u ->
      bindb (check_usable_rules_unif rt u t)
        (\ _ -> check_non_join rs u s t prf);
  });
check_non_join rs rt s t (Argument_Filter_NJ pi prf) =
  (case afs_of pi of {
    Nothing -> Inl (showsl_lit "invalid argument filter");
    Just pia -> let {
                  af = af_term pia;
                  afs = af_rules pia;
                } in check_non_join (afs rs) (afs rt) (af s) (af t) prf;
  });

ru_impl ::
  forall a b.
    [((Term a b, Term a b), [(Term a b, Term a b)])] -> [(Term a b, Term a b)];
ru_impl r = map fst r;

check_conditional_non_cr ::
  forall a b.
    (Compare_order a, Default a, Eq a, Showl a, Card_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b,
      Showl b) => [((Term (Lab a [Nat]) [Char], Term (Lab a [Nat]) [Char]),
                     [(Term (Lab a [Nat]) [Char],
                        Term (Lab a [Nat]) [Char])])] ->
                    Term (Lab a [Nat]) [Char] ->
                      Term (Lab a [Nat]) [Char] ->
                        Term (Lab a [Nat]) [Char] ->
                          [Cstep_proof (Lab a [Nat]) [Char]] ->
                            [Cstep_proof (Lab a [Nat]) [Char]] ->
                              Non_join_info (Lab a [Nat]) [Char] b ->
                                Sum (String -> String) ();
check_conditional_non_cr r s t u ps qs reason =
  bindb (check_csteps r s t ps)
    (\ _ ->
      bindb (check_csteps r s u qs)
        (\ _ -> check_non_join (ru_impl r) (ru_impl r) t u reason));

find_index :: forall a. (Eq a) => Nat -> a -> [a] -> Sum () Nat;
find_index i x [] = Inl ();
find_index i x (y : ys) = (if x == y then Inr i else find_index (suc i) x ys);

check_inline_conds_rule ::
  forall a b.
    (Compare a, Eq a, Showl a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      [(Term a b, Term a b)] ->
                        Sum (String -> String)
                          ([((Term a b, Term a b), [(Term a b, Term a b)])],
                            ((Term a b, Term a b), [(Term a b, Term a b)]));
check_inline_conds_rule r rho [] = Inr (r, rho);
check_inline_conds_rule r rho (c : cs) =
  catch_errora
    (let {
       a = rho;
     } in (case a of {
            (aa, b) ->
              (case aa of {
                (l, _) ->
                  (\ csa ->
                    (case c of {
                      (s, t) ->
                        bindb (check (is_Var t)
                                (showsl_lit "condition with non-variable rhs"))
                          (\ _ ->
                            let {
                              x = the_Var t;
                            } in bindb (catch_errora (find_index zero_nat c csa)
 (\ xa -> Inl (case xa of {
                () -> showsl_lit "condition does not occur in rule";
              })))
                                   (\ i ->
                                     bindb (check (not (contains_var_term x s))
     (showsl_lit "occurs check failed"))
                                       (\ _ ->
 bindb (check (not (contains_var_term x l))
         (showsl_lit "inlining not allowed in lhs of rule"))
   (\ _ ->
     bindb (check
             (not (member x
                    (sup_set
                      (sup_seta
                        (image vars_term (image snd (set (take i csa)))))
                      (sup_seta
                        (image vars_term
                          (image snd (set (drop (suc i) csa))))))))
             (showsl_lit "inlining not allowed in rhss of conditions"))
       (\ _ ->
         check_inline_conds_rule (inline i rho : removeAll rho r) (inline i rho)
           (map (\ (u, ab) -> (subst_apply_term u (subst x s), ab)) cs))))));
                    }));
              })
                b;
          }))
    (\ x ->
      Inl (((((showsl_lit "error while inlining condition " . showsl_eqa c) .
               showsl_lit " of rule ") .
              showsl_crule rho) .
             showsl_literal "\n") .
            x));

check_inline_conds_ctrs ::
  forall a b.
    (Compare a, Eq a, Showl a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    [(((Term a b, Term a b), [(Term a b, Term a b)]),
                       [(Term a b, Term a b)])] ->
                      Sum (String -> String)
                        [((Term a b, Term a b), [(Term a b, Term a b)])];
check_inline_conds_ctrs r [] = Inr r;
check_inline_conds_ctrs ra ((r, cs) : rcs) =
  catch_errora
    (bindb
      (check (membera ra r)
        (showsl_crule r . showsl_lit " does not occur in the input CTRS"))
      (\ _ ->
        bindb (check_inline_conds_rule ra r cs)
          (\ (rb, raa) ->
            check_inline_conds_ctrs (raa : removeAll raa rb) rcs)))
    (\ x -> Inl (showsl_lit "error while inlining conditions\n" . x));

check_inline_conds ::
  forall a b.
    (Compare a, Eq a, Showl a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [(((Term a b, Term a b), [(Term a b, Term a b)]),
                         [(Term a b, Term a b)])] ->
                        Sum (String -> String) ();
check_inline_conds ra r rcs =
  bindb (check_inline_conds_ctrs ra rcs)
    (\ raa ->
      catch_errora (check_same_set r raa)
        (\ _ ->
          Inl ((((showsl_lit "error while inlining:" .
                   showsl_lit "\ninternally computed CTRS\n") .
                  showsl_ctrs raa) .
                 showsl_lit "\nbut certificate contains CTRS\n") .
                showsl_ctrs r)));

check_infeasible_rules ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [((Term a [Char], Term a [Char]), b)] ->
                    [(((Term a [Char], Term a [Char]),
                        [(Term a [Char], Term a [Char])]),
                       Infeasibility_proof a [Char])] ->
                      Sum (String -> String) ();
check_infeasible_rules r =
  (\ xs ->
    catch_errora
      (forallM
        (\ (ra, ps) ->
          catch_errora (check_infeasibleb r (snd ra) ps)
            (\ x ->
              Inl (((showsl_lit "rule " . showsl_crule ra) .
                     showsl_lit " is not infeasible\n") .
                    x)))
        xs)
      (\ x -> Inl (snd x)));

check_ccr_trans ::
  forall a b.
    (Compare a, Default a, Eq a, Showl a, Compare b, Eq b,
      Showl b) => (String -> String) ->
                    [((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                       [(Term (Lab a b) [Char], Term (Lab a b) [Char])])] ->
                      Ccr_transformation a b [Char] ->
                        Sum (String -> String)
                          [((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                             [(Term (Lab a b) [Char], Term (Lab a b) [Char])])];
check_ccr_trans i ra (Inline_Conditions_CCRT r rcs) =
  debug i "Inline Conditions"
    (bindb (check_inline_conds ra r rcs) (\ _ -> Inr r));
check_ccr_trans i r (Infeasible_Rule_Removal_CCRT rps) =
  debug i "Infeasible Rule Removal"
    (bindb (check_infeasible_rules (list_diff r (map fst rps)) rps)
      (\ _ -> Inr (list_diff r (map fst rps))));

check_redundant_rules_ncr ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] -> Nat -> Sum (String -> String) ();
check_redundant_rules_ncr ra r n =
  bindb (catch_errora (check_subseteq ra r)
          (\ _ -> Inl (showsl_lit "old TRS is not a subsystem of given TRS")))
    (\ _ ->
      let {
        s = list_diff r ra;
        t = list_diff ra r;
      } in bindb (catch_errora
                   (forallM
                     (\ (l, rb) ->
                       check (membera (reachable_terms ra l n) rb)
                         (showsl_lit "could not simulate rule " .
                           showsl_rule (l, rb)))
                     s)
                   (\ x -> Inl (snd x)))
             (\ _ ->
               catch_errora
                 (forallM
                   (\ (l, raa) ->
                     check (membera (reachable_terms r l n) raa)
                       (showsl_lit "could not simulate rule " .
                         showsl_rule (l, raa)))
                   t)
                 (\ x -> Inl (snd x))));

check_persistence_not_cr ::
  forall a b c.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b, Showl b, Ccompare c, Eq c,
      Mapping_impl c,
      Showl c) => [(a, ([b], b))] ->
                    [(Term a c, Term a c)] ->
                      [(Term a c, Term a c)] -> Sum (String -> String) ();
check_persistence_not_cr sig r s =
  bindb (check_persistence1 sig r [s])
    (\ (ra, ss) ->
      let {
        sigF = mk_sigF sig;
        types = map (snd . snd) sig;
        needed_types = needed_types_code sig;
      } in catch_errora
             (existsM (\ sa -> check_litsim_trs sa (hda ss))
               (map (\ ty ->
                      let {
                        tys = needed_types ty;
                      } in filter (\ rb -> membera tys (type_of_rule sigF rb))
                             ra)
                 types))
             (\ _ ->
               Inl ((showsl_lit
                       "persistent decomposition: new system is not induced by any type:" .
                      showsl_literal "\n") .
                     showsl_trs s)));

check_modularity_ncr ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showl a, Eq b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] -> Sum (String -> String) ();
check_modularity_ncr ra r =
  bindb (catch_errora (check_subseteq r ra)
          (\ _ -> Inl (showsl_lit "new TRS is not a subsystem of given TRS")))
    (\ _ ->
      let {
        s = list_diff ra r;
        f = funas_trs_list r;
        g = funas_trs_list s;
      } in bindb (check (less_eq_set (inf_set (set f) (set g)) bot_set)
                   (showsl_lit "signatures are not disjoint"))
             (\ _ ->
               bindb (check_varcond_subset r)
                 (\ _ ->
                   catch_errora
                     (catch_errora
                       (forallM
                         (\ x ->
                           (if (case x of {
                                 (l, _) -> not (is_Var l);
                               })
                             then Inr () else Inl x))
                         s)
                       (\ x -> Inl (snd x)))
                     (\ _ -> Inl (showsl_lit "lhss must not be variables")))));

check_non_cr ::
  forall a b.
    (Compare_order a, Default a, Eq a, Showl a, Card_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b,
      Showl b) => [(Term (Lab a [Nat]) [Char], Term (Lab a [Nat]) [Char])] ->
                    Term (Lab a [Nat]) [Char] ->
                      [([Nat],
                         ((Term (Lab a [Nat]) [Char],
                            Term (Lab a [Nat]) [Char]),
                           Term (Lab a [Nat]) [Char]))] ->
                        [([Nat],
                           ((Term (Lab a [Nat]) [Char],
                              Term (Lab a [Nat]) [Char]),
                             Term (Lab a [Nat]) [Char]))] ->
                          Non_join_info (Lab a [Nat]) [Char] b ->
                            Sum (String -> String) ();
check_non_cr r s seq1 seq2 reason =
  let {
    chk = check_rsteps_last r s;
  } in bindb (chk seq1)
         (\ _ ->
           bindb (chk seq2)
             (\ _ ->
               check_non_join r r (rseq_last s seq1) (rseq_last s seq2)
                 reason));

check_ncr_proof ::
  forall a b c.
    (Compare_order b, Countable b, Default b, Eq b,
      Showl b) => Bool ->
                    (String -> String) ->
                      Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                          [(Term (Lab b [Nat]) [Char],
                             Term (Lab b [Nat]) [Char])] ->
                            Ncr_proof b [Nat] [Char] [Char] ->
                              Sum (String -> String) ();
check_ncr_proof a ia i j r (SN_NWCR prf) =
  debug ia "SN_NWCR"
    (let {
       tp = mkc i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a (add_index ia one_nat) tp
                    prf)
                  (\ x ->
                    Inl ((ia . showsl_lit
                                 ": error below strong normalization + wcr\n") .
                          x)))
            (\ _ ->
              catch_errora
                (check
                  (not (isOK (check_critical_pairs_NF r
                               (critical_pairs_impl r r))))
                  (showsl_lit "all critical pairs are joinable"))
                (\ x ->
                  Inl ((((ia . showsl_lit
                                 ": error when disproving local confluence of ") .
                          showsl_tp i tp) .
                         showsl_literal "\n") .
                        x))));
check_ncr_proof a ia i j r (Non_Join s seq1 seq2 prf) =
  debug ia "Non_Join"
    (catch_errora (check_non_cr r s seq1 seq2 prf)
      (\ x ->
        Inl ((((ia . showsl_lit ": error when disproving CR of ") .
                showsl_trs r) .
               showsl_literal "\n") .
              x)));
check_ncr_proof a ia i j ra (NCR_Disj_Subtrs r prf) =
  debug ia "Modularity"
    (bindb
      (catch_errora (check_modularity_ncr ra r)
        (\ x ->
          Inl ((((ia . showsl_lit
                         ": error when applying modularity to switch to ") .
                  showsl_trs r) .
                 showsl_literal "\n") .
                x)))
      (\ _ ->
        catch_errora (check_ncr_proof a (add_index ia one_nat) i j r prf)
          (\ x ->
            Inl ((ia . showsl_lit ": error below the modular decomposition\n") .
                  x))));
check_ncr_proof a ia i j r (NCR_Redundant_Rules rs n prf) =
  debug ia "Redundant Rules"
    (bindb
      (catch_errora (check_ncr_proof a (add_index ia one_nat) i j rs prf)
        (\ x ->
          Inl (((ia . showsl_lit
                        ": error when proving nonconfluence of modified TRS\n") .
                 showsl_trs rs) .
                x)))
      (\ _ ->
        catch_errora (check_redundant_rules_ncr r rs n)
          (\ x ->
            Inl (((ia . showsl_lit
                          ": error in checking redundant rules transformation of the TRS\n") .
                   showsl_trs r) .
                  x))));
check_ncr_proof a ia i j r (NCR_Persistent_Decomposition sig s prf) =
  debug ia "Persistent Decomposition"
    (bindb
      (catch_errora (check_ncr_proof a (add_index ia one_nat) i j s prf)
        (\ x ->
          Inl (((ia . showsl_lit
                        ": error while proving nonconfluence of resulting TRS\n") .
                 showsl_trs s) .
                x)))
      (\ _ ->
        catch_errora (check_persistence_not_cr sig r s)
          (\ x ->
            Inl (((ia . showsl_lit
                          ": error in checking persistent decomposition of ") .
                   showsl_trs r) .
                  x))));

check_conditional_ncr_proof ::
  forall a b c.
    (Compare_order b, Countable b, Default b, Eq b,
      Showl b) => Bool ->
                    (String -> String) ->
                      Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                          [((Term (Lab b [Nat]) [Char],
                              Term (Lab b [Nat]) [Char]),
                             [(Term (Lab b [Nat]) [Char],
                                Term (Lab b [Nat]) [Char])])] ->
                            Conditional_ncr_proof b [Nat] [Char] [Char] ->
                              Sum (String -> String) ();
check_conditional_ncr_proof a ia i j r (Unconditional_CNCR prf) =
  debug ia "Unconditional"
    (bindb
      (catch_errora
        (catch_errora
          (forallM (\ x -> (if null (snd x) then Inr () else Inl x)) r)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl ((showsl_lit "rule with non-empty conditions" .
                 showsl_literal "\n") .
                showsl_crule x)))
      (\ _ -> check_ncr_proof a ia i j (map fst r) prf));
check_conditional_ncr_proof a ia i j r (Transformation_CNCR t prf) =
  debug ia "CR Preserving Transformation"
    (bindb (check_ccr_trans ia r t)
      (\ ra -> check_conditional_ncr_proof a ia i j ra prf));
check_conditional_ncr_proof a ia i j r (Non_Join_CNCR s t u ps qs prf) =
  debug ia "Conditional Non-Joinability"
    (catch_errora (check_conditional_non_cr r s t u ps qs prf)
      (\ x ->
        Inl ((((ia . showsl_lit "error when disproving CR of ") .
                showsl_ctrs r) .
               showsl_literal "\n") .
              x)));

check_subsumptions_guided ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [((Term a b, Term a b),
                       [([Nat], ((Term a b, Term a b), (Bool, Term a b)))])] ->
                      Sum (String -> String) ();
check_subsumptions_guided e [] = Inr ();
check_subsumptions_guided ea ((e, seq) : convs) =
  bindb (catch_errora (check_conversiona ea seq (fst e) (snd e))
          (\ x ->
            Inl (((showsl_lit "problem in conversion for equation " .
                    showsl_eq e) .
                   showsl_literal "\n") .
                  x)))
    (\ _ -> check_subsumptions_guided (e : ea) convs);

check_convertible_instance ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b, Term a b) ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [([Nat],
                            ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum (String -> String) ();
check_convertible_instance eq e convs =
  bindb (catch_errora
          (existsM
            (\ c ->
              check (instance_rule (fst c) eq)
                (showsl_lit "not an instance of " . showsl_eq eq))
            convs)
          (\ _ -> Inl (showsl_lit " no instance found")))
    (\ _ -> check_subsumptions_guided e convs);

check_subsumption_guided ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [([Nat],
                            ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum (String -> String) ();
check_subsumption_guided ea e convs =
  bindb (catch_errora (check_subseteq ea (map fst convs))
          (\ x ->
            Inl (showsl_lit "could not find conversion for equation " .
                  showsl_eq x)))
    (\ _ -> check_subsumptions_guided e convs);

check_subsumption_NF ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] -> Sum (String -> String) ();
check_subsumption_NF e r =
  catch_errora
    (forallM
      (\ ea ->
        catch_errora (check_join_NF r (fst ea) (snd ea))
          (\ x ->
            Inl (((showsl_lit "could not join equation " . showsl_eq ea) .
                   showsl_literal "\n") .
                  x)))
      e)
    (\ x -> Inl (snd x));

check_subsumption ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Maybe [((Term a b, Term a b),
                               [([Nat],
                                  ((Term a b, Term a b),
                                    (Bool, Term a b)))])] ->
                        Sum (String -> String) ();
check_subsumption e r convs_o = (case convs_o of {
                                  Nothing -> check_subsumption_NF e r;
                                  Just a -> check_subsumption_guided e r a;
                                });

check_completion_proof ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Bool ->
                    (String -> String) ->
                      Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                          [(Term (Lab b [Nat]) [Char],
                             Term (Lab b [Nat]) [Char])] ->
                            [(Term (Lab b [Nat]) [Char],
                               Term (Lab b [Nat]) [Char])] ->
                              Completion_proof b [Nat] [Char] ->
                                Sum (String -> String) ();
check_completion_proof a ia i j e r (SN_WCR_Eq joins_i prf conv1 conv2) =
  debug ia "SN_WCR_Eq"
    (let {
       tp = mkc i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a (add_index ia one_nat) tp
                    prf)
                  (\ x ->
                    Inl ((ia . showsl_lit
                                 ": error below strong normalization + wcr\n") .
                          x)))
            (\ _ ->
              bindb (catch_errora (check_subsumption_guided r e conv1)
                      (\ x ->
                        Inl ((ia . showsl_lit
                                     ": error when showing that rewrite relation can be simulated by equations\n") .
                              x)))
                (\ _ ->
                  bindb (catch_errora (check_subsumption e r conv2)
                          (\ x ->
                            Inl ((ia . showsl_lit
 ": error when showing that equations can be simulated by rewrite system\n") .
                                  x)))
                    (\ _ ->
                      catch_errora
                        (check_critical_pairs r (critical_pairs_impl r r)
                          joins_i)
                        (\ x ->
                          Inl ((((ia . showsl_lit
 ": error when proving local confluence of \n") .
                                  showsl_tp i tp) .
                                 showsl_literal "\n") .
                                x))))));

check_equational_disproof ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Bool ->
                    (String -> String) ->
                      Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                          [(Term (Lab b [Nat]) [Char],
                             Term (Lab b [Nat]) [Char])] ->
                            Equation_literal (Lab b [Nat]) [Char] ->
                              Equational_disproof b [Nat] [Char] ->
                                Sum (String -> String) ();
check_equational_disproof a ia i j e (Equation eq)
  (Completion_and_Normalization_Different r p) =
  debug ia "Completion_and_Normalization"
    (bindb (check_completion_proof a ia i j e r p)
      (\ _ ->
        let {
          s = fst eq;
          t = snd eq;
        } in (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
               (Nothing, _) ->
                 Inl (((showsl_lit "error when computing normal forms of " .
                         showsl_terma s) .
                        showsl_lit " and ") .
                       showsl_terma t);
               (Just _, Nothing) ->
                 Inl (((showsl_lit "error when computing normal forms of " .
                         showsl_terma s) .
                        showsl_lit " and ") .
                       showsl_terma t);
               (Just sa, Just ta) ->
                 (if not (equal_term sa ta) then Inr ()
                   else Inl ((((showsl_terma s . showsl_lit " and ") .
                                showsl_terma t) .
                               showsl_lit " have same normal form ") .
                              showsl_terma sa));
             })));
check_equational_disproof a ia i j e_0 (Equation eq)
  (Ordered_Completion_and_Normalization_Different r e ro p) =
  debug ia "Ordered_Completion_and_Normalization"
    (check_equational_disproof_oc ia eq e_0 e r ro p);
check_equational_disproof a ia i j e (Inequality eq)
  (Convertible_Instance convs) =
  debug ia "Convertible_Instance" (check_convertible_instance eq e convs);
check_equational_disproof a ia i j e (Inequality v)
  (Completion_and_Normalization_Different va vb) =
  Inl (showsl_lit "unsupported disproof");
check_equational_disproof a ia i j e (Inequality v)
  (Ordered_Completion_and_Normalization_Different va vb vc vd) =
  Inl (showsl_lit "unsupported disproof");
check_equational_disproof a ia i j e (Equation va) (Convertible_Instance v) =
  Inl (showsl_lit "unsupported disproof");

match_crule ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                           ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                             Maybe (b -> Term a b);
match_crule rho_1 rho_2 =
  bind (zip_option
         (fst (fst rho_2) :
           snd (fst rho_2) : map fst (snd rho_2) ++ map snd (snd rho_2))
         (fst (fst rho_1) :
           snd (fst rho_1) : map fst (snd rho_1) ++ map snd (snd rho_1)))
    (match_list Var);

check_overlapa ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Infinite a, Showl a, Eq b,
      Showl b) => (a -> a) ->
                    (a -> a) ->
                      ([((Term b a, Term b a), [(Term b a, Term b a)])] ->
                        [(Term b a, Term b a)] ->
                          [(Term b a, Term b a)] ->
                            Sum (String -> String) ()) ->
                        [((Term b a, Term b a), [(Term b a, Term b a)])] ->
                          ((Term b a, Term b a), [(Term b a, Term b a)]) ->
                            ((Term b a, Term b a), [(Term b a, Term b a)]) ->
                              [Nat] -> Sum (String -> String) ();
check_overlapa xvar yvar check_infeasible r rho_1 rho_2 p =
  catch_errora
    (case mgu_var_disjoint_generic xvar yvar (subt_at (fst (fst rho_1)) p)
            (fst (fst rho_2))
      of {
      Nothing -> Inr ();
      Just (sigma_1, sigma_2) ->
        catch_errora
          (choice
            [check (null p &&
                     equal_term (subst_apply_term (snd (fst rho_1)) sigma_1)
                       (subst_apply_term (snd (fst rho_2)) sigma_2))
               (showsl_lit "is not a trivial root-overlap"),
              check (null p &&
                      not (is_none (match_crule rho_1 rho_2)) &&
                        not (is_none (match_crule rho_2 rho_1)))
                (showsl_lit
                  "is not a root-overlap of variants of the same rule"),
              catch_errora
                (check_infeasible r (subst_list sigma_1 (snd rho_1))
                  (subst_list sigma_2 (snd rho_2)))
                (\ x ->
                  Inl (showsl_lit "could not be shown to be infeasible\n" .
                        x))])
          (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));
    })
    (\ x ->
      Inl (((showsl_lit "the " . showsl_coverlap rho_1 rho_2 p) .
             showsl_literal "\n") .
            x));

check_ao_infeasiblea ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [((Term a [Char], Term a [Char]), b)] ->
                    [(Term a [Char], Term a [Char])] ->
                      [(Term a [Char], Term a [Char])] ->
                        Ao_infeasibility_proof a [Char] ->
                          Sum (String -> String) ();
check_ao_infeasiblea r cs_1 cs_2 (AO_Infeasibility_Proof p) =
  check_infeasibleb r (cs_1 ++ cs_2) p;
check_ao_infeasiblea r cs_1 cs_2 (AO_Lhss_Equal s t u p) =
  bindb (check (membera cs_1 (s, t))
          ((showsl_eqa (s, t) . showsl_lit " is not an equation in ") .
            showsl_conditions cs_1))
    (\ _ ->
      bindb (check (membera cs_2 (s, u))
              ((showsl_eqa (s, u) . showsl_lit " is not an equation in ") .
                showsl_conditions cs_2))
        (\ _ -> check_nonjoinable (map fst r) t u p));

check_ao_infeasible ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [([(Term a [Char], Term a [Char])],
                     ([(Term a [Char], Term a [Char])],
                       Ao_infeasibility_proof a [Char]))] ->
                    [((Term a [Char], Term a [Char]),
                       [(Term a [Char], Term a [Char])])] ->
                      [(Term a [Char], Term a [Char])] ->
                        [(Term a [Char], Term a [Char])] ->
                          Sum (String -> String) ();
check_ao_infeasible css r cs_1 cs_2 =
  catch_errora
    (existsM
      (\ (cs_1a, (cs_2a, p)) ->
        let {
          cs = cs_1 ++ cs_2;
          csa = cs_1a ++ cs_2a;
        } in bindb (check
                     (equal_nat (size_list cs_1a) (size_list cs_1) &&
                       equal_nat (size_list cs_2a) (size_list cs_2))
                     (showsl_lit "lengths differ"))
               (\ _ ->
                 bindb (check
                         (not (is_none (match_rules csa cs)) &&
                           not (is_none (match_rules cs csa)))
                         id)
                   (\ _ -> check_ao_infeasiblea r cs_1a cs_2a p)))
      css)
    (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));

check_almost_orthogonal_modulo_infeasibilitya ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [([(Term a [Char], Term a [Char])],
                     ([(Term a [Char], Term a [Char])],
                       Ao_infeasibility_proof a [Char]))] ->
                    [((Term a [Char], Term a [Char]),
                       [(Term a [Char], Term a [Char])])] ->
                      Sum (String -> String) ();
check_almost_orthogonal_modulo_infeasibilitya css r =
  bindb (check_left_linear_trs (map fst r))
    (\ _ ->
      catch_errora
        (forallM
          (\ rho_1 ->
            let {
              l_1 = fst (fst rho_1);
            } in catch_errora
                   (forallM
                     (\ rho_2 ->
                       catch_errora
                         (forallM
                           (check_overlapa
                             (\ a ->
                               Char False False False True True True True
                                 False :
                                 a)
                             (\ a ->
                               Char True False False True True True True False :
                                 a)
                             (check_ao_infeasible css) r rho_1 rho_2)
                           (funposs_list l_1))
                         (\ x -> Inl (snd x)))
                     r)
                   (\ x -> Inl (snd x)))
          r)
        (\ x -> Inl (snd x)));

x_vars ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                       Nat -> Set b;
x_vars rho i =
  sup_set (vars_term (fst (fst rho)))
    (sup_seta (image vars_term (image snd (set (take i (snd rho))))));

extended_properly_oriented ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => Set ((Term a b, Term a b), [(Term a b, Term a b)]) -> Bool;
extended_properly_oriented r =
  ball r
    (\ rho ->
      less_eq_set (vars_term (snd (fst rho))) (vars_term (fst (fst rho))) ||
        not (all_interval_nat
              (not .
                (\ m ->
                  all_interval_nat
                    (\ i ->
                      less_eq_set (vars_term (fst (nth (snd rho) i)))
                        (x_vars rho i))
                    zero_nat m &&
                    all_interval_nat
                      (\ i ->
                        less_eq_set
                          (inf_set (vars_term (snd (fst rho)))
                            (vars_rule (nth (snd rho) i)))
                          (x_vars rho m))
                      m (size_list (snd rho))))
              zero_nat (suc (size_list (snd rho)))));

check_extended_properly_oriented ::
  forall a b.
    (Compare a, Eq a, Showl a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum (String -> String) ();
check_extended_properly_oriented r =
  check (extended_properly_oriented (set r))
    (showsl_lit "the given CTRS is not extended properly oriented\n");

funas_crule ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => ((Term a b, Term a b), [(Term a b, Term a b)]) -> Set (a, Nat);
funas_crule rho = sup_set (funas_rule (fst rho)) (funas_trs (set (snd rho)));

funas_ctrs ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Set ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                 Set (a, Nat);
funas_ctrs r = sup_seta (image funas_crule r);

check_constructor_term ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showl a, Compare b, Eq b,
      Showl b) => Term a b ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum (String -> String) ();
check_constructor_term s r =
  check (less_eq_set (funas_term s)
          (minus_set (funas_ctrs (set r)) (set (defined_list (map fst r)))))
    ((showsl_lit "the term " . showsl_terma s) .
      showsl_lit " is not a constructor term\n");

check_Ru_NF ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => Term a b ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum (String -> String) ();
check_Ru_NF s r =
  check (is_NF_trs (map fst r) s)
    ((showsl_lit "the term " . showsl_terma s) .
      showsl_lit " is not an Ru normal form\n");

check_linear_term ::
  forall a b.
    (Showl a, Ceq b, Ccompare b, Set_impl b,
      Showl b) => Term a b -> Sum (String -> String) ();
check_linear_term s =
  check (linear_term s)
    ((showsl_literal "the term " . showsl_terma s) .
      showsl_literal " is not linear\n");

check_right_stable ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a, Showl a, Ceq b, Ccompare b, Compare b, Eq b, Mapping_impl b,
      Set_impl b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum (String -> String) ();
check_right_stable r =
  catch_errora
    (catch_errora
      (forallM
        (\ ra ->
          catch_errora
            (forallM
              (\ i ->
                let {
                  t_i = snd (nth (snd ra) i);
                } in bindb (catch_errora
                             (check_disjoint
                               (vars_term_list (fst (fst ra)) ++
                                 concatMap (\ (s, _) -> vars_term_list s)
                                   (take (suc i) (snd ra)) ++
                                   concatMap (\ (_, a) -> vars_term_list a)
                                     (take i (snd ra)))
                               (vars_term_list t_i))
                             (\ x ->
                               Inl ((((showsl_lit "variable " . showsl x) .
                                       showsl_lit " in rhs of condition ") .
                                      showsl_nat i) .
                                     showsl_lit " is not fresh\n")))
                       (\ _ ->
                         catch_errora
                           (choice
                             [bindb (check_linear_term t_i)
                                (\ _ -> check_constructor_term t_i r),
                               bindb (check_ground_term t_i)
                                 (\ _ -> check_Ru_NF t_i r)])
                           (\ x ->
                             Inl (showsl_sep id (showsl_literal "\n") x))))
              (upt zero_nat (size_list (snd ra))))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x -> Inl (showsl_lit "the CTRS is not right stable\n" . x));

check_level_confluence_modulo_infeasibilitya ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [([(Term a [Char], Term a [Char])],
                     ([(Term a [Char], Term a [Char])],
                       Ao_infeasibility_proof a [Char]))] ->
                    [((Term a [Char], Term a [Char]),
                       [(Term a [Char], Term a [Char])])] ->
                      Sum (String -> String) ();
check_level_confluence_modulo_infeasibilitya css r =
  bindb (check_varcond_no_Var_lhs (map fst r))
    (\ _ ->
      bindb (check_type3 r)
        (\ _ ->
          bindb (check_extended_properly_oriented r)
            (\ _ ->
              bindb (check_right_stable r)
                (\ _ -> check_almost_orthogonal_modulo_infeasibilitya css r))));

trancl_of_list :: forall a. (Eq a) => [(a, a)] -> [(a, a)];
trancl_of_list xs =
  concatMap (\ x -> map (\ a -> (x, a)) (trancl_list_impl xs [x])) (map fst xs);

check_infeasiblea ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [([(Term a [Char], Term a [Char])],
                     Infeasibility_proof a [Char])] ->
                    [((Term a [Char], Term a [Char]),
                       [(Term a [Char], Term a [Char])])] ->
                      [(Term a [Char], Term a [Char])] ->
                        [(Term a [Char], Term a [Char])] ->
                          Sum (String -> String) ();
check_infeasiblea css r cs_1 cs_2 =
  catch_errora
    (existsM
      (\ (cs, p) ->
        let {
          csa = cs_1 ++ cs_2;
        } in bindb (check
                     (not (is_none (match_rules cs csa)) &&
                       not (is_none (match_rules csa cs)))
                     id)
               (\ _ -> check_infeasibleb r (trancl_of_list cs) p))
      css)
    (\ x -> Inl (showsl_sep id (showsl_literal "\n") x));

check_almost_orthogonal_modulo_infeasibility ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [([(Term a [Char], Term a [Char])],
                     Infeasibility_proof a [Char])] ->
                    [((Term a [Char], Term a [Char]),
                       [(Term a [Char], Term a [Char])])] ->
                      Sum (String -> String) ();
check_almost_orthogonal_modulo_infeasibility css r =
  bindb (check_left_linear_trs (map fst r))
    (\ _ ->
      catch_errora
        (forallM
          (\ rho_1 ->
            let {
              l_1 = fst (fst rho_1);
            } in catch_errora
                   (forallM
                     (\ rho_2 ->
                       catch_errora
                         (forallM
                           (check_overlapa
                             (\ a ->
                               Char False False False True True True True
                                 False :
                                 a)
                             (\ a ->
                               Char True False False True True True True False :
                                 a)
                             (check_infeasiblea css) r rho_1 rho_2)
                           (funposs_list l_1))
                         (\ x -> Inl (snd x)))
                     r)
                   (\ x -> Inl (snd x)))
          r)
        (\ x -> Inl (snd x)));

check_level_confluence_modulo_infeasibility ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a,
      Default a, Eq a, Set_impl a,
      Showl a) => [([(Term a [Char], Term a [Char])],
                     Infeasibility_proof a [Char])] ->
                    [((Term a [Char], Term a [Char]),
                       [(Term a [Char], Term a [Char])])] ->
                      Sum (String -> String) ();
check_level_confluence_modulo_infeasibility css r =
  bindb (check_varcond_no_Var_lhs (map fst r))
    (\ _ ->
      bindb (check_type3 r)
        (\ _ ->
          bindb (check_extended_properly_oriented r)
            (\ _ ->
              bindb (check_right_stable r)
                (\ _ -> check_almost_orthogonal_modulo_infeasibility css r))));

check_almost_orthogonal ::
  forall a.
    (Eq a,
      Showl a) => [((Term a [Char], Term a [Char]),
                     [(Term a [Char], Term a [Char])])] ->
                    Sum (String -> String) ();
check_almost_orthogonal r =
  bindb (check_left_linear_trs (map fst r))
    (\ _ ->
      catch_errora
        (forallM
          (\ rho_1 ->
            let {
              l_1 = fst (fst rho_1);
            } in catch_errora
                   (forallM
                     (\ rho_2 ->
                       catch_errora
                         (forallM
                           (check_overlapa
                             (\ a ->
                               Char False False False True True True True
                                 False :
                                 a)
                             (\ a ->
                               Char True False False True True True True False :
                                 a)
                             (\ _ _ _ ->
                               Inl (showsl_lit
                                     "infeasibility check not supported"))
                             r rho_1 rho_2)
                           (funposs_list l_1))
                         (\ x -> Inl (snd x)))
                     r)
                   (\ x -> Inl (snd x)))
          r)
        (\ x -> Inl (snd x)));

check_level_confluence ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a,
      Showl a) => [((Term a [Char], Term a [Char]),
                     [(Term a [Char], Term a [Char])])] ->
                    Sum (String -> String) ();
check_level_confluence r =
  bindb (check_varcond_no_Var_lhs (map fst r))
    (\ _ ->
      bindb (check_type3 r)
        (\ _ ->
          bindb (check_extended_properly_oriented r)
            (\ _ ->
              bindb (check_right_stable r)
                (\ _ -> check_almost_orthogonal r))));

funs_crule_list ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> [a];
funs_crule_list r = add_funs_rule (fst r) (funs_trs_list (snd r));

funs_ctrs_list ::
  forall a b. [((Term a b, Term a b), [(Term a b, Term a b)])] -> [a];
funs_ctrs_list trs = concatMap funs_crule_list trs;

check_source_preserving ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> [b]) ->
                      Sum (String -> String) ();
check_source_preserving crs zv =
  catch_errora
    (forallM
      (\ cr ->
        catch_errora
          (forallM
            (\ i ->
              catch_errora
                (catch_errora
                  (check_subseteq (vars_term_list (fst (fst cr))) (zv cr i))
                  (\ _ ->
                    Inl ((showsl_lit
                            "Some variable in lhs does not occur in Z_" .
                           showsl_nat i) .
                          showsl_lit ". \n")))
                (\ x ->
                  Inl (((showsl_lit
                           "The unraveling is not source preserving for rule " .
                          showsl_crule cr) .
                         showsl_literal "\n") .
                        x)))
            (upt zero_nat (size_list (snd cr))))
          (\ x -> Inl (snd x)))
      crs)
    (\ x -> Inl (snd x));

y_impl ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> [b];
y_impl cr i =
  vars_term_list (snd (fst cr)) ++
    vars_term_list (snd (nth (snd cr) i)) ++
      vars_trs_list (drop (suc i) (snd cr));

check_Z_vars ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> [b]) ->
                      Sum (String -> String) ();
check_Z_vars crs z =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                catch_errora
                  (bindb
                    (catch_errora
                      (check_subseteq (list_inter (x_impl cr i) (y_impl cr i))
                        (z cr i))
                      (\ x ->
                        Inl ((((showsl_lit "Variable " . showsl x) .
                                showsl_lit
                                  " does not occur in variable list of ") .
                               showsl_nat (suc i)) .
                              showsl_lit ". U-symbol\n")))
                    (\ _ ->
                      check (distinct (z cr i))
                        (showsl_lit
                          " variables in additional arguments of U-symbols are not distinct.\n")))
                  (\ x ->
                    Inl (((showsl_lit
                             "conditions for variable-lists in U-symbols for " .
                            showsl_crule cr) .
                           showsl_lit " are violated.\n") .
                          x)))
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        crs)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (showsl_lit
             "The CTRS does not fulfill the condition on Z variables.\n" .
            x));

check_U_cond ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    Nat -> Ctxt a b) ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [a] ->
                        (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                          Nat -> [b]) ->
                          Sum (String -> String) ();
check_U_cond u crs f z =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                (case u cr i of {
                  Hole -> Inl (showsl_lit " Unexpected empty context.");
                  More fa [] Hole aft ->
                    catch_errora
                      (bindb
                        (catch_errora (check_disjoint [fa] f)
                          (\ _ ->
                            Inl ((showsl_lit "The function symbol " .
                                   showsl fa) .
                                  showsl_lit " is not fresh.\n")))
                        (\ _ ->
                          bindb (check (aft == map Var (z cr i))
                                  (showsl_lit " U does not map to Z vars "))
                            (\ _ -> check_f cr i fa crs u)))
                      (\ x ->
                        Inl (((((showsl_lit "Conditions for " .
                                  showsl_crule cr) .
                                 showsl_lit " at  ") .
                                showsl_nat i) .
                               showsl_lit " are violated.\n") .
                              x));
                  More _ [] (More _ _ _ _) _ ->
                    Inl (showsl_lit " Unexpected empty context.");
                  More _ (_ : _) _ _ ->
                    Inl (showsl_lit " Unexpected empty context.");
                }))
              (upt zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        crs)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (showsl_lit
             "The CTRS does not fulfill the condition on the U symbols.\n" .
            x));

create_Umap_cr ::
  forall a b.
    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
      [(Term a b, Term a b)] ->
        Maybe [(a, (((Term a b, Term a b), [(Term a b, Term a b)]), Nat))];
create_Umap_cr cr r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      mapMa (\ (a, b) ->
              (case a of {
                (l, _) -> (\ i -> (case l of {
                                    Var _ -> Nothing;
                                    Fun _ [] -> Nothing;
                                    Fun u (_ : _) -> Just (u, (cr, i));
                                  }));
              })
                b)
        (zip rr (upt zero_nat (size_list rr)));
  });

create_Umap ::
  forall a b.
    (Eq a) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                 [(Term a b, Term a b)])] ->
                a -> Maybe (((Term a b, Term a b), [(Term a b, Term a b)]),
                             Nat);
create_Umap c_rs = (case mapMa (\ (a, b) -> create_Umap_cr a b) c_rs of {
                     Nothing -> (\ _ -> Nothing);
                     Just u -> map_of (concat u);
                   });

create_zs :: forall a b. [(Term a b, Term a b)] -> Maybe (Nat -> [b]);
create_zs r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      bind (mapMa (\ a -> (case a of {
                            (Var _, _) -> Nothing;
                            (Fun _ [], _) -> Nothing;
                            (Fun _ (_ : ts), _) -> Just (map the_Var ts);
                          }))
             rr)
        (\ cs ->
          Just (\ i -> (if less_nat i (size_list cs) then nth cs i else [])));
  });

create_Z ::
  forall a b.
    (Eq a,
      Eq b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                  [(Term a b, Term a b)])] ->
                 Maybe (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                         Nat -> [b]);
create_Z c_rs =
  bind (mapMa (\ (cr, rs) -> bind (create_zs rs) (\ zs -> Just (cr, zs))) c_rs)
    (\ cr_zs -> let {
                  mc = map_of cr_zs;
                } in Just (\ cr -> (case mc cr of {
                                     Nothing -> (\ _ -> []);
                                     Just zs -> zs;
                                   })));

check_sp_unraveling ::
  forall a b.
    (Eq a, Showl a, Ceq b, Ccompare b, Eq b, Set_impl b,
      Showl b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                     [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum (String -> String) [(Term a b, Term a b)];
check_sp_unraveling c_rs ctrs =
  catch_errora
    (bindb
      (catch_errora (check_same_set ctrs (map fst c_rs))
        (\ x ->
          Inl ((showsl_lit "did not find rule " . showsl_crule x) .
                showsl_literal "\n")))
      (\ _ ->
        bindb (case create_U c_rs of {
                Nothing ->
                  Inl (showsl_lit "unable to extract unraveling contexts");
                Just a -> Inr a;
              })
          (\ u ->
            bindb (case create_Z c_rs of {
                    Nothing -> Inl (showsl_lit "unable to extract Z variables");
                    Just a -> Inr a;
                  })
              (\ z ->
                bindb (Inr (create_Umap c_rs))
                  (\ _ ->
                    bindb (check_U_cond u ctrs (funs_ctrs_list ctrs) z)
                      (\ _ ->
                        bindb (check_Z_vars ctrs z)
                          (\ _ ->
                            bindb (check_dctrs ctrs)
                              (\ _ ->
                                bindb (check_type3 ctrs)
                                  (\ _ ->
                                    bindb (catch_errora
    (forallM
      (\ (c, rs) ->
        check (rules_impl u c == rs)
          ((showsl_lit "problem with rules of " . showsl_crule c) .
            showsl_literal "\n"))
      c_rs)
    (\ x -> Inl (snd x)))
                                      (\ _ ->
bindb (catch_errora (check_left_linear_trs (concatMap snd c_rs))
        (\ x -> Inl (showsl_lit "the unraveled TRS is not left-linear\n" . x)))
  (\ _ ->
    bindb (catch_errora (check_wf_ctrs ctrs)
            (\ x -> Inl (showsl_lit "the CTRS is not well-formed\n" . x)))
      (\ _ ->
        bindb (catch_errora (check_source_preserving ctrs z)
                (\ x ->
                  Inl (showsl_lit "unraveling is not source preserving\n" . x)))
          (\ _ -> Inr (concatMap snd c_rs))))))))))))))
    (\ x ->
      Inl (showsl_lit "preconditions on the unraveling are not satisfied\n" .
            x));

check_conditional_cr_proof ::
  forall a b c.
    (Compare_order b, Countable b, Default b, Eq b,
      Showl b) => Bool ->
                    (String -> String) ->
                      Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                          [((Term (Lab b [Nat]) [Char],
                              Term (Lab b [Nat]) [Char]),
                             [(Term (Lab b [Nat]) [Char],
                                Term (Lab b [Nat]) [Char])])] ->
                            Conditional_cr_proof b [Nat] [Char] ->
                              Sum (String -> String) ();
check_conditional_cr_proof a ia i j ctrs (Unconditional_CR prf) =
  debug ia "Unconditional"
    (bindb
      (catch_errora
        (catch_errora
          (forallM (\ x -> (if null (snd x) then Inr () else Inl x)) ctrs)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl ((showsl_lit "rule with non-empty conditions" .
                 showsl_literal "\n") .
                showsl_crule x)))
      (\ _ -> check_cr_proof a ia i j (map fst ctrs) prf));
check_conditional_cr_proof a ia i j ctrs (Unravel_CR u_info prf) =
  debug ia "Unravel"
    (bindb
      (catch_errora (check_sp_unraveling u_info ctrs)
        (\ x ->
          Inl (((ia . showsl_lit ": error in unraveling") .
                 showsl_literal "\n") .
                x)))
      (\ r ->
        catch_errora (check_cr_proof a (add_index ia one_nat) i j r prf)
          (\ x ->
            Inl (((ia . showsl_lit ": error below confluence proof") .
                   showsl_literal "\n") .
                  x))));
check_conditional_cr_proof a ia i j ctrs (Transformation_CR t prf) =
  debug ia "CR Reflecting Transformation"
    (bindb (check_ccr_trans ia ctrs t)
      (\ ctrsa -> check_conditional_cr_proof a ia i j ctrsa prf));
check_conditional_cr_proof a ia i j ctrs Almost_Orthogonal_CR =
  debug ia "Almost-Orthogonal" (check_level_confluence ctrs);
check_conditional_cr_proof a ia i j ctrs
  (Almost_Orthogonal_Modulo_Infeasibility_CR cps) =
  debug ia "Almost-Orthogonal modulo Infeasibility"
    (check_level_confluence_modulo_infeasibility cps ctrs);
check_conditional_cr_proof a ia i j ctrs
  (Almost_Orthogonal_Modulo_Infeasibility_CRa cps) =
  debug ia "Almost-Orthogonal modulo Infeasibility + meet-to-join"
    (check_level_confluence_modulo_infeasibilitya cps ctrs);
check_conditional_cr_proof a ia i j ctrs (AL94_CR qrp cj icp ucp) =
  debug ia "AL94"
    (bindb (check_quasi_reductive_proof a ia i j ctrs qrp)
      (\ _ -> check_al94 cj icp ucp ctrs));

check_fptrs_termination_proof ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          ([(Ctxt (Lab b [Nat]) [Char],
                              (Term (Lab b [Nat]) [Char], Location))],
                            [(Term (Lab b [Nat]) [Char],
                               Term (Lab b [Nat]) [Char])]) ->
                            Fptrs_termination_proof b [Nat] [Char] ->
                              Sum (String -> String) ();
check_fptrs_termination_proof ia j a i tp prf =
  check_fptrs_termination_proof_main ia j a i tp (unlab_to_split_otrs prf);

check_E_reachable ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Term a b -> Bool;
check_E_reachable e s t =
  membera (mk_rtrancl_list equal_term (rewrite e) [s]) t;

check_AC_rule ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq b) => (Term a b, Term a b) -> Bool;
check_AC_rule lr =
  (case lr of {
    (l, r) ->
      (if is_Var l then False
        else let {
               f = fst (the (root l));
             } in set_eq (funas_term l)
                    (inserta (f, nat_of_integer (2 :: Integer)) bot_set) &&
                    set_eq (funas_term r)
                      (inserta (f, nat_of_integer (2 :: Integer)) bot_set) &&
                      vars_term_ms l == vars_term_ms r &&
                        funs_term_ms l == funs_term_ms r);
  });

check_AC_theory ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showl a, Eq b,
      Showl b) => [(Term a b, Term a b)] -> Sum (String -> String) ();
check_AC_theory e =
  catch_errora
    (forallM
      (\ lr ->
        check (check_AC_rule lr)
          ((showsl_lit "rule " . showsl_rule lr) .
            showsl_lit " violates AC-property"))
      e)
    (\ x -> Inl (snd x));

check_symmetric_AC_theory ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showl a, Ccompare b, Eq b,
      Mapping_impl b,
      Showl b) => [(Term a b, Term a b)] -> Sum (String -> String) ();
check_symmetric_AC_theory e =
  bindb (check_AC_theory e)
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM
            (\ (l, r) ->
              check (check_E_reachable e r l)
                (((showsl_lit "rhs " . showsl_terma r) .
                   showsl_lit " does not rewrite to lhs ") .
                  showsl_terma l))
            e)
          (\ x -> Inl (snd x)))
        (\ x -> Inl (showsl_lit "theory is not symmetric\n" . x)));

re :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
re (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = r;

c :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [b];
c (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = c;

a :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [b];
a (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = a;

check_only_C_rule ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Eq b) => Set a -> (Term a b, Term a b) -> Bool;
check_only_C_rule oc lr =
  (case lr of {
    (Var _, _) -> True;
    (Fun _ [], _) -> True;
    (Fun _ [_], _) -> True;
    (Fun f [s, t], r) ->
      (if member f oc then equal_term r (Fun f [t, s]) else True);
    (Fun _ (_ : _ : _ : _), _) -> True;
  });

check_only_C_theory ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Showl a, Eq b,
      Showl b) => Set a -> [(Term a b, Term a b)] -> Sum (String -> String) ();
check_only_C_theory oc e =
  catch_errora
    (forallM
      (\ lr ->
        check (check_only_C_rule oc lr)
          ((showsl_lit "rule " . showsl_rule lr) .
            showsl_lit " violates only-C-property"))
      e)
    (\ x -> Inl (snd x));

check_AC_same_as_E ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Showl a, Ceq b, Ccompare b, Eq b,
      Set_impl b,
      Showl b) => a -> a -> a -> [b] ->
                                   [b] ->
                                     [(Term b a, Term b a)] ->
                                       Sum (String -> String) ();
check_AC_same_as_E x y z a c e =
  catch_errora
    (let {
       xa = Var x;
       ya = Var y;
       za = Var z;
     } in bindb (catch_errora
                  (catch_errora
                    (forallM
                      (\ f ->
                        check (check_E_reachable e (Fun f [xa, ya])
                                (Fun f [ya, xa]))
                          f)
                      c)
                    (\ xb -> Inl (snd xb)))
                  (\ xb ->
                    Inl ((showsl_lit "could not simulate C-rules for " .
                           showsl xb) .
                          showsl_lit " by E")))
            (\ _ ->
              bindb (catch_errora
                      (catch_errora
                        (forallM
                          (\ f ->
                            check (check_E_reachable e
                                    (Fun f [xa, Fun f [ya, za]])
                                    (Fun f [Fun f [xa, ya], za]))
                              f)
                          a)
                        (\ xb -> Inl (snd xb)))
                      (\ xb ->
                        Inl ((showsl_lit "could not simulate A-rules for " .
                               showsl xb) .
                              showsl_lit " by E")))
                (\ _ ->
                  bindb (catch_errora
                          (catch_errora
                            (forallM
                              (\ f ->
                                check (check_E_reachable e
(Fun f [Fun f [xa, ya], za]) (Fun f [xa, Fun f [ya, za]]))
                                  f)
                              a)
                            (\ xb -> Inl (snd xb)))
                          (\ xb ->
                            Inl ((showsl_lit "could not simulate A-rules for " .
                                   showsl xb) .
                                  showsl_lit " by E")))
                    (\ _ ->
                      catch_errora
                        (catch_errora
                          (forallM
                            (\ (l, r) ->
                              check (equal_acterm (aocnf (set a) (set c) l)
                                      (aocnf (set a) (set c) r))
                                (l, r))
                            e)
                          (\ xb -> Inl (snd xb)))
                        (\ xb ->
                          Inl ((showsl_lit "equation " . showsl_rule xb) .
                                showsl_lit " is not AC-equivalent"))))))
    (\ xa ->
      Inl (showsl_lit
             "could not ensure that equations simulate AC-equivalence\n" .
            xa));

check_ext_rule3 ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Eq b) => (Term a b, Term a b) ->
                 a -> Set b -> (Term a b, Term a b) -> Bool;
check_ext_rule3 (la, ra) f xb
  (Fun ga [Fun ha [Var xa, l], Var ya], Fun g [Fun h [Var x, r], Var y]) =
  (la, (ra, (f, (f, (f, (f, (xa, ya))))))) ==
    (l, (r, (ga, (g, (ha, (h, (x, y))))))) &&
    not (x == y) && not (member x xb) && not (member y xb);
check_ext_rule3 uu uv uw (Var vb, va) = False;
check_ext_rule3 uu uv uw (Fun vb [], va) = False;
check_ext_rule3 uu uv uw (Fun vb (Var vf : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf [] : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf (Fun vj vk : vi) : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf [vh] : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb (Fun vf (vh : vj : vl : vm) : ve), va) = False;
check_ext_rule3 uu uv uw (Fun vb [vd], va) = False;
check_ext_rule3 uu uv uw (Fun vb (vd : Fun vh vi : vg), va) = False;
check_ext_rule3 uu uv uw (Fun vb (vd : vf : vh : vi), va) = False;
check_ext_rule3 uu uv uw (v, Var vb) = False;
check_ext_rule3 uu uv uw (v, Fun vb []) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Var vf : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf [] : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf (Fun vj vk : vi) : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf [vh] : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (Fun vf (vh : vj : vl : vm) : ve)) = False;
check_ext_rule3 uu uv uw (v, Fun vb [vd]) = False;
check_ext_rule3 uu uv uw (v, Fun vb (vd : Fun vh vi : vg)) = False;
check_ext_rule3 uu uv uw (v, Fun vb (vd : vf : vh : vi)) = False;

check_ext_rule2 ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Eq b) => (Term a b, Term a b) ->
                 a -> Set b -> (Term a b, Term a b) -> Bool;
check_ext_rule2 (la, ra) f xb (Fun ga [Var xa, l], Fun g [Var x, r]) =
  (la, (ra, (f, (f, xa)))) == (l, (r, (ga, (g, x)))) && not (member xa xb);
check_ext_rule2 uu uv uw (Var vb, va) = False;
check_ext_rule2 uu uv uw (Fun vb [], va) = False;
check_ext_rule2 uu uv uw (Fun vb (Fun vf vg : ve), va) = False;
check_ext_rule2 uu uv uw (Fun vb [vd], va) = False;
check_ext_rule2 uu uv uw (Fun vb (vd : vf : vh : vi), va) = False;
check_ext_rule2 uu uv uw (v, Var vb) = False;
check_ext_rule2 uu uv uw (v, Fun vb []) = False;
check_ext_rule2 uu uv uw (v, Fun vb (Fun vf vg : ve)) = False;
check_ext_rule2 uu uv uw (v, Fun vb [vd]) = False;
check_ext_rule2 uu uv uw (v, Fun vb (vd : vf : vh : vi)) = False;

check_ext_rule1 ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Eq b) => (Term a b, Term a b) ->
                 a -> Set b -> (Term a b, Term a b) -> Bool;
check_ext_rule1 (la, ra) f xb (Fun ga [l, Var xa], Fun g [r, Var x]) =
  (la, (ra, (f, (f, xa)))) == (l, (r, (ga, (g, x)))) && not (member xa xb);
check_ext_rule1 uu uv uw (Var vb, va) = False;
check_ext_rule1 uu uv uw (Fun vb [], va) = False;
check_ext_rule1 uu uv uw (Fun vb [vd], va) = False;
check_ext_rule1 uu uv uw (Fun vb (vd : Fun vh vi : vg), va) = False;
check_ext_rule1 uu uv uw (Fun vb (vd : vf : vh : vi), va) = False;
check_ext_rule1 uu uv uw (v, Var vb) = False;
check_ext_rule1 uu uv uw (v, Fun vb []) = False;
check_ext_rule1 uu uv uw (v, Fun vb [vd]) = False;
check_ext_rule1 uu uv uw (v, Fun vb (vd : Fun vh vi : vg)) = False;
check_ext_rule1 uu uv uw (v, Fun vb (vd : vf : vh : vi)) = False;

check_ext_rule ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       Set a -> Set a -> (Term a b, Term a b) -> Bool;
check_ext_rule rext a c lr =
  (case lr of {
    (l, _) ->
      (if is_Var l ||
            (not (equal_nat (size_list (args l))
                   (nat_of_integer (2 :: Integer))) ||
              not (member (fst (the (root l))) a))
        then True
        else let {
               f = fst (the (root l));
               x = vars_rule lr;
             } in any (check_ext_rule1 lr f x) rext &&
                    (if not (member f c)
                      then any (check_ext_rule2 lr f x) rext &&
                             any (check_ext_rule3 lr f x) rext
                      else True));
  });

check_ext_trs ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Showl a, Finite_UNIV b,
      Cenum b, Ceq b, Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showl b) => [(Term a b, Term a b)] ->
                    [a] ->
                      [a] ->
                        [(Term a b, Term a b)] -> Sum (String -> String) ();
check_ext_trs r a c rext =
  let {
    aa = set a;
    ca = set c;
  } in catch_errora
         (catch_errora
           (forallM
             (\ lr ->
               check (check_ext_rule rext aa ca lr)
                 (((showsl_lit
                      "could not find extended rules for rule l -> r:\n  " .
                     showsl_rule lr) .
                    showsl_lit
                      "\n  expecting rule f(l,x) -> f(r,x) for all A and AC symbols,\n") .
                   showsl_lit
                     "and rules f(x,l) -> f(x,r) and f(f(x,l),y) -> f(f(x,r),y) for all A symbols"))
             r)
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (showsl_lit "could not ensure validity of AC-extended system\n" .
                 x));

ac_dependency_pairs_checks ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showl b,
      Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showl c) => Ac_tp_ops_ext a b c () ->
                    (b -> b) ->
                      c -> c -> c -> Ac_dependency_pairs_proof b c ->
                                       a -> Sum (String -> String) ();
ac_dependency_pairs_checks i shp x y z
  (AC_dependency_pairs_proof e dpr dpe rext) tp =
  catch_errora
    (let {
       aa = a i tp;
       ca = c i tp;
       r = re i tp;
       oc = list_diff ca aa;
       d = defined_list r;
       _ = set d;
       da = defined_list (r ++ e);
     } in bindb (catch_errora
                  (forallM
                    (\ (f, n) ->
                      check (not (membera da (shp f, n)))
                        (((showsl_lit "sharping " . showsl f) .
                           showsl_lit " yields the defined symbol ") .
                          showsl (shp f)))
                    da)
                  (\ xa -> Inl (snd xa)))
            (\ _ ->
              bindb (catch_errora (check_wf_trs (r ++ e))
                      (\ xa ->
                        Inl (showsl_lit "TRS or equations are not well-formed" .
                              xa)))
                (\ _ ->
                  bindb (catch_errora (check_symmetric_AC_theory e)
                          (\ xa ->
                            Inl (showsl_lit
                                   "equations do not form a symmetric AC-theory\n" .
                                  xa)))
                    (\ _ ->
                      bindb (catch_errora (check_only_C_theory (set oc) e)
                              (\ xa ->
                                Inl (showsl_lit
                                       "equations do not form AC_C-theory\n" .
                                      xa)))
                        (\ _ ->
                          bindb (catch_errora
                                  (check_subseteq (funs_trs_list e) (aa ++ ca))
                                  (\ xa ->
                                    Inl ((showsl_lit
    "equations contain symbol " .
   showsl xa) .
  showsl_lit " which is not AC-symbol")))
                            (\ _ ->
                              bindb (catch_errora
                                      (check_AC_same_as_E x y z aa ca e)
                                      (\ xa ->
Inl (showsl_lit
       "could not ensure that equations correspond to AC equivalence\n" .
      xa)))
                                (\ _ ->
                                  bindb (catch_errora
  (check_subseteq (dP_list shp r d) dpr)
  (\ xa -> Inl (showsl_lit "could not find DP for R: " . showsl_rule xa)))
                                    (\ _ ->
                                      bindb
(catch_errora (check_subseteq (dP_list shp e d) dpe)
  (\ xa -> Inl (showsl_lit "could not find DP for E: " . showsl_rule xa)))
(\ _ ->
  catch_errora (check_ext_trs r aa ca rext)
    (\ xa ->
      Inl (showsl_lit "could not ensure validity of extended TRS R_ext\n" .
            xa)))))))))))
    (\ xa -> Inl (showsl_lit "problem in applying AC-dependency pairs\n" . xa));

mkf ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d ->
      [(Term b c, Term b c)] ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] ->
            [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkf (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
      reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
      eq_rules_non_collapsing intersect_pairs more)
  = mk;

ac_dependency_pairs_proc_simple ::
  forall a b c d.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showl b,
      Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showl c) => Ac_tp_ops_ext a b c () ->
                    Ac_dpp_ops_ext d b c () ->
                      (b -> b) ->
                        c -> c -> c -> Ac_dependency_pairs_proof b c ->
 a -> Sum (String -> String) d;
ac_dependency_pairs_proc_simple i j shp x y z
  (AC_dependency_pairs_proof e dpr dpe rext) tp =
  bindb (ac_dependency_pairs_checks i shp x y z
          (AC_dependency_pairs_proof e dpr dpe rext) tp)
    (\ _ ->
      let {
        r = re i tp;
      } in Inr (mkf j
                 (dpr ++
                   map (\ (l, ra) -> (sharp_term shp l, sharp_term shp ra))
                     rext)
                 dpe [] r e));

delete_pairs_rulesa ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_pairs_rulesa
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = delete_pairs_rules;

eq_rules_map ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
eq_rules_map
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = eq_rules_map;

rulesg :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulesg
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = rules;

pairsc :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pairsc
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = pairs;

rwe :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwe (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
      reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
      eq_rules_non_collapsing intersect_pairs more)
  = rw;

rf :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rf (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
     reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
     eq_rules_non_collapsing intersect_pairs more)
  = r;

ec :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
ec (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
     reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
     eq_rules_non_collapsing intersect_pairs more)
  = e;

ac_mono_ur_redpair_proc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showl b,
      Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showl c) => Ac_dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          [(Term b c, Term b c)] ->
                            a -> Sum (String -> String) a;
ac_mono_ur_redpair_proc i rp p_remove r_remove ur dpp =
  (case catch_errora
          (let {
             p = pairsc i dpp;
             _ = rulesg i dpp;
             e = ec i dpp;
             premove = set p_remove;
             rremove = set r_remove;
             us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
             filt = (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
           } in (case partition (\ lr -> member lr premove && filt lr) p of {
                  (ps, pns) ->
                    (case partition (\ lr -> member lr rremove && filt lr) ur of
                      {
                      (urs, urns) ->
                        let {
                          rm = eq_rules_map i dpp;
                        } in bindb (valid rp)
                               (\ _ ->
                                 bindb (mono rp (ps ++ urs ++ urns ++ pns))
                                   (\ _ ->
                                     bindb (catch_errora
     (check_symmetric_AC_theory e)
     (\ x -> Inl (showsl_lit "usable rules demand symmetric AC theory\n" . x)))
                                       (\ _ ->
 bindb (catch_errora
         (forallM
           (\ (l, _) ->
             check (not (is_Var l))
               (showsl_lit "variables as lhss not allowed"))
           (rf i dpp ++ rwe i dpp))
         (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (check_ur_P_closed_rm_af rm ur full_af p)
       (\ _ ->
         bindb (catch_errora
                 (catch_errora (forallM (ns rp) urns) (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (showsl_lit "problem when orienting usable rules\n" .
                         x)))
           (\ _ ->
             bindb (catch_errora
                     (catch_errora (forallM (s rp) urs) (\ x -> Inl (snd x)))
                     (\ x ->
                       Inl (showsl_lit "problem when orienting usable rules\n" .
                             x)))
               (\ _ ->
                 bindb (catch_errora
                         (catch_errora (forallM (ns rp) pns)
                           (\ x -> Inl (snd x)))
                         (\ x ->
                           Inl (showsl_lit "problem when orienting DPs\n" . x)))
                   (\ _ ->
                     catch_errora
                       (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
                       (\ x ->
                         Inl (showsl_lit "problem when orienting DPs\n" .
                               x))))))))));
                    });
                }))
          (\ x ->
            Inl (((showsl_lit
                     "could not apply the monotonic AC reduction pair processor with usable rules and the following\n" .
                    desca rp) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_pairs_rulesa i dpp p_remove r_remove);
  });

pwc :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pwc (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
      reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
      eq_rules_non_collapsing intersect_pairs more)
  = pw;

pc :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pc (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
     reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
     eq_rules_non_collapsing intersect_pairs more)
  = p;

ac_dpp_trivial_check ::
  forall a b c. Ac_dpp_ops_ext a b c () -> a -> Sum (String -> String) ();
ac_dpp_trivial_check i dpp =
  bindb (check (null (pc i dpp)) (showsl_lit "there are strict pairs"))
    (\ _ ->
      check (null (pwc i dpp) || null (rf i dpp))
        (showsl_lit "there are weak pairs and strict rules"));

ac_ur_redpair_proc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showl b,
      Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showl c) => Ac_dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] -> a -> Sum (String -> String) a;
ac_ur_redpair_proc i rp p_remove ur dpp =
  (case catch_errora
          (let {
             p = pairsc i dpp;
             _ = rulesg i dpp;
             e = ec i dpp;
             premove = set p_remove;
           } in (case partition (\ lr -> member lr premove) p of {
                  (ps, pns) ->
                    let {
                      rm = eq_rules_map i dpp;
                      pi = af rp;
                    } in bindb (valid rp)
                           (\ _ ->
                             bindb (catch_errora (check_symmetric_AC_theory e)
                                     (\ x ->
                                       Inl
 (showsl_lit "usable rules demand symmetric AC theory\n" . x)))
                               (\ _ ->
                                 bindb (catch_errora
 (forallM
   (\ (l, _) ->
     check (not (is_Var l)) (showsl_lit "variables as lhss not allowed"))
   (rf i dpp ++ rwe i dpp))
 (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (check_ur_P_closed_rm_af rm ur pi p)
                                       (\ _ ->
 bindb (catch_errora (catch_errora (forallM (ns rp) ur) (\ x -> Inl (snd x)))
         (\ x -> Inl (showsl_lit "problem when orienting usable rules\n" . x)))
   (\ _ ->
     bindb (catch_errora
             (catch_errora (forallM (nst rp) pns) (\ x -> Inl (snd x)))
             (\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x)))
       (\ _ ->
         catch_errora (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
           (\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x))))))));
                }))
          (\ x ->
            Inl (((showsl_lit
                     "could not apply the AC reduction pair processor with usable rules and the following\n" .
                    desca rp) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_pairs_rulesa i dpp p_remove []);
  });

check_size_preserving_trs ::
  forall a b.
    (Showl a, Eq b,
      Showl b) => [(Term a b, Term a b)] -> Sum (String -> String) ();
check_size_preserving_trs e =
  catch_errora
    (catch_errora
      (forallM
        (\ (l, r) ->
          check (equal_nat (num_symbs l) (num_symbs r) &&
                  vars_term_ms l == vars_term_ms r)
            ((showsl_lit "rule " . showsl_rule (l, r)) .
              showsl_lit " is not size preserving"))
        e)
      (\ x -> Inl (snd x)))
    (\ x -> Inl (showsl_lit "TRS is not size-preserving\n" . x));

ac_subterm_proc ::
  forall a b c.
    (Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showl b, Compare c, Eq c,
      Showl c) => Ac_dpp_ops_ext a b c () ->
                    [((b, Nat), [Nat])] ->
                      [(Term b c, Term b c)] -> a -> Sum (String -> String) a;
ac_subterm_proc i pi p_remove dpp =
  (case catch_errora
          (let {
             p = pairsc i dpp;
             r = rulesg i dpp;
             e = ec i dpp;
             re = r ++ e;
             f = map fst pi;
             ff = set f;
             pi_opt = status_of pi;
           } in bindb (check (not (is_none pi_opt))
                        (showsl_lit "argument filter lists invalid positions"))
                  (\ _ ->
                    let {
                      pia = the pi_opt;
                      premove = set p_remove;
                    } in (case partition (\ lr -> member lr premove) p of {
                           (ps, pns) ->
                             bindb (catch_errora
                                     (forallM
                                       (\ fa ->
 check (not (null (status pia fa)))
   ((showsl_lit "status of symbol " . showsl_prod fa) .
     showsl_lit " in F must be non-empty"))
                                       f)
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 bindb (catch_errora
 (check_size_preserving_trs e)
 (\ x -> Inl (showsl_lit "E is not size preserving\n" . x)))
                                   (\ _ ->
                                     bindb (catch_errora
     (forallM
       (\ (l, _) ->
         check (not (is_Var l)) (showsl_lit "variables as lhss not allowed"))
       re)
     (\ x -> Inl (snd x)))
                                       (\ _ ->
 bindb (catch_errora
         (catch_errora
           (forallM (check_supteqproj_pred pia ff)
             (filter (\ lr -> member (the (root (fst lr))) ff) re))
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (showsl_lit "problem when orienting rules with root in F\n" .
                 x)))
   (\ _ ->
     bindb (catch_errora
             (catch_errora (forallM (check_supteqproj_pred pia ff) pns)
               (\ x -> Inl (snd x)))
             (\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x)))
       (\ _ ->
         catch_errora
           (catch_errora (forallM (check_suptproj_pred pia ff) ps)
             (\ x -> Inl (snd x)))
           (\ x -> Inl (showsl_lit "problem when orienting DPs\n" . x)))))));
                         })))
          (\ x ->
            Inl (showsl_lit "could not apply the AC subterm processor\n" . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_pairs_rulesa i dpp p_remove []);
  });

intersect_pairsc ::
  forall a b c d. Ac_dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_pairsc
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = intersect_pairs;

graph_approx_edg_rt_sym ::
  forall a b c d e.
    (Ccompare a,
      Eq a) => Multimap (Maybe (a, Nat)) b -> (c, (d, Gctxt a e)) -> [b];
graph_approx_edg_rt_sym m (uu, (uv, ct)) = graph_approx_rt_sym_main m ct;

eq_rules_non_collapsinga :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> Bool;
eq_rules_non_collapsinga
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = eq_rules_non_collapsing;

reverse_eq_rules_map ::
  forall a b c d.
    Ac_dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
reverse_eq_rules_map
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = reverse_eq_rules_map;

reverse_tcapRM_ac_dpp ::
  forall a b c.
    (Eq b, Eq c) => Ac_dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
reverse_tcapRM_ac_dpp i dpp =
  tcapRM (eq_rules_non_collapsinga i dpp) (reverse_eq_rules_map i dpp);

eq_rules_no_left_vara :: forall a b c d. Ac_dpp_ops_ext a b c d -> a -> Bool;
eq_rules_no_left_vara
  (Ac_dpp_ops_ext ac_dpp p pw pairs r rw rules e mk eq_rules_map
    reverse_eq_rules_map delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairs more)
  = eq_rules_no_left_var;

tcapRM_ac_dpp ::
  forall a b c.
    (Eq b, Eq c) => Ac_dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
tcapRM_ac_dpp i dpp = tcapRM (eq_rules_no_left_vara i dpp) (eq_rules_map i dpp);

check_ac_dep_graph_proc ::
  forall a b c.
    (Ccompare b, Compare_order b, Eq b, Mapping_impl b,
      Showl b) => Ac_dpp_ops_ext a b [Char] () ->
                    a -> [(Maybe c, [(Term b [Char], Term b [Char])])] ->
                           Sum (String -> String) ();
check_ac_dep_graph_proc i dpp dps =
  let {
    c = tcapRM_ac_dpp i dpp;
    rc = reverse_tcapRM_ac_dpp i dpp;
    p = pairsc i dpp;
  } in bindb (catch_errora (check_subseteq p (concatMap snd dps))
               (\ x ->
                 Inl (((showsl_lit "Dependency Pair " . showsl_rule x) .
                        showsl_lit " is missing in decomposition") .
                       showsl_literal "\n")))
         (\ _ ->
           catch_errora
             (check_graph_decomp (showsl_prod . fst)
               (emptyd ((root . fst) . fst)) graph_approx_edg_rt_sym insertd
               (\ (a, b) ->
                 (case a of {
                   (aa, ba) ->
                     (case aa of {
                       (_, t) ->
                         (\ (_, ct) (ab, bb) ->
                           (case ab of {
                             (u, _) ->
                               (\ (cu, _) -> matchb ct u && matchb cu t);
                           })
                             bb);
                     })
                       ba;
                 })
                   b)
               (map (\ (real, cs) ->
                      (not (is_none real),
                        map (\ (s, t) -> ((s, t), (rc s, c t))) cs))
                 dps))
             (\ x ->
               Inl (((showsl_lit
                        "our estimation (EDG***) could not show that you have a valid decomposition " .
                       showsl_lit "due to the following reason") .
                      showsl_literal "\n") .
                     x)));

ac_dep_graph_proc ::
  forall a b c.
    (Ccompare b, Compare_order b, Eq b, Mapping_impl b,
      Showl b) => Ac_dpp_ops_ext a b [Char] () ->
                    a -> [(Maybe c, [(Term b [Char], Term b [Char])])] ->
                           Sum (String -> String) [(c, a)];
ac_dep_graph_proc i d dps =
  (case check_ac_dep_graph_proc i d dps of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (map_filter
            (\ x ->
              (if not (is_none (fst x))
                then Just (the (fst x), intersect_pairsc i d (snd x))
                else Nothing))
            dps);
  });

showsl_ac_dpp ::
  forall a b c.
    (Showl b, Showl c) => Ac_dpp_ops_ext a b c () -> a -> String -> String;
showsl_ac_dpp i d =
  let {
    p = pc i d;
    pw = pwc i d;
    r = rf i d;
    rw = rwe i d;
    e = ec i d;
  } in ((((if null p then id else showsl_trsa showsl showsl "pairs:" " -> " p) .
           (if null pw then id
             else showsl_trsa showsl showsl "weak pairs:" " ->= " pw)) .
          (if null r then id
            else showsl_trsa showsl showsl "strict rules:" " ->! " r)) .
         (if null rw then id
           else showsl_trsa showsl showsl "rules:" " -> " rw)) .
         (if null e then id
           else showsl_trsa showsl showsl "equations:" " -> " e);

check_ac_dp_termination_proof ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b, Mapping_impl b,
      Set_impl b,
      Showl b) => Ac_dpp_ops_ext a b [Char] () ->
                    (String -> String) ->
                      a -> Ac_dp_termination_proof b [Char] ->
                             Sum (String -> String) ();
check_ac_dp_termination_proof ia i dpp AC_P_is_Empty =
  debug i "P is empty"
    (catch_errora (ac_dpp_trivial_check ia dpp)
      (\ x ->
        Inl (((i . showsl_lit "problem in applying trivial check on\n") .
               showsl_ac_dpp ia dpp) .
              x)));
check_ac_dp_termination_proof ia i dpp (AC_Redpair_UR_Proc redp del_p ur prf) =
  debug i "AC_Redpair_UR_Proc"
    (bindb
      (catch_errora (ac_ur_redpair_proc ia (get_redtriple redp) del_p ur dpp)
        (\ x ->
          Inl ((((((i . showsl_lit
                          ": error when applying AC-reduction pair processor to DP problem\n") .
                    showsl_ac_dpp ia dpp) .
                   showsl_lit "\nand trying to remove pairs\n") .
                  showsl_rules del_p) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_ac_dp_termination_proof ia (add_index i one_nat) dppa prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below AC-reduction pair processor\n") .
                  x))));
check_ac_dp_termination_proof ia i dpp (AC_Subterm_Proc pi del_p prf) =
  debug i "AC_Subterm_Proc"
    (bindb
      (catch_errora (ac_subterm_proc ia pi del_p dpp)
        (\ x ->
          Inl ((((((i . showsl_lit
                          ": error when applying AC-subterm criterion processor to DP problem\n") .
                    showsl_ac_dpp ia dpp) .
                   showsl_lit "\nand trying to remove pairs\n") .
                  showsl_rules del_p) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_ac_dp_termination_proof ia (add_index i one_nat) dppa prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below AC-reduction pair processor\n") .
                  x))));
check_ac_dp_termination_proof ia i dpp
  (AC_Mono_Redpair_UR_Proc redp del_p del_r ur prf) =
  debug i "AC_Mono_Redpair_UR_Proc"
    (bindb
      (catch_errora
        (ac_mono_ur_redpair_proc ia (get_redtriple redp) del_p del_r ur dpp)
        (\ x ->
          Inl ((((((((i . showsl_lit
                            ": error when applying monotone AC-reduction pair processor to DP problem\n") .
                      showsl_ac_dpp ia dpp) .
                     showsl_lit "\nand trying to remove pairs\n") .
                    showsl_rules del_p) .
                   showsl_lit "\nand rules\n") .
                  showsl_rules del_r) .
                 showsl_literal "\n") .
                x)))
      (\ dppa ->
        catch_errora
          (check_ac_dp_termination_proof ia (add_index i one_nat) dppa prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below monotone AC-reduction pair processor\n") .
                  x))));
check_ac_dp_termination_proof ia i dpp (AC_Dep_Graph_Proc edpts) =
  debug i "Dep_Graph_Proc"
    (bindb
      (catch_errora (ac_dep_graph_proc ia dpp edpts)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error while trying to perform Sctxt_closure-decomposition  on\n") .
                  showsl_ac_dpp ia dpp) .
                 showsl_literal "\n") .
                x)))
      (\ pdpps ->
        catch_errora
          (catch_errora
            (forallM_index
              (\ (prof, dppa) j ->
                check_ac_dp_termination_proof ia (add_index i (suc j)) dppa
                  prof)
              pdpps)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the dependency graph processor\n") .
                  x))));

ac_dependency_pairs_proc ::
  forall a b c d.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showl b,
      Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showl c) => Ac_tp_ops_ext a b c () ->
                    Ac_dpp_ops_ext d b c () ->
                      (b -> b) ->
                        c -> c -> c -> Ac_dependency_pairs_proof b c ->
 a -> Sum (String -> String) (d, d);
ac_dependency_pairs_proc i j shp x y z
  (AC_dependency_pairs_proof e dpr dpe rext) tp =
  bindb (ac_dependency_pairs_checks i shp x y z
          (AC_dependency_pairs_proof e dpr dpe rext) tp)
    (\ _ ->
      let {
        r = re i tp;
      } in Inr (mkf j dpr dpe [] r e,
                 mkf j (map (\ (l, ra) -> (sharp_term shp l, sharp_term shp ra))
                         rext)
                   dpe [] r e));

delete_rulesa ::
  forall a b c d. Ac_tp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
delete_rulesa (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = delete_rules;

eb :: forall a b c d. Ac_tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
eb (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = e;

ac_rule_removal ::
  forall a b c.
    (Compare b, Eq b, Showl b, Compare c, Eq c,
      Showl c) => Ac_tp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] -> a -> Sum (String -> String) a;
ac_rule_removal i rp r_remove tp =
  (case catch_errora
          (let {
             r = re i tp;
             e = eb i tp;
             rremove = set r_remove;
             rns = filter (\ lr -> not (member lr rremove)) r;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (mono rp (r_remove ++ rns ++ e))
                      (\ _ ->
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (showsl_lit
 "problem when orienting weak rules\n" .
x)))
                          (\ _ ->
                            bindb (catch_errora
                                    (catch_errora (forallM (ns rp) e)
                                      (\ x -> Inl (snd x)))
                                    (\ x ->
                                      Inl
(showsl_lit "problem when orienting equations\n" . x)))
                              (\ _ ->
                                catch_errora
                                  (catch_errora (forallM (s rp) r_remove)
                                    (\ x -> Inl (snd x)))
                                  (\ x ->
                                    Inl (showsl_lit
   "problem when orienting strict rules\n" .
  x)))))))
          (\ x ->
            Inl (((showsl_lit
                     "could not apply AC rule removal with the following\n" .
                    desca rp) .
                   showsl_literal "\n") .
                  x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_rulesa i tp r_remove);
  });

showsl_ac_tp ::
  forall a b c.
    (Showl b, Showl c) => Ac_tp_ops_ext a b c () -> a -> String -> String;
showsl_ac_tp i t =
  let {
    r = re i t;
    aa = a i t;
    ca = c i t;
  } in (showsl_trsa showsl showsl "rules:" " -> " r .
         (if null aa then id
           else (showsl_lit "A-symbols: " . showsl_lista aa) .
                  showsl_literal "\n")) .
         (if null ca then id
           else (showsl_lit "C-symbols: " . showsl_lista ca) .
                  showsl_literal "\n");

check_ac_termination_proof ::
  forall a b c d.
    (Compare_order b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Ac_dpp_ops_ext a (Lab b c) [Char] () ->
                    Ac_tp_ops_ext d (Lab b c) [Char] () ->
                      (String -> String) ->
                        d -> Ac_termination_proof b c [Char] ->
                               Sum (String -> String) ();
check_ac_termination_proof ia j i tp (AC_DP_Trans info prf1 prf2) =
  debug i "AC Dependency Pairs"
    (bindb
      (catch_errora
        (ac_dependency_pairs_proc j ia Sharp
          [Char False False False True True True True False]
          [Char True False False True True True True False]
          [Char False True False True True True True False] info tp)
        (\ x ->
          Inl (((i . showsl_lit
                       ": error when applying AC-dependency pair processor to\n") .
                 showsl_ac_tp j tp) .
                x)))
      (\ (dp1, dp2) ->
        bindb (catch_errora
                (check_ac_dp_termination_proof ia (add_index i one_nat) dp1
                  prf1)
                (\ x ->
                  Inl ((i . showsl_lit
                              ": error below AC-dependency pair processor\n") .
                        x)))
          (\ _ ->
            catch_errora
              (check_ac_dp_termination_proof ia
                (add_index i (nat_of_integer (2 :: Integer))) dp2 prf2)
              (\ x ->
                Inl ((i . showsl_lit
                            ": error below AC-dependency pair processor\n") .
                      x)))));
check_ac_termination_proof ia j i tp (AC_DP_Trans_Single info prf1) =
  debug i "AC Dependency Pairs"
    (bindb
      (catch_errora
        (ac_dependency_pairs_proc_simple j ia Sharp
          [Char False False False True True True True False]
          [Char True False False True True True True False]
          [Char False True False True True True True False] info tp)
        (\ x ->
          Inl (((i . showsl_lit
                       ": error when applying AC-dependency pair processor to\n") .
                 showsl_ac_tp j tp) .
                x)))
      (\ dp1 ->
        catch_errora
          (check_ac_dp_termination_proof ia (add_index i one_nat) dp1 prf1)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below AC-dependency pair processor\n") .
                  x))));
check_ac_termination_proof ia j i tp (AC_Rule_Removal redp del_r prf) =
  debug i "AC_Mono_Redpair_UR_Proc"
    (bindb
      (catch_errora (ac_rule_removal j (get_redtriple redp) del_r tp)
        (\ x ->
          Inl ((((((i . showsl_lit
                          ": error when applying AC rule removal to AC termination problem\n") .
                    showsl_ac_tp j tp) .
                   showsl_lit "\ntrying to remove rules\n") .
                  showsl_rules del_r) .
                 showsl_literal "\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_ac_termination_proof ia j (add_index i one_nat) tpa prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below AC rule removal\n") . x))));
check_ac_termination_proof ia j i tp AC_R_is_Empty =
  debug i "AC_R_is_Empty"
    (catch_errora (check (null (re j tp)) (showsl_lit "The TRS is not empty"))
      (\ x ->
        Inl ((((i . showsl_lit
                      ": error when applying the R-is-Empty check on the AC termination problem\n") .
                showsl_ac_tp j tp) .
               showsl_literal "\n") .
              x)));

equal_strategy ::
  forall a b. (Eq a, Eq b) => Strategy a b -> Strategy a b -> Bool;
equal_strategy Innermost (Innermost_Q x3) = False;
equal_strategy (Innermost_Q x3) Innermost = False;
equal_strategy No_Strategy (Innermost_Q x3) = False;
equal_strategy (Innermost_Q x3) No_Strategy = False;
equal_strategy No_Strategy Innermost = False;
equal_strategy Innermost No_Strategy = False;
equal_strategy (Innermost_Q x3) (Innermost_Q y3) = x3 == y3;
equal_strategy Innermost Innermost = True;
equal_strategy No_Strategy No_Strategy = True;

showsl_transition ::
  forall a b c d.
    (Showl d) => (Term a (Trans_var b, c) -> String -> String) ->
                   Transition_rule a b c d -> String -> String;
showsl_transition showsl_tatom (Transition s t phi) =
  (((showsl s . showsl_lit " ---> ") . showsl t) . showsl_lit ": ") .
    showsl_formula showsl_tatom phi;

transition_hintsa :: forall a b c d e. Hinter_ext a b c d e -> c -> Maybe [a];
transition_hintsa
  (Hinter_ext nodes succ_trans_list cover_hints transition_hints more) =
  transition_hints;

node_invariant ::
  forall a b c d e f. Art_ext a b c d e f -> e -> Formula (Term a (b, c));
node_invariant
  (Art_ext initial_nodes nodes edge node_location node_invariant more) =
  node_invariant;

rename_vars_exp :: forall a b c d. (a -> b) -> Term c (a, d) -> Term c (b, d);
rename_vars_exp r = map_term id (map_prod r id);

nodesa :: forall a b c d e. Hinter_ext a b c d e -> [c];
nodesa (Hinter_ext nodes succ_trans_list cover_hints transition_hints more) =
  nodes;

map_formula :: forall a b. (a -> b) -> Formula a -> Formula b;
map_formula f (Atom x1) = Atom (f x1);
map_formula f (NegAtom x2) = NegAtom (f x2);
map_formula f (Conjunction x3) = Conjunction (map (map_formula f) x3);
map_formula f (Disjunction x4) = Disjunction (map (map_formula f) x4);

edge :: forall a b c d e f. Art_ext a b c d e f -> e -> Art_edge a b c d e;
edge (Art_ext initial_nodes nodes edge node_location node_invariant more) =
  edge;

check_children_edges_cond ::
  forall a b c d e f g h i j k.
    (Default a, Showl a, Eq b, Showl b, Eq c, Showl c, Eq d, Showl d, Showl e,
      Showl f) => (a -> Formula (Term b (Trans_var c, d)) ->
                          Sum (String -> String) ()) ->
                    (Term b (Trans_var c, d) -> String -> String) ->
                      (Term b (Trans_var c, d) ->
                        Formula (Term b (Trans_var c, d))) ->
                        Art_ext b c d e f g ->
                          Lts_ext b c d e h ->
                            Hinter_ext (Hint a) i f j k ->
                              Sum (String -> String) ();
check_children_edges_cond tc2 sa2 ne2 a p h =
  let {
    lc = assertion p;
  } in catch_errora
         (catch_errora
           (forallM
             (\ aa ->
               (case edge a aa of {
                 Cover _ -> Inr ();
                 Children children ->
                   (case transition_hintsa h aa of {
                     Nothing -> Inl (showsl_lit "not yet");
                     Just hints ->
                       catch_errora
                         (bindb
                           (check
                             (equal_nat (size_list hints) (size_list children))
                             (showsl_lit
                               "the number of hints differs from the number of children"))
                           (\ _ ->
                             catch_errora
                               (forallM
                                 (\ (b, c) ->
                                   (case b of {
                                     (tau, ba) ->
                                       (\ ha ->
 (case tau of {
   Transition l _ phi ->
     catch_errora
       (check_formula sa2 tc2 ne2 ha
         (Disjunction
           [map_formula (rename_vars_exp Post) (node_invariant a ba),
             form_not (map_formula (rename_vars_exp Pre) (node_invariant a aa)),
             form_not (map_formula (rename_vars_exp Pre) (lc l)),
             form_not phi]))
       (\ x ->
         Inl (((((((showsl_lit "problem in checking edge " . showsl aa) .
                    showsl_lit " --> ") .
                   showsl ba) .
                  showsl_lit " for transition\n") .
                 showsl_transition sa2 tau) .
                showsl_literal "\n") .
               x));
 }));
                                   })
                                     c)
                                 (zip children hints))
                               (\ x -> Inl (snd x))))
                         (\ x ->
                           Inl (((showsl_lit
                                    "problem in checking transitions of node " .
                                   showsl aa) .
                                  showsl_literal "\n") .
                                 x));
                   });
               }))
             (nodesa h))
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (showsl_lit
                  "could not ensure transition edge condition of ART\n" .
                 x));

is_cover_nodea :: forall a b c d e. Art_edge a b c d e -> Bool;
is_cover_nodea (Cover x1) = True;
is_cover_nodea (Children x2) = False;

cover_hintsa :: forall a b c d e. Hinter_ext a b c d e -> c -> a;
cover_hintsa
  (Hinter_ext nodes succ_trans_list cover_hints transition_hints more) =
  cover_hints;

node_location :: forall a b c d e f. Art_ext a b c d e f -> e -> d;
node_location
  (Art_ext initial_nodes nodes edge node_location node_invariant more) =
  node_location;

nodes :: forall a b c d e f. Art_ext a b c d e f -> [e];
nodes (Art_ext initial_nodes nodes edge node_location node_invariant more) =
  nodes;

check_cover_edges_cond ::
  forall a b c d e f g h i j k l m n o.
    (Default a, Showl a, Eq b, Showl b, Eq c, Showl c, Eq d, Showl d, Eq e,
      Eq f,
      Showl f) => (a -> Formula (Term b (c, d)) -> Sum (String -> String) ()) ->
                    (Term b (c, d) -> String -> String) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        Art_ext b c d e f g ->
                          Lts_ext h i j k l ->
                            Hinter_ext (Hint a) m f n o ->
                              Sum (String -> String) ();
check_cover_edges_cond tc sa ne a p h =
  let {
    _ = assertion p;
  } in catch_errora
         (catch_errora
           (forallM
             (\ aa ->
               (case edge a aa of {
                 Cover b ->
                   catch_errora
                     (bindb
                       (check (membera (nodes a) b)
                         (showsl_lit "target node is not listed as art-node"))
                       (\ _ ->
                         bindb (check (node_location a aa == node_location a b)
                                 (showsl_lit "node-locations differ"))
                           (\ _ ->
                             bindb (check (not (is_cover_nodea (edge a b)))
                                     (showsl_lit
                                       "target node must not have cover edge"))
                               (\ _ ->
                                 check_formula sa tc ne (cover_hintsa h aa)
                                   (Disjunction
                                     [node_invariant a b,
                                       form_not (node_invariant a aa)])))))
                     (\ x ->
                       Inl (((showsl_lit
                                "problem in checking cover edge of node " .
                               showsl aa) .
                              showsl_literal "\n") .
                             x));
                 Children _ -> Inr ();
               }))
             (nodesa h))
           (\ x -> Inl (snd x)))
         (\ x ->
           Inl (showsl_lit "could not ensure cover edge condition of ART\n" .
                 x));

succ_trans_list :: forall a b c d e. Hinter_ext a b c d e -> b -> [d];
succ_trans_list
  (Hinter_ext nodes succ_trans_list cover_hints transition_hints more) =
  succ_trans_list;

initial_nodes :: forall a b c d e f. Art_ext a b c d e f -> [e];
initial_nodes
  (Art_ext initial_nodes nodes edge node_location node_invariant more) =
  initial_nodes;

check_simulation_cond ::
  forall a b c d e f g h i j k l m.
    (Default a, Showl a, Eq b, Showl b, Eq c, Showl c, Eq d, Showl d, Cenum e,
      Ceq e, Ccompare e, Eq e, Set_impl e, Showl e, Eq f,
      Showl f) => (a -> Formula (Term b (c, d)) -> Sum (String -> String) ()) ->
                    (Term b (c, d) -> String -> String) ->
                      (Term b (c, d) -> Formula (Term b (c, d))) ->
                        Art_ext b c d e f g ->
                          Lts_ext h i j e k ->
                            Hinter_ext l e f (Transition_rule b c d e) m ->
                              Sum (String -> String) ();
check_simulation_cond tc sa ne a p h =
  catch_errora
    (bindb
      (check
        (less_eq_set (initial p)
          (set (map (node_location a) (initial_nodes a))))
        (showsl_lit
          "not all initial nodes of LTS are represented by initial nodes in ART"))
      (\ _ ->
        catch_errora
          (forallM
            (\ aa ->
              (case edge a aa of {
                Cover _ -> Inr ();
                Children children ->
                  let {
                    l = node_location a aa;
                  } in catch_errora
                         (catch_errora
                           (forallM
                             (\ tau ->
                               check (any (\ (taua, b) ->
    equal_transition_rule taua tau &&
      node_location a b == target tau && membera (nodes a) b)
                                       children)
                                 (((((showsl_lit
"could not find matching transition in ART for node " .
                                       showsl aa) .
                                      showsl_lit " and transition ") .
                                     showsl (source tau)) .
                                    showsl_lit " --> ") .
                                   showsl (target tau)))
                             (succ_trans_list h l))
                           (\ x -> Inl (snd x)))
                         (\ e1 ->
                           catch_errora
                             (check_valid_formula sa tc ne
                               (form_not (node_invariant a aa)))
                             (\ _ ->
                               Inl (e1 . showsl_lit
   "\nand could not prove unsatisfiability of the node invariant")));
              }))
            (nodesa h))
          (\ x -> Inl (snd x))))
    (\ x ->
      Inl (showsl_lit "could not ensure simulation condition of ART\n" . x));

check_initial_cond ::
  forall a b c d e f.
    (Eq a, Showl a, Eq b, Showl b, Eq c, Showl c, Eq e,
      Showl e) => (Term a (b, c) -> String -> String) ->
                    Art_ext a b c d e f -> Sum (String -> String) ();
check_initial_cond sa a =
  catch_errora
    (forallM
      (\ init ->
        bindb (check (membera (nodes a) init)
                ((showsl_lit "initial node of A (" . showsl init) .
                  showsl_lit ") is not mentioned as node of ART"))
          (\ _ ->
            check (equal_formula (node_invariant a init) (Conjunction []))
              (((showsl_lit "the node invariant for the initial ART node (" .
                  showsl init) .
                 showsl_lit ") must be TRUE,  but it is ") .
                showsl_formula sa (node_invariant a init))))
      (initial_nodes a))
    (\ x -> Inl (snd x));

art ::
  forall a b c d e f.
    (Showl a, Ceq b, Ccompare b, Eq b,
      Showl b) => (a -> ([b], b)) -> Set b -> Art_ext a c b d e f -> Bool;
art type_of_fun bool_types a =
  all (\ aa -> formula (is_bool type_of_fun bool_types) (node_invariant a aa))
    (nodes a);

check_art ::
  forall a b c d e f.
    (Showl a, Ceq b, Ccompare b, Eq b,
      Showl b) => (a -> ([b], b)) ->
                    Set b -> Art_ext a c b d e f -> Sum (String -> String) ();
check_art type_of_fun bool_types a =
  check (art type_of_fun bool_types a) (showsl_lit "ill-formed invariant");

check_art_invariants ::
  forall a b c d e f g h i.
    (Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Default c, Showl c, Eq d,
      Showl d, Cenum e, Ceq e, Ccompare e, Eq e, Set_impl e, Showl e, Eq f,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (c -> Formula (Term a (d, b)) ->
                              Sum (String -> String) ()) ->
                        (c -> Formula (Term a (Trans_var d, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (d, b) -> String -> String) ->
                            (Term a (Trans_var d, b) -> String -> String) ->
                              (Term a (d, b) -> Formula (Term a (d, b))) ->
                                (Term a (Trans_var d, b) ->
                                  Formula (Term a (Trans_var d, b))) ->
                                  Art_ext a d b e f g ->
                                    Lts_ext a d b e h ->
                                      Hinter_ext (Hint c) e f
(Transition_rule a d b e) i ->
Sum (String -> String) ();
check_art_invariants type_of_fun bool_types tc tc2 sa sa2 ne ne2 a p h =
  catch_errora
    (bindb (check_art type_of_fun bool_types a)
      (\ _ ->
        bindb (check_initial_cond sa a)
          (\ _ ->
            bindb (check_simulation_cond tc sa ne a p h)
              (\ _ ->
                bindb (check_cover_edges_cond tc sa ne a p h)
                  (\ _ -> check_children_edges_cond tc2 sa2 ne2 a p h)))))
    (\ x -> Inl (showsl_lit "could not ensure validity of art-graph:\n" . x));

is_cover_node :: forall a b c d e f g. Art_node_impl a b c d e f g -> Bool;
is_cover_node (Art_Node uu uv uw (Cover_Edge ux uy)) = True;
is_cover_node (Art_Node uz va vb (Children_Edge vc)) = False;

transition_hints ::
  forall a b c d e f g.
    (Eq e) => Art_impl_ext a b c d e f g () -> e -> Maybe [g];
transition_hints ai =
  map_of
    (map_filter
      (\ x ->
        (if not (is_cover_node x)
          then Just (name x, (case edgea x of {
                               Children_Edge a -> map (\ (_, (_, h)) -> h) a;
                             }))
          else Nothing))
      (nodesb ai));

cover_hints ::
  forall a b c d e f g.
    (Ccompare e, Eq e, Mapping_impl e,
      Default g) => Art_impl_ext a b c d e f g () -> e -> g;
cover_hints ai =
  map_of_default defaulta
    (map_filter
      (\ x ->
        (if is_cover_node x then Just (name x, (case edgea x of {
         Cover_Edge _ h -> h;
       }))
          else Nothing))
      (nodesb ai));

make_hinter ::
  forall a b c d e f g h i j k l.
    (Eq d, Ccompare j, Eq j, Mapping_impl j,
      Default l) => Lts_impl a b c d e ->
                      Art_impl_ext f g h i j k l () ->
                        Hinter_ext l d j (Transition_rule a b c d) ();
make_hinter pi ai =
  Hinter_ext (art_nodes ai) (succ_transitions pi) (cover_hints ai)
    (transition_hints ai) ();

check_art_invariants_impl ::
  forall a b c d e f g.
    (Ccompare a, Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Default c,
      Showl c, Ccompare d, Eq d, Showl d, Cenum e, Ceq e, Ccompare e, Eq e,
      Mapping_impl e, Set_impl e, Showl e, Ccompare f, Eq f, Mapping_impl f,
      Showl f, Ceq g, Ccompare g, Eq g, Mapping_impl g, Set_impl g,
      Showl g) => (a -> ([b], b)) ->
                    Set b ->
                      (c -> Formula (Term a (d, b)) ->
                              Sum (String -> String) ()) ->
                        (c -> Formula (Term a (Trans_var d, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (d, b) -> String -> String) ->
                            (Term a (Trans_var d, b) -> String -> String) ->
                              (Term a (d, b) -> Formula (Term a (d, b))) ->
                                (Term a (Trans_var d, b) ->
                                  Formula (Term a (Trans_var d, b))) ->
                                  Art_impl_ext a d b e f g (Hint c) () ->
                                    Lts_impl a d b e g ->
                                      Sum (String -> String) ();
check_art_invariants_impl type_of_fun bool_types tc tc2 sa sa2 ne ne2 ai pi =
  check_art_invariants type_of_fun bool_types tc tc2 sa sa2 ne ne2
    (art_of pi ai) (lts_of pi) (make_hinter pi ai);

check_unique_names ::
  forall a b c d e f g h.
    (Eq e) => Art_impl_ext a b c d e f g h -> Sum (String -> String) ();
check_unique_names ai =
  check (distinct (map name (nodesb ai)))
    (showsl_lit "Nodes in art graph must have unique names");

restrict_invariants ::
  forall a b c d.
    (Ceq a,
      Ccompare a) => (a -> Formula (Term b (c, d))) ->
                       Set a -> a -> Formula (Term b (c, d));
restrict_invariants i la l = (if member l la then i l else Conjunction []);

showsl_labeled_transition ::
  forall a b c d e.
    (Showl d,
      Showl e) => (Term a (Trans_var b, c) -> String -> String) ->
                    (d, Transition_rule a b c e) -> String -> String;
showsl_labeled_transition showsl_tatom (lab, tran) =
  (showsl lab . showsl_lit ": ") . showsl_transition showsl_tatom tran;

showsl_lts ::
  forall a b c d e.
    (Showl d,
      Showl e) => (Term a (b, c) -> String -> String) ->
                    (Term a (Trans_var b, c) -> String -> String) ->
                      Lts_impl a b c d e -> String -> String;
showsl_lts showsl_atom showsl_tatom (Lts_Impl i tran lc) =
  (((((showsl_lit "LTS:\nInitial locations: " . showsl_list i) .
       showsl_lit "\nTransitions\n") .
      showsl_sep (showsl_labeled_transition showsl_tatom) (showsl_literal "\n")
        tran) .
     showsl_lit "\nLocation conditions") .
    showsl_sep
      (\ (l, f) -> (showsl l . showsl_lit ": ") . showsl_formula showsl_atom f)
      (showsl_literal "\n") lc) .
    showsl_literal "\n";

get_disj_invariant ::
  forall a b c d e.
    (Eq d) => Art_ext a b c d e () -> d -> Formula (Term a (b, c));
get_disj_invariant a l =
  Disjunction
    (map_filter
      (\ x ->
        (if node_location a x == l && not (is_cover_nodea (edge a x))
          then Just (node_invariant a x) else Nothing))
      (nodes a));

check_trivial_implication :: forall a. (Eq a) => Formula a -> Formula a -> Bool;
check_trivial_implication phi psi =
  all (\ phia ->
        let {
          c_phis = get_conjunctions phia;
        } in any (\ psia -> all (membera c_phis) (get_conjunctions psia))
               (get_disjunctions psi))
    (get_disjunctions phi);

showsl_art_node ::
  forall a b c d e f g.
    (Showl d, Showl e,
      Showl f) => Art_node_impl a b c d e f g -> String -> String;
showsl_art_node (Art_Node n uu l (Cover_Edge m uv)) =
  (((showsl n . showsl_lit "(@ ") . showsl l) . showsl_lit "): covered by ") .
    showsl m;
showsl_art_node (Art_Node n uw l (Children_Edge ls)) =
  (((showsl n . showsl_lit "(@ ") . showsl l) . showsl_lit "): goes to ") .
    default_showsl_list
      (\ (tr, (na, _)) ->
        ((showsl_lit "-" . showsl tr) . showsl_lit "->") . showsl na)
      ls;

showsl_art ::
  forall a b c d e f g.
    (Showl d, Showl e,
      Showl f) => Art_impl_ext a b c d e f g () -> String -> String;
showsl_art a =
  (((showsl_lit "ART:\nInitial node: " . showsl_list (initial_nodesa a)) .
     showsl_lit "\nArcs\n") .
    showsl_sep showsl_art_node (showsl_literal "\n") (nodesb a)) .
    showsl_literal "\n";

invariant_proof_checker ::
  forall a b c d e f g.
    (Ccompare a, Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Default c,
      Showl c, Ccompare d, Eq d, Showl d, Cenum e, Ceq e, Ccompare e, Eq e,
      Mapping_impl e, Set_impl e, Showl e, Ceq f, Ccompare f, Eq f,
      Mapping_impl f, Set_impl f, Showl f, Ccompare g, Eq g, Mapping_impl g,
      Showl g) => (a -> ([b], b)) ->
                    Set b ->
                      (c -> Formula (Term a (d, b)) ->
                              Sum (String -> String) ()) ->
                        (c -> Formula (Term a (Trans_var d, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (d, b) -> String -> String) ->
                            (Term a (Trans_var d, b) -> String -> String) ->
                              (Term a (d, b) -> Formula (Term a (d, b))) ->
                                (Term a (Trans_var d, b) ->
                                  Formula (Term a (Trans_var d, b))) ->
                                  Lts_impl a d b e f ->
                                    Invariant_proof a d b e g f c ->
                                      Sum (String -> String)
(e -> Formula (Term a (d, b)));
invariant_proof_checker type_of_fun bool_types tc tc2 sa sa2 ne ne2 pi
  (Impact ii ai) =
  debug id "invariant checking: Impact"
    (let {
       i = map_of_default (Conjunction []) ii;
     } in (case catch_errora
                  (bindb (check_unique_names ai)
                    (\ _ ->
                      bindb (debug id
                              "provided invariants against deduced invariants from ART graph"
                              (catch_errora
                                (forallM
                                  (\ l ->
                                    let {
                                      il = i l;
                                    } in bindb
   (check (formula (is_bool type_of_fun bool_types) il)
     (showsl_lit "ill-formed formula for location " . showsl l))
   (\ _ ->
     check (check_trivial_implication (get_disj_invariant (art_of pi ai) l) il)
       (showsl_lit
          "could not match provided invariant with invariant extracted from art-graph at location " .
         showsl l)))
                                  (nodes_lts_impl pi))
                                (\ x -> Inl (snd x))))
                        (\ _ ->
                          debug id "checking ART graph"
                            (check_art_invariants_impl type_of_fun bool_types tc
                              tc2 sa sa2 ne ne2 ai pi))))
                  (\ x ->
                    Inl ((((showsl_lit "problem in ensuring invariants for " .
                             showsl_lts sa sa2 pi) .
                            showsl_lit "\nvia ") .
                           showsl_art ai) .
                          x))
            of {
            Inl a -> Inl a;
            Inr _ -> Inr (restrict_invariants i (set (nodes_lts_impl pi)));
          }));

safe_by_assertion_checker ::
  forall a b c d e f.
    (Eq a, Eq b, Showl b, Eq c, Default d, Showl d, Ccompare e, Eq e,
      Mapping_impl e,
      Showl e) => (Term a (b, c) -> String -> String) ->
                    (d -> Formula (Term a (b, c)) ->
                            Sum (String -> String) ()) ->
                      (Term a (b, c) -> Formula (Term a (b, c))) ->
                        Lts_impl a b c e f -> [e] -> Sum (String -> String) ();
safe_by_assertion_checker showsl_atom logic_checker negate_atom pi err =
  catch_errora
    (forallM
      (\ l ->
        catch_errora
          (check_valid_formula showsl_atom logic_checker negate_atom
            (form_not (assertion_of pi l)))
          (\ _ ->
            Inl ((showsl_lit "could not deduce from assertion that " .
                   showsl l) .
                  showsl_lit " is unreachable")))
      err)
    (\ x -> Inl (snd x));

fix_invariants ::
  forall a b c d e.
    (Ccompare d, Eq d, Mapping_impl d, Showl d,
      Showl e) => Lts_impl a b c d e ->
                    (d -> Formula (Term a (b, c))) ->
                      Sum (String -> String) (Lts_impl a b c d e);
fix_invariants p phi =
  catch_errora
    (let {
       ls = nodes_lts_impl p;
       _ = assertion_of p;
     } in Inr (Lts_Impl (initiala p) (transitions_impl p)
                (map (\ l -> (l, phi l)) ls)))
    (\ x ->
      Inl (showsl_lit "problem when fixing invariants as assertions\n" . x));

check_safety_proof ::
  forall a b c d e f g.
    (Ccompare a, Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Default c,
      Showl c, Ccompare d, Eq d, Showl d, Cenum e, Ceq e, Ccompare e, Eq e,
      Mapping_impl e, Set_impl e, Showl e, Ceq f, Ccompare f, Eq f,
      Mapping_impl f, Set_impl f, Showl f, Ccompare g, Eq g, Mapping_impl g,
      Showl g) => (a -> ([b], b)) ->
                    Set b ->
                      (c -> Formula (Term a (d, b)) ->
                              Sum (String -> String) ()) ->
                        (c -> Formula (Term a (Trans_var d, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (d, b) -> String -> String) ->
                            (Term a (Trans_var d, b) -> String -> String) ->
                              (Term a (d, b) -> Formula (Term a (d, b))) ->
                                (Term a (Trans_var d, b) ->
                                  Formula (Term a (Trans_var d, b))) ->
                                  Lts_impl a d b e f ->
                                    [e] ->
                                      Safety_proof a d b e g f c ->
Sum (String -> String) ();
check_safety_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 pi err
  (Invariant_Assertion inv_prf inner) =
  debug id "Add Invariants"
    (bindb
      (invariant_proof_checker type_of_fun bool_types tc tc2 sa sa2 ne ne2 pi
        inv_prf)
      (\ i ->
        bindb (fix_invariants pi i)
          (\ qi ->
            check_safety_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 qi
              err inner)));
check_safety_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 pi err Trivial =
  debug id "Unsatisfiable Error states"
    (safe_by_assertion_checker sa tc ne pi err);

check_safety ::
  forall a b c d e f g.
    (Ccompare a, Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Default c,
      Showl c, Ccompare d, Eq d, Showl d, Cenum e, Ceq e, Ccompare e, Eq e,
      Mapping_impl e, Set_impl e, Showl e, Ceq f, Ccompare f, Eq f,
      Mapping_impl f, Set_impl f, Showl f, Ccompare g, Eq g, Mapping_impl g,
      Showl g) => (a -> ([b], b)) ->
                    Set b ->
                      (c -> Formula (Term a (d, b)) ->
                              Sum (String -> String) ()) ->
                        (c -> Formula (Term a (Trans_var d, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (d, b) -> String -> String) ->
                            (Term a (Trans_var d, b) -> String -> String) ->
                              (Term a (d, b) -> Formula (Term a (d, b))) ->
                                (Term a (Trans_var d, b) ->
                                  Formula (Term a (Trans_var d, b))) ->
                                  Lts_impl a d b e f ->
                                    [e] ->
                                      Safety_proof a d b e g f c ->
Sum (String -> String) ();
check_safety type_of_fun bool_types tc tc2 sa sa2 ne ne2 pi err prf =
  bindb (debug id "init - Check well-formedness"
          (check_lts_impl type_of_fun bool_types pi))
    (\ _ ->
      check_safety_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 pi err
        prf);

check_single_subsumption ::
  forall a b.
    (Eq a, Showl a, Ccompare b, Eq b, Mapping_impl b,
      Showl b) => (Term a b, Term a b) ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [([Nat],
                            ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum (String -> String) ();
check_single_subsumption eq e convs =
  bindb (check (membera (map fst convs) eq)
          (showsl_lit "could not find conversion for equation " . showsl_eq eq))
    (\ _ -> check_subsumptions_guided e convs);

showsl_ln :: Nat -> String -> String;
showsl_ln i = (showsl_literal "\n" . showsl_nat i) . showsl_lit ": ";

eq_proof_lines ::
  forall a b.
    (Showl a,
      Showl b) => Eq_proof a b ->
                    Nat -> (String -> String, (Nat, (Term a b, Term a b)));
eq_proof_lines (Refl s) i =
  ((showsl_ln (suc i) . showsl_eq (s, s)) . showsl_lit " [refl]",
    (suc i, (s, s)));
eq_proof_lines (Sym p) i =
  (case eq_proof_lines p i of {
    (s, (ia, (l, r))) ->
      (((((s . showsl_ln (suc ia)) . showsl_eq (r, l)) . showsl_lit " [sym ") .
         showsl_nat ia) .
         showsl_lit "]",
        (suc ia, (r, l)));
  });
eq_proof_lines (Trans p1 p2) i =
  (case eq_proof_lines p1 i of {
    (s1, (i1, (s, _))) ->
      (case eq_proof_lines p2 i1 of {
        (s2, (i2, (_, v))) ->
          ((((((((s1 . s2) . showsl_ln (suc i2)) . showsl_eq (s, v)) .
                showsl_lit " [trans ") .
               showsl_nat i1) .
              showsl_lit ", ") .
             showsl_nat i2) .
             showsl_lit "]",
            (suc i2, (s, v)));
      });
  });
eq_proof_lines (Assm (l, r) sigma) i =
  let {
    eq = (subst_apply_term l sigma, subst_apply_term r sigma);
  } in ((((showsl_ln (suc i) . showsl_eq eq) . showsl_lit " [assm ") .
          showsl_eq (l, r)) .
          showsl_lit "]",
         (suc i, eq));
eq_proof_lines (Cong f ps) i =
  (case eq_proofs_lines ps i of {
    (s, (is, (ls, rs))) ->
      let {
        eq = (Fun f ls, Fun f rs);
        ia = last is;
        isa = butlast is;
      } in (((s . showsl_ln (suc ia)) . showsl_eq eq) .
              showsl_list_gen showsl_nat " [cong]" " [cong " ", " "]" isa,
             (suc ia, eq));
  });

eq_proofs_lines ::
  forall a b.
    (Showl a,
      Showl b) => [Eq_proof a b] ->
                    Nat ->
                      (String -> String, ([Nat], ([Term a b], [Term a b])));
eq_proofs_lines [] i = (id, ([i], ([], [])));
eq_proofs_lines (p : ps) i =
  (case eq_proof_lines p i of {
    (s1, (ia, (l, r))) ->
      (case eq_proofs_lines ps ia of {
        (s2, (is, (ls, rs))) -> (s1 . s2, (ia : is, (l : ls, r : rs)));
      });
  });

check_proves ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => [(Term a b, Term a b)] ->
                    Eq_proof a b -> Sum (String -> String) (Term a b, Term a b);
check_proves e (Refl s) = Inr (s, s);
check_proves e (Sym p) = bindb (check_proves e p) (\ (s, t) -> Inr (t, s));
check_proves e (Trans p1 p2) =
  bindb (check_proves e p1)
    (\ (s, t) ->
      bindb (check_proves e p2)
        (\ (ta, u) ->
          (if equal_term t ta then Inr (s, u)
            else Inl (((((showsl_lit
                            "the error occurs in the following part \n" .
                           fst (eq_proof_lines (Trans p1 p2) zero_nat)) .
                          showsl_lit "\n\n") .
                         showsl_terma t) .
                        showsl_lit " is not equal to ") .
                       showsl_terma ta))));
check_proves e (Assm (l, r) sigma) =
  (if membera e (l, r)
    then Inr (subst_apply_term l sigma, subst_apply_term r sigma)
    else Inl (((((showsl_lit "the error occurs in the following part \n" .
                   fst (eq_proof_lines (Assm (l, r) sigma) zero_nat)) .
                  showsl_lit "\n\n") .
                 showsl_eqa (l, r)) .
                showsl_lit " is not in the ") .
               showsl_eqs e));
check_proves e (Cong f ps) =
  bindb (mapM (check_proves e) ps)
    (\ sts -> Inr (Fun f (map fst sts), Fun f (map snd sts)));

check_eq_proof ::
  forall a b.
    (Eq a, Showl a, Eq b,
      Showl b) => [(Term a b, Term a b)] ->
                    Eq_proof a b ->
                      (Term a b, Term a b) -> Sum (String -> String) ();
check_eq_proof e p eq =
  catch_errora
    (bindb (check_proves e p)
      (\ eqa ->
        (if eq == eqa then Inr ()
          else Inl (showsl_lit "the proof does not fit the goal"))))
    (\ x ->
      Inl (((((((showsl_lit
                   "there is an error in the equational logic proof\n" .
                  fst (eq_proof_lines p zero_nat)) .
                 showsl_lit "\n\nfor proving the equation\n\n") .
                showsl_eqa eq) .
               showsl_lit "\n\nusing the ") .
              showsl_eqs e) .
             showsl_literal "\n") .
            x));

check_equational_proof ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Bool ->
                    (String -> String) ->
                      Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                          [(Term (Lab b [Nat]) [Char],
                             Term (Lab b [Nat]) [Char])] ->
                            Equation_literal (Lab b [Nat]) [Char] ->
                              Equational_proof b [Nat] [Char] ->
                                Sum (String -> String) ();
check_equational_proof a ia i j e (Equation eq) (Equational_Proof_Tree p) =
  debug ia "Equational_Proof_Tree" (check_eq_proof e p eq);
check_equational_proof a ia i j e (Equation eq) (Conversion eseq) =
  debug ia "Conversion" (check_conversiona e eseq (fst eq) (snd eq));
check_equational_proof a ia i j e (Equation eq) (Conversion_With_History convs)
  = debug ia "Conversion with History" (check_single_subsumption eq e convs);
check_equational_proof a ia i j e (Equation eq)
  (Completion_and_Normalization r p) =
  debug ia "Completion_and_Normalization"
    (bindb (check_completion_proof a ia i j e r p)
      (\ _ ->
        let {
          s = fst eq;
          t = snd eq;
        } in (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
               (Nothing, _) ->
                 Inl (((showsl_lit "error when computing normal forms of " .
                         showsl_terma s) .
                        showsl_lit " and ") .
                       showsl_terma t);
               (Just _, Nothing) ->
                 Inl (((showsl_lit "error when computing normal forms of " .
                         showsl_terma s) .
                        showsl_lit " and ") .
                       showsl_terma t);
               (Just sa, Just ta) ->
                 (if equal_term sa ta then Inr ()
                   else Inl (((showsl_terma s . showsl_lit " and ") .
                               showsl_terma t) .
                              showsl_lit " have different normal forms"));
             })));
check_equational_proof uu uv uw ux uy (Inequality v) va =
  Inl (showsl_lit "unsupported equational proof ");

set_impl_ty :: Phantom Ty Set_impla;
set_impl_ty = Phantom Set_RBT;

check_dp_termination_proof ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          c -> Dp_termination_proof b [Nat] [Char] ->
                                 Sum (String -> String) ();
check_dp_termination_proof ia j a i dpp prf =
  check_dp_termination_proof_main ia j a i dpp (fst (unlab_to_split_dp prf));

equal_claim :: forall a b. Claim a b -> Claim a b -> Bool;
equal_claim Ordered_Completed Anything = False;
equal_claim Anything Ordered_Completed = False;
equal_claim Completed Anything = False;
equal_claim Anything Completed = False;
equal_claim Completed Ordered_Completed = False;
equal_claim Ordered_Completed Completed = False;
equal_claim Nonconfluent Anything = False;
equal_claim Anything Nonconfluent = False;
equal_claim Nonconfluent Ordered_Completed = False;
equal_claim Ordered_Completed Nonconfluent = False;
equal_claim Nonconfluent Completed = False;
equal_claim Completed Nonconfluent = False;
equal_claim Confluent Anything = False;
equal_claim Anything Confluent = False;
equal_claim Confluent Ordered_Completed = False;
equal_claim Ordered_Completed Confluent = False;
equal_claim Confluent Completed = False;
equal_claim Completed Confluent = False;
equal_claim Confluent Nonconfluent = False;
equal_claim Nonconfluent Confluent = False;
equal_claim Nonterminating Anything = False;
equal_claim Anything Nonterminating = False;
equal_claim Nonterminating Ordered_Completed = False;
equal_claim Ordered_Completed Nonterminating = False;
equal_claim Nonterminating Completed = False;
equal_claim Completed Nonterminating = False;
equal_claim Nonterminating Nonconfluent = False;
equal_claim Nonconfluent Nonterminating = False;
equal_claim Nonterminating Confluent = False;
equal_claim Confluent Nonterminating = False;
equal_claim (Upperbound x4) Anything = False;
equal_claim Anything (Upperbound x4) = False;
equal_claim (Upperbound x4) Ordered_Completed = False;
equal_claim Ordered_Completed (Upperbound x4) = False;
equal_claim (Upperbound x4) Completed = False;
equal_claim Completed (Upperbound x4) = False;
equal_claim (Upperbound x4) Nonconfluent = False;
equal_claim Nonconfluent (Upperbound x4) = False;
equal_claim (Upperbound x4) Confluent = False;
equal_claim Confluent (Upperbound x4) = False;
equal_claim (Upperbound x4) Nonterminating = False;
equal_claim Nonterminating (Upperbound x4) = False;
equal_claim Terminating Anything = False;
equal_claim Anything Terminating = False;
equal_claim Terminating Ordered_Completed = False;
equal_claim Ordered_Completed Terminating = False;
equal_claim Terminating Completed = False;
equal_claim Completed Terminating = False;
equal_claim Terminating Nonconfluent = False;
equal_claim Nonconfluent Terminating = False;
equal_claim Terminating Confluent = False;
equal_claim Confluent Terminating = False;
equal_claim Terminating Nonterminating = False;
equal_claim Nonterminating Terminating = False;
equal_claim Terminating (Upperbound x4) = False;
equal_claim (Upperbound x4) Terminating = False;
equal_claim No Anything = False;
equal_claim Anything No = False;
equal_claim No Ordered_Completed = False;
equal_claim Ordered_Completed No = False;
equal_claim No Completed = False;
equal_claim Completed No = False;
equal_claim No Nonconfluent = False;
equal_claim Nonconfluent No = False;
equal_claim No Confluent = False;
equal_claim Confluent No = False;
equal_claim No Nonterminating = False;
equal_claim Nonterminating No = False;
equal_claim No (Upperbound x4) = False;
equal_claim (Upperbound x4) No = False;
equal_claim No Terminating = False;
equal_claim Terminating No = False;
equal_claim Yes Anything = False;
equal_claim Anything Yes = False;
equal_claim Yes Ordered_Completed = False;
equal_claim Ordered_Completed Yes = False;
equal_claim Yes Completed = False;
equal_claim Completed Yes = False;
equal_claim Yes Nonconfluent = False;
equal_claim Nonconfluent Yes = False;
equal_claim Yes Confluent = False;
equal_claim Confluent Yes = False;
equal_claim Yes Nonterminating = False;
equal_claim Nonterminating Yes = False;
equal_claim Yes (Upperbound x4) = False;
equal_claim (Upperbound x4) Yes = False;
equal_claim Yes Terminating = False;
equal_claim Terminating Yes = False;
equal_claim Yes No = False;
equal_claim No Yes = False;
equal_claim (Upperbound x4) (Upperbound y4) = equal_nat x4 y4;
equal_claim Anything Anything = True;
equal_claim Ordered_Completed Ordered_Completed = True;
equal_claim Completed Completed = True;
equal_claim Nonconfluent Nonconfluent = True;
equal_claim Confluent Confluent = True;
equal_claim Nonterminating Nonterminating = True;
equal_claim Terminating Terminating = True;
equal_claim No No = True;
equal_claim Yes Yes = True;

type_of_fun :: Sig -> ([Ty], Ty);
type_of_fun LessF = ([IntT, IntT], BoolT);
type_of_fun LeF = ([IntT, IntT], BoolT);
type_of_fun EqF = ([IntT, IntT], BoolT);
type_of_fun (SumF n) = (replicate n IntT, IntT);
type_of_fun (ConstF uu) = ([], IntT);
type_of_fun (ProdF n) = (replicate n IntT, IntT);

mke ::
  forall a b c d.
    Ac_tp_ops_ext a b c d -> [(Term b c, Term b c)] -> [b] -> [b] -> a;
mke (Ac_tp_ops_ext ac_tp r a c mk delete_rules e more) = mk;

fresh_variable_checker ::
  forall a b c d e.
    (Showl a, Ceq b, Ccompare b, Eq b, Showl b, Eq c, Showl c, Showl d,
      Showl e) => (a -> ([b], b)) ->
                    Set b ->
                      (Trans_var c ->
                        b -> Formula (Term a (Trans_var c, b)) ->
                               Sum (String -> String) ()) ->
                        (Term a (Trans_var c, b) -> String -> String) ->
                          Lts_impl a c b d e ->
                            (e -> Formula (Term a (Trans_var c, b))) ->
                              c -> b -> Sum (String -> String) ();
fresh_variable_checker type_of_fun bool_types definability_checker sa2 p f x ty
  = catch_errora
      (bindb
        (catch_errora
          (forallM
            (\ (l, fa) ->
              check (not (in_vars_formula (x, ty) fa))
                ((showsl x .
                   showsl_lit
                     " is not fresh, it occurs in location condition of ") .
                  showsl l))
            (assertion_impl p))
          (\ xa -> Inl (snd xa)))
        (\ _ ->
          catch_errora
            (forallM
              (\ (tr, tau) ->
                let {
                  psi = f tr;
                } in bindb (check (formula (is_bool type_of_fun bool_types) psi)
                             (showsl_lit
                               "new transition formula seems to be not well-formed"))
                       (\ _ ->
                         catch_errora
                           (case tau of {
                             Transition _ _ phi ->
                               bindb (definability_checker (Post x) ty psi)
                                 (\ _ ->
                                   bindb (check
   (not (in_vars_formula (Post x, ty) phi))
   (showsl_lit "Post x in transition formula" . showsl_formula sa2 phi))
                                     (\ _ ->
                                       check
 (not (in_vars_formula (Pre x, ty) phi))
 (showsl_lit "Pre x in transition formula" . showsl_formula sa2 phi)));
                           })
                           (\ xa ->
                             Inl (((showsl_lit
                                      "problem in transition formula of transition " .
                                     showsl tr) .
                                    showsl_literal "\n") .
                                   xa))))
              (transitions_impl p))
            (\ xa -> Inl (snd xa))))
      (\ xa -> Inl (showsl_lit "fresh_variable_checker failed\n" . xa));

showsl_formulaa :: forall a. (Showl a) => Formula a -> String -> String;
showsl_formulaa (Atom a) = showsl a;
showsl_formulaa (NegAtom a) = (showsl_lit "! (" . showsl a) . showsl_lit ")";
showsl_formulaa (Conjunction a) =
  showsl_list_gen id "TRUE" "(" " & " ")" (map showsl_formulaa a);
showsl_formulaa (Disjunction a) =
  showsl_list_gen id "FALSE" "(" " | " ")" (map showsl_formulaa a);

refine_transition_formula ::
  forall a b c d.
    Transition_rule a b c d ->
      Formula (Term a (Trans_var b, c)) -> Transition_rule a b c d;
refine_transition_formula (Transition l r phi) psi =
  Transition l r (form_and phi psi);

refine_transition_formulas ::
  forall a b c d e.
    Lts_impl a b c d e ->
      (e -> Formula (Term a (Trans_var b, c))) -> Lts_impl a b c d e;
refine_transition_formulas p f =
  Lts_Impl (initiala p)
    (map (\ (tr, tau) -> (tr, refine_transition_formula tau (f tr)))
      (transitions_impl p))
    (assertion_impl p);

fresh_variable_addition ::
  forall a b c d e.
    (Showl a, Ceq b, Ccompare b, Eq b, Showl b, Eq c, Showl c, Showl d,
      Ccompare e, Eq e, Mapping_impl e,
      Showl e) => (a -> ([b], b)) ->
                    Set b ->
                      (Trans_var c ->
                        b -> Formula (Term a (Trans_var c, b)) ->
                               Sum (String -> String) ()) ->
                        (Term a (Trans_var c, b) -> String -> String) ->
                          Lts_impl a c b d e ->
                            Fresh_variable_addition_info a c b e ->
                              Sum (String -> String) (Lts_impl a c b d e);
fresh_variable_addition type_of_fun bool_types definability_checker sa2 p
  (Fresh_Variable_Addition_Info x ty forms) =
  let {
    m = of_alist forms;
    f = lookup_default (Conjunction []) m;
  } in (case catch_errora
               (bindb
                 (catch_errora
                   (forallM
                     (\ fa ->
                       check (formula (is_bool type_of_fun bool_types) fa)
                         (showsl_formulaa fa .
                           showsl_lit " is not a valid formula"))
                     (map snd forms))
                   (\ xa -> Inl (snd xa)))
                 (\ _ ->
                   fresh_variable_checker type_of_fun bool_types
                     definability_checker sa2 p f x ty))
               (\ xa ->
                 Inl (((showsl_lit "problem in adding fresh variable " .
                         showsl x) .
                        showsl_literal "\n") .
                       xa))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (refine_transition_formulas p f);
       });

is_sharp :: forall a. Sharp a -> Bool;
is_sharp (Flat uu) = False;
is_sharp (Sharpa uv) = True;

trivial_termination_checker ::
  forall a b c d e.
    (Showl d,
      Showl e) => (Term a (b, c) -> String -> String) ->
                    (Term a (Trans_var b, c) -> String -> String) ->
                      Lts_impl a b c (Sharp d) e -> Sum (String -> String) ();
trivial_termination_checker showsl_atom showsl_tatom p =
  check (null (filter (\ tau -> is_sharp (source tau))
                (map snd (transitions_impl p))))
    (showsl_lit "there are remaining sharp transitions in " .
      showsl_lts showsl_atom showsl_tatom p);

lex_less_formula ::
  forall a b c.
    (Showl a, Showl b,
      Showl c) => (Term a (Trans_var b, c) ->
                    Term a (Trans_var b, c) ->
                      Formula (Term a (Trans_var b, c))) ->
                    (Term a (Trans_var b, c) ->
                      Term a (Trans_var b, c) ->
                        Formula (Term a (Trans_var b, c))) ->
                      [Term a (Trans_var b, c)] ->
                        [Term a (Trans_var b, c)] ->
                          [Term a (Trans_var b, c)] ->
                            Formula (Term a (Trans_var b, c));
lex_less_formula less_eq_formula less_formula xs ys zs =
  (case xs of {
    [] -> Disjunction [];
    x : xsa ->
      (case ys of {
        [] -> Disjunction [];
        y : ysa ->
          (case zs of {
            [] -> Disjunction [];
            z : zsa ->
              (case xsa of {
                [] -> (case ysa of {
                        [] -> (case zsa of {
                                [] -> form_and (less_formula y z)
(less_eq_formula x z);
                                _ : _ -> Disjunction [];
                              });
                        _ : _ -> Disjunction [];
                      });
                _ : _ ->
                  (case ysa of {
                    [] -> Disjunction [];
                    _ : _ ->
                      (case zsa of {
                        [] -> Disjunction [];
                        _ : _ ->
                          form_or
                            (form_and (less_formula y z) (less_eq_formula x z))
                            (Conjunction
                              [less_eq_formula y z,
                                lex_less_formula less_eq_formula less_formula
                                  xsa ysa zsa]);
                      });
                  });
              });
          });
      });
  });

bound_exp :: forall a b c d e. Transition_removal_info a b c d e -> a;
bound_exp (Transition_removal_info x1 x2 x3 x4 x5) = x4;

hinter :: forall a b c d e. Transition_removal_info a b c d e -> d -> Hint e;
hinter (Transition_removal_info x1 x2 x3 x4 x5) = x5;

rank :: forall a b c d e. Transition_removal_info a b c d e -> Sharp c -> a;
rank (Transition_removal_info x1 x2 x3 x4 x5) = x1;

check_lex_strict ::
  forall a b c d e f.
    (Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Eq c, Showl c, Default d,
      Showl d, Ccompare e, Eq e, Showl e,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (Term a (Trans_var c, b) -> String -> String) ->
                        (d -> Formula (Term a (Trans_var c, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (Trans_var c, b) ->
                            Formula (Term a (Trans_var c, b))) ->
                            (Term a (Trans_var c, b) ->
                              Term a (Trans_var c, b) ->
                                Formula (Term a (Trans_var c, b))) ->
                              (Term a (Trans_var c, b) ->
                                Term a (Trans_var c, b) ->
                                  Formula (Term a (Trans_var c, b))) ->
                                Transition_removal_info [Term a (c, b)] b e f
                                  d ->
                                  Lts_impl a c b (Sharp e) f ->
                                    (f, Transition_rule a c b (Sharp e)) ->
                                      Sum (String -> String) ();
check_lex_strict type_of_fun bool_types showsl_atom logic_checker negate_atom
  less_eq_formula less_formula info pi (tr, Transition l r phi) =
  let {
    psi = lex_less_formula less_eq_formula less_formula
            (map (rename_vars_exp Pre) (bound_exp info))
            (map (rename_vars_exp Post) (rank info r))
            (map (rename_vars_exp Pre) (rank info l));
  } in bindb (check (formula (is_bool type_of_fun bool_types) psi)
               ((showsl_lit "lex-less does not encode valid formula" .
                  showsl_literal "\n") .
                 showsl_formulaa psi))
         (\ _ ->
           check_formula showsl_atom logic_checker negate_atom (hinter info tr)
             (Disjunction
               [psi, Disjunction [],
                 form_not
                   (map_formula (rename_vars_exp Pre) (assertion_of pi l)),
                 form_not phi]));

lex_leq_formula ::
  forall a b c.
    (Showl a, Showl b,
      Showl c) => (Term a (Trans_var b, c) ->
                    Term a (Trans_var b, c) ->
                      Formula (Term a (Trans_var b, c))) ->
                    (Term a (Trans_var b, c) ->
                      Term a (Trans_var b, c) ->
                        Formula (Term a (Trans_var b, c))) ->
                      [Term a (Trans_var b, c)] ->
                        [Term a (Trans_var b, c)] ->
                          [Term a (Trans_var b, c)] ->
                            Formula (Term a (Trans_var b, c));
lex_leq_formula less_eq_formula less_formula xs ys zs =
  (case xs of {
    [] -> (case ys of {
            [] -> (case zs of {
                    [] -> Conjunction [];
                    _ : _ -> Disjunction [];
                  });
            _ : _ -> Disjunction [];
          });
    x : xsa ->
      (case ys of {
        [] -> Disjunction [];
        y : ysa ->
          (case zs of {
            [] -> Disjunction [];
            z : zsa ->
              (case xsa of {
                [] -> (case ysa of {
                        [] -> (case zsa of {
                                [] -> less_eq_formula y z;
                                _ : _ -> Disjunction [];
                              });
                        _ : _ -> Disjunction [];
                      });
                _ : _ ->
                  (case ysa of {
                    [] -> Disjunction [];
                    _ : _ ->
                      (case zsa of {
                        [] -> Disjunction [];
                        _ : _ ->
                          form_or
                            (form_and (less_formula y z) (less_eq_formula x z))
                            (Conjunction
                              [less_eq_formula y z,
                                lex_leq_formula less_eq_formula less_formula xsa
                                  ysa zsa]);
                      });
                  });
              });
          });
      });
  });

check_lex_weak ::
  forall a b c d e f.
    (Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Eq c, Showl c, Default d,
      Showl d, Ccompare e, Eq e, Showl e,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (Term a (Trans_var c, b) -> String -> String) ->
                        (d -> Formula (Term a (Trans_var c, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (Trans_var c, b) ->
                            Formula (Term a (Trans_var c, b))) ->
                            (Term a (Trans_var c, b) ->
                              Term a (Trans_var c, b) ->
                                Formula (Term a (Trans_var c, b))) ->
                              (Term a (Trans_var c, b) ->
                                Term a (Trans_var c, b) ->
                                  Formula (Term a (Trans_var c, b))) ->
                                Transition_removal_info [Term a (c, b)] b e f
                                  d ->
                                  Lts_impl a c b (Sharp e) f ->
                                    (f, Transition_rule a c b (Sharp e)) ->
                                      Sum (String -> String) ();
check_lex_weak type_of_fun bool_types showsl_atom logic_checker negate_atom
  less_eq_formula less_formula info pi (tr, Transition l r phi) =
  let {
    psi = lex_leq_formula less_eq_formula less_formula
            (map (rename_vars_exp Pre) (bound_exp info))
            (map (rename_vars_exp Post) (rank info r))
            (map (rename_vars_exp Pre) (rank info l));
  } in bindb (check (formula (is_bool type_of_fun bool_types) psi)
               ((showsl_lit "lex-leq does not encode valid formula" .
                  showsl_literal "\n") .
                 showsl_formulaa psi))
         (\ _ ->
           check_formula showsl_atom logic_checker negate_atom (hinter info tr)
             (Disjunction
               [psi, Disjunction [],
                 form_not
                   (map_formula (rename_vars_exp Pre) (assertion_of pi l)),
                 form_not phi]));

update_transitions_impl ::
  forall a b c d e f.
    Lts_impl a b c d e -> [(f, Transition_rule a b c d)] -> Lts_impl a b c d f;
update_transitions_impl (Lts_Impl i tsa lc) ts = Lts_Impl i ts lc;

del_transitions_impl ::
  forall a b c d e.
    (Ceq e, Ccompare e,
      Set_impl e) => Lts_impl a b c d e -> [e] -> Lts_impl a b c d e;
del_transitions_impl p td =
  update_transitions_impl p (diff_by_label (transitions_impl p) (set td));

processor ::
  forall a b c d e.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Showl a) => ((a, Transition_rule b c d (Sharp e)) ->
                    Sum (String -> String) ()) ->
                    ((a, Transition_rule b c d (Sharp e)) ->
                      Sum (String -> String) ()) ->
                      [a] ->
                        Lts_impl b c d (Sharp e) a ->
                          Sum (String -> String) (Lts_impl b c d (Sharp e) a);
processor check_weak check_strict td pi =
  catch_errora
    (bindb
      (catch_errora
        (forallM
          (\ (tr, tau) ->
            (if membera td tr
              then bindb (check (is_sharp (source tau))
                           ((showsl_lit "non-sharp transition " . showsl tr) .
                             showsl_lit " cannot be removed"))
                     (\ _ ->
                       catch_errora (check_strict (tr, tau))
                         (\ x ->
                           Inl (((showsl_lit
                                    "Failed to strictly orient transition " .
                                   showsl tr) .
                                  showsl_literal "\n") .
                                 x)))
              else (if is_sharp (source tau)
                     then catch_errora (check_weak (tr, tau))
                            (\ x ->
                              Inl (((showsl_lit
                                       "Failed to weakly orient transition " .
                                      showsl tr) .
                                     showsl_literal "\n") .
                                    x))
                     else Inr ())))
          (transitions_impl pi))
        (\ x -> Inl (snd x)))
      (\ _ -> Inr (del_transitions_impl pi td)))
    (\ x ->
      Inl (((showsl_lit "Failed to eliminate transitions " . showsl_list td) .
             showsl_lit ":\n") .
            x));

removed :: forall a b c d e. Transition_removal_info a b c d e -> [d];
removed (Transition_removal_info x1 x2 x3 x4 x5) = x2;

lex_processor ::
  forall a b c d e f.
    (Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Eq c, Showl c, Default d,
      Showl d, Ccompare e, Eq e, Showl e, Ceq f, Ccompare f, Eq f, Set_impl f,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (Term a (Trans_var c, b) -> String -> String) ->
                        (d -> Formula (Term a (Trans_var c, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (Trans_var c, b) ->
                            Formula (Term a (Trans_var c, b))) ->
                            b -> (Term a (Trans_var c, b) ->
                                   Term a (Trans_var c, b) ->
                                     Formula (Term a (Trans_var c, b))) ->
                                   (Term a (Trans_var c, b) ->
                                     Term a (Trans_var c, b) ->
                                       Formula (Term a (Trans_var c, b))) ->
                                     (Term a (Trans_var c, b) -> Bool) ->
                                       Transition_removal_info [Term a (c, b)] b
 e f d ->
 Lts_impl a c b (Sharp e) f ->
   Sum (String -> String) (Lts_impl a c b (Sharp e) f);
lex_processor type_of_fun bool_types showsl_atom logic_checker negate_atom
  dom_type less_eq_formula less_formula is_constant info pi =
  bindb (catch_errora
          (forallM
            (\ l ->
              catch_errora
                (forallM
                  (\ e ->
                    check (has_type type_of_fun e dom_type)
                      (showsl_lit "Unexpected type of expression:\n" .
                        showsl_terma e))
                  (rank info l))
                (\ x -> Inl (snd x)))
            (nodes_lts_impl pi))
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ e ->
                  check (has_type type_of_fun e dom_type)
                    (showsl_lit "Unexpected type of bound: " . showsl_terma e))
                (bound_exp info))
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (catch_errora
                  (forallM
                    (\ e ->
                      check (is_constant e)
                        (showsl_lit "Non-constant bound: " . showsl_terma e))
                    (map (rename_vars_exp Pre) (bound_exp info)))
                  (\ x -> Inl (snd x)))
            (\ _ ->
              processor
                (check_lex_weak type_of_fun bool_types showsl_atom logic_checker
                  negate_atom less_eq_formula less_formula info pi)
                (check_lex_strict type_of_fun bool_types showsl_atom
                  logic_checker negate_atom less_eq_formula less_formula info
                  pi)
                (removed info) pi)));

check_skip_transition ::
  forall a b c d e.
    (Eq a, Eq b, Showl b, Eq c, Default d,
      Showl d) => (Term a (b, c) -> String -> String) ->
                    (d -> Formula (Term a (b, c)) ->
                            Sum (String -> String) ()) ->
                      (Term a (b, c) -> Formula (Term a (b, c))) ->
                        Transition_rule a b c e -> Sum (String -> String) ();
check_skip_transition showsl_atom logic_checker negate_atom tau =
  (case tau of {
    Transition _ _ phi ->
      check_valid_formula showsl_atom logic_checker negate_atom
        (map_formula (rename_vars_exp untrans_var) phi);
  });

change_source ::
  forall a b c d. a -> Transition_rule b c d a -> Transition_rule b c d a;
change_source l (Transition src tgt phi) = Transition l tgt phi;

location_addition_outgoing ::
  forall a b c d e f.
    (Eq a, Ceq b, Ccompare b, Eq b, Eq c, Showl c, Default d, Showl d,
      Ccompare e, Eq e, Showl e,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (Term a (c, b) -> String -> String) ->
                        (d -> Formula (Term a (c, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (c, b) -> Formula (Term a (c, b))) ->
                            Lts_impl a c b (Sharp e) f ->
                              Location_addition_info a c b (Sharp e) f ->
                                Sum (String -> String)
                                  (Lts_impl a c b (Sharp e) f);
location_addition_outgoing type_of_fun bool_types showsl_atom logic_checker
  negate_atom p (Location_Addition_Info old new skip_ID skip) =
  bindb (check (not (membera (nodes_lts_impl p) new))
          ((showsl_lit "location-id " . showsl_sharp new) .
            showsl_lit " is not fresh"))
    (\ _ ->
      bindb (check (is_sharp new)
              ((showsl_lit "new location " . showsl_sharp new) .
                showsl_lit " must be sharp location"))
        (\ _ ->
          bindb (check (is_sharp old)
                  ((showsl_lit "copied location " . showsl_sharp old) .
                    showsl_lit " must be sharp location"))
            (\ _ ->
              bindb (check (transition_rule type_of_fun bool_types skip)
                      ((showsl_lit "new transition " . showsl skip_ID) .
                        showsl_lit " seems to be ill-formed"))
                (\ _ ->
                  bindb (catch_errora
                          (check_skip_transition showsl_atom logic_checker
                            negate_atom skip)
                          (\ x ->
                            Inl (((showsl_lit "new transition " .
                                    showsl skip_ID) .
                                   showsl_lit " must be skip transition\n") .
                                  x)))
                    (\ _ ->
                      bindb (check
                              (equal_sharp (source skip) old &&
                                equal_sharp (target skip) new)
                              (((((showsl_lit "new skip transition " .
                                    showsl skip_ID) .
                                   showsl_lit " must be from ") .
                                  showsl_sharp old) .
                                 showsl_lit " to ") .
                                showsl_sharp new))
                        (\ _ ->
                          let {
                            trans = transitions_impl p;
                          } in (case partition
                                       (\ tau -> is_sharp (source (snd tau)))
                                       trans
                                 of {
                                 (sharp, flat) ->
                                   (case partition
   (\ tau -> equal_sharp (source (snd tau)) old) sharp
                                     of {
                                     (sharp_modify, sharp_keep) ->
                                       let {
 q = Lts_Impl (initiala p)
       ((skip_ID, skip) :
         flat ++
           sharp_keep ++
             map (\ tau -> (fst tau, change_source new (snd tau))) sharp_modify)
       ((new, assertion_of p old) : assertion_impl p);
                                       } in
 bindb (catch_errora
         (forallM
           (\ l ->
             check (equal_formula (assertion_of p l) (assertion_of q l))
               ((showsl_lit "location condition of initial state " .
                  showsl_sharp l) .
                 showsl_lit " has been changed"))
           (initiala p))
         (\ x -> Inl (snd x)))
   (\ _ -> Inr q);
                                   });
                               })))))));

change_target ::
  forall a b c d. a -> Transition_rule b c d a -> Transition_rule b c d a;
change_target l (Transition src tgt phi) = Transition src l phi;

location_addition_incoming ::
  forall a b c d e f.
    (Eq a, Ceq b, Ccompare b, Eq b, Eq c, Showl c, Default d, Showl d,
      Ccompare e, Eq e, Showl e,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (Term a (c, b) -> String -> String) ->
                        (d -> Formula (Term a (c, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (c, b) -> Formula (Term a (c, b))) ->
                            Lts_impl a c b (Sharp e) f ->
                              Location_addition_info a c b (Sharp e) f ->
                                Sum (String -> String)
                                  (Lts_impl a c b (Sharp e) f);
location_addition_incoming type_of_fun bool_types showsl_atom logic_checker
  negate_atom p (Location_Addition_Info new old skip_ID skip) =
  bindb (check (not (membera (nodes_lts_impl p) new))
          ((showsl_lit "location-id " . showsl_sharp new) .
            showsl_lit " is not fresh"))
    (\ _ ->
      bindb (check (is_sharp new)
              ((showsl_lit "new location " . showsl_sharp new) .
                showsl_lit " must be sharp location"))
        (\ _ ->
          bindb (check (is_sharp old)
                  ((showsl_lit "copied location " . showsl_sharp old) .
                    showsl_lit " must be sharp location"))
            (\ _ ->
              bindb (check (transition_rule type_of_fun bool_types skip)
                      ((showsl_lit "new transition " . showsl skip_ID) .
                        showsl_lit " seems to be ill-formed"))
                (\ _ ->
                  bindb (catch_errora
                          (check_skip_transition showsl_atom logic_checker
                            negate_atom skip)
                          (\ x ->
                            Inl (((showsl_lit "new transition " .
                                    showsl skip_ID) .
                                   showsl_lit " must be skip transition\n") .
                                  x)))
                    (\ _ ->
                      bindb (check
                              (equal_sharp (source skip) new &&
                                equal_sharp (target skip) old)
                              (((((showsl_lit "new skip transition " .
                                    showsl skip_ID) .
                                   showsl_lit " must be from ") .
                                  showsl_sharp new) .
                                 showsl_lit " to ") .
                                showsl_sharp old))
                        (\ _ ->
                          let {
                            trans = transitions_impl p;
                          } in (case partition
                                       (\ tau -> is_sharp (source (snd tau)))
                                       trans
                                 of {
                                 (sharp, flat) ->
                                   (case partition
   (\ tau -> equal_sharp (target (snd tau)) old) sharp
                                     of {
                                     (sharp_modify, sharp_keep) ->
                                       let {
 q = Lts_Impl (initiala p)
       ((skip_ID, skip) :
         flat ++
           sharp_keep ++
             map (\ tau -> (fst tau, change_target new (snd tau))) sharp_modify)
       ((new, assertion_of p old) : assertion_impl p);
                                       } in
 bindb (catch_errora
         (forallM
           (\ l ->
             check (equal_formula (assertion_of p l) (assertion_of q l))
               ((showsl_lit "location condition of initial state " .
                  showsl_sharp l) .
                 showsl_lit " has been changed"))
           (initiala p))
         (\ x -> Inl (snd x)))
   (\ _ -> Inr q);
                                   });
                               })))))));

location_addition ::
  forall a b c d e f.
    (Eq a, Ceq b, Ccompare b, Eq b, Eq c, Showl c, Default d, Showl d,
      Ccompare e, Eq e, Showl e,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (Term a (c, b) -> String -> String) ->
                        (d -> Formula (Term a (c, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (c, b) -> Formula (Term a (c, b))) ->
                            Lts_impl a c b (Sharp e) f ->
                              Location_addition_info a c b (Sharp e) f ->
                                Sum (String -> String)
                                  (Lts_impl a c b (Sharp e) f);
location_addition type_of_fun bool_types showsl_atom logic_checker negate_atom p
  info =
  (case info of {
    Location_Addition_Info src _ _ _ ->
      (if not (membera (nodes_lts_impl p) src)
        then location_addition_incoming type_of_fun bool_types showsl_atom
               logic_checker negate_atom p info
        else location_addition_outgoing type_of_fun bool_types showsl_atom
               logic_checker negate_atom p info);
  });

call_graph_sharp_impl ::
  forall a b c d e.
    (Eq d) => Lts_impl a b c (Sharp d) e -> [(Sharp d, Sharp d)];
call_graph_sharp_impl r =
  remdups
    (concatMap
      (\ tau ->
        (if is_sharp (source (snd tau))
          then [(source (snd tau), target (snd tau))] else []))
      (transitions_impl r));

scc_decomposition ::
  forall a b c d e.
    (Ccompare d, Compare_order d, Eq d,
      Showl d) => Lts_impl a b c (Sharp d) e ->
                    [[Sharp d]] ->
                      Sum (String -> String) [Lts_impl a b c (Sharp d) e];
scc_decomposition cp sccs_info =
  let {
    cg = call_graph_sharp_impl cp;
    sccs = scc_decomp cg;
  } in bindb (catch_errora
               (forallM
                 (\ c ->
                   check (any (\ d -> set_eq (set c) (set d)) sccs_info)
                     ((showsl_lit "could not find SCC " . showsl_lista c) .
                       showsl_lit " in provided decomposition"))
                 sccs)
               (\ x -> Inl (snd x)))
         (\ _ ->
           let {
             trans = transitions_impl cp;
           } in (case partition (\ tau -> is_sharp (source (snd tau))) trans of
                  {
                  (sharp, flat) ->
                    let {
                      cPs = map (\ c ->
                                  let {
                                    l = set c;
                                  } in Lts_Impl (initiala cp)
 (flat ++
   filter (\ tau -> member (source (snd tau)) l && member (target (snd tau)) l)
     sharp)
 (assertion_impl cp))
                              sccs_info;
                    } in catch_errora (Inr cPs)
                           (\ x ->
                             Inl (((showsl_lit
                                      "error is SCC-decomposition w.r.t. sccs_info\n" .
                                     showsl_lista sccs_info) .
                                    showsl_literal "\n") .
                                   x));
                }));

cut_transition_split ::
  forall a b c d e.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Showl a, Ccompare e, Eq e,
      Showl e) => Cut_transition_split_info a ->
                    Lts_impl b c d (Sharp e) a ->
                      Sum (String -> String) [Lts_impl b c d (Sharp e) a];
cut_transition_split (Cut_Transition_Split_Info ct_ids) cp =
  catch_errora
    (case partition ((\ tau -> is_sharp (source tau)) . snd)
            (transitions_impl cp)
      of {
      (p, r) ->
        (case partition ((is_sharp . target) . snd) r of {
          (ct, rr) ->
            let {
              slist = map (source . snd) p;
              s = set slist;
              cT_ids = set (concat ct_ids);
            } in bindb (catch_errora
                         (forallM
                           (\ l ->
                             check (not (is_sharp l))
                               ((showsl_lit "initial state " . showsl_sharp l) .
                                 showsl_lit " must not be sharped"))
                           (initiala cp))
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM
                               (\ (t_id, cta) ->
                                 check (if member (target cta) s
 then member t_id cT_ids else True)
                                   (((showsl_lit
"did not find cut-transition " .
                                       showsl t_id) .
                                      showsl_lit
" in partition\nrelevant cut-points are: ") .
                                     showsl_list_sharp slist))
                               ct)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         let {
                           rrp = rr ++ p;
                         } in Inr (map (\ ct_idsa ->
 Lts_Impl (initiala cp) (filter (\ cta -> membera ct_idsa (fst cta)) ct ++ rrp)
   (assertion_impl cp))
                                    ct_ids)));
        });
    })
    (\ x -> Inl (showsl_lit "error in splitting cut transitions on LTS\n" . x));

showsl_cooperation_program ::
  forall a b c d e.
    (Showl d, Showl e) => Lts_impl a b c (Sharp d) e -> String -> String;
showsl_cooperation_program (Lts_Impl i tran lc) =
  let {
    trana = filter (\ (_, tt) -> is_sharp (target tt)) tran;
    tranb = (case partition (\ (_, tt) -> is_sharp (source tt)) trana of {
              (ss, fs) -> fs ++ ss;
            });
  } in showsl_lit "Cooperation program (only sharp-part)\n" .
         showsl_sep
           (\ (t, tt) ->
             (((showsl t . showsl_lit ": ") . showsl_sharp (source tt)) .
               showsl_lit " --> ") .
               showsl_sharp (target tt))
           (showsl_literal "\n") tranb .
    showsl_literal "\n";

check_cooperation_proof ::
  forall a b c d e f.
    (Ccompare a, Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Default c,
      Showl c, Ccompare d, Eq d, Showl d, Ccompare e, Compare_order e, Eq e,
      Showl e, Ceq f, Ccompare f, Eq f, Mapping_impl f, Set_impl f,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (c -> Formula (Term a (d, b)) ->
                              Sum (String -> String) ()) ->
                        (c -> Formula (Term a (Trans_var d, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (d, b) -> String -> String) ->
                            (Term a (Trans_var d, b) -> String -> String) ->
                              (Term a (d, b) -> Formula (Term a (d, b))) ->
                                (Term a (Trans_var d, b) ->
                                  Formula (Term a (Trans_var d, b))) ->
                                  b -> (Term a (Trans_var d, b) ->
 Term a (Trans_var d, b) -> Formula (Term a (Trans_var d, b))) ->
 (Term a (Trans_var d, b) ->
   Term a (Trans_var d, b) -> Formula (Term a (Trans_var d, b))) ->
   (Term a (Trans_var d, b) -> Bool) ->
     (Trans_var d ->
       b -> Formula (Term a (Trans_var d, b)) -> Sum (String -> String) ()) ->
       (String -> String) ->
         Lts_impl a d b (Sharp e) f ->
           Cooperation_proof a d b e f c -> Sum (String -> String) ();
check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
  less_eq_formula less_formula is_constant definability_checker i cPi
  (Cut_Transition_Split scc_proofs) =
  debug i "Cut Transition Split"
    (bindb
      (catch_errora
        (cut_transition_split (Cut_Transition_Split_Info (map fst scc_proofs))
          cPi)
        (\ x ->
          Inl (((i . showsl_lit ": error in cut-transition split\n") .
                 showsl_cooperation_program cPi) .
                x)))
      (\ sccs ->
        catch_errora
          (forallM_index
            (\ (scc, prof) j ->
              catch_errora
                (check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne
                  ne2 dom_type less_eq_formula less_formula is_constant
                  definability_checker (add_index i (suc j)) scc prof)
                (\ x ->
                  Inl ((i . showsl_lit ": error below cut-transition split\n") .
                        x)))
            (zip sccs (map snd scc_proofs)))
          (\ x -> Inl (snd x))));
check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
  less_eq_formula less_formula is_constant definability_checker i cPi
  (Scc_Decomp scc_proofs) =
  debug i "SCC Decomp"
    (bindb
      (catch_errora (scc_decomposition cPi (map fst scc_proofs))
        (\ x ->
          Inl (((i . showsl_lit ": error in Scc decomposition\n") .
                 showsl_cooperation_program cPi) .
                x)))
      (\ sccs ->
        catch_errora
          (forallM_index
            (\ (scc, prof) j ->
              catch_errora
                (check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne
                  ne2 dom_type less_eq_formula less_formula is_constant
                  definability_checker (add_index i (suc j)) scc prof)
                (\ x ->
                  Inl ((i . showsl_lit ": error below Scc decomposition\n") .
                        x)))
            (zip sccs (map snd scc_proofs)))
          (\ x -> Inl (snd x))));
check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
  less_eq_formula less_formula is_constant definability_checker i cPi
  (Fresh_Variable_Addition info iproof) =
  debug i "Fresh Variable Addition"
    (bindb
      (catch_errora
        (fresh_variable_addition type_of_fun bool_types definability_checker sa2
          cPi info)
        (\ x ->
          Inl (((i . showsl_lit ": error in fresh variable addition\n") .
                 showsl_cooperation_program cPi) .
                x)))
      (\ q ->
        catch_errora
          (check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2
            dom_type less_eq_formula less_formula is_constant
            definability_checker (add_index i one_nat) q iproof)
          (\ x ->
            Inl ((i . showsl_lit ": error below fresh variable addition\n") .
                  x))));
check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
  less_eq_formula less_formula is_constant definability_checker i cPi
  (Location_Addition info iproof) =
  debug i "Location Addition"
    (bindb
      (catch_errora (location_addition type_of_fun bool_types sa tc ne cPi info)
        (\ x ->
          Inl (((i . showsl_literal ": error in location addition\n") .
                 showsl_cooperation_program cPi) .
                x)))
      (\ q ->
        catch_errora
          (check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2
            dom_type less_eq_formula less_formula is_constant
            definability_checker (add_index i one_nat) q iproof)
          (\ x ->
            Inl ((i . showsl_literal ": error below location addition\n") .
                  x))));
check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
  less_eq_formula less_formula is_constant definability_checker i cPi
  (Transition_Removal info iproof) =
  debug i "Transition Removal"
    (bindb
      (catch_errora
        (lex_processor type_of_fun bool_types sa2 tc2 ne2 dom_type
          less_eq_formula less_formula is_constant info cPi)
        (\ x ->
          Inl (((i . showsl_lit ": error in transition removal\n") .
                 showsl_cooperation_program cPi) .
                x)))
      (\ cPia ->
        catch_errora
          (check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2
            dom_type less_eq_formula less_formula is_constant
            definability_checker (add_index i one_nat) cPia iproof)
          (\ x ->
            Inl ((i . showsl_lit ": error below transition removal\n") . x))));
check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
  less_eq_formula less_formula is_constant definability_checker i cPi
  (Invariants_Update iproof cproof) =
  debug i "Invariants_Update"
    (bindb
      (catch_errora
        (invariant_proof_checker type_of_fun bool_types tc tc2 sa sa2 ne ne2 cPi
          iproof)
        (\ x ->
          Inl (((i . showsl_lit ": error in invariant update\n") .
                 showsl_cooperation_program cPi) .
                x)))
      (\ ia ->
        bindb (fix_invariants cPi ia)
          (\ q ->
            catch_errora
              (check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne
                ne2 dom_type less_eq_formula less_formula is_constant
                definability_checker (add_index i one_nat) q cproof)
              (\ x ->
                Inl ((i . showsl_lit ": error below invariant update\n") .
                      x)))));
check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
  less_eq_formula less_formula is_constant definability_checker i cPi Triviala =
  debug i "Trivial CP"
    (catch_errora (trivial_termination_checker sa sa2 cPi)
      (\ x ->
        Inl ((i . showsl_lit
                    ": error in trivial cooperation termination checker\n") .
              x)));

check_exists_cut ::
  forall a b c d e.
    (Eq a, Eq b, Showl b, Eq c, Default d, Showl d, Eq e,
      Showl e) => (Term a (b, c) -> String -> String) ->
                    (d -> Formula (Term a (b, c)) ->
                            Sum (String -> String) ()) ->
                      (Term a (b, c) -> Formula (Term a (b, c))) ->
                        [Transition_rule a b c (Sharp e)] ->
                          e -> Sum (String -> String) ();
check_exists_cut showsl_atom logic_checker negate_atom taus n =
  check (any (\ tau ->
               equal_sharp (source tau) (Flat n) &&
                 equal_sharp (target tau) (Sharpa n) &&
                   isOK (check_skip_transition showsl_atom logic_checker
                          negate_atom tau))
          taus)
    (showsl_lit "missing skip transition for " . showsl n);

sharp_transition ::
  forall a b c d. Transition_rule a b c d -> Transition_rule a b c (Sharp d);
sharp_transition (Transition l r phi) = Transition (Sharpa l) (Sharpa r) phi;

flat_transition ::
  forall a b c d. Transition_rule a b c d -> Transition_rule a b c (Sharp d);
flat_transition (Transition l r phi) = Transition (Flat l) (Flat r) phi;

make_copy_prog ::
  forall a b c d e.
    Lts_impl a b c d e ->
      [(Sharp e, Transition_rule a b c (Sharp d))] ->
        Lts_impl a b c (Sharp d) (Sharp e);
make_copy_prog (Lts_Impl init tau_s lc) cutpoints =
  Lts_Impl (map Flat init)
    (map (\ (tr, tau) -> (Flat tr, flat_transition tau)) tau_s ++
      cutpoints ++ map (\ (tr, tau) -> (Sharpa tr, sharp_transition tau)) tau_s)
    (map (\ (tr, a) -> (Flat tr, a)) lc ++
      map (\ (tr, a) -> (Sharpa tr, a)) lc);

call_graph_impl :: forall a b c d e. (Eq d) => Lts_impl a b c d e -> [(d, d)];
call_graph_impl r =
  remdups
    (map (\ tau -> (source (snd tau), target (snd tau))) (transitions_impl r));

check_cut_points ::
  forall a.
    (Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showl a) => [(a, a)] -> Set a -> Sum (String -> String) ();
check_cut_points r x =
  check_acyclic
    (filter (\ ab -> not (member (fst ab) x) && not (member (snd ab) x)) r);

natural :: forall a. Sharp a -> a;
natural (Sharpa l) = l;
natural (Flat l) = l;

create_initial_cp_prog ::
  forall a b c d e f.
    (Eq a, Ceq b, Ccompare b, Eq b, Eq c, Showl c, Default d, Showl d, Ceq e,
      Ccompare e, Compare_order e, Eq e, Set_impl e, Showl e,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (Term a (c, b) -> String -> String) ->
                        (d -> Formula (Term a (c, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (c, b) -> Formula (Term a (c, b))) ->
                            Lts_impl a c b e f ->
                              [[(Sharp f, Transition_rule a c b (Sharp e))]] ->
                                Sum (String -> String)
                                  [Lts_impl a c b (Sharp e) (Sharp f)];
create_initial_cp_prog type_of_fun bool_types showsl_atom logic_checker
  negate_atom p cp_trans_list =
  (case let {
          cp_trans = concat cp_trans_list;
          cut_points =
            remdups (map (\ (_, tau) -> natural (source tau)) cp_trans);
        } in bindb (catch_errora
                     (check_cut_points (call_graph_impl p) (set cut_points))
                     (\ x ->
                       Inl (showsl_lit
                              "problem in ensuring validity of cutpoints\n" .
                             x)))
               (\ _ ->
                 bindb (catch_errora
                         (forallM
                           (\ (n, cp) ->
                             check (transition_rule type_of_fun bool_types cp)
                               (showsl_sharp n .
                                 showsl_lit " is non valid transition rule"))
                           cp_trans)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     catch_errora
                       (forallM
                         (check_exists_cut showsl_atom logic_checker negate_atom
                           (map snd cp_trans))
                         cut_points)
                       (\ x -> Inl (snd x))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (map (make_copy_prog p) cp_trans_list);
  });

check_termination_proof ::
  forall a b c d e f.
    (Ccompare a, Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Default c,
      Showl c, Ccompare d, Eq d, Showl d, Cenum e, Ceq e, Ccompare e,
      Compare_order e, Eq e, Mapping_impl e, Set_impl e, Showl e, Ceq f,
      Ccompare f, Eq f, Mapping_impl f, Set_impl f,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (c -> Formula (Term a (d, b)) ->
                              Sum (String -> String) ()) ->
                        (c -> Formula (Term a (Trans_var d, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (d, b) -> String -> String) ->
                            (Term a (Trans_var d, b) -> String -> String) ->
                              (Term a (d, b) -> Formula (Term a (d, b))) ->
                                (Term a (Trans_var d, b) ->
                                  Formula (Term a (Trans_var d, b))) ->
                                  b -> (Term a (Trans_var d, b) ->
 Term a (Trans_var d, b) -> Formula (Term a (Trans_var d, b))) ->
 (Term a (Trans_var d, b) ->
   Term a (Trans_var d, b) -> Formula (Term a (Trans_var d, b))) ->
   (Term a (Trans_var d, b) -> Bool) ->
     (Trans_var d ->
       b -> Formula (Term a (Trans_var d, b)) -> Sum (String -> String) ()) ->
       (String -> String) ->
         Lts_impl a d b e f ->
           Termination_proof a d b e f c -> Sum (String -> String) ();
check_termination_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
  less_eq_formula less_formula is_constant definability_checker i pi
  (Via_Cooperation cp_proofs) =
  debug i "Switch to Cooperation Program"
    (bindb
      (catch_errora
        (create_initial_cp_prog type_of_fun bool_types sa tc ne pi
          (map fst cp_proofs))
        (\ x ->
          Inl ((i . showsl_lit
                      ": error in creating initial cooperation program\n") .
                x)))
      (\ cPi ->
        catch_errora
          (forallM_index
            (\ (r, prf) n ->
              catch_errora
                (check_cooperation_proof type_of_fun bool_types tc tc2 sa sa2 ne
                  ne2 dom_type less_eq_formula less_formula is_constant
                  definability_checker (add_index i n) r prf)
                (\ x ->
                  Inl ((i . showsl_lit
                              ": error below switching to initial cooperation program\n") .
                        x)))
            (zip cPi (map snd cp_proofs)))
          (\ x -> Inl (snd x))));
check_termination_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
  less_eq_formula less_formula is_constant definability_checker i pi
  (Invariants_Update_LTS iproof cproof) =
  debug i "Invariant Update"
    (bindb
      (catch_errora
        (invariant_proof_checker type_of_fun bool_types tc tc2 sa sa2 ne ne2 pi
          iproof)
        (\ x -> Inl ((i . showsl_lit ": error in invariant update\n") . x)))
      (\ ia ->
        bindb (fix_invariants pi ia)
          (\ q ->
            catch_errora
              (check_termination_proof type_of_fun bool_types tc tc2 sa sa2 ne
                ne2 dom_type less_eq_formula less_formula is_constant
                definability_checker (add_index i one_nat) q cproof)
              (\ x ->
                Inl ((i . showsl_lit ": error below invariant update\n") .
                      x)))));
check_termination_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type
  less_eq_formula less_formula is_constant definability_checker i pi Trivialb =
  debug i "Trivial Termination"
    (catch_errora
      (check (null (transitions_impl pi))
        (showsl_lit "transition rules remains at trivial termination proof"))
      (\ x ->
        Inl ((i . showsl_lit ": error in trivial termination checker\n") . x)));

checka ::
  forall a b c d e f.
    (Ccompare a, Eq a, Showl a, Ceq b, Ccompare b, Eq b, Showl b, Default c,
      Showl c, Ccompare d, Eq d, Showl d, Cenum e, Ceq e, Ccompare e,
      Compare_order e, Eq e, Mapping_impl e, Set_impl e, Showl e, Ceq f,
      Ccompare f, Eq f, Mapping_impl f, Set_impl f,
      Showl f) => (a -> ([b], b)) ->
                    Set b ->
                      (c -> Formula (Term a (d, b)) ->
                              Sum (String -> String) ()) ->
                        (c -> Formula (Term a (Trans_var d, b)) ->
                                Sum (String -> String) ()) ->
                          (Term a (d, b) -> String -> String) ->
                            (Term a (Trans_var d, b) -> String -> String) ->
                              (Term a (d, b) -> Formula (Term a (d, b))) ->
                                (Term a (Trans_var d, b) ->
                                  Formula (Term a (Trans_var d, b))) ->
                                  b -> (Term a (Trans_var d, b) ->
 Term a (Trans_var d, b) -> Formula (Term a (Trans_var d, b))) ->
 (Term a (Trans_var d, b) ->
   Term a (Trans_var d, b) -> Formula (Term a (Trans_var d, b))) ->
   (Term a (Trans_var d, b) -> Bool) ->
     (Trans_var d ->
       b -> Formula (Term a (Trans_var d, b)) -> Sum (String -> String) ()) ->
       Lts_impl a d b e f ->
         Termination_proof a d b e f c -> Sum (String -> String) ();
checka type_of_fun bool_types tc tc2 sa sa2 ne ne2 dom_type less_eq_formula
  less_formula is_constant definability_checker pi prf =
  bindb (debug id "init - Check well-formedness"
          (catch_errora (check_lts_impl type_of_fun bool_types pi)
            (\ x -> Inl (showsl_lit "input LTS is not well-formed" . x))))
    (\ _ ->
      check_termination_proof type_of_fun bool_types tc tc2 sa sa2 ne ne2
        dom_type less_eq_formula less_formula is_constant definability_checker
        id pi prf);

def_checker_main ::
  forall a.
    (Eq a) => a -> Ty -> Term Sig (a, Ty) ->
                           Term Sig (a, Ty) ->
                             Term Sig (a, Ty) -> Term Sig (a, Ty) -> Bool;
def_checker_main x ty l1 r1 l2 r2 =
  is_bool type_of_fun (inserta BoolT (set_empty (of_phantom set_impl_ty)))
    (Fun LeF [l1, r1]) &&
    has_type type_of_fun r1 ty &&
      is_bool type_of_fun (inserta BoolT (set_empty (of_phantom set_impl_ty)))
        (Fun LeF [l2, r2]) &&
        equal_term (Var (x, ty)) l1 &&
          equal_term l1 r2 &&
            equal_term l2 r1 && not (contains_var_term (x, ty) r1);

def_checker_maina ::
  forall a. (Eq a) => a -> Ty -> Term Sig (a, Ty) -> Term Sig (a, Ty) -> Bool;
def_checker_maina x ty l1 r1 =
  is_bool type_of_fun (inserta BoolT (set_empty (of_phantom set_impl_ty)))
    (Fun EqF [l1, r1]) &&
    has_type type_of_fun r1 ty &&
      equal_term (Var (x, ty)) l1 && not (contains_var_term (x, ty) r1);

def_checker_eq ::
  forall a.
    (Eq a) => a -> Ty -> Formula (Term Sig (a, Ty)) ->
                           Sum (String -> String) ();
def_checker_eq x ty eq =
  (case eq of {
    Atom (Var _) -> Inl (showsl_lit "Invalid literal");
    Atom (Fun LessF _) -> Inl (showsl_lit "Invalid literal");
    Atom (Fun LeF _) -> Inl (showsl_lit "Invalid literal");
    Atom (Fun (SumF _) _) -> Inl (showsl_lit "Invalid literal");
    Atom (Fun (ConstF _) _) -> Inl (showsl_lit "Invalid literal");
    Atom (Fun (ProdF _) _) -> Inl (showsl_lit "Invalid literal");
    Atom (Fun EqF []) -> Inl (showsl_lit "Invalid literal");
    Atom (Fun EqF [_]) -> Inl (showsl_lit "Invalid literal");
    Atom (Fun EqF [l1, r1]) ->
      check (def_checker_maina x ty l1 r1 || def_checker_maina x ty r1 l1)
        (showsl_lit "Non-equation not supported");
    Atom (Fun EqF (_ : _ : _ : _)) -> Inl (showsl_lit "Invalid literal");
    NegAtom _ -> Inl (showsl_lit "Invalid clause");
    Conjunction _ -> Inl (showsl_lit "Invalid clause");
    Disjunction _ -> Inl (showsl_lit "Invalid clause");
  });

def_checker ::
  forall a.
    (Eq a, Linorder a,
      Showl a) => a -> Ty -> Formula (Term Sig (a, Ty)) ->
                               Sum (String -> String) ();
def_checker x ty phi =
  catch_errora
    (case phi of {
      Atom _ -> def_checker_eq x ty phi;
      NegAtom _ -> def_checker_eq x ty phi;
      Conjunction [] -> Inr ();
      Conjunction [eq] -> def_checker_eq x ty eq;
      Conjunction [Atom (Var _), _] -> Inl (showsl_lit "Invalid 1st literal");
      Conjunction [Atom (Fun LessF _), _] ->
        Inl (showsl_lit "Invalid 1st literal");
      Conjunction [Atom (Fun LeF []), _] ->
        Inl (showsl_lit "Invalid 1st literal");
      Conjunction [Atom (Fun LeF [_]), _] ->
        Inl (showsl_lit "Invalid 1st literal");
      Conjunction [Atom (Fun LeF [l1, r1]), lt2] ->
        (case lt2 of {
          Atom (Var _) -> Inl (showsl_lit "Invalid 2nd literal");
          Atom (Fun LessF _) -> Inl (showsl_lit "Invalid 2nd literal");
          Atom (Fun LeF []) -> Inl (showsl_lit "Invalid 2nd literal");
          Atom (Fun LeF [_]) -> Inl (showsl_lit "Invalid 2nd literal");
          Atom (Fun LeF [l2, r2]) ->
            check (def_checker_main x ty l1 r1 l2 r2 ||
                    def_checker_main x ty l2 r2 l1 r1)
              (showsl_lit "Non-equation not supported");
          Atom (Fun LeF (_ : _ : _ : _)) ->
            Inl (showsl_lit "Invalid 2nd literal");
          Atom (Fun (SumF _) _) -> Inl (showsl_lit "Invalid 2nd literal");
          Atom (Fun (ConstF _) _) -> Inl (showsl_lit "Invalid 2nd literal");
          Atom (Fun (ProdF _) _) -> Inl (showsl_lit "Invalid 2nd literal");
          Atom (Fun EqF _) -> Inl (showsl_lit "Invalid 2nd literal");
          NegAtom _ -> Inl (showsl_lit "Invalid 2nd clause");
          Conjunction _ -> Inl (showsl_lit "Invalid 2nd clause");
          Disjunction _ -> Inl (showsl_lit "Invalid 2nd clause");
        });
      Conjunction [Atom (Fun LeF (_ : _ : _ : _)), _] ->
        Inl (showsl_lit "Invalid 1st literal");
      Conjunction [Atom (Fun (SumF _) _), _] ->
        Inl (showsl_lit "Invalid 1st literal");
      Conjunction [Atom (Fun (ConstF _) _), _] ->
        Inl (showsl_lit "Invalid 1st literal");
      Conjunction [Atom (Fun (ProdF _) _), _] ->
        Inl (showsl_lit "Invalid 1st literal");
      Conjunction [Atom (Fun EqF _), _] ->
        Inl (showsl_lit "Invalid 1st literal");
      Conjunction [NegAtom _, _] -> Inl (showsl_lit "Invalid 1st clause");
      Conjunction [Conjunction _, _] -> Inl (showsl_lit "Invalid 1st clause");
      Conjunction [Disjunction _, _] -> Inl (showsl_lit "Invalid 1st clause");
      Conjunction (_ : _ : _ : _) ->
        Inl (showsl_lit "Conjunction of more than two");
      Disjunction _ -> def_checker_eq x ty phi;
    })
    (\ xa ->
      Inl (((((showsl_lit "error in definibility checker for " . showsl x) .
               showsl_lit " on formula\n  ") .
              showsl_formula showsl_IA_exp phi) .
             showsl_literal "\n") .
            xa));

is_constant :: forall a b. Term a b -> Bool;
is_constant (Fun uu []) = True;
is_constant (Var v) = False;
is_constant (Fun v (vb : vc)) = False;

check_termination ::
  forall a b c.
    (Ccompare a, Compare a, Eq a, Mapping_impl a, Linorder a, Showl a, Cenum b,
      Ceq b, Ccompare b, Compare_order b, Eq b, Mapping_impl b, Set_impl b,
      Showl b, Ceq c, Ccompare c, Eq c, Mapping_impl c, Set_impl c,
      Showl c) => Lts_impl Sig a Ty b c ->
                    Termination_proof Sig a Ty b c Hints ->
                      Sum (String -> String) ();
check_termination =
  checka type_of_fun (inserta BoolT (set_empty (of_phantom set_impl_ty)))
    check_clause check_clause showsl_IA_exp showsl_IA_exp negatea negatea IntT
    (\ s t -> Atom (Fun LeF [s, t])) (\ s t -> Atom (Fun LessF [s, t]))
    is_constant def_checker;

get_args_impl :: forall a b. Bool -> Term a b -> [Term a b];
get_args_impl True t = args t;
get_args_impl False t = [t];

innermost_repl_map_impl ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    ([Term a [Char]] ->
                      Term a [Char] -> Term a (Sum () [Char])) ->
                      [(Term a [Char], Term a [Char])] -> [((a, Nat), Nat)];
innermost_repl_map_impl r ecap p =
  remdups
    (concatMap
      (\ (a, b) ->
        (case a of {
          (l, ra) ->
            (\ ba ->
              concatMap
                (\ u ->
                  (if not (is_Var u)
                    then concatMap
                           (\ rs ->
                             concatMap
                               (\ f ->
                                 concatMap
                                   (\ n ->
                                     concatMap
                                       (\ i ->
 (if contains_var_term (Inl ()) (ecap (get_args_impl ba l) (nth rs i))
   then [(f, i)] else []))
                                       (upt zero_nat n))
                                   [snd f])
                               [the (root u)])
                           [args u]
                    else []))
                (supteq_list ra));
        })
          b)
      (map (\ lr -> (lr, True)) r ++ map (\ st -> (st, False)) p));

mu_i_P_impl ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    ([Term a [Char]] ->
                      Term a [Char] -> Term a (Sum () [Char])) ->
                      [(Term a [Char], Term a [Char])] ->
                        ([(a, Nat)], ((a, Nat) -> Set Nat, String));
mu_i_P_impl r ecap p =
  let {
    fis = innermost_repl_map_impl r ecap p;
    fs = remdups (map fst fis);
    mu = (\ f ->
           set (map_filter
                 (\ x ->
                   (if (case x of {
                         (g, _) -> g == f;
                       })
                     then Just (snd x) else Nothing))
                 fis));
  } in (fs, (precompute_fun mu fs, "innermost URM"));

mu_i_impl ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    ([Term a [Char]] ->
                      Term a [Char] -> Term a (Sum () [Char])) ->
                      ([(a, Nat)], ((a, Nat) -> Set Nat, String));
mu_i_impl r ecap = mu_i_P_impl r ecap [];

default_fs ::
  forall a.
    (Compare_order a,
      Showl a) => [(Term a [Char], Term a [Char])] -> [(a, Nat)];
default_fs r = funas_trs_list r;

full_empty ::
  forall a. (Eq a) => [(a, Nat)] -> ([(a, Nat)], ((a, Nat) -> Set Nat, String));
full_empty fs =
  let {
    fsa = filter (\ (_, n) -> not (equal_nat n zero_nat)) fs;
  } in (fsa, ((\ f ->
                (if membera fsa f then full_af f
                  else set_empty (of_phantom set_impl_nat))),
               "full AF"));

get_fs_mu ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    ([Term a [Char]] ->
                      Term a [Char] -> Term a (Sum () [Char])) ->
                      Bool ->
                        Complexity_measure a [Char] ->
                          ([(a, Nat)], ((a, Nat) -> Set Nat, String));
get_fs_mu r ecap inn (Runtime_Complexity c d) =
  (if inn && less_eq_set (inf_set (set c) (set (defined_list r))) bot_set
    then mu_i_impl r ecap else full_empty (remdups (c ++ d ++ default_fs r)));
get_fs_mu r ecap inn (Derivational_Complexity f) =
  full_empty (remdups (f ++ default_fs r));

is_Fsharp_term ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Set (a, Nat) -> Set (a, Nat) -> Term a b -> Bool;
is_Fsharp_term uu uv (Var uw) = False;
is_Fsharp_term fs fa (Fun f ts) =
  member (f, size_list ts) fs &&
    less_eq_set (set (concatMap funas_term_list ts)) fa;

add_funas_mctxt :: forall a b. Mctxt a b -> [(a, Nat)] -> [(a, Nat)];
add_funas_mctxt (MFun f cs) fs =
  (f, size_list cs) : foldr add_funas_mctxt cs fs;
add_funas_mctxt (MVar v) fs = fs;
add_funas_mctxt MHole fs = fs;

funas_mctxt_list :: forall a b. Mctxt a b -> [(a, Nat)];
funas_mctxt_list c = add_funas_mctxt c [];

split_term ::
  forall a b. (Term a b -> Bool) -> Term a b -> (Mctxt a b, [Term a b]);
split_term p (Var x) = (if p (Var x) then (MHole, [Var x]) else (MVar x, []));
split_term p (Fun f ts) =
  (if p (Fun f ts) then (MHole, [Fun f ts])
    else let {
           us = map (split_term p) ts;
         } in (MFun f (map fst us), concatMap snd us));

split_DP ::
  forall a b.
    (Ceq a,
      Ccompare a) => Set (a, Nat) ->
                       (Term a b, Term a b) -> (Mctxt a b, [Term a b]);
split_DP fs =
  (\ r ->
    split_term (\ t -> not (is_Var t) && member (the (root t)) fs) (snd r));

check_DP_complexity ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Showl a,
      Showl b) => [(Term a b, Term a b)] ->
                    Complexity_measure a b ->
                      Sum (String -> String)
                        ([(Term a b, Term a b)],
                          ([(Term a b, Term a b)],
                            ([(a, Nat)], ([(a, Nat)], [(a, Nat)]))));
check_DP_complexity p (Derivational_Complexity uu) =
  Inl (showsl_lit "require runtime complexity");
check_DP_complexity p (Runtime_Complexity c fs) =
  let {
    fsa = set fs;
  } in (case partition (\ lr -> member (the (root (fst lr))) fsa) p of {
         (rs, r) ->
           let {
             cs_ts = map (split_DP fsa) rs;
             cp = remdups (concatMap (funas_mctxt_list . fst) cs_ts);
             cpa = set cp;
             f = remdups
                   (c ++ funas_trs_list r ++
                           concat
                             (concatMap
                               (\ (fsb, _) -> map funas_term_list (args fsb))
                               rs) ++
                             concat
                               (concatMap
                                 (\ (_, a) ->
                                   concatMap
                                     (\ t -> map funas_term_list (args t)) a)
                                 cs_ts));
             fa = set f;
           } in bindb (check
                        (is_empty (inf_set fa fsa) &&
                          is_empty (inf_set fa cpa) &&
                            is_empty (inf_set fsa cpa))
                        (showsl_lit "symbols are not disjoint"))
                  (\ _ ->
                    bindb (check
                            (all (\ lr -> is_Fsharp_term fsa fa (fst lr)) rs)
                            (showsl_lit "lhss of RS are not sharp terms"))
                      (\ _ -> Inr (rs, (r, (cp, (fs, f))))));
       });

get_fs_mu_DP ::
  forall a.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a,
      Showl a) => [(Term a [Char], Term a [Char])] ->
                    ([Term a [Char]] ->
                      Term a [Char] -> Term a (Sum () [Char])) ->
                      Bool ->
                        [(Term a [Char], Term a [Char])] ->
                          Complexity_measure a [Char] ->
                            ([(a, Nat)], ((a, Nat) -> Set Nat, String));
get_fs_mu_DP r ecap inn s cm =
  (case get_fs_mu r ecap inn cm of {
    (fs, (mu, info)) ->
      (case check_DP_complexity r cm of {
        Inl _ -> (fs, (mu, info));
        Inr (rs, (_, (cp, (_, _)))) ->
          (if all (membera rs) s
            then (list_inter fs cp,
                   ((\ f ->
                      (if membera cp f then mu f
                        else set_empty (of_phantom set_impl_nat))),
                     info ++ " with DPs"))
            else (fs, (mu, info)));
      });
  });

showsl_complexity_class :: Complexity_class -> String -> String;
showsl_complexity_class c =
  (if equal_nat (degree c) zero_nat then showsl_lit "O(1)"
    else (if equal_nat (degree c) one_nat then showsl_lit "O(n)"
           else (showsl_lit "O(n^" . showsl_nat (degree c)) . showsl_lit ")"));

is_ur_closed_af_impl_tp_mv_impl ::
  forall a b.
    (Compare a, Eq a, Ceq b,
      Ccompare b) => ([Term a [Char]] ->
                       Term a [Char] -> Term a (Sum () [Char])) ->
                       (Term a [Char] -> Bool) ->
                         [(Term a [Char], b)] ->
                           ((a, Nat) -> Set Nat) ->
                             Set (Term a [Char], b) ->
                               [Term a [Char]] -> Term a [Char] -> Bool;
is_ur_closed_af_impl_tp_mv_impl ic qnf r pi =
  let {
    urc = (\ s -> is_ur_closed_term_af_impl qnf (ic s) pi r);
  } in (\ u s ->
         let {
           sa = map (map_term (\ x -> x)
                      (\ a ->
                        Char False False False True True True True False : a))
                  s;
         } in (\ t ->
                urc sa u sa
                  (map_term (\ x -> x)
                    (\ a ->
                      Char False False False True True True True False : a)
                    t)));

extract_rt_C_D ::
  forall a b.
    Complexity_measure a b -> Sum (String -> String) ([(a, Nat)], [(a, Nat)]);
extract_rt_C_D (Runtime_Complexity c d) = Inr (c, d);
extract_rt_C_D (Derivational_Complexity v) =
  Inl (showsl_lit "runtime complexity required");

cpx ::
  forall a b c.
    Redtriple_ext a b c ->
      Complexity_measure a b -> Complexity_class -> Sum (String -> String) ();
cpx (Redtriple_ext valid s ns nst af mono_af mono desc not_wst not_sst cpx more)
  = cpx;

rule_shift_complexity_urm_ur_tt ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare_order b, Eq b,
      Set_impl b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    Redtriple_ext b [Char] () ->
                      [(Term b [Char], Term b [Char])] ->
                        [(Term b [Char], Term b [Char])] ->
                          Complexity_measure b [Char] ->
                            Complexity_class -> a -> Sum (String -> String) a;
rule_shift_complexity_urm_ur_tt i rp rdelete ur cm cc tp =
  let {
    rb = rulese i tp;
    r = rc i tp;
    rw = rwc i tp;
    r2 = ceta_list_diff r rdelete;
    rremain = rw ++ r2;
    isnf = is_QNFb i tp;
    inn = nFQ_subset_NF_rulesb i tp;
  } in (case catch_errora
               (bindb
                 (catch_errora (check_subseteq rdelete rb)
                   (\ x ->
                     Inl ((showsl_lit "rule " . showsl_rule x) .
                           showsl_lit
                             " should be deleted, but does not occur in problem")))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       bindb (check (nFQ_subset_NF_rulesb i tp)
                               (showsl_lit "innermost required"))
                         (\ _ ->
                           (case get_fs_mu_DP rb (icap_impl isnf rb) inn rdelete
                                   cm
                             of {
                             (fs, (mu, info)) ->
                               (case get_fs_mu_DP rb (icap_impl isnf rb) inn
                                       rremain cm
                                 of {
                                 (_, (pi, _)) ->
                                   bindb (extract_rt_C_D cm)
                                     (\ (cl, dl) ->
                                       let {
 c = set cl;
 d = set dl;
                                       } in
 bindb (check (null (list_inter cl (defined_list rb)))
         ((showsl_lit "constructors " . showsl_lista cl) .
           showsl_lit " must not be defined"))
   (\ _ ->
     bindb (valid rp)
       (\ _ ->
         bindb (catch_errora
                 (forallM
                   (\ (l, ra) ->
                     check (not (member (the (root l)) d &&
                                  less_eq_set
                                    (foldr (sup_set . funas_term) (args l)
                                      bot_set)
                                    c))
                       (showsl_rule (l, ra) . showsl_lit " should be usable"))
                   (list_diff rb ur))
                 (\ x -> Inl (snd x)))
           (\ _ ->
             let {
               ic = icap_impl_tp i tp;
               qnf = is_QNFb i tp;
               ra = rulese i tp;
               uu = set ur;
               is_urc = is_ur_closed_af_impl_tp_mv_impl ic qnf ra mu uu;
               pia = af_inter (af rp) pi;
               is_urc_pi = is_ur_closed_af_impl_tp_mv_impl ic qnf ra pia uu;
             } in bindb (catch_errora
                          (forallM
                            (\ (l, rd) ->
                              check (is_urc (args l) rd &&
                                      is_urc_pi (args l) rd)
                                ((showsl_lit
                                    "problem with closure properties of usable rule " .
                                   showsl_rule (l, rd)) .
                                  showsl_lit
                                    ": rhs is not closed under usable rules"))
                            ur)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (catch_errora
                              (catch_errora
                                (forallM
                                  (\ f ->
                                    check (subset (mu f) (mono_af rp f))
                                      (((((showsl_lit
     "error in monotonicity: strict order for " .
    showsl_prod f) .
   showsl_lit " ensures monotonicity in positions ") .
  showsl_position_set f (mono_af rp f)) .
 showsl_lit "\nbut usable replacement map is ") .
showsl_position_set f (mu f)))
                                  fs)
                                (\ x -> Inl (snd x)))
                              (\ x ->
                                Inl (((((x .
  showsl_lit "\nthe computed usable replacement map (") .
 showsl_literal info) .
showsl_lit ") is\n") .
                                       showsl_sep
 (\ f ->
   ((showsl_lit "mu(" . showsl_prod f) . showsl_lit ") = ") .
     showsl_position_set f (mu f))
 (showsl_literal "\n") fs) .
                                      showsl_lit
"\nand mu(f) = {} for all other symbols f")))
                        (\ _ ->
                          bindb (catch_errora
                                  (catch_errora
                                    (forallM (s rp) (list_inter rdelete ur))
                                    (\ x -> Inl (snd x)))
                                  (\ x ->
                                    Inl (showsl_lit
   "problem when orienting strict TRS\n" .
  x)))
                            (\ _ ->
                              bindb (catch_errora
                                      (catch_errora
(forallM (ns rp) (list_inter rremain ur)) (\ x -> Inl (snd x)))
                                      (\ x ->
Inl (showsl_lit "problem when orienting non-strict TRS\n" . x)))
                                (\ _ ->
                                  catch_errora (cpx rp cm cc)
                                    (\ x ->
                                      Inl
(showsl_lit "problem when ensuring complexity of order\n" . x))))))))));
                               });
                           })))))
               (\ x ->
                 Inl (((((((showsl_lit
                              "could not derive the intended complexity " .
                             showsl_complexity_class cc) .
                            showsl_lit " from the following\n") .
                           desca rp) .
                          showsl_literal "\n") .
                         x) .
                        showsl_lit "\nwith usable rules\n") .
                       showsl_trs ur))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsb i tp) (qb i tp) r2 (list_union rw rdelete));
       });

inn_usable_rules_wf_tp ::
  forall a b.
    (Compare_order b,
      Eq b) => Tp_ops_ext a b [Char] () ->
                 a -> Bool ->
                        ([Term b [Char]], Term b [Char]) ->
                          [(Term b [Char], Term b [Char])];
inn_usable_rules_wf_tp i d nfs =
  inn_usable_rules_wf (is_QNFb i d) (icap_impl_tp i d) (rulese i d) nfs;

x_1_to_x_n :: Nat -> [[Char]];
x_1_to_x_n =
  fresh_strings_list [Char False False False True True True True False] one_nat
    [];

get_innermost_strict_repl_map_rc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b, Set_impl b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    a -> [(Term b [Char], Term b [Char])] ->
                           Complexity_measure b c ->
                             ([(b, Nat)], ((b, Nat) -> Set Nat, String));
get_innermost_strict_repl_map_rc i d s (Derivational_Complexity f) =
  full_empty (remdups (f ++ default_fs (rulese i d)));
get_innermost_strict_repl_map_rc i da s (Runtime_Complexity c d) =
  let {
    r = rulese i da;
  } in (if nFQ_subset_NF_rulesb i da &&
             less_eq_set (inf_set (set c) (set (defined_list r))) bot_set
         then let {
                isNF = is_QNFb i da;
                u = inn_usable_rules_wf_tp i da True;
                a = icap_impl_tp i da;
              } in mu_approx_impl r
                     (concatMap
                       (\ (f, n) ->
                         concatMap
                           (\ xs -> map (\ lr -> (xs, (Fun f xs, lr))) s)
                           [map Var (x_1_to_x_n n)])
                       d)
                     (\ ss t -> u (ss, t)) isNF a
         else full_empty (remdups (c ++ d ++ default_fs r)));

get_innermost_strict_repl_map_rc_DP ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare_order b, Eq b,
      Set_impl b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    a -> [(Term b [Char], Term b [Char])] ->
                           Complexity_measure b [Char] ->
                             ([(b, Nat)], ((b, Nat) -> Set Nat, String));
get_innermost_strict_repl_map_rc_DP i d s t =
  (case get_innermost_strict_repl_map_rc i d s t of {
    (fs, (mu, info)) ->
      (case check_DP_complexity (rulese i d) t of {
        Inl _ -> (fs, (mu, info));
        Inr (rs, (_, (cp, (_, _)))) ->
          (if all (membera rs) s
            then (list_inter fs cp,
                   ((\ f ->
                      (if membera cp f then mu f
                        else set_empty (of_phantom set_impl_nat))),
                     info ++ " with DPs"))
            else (fs, (mu, info)));
      });
  });

rule_shift_complexity_urm_tt ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare_order b, Eq b,
      Set_impl b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    Redtriple_ext b [Char] () ->
                      [(Term b [Char], Term b [Char])] ->
                        Complexity_measure b [Char] ->
                          Complexity_class -> a -> Sum (String -> String) a;
rule_shift_complexity_urm_tt i rp rdelete cm cc tp =
  let {
    rb = rulese i tp;
    r = rc i tp;
    rw = rwc i tp;
    r2 = ceta_list_diff r rdelete;
    _ = qb i tp;
  } in (case catch_errora
               (bindb
                 (catch_errora (check_subseteq rdelete rb)
                   (\ x ->
                     Inl ((showsl_lit "rule " . showsl_rule x) .
                           showsl_lit
                             " should be deleted, but does not occur in problem")))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       (case get_innermost_strict_repl_map_rc_DP i tp rdelete cm
                         of {
                         (fs, (mu, info)) ->
                           bindb (valid rp)
                             (\ _ ->
                               bindb (catch_errora
                                       (catch_errora
 (forallM
   (\ f ->
     check (subset (mu f) (mono_af rp f))
       (((((showsl_lit "error in monotonicity: strict order for " .
             showsl_prod f) .
            showsl_lit " ensures monotonicity in positions ") .
           showsl_position_set f (mono_af rp f)) .
          showsl_lit "\nbut usable replacement map is ") .
         showsl_position_set f (mu f)))
   fs)
 (\ x -> Inl (snd x)))
                                       (\ x ->
 Inl (((((x . showsl_lit "\nthe computed usable replacement map (") .
          showsl_literal info) .
         showsl_lit ") is\n") .
        showsl_sep
          (\ f ->
            ((showsl_lit "mu(" . showsl_prod f) . showsl_lit ") = ") .
              showsl_position_set f (mu f))
          (showsl_literal "\n") fs) .
       showsl_lit "\nand mu(f) = {} for all other symbols f")))
                                 (\ _ ->
                                   bindb (catch_errora
   (catch_errora (forallM (s rp) rdelete) (\ x -> Inl (snd x)))
   (\ x -> Inl (showsl_lit "problem when orienting strict TRS\n" . x)))
                                     (\ _ ->
                                       bindb
 (catch_errora (catch_errora (forallM (ns rp) (rw ++ r2)) (\ x -> Inl (snd x)))
   (\ x -> Inl (showsl_lit "problem when orienting non-strict TRS\n" . x)))
 (\ _ ->
   catch_errora (cpx rp cm cc)
     (\ x ->
       Inl (showsl_lit "problem when ensuring complexity of order\n" . x))))));
                       }))))
               (\ x ->
                 Inl (((((showsl_lit
                            "could not derive the intended complexity " .
                           showsl_complexity_class cc) .
                          showsl_lit " from the following\n") .
                         desca rp) .
                        showsl_literal "\n") .
                       x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsb i tp) (qb i tp) r2 (list_union rw rdelete));
       });

smart_rule_shift_complexity ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare_order b, Eq b,
      Set_impl b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    Redtriple_ext b [Char] () ->
                      [(Term b [Char], Term b [Char])] ->
                        Maybe [(Term b [Char], Term b [Char])] ->
                          Complexity_measure b [Char] ->
                            Complexity_class -> a -> Sum (String -> String) a;
smart_rule_shift_complexity i rp rdelete (Just ur) cm cc tp =
  rule_shift_complexity_urm_ur_tt i rp rdelete ur cm cc tp;
smart_rule_shift_complexity i rp rdelete Nothing cm cc tp =
  rule_shift_complexity_urm_tt i rp rdelete cm cc tp;

is_ur_closed_af_impl_tp_mv ::
  forall a b.
    (Compare_order b, Eq b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           [(Term b [Char], Term b [Char])] ->
                             [Term b [Char]] -> Term b [Char] -> Bool;
is_ur_closed_af_impl_tp_mv i d pi u =
  let {
    ic = icap_impl_tp i d;
    qnf = is_QNFb i d;
    r = rulese i d;
    urc = (\ s -> is_ur_closed_term_af_impl qnf (ic s) pi r (set u));
  } in (\ s ->
         let {
           sa = map (map_term (\ x -> x)
                      (\ a ->
                        Char False False False True True True True False : a))
                  s;
         } in (\ t ->
                urc sa sa
                  (map_term (\ x -> x)
                    (\ a ->
                      Char False False False True True True True False : a)
                    t)));

usable_rules_complexity_innermost ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b, Set_impl b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    [(Term b [Char], Term b [Char])] ->
                      Complexity_measure b [Char] ->
                        Complexity_class -> a -> Sum (String -> String) a;
usable_rules_complexity_innermost i nUr cm cc cp =
  catch_errora
    (let {
       s = rc i cp;
       w = rwc i cp;
       r = s ++ w;
     } in bindb (check (nFQ_subset_NF_rulesb i cp)
                  (showsl_lit "innermost required"))
            (\ _ ->
              bindb (check_wf_trs r)
                (\ _ ->
                  bindb (extract_rt_C_D cm)
                    (\ (cl, dl) ->
                      let {
                        c = set cl;
                        d = set dl;
                        isnf = is_QNFb i cp;
                      } in bindb (check (null (list_inter cl (defined_list r)))
                                   ((showsl_lit "constructors " .
                                      showsl_lista cl) .
                                     showsl_lit " must not be defined"))
                             (\ _ ->
                               bindb (catch_errora (check_subseteq nUr r)
                                       (\ _ ->
 Inl ((showsl_lit "rule " . showsl_rules nUr) .
       showsl_lit " does not occur in problem")))
                                 (\ _ ->
                                   let {
                                     ur = list_diff r nUr;
                                   } in bindb
  (catch_errora
    (forallM
      (\ (l, ra) ->
        check (not (member (the (root l)) d &&
                     less_eq_set (foldr (sup_set . funas_term) (args l) bot_set)
                       c))
          (showsl_rule (l, ra) . showsl_lit " should be usable"))
      nUr)
    (\ x -> Inl (snd x)))
  (\ _ ->
    (case get_fs_mu r (icap_impl isnf r) True cm of {
      (_, (mu, _)) ->
        let {
          is_urc = is_ur_closed_af_impl_tp_mv i cp mu ur;
        } in bindb (catch_errora
                     (forallM
                       (\ (l, ra) ->
                         check (is_urc (args l) ra)
                           ((showsl_lit
                               "problem with closure properties of usable rule " .
                              showsl_rule (l, ra)) .
                             showsl_lit
                               ": rhs is not closed under usable rules"))
                       ur)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 Inr (mkc i (nfsb i cp) (qb i cp) (list_diff s nUr)
                       (list_diff w nUr)));
    }))))))))
    (\ x ->
      Inl (showsl_lit "error when restricting to innermost usable rules\n" .
            x));

get_signature_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
get_signature_of_cm (Derivational_Complexity f) = f;
get_signature_of_cm (Runtime_Complexity c d) = c ++ d;

usable_rules_complexity_usymbols ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showl b,
      Compare c, Eq c,
      Showl c) => Tp_ops_ext a b c () ->
                    [(Term b c, Term b c)] ->
                      Complexity_measure b c ->
                        Complexity_class -> a -> Sum (String -> String) a;
usable_rules_complexity_usymbols i nUr cm cc cp =
  catch_errora
    (let {
       s = rc i cp;
       w = rwc i cp;
       r = s ++ w;
     } in bindb (catch_errora (check_subseteq nUr r)
                  (\ _ ->
                    Inl ((showsl_lit "rule " . showsl_rules nUr) .
                          showsl_lit " does not occur in problem")))
            (\ _ ->
              let {
                ur = list_diff r nUr;
                us = set (concatMap (funas_term_list . snd) ur ++
                           get_signature_of_cm cm);
                urs = set ur;
              } in bindb (check_varcond_subset ur)
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ lr ->
                                   check (if less_eq_set (funas_term (fst lr))
       us
   then member lr urs else True)
                                     ((showsl_lit "rule " . showsl_rule lr) .
                                       showsl_lit " should be usable"))
                                 r)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           Inr (mkc i (nfsb i cp) (qb i cp) (list_diff s nUr)
                                 (list_diff w nUr))))))
    (\ x ->
      Inl (showsl_lit
             "error when restricting to usable rules w.r.t. usable symbols\n" .
            x));

usable_rules_complexity ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b, Set_impl b,
      Showl b) => Tp_ops_ext a b [Char] () ->
                    [(Term b [Char], Term b [Char])] ->
                      Complexity_measure b [Char] ->
                        Complexity_class -> a -> Sum (String -> String) a;
usable_rules_complexity i nUr cm cc cp =
  (case usable_rules_complexity_usymbols i nUr cm cc cp of {
    Inl e ->
      (case usable_rules_complexity_innermost i nUr cm cc cp of {
        Inl ea ->
          Inl ((((showsl_lit
                    "neither of the usable rules processors is applicable:\n" .
                   showsl_lit
                     "the one via usable symbols complains as follows\n") .
                  e) .
                 showsl_lit "\n\nand the one via icap and innermost says\n") .
                ea);
        Inr a -> Inr a;
      });
    Inr a -> Inr a;
  });

split_proc_complexity ::
  forall a b c.
    (Eq b, Showl b, Eq c,
      Showl c) => Tp_ops_ext a b c () ->
                    [(Term b c, Term b c)] ->
                      a -> Sum (String -> String) (a, a);
split_proc_complexity i s1 cp =
  catch_errora
    (let {
       s = rc i cp;
       w = rwc i cp;
       nfs = nfsb i cp;
       q = qb i cp;
     } in bindb (catch_errora (check_subseteq s1 s)
                  (\ x ->
                    Inl ((showsl_lit "rule " . showsl_rule x) .
                          showsl_lit " is not a strict rule")))
            (\ _ ->
              let {
                s2 = list_diff s s1;
              } in Inr (mkc i nfs q s1 (s2 ++ w), mkc i nfs q s2 (s1 ++ w))))
    (\ x -> Inl (showsl_lit "error when splitting complexity problem\n" . x));

showsl_complexity_measure ::
  forall a b.
    (Linorder a, Showl a) => Complexity_measure a b -> String -> String;
showsl_complexity_measure (Runtime_Complexity c d) =
  (((showsl_lit "basic terms f(c1,..,cn) where f in\n" .
      showsl_lista (sort_key (\ x -> x) d)) .
     showsl_lit "\n and ci is term over signature\n ") .
    showsl_lista (sort_key (\ x -> x) c)) .
    showsl_literal "\n";
showsl_complexity_measure (Derivational_Complexity f) =
  (showsl_lit "all terms over signature\n" .
    showsl_lista (sort_key (\ x -> x) f)) .
    showsl_literal "\n";

showsl_complexityLL ::
  forall a b c.
    (Compare_order a, Showl a, Compare_order b, Showl b, Compare_order c,
      Showl c) => ([Term (Lab a b) c],
                    ([(Term (Lab a b) c, Term (Lab a b) c)],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        (Complexity_measure (Lab a b) c, Complexity_class)))) ->
                    String -> String;
showsl_complexityLL (q, (s, (w, (cm, cc)))) =
  (((((((((showsl_lit "strict rules\n" . showsl_rules (sort_key (\ x -> x) s)) .
           showsl_lit "\n\nweak rules\n") .
          showsl_rules (sort_key (\ x -> x) w)) .
         showsl_lit "\n\ninnermost lhss (Q)\n") .
        showsl_lines "empty" (sort_key (\ x -> x) q)) .
       showsl_lit "\n\nstarting terms: ") .
      showsl_complexity_measure cm) .
     showsl_lit "\nintended complexity: ") .
    showsl_complexity_class cc) .
    showsl_literal "\n";

check_terms_of_main ::
  forall a b.
    (Eq a,
      Showl a) => Complexity_measure a b ->
                    Complexity_measure a b -> Sum (String -> String) ();
check_terms_of_main (Derivational_Complexity f) (Derivational_Complexity g) =
  catch_errora (check_subseteq f g)
    (\ x -> Inl (showsl_lit "consider of symbol " . showsl_prod x));
check_terms_of_main (Runtime_Complexity f h) (Derivational_Complexity g) =
  catch_errora (check_subseteq (f ++ h) g)
    (\ x -> Inl (showsl_lit "consider of symbol " . showsl_prod x));
check_terms_of_main (Runtime_Complexity f h) (Runtime_Complexity f1 h1) =
  bindb (catch_errora (check_subseteq f f1)
          (\ x -> Inl (showsl_lit "consider symbol " . showsl_prod x)))
    (\ _ ->
      catch_errora (check_subseteq h h1)
        (\ x -> Inl (showsl_lit "consider symbol " . showsl_prod x)));
check_terms_of_main (Derivational_Complexity g) (Runtime_Complexity f1 h1) =
  Inl (showsl_lit "mixing runtime complexity and derivational complexity");

check_terms_of_nat ::
  forall a b.
    (Eq a,
      Showl a) => Complexity_measure a b ->
                    Complexity_measure a b -> Sum (String -> String) ();
check_terms_of_nat cm1 cm2 =
  catch_errora (check_terms_of_main cm1 cm2)
    (\ x -> Inl (showsl_lit "error comparing start terms\n" . x));

check_complexity_subsumes ::
  forall a b c.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b, Showl b, Ccompare c,
      Compare_order c, Eq c, Mapping_impl c,
      Showl c) => ([Term (Lab a b) c],
                    ([(Term (Lab a b) c, Term (Lab a b) c)],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        (Complexity_measure (Lab a b) c, Complexity_class)))) ->
                    ([Term (Lab a b) c],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        ([(Term (Lab a b) c, Term (Lab a b) c)],
                          (Complexity_measure (Lab a b) c,
                            Complexity_class)))) ->
                      Sum (String -> String) ();
check_complexity_subsumes (q1, (s1, (w1, (cm1, cc1))))
  (q2, (s2, (w2, (cm2, cc2)))) =
  catch_errora
    (bindb
      (catch_errora (check_subseteq s2 s1)
        (\ x ->
          Inl ((showsl_lit "strict rule " . showsl_rule x) .
                showsl_lit " is missing")))
      (\ _ ->
        bindb (catch_errora (check_subseteq w2 w1)
                (\ x ->
                  Inl ((showsl_lit "weak rule " . showsl_rule x) .
                        showsl_lit " is missing")))
          (\ _ ->
            bindb (catch_errora (check_NF_terms_subset (is_NF_terms q2) q1)
                    (\ x ->
                      Inl (showsl_lit "NF(Q) differs due to term " .
                            showsl_terma x)))
              (\ _ ->
                bindb (check (less_eq_complexity_class cc1 cc2)
                        (showsl_lit "complexity classes do not match"))
                  (\ _ -> check_terms_of_nat cm2 cm1)))))
    (\ x ->
      Inl (((((showsl_lit
                 "could not ensure that assumption matches current complexity problem\n" .
                x) .
               showsl_lit "\n\nassumption is\n") .
              showsl_complexityLL (q1, (s1, (w1, (cm1, cc1))))) .
             showsl_lit "\n\ncurrent problem is\n") .
            showsl_complexityLL (q2, (s2, (w2, (cm2, cc2))))));

check_tup :: forall a b. (Ceq a, Ccompare a) => Set a -> Term a b -> Bool;
check_tup t (Var x) = False;
check_tup t (Fun f ts) = member f t;

dPos_impl ::
  forall a b.
    (Ceq a,
      Ccompare a) => (a -> a) ->
                       Set (a, Nat) -> Term a b -> [([Nat], Term a b)];
dPos_impl shp d (Var x) = [];
dPos_impl shp d (Fun f ts) =
  let {
    n = size_list ts;
  } in (if member (f, n) d then (\ a -> ([], Fun (shp f) ts) : a) else id)
         (concatMap
           (\ (i, ti) -> map (\ (p, a) -> (i : p, a)) (dPos_impl shp d ti))
           (zip (upt zero_nat n) ts));

check_rule_dt ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Showl a, Eq b,
      Showl b) => (a -> a) ->
                    Set (a, Nat) ->
                      Set a ->
                        ((Term a b, Term a b), (Term a b, Term a b)) ->
                          Sum (String -> String) ();
check_rule_dt shp d ds =
  (\ (a, b) ->
    (case a of {
      (l, r) ->
        (\ (dl, dr) ->
          catch_errora
            (let {
               sl = sharp_term shp l;
             } in bindb (check (equal_term sl dl)
                          (((showsl_lit "wrong lhs, expected " .
                              showsl_terma sl) .
                             showsl_lit " but got ") .
                            showsl_terma dl))
                    (\ _ ->
                      let {
                        pts = dPos_impl shp d r;
                        spts = map snd pts;
                      } in (case split_term (check_tup ds) dr of {
                             (_, dts) ->
                               check (equal_multiset (mset dts) (mset spts))
                                 (showsl_lit
                                   "multiset of subterms with defined roots differs");
                           })))
            (\ x ->
              Inl (((((showsl_lit "could not ensure that " .
                        showsl_rule (dl, dr)) .
                       showsl_lit " is a valid dependency tuple for ") .
                      showsl_rule (l, r)) .
                     showsl_literal "\n") .
                    x)));
    })
      b);

dt_transformation ::
  forall a b c.
    (Card_UNIV a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Showl a,
      Ccompare c, Eq c, Mapping_impl c,
      Showl c) => (a -> a) ->
                    Tp_ops_ext b a c () ->
                      Dt_transformation_info a c ->
                        Complexity_measure a c ->
                          Complexity_class ->
                            b -> Sum (String -> String)
                                   (Complexity_measure a c, b);
dt_transformation shp i info cm cc cp =
  catch_errora
    (case info of {
      DT_Transformation_Info s_DT_s w_DT_w q ->
        (case cm of {
          Derivational_Complexity _ ->
            Inl (showsl_lit
                  "only runtime complexity supported for dependency tuples");
          Runtime_Complexity c d ->
            let {
              s = rc i cp;
              w = rwc i cp;
              sa = map fst s_DT_s;
              wa = map fst w_DT_w;
              r = sa ++ wa;
              dd = defined_list r;
              dda = set d;
            } in bindb (catch_errora
                         (forallM
                           (\ lr ->
                             check (any (eq_rule_mod_vars lr) sa)
                               (showsl_lit
                                  "could not find DT for strict rule " .
                                 showsl_prod lr))
                           s)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM
                               (\ lr ->
                                 check (any (eq_rule_mod_vars lr) wa)
                                   (showsl_lit
                                      "could not find DT for weak rule " .
                                     showsl_prod lr))
                               w)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM
                                   (\ f ->
                                     check (member f dda)
                                       ((showsl_lit "defined symbol " .
  showsl_prod f) .
 showsl_lit " does not occur in defined symbols from RC"))
                                   dd)
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             let {
                               dTs = map snd s_DT_s;
                               dTw = map snd w_DT_w;
                               da = set dd;
                               shpf = (\ (f, a) -> (shp f, a));
                               ds = image shpf da;
                               ddd = image (shp . fst) da;
                               f = funas_trs_list r ++ c ++ d;
                               fs = set f;
                             } in bindb (catch_errora
  (forallM
    (\ qa ->
      check (not (is_Var qa) && not (member (the (root qa)) fs))
        ((showsl_lit "new Q-term " . showsl_terma qa) .
          showsl_lit " not allowed"))
    q)
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb (check_wf_trs r)
(\ _ ->
  bindb (catch_errora (check_NF_terms_subset (is_QNFb i cp) (map fst r))
          (\ _ -> Inl (showsl_lit "innermost required")))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ fa ->
                  check (not (member fa ds))
                    (showsl_prod fa .
                      showsl_lit " as sharped symbol is not fresh"))
                f)
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (check (is_empty (inf_set (set c) da))
                  (showsl_lit
                    "constructors of RC and defined symbols of TRSs are not disjoint"))
            (\ _ ->
              bindb (catch_errora (forallM (check_rule_dt shp da ddd) s_DT_s)
                      (\ x -> Inl (snd x)))
                (\ _ ->
                  bindb (catch_errora
                          (forallM (check_rule_dt shp da ddd) w_DT_w)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      Inr (Runtime_Complexity c (map shpf d),
                            mkc i False (qb i cp ++ q) dTs
                              (r ++ dTw))))))))))));
        });
    })
    (\ x -> Inl (showsl_lit "error when switching to dependency tuples\n" . x));

showsl_mctxt :: forall a b. (Showl a, Showl b) => Mctxt a b -> String -> String;
showsl_mctxt MHole = showsl_lit "[]";
showsl_mctxt (MVar x) = showsl x;
showsl_mctxt (MFun f cs) =
  showsl f . showsl_list_gen id "" "(" ", " ")" (map showsl_mctxt cs);

ground_mctxt :: forall a b. Mctxt a b -> Bool;
ground_mctxt (MVar uu) = False;
ground_mctxt MHole = True;
ground_mctxt (MFun f cs) = all ground_mctxt cs;

funas_mctxt ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Mctxt a b -> Set (a, Nat);
funas_mctxt (MFun f cs) =
  sup_set (inserta (f, size_list cs) bot_set)
    (sup_seta (image funas_mctxt (set cs)));
funas_mctxt (MVar v) = bot_set;
funas_mctxt MHole = bot_set;

is_compound_context ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Set (a, Nat) -> Mctxt a b -> Bool;
is_compound_context cComp c =
  ground_mctxt c && less_eq_set (funas_mctxt c) cComp;

if_Fun_in_set ::
  forall a b. (Ceq a, Ccompare a) => Set (a, Nat) -> Term a b -> Bool;
if_Fun_in_set f = (\ t -> is_Var t || member (the (root t)) f);

uncap_till :: forall a b. (Term a b -> Bool) -> Term a b -> [Term a b];
uncap_till p (Var x) = (if p (Var x) then [Var x] else []);
uncap_till p (Fun f ts) =
  (if p (Fun f ts) then [Fun f ts] else concatMap (uncap_till p) ts);

check_rule_wdp ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showl a, Compare b, Eq b,
      Showl b) => (a -> a) ->
                    Set (a, Nat) ->
                      ((Term a b, Term a b), (Term a b, Term a b)) ->
                        Sum (String -> String) ();
check_rule_wdp shp cComp =
  (\ (a, b) ->
    (case a of {
      (l, r) ->
        (\ (p, q) ->
          catch_errora
            (let {
               la = sharp_term shp l;
             } in bindb (check (equal_term la p)
                          (((showsl_lit "wrong lhs, expected " .
                              showsl_terma la) .
                             showsl_lit " but got ") .
                            showsl_terma p))
                    (\ _ ->
                      let {
                        us = uncap_till (if_Fun_in_set (uminus_set cComp)) r;
                      } in (case split_term (if_Fun_in_set (uminus_set cComp)) q
                             of {
                             (c, usa) ->
                               bindb (check (map (sharp_term shp) us == usa)
                                       (showsl_lit
 "lists of maximal subterms with defined root differ"))
                                 (\ _ ->
                                   check (is_compound_context cComp c)
                                     ((showsl_mctxt c .
showsl_lit " is not a proper compound context of ") .
                                       showsl_terma q));
                           })))
            (\ x ->
              Inl (((((showsl_lit "could not ensure that " .
                        showsl_rule (p, q)) .
                       showsl_lit " is a valid weak dependency pair for ") .
                      showsl_rule (l, r)) .
                     showsl_literal "\n") .
                    x)));
    })
      b);

check_wdp_trans ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showl a, Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showl c) => (a -> a) ->
                    Tp_ops_ext b a c () ->
                      Wdp_trans_info a c ->
                        Complexity_measure a c ->
                          Complexity_class ->
                            b -> Sum (String -> String)
                                   (Complexity_measure a c, b);
check_wdp_trans shp i info cm cc cp =
  catch_errora
    (case info of {
      WDP_Trans_Info compa s_wdps w_wdps q ->
        (case cm of {
          Derivational_Complexity _ ->
            Inl (showsl_lit
                  "only runtime complexity supported for weak dependency pairs");
          Runtime_Complexity c d ->
            let {
              s = rc i cp;
              w = rwc i cp;
              sa = map fst s_wdps;
              wa = map fst w_wdps;
              r = sa ++ wa;
              fs = funas_trs_list r;
              ds = defined_list r;
            } in bindb (catch_errora
                         (forallM
                           (\ ra ->
                             check (any (eq_rule_mod_vars ra) sa)
                               (showsl_lit
                                  "could not find weak dependency pair for strict rule " .
                                 showsl_prod ra))
                           s)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM
                               (\ ra ->
                                 check (any (eq_rule_mod_vars ra) wa)
                                   (showsl_lit
                                      "could not find weak dependency pair for weak rule " .
                                     showsl_prod ra))
                               w)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         let {
                           wDP_S = map snd s_wdps;
                           wDP_W = map snd w_wdps;
                           shpf = (\ (f, a) -> (shp f, a));
                           f = fs ++ c ++ d;
                           f_sharps = map shpf f;
                           _ = image (\ (fa, a) -> (shp fa, a)) (set f);
                           cComp =
                             sup_set
                               (minus_set
                                 (minus_set (set fs) (set (defined_list r)))
                                 (set d))
                               compa;
                         } in bindb (catch_errora
                                      (forallM
(\ qa ->
  check (not (is_Var qa) && not (membera f (the (root qa))))
    ((showsl_lit "new Q-term " . showsl_terma qa) . showsl_lit " not allowed"))
q)
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  bindb (check_wf_trs r)
                                    (\ _ ->
                                      bindb
(catch_errora
  (forallM
    (\ fa ->
      check (not (member fa cComp))
        (showsl_prod fa . showsl_lit " clashes with sharp symbols"))
    f_sharps)
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (catch_errora
          (forallM
            (\ fa ->
              check (not (member fa cComp))
                (showsl_prod fa .
                  showsl_lit " clashes with defined symbols of RC"))
            d)
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ fa ->
                  check (not (member fa cComp))
                    (showsl_prod fa .
                      showsl_lit " clashes with defined symbols"))
                ds)
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (catch_errora (forallM (check_rule_wdp shp cComp) s_wdps)
                  (\ x -> Inl (snd x)))
            (\ _ ->
              bindb (catch_errora (forallM (check_rule_wdp shp cComp) w_wdps)
                      (\ x -> Inl (snd x)))
                (\ _ ->
                  Inr (Runtime_Complexity c (map shpf d),
                        mkc i (nfsb i cp) (qb i cp ++ q) (wDP_S ++ sa)
                          (wDP_W ++ wa)))))))))));
        });
    })
    (\ x ->
      Inl ((showsl_lit "error when switching to weak dependency pairs" .
             showsl_literal "\n") .
            x));

equal_boundstype :: Boundstype -> Boundstype -> Bool;
equal_boundstype Roof Match = False;
equal_boundstype Match Roof = False;
equal_boundstype Match Match = True;
equal_boundstype Roof Roof = True;

boundstype :: forall a b. Bounds_info a b -> Boundstype;
boundstype (Bounds_Info x1 x2 x3 x4 x5) = x1;

stackable_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
stackable_of_cm (Derivational_Complexity f) = f;
stackable_of_cm (Runtime_Complexity c d) = c;

bounds_complexity_rel ::
  forall a b c d.
    (Compare_order b, Eq b, Showl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showl c,
      Card_UNIV d, Cenum d, Ceq d, Ccompare d, Compare_order d, Eq d,
      Set_impl d,
      Showl d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      [(Term b c, Term b c)] ->
                        Complexity_measure b c ->
                          Complexity_class -> a -> Sum (String -> String) a;
bounds_complexity_rel i info rdelete cm cc tp =
  catch_errora
    (let {
       r = rc i tp;
       rw = rwc i tp;
       r2 = ceta_list_diff r rdelete;
     } in bindb (catch_errora (check_subseteq rdelete (rulese i tp))
                  (\ x ->
                    Inl ((showsl_lit "could not find rule " . showsl_rule x) .
                          showsl_lit " in current complexity problem")))
            (\ _ ->
              bindb (check (less_eq_complexity_class (Comp_Poly one_nat) cc)
                      (showsl_lit "can only ensure linear complexity"))
                (\ _ ->
                  bindb (check (equal_boundstype (boundstype info) Match)
                          (showsl_lit
                            "complexity analysis requires boundstype match"))
                    (\ _ ->
                      let {
                        _ = rulese i tp;
                      } in bindb (check_bounds_generic info rdelete (rw ++ r2)
                                   (stackable_of_cm cm) (roots_of_cm cm))
                             (\ _ ->
                               Inr (mkc i (nfsb i tp) (qb i tp) r2
                                     (list_union rw rdelete)))))))
    (\ x ->
      Inl ((((showsl_lit "problem in ensuring match-RT boundedness of\n" .
               showsl_tp i tp) .
              showsl_lit "\nwith deletion of rules\n") .
             showsl_trs rdelete) .
            x));

bounds_complexity ::
  forall a b c d.
    (Compare_order b, Eq b, Showl b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showl c,
      Card_UNIV d, Cenum d, Ceq d, Ccompare d, Compare_order d, Eq d,
      Set_impl d,
      Showl d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      Complexity_measure b c ->
                        Complexity_class -> a -> Sum (String -> String) ();
bounds_complexity i info cm cc tp =
  catch_errora
    (bindb
      (check (less_eq_complexity_class (Comp_Poly one_nat) cc)
        (showsl_lit "can only ensure linear complexity"))
      (\ _ ->
        bindb (check (equal_boundstype (boundstype info) Match)
                (showsl_lit "complexity analysis requires boundstype match"))
          (\ _ ->
            check_bounds_generic info (rulese i tp) [] (stackable_of_cm cm)
              (roots_of_cm cm))))
    (\ x ->
      Inl (((showsl_lit "problem in ensuring match boundedness of\n" .
              showsl_tp i tp) .
             showsl_literal "\n") .
            x));

check_assm ::
  forall a b c d.
    (Compare_order b, Showl b, Compare_order c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    ((a, (Complexity_measure (Lab b c) [Char],
                           Complexity_class)) ->
                      d -> Sum (String -> String) ()) ->
                      Generic_assm_proof b c [Char] d () () () () ->
                        Sum (String -> String) ();
check_assm i cpx_check (Complexity_assm_proof cp prf) =
  cpx_check (mk_cpx i cp) prf;
check_assm i uu (SN_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Finite_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (SN_FP_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Not_SN_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Infinite_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Not_RelSN_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Not_SN_FP_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Unknown_assm_proof v va) =
  Inl (showsl_lit
        "no support for termination or non-termination assumptions in complexity proof");

check_complexity_proof ::
  forall a b c.
    (Compare_order b, Eq b, Showl b, Compare_order c, Eq c,
      Showl c) => Tp_ops_ext a (Lab b c) [Char] () ->
                    Bool ->
                      (String -> String) ->
                        (a, (Complexity_measure (Lab b c) [Char],
                              Complexity_class)) ->
                          Complexity_proof b c [Char] ->
                            Sum (String -> String) ();
check_complexity_proof ia assms i (tp, (cm, cc))
  (Rule_Shift_Complexity redp rdelete ur_opt prf) =
  debug i "Rule Removal Complexity"
    (bindb
      (catch_errora
        (smart_rule_shift_complexity ia (get_redtriple redp) rdelete ur_opt cm
          cc tp)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error when applying the rule shifting technique on\n") .
                  showsl_tp ia tp) .
                 showsl_literal "\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (add_index i one_nat) (tpa, (cm, cc))
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below the rule shifting processor\n") .
                  x))));
check_complexity_proof ia assms i (tp, (cm, cc)) RisEmpty_Complexity =
  debug i "R is empty for complexity"
    (check (null (rc ia tp))
      ((i . showsl_lit ": R is not empty in\n") . showsl_tp ia tp));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Remove_Nonapplicable_Rules_Complexity r prf) =
  debug i "Removing non-applicable rules"
    (let {
       _ = rc ia tp;
     } in bindb (catch_errora (check_non_applicable_rules (is_QNFb ia tp) r)
                  (\ x ->
                    Inl ((i . showsl_lit
                                ": error when removing non-applicable rules\n") .
                          showsl_rule x . showsl_lit " is applicable")))
            (\ _ ->
              let {
                tpa = delete_R_Rwb ia tp r r;
              } in catch_errora
                     (check_complexity_proof ia assms (add_index i one_nat)
                       (tpa, (cm, cc)) prf)
                     (\ x ->
                       Inl ((i . showsl_lit
                                   ": error below the non-applicable rules removal\n") .
                             x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (Matchbounds_Complexity info) =
  debug i "Matchbounds"
    (catch_errora (bounds_complexity ia info cm cc tp)
      (\ x ->
        Inl ((i . showsl_lit ": error when applying matchbounds\n") . x)));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Matchbounds_Rel_Complexity info rdel prf) =
  debug i "Matchbounds-Rel"
    (bindb
      (catch_errora (bounds_complexity_rel ia info rdel cm cc tp)
        (\ x ->
          Inl ((i . showsl_lit ": error when applying relative matchbounds\n") .
                x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (add_index i one_nat) (tpa, (cm, cc))
            prf)
          (\ x ->
            Inl ((i . showsl_lit
                        ": error below applying relative matchbounds\n") .
                  x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (DT_Transformation info prf) =
  debug i "DT Transformation"
    (bindb
      (catch_errora (dt_transformation Sharp ia info cm cc tp)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error when applying the DT transformation on\n") .
                  showsl_tp ia tp) .
                 showsl_literal "\n") .
                x)))
      (\ (cma, tpa) ->
        catch_errora
          (check_complexity_proof ia assms (add_index i one_nat)
            (tpa, (cma, cc)) prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the DT transformation\n") .
                  x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (WDP_Transformation info prf) =
  debug i "WDP Transformation"
    (bindb
      (catch_errora (check_wdp_trans Sharp ia info cm cc tp)
        (\ x ->
          Inl ((((i . showsl_lit
                        ": error when applying the WDP transformation on\n") .
                  showsl_tp ia tp) .
                 showsl_literal "\n") .
                x)))
      (\ (cma, tpa) ->
        catch_errora
          (check_complexity_proof ia assms (add_index i one_nat)
            (tpa, (cma, cc)) prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below the WDP transformation\n") .
                  x))));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Usable_Rules_Complexity ur prf) =
  debug i "Usable Rules"
    (bindb
      (catch_errora (usable_rules_complexity ia ur cm cc tp)
        (\ x ->
          Inl ((i . showsl_lit ": error when applying usable rules\n") . x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (add_index i one_nat) (tpa, (cm, cc))
            prf)
          (\ x ->
            Inl ((i . showsl_lit ": error below applying usable rules\n") .
                  x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (Complexity_Assumption a ass) =
  debug i "Complexity Assumption"
    (if assms
      then bindb (catch_errora
                   (check_complexity_subsumes a
                     (qb ia tp, (rc ia tp, (rwc ia tp, (cm, cc)))))
                   (\ x ->
                     Inl ((i . showsl_lit
                                 ": error in complexity assumption or unknown proof\n") .
                           x)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa j ->
                       check_assm ia
                         (check_complexity_proof ia assms (add_index i (suc j)))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl ((i . showsl_lit ": error below unknown proof\n") . x)))
      else Inl (showsl_lit
                 "the proof contains an assumption or unknown proof which have to be manually allowed"));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Split_Complexity info prf1 prf2) =
  debug i "Split"
    (bindb
      (catch_errora (split_proc_complexity ia info tp)
        (\ x ->
          Inl ((i . showsl_lit ": error when applying split processor\n") . x)))
      (\ (tp1, tp2) ->
        bindb (catch_errora
                (check_complexity_proof ia assms (add_index i one_nat)
                  (tp1, (cm, cc)) prf1)
                (\ x ->
                  Inl ((i . showsl_lit
                              ": error below applying split processor\n") .
                        x)))
          (\ _ ->
            catch_errora
              (check_complexity_proof ia assms
                (add_index i (nat_of_integer (2 :: Integer))) (tp2, (cm, cc))
                prf2)
              (\ x ->
                Inl ((i . showsl_lit
                            ": error below applying split processor\n") .
                      x)))));

translate_complexity_claim ::
  forall a b c.
    (Eq a) => [(Term a b, Term a b)] ->
                [(Term a b, Term a b)] -> Start_term -> Complexity_measure a c;
translate_complexity_claim r s start =
  let {
    f = funas_trs_list (r ++ s);
    d = defined_list (r ++ s);
    c = filter (\ fa -> not (membera d fa)) f;
  } in (case start of {
         Full -> Derivational_Complexity f;
         Constructor_Based -> Runtime_Complexity c d;
       });

check_unknown_proof ::
  forall a b c.
    (Compare_order b, Countable b, Eq b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      Bool ->
                        (String -> String) ->
                          [Char] ->
                            Unknown_proof b [Nat] [Char] ->
                              Sum (String -> String) ();
check_unknown_proof ia j a i u prf =
  check_unknown_proof_main ia j a i u (unlab_to_split_unknown prf);

fp_strategy_to_fp_impl ::
  forall a b.
    (Eq a) => Fp_strategy a [Char] ->
                [(Term a [Char], b)] ->
                  [(Ctxt a [Char], (Term a [Char], Location))];
fp_strategy_to_fp_impl strat r = (case strat of {
                                   Outermost -> o_to_fp_impl (map fst r);
                                   Context_Sensitive a -> mu_to_fp_impl a;
                                   Forbidden_Patterns fp -> fp;
                                 });

proof_to_string :: forall a b c. Proof a b c -> String;
proof_to_string proof =
  (case proof of {
    TRS_Termination_Proof _ -> "TRS termination proof";
    Complexity_Proof _ -> "complexity proof";
    DP_Termination_Proof _ -> "DP termination proof";
    DP_Nontermination_Proof _ -> "DP nontermination proof";
    TRS_Nontermination_Proof _ -> "TRS nontermination proof";
    FP_Termination_Proof _ -> "FP TRS termination proof";
    Relative_TRS_Nontermination_Proof _ -> "relative TRS nontermination proof";
    TRS_Confluence_Proof _ -> "TRS confluence proof";
    TRS_Non_Confluence_Proof _ -> "TRS nonconfluence proof";
    Completion_Proof _ -> "completion proof";
    Ordered_Completion_Proof _ -> "ordered completion proof";
    Equational_Proof _ -> "equational proof";
    Equational_Disproof _ -> "equational disproof";
    Quasi_Reductive_Proof _ -> "quasi-reductive proof";
    Conditional_CR_Proof _ -> "conditional confluence proof";
    Conditional_Non_CR_Proof _ -> "conditional nonconfluence proof";
    Tree_Automata_Closed_Proof _ -> "tree automata closed proof";
    AC_Termination_Proof _ -> "AC termination proof";
    LTS_Termination_Proof _ -> "LTS termination proof";
    LTS_Safety_Proof _ -> "LTS safety proof";
    Infeasibility_Proof _ -> "Infeasibility proof";
    Unknown_Proof _ -> "unknown proof";
    Unknown_Disproof _ -> "unknown disproof";
  });

input_to_string :: forall a b. Input a b -> String;
input_to_string input = (case input of {
                          DP_input _ _ _ _ -> "DP input";
                          Inn_TRS_input _ _ _ _ -> "TRS input";
                          CPX_input _ _ _ _ _ -> "Complexity input";
                          COMP_input _ _ -> "Completion input";
                          OCOMP_input _ _ _ _ -> "Ordered Completion input";
                          EQ_input _ _ -> "Equational input";
                          FP_TRS_input _ _ -> "FP-TRS input";
                          CTRS_input _ -> "CTRS input";
                          TA_input _ _ -> "TA input";
                          AC_input _ _ _ -> "AC-TRS input";
                          LTS_input _ -> "LTS input";
                          LTS_safety_input _ _ -> "LTS safety input";
                          Infeasibility_input _ _ -> "Infeasibility input";
                          Unknown_input _ -> "Unknown input";
                        });

claim_to_string :: forall a b. Claim a b -> String;
claim_to_string claim = (case claim of {
                          Yes -> "yes";
                          No -> "no";
                          Terminating -> "termination";
                          Upperbound _ -> "upperbound complexity";
                          Nonterminating -> "nontermination";
                          Confluent -> "confluence";
                          Nonconfluent -> "nonconfluence";
                          Completed -> "completion";
                          Ordered_Completed -> "ordered completion";
                          Anything -> "anything";
                        });

check_cert ::
  forall a b c d e.
    (Compare_order b, Countable b, Default b, Eq b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      Ac_tp_ops_ext d (Lab b [Nat]) [Char] () ->
                        Ac_dpp_ops_ext e (Lab b [Nat]) [Char] () ->
                          Bool ->
                            Input (Lab b [Nat]) [Char] ->
                              Claim (Lab b [Nat]) [Char] ->
                                Proof b [Nat] [Char] ->
                                  Sum (String -> String) ();
check_cert i j k l a input claim proof =
  let {
    mismatch =
      showsl_lit
        ((((("Claiming " ++ claim_to_string claim) ++ " of ") ++
            input_to_string input) ++
           " by ") ++
          proof_to_string proof);
  } in (case input of {
         DP_input m p q r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_dp_termination_proof i j a (showsl_lit "1")
                        (mkd j default_nfs_dp m p [] (strategy_to_Q q r) [] r)
                        prf
                 else Inl mismatch);
             DP_Nontermination_Proof prf ->
               (if equal_claim claim Nonterminating ||
                     equal_claim claim Anything
                 then check_dp_nontermination_proof i j a (showsl_lit "1")
                        (mkd j default_nfs_nt_dp m p [] (strategy_to_Q q r) []
                          r)
                        prf
                 else Inl mismatch);
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         Inn_TRS_input q r s start ->
           (case proof of {
             TRS_Termination_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_trs_termination_proof i j a (showsl_lit "1")
                        (mkc i default_nfs_trs (strategy_to_Q q r) r s) prf
                 else Inl mismatch);
             Complexity_Proof prf ->
               (case claim of {
                 Yes -> Inl mismatch;
                 No -> Inl mismatch;
                 Terminating -> Inl mismatch;
                 Upperbound ub ->
                   let {
                     cm = translate_complexity_claim r s start;
                     cc = Comp_Poly ub;
                   } in check_complexity_proof i a (showsl_lit "1")
                          (mkc i True (strategy_to_Q q (r ++ s)) r s, (cm, cc))
                          prf;
                 Nonterminating -> Inl mismatch;
                 Confluent -> Inl mismatch;
                 Nonconfluent -> Inl mismatch;
                 Completed -> Inl mismatch;
                 Ordered_Completed -> Inl mismatch;
                 Anything -> Inl mismatch;
               });
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof prf ->
               (if equal_claim claim Nonterminating ||
                     equal_claim claim Anything
                 then bindb (bindb
                              (check (equal_start_term start Full) mismatch)
                              (\ _ -> check (null s) mismatch))
                        (\ _ ->
                          check_trs_nontermination_proof i j a (showsl_lit "1")
                            (mkc i default_nfs_nt_trs (strategy_to_Q q r) r [])
                            prf)
                 else Inl mismatch);
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof prf ->
               (if equal_claim claim Nonterminating ||
                     equal_claim claim Anything
                 then bindb (check (equal_start_term start Full) mismatch)
                        (\ _ ->
                          check_reltrs_nontermination_proof i j a
                            (showsl_lit "1")
                            (mkc i default_nfs_nt_trs (strategy_to_Q q r) r s)
                            prf)
                 else Inl mismatch);
             TRS_Confluence_Proof prf ->
               (if equal_claim claim Confluent || equal_claim claim Anything
                 then bindb (bindb
                              (bindb
                                (check (equal_start_term start Full)
                                  (showsl_lit
                                    "Confluence with start term not supported"))
                                (\ _ ->
                                  check (equal_strategy q No_Strategy)
                                    (showsl_lit
                                      "Confluence under strategy not supported")))
                              (\ _ ->
                                check (null s)
                                  (showsl_lit
                                    "Relative confluence not supported")))
                        (\ _ -> check_cr_proof a (showsl_lit "1") i j r prf)
                 else Inl mismatch);
             TRS_Non_Confluence_Proof prf ->
               (if equal_claim claim Nonconfluent || equal_claim claim Anything
                 then bindb (bindb
                              (bindb
                                (check (equal_start_term start Full)
                                  (showsl_lit
                                    "Nonconfluence with start term not supported"))
                                (\ _ ->
                                  check (equal_strategy q No_Strategy)
                                    (showsl_lit
                                      "Confluence under strategy not supported")))
                              (\ _ ->
                                check (null s)
                                  (showsl_lit
                                    "Relative nonconfluence not supported")))
                        (\ _ -> check_ncr_proof a (showsl_lit "1") i j r prf)
                 else Inl mismatch);
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         CPX_input q r s cm cc ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof prf ->
               bindb (case claim of {
                       Yes -> Inl mismatch;
                       No -> Inl mismatch;
                       Terminating -> Inl mismatch;
                       Upperbound ub ->
                         check (equal_complexity_class cc (Comp_Poly ub))
                           (showsl_lit "complexity class mismatch");
                       Nonterminating -> Inl mismatch;
                       Confluent -> Inl mismatch;
                       Nonconfluent -> Inl mismatch;
                       Completed -> Inl mismatch;
                       Ordered_Completed -> Inl mismatch;
                       Anything -> Inr ();
                     })
                 (\ _ ->
                   check_complexity_proof i a (showsl_lit "1")
                     (mkc i True (strategy_to_Q q (r ++ s)) r s, (cm, cc)) prf);
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         COMP_input e r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof prf ->
               (if equal_claim claim Completed || equal_claim claim Anything
                 then check_completion_proof a (showsl_lit "1") i j e r prf
                 else Inl mismatch);
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         OCOMP_input e_0 e r ord ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof prf ->
               (if equal_claim claim Ordered_Completed ||
                     equal_claim claim Anything
                 then check_ordered_completion_proof_ext (showsl_lit "1") e_0 e
                        r ord prf
                 else Inl mismatch);
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         EQ_input e eq ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof prf ->
               (if equal_claim claim Yes || equal_claim claim Anything
                 then check_equational_proof a (showsl_lit "1") i j e eq prf
                 else Inl mismatch);
             Equational_Disproof prf ->
               (if equal_claim claim No || equal_claim claim Anything
                 then check_equational_disproof a (showsl_lit "1") i j e eq prf
                 else Inl mismatch);
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         FP_TRS_input strat r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof prf ->
               (if equal_claim claim Nonterminating ||
                     equal_claim claim Anything
                 then check_fp_nontermination_proof i j a (showsl_lit "1")
                        (fp_strategy_to_fp_impl strat r, r) prf
                 else Inl mismatch);
             FP_Termination_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_fptrs_termination_proof i j a (showsl_lit "1")
                        (fp_strategy_to_fp_impl strat r, r) prf
                 else Inl mismatch);
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         CTRS_input ctrs ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_quasi_reductive_proof a (showsl_lit "1") i j ctrs
                        prf
                 else Inl mismatch);
             Conditional_CR_Proof prf ->
               (if equal_claim claim Confluent || equal_claim claim Anything
                 then check_conditional_cr_proof a (showsl_lit "1") i j ctrs prf
                 else Inl mismatch);
             Conditional_Non_CR_Proof prf ->
               (if equal_claim claim Nonconfluent || equal_claim claim Anything
                 then check_conditional_ncr_proof a (showsl_lit "1") i j ctrs
                        prf
                 else Inl mismatch);
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         TA_input ta r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof prf ->
               (if equal_claim claim Yes || equal_claim claim Anything
                 then tree_aut_trs_closed ta prf r else Inl mismatch);
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         AC_input r aa c ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_ac_termination_proof l k (showsl_lit "1")
                        (mke k r aa c) prf
                 else Inl mismatch);
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         LTS_input r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof prf ->
               (if equal_claim claim Terminating || equal_claim claim Anything
                 then check_termination r prf else Inl mismatch);
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         LTS_safety_input r e ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof prf ->
               (if equal_claim claim Yes || equal_claim claim Anything
                 then check_safety type_of_fun
                        (inserta BoolT (set_empty (of_phantom set_impl_ty)))
                        check_clause check_clause showsl_IA_exp showsl_IA_exp
                        negatea negatea r e prf
                 else Inl mismatch);
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         Infeasibility_input c r ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof prf ->
               (if equal_claim claim Yes || equal_claim claim Anything
                 then check_infeasibleb c r prf else Inl mismatch);
             Unknown_Proof _ -> Inl mismatch;
             Unknown_Disproof _ -> Inl mismatch;
           });
         Unknown_input ur ->
           (case proof of {
             TRS_Termination_Proof _ -> Inl mismatch;
             Complexity_Proof _ -> Inl mismatch;
             DP_Termination_Proof _ -> Inl mismatch;
             DP_Nontermination_Proof _ -> Inl mismatch;
             TRS_Nontermination_Proof _ -> Inl mismatch;
             FP_Termination_Proof _ -> Inl mismatch;
             Relative_TRS_Nontermination_Proof _ -> Inl mismatch;
             TRS_Confluence_Proof _ -> Inl mismatch;
             TRS_Non_Confluence_Proof _ -> Inl mismatch;
             Completion_Proof _ -> Inl mismatch;
             Ordered_Completion_Proof _ -> Inl mismatch;
             Equational_Proof _ -> Inl mismatch;
             Equational_Disproof _ -> Inl mismatch;
             Quasi_Reductive_Proof _ -> Inl mismatch;
             Conditional_CR_Proof _ -> Inl mismatch;
             Conditional_Non_CR_Proof _ -> Inl mismatch;
             Tree_Automata_Closed_Proof _ -> Inl mismatch;
             AC_Termination_Proof _ -> Inl mismatch;
             LTS_Termination_Proof _ -> Inl mismatch;
             LTS_Safety_Proof _ -> Inl mismatch;
             Infeasibility_Proof _ -> Inl mismatch;
             Unknown_Proof b -> check_unknown_proof i j a (showsl_lit "1") ur b;
             Unknown_Disproof b ->
               check_unknown_disproof i j a (showsl_lit "1") ur b;
           });
       });

intersect_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
intersect_values key vs m = foldr (aux key m) vs empty;

intersect_rules ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 Rbt (a, Nat) [(Bool, (Term a b, Term a b))] ->
                   Rbt (a, Nat) [(Bool, (Term a b, Term a b))];
intersect_rules rs =
  intersect_values key
    (map (\ a -> (True, a)) rs ++ map (\ a -> (False, a)) rs);

sharp_trans_id ::
  forall a.
    (String ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Sharp a);
sharp_trans_id trans_id_parser =
  xml_or
    (xml_change (trans_id_parser "transitionDuplicate") (xml_return . Sharpa))
    (xml_change (trans_id_parser "transitionId") (xml_return . Flat));

unraveling_info ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        [(((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                            [(Term (Lab a b) [Char], Term (Lab a b) [Char])]),
                           [(Term (Lab a b) [Char], Term (Lab a b) [Char])])];
unraveling_info xml2name =
  xml_do "unravelingInformation"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "unravelingEntry"
        (xml_take (crule xml2name "conditionalRule")
          (\ a ->
            xml_take_many_sub [] zero_nat Infinity_enat (rule xml2name)
              (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (id a)));

impl_ofc ::
  forall b a.
    (Compare_order b,
      Compare_order a) => Tp b a ->
                            (Bool,
                              ([Term b a],
                                (Bool,
                                  ([(Term b a, Term b a)],
                                    ([(Term b a, Term b a)],
                                      (Rbt (b, Nat)
 [(Bool, (Term b a, Term b a))],
Term b a -> Bool))))));
impl_ofc (TP x) = x;

q_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      [Term a b];
q_impl (uu, (q, uv)) = q;

q :: forall a b. (Compare_order a, Compare_order b) => Tp a b -> [Term a b];
q tp = q_impl (impl_ofc tp);

r_impl ::
  forall a b.
    (Compare_order a) => (Bool,
                           ([Term a b],
                             (Bool,
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Term a b -> Bool)))))) ->
                           [(Term a b, Term a b)];
r_impl (uu, (uv, (uw, (vR, (ux, (m, uy)))))) = vR ++ rules_with id m;

r :: forall a b.
       (Compare_order a, Compare_order b) => Tp a b -> [(Term a b, Term a b)];
r tp = r_impl (impl_ofc tp);

xml2dp_nontermination_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Dp_nontermination_proof a b [Char]);
xml2dp_nontermination_proof xml2name x =
  xml_do "dpNonterminationProof"
    (xml_take
      (xml_or
        (xml_do "dpRuleRemoval"
          (xml_take_optional
            (xml_do "dps"
              (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
            (\ p ->
              xml_take_optional
                (xml_do "trs"
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ r ->
                  xml_take (xml2dp_nontermination_proof xml2name)
                    (\ prf ->
                      xml_return
                        (DP_Rule_Removal (Rule_removal_nonterm_dp_prf p r)
                          prf))))))
        (xml_or
          (xml_do "loop"
            (xml_take (relsteps xml2name)
              (\ (s, rseq) ->
                xml_take (substa xml2name)
                  (\ sigma ->
                    xml_take (ctxt xml2name)
                      (\ c ->
                        xml_return (DP_Loop (DP_loop_prf s rseq sigma c)))))))
          (xml_or (xml_change (nonloop xml2name) (xml_return . DP_Nonloop))
            (xml_or
              (xml_do "innermostLhssRemovalProc"
                (xml_take (innermostLhss xml2name)
                  (\ q ->
                    xml_take (xml2dp_nontermination_proof xml2name)
                      (\ p ->
                        xml_return
                          (DP_Q_Reduction (DP_q_reduction_nonterm_prf q) p)))))
              (xml_or
                (xml_do "innermostLhssIncreaseProc"
                  (xml_take (innermostLhss xml2name)
                    (\ q ->
                      xml_take (xml2dp_nontermination_proof xml2name)
                        (\ p ->
                          xml_return
                            (DP_Q_Increase (Q_increase_nonterm_dp_prf q) p)))))
                (xml_or
                  (xml_do "instantiationProc"
                    (xml_take
                      (xml_do "dps"
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ p ->
                        xml_take (xml2dp_nontermination_proof xml2name)
                          (\ prf ->
                            xml_return
                              (DP_Instantiation
                                (Instantiation_complete_proc_prf p) prf)))))
                  (xml_or
                    (xml_do "narrowingProc"
                      (xml_take (rule xml2name)
                        (\ st ->
                          xml_take pos
                            (\ po ->
                              xml_take
                                (xml_do "narrowings"
                                  (xml_take (rules xml2name)
                                    (\ xa -> xml_return (id xa))))
                                (\ p ->
                                  xml_take
                                    (xml2dp_nontermination_proof xml2name)
                                    (\ prf ->
                                      xml_return
(DP_Narrowing (Narrowing_complete_proc_prf st po p) prf)))))))
                    (xml_or
                      (xml_do "rewritingProc"
                        (xml_take (rule xml2name)
                          (\ (s, t) ->
                            xml_take (rstep xml2name)
                              (\ (p, (lr, ta)) ->
                                xml_take_optional (rule xml2name)
                                  (\ c ->
                                    xml_take_optional
                                      (xml_do "usableRules"
(xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                                      (\ uopt ->
xml_take (xml2dp_nontermination_proof xml2name)
  (\ prf ->
    let {
      st = (case c of {
             Nothing -> (s, ta);
             Just v -> v;
           });
    } in xml_return
           (DP_Rewriting
             (Rewriting_complete_proc_prf uopt (s, t) (s, ta) st lr p)
             prf))))))))
                      (xml_or
                        (xml_do "switchFullStrategyProc"
                          (xml_take (wcr_proof xml2name)
                            (\ a ->
                              xml_take (xml2dp_nontermination_proof xml2name)
                                (\ b ->
                                  xml_return (DP_Termination_Switch a b)))))
                        (xml_or
                          (xml_do "infinitenessAssumption"
                            (xml_take (xml2dp_inputa xml2name False)
                              (\ qdp ->
                                xml_return (DP_Assume_Infinite qdp []))))
                          (xml_do "unknownProof"
                            (xml_take (xml_text "description")
                              (\ _ ->
                                xml_take (xml2dp_inputa xml2name False)
                                  (\ b ->
                                    xml_take_many_sub [] zero_nat Infinity_enat
                                      (\ xa -> right (fst xa))
                                      (\ _ ->
xml_return (DP_Assume_Infinite b []))))))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2inn_nt_trs_assm ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Bool,
                          ([Term (Lab a b) [Char]],
                            [(Term (Lab a b) [Char], Term (Lab a b) [Char])]));
xml2inn_nt_trs_assm xml2name =
  xml_change (xml2_trs_input xml2name)
    (\ (Inn_TRS_input inn r s start) ->
      (if not (null s)
        then xml_error "(innermost) TRS without relative rules expected"
        else (if not (equal_start_term start Full)
               then xml_error "start term is not allowed here"
               else xml_return
                      (default_nfs_nt_trs, (strategy_to_Q inn r, r)))));

xml2trs_nontermination_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Trs_nontermination_proof a b [Char]);
xml2trs_nontermination_proof xml2name x =
  xml_do "trsNonterminationProof"
    (xml_take
      (xml_or
        (xml_do "variableConditionViolated" (xml_return TRS_Not_Well_Formed))
        (xml_or
          (xml_change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              xml_return
                (TRS_Loop
                  (TRS_loop_prf s
                    (map (\ (xa, (y, (_, z))) -> (xa, (y, z))) rseq) sigma c))))
          (xml_or (xml_change (nonloop xml2name) (xml_return . TRS_Nonloop))
            (xml_or
              (xml_change (nonloop_srs xml2name) (xml_return . TRS_Nonloop_SRS))
              (xml_or
                (xml_do "ruleRemoval"
                  (xml_take
                    (xml_do "trs"
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ r ->
                      xml_take (xml2trs_nontermination_proof xml2name)
                        (\ p ->
                          xml_return
                            (TRS_Rule_Removal (Rule_removal_nonterm_trs_prf r)
                              p)))))
                (xml_or
                  (xml_do "dpTrans"
                    (xml_take
                      (xml_do "dps"
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ p ->
                        xml_take (xml_bool "markedSymbols")
                          (\ _ ->
                            xml_take (xml2dp_nontermination_proof xml2name)
                              (\ c ->
                                xml_return
                                  (TRS_DP_Trans
                                    (DP_trans_nontermination_tt_prf p) c))))))
                  (xml_or
                    (xml_do "stringReversal"
                      (xml_take
                        (xml_do "trs"
                          (xml_take (rules xml2name)
                            (\ xa -> xml_return (id xa))))
                        (\ _ ->
                          xml_take (xml2trs_nontermination_proof xml2name)
                            (\ p -> xml_return (TRS_String_Reversal p)))))
                    (xml_or
                      (xml_do "constantToUnary"
                        (xml_take plain_var
                          (\ v ->
                            xml_take (renaming xml2name)
                              (\ ren ->
                                xml_take
                                  (xml_do "trs"
                                    (xml_take (rules xml2name)
                                      (\ xa -> xml_return (id xa))))
                                  (\ s ->
                                    xml_take
                                      (xml2trs_nontermination_proof xml2name)
                                      (\ p ->
xml_return (TRS_Constant_String (Const_string_complete_proof v ren s) p)))))))
                      (xml_or
                        (xml_do "innermostLhssIncrease"
                          (xml_take (innermostLhss xml2name)
                            (\ q ->
                              xml_take (xml2trs_nontermination_proof xml2name)
                                (\ r ->
                                  xml_return
                                    (TRS_Q_Increase
                                      (Q_increase_nonterm_trs_prf q) r)))))
                        (xml_or
                          (xml_do "switchFullStrategy"
                            (xml_take (wcr_proof xml2name)
                              (\ a ->
                                xml_take (xml2trs_nontermination_proof xml2name)
                                  (\ b ->
                                    xml_return (TRS_Termination_Switch a b)))))
                          (xml_or
                            (xml_do "uncurry"
                              (xml_take (uncurry_info xml2name)
                                (\ i ->
                                  xml_take
                                    (xml_do "trs"
                                      (xml_take (rules xml2name)
(\ xa -> xml_return (id xa))))
                                    (\ r ->
                                      xml_take
(xml2trs_nontermination_proof xml2name)
(\ p -> xml_return (TRS_Uncurry (Uncurry_nt_proof i r) p))))))
                            (xml_or
                              (xml_change (not_wn_ta xml2name)
                                (xml_return . TRS_Not_WN_Tree_Automaton))
                              (xml_or
                                (xml_do "nonterminationAssumption"
                                  (xml_take (xml2inn_nt_trs_assm xml2name)
                                    (\ qtrs ->
                                      xml_return (TRS_Assume_Not_SN qtrs []))))
                                (xml_do "unknownProof"
                                  (xml_take (xml_text "description")
                                    (\ _ ->
                                      xml_take (xml2inn_nt_trs_assm xml2name)
(\ b ->
  xml_take_many_sub [] zero_nat Infinity_enat (\ xa -> right (fst xa))
    (\ _ -> xml_return (TRS_Assume_Not_SN b [])))))))))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2inn_rel_nt_trs_assm ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Bool,
                          ([Term (Lab a b) [Char]],
                            ([(Term (Lab a b) [Char], Term (Lab a b) [Char])],
                              [(Term (Lab a b) [Char],
                                 Term (Lab a b) [Char])])));
xml2inn_rel_nt_trs_assm xml2name =
  xml_change (xml2_trs_input xml2name)
    (\ (Inn_TRS_input inn r s start) ->
      (if not (equal_start_term start Full)
        then xml_error "start term is not allowed here"
        else xml_return (default_nfs_nt_trs, (strategy_to_Q inn r, (r, s)))));

xml2reltrs_nontermination_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Reltrs_nontermination_proof a b [Char]);
xml2reltrs_nontermination_proof xml2name x =
  xml_do "relativeNonterminationProof"
    (xml_take
      (xml_or
        (xml_do "variableConditionViolated" (xml_return Rel_Not_Well_Formed))
        (xml_or
          (xml_change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              xml_return (Rel_Loop (Rel_trs_loop_prf s rseq sigma c))))
          (xml_or
            (xml_change (xml2trs_nontermination_proof xml2name)
              (xml_return . Rel_R_Not_SN))
            (xml_or
              (xml_do "ruleRemoval"
                (xml_take
                  (xml_do "trs"
                    (xml_take (rules xml2name) (\ xa -> xml_return (Just xa))))
                  (\ r ->
                    xml_take
                      (xml_do "trs"
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (Just xa))))
                      (\ s ->
                        xml_take (xml2reltrs_nontermination_proof xml2name)
                          (\ p ->
                            xml_return
                              (Rel_Rule_Removal
                                (Rule_removal_nonterm_reltrs_prf r s) p))))))
              (xml_or
                (xml_do "stringReversal"
                  (xml_take
                    (xml_do "trs"
                      (xml_take (rules xml2name)
                        (\ xa -> xml_return (Just xa))))
                    (\ _ ->
                      xml_take
                        (xml_do "trs"
                          (xml_take (rules xml2name)
                            (\ xa -> xml_return (Just xa))))
                        (\ _ ->
                          xml_take (xml2reltrs_nontermination_proof xml2name)
                            (\ p -> xml_return (Rel_TRS_String_Reversal p))))))
                (xml_or
                  (xml_do "nonterminationAssumption"
                    (xml_take (xml2inn_rel_nt_trs_assm xml2name)
                      (\ qtrs -> xml_return (Rel_TRS_Assume_Not_SN qtrs []))))
                  (xml_do "unknownProof"
                    (xml_take (xml_text "description")
                      (\ _ ->
                        xml_take (xml2inn_rel_nt_trs_assm xml2name)
                          (\ b ->
                            xml_take_many_sub [] zero_nat Infinity_enat
                              (\ xa -> right (fst xa))
                              (\ _ ->
                                xml_return
                                  (Rel_TRS_Assume_Not_SN b []))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

invariant_proof_parser ::
  forall a b c d e f.
    (Default f) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) a) ->
                     ((Xml, ([([Char], [Char])],
                              (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) b) ->
                       ((Xml, ([([Char], [Char])],
                                (Bool, ([String], [String])))) ->
                         Sum_bot (Xml_error String)
                           (Formula (Term c (d, e)))) ->
                         ((Xml, ([([Char], [Char])],
                                  (Bool, ([String], [String])))) ->
                           Sum_bot (Xml_error String) f) ->
                           [(a, Formula (Term c (d, e)))] ->
                             (Xml, ([([Char], [Char])],
                                     (Bool, ([String], [String])))) ->
                               Sum_bot (Xml_error String)
                                 (Invariant_proof c d e a [Char] b f);
invariant_proof_parser location_parser trans_parser atom_parser hint_parser i =
  xml_change
    (art_parser xml_text location_parser trans_parser atom_parser hint_parser)
    (\ prf -> xml_return (Impact i prf));

sharp_location_parser ::
  forall a.
    (String ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Sharp a);
sharp_location_parser location_id_parser =
  xml_or
    (xml_change (location_id_parser "locationDuplicate") (xml_return . Sharpa))
    (xml_change (location_id_parser "locationId") (xml_return . Flat));

invariant_parser ::
  forall a b c d.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Formula (Term b (c, d)))) ->
        (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) (a, Formula (Term b (c, d)));
invariant_parser location_parser atom_parser =
  xml_do "invariant"
    (xml_take (xml_do "location" (xml_take location_parser xml_return))
      (\ l ->
        xml_take
          (xml_do "formula" (xml_take (formula_parser atom_parser) xml_return))
          (\ phi -> xml_return (l, phi))));

invariants_parser ::
  forall a b c d.
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) a) ->
      ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) (Formula (Term b (c, d)))) ->
        (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) [(a, Formula (Term b (c, d)))];
invariants_parser location_parser atom_parser =
  xml_do "invariants"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (invariant_parser location_parser atom_parser) xml_return);

cooperation_proof_parser ::
  forall a b c d e f.
    (Ccompare a, Eq a, Default e, Ccompare f, Eq f,
      Mapping_impl f) => (String ->
                           (Xml, ([([Char], [Char])],
                                   (Bool, ([String], [String])))) ->
                             Sum_bot (Xml_error String) a) ->
                           ((Xml, ([([Char], [Char])],
                                    (Bool, ([String], [String])))) ->
                             Sum_bot (Xml_error String) (Term b (c, d))) ->
                             ((Xml, ([([Char], [Char])],
                                      (Bool, ([String], [String])))) ->
                               Sum_bot (Xml_error String)
                                 (Formula (Term b (c, d)))) ->
                               ((Xml, ([([Char], [Char])],
(Bool, ([String], [String])))) ->
                                 Sum_bot (Xml_error String)
                                   (Formula (Term b (Trans_var c, d)))) ->
                                 ((Xml, ([([Char], [Char])],
  (Bool, ([String], [String])))) ->
                                   Sum_bot (Xml_error String) c) ->
                                   ((Xml, ([([Char], [Char])],
    (Bool, ([String], [String])))) ->
                                     Sum_bot (Xml_error String) e) ->
                                     ((Xml,
([([Char], [Char])], (Bool, ([String], [String])))) ->
                                       Sum_bot (Xml_error String) d) ->
                                       d ->
 ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
   Sum_bot (Xml_error String) f) ->
   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
     Sum_bot (Xml_error String) (Cooperation_proof b c d a f e);
cooperation_proof_parser location_id_parser exp_parser atom_parser tatom_parser
  variable_parser hint_parser type_parser dom_type trans_parser xs =
  xml_or (xml_do "trivial" (xml_return Triviala))
    (xml_or
      (xml_do "newInvariants"
        (xml_take
          (invariants_parser (sharp_location_parser location_id_parser)
            atom_parser)
          (\ i ->
            xml_take
              (invariant_proof_parser (sharp_location_parser location_id_parser)
                trans_parser atom_parser hint_parser i)
              (\ p ->
                xml_take
                  (cooperation_proof_parser location_id_parser exp_parser
                    atom_parser tatom_parser variable_parser hint_parser
                    type_parser dom_type trans_parser)
                  (\ cp -> xml_return (Invariants_Update p cp))))))
      (xml_or
        (xml_do "transitionRemoval"
          (xml_take
            (xml_do "rankingFunctions"
              (xml_take_many_sub [] zero_nat Infinity_enat
                (xml_do "rankingFunction"
                  (xml_take
                    (xml_do "location"
                      (xml_take (sharp_location_parser location_id_parser)
                        xml_return))
                    (\ l ->
                      xml_take
                        (xml_do "expression"
                          (xml_take_many_sub [] one_nat Infinity_enat exp_parser
                            xml_return))
                        (\ es -> xml_return (l, es)))))
                xml_return))
            (\ rs ->
              xml_take
                (xml_do "bound"
                  (xml_take_many_sub [] zero_nat Infinity_enat exp_parser
                    xml_return))
                (\ bounds ->
                  xml_take
                    (xml_do "remove"
                      (xml_take_many_sub [] zero_nat Infinity_enat trans_parser
                        xml_return))
                    (\ removed ->
                      xml_take_default (\ _ -> default_hint)
                        (xml_do "hints"
                          (xml_take_many_sub [] zero_nat Infinity_enat
                            (xml_do "hint"
                              (xml_take trans_parser
                                (\ tr ->
                                  xml_take_default default_hint
                                    (hints_parser hint_parser)
                                    (\ hint -> xml_return (tr, hint)))))
                            (\ pairs ->
                              xml_return (map_of_default default_hint pairs))))
                        (\ hinter ->
                          xml_take
                            (cooperation_proof_parser location_id_parser
                              exp_parser atom_parser tatom_parser
                              variable_parser hint_parser type_parser dom_type
                              trans_parser)
                            (\ inner ->
                              let {
                                rf = map_of_default [] rs;
                              } in xml_return
                                     (Transition_Removal
                                       (Transition_removal_info rf removed
 dom_type bounds hinter)
                                       inner))))))))
        (xml_or
          (xml_do "locationAddition"
            (xml_take
              (transition_parser (sharp_location_parser location_id_parser)
                trans_parser tatom_parser)
              (\ tr ->
                xml_take
                  (cooperation_proof_parser location_id_parser exp_parser
                    atom_parser tatom_parser variable_parser hint_parser
                    type_parser dom_type trans_parser)
                  (\ prof ->
                    (case tr of {
                      (tr_id, tau) ->
                        xml_return
                          (Location_Addition
                            (Location_Addition_Info (source tau) (target tau)
                              tr_id tau)
                            prof);
                    })))))
          (xml_or
            (xml_do "freshVariableAddition"
              (xml_take variable_parser
                (\ x1 ->
                  xml_take type_parser
                    (\ x2 ->
                      xml_take
                        (xml_do "additionalFormulas"
                          (xml_take_many_sub [] zero_nat Infinity_enat
                            (xml_do "additionalFormula"
                              (xml_take trans_parser
                                (\ tr ->
                                  xml_take (formula_parser tatom_parser)
                                    (\ phi -> xml_return (tr, phi)))))
                            xml_return))
                        (\ x3 ->
                          xml_take
                            (cooperation_proof_parser location_id_parser
                              exp_parser atom_parser tatom_parser
                              variable_parser hint_parser type_parser dom_type
                              trans_parser)
                            (\ prof ->
                              xml_return
                                (Fresh_Variable_Addition
                                  (Fresh_Variable_Addition_Info x1 x2 x3)
                                  prof)))))))
            (xml_or
              (xml_do "cutTransitionSplit"
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (xml_do "cutTransitionsWithProof"
                    (xml_take
                      (xml_do "cutTransitions"
                        (xml_take_many_sub [] zero_nat Infinity_enat
                          trans_parser xml_return))
                      (\ cuts ->
                        xml_take
                          (cooperation_proof_parser location_id_parser
                            exp_parser atom_parser tatom_parser variable_parser
                            hint_parser type_parser dom_type trans_parser)
                          (\ prof -> xml_return (cuts, prof)))))
                  (\ ps -> xml_return (Cut_Transition_Split ps))))
              (xml_do "sccDecomposition"
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (xml_do "sccWithProof"
                    (xml_take
                      (xml_do "scc"
                        (xml_take_many_sub [] one_nat Infinity_enat
                          (sharp_location_parser location_id_parser)
                          xml_return))
                      (\ scc ->
                        xml_take
                          (cooperation_proof_parser location_id_parser
                            exp_parser atom_parser tatom_parser variable_parser
                            hint_parser type_parser dom_type trans_parser)
                          (\ prof -> xml_return (scc, prof)))))
                  (\ sccs -> xml_return (Scc_Decomp sccs)))))))))
    xs;

cut_points_to_transitions ::
  forall a b c d e.
    [(Sharp a, Transition_rule b c d (Sharp e))] ->
      [(e, (a, Formula (Term b (Trans_var c, d))))] ->
        [(Sharp a, Transition_rule b c d (Sharp e))];
cut_points_to_transitions ts [] = ts;
cut_points_to_transitions ts ((l, (tr, phi)) : cps) =
  cut_points_to_transitions ((Flat tr, Transition (Flat l) (Sharpa l) phi) : ts)
    cps;

cutPoints_parser ::
  forall a b c d e.
    (String ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String) a) ->
      (String ->
        (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) b) ->
        ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
          Sum_bot (Xml_error String) (Formula (Term c (Trans_var d, e)))) ->
          (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
            Sum_bot (Xml_error String)
              [(Sharp b, Transition_rule c d e (Sharp a))];
cutPoints_parser location_id_parser trans_id_parser tatom_parser =
  xml_do "cutPoints"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "cutPoint"
        (xml_take (location_id_parser "locationId")
          (\ l ->
            xml_take (trans_id_parser "skipId")
              (\ tr ->
                xml_take
                  (xml_do "skipFormula"
                    (xml_take (formula_parser tatom_parser) xml_return))
                  (\ phi -> xml_return (l, (tr, phi)))))))
      (\ tuples -> xml_return (cut_points_to_transitions [] tuples)));

termination_proof_parser ::
  forall a b c d e f.
    (Ccompare a, Eq a, Ccompare b, Eq b,
      Default f) => (String ->
                      (Xml, ([([Char], [Char])],
                              (Bool, ([String], [String])))) ->
                        Sum_bot (Xml_error String) a) ->
                      (String ->
                        (Xml, ([([Char], [Char])],
                                (Bool, ([String], [String])))) ->
                          Sum_bot (Xml_error String) b) ->
                        ((Xml, ([([Char], [Char])],
                                 (Bool, ([String], [String])))) ->
                          Sum_bot (Xml_error String) (Term c (d, e))) ->
                          ((Xml, ([([Char], [Char])],
                                   (Bool, ([String], [String])))) ->
                            Sum_bot (Xml_error String)
                              (Formula (Term c (d, e)))) ->
                            ((Xml, ([([Char], [Char])],
                                     (Bool, ([String], [String])))) ->
                              Sum_bot (Xml_error String)
                                (Formula (Term c (Trans_var d, e)))) ->
                              ((Xml, ([([Char], [Char])],
                                       (Bool, ([String], [String])))) ->
                                Sum_bot (Xml_error String) d) ->
                                ((Xml, ([([Char], [Char])],
 (Bool, ([String], [String])))) ->
                                  Sum_bot (Xml_error String) f) ->
                                  ((Xml, ([([Char], [Char])],
   (Bool, ([String], [String])))) ->
                                    Sum_bot (Xml_error String) e) ->
                                    e -> (Xml,
   ([([Char], [Char])], (Bool, ([String], [String])))) ->
   Sum_bot (Xml_error String) (Termination_proof c d e a b f);
termination_proof_parser location_id_parser trans_id_parser exp_parser
  atom_parser tatom_parser variable_parser hint_parser type_parser dom_type xml
  = xml_or (xml_do "trivial" (xml_return Trivialb))
      (xml_or
        (xml_do "newInvariants"
          (xml_take
            (invariants_parser (location_parser location_id_parser) atom_parser)
            (\ i ->
              xml_take
                (invariant_proof_parser (location_parser location_id_parser)
                  (trans_id trans_id_parser) atom_parser hint_parser i)
                (\ p ->
                  xml_take
                    (termination_proof_parser location_id_parser trans_id_parser
                      exp_parser atom_parser tatom_parser variable_parser
                      hint_parser type_parser dom_type)
                    (\ cp -> xml_return (Invariants_Update_LTS p cp))))))
        (xml_do "switchToCooperationTermination"
          (xml_take
            (cutPoints_parser location_id_parser trans_id_parser tatom_parser)
            (\ cp ->
              xml_take
                (cooperation_proof_parser location_id_parser exp_parser
                  atom_parser tatom_parser variable_parser hint_parser
                  type_parser dom_type (sharp_trans_id trans_id_parser))
                (\ p -> xml_return (Via_Cooperation [(cp, p)]))))))
      xml;

lts_termination_proof_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String)
      (Termination_proof Sig [Char] Ty [Char] [Char] Hints);
lts_termination_proof_parser =
  termination_proof_parser xml_text xml_text exp_parsera atom_parser
    tatom_parser variable_parser hint_parser type_parser IntT;

xml2ordered_completion_step ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) (Oc_irule (Lab a b) [Char]);
xml2ordered_completion_step xml2name =
  xml_or
    (xml_do "deduce"
      (xml_take (term xml2name)
        (\ a ->
          xml_take (term xml2name)
            (\ b ->
              xml_take (term xml2name) (\ c -> xml_return (OC_Deduce a b c))))))
    (xml_or
      (xml_do "orientl"
        (xml_take (term xml2name)
          (\ a ->
            xml_take (term xml2name) (\ b -> xml_return (OC_Orientl a b)))))
      (xml_or
        (xml_do "orientr"
          (xml_take (term xml2name)
            (\ a ->
              xml_take (term xml2name) (\ b -> xml_return (OC_Orientr a b)))))
        (xml_or
          (xml_do "delete"
            (xml_take (term xml2name) (\ x -> xml_return (OC_Delete x))))
          (xml_or
            (xml_do "compose"
              (xml_take (term xml2name)
                (\ a ->
                  xml_take (term xml2name)
                    (\ b ->
                      xml_take (term xml2name)
                        (\ c -> xml_return (OC_Compose a b c))))))
            (xml_or
              (xml_do "simplifyl"
                (xml_take (term xml2name)
                  (\ a ->
                    xml_take (term xml2name)
                      (\ b ->
                        xml_take (term xml2name)
                          (\ c -> xml_return (OC_Simplifyl a b c))))))
              (xml_or
                (xml_do "simplifyr"
                  (xml_take (term xml2name)
                    (\ a ->
                      xml_take (term xml2name)
                        (\ b ->
                          xml_take (term xml2name)
                            (\ c -> xml_return (OC_Simplifyr a b c))))))
                (xml_do "collapse"
                  (xml_take (term xml2name)
                    (\ a ->
                      xml_take (term xml2name)
                        (\ b ->
                          xml_take (term xml2name)
                            (\ c -> xml_return (OC_Collapse a b c))))))))))));

xml2ordered_completion_proof ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Ordered_completion_proof (Lab a b) [Char]);
xml2ordered_completion_proof xml2name =
  xml_do "orderedCompletionProof"
    (xml_take
      (xml_do "run"
        (xml_take_many_sub [] zero_nat Infinity_enat
          (xml_do "orderedCompletionStep"
            (xml_take (xml2ordered_completion_step xml2name)
              (\ x -> xml_return (id x))))
          (\ a -> xml_return (id a))))
      (\ x -> xml_return (OKB x)));

xml2quasi_reductive_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Quasi_reductive_proof a b [Char]);
xml2quasi_reductive_proof xml2name =
  xml_do "quasiReductiveProof"
    (xml_take
      (xml_do "unraveling"
        (xml_take (unraveling_info xml2name)
          (\ a ->
            xml_take (xml2trs_termination_proof xml2name)
              (\ b -> xml_return (Unravel a b)))))
      (\ x -> xml_return (id x)));

map_r_states :: forall a b c. (a -> b) -> Ta_rule a c -> Ta_rule b c;
map_r_states f r = TA_rule (r_root r) (map f (r_lhs_states r)) (f (r_rhs r));

map_states_impl ::
  forall a b c. (a -> b) -> Tree_automaton a c -> Tree_automaton b c;
map_states_impl f (Tree_Automaton qs ts eps) =
  Tree_Automaton (map f qs) (map (map_r_states f) ts)
    (map (\ (p, q) -> (f p, f q)) eps);

xml2nonreachable_etac_info ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Nonreachability_proof (Lab a b) [Char]);
xml2nonreachable_etac_info xml2name =
  xml_do "nonreachableEtac"
    (xml_take (cPFsignature xml2name)
      (\ a ->
        xml_take xml2name
          (\ b ->
            xml_take xml2name
              (\ c ->
                xml_take (tree_automaton (ta_normal_lhs xml2name))
                  (\ d ->
                    xml_take (xml2state_map xml2name)
                      (\ e ->
                        xml_return
                          (Nonreachable_ETAC a b c (map_states_impl e d))))))));

xml2ordered_completion ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        ([(Term (Lab a b) [Char], Term (Lab a b) [Char])],
                          ([(Term (Lab a b) [Char], Term (Lab a b) [Char])],
                            (Reduction_order_input (Lab a b),
                              Ordered_completion_proof (Lab a b) [Char])));
xml2ordered_completion xml2name =
  xml_do "orderedCompletion"
    (xml_take (xml2ordered_completion_result xml2name)
      (\ (rs, (es, ro)) ->
        xml_take (xml2ordered_completion_proof xml2name)
          (\ p -> xml_return (rs, (es, (ro, p))))));

xml2nonreachability_proof ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Nonreachability_proof (Lab a b) [Char]);
xml2nonreachability_proof xml2name x =
  xml_do "nonreachabilityProof"
    (xml_take
      (xml_or (xml_leaf "nonreachableTcap" Nonreachable_Gtcap)
        (xml_or (xml2nonreachable_etac_info xml2name)
          (xml_or
            (xml_do "nonreachableSubstApprox"
              (xml_take (rules xml2name)
                (\ a ->
                  xml_take (xml2nonreachability_proof xml2name)
                    (\ b -> xml_return (Nonreachable_Subst_Approx a b)))))
            (xml_or
              (xml_do "nonreachableReverse"
                (xml_take (xml2nonreachability_proof xml2name)
                  (\ xa -> xml_return (Nonreachable_Reverse xa))))
              (xml_do "nonreachableFGCR"
                (xml_take (xml_do "eqSymbol" (xml_take xml2name xml_return))
                  (\ eq ->
                    xml_take
                      (xml_do "trueSymbol" (xml_take xml2name xml_return))
                      (\ tr ->
                        xml_take
                          (xml_do "falseSymbol" (xml_take xml2name xml_return))
                          (\ fa ->
                            xml_take (xml2ordered_completion xml2name)
                              (\ (rs, (es, (ro, p))) ->
                                xml_return
                                  (Nonreachable_FGCR eq tr fa es rs ro
                                    p)))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2nonjoinability_proof ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Nonjoinability_proof (Lab a b) [Char]);
xml2nonjoinability_proof xml2name =
  xml_do "nonjoinabilityProof"
    (xml_take
      (xml_or (xml_leaf "nonjoinableTcap" Nonjoinable_Tcap)
        (xml_change (xml2nonreachability_proof xml2name)
          (xml_return . Nonjoinable_Ground_NF)))
      (\ x -> xml_return (id x)));

xml2infeasibility_proof ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Infeasibility_proof (Lab a b) [Char]);
xml2infeasibility_proof xml2name x =
  xml_do "infeasibilityProof"
    (xml_take
      (xml_or
        (xml_do "infeasibleCompoundConditions"
          (xml_take xml2name
            (\ a ->
              xml_take (xml2nonreachability_proof xml2name)
                (\ b -> xml_return (Infeasible_Compound_Conditions a b)))))
        (xml_or
          (xml_do "infeasibleEquation"
            (xml_take (rule xml2name)
              (\ a ->
                xml_take (xml2nonreachability_proof xml2name)
                  (\ b ->
                    xml_return ((case a of {
                                  (aa, ba) -> Infeasible_Equation aa ba;
                                })
                                 b)))))
          (xml_or
            (xml_do "infeasibleSubset"
              (xml_take (rules xml2name)
                (\ a ->
                  xml_take (xml2infeasibility_proof xml2name)
                    (\ b -> xml_return (Infeasible_Subset a b)))))
            (xml_or
              (xml_do "infeasibleRhssEqual"
                (xml_take (term xml2name)
                  (\ a ->
                    xml_take (term xml2name)
                      (\ b ->
                        xml_take (term xml2name)
                          (\ c ->
                            xml_take (xml2nonjoinability_proof xml2name)
                              (\ d ->
                                xml_return (Infeasible_Rhss_Equal a b c d)))))))
              (xml_do "infeasibleTrans"
                (xml_take (term xml2name)
                  (\ a ->
                    xml_take (term xml2name)
                      (\ b ->
                        xml_take (term xml2name)
                          (\ c ->
                            xml_take (xml2nonreachability_proof xml2name)
                              (\ d ->
                                xml_return (Infeasible_Trans a b c d)))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2infeasible_rules_info ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        [(((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                            [(Term (Lab a b) [Char], Term (Lab a b) [Char])]),
                           Infeasibility_proof (Lab a b) [Char])];
xml2infeasible_rules_info xml2name =
  xml_do "infeasibleRules"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "infeasibleRule"
        (xml_take (crule xml2name "rule")
          (\ a ->
            xml_take (xml2infeasibility_proof xml2name)
              (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (id a)));

xml2inline_cond_info ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        [(((Term (Lab a b) [Char], Term (Lab a b) [Char]),
                            [(Term (Lab a b) [Char], Term (Lab a b) [Char])]),
                           [(Term (Lab a b) [Char], Term (Lab a b) [Char])])];
xml2inline_cond_info xml2name =
  xml_do "inlinedRules"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "inlinedRule"
        (xml_take (crule xml2name "rule")
          (\ rule ->
            xml_take (conditions xml2name "inlinedConditions")
              (\ conds -> xml_return (rule, conds)))))
      xml_return);

xml2conditional_ncr_proof ::
  ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) (Lab [Char] [Nat])) ->
    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String)
        (Conditional_ncr_proof [Char] [Nat] [Char] [Char]);
xml2conditional_ncr_proof xml2name x =
  xml_do "conditionalCrDisproof"
    (xml_take
      (xml_or
        (xml_do "unconditional"
          (xml_take (xml2ncr_proof xml2name)
            (\ xa -> xml_return (Unconditional_CNCR xa))))
        (xml_or
          (xml_do "inlineConditions"
            (xml_take
              (xml_do "rules"
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (crule xml2name "rule") xml_return))
              (\ a ->
                xml_take (xml2inline_cond_info xml2name)
                  (\ b ->
                    xml_take (xml2conditional_ncr_proof xml2name)
                      (\ c ->
                        xml_return
                          ((Transformation_CNCR . Inline_Conditions_CCRT a) b
                            c))))))
          (xml_or
            (xml_do "infeasibleRuleRemoval"
              (xml_take (xml2infeasible_rules_info xml2name)
                (\ a ->
                  xml_take (xml2conditional_ncr_proof xml2name)
                    (\ b ->
                      xml_return
                        ((Transformation_CNCR . Infeasible_Rule_Removal_CCRT) a
                          b)))))
            (xml_do "nonJoinableFork"
              (xml_take
                (xml_do "terms"
                  (xml_take (term xml2name)
                    (\ a ->
                      xml_take (term xml2name)
                        (\ b ->
                          xml_take (term xml2name)
                            (\ c -> xml_return (a, (b, c)))))))
                (\ a ->
                  xml_take (csteps xml2name)
                    (\ b ->
                      xml_take (csteps xml2name)
                        (\ c ->
                          xml_take (xml2non_join_info xml2name)
                            (\ d ->
                              xml_return
                                ((case a of {
                                   (s, aa) ->
                                     (case aa of {
                                       (ab, ba) -> Non_Join_CNCR s ab ba;
                                     });
                                 })
                                   b
                                   c
                                  d))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2context_joinable_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Context_joinable_proof (Lab a b) [Char]);
xml2context_joinable_proof xml2name =
  xml_do "contextJoinabilityProof"
    (xml_take (term xml2name)
      (\ a ->
        xml_take (csteps xml2name)
          (\ b ->
            xml_take (csteps xml2name)
              (\ c ->
                xml_take (xml2const_map xml2name)
                  (\ d ->
                    xml_return
                      (Contextual_Join (orig_term d a) (map (orig_cstep d) b)
                        (map (orig_cstep d) c)))))));

xml2context_joinable_ccps ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        [(Term (Lab a b) [Char],
                           (Term (Lab a b) [Char],
                             ([(Term (Lab a b) [Char], Term (Lab a b) [Char])],
                               Context_joinable_proof (Lab a b) [Char])))];
xml2context_joinable_ccps xml2name =
  xml_do "contextJoinableCCPs"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "contextJoinableCCP"
        (xml_take (term xml2name)
          (\ s ->
            xml_take (term xml2name)
              (\ t ->
                xml_take (conditions xml2name "conditions")
                  (\ cs ->
                    xml_take (xml2context_joinable_proof xml2name)
                      (\ p -> xml_return (s, (t, (cs, p)))))))))
      xml_return);

xml2ao_infeasibility_proof ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Ao_infeasibility_proof (Lab a b) [Char]);
xml2ao_infeasibility_proof xml2name =
  xml_do "aoInfeasibilityProof"
    (xml_take
      (xml_or
        (xml_change (xml2infeasibility_proof xml2name)
          (xml_return . AO_Infeasibility_Proof))
        (xml_do "aoLhssEqual"
          (xml_take (term xml2name)
            (\ a ->
              xml_take (term xml2name)
                (\ b ->
                  xml_take (term xml2name)
                    (\ c ->
                      xml_take (xml2nonjoinability_proof xml2name)
                        (\ d -> xml_return (AO_Lhss_Equal a b c d))))))))
      (\ x -> xml_return (id x)));

xml2ao_infeasible_conds ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        [([(Term (Lab a b) [Char], Term (Lab a b) [Char])],
                           ([(Term (Lab a b) [Char], Term (Lab a b) [Char])],
                             Ao_infeasibility_proof (Lab a b) [Char]))];
xml2ao_infeasible_conds xml2name =
  xml_do "aoInfeasibleConditions"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "aoInfeasibleCondition"
        (xml_take (conditions xml2name "conditions")
          (\ a ->
            xml_take (conditions xml2name "conditions")
              (\ b ->
                xml_take (xml2ao_infeasibility_proof xml2name)
                  (\ c -> xml_return (a, (b, c)))))))
      (\ a -> xml_return (id a)));

xml2infeasible_conds ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        [([(Term (Lab a b) [Char], Term (Lab a b) [Char])],
                           Infeasibility_proof (Lab a b) [Char])];
xml2infeasible_conds xml2name =
  xml_do "infeasibleConditions"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "infeasibleCondition"
        (xml_take (conditions xml2name "conditions")
          (\ a ->
            xml_take (xml2infeasibility_proof xml2name)
              (\ b -> xml_return (a, b)))))
      (\ a -> xml_return (id a)));

xml2unfeasible_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Unfeasible_proof (Lab a b) [Char]);
xml2unfeasible_proof xml2name =
  xml_do "unfeasibilityProof"
    (xml_take
      (xml_do "terms"
        (xml_take (term xml2name)
          (\ a ->
            xml_take (term xml2name)
              (\ b ->
                xml_take (term xml2name) (\ c -> xml_return (a, (b, c)))))))
      (\ a ->
        xml_take (csteps xml2name)
          (\ b ->
            xml_take (csteps xml2name)
              (\ c ->
                xml_take
                  (xml_do "rules"
                    (xml_take (crule xml2name "rule")
                      (\ aa ->
                        xml_take (crule xml2name "rule")
                          (\ ba -> xml_return (aa, ba)))))
                  (\ d ->
                    xml_take (xml2const_map xml2name)
                      (\ e ->
                        xml_return
                          ((case a of {
                             (t, (u, v)) ->
                               (\ ps qs (r, ra) m ->
                                 UnfeasibleOverlap (orig_term m t)
                                   (orig_term m u) (orig_term m v)
                                   (map (orig_cstep m) ps)
                                   (map (orig_cstep m) qs) r ra);
                           })
                             b
                             c
                             d
                            e)))))));

xml2unfeasible_ccps ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        [([Char] -> Term (Lab a b) [Char],
                           Unfeasible_proof (Lab a b) [Char])];
xml2unfeasible_ccps xml2name =
  xml_do "unfeasibleCCPs"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "unfeasibleCCP"
        (xml_take (substa xml2name)
          (\ a ->
            xml_take (xml2unfeasible_proof xml2name)
              (\ b -> xml_return (subst_of a, b)))))
      (\ a -> xml_return (id a)));

xml2conditional_cr_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Conditional_cr_proof a b [Char]);
xml2conditional_cr_proof xml2name x =
  xml_do "conditionalCrProof"
    (xml_take
      (xml_or
        (xml_do "unconditional"
          (xml_take (xml2cr_proof xml2name)
            (\ xa -> xml_return (Unconditional_CR xa))))
        (xml_or
          (xml_do "unraveling"
            (xml_take (unraveling_info xml2name)
              (\ a ->
                xml_take (xml2cr_proof xml2name)
                  (\ b -> xml_return (Unravel_CR a b)))))
          (xml_or
            (xml_do "inlineConditions"
              (xml_take
                (xml_do "rules"
                  (xml_take_many_sub [] zero_nat Infinity_enat
                    (crule xml2name "rule") xml_return))
                (\ a ->
                  xml_take (xml2inline_cond_info xml2name)
                    (\ b ->
                      xml_take (xml2conditional_cr_proof xml2name)
                        (\ c ->
                          xml_return
                            ((Transformation_CR . Inline_Conditions_CCRT a) b
                              c))))))
            (xml_or
              (xml_do "infeasibleRuleRemoval"
                (xml_take (xml2infeasible_rules_info xml2name)
                  (\ a ->
                    xml_take (xml2conditional_cr_proof xml2name)
                      (\ b ->
                        xml_return
                          ((Transformation_CR . Infeasible_Rule_Removal_CCRT) a
                            b)))))
              (xml_or (xml_leaf "almostOrthogonal" Almost_Orthogonal_CR)
                (xml_or
                  (xml_do "almostOrthogonalModuloInfeasibility"
                    (xml_take (xml2ao_infeasible_conds xml2name)
                      (\ xa ->
                        xml_return
                          (Almost_Orthogonal_Modulo_Infeasibility_CRa xa))))
                  (xml_do "al94"
                    (xml_take (xml2quasi_reductive_proof xml2name)
                      (\ a ->
                        xml_take (xml2context_joinable_ccps xml2name)
                          (\ b ->
                            xml_take (xml2infeasible_conds xml2name)
                              (\ c ->
                                xml_take (xml2unfeasible_ccps xml2name)
                                  (\ d ->
                                    xml_return (AL94_CR a b c d)))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2ac_dp_termination_proof ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Ac_dp_termination_proof (Lab a b) [Char]);
xml2ac_dp_termination_proof xml2name x =
  xml_do "acDPTerminationProof"
    (xml_take
      (xml_or
        (xml_do "acRedPairProc"
          (xml_take (ordering_constraint_proof xml2name False)
            (\ a ->
              xml_take
                (xml_do "dps"
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ b ->
                  xml_take
                    (xml_do "usableRules"
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ c ->
                      xml_take (xml2ac_dp_termination_proof xml2name)
                        (\ d -> xml_return (AC_Redpair_UR_Proc a b c d)))))))
        (xml_or
          (xml_do "acSubtermProc"
            (xml_take (multiset_af xml2name)
              (\ pi ->
                xml_take
                  (xml_do "dps"
                    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                  (\ r ->
                    xml_take (xml2ac_dp_termination_proof xml2name)
                      (\ prf -> xml_return (AC_Subterm_Proc pi r prf))))))
          (xml_or (xml_do "acTrivialProc" (xml_return AC_P_is_Empty))
            (xml_or
              (xml_do "acMonoRedPairProc"
                (xml_take (ordering_constraint_proof xml2name False)
                  (\ a ->
                    xml_take
                      (xml_do "dps"
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ b ->
                        xml_take
                          (xml_do "trs"
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ c ->
                            xml_take
                              (xml_do "usableRules"
                                (xml_take (rules xml2name)
                                  (\ xa -> xml_return (id xa))))
                              (\ d ->
                                xml_take (xml2ac_dp_termination_proof xml2name)
                                  (\ e ->
                                    xml_return
                                      (AC_Mono_Redpair_UR_Proc a b c d e))))))))
              (xml_do "acDepGraphProc"
                (xml_take_many_sub [] zero_nat Infinity_enat
                  (xml_do "component"
                    (xml_take
                      (xml_do "dps"
                        (xml_take (rules xml2name)
                          (\ xa -> xml_return (id xa))))
                      (\ dps ->
                        xml_take_optional (xml_bool "realScc")
                          (\ _ ->
                            xml_take_optional
                              (xml2ac_dp_termination_proof xml2name)
                              (\ prfOpt -> xml_return (prfOpt, dps))))))
                  (\ ret -> xml_return (AC_Dep_Graph_Proc ret))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2ac_termination_proof ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Ac_termination_proof a b [Char]);
xml2ac_termination_proof xml2name x =
  xml_do "acTerminationProof"
    (xml_take
      (xml_or
        (xml_do "acDependencyPairs"
          (xml_take
            (xml_do "equations"
              (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
            (\ e ->
              xml_take
                (xml_do "dpEquations"
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ dpe ->
                  xml_take
                    (xml_do "dps"
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ dp ->
                      xml_take
                        (xml_do "extensions"
                          (xml_take (rules xml2name)
                            (\ xa -> xml_return (id xa))))
                        (\ rext ->
                          xml_take (xml2ac_dp_termination_proof xml2name)
                            (\ p1 ->
                              xml_take_optional
                                (xml2ac_dp_termination_proof xml2name)
                                (\ a ->
                                  (case a of {
                                    Nothing ->
                                      xml_return
(AC_DP_Trans_Single (AC_dependency_pairs_proof e dp dpe rext) p1);
                                    Just p2 ->
                                      xml_return
(AC_DP_Trans (AC_dependency_pairs_proof e dp dpe rext) p1 p2);
                                  })))))))))
        (xml_or
          (xml_do "acRuleRemoval"
            (xml_take (ordering_constraint_proof xml2name False)
              (\ a ->
                xml_take
                  (xml_do "trs"
                    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                  (\ b ->
                    xml_take (xml2ac_termination_proof xml2name)
                      (\ c -> xml_return (AC_Rule_Removal a b c))))))
          (xml_do "acRIsEmpty" (xml_return AC_R_is_Empty))))
      (\ xa -> xml_return (id xa)))
    x;

safety_proof_parser ::
  forall a b c d e f.
    (Default f) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String) a) ->
                     ((Xml, ([([Char], [Char])],
                              (Bool, ([String], [String])))) ->
                       Sum_bot (Xml_error String) b) ->
                       ((Xml, ([([Char], [Char])],
                                (Bool, ([String], [String])))) ->
                         Sum_bot (Xml_error String)
                           (Formula (Term c (d, e)))) ->
                         ((Xml, ([([Char], [Char])],
                                  (Bool, ([String], [String])))) ->
                           Sum_bot (Xml_error String) f) ->
                           (Xml, ([([Char], [Char])],
                                   (Bool, ([String], [String])))) ->
                             Sum_bot (Xml_error String)
                               (Safety_proof c d e a [Char] b f);
safety_proof_parser location_parser trans_parser atom_parser hint_parser =
  xml_do "safetyViaInvariants"
    (xml_take (invariants_parser location_parser atom_parser)
      (\ i ->
        xml_take
          (invariant_proof_parser location_parser trans_parser atom_parser
            hint_parser i)
          (\ p -> xml_return (Invariant_Assertion p Trivial))));

lts_safety_proof_parser ::
  (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String)
      (Safety_proof Sig [Char] Ty [Char] [Char] [Char] Hints);
lts_safety_proof_parser =
  safety_proof_parser (location_parser xml_text) (trans_id xml_text) atom_parser
    hint_parser;

subsumption_proof ::
  forall a.
    (Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                   Sum_bot (Xml_error String) a) ->
                   (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                     Sum_bot (Xml_error String)
                       [((Term a [Char], Term a [Char]),
                          [([Nat],
                             ((Term a [Char], Term a [Char]),
                               (Bool, Term a [Char])))])];
subsumption_proof xml2name =
  xml_do "subsumptionProof"
    (xml_take_many_sub [] zero_nat Infinity_enat
      (xml_do "ruleSubsumptionProof"
        (xml_take (rule xml2name)
          (\ r ->
            xml_take (conversion xml2name) (\ (_, e) -> xml_return (r, e)))))
      xml_return);

xml2completion_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) (Completion_proof a b [Char]);
xml2completion_proof xml2name =
  xml_do "completionProof"
    (xml_take (wcr_proof xml2name)
      (\ w ->
        xml_take (xml2trs_termination_proof xml2name)
          (\ t ->
            xml_take
              (xml_do "equivalenceProof"
                (xml_take (subsumption_proof xml2name)
                  (\ s1 ->
                    xml_take_optional (subsumption_proof xml2name)
                      (\ s2 -> xml_return (s1, s2)))))
              (\ (s1, s2) -> xml_return (SN_WCR_Eq w t s1 s2)))));

xml2equational_disproof ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a [Nat])) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Equational_disproof a [Nat] [Char]);
xml2equational_disproof xml2name =
  xml_do "equationalDisproof"
    (xml_take
      (xml_or
        (xml_do "completionAndNormalization"
          (xml_take
            (xml_do "trs"
              (xml_take (rules xml2name) (\ x -> xml_return (id x))))
            (\ a ->
              xml_take (xml2completion_proof xml2name)
                (\ b ->
                  xml_return (Completion_and_Normalization_Different a b)))))
        (xml_or
          (xml_change (xml2ordered_completion xml2name)
            (\ (rs, (es, (ro, p))) ->
              xml_return
                (Ordered_Completion_and_Normalization_Different rs es ro p)))
          (xml_do "convertibleInstance"
            (xml_take (subsumption_proof xml2name)
              (\ x -> xml_return (Convertible_Instance x))))))
      (\ x -> xml_return (id x)));

xml2unknown_disproof ::
  forall a b.
    (Compare_order a, Showl a, Compare_order b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) (Neg_unknown_proof a b [Char]);
xml2unknown_disproof xml2name x =
  xml_do "unknownInputProof"
    (xml_take
      (xml_or
        (xml_do "unknownAssumption"
          (xml_take xml2unknown_input
            (\ xa -> xml_return (Assume_NT_Unknown xa []))))
        (xml_do "unknownProof"
          (xml_take (xml_text "description")
            (\ _ ->
              xml_take xml2unknown_input
                (\ b ->
                  xml_take_many_sub [] zero_nat Infinity_enat
                    (\ xa -> right (fst xa))
                    (\ _ -> xml_return (Assume_NT_Unknown b [])))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2equational_proof ::
  forall a.
    (Compare_order a, Eq a,
      Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a [Nat])) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        (Equational_proof a [Nat] [Char]);
xml2equational_proof xml2name =
  xml_do "equationalProof"
    (xml_take
      (xml_or
        (xml_do "equationalProofTree"
          (xml_take (xml2eq_proof xml2name)
            (\ x -> xml_return (Equational_Proof_Tree x))))
        (xml_or
          (xml_change (conversion xml2name)
            (\ (_, e) -> xml_return (Conversion e)))
          (xml_or
            (xml_change (subsumption_proof xml2name)
              (xml_return . Conversion_With_History))
            (xml_do "completionAndNormalization"
              (xml_take
                (xml_do "trs"
                  (xml_take (rules xml2name) (\ x -> xml_return (id x))))
                (\ a ->
                  xml_take (xml2completion_proof xml2name)
                    (\ b -> xml_return (Completion_and_Normalization a b))))))))
      (\ x -> xml_return (id x)));

xml2complexity_inputa ::
  forall a.
    (Eq a,
      Showl a) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) a) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String)
                        ([Term a [Char]],
                          ([(Term a [Char], Term a [Char])],
                            ([(Term a [Char], Term a [Char])],
                              (Complexity_measure a [Char],
                                Complexity_class))));
xml2complexity_inputa xml2name =
  xml_change (xml2complexity_input xml2name)
    (\ (CPX_input q s w cm cc) ->
      xml_return (strategy_to_Q q (s ++ w), (s, (w, (cm, cc)))));

xml2complexity_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) (Complexity_proof a b [Char]);
xml2complexity_proof xml2name x =
  xml_do "complexityProof"
    (xml_take
      (xml_or
        (xml_do "ruleShifting"
          (xml_take (ordering_constraint_proof xml2name True)
            (\ rp ->
              xml_take
                (xml_do "trs"
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ del ->
                  xml_take_optional
                    (xml_do "usableRules"
                      (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                    (\ ur ->
                      xml_take (xml2complexity_proof xml2name)
                        (\ prf ->
                          xml_return (Rule_Shift_Complexity rp del ur prf)))))))
        (xml_or
          (xml_do "usableRules"
            (xml_take
              (xml_do "nonUsableRules"
                (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
              (\ a ->
                xml_take (xml2complexity_proof xml2name)
                  (\ b -> xml_return (Usable_Rules_Complexity a b)))))
          (xml_or
            (xml_do "split"
              (xml_take
                (xml_do "trs"
                  (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                (\ a ->
                  xml_take (xml2complexity_proof xml2name)
                    (\ b ->
                      xml_take (xml2complexity_proof xml2name)
                        (\ c -> xml_return (Split_Complexity a b c))))))
            (xml_or
              (xml_do "removeNonApplicableRules"
                (xml_take
                  (xml_do "trs"
                    (xml_take (rules xml2name) (\ xa -> xml_return (id xa))))
                  (\ a ->
                    xml_take (xml2complexity_proof xml2name)
                      (\ b ->
                        xml_return
                          (Remove_Nonapplicable_Rules_Complexity a b)))))
              (xml_or
                (xml_change (bounds_info xml2name)
                  (xml_return . Matchbounds_Complexity))
                (xml_or
                  (xml_do "relativeBounds"
                    (xml_take (bounds_info xml2name)
                      (\ a ->
                        xml_take
                          (xml_do "trs"
                            (xml_take (rules xml2name)
                              (\ xa -> xml_return (id xa))))
                          (\ b ->
                            xml_take (xml2complexity_proof xml2name)
                              (\ c ->
                                xml_return
                                  (Matchbounds_Rel_Complexity a b c))))))
                  (xml_or (xml_do "rIsEmpty" (xml_return RisEmpty_Complexity))
                    (xml_or
                      (xml_do "dtTransformation"
                        (xml_take (rule_pairs xml2name "strictDTs" "ruleWithDT")
                          (\ s ->
                            xml_take
                              (rule_pairs xml2name "weakDTs" "ruleWithDT")
                              (\ w ->
                                xml_take (innermostLhss xml2name)
                                  (\ inn ->
                                    xml_take (xml2complexity_proof xml2name)
                                      (\ p ->
xml_return (DT_Transformation (DT_Transformation_Info s w inn) p)))))))
                      (xml_or
                        (xml_do "wdpTransformation"
                          (xml_take (symbols xml2name "compoundSymbols")
                            (\ comp ->
                              xml_take
                                (rule_pairs xml2name "strictWDPs" "ruleWithWDP")
                                (\ s ->
                                  xml_take
                                    (rule_pairs xml2name "weakWDPs"
                                      "ruleWithWDP")
                                    (\ w ->
                                      xml_take (innermostLhss xml2name)
(\ q ->
  xml_take (xml2complexity_proof xml2name)
    (\ p ->
      xml_return (WDP_Transformation (WDP_Trans_Info (set comp) s w q) p))))))))
                        (xml_or
                          (xml_do "unknownProof"
                            (xml_take (xml_text "description")
                              (\ _ ->
                                xml_take (xml2complexity_inputa xml2name)
                                  (\ b ->
                                    xml_take_many_sub [] zero_nat Infinity_enat
                                      (xml_do "subProof"
(xml_take (xml2complexity_inputa xml2name)
  (\ inp ->
    xml_take (xml2complexity_proof xml2name)
      (\ prf -> xml_return (Complexity_assm_proof inp prf)))))
                                      (\ c ->
xml_return (Complexity_Assumption b c))))))
                          (xml_do "complexityAssumption"
                            (xml_take (xml2complexity_inputa xml2name)
                              (\ p ->
                                xml_return
                                  (Complexity_Assumption p []))))))))))))))
      (\ xa -> xml_return (id xa)))
    x;

xml2unknown_proof ::
  forall a b.
    (Compare_order a, Eq a, Showl a, Compare_order b, Eq b,
      Showl b) => ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                    Sum_bot (Xml_error String) (Lab a b)) ->
                    (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
                      Sum_bot (Xml_error String) (Unknown_proof a b [Char]);
xml2unknown_proof xml2name x =
  xml_do "unknownInputProof"
    (xml_take
      (xml_or
        (xml_do "unknownAssumption"
          (xml_take xml2unknown_input
            (\ u -> xml_return (Assume_Unknown u []))))
        (xml_do "unknownProof"
          (xml_take (xml_text "description")
            (\ _ ->
              xml_take xml2unknown_input
                (\ b ->
                  xml_take_many_sub [] zero_nat Infinity_enat
                    (xml2subproof xml2name)
                    (\ c -> xml_return (Assume_Unknown b c)))))))
      xml_return)
    x;

xml2cert_problem ::
  ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
    Sum_bot (Xml_error String) [Char]) ->
    ((Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
      Sum_bot (Xml_error String) (Lab [Char] [Nat])) ->
      (Xml, ([([Char], [Char])], (Bool, ([String], [String])))) ->
        Sum_bot (Xml_error String)
          (Maybe (Input (Lab [Char] [Nat]) [Char]), Proof [Char] [Nat] [Char]);
xml2cert_problem xml2uname xml2name =
  xml_do "certificationProblem"
    (xml_take_optional (xml2input xml2name)
      (\ inp ->
        xml_take_optional (xml_text "cpfVersion")
          (\ _ ->
            xml_take
              (xml_do "proof"
                (xml_take
                  (xml_or
                    (xml_change (xml2trs_termination_proof xml2name)
                      (xml_return . TRS_Termination_Proof))
                    (xml_or
                      (xml_change (xml2trs_nontermination_proof xml2name)
                        (xml_return . TRS_Nontermination_Proof))
                      (xml_or
                        (xml_change (xml2reltrs_nontermination_proof xml2name)
                          (xml_return . Relative_TRS_Nontermination_Proof))
                        (xml_or
                          (xml_change (xml2cr_proof xml2name)
                            (xml_return . TRS_Confluence_Proof))
                          (xml_or
                            (xml_change (xml2ncr_proof xml2name)
                              (xml_return . TRS_Non_Confluence_Proof))
                            (xml_or
                              (xml_change (xml2dp_termination_proof xml2name)
                                (xml_return . DP_Termination_Proof))
                              (xml_or
                                (xml_change
                                  (xml2dp_nontermination_proof xml2name)
                                  (xml_return . DP_Nontermination_Proof))
                                (xml_or
                                  (xml_change (xml2completion_proof xml2name)
                                    (xml_return . Completion_Proof))
                                  (xml_or
                                    (xml_change
                                      (xml2ordered_completion_proof xml2name)
                                      (xml_return . Ordered_Completion_Proof))
                                    (xml_or
                                      (xml_change
(xml2equational_proof xml2name) (xml_return . Equational_Proof))
                                      (xml_or
(xml_change (xml2equational_disproof xml2name)
  (xml_return . Equational_Disproof))
(xml_or
  (xml_change (xml2complexity_proof xml2name) (xml_return . Complexity_Proof))
  (xml_or
    (xml_change (xml2quasi_reductive_proof xml2name)
      (xml_return . Quasi_Reductive_Proof))
    (xml_or
      (xml_change (xml2conditional_cr_proof xml2name)
        (xml_return . Conditional_CR_Proof))
      (xml_or
        (xml_change (xml2conditional_ncr_proof xml2name)
          (xml_return . Conditional_Non_CR_Proof))
        (xml_or
          (xml_do "treeAutomatonClosedProof"
            (xml_take closed_criterion
              (\ x -> xml_return (Tree_Automata_Closed_Proof x))))
          (xml_or
            (xml_change (xml2ac_termination_proof xml2name)
              (xml_return . AC_Termination_Proof))
            (xml_or
              (xml_do "ltsTerminationProof"
                (xml_take lts_termination_proof_parser
                  (\ x -> xml_return (LTS_Termination_Proof x))))
              (xml_or
                (xml_do "ltsSafetyProof"
                  (xml_take lts_safety_proof_parser
                    (\ x -> xml_return (LTS_Safety_Proof x))))
                (xml_or
                  (xml_change (xml2infeasibility_proof xml2name)
                    (xml_return . Infeasibility_Proof))
                  (xml_or
                    (xml_change (xml2unknown_proof xml2name)
                      (xml_return . Unknown_Proof))
                    (xml_change (xml2unknown_disproof xml2name)
                      (xml_return . Unknown_Disproof)))))))))))))))))))))))
                  xml_return))
              (\ p ->
                xml_take_optional (\ x -> right (fst x))
                  (\ _ -> xml_return (inp, p))))));

impl_ofe ::
  forall b a.
    (Compare_order b) => Ac_dpp b a ->
                           ([(Term b a, Term b a)],
                             ([(Term b a, Term b a)],
                               ([(Term b a, Term b a)],
                                 ([(Term b a, Term b a)],
                                   ([(Term b a, Term b a)],
                                     Rbt (b, Nat)
                                       [((), (Term b a, Term b a))])))));
impl_ofe (AC_DPP x) = x;

rw_implb ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
rw_implb (p, (pw, (r, (rw, (e, uu))))) = rw;

rwb :: forall a b. (Compare_order a) => Ac_dpp a b -> [(Term a b, Term a b)];
rwb xa = rw_implb (impl_ofe xa);

r_implb ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
r_implb (p, (pw, (r, (rw, (e, uu))))) = r;

rb :: forall a b. (Compare_order a) => Ac_dpp a b -> [(Term a b, Term a b)];
rb xa = r_implb (impl_ofe xa);

e_impl ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
e_impl (p, (pw, (r, (rw, (e, uu))))) = e;

e :: forall a b. (Compare_order a) => Ac_dpp a b -> [(Term a b, Term a b)];
e xa = e_impl (impl_ofe xa);

eq_rules_non_collapsing :: forall a b. (Compare_order a) => Ac_dpp a b -> Bool;
eq_rules_non_collapsing d = let {
                              t = all (\ (_, r) -> not (is_Var r));
                            } in t (rb d) && t (rwb d) && t (e d);

eq_rules_no_left_var :: forall a b. (Compare_order a) => Ac_dpp a b -> Bool;
eq_rules_no_left_var d = let {
                           t = all (\ (l, _) -> not (is_Var l));
                         } in t (rb d) && t (rwb d) && t (e d);

mk_implb ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     [(Term a b, Term a b)] ->
                       [(Term a b, Term a b)] ->
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   Rbt (a, Nat)
                                     [((), (Term a b, Term a b))])))));
mk_implb p pw r rw e =
  (p, (pw, (r, (rw, (e, insert_rules () (r ++ rw ++ e) empty)))));

delete_pairs_rules_impl ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               Rbt (a, Nat) [((), (Term a b, Term a b))])))));
delete_pairs_rules_impl (p, (pw, (r, (rw, (e, m))))) pd rd =
  (if null rd then (list_diff p pd, (list_diff pw pd, (r, (rw, (e, m)))))
    else mk_implb (list_diff p pd) (list_diff pw pd) (list_diff r rd)
           (list_diff rw rd) e);

delete_pairs_rules ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => Ac_dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Ac_dpp a b;
delete_pairs_rules xc xd xe =
  AC_DPP (delete_pairs_rules_impl (impl_ofe xc) xd xe);

reverse_rules_mapa ::
  forall a b.
    (Compare_order a, Eq a) => Ac_dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_mapa d fn =
  concatMap (\ (l, r) -> (if root r == Just fn then [(r, l)] else []))
    (rb d ++ rwb d ++ e d);

intersect_pairs_impla ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             Rbt (a, Nat) [((), (Term a b, Term a b))])))));
intersect_pairs_impla (p, (pw, (r, (rw, (e, m))))) pd =
  (list_inter p pd, (list_inter pw pd, (r, (rw, (e, m)))));

intersect_pairsa ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => Ac_dpp a b -> [(Term a b, Term a b)] -> Ac_dpp a b;
intersect_pairsa xb xc = AC_DPP (intersect_pairs_impla (impl_ofe xb) xc);

rules_map_implb ::
  forall a b.
    (Compare_order a) => ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   Rbt (a, Nat)
                                     [((), (Term a b, Term a b))]))))) ->
                           (a, Nat) -> [(Term a b, Term a b)];
rules_map_implb (p, (pw, (r, (rw, (e, m))))) fn = (case lookup m fn of {
            Nothing -> [];
            Just a -> map snd a;
          });

rules_mapb ::
  forall a b.
    (Compare_order a) => Ac_dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_mapb xa = rules_map_implb (impl_ofe xa);

ac_dpp_impl ::
  forall a b.
    (Compare_order a, Eq a, Compare b,
      Eq b) => ([(Term a b, Term a b)],
                 ([(Term a b, Term a b)],
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
                 (Set (Term a b, Term a b),
                   (Set (Term a b, Term a b),
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b), Set (Term a b, Term a b)))));
ac_dpp_impl (p, (pw, (r, (rw, (e, uu))))) =
  (set p, (set pw, (set r, (set rw, set e))));

ac_dpp ::
  forall a b.
    (Compare_order a, Eq a, Compare b,
      Eq b) => Ac_dpp a b ->
                 (Set (Term a b, Term a b),
                   (Set (Term a b, Term a b),
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b), Set (Term a b, Term a b)))));
ac_dpp xa = ac_dpp_impl (impl_ofe xa);

rules_implc ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
rules_implc (p, (pw, (r, (rw, (e, uu))))) = r ++ rw;

rulesd :: forall a b. (Compare_order a) => Ac_dpp a b -> [(Term a b, Term a b)];
rulesd xa = rules_implc (impl_ofe xa);

pairs_impla ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
pairs_impla (p, (pw, (r, (rw, (e, uu))))) = p ++ pw;

pairsa :: forall a b. (Compare_order a) => Ac_dpp a b -> [(Term a b, Term a b)];
pairsa xa = pairs_impla (impl_ofe xa);

mkb ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     [(Term a b, Term a b)] ->
                       [(Term a b, Term a b)] -> Ac_dpp a b;
mkb xc xd xe xf xg = AC_DPP (mk_implb xc xd xe xf xg);

pw_impla ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
pw_impla (p, (pw, (r, (rw, (e, uu))))) = pw;

pwa :: forall a b. (Compare_order a) => Ac_dpp a b -> [(Term a b, Term a b)];
pwa xa = pw_impla (impl_ofe xa);

p_impla ::
  forall a b.
    ([(Term a b, Term a b)],
      ([(Term a b, Term a b)],
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [((), (Term a b, Term a b))]))))) ->
      [(Term a b, Term a b)];
p_impla (p, (pw, (r, (rw, (e, uu))))) = p;

pa :: forall a b. (Compare_order a) => Ac_dpp a b -> [(Term a b, Term a b)];
pa xa = p_impla (impl_ofe xa);

ac_dpp_rbt_impl ::
  forall a b.
    (Compare_order a, Eq a, Compare b,
      Eq b) => Ac_dpp_ops_ext (Ac_dpp a b) a b ();
ac_dpp_rbt_impl =
  Ac_dpp_ops_ext ac_dpp pa pwa pairsa rb rwb rulesd e mkb rules_mapb
    reverse_rules_mapa delete_pairs_rules eq_rules_no_left_var
    eq_rules_non_collapsing intersect_pairsa ();

c_rules_impl :: forall a. [a] -> [(Term a [Char], Term a [Char])];
c_rules_impl c = let {
                   x = Var [Char False False False True True True True False];
                   y = Var [Char True False False True True True True False];
                 } in map (\ f -> (Fun f [x, y], Fun f [y, x])) c;

a_trs_impl :: forall a. [a] -> [(Term a [Char], Term a [Char])];
a_trs_impl a =
  let {
    x = Var [Char False False False True True True True False];
    y = Var [Char True False False True True True True False];
    z = Var [Char False True False True True True True False];
  } in map (\ f -> (Fun f [Fun f [x, y], z], Fun f [x, Fun f [y, z]])) a ++
         map (\ f -> (Fun f [x, Fun f [y, z]], Fun f [Fun f [x, y], z])) a;

aC_trs_impl :: forall a. [a] -> [a] -> [(Term a [Char], Term a [Char])];
aC_trs_impl a c = a_trs_impl a ++ c_rules_impl c;

ac_tp_list_impl ::
  forall a.
    (Ceq a, Ccompare a, Compare a, Eq a,
      Set_impl a) => Ac_tp_ops_ext
                       ([(Term a [Char], Term a [Char])], ([a], [a])) a [Char]
                       ();
ac_tp_list_impl =
  Ac_tp_ops_ext (\ (r, a) -> (case a of {
                               (aa, c) -> (set r, (set aa, set c));
                             }))
    (\ (r, (_, _)) -> r) (\ (_, a) -> (case a of {
(aa, _) -> aa;
                                      }))
    (\ (_, (_, c)) -> c) (\ r a c -> (r, (a, c)))
    (\ (r, a) -> (case a of {
                   (aa, c) -> (\ dr -> (list_diff r dr, (aa, c)));
                 }))
    (\ (_, a) -> (case a of {
                   (aa, b) -> aC_trs_impl aa b;
                 }))
    ();

rules_non_collapsing_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
rules_non_collapsing_impl (uu, (uv, (uw, (ux, (uy, (uz, (nc, va))))))) = nc;

impl_ofd ::
  forall b a.
    (Compare_order b) => Dpp b a ->
                           (Bool,
                             (Bool,
                               ([(Term b a, Term b a)],
                                 ([(Term b a, Term b a)],
                                   ([Term b a],
                                     (Bool,
                                       (Bool,
 ([(Term b a, Term b a)],
   ([(Term b a, Term b a)],
     (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
       (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
         (Bool, Term b a -> Bool))))))))))));
impl_ofd (DPP x) = x;

rules_non_collapsing :: forall a b. (Compare_order a) => Dpp a b -> Bool;
rules_non_collapsing d = rules_non_collapsing_impl (impl_ofd d);

nFQ_subset_NF_rules_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
nFQ_subset_NF_rules_impla (uu, (uv, (uw, (ux, (uy, (b, uz)))))) = b;

nFQ_subset_NF_rulesa :: forall a b. (Compare_order a) => Dpp a b -> Bool;
nFQ_subset_NF_rulesa d = nFQ_subset_NF_rules_impla (impl_ofd d);

rules_no_left_var_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
rules_no_left_var_impl (uu, (uv, (uw, (ux, (uy, (uz, (va, ([], ([], vb)))))))))
  = True;
rules_no_left_var_impl (v, (vb, (ve, (vg, (vi, (vk, (vm, (vq : vr, vp)))))))) =
  False;
rules_no_left_var_impl
  (v, (vb, (ve, (vg, (vi, (vk, (vm, (vo, (vs : vt, vr))))))))) = False;

rules_no_left_var :: forall a b. (Compare_order a) => Dpp a b -> Bool;
rules_no_left_var d = rules_no_left_var_impl (impl_ofd d);

reverse_rules_map_impl ::
  forall a b.
    (Compare_order a) => (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([Term a b],
                                   (Bool,
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
     (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
       (Bool, Term a b -> Bool)))))))))))) ->
                           (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_map_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (m, ve))))))))))) fn =
  (case lookup m fn of {
    Nothing -> [];
    Just a -> map snd a;
  });

reverse_rules_map ::
  forall a b.
    (Compare_order a) => Dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_map d = reverse_rules_map_impl (impl_ofd d);

is_NF_trs_subset ::
  forall a b. (Term a b -> Bool) -> [(Term a b, Term a b)] -> Bool;
is_NF_trs_subset is_Q_nf r = is_NF_subset is_Q_nf (map fst r);

wwf_qtrs_impl ::
  forall a b. (Eq b) => (Term a b -> Bool) -> [(Term a b, Term a b)] -> Bool;
wwf_qtrs_impl nf r =
  all (\ ra -> wf_rule ra || not (applicable_rule_impl nf ra)) r;

intersect_rules_impl ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   (Bool,
                     (Bool,
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([Term a b],
                             (Bool,
                               (Bool,
                                 ([(Term a b, Term a b)],
                                   ([(Term a b, Term a b)],
                                     (Rbt (a, Nat)
[(Bool, (Term a b, Term a b))],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Bool, Term a b -> Bool))))))))))));
intersect_rules_impl d ri =
  (case d of {
    (nfs, (mi, (p, (pw, (q, (nfq, (nc, (vR,
 (vRw, (m, (rm, (wwf, isnf))))))))))))
      -> (case partition (is_Var . fst) ri of {
           (vri, ria) ->
             let {
               vr = list_inter vR vri;
               vrw = list_inter vRw vri;
               ma = intersect_rules ria m;
               rma = intersect_rules (reverse_rules ri) rm;
               rs = vr ++ vrw ++ map snd (values ma);
             } in (nfs, (mi, (p, (pw, (q,
(nfq || is_NF_trs_subset isnf rs,
  (nc || all (\ r -> not (is_Var (snd r))) rs,
    (vr, (vrw, (ma, (rma, (wwf || wwf_qtrs_impl isnf rs, isnf))))))))))));
         });
  });

intersect_rulesa ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => Dpp a b -> [(Term a b, Term a b)] -> Dpp a b;
intersect_rulesa d rs = DPP (intersect_rules_impl (impl_ofd d) rs);

intersect_pairs_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   (Bool,
                     (Bool,
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([Term a b],
                             (Bool,
                               (Bool,
                                 ([(Term a b, Term a b)],
                                   ([(Term a b, Term a b)],
                                     (Rbt (a, Nat)
[(Bool, (Term a b, Term a b))],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Bool, Term a b -> Bool))))))))))));
intersect_pairs_impl (nfs, (mi, (p, (pw, rest)))) ps =
  (nfs, (mi, (list_inter p ps, (list_inter pw ps, rest))));

intersect_pairs ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => Dpp a b -> [(Term a b, Term a b)] -> Dpp a b;
intersect_pairs d ps = DPP (intersect_pairs_impl (impl_ofd d) ps);

replace_pair_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (Term a b, Term a b) ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
replace_pair_impl (nfs, (mi, (p, (pw, rest)))) pair ps =
  (nfs, (mi, (replace_impl pair ps p, (replace_impl pair ps pw, rest))));

replace_pair ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => Dpp a b ->
                 (Term a b, Term a b) -> [(Term a b, Term a b)] -> Dpp a b;
replace_pair d pair ps = DPP (replace_pair_impl (impl_ofd d) pair ps);

rules_implb ::
  forall a b.
    (Compare_order a) => (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([Term a b],
                                   (Bool,
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
     (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
       (Bool, Term a b -> Bool)))))))))))) ->
                           [(Term a b, Term a b)];
rules_implb (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vrw, (m, vb)))))))))) =
  vr ++ vrw ++ map snd (values m);

split_rules_impla ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules_impla d rs = partition (membera rs) (rules_implb d);

split_rulesa ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rulesa d = split_rules_impla (impl_ofd d);

pairs_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
pairs_impl (uu, (uv, (p, (pw, uw)))) = p ++ pw;

split_pairs_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_pairs_impl d ps = partition (membera ps) (pairs_impl d);

split_pairs ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_pairs d = split_pairs_impl (impl_ofd d);

delete_R_Rw_impla ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
delete_R_Rw_impla d r rw =
  (case d of {
    (nfs, (mi, (p, (pw, (q, (nfq, (nc, (vR,
 (vRw, (m, (rm, (wwf, isnf))))))))))))
      -> (case partition (is_Var . fst) r of {
           (vr, ra) ->
             (case partition (is_Var . fst) rw of {
               (vrw, rwa) ->
                 let {
                   vra = list_diff vR vr;
                   vrwa = list_diff vRw vrw;
                   ma = delete_rules True ra (delete_rules False rwa m);
                   rma = delete_rules True (reverse_rules r)
                           (delete_rules False (reverse_rules rw) rm);
                   rs = vra ++ vrwa ++ map snd (values ma);
                 } in (nfs, (mi, (p, (pw, (q,
    (nfq || is_NF_trs_subset isnf rs,
      (nc || all (\ rb -> not (is_Var (snd rb))) rs,
        (vra, (vrwa, (ma, (rma, (wwf || wwf_qtrs_impl isnf rs, isnf))))))))))));
             });
         });
  });

delete_R_Rwa ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Dpp a b;
delete_R_Rwa d r rw = DPP (delete_R_Rw_impla (impl_ofd d) r rw);

delete_P_Pw_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
delete_P_Pw_impl (nfs, (mi, (p, (pw, rest)))) pd pwd =
  (nfs, (mi, (list_diff p pd, (list_diff pw pwd, rest))));

delete_P_Pw ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Dpp a b;
delete_P_Pw d p pw = DPP (delete_P_Pw_impl (impl_ofd d) p pw);

rules_map_impla ::
  forall a b.
    (Compare_order a) => (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([Term a b],
                                   (Bool,
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
     (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
       (Bool, Term a b -> Bool)))))))))))) ->
                           (a, Nat) -> [(Term a b, Term a b)];
rules_map_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (m, vd)))))))))) fn
  = (case lookup m fn of {
      Nothing -> [];
      Just a -> map snd a;
    });

rules_mapa ::
  forall a b.
    (Compare_order a) => Dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_mapa d = rules_map_impla (impl_ofd d);

wwf_rules_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
wwf_rules_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, (wwf, vf)))))))))))) =
  wwf;

wwf_rules :: forall a b. (Compare_order a) => Dpp a b -> Bool;
wwf_rules d = wwf_rules_impl (impl_ofd d);

q_empty_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
q_empty_impla (uu, (uv, (uw, (ux, (q, uy))))) = null q;

q_emptya :: forall a b. (Compare_order a) => Dpp a b -> Bool;
q_emptya d = q_empty_impla (impl_ofd d);

is_QNF_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Term a b -> Bool;
is_QNF_impla
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, (vf, isnf)))))))))))) =
  isnf;

is_QNFa :: forall a b. (Compare_order a) => Dpp a b -> Term a b -> Bool;
is_QNFa d = is_QNF_impla (impl_ofd d);

rulesc :: forall a b. (Compare_order a) => Dpp a b -> [(Term a b, Term a b)];
rulesc d = rules_implb (impl_ofd d);

pairs :: forall a b. (Compare_order a) => Dpp a b -> [(Term a b, Term a b)];
pairs d = pairs_impl (impl_ofd d);

dpp_impl ::
  forall a b.
    (Compare_order a, Eq a, Compare b,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (Bool,
                   (Bool,
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b),
                         (Set (Term a b),
                           (Set (Term a b, Term a b),
                             Set (Term a b, Term a b)))))));
dpp_impl (nfs, (mi, (p, (pw, (q, (uu, (uv, (vr, (vrw, (m, uw)))))))))) =
  (nfs, (mi, (set p,
               (set pw,
                 (set q,
                   (set (vr ++ rules_with id m),
                     set (vrw ++ rules_with not m)))))));

dpp ::
  forall a b.
    (Compare_order a, Eq a, Compare b,
      Eq b) => Dpp a b ->
                 (Bool,
                   (Bool,
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b),
                         (Set (Term a b),
                           (Set (Term a b, Term a b),
                             Set (Term a b, Term a b)))))));
dpp d = dpp_impl (impl_ofd d);

nfs_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
nfs_impla (nfs, uu) = nfs;

nfsa :: forall a b. (Compare_order a) => Dpp a b -> Bool;
nfsa d = nfs_impla (impl_ofd d);

mk_impla ::
  forall a b.
    (Compare_order a, Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 [Term a b] ->
                                   [(Term a b, Term a b)] ->
                                     [(Term a b, Term a b)] ->
                                       (Bool,
 (Bool,
   ([(Term a b, Term a b)],
     ([(Term a b, Term a b)],
       ([Term a b],
         (Bool,
           (Bool,
             ([(Term a b, Term a b)],
               ([(Term a b, Term a b)],
                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                     (Bool, Term a b -> Bool))))))))))));
mk_impla nfs mi p pw q r rw =
  (case partition (is_Var . fst) r of {
    (vr, ra) ->
      (case partition (is_Var . fst) rw of {
        (vrw, rwa) ->
          let {
            rs = r ++ rw;
            isnf = is_NF_terms q;
          } in (nfs, (mi, (p, (pw, (q, (is_NF_trs_subset isnf rs,
 (all (\ rb -> not (is_Var (snd rb))) rs,
   (vr, (vrw, (insert_rules True ra (insert_rules False rwa empty),
                (insert_rules True (reverse_rules r)
                   (insert_rules False (reverse_rules rw) empty),
                  (wwf_qtrs_impl isnf rs, isnf))))))))))));
      });
  });

mka ::
  forall a b.
    (Compare_order a, Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 [Term a b] ->
                                   [(Term a b, Term a b)] ->
                                     [(Term a b, Term a b)] -> Dpp a b;
mka nfs mi p pw q r rw = DPP (mk_impla nfs mi p pw q r rw);

rw_impla ::
  forall a b.
    (Compare_order a) => (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([Term a b],
                                   (Bool,
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
     (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
       (Bool, Term a b -> Bool)))))))))))) ->
                           [(Term a b, Term a b)];
rw_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vrw, (m, vc)))))))))) =
  vrw ++ rules_with not m;

rwa :: forall a b. (Compare_order a) => Dpp a b -> [(Term a b, Term a b)];
rwa d = rw_impla (impl_ofd d);

pw_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
pw_impl (uu, (uv, (uw, (pw, ux)))) = pw;

pw :: forall a b. (Compare_order a) => Dpp a b -> [(Term a b, Term a b)];
pw d = pw_impl (impl_ofd d);

r_impla ::
  forall a b.
    (Compare_order a) => (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([Term a b],
                                   (Bool,
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
     (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
       (Bool, Term a b -> Bool)))))))))))) ->
                           [(Term a b, Term a b)];
r_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vb, (m, vc)))))))))) =
  vr ++ rules_with id m;

ra :: forall a b. (Compare_order a) => Dpp a b -> [(Term a b, Term a b)];
ra d = r_impla (impl_ofd d);

q_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [Term a b];
q_impla (uu, (uv, (uw, (ux, (q, uy))))) = q;

qa :: forall a b. (Compare_order a) => Dpp a b -> [Term a b];
qa d = q_impla (impl_ofd d);

p_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
p_impl (uu, (uv, (p, uw))) = p;

p :: forall a b. (Compare_order a) => Dpp a b -> [(Term a b, Term a b)];
p d = p_impl (impl_ofd d);

m_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
m_impl (uu, (mi, uv)) = mi;

m :: forall a b. (Compare_order a) => Dpp a b -> Bool;
m d = m_impl (impl_ofd d);

dpp_rbt_impl ::
  forall a b.
    (Compare_order a, Eq a, Ccompare b, Compare b, Eq b,
      Mapping_impl b) => Dpp_ops_ext (Dpp a b) a b ();
dpp_rbt_impl =
  Dpp_ops_ext dpp p pw pairs qa ra rwa rulesc q_emptya rules_no_left_var
    rules_non_collapsing is_QNFa nFQ_subset_NF_rulesa rules_mapa
    reverse_rules_map intersect_pairs replace_pair intersect_rulesa delete_P_Pw
    delete_R_Rwa split_pairs split_rulesa mka m nfsa wwf_rules ();

nFQ_subset_NF_rules_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Bool;
nFQ_subset_NF_rules_impl (uu, (uv, (b, uw))) = b;

nFQ_subset_NF_rules ::
  forall a b. (Compare_order a, Compare_order b) => Tp a b -> Bool;
nFQ_subset_NF_rules tp = nFQ_subset_NF_rules_impl (impl_ofc tp);

rules_impla ::
  forall a b.
    (Compare_order a) => (Bool,
                           ([Term a b],
                             (Bool,
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Term a b -> Bool)))))) ->
                           [(Term a b, Term a b)];
rules_impla (uu, (uv, (uw, (vR, (vRw, (m, ux)))))) =
  vR ++ vRw ++ map snd (values m);

split_rules_impl ::
  forall a b.
    (Compare_order a,
      Compare_order b) => (Bool,
                            ([Term a b],
                              (Bool,
                                ([(Term a b, Term a b)],
                                  ([(Term a b, Term a b)],
                                    (Rbt (a, Nat)
                                       [(Bool, (Term a b, Term a b))],
                                      Term a b -> Bool)))))) ->
                            [(Term a b, Term a b)] ->
                              ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules_impl tp rs = let {
                           m = ceta_set_of rs;
                         } in partition m (rules_impla tp);

split_rules ::
  forall a b.
    (Compare_order a,
      Compare_order b) => Tp a b ->
                            [(Term a b, Term a b)] ->
                              ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules tp = split_rules_impl (impl_ofc tp);

delete_R_Rw_impl ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       ([Term a b],
                         (Bool,
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                 Term a b -> Bool))))));
delete_R_Rw_impl (nfs, (q, (uu, (vR, (vRw, (m, isnf)))))) r rw =
  (case partition (is_Var . fst) r of {
    (vr, ra) ->
      (case partition (is_Var . fst) rw of {
        (vrw, rwa) ->
          let {
            vra = list_diff vR vr;
            vrwa = list_diff vRw vrw;
            ma = delete_rules True ra (delete_rules False rwa m);
          } in (nfs, (q, (is_NF_trs_subset isnf
                            (vra ++ vrwa ++ map snd (values ma)),
                           (vra, (vrwa, (ma, isnf))))));
      });
  });

delete_R_Rw ::
  forall a b.
    (Compare_order a, Eq a, Compare_order b,
      Eq b) => Tp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Tp a b;
delete_R_Rw tp r rw = TP (delete_R_Rw_impl (impl_ofc tp) r rw);

rules_map_impl ::
  forall a b.
    (Compare_order a) => (Bool,
                           ([Term a b],
                             (Bool,
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Term a b -> Bool)))))) ->
                           (a, Nat) -> [(Term a b, Term a b)];
rules_map_impl (uu, (uv, (uw, (ux, (uy, (m, uz)))))) fn =
  (case lookup m fn of {
    Nothing -> [];
    Just a -> map snd a;
  });

rules_map ::
  forall a b.
    (Compare_order a,
      Compare_order b) => Tp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_map tp = rules_map_impl (impl_ofc tp);

qreltrs_impl ::
  forall a b.
    (Compare_order a, Eq a, Compare b,
      Eq b) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 (Bool,
                   (Set (Term a b),
                     (Set (Term a b, Term a b), Set (Term a b, Term a b))));
qreltrs_impl (nfs, (q, (uu, (vR, (vRw, (m, isnf)))))) =
  (nfs, (set q, (set (vR ++ rules_with id m), set (vRw ++ rules_with not m))));

qreltrs ::
  forall a b.
    (Compare_order a, Eq a, Compare_order b,
      Eq b) => Tp a b ->
                 (Bool,
                   (Set (Term a b),
                     (Set (Term a b, Term a b), Set (Term a b, Term a b))));
qreltrs tp = qreltrs_impl (impl_ofc tp);

q_empty_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Bool;
q_empty_impl (uu, (q, uv)) = null q;

q_empty :: forall a b. (Compare_order a, Compare_order b) => Tp a b -> Bool;
q_empty tp = q_empty_impl (impl_ofc tp);

is_QNF_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Term a b -> Bool;
is_QNF_impl (uu, (uv, (uw, (ux, (uy, (uz, isnf)))))) = isnf;

is_QNF ::
  forall a b. (Compare_order a, Compare_order b) => Tp a b -> Term a b -> Bool;
is_QNF tp = is_QNF_impl (impl_ofc tp);

rulesb ::
  forall a b.
    (Compare_order a, Compare_order b) => Tp a b -> [(Term a b, Term a b)];
rulesb tp = rules_impla (impl_ofc tp);

nfs_impl ::
  forall a b.
    (Compare_order a) => (Bool,
                           ([Term a b],
                             (Bool,
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Term a b -> Bool)))))) ->
                           Bool;
nfs_impl (nfs, uu) = nfs;

nfs :: forall a b. (Compare_order a, Compare_order b) => Tp a b -> Bool;
nfs tp = nfs_impl (impl_ofc tp);

mk_impl ::
  forall a b.
    (Compare_order a, Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           [Term a b] ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 (Bool,
                                   ([Term a b],
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Term a b -> Bool))))));
mk_impl nfs q r rw =
  (case partition (is_Var . fst) r of {
    (vr, ra) ->
      (case partition (is_Var . fst) rw of {
        (vrw, rwa) ->
          let {
            isnf = is_NF_terms q;
          } in (nfs, (q, (is_NF_trs_subset isnf (r ++ rw),
                           (vr, (vrw, (insert_rules True ra
 (insert_rules False rwa empty),
isnf))))));
      });
  });

mk :: forall a b.
        (Compare_order a, Eq a, Ccompare b, Compare_order b, Eq b,
          Mapping_impl b) => Bool ->
                               [Term a b] ->
                                 [(Term a b, Term a b)] ->
                                   [(Term a b, Term a b)] -> Tp a b;
mk nfs q r rw = TP (mk_impl nfs q r rw);

rw_impl ::
  forall a b.
    (Compare_order a) => (Bool,
                           ([Term a b],
                             (Bool,
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Term a b -> Bool)))))) ->
                           [(Term a b, Term a b)];
rw_impl (uu, (uv, (uw, (ux, (vRw, (m, uy)))))) = vRw ++ rules_with not m;

rw :: forall a b.
        (Compare_order a, Compare_order b) => Tp a b -> [(Term a b, Term a b)];
rw tp = rw_impl (impl_ofc tp);

tp_rbt_impl ::
  forall a b.
    (Compare_order a, Eq a, Ccompare b, Compare_order b, Eq b,
      Mapping_impl b) => Tp_ops_ext (Tp a b) a b ();
tp_rbt_impl =
  Tp_ops_ext qreltrs q r rw rulesb q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs ();

certify_cert_problem ::
  forall a b c d e.
    (Compare_order b, Countable b, Default b, Eq b,
      Showl b) => Tp_ops_ext a (Lab b [Nat]) [Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Char] () ->
                      Ac_tp_ops_ext d (Lab b [Nat]) [Char] () ->
                        Ac_dpp_ops_ext e (Lab b [Nat]) [Char] () ->
                          Bool ->
                            Input (Lab b [Nat]) [Char] ->
                              Claim (Lab b [Nat]) [Char] ->
                                Proof b [Nat] [Char] -> Cert_result;
certify_cert_problem i j k l a input claim proof =
  (case check_cert i j k l a input claim proof of {
    Inl err -> Error (err "");
    Inr _ -> Certified;
  });

parse_cert_problem ::
  [Char] ->
    Sum_bot [Char]
      (Maybe (Input (Lab [Char] [Nat]) [Char]), Proof [Char] [Nat] [Char]);
parse_cert_problem =
  parse_xmlfile
    (debug (showsl_literal "0") "parsing xml to certification problem"
      (xml2cert_problem (xml_text "name") plain_name));

certify_proof ::
  Bool ->
    Maybe [Char] ->
      Sum (Claim (Lab [Char] [Nat]) [Char]) [Char] -> [Char] -> Cert_result;
certify_proof a xtc_o claim_o cpf =
  let {
    input_ret1 =
      (case xtc_o of {
        Nothing -> right Nothing;
        Just xtc ->
          bind2 (parse_xmlfile (problem plain_name) xtc) (left . implode)
            (right . Just);
      });
  } in bind2a input_ret1 Unsupported
         (\ input_o1 ->
           let {
             claim_ret = (case claim_o of {
                           Inl aa -> right aa;
                           Inr aa -> parse_claim plain_name aa;
                         });
           } in bind2a claim_ret (Unsupported . implode)
                  (\ claim ->
                    bind2a (parse_cert_problem cpf) (Unsupported . implode)
                      (\ (input_o2, proof) ->
                        (case (input_o1, input_o2) of {
                          (Nothing, Nothing) ->
                            Unsupported "missing input problem";
                          (Nothing, Just input) ->
                            certify_cert_problem tp_rbt_impl dpp_rbt_impl
                              ac_tp_list_impl ac_dpp_rbt_impl a input claim
                              proof;
                          (Just input, _) ->
                            certify_cert_problem tp_rbt_impl dpp_rbt_impl
                              ac_tp_list_impl ac_dpp_rbt_impl a input claim
                              proof;
                        }))));

}
