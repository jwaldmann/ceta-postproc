{-# LANGUAGE EmptyDataDecls, RankNTypes, ScopedTypeVariables #-}

module
  Ceta(Nat, Nibble, Sum(..), Lab, Xml, Sum_bot(..), Cert_result(..),
        Cert_problem, Tp, Dpp, Tp_ops_ext, Dpp_ops_ext, certify_proof)
  where {

import Prelude ((==), (/=), (<), (<=), (>=), (>), (+), (-), (*), (/), (**),
  (>>=), (>>), (=<<), (&&), (||), (^), (^^), (.), ($), ($!), (++), (!!), Eq,
  error, id, return, not, fst, snd, map, filter, concat, concatMap, reverse,
  zip, null, takeWhile, dropWhile, all, any, Integer, negate, abs, divMod,
  String, Bool(True, False), Maybe(Nothing, Just));
import qualified Prelude;

data Num = One | Bit0 Num | Bit1 Num;

equal_num :: Num -> Num -> Bool;
equal_num (Bit0 x2) (Bit1 x3) = False;
equal_num (Bit1 x3) (Bit0 x2) = False;
equal_num One (Bit1 x3) = False;
equal_num (Bit1 x3) One = False;
equal_num One (Bit0 x2) = False;
equal_num (Bit0 x2) One = False;
equal_num (Bit1 x3) (Bit1 y3) = equal_num x3 y3;
equal_num (Bit0 x2) (Bit0 y2) = equal_num x2 y2;
equal_num One One = True;

data Int = Zero_int | Pos Num | Neg Num;

equal_int :: Int -> Int -> Bool;
equal_int (Neg k) (Neg l) = equal_num k l;
equal_int (Neg k) (Pos l) = False;
equal_int (Neg k) Zero_int = False;
equal_int (Pos k) (Neg l) = False;
equal_int (Pos k) (Pos l) = equal_num k l;
equal_int (Pos k) Zero_int = False;
equal_int Zero_int (Neg l) = False;
equal_int Zero_int (Pos l) = False;
equal_int Zero_int Zero_int = True;

instance Eq Int where {
  a == b = equal_int a b;
};

plus_num :: Num -> Num -> Num;
plus_num (Bit1 m) (Bit1 n) = Bit0 (plus_num (plus_num m n) One);
plus_num (Bit1 m) (Bit0 n) = Bit1 (plus_num m n);
plus_num (Bit1 m) One = Bit0 (plus_num m One);
plus_num (Bit0 m) (Bit1 n) = Bit1 (plus_num m n);
plus_num (Bit0 m) (Bit0 n) = Bit0 (plus_num m n);
plus_num (Bit0 m) One = Bit1 m;
plus_num One (Bit1 n) = Bit0 (plus_num n One);
plus_num One (Bit0 n) = Bit1 n;
plus_num One One = Bit0 One;

times_num :: Num -> Num -> Num;
times_num (Bit1 m) (Bit1 n) =
  Bit1 (plus_num (plus_num m n) (Bit0 (times_num m n)));
times_num (Bit1 m) (Bit0 n) = Bit0 (times_num (Bit1 m) n);
times_num (Bit0 m) (Bit1 n) = Bit0 (times_num m (Bit1 n));
times_num (Bit0 m) (Bit0 n) = Bit0 (Bit0 (times_num m n));
times_num One n = n;
times_num m One = m;

times_int :: Int -> Int -> Int;
times_int (Neg m) (Neg n) = Pos (times_num m n);
times_int (Neg m) (Pos n) = Neg (times_num m n);
times_int (Pos m) (Neg n) = Neg (times_num m n);
times_int (Pos m) (Pos n) = Pos (times_num m n);
times_int Zero_int l = Zero_int;
times_int k Zero_int = Zero_int;

class Times a where {
  times :: a -> a -> a;
};

class (Times a) => Dvd a where {
};

instance Times Int where {
  times = times_int;
};

instance Dvd Int where {
};

uminus_int :: Int -> Int;
uminus_int (Neg m) = Pos m;
uminus_int (Pos m) = Neg m;
uminus_int Zero_int = Zero_int;

data Nat = Zero_nat | Nat_of_num Num;

equal_nat :: Nat -> Nat -> Bool;
equal_nat (Nat_of_num k) (Nat_of_num l) = equal_num k l;
equal_nat (Nat_of_num k) Zero_nat = False;
equal_nat Zero_nat (Nat_of_num l) = False;
equal_nat Zero_nat Zero_nat = True;

data Nibble = Nibble0 | Nibble1 | Nibble2 | Nibble3 | Nibble4 | Nibble5
  | Nibble6 | Nibble7 | Nibble8 | Nibble9 | NibbleA | NibbleB | NibbleC
  | NibbleD | NibbleE | NibbleF;

string_of_digit :: Nat -> [Prelude.Char];
string_of_digit n =
  (if equal_nat n Zero_nat then "0"
    else (if equal_nat n (Nat_of_num One) then "1"
           else (if equal_nat n (Nat_of_num (Bit0 One)) then "2"
                  else (if equal_nat n (Nat_of_num (Bit1 One)) then "3"
                         else (if equal_nat n (Nat_of_num (Bit0 (Bit0 One)))
                                then "4"
                                else (if equal_nat n
   (Nat_of_num (Bit1 (Bit0 One)))
                                       then "5"
                                       else (if equal_nat n
          (Nat_of_num (Bit0 (Bit1 One)))
      then "6"
      else (if equal_nat n (Nat_of_num (Bit1 (Bit1 One))) then "7"
             else (if equal_nat n (Nat_of_num (Bit0 (Bit0 (Bit0 One)))) then "8"
                    else "9")))))))));

class Ord a where {
  less_eq :: a -> a -> Bool;
  less :: a -> a -> Bool;
};

class Plus a where {
  plus :: a -> a -> a;
};

class One a where {
  onea :: a;
};

class (Plus a) => Semigroup_add a where {
};

class (One a, Semigroup_add a) => Numeral a where {
};

numeral :: forall a. (Numeral a) => Num -> a;
numeral (Bit1 n) = let {
                     m = numeral n;
                   } in plus (plus m m) onea;
numeral (Bit0 n) = let {
                     m = numeral n;
                   } in plus m m;
numeral One = onea;

class Minus a where {
  minus :: a -> a -> a;
};

class (Semigroup_add a) => Cancel_semigroup_add a where {
};

class (Semigroup_add a) => Ab_semigroup_add a where {
};

class (Ab_semigroup_add a, Cancel_semigroup_add a,
        Minus a) => Cancel_ab_semigroup_add a where {
};

class Zero a where {
  zeroa :: a;
};

class (Semigroup_add a, Zero a) => Monoid_add a where {
};

class (Ab_semigroup_add a, Monoid_add a) => Comm_monoid_add a where {
};

class (Cancel_ab_semigroup_add a,
        Comm_monoid_add a) => Cancel_comm_monoid_add a where {
};

class (Times a, Zero a) => Mult_zero a where {
};

class (Times a) => Semigroup_mult a where {
};

class (Ab_semigroup_add a, Semigroup_mult a) => Semiring a where {
};

class (Comm_monoid_add a, Mult_zero a, Semiring a) => Semiring_0 a where {
};

class (Cancel_comm_monoid_add a, Semiring_0 a) => Semiring_0_cancel a where {
};

class (Semigroup_mult a) => Ab_semigroup_mult a where {
};

class (Ab_semigroup_mult a, Semiring a) => Comm_semiring a where {
};

class (Comm_semiring a, Semiring_0 a) => Comm_semiring_0 a where {
};

class (Comm_semiring_0 a,
        Semiring_0_cancel a) => Comm_semiring_0_cancel a where {
};

class (One a, Times a) => Power a where {
};

class (Semigroup_mult a, Power a) => Monoid_mult a where {
};

class (Monoid_mult a, Numeral a, Semiring a) => Semiring_numeral a where {
};

class (One a, Zero a) => Zero_neq_one a where {
};

class (Semiring_numeral a, Semiring_0 a, Zero_neq_one a) => Semiring_1 a where {
};

class (Semiring_0_cancel a, Semiring_1 a) => Semiring_1_cancel a where {
};

class (Ab_semigroup_mult a, Monoid_mult a, Dvd a) => Comm_monoid_mult a where {
};

class (Comm_monoid_mult a, Comm_semiring_0 a,
        Semiring_1 a) => Comm_semiring_1 a where {
};

class (Comm_semiring_0_cancel a, Comm_semiring_1 a,
        Semiring_1_cancel a) => Comm_semiring_1_cancel a where {
};

class (Comm_semiring_1_cancel a) => Comm_semiring_1_diff_distrib a where {
};

class (Comm_semiring_1_diff_distrib a) => Semiring_parity a where {
};

class (Semiring_0 a) => Semiring_no_zero_divisors a where {
};

class (Comm_semiring_1_diff_distrib a,
        Semiring_no_zero_divisors a) => Semidom a where {
};

class (Dvd a) => Div a where {
  div :: a -> a -> a;
  mod :: a -> a -> a;
};

class (Div a, Semidom a) => Semiring_div a where {
};

class (Semiring_div a, Semiring_parity a) => Semiring_div_parity a where {
};

class (Ord a) => Preorder a where {
};

class (Preorder a) => Order a where {
};

class (Ab_semigroup_add a, Order a) => Ordered_ab_semigroup_add a where {
};

class (Comm_monoid_add a, Ordered_ab_semigroup_add a,
        Semiring a) => Ordered_semiring a where {
};

class (Ordered_semiring a,
        Semiring_0_cancel a) => Ordered_cancel_semiring a where {
};

class (Comm_semiring_0 a, Ordered_semiring a) => Ordered_comm_semiring a where {
};

class (Comm_semiring_0_cancel a, Ordered_cancel_semiring a,
        Ordered_comm_semiring a) => Ordered_cancel_comm_semiring a where {
};

class (Cancel_ab_semigroup_add a,
        Ordered_ab_semigroup_add a) => Ordered_cancel_ab_semigroup_add a where {
};

class (Ordered_cancel_ab_semigroup_add a) => Ordered_ab_semigroup_add_imp_le a where {
};

class (Order a) => Linorder a where {
};

class (Ordered_ab_semigroup_add a,
        Linorder a) => Linordered_ab_semigroup_add a where {
};

class (Linordered_ab_semigroup_add a,
        Ordered_ab_semigroup_add_imp_le a) => Linordered_cancel_ab_semigroup_add a where {
};

class (Comm_monoid_add a,
        Ordered_cancel_ab_semigroup_add a) => Ordered_comm_monoid_add a where {
};

class (Linordered_cancel_ab_semigroup_add a, Ordered_comm_monoid_add a,
        Ordered_cancel_semiring a) => Linordered_semiring a where {
};

class (Linordered_semiring a) => Linordered_semiring_strict a where {
};

class (Linordered_semiring_strict a,
        Ordered_cancel_comm_semiring a) => Linordered_comm_semiring_strict a where {
};

class (Semiring_1 a) => Semiring_char_0 a where {
};

class (Semiring_char_0 a, Linordered_comm_semiring_strict a,
        Semidom a) => Linordered_semidom a where {
};

class (Semiring_div_parity a,
        Linordered_semidom a) => Semiring_numeral_div a where {
};

divmod_step :: forall a. (Semiring_numeral_div a) => Num -> (a, a) -> (a, a);
divmod_step l (q, r) =
  (if less_eq (numeral l) r
    then (plus (times (numeral (Bit0 One)) q) onea, minus r (numeral l))
    else (times (numeral (Bit0 One)) q, r));

less_num :: Num -> Num -> Bool;
less_num (Bit1 m) (Bit0 n) = less_num m n;
less_num (Bit1 m) (Bit1 n) = less_num m n;
less_num (Bit0 m) (Bit1 n) = less_eq_num m n;
less_num (Bit0 m) (Bit0 n) = less_num m n;
less_num One (Bit1 n) = True;
less_num One (Bit0 n) = True;
less_num m One = False;

less_eq_num :: Num -> Num -> Bool;
less_eq_num (Bit1 m) (Bit0 n) = less_num m n;
less_eq_num (Bit1 m) (Bit1 n) = less_eq_num m n;
less_eq_num (Bit0 m) (Bit1 n) = less_eq_num m n;
less_eq_num (Bit0 m) (Bit0 n) = less_eq_num m n;
less_eq_num (Bit1 m) One = False;
less_eq_num (Bit0 m) One = False;
less_eq_num One n = True;

divmod :: forall a. (Semiring_numeral_div a) => Num -> Num -> (a, a);
divmod (Bit1 m) (Bit0 n) =
  let {
    (q, r) = divmod m n;
  } in (q, plus (times (numeral (Bit0 One)) r) onea);
divmod (Bit0 m) (Bit0 n) =
  let {
    (q, r) = divmod m n;
  } in (q, times (numeral (Bit0 One)) r);
divmod m n =
  (if less_num m n then (zeroa, numeral m)
    else divmod_step n (divmod m (Bit0 n)));

times_nat :: Nat -> Nat -> Nat;
times_nat Zero_nat n = Zero_nat;
times_nat m Zero_nat = Zero_nat;
times_nat (Nat_of_num k) (Nat_of_num l) = Nat_of_num (times_num k l);

less_eq_nat :: Nat -> Nat -> Bool;
less_eq_nat (Nat_of_num k) (Nat_of_num l) = less_eq_num k l;
less_eq_nat (Nat_of_num k) Zero_nat = False;
less_eq_nat Zero_nat n = True;

plus_nat :: Nat -> Nat -> Nat;
plus_nat Zero_nat n = n;
plus_nat m Zero_nat = m;
plus_nat (Nat_of_num k) (Nat_of_num l) = Nat_of_num (plus_num k l);

map_option :: forall a b. (a -> b) -> Maybe a -> Maybe b;
map_option f Nothing = Nothing;
map_option f (Just x2) = Just (f x2);

dupa :: Nat -> Nat;
dupa (Nat_of_num k) = Nat_of_num (Bit0 k);
dupa Zero_nat = Zero_nat;

bitM :: Num -> Num;
bitM One = One;
bitM (Bit0 n) = Bit1 (bitM n);
bitM (Bit1 n) = Bit1 (Bit0 n);

minus_nat :: Nat -> Nat -> Nat;
minus_nat Zero_nat n = Zero_nat;
minus_nat m Zero_nat = m;
minus_nat (Nat_of_num k) (Nat_of_num l) =
  (case suba k l of {
    Nothing -> Zero_nat;
    Just j -> j;
  });

suba :: Num -> Num -> Maybe Nat;
suba (Bit0 m) (Bit1 n) =
  (case suba m n of {
    Nothing -> Nothing;
    Just q ->
      (if equal_nat q Zero_nat then Nothing
        else Just (minus_nat (dupa q) (Nat_of_num One)));
  });
suba (Bit1 m) (Bit0 n) =
  map_option (\ q -> plus_nat (dupa q) (Nat_of_num One)) (suba m n);
suba (Bit1 m) (Bit1 n) = map_option dupa (suba m n);
suba (Bit0 m) (Bit0 n) = map_option dupa (suba m n);
suba One (Bit1 n) = Nothing;
suba One (Bit0 n) = Nothing;
suba (Bit1 m) One = Just (Nat_of_num (Bit0 m));
suba (Bit0 m) One = Just (Nat_of_num (bitM m));
suba One One = Just Zero_nat;

less_nat :: Nat -> Nat -> Bool;
less_nat (Nat_of_num k) (Nat_of_num l) = less_num k l;
less_nat Zero_nat (Nat_of_num l) = True;
less_nat m Zero_nat = False;

one_nat :: Nat;
one_nat = Nat_of_num One;

instance Plus Nat where {
  plus = plus_nat;
};

instance Semigroup_add Nat where {
};

instance Cancel_semigroup_add Nat where {
};

instance Ab_semigroup_add Nat where {
};

instance Minus Nat where {
  minus = minus_nat;
};

instance Cancel_ab_semigroup_add Nat where {
};

instance Zero Nat where {
  zeroa = Zero_nat;
};

instance Monoid_add Nat where {
};

instance Comm_monoid_add Nat where {
};

instance Cancel_comm_monoid_add Nat where {
};

instance Times Nat where {
  times = times_nat;
};

instance Mult_zero Nat where {
};

instance Semigroup_mult Nat where {
};

instance Semiring Nat where {
};

instance Semiring_0 Nat where {
};

instance Semiring_0_cancel Nat where {
};

instance Ab_semigroup_mult Nat where {
};

instance Comm_semiring Nat where {
};

instance Comm_semiring_0 Nat where {
};

instance Comm_semiring_0_cancel Nat where {
};

instance One Nat where {
  onea = one_nat;
};

instance Power Nat where {
};

instance Monoid_mult Nat where {
};

instance Numeral Nat where {
};

instance Semiring_numeral Nat where {
};

instance Zero_neq_one Nat where {
};

instance Semiring_1 Nat where {
};

instance Semiring_1_cancel Nat where {
};

instance Dvd Nat where {
};

instance Comm_monoid_mult Nat where {
};

instance Comm_semiring_1 Nat where {
};

instance Comm_semiring_1_cancel Nat where {
};

instance Comm_semiring_1_diff_distrib Nat where {
};

instance Semiring_parity Nat where {
};

instance Semiring_no_zero_divisors Nat where {
};

instance Semidom Nat where {
};

instance Ord Nat where {
  less_eq = less_eq_nat;
  less = less_nat;
};

instance Preorder Nat where {
};

instance Order Nat where {
};

instance Ordered_ab_semigroup_add Nat where {
};

instance Ordered_semiring Nat where {
};

instance Ordered_cancel_semiring Nat where {
};

instance Ordered_comm_semiring Nat where {
};

instance Ordered_cancel_comm_semiring Nat where {
};

instance Ordered_cancel_ab_semigroup_add Nat where {
};

instance Ordered_ab_semigroup_add_imp_le Nat where {
};

instance Linorder Nat where {
};

instance Linordered_ab_semigroup_add Nat where {
};

instance Linordered_cancel_ab_semigroup_add Nat where {
};

instance Ordered_comm_monoid_add Nat where {
};

instance Linordered_semiring Nat where {
};

instance Linordered_semiring_strict Nat where {
};

instance Linordered_comm_semiring_strict Nat where {
};

instance Semiring_char_0 Nat where {
};

instance Linordered_semidom Nat where {
};

mod_nat :: Nat -> Nat -> Nat;
mod_nat m n = snd (divmod_nat m n);

instance Semiring_numeral_div Nat where {
};

divmod_nat :: Nat -> Nat -> (Nat, Nat);
divmod_nat Zero_nat n = (Zero_nat, Zero_nat);
divmod_nat m Zero_nat = (Zero_nat, m);
divmod_nat (Nat_of_num k) (Nat_of_num l) = divmod k l;

div_nat :: Nat -> Nat -> Nat;
div_nat m n = fst (divmod_nat m n);

instance Div Nat where {
  div = div_nat;
  mod = mod_nat;
};

instance Semiring_div Nat where {
};

instance Semiring_div_parity Nat where {
};

shows_string :: [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
shows_string = (\ a b -> a ++ b);

showsp_nat :: Nat -> Nat -> [Prelude.Char] -> [Prelude.Char];
showsp_nat p n =
  (if less_nat n (Nat_of_num (Bit0 (Bit1 (Bit0 One))))
    then shows_string (string_of_digit n)
    else showsp_nat p (div_nat n (Nat_of_num (Bit0 (Bit1 (Bit0 One))))) .
           shows_string
             (string_of_digit
               (mod_nat n (Nat_of_num (Bit0 (Bit1 (Bit0 One)))))));

less_int :: Int -> Int -> Bool;
less_int (Neg k) (Neg l) = less_num l k;
less_int (Neg k) (Pos l) = True;
less_int (Neg k) Zero_int = True;
less_int (Pos k) (Neg l) = False;
less_int (Pos k) (Pos l) = less_num k l;
less_int (Pos k) Zero_int = False;
less_int Zero_int (Neg l) = False;
less_int Zero_int (Pos l) = True;
less_int Zero_int Zero_int = False;

nat :: Int -> Nat;
nat (Pos k) = Nat_of_num k;
nat Zero_int = Zero_nat;
nat (Neg k) = Zero_nat;

showsp_int :: Nat -> Int -> [Prelude.Char] -> [Prelude.Char];
showsp_int p i =
  (if less_int i Zero_int
    then shows_string "-" . showsp_nat p (nat (uminus_int i))
    else showsp_nat p (nat i));

shows_prec_int :: Nat -> Int -> [Prelude.Char] -> [Prelude.Char];
shows_prec_int = showsp_int;

shows_sep ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ([Prelude.Char] -> [Prelude.Char]) ->
        [a] -> [Prelude.Char] -> [Prelude.Char];
shows_sep s sep [] = shows_string [];
shows_sep s sep [x] = s x;
shows_sep s sep (x : v : va) = (s x . sep) . shows_sep s sep (v : va);

shows_list_gen ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      [Prelude.Char] ->
        [Prelude.Char] ->
          [Prelude.Char] ->
            [Prelude.Char] -> [a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_gen showsx e l s r xs =
  (if null xs then shows_string e
    else (shows_string l . shows_sep showsx (shows_string s) xs) .
           shows_string r);

showsp_list ::
  forall a.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      Nat -> [a] -> [Prelude.Char] -> [Prelude.Char];
showsp_list s p xs = shows_list_gen (s Zero_nat) "[]" "[" ", " "]" xs;

shows_list_int :: [Int] -> [Prelude.Char] -> [Prelude.Char];
shows_list_int = showsp_list shows_prec_int Zero_nat;

class Showa a where {
  shows_prec :: Nat -> a -> [Prelude.Char] -> [Prelude.Char];
  shows_list :: [a] -> [Prelude.Char] -> [Prelude.Char];
};

instance Showa Int where {
  shows_prec = shows_prec_int;
  shows_list = shows_list_int;
};

one_int :: Int;
one_int = Pos One;

instance One Int where {
  onea = one_int;
};

dup :: Int -> Int;
dup (Neg n) = Neg (Bit0 n);
dup (Pos n) = Pos (Bit0 n);
dup Zero_int = Zero_int;

minus_int :: Int -> Int -> Int;
minus_int (Neg m) (Neg n) = sub n m;
minus_int (Neg m) (Pos n) = Neg (plus_num m n);
minus_int (Pos m) (Neg n) = Pos (plus_num m n);
minus_int (Pos m) (Pos n) = sub m n;
minus_int Zero_int l = uminus_int l;
minus_int k Zero_int = k;

sub :: Num -> Num -> Int;
sub (Bit0 m) (Bit1 n) = minus_int (dup (sub m n)) (Pos One);
sub (Bit1 m) (Bit0 n) = plus_int (dup (sub m n)) (Pos One);
sub (Bit1 m) (Bit1 n) = dup (sub m n);
sub (Bit0 m) (Bit0 n) = dup (sub m n);
sub One (Bit1 n) = Neg (Bit0 n);
sub One (Bit0 n) = Neg (bitM n);
sub (Bit1 m) One = Pos (Bit0 m);
sub (Bit0 m) One = Pos (bitM m);
sub One One = Zero_int;

plus_int :: Int -> Int -> Int;
plus_int (Neg m) (Neg n) = Neg (plus_num m n);
plus_int (Neg m) (Pos n) = sub n m;
plus_int (Pos m) (Neg n) = sub m n;
plus_int (Pos m) (Pos n) = Pos (plus_num m n);
plus_int Zero_int l = l;
plus_int k Zero_int = k;

sgn_int :: Int -> Int;
sgn_int i =
  (if equal_int i Zero_int then Zero_int
    else (if less_int Zero_int i then Pos One else Neg One));

abs_int :: Int -> Int;
abs_int i = (if less_int i Zero_int then uminus_int i else i);

apsnd :: forall a b c. (a -> b) -> (c, a) -> (c, b);
apsnd f (x, y) = (x, f y);

less_eq_int :: Int -> Int -> Bool;
less_eq_int (Neg k) (Neg l) = less_eq_num l k;
less_eq_int (Neg k) (Pos l) = True;
less_eq_int (Neg k) Zero_int = True;
less_eq_int (Pos k) (Neg l) = False;
less_eq_int (Pos k) (Pos l) = less_eq_num k l;
less_eq_int (Pos k) Zero_int = False;
less_eq_int Zero_int (Neg l) = False;
less_eq_int Zero_int (Pos l) = True;
less_eq_int Zero_int Zero_int = True;

instance Plus Int where {
  plus = plus_int;
};

instance Semigroup_add Int where {
};

instance Cancel_semigroup_add Int where {
};

instance Ab_semigroup_add Int where {
};

instance Minus Int where {
  minus = minus_int;
};

instance Cancel_ab_semigroup_add Int where {
};

instance Zero Int where {
  zeroa = Zero_int;
};

instance Monoid_add Int where {
};

instance Comm_monoid_add Int where {
};

instance Cancel_comm_monoid_add Int where {
};

instance Mult_zero Int where {
};

instance Semigroup_mult Int where {
};

instance Semiring Int where {
};

instance Semiring_0 Int where {
};

instance Semiring_0_cancel Int where {
};

instance Ab_semigroup_mult Int where {
};

instance Comm_semiring Int where {
};

instance Comm_semiring_0 Int where {
};

instance Comm_semiring_0_cancel Int where {
};

instance Power Int where {
};

instance Monoid_mult Int where {
};

instance Numeral Int where {
};

instance Semiring_numeral Int where {
};

instance Zero_neq_one Int where {
};

instance Semiring_1 Int where {
};

instance Semiring_1_cancel Int where {
};

instance Comm_monoid_mult Int where {
};

instance Comm_semiring_1 Int where {
};

instance Comm_semiring_1_cancel Int where {
};

instance Comm_semiring_1_diff_distrib Int where {
};

instance Semiring_parity Int where {
};

instance Semiring_no_zero_divisors Int where {
};

instance Semidom Int where {
};

instance Ord Int where {
  less_eq = less_eq_int;
  less = less_int;
};

instance Preorder Int where {
};

instance Order Int where {
};

instance Ordered_ab_semigroup_add Int where {
};

instance Ordered_semiring Int where {
};

instance Ordered_cancel_semiring Int where {
};

instance Ordered_comm_semiring Int where {
};

instance Ordered_cancel_comm_semiring Int where {
};

instance Ordered_cancel_ab_semigroup_add Int where {
};

instance Ordered_ab_semigroup_add_imp_le Int where {
};

instance Linorder Int where {
};

instance Linordered_ab_semigroup_add Int where {
};

instance Linordered_cancel_ab_semigroup_add Int where {
};

instance Ordered_comm_monoid_add Int where {
};

instance Linordered_semiring Int where {
};

instance Linordered_semiring_strict Int where {
};

instance Linordered_comm_semiring_strict Int where {
};

instance Semiring_char_0 Int where {
};

instance Linordered_semidom Int where {
};

instance Div Int where {
  div = div_int;
  mod = mod_int;
};

instance Semiring_div Int where {
};

instance Semiring_div_parity Int where {
};

instance Semiring_numeral_div Int where {
};

divmod_abs :: Int -> Int -> (Int, Int);
divmod_abs Zero_int j = (Zero_int, Zero_int);
divmod_abs j Zero_int = (Zero_int, abs_int j);
divmod_abs (Pos k) (Neg l) = divmod k l;
divmod_abs (Neg k) (Pos l) = divmod k l;
divmod_abs (Neg k) (Neg l) = divmod k l;
divmod_abs (Pos k) (Pos l) = divmod k l;

divmod_int :: Int -> Int -> (Int, Int);
divmod_int k l =
  (if equal_int k Zero_int then (Zero_int, Zero_int)
    else (if equal_int l Zero_int then (Zero_int, k)
           else apsnd (times_int (sgn_int l))
                  (if equal_int (sgn_int k) (sgn_int l) then divmod_abs k l
                    else let {
                           (r, s) = divmod_abs k l;
                         } in (if equal_int s Zero_int
                                then (uminus_int r, Zero_int)
                                else (minus_int (uminus_int r) (Pos One),
                                       minus_int (abs_int l) s)))));

div_int :: Int -> Int -> Int;
div_int a b = fst (divmod_int a b);

mod_int :: Int -> Int -> Int;
mod_int a b = snd (divmod_int a b);

ceq_int :: Maybe (Int -> Int -> Bool);
ceq_int = Just equal_int;

class Ceq a where {
  ceq :: Maybe (a -> a -> Bool);
};

instance Ceq Int where {
  ceq = ceq_int;
};

newtype Phantom a b = Phantom b;

data Set_impla = Set_Choose | Set_Collect | Set_DList | Set_RBT | Set_Monada;

set_impl_int :: Phantom Int Set_impla;
set_impl_int = Phantom Set_RBT;

class Set_impl a where {
  set_impl :: Phantom a Set_impla;
};

instance Set_impl Int where {
  set_impl = set_impl_int;
};

cEnum_int :: Maybe ([Int], ((Int -> Bool) -> Bool, (Int -> Bool) -> Bool));
cEnum_int = Nothing;

class Cenum a where {
  cEnum :: Maybe ([a], ((a -> Bool) -> Bool, (a -> Bool) -> Bool));
};

instance Cenum Int where {
  cEnum = cEnum_int;
};

class (Ord a) => Non_strict_order a where {
};

class (Ab_semigroup_add a, Monoid_add a,
        Non_strict_order a) => Ordered_ab_semigroup a where {
};

class (Semiring_0 a, Ordered_ab_semigroup a) => Ordered_semiring_0 a where {
};

class (Semiring_1 a, Ordered_semiring_0 a) => Ordered_semiring_1 a where {
};

class (Comm_semiring_1 a, Ordered_semiring_1 a) => Poly_carrier a where {
};

instance Non_strict_order Int where {
};

instance Ordered_ab_semigroup Int where {
};

instance Ordered_semiring_0 Int where {
};

instance Ordered_semiring_1 Int where {
};

instance Poly_carrier Int where {
};

data Ordera = Eqa | Lt | Gt;

comparator_of :: forall a. (Eq a, Linorder a) => a -> a -> Ordera;
comparator_of x y = (if less x y then Lt else (if x == y then Eqa else Gt));

compare_int :: Int -> Int -> Ordera;
compare_int = comparator_of;

ccompare_int :: Maybe (Int -> Int -> Ordera);
ccompare_int = Just compare_int;

class Ccompare a where {
  ccompare :: Maybe (a -> a -> Ordera);
};

instance Ccompare Int where {
  ccompare = ccompare_int;
};

instance Eq Nat where {
  a == b = equal_nat a b;
};

shows_prec_nat :: Nat -> Nat -> [Prelude.Char] -> [Prelude.Char];
shows_prec_nat = showsp_nat;

shows_list_nat :: [Nat] -> [Prelude.Char] -> [Prelude.Char];
shows_list_nat = showsp_list shows_prec_nat Zero_nat;

instance Showa Nat where {
  shows_prec = shows_prec_nat;
  shows_list = shows_list_nat;
};

compare_nat :: Nat -> Nat -> Ordera;
compare_nat = comparator_of;

class Compare a where {
  compare :: a -> a -> Ordera;
};

class (Compare a, Linorder a) => Compare_order a where {
};

class (Compare_order a) => Key a where {
};

instance Compare Nat where {
  compare = compare_nat;
};

instance Compare_order Nat where {
};

instance Key Nat where {
};

ceq_nat :: Maybe (Nat -> Nat -> Bool);
ceq_nat = Just equal_nat;

instance Ceq Nat where {
  ceq = ceq_nat;
};

set_impl_nat :: Phantom Nat Set_impla;
set_impl_nat = Phantom Set_RBT;

instance Set_impl Nat where {
  set_impl = set_impl_nat;
};

finite_UNIV_nat :: Phantom Nat Bool;
finite_UNIV_nat = Phantom False;

card_UNIV_nat :: Phantom Nat Nat;
card_UNIV_nat = Phantom Zero_nat;

class Finite_UNIV a where {
  finite_UNIV :: Phantom a Bool;
};

class (Finite_UNIV a) => Card_UNIV a where {
  card_UNIVa :: Phantom a Nat;
};

instance Finite_UNIV Nat where {
  finite_UNIV = finite_UNIV_nat;
};

instance Card_UNIV Nat where {
  card_UNIVa = card_UNIV_nat;
};

cEnum_nat :: Maybe ([Nat], ((Nat -> Bool) -> Bool, (Nat -> Bool) -> Bool));
cEnum_nat = Nothing;

instance Cenum Nat where {
  cEnum = cEnum_nat;
};

ccompare_nat :: Maybe (Nat -> Nat -> Ordera);
ccompare_nat = Just compare_nat;

instance Ccompare Nat where {
  ccompare = ccompare_nat;
};

data Mapping_impla = Mapping_Choose | Mapping_Assoc_List | Mapping_RBT
  | Mapping_Mapping;

mapping_impl_nat :: Phantom Nat Mapping_impla;
mapping_impl_nat = Phantom Mapping_RBT;

class Mapping_impl a where {
  mapping_impl :: Phantom a Mapping_impla;
};

instance Mapping_impl Nat where {
  mapping_impl = mapping_impl_nat;
};

proper_interval_nat :: Maybe Nat -> Maybe Nat -> Bool;
proper_interval_nat no Nothing = True;
proper_interval_nat Nothing (Just x) = less_nat Zero_nat x;
proper_interval_nat (Just x) (Just y) =
  less_nat (Nat_of_num One) (minus_nat y x);

cproper_interval_nat :: Maybe Nat -> Maybe Nat -> Bool;
cproper_interval_nat = proper_interval_nat;

class (Ccompare a) => Cproper_interval a where {
  cproper_interval :: Maybe a -> Maybe a -> Bool;
};

instance Cproper_interval Nat where {
  cproper_interval = cproper_interval_nat;
};

newtype Rat = Frct (Int, Int);

quotient_of :: Rat -> (Int, Int);
quotient_of (Frct x) = x;

equal_rat :: Rat -> Rat -> Bool;
equal_rat a b = quotient_of a == quotient_of b;

instance Eq Rat where {
  a == b = equal_rat a b;
};

gcd_int :: Int -> Int -> Int;
gcd_int k l =
  abs_int
    (if equal_int l Zero_int then k
      else gcd_int l (mod_int (abs_int k) (abs_int l)));

normalize :: (Int, Int) -> (Int, Int);
normalize p =
  (if less_int Zero_int (snd p)
    then let {
           a = gcd_int (fst p) (snd p);
         } in (div_int (fst p) a, div_int (snd p) a)
    else (if equal_int (snd p) Zero_int then (Zero_int, Pos One)
           else let {
                  a = uminus_int (gcd_int (fst p) (snd p));
                } in (div_int (fst p) a, div_int (snd p) a)));

times_rat :: Rat -> Rat -> Rat;
times_rat p q =
  Frct (let {
          a = quotient_of p;
          (aa, c) = a;
          b = quotient_of q;
          (ba, d) = b;
        } in normalize (times_int aa ba, times_int c d));

instance Times Rat where {
  times = times_rat;
};

instance Dvd Rat where {
};

showsp_rat :: Nat -> Rat -> [Prelude.Char] -> [Prelude.Char];
showsp_rat p x =
  let {
    (d, n) = quotient_of x;
  } in (if equal_int n (Pos One) then showsp_int p d
         else (showsp_int p d . shows_string "/") . showsp_int p n);

shows_prec_rat :: Nat -> Rat -> [Prelude.Char] -> [Prelude.Char];
shows_prec_rat = showsp_rat;

shows_list_rat :: [Rat] -> [Prelude.Char] -> [Prelude.Char];
shows_list_rat = showsp_list shows_prec_rat Zero_nat;

instance Showa Rat where {
  shows_prec = shows_prec_rat;
  shows_list = shows_list_rat;
};

abs_rat :: Rat -> Rat;
abs_rat p = Frct (let {
                    a = quotient_of p;
                    (aa, b) = a;
                  } in (abs_int aa, b));

class Abs a where {
  absa :: a -> a;
};

instance Abs Rat where {
  absa = abs_rat;
};

one_rat :: Rat;
one_rat = Frct (Pos One, Pos One);

instance One Rat where {
  onea = one_rat;
};

sgn_rat :: Rat -> Rat;
sgn_rat p = Frct (sgn_int (fst (quotient_of p)), Pos One);

class Sgn a where {
  sgn :: a -> a;
};

instance Sgn Rat where {
  sgn = sgn_rat;
};

uminus_rat :: Rat -> Rat;
uminus_rat p =
  Frct (let {
          a = quotient_of p;
          (aa, b) = a;
        } in (uminus_int aa, b));

minus_rat :: Rat -> Rat -> Rat;
minus_rat p q =
  Frct (let {
          a = quotient_of p;
          (aa, c) = a;
          b = quotient_of q;
          (ba, d) = b;
        } in normalize
               (minus_int (times_int aa d) (times_int ba c), times_int c d));

zero_rat :: Rat;
zero_rat = Frct (Zero_int, Pos One);

plus_rat :: Rat -> Rat -> Rat;
plus_rat p q =
  Frct (let {
          a = quotient_of p;
          (aa, c) = a;
          b = quotient_of q;
          (ba, d) = b;
        } in normalize
               (plus_int (times_int aa d) (times_int ba c), times_int c d));

class Uminus a where {
  uminus :: a -> a;
};

class (Comm_semiring_1_cancel a) => Comm_semiring_1_cancel_crossproduct a where {
};

class (Cancel_semigroup_add a, Minus a, Monoid_add a,
        Uminus a) => Group_add a where {
};

class (Cancel_comm_monoid_add a, Group_add a) => Ab_group_add a where {
};

class (Ab_group_add a, Semiring_0_cancel a) => Ring a where {
};

class (Ring a, Semiring_no_zero_divisors a) => Ring_no_zero_divisors a where {
};

class (Group_add a, Numeral a) => Neg_numeral a where {
};

class (Neg_numeral a, Ring a, Semiring_1_cancel a) => Ring_1 a where {
};

class (Ring_1 a, Ring_no_zero_divisors a) => Ring_1_no_zero_divisors a where {
};

class (Comm_semiring_0_cancel a, Ring a) => Comm_ring a where {
};

class (Comm_ring a, Comm_semiring_1_diff_distrib a,
        Ring_1 a) => Comm_ring_1 a where {
};

class (Comm_ring_1 a, Ring_1_no_zero_divisors a, Semidom a,
        Comm_semiring_1_cancel_crossproduct a) => Idom a where {
};

instance Plus Rat where {
  plus = plus_rat;
};

instance Semigroup_add Rat where {
};

instance Cancel_semigroup_add Rat where {
};

instance Ab_semigroup_add Rat where {
};

instance Minus Rat where {
  minus = minus_rat;
};

instance Cancel_ab_semigroup_add Rat where {
};

instance Zero Rat where {
  zeroa = zero_rat;
};

instance Monoid_add Rat where {
};

instance Comm_monoid_add Rat where {
};

instance Cancel_comm_monoid_add Rat where {
};

instance Mult_zero Rat where {
};

instance Semigroup_mult Rat where {
};

instance Semiring Rat where {
};

instance Semiring_0 Rat where {
};

instance Semiring_0_cancel Rat where {
};

instance Ab_semigroup_mult Rat where {
};

instance Comm_semiring Rat where {
};

instance Comm_semiring_0 Rat where {
};

instance Comm_semiring_0_cancel Rat where {
};

instance Power Rat where {
};

instance Monoid_mult Rat where {
};

instance Numeral Rat where {
};

instance Semiring_numeral Rat where {
};

instance Zero_neq_one Rat where {
};

instance Semiring_1 Rat where {
};

instance Semiring_1_cancel Rat where {
};

instance Comm_monoid_mult Rat where {
};

instance Comm_semiring_1 Rat where {
};

instance Comm_semiring_1_cancel Rat where {
};

instance Comm_semiring_1_cancel_crossproduct Rat where {
};

instance Semiring_no_zero_divisors Rat where {
};

instance Uminus Rat where {
  uminus = uminus_rat;
};

instance Group_add Rat where {
};

instance Ab_group_add Rat where {
};

instance Ring Rat where {
};

instance Ring_no_zero_divisors Rat where {
};

instance Neg_numeral Rat where {
};

instance Ring_1 Rat where {
};

instance Ring_1_no_zero_divisors Rat where {
};

instance Comm_semiring_1_diff_distrib Rat where {
};

instance Comm_ring Rat where {
};

instance Comm_ring_1 Rat where {
};

instance Semidom Rat where {
};

instance Idom Rat where {
};

inverse_rat :: Rat -> Rat;
inverse_rat p =
  Frct (let {
          a = quotient_of p;
          (aa, b) = a;
        } in (if equal_int aa Zero_int then (Zero_int, Pos One)
               else (times_int (sgn_int aa) b, abs_int aa)));

divide_rat :: Rat -> Rat -> Rat;
divide_rat p q =
  Frct (let {
          a = quotient_of p;
          (aa, c) = a;
          b = quotient_of q;
          (ba, d) = b;
        } in normalize (times_int aa d, times_int c ba));

class Inverse a where {
  inverse :: a -> a;
  divide :: a -> a -> a;
};

class (Inverse a, Ring_1_no_zero_divisors a) => Division_ring a where {
};

class (Division_ring a, Idom a) => Field a where {
};

instance Inverse Rat where {
  inverse = inverse_rat;
  divide = divide_rat;
};

instance Division_ring Rat where {
};

instance Field Rat where {
};

less_eq_rat :: Rat -> Rat -> Bool;
less_eq_rat p q =
  let {
    a = quotient_of p;
    (aa, c) = a;
    b = quotient_of q;
    (ba, d) = b;
  } in less_eq_int (times_int aa d) (times_int c ba);

less_rat :: Rat -> Rat -> Bool;
less_rat p q =
  let {
    a = quotient_of p;
    (aa, c) = a;
    b = quotient_of q;
    (ba, d) = b;
  } in less_int (times_int aa d) (times_int c ba);

class (Abs a, Minus a, Uminus a, Zero a, Ord a) => Abs_if a where {
};

instance Ord Rat where {
  less_eq = less_eq_rat;
  less = less_rat;
};

instance Abs_if Rat where {
};

class (Minus a, One a, Sgn a, Uminus a, Zero a, Ord a) => Sgn_if a where {
};

instance Sgn_if Rat where {
};

instance Preorder Rat where {
};

instance Order Rat where {
};

instance Linorder Rat where {
};

compare_rat :: Rat -> Rat -> Ordera;
compare_rat = comparator_of;

instance Compare Rat where {
  compare = compare_rat;
};

class (Semiring_char_0 a, Ring_1 a) => Ring_char_0 a where {
};

instance Semiring_char_0 Rat where {
};

instance Ring_char_0 Rat where {
};

class (Field a, Ring_char_0 a) => Field_char_0 a where {
};

instance Field_char_0 Rat where {
};

class (Order a) => No_bot a where {
};

instance No_bot Rat where {
};

class (Order a) => No_top a where {
};

instance No_top Rat where {
};

ceq_rat :: Maybe (Rat -> Rat -> Bool);
ceq_rat = Just equal_rat;

instance Ceq Rat where {
  ceq = ceq_rat;
};

set_impl_rat :: Phantom Rat Set_impla;
set_impl_rat = Phantom Set_RBT;

instance Set_impl Rat where {
  set_impl = set_impl_rat;
};

class (Ab_group_add a, Ordered_ab_semigroup_add_imp_le a,
        Ordered_comm_monoid_add a) => Ordered_ab_group_add a where {
};

class (Ordered_ab_group_add a, Ordered_cancel_semiring a,
        Ring a) => Ordered_ring a where {
};

instance Ordered_ab_semigroup_add Rat where {
};

instance Ordered_semiring Rat where {
};

instance Ordered_cancel_semiring Rat where {
};

instance Ordered_cancel_ab_semigroup_add Rat where {
};

instance Ordered_ab_semigroup_add_imp_le Rat where {
};

instance Ordered_comm_monoid_add Rat where {
};

instance Ordered_ab_group_add Rat where {
};

instance Ordered_ring Rat where {
};

cEnum_rat :: Maybe ([Rat], ((Rat -> Bool) -> Bool, (Rat -> Bool) -> Bool));
cEnum_rat = Nothing;

instance Cenum Rat where {
  cEnum = cEnum_rat;
};

class (Order a) => Dense_order a where {
};

instance Dense_order Rat where {
};

class (Linordered_semiring a, Semiring_1 a) => Linordered_semiring_1 a where {
};

class (Linordered_semiring_1 a,
        Linordered_semiring_strict a) => Linordered_semiring_1_strict a where {
};

class (Abs a, Ordered_ab_group_add a) => Ordered_ab_group_add_abs a where {
};

class (Linordered_cancel_ab_semigroup_add a,
        Ordered_ab_group_add a) => Linordered_ab_group_add a where {
};

class (Abs_if a, Linordered_ab_group_add a, Ordered_ab_group_add_abs a,
        Linordered_semiring a, Ordered_ring a) => Linordered_ring a where {
};

class (Linordered_ring a, Linordered_semiring_strict a,
        Ring_no_zero_divisors a) => Linordered_ring_strict a where {
};

class (Comm_ring a, Ordered_cancel_comm_semiring a,
        Ordered_ring a) => Ordered_comm_ring a where {
};

class (Ordered_ab_group_add_abs a, Ordered_ring a) => Ordered_ring_abs a where {
};

class (Sgn_if a, Ring_char_0 a, Idom a, Linordered_ring_strict a,
        Linordered_semidom a, Linordered_semiring_1_strict a,
        Ordered_comm_ring a, Ordered_ring_abs a) => Linordered_idom a where {
};

instance Linordered_ab_semigroup_add Rat where {
};

instance Linordered_cancel_ab_semigroup_add Rat where {
};

instance Linordered_semiring Rat where {
};

instance Linordered_semiring_strict Rat where {
};

instance Linordered_semiring_1 Rat where {
};

instance Linordered_semiring_1_strict Rat where {
};

instance Ordered_ab_group_add_abs Rat where {
};

instance Linordered_ab_group_add Rat where {
};

instance Linordered_ring Rat where {
};

instance Linordered_ring_strict Rat where {
};

instance Ordered_comm_semiring Rat where {
};

instance Ordered_cancel_comm_semiring Rat where {
};

instance Linordered_comm_semiring_strict Rat where {
};

instance Linordered_semidom Rat where {
};

instance Ordered_comm_ring Rat where {
};

instance Ordered_ring_abs Rat where {
};

instance Linordered_idom Rat where {
};

instance Non_strict_order Rat where {
};

instance Ordered_ab_semigroup Rat where {
};

instance Ordered_semiring_0 Rat where {
};

instance Ordered_semiring_1 Rat where {
};

instance Poly_carrier Rat where {
};

class (Dense_order a, Linorder a) => Dense_linorder a where {
};

class (Dense_linorder a, No_bot a,
        No_top a) => Unbounded_dense_linorder a where {
};

class (Field_char_0 a, Unbounded_dense_linorder a,
        Linordered_idom a) => Linordered_field a where {
};

instance Dense_linorder Rat where {
};

instance Unbounded_dense_linorder Rat where {
};

instance Linordered_field Rat where {
};

ccompare_rat :: Maybe (Rat -> Rat -> Ordera);
ccompare_rat = Just compare_rat;

instance Ccompare Rat where {
  ccompare = ccompare_rat;
};

class (Linordered_field a) => Archimedean_field a where {
};

class (Poly_carrier a) => Large_ordered_semiring_1 a where {
};

class (Archimedean_field a,
        Large_ordered_semiring_1 a) => Floor_ceiling a where {
  floor :: a -> Int;
};

floor_rat :: Rat -> Int;
floor_rat p = let {
                a = quotient_of p;
                (aa, b) = a;
              } in div_int aa b;

instance Archimedean_field Rat where {
};

instance Large_ordered_semiring_1 Rat where {
};

instance Floor_ceiling Rat where {
  floor = floor_rat;
};

list_member :: forall a. (a -> a -> Bool) -> [a] -> a -> Bool;
list_member equal (x : xs) y = equal x y || list_member equal xs y;
list_member equal [] y = False;

data Color = R | B;

data Rbta a b = Emptya | Branch Color (Rbta a b) a b (Rbta a b);

newtype Mapping_rbt b a = Mapping_RBTa (Rbta b a);

newtype Set_dlist a = Abs_dlist [a];

data Set a = Collect_set (a -> Bool) | DList_set (Set_dlist a)
  | RBT_set (Mapping_rbt a ()) | Set_Monad [a] | Complement (Set a);

uminus_set :: forall a. Set a -> Set a;
uminus_set (Complement b) = b;
uminus_set (Collect_set p) = Collect_set (\ x -> not (p x));
uminus_set a = Complement a;

balance :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance (Branch R a w x b) s t (Branch R c y z d) =
  Branch R (Branch B a w x b) s t (Branch B c y z d);
balance (Branch R (Branch R a w x b) s t c) y z Emptya =
  Branch R (Branch B a w x b) s t (Branch B c y z Emptya);
balance (Branch R (Branch R a w x b) s t c) y z (Branch B va vb vc vd) =
  Branch R (Branch B a w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch R Emptya w x (Branch R b s t c)) y z Emptya =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z Emptya);
balance (Branch R (Branch B va vb vc vd) w x (Branch R b s t c)) y z Emptya =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z Emptya);
balance (Branch R Emptya w x (Branch R b s t c)) y z (Branch B va vb vc vd) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch R (Branch B ve vf vg vh) w x (Branch R b s t c)) y z
  (Branch B va vb vc vd) =
  Branch R (Branch B (Branch B ve vf vg vh) w x b) s t
    (Branch B c y z (Branch B va vb vc vd));
balance Emptya w x (Branch R b s t (Branch R c y z d)) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z d);
balance (Branch B va vb vc vd) w x (Branch R b s t (Branch R c y z d)) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z d);
balance Emptya w x (Branch R (Branch R b s t c) y z Emptya) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z Emptya);
balance Emptya w x (Branch R (Branch R b s t c) y z (Branch B va vb vc vd)) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch B va vb vc vd) w x (Branch R (Branch R b s t c) y z Emptya) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z Emptya);
balance (Branch B va vb vc vd) w x
  (Branch R (Branch R b s t c) y z (Branch B ve vf vg vh)) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t
    (Branch B c y z (Branch B ve vf vg vh));
balance Emptya s t Emptya = Branch B Emptya s t Emptya;
balance Emptya s t (Branch B va vb vc vd) =
  Branch B Emptya s t (Branch B va vb vc vd);
balance Emptya s t (Branch v Emptya vb vc Emptya) =
  Branch B Emptya s t (Branch v Emptya vb vc Emptya);
balance Emptya s t (Branch v (Branch B ve vf vg vh) vb vc Emptya) =
  Branch B Emptya s t (Branch v (Branch B ve vf vg vh) vb vc Emptya);
balance Emptya s t (Branch v Emptya vb vc (Branch B vf vg vh vi)) =
  Branch B Emptya s t (Branch v Emptya vb vc (Branch B vf vg vh vi));
balance Emptya s t
  (Branch v (Branch B ve vj vk vl) vb vc (Branch B vf vg vh vi)) =
  Branch B Emptya s t
    (Branch v (Branch B ve vj vk vl) vb vc (Branch B vf vg vh vi));
balance (Branch B va vb vc vd) s t Emptya =
  Branch B (Branch B va vb vc vd) s t Emptya;
balance (Branch B va vb vc vd) s t (Branch B ve vf vg vh) =
  Branch B (Branch B va vb vc vd) s t (Branch B ve vf vg vh);
balance (Branch B va vb vc vd) s t (Branch v Emptya vf vg Emptya) =
  Branch B (Branch B va vb vc vd) s t (Branch v Emptya vf vg Emptya);
balance (Branch B va vb vc vd) s t
  (Branch v (Branch B vi vj vk vl) vf vg Emptya) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v (Branch B vi vj vk vl) vf vg Emptya);
balance (Branch B va vb vc vd) s t
  (Branch v Emptya vf vg (Branch B vj vk vl vm)) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v Emptya vf vg (Branch B vj vk vl vm));
balance (Branch B va vb vc vd) s t
  (Branch v (Branch B vi vn vo vp) vf vg (Branch B vj vk vl vm)) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v (Branch B vi vn vo vp) vf vg (Branch B vj vk vl vm));
balance (Branch v Emptya vb vc Emptya) s t Emptya =
  Branch B (Branch v Emptya vb vc Emptya) s t Emptya;
balance (Branch v Emptya vb vc (Branch B ve vf vg vh)) s t Emptya =
  Branch B (Branch v Emptya vb vc (Branch B ve vf vg vh)) s t Emptya;
balance (Branch v (Branch B vf vg vh vi) vb vc Emptya) s t Emptya =
  Branch B (Branch v (Branch B vf vg vh vi) vb vc Emptya) s t Emptya;
balance (Branch v (Branch B vf vg vh vi) vb vc (Branch B ve vj vk vl)) s t
  Emptya =
  Branch B (Branch v (Branch B vf vg vh vi) vb vc (Branch B ve vj vk vl)) s t
    Emptya;
balance (Branch v Emptya vf vg Emptya) s t (Branch B va vb vc vd) =
  Branch B (Branch v Emptya vf vg Emptya) s t (Branch B va vb vc vd);
balance (Branch v Emptya vf vg (Branch B vi vj vk vl)) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v Emptya vf vg (Branch B vi vj vk vl)) s t
    (Branch B va vb vc vd);
balance (Branch v (Branch B vj vk vl vm) vf vg Emptya) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v (Branch B vj vk vl vm) vf vg Emptya) s t
    (Branch B va vb vc vd);
balance (Branch v (Branch B vj vk vl vm) vf vg (Branch B vi vn vo vp)) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v (Branch B vj vk vl vm) vf vg (Branch B vi vn vo vp)) s t
    (Branch B va vb vc vd);

rbt_comp_ins ::
  forall a b.
    (a -> a -> Ordera) -> (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_ins c f k v Emptya = Branch R Emptya k v Emptya;
rbt_comp_ins c f k v (Branch B l x y r) =
  (case c k x of {
    Eqa -> Branch B l x (f k y v) r;
    Lt -> balance (rbt_comp_ins c f k v l) x y r;
    Gt -> balance l x y (rbt_comp_ins c f k v r);
  });
rbt_comp_ins c f k v (Branch R l x y r) =
  (case c k x of {
    Eqa -> Branch R l x (f k y v) r;
    Lt -> Branch R (rbt_comp_ins c f k v l) x y r;
    Gt -> Branch R l x y (rbt_comp_ins c f k v r);
  });

paint :: forall a b. Color -> Rbta a b -> Rbta a b;
paint c Emptya = Emptya;
paint c (Branch uu l k v r) = Branch c l k v r;

rbt_comp_insert_with_key ::
  forall a b.
    (a -> a -> Ordera) -> (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_insert_with_key c f k v t = paint B (rbt_comp_ins c f k v t);

rbt_comp_insert ::
  forall a b. (a -> a -> Ordera) -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_insert c = rbt_comp_insert_with_key c (\ _ _ nv -> nv);

impl_ofb :: forall b a. (Ccompare b) => Mapping_rbt b a -> Rbta b a;
impl_ofb (Mapping_RBTa x) = x;

the :: forall a. Maybe a -> a;
the (Just x2) = x2;

inserte ::
  forall a b. (Ccompare a) => a -> b -> Mapping_rbt a b -> Mapping_rbt a b;
inserte xc xd xe =
  Mapping_RBTa (rbt_comp_insert (the ccompare) xc xd (impl_ofb xe));

comp_sunion_with ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
comp_sunion_with c f ((ka, va) : asa) ((k, v) : bs) =
  (case c k ka of {
    Eqa -> (ka, f ka va v) : comp_sunion_with c f asa bs;
    Lt -> (k, v) : comp_sunion_with c f ((ka, va) : asa) bs;
    Gt -> (ka, va) : comp_sunion_with c f asa ((k, v) : bs);
  });
comp_sunion_with c f [] bs = bs;
comp_sunion_with c f asa [] = asa;

data Comparea = LT | GT | EQ;

skip_red :: forall a b. Rbta a b -> Rbta a b;
skip_red (Branch R l k v r) = l;
skip_red Emptya = Emptya;
skip_red (Branch B va vb vc vd) = Branch B va vb vc vd;

skip_black :: forall a b. Rbta a b -> Rbta a b;
skip_black t =
  let {
    ta = skip_red t;
  } in (case ta of {
         Emptya -> ta;
         Branch R _ _ _ _ -> ta;
         Branch B l _ _ _ -> l;
       });

compare_height ::
  forall a b. Rbta a b -> Rbta a b -> Rbta a b -> Rbta a b -> Comparea;
compare_height sx s t tx =
  (case (skip_red sx, (skip_red s, (skip_red t, skip_red tx))) of {
    (Emptya, (Emptya, (_, Emptya))) -> EQ;
    (Emptya, (Emptya, (_, Branch _ _ _ _ _))) -> LT;
    (Emptya, (Branch _ _ _ _ _, (Emptya, _))) -> EQ;
    (Emptya, (Branch _ _ _ _ _, (Branch _ _ _ _ _, Emptya))) -> EQ;
    (Emptya, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Branch _ txa _ _ _))) ->
      compare_height Emptya sa ta (skip_black txa);
    (Branch _ _ _ _ _, (Emptya, (Emptya, Emptya))) -> GT;
    (Branch _ _ _ _ _, (Emptya, (Emptya, Branch _ _ _ _ _))) -> LT;
    (Branch _ _ _ _ _, (Emptya, (Branch _ _ _ _ _, Emptya))) -> EQ;
    (Branch _ _ _ _ _, (Emptya, (Branch _ _ _ _ _, Branch _ _ _ _ _))) -> LT;
    (Branch _ _ _ _ _, (Branch _ _ _ _ _, (Emptya, _))) -> GT;
    (Branch _ sxa _ _ _, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Emptya))) ->
      compare_height (skip_black sxa) sa ta Emptya;
    (Branch _ sxa _ _ _,
      (Branch _ sa _ _ _, (Branch _ ta _ _ _, Branch _ txa _ _ _)))
      -> compare_height (skip_black sxa) sa ta (skip_black txa);
  });

gen_length :: forall a. Nat -> [a] -> Nat;
gen_length n (x : xs) = gen_length (plus_nat n (Nat_of_num One)) xs;
gen_length n [] = n;

size_list :: forall a. [a] -> Nat;
size_list = gen_length Zero_nat;

apfst :: forall a b c. (a -> b) -> (a, c) -> (b, c);
apfst f (x, y) = (f x, y);

rbtreeify_g :: forall a b. Nat -> [(a, b)] -> (Rbta a b, [(a, b)]);
rbtreeify_g n kvs =
  (if equal_nat n Zero_nat || equal_nat n (Nat_of_num One) then (Emptya, kvs)
    else let {
           (na, r) = divmod_nat n (Nat_of_num (Bit0 One));
         } in (if equal_nat r Zero_nat
                then let {
                       (t1, (k, v) : kvsa) = rbtreeify_g na kvs;
                     } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)
                else let {
                       (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                     } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)));

rbtreeify_f :: forall a b. Nat -> [(a, b)] -> (Rbta a b, [(a, b)]);
rbtreeify_f n kvs =
  (if equal_nat n Zero_nat then (Emptya, kvs)
    else (if equal_nat n (Nat_of_num One)
           then let {
                  ((k, v) : kvsa) = kvs;
                } in (Branch R Emptya k v Emptya, kvsa)
           else let {
                  (na, r) = divmod_nat n (Nat_of_num (Bit0 One));
                } in (if equal_nat r Zero_nat
                       then let {
                              (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                            } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)
                       else let {
                              (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                            } in apfst (Branch B t1 k v)
                                   (rbtreeify_f na kvsa))));

rbtreeify :: forall a b. [(a, b)] -> Rbta a b;
rbtreeify kvs =
  fst (rbtreeify_g (plus_nat (size_list kvs) (Nat_of_num One)) kvs);

gen_entries :: forall a b. [((a, b), Rbta a b)] -> Rbta a b -> [(a, b)];
gen_entries kvts (Branch c l k v r) = gen_entries (((k, v), r) : kvts) l;
gen_entries ((kv, t) : kvts) Emptya = kv : gen_entries kvts t;
gen_entries [] Emptya = [];

entries :: forall a b. Rbta a b -> [(a, b)];
entries = gen_entries [];

folda :: forall a b c. (a -> b -> c -> c) -> Rbta a b -> c -> c;
folda f (Branch c lt k v rt) x = folda f rt (f k v (folda f lt x));
folda f Emptya x = x;

rbt_comp_union_with_key ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_comp_union_with_key c f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> folda (rbt_comp_insert_with_key c (\ k v w -> f k w v)) t1 t2;
    GT -> folda (rbt_comp_insert_with_key c f) t2 t1;
    EQ -> rbtreeify (comp_sunion_with c f (entries t1) (entries t2));
  });

join ::
  forall a b.
    (Ccompare a) => (a -> b -> b -> b) ->
                      Mapping_rbt a b -> Mapping_rbt a b -> Mapping_rbt a b;
join xc xd xe =
  Mapping_RBTa
    (rbt_comp_union_with_key (the ccompare) xc (impl_ofb xd) (impl_ofb xe));

list_insert :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
list_insert equal x xs = (if list_member equal xs x then xs else x : xs);

list_of_dlist :: forall a. (Ceq a) => Set_dlist a -> [a];
list_of_dlist (Abs_dlist x) = x;

insertc :: forall a. (Ceq a) => a -> Set_dlist a -> Set_dlist a;
insertc xb xc = Abs_dlist (list_insert (the ceq) xb (list_of_dlist xc));

fold :: forall a b. (a -> b -> b) -> [a] -> b -> b;
fold f (x : xs) s = fold f xs (f x s);
fold f [] s = s;

foldc :: forall a b. (Ceq a) => (a -> b -> b) -> Set_dlist a -> b -> b;
foldc x xc = fold x (list_of_dlist xc);

union :: forall a. (Ceq a) => Set_dlist a -> Set_dlist a -> Set_dlist a;
union = foldc insertc;

memberc :: forall a. (Ceq a) => Set_dlist a -> a -> Bool;
memberc xa = list_member (the ceq) (list_of_dlist xa);

rbt_comp_lookup :: forall a b. (a -> a -> Ordera) -> Rbta a b -> a -> Maybe b;
rbt_comp_lookup c Emptya k = Nothing;
rbt_comp_lookup c (Branch uu l x y r) k =
  (case c k x of {
    Eqa -> Just y;
    Lt -> rbt_comp_lookup c l k;
    Gt -> rbt_comp_lookup c r k;
  });

lookupd :: forall a b. (Ccompare a) => Mapping_rbt a b -> a -> Maybe b;
lookupd xa = rbt_comp_lookup (the ccompare) (impl_ofb xa);

memberb :: forall a. (Ccompare a) => Mapping_rbt a () -> a -> Bool;
memberb t x = lookupd t x == Just ();

member :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Bool;
member x (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "member Set_Monad: ceq = None" (\ _ -> member x (Set_Monad xs));
    Just eq -> list_member eq xs x;
  });
member xa (Complement x) = not (member xa x);
member x (RBT_set rbt) = memberb rbt x;
member x (DList_set dxs) = memberc dxs x;
member x (Collect_set a) = a x;

is_none :: forall a. Maybe a -> Bool;
is_none (Just x) = False;
is_none Nothing = True;

inter_list ::
  forall a. (Ccompare a) => Mapping_rbt a () -> [a] -> Mapping_rbt a ();
inter_list xb xc =
  Mapping_RBTa
    (fold (\ k -> rbt_comp_insert (the ccompare) k ())
      (filter
        (\ x -> not (is_none (rbt_comp_lookup (the ccompare) (impl_ofb xb) x)))
        xc)
      Emptya);

filterc ::
  forall a b.
    (Ccompare a) => ((a, b) -> Bool) -> Mapping_rbt a b -> Mapping_rbt a b;
filterc xb xc = Mapping_RBTa (rbtreeify (filter xb (entries (impl_ofb xc))));

comp_sinter_with ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
comp_sinter_with c f ((ka, va) : asa) ((k, v) : bs) =
  (case c k ka of {
    Eqa -> (ka, f ka va v) : comp_sinter_with c f asa bs;
    Lt -> comp_sinter_with c f ((ka, va) : asa) bs;
    Gt -> comp_sinter_with c f asa ((k, v) : bs);
  });
comp_sinter_with c f [] uu = [];
comp_sinter_with c f uv [] = [];

map_filter :: forall a b. (a -> Maybe b) -> [a] -> [b];
map_filter f [] = [];
map_filter f (x : xs) =
  (case f x of {
    Nothing -> map_filter f xs;
    Just y -> y : map_filter f xs;
  });

rbt_comp_inter_with_key ::
  forall a b.
    (a -> a -> Ordera) ->
      (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_comp_inter_with_key c f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> rbtreeify
            (map_filter
              (\ (k, v) ->
                map_option (\ w -> (k, f k v w)) (rbt_comp_lookup c t2 k))
              (entries t1));
    GT -> rbtreeify
            (map_filter
              (\ (k, v) ->
                map_option (\ w -> (k, f k w v)) (rbt_comp_lookup c t1 k))
              (entries t2));
    EQ -> rbtreeify (comp_sinter_with c f (entries t1) (entries t2));
  });

meet ::
  forall a b.
    (Ccompare a) => (a -> b -> b -> b) ->
                      Mapping_rbt a b -> Mapping_rbt a b -> Mapping_rbt a b;
meet xc xd xe =
  Mapping_RBTa
    (rbt_comp_inter_with_key (the ccompare) xc (impl_ofb xd) (impl_ofb xe));

filterb :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Set_dlist a;
filterb xb xc = Abs_dlist (filter xb (list_of_dlist xc));

inf_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
inf_set (RBT_set rbt1) (Set_Monad xs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set Set_Monad: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (Set_Monad xs));
    Just _ -> RBT_set (inter_list rbt1 xs);
  });
inf_set (RBT_set rbt) (DList_set dxs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set DList_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "inter RBT_set DList_set: ceq = None"
            (\ _ -> inf_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (inter_list rbt (list_of_dlist dxs));
      });
  });
inf_set (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set RBT_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (RBT_set rbt2));
    Just _ -> RBT_set (meet (\ _ _ -> id) rbt1 rbt2);
  });
inf_set (DList_set dxs1) (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set Set_Monad: ceq = None"
        (\ _ -> inf_set (DList_set dxs1) (Set_Monad xs));
    Just eq -> DList_set (filterb (list_member eq xs) dxs1);
  });
inf_set (DList_set dxs1) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set DList_set: ceq = None"
        (\ _ -> inf_set (DList_set dxs1) (DList_set dxs2));
    Just _ -> DList_set (filterb (memberc dxs2) dxs1);
  });
inf_set (DList_set dxs) (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set RBT_set: ccompare = None"
        (\ _ -> inf_set (DList_set dxs) (RBT_set rbt));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "inter DList_set RBT_set: ceq = None"
            (\ _ -> inf_set (DList_set dxs) (RBT_set rbt));
        Just _ -> RBT_set (inter_list rbt (list_of_dlist dxs));
      });
  });
inf_set (Set_Monad xs1) (Set_Monad xs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad Set_Monad: ceq = None"
        (\ _ -> inf_set (Set_Monad xs1) (Set_Monad xs2));
    Just eq -> Set_Monad (filter (list_member eq xs2) xs1);
  });
inf_set (Set_Monad xs) (DList_set dxs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad DList_set: ceq = None"
        (\ _ -> inf_set (Set_Monad xs) (DList_set dxs2));
    Just eq -> DList_set (filterb (list_member eq xs) dxs2);
  });
inf_set (Set_Monad xs) (RBT_set rbt1) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter Set_Monad RBT_set: ccompare = None"
        (\ _ -> inf_set (RBT_set rbt1) (Set_Monad xs));
    Just _ -> RBT_set (inter_list rbt1 xs);
  });
inf_set (Complement ba) (Complement b) = Complement (sup_set ba b);
inf_set g (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set2: ccompare = None" (\ _ -> inf_set g (RBT_set rbt2));
    Just _ -> RBT_set (filterc ((\ x -> member x g) . fst) rbt2);
  });
inf_set (RBT_set rbt1) g =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter RBT_set1: ccompare = None" (\ _ -> inf_set (RBT_set rbt1) g);
    Just _ -> RBT_set (filterc ((\ x -> member x g) . fst) rbt1);
  });
inf_set h (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set2: ceq = None" (\ _ -> inf_set h (DList_set dxs2));
    Just _ -> DList_set (filterb (\ x -> member x h) dxs2);
  });
inf_set (DList_set dxs1) h =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "inter DList_set1: ceq = None" (\ _ -> inf_set (DList_set dxs1) h);
    Just _ -> DList_set (filterb (\ x -> member x h) dxs1);
  });
inf_set i (Set_Monad xs) = Set_Monad (filter (\ x -> member x i) xs);
inf_set (Set_Monad xs) i = Set_Monad (filter (\ x -> member x i) xs);
inf_set j (Collect_set a) = Collect_set (\ x -> a x && member x j);
inf_set (Collect_set a) j = Collect_set (\ x -> a x && member x j);

sup_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
sup_set ba (Complement b) = Complement (inf_set (uminus_set ba) b);
sup_set (Complement ba) b = Complement (inf_set ba (uminus_set b));
sup_set b (Collect_set a) = Collect_set (\ x -> a x || member x b);
sup_set (Collect_set a) b = Collect_set (\ x -> a x || member x b);
sup_set (Set_Monad xs) (Set_Monad ys) = Set_Monad (xs ++ ys);
sup_set (DList_set dxs1) (Set_Monad ws) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set Set_Monad: ceq = None"
        (\ _ -> sup_set (DList_set dxs1) (Set_Monad ws));
    Just _ -> DList_set (fold insertc ws dxs1);
  });
sup_set (Set_Monad ws) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union Set_Monad DList_set: ceq = None"
        (\ _ -> sup_set (Set_Monad ws) (DList_set dxs2));
    Just _ -> DList_set (fold insertc ws dxs2);
  });
sup_set (RBT_set rbt1) (Set_Monad zs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set Set_Monad: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt1) (Set_Monad zs));
    Just _ -> RBT_set (fold (\ k -> inserte k ()) zs rbt1);
  });
sup_set (Set_Monad zs) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union Set_Monad RBT_set: ccompare = None"
        (\ _ -> sup_set (Set_Monad zs) (RBT_set rbt2));
    Just _ -> RBT_set (fold (\ k -> inserte k ()) zs rbt2);
  });
sup_set (DList_set dxs1) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set DList_set: ceq = None"
        (\ _ -> sup_set (DList_set dxs1) (DList_set dxs2));
    Just _ -> DList_set (union dxs1 dxs2);
  });
sup_set (DList_set dxs) (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union DList_set RBT_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "union DList_set RBT_set: ceq = None"
            (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (foldc (\ k -> inserte k ()) dxs rbt);
      });
  });
sup_set (RBT_set rbt) (DList_set dxs) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set DList_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "union RBT_set DList_set: ceq = None"
            (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (foldc (\ k -> inserte k ()) dxs rbt);
      });
  });
sup_set (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "union RBT_set RBT_set: ccompare = None"
        (\ _ -> sup_set (RBT_set rbt1) (RBT_set rbt2));
    Just _ -> RBT_set (join (\ _ _ -> id) rbt1 rbt2);
  });

class Inf a where {
  inf :: a -> a -> a;
};

instance (Ceq a, Ccompare a) => Inf (Set a) where {
  inf = inf_set;
};

class Sup a where {
  sup :: a -> a -> a;
};

instance (Ceq a, Ccompare a) => Sup (Set a) where {
  sup = sup_set;
};

equal_order :: Ordera -> Ordera -> Bool;
equal_order Lt Gt = False;
equal_order Gt Lt = False;
equal_order Eqa Gt = False;
equal_order Gt Eqa = False;
equal_order Eqa Lt = False;
equal_order Lt Eqa = False;
equal_order Gt Gt = True;
equal_order Lt Lt = True;
equal_order Eqa Eqa = True;

newtype Generator a b = Generator (b -> Bool, b -> (a, b));

generator :: forall a b. Generator a b -> (b -> Bool, b -> (a, b));
generator (Generator x) = x;

has_next :: forall a b. Generator a b -> b -> Bool;
has_next g = fst (generator g);

next :: forall a b. Generator a b -> b -> (a, b);
next g = snd (generator g);

sorted_list_subset_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
sorted_list_subset_fusion less eq g1 g2 s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in has_next g2 s2 &&
                let {
                  (y, s2a) = next g2 s2;
                } in (if eq x y
                       then sorted_list_subset_fusion less eq g1 g2 s1a s2a
                       else less y x &&
                              sorted_list_subset_fusion less eq g1 g2 s1 s2a)
    else True);

list_all_fusion :: forall a b. Generator a b -> (a -> Bool) -> b -> Bool;
list_all_fusion g p s =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in p x && list_all_fusion g p sa
    else True);

rbt_keys_next ::
  forall a b. ([(a, Rbta a b)], Rbta a b) -> (a, ([(a, Rbta a b)], Rbta a b));
rbt_keys_next ((k, t) : kts, Emptya) = (k, (kts, t));
rbt_keys_next (kts, Branch c l k v r) = rbt_keys_next ((k, r) : kts, l);

rbt_has_next :: forall a b c. ([(a, Rbta b c)], Rbta b c) -> Bool;
rbt_has_next ([], Emptya) = False;
rbt_has_next (vb : vc, va) = True;
rbt_has_next (v, Branch vb vc vd ve vf) = True;

rbt_keys_generator :: forall a b. Generator a ([(a, Rbta a b)], Rbta a b);
rbt_keys_generator = Generator (rbt_has_next, rbt_keys_next);

lt_of_comp :: forall a. (a -> a -> Ordera) -> a -> a -> Bool;
lt_of_comp acomp x y =
  (case acomp x y of {
    Eqa -> False;
    Lt -> True;
    Gt -> False;
  });

dlist_all :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Bool;
dlist_all x xc = all x (list_of_dlist xc);

rbt_init :: forall a b c. Rbta a b -> ([(c, Rbta a b)], Rbta a b);
rbt_init = (\ a -> ([], a));

init ::
  forall a b c. (Ccompare a) => Mapping_rbt a b -> ([(c, Rbta a b)], Rbta a b);
init xa = rbt_init (impl_ofb xa);

collect :: forall a. (Cenum a) => (a -> Bool) -> Set a;
collect p =
  (case cEnum of {
    Nothing -> Collect_set p;
    Just (enum, _) -> Set_Monad (filter p enum);
  });

subset_eq :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
subset_eq (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset RBT_set RBT_set: ccompare = None"
        (\ _ -> subset_eq (RBT_set rbt1) (RBT_set rbt2));
    Just c ->
      (case ceq of {
        Nothing ->
          sorted_list_subset_fusion (lt_of_comp c)
            (\ x y -> equal_order (c x y) Eqa) rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
        Just eq ->
          sorted_list_subset_fusion (lt_of_comp c) eq rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
      });
  });
subset_eq (Complement a1) (Complement a2) = subset_eq a2 a1;
subset_eq (Collect_set p) (Complement a) =
  subset_eq a (collect (\ x -> not (p x)));
subset_eq (Set_Monad xs) c = all (\ x -> member x c) xs;
subset_eq (DList_set dxs) c =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset DList_set1: ceq = None" (\ _ -> subset_eq (DList_set dxs) c);
    Just _ -> dlist_all (\ x -> member x c) dxs;
  });
subset_eq (RBT_set rbt) b =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "subset RBT_set1: ccompare = None" (\ _ -> subset_eq (RBT_set rbt) b);
    Just _ -> list_all_fusion rbt_keys_generator (\ x -> member x b) (init rbt);
  });

less_eq_set :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
less_eq_set = subset_eq;

less_set :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
less_set a b = less_eq_set a b && not (less_eq_set b a);

instance (Cenum a, Ceq a, Ccompare a) => Ord (Set a) where {
  less_eq = less_eq_set;
  less = less_set;
};

instance (Cenum a, Ceq a, Ccompare a) => Preorder (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Order (Set a) where {
};

class (Sup a, Order a) => Semilattice_sup a where {
};

class (Inf a, Order a) => Semilattice_inf a where {
};

class (Semilattice_inf a, Semilattice_sup a) => Lattice a where {
};

instance (Cenum a, Ceq a, Ccompare a) => Semilattice_sup (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Semilattice_inf (Set a) where {
};

instance (Cenum a, Ceq a, Ccompare a) => Lattice (Set a) where {
};

list_all2_fusion ::
  forall a b c d.
    (a -> b -> Bool) -> Generator a c -> Generator b d -> c -> d -> Bool;
list_all2_fusion p g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 &&
           let {
             (x, s1a) = next g1 s1;
             (y, s2a) = next g2 s2;
           } in p x y && list_all2_fusion p g1 g2 s1a s2a
    else not (has_next g2 s2));

set_eq :: forall a. (Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
set_eq (RBT_set rbt1) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_eq RBT_set RBT_set: ccompare = None"
        (\ _ -> set_eq (RBT_set rbt1) (RBT_set rbt2));
    Just c ->
      (case ceq of {
        Nothing ->
          list_all2_fusion (\ x y -> equal_order (c x y) Eqa) rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
        Just eq ->
          list_all2_fusion eq rbt_keys_generator rbt_keys_generator (init rbt1)
            (init rbt2);
      });
  });
set_eq (Complement a) (Complement b) = set_eq a b;
set_eq a b = less_eq_set a b && less_eq_set b a;

ceq_set ::
  forall a. (Cenum a, Ceq a, Ccompare a) => Maybe (Set a -> Set a -> Bool);
ceq_set =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing -> Nothing;
    Just _ -> Just set_eq;
  });

instance (Cenum a, Ceq a, Ccompare a) => Ceq (Set a) where {
  ceq = ceq_set;
};

set_impl_set :: forall a. Phantom (Set a) Set_impla;
set_impl_set = Phantom Set_Choose;

instance Set_impl (Set a) where {
  set_impl = set_impl_set;
};

sublists :: forall a. [a] -> [[a]];
sublists [] = [[]];
sublists (x : xs) = let {
                      xss = sublists xs;
                    } in map (\ a -> x : a) xss ++ xss;

of_phantom :: forall a b. Phantom a b -> b;
of_phantom (Phantom x) = x;

emptye :: forall a b. (Ccompare a) => Mapping_rbt a b;
emptye = Mapping_RBTa Emptya;

emptyc :: forall a. (Ceq a) => Set_dlist a;
emptyc = Abs_dlist [];

set_empty_choose :: forall a. (Ceq a, Ccompare a) => Set a;
set_empty_choose =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing -> Set_Monad [];
        Just _ -> DList_set emptyc;
      });
    Just _ -> RBT_set emptye;
  });

set_empty :: forall a. (Ceq a, Ccompare a) => Set_impla -> Set a;
set_empty Set_Choose = set_empty_choose;
set_empty Set_Monada = Set_Monad [];
set_empty Set_RBT = RBT_set emptye;
set_empty Set_DList = DList_set emptyc;
set_empty Set_Collect = Collect_set (\ _ -> False);

fun_upda :: forall a b. (a -> a -> Bool) -> (a -> b) -> a -> b -> a -> b;
fun_upda equal f aa b a = (if equal aa a then b else f a);

balance_right :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance_right a k x (Branch R b s y c) = Branch R a k x (Branch B b s y c);
balance_right (Branch B a k x b) s y Emptya =
  balance (Branch R a k x b) s y Emptya;
balance_right (Branch B a k x b) s y (Branch B va vb vc vd) =
  balance (Branch R a k x b) s y (Branch B va vb vc vd);
balance_right (Branch R a k x (Branch B b s y c)) t z Emptya =
  Branch R (balance (paint R a) k x b) s y (Branch B c t z Emptya);
balance_right (Branch R a k x (Branch B b s y c)) t z (Branch B va vb vc vd) =
  Branch R (balance (paint R a) k x b) s y
    (Branch B c t z (Branch B va vb vc vd));
balance_right Emptya k x Emptya = Emptya;
balance_right (Branch R va vb vc Emptya) k x Emptya = Emptya;
balance_right (Branch R va vb vc (Branch R ve vf vg vh)) k x Emptya = Emptya;
balance_right Emptya k x (Branch B va vb vc vd) = Emptya;
balance_right (Branch R ve vf vg Emptya) k x (Branch B va vb vc vd) = Emptya;
balance_right (Branch R ve vf vg (Branch R vi vj vk vl)) k x
  (Branch B va vb vc vd) = Emptya;

balance_left :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance_left (Branch R a k x b) s y c = Branch R (Branch B a k x b) s y c;
balance_left Emptya k x (Branch B a s y b) =
  balance Emptya k x (Branch R a s y b);
balance_left (Branch B va vb vc vd) k x (Branch B a s y b) =
  balance (Branch B va vb vc vd) k x (Branch R a s y b);
balance_left Emptya k x (Branch R (Branch B a s y b) t z c) =
  Branch R (Branch B Emptya k x a) s y (balance b t z (paint R c));
balance_left (Branch B va vb vc vd) k x (Branch R (Branch B a s y b) t z c) =
  Branch R (Branch B (Branch B va vb vc vd) k x a) s y
    (balance b t z (paint R c));
balance_left Emptya k x Emptya = Emptya;
balance_left Emptya k x (Branch R Emptya vb vc vd) = Emptya;
balance_left Emptya k x (Branch R (Branch R ve vf vg vh) vb vc vd) = Emptya;
balance_left (Branch B va vb vc vd) k x Emptya = Emptya;
balance_left (Branch B va vb vc vd) k x (Branch R Emptya vf vg vh) = Emptya;
balance_left (Branch B va vb vc vd) k x
  (Branch R (Branch R vi vj vk vl) vf vg vh) = Emptya;

combine :: forall a b. Rbta a b -> Rbta a b -> Rbta a b;
combine Emptya x = x;
combine (Branch v va vb vc vd) Emptya = Branch v va vb vc vd;
combine (Branch R a k x b) (Branch R c s y d) =
  (case combine b c of {
    Emptya -> Branch R a k x (Branch R Emptya s y d);
    Branch R b2 t z c2 -> Branch R (Branch R a k x b2) t z (Branch R c2 s y d);
    Branch B b2 t z c2 -> Branch R a k x (Branch R (Branch B b2 t z c2) s y d);
  });
combine (Branch B a k x b) (Branch B c s y d) =
  (case combine b c of {
    Emptya -> balance_left a k x (Branch B Emptya s y d);
    Branch R b2 t z c2 -> Branch R (Branch B a k x b2) t z (Branch B c2 s y d);
    Branch B b2 t z c2 ->
      balance_left a k x (Branch B (Branch B b2 t z c2) s y d);
  });
combine (Branch B va vb vc vd) (Branch R b k x c) =
  Branch R (combine (Branch B va vb vc vd) b) k x c;
combine (Branch R a k x b) (Branch B va vb vc vd) =
  Branch R a k x (combine b (Branch B va vb vc vd));

rbt_comp_del :: forall a b. (a -> a -> Ordera) -> a -> Rbta a b -> Rbta a b;
rbt_comp_del c x Emptya = Emptya;
rbt_comp_del c x (Branch uu a y s b) =
  (case c x y of {
    Eqa -> combine a b;
    Lt -> rbt_comp_del_from_left c x a y s b;
    Gt -> rbt_comp_del_from_right c x a y s b;
  });

rbt_comp_del_from_left ::
  forall a b.
    (a -> a -> Ordera) -> a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_del_from_left c x (Branch B lt z v rt) y s b =
  balance_left (rbt_comp_del c x (Branch B lt z v rt)) y s b;
rbt_comp_del_from_left c x Emptya y s b =
  Branch R (rbt_comp_del c x Emptya) y s b;
rbt_comp_del_from_left c x (Branch R va vb vc vd) y s b =
  Branch R (rbt_comp_del c x (Branch R va vb vc vd)) y s b;

rbt_comp_del_from_right ::
  forall a b.
    (a -> a -> Ordera) -> a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_comp_del_from_right c x a y s (Branch B lt z v rt) =
  balance_right a y s (rbt_comp_del c x (Branch B lt z v rt));
rbt_comp_del_from_right c x a y s Emptya =
  Branch R a y s (rbt_comp_del c x Emptya);
rbt_comp_del_from_right c x a y s (Branch R va vb vc vd) =
  Branch R a y s (rbt_comp_del c x (Branch R va vb vc vd));

rbt_comp_delete :: forall a b. (a -> a -> Ordera) -> a -> Rbta a b -> Rbta a b;
rbt_comp_delete c k t = paint B (rbt_comp_del c k t);

deletea :: forall a b. (Ccompare a) => a -> Mapping_rbt a b -> Mapping_rbt a b;
deletea xb xc = Mapping_RBTa (rbt_comp_delete (the ccompare) xb (impl_ofb xc));

list_remove1 :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
list_remove1 equal x (y : xs) =
  (if equal x y then xs else y : list_remove1 equal x xs);
list_remove1 equal x [] = [];

removea :: forall a. (Ceq a) => a -> Set_dlist a -> Set_dlist a;
removea xb xc = Abs_dlist (list_remove1 (the ceq) xb (list_of_dlist xc));

inserta :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Set a;
inserta xa (Complement x) = Complement (remove xa x);
inserta x (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert RBT_set: ccompare = None" (\ _ -> inserta x (RBT_set rbt));
    Just _ -> RBT_set (inserte x () rbt);
  });
inserta x (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert DList_set: ceq = None" (\ _ -> inserta x (DList_set dxs));
    Just _ -> DList_set (insertc x dxs);
  });
inserta x (Set_Monad xs) = Set_Monad (x : xs);
inserta x (Collect_set a) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "insert Collect_set: ceq = None" (\ _ -> inserta x (Collect_set a));
    Just eq -> Collect_set (fun_upda eq a x True);
  });

remove :: forall a. (Ceq a, Ccompare a) => a -> Set a -> Set a;
remove x (Complement a) = Complement (inserta x a);
remove x (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "remove RBT_set: ccompare = None" (\ _ -> remove x (RBT_set rbt));
    Just _ -> RBT_set (deletea x rbt);
  });
remove x (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "remove DList_set: ceq = None" (\ _ -> remove x (DList_set dxs));
    Just _ -> DList_set (removea x dxs);
  });
remove x (Collect_set a) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "remove Collect: ceq = None"
        (\ _ -> remove x (Collect_set a));
    Just eq -> Collect_set (fun_upda eq a x False);
  });

foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a;
foldl f a [] = a;
foldl f a (x : xs) = foldl f (f a x) xs;

set_aux :: forall a. (Ceq a, Ccompare a) => Set_impla -> [a] -> Set a;
set_aux Set_Monada = Set_Monad;
set_aux Set_Choose =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing -> Set_Monad;
        Just _ -> foldl (\ s x -> inserta x s) (DList_set emptyc);
      });
    Just _ -> foldl (\ s x -> inserta x s) (RBT_set emptye);
  });
set_aux impl = foldl (\ s x -> inserta x s) (set_empty impl);

set :: forall a. (Ceq a, Ccompare a, Set_impl a) => [a] -> Set a;
set xs = set_aux (of_phantom (set_impl :: Phantom a Set_impla)) xs;

cEnum_set ::
  forall a.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Maybe ([Set a],
                             ((Set a -> Bool) -> Bool,
                               (Set a -> Bool) -> Bool));
cEnum_set =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (_, _)) ->
      Just (map set (sublists enum_a),
             ((\ p -> all p (map set (sublists enum_a))),
               (\ p -> any p (map set (sublists enum_a)))));
  });

instance (Cenum a, Ceq a, Ccompare a, Set_impl a) => Cenum (Set a) where {
  cEnum = cEnum_set;
};

bot_set :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set a;
bot_set = set_empty (of_phantom (set_impl :: Phantom a Set_impla));

newtype Comp_fun_idem b a = Abs_comp_fun_idem (b -> a -> a);

comp_fun_idem_apply :: forall b a. Comp_fun_idem b a -> b -> a -> a;
comp_fun_idem_apply (Abs_comp_fun_idem x) = x;

foldb ::
  forall a b. (Ccompare a) => (a -> b -> b) -> Mapping_rbt a () -> b -> b;
foldb x xc = folda (\ a _ -> x a) (impl_ofb xc);

set_fold_cfi ::
  forall a b. (Ceq a, Ccompare a) => Comp_fun_idem a b -> b -> Set a -> b;
set_fold_cfi f b (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold_cfi RBT_set: ccompare = None"
        (\ _ -> set_fold_cfi f b (RBT_set rbt));
    Just _ -> foldb (comp_fun_idem_apply f) rbt b;
  });
set_fold_cfi f b (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "set_fold_cfi DList_set: ceq = None"
        (\ _ -> set_fold_cfi f b (DList_set dxs));
    Just _ -> foldc (comp_fun_idem_apply f) dxs b;
  });
set_fold_cfi f b (Set_Monad xs) = fold (comp_fun_idem_apply f) xs b;
set_fold_cfi f b (Collect_set p) =
  (error :: forall a. String -> (() -> a) -> a)
    "set_fold_cfi not supported on Collect_set"
    (\ _ -> set_fold_cfi f b (Collect_set p));
set_fold_cfi f b (Complement a) =
  (error :: forall a. String -> (() -> a) -> a)
    "set_fold_cfi not supported on Complement"
    (\ _ -> set_fold_cfi f b (Complement a));

finite :: forall a. (Finite_UNIV a, Ceq a, Ccompare a) => Set a -> Bool;
finite (Collect_set p) =
  of_phantom (finite_UNIV :: Phantom a Bool) ||
    (error :: forall a. String -> (() -> a) -> a) "finite Collect_set"
      (\ _ -> finite (Collect_set p));
finite (Set_Monad xs) = True;
finite (Complement a) =
  (if of_phantom (finite_UNIV :: Phantom a Bool) then True
    else (if finite a then False
           else (error :: forall a. String -> (() -> a) -> a)
                  "finite Complement: infinite set"
                  (\ _ -> finite (Complement a))));
finite (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "finite RBT_set: ccompare = None" (\ _ -> finite (RBT_set rbt));
    Just _ -> True;
  });
finite (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "finite DList_set: ceq = None" (\ _ -> finite (DList_set dxs));
    Just _ -> True;
  });

sup_cfi :: forall a. (Lattice a) => Comp_fun_idem a a;
sup_cfi = Abs_comp_fun_idem sup;

set_less_eq_aux_Compl_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
set_less_eq_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then let {
                  (x, s1a) = next g1 s1;
                  (y, s2a) = next g2 s2;
                } in (if less x y
                       then proper_interval ao (Just x) ||
                              set_less_eq_aux_Compl_fusion less proper_interval
                                g1 g2 (Just x) s1a s2
                       else (if less y x
                              then proper_interval ao (Just y) ||
                                     set_less_eq_aux_Compl_fusion less
                                       proper_interval g1 g2 (Just y) s1 s2a
                              else proper_interval ao (Just y)))
           else True)
    else True);

compl_set_less_eq_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
compl_set_less_eq_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then not (proper_interval ao (Just x)) &&
                                   compl_set_less_eq_aux_fusion less
                                     proper_interval g1 g2 (Just x) s1a s2
                            else (if less y x
                                   then not (proper_interval ao (Just y)) &&
  compl_set_less_eq_aux_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                   else not (proper_interval ao (Just y))))
                else not (proper_interval ao (Just x)) &&
                       compl_set_less_eq_aux_fusion less proper_interval g1 g2
                         (Just x) s1a s2)
    else (if has_next g2 s2
           then let {
                  (y, s2a) = next g2 s2;
                } in not (proper_interval ao (Just y)) &&
                       compl_set_less_eq_aux_fusion less proper_interval g1 g2
                         (Just y) s1 s2a
           else not (proper_interval ao Nothing)));

set_less_eq_aux_Compl ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
set_less_eq_aux_Compl less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           set_less_eq_aux_Compl less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  set_less_eq_aux_Compl less proper_interval (Just y) (x : xs)
                    ys
           else proper_interval ao (Just y)));
set_less_eq_aux_Compl less proper_interval ao xs [] = True;
set_less_eq_aux_Compl less proper_interval ao [] ys = True;

compl_set_less_eq_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
compl_set_less_eq_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           compl_set_less_eq_aux less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  compl_set_less_eq_aux less proper_interval (Just y) (x : xs)
                    ys
           else not (proper_interval ao (Just y))));
compl_set_less_eq_aux less proper_interval ao (x : xs) [] =
  not (proper_interval ao (Just x)) &&
    compl_set_less_eq_aux less proper_interval (Just x) xs [];
compl_set_less_eq_aux less proper_interval ao [] (y : ys) =
  not (proper_interval ao (Just y)) &&
    compl_set_less_eq_aux less proper_interval (Just y) [] ys;
compl_set_less_eq_aux less proper_interval ao [] [] =
  not (proper_interval ao Nothing);

lexord_eq_fusion ::
  forall a b c.
    (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
lexord_eq_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 &&
           let {
             (x, s1a) = next g1 s1;
             (y, s2a) = next g2 s2;
           } in less x y ||
                  not (less y x) && lexord_eq_fusion less g1 g2 s1a s2a
    else True);

remdups_sorted :: forall a. (a -> a -> Bool) -> [a] -> [a];
remdups_sorted less (x : y : xs) =
  (if less x y then x : remdups_sorted less (y : xs)
    else remdups_sorted less (y : xs));
remdups_sorted less [x] = [x];
remdups_sorted less [] = [];

quicksort_acc :: forall a. (a -> a -> Bool) -> [a] -> [a] -> [a];
quicksort_acc less ac (x : v : va) = quicksort_part less ac x [] [] [] (v : va);
quicksort_acc less ac [x] = x : ac;
quicksort_acc less ac [] = ac;

quicksort_part ::
  forall a. (a -> a -> Bool) -> [a] -> a -> [a] -> [a] -> [a] -> [a] -> [a];
quicksort_part less ac x lts eqs gts (z : zs) =
  (if less x z then quicksort_part less ac x lts eqs (z : gts) zs
    else (if less z x then quicksort_part less ac x (z : lts) eqs gts zs
           else quicksort_part less ac x lts (z : eqs) gts zs));
quicksort_part less ac x lts eqs gts [] =
  quicksort_acc less (eqs ++ x : quicksort_acc less ac gts) lts;

quicksort :: forall a. (a -> a -> Bool) -> [a] -> [a];
quicksort less = quicksort_acc less [];

gen_keys :: forall a b. [(a, Rbta a b)] -> Rbta a b -> [a];
gen_keys kts (Branch c l k v r) = gen_keys ((k, r) : kts) l;
gen_keys ((k, t) : kts) Emptya = k : gen_keys kts t;
gen_keys [] Emptya = [];

keys :: forall a b. Rbta a b -> [a];
keys = gen_keys [];

keysa :: forall a. (Ccompare a) => Mapping_rbt a () -> [a];
keysa xa = keys (impl_ofb xa);

csorted_list_of_set :: forall a. (Ceq a, Ccompare a) => Set a -> [a];
csorted_list_of_set (Set_Monad xs) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set Set_Monad: ccompare = None"
        (\ _ -> csorted_list_of_set (Set_Monad xs));
    Just c -> remdups_sorted (lt_of_comp c) (quicksort (lt_of_comp c) xs);
  });
csorted_list_of_set (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set DList_set: ceq = None"
        (\ _ -> csorted_list_of_set (DList_set dxs));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "csorted_list_of_set DList_set: ccompare = None"
            (\ _ -> csorted_list_of_set (DList_set dxs));
        Just c -> quicksort (lt_of_comp c) (list_of_dlist dxs);
      });
  });
csorted_list_of_set (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "csorted_list_of_set RBT_set: ccompare = None"
        (\ _ -> csorted_list_of_set (RBT_set rbt));
    Just _ -> keysa rbt;
  });

top_set :: forall a. (Ceq a, Ccompare a, Set_impl a) => Set a;
top_set = uminus_set bot_set;

le_of_comp :: forall a. (a -> a -> Ordera) -> a -> a -> Bool;
le_of_comp acomp x y =
  (case acomp x y of {
    Eqa -> True;
    Lt -> True;
    Gt -> False;
  });

lexordp_eq :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
lexordp_eq less (x : xs) (y : ys) =
  less x y || not (less y x) && lexordp_eq less xs ys;
lexordp_eq less (x : xs) [] = False;
lexordp_eq less xs [] = null xs;
lexordp_eq less [] ys = True;

set_less_aux_Compl_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
set_less_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then proper_interval ao (Just x) ||
                                   set_less_aux_Compl_fusion less
                                     proper_interval g1 g2 (Just x) s1a s2
                            else (if less y x
                                   then proper_interval ao (Just y) ||
  set_less_aux_Compl_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                   else proper_interval ao (Just y)))
                else proper_interval ao (Just x) ||
                       set_less_aux_Compl_fusion less proper_interval g1 g2
                         (Just x) s1a s2)
    else (if has_next g2 s2
           then let {
                  (y, s2a) = next g2 s2;
                } in proper_interval ao (Just y) ||
                       set_less_aux_Compl_fusion less proper_interval g1 g2
                         (Just y) s1 s2a
           else proper_interval ao Nothing));

compl_set_less_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
compl_set_less_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 &&
    has_next g2 s2 &&
      let {
        (x, s1a) = next g1 s1;
        (y, s2a) = next g2 s2;
      } in (if less x y
             then not (proper_interval ao (Just x)) &&
                    compl_set_less_aux_fusion less proper_interval g1 g2
                      (Just x) s1a s2
             else (if less y x
                    then not (proper_interval ao (Just y)) &&
                           compl_set_less_aux_fusion less proper_interval g1 g2
                             (Just y) s1 s2a
                    else not (proper_interval ao (Just y))));

set_less_aux_Compl ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
set_less_aux_Compl less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           set_less_aux_Compl less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  set_less_aux_Compl less proper_interval (Just y) (x : xs) ys
           else proper_interval ao (Just y)));
set_less_aux_Compl less proper_interval ao (x : xs) [] =
  proper_interval ao (Just x) ||
    set_less_aux_Compl less proper_interval (Just x) xs [];
set_less_aux_Compl less proper_interval ao [] (y : ys) =
  proper_interval ao (Just y) ||
    set_less_aux_Compl less proper_interval (Just y) [] ys;
set_less_aux_Compl less proper_interval ao [] [] = proper_interval ao Nothing;

compl_set_less_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
compl_set_less_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           compl_set_less_aux less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  compl_set_less_aux less proper_interval (Just y) (x : xs) ys
           else not (proper_interval ao (Just y))));
compl_set_less_aux less proper_interval ao xs [] = False;
compl_set_less_aux less proper_interval ao [] ys = False;

lexord_fusion ::
  forall a b c.
    (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
lexord_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then let {
                  (x, s1a) = next g1 s1;
                  (y, s2a) = next g2 s2;
                } in less x y ||
                       not (less y x) && lexord_fusion less g1 g2 s1a s2a
           else False)
    else has_next g2 s2);

lexordp :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
lexordp less (x : xs) (y : ys) =
  less x y || not (less y x) && lexordp less xs ys;
lexordp less xs [] = False;
lexordp less [] ys = not (null ys);

comp_of_ords ::
  forall a. (a -> a -> Bool) -> (a -> a -> Bool) -> a -> a -> Ordera;
comp_of_ords le lt x y = (if lt x y then Lt else (if le x y then Eqa else Gt));

ccompare_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Maybe (Set a -> Set a -> Ordera);
ccompare_set =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing -> Nothing;
    Just _ -> Just (comp_of_ords cless_eq_set cless_set);
  });

cless_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Set a -> Set a -> Bool;
cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ -> cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        compl_set_less_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set RBT_set (Complement RBT_set): ccompare = None"
        (\ _ -> cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)));
    Just c ->
      (if (finite :: Set a -> Bool) (top_set :: Set a)
        then set_less_aux_Compl_fusion (lt_of_comp c) cproper_interval
               rbt_keys_generator rbt_keys_generator Nothing (init rbt1)
               (init rbt2)
        else True);
  });
cless_set (RBT_set rbta) (RBT_set rbt) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set RBT_set RBT_set: ccompare = None"
        (\ _ -> cless_set (RBT_set rbta) (RBT_set rbt));
    Just c ->
      lexord_fusion (\ x y -> lt_of_comp c y x) rbt_keys_generator
        rbt_keys_generator (init rbta) (init rbt);
  });
cless_set (Complement a) (Complement b) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement Complement: ccompare = None"
        (\ _ -> cless_set (Complement a) (Complement b));
    Just _ -> lt_of_comp (the ccompare_set) b a;
  });
cless_set (Complement a) b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement1: ccompare = None"
        (\ _ -> cless_set (Complement a) b);
    Just c ->
      (if finite a && finite b
        then (finite :: Set a -> Bool) (top_set :: Set a) &&
               compl_set_less_aux (lt_of_comp c) cproper_interval Nothing
                 (csorted_list_of_set a) (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set Complement1: infinite set"
               (\ _ -> cless_set (Complement a) b));
  });
cless_set a (Complement b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_set Complement2: ccompare = None"
        (\ _ -> cless_set a (Complement b));
    Just c ->
      (if finite a && finite b
        then (if (finite :: Set a -> Bool) (top_set :: Set a)
               then set_less_aux_Compl (lt_of_comp c) cproper_interval Nothing
                      (csorted_list_of_set a) (csorted_list_of_set b)
               else True)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set Complement2: infinite set"
               (\ _ -> cless_set a (Complement b)));
  });
cless_set a b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "cless_set: ccompare = None"
        (\ _ -> cless_set a b);
    Just c ->
      (if finite a && finite b
        then lexordp (\ x y -> lt_of_comp c y x) (csorted_list_of_set a)
               (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_set: infinite set" (\ _ -> cless_set a b));
  });

cless_eq_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Set a -> Set a -> Bool;
cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ -> cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        compl_set_less_eq_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set RBT_set (Complement RBT_set): ccompare = None"
        (\ _ -> cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)));
    Just c ->
      (if (finite :: Set a -> Bool) (top_set :: Set a)
        then set_less_eq_aux_Compl_fusion (lt_of_comp c) cproper_interval
               rbt_keys_generator rbt_keys_generator Nothing (init rbt1)
               (init rbt2)
        else True);
  });
cless_eq_set (RBT_set rbta) (RBT_set rbt) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set RBT_set RBT_set: ccompare = None"
        (\ _ -> cless_eq_set (RBT_set rbta) (RBT_set rbt));
    Just c ->
      lexord_eq_fusion (\ x y -> lt_of_comp c y x) rbt_keys_generator
        rbt_keys_generator (init rbta) (init rbt);
  });
cless_eq_set (Complement a) (Complement b) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement Complement: ccompare = None"
        (\ _ -> le_of_comp (the ccompare_set) (Complement a) (Complement b));
    Just _ -> cless_eq_set b a;
  });
cless_eq_set (Complement a) b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement1: ccompare = None"
        (\ _ -> cless_eq_set (Complement a) b);
    Just c ->
      (if finite a && finite b
        then (finite :: Set a -> Bool) (top_set :: Set a) &&
               compl_set_less_eq_aux (lt_of_comp c) cproper_interval Nothing
                 (csorted_list_of_set a) (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set Complement1: infinite set"
               (\ _ -> cless_eq_set (Complement a) b));
  });
cless_eq_set a (Complement b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set Complement2: ccompare = None"
        (\ _ -> cless_eq_set a (Complement b));
    Just c ->
      (if finite a && finite b
        then (if (finite :: Set a -> Bool) (top_set :: Set a)
               then set_less_eq_aux_Compl (lt_of_comp c) cproper_interval
                      Nothing (csorted_list_of_set a) (csorted_list_of_set b)
               else True)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set Complement2: infinite set"
               (\ _ -> cless_eq_set a (Complement b)));
  });
cless_eq_set a b =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cless_eq_set: ccompare = None" (\ _ -> cless_eq_set a b);
    Just c ->
      (if finite a && finite b
        then lexordp_eq (\ x y -> lt_of_comp c y x) (csorted_list_of_set a)
               (csorted_list_of_set b)
        else (error :: forall a. String -> (() -> a) -> a)
               "cless_eq_set: infinite set" (\ _ -> cless_eq_set a b));
  });

instance (Finite_UNIV a, Ceq a, Cproper_interval a,
           Set_impl a) => Ccompare (Set a) where {
  ccompare = ccompare_set;
};

finite_UNIV_set :: forall a. (Finite_UNIV a) => Phantom (Set a) Bool;
finite_UNIV_set = Phantom (of_phantom (finite_UNIV :: Phantom a Bool));

instance (Finite_UNIV a) => Finite_UNIV (Set a) where {
  finite_UNIV = finite_UNIV_set;
};

sup_seta ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a,
      Set_impl a) => Set (Set a) -> Set a;
sup_seta a =
  (if finite a then set_fold_cfi sup_cfi bot_set a
    else (error :: forall a. String -> (() -> a) -> a) "Sup: infinite"
           (\ _ -> sup_seta a));

class Supa a where {
  supa :: Set a -> a;
};

instance (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a,
           Set_impl a) => Supa (Set a) where {
  supa = sup_seta;
};

fold_fusion :: forall a b c. Generator a b -> (a -> c -> c) -> b -> c -> c;
fold_fusion g f s b =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in fold_fusion g f sa (f x b)
    else b);

length_last_fusion :: forall a b. Generator a b -> b -> (Nat, a);
length_last_fusion g s =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in fold_fusion g (\ xa (n, _) -> (plus_nat n (Nat_of_num One), xa))
                sa (Nat_of_num One, x)
    else (Zero_nat, error "undefined"));

gen_length_fusion :: forall a b. Generator a b -> Nat -> b -> Nat;
gen_length_fusion g n s =
  (if has_next g s
    then gen_length_fusion g (plus_nat n (Nat_of_num One)) (snd (next g s))
    else n);

length_fusion :: forall a b. Generator a b -> b -> Nat;
length_fusion g = gen_length_fusion g Zero_nat;

card_UNIV :: forall a. (Card_UNIV a) => Phantom a Nat;
card_UNIV = card_UNIVa;

proper_interval_set_Compl_aux_fusion ::
  forall a b c.
    (Card_UNIV a) => (a -> a -> Bool) ->
                       (Maybe a -> Maybe a -> Bool) ->
                         Generator a b ->
                           Generator a c -> Maybe a -> Nat -> b -> c -> Bool;
proper_interval_set_Compl_aux_fusion less proper_interval g1 g2 ao n s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then proper_interval ao (Just x) ||
                                   proper_interval_set_Compl_aux_fusion less
                                     proper_interval g1 g2 (Just x)
                                     (plus_nat n (Nat_of_num One)) s1a s2
                            else (if less y x
                                   then proper_interval ao (Just y) ||
  proper_interval_set_Compl_aux_fusion less proper_interval g1 g2 (Just y)
    (plus_nat n (Nat_of_num One)) s1 s2a
                                   else proper_interval ao (Just x) &&
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
  } in not (equal_nat (minus_nat m (length_fusion g2 s2a))
             (Nat_of_num (Bit0 One))) ||
         not (equal_nat (minus_nat m (length_fusion g1 s1a))
               (Nat_of_num (Bit0 One)))))
                else let {
                       m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat))
                             n;
                       (len_x, xa) = length_last_fusion g1 s1;
                     } in not (equal_nat m len_x) &&
                            (if equal_nat m (plus_nat len_x (Nat_of_num One))
                              then not (proper_interval (Just xa) Nothing)
                              else True))
    else (if has_next g2 s2
           then let {
                  (_, _) = next g2 s2;
                  m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                  (len_y, y) = length_last_fusion g2 s2;
                } in not (equal_nat m len_y) &&
                       (if equal_nat m (plus_nat len_y (Nat_of_num One))
                         then not (proper_interval (Just y) Nothing) else True)
           else less_nat (plus_nat n (Nat_of_num One))
                  (of_phantom (card_UNIV :: Phantom a Nat))));

proper_interval_Compl_set_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
proper_interval_Compl_set_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 &&
    has_next g2 s2 &&
      let {
        (x, s1a) = next g1 s1;
        (y, s2a) = next g2 s2;
      } in (if less x y
             then not (proper_interval ao (Just x)) &&
                    proper_interval_Compl_set_aux_fusion less proper_interval g1
                      g2 (Just x) s1a s2
             else (if less y x
                    then not (proper_interval ao (Just y)) &&
                           proper_interval_Compl_set_aux_fusion less
                             proper_interval g1 g2 (Just y) s1 s2a
                    else not (proper_interval ao (Just x)) &&
                           (has_next g2 s2a || has_next g1 s1a)));

exhaustive_above_fusion ::
  forall a b. (Maybe a -> Maybe a -> Bool) -> Generator a b -> a -> b -> Bool;
exhaustive_above_fusion proper_interval g y s =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in not (proper_interval (Just y) (Just x)) &&
                exhaustive_above_fusion proper_interval g x sa
    else not (proper_interval (Just y) Nothing));

proper_interval_set_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> b -> c -> Bool;
proper_interval_set_aux_fusion less proper_interval g1 g2 s1 s2 =
  has_next g2 s2 &&
    let {
      (y, s2a) = next g2 s2;
    } in (if has_next g1 s1
           then let {
                  (x, s1a) = next g1 s1;
                } in (if less x y then False
                       else (if less y x
                              then proper_interval (Just y) (Just x) ||
                                     (has_next g2 s2a ||
                                       not
 (exhaustive_above_fusion proper_interval g1 x s1a))
                              else proper_interval_set_aux_fusion less
                                     proper_interval g1 g2 s1a s2a))
           else has_next g2 s2a || proper_interval (Just y) Nothing);

length_last :: forall a. [a] -> (Nat, a);
length_last (x : xs) =
  fold (\ xa (n, _) -> (plus_nat n (Nat_of_num One), xa)) xs
    (Nat_of_num One, x);
length_last [] = (Zero_nat, error "undefined");

proper_interval_set_Compl_aux ::
  forall a.
    (Card_UNIV a) => (a -> a -> Bool) ->
                       (Maybe a -> Maybe a -> Bool) ->
                         Maybe a -> Nat -> [a] -> [a] -> Bool;
proper_interval_set_Compl_aux less proper_interval ao n (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           proper_interval_set_Compl_aux less proper_interval (Just x)
             (plus_nat n (Nat_of_num One)) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  proper_interval_set_Compl_aux less proper_interval (Just y)
                    (plus_nat n (Nat_of_num One)) (x : xs) ys
           else proper_interval ao (Just x) &&
                  let {
                    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                  } in not (equal_nat (minus_nat m (size_list ys))
                             (Nat_of_num (Bit0 One))) ||
                         not (equal_nat (minus_nat m (size_list xs))
                               (Nat_of_num (Bit0 One)))));
proper_interval_set_Compl_aux less proper_interval ao n (x : xs) [] =
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
    (len_x, xa) = length_last (x : xs);
  } in not (equal_nat m len_x) &&
         (if equal_nat m (plus_nat len_x (Nat_of_num One))
           then not (proper_interval (Just xa) Nothing) else True);
proper_interval_set_Compl_aux less proper_interval ao n [] (y : ys) =
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
    (len_y, ya) = length_last (y : ys);
  } in not (equal_nat m len_y) &&
         (if equal_nat m (plus_nat len_y (Nat_of_num One))
           then not (proper_interval (Just ya) Nothing) else True);
proper_interval_set_Compl_aux less proper_interval ao n [] [] =
  less_nat (plus_nat n (Nat_of_num One))
    (of_phantom (card_UNIV :: Phantom a Nat));

proper_interval_Compl_set_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
proper_interval_Compl_set_aux less proper_interval ao uu [] = False;
proper_interval_Compl_set_aux less proper_interval ao [] uv = False;
proper_interval_Compl_set_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           proper_interval_Compl_set_aux less proper_interval (Just x) xs
             (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  proper_interval_Compl_set_aux less proper_interval (Just y)
                    (x : xs) ys
           else not (proper_interval ao (Just x)) &&
                  (if null ys then not (null xs) else True)));

exhaustive_above :: forall a. (Maybe a -> Maybe a -> Bool) -> a -> [a] -> Bool;
exhaustive_above proper_interval x (y : ys) =
  not (proper_interval (Just x) (Just y)) &&
    exhaustive_above proper_interval y ys;
exhaustive_above proper_interval x [] = not (proper_interval (Just x) Nothing);

proper_interval_set_aux ::
  forall a.
    (a -> a -> Bool) -> (Maybe a -> Maybe a -> Bool) -> [a] -> [a] -> Bool;
proper_interval_set_aux less proper_interval (x : xs) (y : ys) =
  (if less x y then False
    else (if less y x
           then proper_interval (Just y) (Just x) ||
                  (not (null ys) || not (exhaustive_above proper_interval x xs))
           else proper_interval_set_aux less proper_interval xs ys));
proper_interval_set_aux less proper_interval [] (y : ys) =
  not (null ys) || proper_interval (Just y) Nothing;
proper_interval_set_aux less proper_interval xs [] = False;

exhaustive_fusion ::
  forall a b. (Maybe a -> Maybe a -> Bool) -> Generator a b -> b -> Bool;
exhaustive_fusion proper_interval g s =
  has_next g s &&
    let {
      (x, sa) = next g s;
    } in not (proper_interval Nothing (Just x)) &&
           exhaustive_above_fusion proper_interval g x sa;

list_remdups :: forall a. (a -> a -> Bool) -> [a] -> [a];
list_remdups equal (x : xs) =
  (if list_member equal xs x then list_remdups equal xs
    else x : list_remdups equal xs);
list_remdups equal [] = [];

length :: forall a. (Ceq a) => Set_dlist a -> Nat;
length xa = size_list (list_of_dlist xa);

card :: forall a. (Card_UNIV a, Ceq a, Ccompare a) => Set a -> Nat;
card (Complement a) =
  let {
    aa = card a;
    s = of_phantom (card_UNIV :: Phantom a Nat);
  } in (if less_nat Zero_nat s then minus_nat s aa
         else (if finite a then Zero_nat
                else (error :: forall a. String -> (() -> a) -> a)
                       "card Complement: infinite"
                       (\ _ -> card (Complement a))));
card (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "card Set_Monad: ceq = None"
        (\ _ -> card (Set_Monad xs));
    Just eq -> size_list (list_remdups eq xs);
  });
card (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "card RBT_set: ccompare = None" (\ _ -> card (RBT_set rbt));
    Just _ -> size_list (keysa rbt);
  });
card (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "card DList_set: ceq = None"
        (\ _ -> card (DList_set dxs));
    Just _ -> length dxs;
  });

is_UNIV :: forall a. (Card_UNIV a, Ceq a, Cproper_interval a) => Set a -> Bool;
is_UNIV (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_UNIV RBT_set: ccompare = None" (\ _ -> is_UNIV (RBT_set rbt));
    Just _ ->
      of_phantom (finite_UNIV :: Phantom a Bool) &&
        exhaustive_fusion cproper_interval rbt_keys_generator (init rbt);
  });
is_UNIV a =
  let {
    aa = of_phantom (card_UNIV :: Phantom a Nat);
    b = card a;
  } in (if less_nat Zero_nat aa then equal_nat aa b
         else (if less_nat Zero_nat b then False
                else (error :: forall a. String -> (() -> a) -> a)
                       "is_UNIV called on infinite type and set"
                       (\ _ -> is_UNIV a)));

is_emptya :: forall a b. (Ccompare a) => Mapping_rbt a b -> Bool;
is_emptya xa =
  (case impl_ofb xa of {
    Emptya -> True;
    Branch _ _ _ _ _ -> False;
  });

nulla :: forall a. (Ceq a) => Set_dlist a -> Bool;
nulla xa = null (list_of_dlist xa);

is_empty :: forall a. (Card_UNIV a, Ceq a, Cproper_interval a) => Set a -> Bool;
is_empty (Complement a) = is_UNIV a;
is_empty (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_empty RBT_set: ccompare = None" (\ _ -> is_empty (RBT_set rbt));
    Just _ -> is_emptya rbt;
  });
is_empty (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "is_empty DList_set: ceq = None" (\ _ -> is_empty (DList_set dxs));
    Just _ -> nulla dxs;
  });
is_empty (Set_Monad xs) = null xs;

cproper_interval_set ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Maybe (Set a) -> Maybe (Set a) -> Bool;
cproper_interval_set (Just (Complement (RBT_set rbt1))) (Just (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval (Complement RBT_set) RBT_set: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (Complement (RBT_set rbt1)))
            (Just (RBT_set rbt2)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_Compl_set_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cproper_interval_set (Just (RBT_set rbt1)) (Just (Complement (RBT_set rbt2))) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval RBT_set (Complement RBT_set): ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (RBT_set rbt1))
            (Just (Complement (RBT_set rbt2))));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_Compl_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing Zero_nat (init rbt1)
          (init rbt2);
  });
cproper_interval_set (Just (RBT_set rbt1)) (Just (RBT_set rbt2)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval RBT_set RBT_set: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (RBT_set rbt1)) (Just (RBT_set rbt2)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_aux_fusion (lt_of_comp c) cproper_interval
          rbt_keys_generator rbt_keys_generator (init rbt1) (init rbt2);
  });
cproper_interval_set (Just (Complement a)) (Just (Complement b)) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement Complement: ccompare = None"
        (\ _ ->
          cproper_interval_set (Just (Complement a)) (Just (Complement b)));
    Just _ -> cproper_interval_set (Just b) (Just a);
  });
cproper_interval_set (Just (Complement a)) (Just b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement1: ccompare = None"
        (\ _ -> cproper_interval_set (Just (Complement a)) (Just b));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_Compl_set_aux (lt_of_comp c) cproper_interval Nothing
          (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) (Just (Complement b)) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval Complement2: ccompare = None"
        (\ _ -> cproper_interval_set (Just a) (Just (Complement b)));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_Compl_aux (lt_of_comp c) cproper_interval Nothing
          Zero_nat (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) (Just b) =
  (case ccompare of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "cproper_interval: ccompare = None"
        (\ _ -> cproper_interval_set (Just a) (Just b));
    Just c ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_aux (lt_of_comp c) cproper_interval
          (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) Nothing = not (is_UNIV a);
cproper_interval_set Nothing (Just b) = not (is_empty b);
cproper_interval_set Nothing Nothing = True;

instance (Card_UNIV a, Ceq a, Cproper_interval a,
           Set_impl a) => Cproper_interval (Set a) where {
  cproper_interval = cproper_interval_set;
};

shows_prec_list ::
  forall a. (Showa a) => Nat -> [a] -> [Prelude.Char] -> [Prelude.Char];
shows_prec_list p xs = shows_list xs;

shows_list_list ::
  forall a. (Showa a) => [[a]] -> [Prelude.Char] -> [Prelude.Char];
shows_list_list xss = showsp_list shows_prec_list Zero_nat xss;

instance (Showa a) => Showa [a] where {
  shows_prec = shows_prec_list;
  shows_list = shows_list_list;
};

default_list :: forall a. [a];
default_list = [];

class Default a where {
  defaulta :: a;
};

instance Default [a] where {
  defaulta = default_list;
};

less_eq_list :: forall a. (Eq a, Order a) => [a] -> [a] -> Bool;
less_eq_list (x : xs) (y : ys) = less x y || x == y && less_eq_list xs ys;
less_eq_list [] xs = True;
less_eq_list (x : xs) [] = False;

less_list :: forall a. (Eq a, Order a) => [a] -> [a] -> Bool;
less_list (x : xs) (y : ys) = less x y || x == y && less_list xs ys;
less_list [] (x : xs) = True;
less_list xs [] = False;

instance (Eq a, Order a) => Ord [a] where {
  less_eq = less_eq_list;
  less = less_list;
};

comparator_list :: forall a. (a -> a -> Ordera) -> [a] -> [a] -> Ordera;
comparator_list comp_a (x : xa) (y : ya) =
  (case comp_a x y of {
    Eqa -> comparator_list comp_a xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_list comp_a (x : xa) [] = Gt;
comparator_list comp_a [] (y : ya) = Lt;
comparator_list comp_a [] [] = Eqa;

compare_list :: forall a. (Compare a) => [a] -> [a] -> Ordera;
compare_list = comparator_list compare;

instance (Eq a, Order a) => Preorder [a] where {
};

instance (Eq a, Order a) => Order [a] where {
};

instance (Eq a, Linorder a) => Linorder [a] where {
};

instance (Compare a) => Compare [a] where {
  compare = compare_list;
};

instance (Compare_order a, Eq a) => Compare_order [a] where {
};

instance (Eq a, Key a) => Key [a] where {
};

equality_list :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
equality_list eq_a (x : xa) (y : ya) = eq_a x y && equality_list eq_a xa ya;
equality_list eq_a (x : xa) [] = False;
equality_list eq_a [] (y : ya) = False;
equality_list eq_a [] [] = True;

ceq_list :: forall a. (Ceq a) => Maybe ([a] -> [a] -> Bool);
ceq_list =
  (case ceq of {
    Nothing -> Nothing;
    Just eq_a -> Just (equality_list eq_a);
  });

instance (Ceq a) => Ceq [a] where {
  ceq = ceq_list;
};

set_impl_list :: forall a. Phantom [a] Set_impla;
set_impl_list = Phantom Set_Choose;

instance Set_impl [a] where {
  set_impl = set_impl_list;
};

class Countable a where {
};

instance (Countable a) => Countable [a] where {
};

finite_UNIV_list :: forall a. Phantom [a] Bool;
finite_UNIV_list = Phantom False;

card_UNIV_list :: forall a. Phantom [a] Nat;
card_UNIV_list = Phantom Zero_nat;

instance Finite_UNIV [a] where {
  finite_UNIV = finite_UNIV_list;
};

instance Card_UNIV [a] where {
  card_UNIVa = card_UNIV_list;
};

cEnum_list ::
  forall a. Maybe ([[a]], (([a] -> Bool) -> Bool, ([a] -> Bool) -> Bool));
cEnum_list = Nothing;

instance Cenum [a] where {
  cEnum = cEnum_list;
};

ccompare_list :: forall a. (Ccompare a) => Maybe ([a] -> [a] -> Ordera);
ccompare_list =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_a -> Just (comparator_list comp_a);
  });

instance (Ccompare a) => Ccompare [a] where {
  ccompare = ccompare_list;
};

mapping_impl_list :: forall a. Phantom [a] Mapping_impla;
mapping_impl_list = Phantom Mapping_Choose;

instance Mapping_impl [a] where {
  mapping_impl = mapping_impl_list;
};

cproper_interval_list ::
  forall a. (Ccompare a) => Maybe [a] -> Maybe [a] -> Bool;
cproper_interval_list xso yso = error "undefined";

instance (Ccompare a) => Cproper_interval [a] where {
  cproper_interval = cproper_interval_list;
};

newtype Mini_alg = Abs_mini_alg (Rat, (Rat, Nat));

newtype Mini_alg_unique = Abs_mini_alg_unique Mini_alg;

newtype Real = Real_of_u Mini_alg_unique;

rep_mini_alg_unique :: Mini_alg_unique -> Mini_alg;
rep_mini_alg_unique (Abs_mini_alg_unique x) = x;

rep_mini_alg :: Mini_alg -> (Rat, (Rat, Nat));
rep_mini_alg (Abs_mini_alg x) = x;

ma_identity :: Mini_alg -> Mini_alg -> Bool;
ma_identity xa xc = rep_mini_alg xa == rep_mini_alg xc;

mau_equal :: Mini_alg_unique -> Mini_alg_unique -> Bool;
mau_equal xa xc = ma_identity (rep_mini_alg_unique xa) (rep_mini_alg_unique xc);

equal_real :: Real -> Real -> Bool;
equal_real (Real_of_u r1) (Real_of_u r2) = mau_equal r1 r2;

instance Eq Real where {
  a == b = equal_real a b;
};

ma_compatible :: Mini_alg -> Mini_alg -> Bool;
ma_compatible xa xc =
  let {
    (_, (q1, b1)) = rep_mini_alg xa;
  } in (\ (_, (q2, b2)) ->
         equal_rat q1 zero_rat || (equal_rat q2 zero_rat || equal_nat b1 b2))
    (rep_mini_alg xc);

mau_compatible :: Mini_alg_unique -> Mini_alg_unique -> Bool;
mau_compatible xa xc =
  ma_compatible (rep_mini_alg_unique xa) (rep_mini_alg_unique xc);

of_nat :: forall a. (Semiring_1 a) => Nat -> a;
of_nat (Nat_of_num k) = numeral k;
of_nat Zero_nat = zeroa;

ma_normalize :: (Rat, (Rat, Nat)) -> (Rat, (Rat, Nat));
ma_normalize x =
  let {
    (a, b) = x;
    (ba, c) = b;
  } in (if equal_rat ba zero_rat then (a, (zero_rat, Zero_nat))
         else (a, (ba, c)));

ma_times :: Mini_alg -> Mini_alg -> Mini_alg;
ma_times xb xc =
  Abs_mini_alg
    (let {
       (p1, (q1, b1)) = rep_mini_alg xb;
     } in (\ (p2, (q2, b2)) ->
            (if equal_rat q1 zero_rat
              then ma_normalize (times_rat p1 p2, (times_rat p1 q2, b2))
              else ma_normalize
                     (plus_rat (times_rat p1 p2)
                        (times_rat (times_rat (of_nat b2) q1) q2),
                       (plus_rat (times_rat p1 q2) (times_rat q1 p2), b1))))
      (rep_mini_alg xc));

mau_times :: Mini_alg_unique -> Mini_alg_unique -> Mini_alg_unique;
mau_times xb xc =
  Abs_mini_alg_unique
    (ma_times (rep_mini_alg_unique xb) (rep_mini_alg_unique xc));

times_real :: Real -> Real -> Real;
times_real (Real_of_u r1) (Real_of_u r2) =
  (if mau_compatible r1 r2 then Real_of_u (mau_times r1 r2)
    else (error :: forall a. String -> (() -> a) -> a) "different base"
           (\ _ -> times_real (Real_of_u r1) (Real_of_u r2)));

instance Times Real where {
  times = times_real;
};

instance Dvd Real where {
};

shows_prec_char :: Nat -> Prelude.Char -> [Prelude.Char] -> [Prelude.Char];
shows_prec_char p c = (\ a -> c : a);

shows_list_char :: [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
shows_list_char cs = shows_string cs;

instance Showa Prelude.Char where {
  shows_prec = shows_prec_char;
  shows_list = shows_list_char;
};

ma_show_real :: Mini_alg -> [Prelude.Char];
ma_show_real xa =
  let {
    (p, (q, b)) = rep_mini_alg xa;
    sb = (shows_prec_list Zero_nat "sqrt(" . shows_prec_nat Zero_nat b) .
           shows_prec_list Zero_nat ")";
    qb = (if equal_rat q one_rat then sb
           else (if equal_rat q (uminus_rat one_rat)
                  then shows_prec_list Zero_nat "-" . sb
                  else (shows_prec_rat Zero_nat q .
                         shows_prec_list Zero_nat "*") .
                         sb));
  } in (if equal_rat q zero_rat then shows_prec_rat Zero_nat p []
         else (if equal_rat p zero_rat then qb []
                else (if less_rat q zero_rat
                       then shows_prec_rat Zero_nat p (qb [])
                       else shows_prec_rat Zero_nat p
                              (shows_prec_list Zero_nat "+" (qb [])))));

mau_show_real :: Mini_alg_unique -> [Prelude.Char];
mau_show_real xa = ma_show_real (rep_mini_alg_unique xa);

show_real :: Real -> [Prelude.Char];
show_real (Real_of_u x) = mau_show_real x;

shows_paren ::
  ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_paren s =
  (shows_prec_char Zero_nat '(' . s) . shows_prec_char Zero_nat ')';

ma_is_rat :: Mini_alg -> Bool;
ma_is_rat xa = let {
                 (_, (q, _)) = rep_mini_alg xa;
               } in equal_rat q zero_rat;

mau_is_rat :: Mini_alg_unique -> Bool;
mau_is_rat xa = ma_is_rat (rep_mini_alg_unique xa);

is_rat :: Real -> Bool;
is_rat (Real_of_u x) = mau_is_rat x;

shows_prec_real :: Nat -> Real -> [Prelude.Char] -> [Prelude.Char];
shows_prec_real d x =
  (if is_rat x then id else shows_paren) (shows_string (show_real x));

shows_list_real :: [Real] -> [Prelude.Char] -> [Prelude.Char];
shows_list_real ps = showsp_list shows_prec_real Zero_nat ps;

instance Showa Real where {
  shows_prec = shows_prec_real;
  shows_list = shows_list_real;
};

ma_uminus :: Mini_alg -> Mini_alg;
ma_uminus xa =
  Abs_mini_alg
    (let {
       (p1, (q1, b1)) = rep_mini_alg xa;
     } in (uminus_rat p1, (uminus_rat q1, b1)));

mau_uminus :: Mini_alg_unique -> Mini_alg_unique;
mau_uminus xa = Abs_mini_alg_unique (ma_uminus (rep_mini_alg_unique xa));

uminus_real :: Real -> Real;
uminus_real (Real_of_u r) = Real_of_u (mau_uminus r);

ma_of_rat :: Rat -> Mini_alg;
ma_of_rat xa = Abs_mini_alg (xa, (zero_rat, Zero_nat));

mau_of_rat :: Rat -> Mini_alg_unique;
mau_of_rat xa = Abs_mini_alg_unique (ma_of_rat xa);

zero_real :: Real;
zero_real = Real_of_u (mau_of_rat zero_rat);

ma_plus :: Mini_alg -> Mini_alg -> Mini_alg;
ma_plus xb xc =
  Abs_mini_alg
    (let {
       (p1, (q1, b1)) = rep_mini_alg xb;
     } in (\ (p2, (q2, b2)) ->
            (if equal_rat q1 zero_rat then (plus_rat p1 p2, (q2, b2))
              else ma_normalize (plus_rat p1 p2, (plus_rat q1 q2, b1))))
      (rep_mini_alg xc));

mau_plus :: Mini_alg_unique -> Mini_alg_unique -> Mini_alg_unique;
mau_plus xb xc =
  Abs_mini_alg_unique
    (ma_plus (rep_mini_alg_unique xb) (rep_mini_alg_unique xc));

plus_real :: Real -> Real -> Real;
plus_real (Real_of_u r1) (Real_of_u r2) =
  (if mau_compatible r1 r2 then Real_of_u (mau_plus r1 r2)
    else (error :: forall a. String -> (() -> a) -> a) "different base"
           (\ _ -> plus_real (Real_of_u r1) (Real_of_u r2)));

minus_real :: Real -> Real -> Real;
minus_real x y = plus_real x (uminus_real y);

sqrt_int_maina :: Int -> Int -> (Int, Bool);
sqrt_int_maina x n =
  let {
    x2 = times_int x x;
  } in (if less_eq_int x2 n then (x, equal_int x2 n)
         else sqrt_int_maina
                (div_int (plus_int (div_int n x) x) (Pos (Bit0 One))) n);

ceiling :: forall a. (Floor_ceiling a) => a -> Int;
ceiling x = uminus_int (floor (uminus x));

power :: forall a. a -> (a -> a -> a) -> a -> Nat -> a;
power one times a n =
  (if equal_nat n Zero_nat then one
    else times a (power one times a (minus_nat n (Nat_of_num One))));

powera :: forall a. (Power a) => a -> Nat -> a;
powera = power onea times;

log_ceil_impl :: Nat -> Int -> Int -> Nat -> Nat;
log_ceil_impl b x prod sum =
  (if less_eq_int x prod then sum
    else log_ceil_impl b x (times_int prod (of_nat b))
           (plus_nat sum (Nat_of_num One)));

log_ceil :: Nat -> Int -> Nat;
log_ceil b x =
  (if less_nat (Nat_of_num One) b && less_eq_int Zero_int x
    then log_ceil_impl b x (Pos One) Zero_nat else Zero_nat);

of_int :: Int -> Rat;
of_int a = Frct (a, Pos One);

start_value :: Int -> Nat -> Int;
start_value n p =
  powera (Pos (Bit0 One))
    (nat (ceiling
           (divide_rat (of_int (of_nat (log_ceil (Nat_of_num (Bit0 One)) n)))
             (of_nat p))));

sqrt_int_main :: Int -> (Int, Bool);
sqrt_int_main x = sqrt_int_maina (start_value x (Nat_of_num (Bit0 One))) x;

sqrt_int_ceiling_pos :: Int -> Int;
sqrt_int_ceiling_pos x =
  (case sqrt_int_main x of {
    (y, True) -> y;
    (y, False) -> plus_int y (Pos One);
  });

sqrt_int_floor_pos :: Int -> Int;
sqrt_int_floor_pos x = fst (sqrt_int_main x);

ma_floor :: Mini_alg -> Int;
ma_floor xa =
  let {
    (p, (q, b)) = rep_mini_alg xa;
    ((z1, n1), (z2, n2)) = (quotient_of p, quotient_of q);
    z2n1 = times_int z2 n1;
    z1n2 = times_int z1 n2;
    n12 = times_int n1 n2;
    prod = times_int (times_int z2n1 z2n1) (of_nat b);
  } in div_int
         (plus_int z1n2
           (if less_eq_int Zero_int z2n1 then sqrt_int_floor_pos prod
             else uminus_int (sqrt_int_ceiling_pos prod)))
         n12;

mau_floor :: Mini_alg_unique -> Int;
mau_floor xa = ma_floor (rep_mini_alg_unique xa);

floor_real :: Real -> Int;
floor_real (Real_of_u r) = mau_floor r;

of_inta :: forall a. (Ring_1 a) => Int -> a;
of_inta (Pos k) = numeral k;
of_inta Zero_int = zeroa;
of_inta (Neg k) = uminus (numeral k);

one_real :: Real;
one_real = Real_of_u (mau_of_rat one_rat);

instance Plus Real where {
  plus = plus_real;
};

instance Semigroup_add Real where {
};

instance Cancel_semigroup_add Real where {
};

instance Ab_semigroup_add Real where {
};

instance Minus Real where {
  minus = minus_real;
};

instance Cancel_ab_semigroup_add Real where {
};

instance Zero Real where {
  zeroa = zero_real;
};

instance Monoid_add Real where {
};

instance Comm_monoid_add Real where {
};

instance Cancel_comm_monoid_add Real where {
};

instance Mult_zero Real where {
};

instance Semigroup_mult Real where {
};

instance Semiring Real where {
};

instance Semiring_0 Real where {
};

instance Semiring_0_cancel Real where {
};

instance One Real where {
  onea = one_real;
};

instance Power Real where {
};

instance Monoid_mult Real where {
};

instance Numeral Real where {
};

instance Semiring_numeral Real where {
};

instance Zero_neq_one Real where {
};

instance Semiring_1 Real where {
};

instance Semiring_1_cancel Real where {
};

instance Uminus Real where {
  uminus = uminus_real;
};

instance Group_add Real where {
};

instance Neg_numeral Real where {
};

instance Ab_group_add Real where {
};

instance Ring Real where {
};

instance Ring_1 Real where {
};

real_lt :: Real -> Real -> Bool;
real_lt x y =
  let {
    fx = floor_real x;
    fy = floor_real y;
  } in (if less_int fx fy then True
         else (if less_int fy fx then False
                else real_lt
                       (times_real x
                         (of_inta
                           (Pos (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))))))
                       (times_real y
                         (of_inta
                           (Pos (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))))))));

ma_ge_0 :: Mini_alg -> Bool;
ma_ge_0 xa =
  let {
    (p, (q, b)) = rep_mini_alg xa;
    bqq = times_rat (times_rat (of_nat b) q) q;
    pp = times_rat p p;
  } in less_eq_rat zero_rat p && less_eq_rat bqq pp ||
         less_eq_rat zero_rat q && less_eq_rat pp bqq;

mau_ge_0 :: Mini_alg_unique -> Bool;
mau_ge_0 xa = ma_ge_0 (rep_mini_alg_unique xa);

ge_0 :: Real -> Bool;
ge_0 (Real_of_u x) = mau_ge_0 x;

less_real :: Real -> Real -> Bool;
less_real (Real_of_u x) (Real_of_u y) =
  not (equal_real (Real_of_u x) (Real_of_u y)) &&
    (if mau_compatible x y then ge_0 (minus_real (Real_of_u y) (Real_of_u x))
      else real_lt (Real_of_u x) (Real_of_u y));

abs_real :: Real -> Real;
abs_real a = (if less_real a zero_real then uminus_real a else a);

instance Abs Real where {
  absa = abs_real;
};

of_rat :: forall a. (Field_char_0 a) => Rat -> a;
of_rat p =
  let {
    a = quotient_of p;
    (aa, b) = a;
  } in divide (of_inta aa) (of_inta b);

ma_inverse :: Mini_alg -> Mini_alg;
ma_inverse xa =
  Abs_mini_alg
    (let {
       (p, (q, b)) = rep_mini_alg xa;
       d = inverse_rat
             (minus_rat (times_rat p p) (times_rat (times_rat (of_nat b) q) q));
     } in ma_normalize (times_rat p d, (times_rat (uminus_rat q) d, b)));

mau_inverse :: Mini_alg_unique -> Mini_alg_unique;
mau_inverse xa = Abs_mini_alg_unique (ma_inverse (rep_mini_alg_unique xa));

inverse_real :: Real -> Real;
inverse_real (Real_of_u r) = Real_of_u (mau_inverse r);

divide_real :: Real -> Real -> Real;
divide_real x y = times_real x (inverse_real y);

instance Semiring_char_0 Real where {
};

instance Ring_char_0 Real where {
};

instance Semiring_no_zero_divisors Real where {
};

instance Ring_no_zero_divisors Real where {
};

instance Ring_1_no_zero_divisors Real where {
};

instance Inverse Real where {
  inverse = inverse_real;
  divide = divide_real;
};

instance Division_ring Real where {
};

instance Ab_semigroup_mult Real where {
};

instance Comm_semiring Real where {
};

instance Comm_semiring_0 Real where {
};

instance Comm_semiring_0_cancel Real where {
};

instance Comm_monoid_mult Real where {
};

instance Comm_semiring_1 Real where {
};

instance Comm_semiring_1_cancel Real where {
};

instance Comm_semiring_1_cancel_crossproduct Real where {
};

instance Comm_semiring_1_diff_distrib Real where {
};

instance Comm_ring Real where {
};

instance Comm_ring_1 Real where {
};

instance Semidom Real where {
};

instance Idom Real where {
};

instance Field Real where {
};

instance Field_char_0 Real where {
};

sgn_real :: Real -> Real;
sgn_real a =
  (if equal_real a zero_real then zero_real
    else (if less_real zero_real a then one_real
           else of_rat (uminus_rat one_rat)));

instance Sgn Real where {
  sgn = sgn_real;
};

less_eq_real :: Real -> Real -> Bool;
less_eq_real (Real_of_u x) (Real_of_u y) =
  equal_real (Real_of_u x) (Real_of_u y) ||
    (if mau_compatible x y then ge_0 (minus_real (Real_of_u y) (Real_of_u x))
      else real_lt (Real_of_u x) (Real_of_u y));

instance Ord Real where {
  less_eq = less_eq_real;
  less = less_real;
};

instance Abs_if Real where {
};

instance Sgn_if Real where {
};

instance Preorder Real where {
};

instance Order Real where {
};

instance No_bot Real where {
};

instance No_top Real where {
};

ceq_real :: Maybe (Real -> Real -> Bool);
ceq_real = Just equal_real;

instance Ceq Real where {
  ceq = ceq_real;
};

set_impl_real :: Phantom Real Set_impla;
set_impl_real = Phantom Set_RBT;

instance Set_impl Real where {
  set_impl = set_impl_real;
};

instance Linorder Real where {
};

instance Ordered_ab_semigroup_add Real where {
};

instance Ordered_semiring Real where {
};

instance Ordered_cancel_semiring Real where {
};

instance Ordered_cancel_ab_semigroup_add Real where {
};

instance Ordered_ab_semigroup_add_imp_le Real where {
};

instance Ordered_comm_monoid_add Real where {
};

instance Ordered_ab_group_add Real where {
};

instance Ordered_ring Real where {
};

cEnum_real :: Maybe ([Real], ((Real -> Bool) -> Bool, (Real -> Bool) -> Bool));
cEnum_real = Nothing;

instance Cenum Real where {
  cEnum = cEnum_real;
};

instance Dense_order Real where {
};

instance Linordered_ab_semigroup_add Real where {
};

instance Linordered_cancel_ab_semigroup_add Real where {
};

instance Linordered_semiring Real where {
};

instance Linordered_semiring_strict Real where {
};

instance Linordered_semiring_1 Real where {
};

instance Linordered_semiring_1_strict Real where {
};

instance Ordered_ab_group_add_abs Real where {
};

instance Linordered_ab_group_add Real where {
};

instance Linordered_ring Real where {
};

instance Linordered_ring_strict Real where {
};

instance Ordered_comm_semiring Real where {
};

instance Ordered_cancel_comm_semiring Real where {
};

instance Linordered_comm_semiring_strict Real where {
};

instance Linordered_semidom Real where {
};

instance Ordered_comm_ring Real where {
};

instance Ordered_ring_abs Real where {
};

instance Linordered_idom Real where {
};

instance Non_strict_order Real where {
};

instance Ordered_ab_semigroup Real where {
};

instance Ordered_semiring_0 Real where {
};

instance Ordered_semiring_1 Real where {
};

instance Poly_carrier Real where {
};

instance Dense_linorder Real where {
};

instance Unbounded_dense_linorder Real where {
};

instance Linordered_field Real where {
};

compare_real :: Real -> Real -> Ordera;
compare_real = comparator_of;

ccompare_real :: Maybe (Real -> Real -> Ordera);
ccompare_real = Just compare_real;

instance Ccompare Real where {
  ccompare = ccompare_real;
};

instance Archimedean_field Real where {
};

instance Large_ordered_semiring_1 Real where {
};

instance Floor_ceiling Real where {
  floor = floor_real;
};

data Term a b = Var b | Fun a [Term a b];

data Ctxt a b = Hole | More a [Term a b] (Ctxt a b) [Term a b];

instance (Eq a, Eq b) => Eq (Term a b) where {
  a == b = equal_term a b;
};

equal_term :: forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Bool;
equal_term (Var x1) (Fun x21 x22) = False;
equal_term (Fun x21 x22) (Var x1) = False;
equal_term (Fun x21 x22) (Fun y21 y22) = x21 == y21 && x22 == y22;
equal_term (Var x1) (Var y1) = x1 == y1;

equal_ctxt :: forall a b. (Eq a, Eq b) => Ctxt a b -> Ctxt a b -> Bool;
equal_ctxt Hole (More x21 x22 x23 x24) = False;
equal_ctxt (More x21 x22 x23 x24) Hole = False;
equal_ctxt (More x21 x22 x23 x24) (More y21 y22 y23 y24) =
  x21 == y21 && x22 == y22 && equal_ctxt x23 y23 && x24 == y24;
equal_ctxt Hole Hole = True;

instance (Eq a, Eq b) => Eq (Ctxt a b) where {
  a == b = equal_ctxt a b;
};

ceq_ctxt :: forall a b. (Eq a, Eq b) => Maybe (Ctxt a b -> Ctxt a b -> Bool);
ceq_ctxt = Just equal_ctxt;

instance (Eq a, Eq b) => Ceq (Ctxt a b) where {
  ceq = ceq_ctxt;
};

set_impl_ctxt :: forall a b. Phantom (Ctxt a b) Set_impla;
set_impl_ctxt = Phantom Set_RBT;

instance Set_impl (Ctxt a b) where {
  set_impl = set_impl_ctxt;
};

comparator_term ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Term a b -> Term a b -> Ordera;
comparator_term comp_f comp_v (Fun x xa) (Fun ya yb) =
  (case comp_f x ya of {
    Eqa -> comparator_list (comparator_term comp_f comp_v) xa yb;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_term comp_f comp_v (Fun x xa) (Var y) = Gt;
comparator_term comp_f comp_v (Var x) (Fun ya yb) = Lt;
comparator_term comp_f comp_v (Var x) (Var y) = comp_v x y;

comparator_ctxt ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Ctxt a b -> Ctxt a b -> Ordera;
comparator_ctxt comp_f comp_v (More x xa xb xc) (More y ya yb yc) =
  (case comp_f x y of {
    Eqa ->
      (case comparator_list (comparator_term comp_f comp_v) xa ya of {
        Eqa ->
          (case comparator_ctxt comp_f comp_v xb yb of {
            Eqa -> comparator_list (comparator_term comp_f comp_v) xc yc;
            Lt -> Lt;
            Gt -> Gt;
          });
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_ctxt comp_f comp_v (More x xa xb xc) Hole = Gt;
comparator_ctxt comp_f comp_v Hole (More y ya yb yc) = Lt;
comparator_ctxt comp_f comp_v Hole Hole = Eqa;

compare_ctxt ::
  forall a b. (Compare a, Compare b) => Ctxt a b -> Ctxt a b -> Ordera;
compare_ctxt = comparator_ctxt compare compare;

ccompare_ctxt ::
  forall a b. (Compare a, Compare b) => Maybe (Ctxt a b -> Ctxt a b -> Ordera);
ccompare_ctxt = Just compare_ctxt;

instance (Compare a, Compare b) => Ccompare (Ctxt a b) where {
  ccompare = ccompare_ctxt;
};

shows_term ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Term a b -> [Prelude.Char] -> [Prelude.Char];
shows_term fun var (Var x) = var x;
shows_term fun var (Fun f ts) =
  fun f . shows_list_gen id [] "(" ", " ")" (map (shows_term fun var) ts);

shows_prec_term ::
  forall a b.
    (Showa a, Showa b) => Nat -> Term a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_term d t = shows_term (shows_prec Zero_nat) (shows_prec Zero_nat) t;

shows_list_term ::
  forall a b.
    (Showa a, Showa b) => [Term a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_term ts = showsp_list shows_prec_term Zero_nat ts;

instance (Showa a, Showa b) => Showa (Term a b) where {
  shows_prec = shows_prec_term;
  shows_list = shows_list_term;
};

compare_term ::
  forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Ordera;
compare_term = comparator_term compare compare;

less_eq_term ::
  forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Bool;
less_eq_term = le_of_comp compare_term;

less_term :: forall a b. (Compare a, Compare b) => Term a b -> Term a b -> Bool;
less_term = lt_of_comp compare_term;

instance (Compare a, Compare b) => Ord (Term a b) where {
  less_eq = less_eq_term;
  less = less_term;
};

instance (Compare a, Compare b) => Preorder (Term a b) where {
};

instance (Compare a, Compare b) => Order (Term a b) where {
};

instance (Compare a, Compare b) => Linorder (Term a b) where {
};

instance (Compare a, Compare b) => Compare (Term a b) where {
  compare = compare_term;
};

instance (Compare a, Compare b) => Compare_order (Term a b) where {
};

instance (Key a, Key b) => Key (Term a b) where {
};

ceq_term :: forall a b. (Eq a, Eq b) => Maybe (Term a b -> Term a b -> Bool);
ceq_term = Just equal_term;

instance (Eq a, Eq b) => Ceq (Term a b) where {
  ceq = ceq_term;
};

set_impl_term :: forall a b. Phantom (Term a b) Set_impla;
set_impl_term = Phantom Set_RBT;

instance Set_impl (Term a b) where {
  set_impl = set_impl_term;
};

cEnum_term ::
  forall a b.
    Maybe ([Term a b],
            ((Term a b -> Bool) -> Bool, (Term a b -> Bool) -> Bool));
cEnum_term = Nothing;

instance Cenum (Term a b) where {
  cEnum = cEnum_term;
};

ccompare_term ::
  forall a b. (Compare a, Compare b) => Maybe (Term a b -> Term a b -> Ordera);
ccompare_term = Just compare_term;

instance (Compare a, Compare b) => Ccompare (Term a b) where {
  ccompare = ccompare_term;
};

instance Ord Prelude.Char where {
  less_eq = (\ a b -> a <= b);
  less = (\ a b -> a < b);
};

instance Preorder Prelude.Char where {
};

instance Order Prelude.Char where {
};

instance Linorder Prelude.Char where {
};

compare_char :: Prelude.Char -> Prelude.Char -> Ordera;
compare_char = comparator_of;

instance Compare Prelude.Char where {
  compare = compare_char;
};

instance Compare_order Prelude.Char where {
};

instance Key Prelude.Char where {
};

ceq_char :: Maybe (Prelude.Char -> Prelude.Char -> Bool);
ceq_char = Just (\ a b -> a == b);

instance Ceq Prelude.Char where {
  ceq = ceq_char;
};

instance Countable Prelude.Char where {
};

ccompare_char :: Maybe (Prelude.Char -> Prelude.Char -> Ordera);
ccompare_char = Just compare_char;

instance Ccompare Prelude.Char where {
  ccompare = ccompare_char;
};

data Pos = Empty | PCons Nat Pos;

equal_pos :: Pos -> Pos -> Bool;
equal_pos Empty (PCons x21 x22) = False;
equal_pos (PCons x21 x22) Empty = False;
equal_pos (PCons x21 x22) (PCons y21 y22) =
  equal_nat x21 y21 && equal_pos x22 y22;
equal_pos Empty Empty = True;

instance Eq Pos where {
  a == b = equal_pos a b;
};

one_pos :: Pos;
one_pos = Empty;

instance One Pos where {
  onea = one_pos;
};

append :: Pos -> Pos -> Pos;
append Empty q = q;
append (PCons i p) q = PCons i (append p q);

times_pos :: Pos -> Pos -> Pos;
times_pos p q = append p q;

instance Times Pos where {
  times = times_pos;
};

instance Power Pos where {
};

ceq_pos :: Maybe (Pos -> Pos -> Bool);
ceq_pos = Just equal_pos;

instance Ceq Pos where {
  ceq = ceq_pos;
};

set_impl_pos :: Phantom Pos Set_impla;
set_impl_pos = Phantom Set_RBT;

instance Set_impl Pos where {
  set_impl = set_impl_pos;
};

cEnum_pos :: Maybe ([Pos], ((Pos -> Bool) -> Bool, (Pos -> Bool) -> Bool));
cEnum_pos = Nothing;

instance Cenum Pos where {
  cEnum = cEnum_pos;
};

finite_UNIV_pos :: Phantom Pos Bool;
finite_UNIV_pos = Phantom False;

instance Finite_UNIV Pos where {
  finite_UNIV = finite_UNIV_pos;
};

comparator_pos :: Pos -> Pos -> Ordera;
comparator_pos (PCons x xa) (PCons y ya) =
  (case comparator_of x y of {
    Eqa -> comparator_pos xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_pos (PCons x xa) Empty = Gt;
comparator_pos Empty (PCons y ya) = Lt;
comparator_pos Empty Empty = Eqa;

compare_pos :: Pos -> Pos -> Ordera;
compare_pos = comparator_pos;

ccompare_pos :: Maybe (Pos -> Pos -> Ordera);
ccompare_pos = Just compare_pos;

instance Ccompare Pos where {
  ccompare = ccompare_pos;
};

cproper_interval_pos :: Maybe Pos -> Maybe Pos -> Bool;
cproper_interval_pos = (\ _ _ -> False);

instance Cproper_interval Pos where {
  cproper_interval = cproper_interval_pos;
};

data Sum a b = Inl a | Inr b;

equal_sum :: forall a b. (Eq a, Eq b) => Sum a b -> Sum a b -> Bool;
equal_sum (Inl x1) (Inr x2) = False;
equal_sum (Inr x2) (Inl x1) = False;
equal_sum (Inr x2) (Inr y2) = x2 == y2;
equal_sum (Inl x1) (Inl y1) = x1 == y1;

instance (Eq a, Eq b) => Eq (Sum a b) where {
  a == b = equal_sum a b;
};

data Lab a b = Lab (Lab a b) b | FunLab (Lab a b) [Lab a b] | UnLab a
  | Sharp (Lab a b);

instance (Eq a, Eq b) => Eq (Lab a b) where {
  a == b = equal_lab a b;
};

equal_lab :: forall a b. (Eq a, Eq b) => Lab a b -> Lab a b -> Bool;
equal_lab (UnLab x3) (Sharp x4) = False;
equal_lab (Sharp x4) (UnLab x3) = False;
equal_lab (FunLab x21 x22) (Sharp x4) = False;
equal_lab (Sharp x4) (FunLab x21 x22) = False;
equal_lab (FunLab x21 x22) (UnLab x3) = False;
equal_lab (UnLab x3) (FunLab x21 x22) = False;
equal_lab (Lab x11 x12) (Sharp x4) = False;
equal_lab (Sharp x4) (Lab x11 x12) = False;
equal_lab (Lab x11 x12) (UnLab x3) = False;
equal_lab (UnLab x3) (Lab x11 x12) = False;
equal_lab (Lab x11 x12) (FunLab x21 x22) = False;
equal_lab (FunLab x21 x22) (Lab x11 x12) = False;
equal_lab (Sharp x4) (Sharp y4) = equal_lab x4 y4;
equal_lab (UnLab x3) (UnLab y3) = x3 == y3;
equal_lab (FunLab x21 x22) (FunLab y21 y22) = equal_lab x21 y21 && x22 == y22;
equal_lab (Lab x11 x12) (Lab y11 y12) = equal_lab x11 y11 && x12 == y12;

shows_lab ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Lab a b -> [Prelude.Char] -> [Prelude.Char];
shows_lab fun lab (UnLab f) = fun f;
shows_lab fun lab (Lab f l) =
  shows_lab fun lab f . shows_string "[" . lab l . shows_string "]";
shows_lab fun lab (Sharp f) = shows_lab fun lab f . shows_string "#";
shows_lab fun lab (FunLab f l) =
  shows_lab fun lab f .
    shows_string "[" .
      shows_list_gen (shows_lab fun lab) [] [] [] [] l . shows_string "]";

shows_prec_lab ::
  forall a b.
    (Showa a, Showa b) => Nat -> Lab a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_lab d l = shows_lab (shows_prec Zero_nat) (shows_prec Zero_nat) l;

shows_list_lab ::
  forall a b.
    (Showa a, Showa b) => [Lab a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_lab fs = showsp_list shows_prec_lab Zero_nat fs;

instance (Showa a, Showa b) => Showa (Lab a b) where {
  shows_prec = shows_prec_lab;
  shows_list = shows_list_lab;
};

default_lab :: forall a b. (Default a) => Lab a b;
default_lab = UnLab defaulta;

instance (Default a) => Default (Lab a b) where {
  defaulta = default_lab;
};

comparator_lab ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Lab a b -> Lab a b -> Ordera;
comparator_lab comp_f comp_l (Sharp x) (Sharp ye) =
  comparator_lab comp_f comp_l x ye;
comparator_lab comp_f comp_l (Sharp x) (UnLab yd) = Gt;
comparator_lab comp_f comp_l (Sharp x) (FunLab yb yc) = Gt;
comparator_lab comp_f comp_l (Sharp x) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (UnLab x) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (UnLab x) (UnLab yd) = comp_f x yd;
comparator_lab comp_f comp_l (UnLab x) (FunLab yb yc) = Gt;
comparator_lab comp_f comp_l (UnLab x) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (FunLab x xa) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (FunLab x xa) (UnLab yd) = Lt;
comparator_lab comp_f comp_l (FunLab x xa) (FunLab yb yc) =
  (case comparator_lab comp_f comp_l x yb of {
    Eqa -> comparator_list (comparator_lab comp_f comp_l) xa yc;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_lab comp_f comp_l (FunLab x xa) (Lab y ya) = Gt;
comparator_lab comp_f comp_l (Lab x xa) (Sharp ye) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (UnLab yd) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (FunLab yb yc) = Lt;
comparator_lab comp_f comp_l (Lab x xa) (Lab y ya) =
  (case comparator_lab comp_f comp_l x y of {
    Eqa -> comp_l xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });

compare_lab ::
  forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Ordera;
compare_lab = comparator_lab compare compare;

less_eq_lab :: forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Bool;
less_eq_lab = le_of_comp compare_lab;

less_lab :: forall a b. (Compare a, Compare b) => Lab a b -> Lab a b -> Bool;
less_lab = lt_of_comp compare_lab;

instance (Compare a, Compare b) => Ord (Lab a b) where {
  less_eq = less_eq_lab;
  less = less_lab;
};

instance (Compare a, Compare b) => Preorder (Lab a b) where {
};

instance (Compare a, Compare b) => Order (Lab a b) where {
};

instance (Compare a, Compare b) => Linorder (Lab a b) where {
};

instance (Compare a, Compare b) => Compare (Lab a b) where {
  compare = compare_lab;
};

instance (Compare a, Compare b) => Compare_order (Lab a b) where {
};

instance (Key a, Key b) => Key (Lab a b) where {
};

ceq_lab :: forall a b. (Eq a, Eq b) => Maybe (Lab a b -> Lab a b -> Bool);
ceq_lab = Just equal_lab;

instance (Eq a, Eq b) => Ceq (Lab a b) where {
  ceq = ceq_lab;
};

set_impl_lab :: forall a b. Phantom (Lab a b) Set_impla;
set_impl_lab = Phantom Set_RBT;

instance Set_impl (Lab a b) where {
  set_impl = set_impl_lab;
};

finite_UNIV_lab :: forall a b. Phantom (Lab a b) Bool;
finite_UNIV_lab = Phantom False;

card_UNIV_lab :: forall a b. Phantom (Lab a b) Nat;
card_UNIV_lab = Phantom Zero_nat;

instance Finite_UNIV (Lab a b) where {
  finite_UNIV = finite_UNIV_lab;
};

instance Card_UNIV (Lab a b) where {
  card_UNIVa = card_UNIV_lab;
};

cEnum_lab ::
  forall a b.
    Maybe ([Lab a b], ((Lab a b -> Bool) -> Bool, (Lab a b -> Bool) -> Bool));
cEnum_lab = Nothing;

instance Cenum (Lab a b) where {
  cEnum = cEnum_lab;
};

ccompare_lab ::
  forall a b. (Compare a, Compare b) => Maybe (Lab a b -> Lab a b -> Ordera);
ccompare_lab = Just compare_lab;

instance (Compare a, Compare b) => Ccompare (Lab a b) where {
  ccompare = ccompare_lab;
};

mapping_impl_lab :: forall a b. Phantom (Lab a b) Mapping_impla;
mapping_impl_lab = Phantom Mapping_RBT;

instance Mapping_impl (Lab a b) where {
  mapping_impl = mapping_impl_lab;
};

cproper_interval_lab ::
  forall a b.
    (Compare a, Compare b) => Maybe (Lab a b) -> Maybe (Lab a b) -> Bool;
cproper_interval_lab = (\ _ _ -> False);

instance (Compare a, Compare b) => Cproper_interval (Lab a b) where {
  cproper_interval = cproper_interval_lab;
};

equality_option :: forall a. (a -> a -> Bool) -> Maybe a -> Maybe a -> Bool;
equality_option eq_a (Just x) (Just y) = eq_a x y;
equality_option eq_a (Just x) Nothing = False;
equality_option eq_a Nothing (Just y) = False;
equality_option eq_a Nothing Nothing = True;

ceq_option :: forall a. (Ceq a) => Maybe (Maybe a -> Maybe a -> Bool);
ceq_option =
  (case ceq of {
    Nothing -> Nothing;
    Just eq_a -> Just (equality_option eq_a);
  });

instance (Ceq a) => Ceq (Maybe a) where {
  ceq = ceq_option;
};

set_impl_option :: forall a. (Set_impl a) => Phantom (Maybe a) Set_impla;
set_impl_option = Phantom (of_phantom (set_impl :: Phantom a Set_impla));

instance (Set_impl a) => Set_impl (Maybe a) where {
  set_impl = set_impl_option;
};

cEnum_option ::
  forall a.
    (Cenum a) => Maybe ([Maybe a],
                         ((Maybe a -> Bool) -> Bool,
                           (Maybe a -> Bool) -> Bool));
cEnum_option =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (enum_all_a, enum_ex_a)) ->
      Just (Nothing : map Just enum_a,
             ((\ p -> p Nothing && enum_all_a (\ x -> p (Just x))),
               (\ p -> p Nothing || enum_ex_a (\ x -> p (Just x)))));
  });

instance (Cenum a) => Cenum (Maybe a) where {
  cEnum = cEnum_option;
};

finite_UNIV_option :: forall a. (Finite_UNIV a) => Phantom (Maybe a) Bool;
finite_UNIV_option = Phantom (of_phantom (finite_UNIV :: Phantom a Bool));

instance (Finite_UNIV a) => Finite_UNIV (Maybe a) where {
  finite_UNIV = finite_UNIV_option;
};

comparator_option ::
  forall a. (a -> a -> Ordera) -> Maybe a -> Maybe a -> Ordera;
comparator_option comp_a (Just x) (Just y) = comp_a x y;
comparator_option comp_a (Just x) Nothing = Gt;
comparator_option comp_a Nothing (Just y) = Lt;
comparator_option comp_a Nothing Nothing = Eqa;

ccompare_option ::
  forall a. (Ccompare a) => Maybe (Maybe a -> Maybe a -> Ordera);
ccompare_option =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_a -> Just (comparator_option comp_a);
  });

instance (Ccompare a) => Ccompare (Maybe a) where {
  ccompare = ccompare_option;
};

mapping_impl_option ::
  forall a. (Mapping_impl a) => Phantom (Maybe a) Mapping_impla;
mapping_impl_option =
  Phantom (of_phantom (mapping_impl :: Phantom a Mapping_impla));

instance (Mapping_impl a) => Mapping_impl (Maybe a) where {
  mapping_impl = mapping_impl_option;
};

cproper_interval_option ::
  forall a. (Cproper_interval a) => Maybe (Maybe a) -> Maybe (Maybe a) -> Bool;
cproper_interval_option Nothing Nothing = True;
cproper_interval_option Nothing (Just x) = not (is_none x);
cproper_interval_option (Just x) Nothing = cproper_interval x Nothing;
cproper_interval_option (Just x) (Just Nothing) = False;
cproper_interval_option (Just x) (Just (Just y)) = cproper_interval x (Just y);

instance (Cproper_interval a) => Cproper_interval (Maybe a) where {
  cproper_interval = cproper_interval_option;
};

newtype Alist b a = Alist [(b, a)];

newtype Multiset a = Bag (Alist a Nat);

map_of :: forall a b. (Eq a) => [(a, b)] -> a -> Maybe b;
map_of ((l, v) : ps) k = (if l == k then Just v else map_of ps k);
map_of [] k = Nothing;

count_of :: forall a. (Eq a) => [(a, Nat)] -> a -> Nat;
count_of xs x = (case map_of xs x of {
                  Nothing -> Zero_nat;
                  Just n -> n;
                });

impl_ofa :: forall b a. Alist b a -> [(b, a)];
impl_ofa (Alist x) = x;

count :: forall a. (Eq a) => Multiset a -> a -> Nat;
count (Bag xs) = count_of (impl_ofa xs);

less_eq_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Bool;
less_eq_multiset (Bag xs) a =
  all (\ (x, n) -> less_eq_nat n (count a x)) (impl_ofa xs);

equal_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Bool;
equal_multiset m1 m2 = less_eq_multiset m1 m2 && less_eq_multiset m2 m1;

instance (Eq a) => Eq (Multiset a) where {
  a == b = equal_multiset a b;
};

showsp_prod ::
  forall a b.
    (Nat -> a -> [Prelude.Char] -> [Prelude.Char]) ->
      (Nat -> b -> [Prelude.Char] -> [Prelude.Char]) ->
        Nat -> (a, b) -> [Prelude.Char] -> [Prelude.Char];
showsp_prod s1 s2 p (x, y) =
  (((shows_string "(" . s1 Zero_nat x) . shows_string ", ") . s2 Zero_nat y) .
    shows_string ")";

shows_prec_prod ::
  forall a b.
    (Showa a, Showa b) => Nat -> (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_prec_prod = showsp_prod shows_prec shows_prec;

shows_list_prod ::
  forall a b.
    (Showa a, Showa b) => [(a, b)] -> [Prelude.Char] -> [Prelude.Char];
shows_list_prod = showsp_list shows_prec_prod Zero_nat;

instance (Showa a, Showa b) => Showa (a, b) where {
  shows_prec = shows_prec_prod;
  shows_list = shows_list_prod;
};

less_eq_prod :: forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Bool;
less_eq_prod (x1, y1) (x2, y2) = less x1 x2 || less_eq x1 x2 && less_eq y1 y2;

less_prod :: forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Bool;
less_prod (x1, y1) (x2, y2) = less x1 x2 || less_eq x1 x2 && less y1 y2;

instance (Ord a, Ord b) => Ord (a, b) where {
  less_eq = less_eq_prod;
  less = less_prod;
};

comparator_prod ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> (a, b) -> (a, b) -> Ordera;
comparator_prod comp_a comp_b (x, xa) (y, ya) =
  (case comp_a x y of {
    Eqa -> comp_b xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });

compare_prod ::
  forall a b. (Compare a, Compare b) => (a, b) -> (a, b) -> Ordera;
compare_prod = comparator_prod compare compare;

instance (Preorder a, Preorder b) => Preorder (a, b) where {
};

instance (Order a, Order b) => Order (a, b) where {
};

instance (Linorder a, Linorder b) => Linorder (a, b) where {
};

instance (Compare a, Compare b) => Compare (a, b) where {
  compare = compare_prod;
};

instance (Compare_order a, Compare_order b) => Compare_order (a, b) where {
};

instance (Key a, Key b) => Key (a, b) where {
};

equality_prod ::
  forall a b. (a -> a -> Bool) -> (b -> b -> Bool) -> (a, b) -> (a, b) -> Bool;
equality_prod eq_a eq_b (x, xa) (y, ya) = eq_a x y && eq_b xa ya;

ceq_prod :: forall a b. (Ceq a, Ceq b) => Maybe ((a, b) -> (a, b) -> Bool);
ceq_prod =
  (case ceq of {
    Nothing -> Nothing;
    Just eq_a ->
      (case ceq of {
        Nothing -> Nothing;
        Just eq_b -> Just (equality_prod eq_a eq_b);
      });
  });

instance (Ceq a, Ceq b) => Ceq (a, b) where {
  ceq = ceq_prod;
};

set_impl_choose2 :: Set_impla -> Set_impla -> Set_impla;
set_impl_choose2 Set_Monada Set_Monada = Set_Monada;
set_impl_choose2 Set_RBT Set_RBT = Set_RBT;
set_impl_choose2 Set_DList Set_DList = Set_DList;
set_impl_choose2 Set_Collect Set_Collect = Set_Collect;
set_impl_choose2 x y = Set_Choose;

set_impl_prod ::
  forall a b. (Set_impl a, Set_impl b) => Phantom (a, b) Set_impla;
set_impl_prod =
  Phantom
    (set_impl_choose2 (of_phantom (set_impl :: Phantom a Set_impla))
      (of_phantom (set_impl :: Phantom b Set_impla)));

instance (Set_impl a, Set_impl b) => Set_impl (a, b) where {
  set_impl = set_impl_prod;
};

finite_UNIV_prod ::
  forall a b. (Finite_UNIV a, Finite_UNIV b) => Phantom (a, b) Bool;
finite_UNIV_prod =
  Phantom
    (of_phantom (finite_UNIV :: Phantom a Bool) &&
      of_phantom (finite_UNIV :: Phantom b Bool));

card_UNIV_prod :: forall a b. (Card_UNIV a, Card_UNIV b) => Phantom (a, b) Nat;
card_UNIV_prod =
  Phantom
    (times_nat (of_phantom (card_UNIVa :: Phantom a Nat))
      (of_phantom (card_UNIVa :: Phantom b Nat)));

instance (Finite_UNIV a, Finite_UNIV b) => Finite_UNIV (a, b) where {
  finite_UNIV = finite_UNIV_prod;
};

instance (Card_UNIV a, Card_UNIV b) => Card_UNIV (a, b) where {
  card_UNIVa = card_UNIV_prod;
};

product :: forall a b. [a] -> [b] -> [(a, b)];
product [] uu = [];
product (x : xs) ys = map (\ a -> (x, a)) ys ++ product xs ys;

cEnum_prod ::
  forall a b.
    (Cenum a,
      Cenum b) => Maybe ([(a, b)],
                          (((a, b) -> Bool) -> Bool, ((a, b) -> Bool) -> Bool));
cEnum_prod =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (enum_all_a, enum_ex_a)) ->
      (case cEnum of {
        Nothing -> Nothing;
        Just (enum_b, (enum_all_b, enum_ex_b)) ->
          Just (product enum_a enum_b,
                 ((\ p -> enum_all_a (\ x -> enum_all_b (\ y -> p (x, y)))),
                   (\ p -> enum_ex_a (\ x -> enum_ex_b (\ y -> p (x, y))))));
      });
  });

instance (Cenum a, Cenum b) => Cenum (a, b) where {
  cEnum = cEnum_prod;
};

ccompare_prod ::
  forall a b. (Ccompare a, Ccompare b) => Maybe ((a, b) -> (a, b) -> Ordera);
ccompare_prod =
  (case ccompare of {
    Nothing -> Nothing;
    Just comp_a ->
      (case ccompare of {
        Nothing -> Nothing;
        Just comp_b -> Just (comparator_prod comp_a comp_b);
      });
  });

instance (Ccompare a, Ccompare b) => Ccompare (a, b) where {
  ccompare = ccompare_prod;
};

mapping_impl_choose2 :: Mapping_impla -> Mapping_impla -> Mapping_impla;
mapping_impl_choose2 Mapping_RBT Mapping_RBT = Mapping_RBT;
mapping_impl_choose2 Mapping_Assoc_List Mapping_Assoc_List = Mapping_Assoc_List;
mapping_impl_choose2 Mapping_Mapping Mapping_Mapping = Mapping_Mapping;
mapping_impl_choose2 x y = Mapping_Choose;

mapping_impl_prod ::
  forall a b. (Mapping_impl a, Mapping_impl b) => Phantom (a, b) Mapping_impla;
mapping_impl_prod =
  Phantom
    (mapping_impl_choose2 (of_phantom (mapping_impl :: Phantom a Mapping_impla))
      (of_phantom (mapping_impl :: Phantom b Mapping_impla)));

instance (Mapping_impl a, Mapping_impl b) => Mapping_impl (a, b) where {
  mapping_impl = mapping_impl_prod;
};

cproper_interval_prod ::
  forall a b.
    (Cproper_interval a,
      Cproper_interval b) => Maybe (a, b) -> Maybe (a, b) -> Bool;
cproper_interval_prod Nothing Nothing = True;
cproper_interval_prod Nothing (Just (y1, y2)) =
  cproper_interval Nothing (Just y1) || cproper_interval Nothing (Just y2);
cproper_interval_prod (Just (x1, x2)) Nothing =
  cproper_interval (Just x1) Nothing || cproper_interval (Just x2) Nothing;
cproper_interval_prod (Just (x1, x2)) (Just (y1, y2)) =
  cproper_interval (Just x1) (Just y1) ||
    (lt_of_comp (the ccompare) x1 y1 &&
       (cproper_interval (Just x2) Nothing ||
         cproper_interval Nothing (Just y2)) ||
      not (lt_of_comp (the ccompare) y1 x1) &&
        cproper_interval (Just x2) (Just y2));

instance (Cproper_interval a,
           Cproper_interval b) => Cproper_interval (a, b) where {
  cproper_interval = cproper_interval_prod;
};

data Gctxt a b = GCHole | GCFun a [Gctxt a b];

instance (Eq a) => Eq (Gctxt a b) where {
  a == b = equal_gctxt a b;
};

equal_gctxt :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Bool;
equal_gctxt GCHole (GCFun x21 x22) = False;
equal_gctxt (GCFun x21 x22) GCHole = False;
equal_gctxt (GCFun x21 x22) (GCFun y21 y22) = x21 == y21 && x22 == y22;
equal_gctxt GCHole GCHole = True;

ceq_gctxt :: forall a b. (Eq a) => Maybe (Gctxt a b -> Gctxt a b -> Bool);
ceq_gctxt = Just equal_gctxt;

instance (Eq a) => Ceq (Gctxt a b) where {
  ceq = ceq_gctxt;
};

set_impl_gctxt :: forall a b. Phantom (Gctxt a b) Set_impla;
set_impl_gctxt = Phantom Set_RBT;

instance Set_impl (Gctxt a b) where {
  set_impl = set_impl_gctxt;
};

comparator_gctxt ::
  forall a b. (a -> a -> Ordera) -> Gctxt a b -> Gctxt a b -> Ordera;
comparator_gctxt comp_f (GCFun x xa) (GCFun y ya) =
  (case comp_f x y of {
    Eqa -> comparator_list (comparator_gctxt comp_f) xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_gctxt comp_f (GCFun x xa) GCHole = Gt;
comparator_gctxt comp_f GCHole (GCFun y ya) = Lt;
comparator_gctxt comp_f GCHole GCHole = Eqa;

compare_gctxt :: forall a b. (Compare a) => Gctxt a b -> Gctxt a b -> Ordera;
compare_gctxt = comparator_gctxt compare;

ccompare_gctxt ::
  forall a b.
    (Compare a, Compare b) => Maybe (Gctxt a b -> Gctxt a b -> Ordera);
ccompare_gctxt = Just compare_gctxt;

instance (Compare a, Compare b) => Ccompare (Gctxt a b) where {
  ccompare = ccompare_gctxt;
};

data Ta_rule a b = TA_rule b [a] a;

equal_ta_rule :: forall a b. (Eq a, Eq b) => Ta_rule a b -> Ta_rule a b -> Bool;
equal_ta_rule (TA_rule x1 x2 x3) (TA_rule y1 y2 y3) =
  x1 == y1 && x2 == y2 && x3 == y3;

instance (Eq a, Eq b) => Eq (Ta_rule a b) where {
  a == b = equal_ta_rule a b;
};

show_ta_rule ::
  forall a b.
    (Showa a, Showa b) => Ta_rule a b -> [Prelude.Char] -> [Prelude.Char];
show_ta_rule (TA_rule f qs q) =
  ((shows_prec Zero_nat f . shows_prec_list Zero_nat qs) .
    shows_prec_list Zero_nat " -> ") .
    shows_prec Zero_nat q;

shows_prec_ta_rule ::
  forall a b.
    (Showa a,
      Showa b) => Nat -> Ta_rule a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_ta_rule p r = show_ta_rule r;

shows_list_ta_rule ::
  forall a b.
    (Showa a, Showa b) => [Ta_rule a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_ta_rule ps = showsp_list shows_prec_ta_rule Zero_nat ps;

instance (Showa a, Showa b) => Showa (Ta_rule a b) where {
  shows_prec = shows_prec_ta_rule;
  shows_list = shows_list_ta_rule;
};

ceq_ta_rule ::
  forall a b. (Eq a, Eq b) => Maybe (Ta_rule a b -> Ta_rule a b -> Bool);
ceq_ta_rule = Just equal_ta_rule;

instance (Eq a, Eq b) => Ceq (Ta_rule a b) where {
  ceq = ceq_ta_rule;
};

set_impl_ta_rule :: forall a b. Phantom (Ta_rule a b) Set_impla;
set_impl_ta_rule = Phantom Set_RBT;

instance Set_impl (Ta_rule a b) where {
  set_impl = set_impl_ta_rule;
};

cEnum_ta_rule ::
  forall a b.
    Maybe ([Ta_rule a b],
            ((Ta_rule a b -> Bool) -> Bool, (Ta_rule a b -> Bool) -> Bool));
cEnum_ta_rule = Nothing;

instance Cenum (Ta_rule a b) where {
  cEnum = cEnum_ta_rule;
};

finite_UNIV_ta_rule :: forall a b. Phantom (Ta_rule a b) Bool;
finite_UNIV_ta_rule = Phantom False;

instance Finite_UNIV (Ta_rule a b) where {
  finite_UNIV = finite_UNIV_ta_rule;
};

comparator_ta_rule ::
  forall a b.
    (a -> a -> Ordera) ->
      (b -> b -> Ordera) -> Ta_rule a b -> Ta_rule a b -> Ordera;
comparator_ta_rule comp_q comp_f (TA_rule x xa xb) (TA_rule y ya yb) =
  (case comp_f x y of {
    Eqa ->
      (case comparator_list comp_q xa ya of {
        Eqa -> comp_q xb yb;
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });

compare_ta_rule ::
  forall a b. (Compare a, Compare b) => Ta_rule a b -> Ta_rule a b -> Ordera;
compare_ta_rule = comparator_ta_rule compare compare;

ccompare_ta_rule ::
  forall a b.
    (Compare a, Compare b) => Maybe (Ta_rule a b -> Ta_rule a b -> Ordera);
ccompare_ta_rule = Just compare_ta_rule;

instance (Compare a, Compare b) => Ccompare (Ta_rule a b) where {
  ccompare = ccompare_ta_rule;
};

cproper_interval_ta_rule ::
  forall a b.
    (Compare a,
      Compare b) => Maybe (Ta_rule a b) -> Maybe (Ta_rule a b) -> Bool;
cproper_interval_ta_rule = (\ _ _ -> False);

instance (Compare a, Compare b) => Cproper_interval (Ta_rule a b) where {
  cproper_interval = cproper_interval_ta_rule;
};

data Mctxt a b = MVar b | MHole | MFun a [Mctxt a b];

instance (Eq a, Eq b) => Eq (Mctxt a b) where {
  a == b = equal_mctxt a b;
};

equal_mctxt :: forall a b. (Eq a, Eq b) => Mctxt a b -> Mctxt a b -> Bool;
equal_mctxt MHole (MFun x31 x32) = False;
equal_mctxt (MFun x31 x32) MHole = False;
equal_mctxt (MVar x1) (MFun x31 x32) = False;
equal_mctxt (MFun x31 x32) (MVar x1) = False;
equal_mctxt (MVar x1) MHole = False;
equal_mctxt MHole (MVar x1) = False;
equal_mctxt (MFun x31 x32) (MFun y31 y32) = x31 == y31 && x32 == y32;
equal_mctxt (MVar x1) (MVar y1) = x1 == y1;
equal_mctxt MHole MHole = True;

ceq_mctxt :: forall a b. (Eq a, Eq b) => Maybe (Mctxt a b -> Mctxt a b -> Bool);
ceq_mctxt = Just equal_mctxt;

instance (Eq a, Eq b) => Ceq (Mctxt a b) where {
  ceq = ceq_mctxt;
};

set_impl_mctxt :: forall a b. Phantom (Mctxt a b) Set_impla;
set_impl_mctxt = Phantom Set_RBT;

instance Set_impl (Mctxt a b) where {
  set_impl = set_impl_mctxt;
};

comparator_mctxt ::
  forall a b.
    (a -> a -> Ordera) ->
      (b -> b -> Ordera) -> Mctxt a b -> Mctxt a b -> Ordera;
comparator_mctxt comp_f comp_v (MFun x xa) (MFun ya yb) =
  (case comp_f x ya of {
    Eqa -> comparator_list (comparator_mctxt comp_f comp_v) xa yb;
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_mctxt comp_f comp_v (MFun x xa) MHole = Gt;
comparator_mctxt comp_f comp_v (MFun x xa) (MVar y) = Gt;
comparator_mctxt comp_f comp_v MHole (MFun ya yb) = Lt;
comparator_mctxt comp_f comp_v MHole MHole = Eqa;
comparator_mctxt comp_f comp_v MHole (MVar y) = Gt;
comparator_mctxt comp_f comp_v (MVar x) (MFun ya yb) = Lt;
comparator_mctxt comp_f comp_v (MVar x) MHole = Lt;
comparator_mctxt comp_f comp_v (MVar x) (MVar y) = comp_v x y;

compare_mctxt ::
  forall a b. (Compare a, Compare b) => Mctxt a b -> Mctxt a b -> Ordera;
compare_mctxt = comparator_mctxt compare compare;

ccompare_mctxt ::
  forall a b.
    (Compare a, Compare b) => Maybe (Mctxt a b -> Mctxt a b -> Ordera);
ccompare_mctxt = Just compare_mctxt;

instance (Compare a, Compare b) => Ccompare (Mctxt a b) where {
  ccompare = ccompare_mctxt;
};

data Arctic = MinInfty | Num_arc Int;

equal_arctic :: Arctic -> Arctic -> Bool;
equal_arctic MinInfty (Num_arc x2) = False;
equal_arctic (Num_arc x2) MinInfty = False;
equal_arctic (Num_arc x2) (Num_arc y2) = equal_int x2 y2;
equal_arctic MinInfty MinInfty = True;

instance Eq Arctic where {
  a == b = equal_arctic a b;
};

shows_arctic :: Arctic -> [Prelude.Char] -> [Prelude.Char];
shows_arctic (Num_arc i) = shows_prec_int Zero_nat i;
shows_arctic MinInfty = shows_prec_list Zero_nat "-inf";

shows_prec_arctic :: Nat -> Arctic -> [Prelude.Char] -> [Prelude.Char];
shows_prec_arctic p ai = shows_arctic ai;

shows_list_arctic :: [Arctic] -> [Prelude.Char] -> [Prelude.Char];
shows_list_arctic asa = showsp_list shows_prec_arctic Zero_nat asa;

instance Showa Arctic where {
  shows_prec = shows_prec_arctic;
  shows_list = shows_list_arctic;
};

one_arctic :: Arctic;
one_arctic = Num_arc Zero_int;

instance One Arctic where {
  onea = one_arctic;
};

max :: forall a. (Ord a) => a -> a -> a;
max a b = (if less_eq a b then b else a);

plus_arctic :: Arctic -> Arctic -> Arctic;
plus_arctic MinInfty y = y;
plus_arctic (Num_arc v) MinInfty = Num_arc v;
plus_arctic (Num_arc x) (Num_arc y) = Num_arc (max x y);

instance Plus Arctic where {
  plus = plus_arctic;
};

zero_arctic :: Arctic;
zero_arctic = MinInfty;

instance Zero Arctic where {
  zeroa = zero_arctic;
};

instance Semigroup_add Arctic where {
};

instance Numeral Arctic where {
};

times_arctic :: Arctic -> Arctic -> Arctic;
times_arctic MinInfty y = MinInfty;
times_arctic (Num_arc v) MinInfty = MinInfty;
times_arctic (Num_arc x) (Num_arc y) = Num_arc (plus_int x y);

instance Times Arctic where {
  times = times_arctic;
};

instance Power Arctic where {
};

less_eq_arctic :: Arctic -> Arctic -> Bool;
less_eq_arctic MinInfty x = True;
less_eq_arctic (Num_arc uu) MinInfty = False;
less_eq_arctic (Num_arc y) (Num_arc x) = less_eq_int y x;

less_arctic :: Arctic -> Arctic -> Bool;
less_arctic MinInfty x = True;
less_arctic (Num_arc uu) MinInfty = False;
less_arctic (Num_arc y) (Num_arc x) = less_int y x;

instance Ord Arctic where {
  less_eq = less_eq_arctic;
  less = less_arctic;
};

instance Ab_semigroup_add Arctic where {
};

instance Semigroup_mult Arctic where {
};

instance Semiring Arctic where {
};

instance Mult_zero Arctic where {
};

instance Monoid_add Arctic where {
};

instance Comm_monoid_add Arctic where {
};

instance Semiring_0 Arctic where {
};

instance Monoid_mult Arctic where {
};

instance Semiring_numeral Arctic where {
};

instance Zero_neq_one Arctic where {
};

instance Semiring_1 Arctic where {
};

ceq_arctic :: Maybe (Arctic -> Arctic -> Bool);
ceq_arctic = Just equal_arctic;

instance Ceq Arctic where {
  ceq = ceq_arctic;
};

set_impl_arctic :: Phantom Arctic Set_impla;
set_impl_arctic = Phantom Set_RBT;

instance Set_impl Arctic where {
  set_impl = set_impl_arctic;
};

cEnum_arctic ::
  Maybe ([Arctic], ((Arctic -> Bool) -> Bool, (Arctic -> Bool) -> Bool));
cEnum_arctic = Nothing;

instance Cenum Arctic where {
  cEnum = cEnum_arctic;
};

comparator_arctic :: Arctic -> Arctic -> Ordera;
comparator_arctic (Num_arc x) (Num_arc y) = comparator_of x y;
comparator_arctic (Num_arc x) MinInfty = Gt;
comparator_arctic MinInfty (Num_arc y) = Lt;
comparator_arctic MinInfty MinInfty = Eqa;

compare_arctic :: Arctic -> Arctic -> Ordera;
compare_arctic = comparator_arctic;

ccompare_arctic :: Maybe (Arctic -> Arctic -> Ordera);
ccompare_arctic = Just compare_arctic;

instance Ccompare Arctic where {
  ccompare = ccompare_arctic;
};

instance Non_strict_order Arctic where {
};

instance Ordered_ab_semigroup Arctic where {
};

instance Ordered_semiring_0 Arctic where {
};

instance Ordered_semiring_1 Arctic where {
};

data Filtered a = FPair a Nat;

equal_filtered :: forall a. (Eq a) => Filtered a -> Filtered a -> Bool;
equal_filtered (FPair x1 x2) (FPair y1 y2) = x1 == y1 && equal_nat x2 y2;

instance (Eq a) => Eq (Filtered a) where {
  a == b = equal_filtered a b;
};

filtered_fun :: forall a. Filtered a -> a;
filtered_fun (FPair f n) = f;

shows_prec_filtered ::
  forall a. (Showa a) => Nat -> Filtered a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_filtered p f = shows_prec Zero_nat (filtered_fun f);

shows_list_filtered ::
  forall a. (Showa a) => [Filtered a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_filtered fs = showsp_list shows_prec_filtered Zero_nat fs;

instance (Showa a) => Showa (Filtered a) where {
  shows_prec = shows_prec_filtered;
  shows_list = shows_list_filtered;
};

comparator_filtered ::
  forall a. (a -> a -> Ordera) -> Filtered a -> Filtered a -> Ordera;
comparator_filtered comp_f (FPair x xa) (FPair y ya) =
  (case comp_f x y of {
    Eqa -> comparator_of xa ya;
    Lt -> Lt;
    Gt -> Gt;
  });

compare_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Ordera;
compare_filtered = comparator_filtered compare;

less_eq_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Bool;
less_eq_filtered = le_of_comp compare_filtered;

less_filtered :: forall a. (Compare a) => Filtered a -> Filtered a -> Bool;
less_filtered = lt_of_comp compare_filtered;

instance (Compare a) => Ord (Filtered a) where {
  less_eq = less_eq_filtered;
  less = less_filtered;
};

instance (Compare a) => Preorder (Filtered a) where {
};

instance (Compare a) => Order (Filtered a) where {
};

instance (Compare a) => Linorder (Filtered a) where {
};

instance (Compare a) => Compare (Filtered a) where {
  compare = compare_filtered;
};

instance (Compare a) => Compare_order (Filtered a) where {
};

instance (Key a) => Key (Filtered a) where {
};

data L_poly a b = LPoly b [(a, b)];

cEnum_l_poly ::
  forall a b.
    Maybe ([L_poly a b],
            ((L_poly a b -> Bool) -> Bool, (L_poly a b -> Bool) -> Bool));
cEnum_l_poly = Nothing;

instance Cenum (L_poly a b) where {
  cEnum = cEnum_l_poly;
};

data Location = H | A | Ba | Ra;

equal_location :: Location -> Location -> Bool;
equal_location Ba Ra = False;
equal_location Ra Ba = False;
equal_location A Ra = False;
equal_location Ra A = False;
equal_location A Ba = False;
equal_location Ba A = False;
equal_location H Ra = False;
equal_location Ra H = False;
equal_location H Ba = False;
equal_location Ba H = False;
equal_location H A = False;
equal_location A H = False;
equal_location Ra Ra = True;
equal_location Ba Ba = True;
equal_location A A = True;
equal_location H H = True;

instance Eq Location where {
  a == b = equal_location a b;
};

ceq_location :: Maybe (Location -> Location -> Bool);
ceq_location = Just equal_location;

instance Ceq Location where {
  ceq = ceq_location;
};

set_impl_location :: Phantom Location Set_impla;
set_impl_location = Phantom Set_RBT;

instance Set_impl Location where {
  set_impl = set_impl_location;
};

comparator_location :: Location -> Location -> Ordera;
comparator_location Ra Ra = Eqa;
comparator_location Ra Ba = Gt;
comparator_location Ra A = Gt;
comparator_location Ra H = Gt;
comparator_location Ba Ra = Lt;
comparator_location Ba Ba = Eqa;
comparator_location Ba A = Gt;
comparator_location Ba H = Gt;
comparator_location A Ra = Lt;
comparator_location A Ba = Lt;
comparator_location A A = Eqa;
comparator_location A H = Gt;
comparator_location H Ra = Lt;
comparator_location H Ba = Lt;
comparator_location H A = Lt;
comparator_location H H = Eqa;

compare_location :: Location -> Location -> Ordera;
compare_location = comparator_location;

ccompare_location :: Maybe (Location -> Location -> Ordera);
ccompare_location = Just compare_location;

instance Ccompare Location where {
  ccompare = ccompare_location;
};

data Scg a b = Null | Scg a a [(b, b)] [(b, b)];

equal_scg :: forall a b. (Eq a, Eq b) => Scg a b -> Scg a b -> Bool;
equal_scg Null (Scg x21 x22 x23 x24) = False;
equal_scg (Scg x21 x22 x23 x24) Null = False;
equal_scg (Scg x21 x22 x23 x24) (Scg y21 y22 y23 y24) =
  x21 == y21 && x22 == y22 && x23 == y23 && x24 == y24;
equal_scg Null Null = True;

instance (Eq a, Eq b) => Eq (Scg a b) where {
  a == b = equal_scg a b;
};

comparator_scg ::
  forall a b.
    (a -> a -> Ordera) -> (b -> b -> Ordera) -> Scg a b -> Scg a b -> Ordera;
comparator_scg comp_p_p comp_a_p (Scg x xa xb xc) (Scg y ya yb yc) =
  (case comp_p_p x y of {
    Eqa ->
      (case comp_p_p xa ya of {
        Eqa ->
          (case comparator_list (comparator_prod comp_a_p comp_a_p) xb yb of {
            Eqa -> comparator_list (comparator_prod comp_a_p comp_a_p) xc yc;
            Lt -> Lt;
            Gt -> Gt;
          });
        Lt -> Lt;
        Gt -> Gt;
      });
    Lt -> Lt;
    Gt -> Gt;
  });
comparator_scg comp_p_p comp_a_p (Scg x xa xb xc) Null = Gt;
comparator_scg comp_p_p comp_a_p Null (Scg y ya yb yc) = Lt;
comparator_scg comp_p_p comp_a_p Null Null = Eqa;

compare_scg ::
  forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Ordera;
compare_scg = comparator_scg compare compare;

less_eq_scg :: forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Bool;
less_eq_scg = le_of_comp compare_scg;

less_scg :: forall a b. (Compare a, Compare b) => Scg a b -> Scg a b -> Bool;
less_scg = lt_of_comp compare_scg;

instance (Compare a, Compare b) => Ord (Scg a b) where {
  less_eq = less_eq_scg;
  less = less_scg;
};

instance (Compare a, Compare b) => Compare (Scg a b) where {
  compare = compare_scg;
};

instance (Compare a, Compare b) => Preorder (Scg a b) where {
};

instance (Compare a, Compare b) => Order (Scg a b) where {
};

instance (Compare a, Compare b) => Linorder (Scg a b) where {
};

instance (Compare a, Compare b) => Compare_order (Scg a b) where {
};

data Arctic_delta a = MinInfty_delta | Num_arc_delta a;

equal_arctic_delta ::
  forall a. (Eq a) => Arctic_delta a -> Arctic_delta a -> Bool;
equal_arctic_delta MinInfty_delta (Num_arc_delta x2) = False;
equal_arctic_delta (Num_arc_delta x2) MinInfty_delta = False;
equal_arctic_delta (Num_arc_delta x2) (Num_arc_delta y2) = x2 == y2;
equal_arctic_delta MinInfty_delta MinInfty_delta = True;

instance (Eq a) => Eq (Arctic_delta a) where {
  a == b = equal_arctic_delta a b;
};

shows_arctic_delta ::
  forall a. (Showa a) => Arctic_delta a -> [Prelude.Char] -> [Prelude.Char];
shows_arctic_delta (Num_arc_delta i) = shows_prec Zero_nat i;
shows_arctic_delta MinInfty_delta = shows_prec_list Zero_nat "-inf";

shows_prec_arctic_delta ::
  forall a.
    (Showa a) => Nat -> Arctic_delta a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_arctic_delta d ari = shows_arctic_delta ari;

shows_list_arctic_delta ::
  forall a. (Showa a) => [Arctic_delta a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_arctic_delta ps = showsp_list shows_prec_arctic_delta Zero_nat ps;

instance (Showa a) => Showa (Arctic_delta a) where {
  shows_prec = shows_prec_arctic_delta;
  shows_list = shows_list_arctic_delta;
};

one_arctic_delta :: forall a. (Linordered_field a) => Arctic_delta a;
one_arctic_delta = Num_arc_delta zeroa;

instance (Linordered_field a) => One (Arctic_delta a) where {
  onea = one_arctic_delta;
};

plus_arctic_delta ::
  forall a.
    (Linordered_field a) => Arctic_delta a -> Arctic_delta a -> Arctic_delta a;
plus_arctic_delta MinInfty_delta y = y;
plus_arctic_delta (Num_arc_delta v) MinInfty_delta = Num_arc_delta v;
plus_arctic_delta (Num_arc_delta x) (Num_arc_delta y) = Num_arc_delta (max x y);

instance (Linordered_field a) => Plus (Arctic_delta a) where {
  plus = plus_arctic_delta;
};

zero_arctic_delta :: forall a. (Linordered_field a) => Arctic_delta a;
zero_arctic_delta = MinInfty_delta;

instance (Linordered_field a) => Zero (Arctic_delta a) where {
  zeroa = zero_arctic_delta;
};

instance (Linordered_field a) => Semigroup_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Numeral (Arctic_delta a) where {
};

times_arctic_delta ::
  forall a.
    (Linordered_field a) => Arctic_delta a -> Arctic_delta a -> Arctic_delta a;
times_arctic_delta MinInfty_delta y = MinInfty_delta;
times_arctic_delta (Num_arc_delta v) MinInfty_delta = MinInfty_delta;
times_arctic_delta (Num_arc_delta x) (Num_arc_delta y) =
  Num_arc_delta (plus x y);

instance (Linordered_field a) => Times (Arctic_delta a) where {
  times = times_arctic_delta;
};

instance (Linordered_field a) => Power (Arctic_delta a) where {
};

less_eq_arctic_delta ::
  forall a. (Ord a) => Arctic_delta a -> Arctic_delta a -> Bool;
less_eq_arctic_delta MinInfty_delta x = True;
less_eq_arctic_delta (Num_arc_delta uu) MinInfty_delta = False;
less_eq_arctic_delta (Num_arc_delta y) (Num_arc_delta x) = less_eq y x;

less_arctic_delta ::
  forall a. (Ord a) => Arctic_delta a -> Arctic_delta a -> Bool;
less_arctic_delta MinInfty_delta x = True;
less_arctic_delta (Num_arc_delta uu) MinInfty_delta = False;
less_arctic_delta (Num_arc_delta y) (Num_arc_delta x) = less y x;

instance (Ord a) => Ord (Arctic_delta a) where {
  less_eq = less_eq_arctic_delta;
  less = less_arctic_delta;
};

instance (Linordered_field a) => Ab_semigroup_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Semigroup_mult (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring (Arctic_delta a) where {
};

instance (Linordered_field a) => Mult_zero (Arctic_delta a) where {
};

instance (Linordered_field a) => Monoid_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Comm_monoid_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_0 (Arctic_delta a) where {
};

instance (Linordered_field a) => Monoid_mult (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_numeral (Arctic_delta a) where {
};

instance (Linordered_field a) => Zero_neq_one (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_1 (Arctic_delta a) where {
};

ceq_arctic_delta ::
  forall a. (Eq a) => Maybe (Arctic_delta a -> Arctic_delta a -> Bool);
ceq_arctic_delta = Just equal_arctic_delta;

instance (Eq a) => Ceq (Arctic_delta a) where {
  ceq = ceq_arctic_delta;
};

set_impl_arctic_delta :: forall a. Phantom (Arctic_delta a) Set_impla;
set_impl_arctic_delta = Phantom Set_RBT;

instance Set_impl (Arctic_delta a) where {
  set_impl = set_impl_arctic_delta;
};

cEnum_arctic_delta ::
  forall a.
    Maybe ([Arctic_delta a],
            ((Arctic_delta a -> Bool) -> Bool,
              (Arctic_delta a -> Bool) -> Bool));
cEnum_arctic_delta = Nothing;

instance Cenum (Arctic_delta a) where {
  cEnum = cEnum_arctic_delta;
};

comparator_arctic_delta ::
  forall a. (a -> a -> Ordera) -> Arctic_delta a -> Arctic_delta a -> Ordera;
comparator_arctic_delta comp_a (Num_arc_delta x) (Num_arc_delta y) = comp_a x y;
comparator_arctic_delta comp_a (Num_arc_delta x) MinInfty_delta = Gt;
comparator_arctic_delta comp_a MinInfty_delta (Num_arc_delta y) = Lt;
comparator_arctic_delta comp_a MinInfty_delta MinInfty_delta = Eqa;

compare_arctic_delta ::
  forall a. (Compare a) => Arctic_delta a -> Arctic_delta a -> Ordera;
compare_arctic_delta = comparator_arctic_delta compare;

ccompare_arctic_delta ::
  forall a. (Compare a) => Maybe (Arctic_delta a -> Arctic_delta a -> Ordera);
ccompare_arctic_delta = Just compare_arctic_delta;

instance (Compare a) => Ccompare (Arctic_delta a) where {
  ccompare = ccompare_arctic_delta;
};

instance (Linordered_field a) => Non_strict_order (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_ab_semigroup (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_semiring_0 (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_semiring_1 (Arctic_delta a) where {
};

data Cond_constraint a b = CC_cond Bool (Term a b, Term a b)
  | CC_rewr (Term a b) (Term a b)
  | CC_impl [Cond_constraint a b] (Cond_constraint a b)
  | CC_all b (Cond_constraint a b);

instance (Eq a, Eq b) => Eq (Cond_constraint a b) where {
  a == b = equal_cond_constraint a b;
};

equal_cond_constraint ::
  forall a b.
    (Eq a, Eq b) => Cond_constraint a b -> Cond_constraint a b -> Bool;
equal_cond_constraint (CC_impl x31 x32) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_impl x31 x32) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_impl x31 x32) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_all x41 x42) (CC_all y41 y42) =
  x41 == y41 && equal_cond_constraint x42 y42;
equal_cond_constraint (CC_impl x31 x32) (CC_impl y31 y32) =
  x31 == y31 && equal_cond_constraint x32 y32;
equal_cond_constraint (CC_rewr x21 x22) (CC_rewr y21 y22) =
  equal_term x21 y21 && equal_term x22 y22;
equal_cond_constraint (CC_cond x11 x12) (CC_cond y11 y12) =
  x11 == y11 && x12 == y12;

data Itself a = Type;

newtype Rbt b a = RBT (Rbta b a);

data Xml = XML [Prelude.Char] [([Prelude.Char], [Prelude.Char])] [Xml]
  | XML_text [Prelude.Char];

data Xmldoc = XMLDOC [[Prelude.Char]] Xml;

data Order_tag = Lex | Mul;

data Mapping a b = Assoc_List_Mapping (Alist a b)
  | RBT_Mapping (Mapping_rbt a b) | Mapping (a -> Maybe b);

data Complexity_measure a b = Derivational_Complexity [(a, Nat)]
  | Runtime_Complexity [(a, Nat)] [(a, Nat)];

newtype Complexity_class = Comp_Poly Nat;

data Strategy a b = No_Strategy | Innermost | Innermost_Q [Term a b];

data Fp_strategy a b = Outermost | Context_Sensitive [((a, Nat), [Nat])]
  | Forbidden_Patterns [(Ctxt a b, (Term a b, Location))];

data Input a b =
  DP_input
    (Bool, ([(Term a b, Term a b)], (Strategy a b, [(Term a b, Term a b)])))
  | Inn_TRS_input
      (Strategy a b, ([(Term a b, Term a b)], Maybe [(Term a b, Term a b)]))
  | COMP_input ([(Term a b, Term a b)], [(Term a b, Term a b)])
  | EQ_input ([(Term a b, Term a b)], (Term a b, Term a b))
  | CPX_input
      (Strategy a b,
        ([(Term a b, Term a b)],
          (Maybe [(Term a b, Term a b)],
            (Complexity_measure a b, Complexity_class))))
  | FP_TRS_input (Fp_strategy a b, [(Term a b, Term a b)])
  | CTRS_input [((Term a b, Term a b), [(Term a b, Term a b)])]
  | Unknown_input [Prelude.Char];

data Tpoly a b = PVar a | PNum b | PSum [Tpoly a b] | PMult [Tpoly a b];

data Domain = Natural Nat | Integera | Arctic | Arctic_rat | Int_mat Nat Nat
  | Arctic_mat Nat | Arctic_rat_mat Nat | Rational Rat Nat | Rat_mat Nat Nat
  | Mini_Alg Real Nat | Mini_Alg_mat Nat Nat;

newtype Status a = Abs_status ((a, Nat) -> [Nat]);

data Const_string_sound_proof a b =
  Const_string_sound_proof b [(a, a)] [(Term a b, Term a b)]
    [(Term a b, Term a b)];

data Af_entry = Collapse Nat | AFList [Nat];

data Redtriple_impl a = Int_carrier [((a, Nat), (Int, [Int]))]
  | Int_nl_carrier [((a, Nat), [([(Nat, Nat)], Int)])]
  | Rat_carrier [((a, Nat), (Rat, [Rat]))]
  | Rat_nl_carrier Rat [((a, Nat), [([(Nat, Nat)], Rat)])]
  | Real_carrier [((a, Nat), (Real, [Real]))]
  | Real_nl_carrier Real [((a, Nat), [([(Nat, Nat)], Real)])]
  | Arctic_carrier [((a, Nat), (Arctic, [Arctic]))]
  | Arctic_rat_carrier [((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]))]
  | Int_mat_carrier Nat Nat [((a, Nat), ([[Int]], [[[Int]]]))]
  | Rat_mat_carrier Nat Nat [((a, Nat), ([[Rat]], [[[Rat]]]))]
  | Real_mat_carrier Nat Nat [((a, Nat), ([[Real]], [[[Real]]]))]
  | Arctic_mat_carrier Nat [((a, Nat), ([[Arctic]], [[[Arctic]]]))]
  | Arctic_rat_mat_carrier Nat
      [((a, Nat), ([[Arctic_delta Rat]], [[[Arctic_delta Rat]]]))]
  | RPO [((a, Nat), (Nat, Order_tag))] [((a, Nat), Af_entry)]
  | KBO ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) [((a, Nat), Af_entry)]
  | WPO [((a, Nat), (Nat, [Nat]))] (Redtriple_impl a);

data Complex_constant_removal_prf a b =
  Complex_Constant_Removal_Proof (Term a b)
    [((Term a b, Term a b), (Term a b, Term a b))];

data List_order_type = MS_Ext | Max_Ext | Min_Ext | Dms_Ext;

data Root_redtriple_impl a =
  SCNP List_order_type [((a, Nat), [(Nat, Nat)])] (Redtriple_impl a);

data Cond_constraint_prf a b = Final
  | Delete_Condition (Cond_constraint a b) (Cond_constraint_prf a b)
  | Different_Constructor (Cond_constraint a b)
  | Same_Constructor (Cond_constraint a b) (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Variable_Equation b (Term a b) (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Funarg_Into_Var (Cond_constraint a b) Nat b (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Simplify_Condition (Cond_constraint a b) [(b, Term a b)]
      (Cond_constraint a b) (Cond_constraint_prf a b)
  | Induction (Cond_constraint a b) [Cond_constraint a b]
      [((Term a b, Term a b),
         ([(Term a b, [b])], (Cond_constraint a b, Cond_constraint_prf a b)))];

data Cond_red_pair_prf a b =
  Cond_Red_Pair_Prf a
    [(Cond_constraint a b, ([(Term a b, Term a b)], Cond_constraint_prf a b))]
    Nat Nat;

data ArithFun = Arg Nat | Const Nat | Sum [ArithFun] | Max [ArithFun]
  | Min [ArithFun] | Prod [ArithFun]
  | IfEqual ArithFun ArithFun ArithFun ArithFun;

data Sl_inter a = SL_Inter Nat [((a, Nat), ArithFun)];

data Sl_variant a b = Rootlab (Maybe (a, Nat)) | Finitelab (Sl_inter a)
  | QuasiFinitelab (Sl_inter a) b;

data Generic_assm_proof a b c d e f g h =
  SN_assm_proof
    (Bool,
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          [(Term (Lab a b) c, Term (Lab a b) c)])))
    d
  | Finite_assm_proof
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      e
  | SN_FP_assm_proof
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      f
  | Not_SN_assm_proof
      (Bool, ([Term (Lab a b) c], [(Term (Lab a b) c, Term (Lab a b) c)])) d
  | Infinite_assm_proof
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      e
  | Not_RelSN_assm_proof
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      f
  | Not_SN_FP_assm_proof
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      g
  | Complexity_assm_proof
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            (Complexity_measure (Lab a b) c, Complexity_class))))
      d
  | Unknown_assm_proof [Prelude.Char] h;

data Join_info a =
  Guided
    [(Term a [Prelude.Char],
       ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                 Term a [Prelude.Char]))],
         (Term a [Prelude.Char],
           [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                    Term a [Prelude.Char]))])))]
  | Join_NF | Join_BFS Nat;

newtype ProjL a = Projection [((a, Nat), Nat)];

data Tree_automaton a b = Tree_Automaton [a] [Ta_rule a b] [(a, a)];

data Ta_relation a = Decision_Proc | Id_Relation | Some_Relation [(a, a)];

data Boundstype = Roof | Match;

data Bounds_info a b =
  Bounds_Info Boundstype Nat [b] (Tree_automaton b (a, Nat)) (Ta_relation b);

data Trs_termination_proof a b c =
  DP_Trans Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
    (Dp_termination_proof a b c)
  | Rule_Removal (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | String_Reversal (Trs_termination_proof a b c)
  | Constant_String (Const_string_sound_proof (Lab a b) c)
      (Trs_termination_proof a b c)
  | Bounds (Bounds_info (Lab a b) c)
  | Uncurry
      (Lab a b,
        ([((Lab a b, Nat), [Lab a b])],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | Semlab (Sl_variant (Lab a b) c) [Term (Lab a b) c]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | R_is_Empty
  | Fcc [Ctxt (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c)
  | Split [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
      (Trs_termination_proof a b c)
  | Switch_Innermost (Join_info (Lab a b)) (Trs_termination_proof a b c)
  | Drop_Equality (Trs_termination_proof a b c)
  | Remove_Nonapplicable_Rules [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c)
  | Permuting_AFS [((Lab a b, Nat), Af_entry)] (Trs_termination_proof a b c)
  | Assume_SN
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [Generic_assm_proof a b c (Trs_termination_proof a b c)
         (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
         (Unknown_proof a b c)];

data Fptrs_termination_proof a b c =
  Assume_FP_SN
    ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
      [(Term (Lab a b) c, Term (Lab a b) c)])
    [Generic_assm_proof a b c (Trs_termination_proof a b c)
       (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
       (Unknown_proof a b c)];

data Dp_termination_proof a b c = P_is_Empty
  | Subterm_Criterion_Proc (ProjL (Lab a b))
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Redpair_Proc
      (Sum (Root_redtriple_impl (Lab a b)) (Redtriple_impl (Lab a b)))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Redpair_UR_Proc
      (Sum (Root_redtriple_impl (Lab a b)) (Redtriple_impl (Lab a b)))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Usable_Rules_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_termination_proof a b c)
  | Dep_Graph_Proc
      [(Maybe (Dp_termination_proof a b c),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
  | Mono_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Mono_URM_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Mono_Redpair_UR_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Size_Change_Subterm_Proc
      [((Term (Lab a b) c, Term (Lab a b) c), ([(Nat, Nat)], [(Nat, Nat)]))]
  | Size_Change_Redpair_Proc (Redtriple_impl (Lab a b))
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      [((Term (Lab a b) c, Term (Lab a b) c), ([(Nat, Nat)], [(Nat, Nat)]))]
  | Uncurry_Proc (Maybe Nat)
      (Lab a b,
        ([((Lab a b, Nat), [Lab a b])],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Fcc_Proc (Lab a b) [Ctxt (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Split_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
      (Dp_termination_proof a b c)
  | Semlab_Proc (Sl_variant (Lab a b) c) [(Term (Lab a b) c, Term (Lab a b) c)]
      [Term (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_termination_proof a b c)
  | Switch_Innermost_Proc (Join_info (Lab a b)) (Dp_termination_proof a b c)
  | Rewriting_Proc (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Term (Lab a b) c, Term (Lab a b) c) (Term (Lab a b) c, Term (Lab a b) c)
      (Term (Lab a b) c, Term (Lab a b) c) (Term (Lab a b) c, Term (Lab a b) c)
      Pos (Dp_termination_proof a b c)
  | Instantiation_Proc (Term (Lab a b) c, Term (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Forward_Instantiation_Proc (Term (Lab a b) c, Term (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Dp_termination_proof a b c)
  | Narrowing_Proc (Term (Lab a b) c, Term (Lab a b) c) Pos
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Assume_Finite
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      [Generic_assm_proof a b c (Trs_termination_proof a b c)
         (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
         (Unknown_proof a b c)]
  | Unlab_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Q_Reduction_Proc [Term (Lab a b) c] (Dp_termination_proof a b c)
  | Complex_Constant_Removal_Proc (Complex_constant_removal_prf (Lab a b) c)
      (Dp_termination_proof a b c)
  | General_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Cond_red_pair_prf (Lab a b) c)
      [Dp_termination_proof a b c]
  | To_Trs_Proc (Trs_termination_proof a b c);

data Unknown_proof a b c =
  Assume_Unknown [Prelude.Char]
    [Generic_assm_proof a b c (Trs_termination_proof a b c)
       (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
       (Unknown_proof a b c)];

data Cr_proof a b c = SN_WCR (Join_info (Lab a b)) (Trs_termination_proof a b c)
  | Weakly_Orthogonal | Strongly_Closed Nat
  | Rule_Labeling [((Term (Lab a b) c, Term (Lab a b) c), Nat)]
      [(Term (Lab a b) [Prelude.Char],
         ([(Pos, ((Term (Lab a b) [Prelude.Char],
                    Term (Lab a b) [Prelude.Char]),
                   Term (Lab a b) [Prelude.Char]))],
           (Term (Lab a b) [Prelude.Char],
             [(Pos, ((Term (Lab a b) [Prelude.Char],
                       Term (Lab a b) [Prelude.Char]),
                      Term (Lab a b) [Prelude.Char]))])))]
      (Maybe (Trs_termination_proof a b c))
  | Redundant_Rules [(Term (Lab a b) c, Term (Lab a b) c)] Nat
      [[(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                (Bool, Term (Lab a b) c)))]]
      (Cr_proof a b c);

newtype Multimap a b = Abs_multimap (b -> a, (Mapping a [b], [b]));

data Ring_ext a b = Ring_ext a (a -> a -> a) b;

newtype Sum_bot a b = Sumbot (Sum a b);

newtype Afs a = Abs_afs ((a, Nat) -> Af_entry, Set (a, Nat));

data Non_join_info a b c = Diff_NFs
  | Tcap_Non_Unif (Term a b -> Term a b -> b -> Term a b)
  | Tree_Aut_Intersect_Empty (Tree_automaton c a) (Ta_relation c)
      (Tree_automaton c a) (Ta_relation c)
  | Finite_Model_Gt (Sl_variant a b) | Reduction_Pair_Gt (Redtriple_impl a)
  | Usable_Rules_Reach_NJ (Non_join_info a b c)
  | Usable_Rules_Reach_Unif_NJ
      (Sum [(Term a b, Term a b)] [(Term a b, Term a b)]) (Non_join_info a b c)
  | Argument_Filter_NJ [((a, Nat), Af_entry)] (Non_join_info a b c)
  | Grounding [(b, Term a b)] (Non_join_info a b c)
  | Subterm_NJ Pos (Non_join_info a b c);

data Ncr_proof a b c d = SN_NWCR (Trs_termination_proof a b c)
  | Non_Join (Term (Lab a b) c)
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))]
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))]
      (Non_join_info (Lab a b) c d)
  | NCR_Disj_Subtrs [(Term (Lab a b) c, Term (Lab a b) c)] (Ncr_proof a b c d)
  | NCR_Redundant_Rules [(Term (Lab a b) c, Term (Lab a b) c)] Nat
      (Ncr_proof a b c d);

data Dp_loop_prf a b =
  DP_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), (Bool, Term a b)))]
    [(b, Term a b)] (Ctxt a b);

data Monoid_ext a b = Monoid_ext (a -> a -> a) a b;

data Trs_loop_prf a b =
  TRS_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), Term a b))]
    [(b, Term a b)] (Ctxt a b);

data Ta_ext a b c = Ta_ext (Set a) (Set (Ta_rule a b)) (Set (a, a)) c;

data Dependance = Ignore | Increase | Decrease | Wild;

data Pat_eqv_prf a b = Pat_Dom_Renaming [(b, Term a b)]
  | Pat_Irrelevant [(b, Term a b)] [(b, Term a b)]
  | Pat_Simplify [(b, Term a b)] [(b, Term a b)];

data Interpretation a = Int_linear_poly ((a, Nat), (Int, [Int]))
  | Rat_linear_poly ((a, Nat), (Rat, [Rat]))
  | Arctic_linear_poly ((a, Nat), (Arctic, [Arctic]))
  | Arctic_rat_linear_poly ((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]))
  | Real_linear_poly ((a, Nat), (Real, [Real]))
  | Int_matrix ((a, Nat), ([[Int]], [[[Int]]]))
  | Rat_matrix ((a, Nat), ([[Rat]], [[[Rat]]]))
  | Arctic_matrix ((a, Nat), ([[Arctic]], [[[Arctic]]]))
  | Arctic_rat_matrix ((a, Nat), ([[Arctic_delta Rat]], [[[Arctic_delta Rat]]]))
  | Real_matrix ((a, Nat), ([[Real]], [[[Real]]]))
  | Int_non_linear_poly ((a, Nat), [([(Nat, Nat)], Int)])
  | Rat_non_linear_poly ((a, Nat), [([(Nat, Nat)], Rat)])
  | Real_non_linear_poly ((a, Nat), [([(Nat, Nat)], Real)]);

data Relation_kind = Strict_TRS | Weak_TRS (Maybe Nat);

data Pat_rule_pos = Pat_Base | Pat_Pump | Pat_Close;

data Pat_rule_prf a b = Pat_OrigRule (Term a b, Term a b) Bool
  | Pat_InitPump (Pat_rule_prf a b) [(b, Term a b)] [(b, Term a b)]
  | Pat_InitPumpCtxt (Pat_rule_prf a b) [(b, Term a b)] Pos b
  | Pat_Equiv (Pat_rule_prf a b) Bool (Pat_eqv_prf a b)
  | Pat_Narrow (Pat_rule_prf a b) (Pat_rule_prf a b) Pos
  | Pat_Inst (Pat_rule_prf a b) [(b, Term a b)] Pat_rule_pos
  | Pat_Rewr (Pat_rule_prf a b)
      (Term a b, [(Pos, ((Term a b, Term a b), Term a b))]) Pat_rule_pos b
  | Pat_Exp_Sigma (Pat_rule_prf a b) Nat;

data Non_loop_prf a b =
  Non_loop_prf (Pat_rule_prf a b) [(b, Term a b)] [(b, Term a b)] Nat Nat Pos;

data Cert_result = Certified [Prelude.Char] | Unsupported [Prelude.Char]
  | Error [Prelude.Char];

newtype Subst_incr a b = Abs_subst_incr
  (b -> Term a b, (Set b, Term a b -> [b]));

data Memory_ext a b c d =
  Memory_ext (() -> a) (a -> b -> Maybe c) (a -> (b, c) -> a) d;

data Rule_removal_nonterm_reltrs_prf a b =
  Rule_removal_nonterm_reltrs_prf (Maybe [(Term a b, Term a b)])
    (Maybe [(Term a b, Term a b)]);

newtype Dp_trans_nontermination_tt_prf a b c = DP_trans_nontermination_tt_prf
  [(Term (Lab a b) c, Term (Lab a b) c)];

data Const_string_complete_proof a b =
  Const_string_complete_proof b [(a, a)] [(Term a b, Term a b)];

newtype Rule_removal_nonterm_trs_prf a b = Rule_removal_nonterm_trs_prf
  [(Term a b, Term a b)];

newtype Q_increase_nonterm_trs_prf a b = Q_increase_nonterm_trs_prf [Term a b];

newtype Instantiation_complete_proc_prf a b = Instantiation_complete_proc_prf
  [(Term a b, Term a b)];

data Rule_removal_nonterm_dp_prf a b =
  Rule_removal_nonterm_dp_prf (Maybe [(Term a b, Term a b)])
    (Maybe [(Term a b, Term a b)]);

newtype Q_increase_nonterm_dp_prf a b = Q_increase_nonterm_dp_prf [Term a b];

newtype Dp_q_reduction_nonterm_prf a b = DP_q_reduction_nonterm_prf [Term a b];

data Rewriting_complete_proc_prf a b =
  Rewriting_complete_proc_prf (Maybe [(Term a b, Term a b)])
    (Term a b, Term a b) (Term a b, Term a b) (Term a b, Term a b)
    (Term a b, Term a b) Pos;

data Narrowing_complete_proc_prf a b =
  Narrowing_complete_proc_prf (Term a b, Term a b) Pos [(Term a b, Term a b)];

data Fp_loop_prf a b =
  FP_loop_prf (Ctxt a b) [(b, Term a b)] (Term a b)
    [(Pos, ((Term a b, Term a b), Term a b))];

data Dp_proof_step a = OC1 ([a], [a]) Bool
  | OC2 ([a], [a]) ([a], [a]) ([a], [a]) [a] [a] [a]
  | OC2p ([a], [a]) ([a], [a]) ([a], [a]) [a] [a] [a]
  | OC3 ([a], [a]) ([a], [a]) ([a], [a]) [a] [a]
  | OC3p ([a], [a]) ([a], [a]) ([a], [a]) [a] [a]
  | OCDP1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a])
  | OCDP2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a])
  | WPEQ (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
  | Lift (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
  | DPOC1_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC1_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a] [a]
  | DPOC2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC3_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC3_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a] [a]
  | DPDP1_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP1_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP2_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP2_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a]
      [a];

data Non_loop_srs_proof a = SE_OC ([a], [a]) [a] [a] [Dp_proof_step a]
  | SE_DP (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a]
      [a] [Dp_proof_step a];

data Uncurry_nt_proof a b c =
  Uncurry_nt_proof
    (Lab a b,
      ([((Lab a b, Nat), [Lab a b])],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          [(Term (Lab a b) c, Term (Lab a b) c)])))
    [(Term (Lab a b) c, Term (Lab a b) c)];

data Rel_trs_loop_prf a b =
  Rel_trs_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), (Bool, Term a b)))]
    [(b, Term a b)] (Ctxt a b);

data Reltrs_nontermination_proof a b c = Rel_Loop (Rel_trs_loop_prf (Lab a b) c)
  | Rel_TRS_String_Reversal (Reltrs_nontermination_proof a b c)
  | Rel_Not_Well_Formed
  | Rel_Rule_Removal (Rule_removal_nonterm_reltrs_prf (Lab a b) c)
      (Reltrs_nontermination_proof a b c)
  | Rel_R_Not_SN (Trs_nontermination_proof a b c)
  | Rel_TRS_Assume_Not_SN
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Trs_nontermination_proof a b c = TRS_Loop (Trs_loop_prf (Lab a b) c)
  | TRS_Not_Well_Formed
  | TRS_Rule_Removal (Rule_removal_nonterm_trs_prf (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_String_Reversal (Trs_nontermination_proof a b c)
  | TRS_Constant_String (Const_string_complete_proof (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_DP_Trans (Dp_trans_nontermination_tt_prf a b c)
      (Dp_nontermination_proof a b c)
  | TRS_Termination_Switch (Join_info (Lab a b))
      (Trs_nontermination_proof a b c)
  | TRS_Nonloop (Non_loop_prf (Lab a b) c)
  | TRS_Nonloop_SRS (Non_loop_srs_proof (Lab a b))
  | TRS_Q_Increase (Q_increase_nonterm_trs_prf (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_Uncurry (Uncurry_nt_proof a b c) (Trs_nontermination_proof a b c)
  | TRS_Assume_Not_SN
      (Bool, ([Term (Lab a b) c], [(Term (Lab a b) c, Term (Lab a b) c)]))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Fp_nontermination_proof a b c = FPTRS_Loop (Fp_loop_prf (Lab a b) c)
  | FPTRS_Rule_Removal (Rule_removal_nonterm_trs_prf (Lab a b) c)
      (Fp_nontermination_proof a b c)
  | FPTRS_Assume_Not_SN
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Dp_nontermination_proof a b c = DP_Loop (Dp_loop_prf (Lab a b) c)
  | DP_Nonloop (Non_loop_prf (Lab a b) c)
  | DP_Rule_Removal (Rule_removal_nonterm_dp_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Q_Increase (Q_increase_nonterm_dp_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Q_Reduction (Dp_q_reduction_nonterm_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Termination_Switch (Join_info (Lab a b)) (Dp_nontermination_proof a b c)
  | DP_Instantiation (Instantiation_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Rewriting (Rewriting_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Narrowing (Narrowing_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Assume_Infinite
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Neg_unknown_proof a b c =
  Assume_NT_Unknown [Prelude.Char]
    [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
       (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
       (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Quasi_reductive_proof a b c =
  Unravel
    [(((Term (Lab a b) c, Term (Lab a b) c),
        [(Term (Lab a b) c, Term (Lab a b) c)]),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
    (Trs_termination_proof a b c);

data Completion_proof a b c =
  SN_WCR_Eq (Join_info (Lab a b)) (Trs_termination_proof a b c)
    [((Term (Lab a b) c, Term (Lab a b) c),
       [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                (Bool, Term (Lab a b) c)))])]
    (Maybe [((Term (Lab a b) c, Term (Lab a b) c),
              [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                       (Bool, Term (Lab a b) c)))])]);

data Equational_disproof a b c =
  Completion_and_Normalization_Different [(Term (Lab a b) c, Term (Lab a b) c)]
    (Completion_proof a b c);

data Conditional_cr_proof a b c =
  Unravel_CR
    [(((Term (Lab a b) c, Term (Lab a b) c),
        [(Term (Lab a b) c, Term (Lab a b) c)]),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
    (Cr_proof a b c);

data Eq_proof a b = Refl (Term a b) | Sym (Eq_proof a b)
  | Trans (Eq_proof a b) (Eq_proof a b)
  | Assm (Term a b, Term a b) (b -> Term a b) | Cong a [Eq_proof a b];

data Equational_proof a b c = Equational_Proof_Tree (Eq_proof (Lab a b) c)
  | Completion_and_Normalization [(Term (Lab a b) c, Term (Lab a b) c)]
      (Completion_proof a b c)
  | Conversion
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), (Bool, Term (Lab a b) c)))]
  | Conversion_With_History
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                  (Bool, Term (Lab a b) c)))])];

data Dt_transformation_info a b =
  DT_Transformation_Info [((Term a b, Term a b), (Term a b, Term a b))]
    [((Term a b, Term a b), (Term a b, Term a b))] [Term a b];

data Wdp_trans_info a b =
  WDP_Trans_Info (Set (a, Nat)) [((Term a b, Term a b), (Term a b, Term a b))]
    [((Term a b, Term a b), (Term a b, Term a b))] [Term a b];

data Complexity_proof a b c =
  Rule_Shift_Complexity (Redtriple_impl (Lab a b))
    [(Term (Lab a b) c, Term (Lab a b) c)]
    (Maybe [(Term (Lab a b) c, Term (Lab a b) c)]) (Complexity_proof a b c)
  | RisEmpty_Complexity
  | Remove_Nonapplicable_Rules_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c)
  | Matchbounds_Complexity (Bounds_info (Lab a b) c)
  | Matchbounds_Rel_Complexity (Bounds_info (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Complexity_proof a b c)
  | DT_Transformation (Dt_transformation_info (Lab a b) c)
      (Complexity_proof a b c)
  | WDP_Transformation (Wdp_trans_info (Lab a b) c) (Complexity_proof a b c)
  | Complexity_Assumption
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            (Complexity_measure (Lab a b) c, Complexity_class))))
      [Generic_assm_proof a b c (Complexity_proof a b c) () () () ()]
  | Usable_Rules_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c)
  | Split_Complexity [(Term (Lab a b) c, Term (Lab a b) c)]
      (Complexity_proof a b c) (Complexity_proof a b c);

data Cert_problem a b c =
  TRS_Termination_Proof Bool (Strategy (Lab a b) c)
    [(Term (Lab a b) c, Term (Lab a b) c)]
    (Maybe [(Term (Lab a b) c, Term (Lab a b) c)]) (Trs_termination_proof a b c)
  | Complexity_Proof (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Complexity_measure (Lab a b) c) Complexity_class (Complexity_proof a b c)
  | DP_Termination_Proof Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | DP_Nontermination_Proof Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      (Strategy (Lab a b) c) [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_nontermination_proof a b c)
  | TRS_Nontermination_Proof Bool (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_nontermination_proof a b c)
  | Outermost_Termination_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Fptrs_termination_proof a b c)
  | Outermost_Nontermination_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Fp_nontermination_proof a b c)
  | CS_Termination_Proof [((Lab a b, Nat), [Nat])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fptrs_termination_proof a b c)
  | CS_Nontermination_Proof [((Lab a b, Nat), [Nat])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fp_nontermination_proof a b c)
  | FP_Termination_Proof [(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fptrs_termination_proof a b c)
  | FP_Nontermination_Proof [(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fp_nontermination_proof a b c)
  | Relative_TRS_Nontermination_Proof Bool (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Reltrs_nontermination_proof a b c)
  | TRS_Confluence_Proof Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      (Cr_proof a b c)
  | TRS_Non_Confluence_Proof Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      (Ncr_proof a b c c)
  | Completion_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Completion_proof a b c)
  | Equational_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Term (Lab a b) c, Term (Lab a b) c) (Equational_proof a b c)
  | Equational_Disproof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Term (Lab a b) c, Term (Lab a b) c) (Equational_disproof a b c)
  | Quasi_Reductive_Proof
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
      (Quasi_reductive_proof a b c)
  | Conditional_CR_Proof
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
      (Conditional_cr_proof a b c)
  | Unknown_Proof [Prelude.Char] (Unknown_proof a b c)
  | Unknown_Disproof [Prelude.Char] (Neg_unknown_proof a b c);

newtype Tp b a = TP
  (Bool,
    ([Term b a],
      (Bool,
        ([(Term b a, Term b a)],
          ([(Term b a, Term b a)],
            (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
              Term b a -> Bool))))));

data C_constraint a b =
  Conditional_C Bool (Term a b, Term a b) (Term a b, Term a b)
  | Unconditional_C Bool (Term a b, Term a b);

data Ta_rule_impl a b = TA_rule_impl b [a] a (Rbt a ());

newtype Dpp b a = DPP
  (Bool,
    (Bool,
      ([(Term b a, Term b a)],
        ([(Term b a, Term b a)],
          ([Term b a],
            (Bool,
              (Bool,
                ([(Term b a, Term b a)],
                  ([(Term b a, Term b a)],
                    (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                      (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                        (Bool, Term b a -> Bool))))))))))));

data Ta_impl_ext a b c =
  Ta_impl_ext (Rbt a ()) (Rbt (b, Nat) [Ta_rule_impl a b]) [a] (Rbt a ())
    [(a, a)] (a -> Rbt a ()) (a -> Rbt a ()) c;

data Condition_type = Bound | Strict | Non_Strict;

data Redtriple_ext a b c =
  Redtriple_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Set Nat) ((a, Nat) -> Set Nat)
    ([(Term a b, Term a b)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ([Prelude.Char] -> [Prelude.Char]) (Maybe [(a, Nat)])
    (Complexity_measure a b ->
      Sum ([Prelude.Char] -> [Prelude.Char]) Complexity_class)
    c;

data Sl_ops_ext a b c d e =
  Sl_ops_ext (a -> [b] -> c) (a -> Nat -> c -> Bool) (a -> [b] -> b) [b] b
    ([(Term a d, Term a d)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    (a -> [b] -> c) (a -> Nat -> c -> Bool) (c -> [c]) (a -> Nat -> [c]) e;

data Slm_ops_ext a b c d =
  Slm_ops_ext (a -> [b] -> c) (a -> [b] -> b) [b] b (a -> [b] -> c) d;

data Tp_ops_ext a b c d =
  Tp_ops_ext
    (a -> (Bool,
            (Set (Term b c),
              (Set (Term b c, Term b c), Set (Term b c, Term b c)))))
    (a -> [Term b c]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)]) (a -> Bool)
    (a -> Term b c -> Bool) (a -> Bool)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (Bool ->
      [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> Bool) d;

data Partial_object_ext a b = Partial_object_ext (Set a) b;

data Dpp_ops_ext a b c d =
  Dpp_ops_ext
    (a -> (Bool,
            (Bool,
              (Set (Term b c, Term b c),
                (Set (Term b c, Term b c),
                  (Set (Term b c),
                    (Set (Term b c, Term b c), Set (Term b c, Term b c))))))))
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [Term b c])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> Bool) (a -> Bool) (a -> Bool)
    (a -> Term b c -> Bool) (a -> Bool)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> (b, Nat) -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)] -> a)
    (a -> (Term b c, Term b c) -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (Bool ->
      Bool ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] ->
            [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> Bool) (a -> Bool) (a -> Bool) d;

data Root_redtriple_ext a b c =
  Root_redtriple_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Set Nat) ((a, Nat) -> Set Nat)
    ([Prelude.Char] -> [Prelude.Char]) c;

data Non_inf_order_ext a b c =
  Non_inf_order_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    (C_constraint a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Nat -> Dependance) ([Prelude.Char] -> [Prelude.Char]) c;

data Ordered_semiring_ext a b =
  Ordered_semiring_ext (a -> a -> Bool) (a -> a -> Bool) (a -> a -> a) b;

data Lpoly_order_semiring_ext a b =
  Lpoly_order_semiring_ext Bool a (a -> Bool) (a -> Bool) (a -> Nat)
    (a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat) [Prelude.Char] b;

newtype X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a =
  Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
  (Maybe ((a, Nat) -> [Nat]));

newtype
  X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
    a
  = Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
  (Maybe ((a, Nat) -> Af_entry, Set (a, Nat)));

dom :: forall a b. (Cenum a) => (a -> Maybe b) -> Set a;
dom m = collect (\ a -> not (is_none (m a)));

suc :: Nat -> Nat;
suc n = plus_nat n (Nat_of_num One);

dlist_ex :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Bool;
dlist_ex x xc = any x (list_of_dlist xc);

rBT_Impl_rbt_ex :: forall a b. (a -> b -> Bool) -> Rbta a b -> Bool;
rBT_Impl_rbt_ex p (Branch c l k v r) =
  p k v || (rBT_Impl_rbt_ex p l || rBT_Impl_rbt_ex p r);
rBT_Impl_rbt_ex p Emptya = False;

ex :: forall a b. (Ccompare a) => (a -> b -> Bool) -> Mapping_rbt a b -> Bool;
ex xb xc = rBT_Impl_rbt_ex xb (impl_ofb xc);

bex :: forall a. (Ceq a, Ccompare a) => Set a -> (a -> Bool) -> Bool;
bex (RBT_set rbt) p =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Bex RBT_set: ccompare = None" (\ _ -> bex (RBT_set rbt) p);
    Just _ -> ex (\ k _ -> p k) rbt;
  });
bex (DList_set dxs) p =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "Bex DList_set: ceq = None"
        (\ _ -> bex (DList_set dxs) p);
    Just _ -> dlist_ex p dxs;
  });
bex (Set_Monad xs) p = any p xs;

tag :: Xml -> [Prelude.Char];
tag (XML name uu uv) = name;
tag (XML_text uw) = [];

nth :: forall a. [a] -> Nat -> a;
nth (x : xs) n =
  (if equal_nat n Zero_nat then x else nth xs (minus_nat n (Nat_of_num One)));

upt :: Nat -> Nat -> [Nat];
upt i j =
  (if less_nat i j then i : upt (plus_nat i (Nat_of_num One)) j else []);

rBT_Impl_rbt_all :: forall a b. (a -> b -> Bool) -> Rbta a b -> Bool;
rBT_Impl_rbt_all p (Branch c l k v r) =
  p k v && rBT_Impl_rbt_all p l && rBT_Impl_rbt_all p r;
rBT_Impl_rbt_all p Emptya = True;

alla :: forall a b. (Ccompare a) => (a -> b -> Bool) -> Mapping_rbt a b -> Bool;
alla xb xc = rBT_Impl_rbt_all xb (impl_ofb xc);

ball :: forall a. (Ceq a, Ccompare a) => Set a -> (a -> Bool) -> Bool;
ball (RBT_set rbt) p =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Ball RBT_set: ccompare = None" (\ _ -> ball (RBT_set rbt) p);
    Just _ -> alla (\ k _ -> p k) rbt;
  });
ball (DList_set dxs) p =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a) "Ball DList_set: ceq = None"
        (\ _ -> ball (DList_set dxs) p);
    Just _ -> dlist_all p dxs;
  });
ball (Set_Monad xs) p = all p xs;

returna :: forall a b. a -> Sum_bot b a;
returna x = Sumbot (Inr x);

errora :: forall a b. a -> Sum_bot a b;
errora x = Sumbot (Inl x);

int_of_digit :: Prelude.Char -> Sum_bot [Prelude.Char] Int;
int_of_digit x =
  (if x == '0' then returna Zero_int
    else (if x == '1' then returna (Pos One)
           else (if x == '2' then returna (Pos (Bit0 One))
                  else (if x == '3' then returna (Pos (Bit1 One))
                         else (if x == '4' then returna (Pos (Bit0 (Bit0 One)))
                                else (if x == '5'
                                       then returna (Pos (Bit1 (Bit0 One)))
                                       else (if x == '6'
      then returna (Pos (Bit0 (Bit1 One)))
      else (if x == '7' then returna (Pos (Bit1 (Bit1 One)))
             else (if x == '8' then returna (Pos (Bit0 (Bit0 (Bit0 One))))
                    else (if x == '9'
                           then returna (Pos (Bit1 (Bit0 (Bit0 One))))
                           else errora
                                  [x, ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                                    'a', ' ', 'd', 'i', 'g', 'i',
                                    't']))))))))));

binda :: forall a b c. Sum_bot a b -> (b -> Sum_bot a c) -> Sum_bot a c;
binda (Sumbot a) f = (case a of {
                       Inl b -> Sumbot (Inl b);
                       Inr aa -> f aa;
                     });

int_of_string_aux :: Int -> [Prelude.Char] -> Sum_bot [Prelude.Char] Int;
int_of_string_aux n [] = returna n;
int_of_string_aux n (d : s) =
  binda (int_of_digit d)
    (\ m ->
      int_of_string_aux
        (plus_int (times_int (Pos (Bit0 (Bit1 (Bit0 One)))) n) m) s);

tl :: forall a. [a] -> [a];
tl [] = [];
tl (x21 : x22) = x22;

take :: forall a. Nat -> [a] -> [a];
take n [] = [];
take n (x : xs) =
  (if equal_nat n Zero_nat then []
    else x : take (minus_nat n (Nat_of_num One)) xs);

int_of_string :: [Prelude.Char] -> Sum_bot [Prelude.Char] Int;
int_of_string s =
  (if null s then errora "cannot convert empty string into number"
    else (if take (Nat_of_num One) s == "-"
           then binda (int_of_string_aux Zero_int (tl s))
                  (\ i -> returna (minus_int Zero_int i))
           else int_of_string_aux Zero_int s));

shows_attr ::
  ([Prelude.Char], [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_attr av =
  shows_prec_list Zero_nat (fst av) . shows_string ("=\"" ++ snd av ++ "\"");

foldr :: forall a b. (a -> b -> b) -> [a] -> b -> b;
foldr f [] = id;
foldr f (x : xs) = f x . foldr f xs;

shows_attrs ::
  [([Prelude.Char], [Prelude.Char])] -> [Prelude.Char] -> [Prelude.Char];
shows_attrs asa = foldr (\ a -> shows_string " " . shows_attr a) asa;

replicate :: forall a. Nat -> a -> [a];
replicate n x =
  (if equal_nat n Zero_nat then []
    else x : replicate (minus_nat n (Nat_of_num One)) x);

shows_XML_indent ::
  [Prelude.Char] -> Nat -> Xml -> [Prelude.Char] -> [Prelude.Char];
shows_XML_indent ind i (XML n a c) =
  shows_string "\n" .
    shows_string ind .
      shows_string "<" .
        shows_prec_list Zero_nat n .
          shows_attrs a .
            (if null c then shows_string "/>"
              else shows_string ">" .
                     foldr (shows_XML_indent (replicate i ' ' ++ ind) i) c .
                       shows_string "\n" .
                         shows_string ind .
                           shows_string "</" .
                             shows_prec_list Zero_nat n . shows_string ">");
shows_XML_indent ind i (XML_text t) = shows_string t;

shows_prec_xml :: Nat -> Xml -> [Prelude.Char] -> [Prelude.Char];
shows_prec_xml d xml = shows_XML_indent [] (Nat_of_num (Bit0 One)) xml;

text :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
text tag (XML n atts [XML_text t]) =
  (if n == tag && null atts then returna t
    else errora
           (concat
             ["could not extract text for ", tag, " from ", "\n",
               shows_prec_xml Zero_nat (XML n atts [XML_text t]) []]));
text tag (XML v va []) =
  errora
    (concat
      ["could not extract text for ", tag, " from ", "\n",
        shows_prec_xml Zero_nat (XML v va []) []]);
text tag (XML v va (XML ve vf vg : vd)) =
  errora
    (concat
      ["could not extract text for ", tag, " from ", "\n",
        shows_prec_xml Zero_nat (XML v va (XML ve vf vg : vd)) []]);
text tag (XML v va (vc : ve : vf)) =
  errora
    (concat
      ["could not extract text for ", tag, " from ", "\n",
        shows_prec_xml Zero_nat (XML v va (vc : ve : vf)) []]);
text tag (XML_text v) =
  errora
    (concat
      ["could not extract text for ", tag, " from ", "\n",
        shows_prec_xml Zero_nat (XML_text v) []]);

int :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Int;
int tag x = binda (text tag x) int_of_string;

nata :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Nat;
nata tag x =
  binda (text tag x)
    (\ txt -> binda (int_of_string txt) (\ i -> returna (nat i)));

options ::
  forall a.
    [([Prelude.Char], Xml -> Sum_bot [Prelude.Char] a)] ->
      Xml -> Sum_bot [Prelude.Char] a;
options ps x =
  (case map_of ps (tag x) of {
    Nothing ->
      errora
        (concat
          ["expected one of: ", concatMap (\ p -> fst p ++ " ") ps, "\n",
            "but found", "\n", shows_prec_xml Zero_nat x []]);
    Just p -> p x;
  });

change ::
  forall a b.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      (a -> b) -> Xml -> Sum_bot [Prelude.Char] b;
change p f x = binda (p x) (returna . f);

list2elements :: forall a. [a] -> Maybe (a, a);
list2elements [x, y] = Just (x, y);
list2elements [] = Nothing;
list2elements [v] = Nothing;
list2elements (v : vb : vd : ve) = Nothing;

fail :: forall a. [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] a;
fail tag xml =
  errora
    (concat
      ["could not transform the following xml element (expected ", tag, ")",
        "\n", shows_prec_xml Zero_nat xml []]);

pair ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> b -> c) -> Xml -> Sum_bot [Prelude.Char] c;
pair tag p1 p2 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list2elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, cs2) ->
                 binda (p1 cs1)
                   (\ a -> binda (p2 cs2) (\ b -> returna (f a b)));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

rat :: Xml -> Sum_bot [Prelude.Char] Rat;
rat = options
        [("integer", change (int "integer") of_int),
          ("rational",
            pair "rational" (int "numerator") (int "denominator")
              (\ x y -> divide_rat (of_int x) (of_int y)))];

drop :: forall a. Nat -> [a] -> [a];
drop n [] = [];
drop n (x : xs) =
  (if equal_nat n Zero_nat then x : xs
    else drop (minus_nat n (Nat_of_num One)) xs);

find :: forall a. (a -> Bool) -> [a] -> Maybe a;
find uu [] = Nothing;
find p (x : xs) = (if p x then Just x else find p xs);

last :: forall a. [a] -> a;
last (x : xs) = (if null xs then x else last xs);

empty :: forall a b. (Linorder a) => Rbt a b;
empty = RBT Emptya;

image ::
  forall a b.
    (Ceq a, Ccompare a, Ceq b, Ccompare b,
      Set_impl b) => (a -> b) -> Set a -> Set b;
image h (RBT_set rbt) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "image RBT_set: ccompare = None" (\ _ -> image h (RBT_set rbt));
    Just _ -> foldb (inserta . h) rbt bot_set;
  });
image g (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "image DList_set: ceq = None" (\ _ -> image g (DList_set dxs));
    Just _ -> foldc (inserta . g) dxs bot_set;
  });
image f (Complement (Complement b)) = image f b;
image f (Collect_set a) =
  (error :: forall a. String -> (() -> a) -> a) "image Collect_set"
    (\ _ -> image f (Collect_set a));
image f (Set_Monad xs) = Set_Monad (map f xs);

bind :: forall a b. Maybe a -> (a -> Maybe b) -> Maybe b;
bind Nothing f = Nothing;
bind (Just x) f = f x;

zip_option :: forall a b. [a] -> [b] -> Maybe [(a, b)];
zip_option [] [] = Just [];
zip_option (x : xs) (y : ys) =
  bind (zip_option xs ys) (\ zs -> Just ((x, y) : zs));
zip_option (x : xs) [] = Nothing;
zip_option [] (y : ys) = Nothing;

guarda :: Bool -> Maybe ();
guarda b = (if b then Just () else Nothing);

match_lista ::
  forall a b. (Eq a) => [(Gctxt a b, Term a b)] -> Maybe [(Gctxt a b, b)];
match_lista ((GCFun f ss, Var x) : ps) =
  bind (match_lista ps) (\ psa -> Just ((GCFun f ss, x) : psa));
match_lista ((GCFun f ss, Fun g ts) : ps) =
  bind (guarda (f == g))
    (\ _ -> bind (zip_option ss ts) (\ psa -> match_lista (psa ++ ps)));
match_lista ((GCHole, t) : ps) = match_lista ps;
match_lista [] = Just [];

merge_lists ::
  forall a b. (Eq a) => [Gctxt a b] -> [Gctxt a b] -> Maybe [Gctxt a b];
merge_lists (c : cs) [] = Nothing;
merge_lists [] (d : ds) = Nothing;
merge_lists (GCFun f ss : cs) (GCFun g ts : ds) =
  bind (guarda (f == g))
    (\ _ ->
      bind (merge_lists ss ts)
        (\ us -> bind (merge_lists cs ds) (\ es -> Just (GCFun f us : es))));
merge_lists (c : cs) (GCHole : ds) =
  bind (merge_lists cs ds) (\ es -> Just (c : es));
merge_lists (GCHole : cs) (d : ds) =
  bind (merge_lists cs ds) (\ es -> Just (d : es));
merge_lists [] [] = Just [];

merge :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Maybe (Gctxt a b);
merge c d = bind (merge_lists [c] [d]) (\ es -> Just (nth es Zero_nat));

merge_var ::
  forall a b.
    (Eq a,
      Eq b) => a -> Gctxt b a ->
                      [(Gctxt b a, a)] ->
                        Maybe ((Gctxt b a, a), [(Gctxt b a, a)]);
merge_var x c ((d, y) : ps) =
  (if x == y then bind (merge c d) (\ e -> merge_var x e ps)
    else bind (merge_var x c ps) (\ (b, psa) -> Just (b, (d, y) : psa)));
merge_var x c [] = Just ((c, x), []);

merge_all ::
  forall a b. (Eq a, Eq b) => [(Gctxt a b, b)] -> Maybe [(Gctxt a b, b)];
merge_all [] = Just [];
merge_all ((c, x) : ps) =
  bind (merge_var x c ps)
    (\ (cx, psa) -> bind (merge_all psa) (\ psb -> Just (cx : psb)));

matchc ::
  forall a b. (Eq a, Eq b) => (Gctxt a b, Term a b) -> Maybe [(Gctxt a b, b)];
matchc (c, t) = bind (match_lista [(c, t)]) merge_all;

matchb :: forall a b. (Eq a, Eq b) => Gctxt a b -> Term a b -> Bool;
matchb c t = not (is_none (matchc (c, t)));

tcap ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Set (Term a b, Term a b) -> Term a b -> Gctxt a b;
tcap uu (Var uv) = GCHole;
tcap r (Fun f ts) =
  let {
    h = GCFun f (map (tcap r) ts);
  } in (if bex r (\ ra -> matchb h (fst ra)) then GCHole else h);

root :: forall a b. Term a b -> Maybe (a, Nat);
root (Var x) = Nothing;
root (Fun f ts) = Just (f, size_list ts);

bool_of_string :: [Prelude.Char] -> Sum_bot [Prelude.Char] Bool;
bool_of_string s =
  (if s == "true" then returna True
    else (if s == "false" then returna False
           else errora ("cannot convert " ++ s ++ " into Boolean")));

bool :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Bool;
bool tag node = binda (text tag node) bool_of_string;

leaf :: forall a. [Prelude.Char] -> a -> Xml -> Sum_bot [Prelude.Char] a;
leaf tag x (XML name atts cs) =
  (if name == tag && null atts && null cs then returna x
    else fail tag (XML name atts cs));
leaf tag x (XML_text v) = fail tag (XML_text v);

map_sum_bot :: forall a b c. (a -> Sum_bot b c) -> [a] -> Sum_bot b [c];
map_sum_bot f [] = returna [];
map_sum_bot f (x : xs) =
  binda (f x) (\ y -> binda (map_sum_bot f xs) (\ ys -> returna (y : ys)));

many ::
  forall a b.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        ([a] -> b) -> Xml -> Sum_bot [Prelude.Char] b;
many tag p f (XML name atts cs) =
  (if name == tag && null atts then binda (map_sum_bot p cs) (returna . f)
    else fail tag (XML name atts cs));
many tag p f (XML_text v) = fail tag (XML_text v);

funpow :: forall a. Nat -> (a -> a) -> a -> a;
funpow n f =
  (if equal_nat n Zero_nat then id
    else f . funpow (minus_nat n (Nat_of_num One)) f);

rbt_del :: forall a b. (Compare_order a) => a -> Rbta a b -> Rbta a b;
rbt_del x (Branch c a y s b) =
  (case compare x y of {
    Eqa -> combine a b;
    Lt -> rbt_del_from_left x a y s b;
    Gt -> rbt_del_from_right x a y s b;
  });
rbt_del x Emptya = Emptya;

rbt_del_from_left ::
  forall a b.
    (Compare_order a) => a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_left x (Branch B lt z v rt) y s b =
  balance_left (rbt_del x (Branch B lt z v rt)) y s b;
rbt_del_from_left x Emptya y s b = Branch R (rbt_del x Emptya) y s b;
rbt_del_from_left x (Branch R va vb vc vd) y s b =
  Branch R (rbt_del x (Branch R va vb vc vd)) y s b;

rbt_del_from_right ::
  forall a b.
    (Compare_order a) => a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_right x a y s (Branch B lt z v rt) =
  balance_right a y s (rbt_del x (Branch B lt z v rt));
rbt_del_from_right x a y s Emptya = Branch R a y s (rbt_del x Emptya);
rbt_del_from_right x a y s (Branch R va vb vc vd) =
  Branch R a y s (rbt_del x (Branch R va vb vc vd));

rbt_delete :: forall a b. (Compare_order a) => a -> Rbta a b -> Rbta a b;
rbt_delete k t = paint B (rbt_del k t);

impl_of :: forall b a. (Linorder b) => Rbt b a -> Rbta b a;
impl_of (RBT x) = x;

delete :: forall a b. (Compare_order a) => a -> Rbt a b -> Rbt a b;
delete xb xc = RBT (rbt_delete xb (impl_of xc));

rbt_ins ::
  forall a b.
    (Compare_order a) => (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_ins f k v (Branch R l x y r) =
  (case compare k x of {
    Eqa -> Branch R l x (f k y v) r;
    Lt -> Branch R (rbt_ins f k v l) x y r;
    Gt -> Branch R l x y (rbt_ins f k v r);
  });
rbt_ins f k v (Branch B l x y r) =
  (case compare k x of {
    Eqa -> Branch B l x (f k y v) r;
    Lt -> balance (rbt_ins f k v l) x y r;
    Gt -> balance l x y (rbt_ins f k v r);
  });
rbt_ins f k v Emptya = Branch R Emptya k v Emptya;

rbt_insert_with_key ::
  forall a b.
    (Compare_order a) => (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_insert_with_key f k v t = paint B (rbt_ins f k v t);

rbt_insert :: forall a b. (Compare_order a) => a -> b -> Rbta a b -> Rbta a b;
rbt_insert = rbt_insert_with_key (\ _ _ nv -> nv);

insert :: forall a b. (Compare_order a) => a -> b -> Rbt a b -> Rbt a b;
insert xc xd xe = RBT (rbt_insert xc xd (impl_of xe));

rbt_lookup :: forall a b. (Compare_order a) => Rbta a b -> a -> Maybe b;
rbt_lookup (Branch uu l x y r) k =
  (case compare k x of {
    Eqa -> Just y;
    Lt -> rbt_lookup l k;
    Gt -> rbt_lookup r k;
  });
rbt_lookup Emptya k = Nothing;

lookup :: forall a b. (Compare_order a) => Rbt a b -> a -> Maybe b;
lookup x = rbt_lookup (impl_of x);

proja :: forall a b. Term a b -> Nat -> Term a b;
proja (Fun f ts) i = (if less_nat i (size_list ts) then nth ts i else Fun f ts);

filtera :: forall a. (Ceq a, Ccompare a) => (a -> Bool) -> Set a -> Set a;
filtera p a = inf_set a (Collect_set p);

fun_upd :: forall a b. (Eq a) => (a -> b) -> a -> b -> a -> b;
fun_upd f a b = (\ x -> (if x == a then b else f x));

subst :: forall a b. (Eq a) => a -> Term b a -> a -> Term b a;
subst x t = fun_upd Var x t;

debug :: forall a. [Prelude.Char] -> [Prelude.Char] -> a -> a;
debug i t x = x;

guard ::
  forall a.
    (Xml -> Bool) ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] a;
guard p p1 p2 x = (if p x then p1 x else p2 x);

many1_gen ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> [b] -> c) -> Xml -> Sum_bot [Prelude.Char] c;
many1_gen tag p1 p2 f (XML name atts cs) =
  (if name == tag && null atts && not (null cs)
    then let {
           (h : t) = cs;
         } in binda (p1 h)
                (\ x -> binda (map_sum_bot (p2 x) t) (\ xs -> returna (f x xs)))
    else fail tag (XML name atts cs));
many1_gen tag p1 p2 f (XML_text v) = fail tag (XML_text v);

many1 ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> [b] -> c) -> Xml -> Sum_bot [Prelude.Char] c;
many1 tag p1 p2 = many1_gen tag p1 (\ _ -> p2);

length_ge_2 :: forall a. [a] -> Bool;
length_ge_2 (uu : uv : uw) = True;
length_ge_2 [] = False;
length_ge_2 [v] = False;

many2 ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> b -> [c] -> d) -> Xml -> Sum_bot [Prelude.Char] d;
many2 tag p1 p2 p3 f (XML name atts cs) =
  (if name == tag && null atts && length_ge_2 cs
    then let {
           (cs0 : cs1 : t) = cs;
         } in binda (p1 cs0)
                (\ x ->
                  binda (p2 cs1)
                    (\ y ->
                      binda (map_sum_bot p3 t) (\ xs -> returna (f x y xs))))
    else fail tag (XML name atts cs));
many2 tag p1 p2 p3 f (XML_text v) = fail tag (XML_text v);

membera :: forall a. (Eq a) => [a] -> a -> Bool;
membera [] y = False;
membera (x : xs) y = x == y || membera xs y;

insertb :: forall a. (Eq a) => a -> [a] -> [a];
insertb x xs = (if membera xs x then xs else x : xs);

lterms ::
  forall a b. ((a, Nat) -> [(Nat, Nat)]) -> Term a b -> [(Term a b, Nat)];
lterms pi =
  (\ (Fun f ts) ->
    map (\ (i, a) -> (proja (Fun f ts) i, a)) (pi (f, size_list ts)));

ground :: forall a b. Term a b -> Bool;
ground (Var x) = False;
ground (Fun f ts) = all ground ts;

insert_vars_term :: forall a b. (Eq b) => Term a b -> [b] -> [b];
insert_vars_term (Var x) xs = insertb x xs;
insert_vars_term (Fun f ts) xs = foldr insert_vars_term ts xs;

is_Var :: forall a b. Term a b -> Bool;
is_Var (Var x1) = True;
is_Var (Fun x21 x22) = False;

wf_rule :: forall a b. (Eq b) => (Term a b, Term a b) -> Bool;
wf_rule r =
  not (is_Var (fst r)) &&
    all (membera (insert_vars_term (fst r) [])) (insert_vars_term (snd r) []);

fun_of :: forall a b. (Eq a) => [(a, b)] -> a -> b;
fun_of vec x = the (map_of vec x);

letters :: [Prelude.Char];
letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789&;:-";

catch_error :: forall a b c. Sum_bot a b -> (a -> Sum_bot c b) -> Sum_bot c b;
catch_error (Sumbot a) f =
  (case a of {
    Inl aa -> f aa;
    Inr aa -> Sumbot (Inr aa);
  });

choice ::
  forall a.
    [Prelude.Char] ->
      [Xml -> Sum_bot [Prelude.Char] a] -> Xml -> Sum_bot [Prelude.Char] a;
choice e [] x =
  errora
    (concat
      ["error in parsing choice for ", e, "\n", shows_prec_xml Zero_nat x []]);
choice e (p : ps) x = catch_error (p x) (\ _ -> choice e ps x);

list3elements :: forall a. [a] -> Maybe (a, (a, a));
list3elements [x, y, z] = Just (x, (y, z));
list3elements [] = Nothing;
list3elements [v] = Nothing;
list3elements [v, vb] = Nothing;
list3elements (v : vb : vd : vf : vg) = Nothing;

triple ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> b -> c -> d) -> Xml -> Sum_bot [Prelude.Char] d;
triple tag p1 p2 p3 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list3elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, (cs2, cs3)) ->
                 binda (p1 cs1)
                   (\ a ->
                     binda (p2 cs2)
                       (\ b -> binda (p3 cs3) (\ c -> returna (f a b c))));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

list4elements :: forall a. [a] -> Maybe (a, (a, (a, a)));
list4elements [x, y, z, u] = Just (x, (y, (z, u)));
list4elements [] = Nothing;
list4elements [v] = Nothing;
list4elements [v, vb] = Nothing;
list4elements [v, vb, vd] = Nothing;
list4elements (v : vb : vd : vf : vh : vi) = Nothing;

tuple4 ::
  forall a b c d e.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (a -> b -> c -> d -> e) -> Xml -> Sum_bot [Prelude.Char] e;
tuple4 tag p1 p2 p3 p4 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list4elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, (cs2, (cs3, cs4))) ->
                 binda (p1 cs1)
                   (\ a ->
                     binda (p2 cs2)
                       (\ b ->
                         binda (p3 cs3)
                           (\ c ->
                             binda (p4 cs4) (\ d -> returna (f a b c d)))));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

list5elements :: forall a. [a] -> Maybe (a, (a, (a, (a, a))));
list5elements [x, y, z, u, v] = Just (x, (y, (z, (u, v))));
list5elements [] = Nothing;
list5elements [v] = Nothing;
list5elements [v, vb] = Nothing;
list5elements [v, vb, vd] = Nothing;
list5elements [v, vb, vd, vf] = Nothing;
list5elements (v : vb : vd : vf : vh : vj : vk) = Nothing;

tuple5 ::
  forall a b c d e f.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (Xml -> Sum_bot [Prelude.Char] e) ->
                (a -> b -> c -> d -> e -> f) -> Xml -> Sum_bot [Prelude.Char] f;
tuple5 tag p1 p2 p3 p4 p5 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list5elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, (cs2, (cs3, (cs4, cs5)))) ->
                 binda (p1 cs1)
                   (\ a ->
                     binda (p2 cs2)
                       (\ b ->
                         binda (p3 cs3)
                           (\ c ->
                             binda (p4 cs4)
                               (\ d ->
                                 binda (p5 cs5)
                                   (\ e -> returna (f a b c d e))))));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

list6elements :: forall a. [a] -> Maybe (a, (a, (a, (a, (a, a)))));
list6elements [x, y, z, u, v, w] = Just (x, (y, (z, (u, (v, w)))));
list6elements [] = Nothing;
list6elements [v] = Nothing;
list6elements [v, vb] = Nothing;
list6elements [v, vb, vd] = Nothing;
list6elements [v, vb, vd, vf] = Nothing;
list6elements [v, vb, vd, vf, vh] = Nothing;
list6elements (v : vb : vd : vf : vh : vj : vl : vm) = Nothing;

tuple6 ::
  forall a b c d e f g.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (Xml -> Sum_bot [Prelude.Char] e) ->
                (Xml -> Sum_bot [Prelude.Char] f) ->
                  (a -> b -> c -> d -> e -> f -> g) ->
                    Xml -> Sum_bot [Prelude.Char] g;
tuple6 tag p1 p2 p3 p4 p5 p6 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list6elements cs of {
               Nothing -> fail tag xml;
               Just (cs1, (cs2, (cs3, (cs4, (cs5, cs6))))) ->
                 binda (p1 cs1)
                   (\ a ->
                     binda (p2 cs2)
                       (\ b ->
                         binda (p3 cs3)
                           (\ c ->
                             binda (p4 cs4)
                               (\ d ->
                                 binda (p5 cs5)
                                   (\ e ->
                                     binda (p6 cs6)
                                       (\ ff -> returna (f a b c d e ff)))))));
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

update :: forall a b. (Eq a) => a -> b -> [(a, b)] -> [(a, b)];
update k v [] = [(k, v)];
update k v (p : ps) = (if fst p == k then (k, v) : ps else p : update k v ps);

emptya :: forall a b. Alist a b;
emptya = Alist [];

scf_list :: forall a. (Nat -> Nat) -> [a] -> [a];
scf_list scf xs =
  concatMap (\ (x, i) -> replicate (scf i) x)
    (zip xs (upt Zero_nat (size_list xs)));

scf_term :: forall a b. ((a, Nat) -> Nat -> Nat) -> Term a b -> Term a b;
scf_term scf (Var x) = Var x;
scf_term scf (Fun f ts) =
  Fun f (scf_list (scf (f, size_list ts)) (map (scf_term scf) ts));

butlast :: forall a. [a] -> [a];
butlast [] = [];
butlast (x : xs) = (if null xs then [] else x : butlast xs);

extract :: forall a. (a -> Bool) -> [a] -> Maybe ([a], (a, [a]));
extract p (x : xs) =
  (if p x then Just ([], (x, xs))
    else (case extract p xs of {
           Nothing -> Nothing;
           Just (ys, (y, zs)) -> Just (x : ys, (y, zs));
         }));
extract p [] = Nothing;

hd :: forall a. [a] -> a;
hd (x21 : x22) = x21;

productb ::
  forall a b. (Ceq a, Ceq b) => Set_dlist a -> Set_dlist b -> Set_dlist (a, b);
productb dxs1 dxs2 =
  Abs_dlist (foldc (\ a -> foldc (\ c -> (\ b -> (a, c) : b)) dxs2) dxs1 []);

rbt_product ::
  forall a b c d e.
    (a -> b -> c -> d -> e) -> Rbta a b -> Rbta c d -> Rbta (a, c) e;
rbt_product f rbt1 rbt2 =
  rbtreeify
    (reverse
      (folda (\ a b -> folda (\ c d -> (\ e -> ((a, c), f a b c d) : e)) rbt2)
        rbt1 []));

productd ::
  forall a d b e c.
    (Ccompare a,
      Ccompare b) => (a -> d -> b -> e -> c) ->
                       Mapping_rbt a d ->
                         Mapping_rbt b e -> Mapping_rbt (a, b) c;
productd xc xd xe = Mapping_RBTa (rbt_product xc (impl_ofb xd) (impl_ofb xe));

producta ::
  forall a b.
    (Ccompare a,
      Ccompare b) => Mapping_rbt a () ->
                       Mapping_rbt b () -> Mapping_rbt (a, b) ();
producta rbt1 rbt2 = productd (\ _ _ _ _ -> ()) rbt1 rbt2;

productc ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Set a -> Set b -> Set (a, b);
productc (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set RBT_set: ccompare1 = None"
        (\ _ -> productc (RBT_set rbt1) (RBT_set rbt2));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "product RBT_set RBT_set: ccompare2 = None"
            (\ _ -> productc (RBT_set rbt1) (RBT_set rbt2));
        Just _ -> RBT_set (producta rbt1 rbt2);
      });
  });
productc a2 (RBT_set rbt2) =
  (case (ccompare :: Maybe (b -> b -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set: ccompare2 = None" (\ _ -> productc a2 (RBT_set rbt2));
    Just _ -> foldb (\ y -> sup_set (image (\ x -> (x, y)) a2)) rbt2 bot_set;
  });
productc (RBT_set rbt1) b2 =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product RBT_set: ccompare1 = None" (\ _ -> productc (RBT_set rbt1) b2);
    Just _ -> foldb (\ x -> sup_set (image (\ a -> (x, a)) b2)) rbt1 bot_set;
  });
productc (DList_set dxs) (DList_set dys) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set DList_set: ceq1 = None"
        (\ _ -> productc (DList_set dxs) (DList_set dys));
    Just _ ->
      (case (ceq :: Maybe (b -> b -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "product DList_set DList_set: ceq2 = None"
            (\ _ -> productc (DList_set dxs) (DList_set dys));
        Just _ -> DList_set (productb dxs dys);
      });
  });
productc a1 (DList_set dys) =
  (case (ceq :: Maybe (b -> b -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set2: ceq = None" (\ _ -> productc a1 (DList_set dys));
    Just _ -> foldc (\ y -> sup_set (image (\ x -> (x, y)) a1)) dys bot_set;
  });
productc (DList_set dxs) b1 =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "product DList_set1: ceq = None" (\ _ -> productc (DList_set dxs) b1);
    Just _ -> foldc (\ x -> sup_set (image (\ a -> (x, a)) b1)) dxs bot_set;
  });
productc (Set_Monad xs) (Set_Monad ys) =
  Set_Monad (fold (\ x -> fold (\ y -> (\ a -> (x, y) : a)) ys) xs []);
productc a b = Collect_set (\ (x, y) -> member x a && member y b);

set_Cons ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Set a -> Set [a] -> Set [a];
set_Cons a xs =
  image (\ (aa, b) -> aa : b)
    (productc (inf_set (image (\ x -> x) a) top_set)
      (inf_set top_set (image (\ xsa -> xsa) xs)));

listset :: forall a. (Ceq a, Ccompare a, Set_impl a) => [Set a] -> Set [a];
listset [] = inserta [] (set_empty (of_phantom set_impl_list));
listset (a : asa) = set_Cons a (listset asa);

remdups :: forall a. (Eq a) => [a] -> [a];
remdups [] = [];
remdups (x : xs) = (if membera xs x then remdups xs else x : remdups xs);

remove1 :: forall a. (Eq a) => a -> [a] -> [a];
remove1 x [] = [];
remove1 x (y : xs) = (if x == y then xs else y : remove1 x xs);

l2m_lookup ::
  forall a b c. (Eq a, Eq b) => [(a, [(b, c)])] -> (a, b) -> Maybe c;
l2m_lookup [] uu = Nothing;
l2m_lookup ((a, kvs) : rec) (k1, k2) =
  (case k1 == a of {
    True -> map_of kvs k2;
    False -> l2m_lookup rec (k1, k2);
  });

lm_store_acc ::
  forall a b. (Eq a) => [(a, b)] -> (a, b) -> [(a, b)] -> [(a, b)];
lm_store_acc [] kv accu = kv : accu;
lm_store_acc ((a, uu) : rec) (k, v) accu =
  (case k == a of {
    True -> accu;
    False -> lm_store_acc rec (k, v) accu;
  });

lm_store :: forall a b. (Eq a) => [(a, b)] -> (a, b) -> [(a, b)];
lm_store m kv = lm_store_acc m kv m;

l2m_store ::
  forall a b c.
    (Eq a, Eq b) => [(a, [(b, c)])] -> ((a, b), c) -> [(a, [(b, c)])];
l2m_store [] ((k1, k2), v) = [(k1, [(k2, v)])];
l2m_store ((a, kvs) : rec) ((k1, k2), v) =
  (case k1 == a of {
    True -> (a, lm_store kvs (k2, v)) : rec;
    False -> (a, kvs) : l2m_store rec ((k1, k2), v);
  });

l2m :: forall a b c. (Eq a, Eq b) => Memory_ext [(a, [(b, c)])] (a, b) c ();
l2m = Memory_ext (\ _ -> []) l2m_lookup l2m_store ();

aux ::
  forall a b.
    (Eq a,
      Compare_order b) => (a -> Maybe b) ->
                            Rbt b [a] -> a -> Rbt b [a] -> Rbt b [a];
aux key ma v m =
  (case key v of {
    Nothing -> m;
    Just k ->
      (case lookup ma k of {
        Nothing -> m;
        Just ws ->
          (if membera ws v
            then (case lookup m k of {
                   Nothing -> insert k [v] m;
                   Just vs -> insert k (insertb v vs) m;
                 })
            else m);
      });
  });

ma_coeff :: Mini_alg -> Rat;
ma_coeff xa = fst (snd (rep_mini_alg xa));

mau_coeff :: Mini_alg_unique -> Rat;
mau_coeff xa = ma_coeff (rep_mini_alg_unique xa);

root_int_maina :: Nat -> Int -> Int -> Int -> Int -> (Int, Bool);
root_int_maina pm ipm ip x n =
  let {
    xpm = powera x pm;
    xp = times_int xpm x;
  } in (if less_eq_int xp n then (x, equal_int xp n)
         else root_int_maina pm ipm ip
                (div_int (plus_int (div_int n xpm) (times_int x ipm)) ip) n);

root_int_main :: Nat -> Int -> (Int, Bool);
root_int_main p n =
  (if equal_nat p Zero_nat then (Pos One, equal_int n (Pos One))
    else let {
           pm = minus_nat p (Nat_of_num One);
         } in root_int_maina pm (of_nat pm) (of_nat p) (start_value n p) n);

root_int_floor_pos :: Nat -> Int -> Int;
root_int_floor_pos p x =
  (if equal_nat p Zero_nat then Zero_int else fst (root_int_main p x));

root_nat_floor :: Nat -> Nat -> Int;
root_nat_floor p x = root_int_floor_pos p (of_nat x);

sqrt_int :: Int -> [Int];
sqrt_int x =
  (if less_int x Zero_int then []
    else (case sqrt_int_main x of {
           (y, True) ->
             (if equal_int y Zero_int then [Zero_int] else [y, uminus_int y]);
           (_, False) -> [];
         }));

sqrt_nat :: Nat -> [Nat];
sqrt_nat x = map nat (take (Nat_of_num One) (sqrt_int (of_nat x)));

dvd :: forall a. (Semiring_div a, Eq a) => a -> a -> Bool;
dvd a b = mod b a == zeroa;

prime_product_factor_main :: Nat -> Nat -> Nat -> Nat -> Nat -> (Nat, Nat);
prime_product_factor_main factor_sq factor_pr limit n i =
  (if less_eq_nat i limit && less_eq_nat (Nat_of_num (Bit0 One)) i
    then (if dvd i n
           then let {
                  na = div_nat n i;
                } in (if dvd i na
                       then let {
                              nb = div_nat na i;
                            } in prime_product_factor_main
                                   (times_nat factor_sq i) factor_pr
                                   (nat (root_nat_floor (Nat_of_num (Bit1 One))
  nb))
                                   nb i
                       else (case sqrt_nat na of {
                              [] -> prime_product_factor_main factor_sq
                                      (times_nat factor_pr i)
                                      (nat
(root_nat_floor (Nat_of_num (Bit1 One)) na))
                                      na (plus_nat i (Nat_of_num One));
                              sn : _ ->
                                (times_nat factor_sq sn, times_nat factor_pr i);
                            }))
           else prime_product_factor_main factor_sq factor_pr limit n
                  (plus_nat i (Nat_of_num One)))
    else (factor_sq, times_nat factor_pr n));

prime_product_factor :: Nat -> (Nat, Nat);
prime_product_factor n =
  (case sqrt_nat n of {
    [] -> prime_product_factor_main (Nat_of_num One) (Nat_of_num One)
            (nat (root_nat_floor (Nat_of_num (Bit1 One)) n)) n
            (Nat_of_num (Bit0 One));
    s : _ -> (s, Nat_of_num One);
  });

ma_sqrt :: Mini_alg -> Mini_alg;
ma_sqrt xa =
  Abs_mini_alg
    (let {
       (p, (_, _)) = rep_mini_alg xa;
       a = quotient_of p;
       (aa, b) = a;
       aaa = abs_int (times_int aa b);
     } in (case sqrt_int aaa of {
            [] -> (zero_rat, (inverse_rat (of_int b), nat aaa));
            s : _ -> (divide_rat (of_int s) (of_int b), (zero_rat, Zero_nat));
          }));

ma_rat :: Mini_alg -> Rat;
ma_rat xa = fst (rep_mini_alg xa);

mau_sqrt :: Mini_alg_unique -> Mini_alg_unique;
mau_sqrt xa =
  Abs_mini_alg_unique
    (let {
       a = quotient_of (ma_rat (rep_mini_alg_unique xa));
       (aa, b) = a;
       (sq, fact) = prime_product_factor (nat (times_int (abs_int aa) b));
       ma = ma_of_rat
              (divide_rat (times_rat (of_int (sgn_int aa)) (of_nat sq))
                (of_int b));
     } in ma_times ma (ma_sqrt (ma_of_rat (of_nat fact))));

sqrt :: Real -> Real;
sqrt (Real_of_u r) =
  (if equal_rat (mau_coeff r) zero_rat then Real_of_u (mau_sqrt r)
    else (error :: forall a. String -> (() -> a) -> a)
           "cannot represent sqrt of irrational number"
           (\ _ -> sqrt (Real_of_u r)));

rev :: Pos -> Pos;
rev Empty = Empty;
rev (PCons i p) = append (rev p) (PCons i Empty);

key :: forall a b c. (a, (Term b c, Term b c)) -> Maybe (b, Nat);
key (uu, (Fun f ts, uv)) = Just (f, size_list ts);
key (uw, (Var ux, uy)) = Nothing;

subt_at :: forall a b. Term a b -> Pos -> Term a b;
subt_at s Empty = s;
subt_at (Fun f ss) (PCons i p) = subt_at (nth ss i) p;

children :: Xml -> [Xml];
children (XML uu uv cs) = cs;
children (XML_text uw) = [];

lookupa :: forall a b. (Eq a) => Alist a b -> a -> Maybe b;
lookupa xa = map_of (impl_ofa xa);

updatea :: forall a b. (Eq a) => a -> b -> Alist a b -> Alist a b;
updatea xc xd xe = Alist (update xc xd (impl_ofa xe));

distinct :: forall a. (Eq a) => [a] -> Bool;
distinct [] = True;
distinct (x : xs) = not (membera xs x) && distinct xs;

mapping_empty_choose :: forall a b. (Ccompare a) => Mapping a b;
mapping_empty_choose =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing -> Assoc_List_Mapping emptya;
    Just _ -> RBT_Mapping emptye;
  });

mapping_empty :: forall a b. (Ccompare a) => Mapping_impla -> Mapping a b;
mapping_empty Mapping_RBT = RBT_Mapping emptye;
mapping_empty Mapping_Assoc_List = Assoc_List_Mapping emptya;
mapping_empty Mapping_Mapping = Mapping (\ _ -> Nothing);
mapping_empty Mapping_Choose = mapping_empty_choose;

emptyb :: forall a b. (Ccompare a, Mapping_impl a) => Mapping a b;
emptyb = mapping_empty (of_phantom (mapping_impl :: Phantom a Mapping_impla));

add ::
  forall a b. Partial_object_ext a (Monoid_ext a (Ring_ext a b)) -> a -> a -> a;
add (Partial_object_ext carrier (Monoid_ext mult one (Ring_ext zero add more)))
  = add;

shows_nl :: [Prelude.Char] -> [Prelude.Char];
shows_nl = shows_prec_char Zero_nat '\n';

hole_pos :: forall a b. Ctxt a b -> Pos;
hole_pos Hole = Empty;
hole_pos (More f ss d ts) = PCons (size_list ss) (hole_pos d);

mk_subst ::
  forall a b c. (Eq a) => (a -> Term b c) -> [(a, Term b c)] -> a -> Term b c;
mk_subst d xts =
  (\ x -> (case map_of xts x of {
            Nothing -> d x;
            Just t -> t;
          }));

supremum ::
  forall a b.
    (Ceq a, Ccompare a, Ceq b, Ccompare b, Supa b,
      Set_impl b) => Set a -> (a -> b) -> b;
supremum a f = supa (image f a);

vars_term ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => Term a b -> Set b;
vars_term (Var x1) = inserta x1 bot_set;
vars_term (Fun x21 x22) = supremum (set x22) vars_term;

vars_rule ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Set b;
vars_rule r = sup_set (vars_term (fst r)) (vars_term (snd r));

unapp :: forall a b. (Eq a) => a -> Term a b -> (Term a b, [Term a b]);
unapp a (Var x) = (Var x, []);
unapp a (Fun f ss) =
  (if f == a && equal_nat (size_list ss) (Nat_of_num (Bit0 One))
    then let {
           (r, ts) = unapp a (nth ss Zero_nat);
         } in (r, ts ++ [nth ss (Nat_of_num One)])
    else (Fun f ss, []));

update_tokens :: forall a. ([a] -> [a]) -> [a] -> Sum [Prelude.Char] ([a], [a]);
update_tokens f ts = Inr (ts, f ts);

remove_comments_aux_acc ::
  [Prelude.Char] -> Bool -> [Prelude.Char] -> [Prelude.Char];
remove_comments_aux_acc a False (c : cs) =
  (if c == '<' && take (Nat_of_num (Bit1 One)) cs == "!--"
    then remove_comments_aux_acc a True (tl cs)
    else remove_comments_aux_acc (c : a) False cs);
remove_comments_aux_acc a True (c : cs) =
  (if c == '-' && take (Nat_of_num (Bit0 One)) cs == "->"
    then remove_comments_aux_acc a False (drop (Nat_of_num (Bit0 One)) cs)
    else remove_comments_aux_acc a True cs);
remove_comments_aux_acc a uu [] = a;

remove_comments_aux :: Bool -> [Prelude.Char] -> [Prelude.Char];
remove_comments_aux False (c : cs) =
  (if c == '<' && take (Nat_of_num (Bit1 One)) cs == "!--"
    then remove_comments_aux True (tl cs)
    else c : remove_comments_aux False cs);
remove_comments_aux True (c : cs) =
  (if c == '-' && take (Nat_of_num (Bit0 One)) cs == "->"
    then remove_comments_aux False (drop (Nat_of_num (Bit0 One)) cs)
    else remove_comments_aux True cs);
remove_comments_aux uu [] = [];

remove_comments :: [Prelude.Char] -> [Prelude.Char];
remove_comments =
  (if False then reverse . remove_comments_aux_acc [] False
    else remove_comments_aux False);

returnb :: forall a b. a -> [b] -> Sum [Prelude.Char] (a, [b]);
returnb x = (\ ts -> Inr (x, ts));

bindb :: forall a b c. Sum a b -> (b -> Sum a c) -> Sum a c;
bindb m f = (case m of {
              Inl a -> Inl a;
              Inr a -> f a;
            });

bindc ::
  forall a b c.
    ([a] -> Sum [Prelude.Char] (b, [a])) ->
      (b -> [a] -> Sum [Prelude.Char] (c, [a])) ->
        [a] -> Sum [Prelude.Char] (c, [a]);
bindc m f ts = bindb (m ts) (\ (a, b) -> f a b);

shows_quote ::
  ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_quote s =
  (shows_prec_char Zero_nat '\'' . s) . shows_prec_char Zero_nat '\'';

scan_upto ::
  [Prelude.Char] ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
scan_upto end (t : ts) =
  (if map snd (zip end (t : ts)) == end
    then Inr (end, drop (size_list end) (t : ts))
    else bindb (scan_upto end ts) (\ (res, tsa) -> Inr (t : res, tsa)));
scan_upto end [] =
  Inl ("did not find end-marker " ++
        shows_quote (shows_prec_list Zero_nat end) []);

trim :: [Prelude.Char] -> [Prelude.Char];
trim = dropWhile (membera " \n\t\r");

manya ::
  (Prelude.Char -> Bool) ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
manya p (t : ts) =
  (if p t then bindb (manya p ts) (\ (rs, tsa) -> Inr (t : rs, tsa))
    else Inr ([], t : ts));
manya p [] = Inr ([], []);

parse_header ::
  [Prelude.Char] -> Sum [Prelude.Char] ([[Prelude.Char]], [Prelude.Char]);
parse_header ts =
  (if take (Nat_of_num (Bit0 One)) (trim ts) == "<?"
    then bindc (scan_upto "?>")
           (\ h -> bindc parse_header (\ hs -> returnb (h : hs))) ts
    else bindc (bindc (manya (membera " \n\t\r")) (\ _ -> returnb ()))
           (\ _ -> returnb []) ts);

err_expecting ::
  forall a b. (Showa a) => [Prelude.Char] -> [a] -> Sum [Prelude.Char] (b, [a]);
err_expecting msg ts =
  Inl ("expecting " ++
        msg ++
          ", but found: " ++
            shows_quote
              (shows_prec_list Zero_nat
                (take (Nat_of_num (Bit0 (Bit1 (Bit1 (Bit1 One))))) ts))
              []);

eoi :: forall a. (Showa a) => [a] -> Sum [Prelude.Char] ((), [a]);
eoi [] = Inr ((), []);
eoi (v : va) = err_expecting "end of input" (v : va);

exactly_aux ::
  [Prelude.Char] ->
    [Prelude.Char] ->
      [Prelude.Char] ->
        [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
exactly_aux s i (x : xs) (y : ys) =
  (if x == y then exactly_aux s i xs ys
    else err_expecting ("\"" ++ s ++ "\"") i);
exactly_aux s i [] xs = Inr (s, trim xs);
exactly_aux s i (x : xs) [] = err_expecting ("\"" ++ s ++ "\"") i;

exactly ::
  [Prelude.Char] ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
exactly s x = exactly_aux s x s x;

parse_attribute_value ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
parse_attribute_value =
  bindc (exactly "\"")
    (\ _ ->
      bindc (manya (\ y -> not ('\"' == y)))
        (\ v -> bindc (exactly "\"") (\ _ -> returnb v)));

errorb :: forall a b. [Prelude.Char] -> [a] -> Sum [Prelude.Char] (b, [a]);
errorb e = (\ _ -> Inl e);

letters_impl :: Prelude.Char -> Bool;
letters_impl c =
  'a' <= c && c <= 'z' ||
    ('A' <= c && c <= 'Z' || ('0' <= c && c <= '9' || membera "_&;:-" c));

parse_name ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
parse_name s =
  bindc (manya letters_impl)
    (\ n ->
      bindc (bindc (manya (membera " \n\t\r")) (\ _ -> returnb ()))
        (\ _ ->
          (if null n
            then errorb
                   ("expected letter " ++
                     letters ++
                       " but first symbol is \"" ++
                         take (Nat_of_num One) s ++ "\"")
            else returnb n)))
    s;

parse_attributes ::
  [Prelude.Char] ->
    Sum [Prelude.Char] ([([Prelude.Char], [Prelude.Char])], [Prelude.Char]);
parse_attributes [] = Inr ([], []);
parse_attributes (c : s) =
  (if membera "/>" c then Inr ([], c : s)
    else bindc parse_name
           (\ k ->
             bindc (exactly "=")
               (\ _ ->
                 bindc parse_attribute_value
                   (\ v ->
                     bindc parse_attributes
                       (\ atts -> returnb ((k, v) : atts)))))
           (c : s));

oneof_closed ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
oneof_closed (x : xs) =
  (if x == '>' then Inr (">", trim xs)
    else (if x == '/' && (case xs of {
                           [] -> False;
                           y : _ -> y == '>';
                         })
           then Inr ("/>", trim (tl xs))
           else err_expecting "one of [/>, >]" (x : xs)));
oneof_closed [] = err_expecting "one of [/>, >]" [];

parse_text ::
  [Prelude.Char] -> Sum [Prelude.Char] (Maybe [Prelude.Char], [Prelude.Char]);
parse_text =
  bindc (manya (\ y -> not ('<' == y)))
    (\ ts ->
      let {
        text = trim ts;
      } in (if null text then returnb Nothing
             else returnb (Just (reverse (trim (reverse text))))));

parse_nodes :: [Prelude.Char] -> Sum [Prelude.Char] ([Xml], [Prelude.Char]);
parse_nodes ts =
  (if null ts || take (Nat_of_num (Bit0 One)) ts == "</" then returnb [] ts
    else (if not (hd ts == '<')
           then bindc parse_text
                  (\ t ->
                    bindc parse_nodes (\ ns -> returnb (XML_text (the t) : ns)))
                  ts
           else bindc (exactly "<")
                  (\ _ ->
                    bindc parse_name
                      (\ n ->
                        bindc parse_attributes
                          (\ atts ->
                            bindc oneof_closed
                              (\ e ->
                                (if e == "/>"
                                  then bindc parse_nodes
 (\ cs -> returnb (XML n atts [] : cs))
                                  else bindc parse_nodes
 (\ cs ->
   bindc (exactly "</")
     (\ _ ->
       bindc (exactly n)
         (\ _ ->
           bindc (exactly ">")
             (\ _ ->
               bindc parse_nodes (\ ns -> returnb (XML n atts cs : ns)))))))))))
                  ts));

parse_node :: [Prelude.Char] -> Sum [Prelude.Char] (Xml, [Prelude.Char]);
parse_node =
  bindc (exactly "<")
    (\ _ ->
      bindc parse_name
        (\ n ->
          bindc parse_attributes
            (\ atts ->
              bindc oneof_closed
                (\ e ->
                  (if e == "/>" then returnb (XML n atts [])
                    else bindc parse_nodes
                           (\ cs ->
                             bindc (exactly "</")
                               (\ _ ->
                                 bindc (exactly n)
                                   (\ _ ->
                                     bindc (exactly ">")
                                       (\ _ -> returnb (XML n atts cs))))))))));

parse_doc :: [Prelude.Char] -> Sum [Prelude.Char] (Xmldoc, [Prelude.Char]);
parse_doc =
  bindc (update_tokens remove_comments)
    (\ _ ->
      bindc parse_header
        (\ h ->
          bindc parse_node
            (\ xml -> bindc eoi (\ _ -> returnb (XMLDOC h xml)))));

position :: Xml -> Sum_bot [Prelude.Char] Nat;
position = change (nata "position") (\ n -> minus_nat n (Nat_of_num One));

afs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), Af_entry)];
afs xml2name =
  many "argumentFilter"
    (triple "argumentFilterEntry" xml2name (nata "arity")
      (options
        [("collapsing",
           change (nata "collapsing")
             (\ i -> Collapse (minus_nat i (Nat_of_num One)))),
          ("nonCollapsing", many "nonCollapsing" position AFList)])
      (\ f a -> (\ b -> ((f, a), b))))
    id;

list2position :: [Nat] -> Pos;
list2position [] = Empty;
list2position (n : ns) = PCons n (list2position ns);

pos :: Xml -> Sum_bot [Prelude.Char] Pos;
pos = many "positionInTerm" position list2position;

scg_position :: Xml -> Sum_bot [Prelude.Char] Nat;
scg_position = nata "position";

list1element :: forall a. [a] -> Maybe a;
list1element [x] = Just x;
list1element [] = Nothing;
list1element (v : vb : vc) = Nothing;

singleton ::
  forall a b.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> b) -> Xml -> Sum_bot [Prelude.Char] b;
singleton tag p1 f xml =
  (case xml of {
    XML name atts cs ->
      (if name == tag && null atts
        then (case list1element cs of {
               Nothing -> fail tag xml;
               Just cs1 -> binda (p1 cs1) (returna . f);
             })
        else fail tag xml);
    XML_text _ -> fail tag xml;
  });

var :: forall a. Xml -> Sum_bot [Prelude.Char] (Term a [Prelude.Char]);
var x = binda (text "var" x) (returna . Var);

term ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Term a [Prelude.Char]);
term xml2name x =
  options
    [("var", var),
      ("funapp",
        many1 "funapp" xml2name (singleton "arg" (term xml2name) id) Fun)]
    x;

rule ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char] (Term a [Prelude.Char], Term a [Prelude.Char]);
rule xml2name =
  pair "rule" (singleton "lhs" (term xml2name) id)
    (singleton "rhs" (term xml2name) id) (\ a b -> (a, b));

scg ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ((Term a [Prelude.Char], Term a [Prelude.Char]),
            ([(Nat, Nat)], [(Nat, Nat)]));
scg xml2name =
  many1 "sizeChangeGraph" (rule xml2name)
    (triple "edge" scg_position (bool "strict") scg_position
      (\ p s q -> (s, (p, q))))
    (\ lr edges ->
      (lr, (map_filter (\ x -> (if fst x then Just (snd x) else Nothing)) edges,
             map_filter (\ x -> (if not (fst x) then Just (snd x) else Nothing))
               edges)));

map_term :: forall a b c d. (a -> b) -> (c -> d) -> Term a c -> Term b d;
map_term f1 f2 (Var x1) = Var (f2 x1);
map_term f1 f2 (Fun x21 x22) = Fun (f1 x21) (map (map_term f1 f2) x22);

class_to_term_intern ::
  forall a b. (Nat -> a) -> Nat -> Term b (Sum () a) -> (Nat, Term b a);
class_to_term_intern iv i (Fun f ts) =
  let {
    (k, ss) =
      foldr (\ t (j, ss) ->
              let {
                (k, s) = class_to_term_intern iv j t;
              } in (k, s : ss))
        ts (i, []);
  } in (k, Fun f ss);
class_to_term_intern iv i (Var (Inl uu)) =
  (plus_nat i (Nat_of_num One), Var (iv i));
class_to_term_intern iv i (Var (Inr x)) = (i, Var x);

class_to_term ::
  forall a.
    Prelude.Char -> Term a (Sum () [Prelude.Char]) -> Term a [Prelude.Char];
class_to_term c t =
  snd (class_to_term_intern (\ i -> c : shows_prec_nat Zero_nat i []) Zero_nat
        t);

subst_apply_term :: forall a b c. Term a b -> (b -> Term a c) -> Term a c;
subst_apply_term (Var x) sigma = sigma x;
subst_apply_term (Fun f ss) sigma =
  Fun f (map (\ t -> subst_apply_term t sigma) ss);

subst_compose ::
  forall a b c d. (a -> Term b c) -> (c -> Term b d) -> a -> Term b d;
subst_compose sigma tau = (\ x -> subst_apply_term (sigma x) tau);

subst_of :: forall a b. (Eq a) => [(a, Term b a)] -> a -> Term b a;
subst_of ss = foldr (\ (x, t) sigma -> subst_compose sigma (subst x t)) ss Var;

contains_var_term :: forall a b. (Eq a) => a -> Term b a -> Bool;
contains_var_term x (Var y) = x == y;
contains_var_term x (Fun uu ts) = any (contains_var_term x) ts;

subst_list ::
  forall a b.
    (a -> Term b a) -> [(Term b a, Term b a)] -> [(Term b a, Term b a)];
subst_list sigma ys =
  map (\ p -> (subst_apply_term (fst p) sigma, subst_apply_term (snd p) sigma))
    ys;

decompose ::
  forall a b c. (Eq a) => Term a b -> Term a c -> Maybe [(Term a b, Term a c)];
decompose s t =
  (case (s, t) of {
    (Var _, _) -> Nothing;
    (Fun _ _, Var _) -> Nothing;
    (Fun f ss, Fun g ts) -> (if f == g then zip_option ss ts else Nothing);
  });

unify ::
  forall a b.
    (Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(b, Term a b)] -> Maybe [(b, Term a b)];
unify [] bs = Just bs;
unify ((Fun f ss, Fun g ts) : e) bs =
  (case decompose (Fun f ss) (Fun g ts) of {
    Nothing -> Nothing;
    Just us -> unify (us ++ e) bs;
  });
unify ((Var x, t) : e) bs =
  (if equal_term t (Var x) then unify e bs
    else (if contains_var_term x t then Nothing
           else unify (subst_list (subst x t) e) ((x, t) : bs)));
unify ((Fun v va, Var x) : e) bs =
  (if contains_var_term x (Fun v va) then Nothing
    else unify (subst_list (subst x (Fun v va)) e) ((x, Fun v va) : bs));

mgu ::
  forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Maybe (b -> Term a b);
mgu s t =
  (case unify [(s, t)] [] of {
    Nothing -> Nothing;
    Just res -> Just (subst_of res);
  });

mgu_class ::
  forall a.
    (Eq a) => Term a (Sum () [Prelude.Char]) ->
                Term a [Prelude.Char] ->
                  Maybe ([Prelude.Char] -> Term a [Prelude.Char]);
mgu_class cs t =
  mgu (class_to_term 'z' cs) (map_term (\ x -> x) (\ a -> 'y' : a) t);

partition :: forall a. (a -> Bool) -> [a] -> ([a], [a]);
partition p [] = ([], []);
partition p (x : xs) =
  let {
    (yes, no) = partition p xs;
  } in (if p x then (x : yes, no) else (yes, x : no));

removeAll :: forall a. (Eq a) => a -> [a] -> [a];
removeAll x [] = [];
removeAll x (y : xs) = (if x == y then removeAll x xs else y : removeAll x xs);

span :: forall a. (a -> Bool) -> [a] -> ([a], [a]);
span p (x : xs) =
  (if p x then let {
                 a = span p xs;
                 (ys, aa) = a;
               } in (x : ys, aa)
    else ([], x : xs));
span uu [] = ([], []);

lookupb :: forall a b. (Ccompare a, Eq a) => Mapping a b -> a -> Maybe b;
lookupb (RBT_Mapping t) = lookupd t;
lookupb (Assoc_List_Mapping al) = lookupa al;

updateb ::
  forall a b. (Ccompare a, Eq a) => a -> b -> Mapping a b -> Mapping a b;
updateb k v (RBT_Mapping t) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "update RBT_Mapping: ccompare = None"
        (\ _ -> updateb k v (RBT_Mapping t));
    Just _ -> RBT_Mapping (inserte k v t);
  });
updateb k v (Assoc_List_Mapping al) = Assoc_List_Mapping (updatea k v al);
updateb k v (Mapping m) = Mapping (fun_upd m k (Just v));

match_term_list_code ::
  forall a b c.
    (Eq a, Ccompare b, Eq b,
      Eq c) => [(Term a b, Term a c)] ->
                 Mapping b (Term a c) -> Maybe (Mapping b (Term a c));
match_term_list_code ((Fun f ss, Var x) : p) sigma = Nothing;
match_term_list_code ((Fun f ss, Fun g ts) : p) sigma =
  (case decompose (Fun f ss) (Fun g ts) of {
    Nothing -> Nothing;
    Just us -> match_term_list_code (us ++ p) sigma;
  });
match_term_list_code ((Var x, t) : p) sigma =
  (if is_none (lookupb sigma x) || lookupb sigma x == Just t
    then match_term_list_code p (updateb x t sigma) else Nothing);
match_term_list_code [] sigma = Just sigma;

subst_of_map :: forall a b. (a -> b) -> (a -> Maybe b) -> a -> b;
subst_of_map d sigma x = (case sigma x of {
                           Nothing -> d x;
                           Just t -> t;
                         });

match_list ::
  forall a b c.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Eq c) => (a -> Term b c) ->
                 [(Term b a, Term b c)] -> Maybe (a -> Term b c);
match_list d p =
  map_option (subst_of_map d . lookupb) (match_term_list_code p emptyb);

match ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b -> Term a b -> Maybe (b -> Term a b);
match t l = match_list Var [(l, t)];

imagea ::
  forall a b.
    (Ceq a, Ccompare a, Ceq b, Ccompare b,
      Set_impl b) => Set (a, b) -> Set a -> Set b;
imagea (RBT_set rbt) c =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Image RBT_set: ccompare1 = None" (\ _ -> imagea (RBT_set rbt) c);
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "Image RBT_set: ccompare2 = None" (\ _ -> imagea (RBT_set rbt) c);
        Just _ ->
          foldb (\ (x, y) acc -> (if member x c then inserta y acc else acc))
            rbt bot_set;
      });
  });
imagea (DList_set dxs) b =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "Image DList_set: ceq1 = None" (\ _ -> imagea (DList_set dxs) b);
    Just _ ->
      (case (ceq :: Maybe (b -> b -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "Image DList_set: ceq2 = None" (\ _ -> imagea (DList_set dxs) b);
        Just _ ->
          foldc (\ (x, y) acc -> (if member x b then inserta y acc else acc))
            dxs bot_set;
      });
  });
imagea (Set_Monad rxs) a =
  Set_Monad
    (fold (\ (x, y) rest -> (if member x a then y : rest else rest)) rxs []);
imagea x y = image snd (filtera (\ (xa, _) -> member xa y) x);

zero :: forall a b. Partial_object_ext a (Monoid_ext a (Ring_ext a b)) -> a;
zero (Partial_object_ext carrier (Monoid_ext mult one (Ring_ext zero add more)))
  = zero;

args :: forall a b. Term a b -> [Term a b];
args (Var x1) = [];
args (Fun x21 x22) = x22;

aarity :: forall a. (a -> Nat -> [a]) -> a -> Nat -> Nat;
aarity sm f n = minus_nat (size_list (sm f n)) (Nat_of_num One);

ctxt ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Ctxt a [Prelude.Char]);
ctxt xml2name x =
  options
    [("box", leaf "box" Hole),
      ("funContext",
        tuple4 "funContext" xml2name (many "before" (term xml2name) id)
          (ctxt xml2name) (many "after" (term xml2name) id) More)]
    x;

xml3to4elements ::
  forall a b c d e.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (a -> b -> Maybe c -> d -> e) -> Xml -> Sum_bot [Prelude.Char] e;
xml3to4elements tag p1 p2 p3 p4 f (XML name atts cs) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts &&
               less_eq_nat (Nat_of_num (Bit1 One)) l &&
                 less_eq_nat l (Nat_of_num (Bit0 (Bit0 One)))
         then binda (p1 (nth cs Zero_nat))
                (\ x1 ->
                  binda (p2 (nth cs (Nat_of_num One)))
                    (\ x2 ->
                      (if equal_nat l (Nat_of_num (Bit0 (Bit0 One)))
                        then binda (p3 (nth cs (Nat_of_num (Bit0 One))))
                               (\ x3 ->
                                 binda (p4 (nth cs (Nat_of_num (Bit1 One))))
                                   (\ x4 -> returna (f x1 x2 (Just x3) x4)))
                        else binda (p4 (nth cs (Nat_of_num (Bit0 One))))
                               (\ x4 -> returna (f x1 x2 Nothing x4)))))
         else fail tag (XML name atts cs));
xml3to4elements tag p1 p2 p3 p4 f (XML_text v) = fail tag (XML_text v);

relstep ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                  (Bool, Term a [Prelude.Char])));
relstep xml2name =
  xml3to4elements "rewriteStep" pos (rule xml2name) (leaf "relative" ())
    (term xml2name) (\ p r rel t -> (p, (r, (is_none rel, t))));

relsteps ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                     (Bool, Term a [Prelude.Char])))]);
relsteps xml2name =
  many1 "rewriteSequence" (singleton "startTerm" (term xml2name) id)
    (relstep xml2name) (\ a b -> (a, b));

substa ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [([Prelude.Char], Term a [Prelude.Char])];
substa xml2name =
  many "substitution"
    (pair "substEntry" (text "var") (term xml2name) (\ a b -> (a, b))) id;

loop ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                      (Bool, Term a [Prelude.Char])))],
              ([([Prelude.Char], Term a [Prelude.Char])],
                Ctxt a [Prelude.Char])));
loop xml2name =
  triple "loop" (relsteps xml2name) (substa xml2name) (ctxt xml2name)
    (\ (s, rseq) sigma c -> (s, (rseq, (sigma, c))));

proj ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (ProjL a);
proj xml2name =
  change (afs xml2name)
    (\ afl ->
      Projection
        (map (\ (fa, a) ->
               (case a of {
                 Collapse aa -> (fa, aa);
                 AFList _ -> (fa, snd fa);
               }))
          afl));

real :: Xml -> Sum_bot [Prelude.Char] Real;
real x =
  catch_error (change rat of_rat x)
    (\ _ ->
      triple "algebraic" rat rat rat
        (\ a b c ->
          plus_real (of_rat a) (times_real (of_rat b) (sqrt (of_rat c))))
        x);

proj_term :: forall a b. ((a, Nat) -> Nat) -> Term a b -> Term a b;
proj_term p (Var x) = Var x;
proj_term p (Fun f ts) =
  let {
    n = size_list ts;
    i = p (f, n);
  } in (if less_nat i n then nth ts i else Fun f ts);

start_term ::
  forall a.
    (Eq a) => (Xml -> Sum_bot [Prelude.Char] a) ->
                Term a [Prelude.Char] ->
                  Xml -> Sum_bot [Prelude.Char] (Term a [Prelude.Char]);
start_term xml2name t =
  singleton "startTerm"
    (\ xml ->
      binda (term xml2name xml)
        (\ s ->
          (if equal_term s t then returna t
            else errora "<startTerm> does not match lhs")))
    id;

rstep ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                  Term a [Prelude.Char]));
rstep xml2name =
  triple "rewriteStep" pos (rule xml2name) (term xml2name)
    (\ p r t -> (p, (r, t)));

rseq ::
  forall a.
    (Eq a) => (Xml -> Sum_bot [Prelude.Char] a) ->
                ((a, Nat) -> Nat) ->
                  (Term a [Prelude.Char], Term a [Prelude.Char]) ->
                    Xml ->
                      Sum_bot [Prelude.Char]
                        ((Term a [Prelude.Char], Term a [Prelude.Char]),
                          [(Pos, ((Term a [Prelude.Char],
                                    Term a [Prelude.Char]),
                                   Term a [Prelude.Char]))]);
rseq xml2name pi r =
  many1 "rewriteSequence" (start_term xml2name (proj_term pi (fst r)))
    (rstep xml2name) (\ _ -> (\ a -> (r, a)));

label :: forall a b. Lab a b -> Nat -> Sum b [Lab a b] -> Lab a b;
label f n (Inl l) = Lab f l;
label f n (Inr l) = FunLab f l;

unlab :: forall a b. Lab a b -> Lab a b;
unlab (Lab f l) = f;
unlab (FunLab f l) = f;
unlab (UnLab v) = UnLab v;
unlab (Sharp v) = Sharp v;

emptyd :: forall a b. (Ccompare b, Mapping_impl b) => (a -> b) -> Multimap b a;
emptyd xa = Abs_multimap (xa, (emptyb, []));

rm_iterateoi ::
  forall a b c. Rbta a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
rm_iterateoi Emptya c f sigma = sigma;
rm_iterateoi (Branch col l k v r) c f sigma =
  (if c sigma
    then let {
           sigmaa = rm_iterateoi l c f sigma;
         } in (if c sigmaa then rm_iterateoi r c f (f (k, v) sigmaa)
                else sigmaa)
    else sigma);

iteratei_bmap_op_list_it_rm_basic_ops ::
  forall a b c.
    (Linorder a) => Rbt a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
iteratei_bmap_op_list_it_rm_basic_ops s = rm_iterateoi (impl_of s);

g_to_list_rm_basic_ops :: forall a b. (Linorder a) => Rbt a b -> [(a, b)];
g_to_list_rm_basic_ops m =
  iteratei_bmap_op_list_it_rm_basic_ops m (\ _ -> True) (\ a b -> a : b) [];

values :: forall a b. (Linorder a) => Rbt a [b] -> [b];
values m = concatMap snd (g_to_list_rm_basic_ops m);

single :: forall a. (Eq a) => a -> Multiset a;
single x = Bag (updatea x (Nat_of_num One) emptya);

tcapI ::
  forall a b. (Eq a, Eq b) => [(Term a b, Term a b)] -> Term a b -> Gctxt a b;
tcapI uu (Var uv) = GCHole;
tcapI r (Fun f ts) =
  let {
    h = GCFun f (map (tcapI r) ts);
  } in (if any (\ ra -> matchb h (fst ra)) r then GCHole else h);

funas_term ::
  forall a b. (Ceq a, Ccompare a, Set_impl a) => Term a b -> Set (a, Nat);
funas_term (Var uu) = bot_set;
funas_term (Fun f ts) =
  sup_set (inserta (f, size_list ts) bot_set)
    (foldr (sup_set . funas_term) ts bot_set);

sharp_term :: forall a b. (a -> a) -> Term a b -> Term a b;
sharp_term shp (Var x) = Var x;
sharp_term shp (Fun f ss) = Fun (shp f) ss;

hvf_top :: forall a b. (Eq a) => a -> Nat -> Term a b -> Bool;
hvf_top a n (Fun f ts) =
  (if f == a && equal_nat (size_list ts) n then not (is_Var (hd ts)) else True);
hvf_top a n (Var uu) = False;

status :: forall a. Status a -> (a, Nat) -> [Nat];
status (Abs_status x) = x;

af_wpo :: forall a. ((a, Nat) -> Set Nat) -> Status a -> (a, Nat) -> Set Nat;
af_wpo pi sigma f = sup_set (set (status sigma f)) (pi f);

lex_ext_unbounded ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
lex_ext_unbounded f [] [] = (False, True);
lex_ext_unbounded f (uu : uv) [] = (True, True);
lex_ext_unbounded f [] (uw : ux) = (False, False);
lex_ext_unbounded f (a : asa) (b : bs) =
  (case f a b of {
    (True, _) -> (True, True);
    (False, True) -> lex_ext_unbounded f asa bs;
    (False, False) -> (False, False);
  });

wpo_ub ::
  forall a b.
    (Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool)) ->
                ((a, Nat) -> Bool) ->
                  (Term a b -> Term a b -> Bool) ->
                    (Term a b -> Term a b -> Bool) ->
                      Status a -> Term a b -> Term a b -> (Bool, Bool);
wpo_ub pr prl cS cNS sigma s t =
  (case s of {
    Var x ->
      (False,
        (case t of {
          Var a -> x == a;
          Fun g ts ->
            cNS s t &&
              null (status sigma (g, size_list ts)) && prl (g, size_list ts);
        }));
    Fun f ss ->
      (if cS s t then (True, True)
        else let {
               ff = (f, size_list ss);
               sf = status sigma ff;
             } in (if cNS s t
                    then (if any (\ i ->
                                   snd (wpo_ub pr prl cS cNS sigma (nth ss i)
 t))
                               sf
                           then (True, True)
                           else (case t of {
                                  Var _ -> (False, False);
                                  Fun g ts ->
                                    let {
                                      gg = (g, size_list ts);
                                      sg = status sigma gg;
                                      (prs, prns) = pr ff gg;
                                    } in (if prns &&
       all (\ j -> fst (wpo_ub pr prl cS cNS sigma s (nth ts j))) sg
   then (if prs then (True, True)
          else lex_ext_unbounded (wpo_ub pr prl cS cNS sigma) (map (nth ss) sf)
                 (map (nth ts) sg))
   else (False, False));
                                }))
                    else (False, False)));
  });

crule ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ((Term a [Prelude.Char], Term a [Prelude.Char]),
            [(Term a [Prelude.Char], Term a [Prelude.Char])]);
crule xml2name =
  many1 "conditionalRule" (rule xml2name) (rule xml2name) (\ a b -> (a, b));

estep ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                  (Bool, Term a [Prelude.Char])));
estep xml2name =
  tuple4 "equationStep" pos (rule xml2name)
    (options
      [("leftRight", leaf "leftRight" True),
        ("rightLeft", leaf "rightLeft" False)])
    (term xml2name) (\ p r b t -> (p, (r, (b, t))));

rules ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char] [(Term a [Prelude.Char], Term a [Prelude.Char])];
rules xml2name = many "rules" (rule xml2name) id;

state :: Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
state = text "state";

isOK :: forall a b. Sum a b -> Bool;
isOK m = (case m of {
           Inl _ -> False;
           Inr _ -> True;
         });

mapM :: forall a b c. (a -> Sum b c) -> [a] -> Sum b [c];
mapM f [] = Inr [];
mapM f (x : xs) = bindb (f x) (\ y -> bindb (mapM f xs) (\ ys -> Inr (y : ys)));

one :: forall a b. Partial_object_ext a (Monoid_ext a b) -> a;
one (Partial_object_ext carrier (Monoid_ext mult one more)) = one;

list_update :: forall a. [a] -> Nat -> a -> [a];
list_update [] i y = [];
list_update (x : xs) i y =
  (if equal_nat i Zero_nat then y : xs
    else x : list_update xs (minus_nat i (Nat_of_num One)) y);

remdups_adj :: forall a. (Eq a) => [a] -> [a];
remdups_adj [] = [];
remdups_adj [x] = [x];
remdups_adj (x : y : xs) =
  (if x == y then remdups_adj (x : xs) else x : remdups_adj (y : xs));

base :: forall a. (a, Nat) -> a;
base (f, h) = f;

lift :: forall a. Nat -> a -> (a, Nat);
lift h f = (f, h);

add_vars_term :: forall a b. Term a b -> [b] -> [b];
add_vars_term (Var x) xs = x : xs;
add_vars_term (Fun uu ts) xs = foldr add_vars_term ts xs;

vars_term_list :: forall a b. Term a b -> [b];
vars_term_list t = add_vars_term t [];

roof ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Set_impl b) => (Term a b, Term a b) -> Term a b -> Bool;
roof (l, r) =
  let {
    xs = vars_term_list r;
  } in (\ t -> let {
                 xt = vars_term t;
               } in all (\ x -> member x xt) xs);

matches ::
  forall a b c.
    (Eq a, Eq b, Ccompare c, Eq c,
      Mapping_impl c) => Term a b -> Term a c -> Bool;
matches t p =
  (case match_list (\ _ -> t) [(p, t)] of {
    Nothing -> False;
    Just _ -> True;
  });

vec :: forall a. Nat -> [a] -> Bool;
vec n x = equal_nat (size_list x) n;

mat :: forall a. Nat -> Nat -> [[a]] -> Bool;
mat nr nc m = equal_nat (size_list m) nc && all (vec nr) m;

option_list_to_list :: forall a. Maybe [a] -> [a];
option_list_to_list Nothing = [];
option_list_to_list (Just asa) = asa;

rep_multimap :: forall a b. Multimap a b -> (b -> a, (Mapping a [b], [b]));
rep_multimap (Abs_multimap x) = x;

insertd :: forall a b. (Ccompare b, Eq b) => a -> Multimap b a -> Multimap b a;
insertd xb xc =
  Abs_multimap
    (let {
       (f, (m, alla)) = rep_multimap xc;
       k = f xb;
       old = option_list_to_list (lookupb m k);
       new = xb : old;
     } in (f, (updateb k new m, xb : alla)));

lookupc :: forall a b. (Ccompare a, Eq a) => Multimap a b -> a -> [b];
lookupc xa =
  let {
    (_, (m, _)) = rep_multimap xa;
  } in (\ k -> option_list_to_list (lookupb m k));

valuesa :: forall a b. Multimap a b -> [b];
valuesa xa = let {
               (_, (_, alla)) = rep_multimap xa;
             } in alla;

eq_monom :: forall a. (Eq a) => [(a, Nat)] -> [(a, Nat)] -> Bool;
eq_monom [] n = null n;
eq_monom ((x, p) : m) n =
  (case extract (\ yq -> fst yq == x) n of {
    Nothing -> False;
    Just (n1, ((_, q), n2)) -> equal_nat p q && eq_monom m (n1 ++ n2);
  });

poly_split ::
  forall a b.
    (Eq a, Zero b) => [(a, Nat)] -> [([(a, Nat)], b)] -> (b, [([(a, Nat)], b)]);
poly_split m p =
  (case extract (\ (n, _) -> eq_monom m n) p of {
    Nothing -> (zeroa, p);
    Just (p1, ((_, c), p2)) -> (c, p1 ++ p2);
  });

max_v ::
  forall a b.
    (Zero a,
      Ord a) => a -> ((b, Nat) -> [([(Nat, Nat)], a)]) -> [(b, Nat)] -> a;
max_v v i fs =
  max v (foldr (\ f m -> max m (fst (poly_split [] (i f)))) fs zeroa);

to_list :: Pos -> [Nat];
to_list Empty = [];
to_list (PCons i p) = i : to_list p;

relcomp ::
  forall a b c.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b, Ceq c, Ccompare c,
      Set_impl c) => Set (a, b) -> Set (b, c) -> Set (a, c);
relcomp (Set_Monad xs6) (DList_set dxs4) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad DList_set: ceq1 = None"
        (\ _ -> relcomp (Set_Monad xs6) (DList_set dxs4));
    Just eq ->
      (case (ceq :: Maybe (c -> c -> Bool)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp Set_Monad DList_set: ceq2 = None"
            (\ _ -> relcomp (Set_Monad xs6) (DList_set dxs4));
        Just _ ->
          fold (\ (x, y) ->
                 foldc (\ (ya, z) a ->
                         (if eq y ya then inserta (x, z) a else a))
                   dxs4)
            xs6 bot_set;
      });
  });
relcomp (DList_set dxs3) (Set_Monad xs5) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set Set_Monad: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs3) (Set_Monad xs5));
    Just _ ->
      (case ceq of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set Set_Monad: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs3) (Set_Monad xs5));
        Just eq ->
          foldc (\ (x, y) ->
                  fold (\ (ya, z) a ->
                         (if eq y ya then inserta (x, z) a else a))
                    xs5)
            dxs3 bot_set;
      });
  });
relcomp (Set_Monad xs4) (RBT_set rbt5) =
  (case (ccompare :: Maybe (c -> c -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad RBT_set: ccompare1 = None"
        (\ _ -> relcomp (Set_Monad xs4) (RBT_set rbt5));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp Set_Monad RBT_set: ccompare2 = None"
            (\ _ -> relcomp (Set_Monad xs4) (RBT_set rbt5));
        Just c_b ->
          fold (\ (x, y) ->
                 foldb (\ (ya, z) a ->
                         (if not (equal_order (c_b y ya) Eqa) then a
                           else inserta (x, z) a))
                   rbt5)
            xs4 bot_set;
      });
  });
relcomp (RBT_set rbt1) (Set_Monad xs3) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set Set_Monad: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt1) (Set_Monad xs3));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set Set_Monad: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt1) (Set_Monad xs3));
        Just c_b ->
          foldb (\ (x, y) ->
                  fold (\ (ya, z) a ->
                         (if not (equal_order (c_b y ya) Eqa) then a
                           else inserta (x, z) a))
                    xs3)
            rbt1 bot_set;
      });
  });
relcomp (Set_Monad xs1) (Set_Monad xs2) =
  (case ceq of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp Set_Monad Set_Monad: ceq = None"
        (\ _ -> relcomp (Set_Monad xs1) (Set_Monad xs2));
    Just eq ->
      fold (\ (x, y) ->
             fold (\ (ya, z) a -> (if eq y ya then inserta (x, z) a else a))
               xs2)
        xs1 bot_set;
  });
relcomp (DList_set dxs3) (DList_set dxs4) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set DList_set: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
    Just _ ->
      (case ceq of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set DList_set: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
        Just eq ->
          (case (ceq :: Maybe (c -> c -> Bool)) of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp DList_set DList_set: ceq3 = None"
                (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
            Just _ ->
              foldc (\ (x, y) ->
                      foldc (\ (ya, z) a ->
                              (if eq y ya then inserta (x, z) a else a))
                        dxs4)
                dxs3 bot_set;
          });
      });
  });
relcomp (DList_set dxs2) (RBT_set rbt4) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp DList_set RBT_set: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp DList_set RBT_set: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
        Just _ ->
          (case ceq of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp DList_set RBT_set: ccompare2 = None"
                (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
            Just eq ->
              (case (ccompare :: Maybe (c -> c -> Ordera)) of {
                Nothing ->
                  (error :: forall a. String -> (() -> a) -> a)
                    "relcomp DList_set RBT_set: ccompare3 = None"
                    (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
                Just _ ->
                  foldc (\ (x, y) ->
                          foldb (\ (ya, z) a ->
                                  (if eq y ya then inserta (x, z) a else a))
                            rbt4)
                    dxs2 bot_set;
              });
          });
      });
  });
relcomp (RBT_set rbt3) (DList_set dxs1) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set DList_set: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
    Just _ ->
      (case (ccompare :: Maybe (b -> b -> Ordera)) of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set DList_set: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
        Just _ ->
          (case ceq of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp RBT_set DList_set: ceq2 = None"
                (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
            Just eq ->
              (case (ceq :: Maybe (c -> c -> Bool)) of {
                Nothing ->
                  (error :: forall a. String -> (() -> a) -> a)
                    "relcomp RBT_set DList_set: ceq3 = None"
                    (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
                Just _ ->
                  foldb (\ (x, y) ->
                          foldc (\ (ya, z) a ->
                                  (if eq y ya then inserta (x, z) a else a))
                            dxs1)
                    rbt3 bot_set;
              });
          });
      });
  });
relcomp (RBT_set rbt1) (RBT_set rbt2) =
  (case (ccompare :: Maybe (a -> a -> Ordera)) of {
    Nothing ->
      (error :: forall a. String -> (() -> a) -> a)
        "relcomp RBT_set RBT_set: ccompare1 = None"
        (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
    Just _ ->
      (case ccompare of {
        Nothing ->
          (error :: forall a. String -> (() -> a) -> a)
            "relcomp RBT_set RBT_set: ccompare2 = None"
            (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
        Just c_b ->
          (case (ccompare :: Maybe (c -> c -> Ordera)) of {
            Nothing ->
              (error :: forall a. String -> (() -> a) -> a)
                "relcomp RBT_set RBT_set: ccompare3 = None"
                (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
            Just _ ->
              foldb (\ (x, y) ->
                      foldb (\ (ya, z) a ->
                              (if not (equal_order (c_b y ya) Eqa) then a
                                else inserta (x, z) a))
                        rbt2)
                rbt1 bot_set;
          });
      });
  });

shows_lines :: forall a. (Showa a) => [a] -> [Prelude.Char] -> [Prelude.Char];
shows_lines = shows_sep (shows_prec Zero_nat) shows_nl;

map_sum :: forall a b c d. (a -> b) -> (c -> d) -> Sum a c -> Sum b d;
map_sum f1 f2 (Inl a) = Inl (f1 a);
map_sum f1 f2 (Inr a) = Inr (f2 a);

tcapRM2 ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> [(Term a b, Term a b)]) -> Term a b -> Gctxt a b;
tcapRM2 uu (Var uv) = GCHole;
tcapRM2 rm (Fun f ts) =
  let {
    h = GCFun f (map (tcapRM2 rm) ts);
    n = size_list ts;
  } in (if any (\ r -> matchb h (fst r)) (rm (f, n)) then GCHole else h);

tcapRM ::
  forall a b.
    (Eq a,
      Eq b) => Bool ->
                 ((a, Nat) -> [(Term a b, Term a b)]) -> Term a b -> Gctxt a b;
tcapRM nlv rm = (if nlv then tcapRM2 rm else (\ _ -> GCHole));

linear_term_impl ::
  forall a b. (Ceq a, Ccompare a) => Set a -> Term b a -> Maybe (Set a);
linear_term_impl xs (Var x) =
  (if member x xs then Nothing else Just (inserta x xs));
linear_term_impl xs (Fun uu []) = Just xs;
linear_term_impl xs (Fun f (t : ts)) =
  (case linear_term_impl xs t of {
    Nothing -> Nothing;
    Just ys -> linear_term_impl ys (Fun f ts);
  });

linear_term :: forall a b. (Ceq b, Ccompare b, Set_impl b) => Term a b -> Bool;
linear_term t = not (is_none (linear_term_impl bot_set t));

ctxt_of_pos_term :: forall a b. Pos -> Term a b -> Ctxt a b;
ctxt_of_pos_term Empty t = Hole;
ctxt_of_pos_term (PCons i ps) (Fun f ts) =
  More f (take i ts) (ctxt_of_pos_term ps (nth ts i))
    (drop (plus_nat i (Nat_of_num One)) ts);

ctxt_apply_term :: forall a b. Ctxt a b -> Term a b -> Term a b;
ctxt_apply_term Hole s = s;
ctxt_apply_term (More f ss1 c ss2) s = Fun f (ss1 ++ ctxt_apply_term c s : ss2);

poss_list :: forall a b. Term a b -> [Pos];
poss_list (Var x) = [Empty];
poss_list (Fun f ss) =
  Empty :
    concatMap (\ (i, a) -> map (PCons i) a)
      (zip (upt Zero_nat (size_list ss)) (map poss_list ss));

rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
rewrite r s =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ p ->
          (case match (subt_at s p) l of {
            Nothing -> [];
            Just sigma ->
              [ctxt_apply_term (ctxt_of_pos_term p s)
                 (subst_apply_term ra sigma)];
          }))
        (poss_list s))
    r;

hvf_term :: forall a b. (Eq a) => a -> Term a b -> Bool;
hvf_term a t =
  (case unapp a t of {
    (Var _, ts) -> null ts;
    (Fun _ us, ts) -> all (hvf_term a) (us ++ ts);
  });

max_list :: [Nat] -> Nat;
max_list [] = Zero_nat;
max_list (x : xs) = max x (max_list xs);

num_children :: Xml -> Nat;
num_children (XML uu uv cs) = size_list cs;
num_children (XML_text uw) = Zero_nat;

map_default :: forall a b. (Eq a) => a -> b -> (b -> b) -> [(a, b)] -> [(a, b)];
map_default k v f [] = [(k, v)];
map_default k v f (p : ps) =
  (if fst p == k then (k, f (snd p)) : ps else p : map_default k v f ps);

crules ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]),
             [(Term a [Prelude.Char], Term a [Prelude.Char])])];
crules xml2name = many "conditionalRules" (crule xml2name) id;

string ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] [a];
string xml2name = many "string" xml2name id;

oc_srs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ([a], [a]);
oc_srs xml2name =
  pair "overlapClosureSRS" (string xml2name) (string xml2name)
    (\ a b -> (a, b));

rsteps ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                     Term a [Prelude.Char]))]);
rsteps xml2name =
  many1 "rewriteSequence" (singleton "startTerm" (term xml2name) id)
    (rstep xml2name) (\ a b -> (a, b));

check :: forall a. Bool -> a -> Sum a ();
check b e = (if b then Inr () else Inl e);

degree :: Complexity_class -> Nat;
degree (Comp_Poly d) = d;

catch_errora :: forall a b c. Sum a b -> (a -> Sum c b) -> Sum c b;
catch_errora m f = (case m of {
                     Inl a -> f a;
                     Inr a -> Inr a;
                   });

check_no_edge ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ((a, a) -> Bool) -> a -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_edge ss g m n =
  check (not (g (m, n)))
    (shows_string "edge from " . ss m . shows_string " to " . ss n);

forallM :: forall a b. (a -> Sum b ()) -> [a] -> Sum (a, b) ();
forallM f [] = Inr ();
forallM f (x : xs) =
  bindb (catch_errora (f x) (\ xa -> Inl (x, xa))) (\ _ -> forallM f xs);

check_edges ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ((a, a) -> Bool) ->
        [a] -> [a] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_edges ss g c d =
  catch_errora
    (forallM
      (\ n ->
        catch_errora (forallM (check_no_edge ss g n) d) (\ x -> Inl (snd x)))
      c)
    (\ x -> Inl (snd x));

mult :: forall a b. Partial_object_ext a (Monoid_ext a b) -> a -> a -> a;
mult (Partial_object_ext carrier (Monoid_ext mult one more)) = mult;

matcha :: forall a b. (Term a b, Term a b) -> Term a b -> Bool;
matcha = (\ _ _ -> True);

fresh_strings_list ::
  [Prelude.Char] -> Nat -> [[Prelude.Char]] -> Nat -> [[Prelude.Char]];
fresh_strings_list name offset used n =
  take n
    (filter (\ s -> not (membera (remdups used) s))
      (map (\ i -> name ++ shows_prec_nat Zero_nat (plus_nat i offset) [])
        (upt Zero_nat (plus_nat n (size_list (remdups used))))));

fresh_string :: [Prelude.Char] -> [[Prelude.Char]] -> [Prelude.Char];
fresh_string pre =
  (\ s -> hd (fresh_strings_list pre (Nat_of_num One) s (Nat_of_num One)));

mapMa :: forall a b. (a -> Maybe b) -> [a] -> Maybe [b];
mapMa f [] = Just [];
mapMa f (x : xs) =
  bind (f x) (\ y -> bind (mapMa f xs) (\ ys -> Just (y : ys)));

equal_order_tag :: Order_tag -> Order_tag -> Bool;
equal_order_tag Lex Mul = False;
equal_order_tag Mul Lex = False;
equal_order_tag Mul Mul = True;
equal_order_tag Lex Lex = True;

any_nstri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> (Bool, b);
any_nstri_efficient_m f [] m = (False, m);
any_nstri_efficient_m f (a : asa) m =
  let {
    aa = f a m;
    (ab, b) = aa;
  } in let {
         (_, ns) = ab;
       } in (\ ma ->
              (if ns then (True, ma) else any_nstri_efficient_m f asa ma))
         b;

all_stri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> (Bool, b);
all_stri_efficient_m f [] m = (True, m);
all_stri_efficient_m f (a : asa) m =
  let {
    aa = f a m;
    (ab, b) = aa;
  } in let {
         (s, _) = ab;
       } in (\ ma -> (if s then all_stri_efficient_m f asa ma else (False, ma)))
         b;

filter_not_stri_efficient_m_aux ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ([a], b);
filter_not_stri_efficient_m_aux f [] bs m = (bs, m);
filter_not_stri_efficient_m_aux f (a : asa) bs m =
  let {
    b = f a m;
    (ba, c) = b;
  } in let {
         (s, _) = ba;
       } in (\ ma ->
              (if s then filter_not_stri_efficient_m_aux f asa bs ma
                else filter_not_stri_efficient_m_aux f asa (a : bs) ma))
         c;

filter_not_stri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> ([a], b);
filter_not_stri_efficient_m f asa m =
  let {
    a = filter_not_stri_efficient_m_aux f asa [] m;
    (ys, aa) = a;
  } in (reverse ys, aa);

mul_ext_efficient_m ::
  forall a b.
    (Eq a) => (a -> a -> b -> ((Bool, Bool), b)) ->
                [a] -> [a] -> b -> ((Bool, Bool), b);
mul_ext_efficient_m f [] [] m = ((False, True), m);
mul_ext_efficient_m f [] (v : va) m = ((False, False), m);
mul_ext_efficient_m f (v : va) [] m = ((True, True), m);
mul_ext_efficient_m f (v : va) (y : ys) m =
  ex_dom_efficient_m f y (v : va) (v : va) ys m;

ex_dom_efficient_m ::
  forall a b.
    (Eq a) => (a -> a -> b -> ((Bool, Bool), b)) ->
                a -> [a] -> [a] -> [a] -> b -> ((Bool, Bool), b);
ex_dom_efficient_m f y [] uw ux m = ((False, False), m);
ex_dom_efficient_m f y (b : bs) xs ys m =
  let {
    a = f b y m;
    (aa, c) = a;
  } in let {
         (s, ns) = aa;
       } in (\ ma ->
              (if s then let {
                           (ysa, m2) = filter_not_stri_efficient_m (f b) ys ma;
                           ab = mul_ext_efficient_m f (remove1 b xs) ysa m2;
                           (ac, ba) = ab;
                         } in let {
                                (_, ns1) = ac;
                              } in (\ m3 ->
                                     (if ns1 then ((True, True), m3)
                                       else ex_dom_efficient_m f y bs xs ys m3))
                                ba
                else (if ns
                       then let {
                              ab = mul_ext_efficient_m f (remove1 b xs) ys ma;
                              (ac, ba) = ab;
                            } in let {
                                   (s1, ns1) = ac;
                                 } in (\ mb ->
(if s1 then ((True, True), mb)
  else let {
         ad = ex_dom_efficient_m f y bs xs ys mb;
         (ae, bb) = ad;
       } in let {
              (s2, ns2) = ae;
            } in (\ m3 ->
                   (if s2 then ((True, True), m3)
                     else ((False, ns1 || ns2), m3)))
              bb))
                                   ba
                       else ex_dom_efficient_m f y bs xs ys ma)))
         c;

lex_ext_efficient_m ::
  forall a b.
    (a -> a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ((Bool, Bool), b);
lex_ext_efficient_m f [] [] m = ((False, True), m);
lex_ext_efficient_m f (uu : uv) [] m = ((True, True), m);
lex_ext_efficient_m f [] (uw : ux) m = ((False, False), m);
lex_ext_efficient_m f (a : asa) (b : bs) m =
  let {
    aa = f a b m;
    (ab, ba) = aa;
  } in let {
         (s, ns) = ab;
       } in (\ ma ->
              (if s then ((True, True), ma)
                else (if ns then lex_ext_efficient_m f asa bs ma
                       else ((False, False), ma))))
         ba;

lookupe :: forall a b c d. Memory_ext a b c d -> a -> b -> Maybe c;
lookupe (Memory_ext empty lookup store more) = lookup;

store :: forall a b c d. Memory_ext a b c d -> a -> (b, c) -> a;
store (Memory_ext empty lookup store more) = store;

diag_l :: forall a b. (a, b) -> ((a, a), b);
diag_l (a, b) = ((a, a), b);

rpo_efficient_m ::
  forall a b c.
    (Eq b,
      Eq c) => Memory_ext a (Term b c, Term b c) (Bool, Bool) () ->
                 ((b, Nat) -> (b, Nat) -> (Bool, Bool), (b, Nat) -> Bool) ->
                   ((b, Nat) -> Order_tag) ->
                     Term b c -> Term b c -> a -> ((Bool, Bool), a);
rpo_efficient_m model pr tag s t m =
  (case lookupe model m (s, t) of {
    Nothing ->
      let {
        (res, res_m) =
          (case (s, t) of {
            (Var x, Var y) -> ((False, x == y), m);
            (Var _, Fun g ts) -> ((False, null ts && snd pr (g, Zero_nat)), m);
            (Fun _ ss, Var y) ->
              diag_l
                (any_nstri_efficient_m
                  (\ sa -> rpo_efficient_m model pr tag sa (Var y)) ss m);
            (Fun f ss, Fun g ts) ->
              (case any_nstri_efficient_m
                      (\ sa -> rpo_efficient_m model pr tag sa (Fun g ts)) ss m
                of {
                (True, ma) -> ((True, True), ma);
                (False, ma) ->
                  let {
                    maa = size_list ss;
                    n = size_list ts;
                  } in (case fst pr (f, maa) (g, n) of {
                         (prs, True) ->
                           (case all_stri_efficient_m
                                   (rpo_efficient_m model pr tag (Fun f ss)) ts
                                   ma
                             of {
                             (True, mb) ->
                               (if prs then ((True, True), mb)
                                 else let {
cf = tag (f, maa);
                                      } in
(if equal_order_tag cf (tag (g, n))
  then (if equal_order_tag cf Mul
         then mul_ext_efficient_m (rpo_efficient_m model pr tag) ss ts mb
         else lex_ext_efficient_m (rpo_efficient_m model pr tag) ss ts mb)
  else let {
         b = equal_nat n Zero_nat;
       } in ((not (equal_nat maa Zero_nat) && b, b), mb)));
                             (False, mb) -> ((False, False), mb);
                           });
                         (_, False) -> ((False, False), ma);
                       });
              });
          });
      } in (res, store model res_m ((s, t), res));
    Just v -> (v, m);
  });

emptyf :: forall a b c d. Memory_ext a b c d -> () -> a;
emptyf (Memory_ext empty lookup store more) = empty;

efficient_rpo_2 ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
efficient_rpo_2 pr tag p q =
  fst (rpo_efficient_m l2m pr tag p q (emptyf l2m ()));

rpo_unbounded_impl ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
rpo_unbounded_impl = efficient_rpo_2;

rpo_unbounded ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                 ((a, Nat) -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
rpo_unbounded = rpo_unbounded_impl;

converse ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a, Ceq b, Ccompare b,
      Set_impl b) => Set (a, b) -> Set (b, a);
converse r = image (\ (x, y) -> (y, x)) r;

zero_multiset :: forall a. Multiset a;
zero_multiset = Bag emptya;

join_raw ::
  forall a b. (Eq a) => (a -> (b, b) -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
join_raw f xs ys =
  foldr (\ (k, v) -> map_default k v (\ va -> f k (va, v))) ys xs;

joina ::
  forall a b.
    (Eq a) => (a -> (b, b) -> b) -> Alist a b -> Alist a b -> Alist a b;
joina xc xd xe = Alist (join_raw xc (impl_ofa xd) (impl_ofa xe));

plus_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
plus_multiset (Bag xs) (Bag ys) =
  Bag (joina (\ _ (a, b) -> plus_nat a b) xs ys);

fold_impl :: forall a b. (a -> Nat -> b -> b) -> b -> [(a, Nat)] -> b;
fold_impl fn e ((a, n) : ms) = fold_impl fn (fn a n e) ms;
fold_impl fn e [] = e;

foldd :: forall a b. (a -> Nat -> b -> b) -> b -> Alist a Nat -> b;
foldd f e al = fold_impl f e (impl_ofa al);

union_mset :: forall a. (Eq a) => Multiset (Multiset a) -> Multiset a;
union_mset (Bag ms) =
  foldd (\ a n -> funpow n (plus_multiset a)) zero_multiset ms;

multiset_of :: forall a. (Eq a) => [a] -> Multiset a;
multiset_of (a : x) = plus_multiset (multiset_of x) (single a);
multiset_of [] = zero_multiset;

funs_term_ms :: forall a b. (Eq a) => Term a b -> Multiset a;
funs_term_ms (Var x) = zero_multiset;
funs_term_ms (Fun f ts) =
  plus_multiset (single f) (union_mset (multiset_of (map funs_term_ms ts)));

subt_at_ctxt :: forall a b. Ctxt a b -> Pos -> Ctxt a b;
subt_at_ctxt c Empty = c;
subt_at_ctxt (More f bef c aft) (PCons i p) = subt_at_ctxt c p;

the_Var :: forall a b. Term a b -> b;
the_Var (Var x1) = x1;

vars_term_ms :: forall a b. (Eq b) => Term a b -> Multiset b;
vars_term_ms (Var x) = single x;
vars_term_ms (Fun f ts) = union_mset (multiset_of (map vars_term_ms ts));

in_poss :: forall a b. Pos -> Term a b -> Bool;
in_poss Empty uu = True;
in_poss (PCons i p) (Fun f ts) =
  less_nat i (size_list ts) && in_poss p (nth ts i);
in_poss (PCons i p) (Var uv) = False;

add_funs_term :: forall a b. Term a b -> [a] -> [a];
add_funs_term (Var uu) fs = fs;
add_funs_term (Fun f ts) fs = f : foldr add_funs_term ts fs;

add_funs_rule :: forall a b. (Term a b, Term a b) -> [a] -> [a];
add_funs_rule r fs = add_funs_term (fst r) (add_funs_term (snd r) fs);

funs_trs_list :: forall a b. [(Term a b, Term a b)] -> [a];
funs_trs_list trs = foldr add_funs_rule trs [];

instance_rule ::
  forall a b c.
    (Eq a, Eq b, Ccompare c, Eq c,
      Mapping_impl c) => (Term a b, Term a b) -> (Term a c, Term a c) -> Bool;
instance_rule lr st =
  not (is_none
        (match_list (\ _ -> fst lr) [(fst st, fst lr), (snd st, snd lr)]));

map_funs_rule ::
  forall a b c. (a -> b) -> (Term a c, Term a c) -> (Term b c, Term b c);
map_funs_rule fg lr =
  (map_term fg (\ x -> x) (fst lr), map_term fg (\ x -> x) (snd lr));

add_vars_rule :: forall a b. (Term a b, Term a b) -> [b] -> [b];
add_vars_rule r xs = add_vars_term (fst r) (add_vars_term (snd r) xs);

vars_trs_list :: forall a b. [(Term a b, Term a b)] -> [b];
vars_trs_list trs = foldr add_vars_rule trs [];

label_depth :: forall a b. Lab a b -> Nat;
label_depth (UnLab uu) = Zero_nat;
label_depth (Lab f uv) = plus_nat (label_depth f) (Nat_of_num One);
label_depth (FunLab f uw) = plus_nat (label_depth f) (Nat_of_num One);
label_depth (Sharp f) = plus_nat (label_depth f) (Nat_of_num One);

gen_label :: forall a b. Lab a b -> Nat -> Lab a b;
gen_label f n =
  (if equal_nat n Zero_nat then f
    else FunLab (gen_label f (minus_nat n (Nat_of_num One))) []);

fmap ::
  forall a b.
    (Eq a,
      Eq b) => Lab a b ->
                 Nat ->
                   [((Lab a b, Nat), [Lab a b])] -> Lab a b -> Nat -> Lab a b;
fmap a nn sml =
  let {
    m = plus_nat (max_list (map label_depth (a : concatMap snd sml)))
          (Nat_of_num One);
  } in (\ f n -> (if (f, n) == (a, nn) then a else gen_label f m));

enum_vectors :: forall a b. [a] -> [b] -> [[(b, a)]];
enum_vectors c [] = [[]];
enum_vectors c (x : xs) =
  let {
    a = enum_vectors c xs;
  } in concatMap (\ vec -> map (\ ca -> (x, ca) : vec) c) a;

replace_impl :: forall a. (Eq a) => a -> [a] -> [a] -> [a];
replace_impl a bs m =
  (if membera m a then bs ++ filter (\ b -> not (b == a)) m else m);

doc_of_string :: [Prelude.Char] -> Sum [Prelude.Char] Xmldoc;
doc_of_string s = bindb (parse_doc s) (\ (doc, _) -> Inr doc);

pat_eqv_prf ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Pat_eqv_prf a [Prelude.Char]);
pat_eqv_prf xml2name =
  let {
    sub = substa xml2name;
  } in singleton "patternEquivalence"
         (options
           [("domainRenaming", singleton "domainRenaming" sub Pat_Dom_Renaming),
             ("irrelevant", pair "irrelevant" sub sub Pat_Irrelevant),
             ("simplification", pair "simplification" sub sub Pat_Simplify)])
         id;

pat_term ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            ([([Prelude.Char], Term a [Prelude.Char])],
              [([Prelude.Char], Term a [Prelude.Char])]));
pat_term xml2name =
  triple "patternTerm" (term xml2name) (substa xml2name) (substa xml2name)
    (\ t s1 s2 -> (t, (s1, s2)));

pat_rule_prf ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Pat_rule_prf a [Prelude.Char]);
pat_rule_prf xml2name x =
  let {
    pat = pat_rule_prf xml2name;
    sub = substa xml2name;
    pt = pat_term xml2name;
    var = text "var";
  } in triple "patternRule" pt pt
         (options
           [("originalRule",
              pair "originalRule" (rule xml2name) (bool "isPair") Pat_OrigRule),
             ("initialPumping",
               triple "initialPumping" pat sub sub Pat_InitPump),
             ("initialPumpingContext",
               tuple4 "initialPumpingContext" pat sub pos var Pat_InitPumpCtxt),
             ("equivalence",
               triple "equivalence" pat
                 (options
                   [("left", leaf "left" True), ("right", leaf "right" False)])
                 (pat_eqv_prf xml2name) Pat_Equiv),
             ("narrowing", triple "narrowing" pat pat pos Pat_Narrow),
             ("instantiation",
               triple "instantiation" pat sub
                 (options
                   [("base", leaf "base" Pat_Base),
                     ("pumping", leaf "pumping" Pat_Pump),
                     ("closing", leaf "closing" Pat_Close)])
                 Pat_Inst),
             ("instantiationPumping",
               pair "instantiationPumping" pat (nata "power") Pat_Exp_Sigma),
             ("rewriting",
               triple "rewriting" pat (rsteps xml2name)
                 (options
                   [("base", leaf "base" (Pat_Base, [])),
                     ("pumping",
                       singleton "pumping" var (\ a -> (Pat_Pump, a))),
                     ("closing",
                       singleton "closing" var (\ a -> (Pat_Close, a)))])
                 (\ p seq (a, b) -> Pat_Rewr p seq a b))])
         (\ _ _ z -> z) x;

nonloop ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Non_loop_prf a [Prelude.Char]);
nonloop xml2name =
  tuple6 "nonLoop" (pat_rule_prf xml2name) (substa xml2name) (substa xml2name)
    (nata "natural") (nata "natural") pos Non_loop_prf;

symbols ::
  forall a.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] [(a, Nat)];
symbols tagname xml2name =
  many tagname (pair "symbol" xml2name (nata "arity") (\ a b -> (a, b))) id;

xml_lab :: forall a b. (Showa a, Showa b) => Lab a [b] -> Xml;
xml_lab (UnLab x) = XML "name" [] [XML_text (shows_prec Zero_nat x [])];
xml_lab (Sharp x) = XML "sharp" [] [xml_lab x];
xml_lab (FunLab x l) =
  XML "labeledSymbol" [] [xml_lab x, XML "symbolLabel" [] (map xml_lab l)];
xml_lab (Lab x l) =
  XML "labeledSymbol" []
    [xml_lab x,
      XML "numberLabel" []
        (map (\ n -> XML "number" [] [XML_text (shows_prec Zero_nat n [])]) l)];

xml_single_pos :: Nat -> Xml;
xml_single_pos i =
  XML "position" []
    [XML_text (shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) [])];

xml_pos :: Pos -> Xml;
xml_pos p = XML "positionInTerm" [] (map xml_single_pos (to_list p));

eq_set ::
  forall a. (Card_UNIV a, Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
eq_set = set_eq;

min :: forall a. (Ord a) => a -> a -> a;
min a b = (if less_eq a b then a else b);

min_list :: forall a. (Linorder a) => [a] -> a;
min_list [x] = x;
min_list (x : v : va) = min x (min_list (v : va));

height :: forall a. (a, Nat) -> Nat;
height (f, h) = h;

vec0I :: forall a. a -> Nat -> [a];
vec0I ze n = replicate n ze;

mat0I :: forall a. a -> Nat -> Nat -> [[a]];
mat0I ze nr nc = replicate nc (vec0I ze nr);

vec1I :: forall a. a -> a -> Nat -> Nat -> [a];
vec1I ze on n i =
  replicate i ze ++
    on : replicate (minus_nat (minus_nat n (Nat_of_num One)) i) ze;

mat1I :: forall a. a -> a -> Nat -> [[a]];
mat1I ze on n = map (vec1I ze on n) (upt Zero_nat n);

check_poly_ge ::
  forall a b.
    (Eq a,
      Ordered_semiring_0 b) => [([(a, Nat)], b)] -> [([(a, Nat)], b)] -> Bool;
check_poly_ge [] q = all (\ (_, d) -> less_eq d zeroa) q;
check_poly_ge ((m, c) : p) q =
  (case extract (\ nd -> eq_monom (fst nd) m) q of {
    Nothing -> less_eq zeroa c && check_poly_ge p q;
    Just (q1, ((_, d), q2)) -> less_eq d c && check_poly_ge p (q1 ++ q2);
  });

check_poly_gt ::
  forall a b.
    (Ordered_semiring_0 a,
      Eq b) => (a -> a -> Bool) ->
                 [([(b, Nat)], a)] -> [([(b, Nat)], a)] -> Bool;
check_poly_gt gt p q =
  let {
    (a1, p1) = poly_split [] p;
    (b1, q1) = poly_split [] q;
  } in gt a1 b1 && check_poly_ge p1 q1;

shows_monom ::
  forall a. (Showa a) => [(a, Nat)] -> [Prelude.Char] -> [Prelude.Char];
shows_monom [(x, p)] =
  (if equal_nat p (Nat_of_num One) then shows_prec Zero_nat x
    else shows_prec Zero_nat x . shows_string "^" . shows_prec_nat Zero_nat p);
shows_monom ((x, p) : v : va) =
  (if equal_nat p (Nat_of_num One) then shows_prec Zero_nat x
    else shows_prec Zero_nat x . shows_string "^" . shows_prec_nat Zero_nat p) .
    shows_string "*" . shows_monom (v : va);
shows_monom [] = shows_string "1";

shows_poly ::
  forall a b.
    (Showa a, Eq b, Poly_carrier b,
      Showa b) => [([(a, Nat)], b)] -> [Prelude.Char] -> [Prelude.Char];
shows_poly [] = shows_string "0";
shows_poly ((m, c) : p) =
  (if c == onea then shows_monom m
    else (if null m then shows_prec Zero_nat c
           else shows_prec Zero_nat c . shows_string "*" . shows_monom m)) .
    (if null p then shows_string [] else shows_string " + " . shows_poly p);

monom_mult :: forall a. (Eq a) => [(a, Nat)] -> [(a, Nat)] -> [(a, Nat)];
monom_mult [] n = n;
monom_mult ((x, p) : m) n =
  (case extract (\ yq -> fst yq == x) n of {
    Nothing -> (x, p) : monom_mult m n;
    Just (n1, ((_, q), n2)) -> (x, plus_nat p q) : monom_mult m (n1 ++ n2);
  });

monom_mult_poly ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => ([(a, Nat)], b) ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
monom_mult_poly uu [] = [];
monom_mult_poly (ma, c) ((m, d) : p) =
  (if times c d == zeroa then monom_mult_poly (ma, c) p
    else (monom_mult ma m, times c d) : monom_mult_poly (ma, c) p);

poly_add ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
poly_add [] q = q;
poly_add ((m, c) : p) q =
  (case extract (\ mc -> eq_monom (fst mc) m) q of {
    Nothing -> (m, c) : poly_add p q;
    Just (q1, ((_, d), q2)) ->
      (if plus c d == zeroa then poly_add p (q1 ++ q2)
        else (m, plus c d) : poly_add p (q1 ++ q2));
  });

poly_mult ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
poly_mult [] q = [];
poly_mult (mc : p) q = poly_add (monom_mult_poly mc q) (poly_mult p q);

one_poly :: forall a b. (Semiring_1 b) => [([(a, Nat)], b)];
one_poly = [([], onea)];

poly_power ::
  forall a b.
    (Eq a, Eq b,
      Comm_semiring_1 b) => [([(a, Nat)], b)] -> Nat -> [([(a, Nat)], b)];
poly_power uu n =
  (if equal_nat n Zero_nat then one_poly
    else poly_mult uu (poly_power uu (minus_nat n (Nat_of_num One))));

monom_subst ::
  forall a b c.
    (Eq b, Eq c,
      Comm_semiring_1 c) => (a -> [([(b, Nat)], c)]) ->
                              [(a, Nat)] -> [([(b, Nat)], c)];
monom_subst sigma [] = one_poly;
monom_subst sigma ((x, p) : m) =
  poly_mult (poly_power (sigma x) p) (monom_subst sigma m);

zero_poly :: forall a b. [([(a, Nat)], b)];
zero_poly = [];

poly_subst ::
  forall a b c.
    (Eq b, Eq c,
      Comm_semiring_1 c) => (a -> [([(b, Nat)], c)]) ->
                              [([(a, Nat)], c)] -> [([(b, Nat)], c)];
poly_subst sigma [] = zero_poly;
poly_subst sigma ((m, c) : p) =
  poly_add (poly_mult [([], c)] (monom_subst sigma m)) (poly_subst sigma p);

eval_term ::
  forall a b c.
    (Eq b, Poly_carrier b,
      Eq c) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                 Term a c -> [([(c, Nat)], b)];
eval_term uu (Var x) = [([(x, Nat_of_num One)], onea)];
eval_term i (Fun f ts) =
  let {
    ps = map (eval_term i) ts;
    n = size_list ts;
  } in poly_subst (\ ia -> (if less_nat ia n then nth ps ia else zero_poly))
         (i (f, n));

check_s ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Showa b, Eq c,
      Showa c) => (a -> a -> Bool) ->
                    ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                      (Term b c, Term b c) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_s gt i =
  (\ (s, t) ->
    let {
      p = eval_term i s;
      q = eval_term i t;
    } in check (check_poly_gt gt p q)
           (shows_string "could not ensure " .
             shows_prec_term Zero_nat s .
               shows_string " > " .
                 shows_prec_term Zero_nat t .
                   shows_string " since we " .
                     shows_nl .
                       shows_string "could not ensure " .
                         shows_poly p . shows_string " > " . shows_poly q));

poly_of ::
  forall a b. (Eq a, Eq b, Comm_semiring_1 b) => Tpoly a b -> [([(a, Nat)], b)];
poly_of (PNum i) = (if i == zeroa then [] else [([], i)]);
poly_of (PVar x) = [([(x, Nat_of_num One)], onea)];
poly_of (PSum []) = zero_poly;
poly_of (PSum (p : ps)) = poly_add (poly_of p) (poly_of (PSum ps));
poly_of (PMult []) = one_poly;
poly_of (PMult (p : ps)) = poly_mult (poly_of p) (poly_of (PMult ps));

shows_pos :: Pos -> [Prelude.Char] -> [Prelude.Char];
shows_pos (PCons i Empty) =
  shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One));
shows_pos (PCons i (PCons v va)) =
  shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) .
    shows_pos (PCons v va);
shows_pos Empty = shows_string "epsilon";

shows_rpo_repr ::
  forall a.
    (Showa a) => [((a, Nat), (Nat, Order_tag))] ->
                   [Prelude.Char] -> [Prelude.Char];
shows_rpo_repr prs =
  ((((((((((shows_prec_list Zero_nat "RPO with the following precedence" .
             shows_nl) .
            foldr (\ (a, b) ->
                    let {
                      (f, n) = a;
                    } in (\ (pr, _) ->
                           (((((shows_prec_list Zero_nat "precedence(" .
                                 shows_prec Zero_nat f) .
                                shows_prec_list Zero_nat "[") .
                               shows_prec_nat Zero_nat n) .
                              shows_prec_list Zero_nat "]) = ") .
                             shows_prec_nat Zero_nat pr) .
                             shows_nl)
                      b)
              prs) .
           shows_nl) .
          shows_prec_list Zero_nat "precedence(_) = 0") .
         shows_nl) .
        shows_prec_list Zero_nat "and the following status") .
       shows_nl) .
      foldr (\ (a, b) ->
              let {
                (f, n) = a;
              } in (\ (_, s) ->
                     (((((shows_prec_list Zero_nat "status(" .
                           shows_prec Zero_nat f) .
                          shows_prec_list Zero_nat "[") .
                         shows_prec_nat Zero_nat n) .
                        shows_prec_list Zero_nat "]) = ") .
                       shows_prec_list Zero_nat
                         (case s of {
                           Lex -> "lex";
                           Mul -> "mul";
                         })) .
                       shows_nl)
                b)
        prs) .
     shows_nl) .
    shows_prec_list Zero_nat "status(_) = lex") .
    shows_nl;

scnp_af_to_af ::
  forall a.
    ((a, Nat) -> [(Nat, Nat)]) -> ((a, Nat) -> Set Nat) -> (a, Nat) -> Set Nat;
scnp_af_to_af pia pi =
  (\ (f, n) ->
    let {
      is = map fst (pia (f, n));
    } in (if any (less_eq_nat n) is then sup_set (pi (f, n)) (set is)
           else set is));

mk_subst_domain ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)];
mk_subst_domain sigma =
  let {
    tau = mk_subst Var sigma;
  } in filter (\ (x, t) -> not (equal_term (Var x) t))
         (map (\ x -> (x, tau x)) (remdups (map fst sigma)));

subst_eq ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> Bool;
subst_eq sigma tau =
  let {
    sigmaa = mk_subst_domain sigma;
    taua = mk_subst_domain tau;
  } in set_eq (set sigmaa) (set taua);

full_af :: forall a. (a, Nat) -> Set Nat;
full_af fn = set (upt Zero_nat (snd fn));

add_funas_term :: forall a b. Term a b -> [(a, Nat)] -> [(a, Nat)];
add_funas_term (Var uu) fs = fs;
add_funas_term (Fun f ts) fs = (f, size_list ts) : foldr add_funas_term ts fs;

add_funas_rule :: forall a b. (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
add_funas_rule r fs = add_funas_term (fst r) (add_funas_term (snd r) fs);

funas_trs_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
funas_trs_list trs = foldr add_funas_rule trs [];

funs_rule_list :: forall a b. (Term a b, Term a b) -> [a];
funs_rule_list r = add_funs_rule r [];

vars_rule_list :: forall a b. (Term a b, Term a b) -> [b];
vars_rule_list r = add_vars_rule r [];

apply_args :: forall a b. a -> Term a b -> [Term a b] -> Term a b;
apply_args a t [] = t;
apply_args a t (s : ss) = apply_args a (Fun a [t, s]) ss;

get_symbol :: forall a. (a -> Nat -> [a]) -> a -> Nat -> Nat -> a;
get_symbol sm f n i = nth (sm f n) i;

xml2nd_choice ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        [Prelude.Char] ->
          (Xml -> Sum_bot [Prelude.Char] b) ->
            (a -> Maybe b -> c) -> Xml -> Sum_bot [Prelude.Char] c;
xml2nd_choice tag p1 cn p2 f (XML name atts cs) =
  let {
    l = size_list cs;
  } in (if name == tag && null atts && less_eq_nat (Nat_of_num (Bit0 One)) l
         then binda (p1 (nth cs Zero_nat))
                (\ x1 ->
                  binda (bool cn (nth cs (Nat_of_num One)))
                    (\ b ->
                      (if b then binda (p2
 (nth cs (minus_nat l (Nat_of_num One))))
                                   (\ x2 -> returna (f x1 (Just x2)))
                        else returna (f x1 Nothing))))
         else fail tag (XML name atts cs));
xml2nd_choice tag p1 cn p2 f (XML_text v) = fail tag (XML_text v);

rep_afs :: forall a. Afs a -> ((a, Nat) -> Af_entry, Set (a, Nat));
rep_afs (Abs_afs x) = x;

afsa :: forall a. Afs a -> (a, Nat) -> Af_entry;
afsa xa = fst (rep_afs xa);

sum_lpoly ::
  forall a.
    Partial_object_ext a (Monoid_ext a (Ring_ext a ())) -> [a] -> [a] -> [a];
sum_lpoly c [] ys = ys;
sum_lpoly c (v : va) [] = v : va;
sum_lpoly c (x : xs) (y : ys) = add c x y : sum_lpoly c xs ys;

lpoly_of ::
  forall a.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a ())) ->
                Tpoly Nat a -> Sum_bot [Prelude.Char] (a, [a]);
lpoly_of c (PNum i) = returna (i, []);
lpoly_of c (PVar x) = returna (zero c, replicate x (zero c) ++ [one c]);
lpoly_of c (PSum []) = returna (zero c, []);
lpoly_of c (PSum (p : ps)) =
  binda (lpoly_of c p)
    (\ (cp, ncp) ->
      binda (lpoly_of c (PSum ps))
        (\ (cq, ncq) -> returna (add c cp cq, sum_lpoly c ncp ncq)));
lpoly_of c (PMult []) = returna (one c, []);
lpoly_of c (PMult (p : ps)) =
  binda (lpoly_of c p)
    (\ (cp, ncp) ->
      binda (lpoly_of c (PMult ps))
        (\ (cq, ncq) ->
          (if all (\ a -> zero c == a) ncp
            then returna (mult c cp cq, map (mult c cp) ncq)
            else (if all (\ a -> zero c == a) ncq
                   then returna (mult c cp cq, map (\ x -> mult c x cq) ncp)
                   else errora
                          "cannot transform non-linear polynomial to linear polynomial"))));

renaming ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] [(a, a)];
renaming xml2name =
  many "renaming" (pair "renamingEntry" xml2name xml2name (\ a b -> (a, b))) id;

innermostLhss ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [Term a [Prelude.Char]];
innermostLhss xml2name = many "innermostLhss" (term xml2name) id;

strategy ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Strategy a [Prelude.Char]);
strategy xml2name =
  singleton "strategy"
    (options
      [("innermost", leaf "innermost" Innermost),
        ("innermostLhss", change (innermostLhss xml2name) Innermost_Q)])
    id;

xml_term ::
  forall a b c. (Showa a, Showa b, Showa c) => Term (Lab a [b]) c -> Xml;
xml_term (Var x) = XML "var" [] [XML_text (shows_prec Zero_nat x [])];
xml_term (Fun f ts) =
  XML "funapp" [] (xml_lab f : map (\ t -> XML "arg" [] [xml_term t]) ts);

xml_rule ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (Term (Lab a [b]) c, Term (Lab a [b]) c) -> Xml;
xml_rule =
  (\ (l, r) ->
    XML "rule" [] [XML "lhs" [] [xml_term l], XML "rhs" [] [xml_term r]]);

subset ::
  forall a. (Card_UNIV a, Cenum a, Ceq a, Ccompare a) => Set a -> Set a -> Bool;
subset = subset_eq;

existsM :: forall a b. (a -> Sum b ()) -> [a] -> Sum [b] ();
existsM f [] = Inl [];
existsM f (x : xs) =
  catch_errora (f x)
    (\ e -> catch_errora (existsM f xs) (\ xa -> Inl (e : xa)));

listsum :: forall a. (Monoid_add a) => [a] -> a;
listsum xs = foldr plus xs zeroa;

weight ::
  forall a b.
    ((a, Nat) -> Nat) -> Nat -> ((a, Nat) -> Nat -> Nat) -> Term a b -> Nat;
weight w w0 scf (Fun f ts) =
  let {
    n = size_list ts;
    scff = scf (f, n);
  } in plus_nat (w (f, n))
         (listsum
           (map (\ (ti, i) -> times_nat (weight w w0 scf ti) (scff i))
             (zip ts (upt Zero_nat n))));
weight w w0 scf (Var x) = w0;

kbo_impl ::
  forall a b.
    (Eq b) => ((a, Nat) -> Nat) ->
                Nat ->
                  ((a, Nat) -> Nat) ->
                    (a -> Bool) ->
                      ((a, Nat) -> Nat -> Nat) ->
                        Term a b -> Term a b -> (Bool, Bool);
kbo_impl w w0 prc least scf s t =
  let {
    wt = weight w w0 scf t;
    ws = weight w w0 scf s;
  } in (if less_eq_multiset (vars_term_ms (scf_term scf t))
             (vars_term_ms (scf_term scf s)) &&
             less_eq_nat wt ws
         then (if less_nat wt ws then (True, True)
                else (case s of {
                       Var _ ->
                         (False,
                           (case t of {
                             Var _ -> True;
                             Fun g ts -> null ts && least g;
                           }));
                       Fun f ss ->
                         (case t of {
                           Var _ -> (True, True);
                           Fun g ts ->
                             let {
                               pf = prc (f, size_list ss);
                               pg = prc (g, size_list ts);
                             } in (if less_nat pg pf then (True, True)
                                    else (if less_eq_nat pg pf
   then lex_ext_unbounded (kbo_impl w w0 prc least scf) ss ts
   else (False, False)));
                         });
                     }))
         else (False, False));

kbo_strict ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ((a, Nat) -> Nat) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        (a -> Bool) ->
                          ((a, Nat) -> Nat -> Nat) ->
                            (Term a b, Term a b) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
kbo_strict pr w w0 least scf =
  (\ (s, t) ->
    check (fst (kbo_impl w w0 pr least scf s t))
      (shows_string "could not orient " .
        shows_prec_term Zero_nat s .
          shows_string " >KBO " . shows_prec_term Zero_nat t . shows_nl));

list_diff :: forall a. (Eq a) => [a] -> [a] -> [a];
list_diff [] ys = [];
list_diff (x : xs) ys =
  let {
    zs = list_diff xs ys;
  } in (if membera ys x then zs else x : zs);

eval :: forall a b c. (a -> [b] -> b) -> (c -> b) -> Term a c -> b;
eval i alpha (Var x) = alpha x;
eval i alpha (Fun f ts) = i f (map (eval i alpha) ts);

poly_vars_list :: forall a b. (Eq a) => [([(a, Nat)], b)] -> [a];
poly_vars_list p = remdups (concatMap (map fst . fst) p);

concat_lists :: forall a. [[a]] -> [[a]];
concat_lists [] = [[]];
concat_lists (asa : xs) =
  concatMap (\ vec -> map (\ a -> a : vec) asa) (concat_lists xs);

square_possibilities ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => (a -> [a]) -> [([(b, Nat)], a)] -> [[([(b, Nat)], a)]];
square_possibilities sqrt p =
  let {
    roots =
      map (\ x ->
            map (\ a -> (x, a))
              (sqrt (fst (poly_split [(x, Nat_of_num (Bit0 One))] p))))
        (poly_vars_list p);
    choices = (if membera roots [] then [] else concat_lists roots);
    polys =
      map (\ xas ->
            poly_of (PSum (map (\ (x, a) -> PMult [PVar x, PNum a]) xas)))
        choices;
  } in polys;

check_poly_eq ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] -> [([(a, Nat)], b)] -> Bool;
check_poly_eq [] q = null q;
check_poly_eq ((m, c) : p) q =
  (case extract (\ nd -> eq_monom (fst nd) m) q of {
    Nothing -> False;
    Just (q1, ((_, d), q2)) -> c == d && check_poly_eq p (q1 ++ q2);
  });

monom_degree :: forall a. [(a, Nat)] -> Nat;
monom_degree xps = listsum (map snd xps);

poly_degree :: forall a b. [([(a, Nat)], b)] -> Nat;
poly_degree p = max_list (map (\ (m, _) -> monom_degree m) p);

check_quadratic ::
  forall a.
    (Eq a,
      Poly_carrier a) => (a -> [a]) ->
                           [([(Nat, Nat)], a)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quadratic sqrt p =
  bindb (check (equal_nat (poly_degree p) (Nat_of_num (Bit0 One)))
          (shows_prec_list Zero_nat "not quadratic"))
    (\ _ ->
      let {
        polys = square_possibilities sqrt p;
      } in check (any (\ q -> check_poly_eq (poly_mult q q) p) polys)
             (shows_prec_list Zero_nat "could not find quadratic polynomial"));

check_quadratic_ge_const ::
  forall a b c.
    (Eq a, Poly_carrier a,
      Eq c) => (a -> [a]) ->
                 ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                   (Term b c, Term b c) ->
                     Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quadratic_ge_const sq i st =
  let {
    (s, t) = st;
  } in bindb (check (not (is_Var s))
               (shows_prec_list Zero_nat "require non-variables as arguments"))
         (\ _ ->
           let {
             pt = eval_term i t;
             (c, p0) = poly_split [] pt;
           } in bindb (check (p0 == zero_poly)
                        (shows_prec_list Zero_nat
                          "rhs must evaluate to constant"))
                  (\ _ ->
                    let {
                      ps = i (the (root s));
                      (d, psx) = poly_split [] ps;
                    } in bindb (check (less_eq c d)
                                 (shows_prec_list Zero_nat
                                   "problem in comparing constants"))
                           (\ _ -> check_quadratic sq psx)));

check_ns ::
  forall a b c.
    (Showa a, Eq b, Poly_carrier b, Showa b, Eq c,
      Showa c) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                    (Term a c, Term a c) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ns i =
  (\ (s, t) ->
    let {
      p = eval_term i s;
      q = eval_term i t;
    } in check (check_poly_ge p q)
           (shows_string "could not ensure " .
             shows_prec_term Zero_nat s .
               shows_string " >= " .
                 shows_prec_term Zero_nat t .
                   shows_string " since we " .
                     shows_nl .
                       shows_string "could not ensure " .
                         shows_poly p . shows_string " >= " . shows_poly q));

check_cc ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Showa b, Eq c,
      Showa c) => (a -> [a]) ->
                    (a -> a -> Bool) ->
                      ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                        C_constraint b c ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cc sq gt i (Unconditional_C False st) =
  (if isOK (check_quadratic_ge_const sq i st) then Inr () else check_ns i st);
check_cc sq gt i (Unconditional_C True st) = check_s gt i st;
check_cc sq gt i (Conditional_C True (u, v) (s, t)) =
  let {
    ss = eval_term i s;
    tt = eval_term i t;
    uu = eval_term i u;
    vv = eval_term i v;
  } in (if check_poly_gt gt ss tt then Inr ()
         else check (check_poly_ge (poly_add ss vv) (poly_add tt uu))
                (shows_string "could not ensure " .
                  shows_prec_term Zero_nat u .
                    shows_string " > " .
                      shows_prec_term Zero_nat v .
                        shows_string " ==> " .
                          shows_prec_term Zero_nat s .
                            shows_string " > " . shows_prec_term Zero_nat t));
check_cc sq gt i (Conditional_C False (u, v) (s, t)) =
  (if isOK (check_quadratic_ge_const sq i (s, t)) then Inr ()
    else let {
           ss = eval_term i s;
           tt = eval_term i t;
           uu = eval_term i u;
           vv = eval_term i v;
         } in (if check_poly_ge ss tt then Inr ()
                else check (check_poly_ge (poly_add ss vv) (poly_add tt uu))
                       (shows_string "could not ensure " .
                         shows_prec_term Zero_nat u .
                           shows_string " >= " .
                             shows_prec_term Zero_nat v .
                               shows_string " ==> " .
                                 shows_prec_term Zero_nat s .
                                   shows_string " >= " .
                                     shows_prec_term Zero_nat t)));

is_left_of :: Pos -> Pos -> Bool;
is_left_of Empty q = False;
is_left_of (PCons i p) q =
  (case q of {
    Empty -> False;
    PCons j qa ->
      (if less_nat i j then True
        else (if less_nat j i then False else is_left_of p qa));
  });

pos_prefix :: Pos -> Pos -> Maybe Pos;
pos_prefix Empty q = Just q;
pos_prefix (PCons i p) q =
  (case q of {
    Empty -> Nothing;
    PCons j qa -> (if equal_nat i j then pos_prefix p qa else Nothing);
  });

pos_suffix :: Pos -> Pos -> Maybe Pos;
pos_suffix p q =
  (case pos_prefix (rev p) (rev q) of {
    Nothing -> Nothing;
    Just qa -> Just (rev qa);
  });

sqrt_real :: Real -> [Real];
sqrt_real x =
  (if is_rat x && less_eq_real zero_real x
    then (if equal_real x zero_real then [zero_real]
           else let {
                  sx = sqrt x;
                } in [sx, uminus_real sx])
    else []);

rules_with ::
  forall a b c.
    (Linorder b) => (a -> Bool) ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        [(Term b c, Term b c)];
rules_with p m =
  map_filter (\ x -> (if (p . fst) x then Just (snd x) else Nothing))
    (values m);

scnp_desc ::
  forall a.
    (Showa a) => [((a, Nat), [(Nat, Nat)])] ->
                   [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
scnp_desc af mu =
  ((((shows_prec_list Zero_nat "SCNP-version with mu = " .
       shows_prec_list Zero_nat mu) .
      shows_prec_list Zero_nat " and the level mapping defined by ") .
     shows_nl) .
    shows_sep
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ asa ->
               ((shows_prec_list Zero_nat "pi(" . shows_prec Zero_nat f) .
                 shows_prec_list Zero_nat ") = ") .
                 showsp_list
                   (\ _ (p, l) ->
                     (((shows_prec_list Zero_nat "(" .
                         (if less_nat p n
                           then shows_prec_nat Zero_nat
                                  (plus_nat p (Nat_of_num One))
                           else shows_prec_list Zero_nat "epsilon")) .
                        shows_prec_list Zero_nat ",") .
                       shows_prec_nat Zero_nat l) .
                       shows_prec_list Zero_nat ")")
                   Zero_nat asa)
          b)
      shows_nl af) .
    shows_nl;

split_rulesb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_rulesb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = split_rules;

delete_R_Rwb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_R_Rwb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = delete_R_Rw;

nfsb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
nfsb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
       rules_map delete_R_Rw split_rules mk nfs more)
  = nfs;

mkb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      Bool ->
        [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
      rules_map delete_R_Rw split_rules mk nfs more)
  = mk;

qb :: forall a b c d. Tp_ops_ext a b c d -> a -> [Term b c];
qb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
     delete_R_Rw split_rules mk nfs more)
  = q;

split_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () -> a -> [(Term b c, Term b c)] -> (a, a);
split_tt i tp r_remove =
  let {
    (r, rw) = split_rulesb i tp r_remove;
    tp1 = mkb i (nfsb i tp) (qb i tp) r rw;
    a = delete_R_Rwb i tp r_remove r_remove;
  } in (tp1, a);

supt_impl :: forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Bool;
supt_impl (Var x) t = False;
supt_impl (Fun f ss) t = membera ss t || any (\ s -> supt_impl s t) ss;

af_inter ::
  forall a.
    ((a, Nat) -> Set Nat) -> ((a, Nat) -> Set Nat) -> (a, Nat) -> Set Nat;
af_inter pi mu f = inf_set (pi f) (mu f);

empty_af :: forall a. (a, Nat) -> Set Nat;
empty_af fn = set_empty (of_phantom set_impl_nat);

r_rhs :: forall a b. Ta_rule a b -> a;
r_rhs (TA_rule f qs q) = q;

r_sym :: forall a b. Ta_rule a b -> (b, Nat);
r_sym (TA_rule f qs q) = (f, size_list qs);

shows_rule ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          (Term a b, Term a b) -> [Prelude.Char] -> [Prelude.Char];
shows_rule fun var arr (l, r) =
  (shows_term fun var l . shows_prec_list Zero_nat arr) . shows_term fun var r;

shows_rules ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          [(Term a b, Term a b)] -> [Prelude.Char] -> [Prelude.Char];
shows_rules fun var arr trs =
  shows_list_gen (shows_rule fun var arr) [] [] "\n" [] trs . shows_nl;

shows_trs ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          [Prelude.Char] ->
            [(Term a b, Term a b)] -> [Prelude.Char] -> [Prelude.Char];
shows_trs fun var name arr r =
  ((shows_prec_list Zero_nat name . shows_nl) . shows_nl) .
    shows_rules fun var arr r;

aarity_term ::
  forall a b. (Eq a) => a -> (a -> Nat -> [a]) -> Term a b -> Maybe Nat;
aarity_term a sm t =
  (case unapp a t of {
    (Var _, _) -> Nothing;
    (Fun f ss, ts) ->
      Just (minus_nat (aarity sm f (size_list ss)) (size_list ts));
  });

map_funs_term_wa :: forall a b c. ((a, Nat) -> b) -> Term a c -> Term b c;
map_funs_term_wa fg (Var x) = Var x;
map_funs_term_wa fg (Fun f ts) =
  Fun (fg (f, size_list ts)) (map (map_funs_term_wa fg) ts);

uncurry_top ::
  forall a b. (Eq a) => a -> Nat -> (a -> Nat -> [a]) -> Term a b -> Term a b;
uncurry_top a n sm (Fun f ts) =
  let {
    mt = map (map_funs_term_wa (\ (fa, na) -> get_symbol sm fa na Zero_nat));
    (h, m) = the (root (hd ts));
  } in (if f == a &&
             equal_nat (size_list ts) n &&
               not (is_Var (hd ts)) && not (equal_nat (aarity sm h m) Zero_nat)
         then let {
                (Fun g ss) = hd ts;
              } in Fun (get_symbol sm g (size_list ss) (Nat_of_num One))
                     (mt (ss ++ tl ts))
         else Fun (let {
                     (fa, na) = (f, size_list ts);
                   } in get_symbol sm fa na Zero_nat)
                (mt ts));
uncurry_top a n sm (Var x) = Var x;

arith_fun :: Xml -> Sum_bot [Prelude.Char] ArithFun;
arith_fun xml =
  singleton "arithFunction"
    (options
      [("natural", change (nata "natural") Const),
        ("variable",
          change (nata "variable") (\ n -> Arg (minus_nat n (Nat_of_num One)))),
        ("sum", many "sum" arith_fun Sum),
        ("product", many "product" arith_fun Prod),
        ("min", many "min" arith_fun Min), ("max", many "max" arith_fun Max),
        ("ifEqual",
          tuple4 "ifEqual" arith_fun arith_fun arith_fun arith_fun IfEqual)])
    id xml;

int_coeff :: Xml -> Sum_bot [Prelude.Char] Int;
int_coeff = int "integer";

vec_coeff ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] [a];
vec_coeff xml2coeff = many "vector" (singleton "coefficient" xml2coeff id) id;

mat_coeff ::
  forall a.
    a -> (Xml -> Sum_bot [Prelude.Char] a) ->
           Xml -> Sum_bot [Prelude.Char] [[a]];
mat_coeff ze xml2coeff =
  options
    [("matrix", many "matrix" (vec_coeff xml2coeff) id),
      ("vector",
        change (vec_coeff xml2coeff)
          (\ v ->
            v : replicate (minus_nat (size_list v) (Nat_of_num One))
                  (replicate (size_list v) ze)))];

plain_var :: Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
plain_var x = text "var" x;

precedence_weight ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Nat -> ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat));
precedence_weight xml2name =
  many "precedenceWeight"
    (guard (\ x -> equal_nat (num_children x) (Nat_of_num (Bit0 (Bit0 One))))
      (tuple4 "precedenceWeightEntry" xml2name (nata "arity")
        (nata "precedence") (nata "weight")
        (\ f a p w -> ((f, a), (p, (w, Nothing)))))
      (tuple5 "precedenceWeightEntry" xml2name (nata "arity")
        (nata "precedence") (nata "weight")
        (many "subtermCoefficientEntries" (nata "entry") id)
        (\ f a p w e -> ((f, a), (p, (w, Just e))))))
    (\ a b -> (a, b));

xml2to3elements ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> b -> Maybe c -> d) -> Xml -> Sum_bot [Prelude.Char] d;
xml2to3elements tag p1 p2 p3 f (XML name atts cs) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts &&
               less_eq_nat (Nat_of_num (Bit0 One)) l &&
                 less_eq_nat l (Nat_of_num (Bit1 One))
         then binda (p1 (nth cs Zero_nat))
                (\ x1 ->
                  binda (p2 (nth cs (Nat_of_num One)))
                    (\ x2 ->
                      (if equal_nat l (Nat_of_num (Bit1 One))
                        then binda (p3 (nth cs (Nat_of_num (Bit0 One))))
                               (\ x3 -> returna (f x1 x2 (Just x3)))
                        else returna (f x1 x2 Nothing))))
         else fail tag (XML name atts cs));
xml2to3elements tag p1 p2 p3 f (XML_text v) = fail tag (XML_text v);

knuth_bendix_order ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
knuth_bendix_order xml2name =
  xml2to3elements "knuthBendixOrder" (nata "w0") (precedence_weight xml2name)
    (afs xml2name)
    (\ w0 prw afo ->
      let {
        a = (case afo of {
              Nothing -> [];
              Just af -> af;
            });
      } in KBO (prw w0) a);

arctic_rat_linear_poly ::
  forall a.
    Interpretation a -> ((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]));
arctic_rat_linear_poly (Arctic_rat_linear_poly x4) = x4;

real_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Real)]);
real_non_linear_poly (Real_non_linear_poly x13) = x13;

rat_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Rat)]);
rat_non_linear_poly (Rat_non_linear_poly x12) = x12;

int_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Int)]);
int_non_linear_poly (Int_non_linear_poly x11) = x11;

arctic_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), (Arctic, [Arctic]));
arctic_linear_poly (Arctic_linear_poly x3) = x3;

arctic_rat_matrix ::
  forall a.
    Interpretation a ->
      ((a, Nat), ([[Arctic_delta Rat]], [[[Arctic_delta Rat]]]));
arctic_rat_matrix (Arctic_rat_matrix x9) = x9;

real_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Real, [Real]));
real_linear_poly (Real_linear_poly x5) = x5;

rat_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Rat, [Rat]));
rat_linear_poly (Rat_linear_poly x2) = x2;

int_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Int, [Int]));
int_linear_poly (Int_linear_poly x1) = x1;

arctic_matrix ::
  forall a. Interpretation a -> ((a, Nat), ([[Arctic]], [[[Arctic]]]));
arctic_matrix (Arctic_matrix x8) = x8;

real_matrix :: forall a. Interpretation a -> ((a, Nat), ([[Real]], [[[Real]]]));
real_matrix (Real_matrix x10) = x10;

rat_matrix :: forall a. Interpretation a -> ((a, Nat), ([[Rat]], [[[Rat]]]));
rat_matrix (Rat_matrix x7) = x7;

int_matrix :: forall a. Interpretation a -> ((a, Nat), ([[Int]], [[[Int]]]));
int_matrix (Int_matrix x6) = x6;

class_semiring ::
  forall a b.
    (Ceq a, Ccompare a, One a, Plus a, Times a, Zero a,
      Set_impl a) => Itself a ->
                       b -> Partial_object_ext a (Monoid_ext a (Ring_ext a b));
class_semiring uu b =
  Partial_object_ext top_set (Monoid_ext times onea (Ring_ext zeroa plus b));

real_domain :: Xml -> Sum_bot [Prelude.Char] Real;
real_domain = singleton "algebraicNumbers" (singleton "delta" real id) id;

rat_domain :: Xml -> Sum_bot [Prelude.Char] Rat;
rat_domain = singleton "rationals" (singleton "delta" rat id) id;

basic_domain :: Xml -> Sum_bot [Prelude.Char] (Nat -> Domain);
basic_domain =
  options
    [("naturals", leaf "naturals" Natural),
      ("integers", leaf "integers" (\ _ -> Integera)),
      ("arctic",
        singleton "arctic"
          (singleton "domain"
            (options
              [("naturals", leaf "naturals" (\ _ -> Arctic)),
                ("integers", leaf "integers" (\ _ -> Arctic)),
                ("rationals", change rat_domain (\ _ _ -> Arctic_rat))])
            id)
          id),
      ("rationals", change rat_domain Rational),
      ("algebraicNumbers", change real_domain Mini_Alg)];

interpretation_type :: Xml -> Sum_bot [Prelude.Char] Domain;
interpretation_type =
  singleton "type"
    (options
      [("polynomial",
         pair "polynomial"
           (singleton "domain"
             (options
               [("naturals", basic_domain), ("integers", basic_domain),
                 ("arctic", basic_domain), ("rationals", basic_domain),
                 ("algebraicNumbers", basic_domain),
                 ("matrices",
                   triple "matrices" (nata "dimension") (nata "strictDimension")
                     (singleton "domain" basic_domain id)
                     (\ di sd domain d ->
                       (case domain d of {
                         Natural _ -> Int_mat di sd;
                         Integera -> Int_mat di sd;
                         Arctic -> Arctic_mat di;
                         Arctic_rat -> Arctic_rat_mat di;
                         Rational _ _ -> Rat_mat di sd;
                         Mini_Alg _ _ -> Mini_Alg_mat di sd;
                       })))])
             id)
           (nata "degree") (\ typea -> typea)),
        ("matrixInterpretation",
          triple "matrixInterpretation" (singleton "domain" basic_domain id)
            (nata "dimension") (nata "strictDimension")
            (\ domain di sd ->
              (case domain Zero_nat of {
                Natural _ -> Int_mat di sd;
                Integera -> Int_mat di sd;
                Arctic -> Arctic_mat di;
                Arctic_rat -> Arctic_rat_mat di;
                Rational _ _ -> Rat_mat di sd;
                Mini_Alg _ _ -> Mini_Alg_mat di sd;
              })))])
    id;

arctic_rat_coeff :: Xml -> Sum_bot [Prelude.Char] (Arctic_delta Rat);
arctic_rat_coeff =
  options
    [("integer", change rat Num_arc_delta),
      ("rational", change rat Num_arc_delta),
      ("minusInfinity", leaf "minusInfinity" MinInfty_delta)];

arctic_coeff :: Xml -> Sum_bot [Prelude.Char] Arctic;
arctic_coeff =
  options
    [("integer", change (int "integer") Num_arc),
      ("minusInfinity", leaf "minusInfinity" MinInfty)];

vec_plusI :: forall a. (a -> a -> a) -> [a] -> [a] -> [a];
vec_plusI pl v w = map (\ xy -> pl (fst xy) (snd xy)) (zip v w);

mat_plusI :: forall a. (a -> a -> a) -> [[a]] -> [[a]] -> [[a]];
mat_plusI pl m1 m2 = map (\ uv -> vec_plusI pl (fst uv) (snd uv)) (zip m1 m2);

scalar_prodI ::
  forall a. a -> (a -> a -> a) -> (a -> a -> a) -> [a] -> [a] -> a;
scalar_prodI ze pl ti v w = foldr (\ (x, y) -> pl (ti x y)) (zip v w) ze;

matT_vec_multI ::
  forall a. a -> (a -> a -> a) -> (a -> a -> a) -> [[a]] -> [a] -> [a];
matT_vec_multI ze pl ti m v = map (\ w -> scalar_prodI ze pl ti w v) m;

transpose :: forall a. Nat -> [[a]] -> [[a]];
transpose nr [] = replicate nr [];
transpose nr (v : m) = map (\ (a, b) -> a : b) (zip v (transpose nr m));

mat_multI ::
  forall a.
    a -> (a -> a -> a) -> (a -> a -> a) -> Nat -> [[a]] -> [[a]] -> [[a]];
mat_multI ze pl ti nr m1 m2 =
  map (matT_vec_multI ze pl ti (transpose nr m1)) m2;

mat_ring ::
  forall a b.
    (One b, Plus b, Times b,
      Zero b) => Nat ->
                   a -> Partial_object_ext [[b]]
                          (Monoid_ext [[b]] (Ring_ext [[b]] a));
mat_ring n b =
  Partial_object_ext (collect (mat n n))
    (Monoid_ext (mat_multI zeroa plus times n) (mat1I zeroa onea n)
      (Ring_ext (mat0I zeroa n n) (mat_plusI plus) b));

polynomial ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Tpoly Nat a);
polynomial xml2coeff x =
  singleton "polynomial"
    (options
      [("coefficient", singleton "coefficient" xml2coeff PNum),
        ("variable",
          change (nata "variable")
            (\ n -> PVar (minus_nat n (Nat_of_num One)))),
        ("sum", many "sum" (polynomial xml2coeff) PSum),
        ("product", many "product" (polynomial xml2coeff) PMult)])
    id x;

fit_length ::
  forall a.
    Partial_object_ext a (Monoid_ext a (Ring_ext a ())) -> Nat -> [a] -> [a];
fit_length c n uu =
  (if equal_nat n Zero_nat then []
    else (case uu of {
           [] -> replicate
                   (plus_nat (minus_nat n (Nat_of_num One)) (Nat_of_num One))
                   (zero c);
           b : bs -> b : fit_length c (minus_nat n (Nat_of_num One)) bs;
         }));

interpretation ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
interpretation bi xml2name =
  many1_gen "interpretation" interpretation_type
    (\ a ->
      (case a of {
        Natural deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then triple "interpret" xml2name (nata "arity")
                   (\ x ->
                     binda (polynomial int_coeff x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Int_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple "interpret" xml2name (nata "arity")
                   (\ x ->
                     binda (polynomial int_coeff x)
                       (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Int_non_linear_poly ((f, aa), poly)));
        Integera ->
          triple "interpret" xml2name (nata "arity")
            (\ x -> binda (polynomial int_coeff x) (\ p -> returna (poly_of p)))
            (\ f aa poly -> Int_non_linear_poly ((f, aa), poly));
        Arctic ->
          triple "interpret" xml2name (nata "arity")
            (\ x ->
              binda (polynomial arctic_coeff x)
                (lpoly_of (class_semiring Type ())))
            (\ f aa poly ->
              Arctic_linear_poly
                ((f, aa),
                  (fst poly,
                    fit_length (class_semiring Type ()) aa (snd poly))));
        Arctic_rat ->
          triple "interpret" xml2name (nata "arity")
            (\ x ->
              binda (polynomial arctic_rat_coeff x)
                (lpoly_of (class_semiring Type ())))
            (\ f aa poly ->
              Arctic_rat_linear_poly
                ((f, aa),
                  (fst poly,
                    fit_length (class_semiring Type ()) aa (snd poly))));
        Int_mat n _ ->
          triple "interpret" xml2name (nata "arity")
            (\ x ->
              binda (polynomial (mat_coeff Zero_int int_coeff) x)
                (lpoly_of (mat_ring n ())))
            (\ f aa poly ->
              Int_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring n ()) aa (snd poly))));
        Arctic_mat n ->
          triple "interpret" xml2name (nata "arity")
            (\ x ->
              binda (polynomial (mat_coeff MinInfty arctic_coeff) x)
                (lpoly_of (mat_ring n ())))
            (\ f aa poly ->
              Arctic_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring n ()) aa (snd poly))));
        Arctic_rat_mat n ->
          triple "interpret" xml2name (nata "arity")
            (\ x ->
              binda (polynomial (mat_coeff MinInfty_delta arctic_rat_coeff) x)
                (lpoly_of (mat_ring n ())))
            (\ f aa poly ->
              Arctic_rat_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring n ()) aa (snd poly))));
        Rational _ deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then triple "interpret" xml2name (nata "arity")
                   (\ x ->
                     binda (polynomial rat x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Rat_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple "interpret" xml2name (nata "arity")
                   (\ x ->
                     binda (polynomial rat x) (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Rat_non_linear_poly ((f, aa), poly)));
        Rat_mat n _ ->
          triple "interpret" xml2name (nata "arity")
            (\ x ->
              binda (polynomial (mat_coeff zero_rat rat) x)
                (lpoly_of (mat_ring n ())))
            (\ f aa poly ->
              Rat_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring n ()) aa (snd poly))));
        Mini_Alg _ deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then triple "interpret" xml2name (nata "arity")
                   (\ x ->
                     binda (polynomial real x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Real_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple "interpret" xml2name (nata "arity")
                   (\ x ->
                     binda (polynomial real x) (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Real_non_linear_poly ((f, aa), poly)));
        Mini_Alg_mat n _ ->
          triple "interpret" xml2name (nata "arity")
            (\ x ->
              binda (polynomial (mat_coeff zero_real real) x)
                (lpoly_of (mat_ring n ())))
            (\ f aa poly ->
              Real_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring n ()) aa (snd poly))));
      }))
    (\ typea pi ->
      (case typea of {
        Natural deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then Int_carrier (map int_linear_poly pi)
            else Int_nl_carrier (map int_non_linear_poly pi));
        Integera -> Int_nl_carrier (map int_non_linear_poly pi);
        Arctic -> Arctic_carrier (map arctic_linear_poly pi);
        Arctic_rat -> Arctic_rat_carrier (map arctic_rat_linear_poly pi);
        Int_mat n sd -> Int_mat_carrier n sd (map int_matrix pi);
        Arctic_mat n -> Arctic_mat_carrier n (map arctic_matrix pi);
        Arctic_rat_mat n -> Arctic_rat_mat_carrier n (map arctic_rat_matrix pi);
        Rational d deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then Rat_carrier (map rat_linear_poly pi)
            else Rat_nl_carrier d (map rat_non_linear_poly pi));
        Rat_mat n sd -> Rat_mat_carrier n sd (map rat_matrix pi);
        Mini_Alg d deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then Real_carrier (map real_linear_poly pi)
            else Real_nl_carrier d (map real_non_linear_poly pi));
        Mini_Alg_mat n sd -> Real_mat_carrier n sd (map real_matrix pi);
      }));

wpo_params ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), (Nat, [Nat]))];
wpo_params xml2name =
  many "precedenceStatus"
    (tuple4 "precedenceStatusEntry" xml2name (nata "arity") (nata "precedence")
      (many "status" position id) (\ f a p s -> ((f, a), (p, s))))
    id;

status_precedence ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), (Nat, Order_tag))];
status_precedence xml2name =
  many "statusPrecedence"
    (tuple4 "statusPrecedenceEntry" xml2name (nata "arity") (nata "precedence")
      (options [("lex", leaf "lex" Lex), ("mul", leaf "mul" Mul)])
      (\ f a p s -> ((f, a), (p, s))))
    id;

xml1to2elements ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> Maybe b -> c) -> Xml -> Sum_bot [Prelude.Char] c;
xml1to2elements tag p1 p2 f (XML name atts cs) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts &&
               less_eq_nat (Nat_of_num One) l &&
                 less_eq_nat l (Nat_of_num (Bit0 One))
         then binda (p1 (nth cs Zero_nat))
                (\ x1 ->
                  (if equal_nat l (Nat_of_num (Bit0 One))
                    then binda (p2 (nth cs (Nat_of_num One)))
                           (\ x2 -> returna (f x1 (Just x2)))
                    else returna (f x1 Nothing)))
         else fail tag (XML name atts cs));
xml1to2elements tag p1 p2 f (XML_text v) = fail tag (XML_text v);

path_order ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
path_order xml2name =
  xml1to2elements "pathOrder" (status_precedence xml2name) (afs xml2name)
    (\ prec_tau afo ->
      let {
        a = (case afo of {
              Nothing -> [];
              Just af -> af;
            });
      } in RPO prec_tau a);

redtriple ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
redtriple bi xml2name x =
  singleton "redPair"
    (options
      [("interpretation", interpretation bi xml2name),
        ("pathOrder", path_order xml2name),
        ("knuthBendixOrder", knuth_bendix_order xml2name),
        ("weightedPathOrder",
          pair "weightedPathOrder" (wpo_params xml2name) (redtriple bi xml2name)
            WPO)])
    id x;

signature ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [(a, Nat)];
signature = symbols "signature";

joinable_critical_pairs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(Term a [Prelude.Char],
             ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                       Term a [Prelude.Char]))],
               (Term a [Prelude.Char],
                 [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                          Term a [Prelude.Char]))])))];
joinable_critical_pairs xml2name =
  let {
    rew = rsteps xml2name;
  } in many "joinableCriticalPairs"
         (pair "joinableCriticalPair" rew rew
           (\ (s, sseq) (t, tseq) -> (s, (sseq, (t, tseq)))))
         id;

wcr_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Join_info a);
wcr_proof xml2name =
  singleton "wcrProof"
    (options
      [("joinableCriticalPairs",
         change (joinable_critical_pairs xml2name) Guided),
        ("joinableCriticalPairsBFS",
          change (nata "joinableCriticalPairsBFS") Join_BFS),
        ("joinableCriticalPairsAuto",
          leaf "joinableCriticalPairsAuto" Join_NF)])
    id;

xml2equational_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ([(Term a [Prelude.Char], Term a [Prelude.Char])],
            (Term a [Prelude.Char], Term a [Prelude.Char]));
xml2equational_input xml2name =
  pair "equationalReasoningInput" (singleton "equations" (rules xml2name) id)
    (pair "equation" (term xml2name) (term xml2name) (\ a b -> (a, b)))
    (\ a b -> (a, b));

complexity_measure ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Complexity_measure a [Prelude.Char]);
complexity_measure xml2name =
  options
    [("derivationalComplexity",
       singleton "derivationalComplexity" (signature xml2name)
         Derivational_Complexity),
      ("runtimeComplexity",
        pair "runtimeComplexity" (signature xml2name) (signature xml2name)
          Runtime_Complexity)];

complexity_class :: Xml -> Sum_bot [Prelude.Char] Complexity_class;
complexity_class = change (nata "polynomial") Comp_Poly;

forbidden_pattern ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location));
forbidden_pattern xml2name xml =
  binda (triple "forbiddenPattern" (term xml2name) pos
          (options
            [("here", leaf "here" H), ("above", leaf "above" A),
              ("below", leaf "below" Ba), ("right", leaf "below" Ra)])
          (\ t p l -> (t, (p, l))) xml)
    (\ (t, (p, l)) ->
      (if in_poss p t then returna (ctxt_of_pos_term p t, (subt_at t p, l))
        else errora "position does not exist in term"));

forbidden_patterns ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
forbidden_patterns xml2name =
  many "forbiddenPatterns" (forbidden_pattern xml2name) id;

replacement_map ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), [Nat])];
replacement_map xml2name =
  many "contextSensitive"
    (many2 "replacementMapEntry" xml2name (nata "arity") position
      (\ f a -> (\ b -> ((f, a), b))))
    id;

inn_fp_strategy ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Sum (Strategy a [Prelude.Char]) (Fp_strategy a [Prelude.Char]));
inn_fp_strategy xml2name =
  singleton "strategy"
    (options
      [("innermost", leaf "innermost" (Inl Innermost)),
        ("outermost", leaf "outermost" (Inr Outermost)),
        ("contextSensitive",
          change (replacement_map xml2name) (\ p -> Inr (Context_Sensitive p))),
        ("forbiddenPatterns",
          change (forbidden_patterns xml2name)
            (\ p -> Inr (Forbidden_Patterns p))),
        ("innermostLhss",
          change (innermostLhss xml2name) (\ q -> Inl (Innermost_Q q)))])
    id;

xml2pre_trs_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Input a [Prelude.Char]);
xml2pre_trs_input xml2name x =
  let {
    e = fail "trsInput" x;
  } in binda (case x of {
               XML _ [] [] -> e;
               XML taga [] (c : cs) ->
                 (if less_eq_nat (size_list cs) (Nat_of_num (Bit0 One)) &&
                       taga == "trsInput"
                   then binda (singleton "trs" (rules xml2name) id c)
                          (\ r ->
                            binda (if null cs || not (tag (hd cs) == "strategy")
                                    then returna (Inl No_Strategy, cs)
                                    else binda
   (inn_fp_strategy xml2name (hd cs)) (\ s -> returna (s, tl cs)))
                              (\ (str, csa) ->
                                binda (if null csa ||
    not (tag (hd csa) == "relativeRules")
then returna (Nothing, csa)
else binda (singleton "relativeRules" (rules xml2name) id (hd csa))
       (\ s -> returna (Just s, tl csa)))
                                  (\ (s_opt, csb) ->
                                    (if null csb then returna (str, (r, s_opt))
                                      else e))))
                   else e);
               XML _ (_ : _) _ -> e;
               XML_text _ -> e;
             })
         (\ a ->
           (case a of {
             (Inl istrat, (r, so)) -> returna (Inn_TRS_input (istrat, (r, so)));
             (Inr fpstrat, (r, Nothing)) -> returna (FP_TRS_input (fpstrat, r));
             (Inr _, (_, Just _)) ->
               errora
                 "the combination of relative rules with strategies is only supported for innermost";
           }));

xml2trs_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Strategy a [Prelude.Char],
            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
              Maybe [(Term a [Prelude.Char], Term a [Prelude.Char])]));
xml2trs_input xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ -> errora "require innermost trs at this point";
        Inn_TRS_input aa -> returna aa;
        COMP_input _ -> errora "require innermost trs at this point";
        EQ_input _ -> errora "require innermost trs at this point";
        CPX_input _ -> errora "require innermost trs at this point";
        FP_TRS_input _ -> errora "require innermost trs at this point";
        CTRS_input _ -> errora "require innermost trs at this point";
        Unknown_input _ -> errora "require innermost trs at this point";
      }));

xml2complexity_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Strategy a [Prelude.Char],
            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
              (Maybe [(Term a [Prelude.Char], Term a [Prelude.Char])],
                (Complexity_measure a [Prelude.Char], Complexity_class))));
xml2complexity_input xml2name =
  triple "complexityInput" (xml2trs_input xml2name)
    (complexity_measure xml2name) complexity_class
    (\ (q, (r, s)) cm cc -> (q, (r, (s, (cm, cc)))));

xml2completion_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ([(Term a [Prelude.Char], Term a [Prelude.Char])],
            [(Term a [Prelude.Char], Term a [Prelude.Char])]);
xml2completion_input xml2name =
  pair "completionInput" (singleton "equations" (rules xml2name) id)
    (singleton "trs" (rules xml2name) id) (\ a b -> (a, b));

xml2unknown_input :: Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
xml2unknown_input = text "unknownInput";

xml2ctrs_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]),
             [(Term a [Prelude.Char], Term a [Prelude.Char])])];
xml2ctrs_input xml2name = singleton "ctrsInput" (crules xml2name) id;

xml2dp_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Bool,
            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
              (Strategy a [Prelude.Char],
                [(Term a [Prelude.Char], Term a [Prelude.Char])])));
xml2dp_input xml2name =
  guard (\ x -> equal_nat (num_children x) (Nat_of_num (Bit0 (Bit0 One))))
    (tuple4 "dpInput" (singleton "trs" (rules xml2name) id)
      (singleton "dps" (rules xml2name) id) (strategy xml2name) (bool "minimal")
      (\ r p s m -> (m, (p, (s, r)))))
    (triple "dpInput" (singleton "trs" (rules xml2name) id)
      (singleton "dps" (rules xml2name) id) (bool "minimal")
      (\ r p m -> (m, (p, (No_Strategy, r)))));

xml2input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Input a [Prelude.Char]);
xml2input xml2name =
  singleton "input"
    (options
      [("dpInput", change (xml2dp_input xml2name) DP_input),
        ("completionInput", change (xml2completion_input xml2name) COMP_input),
        ("trsInput", xml2pre_trs_input xml2name),
        ("equationalReasoningInput",
          change (xml2equational_input xml2name) EQ_input),
        ("complexityInput", change (xml2complexity_input xml2name) CPX_input),
        ("ctrsInput", change (xml2ctrs_input xml2name) CTRS_input),
        ("unknownInput", change xml2unknown_input Unknown_input)])
    id;

xml_crule ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => ((Term (Lab a [b]) c, Term (Lab a [b]) c),
                    [(Term (Lab a [b]) c, Term (Lab a [b]) c)]) ->
                    Xml;
xml_crule = (\ (c, rs) -> XML "conditionalRule" [] (map xml_rule (c : rs)));

xml_rules ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => [Prelude.Char] ->
                    [(Term (Lab a [b]) c, Term (Lab a [b]) c)] -> Xml;
xml_rules tag rls = XML tag [] [XML "rules" [] (map xml_rule rls)];

missing ::
  [Prelude.Char] ->
    ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
missing s x =
  shows_string "the " .
    shows_string s . shows_string " " . x . shows_string " is missing";

toomuch ::
  [Prelude.Char] ->
    ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
toomuch s x =
  shows_string "superfluous " . shows_string s . shows_string " " . x . x;

is_NF_subset :: forall a b. (Term a b -> Bool) -> [Term a b] -> Bool;
is_NF_subset is_Q_nf q = all (\ qa -> not (is_Q_nf qa)) q;

icap_impl_gen ::
  forall a.
    (Eq a) => Bool ->
                (Term a [Prelude.Char] -> Bool) ->
                  [Term a [Prelude.Char]] ->
                    [Term a [Prelude.Char]] ->
                      ([Prelude.Char] -> Bool) ->
                        Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char]);
icap_impl_gen nf isQnf ls s sx (Var x) =
  (if nf && sx x then Var (Inr x) else Var (Inl ()));
icap_impl_gen nf isQnf ls s sx (Fun f ts) =
  let {
    t = Fun f (map (icap_impl_gen nf isQnf ls s sx) ts);
  } in (if any (\ l ->
                 (case mgu_class t l of {
                   Nothing -> False;
                   Just mu ->
                     all (\ u ->
                           isQnf (subst_apply_term
                                   (map_term (\ x -> x) (\ a -> 'y' : a) u) mu))
                       (args l) &&
                       all (\ u -> isQnf (subst_apply_term u mu)) s;
                 }))
             ls
         then Var (Inl ()) else t);

ins_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
ins_rm_basic_ops x s = insert x () s;

g_from_list_aux_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> [a] -> Rbt a ();
g_from_list_aux_dflt_basic_oops_rm_basic_ops y [] = y;
g_from_list_aux_dflt_basic_oops_rm_basic_ops accs (x : l) =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops (ins_rm_basic_ops x accs) l;

empty_rm_basic_ops :: forall a. (Linorder a) => () -> Rbt a ();
empty_rm_basic_ops = (\ _ -> empty);

g_from_list_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => [a] -> Rbt a ();
g_from_list_dflt_basic_oops_rm_basic_ops l =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops (empty_rm_basic_ops ()) l;

memb_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Bool;
memb_rm_basic_ops x s = not (is_none (lookup s x));

ceta_set_of :: forall a. (Key a) => [a] -> a -> Bool;
ceta_set_of ps =
  let {
    tree = g_from_list_dflt_basic_oops_rm_basic_ops ps;
  } in (\ a -> memb_rm_basic_ops a tree);

icap_impl ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char]);
icap_impl isnf r =
  let {
    ls = map fst r;
    nf = is_NF_subset isnf ls;
    ic = icap_impl_gen nf isnf ls;
  } in (\ s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
           sx = ceta_set_of (concatMap vars_term_list sa);
         } in (\ t -> ic sa sx (map_term (\ x -> x) (\ a -> 'x' : a) t)));

rep_subst_incr ::
  forall a b. Subst_incr a b -> (b -> Term a b, (Set b, Term a b -> [b]));
rep_subst_incr (Abs_subst_incr x) = x;

si_W :: forall a b. Subst_incr a b -> Term a b -> [b];
si_W xa = snd (snd (rep_subst_incr xa));

kbo_nstrict ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ((a, Nat) -> Nat) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        (a -> Bool) ->
                          ((a, Nat) -> Nat -> Nat) ->
                            (Term a b, Term a b) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
kbo_nstrict pr w w0 least scf =
  (\ (s, t) ->
    check (snd (kbo_impl w w0 pr least scf s t))
      (shows_string "could not orient " .
        shows_prec_term Zero_nat s .
          shows_string " >=KBO " . shows_prec_term Zero_nat t . shows_nl));

list_inter :: forall a. (Eq a) => [a] -> [a] -> [a];
list_inter [] bs = [];
list_inter (a : asa) bs =
  (if membera bs a then a : list_inter asa bs else list_inter asa bs);

list_union :: forall a. (Eq a) => [a] -> [a] -> [a];
list_union [] ys = ys;
list_union (x : xs) ys =
  let {
    zs = list_union xs ys;
  } in (if membera zs x then zs else x : zs);

sub_vec :: forall a. Nat -> [a] -> [a];
sub_vec = take;

sub_mat :: forall a. Nat -> Nat -> [[a]] -> [[a]];
sub_mat nr nc m = map (sub_vec nr) (take nc m);

default_I :: forall a. (Poly_carrier a) => a -> Nat -> [([(Nat, Nat)], a)];
default_I def n =
  ([], def) : map (\ i -> ([(i, Nat_of_num One)], onea)) (upt Zero_nat n);

eval_monom :: forall a b. (Comm_semiring_1 b) => (a -> b) -> [(a, Nat)] -> b;
eval_monom alpha [] = onea;
eval_monom alpha ((x, p) : m) = times (eval_monom alpha m) (powera (alpha x) p);

eval_poly ::
  forall a b. (Comm_semiring_1 b) => (a -> b) -> [([(a, Nat)], b)] -> b;
eval_poly alpha [] = zeroa;
eval_poly alpha (mc : p) =
  plus (times (eval_monom alpha (fst mc)) (snd mc)) (eval_poly alpha p);

poly_vars ::
  forall a b. (Ceq a, Ccompare a, Set_impl a) => [([(a, Nat)], b)] -> Set a;
poly_vars p = set (concatMap (map fst . fst) p);

proper_prefix_list :: Pos -> [Pos];
proper_prefix_list Empty = [];
proper_prefix_list (PCons i p) = Empty : map (PCons i) (proper_prefix_list p);

prefix_list :: Pos -> [Pos];
prefix_list p = p : proper_prefix_list p;

scnp_arity :: forall a. [((a, Nat), [(Nat, Nat)])] -> Nat;
scnp_arity af = max_list (map (\ (_, a) -> size_list a) af);

rules_no_left_vara :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
rules_no_left_vara
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_no_left_var;

rules_mapb ::
  forall a b c d.
    Dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
rules_mapb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_map;

tcapRM_dpp ::
  forall a b c.
    (Eq b, Eq c) => Dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
tcapRM_dpp i dpp = tcapRM (rules_no_left_vara i dpp) (rules_mapb i dpp);

funas_term_list :: forall a b. Term a b -> [(a, Nat)];
funas_term_list (Var uu) = [];
funas_term_list (Fun f ts) = (f, size_list ts) : concatMap funas_term_list ts;

check_supt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Term a b ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_supt s t =
  check (supt_impl s t)
    (shows_prec_term Zero_nat t .
      shows_string " is not a proper subterm of " . shows_prec_term Zero_nat s);

compute_trancl ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Set_impl a) => Set a -> Set (a, a) -> Set a;
compute_trancl a r =
  let {
    b = imagea r a;
  } in (if less_eq_set b bot_set then bot_set
         else sup_set b
                (compute_trancl b
                  (filtera
                    (\ ab -> not (member (fst ab) a) && not (member (snd ab) b))
                    r)));

r_lhs_states :: forall a b. Ta_rule a b -> [a];
r_lhs_states (TA_rule f qs q) = qs;

ta_rules :: forall a b c. Ta_ext a b c -> Set (Ta_rule a b);
ta_rules (Ta_ext ta_final ta_rules ta_eps more) = ta_rules;

ta_eps :: forall a b c. Ta_ext a b c -> Set (a, a);
ta_eps (Ta_ext ta_final ta_rules ta_eps more) = ta_eps;

ta_res ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => Ta_ext a b () -> Term b a -> Set a;
ta_res ta (Fun f ts) =
  let {
    qs = map (ta_res ta) ts;
    g = (f, size_list ts);
  } in sup_set
         (image r_rhs
           (filtera
             (\ r ->
               r_sym r == g &&
                 all (\ qq -> member (snd qq) (fst qq))
                   (zip qs (r_lhs_states r)))
             (ta_rules ta)))
         (compute_trancl
           (image r_rhs
             (filtera
               (\ r ->
                 r_sym r == g &&
                   all (\ qq -> member (snd qq) (fst qq))
                     (zip qs (r_lhs_states r)))
               (ta_rules ta)))
           (ta_eps ta));
ta_res ta (Var q) =
  sup_set (inserta q bot_set) (compute_trancl (inserta q bot_set) (ta_eps ta));

eq_rule_mod_vars ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b, Term a b) -> (Term a b, Term a b) -> Bool;
eq_rule_mod_vars lr st = instance_rule lr st && instance_rule st lr;

generate_var :: Nat -> [Prelude.Char];
generate_var i = 'x' : shows_prec_nat Zero_nat i [];

uncurry_term ::
  forall a b. (Eq a) => a -> (a -> Nat -> [a]) -> Term a b -> Term a b;
uncurry_term a sm t =
  (case unapp a t of {
    (Var x, ts) -> apply_args a (Var x) (map (uncurry_term a sm) ts);
    (Fun f ss, ts) ->
      let {
        n = size_list ss;
        uss = map (uncurry_term a sm) ss;
        uts = map (uncurry_term a sm) ts;
        aa = aarity sm f n;
        m = min (size_list ts) aa;
        fm = get_symbol sm f n m;
      } in apply_args a (Fun fm (uss ++ take m uts)) (drop m uts);
  });

conversion ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                   (Bool, Term a [Prelude.Char])))];
conversion xml2name =
  many1 "conversion" (singleton "startTerm" (term xml2name) id) (estep xml2name)
    (\ _ x -> x);

plain_name :: Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat]);
plain_name x =
  options
    [("name", change (text "name") UnLab),
      ("sharp", singleton "sharp" plain_name Sharp),
      ("labeledSymbol",
        pair "labeledSymbol" plain_name
          (options
            [("numberLabel", many "numberLabel" (nata "number") Inl),
              ("symbolLabel", many "symbolLabel" plain_name Inr)])
          (\ f a ->
            (case a of {
              Inl aa -> Lab f aa;
              Inr aa -> FunLab f aa;
            })))]
    x;

rule_pairs ::
  forall a.
    [Prelude.Char] ->
      [Prelude.Char] ->
        (Xml -> Sum_bot [Prelude.Char] a) ->
          Xml ->
            Sum_bot [Prelude.Char]
              [((Term a [Prelude.Char], Term a [Prelude.Char]),
                 (Term a [Prelude.Char], Term a [Prelude.Char]))];
rule_pairs s p xml2name =
  many s (pair p (rule xml2name) (rule xml2name) (\ a b -> (a, b))) id;

xml1or2many_elements ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> Maybe b -> [c] -> d) -> Xml -> Sum_bot [Prelude.Char] d;
xml1or2many_elements tag p1 p2 p3 f (XML name atts cs) =
  (if name == tag && null atts && not (null cs)
    then let {
           (cs0 : tt) = cs;
         } in binda (p1 cs0)
                (\ x ->
                  (case tt of {
                    [] -> returna (f x Nothing []);
                    cs1 : t ->
                      catch_error
                        (binda (p2 cs1)
                          (\ y ->
                            binda (map_sum_bot p3 t)
                              (\ xs -> returna (f x (Just y) xs))))
                        (\ _ ->
                          binda (map_sum_bot p3 tt)
                            (\ xs -> returna (f x Nothing xs)));
                  }))
    else fail tag (XML name atts cs));
xml1or2many_elements tag p1 p2 p3 f (XML_text v) = fail tag (XML_text v);

sl_variant ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Sl_variant a [Prelude.Char]);
sl_variant xml2name =
  singleton "model"
    (options
      [("finiteModel",
         xml1or2many_elements "finiteModel"
           (change (nata "carrierSize") (\ n -> minus_nat n (Nat_of_num One)))
           (singleton "tupleOrder" (leaf "pointWise" ()) id)
           (triple "interpret" xml2name (nata "arity") arith_fun
             (\ f a -> (\ b -> ((f, a), b))))
           (\ n model xs ->
             (if is_none model then Finitelab (SL_Inter n xs)
               else QuasiFinitelab (SL_Inter n xs) []))),
        ("rootLabeling",
          guard (\ x -> equal_nat (num_children x) Zero_nat)
            (leaf "rootLabeling" (Rootlab Nothing))
            (singleton "rootLabeling" xml2name
              (\ f -> Rootlab (Just (f, Nat_of_num One)))))])
    id;

transition_lhs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Sum a [Prelude.Char]);
transition_lhs xml2lhs =
  choice "lhs" [singleton "lhs" state Inr, change xml2lhs Inl];

transition ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]])) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Sum (Ta_rule [Prelude.Char] a) ([Prelude.Char], [Prelude.Char]));
transition xml2lhs =
  pair "transition" (transition_lhs xml2lhs) (singleton "rhs" state id)
    (\ lhs q ->
      (case lhs of {
        Inl (f, qs) -> Inl (TA_rule f qs q);
        Inr qa -> Inr (qa, q);
      }));

max_tag :: Nat;
max_tag = Nat_of_num (Bit1 (Bit0 (Bit1 (Bit1 One))));

all_interval_nat :: (Nat -> Bool) -> Nat -> Nat -> Bool;
all_interval_nat p i j =
  less_eq_nat j i || p i && all_interval_nat p (plus_nat i (Nat_of_num One)) j;

shows_prec_pos :: Nat -> Pos -> [Prelude.Char] -> [Prelude.Char];
shows_prec_pos d p = shows_pos p;

check_prop_rstep_rule ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      Pos ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstep_rule nfs pa p rule s t =
  bindb (check (in_poss p s)
          (shows_prec_pos Zero_nat p .
            shows_string " is not a position of " .
              shows_prec_term Zero_nat s . shows_nl))
    (\ _ ->
      bindb (check (in_poss p t)
              (shows_prec_pos Zero_nat p .
                shows_string " is not a position of " .
                  shows_prec_term Zero_nat t . shows_nl))
        (\ _ ->
          let {
            c = ctxt_of_pos_term p s;
            d = ctxt_of_pos_term p t;
            u = subt_at s p;
            v = subt_at t p;
          } in (case match_list Var [(fst rule, u), (snd rule, v)] of {
                 Nothing ->
                   Inl (shows_string "the term " .
                         shows_prec_term Zero_nat t .
                           shows_string
                             " does not result from a proper application of rule " .
                             shows_nl .
                               shows_rule (shows_prec Zero_nat)
                                 (shows_prec Zero_nat) " -> " rule .
                                 shows_string " at position " .
                                   shows_prec_pos Zero_nat p . shows_nl);
                 Just tau ->
                   bindb (catch_errora
                           (forallM pa
                             (args u ++
                               (if nfs then map tau (vars_rule_list rule)
                                 else [])))
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       check (equal_ctxt c d)
                         (shows_string "the term " .
                           shows_prec_term Zero_nat t .
                             shows_string
                               " does not result from a proper application of rule " .
                               shows_nl .
                                 shows_rule (shows_prec Zero_nat)
                                   (shows_prec Zero_nat) " -> " rule .
                                   shows_string " at position " .
                                     shows_prec_pos Zero_nat p . shows_nl));
               })));

check_prop_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstep nfs pa r p rule s t =
  check (any (\ ra ->
               eq_rule_mod_vars rule ra &&
                 isOK (check_prop_rstep_rule nfs pa p ra s t))
          r)
    (shows_prec_list Zero_nat "the step from " .
      shows_prec_term Zero_nat s .
        shows_prec_list Zero_nat " to " .
          shows_prec_term Zero_nat t .
            shows_prec_list Zero_nat " via rule " .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                rule .
                shows_prec_list Zero_nat " at position " .
                  shows_prec_pos Zero_nat p .
                    shows_prec_list Zero_nat " is problematic" . shows_nl);

check_qrstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrstep nf nfs =
  check_prop_rstep nfs
    (\ t ->
      check (nf t)
        (shows_prec_term Zero_nat t .
          shows_prec_list Zero_nat " is not in Q-normal form"));

check_rqrstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rqrstep nf nfs r rule s t = check_qrstep nf nfs r Empty rule s t;

check_qsteps ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qsteps nf nfs p r [] s u =
  check (equal_term s u)
    (shows_string "the last term of the rewrite sequence" .
      shows_nl .
        shows_prec_term Zero_nat s .
          shows_nl .
            shows_string "does not correspond to the goal term" .
              shows_nl . shows_prec_term Zero_nat u . shows_nl);
check_qsteps nf nfs p ra ((uu, (r, (True, t))) : prts) s u =
  bindb (check_rqrstep nf nfs p r s t)
    (\ _ -> check_qsteps nf nfs p ra prts t u);
check_qsteps nf nfs pa ra ((p, (r, (False, t))) : prts) s u =
  bindb (check_qrstep nf nfs ra p r s t)
    (\ _ -> check_qsteps nf nfs pa ra prts t u);

check_qrsteps ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrsteps nf nfs r prts s u =
  check_qsteps nf nfs [] r (map (\ (p, (ra, t)) -> (p, (ra, (False, t)))) prts)
    s u;

check_qrstep_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrstep_subst cni nfs =
  let {
    main =
      check_prop_rstep nfs
        (\ t ->
          catch_errora (cni t)
            (\ _ ->
              Inl (shows_prec_term Zero_nat t .
                    shows_prec_list Zero_nat
                      " mu ^^ i is not in Q-normal form for all i")));
  } in (\ r p ra s t ->
         bindb (check (not (is_Var (fst ra)))
                 (shows_prec_list Zero_nat
                   "loop check requires lhss to be non-variable"))
           (\ _ -> main r p ra s t));

check_rqrstep_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rqrstep_subst cni nfs = (\ r -> check_qrstep_subst cni nfs r Empty);

check_qsteps_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qsteps_subst cni nfs p r [] s u =
  check (equal_term s u)
    (shows_string "the last term of the rewrite sequence" .
      shows_nl .
        shows_prec_term Zero_nat s .
          shows_nl .
            shows_string "does not correspond to the goal term" .
              shows_nl . shows_prec_term Zero_nat u . shows_nl);
check_qsteps_subst cni nfs p ra ((uu, (r, (True, t))) : prts) s u =
  bindb (check_rqrstep_subst cni nfs p r s t)
    (\ _ -> check_qsteps_subst cni nfs p ra prts t u);
check_qsteps_subst cni nfs pa ra ((p, (r, (False, t))) : prts) s u =
  bindb (check_qrstep_subst cni nfs ra p r s t)
    (\ _ -> check_qsteps_subst cni nfs pa ra prts t u);

check_qrsteps_subst ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrsteps_subst cni nfs r prts s u =
  check_qsteps_subst cni nfs [] r
    (map (\ (p, (ra, t)) -> (p, (ra, (False, t)))) prts) s u;

si_subst :: forall a b. Subst_incr a b -> b -> Term a b;
si_subst xa = fst (rep_subst_incr xa);

supteq_list :: forall a b. Term a b -> [Term a b];
supteq_list (Var x) = [Var x];
supteq_list (Fun f ts) = Fun f ts : concatMap supteq_list ts;

match_prob_of_rp_impl ::
  forall a b.
    (Eq a,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> [(Term a b, Term a b)];
match_prob_of_rp_impl mu (t, Var x) = [(t, Var x)];
match_prob_of_rp_impl mu (t, Fun v va) =
  let {
    sterms = remdups (t : map (si_subst mu) (si_W mu t));
    uterms = concatMap (filter (\ ta -> not (is_Var ta)) . supteq_list) sterms;
  } in map (\ u -> (u, Fun v va)) (remdups uterms);

si_v_incr :: forall a b. Subst_incr a b -> Set b;
si_v_incr xa = fst (snd (rep_subst_incr xa));

simplify_mp ::
  forall a b.
    (Eq a, Ceq b,
      Ccompare b) => Subst_incr a b ->
                       [(Term a b, Term a b)] ->
                         [(Term a b, Term a b)] ->
                           Maybe ([(Term a b, Term a b)], Nat);
simplify_mp mu_incr ((Var x, Fun f ls) : mp) solved =
  bind (guarda (member x (si_v_incr mu_incr)))
    (\ _ ->
      let {
        m = map (\ (s, a) -> (subst_apply_term s (si_subst mu_incr), a));
      } in bind (simplify_mp mu_incr (m ((Var x, Fun f ls) : mp)) (m solved))
             (\ (smp, i) -> Just (smp, plus_nat i (Nat_of_num One))));
simplify_mp mu_incr ((Fun g ts, Fun f ls) : mp) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (zip_option ts ls)
        (\ pairs -> simplify_mp mu_incr (pairs ++ mp) solved));
simplify_mp mu_incr ((s, Var x) : mp) solved =
  simplify_mp mu_incr mp ((s, Var x) : solved);
simplify_mp mu_incr [] solved = Just (solved, Zero_nat);

conflicts ::
  forall a b.
    (Eq a,
      Eq b) => (a -> Term b a) ->
                 (Term b a, (Term b a, Nat)) -> [(Term b a, (Term b a, Nat))];
conflicts mu (Fun f ts, (Fun g ss, n)) =
  (if f == g && equal_nat (size_list ts) (size_list ss)
    then concatMap (\ (s, t) -> conflicts mu (s, (t, n))) (zip ts ss)
    else [(Fun f ts, (Fun g ss, n))]);
conflicts mu (Var x, (Fun g ss, n)) = [(Var x, (Fun g ss, n))];
conflicts mu (Fun f ts, (Var y, n)) =
  (if equal_nat n Zero_nat then [(Var y, (Fun f ts, Zero_nat))]
    else conflicts mu (Fun f ts, (mu y, minus_nat n (Nat_of_num One))));
conflicts mu (Var x, (Var y, n)) =
  (if equal_nat n Zero_nat
    then (if x == y then [] else [(Var x, (Var y, Zero_nat))])
    else conflicts mu (Var x, (mu y, minus_nat n (Nat_of_num One))));

ident_solvea ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b ->
                 Set (Term a b, (Term a b, Nat)) ->
                   (Term a b, (Term a b, Nat)) -> Maybe Nat;
ident_solvea mu_incr cps st =
  let {
    cp = conflicts (si_subst mu_incr) st;
  } in (if any (\ (u, (_, _)) -> not (is_Var u)) cp then Nothing
         else (if any (\ (u, (v, _)) ->
                        member (u, v) (image (\ (ua, (va, _)) -> (ua, va)) cps))
                    cp
                then Nothing
                else bind (mapMa
                            (\ (u, (v, m)) ->
                              ident_solvea mu_incr (inserta (u, (v, m)) cps)
                                (subst_apply_term u (si_subst mu_incr),
                                  (v, plus_nat m (Nat_of_num One))))
                            (conflicts (si_subst mu_incr) st))
                       (\ is -> Just (max_list (map suc is)))));

ident_solve ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Maybe Nat;
ident_solve mu_incr =
  (\ (s, t) ->
    ident_solvea mu_incr
      (set_empty
        (of_phantom
          (set_impl_prod :: Phantom (Term a b, (Term a b, Nat)) Set_impla)))
      (s, (t, Zero_nat)));

ident_decision ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
ident_decision sigma ip = not (is_none (ident_solve sigma ip));

ident_prob_of_smp ::
  forall a b. (Eq a, Eq b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)];
ident_prob_of_smp [] = [];
ident_prob_of_smp ((t, l) : other) =
  map_filter
    (\ x ->
      (if let {
            (_, s) = x;
          } in equal_term s l
        then Just (let {
                     (s, _) = x;
                   } in (t, s))
        else Nothing))
    other ++
    ident_prob_of_smp other;

gmatch_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> [(Term a b, Term a b)] -> Bool;
gmatch_decision sigma mp =
  not (is_none
        (bind (simplify_mp sigma mp [])
          (\ (smp, _) ->
            guarda (all (ident_decision sigma) (ident_prob_of_smp smp)))));

match_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
match_decision mu mp = gmatch_decision mu [mp];

redex_decision ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
redex_decision mu rp = any (match_decision mu) (match_prob_of_rp_impl mu rp);

new_as :: forall a b. (a -> b -> Bool) -> [a] -> [b] -> [b];
new_as p bs asa = filter (\ a -> any (\ b -> p b a) bs) asa;

the_set_impl_main ::
  forall a b.
    (Eq a, Eq b) => (a -> b -> Bool) -> (b -> [a]) -> [b] -> [b] -> [a] -> [b];
the_set_impl_main p q remain have bs =
  let {
    new = new_as p bs remain;
  } in (if null new then have
         else the_set_impl_main p q (list_diff remain new) (new ++ have)
                (remdups (concatMap q new)));

the_set_impl ::
  forall a b.
    (Eq a, Eq b) => [a] -> (b -> a -> Bool) -> (a -> [b]) -> [b] -> [a];
the_set_impl r p q bs = the_set_impl_main p q r [] bs;

inductive_set_impl ::
  forall a b.
    (Eq a, Eq b) => [a] -> (b -> a -> Bool) -> (a -> [b]) -> [b] -> [a];
inductive_set_impl = the_set_impl;

v_incr_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
v_incr_impl mu =
  inductive_set_impl (map fst mu) (\ a b -> a == b)
    (\ x ->
      concatMap (\ (y, t) -> (if equal_term t (Var x) then [y] else [])) mu)
    (concatMap (\ (y, t) -> (if not (is_Var t) then [y] else [])) mu);

relpow_impl ::
  forall a b.
    ([a] -> [a]) -> ([a] -> b -> b) -> (a -> b -> Bool) -> [a] -> b -> Nat -> b;
relpow_impl succ un memb new have m =
  (if equal_nat m Zero_nat then un new have
    else (if null new then have
           else let {
                  maybe = succ new;
                  havea = un new have;
                  newa = filter (\ n -> not (memb n havea)) maybe;
                } in relpow_impl succ un memb newa havea
                       (minus_nat m (Nat_of_num One))));

rtrancl_impl ::
  forall a b.
    ([(a, a)] -> [a] -> [a]) ->
      ([a] -> b -> b) -> (a -> b -> Bool) -> b -> [(a, a)] -> [a] -> b;
rtrancl_impl gen_succ un memb emp rel =
  let {
    succ = gen_succ rel;
    n = size_list rel;
  } in (\ asa -> relpow_impl succ un memb asa emp n);

rtrancl_list_impl :: forall a. (Eq a) => [(a, a)] -> [a] -> [a];
rtrancl_list_impl =
  rtrancl_impl
    (\ r asa ->
      remdups
        (map_filter
          (\ x ->
            (if let {
                  (a, _) = x;
                } in membera asa a
              then Just (snd x) else Nothing))
          r))
    (\ xs ys -> filter (\ x -> not (membera ys x)) xs ++ ys)
    (\ x xs -> membera xs x) [];

w_impl :: forall a b. (Eq a) => [(a, Term b a)] -> Term b a -> [a];
w_impl d =
  let {
    filt = filter (\ (x, y) -> not (x == y));
    xvs = concatMap (\ (x, t) -> map (\ a -> (x, a)) (vars_term_list t)) d;
    rel = filt xvs;
    rtran = rtrancl_list_impl rel;
  } in (\ t -> rtran (vars_term_list t));

subst_incr ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq b) => [(a, Term b a)] -> Subst_incr b a;
subst_incr xa =
  Abs_subst_incr
    (let {
       dom = mk_subst_domain xa;
     } in (mk_subst Var xa, (set (v_incr_impl dom), w_impl dom)));

redex_rps_decision ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] ->
                 [(Term b a, Term b a)] -> Sum (Term b a, Term b a) ();
redex_rps_decision mu =
  let {
    mua = subst_incr mu;
    main = redex_decision mua;
  } in (\ xs ->
         catch_errora (forallM (\ tl -> check (not (main tl)) tl) xs)
           (\ x -> Inl (snd x)));

check_NF_iteration ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] ->
                 [Term b a] -> Term b a -> Sum (Term b a, Term b a) ();
check_NF_iteration mu =
  let {
    dec = redex_rps_decision mu;
  } in (\ q t -> dec (map (\ a -> (t, a)) q));

check_loop ::
  forall a b.
    (Compare a, Eq a, Showa a, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [Term a b] ->
                    Bool ->
                      Term a b ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          [(b, Term a b)] ->
                            Ctxt a b ->
                              [(Term a b, Term a b)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_loop q nfs s rseq sigma c r =
  bindb (check (not (null rseq))
          (shows_prec_list Zero_nat "rewrite sequence must be non-empty"))
    (\ _ ->
      (if null q
        then check_qrsteps (\ _ -> True) nfs r rseq s
               (ctxt_apply_term c (subst_apply_term s (mk_subst Var sigma)))
        else check_qrsteps_subst (check_NF_iteration sigma q) nfs r rseq s
               (ctxt_apply_term c (subst_apply_term s (mk_subst Var sigma)))));

fun_of_map :: forall a b. (a -> Maybe b) -> b -> a -> b;
fun_of_map m d a = (case m a of {
                     Nothing -> d;
                     Just b -> b;
                   });

delete_value ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> a -> Rbt b [a] -> Rbt b [a];
delete_value key v m =
  (case key v of {
    Nothing -> m;
    Just k ->
      (case lookup m k of {
        Nothing -> m;
        Just vs -> insert k (removeAll v vs) m;
      });
  });

insert_value ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> a -> Rbt b [a] -> Rbt b [a];
insert_value key v m =
  (case key v of {
    Nothing -> m;
    Just k ->
      (case lookup m k of {
        Nothing -> insert k [v] m;
        Just vs -> insert k (insertb v vs) m;
      });
  });

check_ge_v :: forall a. (Poly_carrier a) => a -> [([(Nat, Nat)], a)] -> Bool;
check_ge_v v p =
  (case p of {
    [] -> True;
    [([], c)] -> less_eq c v;
    ([], _) : _ : _ -> False;
    (_ : _, _) : _ -> False;
  });

check_poly_weak_anti_mono_discrete ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono_discrete p v =
  check_poly_ge p
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p);

check_poly_weak_anti_mono ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Ordered_semiring_0 b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono p v =
  all (\ (m, c) -> less_eq c zeroa || not (member v (image fst (set m)))) p;

check_poly_weak_anti_mono_smart ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Eq b,
      Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono_smart discrete =
  (if discrete then check_poly_weak_anti_mono_discrete
    else check_poly_weak_anti_mono);

check_poly_weak_mono_discrete ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono_discrete p v =
  check_poly_ge
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p)
    p;

check_poly_weak_mono ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Ordered_semiring_0 b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono p v =
  all (\ (m, c) -> less_eq zeroa c || not (member v (image fst (set m)))) p;

check_poly_weak_mono_smart ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a, Eq b,
      Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono_smart discrete =
  (if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono);

fun_of_map_fun :: forall a b. (a -> Maybe b) -> (a -> b) -> a -> b;
fun_of_map_fun m d a = (case m a of {
                         Nothing -> d a;
                         Just b -> b;
                       });

g_list_to_map_rm_basic_ops ::
  forall a b. (Compare_order a) => [(a, b)] -> Rbt a b;
g_list_to_map_rm_basic_ops l =
  foldl (\ m (k, v) -> insert k v m) empty (reverse l);

ceta_map_of :: forall a b. (Key a) => [(a, b)] -> a -> Maybe b;
ceta_map_of ps = lookup (g_list_to_map_rm_basic_ops ps);

poly_inter_list_to_inter ::
  forall a b.
    (Poly_carrier a,
      Key b) => a -> [((b, Nat), [([(Nat, Nat)], a)])] ->
                       (b, Nat) -> [([(Nat, Nat)], a)];
poly_inter_list_to_inter def i =
  fun_of_map_fun (ceta_map_of i) (\ fn -> default_I def (snd fn));

fun_of_map_funa ::
  forall a b c. (a -> Maybe b) -> (a -> c) -> (b -> c) -> a -> c;
fun_of_map_funa m d f a = (case m a of {
                            Nothing -> d a;
                            Just aa -> f aa;
                          });

create_dep ::
  forall a b.
    (Eq a, Poly_carrier a, Eq b,
      Key b) => Bool ->
                  a -> [((b, Nat), [([(Nat, Nat)], a)])] ->
                         (b, Nat) -> Nat -> Dependance;
create_dep discrete def i =
  let {
    fs = remdups (map fst i);
    ii = poly_inter_list_to_inter def i;
    fsres =
      map (\ fn ->
            let {
              p = ii fn;
              vars = poly_vars_list p;
              is = upt Zero_nat (snd fn);
              a = map (\ ia ->
                        (if membera vars ia
                          then (if check_poly_weak_mono_smart discrete p ia
                                 then Increase
                                 else (if check_poly_weak_anti_mono_smart
    discrete p ia
then Decrease else Wild))
                          else Ignore))
                    is;
            } in (fn, a))
        fs;
    iii = fun_of_map_funa (ceta_map_of fsres) (\ _ _ -> Increase) nth;
  } in iii;

xml_tag :: forall a b c. Cert_problem a b c -> [Prelude.Char];
xml_tag (TRS_Termination_Proof uu uv uw (Just ux) uy) =
  "<relativeTerminationProof>";
xml_tag (TRS_Termination_Proof uz va vb Nothing vc) = "<trsTerminationProof>";
xml_tag (Complexity_Proof vd ve vf vg vh vi) = "<complexityProof>";
xml_tag (TRS_Nontermination_Proof vj vk vl vm) = "<trsNonterminationProof>";
xml_tag (Outermost_Nontermination_Proof vn vo) = "<trsNonterminationProof>";
xml_tag (Outermost_Termination_Proof vp vq) = "<trsTerminationProof>";
xml_tag (FP_Nontermination_Proof vr vs vt) = "<trsNonterminationProof>";
xml_tag (FP_Termination_Proof vu vv vw) = "<trsTerminationProof>";
xml_tag (CS_Nontermination_Proof vx vy vz) = "<trsNonterminationProof>";
xml_tag (CS_Termination_Proof wa wb wc) = "<trsTerminationProof>";
xml_tag (Relative_TRS_Nontermination_Proof wd we wf wg wh) =
  "<relativeNonterminationProof>";
xml_tag (DP_Termination_Proof wi wj wk wl wm wn wo wp) = "<dpProof>";
xml_tag (DP_Nontermination_Proof wq wr ws wt wu wv) = "<dpNonterminationProof>";
xml_tag (TRS_Confluence_Proof ww wx wy) = "<crProof>";
xml_tag (TRS_Non_Confluence_Proof wz xa xb) = "<crDisproof>";
xml_tag (Completion_Proof xc xd xe) = "<completionProof>";
xml_tag (Equational_Proof xf xg xh) = "<equationalProof>";
xml_tag (Equational_Disproof xi xj xk) = "<equationalDisproof>";
xml_tag (Quasi_Reductive_Proof xl xm) = "<quasiReductiveProof>";
xml_tag (Conditional_CR_Proof xn xo) = "<conditionalCrProof>";
xml_tag (Unknown_Proof xp xq) = "<unknownInputProof>";
xml_tag (Unknown_Disproof xr xs) = "<unknownInputProof>";

enfc_q ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                (Term a [Prelude.Char] -> Bool) ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [Term a [Prelude.Char]] ->
                      [Term a [Prelude.Char]] -> Term a [Prelude.Char] -> Bool;
enfc_q isQnf isRnf r q s (Var x) = True;
enfc_q isQnf isRnf r q s (Fun f ts) =
  all (\ qa ->
        (case mgu_class (Fun f (map (icap_impl isQnf r s) ts)) qa of {
          Nothing -> True;
          Just mu ->
            not (all (\ u ->
                       isQnf (subst_apply_term
                               (map_term (\ x -> x) (\ a -> 'x' : a) u) mu))
                   s &&
                  isRnf (subst_apply_term
                          (map_term (\ x -> x) (\ a -> 'y' : a) qa) mu));
        }))
    q;

delete_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
delete_values uu [] m = m;
delete_values key (v : vs) m = delete_value key v (delete_values key vs m);

delete_rules ::
  forall a b c.
    (Eq a, Compare_order b, Eq b,
      Eq c) => a -> [(Term b c, Term b c)] ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        Rbt (b, Nat) [(a, (Term b c, Term b c))];
delete_rules a rs = delete_values key (map (\ b -> (a, b)) rs);

insert_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
insert_values uu [] m = m;
insert_values key (v : vs) m = insert_value key v (insert_values key vs m);

insert_rules ::
  forall a b c.
    (Eq a, Compare_order b, Eq b,
      Eq c) => a -> [(Term b c, Term b c)] ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        Rbt (b, Nat) [(a, (Term b c, Term b c))];
insert_rules a rs = insert_values key (map (\ b -> (a, b)) rs);

split_rulesc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_rulesc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = split_rules;

split_pairsa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_pairsa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = split_pairs;

delete_R_Rwc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_R_Rwc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = delete_R_Rw;

delete_P_Pwa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_P_Pwa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = delete_P_Pw;

minimal :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
minimal
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = minimal;

nfsc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
nfsc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
       rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
       reverse_rules_map intersect_pairs replace_pair intersect_rules
       delete_P_Pw delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules
       more)
  = nfs;

mkc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      Bool ->
        Bool ->
          [(Term b c, Term b c)] ->
            [(Term b c, Term b c)] ->
              [Term b c] ->
                [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = mk;

qc :: forall a b c d. Dpp_ops_ext a b c d -> a -> [Term b c];
qc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = q;

split_proc ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> [(Term b c, Term b c)] ->
                           [(Term b c, Term b c)] -> (a, a);
split_proc i d p_remove r_remove =
  let {
    (p, pw) = split_pairsa i d p_remove;
    (r, rw) = split_rulesc i d r_remove;
    dpp1 = mkc i (nfsc i d) (minimal i d) p pw (qc i d) r rw;
    a = delete_R_Rwc i (delete_P_Pwa i d p_remove p_remove) r_remove r_remove;
  } in (dpp1, a);

rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a ->
      Maybe ((a, Nat) -> [Nat]);
rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
  (Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option x) = x;

sel21 ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a -> Status a;
sel21 xa =
  Abs_status
    (case rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option xa of {
      Nothing -> status (error "undefined");
      Just x2 -> x2;
    });

dis1 ::
  forall a. X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a -> Bool;
dis1 xa =
  (case rep_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option xa of {
    Nothing -> True;
    Just _ -> False;
  });

rep_isom ::
  forall a.
    X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a ->
      Maybe (Status a);
rep_isom x = (if dis1 x then Nothing else Just (sel21 x));

status_of_aux ::
  forall a.
    (Eq a) => [((a, Nat), [Nat])] ->
                X_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option a;
status_of_aux xa =
  Abs_x_f_status_option_x_x_nat_list_nat_x_f_prod_fun_option
    (if all (\ fidx -> all (\ i -> less_nat i (snd (fst fidx))) (snd fidx)) xa
      then Just (fun_of_map_fun (map_of xa) (\ (_, a) -> upt Zero_nat a))
      else Nothing);

status_of :: forall a. (Eq a) => [((a, Nat), [Nat])] -> Maybe (Status a);
status_of x = rep_isom (status_of_aux x);

subst_apply_ctxt :: forall a b c. Ctxt a b -> (b -> Term a c) -> Ctxt a c;
subst_apply_ctxt Hole sigma = Hole;
subst_apply_ctxt (More f ss1 d ss2) sigma =
  More f (map (\ t -> subst_apply_term t sigma) ss1) (subst_apply_ctxt d sigma)
    (map (\ t -> subst_apply_term t sigma) ss2);

shows_ctxt ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Ctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_ctxt fun var Hole = shows_string "[]";
shows_ctxt fun var (More f ss1 d ss2) =
  fun f .
    shows_string "(" .
      shows_list_gen (shows_term fun var) [] [] ", " ", " ss1 .
        shows_ctxt fun var d .
          shows_list_gen (shows_term fun var) ")" ", " ", " ")" ss2;

ta_final :: forall a b c. Ta_ext a b c -> Set a;
ta_final (Ta_ext ta_final ta_rules ta_eps more) = ta_final;

r_states :: forall a b. (Ceq a, Ccompare a, Set_impl a) => Ta_rule a b -> Set a;
r_states = (\ ta_rule -> inserta (r_rhs ta_rule) (set (r_lhs_states ta_rule)));

ta_states ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Ta_ext a b () -> Set a;
ta_states ta =
  sup_set
    (sup_set (sup_seta (image r_states (ta_rules ta)))
      (sup_seta
        (image (\ (q, qa) -> inserta q (inserta qa bot_set)) (ta_eps ta))))
    (ta_final ta);

ta_syms ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b, Eq b,
      Set_impl b) => Ta_ext a b () -> Set (b, Nat);
ta_syms ta = image r_sym (ta_rules ta);

prod_ta ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Finite_UNIV c,
      Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Ta_ext c b () -> Set (a, c) -> Ta_ext (a, c) b ();
prod_ta tA1 tA2 f =
  Ta_ext f
    (image
      (\ (TA_rule fa qs1 q1, TA_rule _ qs2 q2) ->
        TA_rule fa (zip qs1 qs2) (q1, q2))
      (sup_seta
        (image
          (\ fa ->
            productc (filtera (\ r -> r_sym r == fa) (ta_rules tA1))
              (filtera (\ r -> r_sym r == fa) (ta_rules tA2)))
          (ta_syms tA1))))
    (sup_set
      (image (\ (a, b) -> let {
                            (q, qa) = a;
                          } in (\ p -> ((q, p), (qa, p)))
                            b)
        (productc (ta_eps tA1) (ta_states tA2)))
      (image (\ (p, (q, qa)) -> ((p, q), (p, qa)))
        (productc (ta_states tA1) (ta_eps tA2))))
    ();

productive_relation ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Ta_ext a b () -> Set (a, a);
productive_relation ta =
  sup_set (image (\ (a, b) -> (b, a)) (ta_eps ta))
    (sup_seta
      (image (\ r -> image (\ a -> (r_rhs r, a)) (set (r_lhs_states r)))
        (ta_rules ta)));

ta_productive ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Ta_ext a b () -> Set a;
ta_productive ta =
  sup_set (ta_final ta) (compute_trancl (ta_final ta) (productive_relation ta));

reduced_TA ::
  forall a b c.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b, Eq b,
      Set_impl b) => a -> Ta_ext b a c -> Set b -> Ta_ext b a ();
reduced_TA f ta q =
  Ta_ext bot_set
    (sup_set
      (image
        (\ (TA_rule fa qs a) ->
          TA_rule fa (filter (\ qa -> not (member qa q)) qs) a)
        (filtera (\ r -> not (member (r_rhs r) q)) (ta_rules ta)))
      (image (\ p -> TA_rule f [] (snd p))
        (filtera (\ p -> member (fst p) q && not (member (snd p) q))
          (ta_eps ta))))
    (filtera (\ p -> not (member (fst p) q) && not (member (snd p) q))
      (ta_eps ta))
    ();

new_reach ::
  forall a b c.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => Ta_ext a b c -> Set a;
new_reach ta =
  image r_rhs (filtera (\ r -> null (r_lhs_states r)) (ta_rules ta));

ta_reachable ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Default b, Eq b) => Ta_ext a b () -> Set a;
ta_reachable ta =
  let {
    q = new_reach ta;
  } in (if less_eq_set q bot_set then bot_set
         else sup_set q (ta_reachable (reduced_TA defaulta ta q)));

ta_restrict ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => Ta_ext a b c -> Set a -> Ta_ext a b ();
ta_restrict ta q =
  Ta_ext (inf_set (ta_final ta) q)
    (filtera (\ r -> less_eq_set (r_states r) q) (ta_rules ta))
    (inf_set (ta_eps ta) (productc q q)) ();

trim_ta ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Default b, Eq b) => Ta_ext a b () -> Ta_ext a b ();
trim_ta ta =
  ta_restrict (ta_restrict ta (ta_reachable ta))
    (ta_productive (ta_restrict ta (ta_reachable ta)));

check_subseteq :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_subseteq xs ys =
  catch_errora (forallM (\ x -> (if membera ys x then Inr () else Inl x)) xs)
    (\ x -> Inl (snd x));

check_varcond_subset ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_varcond_subset r =
  catch_errora
    (forallM
      (\ rule ->
        catch_errora
          (check_subseteq (insert_vars_term (snd rule) [])
            (insert_vars_term (fst rule) []))
          (\ x ->
            Inl ((((shows_prec_list Zero_nat "free variable " .
                     shows_prec Zero_nat x) .
                    shows_prec_list Zero_nat " in right-hand side of rule ") .
                   shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                     rule) .
                  shows_nl)))
      r)
    (\ x -> Inl (snd x));

check_wf_trs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_trs r =
  catch_errora
    (bindb
      (catch_errora
        (forallM
          (\ rule ->
            check (not (is_Var (fst rule)))
              ((shows_prec_list Zero_nat "variable left-hand side in rule " .
                 shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                   rule) .
                shows_nl))
          r)
        (\ x -> Inl (snd x)))
      (\ _ -> check_varcond_subset r))
    (\ x ->
      Inl ((shows_prec_list Zero_nat "the TRS is not well-formed" . shows_nl) .
            x));

defined_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
defined_list r =
  concatMap (\ (l, _) -> (if not (is_Var l) then [the (root l)] else [])) r;

generate_f_xs :: forall a. a -> Nat -> Term a [Prelude.Char];
generate_f_xs f n = Fun f (map (\ i -> Var (generate_var i)) (upt Zero_nat n));

rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Maybe ((a, Nat) -> Af_entry, Set (a, Nat));
rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
  (Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
    x)
  = x;

sel21a ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Afs a;
sel21a xa =
  Abs_afs
    (case rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
            xa
      of {
      Nothing -> rep_afs (error "undefined");
      Just x2 -> x2;
    });

dis1a ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Bool;
dis1a xa =
  (case rep_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
          xa
    of {
    Nothing -> True;
    Just _ -> False;
  });

rep_isoma ::
  forall a.
    (Key a) => X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                 a ->
                 Maybe (Afs a);
rep_isoma x = (if dis1a x then Nothing else Just (sel21a x));

default_af_entry :: Nat -> Af_entry;
default_af_entry n = AFList (upt Zero_nat n);

wf_af_entry :: Nat -> Af_entry -> Bool;
wf_af_entry n (Collapse i) = less_nat i n;
wf_af_entry n (AFList is) = all (\ i -> less_nat i n) is;

afs_of_aux ::
  forall a.
    (Ceq a, Ccompare a, Key a,
      Set_impl a) => [((a, Nat), Af_entry)] ->
                       X_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
                         a;
afs_of_aux xa =
  Abs_x_key_x_x_f_afs_option_x_x_nat_x_key_x_x_f_prod_set_af_entry_nat_x_key_x_x_f_prod_fun_prod_option
    (if all (\ ((_, n), e) -> wf_af_entry n e) xa
      then Just (fun_of_map_fun (ceta_map_of xa)
                   (\ fn -> default_af_entry (snd fn)),
                  set (map fst xa))
      else Nothing);

afs_of ::
  forall a.
    (Ceq a, Ccompare a, Key a,
      Set_impl a) => [((a, Nat), Af_entry)] -> Maybe (Afs a);
afs_of x = rep_isoma (afs_of_aux x);

closed_criterion :: Xml -> Sum_bot [Prelude.Char] (Ta_relation [Prelude.Char]);
closed_criterion =
  singleton "criterion"
    (options
      [("compatibility", leaf "compatibility" Id_Relation),
        ("stateCompatibility",
          singleton "stateCompatibility"
            (many "relation" (pair "entry" state state (\ a b -> (a, b))) id)
            Some_Relation),
        ("decisionProcedure", leaf "decisionProcedure" Decision_Proc)])
    id;

final_states :: Xml -> Sum_bot [Prelude.Char] [[Prelude.Char]];
final_states = many "finalStates" state id;

transitions ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]])) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ([Ta_rule [Prelude.Char] a], [([Prelude.Char], [Prelude.Char])]);
transitions xml2lhs =
  many "transitions" (transition xml2lhs)
    (\ rls ->
      let {
        (rules, eps) =
          partition (\ a -> (case a of {
                              Inl _ -> True;
                              Inr _ -> False;
                            }))
            rls;
        ruls = map (\ (Inl r) -> r) rules;
        a = map (\ (Inr e) -> e) eps;
      } in (ruls, a));

tree_automaton ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]])) ->
      Xml -> Sum_bot [Prelude.Char] (Tree_automaton [Prelude.Char] a);
tree_automaton xml2lhs =
  pair "treeAutomaton" final_states (transitions xml2lhs)
    (\ f (a, b) -> Tree_Automaton f a b);

ta_bounds_lhs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ((a, Nat), [[Prelude.Char]]);
ta_bounds_lhs xml2name =
  many2 "lhs" xml2name (nata "height") state (\ f h -> (\ a -> ((f, h), a)));

bounds_bound :: Xml -> Sum_bot [Prelude.Char] Nat;
bounds_bound = nata "bound";

bounds_type :: Xml -> Sum_bot [Prelude.Char] Boundstype;
bounds_type =
  singleton "type"
    (options [("roof", leaf "roof" Roof), ("match", leaf "match" Match)]) id;

bounds_info ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Bounds_info a [Prelude.Char]);
bounds_info xml2name =
  guard (\ x -> equal_nat (num_children x) (Nat_of_num (Bit0 (Bit0 One))))
    (tuple4 "bounds" bounds_type bounds_bound final_states
      (tree_automaton (ta_bounds_lhs xml2name))
      (\ a b c d -> Bounds_Info a b c d Id_Relation))
    (tuple5 "bounds" bounds_type bounds_bound final_states
      (tree_automaton (ta_bounds_lhs xml2name)) closed_criterion Bounds_Info);

word_pattern ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ([a], ((Nat, (Nat, [a])), [a]));
word_pattern xml2name =
  let {
    s = string xml2name;
  } in tuple5 "wordPattern" s s (nata "factor") (nata "constant") s
         (\ l m f c r -> (l, ((f, (c, m)), r)));

derivation_pattern ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])));
derivation_pattern xml2name =
  pair "derivationPattern" (word_pattern xml2name) (word_pattern xml2name)
    (\ a b -> (a, b));

derivation_pattern_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Dp_proof_step a);
derivation_pattern_proof xml2name =
  let {
    oc = oc_srs xml2name;
    dp = derivation_pattern xml2name;
    s = string xml2name;
  } in singleton "derivationPatternProof"
         (options
           [("OC1", pair "OC1" oc (bool "isPair") OC1),
             ("OC2", tuple6 "OC2" oc oc oc s s s OC2),
             ("OC2prime", tuple6 "OC2prime" oc oc oc s s s OC2p),
             ("OC3", tuple5 "OC3" oc oc oc s s OC3),
             ("OC3prime", tuple5 "OC3prime" oc oc oc s s OC3p),
             ("OCintoDP1", pair "OCintoDP1" dp oc OCDP1),
             ("OCintoDP2", pair "OCintoDP2" dp oc OCDP2),
             ("equivalent", pair "equivalent" dp dp WPEQ),
             ("lift", pair "lift" dp dp Lift),
             ("DP_OC_1_1", tuple5 "DP_OC_1_1" dp dp oc s s DPOC1_1),
             ("DP_OC_1_2", tuple6 "DP_OC_1_2" dp dp oc s s s DPOC1_2),
             ("DP_OC_2", tuple5 "DP_OC_2" dp dp oc s s DPOC2),
             ("DP_OC_3_1", tuple5 "DP_OC_3_1" dp dp oc s s DPOC3_1),
             ("DP_OC_3_2", tuple6 "DP_OC_3_2" dp dp oc s s s DPOC3_2),
             ("DP_DP_1_1", tuple5 "DP_DP_1_1" dp dp dp s s DPDP1_1),
             ("DP_DP_1_2", tuple5 "DP_DP_1_2" dp dp dp s s DPDP1_2),
             ("DP_DP_2_1", tuple5 "DP_DP_2_1" dp dp dp s s DPDP2_1),
             ("DP_DP_2_2", tuple5 "DP_DP_2_2" dp dp dp s s DPDP2_2)])
         id;

nonloop_srs_reason ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ([Dp_proof_step a] -> Non_loop_srs_proof a);
nonloop_srs_reason xml2name =
  let {
    s = string xml2name;
  } in options
         [("selfEmbeddingOC",
            triple "selfEmbeddingOC" s s s
              (\ l m r -> SE_OC (m, l ++ m ++ r) l r)),
           ("selfEmbeddingDP",
             triple "selfEmbeddingDP" (derivation_pattern xml2name) s s SE_DP)];

nonloop_srs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Non_loop_srs_proof a);
nonloop_srs xml2name =
  pair "nonterminatingSRS"
    (many "derivationPatterns" (derivation_pattern_proof xml2name) id)
    (nonloop_srs_reason xml2name) (\ list prf -> prf list);

nFQ_subset_NF_rulesb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
nFQ_subset_NF_rulesb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = nFQ_subset_NF_rules;

is_QNFb :: forall a b c d. Tp_ops_ext a b c d -> a -> Term b c -> Bool;
is_QNFb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = is_QNF;

rulesc :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulesc
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = rules;

icap_impl_tp ::
  forall a b.
    (Eq b) => Tp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_tp i d =
  let {
    qr = nFQ_subset_NF_rulesb i d;
    qnf = is_QNFb i d;
    r = rulesc i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s -> let {
                 a = ceta_set_of (concatMap vars_term_list s);
               } in ic s a);

label_decomp :: forall a b. Lab a b -> (Lab a b, Sum b [Lab a b]);
label_decomp (Lab f l) = (f, Inl l);
label_decomp (FunLab f l) = (f, Inr l);

is_partition_impl ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => [Set a] -> Maybe (Set a);
is_partition_impl [] = Just bot_set;
is_partition_impl (asa : rest) =
  bind (is_partition_impl rest)
    (\ alla ->
      (if is_empty (inf_set asa alla) then Just (sup_set alla asa)
        else Nothing));

is_partition ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a, Set_impl a) => [Set a] -> Bool;
is_partition asa = not (is_none (is_partition_impl asa));

sequences :: forall a b. (Linorder b) => (a -> b) -> [a] -> [[a]];
sequences key (a : b : xs) =
  (if less (key b) (key a) then desca key b [a] xs
    else asc key b (\ ba -> a : ba) xs);
sequences key [] = [[]];
sequences key [v] = [[v]];

asc ::
  forall a b. (Linorder b) => (a -> b) -> a -> ([a] -> [a]) -> [a] -> [[a]];
asc key a f (b : bs) =
  (if not (less (key b) (key a)) then asc key b (f . (\ ba -> a : ba)) bs
    else f [a] : sequences key (b : bs));
asc key a f [] = f [a] : sequences key [];

desca :: forall a b. (Linorder b) => (a -> b) -> a -> [a] -> [a] -> [[a]];
desca key a asa (b : bs) =
  (if less (key b) (key a) then desca key b (a : asa) bs
    else (a : asa) : sequences key (b : bs));
desca key a asa [] = (a : asa) : sequences key [];

mergea :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a] -> [a];
mergea key (a : asa) (b : bs) =
  (if less (key b) (key a) then b : mergea key (a : asa) bs
    else a : mergea key asa (b : bs));
mergea key [] bs = bs;
mergea key (v : va) [] = v : va;

merge_pairs :: forall a b. (Linorder b) => (a -> b) -> [[a]] -> [[a]];
merge_pairs key (a : b : xs) = mergea key a b : merge_pairs key xs;
merge_pairs key [] = [];
merge_pairs key [v] = [v];

merge_alla :: forall a b. (Linorder b) => (a -> b) -> [[a]] -> [a];
merge_alla key [] = [];
merge_alla key [x] = x;
merge_alla key (v : vb : vc) = merge_alla key (merge_pairs key (v : vb : vc));

sort_key :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a];
sort_key key = merge_alla key . sequences key;

remdups_sort :: forall a. (Eq a, Linorder a) => [a] -> [a];
remdups_sort xs = remdups_adj (sort_key (\ x -> x) xs);

swap :: forall a b. (a, b) -> (b, a);
swap p = (snd p, fst p);

set_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
set_ext s_ns =
  (\ asa bs ->
    (not (null asa) && all (\ b -> any (\ a -> fst (s_ns a b)) asa) bs,
      all (\ b -> any (\ a -> snd (s_ns a b)) asa) bs));

check_no_var ::
  forall a b.
    (Showa a, Showa b) => Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_var t =
  check (not (is_Var t)) (shows_string "variable found" . shows_nl);

check_supteq ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Term a b ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_supteq s t =
  check (equal_term s t || supt_impl s t)
    (shows_prec_term Zero_nat t .
      shows_string " is not a subterm of " . shows_prec_term Zero_nat s);

ta_empty ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Default b, Eq b) => Ta_ext a b () -> Bool;
ta_empty ta = less_eq_set (inf_set (ta_reachable ta) (ta_final ta)) bot_set;

ta_match ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b, Eq b,
      Ceq c,
      Ccompare c) => Ta_ext a b () ->
                       Set a -> Term b c -> Set a -> Set [(c, a)];
ta_match ta qsig (Fun f ts) q =
  let {
    n = size_list ts;
    rls = filtera
            (\ rule ->
              r_sym rule == (f, n) &&
                bex (sup_set (inserta (r_rhs rule) bot_set)
                      (compute_trancl (inserta (r_rhs rule) bot_set)
                        (ta_eps ta)))
                  (\ qa -> member qa q))
            (ta_rules ta);
  } in sup_seta
         (image
           (\ (TA_rule _ qs _) ->
             image concat
               (listset
                 (map (\ (tsi, qsi) ->
                        ta_match ta qsig tsi (inserta qsi bot_set))
                   (zip ts qs))))
           rls);
ta_match ta qsig (Var x) q =
  image (\ qa -> [(x, qa)])
    (filtera (\ qa -> member qa qsig)
      (sup_set q (compute_trancl q (converse (ta_eps ta)))));

compute_NF :: forall a. (a -> Maybe a) -> a -> Maybe a;
compute_NF f a =
  (case f a of {
    Nothing -> Just a;
    Just aa -> compute_NF f aa;
  });

first_rewrite ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
first_rewrite r s = (case rewrite r s of {
                      [] -> Nothing;
                      t : _ -> Just t;
                    });

compute_rstep_NF ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
compute_rstep_NF r s = compute_NF (first_rewrite r) s;

check_join_NF ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join_NF r s t =
  (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
    (Nothing, _) ->
      Inl (shows_prec_list Zero_nat "strange error in normal form computation");
    (Just _, Nothing) ->
      Inl (shows_prec_list Zero_nat "strange error in normal form computation");
    (Just sa, Just ta) ->
      check (equal_term sa ta)
        (shows_string "the normal form " .
          shows_prec_term Zero_nat sa .
            shows_prec_list Zero_nat " of " .
              shows_prec_term Zero_nat s .
                shows_prec_list Zero_nat " differs from " .
                  shows_nl .
                    shows_prec_list Zero_nat "the normal form " .
                      shows_prec_term Zero_nat ta .
                        shows_prec_list Zero_nat " of " .
                          shows_prec_term Zero_nat t);
  });

in_rstep_impl ::
  forall a b.
    (Compare a, Eq a, Ccompare b, Compare b, Eq b,
      Mapping_impl b) => Term a b ->
                           Term a b -> Set (Term a b, Term a b) -> Bool;
in_rstep_impl s t r =
  any (\ p ->
        in_poss p t &&
          equal_ctxt (ctxt_of_pos_term p s) (ctxt_of_pos_term p t) &&
            let {
              sp = subt_at s p;
              tp = subt_at t p;
            } in bex r (\ lr ->
                         not (is_none
                               (match_list Var [(fst lr, sp), (snd lr, tp)]))))
    (poss_list s);

reverse_rules :: forall a b. [(Term a b, Term a b)] -> [(Term a b, Term a b)];
reverse_rules rs = map swap rs;

wf_rules_impl ::
  forall a b. (Eq b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)];
wf_rules_impl r = filter wf_rule r;

check_pairwise :: forall a b. (a -> a -> Sum b ()) -> [a] -> Sum b ();
check_pairwise c [] = Inr ();
check_pairwise c (x : xs) =
  bindb (catch_errora (forallM (c x) xs) (\ xa -> Inl (snd xa)))
    (\ _ -> check_pairwise c xs);

check_disjoint :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_disjoint xs ys =
  catch_errora
    (forallM (\ x -> (if not (membera ys x) then Inr () else Inl x)) xs)
    (\ x -> Inl (snd x));

check_partition :: forall a. (Eq a) => [[a]] -> Sum a ();
check_partition xss = check_pairwise check_disjoint xss;

check_inj ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Lab a b ->
                    Nat ->
                      [((Lab a b, Nat), [Lab a b])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_inj a nn sml =
  let {
    symbols =
      map (\ (aa, b) ->
            let {
              (_, n) = aa;
            } in (\ fs ->
                   map (\ (g, i) ->
                         (g, plus_nat n
                               (times_nat i (minus_nat nn (Nat_of_num One)))))
                     (zip fs (upt Zero_nat (size_list fs))))
              b)
        sml;
    fsymbols = concat symbols;
  } in bindb (catch_errora (check_partition symbols)
               (\ x ->
                 Inl (shows_prec_list Zero_nat "symbol " .
                       shows_prec_prod Zero_nat x .
                         shows_prec_list Zero_nat " occurs twice)")))
         (\ _ ->
           bindb (check (not (membera fsymbols (a, nn)))
                   (shows_prec_list Zero_nat "application symbol" .
                     shows_prec_lab Zero_nat a .
                       shows_prec_list Zero_nat
                         " must not occur as new symbol"))
             (\ _ ->
               bindb (check (not (membera (map fst sml) (a, nn)))
                       (shows_prec_list Zero_nat "application symbol" .
                         shows_prec_lab Zero_nat a .
                           shows_prec_list Zero_nat " must not be uncurried"))
                 (\ _ ->
                   (if less_eq_nat nn (Nat_of_num One)
                     then catch_errora
                            (forallM
                              (check_pairwise
                                (\ gn1 gn2 ->
                                  check (not (gn1 == gn2))
                                    (shows_prec_list Zero_nat "symbol " .
                                      shows_prec_prod Zero_nat gn1 .
shows_prec_list Zero_nat " occurs twice")))
                              symbols)
                            (\ x -> Inl (snd x))
                     else Inr ()))));

not_ws_ns :: forall a b c. Redtriple_ext a b c -> Maybe [(a, Nat)];
not_ws_ns (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more)
  = not_ws_ns;

valid ::
  forall a b c.
    Redtriple_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
valid (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  valid;

desc :: forall a b c. Redtriple_ext a b c -> [Prelude.Char] -> [Prelude.Char];
desc (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  desc;

check_status_ws_info ::
  forall a.
    (Showa a) => Status a ->
                   ((Term a [Prelude.Char], Term a [Prelude.Char]) ->
                     Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                     Maybe [(a, Nat)] ->
                       Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_status_ws_info sigma cns Nothing =
  Inl (shows_prec_list Zero_nat
        "missing weak-subterm status of base reduction pair");
check_status_ws_info sigma cns (Just fs) =
  catch_errora
    (forallM
      (\ f ->
        catch_errora
          (forallM
            (\ i ->
              catch_errora
                (cns (Fun (fst f)
                        (map (\ ia -> Var (shows_prec_nat Zero_nat ia []))
                          (upt Zero_nat (snd f))),
                       Var (shows_prec_nat Zero_nat i [])))
                (\ _ ->
                  Inl (shows_prec_list Zero_nat
                         "according to weak-mon. information of order, argument #" .
                        shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) .
                          shows_prec_list Zero_nat
                            " must not occur in status of " .
                            shows_prec_prod Zero_nat f)))
            (status sigma f))
          (\ x -> Inl (snd x)))
      fs)
    (\ x -> Inl (snd x));

ns :: forall a b c.
        Redtriple_ext a b c ->
          (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
ns (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) = ns;

af :: forall a b c. Redtriple_ext a b c -> (a, Nat) -> Set Nat;
af (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) = af;

s :: forall a b c.
       Redtriple_ext a b c ->
         (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
s (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) = s;

shows_wpo_params ::
  forall a.
    (Showa a) => [((a, Nat), (Nat, [Nat]))] -> [Prelude.Char] -> [Prelude.Char];
shows_wpo_params params =
  shows_prec_list Zero_nat "status and precedence " .
    shows_nl .
      shows_sep
        (\ (f, (p, s)) ->
          shows_prec_list Zero_nat "symbol " .
            shows_prec_prod Zero_nat f .
              shows_prec_list Zero_nat ": precedence = " .
                shows_prec_nat Zero_nat p .
                  shows_prec_list Zero_nat "   status = " .
                    shows_prec_list Zero_nat s)
        shows_nl params;

faulty_redtriple ::
  forall a b.
    Itself a ->
      Itself b ->
        ([Prelude.Char] -> [Prelude.Char]) ->
          ([Prelude.Char] -> [Prelude.Char]) -> Redtriple_ext a b ();
faulty_redtriple uu uv err desc =
  Redtriple_ext (Inl err) (\ _ -> Inr ()) (\ _ -> Inr ()) (\ _ -> Inr ())
    full_af empty_af (\ _ -> Inr ()) desc Nothing
    (\ _ -> Inl (shows_prec_list Zero_nat "complexity analysis unsupported"))
    ();

prl_nat :: forall a. ((a, Nat) -> Nat) -> (a, Nat) -> Bool;
prl_nat pr = (\ f -> equal_nat (pr f) Zero_nat);

prc_nat :: forall a. ((a, Nat) -> Nat) -> (a, Nat) -> (a, Nat) -> (Bool, Bool);
prc_nat pr =
  (\ f g ->
    let {
      pf = pr f;
      pg = pr g;
    } in (less_nat pg pf, less_eq_nat pg pf));

wpo_redtriple ::
  forall a.
    (Eq a, Key a,
      Showa a) => Redtriple_ext a [Prelude.Char] () ->
                    [((a, Nat), (Nat, [Nat]))] ->
                      Redtriple_ext a [Prelude.Char] ();
wpo_redtriple rt params =
  let {
    stat = map (\ (f, ps) -> (f, snd ps)) params;
    pr = fun_of_map_funa (ceta_map_of params) (\ _ -> Zero_nat) fst;
    desca =
      shows_prec_list Zero_nat "WPO with " .
        shows_wpo_params params .
          shows_nl .
            shows_prec_list Zero_nat "over the following reduction pair:" .
              shows_nl . desc rt;
  } in (case status_of stat of {
         Nothing ->
           faulty_redtriple Type Type
             (shows_prec_list Zero_nat "problem with indices in status of WPO!")
             desca;
         Just sigma ->
           let {
             sa = (\ sa t -> isOK (s rt (sa, t)));
             nsa = (\ sb t -> isOK (ns rt (sb, t)));
             wpo = wpo_ub (prc_nat pr) (prl_nat pr) sa nsa sigma;
             wpo_s =
               (\ (sb, t) ->
                 check (fst (wpo sb t))
                   (shows_prec_term Zero_nat sb .
                     shows_prec_list Zero_nat " >wpo " .
                       shows_prec_term Zero_nat t .
                         shows_prec_list Zero_nat " could not be ensured"));
             wpo_ns =
               (\ (sb, t) ->
                 check (snd (wpo sb t))
                   (shows_prec_term Zero_nat sb .
                     shows_prec_list Zero_nat " >=wpo " .
                       shows_prec_term Zero_nat t .
                         shows_prec_list Zero_nat " could not be ensured"));
           } in Redtriple_ext
                  (bindb (valid rt)
                    (\ _ -> check_status_ws_info sigma (ns rt) (not_ws_ns rt)))
                  wpo_s wpo_ns wpo_ns (af_wpo (af rt) sigma) empty_af
                  (\ _ ->
                    catch_errora
                      (forallM
                        (\ (a, b) ->
                          let {
                            (f, n) = a;
                          } in (\ idx ->
                                 check (eq_set (set idx) (set (upt Zero_nat n)))
                                   (shows_prec_list Zero_nat
                                      "for monotonicity, status must be complete, but status of " .
                                     shows_prec_prod Zero_nat (f, n) .
                                       shows_prec_list Zero_nat " is " .
 shows_prec_list Zero_nat (map suc idx)))
                            b)
                        stat)
                      (\ x -> Inl (snd x)))
                  desca (Just (map fst stat))
                  (\ _ ->
                    Inl (shows_prec_list Zero_nat
                          "complexity analysis unsupported"))
                  ();
       });

apply_af_entry :: forall a b. a -> Af_entry -> [Term a b] -> Term a b;
apply_af_entry uu (Collapse i) ts = nth ts i;
apply_af_entry f (AFList is) ts = Fun f (map (nth ts) is);

afs_term :: forall a b. Afs a -> Term a b -> Term (Filtered a) b;
afs_term pi (Fun f ts) =
  let {
    l = size_list ts;
  } in apply_af_entry (FPair f l) (afsa pi (f, l)) (map (afs_term pi) ts);
afs_term pi (Var x) = Var x;

afs_rule ::
  forall a b.
    Afs a -> (Term a b, Term a b) -> (Term (Filtered a) b, Term (Filtered a) b);
afs_rule pi lr = (afs_term pi (fst lr), afs_term pi (snd lr));

af_rule :: forall a b. Afs a -> (Term a b, Term a b) -> (Term a b, Term a b);
af_rule pi = (\ t -> map_funs_rule filtered_fun (afs_rule pi t));

af_term :: forall a b. Afs a -> Term a b -> Term a b;
af_term pi t = map_term filtered_fun (\ x -> x) (afs_term pi t);

uncurry_info ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (a, ([((a, Nat), [a])],
                ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                  [(Term a [Prelude.Char], Term a [Prelude.Char])])));
uncurry_info xml2name =
  tuple4 "uncurryInformation" xml2name
    (many "uncurriedSymbols"
      (many2 "uncurriedSymbolEntry" xml2name (nata "arity") xml2name
        (\ f n -> (\ a -> ((f, n), a))))
      id)
    (singleton "uncurryRules" (rules xml2name) id)
    (singleton "etaRules" (rules xml2name) id)
    (\ a sml u e -> (a, (sml, (u, e))));

level_mapping ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), [(Nat, Nat)])];
level_mapping xml2name =
  many "levelMapping"
    (many2 "levelMappingEntry" xml2name (nata "arity")
      (pair "positionLevelEntry" (nata "position") (nata "level")
        (\ a b -> (a, b)))
      (\ f a ps ->
        ((f, a),
          map (\ (p, b) ->
                ((if equal_nat p Zero_nat then a
                   else minus_nat p (Nat_of_num One)),
                  b))
            ps)))
    id;

root_redtriple ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Root_redtriple_impl a);
root_redtriple xml2name =
  singleton "redPair"
    (triple "scnp"
      (singleton "status"
        (options
          [("ms", leaf "ms" MS_Ext), ("min", leaf "min" Min_Ext),
            ("dms", leaf "dms" Dms_Ext), ("max", leaf "max" Max_Ext)])
        id)
      (level_mapping xml2name) (redtriple False xml2name) SCNP)
    id;

root_ordering_constraint_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Root_redtriple_impl a);
root_ordering_constraint_proof xml2name =
  singleton "orderingConstraintProof" (root_redtriple xml2name) id;

ordering_constraint_proof ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
ordering_constraint_proof bi xml2name =
  singleton "orderingConstraintProof" (redtriple bi xml2name) id;

ordering_constraint_proofa ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml ->
          Sum_bot [Prelude.Char]
            (Sum (Root_redtriple_impl a) (Redtriple_impl a));
ordering_constraint_proofa bi xml2name =
  choice "reduction pair"
    [change (ordering_constraint_proof bi xml2name) Inr,
      change (root_ordering_constraint_proof xml2name) Inl];

create_proj :: forall a. (Key a) => ProjL a -> (a, Nat) -> Nat;
create_proj (Projection p) =
  let {
    i = ceta_map_of p;
  } in (\ f -> (case i f of {
                 Nothing -> Zero_nat;
                 Just n -> n;
               }));

xml2cond_constraint ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Cond_constraint a [Prelude.Char]);
xml2cond_constraint xml2name x =
  singleton "conditionalConstraint"
    (options
      [("all", pair "all" (text "var") (xml2cond_constraint xml2name) CC_all),
        ("implication",
          many1 "implication" (xml2cond_constraint xml2name)
            (xml2cond_constraint xml2name)
            (\ c cs ->
              let {
                ccs = c : cs;
              } in CC_impl (take (size_list cs) ccs) (last ccs))),
        ("constraint",
          triple "constraint" (term xml2name)
            (options
              [("rewrite", leaf "rewrite" Nothing),
                ("strict", leaf "strict" (Just True)),
                ("nonStrict", leaf "nonStrict" (Just False))])
            (term xml2name)
            (\ s rel t ->
              (case rel of {
                Nothing -> CC_rewr s t;
                Just stri -> CC_cond stri (s, t);
              })))])
    id x;

xml2cond_constraint_prf ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Cond_constraint_prf a [Prelude.Char]);
xml2cond_constraint_prf xml2name x =
  let {
    cc = xml2cond_constraint xml2name;
  } in singleton "conditionalConstraintProof"
         (options
           [("final", leaf "final" Final),
             ("differentConstructor",
               singleton "differentConstructor" cc Different_Constructor),
             ("sameConstructor",
               triple "sameConstructor" cc cc (xml2cond_constraint_prf xml2name)
                 Same_Constructor),
             ("variableEquation",
               tuple4 "variableEquation" (text "var") (term xml2name) cc
                 (xml2cond_constraint_prf xml2name) Variable_Equation),
             ("funargIntoVar",
               tuple5 "funargIntoVar" cc position (text "var") cc
                 (xml2cond_constraint_prf xml2name) Funarg_Into_Var),
             ("simplifyCondition",
               tuple4 "simplifyCondition" cc (substa xml2name) cc
                 (xml2cond_constraint_prf xml2name) Simplify_Condition),
             ("induction",
               triple "induction" cc (many "conjuncts" cc id)
                 (many "ruleConstraintProofs"
                   (tuple4 "ruleConstraintProof" (rule xml2name)
                     (many "subtermVarEntries"
                       (many1 "subtermVarEntry" (term xml2name) (text "var")
                         (\ a b -> (a, b)))
                       id)
                     cc (xml2cond_constraint_prf xml2name)
                     (\ lr rys cca p -> (lr, (rys, (cca, p)))))
                   id)
                 Induction),
             ("deleteCondition",
               pair "deleteCondition" cc (xml2cond_constraint_prf xml2name)
                 Delete_Condition)])
         id x;

xml2cond_red_pair_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Cond_red_pair_prf a [Prelude.Char]);
xml2cond_red_pair_proof xml2name =
  tuple4 "condRedPairProof" xml2name (nata "before") (nata "after")
    (many "conditions"
      (triple "condition" (xml2cond_constraint xml2name)
        (singleton "dpSequence" (rules xml2name) id)
        (xml2cond_constraint_prf xml2name) (\ c s p -> (c, (s, p))))
      id)
    (\ c b a ccs -> Cond_Red_Pair_Prf c ccs b a);

strategy_to_Q ::
  forall a b.
    (Eq a, Eq b) => Strategy a b -> [(Term a b, Term a b)] -> [Term a b];
strategy_to_Q No_Strategy uu = [];
strategy_to_Q Innermost r = remdups (map fst r);
strategy_to_Q (Innermost_Q q) uv = q;

o_to_fp_term :: forall a b. Term a b -> (Ctxt a b, (Term a b, Location));
o_to_fp_term t = (Hole, (t, Ba));

o_to_fp_impl :: forall a b. [Term a b] -> [(Ctxt a b, (Term a b, Location))];
o_to_fp_impl = map o_to_fp_term;

mu_to_fp_impl ::
  forall a.
    (Eq a) => [((a, Nat), [Nat])] ->
                [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
mu_to_fp_impl mu =
  let {
    fs = remdups (map fst mu);
    m = map_of mu;
    a = concatMap
          (\ f ->
            let {
              xs = map Var (fresh_strings_list "x" Zero_nat [] (snd f));
            } in map (\ i -> (f, (xs, i)))
                   (concatMap
                     (\ i -> (if not (membera (the (m f)) i) then [i] else []))
                     (upt Zero_nat (snd f))))
          fs;
  } in concatMap
         (\ ((f, _), (xs, i)) ->
           map (\ loc ->
                 (ctxt_of_pos_term (PCons i Empty) (Fun f xs), (nth xs i, loc)))
             [Ba, H])
         a;

strategy_to_fp ::
  forall a.
    (Eq a) => Fp_strategy a [Prelude.Char] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
strategy_to_fp (Forbidden_Patterns p) r = p;
strategy_to_fp Outermost r = o_to_fp_impl (map fst r);
strategy_to_fp (Context_Sensitive mu) r = mu_to_fp_impl mu;

default_nfs_trs :: Bool;
default_nfs_trs = False;

xml2inn_fp_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Sum (Bool,
                            ([Term (Lab a b) [Prelude.Char]],
                              ([(Term (Lab a b) [Prelude.Char],
                                  Term (Lab a b) [Prelude.Char])],
                                [(Term (Lab a b) [Prelude.Char],
                                   Term (Lab a b) [Prelude.Char])])))
                       ([(Ctxt (Lab a b) [Prelude.Char],
                           (Term (Lab a b) [Prelude.Char], Location))],
                         [(Term (Lab a b) [Prelude.Char],
                            Term (Lab a b) [Prelude.Char])]));
xml2inn_fp_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ -> errora "trs as input required";
        Inn_TRS_input (inn, (r, so)) ->
          returna
            (Inl (default_nfs_trs,
                   (strategy_to_Q inn r,
                     (r, (case so of {
                           Nothing -> [];
                           Just s -> s;
                         })))));
        COMP_input _ -> errora "trs as input required";
        EQ_input _ -> errora "trs as input required";
        CPX_input _ -> errora "trs as input required";
        FP_TRS_input (fp, r) -> returna (Inr (strategy_to_fp fp r, r));
        CTRS_input _ -> errora "trs as input required";
        Unknown_input _ -> errora "trs as input required";
      }));

default_nfs_nt_dp :: Bool;
default_nfs_nt_dp = False;

default_nfs_dp :: Bool;
default_nfs_dp = True;

xml2dp_inputa ::
  forall a b.
    (Eq a,
      Eq b) => Bool ->
                 (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                   Xml ->
                     Sum_bot [Prelude.Char]
                       (Bool,
                         (Bool,
                           ([(Term (Lab a b) [Prelude.Char],
                               Term (Lab a b) [Prelude.Char])],
                             ([(Term (Lab a b) [Prelude.Char],
                                 Term (Lab a b) [Prelude.Char])],
                               ([Term (Lab a b) [Prelude.Char]],
                                 ([(Term (Lab a b) [Prelude.Char],
                                     Term (Lab a b) [Prelude.Char])],
                                   [(Term (Lab a b) [Prelude.Char],
                                      Term (Lab a b) [Prelude.Char])]))))));
xml2dp_inputa termination xml2name =
  change (xml2dp_input xml2name)
    (\ (m, (p, (q, r))) ->
      ((if termination then default_nfs_dp else default_nfs_nt_dp),
        (m, (p, ([], (strategy_to_Q q r, ([], r)))))));

xml1many2elements_gen ::
  forall a b c d e.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (a -> [b] -> c -> d -> e) -> Xml -> Sum_bot [Prelude.Char] e;
xml1many2elements_gen tag p1 p2 p3 p4 f (XML name atts cs) =
  let {
    ds = reverse cs;
    l = size_list cs;
  } in (if name == tag && null atts && less_eq_nat (Nat_of_num (Bit1 One)) l
         then binda (p1 (nth cs Zero_nat))
                (\ x ->
                  binda (map_sum_bot (p2 x)
                          (tl (take (minus_nat l (Nat_of_num (Bit0 One))) cs)))
                    (\ xs ->
                      binda (p3 (nth ds (Nat_of_num One)))
                        (\ y ->
                          binda (p4 (nth ds Zero_nat))
                            (\ z -> returna (f x xs y z)))))
         else fail tag (XML name atts cs));
xml1many2elements_gen tag p1 p2 p3 p4 f (XML_text v) = fail tag (XML_text v);

projected_rseq ::
  forall a.
    (Eq a) => (Xml -> Sum_bot [Prelude.Char] a) ->
                ((a, Nat) -> Nat) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      ((Term a [Prelude.Char], Term a [Prelude.Char]),
                        [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                                 Term a [Prelude.Char]))]);
projected_rseq xml2name pi xml =
  let {
    tag = "projectedRewriteSequence";
  } in (case xml of {
         XML name atts cs ->
           (if name == tag &&
                 null atts && equal_nat (size_list cs) (Nat_of_num (Bit0 One))
             then binda (rule xml2name (nth cs Zero_nat))
                    (\ r -> rseq xml2name pi r (nth cs (Nat_of_num One)))
             else fail tag xml);
         XML_text _ -> fail tag xml;
       });

flat_contexts ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [Ctxt a [Prelude.Char]];
flat_contexts xml2name = many "flatContexts" (ctxt xml2name) id;

xml2fp_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     ([(Ctxt (Lab a b) [Prelude.Char],
                         (Term (Lab a b) [Prelude.Char], Location))],
                       [(Term (Lab a b) [Prelude.Char],
                          Term (Lab a b) [Prelude.Char])]);
xml2fp_trs_assm xml2name x =
  binda (xml2inn_fp_trs_assm xml2name x)
    (\ a ->
      (case a of {
        Inl _ -> errora "FP TRS expected at this point";
        Inr aa -> returna aa;
      }));

xml2inn_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Bool,
                       ([Term (Lab a b) [Prelude.Char]],
                         ([(Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char])],
                           [(Term (Lab a b) [Prelude.Char],
                              Term (Lab a b) [Prelude.Char])])));
xml2inn_trs_assm xml2name x =
  binda (xml2inn_fp_trs_assm xml2name x)
    (\ a ->
      (case a of {
        Inl aa -> returna aa;
        Inr _ -> errora "innermost (relative) TRS expected at this point";
      }));

xml2trs_termination_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Trs_termination_proof a b [Prelude.Char]);
xml2trs_termination_proof xml2name x =
  options
    [("trsTerminationProof",
       singleton "trsTerminationProof"
         (options
           [("rIsEmpty", leaf "rIsEmpty" R_is_Empty),
             ("semlab",
               guard (\ xa ->
                       equal_nat (num_children xa) (Nat_of_num (Bit1 One)))
                 (triple "semlab" (sl_variant xml2name)
                   (singleton "trs" (rules xml2name) id)
                   (xml2trs_termination_proof xml2name)
                   (\ sli -> Semlab sli []))
                 (tuple4 "semlab" (sl_variant xml2name)
                   (singleton "trs" (rules xml2name) id)
                   (innermostLhss xml2name) (xml2trs_termination_proof xml2name)
                   (\ sli lr lq -> Semlab sli lq lr))),
             ("split",
               triple "split" (singleton "trs" (rules xml2name) id)
                 (xml2trs_termination_proof xml2name)
                 (xml2trs_termination_proof xml2name) Split),
             ("dpTrans",
               triple "dpTrans" (singleton "dps" (rules xml2name) id)
                 (bool "markedSymbols") (xml2dp_termination_proof xml2name)
                 (\ dps _ -> DP_Trans default_nfs_dp True dps)),
             ("ruleRemoval",
               triple "ruleRemoval" (ordering_constraint_proof False xml2name)
                 (singleton "trs" (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) Rule_Removal),
             ("bounds", change (bounds_info xml2name) Bounds),
             ("stringReversal",
               pair "stringReversal" (singleton "trs" (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) (\ _ -> String_Reversal)),
             ("constantToUnary",
               tuple4 "constantToUnary" plain_var (renaming xml2name)
                 (singleton "trs" (rules xml2name) id)
                 (xml2trs_termination_proof xml2name)
                 (\ v ren s ->
                   Constant_String (Const_string_sound_proof v ren s []))),
             ("removeNonApplicableRules",
               pair "removeNonApplicableRules"
                 (singleton "trs" (rules xml2name) id)
                 (xml2trs_termination_proof xml2name)
                 Remove_Nonapplicable_Rules),
             ("uncurry",
               triple "uncurry" (uncurry_info xml2name)
                 (singleton "trs" (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) Uncurry),
             ("flatContextClosure",
               triple "flatContextClosure" (flat_contexts xml2name)
                 (singleton "trs" (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) Fcc),
             ("switchInnermost",
               pair "switchInnermost" (wcr_proof xml2name)
                 (xml2trs_termination_proof xml2name) Switch_Innermost),
             ("permutingArgumentFilter",
               pair "permutingArgumentFilter" (afs xml2name)
                 (xml2trs_termination_proof xml2name) Permuting_AFS),
             ("terminationAssumption",
               singleton "terminationAssumption" (xml2inn_trs_assm xml2name)
                 (\ qtrs -> Assume_SN qtrs [])),
             ("unknownProof",
               many2 "unknownProof" (text "description")
                 (xml2inn_trs_assm xml2name)
                 (\ xa ->
                   let {
                     cs = children xa;
                   } in (if not (equal_nat (size_list cs)
                                  (Nat_of_num (Bit0 One)))
                          then fail "subProof" xa
                          else let {
                                 inp = take (Nat_of_num (Bit0 One))
 (tag (nth cs (Nat_of_num One)));
                               } in (if inp == "tr" || inp == "re"
                                      then binda
     (xml2inn_fp_trs_assm xml2name (hd cs))
     (\ io_trs ->
       (case io_trs of {
         Inl qtrs ->
           change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
         Inr fptrs ->
           change (xml2fptrs_termination_proof xml2name)
             (SN_FP_assm_proof fptrs);
       })
         (nth cs (Nat_of_num One)))
                                      else (if inp == "dp"
     then pair "subProof" (xml2dp_inputa True xml2name)
            (xml2dp_termination_proof xml2name) Finite_assm_proof xa
     else (if inp == "un"
            then pair "subProof" xml2unknown_input (xml2unknown_proof xml2name)
                   Unknown_assm_proof xa
            else fail "subProof" xa)))))
                 (\ _ -> Assume_SN))])
         id),
      ("relativeTerminationProof",
        singleton "relativeTerminationProof"
          (options
            [("rIsEmpty", leaf "rIsEmpty" R_is_Empty),
              ("sIsEmpty",
                singleton "sIsEmpty" (xml2trs_termination_proof xml2name) id),
              ("ruleRemoval",
                tuple4 "ruleRemoval" (ordering_constraint_proof False xml2name)
                  (singleton "trs" (rules xml2name) id)
                  (singleton "trs" (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ rp one two -> Rule_Removal rp (one ++ two))),
              ("semlab",
                guard (\ xa ->
                        equal_nat (num_children xa)
                          (Nat_of_num (Bit0 (Bit0 One))))
                  (tuple4 "semlab" (sl_variant xml2name)
                    (singleton "trs" (rules xml2name) id)
                    (singleton "trs" (rules xml2name) id)
                    (xml2trs_termination_proof xml2name)
                    (\ sli lr lrw -> Semlab sli [] (lr ++ lrw)))
                  (tuple5 "semlab" (sl_variant xml2name)
                    (singleton "trs" (rules xml2name) id)
                    (singleton "trs" (rules xml2name) id)
                    (innermostLhss xml2name)
                    (xml2trs_termination_proof xml2name)
                    (\ sli lr lrw lq -> Semlab sli lq (lr ++ lrw)))),
              ("uncurry",
                tuple4 "uncurry" (uncurry_info xml2name)
                  (singleton "trs" (rules xml2name) id)
                  (singleton "trs" (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ i r s -> Uncurry i (r ++ s))),
              ("permutingArgumentFilter",
                pair "permutingArgumentFilter" (afs xml2name)
                  (xml2trs_termination_proof xml2name) Permuting_AFS),
              ("flatContextClosure",
                tuple4 "flatContextClosure" (flat_contexts xml2name)
                  (singleton "trs" (rules xml2name) id)
                  (singleton "trs" (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ fcc r s -> Fcc fcc (r ++ s))),
              ("stringReversal",
                triple "stringReversal" (singleton "trs" (rules xml2name) id)
                  (singleton "trs" (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ _ _ -> String_Reversal)),
              ("equalityRemoval",
                singleton "equalityRemoval" (xml2trs_termination_proof xml2name)
                  Drop_Equality),
              ("constantToUnary",
                tuple5 "constantToUnary" plain_var (renaming xml2name)
                  (singleton "trs" (rules xml2name) id)
                  (singleton "trs" (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ v ren s sw ->
                    Constant_String (Const_string_sound_proof v ren s sw))),
              ("relativeTerminationAssumption",
                singleton "relativeTerminationAssumption"
                  (xml1to2elements "trsInput"
                    (singleton "trs" (rules xml2name) id)
                    (singleton "relativeRules" (rules xml2name) id)
                    (\ r a ->
                      (case a of {
                        Nothing ->
                          Assume_SN (default_nfs_trs, ([], (r, []))) [];
                        Just rw ->
                          Assume_SN (default_nfs_trs, ([], (r, rw))) [];
                      })))
                  id),
              ("unknownProof",
                many2 "unknownProof" (text "description")
                  (xml2inn_trs_assm xml2name)
                  (\ xa ->
                    let {
                      cs = children xa;
                    } in (if not (equal_nat (size_list cs)
                                   (Nat_of_num (Bit0 One)))
                           then fail "subProof" xa
                           else let {
                                  inp = take (Nat_of_num (Bit0 One))
  (tag (nth cs (Nat_of_num One)));
                                } in (if inp == "tr" || inp == "re"
                                       then binda
      (xml2inn_fp_trs_assm xml2name (hd cs))
      (\ io_trs ->
        (case io_trs of {
          Inl qtrs ->
            change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
          Inr fptrs ->
            change (xml2fptrs_termination_proof xml2name)
              (SN_FP_assm_proof fptrs);
        })
          (nth cs (Nat_of_num One)))
                                       else (if inp == "dp"
      then pair "subProof" (xml2dp_inputa True xml2name)
             (xml2dp_termination_proof xml2name) Finite_assm_proof xa
      else (if inp == "un"
             then pair "subProof" xml2unknown_input (xml2unknown_proof xml2name)
                    Unknown_assm_proof xa
             else fail "subProof" xa)))))
                  (\ _ -> Assume_SN))])
          id)]
    x;

xml2fptrs_termination_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Fptrs_termination_proof a b [Prelude.Char]);
xml2fptrs_termination_proof xml2name x =
  singleton "trsTerminationProof"
    (options
      [("terminationAssumption",
         singleton "terminationAssumption" (xml2fp_trs_assm xml2name)
           (\ qtrs -> Assume_FP_SN qtrs [])),
        ("unknownProof",
          many2 "unknownProof" (text "description") (xml2fp_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail "subProof" xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == "tr" || inp == "re"
                                 then binda
(xml2inn_fp_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fptrs_termination_proof xml2name) (SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == "dp"
then pair "subProof" (xml2dp_inputa True xml2name)
       (xml2dp_termination_proof xml2name) Finite_assm_proof xa
else (if inp == "un"
       then pair "subProof" xml2unknown_input (xml2unknown_proof xml2name)
              Unknown_assm_proof xa
       else fail "subProof" xa)))))
            (\ _ -> Assume_FP_SN))])
    id x;

xml2dp_termination_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Dp_termination_proof a b [Prelude.Char]);
xml2dp_termination_proof xml2name x =
  singleton "dpProof"
    (options
      [("pIsEmpty", leaf "pIsEmpty" P_is_Empty),
        ("depGraphProc",
          many "depGraphProc"
            (xml2nd_choice "component" (singleton "dps" (rules xml2name) id)
              "realScc" (xml2dp_termination_proof xml2name)
              (\ dps prfOpt -> (prfOpt, dps)))
            Dep_Graph_Proc),
        ("redPairProc",
          triple "redPairProc" (ordering_constraint_proofa False xml2name)
            (singleton "dps" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Redpair_Proc),
        ("usableRulesProc",
          pair "usableRulesProc" (singleton "usableRules" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Usable_Rules_Proc),
        ("innermostLhssRemovalProc",
          pair "innermostLhssRemovalProc" (innermostLhss xml2name)
            (xml2dp_termination_proof xml2name) Q_Reduction_Proc),
        ("rewritingProc",
          guard (\ xa -> equal_nat (num_children xa) (Nat_of_num (Bit1 One)))
            (triple "rewritingProc" (rule xml2name) (rstep xml2name)
              (xml2dp_termination_proof xml2name)
              (\ (s, t) (p, (lr, ta)) ->
                Rewriting_Proc Nothing (s, t) (s, ta) (s, ta) lr p))
            (guard
              (\ xa ->
                equal_nat (num_children xa) (Nat_of_num (Bit0 (Bit0 One))))
              (guard
                (\ xa ->
                  tag (nth (children xa) (Nat_of_num (Bit0 One))) ==
                    "usableRules")
                (tuple4 "rewritingProc" (rule xml2name) (rstep xml2name)
                  (singleton "usableRules" (rules xml2name) id)
                  (xml2dp_termination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) u ->
                    Rewriting_Proc (Just u) (s, t) (s, ta) (s, ta) lr p))
                (tuple4 "rewritingProc" (rule xml2name) (rstep xml2name)
                  (rule xml2name) (xml2dp_termination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) st ->
                    Rewriting_Proc Nothing (s, t) (s, ta) st lr p)))
              (tuple5 "rewritingProc" (rule xml2name) (rstep xml2name)
                (rule xml2name) (singleton "usableRules" (rules xml2name) id)
                (xml2dp_termination_proof xml2name)
                (\ (s, t) (p, (lr, ta)) st u ->
                  Rewriting_Proc (Just u) (s, t) (s, ta) st lr p)))),
        ("narrowingProc",
          tuple4 "narrowingProc" (rule xml2name) pos
            (singleton "narrowings" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Narrowing_Proc),
        ("instantiationProc",
          triple "instantiationProc" (rule xml2name)
            (singleton "instantiations" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Instantiation_Proc),
        ("forwardInstantiationProc",
          xml3to4elements "forwardInstantiationProc" (rule xml2name)
            (singleton "instantiations" (rules xml2name) id)
            (singleton "usableRules" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Forward_Instantiation_Proc),
        ("semlabProc",
          guard (\ xa ->
                  equal_nat (num_children xa) (Nat_of_num (Bit0 (Bit0 One))))
            (tuple4 "semlabProc" (sl_variant xml2name)
              (singleton "dps" (rules xml2name) id)
              (singleton "trs" (rules xml2name) id)
              (xml2dp_termination_proof xml2name)
              (\ sli lp -> Semlab_Proc sli lp []))
            (tuple5 "semlabProc" (sl_variant xml2name)
              (singleton "dps" (rules xml2name) id)
              (singleton "trs" (rules xml2name) id) (innermostLhss xml2name)
              (xml2dp_termination_proof xml2name)
              (\ sli lp lr lq -> Semlab_Proc sli lp lq lr))),
        ("subtermProc",
          xml1many2elements_gen "subtermProc" (proj xml2name)
            (\ pi -> projected_rseq xml2name (create_proj pi))
            (singleton "dps" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Subterm_Criterion_Proc),
        ("redPairUrProc",
          tuple4 "redPairUrProc" (ordering_constraint_proofa False xml2name)
            (singleton "dps" (rules xml2name) id)
            (singleton "usableRules" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Redpair_UR_Proc),
        ("monoRedPairUrProc",
          tuple5 "monoRedPairUrProc" (ordering_constraint_proof False xml2name)
            (singleton "dps" (rules xml2name) id)
            (singleton "trs" (rules xml2name) id)
            (singleton "usableRules" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Mono_Redpair_UR_Proc),
        ("monoRedPairProc",
          tuple4 "monoRedPairProc" (ordering_constraint_proof False xml2name)
            (singleton "dps" (rules xml2name) id)
            (singleton "trs" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Mono_Redpair_Proc),
        ("innermostMonoRedPairProc",
          triple "innermostMonoRedPairProc"
            (ordering_constraint_proof False xml2name)
            (pair "deleted" (singleton "dps" (rules xml2name) id)
              (singleton "trs" (rules xml2name) id) (\ a b -> (a, b)))
            (xml2dp_termination_proof xml2name)
            (\ rp (a, b) -> Mono_URM_Redpair_Proc rp a b)),
        ("uncurryProc",
          guard (\ xa ->
                  equal_nat (num_children xa) (Nat_of_num (Bit0 (Bit0 One))))
            (tuple4 "uncurryProc" (uncurry_info xml2name)
              (singleton "dps" (rules xml2name) id)
              (singleton "trs" (rules xml2name) id)
              (xml2dp_termination_proof xml2name) (Uncurry_Proc Nothing))
            (tuple5 "uncurryProc" (nata "applicativeTop")
              (uncurry_info xml2name) (singleton "dps" (rules xml2name) id)
              (singleton "trs" (rules xml2name) id)
              (xml2dp_termination_proof xml2name)
              (\ n -> Uncurry_Proc (Just n)))),
        ("flatContextClosureProc",
          tuple5 "flatContextClosureProc" (singleton "freshSymbol" xml2name id)
            (flat_contexts xml2name) (singleton "dps" (rules xml2name) id)
            (singleton "trs" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Fcc_Proc),
        ("switchInnermostProc",
          pair "switchInnermostProc" (wcr_proof xml2name)
            (xml2dp_termination_proof xml2name) Switch_Innermost_Proc),
        ("splitProc",
          tuple4 "splitProc" (singleton "dps" (rules xml2name) id)
            (singleton "trs" (rules xml2name) id)
            (xml2dp_termination_proof xml2name)
            (xml2dp_termination_proof xml2name) Split_Proc),
        ("finitenessAssumption",
          singleton "finitenessAssumption" (xml2dp_inputa True xml2name)
            (\ dpp -> Assume_Finite dpp [])),
        ("unknownProof",
          many2 "unknownProof" (text "description")
            (xml2dp_inputa True xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail "subProof" xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == "tr" || inp == "re"
                                 then binda
(xml2inn_fp_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fptrs_termination_proof xml2name) (SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == "dp"
then pair "subProof" (xml2dp_inputa True xml2name)
       (xml2dp_termination_proof xml2name) Finite_assm_proof xa
else (if inp == "un"
       then pair "subProof" xml2unknown_input (xml2unknown_proof xml2name)
              Unknown_assm_proof xa
       else fail "subProof" xa)))))
            (\ _ -> Assume_Finite)),
        ("switchToTRS",
          singleton "switchToTRS" (xml2trs_termination_proof xml2name)
            To_Trs_Proc),
        ("unlabProc",
          triple "unlabProc" (singleton "dps" (rules xml2name) id)
            (singleton "trs" (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Unlab_Proc),
        ("generalRedPairProc",
          guard (\ xa ->
                  equal_nat (num_children xa) (Nat_of_num (Bit1 (Bit0 One))))
            (tuple5 "generalRedPairProc"
              (ordering_constraint_proof True xml2name)
              (singleton "strict" (rules xml2name) id)
              (singleton "bound" (rules xml2name) id)
              (xml2cond_red_pair_proof xml2name)
              (xml2dp_termination_proof xml2name)
              (\ rp s b c p -> General_Redpair_Proc rp s b c [p]))
            (tuple6 "generalRedPairProc"
              (ordering_constraint_proof True xml2name)
              (singleton "strict" (rules xml2name) id)
              (singleton "bound" (rules xml2name) id)
              (xml2cond_red_pair_proof xml2name)
              (xml2dp_termination_proof xml2name)
              (xml2dp_termination_proof xml2name)
              (\ rp s b c ps pb -> General_Redpair_Proc rp s b c [ps, pb]))),
        ("complexConstantRemovalProc",
          triple "complexConstantRemovalProc" (term xml2name)
            (many "ruleMap"
              (pair "ruleMapEntry" (rule xml2name) (rule xml2name)
                (\ a b -> (a, b)))
              id)
            (xml2dp_termination_proof xml2name)
            (\ t rls ->
              Complex_Constant_Removal_Proc
                (Complex_Constant_Removal_Proof t rls))),
        ("sizeChangeProc",
          many1 "sizeChangeProc"
            (options
              [("subtermCriterion", leaf "subtermCriterion" Nothing),
                ("reductionPair",
                  xml1to2elements "reductionPair"
                    (ordering_constraint_proof False xml2name)
                    (singleton "usableRules" (rules xml2name) id)
                    (\ redp ur -> Just (redp, ur)))])
            (scg xml2name)
            (\ a ->
              (case a of {
                Nothing -> Size_Change_Subterm_Proc;
                Just redp_ur ->
                  Size_Change_Redpair_Proc (fst redp_ur) (snd redp_ur);
              })))])
    id x;

xml2unknown_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char] (Unknown_proof a b [Prelude.Char]);
xml2unknown_proof xml2name x =
  singleton "unknownInputProof"
    (options
      [("unknownAssumption",
         singleton "unknownAssumption" xml2unknown_input
           (\ u -> Assume_Unknown u [])),
        ("unknownProof",
          many2 "unknownProof" (text "description") xml2unknown_input
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail "subProof" xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == "tr" || inp == "re"
                                 then binda
(xml2inn_fp_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fptrs_termination_proof xml2name) (SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == "dp"
then pair "subProof" (xml2dp_inputa True xml2name)
       (xml2dp_termination_proof xml2name) Finite_assm_proof xa
else (if inp == "un"
       then pair "subProof" xml2unknown_input (xml2unknown_proof xml2name)
              Unknown_assm_proof xa
       else fail "subProof" xa)))))
            (\ _ -> Assume_Unknown))])
    id x;

rule_labeling_function ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]), Nat)];
rule_labeling_function xml2name =
  many "ruleLabelingFunction"
    (pair "ruleLabelingFunctionEntry" (rule xml2name) (nata "label")
      (\ a b -> (a, b)))
    id;

xml2cr_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char] (Cr_proof a [Nat] [Prelude.Char]);
xml2cr_proof xml2name x =
  singleton "crProof"
    (options
      [("wcrAndSN",
         pair "wcrAndSN" (wcr_proof xml2name)
           (xml2trs_termination_proof xml2name) SN_WCR),
        ("orthogonal", leaf "orthogonal" Weakly_Orthogonal),
        ("stronglyClosed", change (nata "stronglyClosed") Strongly_Closed),
        ("ruleLabeling",
          pair "ruleLabeling" (rule_labeling_function xml2name)
            (joinable_critical_pairs xml2name)
            (\ rl js -> Rule_Labeling rl js Nothing)),
        ("decreasingDiagrams",
          guard (\ xa -> equal_nat (num_children xa) (Nat_of_num (Bit0 One)))
            (pair "decreasingDiagrams" (xml2trs_termination_proof xml2name)
              (pair "ruleLabeling" (rule_labeling_function xml2name)
                (joinable_critical_pairs xml2name) Rule_Labeling)
              (\ prf rljs -> rljs (Just prf)))
            (singleton "decreasingDiagrams"
              (pair "ruleLabeling" (rule_labeling_function xml2name)
                (joinable_critical_pairs xml2name)
                (\ rl js -> Rule_Labeling rl js Nothing))
              id)),
        ("redundantRules",
          xml3to4elements "redundantRules" (singleton "trs" (rules xml2name) id)
            (nata "nrSteps") (many "conversions" (conversion xml2name) id)
            (xml2cr_proof xml2name)
            (\ trs n convs prf ->
              (case convs of {
                Nothing -> Redundant_Rules trs n [] prf;
                Just cs -> Redundant_Rules trs n cs prf;
              })))])
    id x;

xml2eq_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Eq_proof a [Prelude.Char]);
xml2eq_proof xml2name x =
  options
    [("refl", singleton "refl" (term xml2name) Refl),
      ("sym", singleton "sym" (xml2eq_proof xml2name) Sym),
      ("trans",
        pair "trans" (xml2eq_proof xml2name) (xml2eq_proof xml2name) Trans),
      ("assm",
        pair "assm" (rule xml2name) (substa xml2name)
          (\ r s -> Assm r (mk_subst Var s))),
      ("cong", many1 "cong" xml2name (xml2eq_proof xml2name) Cong)]
    x;

xml_repl_map ::
  forall a b. (Showa a, Showa b) => ((Lab a [b], Nat), [Nat]) -> Xml;
xml_repl_map =
  (\ (a, b) ->
    let {
      (f, aa) = a;
    } in (\ l ->
           XML "replacementMapEntry" []
             (xml_lab f :
               XML "arity" [] [XML_text (shows_prec_nat Zero_nat aa [])] :
                 map xml_single_pos l))
      b);

xml_forbidden_pattern ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (Ctxt (Lab a [b]) c, (Term (Lab a [b]) c, Location)) -> Xml;
xml_forbidden_pattern =
  (\ (c, (t, l)) ->
    XML "forbiddenPattern" []
      [xml_term (ctxt_apply_term c t), xml_pos (hole_pos c),
        (case l of {
          H -> XML "here" [] [];
          A -> XML "above" [] [];
          Ba -> XML "below" [] [];
          Ra -> XML "right" [] [];
        })]);

xml_strategy ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => Sum (Strategy (Lab a [b]) c) (Fp_strategy (Lab a [b]) c) ->
                    [Xml];
xml_strategy (Inl No_Strategy) = [];
xml_strategy (Inl Innermost) = [XML "strategy" [] [XML "innermost" [] []]];
xml_strategy (Inr Outermost) = [XML "strategy" [] [XML "outermost" [] []]];
xml_strategy (Inr (Forbidden_Patterns p)) =
  [XML "strategy" []
     [XML "forbiddenPatterns" [] (map xml_forbidden_pattern p)]];
xml_strategy (Inr (Context_Sensitive mu)) =
  [XML "strategy" [] [XML "contextSensitive" [] (map xml_repl_map mu)]];
xml_strategy (Inl (Innermost_Q q)) =
  [XML "strategy" [] [XML "innermostLhss" [] (map xml_term q)]];

mk_cpx ::
  forall a b c d e.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    ([Term (Lab b c) [Prelude.Char]],
                      ([(Term (Lab b c) [Prelude.Char],
                          Term (Lab b c) [Prelude.Char])],
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          (d, e)))) ->
                      (a, (d, e));
mk_cpx i (q, (s, (w, (cm, cc)))) = (mkb i False q s w, (cm, cc));

mk_tp ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      (Bool, ([Term b c], ([(Term b c, Term b c)], [(Term b c, Term b c)]))) ->
        a;
mk_tp i (nfs, (q, (r, rw))) = mkb i nfs q r rw;

nFQ_subset_NF_rulesc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
nFQ_subset_NF_rulesc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = nFQ_subset_NF_rules;

is_QNFc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Term b c -> Bool;
is_QNFc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = is_QNF;

rulesd :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulesd
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules;

icap_impl_dpp ::
  forall a b.
    (Eq b) => Dpp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_dpp i d =
  let {
    qr = nFQ_subset_NF_rulesc i d;
    qnf = is_QNFc i d;
    r = rulesd i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s -> let {
                 a = ceta_set_of (concatMap vars_term_list s);
               } in ic s a);

shows_kbo_repr ::
  forall a.
    (Showa a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                   [Prelude.Char] -> [Prelude.Char];
shows_kbo_repr (prs, w0) =
  ((((((((((((((((((((shows_prec_list Zero_nat
                        "KBO with the following precedence and weight function" .
                       shows_nl) .
                      foldr (\ (a, b) ->
                              let {
                                (f, n) = a;
                              } in (\ (pr, (_, _)) ->
                                     (((((shows_prec_list Zero_nat
    "precedence(" .
   shows_prec Zero_nat f) .
  shows_prec_list Zero_nat "[") .
 shows_prec_nat Zero_nat n) .
shows_prec_list Zero_nat "]) = ") .
                                       shows_prec_nat Zero_nat pr) .
                                       shows_nl)
                                b)
                        prs) .
                     shows_nl) .
                    shows_prec_list Zero_nat "precedence(_) = 0") .
                   shows_nl) .
                  shows_prec_list Zero_nat "and the following weight") .
                 shows_nl) .
                foldr (\ (a, b) ->
                        let {
                          (f, n) = a;
                        } in (\ (_, (w, _)) ->
                               (((((shows_prec_list Zero_nat "weight(" .
                                     shows_prec Zero_nat f) .
                                    shows_prec_list Zero_nat "[") .
                                   shows_prec_nat Zero_nat n) .
                                  shows_prec_list Zero_nat "]) = ") .
                                 shows_prec_nat Zero_nat w) .
                                 shows_nl)
                          b)
                  prs) .
               shows_nl) .
              shows_prec_list Zero_nat "weight(_) = ") .
             shows_prec_nat Zero_nat (plus_nat w0 (Nat_of_num One))) .
            shows_nl) .
           shows_prec_list Zero_nat "w0 = ") .
          shows_prec_nat Zero_nat w0) .
         shows_nl) .
        shows_prec_list Zero_nat
          "and the following subterm coefficient functions") .
       shows_nl) .
      foldr (\ (a, b) ->
              let {
                (f, n) = a;
              } in (\ (_, (_, scf)) ->
                     (((((shows_prec_list Zero_nat "scf(" .
                           shows_prec Zero_nat f) .
                          shows_prec_list Zero_nat "[") .
                         shows_prec_nat Zero_nat n) .
                        shows_prec_list Zero_nat "]) = ") .
                       (if is_none scf then shows_prec_list Zero_nat "all 1"
                         else shows_prec_list Zero_nat (the scf))) .
                       shows_nl)
                b)
        prs) .
     shows_nl) .
    shows_prec_list Zero_nat "scf(_) = all 1") .
    shows_nl;

roots_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
roots_of_cm (Derivational_Complexity f) = f;
roots_of_cm (Runtime_Complexity c d) = d;

sym_collect :: forall a b. (Term a b -> Bool) -> Term a b -> [a];
sym_collect p (Var x) = [];
sym_collect p (Fun f ts) =
  (if p (Fun f ts) then [f] else []) ++ concatMap (sym_collect p) ts;

pat_of ::
  forall a.
    Dp_proof_step a ->
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])));
pat_of (OC1 rl uu) =
  (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
    ([], ((Zero_nat, (Zero_nat, [])), snd rl)));
pat_of (OC2 rl uv uw ux uy uz) =
  (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
    ([], ((Zero_nat, (Zero_nat, [])), snd rl)));
pat_of (OC2p rl va vb vc vd ve) =
  (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
    ([], ((Zero_nat, (Zero_nat, [])), snd rl)));
pat_of (OC3 rl vf vg vh vi) =
  (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
    ([], ((Zero_nat, (Zero_nat, [])), snd rl)));
pat_of (OC3p rl vj vk vl vm) =
  (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
    ([], ((Zero_nat, (Zero_nat, [])), snd rl)));
pat_of (OCDP1 p vn) = p;
pat_of (OCDP2 p vo) = p;
pat_of (WPEQ p vp) = p;
pat_of (Lift p vq) = p;
pat_of (DPOC1_1 p vr vs vt vu) = p;
pat_of (DPOC1_2 p vv vw vx vy vz) = p;
pat_of (DPOC2 p wa wb wc wd) = p;
pat_of (DPOC3_1 p we wf wg wh) = p;
pat_of (DPOC3_2 p wi wj wk wl wm) = p;
pat_of (DPDP1_1 p wn wo wp wq) = p;
pat_of (DPDP1_2 p wr ws wt wu) = p;
pat_of (DPDP2_1 p wv ww wx wy) = p;
pat_of (DPDP2_2 p wz xa xb xc) = p;

mk_rtrancl_list_main ::
  forall a. (a -> a -> Bool) -> (a -> [a]) -> [a] -> [a] -> [a];
mk_rtrancl_list_main subsumes r todo fin =
  (case todo of {
    [] -> fin;
    a : tod ->
      (if any (\ b -> subsumes b a) fin
        then mk_rtrancl_list_main subsumes r tod fin
        else mk_rtrancl_list_main subsumes r (r a ++ tod) (a : fin));
  });

mk_rtrancl_list :: forall a. (a -> a -> Bool) -> (a -> [a]) -> [a] -> [a];
mk_rtrancl_list subsumes r init = mk_rtrancl_list_main subsumes r init [];

ins_dj_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
ins_dj_rm_basic_ops x s = insert x () s;

mk_rtrancl_set_main ::
  forall a. (Compare_order a) => (a -> [a]) -> [a] -> Rbt a () -> Rbt a ();
mk_rtrancl_set_main r todo fin =
  (case todo of {
    [] -> fin;
    a : tod ->
      (if memb_rm_basic_ops a fin then mk_rtrancl_set_main r tod fin
        else mk_rtrancl_set_main r (r a ++ tod) (ins_dj_rm_basic_ops a fin));
  });

mk_rtrancl_set :: forall a. (Compare_order a) => (a -> [a]) -> [a] -> Rbt a ();
mk_rtrancl_set r init = mk_rtrancl_set_main r init (empty_rm_basic_ops ());

subst_compose_impl ::
  forall a b.
    (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> [(a, Term b a)];
subst_compose_impl sigma tau =
  let {
    sigmaa = mk_subst_domain sigma;
    taua = mk_subst_domain tau;
    d_sigma = map fst sigmaa;
  } in map (\ (x, t) -> (x, subst_apply_term t (mk_subst Var taua))) sigmaa ++
         filter (\ (x, _) -> not (membera d_sigma x)) taua;

commutes_impl ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> Bool;
commutes_impl sigma mu =
  subst_eq (subst_compose_impl sigma mu) (subst_compose_impl mu sigma);

mk_subst_case ::
  forall a b.
    (Eq a,
      Eq b) => [a] -> (a -> Term b a) -> [(a, Term b a)] -> [(a, Term b a)];
mk_subst_case xs sigma tau =
  subst_compose_impl (map (\ x -> (x, sigma x)) xs) tau;

ta_matcha ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b, Eq b,
      Ceq c, Ccompare c) => Ta_ext a b () -> Set a -> Term b c -> Set [(c, a)];
ta_matcha ta q t = ta_match ta q t q;

adapt_vars :: forall a b c. Term a b -> Term a c;
adapt_vars (Fun f ts) = Fun f (map adapt_vars ts);

ta_member ::
  forall a b c.
    (Compare a, Eq a, Cenum c, Ceq c, Ccompare c, Compare c, Eq c,
      Set_impl c) => Term a b -> Ta_ext c a () -> Bool;
ta_member t ta =
  ground t &&
    not (less_eq_set (inf_set (ta_final ta) (ta_res ta (adapt_vars t)))
          bot_set);

add_funas_args_term :: forall a b. Term a b -> [(a, Nat)] -> [(a, Nat)];
add_funas_args_term t fs = foldr add_funas_term (args t) fs;

add_funas_args_rule ::
  forall a b. (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
add_funas_args_rule r fs =
  add_funas_args_term (fst r) (add_funas_args_term (snd r) fs);

funas_args_trs_list :: forall a b. [(Term a b, Term a b)] -> [(a, Nat)];
funas_args_trs_list trs = foldr add_funas_args_rule trs [];

rwb :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
      rules_map delete_R_Rw split_rules mk nfs more)
  = rw;

rb :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
     delete_R_Rw split_rules mk nfs more)
  = r;

uncurry_of_sig_list ::
  forall a.
    a -> [((a, Nat), [a])] ->
           (a -> Nat -> [a]) ->
             [(Term a [Prelude.Char], Term a [Prelude.Char])];
uncurry_of_sig_list a sml sm =
  concatMap
    (\ (b, c) ->
      let {
        (f, n) = b;
      } in (\ _ ->
             let {
               g = get_symbol sm f n;
             } in map (\ i ->
                        (Fun a [generate_f_xs (g i) (plus_nat n i),
                                 Var (generate_var (plus_nat n i))],
                          generate_f_xs (g (plus_nat i (Nat_of_num One)))
                            (plus_nat n (plus_nat i (Nat_of_num One)))))
                    (upt Zero_nat (aarity sm f n)))
        c)
    sml;

sig_list_to_sig_map ::
  forall a.
    (Eq a) => a -> [((a, Nat), [a])] ->
                     ([((a, Nat), [a])] -> a -> Nat -> a) -> a -> Nat -> [a];
sig_list_to_sig_map a sml fmap =
  let {
    fm = fmap sml;
  } in (\ f n ->
         (case map_of sml (f, n) of {
           Nothing -> [fm f n];
           Just xs -> (if null xs then [fm f n] else xs);
         }));

uncurry_eta_split ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             ([(Term a b, Term a b)], [(Term a b, Term a b)]);
uncurry_eta_split eboth rtest =
  let {
    test =
      (\ (l, r) ->
        less_nat Zero_nat (size_list (args l)) &&
          less_nat Zero_nat (size_list (args r)) &&
            any (eq_rule_mod_vars (hd (args l), hd (args r))) rtest);
  } in partition test eboth;

insert_vars_rule :: forall a b. (Eq b) => (Term a b, Term a b) -> [b] -> [b];
insert_vars_rule r xs = insert_vars_term (fst r) (insert_vars_term (snd r) xs);

eta_closed_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => a -> (a -> Nat -> [a]) ->
                         [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
eta_closed_rules a sm ra r =
  catch_errora
    (forallM
      (\ (l, raa) ->
        (case aarity_term a sm l of {
          Nothing -> Inr ();
          Just ab ->
            (if equal_nat ab Zero_nat then Inr ()
              else check (any (\ (lll, rrr) ->
                                (case (lll, rrr) of {
                                  (Var _, _) -> False;
                                  (Fun _ [], _) -> False;
                                  (Fun _ [_], _) -> False;
                                  (Fun _ [_, Var _], Var _) -> False;
                                  (Fun _ [_, Var _], Fun _ []) -> False;
                                  (Fun _ [_, Var _], Fun _ [_]) -> False;
                                  (Fun f [ll, Var x], Fun g [rr, Var y]) ->
                                    f == a &&
                                      g == a &&
x == y &&
  not (membera (insert_vars_rule (ll, rr) []) x) &&
    instance_rule (l, raa) (ll, rr);
                                  (Fun _ [_, Var _], Fun _ (_ : Var _ : _ : _))
                                    -> False;
                                  (Fun _ [_, Var _], Fun _ (_ : Fun _ _ : _)) ->
                                    False;
                                  (Fun _ (_ : Var _ : _ : _), _) -> False;
                                  (Fun _ (_ : Fun _ _ : _), _) -> False;
                                }))
                           r)
                     ((shows_prec_list Zero_nat "eta expansion of " .
                        shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                          " -> " (l, raa)) .
                       shows_prec_list Zero_nat " missing"));
        }))
      ra)
    (\ x -> Inl (snd x));

uncurry_rules ::
  forall a b.
    (Eq a) => a -> (a -> Nat -> [a]) ->
                     [(Term a b, Term a b)] -> [(Term a b, Term a b)];
uncurry_rules a sm =
  map (\ (l, r) -> (uncurry_term a sm l, uncurry_term a sm r));

check_CS_subseteq ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Sum (Term a b, Term a b) ();
check_CS_subseteq r s =
  catch_errora
    (forallM (\ (l, ra) -> check (any (instance_rule (l, ra)) s) (l, ra)) r)
    (\ x -> Inl (snd x));

uncurry_tt ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_tt i info r tp =
  let {
    (a, (sml, (u, eb))) = info;
    ra = rb i tp;
    rw = rwb i tp;
    (e, ew) = uncurry_eta_split eb ra;
    r_eta = e ++ ra;
    rw_eta = ew ++ rw;
    rb_eta = r_eta ++ rw_eta;
    fmap = (\ _ f _ -> f);
    sm = sig_list_to_sig_map a sml fmap;
    uR = uncurry_rules a sm r_eta;
    uRw = uncurry_rules a sm rw_eta;
  } in (case let {
               s = uncurry_of_sig_list a sml sm;
             } in bindb (catch_errora
                          (forallM
                            (\ (l, _) ->
                              check (hvf_term a l)
                                (shows_prec_list Zero_nat
                                   "head variable in lhs " .
                                  shows_term (shows_prec Zero_nat)
                                    (shows_prec_list Zero_nat) l .
                                    shows_prec_list Zero_nat " not allowed"))
                            r_eta)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (catch_errora
                              (forallM
                                (\ (l, _) ->
                                  check (hvf_term a l)
                                    (shows_prec_list Zero_nat
                                       "head variable in lhs " .
                                      shows_term (shows_prec Zero_nat)
(shows_prec_list Zero_nat) l .
shows_prec_list Zero_nat " not allowed"))
                                rw_eta)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          bindb (eta_closed_rules a sm r_eta r_eta)
                            (\ _ ->
                              bindb (eta_closed_rules a sm rb_eta rb_eta)
                                (\ _ ->
                                  bindb (catch_errora
  (forallM
    (\ (l, rc) ->
      check (not (is_Var l))
        (shows_prec_list Zero_nat "lhs must not be a variable in rule " .
          shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> "
            (l, rc)))
    rw_eta)
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora (check_subseteq uR r)
  (\ x ->
    Inl (shows_prec_list Zero_nat "uncurried rule " .
          shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " x .
            shows_prec_list Zero_nat " is missing")))
(\ _ ->
  bindb (catch_errora (check_subseteq uRw r)
          (\ x ->
            Inl (shows_prec_list Zero_nat "uncurried rule " .
                  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                    " -> " x .
                    shows_prec_list Zero_nat " is missing")))
    (\ _ ->
      bindb (catch_errora (check_CS_subseteq s u)
              (\ x ->
                Inl (shows_prec_list Zero_nat "uncurry rule " .
                      shows_rule (shows_prec Zero_nat)
                        (shows_prec_list Zero_nat) " -> " x .
                        shows_prec_list Zero_nat " is missing")))
        (\ _ ->
          catch_errora (check_subseteq u r)
            (\ x ->
              Inl (shows_prec_list Zero_nat "uncurry rule " .
                    shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                      " -> " x .
                      shows_prec_list Zero_nat
                        " is missing in new TRS"))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkb i (nfsb i tp) [] uR (uRw ++ u));
       });

shows_crule ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        ((Term a b, Term a b), [(Term a b, Term a b)]) ->
          [Prelude.Char] -> [Prelude.Char];
shows_crule fun var cr =
  shows_rule fun var " -> " (fst cr) .
    shows_list_gen (shows_rule fun var " ->* ") [] " | " ", " [] (snd cr);

check_prefix_equivalent ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prefix_equivalent rhoa rho n =
  catch_errora
    (bindb
      (check (less_nat n (size_list (snd rhoa)))
        (shows_string "There are fewer than " .
          shows_prec_nat Zero_nat n .
            shows_string " conditions in " .
              shows_crule (shows_prec Zero_nat) (shows_prec Zero_nat) rhoa))
      (\ _ ->
        bindb (check (less_nat n (size_list (snd rho)))
                (shows_string "There are fewer than " .
                  shows_prec_nat Zero_nat n .
                    shows_string " conditions in " .
                      shows_crule (shows_prec Zero_nat) (shows_prec Zero_nat)
                        rho))
          (\ _ ->
            bindb (check (equal_term (fst (fst rhoa)) (fst (fst rho)))
                    (shows_prec_list Zero_nat "Left-hand sides are different."))
              (\ _ ->
                bindb (catch_errora
                        (forallM
                          (\ i ->
                            check (equal_term (snd (nth (snd rhoa) i))
                                    (snd (nth (snd rho) i)))
                              (shows_string "Rhs of conditions are different " .
                                shows_nl))
                          (upt Zero_nat n))
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    catch_errora
                      (forallM
                        (\ i ->
                          check (equal_term (fst (nth (snd rhoa) i))
                                  (fst (nth (snd rho) i)))
                            (shows_string "Lhs of conditions are different " .
                              shows_nl))
                        (upt Zero_nat (plus_nat n (Nat_of_num One))))
                      (\ x -> Inl (snd x)))))))
    (\ x ->
      Inl (shows_string "Rules" .
            shows_crule (shows_prec Zero_nat) (shows_prec Zero_nat) rhoa .
              shows_string " and " .
                shows_crule (shows_prec Zero_nat) (shows_prec Zero_nat) rho .
                  shows_string " are not " .
                    shows_prec_nat Zero_nat n .
                      shows_string " equivalent." . shows_nl . x));

check_f ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    Nat ->
                      a -> [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                             (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                               Nat -> Ctxt a b) ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_f cr j f crs u =
  catch_errora
    (forallM
      (\ cra ->
        catch_errora
          (forallM
            (\ i ->
              (case u cra i of {
                Hole -> Inr ();
                More g _ _ _ ->
                  (if f == g
                    then catch_errora
                           (bindb
                             (check (equal_nat i j)
                               (shows_string
                                  "Same symbol occurs at different levels" .
                                 shows_nl))
                             (\ _ ->
                               bindb (catch_errora
                                       (forallM
 (\ k ->
   check (equal_ctxt (u cra k) (u cr k))
     (shows_string "Contexts are different " . shows_nl))
 (upt Zero_nat (plus_nat j (Nat_of_num One))))
                                       (\ x -> Inl (snd x)))
                                 (\ _ -> check_prefix_equivalent cra cr j)))
                           (\ x ->
                             Inl (shows_string "Rules" .
                                   shows_crule (shows_prec Zero_nat)
                                     (shows_prec Zero_nat) cra .
                                     shows_string " and " .
                                       shows_crule (shows_prec Zero_nat)
 (shows_prec Zero_nat) cr .
 shows_string " share a symbol." . shows_nl . x))
                    else Inr ());
              }))
            (upt Zero_nat (size_list (snd cra))))
          (\ x -> Inl (snd x)))
      crs)
    (\ x -> Inl (snd x));

af_rules ::
  forall a b. Afs a -> [(Term a b, Term a b)] -> [(Term a b, Term a b)];
af_rules pi r = map (af_rule pi) r;

afs_syms :: forall a. Afs a -> Set (a, Nat);
afs_syms xa = snd (rep_afs xa);

mono_af_entry :: Nat -> Af_entry -> Bool;
mono_af_entry n (Collapse i) = less_eq_nat n (Nat_of_num One);
mono_af_entry n (AFList ids) = all_interval_nat (membera ids) Zero_nat n;

mono_afs :: forall a. (Ceq a, Ccompare a) => Afs a -> Bool;
mono_afs pi = ball (afs_syms pi) (\ (f, n) -> mono_af_entry n (afsa pi (f, n)));

ta_normal_lhs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]]);
ta_normal_lhs xml2name = many1 "lhs" xml2name state (\ a b -> (a, b));

compatible_ta ::
  forall a.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml ->
          Sum_bot [Prelude.Char]
            (Tree_automaton [Prelude.Char] a, Ta_relation [Prelude.Char]);
compatible_ta tag xml2name =
  guard (\ x -> equal_nat (num_children x) (Nat_of_num One))
    (singleton tag (tree_automaton (ta_normal_lhs xml2name))
      (\ ta -> (ta, Id_Relation)))
    (pair tag (tree_automaton (ta_normal_lhs xml2name)) closed_criterion
      (\ a b -> (a, b)));

doc_of_stringa :: [Prelude.Char] -> Sum [Prelude.Char] Xmldoc;
doc_of_stringa = debug "0" "parsing txt to xml" doc_of_string;

default_grd_fun ::
  forall a.
    Term (Lab [Prelude.Char] a) [Prelude.Char] ->
      Term (Lab [Prelude.Char] a) [Prelude.Char] ->
        [Prelude.Char] -> Term (Lab [Prelude.Char] a) [Prelude.Char];
default_grd_fun s t =
  let {
    f = funs_rule_list (s, t);
    m = fold (\ fa m ->
               (case fa of {
                 Lab _ _ -> m;
                 FunLab _ _ -> m;
                 UnLab _ -> m;
                 Sharp (Lab _ _) -> m;
                 Sharp (FunLab _ _) -> m;
                 Sharp (UnLab g) -> max (size_list g) m;
                 Sharp (Sharp _) -> m;
               }))
          f Zero_nat;
    suffix = replicate (plus_nat m (Nat_of_num One)) 'a';
  } in (\ x -> Fun (Sharp (UnLab (x ++ suffix))) []);

xml2non_join_info ::
  (Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat])) ->
    Xml ->
      Sum_bot [Prelude.Char]
        (Non_join_info (Lab [Prelude.Char] [Nat]) [Prelude.Char]
          [Prelude.Char]);
xml2non_join_info xml2name x =
  options
    [("distinctNormalForms", leaf "distinctNormalForms" Diff_NFs),
      ("capNotUnif", leaf "capNotUnif" (Tcap_Non_Unif default_grd_fun)),
      ("subterm", pair "subterm" pos (xml2non_join_info xml2name) Subterm_NJ),
      ("grounding",
        pair "grounding" (substa xml2name) (xml2non_join_info xml2name)
          Grounding),
      ("emptyTreeAutomataIntersection",
        pair "emptyTreeAutomataIntersection"
          (compatible_ta "firstAutomaton" xml2name)
          (compatible_ta "secondAutomaton" xml2name)
          (\ (ta1, rel1) (a, b) -> Tree_Aut_Intersect_Empty ta1 rel1 a b)),
      ("differentInterpretation",
        singleton "differentInterpretation" (sl_variant xml2name)
          Finite_Model_Gt),
      ("strictDecrease",
        singleton "strictDecrease" (ordering_constraint_proof False xml2name)
          Reduction_Pair_Gt),
      ("argumentFilterNonJoin",
        pair "argumentFilterNonJoin" (afs xml2name) (xml2non_join_info xml2name)
          Argument_Filter_NJ),
      ("usableRulesNonJoin",
        guard (\ xa -> equal_nat (num_children xa) (Nat_of_num One))
          (singleton "usableRulesNonJoin" (xml2non_join_info xml2name)
            Usable_Rules_Reach_NJ)
          (triple "usableRulesNonJoin"
            (options
              [("left", leaf "left" True), ("right", leaf "right" False)])
            (singleton "usableRules" (rules xml2name) id)
            (xml2non_join_info xml2name)
            (\ left u ->
              Usable_Rules_Reach_Unif_NJ (if left then Inl u else Inr u))))]
    x;

xml2ncr_proof ::
  (Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat])) ->
    Xml ->
      Sum_bot [Prelude.Char]
        (Ncr_proof [Prelude.Char] [Nat] [Prelude.Char] [Prelude.Char]);
xml2ncr_proof xml2name x =
  let {
    rew = rsteps xml2name;
  } in singleton "crDisproof"
         (options
           [("nonWcrAndSN",
              pair "nonWcrAndSN" (\ _ -> returna ())
                (xml2trs_termination_proof xml2name) (\ _ -> SN_NWCR)),
             ("nonJoinableFork",
               triple "nonJoinableFork" rew rew (xml2non_join_info xml2name)
                 (\ (s, seq1) (_, a) -> Non_Join s seq1 a)),
             ("modularityDisjoint",
               pair "modularityDisjoint" (singleton "trs" (rules xml2name) id)
                 (xml2ncr_proof xml2name) NCR_Disj_Subtrs),
             ("redundantRules",
               triple "redundantRules" (singleton "trs" (rules xml2name) id)
                 (nata "nrSteps") (xml2ncr_proof xml2name)
                 NCR_Redundant_Rules)])
         id x;

xml_signature :: forall a b. (Showa a, Showa b) => [(Lab a [b], Nat)] -> Xml;
xml_signature fs =
  XML "signature" []
    (map (\ (f, n) ->
           XML "symbol" []
             [xml_lab f,
               XML "arity" [] [XML_text (shows_prec_nat Zero_nat n [])]])
      fs);

xml_trs_input ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => Sum (Strategy (Lab a [b]) c) (Fp_strategy (Lab a [b]) c) ->
                    [(Term (Lab a [b]) c, Term (Lab a [b]) c)] ->
                      Maybe [(Term (Lab a [b]) c, Term (Lab a [b]) c)] -> Xml;
xml_trs_input strat r Nothing =
  XML "trsInput" [] ([xml_rules "trs" r] ++ xml_strategy strat);
xml_trs_input strat r (Just s) =
  XML "trsInput" []
    (xml_rules "trs" r : xml_strategy strat ++ [xml_rules "relativeRules" s]);

mgu_var_disjoint_generic ::
  forall a b c d.
    (Eq b,
      Eq d) => (a -> b) ->
                 (c -> b) ->
                   Term d a -> Term d c -> Maybe (a -> Term d b, c -> Term d b);
mgu_var_disjoint_generic vu wu s t =
  (case mgu (map_term (\ x -> x) vu s) (map_term (\ x -> x) wu t) of {
    Nothing -> Nothing;
    Just gamma -> Just (gamma . vu, gamma . wu);
  });

critical_pairs_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Bool, (Term a [Prelude.Char], Term a [Prelude.Char]))];
critical_pairs_impl p r =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ pa ->
          let {
            c = ctxt_of_pos_term pa l;
            la = subt_at l pa;
            b = equal_ctxt c Hole;
          } in (if is_Var la then []
                 else concatMap
                        (\ (laa, rb) ->
                          (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                                  (\ a -> 'y' : a) la laa
                            of {
                            Nothing -> [];
                            Just (sigma, tau) ->
                              [(b, (subst_apply_term ra sigma,
                                     ctxt_apply_term (subst_apply_ctxt c sigma)
                                       (subst_apply_term rb tau)))];
                          }))
                        r))
        (poss_list l))
    p;

check_linear_trs ::
  forall a b.
    (Showa a, Ceq b, Ccompare b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_linear_trs r =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (l, ra) = x;
              } in linear_term l && linear_term ra
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ _ ->
      Inl (((shows_prec_list Zero_nat r . shows_nl) .
             shows_prec_list Zero_nat "is not linear") .
            shows_nl));

indent ::
  ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
indent p s = concatMap (\ c -> (if c == '\n' then "\n " else [c])) (p s);

reachable_terms ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Nat -> [Term a b];
reachable_terms r s n =
  (if equal_nat n Zero_nat then [s]
    else let {
           ts = reachable_terms r s (minus_nat n (Nat_of_num One));
         } in remdups (ts ++ concatMap (rewrite r) ts));

check_strongly_closed ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strongly_closed r n =
  catch_errora
    (bindb (check_linear_trs r)
      (\ _ ->
        catch_errora
          (forallM
            (\ (_, (s, t)) ->
              check (not (is_none
                           (find (membera (reachable_terms r s n))
                             (reachable_terms r t
                               (plus_nat Zero_nat (Nat_of_num One))))) &&
                      not (is_none
                            (find (membera (reachable_terms r t n))
                              (reachable_terms r s
                                (plus_nat Zero_nat (Nat_of_num One))))))
                (shows_prec_list Zero_nat
                   "there is a critical pair that is not strongly closed: " .
                  shows_term (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                    s .
                    shows_prec_list Zero_nat " <- . -> " .
                      shows_term (shows_prec Zero_nat)
                        (shows_prec_list Zero_nat) t))
            (critical_pairs_impl r r))
          (\ x -> Inl (snd x))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list Zero_nat
                   "hence, the following TRS is not strongly closed " .
                   shows_nl .
                     shows_trs (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                       "rewrite system:" " -> " r .
                       indent x));

applicable_rule_impl ::
  forall a b. (Term a b -> Bool) -> (Term a b, Term a b) -> Bool;
applicable_rule_impl isNF = (\ (l, _) -> all isNF (args l));

check_non_applicable_rules ::
  forall a b.
    (Term a b -> Bool) -> [(Term a b, Term a b)] -> Sum (Term a b, Term a b) ();
check_non_applicable_rules isNF r =
  catch_errora
    (forallM
      (\ x -> (if not (applicable_rule_impl isNF x) then Inr () else Inl x)) r)
    (\ x -> Inl (snd x));

rule_match_impl ::
  forall a b.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                (b -> Term a (Sum () [Prelude.Char])) ->
                  [Term a [Prelude.Char]] ->
                    a -> [b] -> Term a [Prelude.Char] -> Bool;
rule_match_impl nfq e_cap s f ts l =
  (case mgu_class (Fun f (map e_cap ts)) l of {
    Nothing -> False;
    Just mu ->
      all (\ u ->
            nfq (subst_apply_term (map_term (\ x -> x) (\ a -> 'y' : a) u) mu))
        (args l) &&
        all (\ u -> nfq (subst_apply_term u mu)) s;
  });

is_ur_closed_term_af_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   ((a, Nat) -> Set Nat) ->
                     [(Term a [Prelude.Char], c)] ->
                       [(Term a [Prelude.Char], c)] ->
                         [Term a [Prelude.Char]] -> Term a b -> Bool;
is_ur_closed_term_af_impl nfq e_cap pi r u s (Var x) = True;
is_ur_closed_term_af_impl nfq e_cap pi r u s (Fun f ts) =
  let {
    n = size_list ts;
    pi_f = pi (f, n);
  } in all (\ (i, t) ->
             (if member i pi_f
               then is_ur_closed_term_af_impl nfq e_cap pi r u s t else True))
         (zip (upt Zero_nat n) ts) &&
         all (\ (l, ra) ->
               membera u (l, ra) || not (rule_match_impl nfq e_cap s f ts l))
           r;

is_ur_closed_af_impl_dpp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Term b [Prelude.Char] -> Bool;
is_ur_closed_af_impl_dpp_mv i d pi =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulesd i d;
    urc = (\ s -> is_ur_closed_term_af_impl qnf (ic s) pi r);
  } in (\ u s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_term (\ x -> x) (\ a -> 'x' : a) t)));

wwf_rulesa :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
wwf_rulesa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = wwf_rules;

q_emptyc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
q_emptyc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = q_empty;

matchCapRMBelow ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                 Term a b -> Term a b -> Bool;
matchCapRMBelow rm l (Fun f ts) = matchb (GCFun f (map (tcapRM2 rm) ts)) l;

forallM_index_aux ::
  forall a b. (a -> Nat -> Sum b ()) -> Nat -> [a] -> Sum ((a, Nat), b) ();
forallM_index_aux p i [] = Inr ();
forallM_index_aux p i (x : xs) =
  bindb (catch_errora (p x i) (\ xa -> Inl ((x, i), xa)))
    (\ _ -> forallM_index_aux p (plus_nat i (Nat_of_num One)) xs);

forallM_index ::
  forall a b. (a -> Nat -> Sum b ()) -> [a] -> Sum ((a, Nat), b) ();
forallM_index p xs = forallM_index_aux p Zero_nat xs;

check_ur_closed_term_rm_af ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                    [(Term a b, Term a b)] ->
                      ((a, Nat) -> Set Nat) ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ur_closed_term_rm_af uu uv uw (Var x) = Inr ();
check_ur_closed_term_rm_af rm ur pi (Fun f ts) =
  let {
    n = size_list ts;
    pia = pi (f, n);
  } in bindb (catch_errora
               (forallM_index
                 (\ t i ->
                   (if member i pia then check_ur_closed_term_rm_af rm ur pi t
                     else Inr ()))
                 ts)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ lr ->
                 check (membera ur lr ||
                         not (matchCapRMBelow rm (fst lr) (Fun f ts)))
                   (shows_string "due to the subterm " .
                     shows_prec_term Zero_nat (Fun f ts) .
                       shows_string " of some usable rhs, rule " .
                         shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                           " -> " lr .
                           shows_string " should be usable."))
               (rm (f, n)))
             (\ x -> Inl (snd x)));

check_ur_P_closed_rm_af ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        ((a, Nat) -> Set Nat) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ur_P_closed_rm_af rm ur p pi =
  bindb (catch_errora
          (catch_errora
            (forallM (\ lr -> check_ur_closed_term_rm_af rm ur pi (snd lr)) ur)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (shows_string
                   "error when checking closure properties of rhs of usable rules" .
                  shows_nl . x)))
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM (\ st -> check_ur_closed_term_rm_af rm ur pi (snd st)) p)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_string
                 "error when checking closure properties of rhs of DPs" .
                shows_nl . x)));

smart_usable_rules_checker_impl ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           Maybe [(Term b [Prelude.Char],
                                    Term b [Prelude.Char])] ->
                             [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                               Sum ([Prelude.Char] -> [Prelude.Char])
                                 [(Term b [Prelude.Char],
                                    Term b [Prelude.Char])];
smart_usable_rules_checker_impl i d pi u_opt sts =
  let {
    nfs = nfsc i d;
    m = minimal i d;
    wwf = wwf_rulesa i d;
    qempty = q_emptyc i d;
  } in (case u_opt of {
         Nothing -> Inr (rulesd i d);
         Just u ->
           (if nFQ_subset_NF_rulesc i d &&
                 (nfs || isOK (check_varcond_subset sts)) && (nfs || (m || wwf))
             then let {
                    urc = is_ur_closed_af_impl_dpp_mv i d pi u;
                    check_urc =
                      (\ s t ->
                        check (urc s t)
                          (shows_prec_list Zero_nat "term " .
                            shows_prec_term Zero_nat t .
                              shows_prec_list Zero_nat
                                " is not closed under usable rules"));
                  } in bindb (catch_errora
                               (forallM (\ (s, a) -> check_urc [s] a) sts)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM (\ (l, a) -> check_urc (args l) a)
                                     u)
                                   (\ x -> Inl (snd x)))
                             (\ _ -> Inr u))
             else bindb (check (m && (if nfs then qempty || wwf else True))
                          (shows_prec_list Zero_nat
                            "minimality and well formedness required"))
                    (\ _ ->
                      bindb (catch_errora
                              (forallM
                                (\ (l, _) ->
                                  check (not (is_Var l))
                                    (shows_prec_list Zero_nat
                                      "variables as lhss not allowed"))
                                (rulesd i d))
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          let {
                            rm = rules_mapb i d;
                          } in bindb (check_ur_P_closed_rm_af rm u sts pi)
                                 (\ _ -> Inr u))));
       });

root_aft_to_entry ::
  forall a b c. a -> Term b c -> ((b, Nat) -> Set Nat) -> [(a, Term b c)];
root_aft_to_entry s t pi =
  let {
    rt = the (root t);
    pi_t = pi rt;
    ts = args t;
  } in map_filter
         (\ x -> (if member x pi_t then Just (s, nth ts x) else Nothing))
         (upt Zero_nat (snd rt));

check_no_defined_root ::
  forall a b.
    (Showa a,
      Showa b) => ((a, Nat) -> Bool) ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_defined_root isdef t =
  check (not (isdef (the (root t))))
    (shows_string "the root of " .
      shows_prec_term Zero_nat t . shows_string " is defined");

pairsa :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pairsa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = pairs;

valida ::
  forall a b c.
    Root_redtriple_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
valida (Root_redtriple_ext valid s ns nst af aft desc more) = valid;

descb ::
  forall a b c. Root_redtriple_ext a b c -> [Prelude.Char] -> [Prelude.Char];
descb (Root_redtriple_ext valid s ns nst af aft desc more) = desc;

nsta ::
  forall a b c.
    Root_redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsta (Root_redtriple_ext valid s ns nst af aft desc more) = nst;

aft :: forall a b c. Root_redtriple_ext a b c -> (a, Nat) -> Set Nat;
aft (Root_redtriple_ext valid s ns nst af aft desc more) = aft;

nsa ::
  forall a b c.
    Root_redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsa (Root_redtriple_ext valid s ns nst af aft desc more) = ns;

afa :: forall a b c. Root_redtriple_ext a b c -> (a, Nat) -> Set Nat;
afa (Root_redtriple_ext valid s ns nst af aft desc more) = af;

sa :: forall a b c.
        Root_redtriple_ext a b c ->
          (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sa (Root_redtriple_ext valid s ns nst af aft desc more) = s;

generic_ur_af_root_redtriple_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Root_redtriple_ext b [Prelude.Char] () ->
                      Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_ur_af_root_redtriple_proc i rp u_opt premove dpp =
  (case catch_errora
          (bindb (valida rp)
            (\ _ ->
              let {
                (ps, pns) = split_pairsa i dpp premove;
                p = pairsa i dpp;
                pi = afa rp;
                pia = aft rp;
                is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
              } in bindb (catch_errora
                           (forallM
                             (\ (l, r) ->
                               bindb (check_no_var l)
                                 (\ _ ->
                                   bindb (check_no_var r)
                                     (\ _ -> check_no_defined_root is_def r)))
                             p)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulesd i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (smart_usable_rules_checker_impl i dpp pi u_opt
                                   (concatMap
                                     (\ (s, t) -> root_aft_to_entry s t pia) p))
                             (\ u ->
                               bindb (catch_errora
                                       (catch_errora (forallM (nsa rp) u)
 (\ x -> Inl (snd x)))
                                       (\ x ->
 Inl (shows_string "problem when orienting (usable) rules" . shows_nl . x)))
                                 (\ _ ->
                                   bindb (catch_errora
   (catch_errora (forallM (nsta rp) pns) (\ x -> Inl (snd x)))
   (\ x -> Inl (shows_string "problem when orienting DPs" . shows_nl . x)))
                                     (\ _ ->
                                       catch_errora
 (catch_errora (forallM (sa rp) ps) (\ x -> Inl (snd x)))
 (\ x -> Inl (shows_string "problem when orienting DPs" . shows_nl . x)))))))))
          (\ x ->
            Inl (shows_string
                   "could not apply the generic root reduction pair processor with the following" .
                  shows_nl . descb rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp premove premove);
  });

nst ::
  forall a b c.
    Redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nst (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  nst;

generic_ur_af_redtriple_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_ur_af_redtriple_proc i rp u_opt premove dpp =
  (case catch_errora
          (bindb (valid rp)
            (\ _ ->
              let {
                (ps, pns) = split_pairsa i dpp premove;
                p = pairsa i dpp;
              } in bindb (smart_usable_rules_checker_impl i dpp (af rp) u_opt p)
                     (\ u ->
                       bindb (catch_errora
                               (catch_errora (forallM (ns rp) u)
                                 (\ x -> Inl (snd x)))
                               (\ x ->
                                 Inl (shows_string
"problem when orienting (usable) rules" .
                                       shows_nl . x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (catch_errora (forallM (nst rp) pns)
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (shows_string
    "problem when orienting DPs" .
   shows_nl . x)))
                             (\ _ ->
                               catch_errora
                                 (catch_errora (forallM (s rp) ps)
                                   (\ x -> Inl (snd x)))
                                 (\ x ->
                                   Inl (shows_string
  "problem when orienting DPs" .
 shows_nl . x)))))))
          (\ x ->
            Inl (shows_string
                   "could not apply the generic reduction pair processor with the following" .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp premove premove);
  });

is_ur_closed_term_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   [(Term a [Prelude.Char], c)] ->
                     [(Term a [Prelude.Char], c)] ->
                       [Term a [Prelude.Char]] -> Term a b -> Bool;
is_ur_closed_term_impl nfq e_cap r u s (Var x) = True;
is_ur_closed_term_impl nfq e_cap r u s (Fun f ts) =
  all (is_ur_closed_term_impl nfq e_cap r u s) ts &&
    all (\ (l, ra) ->
          membera u (l, ra) || not (rule_match_impl nfq e_cap s f ts l))
      r;

is_ur_closed_impl_dpp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                           [Term b [Prelude.Char]] ->
                             Term b [Prelude.Char] -> Bool;
is_ur_closed_impl_dpp_mv i d =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulesd i d;
    urc = (\ s -> is_ur_closed_term_impl qnf (ic s) r);
  } in (\ u s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_term (\ x -> x) (\ a -> 'x' : a) t)));

intersect_rulesb ::
  forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_rulesb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = intersect_rules;

usable_rules_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_proc i u dpp =
  (case bindb (check (nFQ_subset_NF_rulesc i dpp)
                (shows_prec_list Zero_nat "innermost rewriting required"))
          (\ _ ->
            bindb (check (nfsc i dpp || (minimal i dpp || wwf_rulesa i dpp))
                    (shows_prec_list Zero_nat
                      "normal form subst, minimality or well-formedness required"))
              (\ _ ->
                let {
                  p = pairsa i dpp;
                  urc = is_ur_closed_impl_dpp_mv i dpp u;
                  check_urc =
                    (\ s t ->
                      check (urc s t)
                        (shows_prec_list Zero_nat "term " .
                          shows_prec_term Zero_nat t .
                            shows_prec_list Zero_nat
                              " is not closed under usable rules"));
                  nfs = nfsc i dpp;
                } in bindb (catch_errora
                             (forallM
                               (\ (l, r) ->
                                 bindb (if nfs then Inr ()
 else catch_errora (check_subseteq (vars_term_list r) (vars_term_list l))
        (\ _ ->
          Inl (shows_prec_list Zero_nat "variable condition in P violated")))
                                   (\ _ -> check_urc [l] r))
                               p)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         catch_errora
                           (forallM (\ (l, a) -> check_urc (args l) a) u)
                           (\ x -> Inl (snd x)))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (intersect_rulesb i dpp u);
  });

mono ::
  forall a b c.
    Redtriple_ext a b c ->
      [(Term a b, Term a b)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
mono (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  mono;

mono_inn_usable_rules_ce_proc ::
  forall a b.
    (Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_inn_usable_rules_ce_proc i rp premove rremove ur dpp =
  (case catch_errora
          (bindb (usable_rules_proc i ur dpp)
            (\ _ ->
              let {
                p = pairsa i dpp;
                us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
                filt =
                  (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
                (pms, pns) = split_pairsa i dpp premove;
                (ps, pnwf) = partition filt pms;
                (urms, urns) = partition (membera rremove) ur;
                (urs, urnwf) = partition filt urms;
              } in bindb (valid rp)
                     (\ _ ->
                       bindb (mono rp
                               (ps ++ urs ++ urns ++ urnwf ++ pns ++ pnwf))
                         (\ _ ->
                           bindb (catch_errora
                                   (catch_errora
                                     (forallM (ns rp) (urns ++ urnwf))
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (shows_string
    "problem when orienting usable rules" .
   shows_nl . x)))
                             (\ _ ->
                               bindb (catch_errora
                                       (catch_errora (forallM (s rp) urs)
 (\ x -> Inl (snd x)))
                                       (\ x ->
 Inl (shows_string "problem when orienting usable rules" . shows_nl . x)))
                                 (\ _ ->
                                   bindb (catch_errora
   (catch_errora (forallM (ns rp) (pns ++ pnwf)) (\ x -> Inl (snd x)))
   (\ x -> Inl (shows_string "problem when orienting DPs" . shows_nl . x)))
                                     (\ _ ->
                                       catch_errora
 (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
 (\ x -> Inl (shows_string "problem when orienting DPs" . shows_nl . x)))))))))
          (\ x ->
            Inl (shows_string
                   "could not apply the innermost usable rules reduction pair processor with the following" .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

mono_ur_redpair_proc ::
  forall a b c.
    (Ceq b, Ccompare b, Eq b, Set_impl b, Showa b, Eq c,
      Showa c) => Dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          [(Term b c, Term b c)] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_ur_redpair_proc i rp premove rremove ur dpp =
  (case catch_errora
          (bindb
            (check (minimal i dpp)
              (shows_prec_list Zero_nat "minimality required"))
            (\ _ ->
              bindb (check
                      (if nfsc i dpp
                        then (if not (q_emptyc i dpp) then wwf_rulesa i dpp
                               else True)
                        else True)
                      (shows_prec_list Zero_nat "well formedness required"))
                (\ _ ->
                  let {
                    p = pairsa i dpp;
                    us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
                    filt =
                      (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
                    (pms, pns) = split_pairsa i dpp premove;
                    (ps, pnwf) = partition filt pms;
                    (urms, urns) = partition (membera rremove) ur;
                    (urs, urnwf) = partition filt urms;
                    rm = rules_mapb i dpp;
                  } in bindb (valid rp)
                         (\ _ ->
                           bindb (mono rp
                                   (ps ++ urs ++ urns ++ urnwf ++ pns ++ pnwf))
                             (\ _ ->
                               bindb (check_ur_P_closed_rm_af rm ur p full_af)
                                 (\ _ ->
                                   bindb (catch_errora
   (forallM
     (\ (l, _) ->
       check (not (is_Var l))
         (shows_prec_list Zero_nat "variables as lhss not allowed"))
     (rulesd i dpp))
   (\ x -> Inl (snd x)))
                                     (\ _ ->
                                       bindb
 (catch_errora
   (catch_errora (forallM (ns rp) (urns ++ urnwf)) (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string "problem when orienting usable rules" . shows_nl . x)))
 (\ _ ->
   bindb (catch_errora (catch_errora (forallM (s rp) urs) (\ x -> Inl (snd x)))
           (\ x ->
             Inl (shows_string "problem when orienting usable rules" .
                   shows_nl . x)))
     (\ _ ->
       bindb (catch_errora
               (catch_errora (forallM (ns rp) (pns ++ pnwf))
                 (\ x -> Inl (snd x)))
               (\ x ->
                 Inl (shows_string "problem when orienting DPs" .
                       shows_nl . x)))
         (\ _ ->
           catch_errora (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
             (\ x ->
               Inl (shows_string "problem when orienting DPs" .
                     shows_nl . x))))))))))))
          (\ x ->
            Inl (shows_string
                   "could not apply the monotonic reduction pair processor with the following" .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

generic_mono_ur_redpair_proc ::
  forall a b.
    (Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_mono_ur_redpair_proc i rp premove rremove ur dpp =
  (if nFQ_subset_NF_rulesc i dpp
    then mono_inn_usable_rules_ce_proc i rp premove rremove ur dpp
    else bindb (check (minimal i dpp)
                 (shows_prec_list Zero_nat
                   "minimality or innermost required for mon. red. pair proc. with usable rules"))
           (\ _ -> mono_ur_redpair_proc i rp premove rremove ur dpp));

compat_roota :: forall a b. (Eq a) => Term a b -> Maybe (a, Nat) -> Bool;
compat_roota uu Nothing = False;
compat_roota (Var uv) (Just v) = False;
compat_roota (Fun va vb) (Just v) = root (Fun va vb) == Just v;

usable_rules_gen2 ::
  forall a b.
    (Eq a) => [(Term a b, Term a b)] ->
                (Maybe (a, Nat), Bool) -> [(Term a b, Term a b)];
usable_rules_gen2 r (fn, b) =
  let {
    rr = concatMap (\ (l, ra) -> (if compat_roota l fn then [(l, ra)] else []))
           r;
  } in (if b then rr else map (\ (l, ra) -> (ra, l)) rr);

rel_dep_prod :: Bool -> Dependance -> [Bool];
rel_dep_prod uu Ignore = [];
rel_dep_prod b Increase = [b];
rel_dep_prod b Decrease = [not b];
rel_dep_prod uv Wild = [True, False];

compat_root :: forall a b c. (Eq a) => Term a b -> Term a c -> Bool;
compat_root uu (Var uv) = False;
compat_root (Var uw) (Fun v va) = False;
compat_root (Fun vb vc) (Fun v va) = root (Fun vb vc) == root (Fun v va);

usable_rules_gen1 ::
  forall a b.
    (Eq a) => ((a, Nat) -> Nat -> Dependance) ->
                [(Term a b, Term a b)] ->
                  (Term a b, Bool) -> [(Term a b, Bool)];
usable_rules_gen1 pi r (Var uu, uv) = [];
usable_rules_gen1 pi r (Fun f ts, b) =
  let {
    n = size_list ts;
  } in concatMap
         (\ (l, ra) -> (if compat_root l (Fun f ts) then [(ra, b)] else []))
         r ++
         concatMap
           (\ i -> map (\ a -> (nth ts i, a)) (rel_dep_prod b (pi (f, n) i)))
           (upt Zero_nat n);

usable_rules_gen ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> Nat -> Dependance) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] -> [(Term a b, Term a b)];
usable_rules_gen pi r p =
  concatMap (usable_rules_gen2 r)
    (remdups
      (map (\ (t, a) -> (root t, a))
        (mk_rtrancl_list (\ a b -> a == b) (usable_rules_gen1 pi r)
          (map (\ (_, t) -> (t, True)) p))));

generate_lists :: forall a. Nat -> [a] -> [[a]];
generate_lists n xs = concat_lists (map (\ _ -> xs) (upt Zero_nat n));

initial_conditions_gen_impl ::
  forall a. (a -> a -> Bool) -> Nat -> Nat -> [a] -> a -> [[a]];
initial_conditions_gen_impl pa bef_len aft_len p st =
  let {
    pairs = (\ n -> generate_lists n p);
    a = concatMap (\ bef -> map (\ aft -> bef ++ st : aft) (pairs aft_len))
          (pairs bef_len);
  } in filter
         (\ bef_st_aft ->
           all_interval_nat
             (\ i ->
               pa (nth bef_st_aft i)
                 (nth bef_st_aft (plus_nat i (Nat_of_num One))))
             Zero_nat (plus_nat bef_len aft_len))
         a;

disjoint_variant ::
  forall a b.
    (Compare a, Eq a, Card_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b, Mapping_impl b,
      Set_impl b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Bool;
disjoint_variant sts uvs =
  equal_nat (size_list sts) (size_list uvs) &&
    all_interval_nat (\ i -> eq_rule_mod_vars (nth sts i) (nth uvs i)) Zero_nat
      (size_list sts) &&
      is_partition (map vars_rule uvs);

condition_of ::
  forall a b.
    a -> Condition_type -> (Term a b, Term a b) -> Cond_constraint a b;
condition_of c Bound (s, uu) = CC_cond False (s, Fun c []);
condition_of c Strict st = CC_cond True st;
condition_of c Non_Strict st = CC_cond False st;

constraint_of ::
  forall a b.
    a -> Condition_type -> [(Term a b, Term a b)] -> Nat -> Cond_constraint a b;
constraint_of c ctype uvs bef =
  CC_impl
    (map (\ i ->
           CC_rewr (snd (nth uvs i))
             (fst (nth uvs (plus_nat i (Nat_of_num One)))))
      (upt Zero_nat (minus_nat (size_list uvs) (Nat_of_num One))))
    (condition_of c ctype (nth uvs bef));

the_set_impl_main_lazy ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Eq b) => (a -> [b]) -> (b -> [a]) -> [a] -> Set a -> [b] -> [a];
the_set_impl_main_lazy q gen_as have_asa have_as bs =
  let {
    new_as =
      concatMap
        (\ b ->
          concatMap (\ a -> (if not (member a have_as) then [a] else []))
            (gen_as b))
        bs;
  } in (if null new_as then have_asa
         else the_set_impl_main_lazy q gen_as (new_as ++ have_asa)
                (sup_set (set new_as) have_as) (remdups (concatMap q new_as)));

the_set_impl_lazy ::
  forall a b.
    (Ceq a, Ccompare a, Set_impl a,
      Eq b) => (a -> [b]) -> (b -> [a]) -> [b] -> [a];
the_set_impl_lazy q gen_as bs = the_set_impl_main_lazy q gen_as [] bot_set bs;

inductive_set_impl_lazy ::
  forall a b.
    (Eq a, Ceq b, Ccompare b,
      Set_impl b) => (a -> [b]) -> (b -> [a]) -> [a] -> [b];
inductive_set_impl_lazy q p = the_set_impl_lazy p q;

ur_term_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   [(Term a [Prelude.Char], c)] ->
                     ((a, Nat) -> Set Nat) ->
                       [Term a [Prelude.Char]] ->
                         Term a b -> [(Term a [Prelude.Char], c)];
ur_term_impl nfq e_cap r pi s (Var x) = [];
ur_term_impl nfq e_cap r pi s (Fun f ts) =
  let {
    n = size_list ts;
    rec = map (ur_term_impl nfq e_cap r pi s) ts;
  } in remdups
         (concatMap (\ (i, urs) -> (if member i (pi (f, n)) then urs else []))
            (zip (upt Zero_nat n) rec) ++
           filter (\ (l, _) -> rule_match_impl nfq e_cap s f ts l) r);

precompute_fun :: forall a b. (Key a) => (a -> b) -> [a] -> a -> b;
precompute_fun f asa =
  fun_of_map_fun (ceta_map_of (map (\ a -> (a, f a)) asa)) f;

usable_rules_calc_impl ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  ([Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      [([Term a [Prelude.Char]], Term a [Prelude.Char])] ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])];
usable_rules_calc_impl nfq e_cap r =
  let {
    urt = (\ (s, t) ->
            let {
              sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
            } in ur_term_impl nfq (e_cap sa) r full_af sa
                   (map_term (\ x -> x) (\ a -> 'x' : a) t));
    urules = map (\ (l, a) -> (args l, a)) r;
    ufun = precompute_fun urt urules;
  } in inductive_set_impl_lazy ufun (\ (l, ra) -> [(args l, ra)]);

ur_calc_singleton ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  ([Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      ([Term a [Prelude.Char]], Term a [Prelude.Char]) ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])];
ur_calc_singleton nfq e_cap r st = usable_rules_calc_impl nfq e_cap r [st];

inn_usable_rules_pair ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                         [(Term b [Prelude.Char], Term b [Prelude.Char])];
inn_usable_rules_pair i d =
  let {
    inn = nFQ_subset_NF_rulesc i d;
    r = rulesd i d;
    qnf = is_QNFc i d;
    ic = icap_impl_dpp i d;
    calc = ur_calc_singleton qnf ic r;
    nfs = nfsc i d;
    wwf = wwf_rulesa i d;
    m = minimal i d;
  } in (\ (s, t) ->
         (if inn &&
               (nfs || subset (vars_term t) (vars_term s)) &&
                 (nfs || (m || wwf))
           then calc ([s], t) else r));

is_NF_main ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool -> ((a, Nat) -> [Term a b]) -> Term a b -> Bool;
is_NF_main var_cond r_empty m =
  (if var_cond then (\ _ -> False)
    else (if r_empty then (\ _ -> True)
           else (\ t ->
                  all (\ u ->
                        (if not (is_Var u)
                          then all (\ l -> not (matches u l)) (m (the (root u)))
                          else True))
                    (supteq_list t))));

elem_list_to_rm ::
  forall a b. (Compare_order b) => (a -> b) -> [a] -> Rbt b [a];
elem_list_to_rm key (d : ds) =
  let {
    rm = elem_list_to_rm key ds;
    k = key d;
  } in (case lookup rm k of {
         Nothing -> insert k [d] rm;
         Just dataa -> insert k (d : dataa) rm;
       });
elem_list_to_rm key [] = empty;

term_map :: forall a b. (Key a) => [Term a b] -> (a, Nat) -> [Term a b];
term_map ts = fun_of_map (lookup (elem_list_to_rm (the . root) ts)) [];

is_NF_terms ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> Term a b -> Bool;
is_NF_terms q = is_NF_main (any is_Var q) (null q) (term_map q);

icap_impl_dpp_mv ::
  forall a b.
    (Eq b) => Dpp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_dpp_mv i d =
  let {
    qr = nFQ_subset_NF_rulesc i d;
    qnf = is_QNFc i d;
    r = rulesd i d;
    ic = icap_impl_gen qr qnf (map fst r);
  } in (\ s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
           sx = ceta_set_of (concatMap vars_term_list sa);
         } in (\ t -> ic sa sx (map_term (\ x -> x) (\ a -> 'x' : a) t)));

is_iedg_edge_dpp ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                           Term b [Prelude.Char] -> Bool;
is_iedg_edge_dpp i d =
  let {
    qnf = is_QNFc i d;
    ic = icap_impl_dpp_mv i d;
    _ = rulesd i d;
    urules = inn_usable_rules_pair i d;
  } in (\ (s, t) ->
         let {
           cst = ic [s] t;
           urls = reverse_rules (urules (s, t));
           ica = icap_impl (is_NF_terms []) urls;
         } in (\ u ->
                (case mgu_class cst u of {
                  Nothing -> False;
                  Just mu ->
                    qnf (subst_apply_term
                          (map_term (\ x -> x) (\ a -> 'x' : a) s) mu) &&
                      qnf (subst_apply_term
                            (map_term (\ x -> x) (\ a -> 'y' : a) u) mu);
                }) &&
                  let {
                    cu = ica [] u;
                  } in (case mgu_class cu t of {
                         Nothing -> False;
                         Just mu ->
                           qnf (subst_apply_term
                                 (map_term (\ x -> x) (\ a -> 'y' : a) s) mu);
                       })));

deep_normalize_cca :: forall a b. Cond_constraint a b -> Cond_constraint a b;
deep_normalize_cca (CC_impl [] c) = deep_normalize_cca c;
deep_normalize_cca (CC_impl (v : va) c) =
  CC_impl (map deep_normalize_cca (v : va)) (deep_normalize_cca c);
deep_normalize_cca (CC_cond s c) = CC_cond s c;
deep_normalize_cca (CC_all s c) = CC_all s (deep_normalize_cca c);
deep_normalize_cca (CC_rewr s c) = CC_rewr s c;

vars_cc_list :: forall a b. (Eq b) => Cond_constraint a b -> [b];
vars_cc_list (CC_cond ct (s, t)) = vars_term_list s ++ vars_term_list t;
vars_cc_list (CC_rewr s t) = vars_term_list s ++ vars_term_list t;
vars_cc_list (CC_impl c1 c2) = concatMap vars_cc_list c1 ++ vars_cc_list c2;
vars_cc_list (CC_all x c) =
  concatMap (\ y -> (if not (y == x) then [y] else [])) (vars_cc_list c);

cc_subst_apply ::
  forall a b.
    (Eq a) => ([a] -> a) ->
                Cond_constraint b a ->
                  (a -> Term b a, [a]) -> Cond_constraint b a;
cc_subst_apply fresh (CC_all x c) (sigma, vs) =
  let {
    y = fresh (vs ++ vars_cc_list (CC_all x c));
  } in CC_all y (cc_subst_apply fresh c (fun_upd sigma x (Var y), y : vs));
cc_subst_apply fresh (CC_impl c1 c2) sigma =
  CC_impl (map (\ c -> cc_subst_apply fresh c sigma) c1)
    (cc_subst_apply fresh c2 sigma);
cc_subst_apply fresh (CC_rewr s t) (sigma, uv) =
  CC_rewr (subst_apply_term s sigma) (subst_apply_term t sigma);
cc_subst_apply fresh (CC_cond ct (s, t)) (sigma, uu) =
  CC_cond ct (subst_apply_term s sigma, subst_apply_term t sigma);

normalize_alpha ::
  forall a b.
    (Eq a) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a;
normalize_alpha fresh c = cc_subst_apply fresh c (Var, []);

deep_normalize_cc ::
  forall a b.
    (Eq a) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a;
deep_normalize_cc fresh c = normalize_alpha fresh (deep_normalize_cca c);

check_subsumesa ::
  forall a b.
    (Eq a, Eq b) => Cond_constraint a b -> Cond_constraint a b -> Bool;
check_subsumesa (CC_impl cs c) (CC_impl ds d) =
  check_subsumesa c d &&
    all (\ ca -> any (\ da -> check_subsumesa da ca) ds) cs;
check_subsumesa (CC_cond v va) (CC_impl ds d) =
  check_subsumesa (CC_cond v va) d;
check_subsumesa (CC_rewr v va) (CC_impl ds d) =
  check_subsumesa (CC_rewr v va) d;
check_subsumesa (CC_all v va) (CC_impl ds d) = check_subsumesa (CC_all v va) d;
check_subsumesa (CC_all x c) (CC_all y d) = x == y && check_subsumesa c d;
check_subsumesa (CC_cond v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_cond vb vc);
check_subsumesa (CC_cond v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_rewr vb vc);
check_subsumesa (CC_cond v va) (CC_all vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_all vb vc);
check_subsumesa (CC_rewr v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_cond vb vc);
check_subsumesa (CC_rewr v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_rewr vb vc);
check_subsumesa (CC_rewr v va) (CC_all vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_all vb vc);
check_subsumesa (CC_all v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_all v va) (CC_cond vb vc);
check_subsumesa (CC_all v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_all v va) (CC_rewr vb vc);
check_subsumesa c (CC_cond v va) = equal_cond_constraint c (CC_cond v va);
check_subsumesa c (CC_rewr v va) = equal_cond_constraint c (CC_rewr v va);
check_subsumesa (CC_impl vb vc) (CC_all v va) =
  equal_cond_constraint (CC_impl vb vc) (CC_all v va);

check_subsumes ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a -> Bool;
check_subsumes fresh c d =
  let {
    n = deep_normalize_cc fresh;
  } in check_subsumesa (n c) (n d);

check_constraint_present ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> b -> [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                                Nat ->
                                  Nat ->
                                    [(Cond_constraint b [Prelude.Char],
                                       [(Term b [Prelude.Char],
  Term b [Prelude.Char])])] ->
                                      Condition_type ->
(Term b [Prelude.Char], Term b [Prelude.Char]) ->
  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_constraint_present i dpp constant p bef aft ccs =
  let {
    edg = is_iedg_edge_dpp i dpp;
    init_conds =
      initial_conditions_gen_impl (\ st uv -> edg st (fst uv)) bef aft p;
  } in (\ ct st ->
         catch_errora
           (forallM
             (\ sts ->
               check (any (\ (c, uvs) ->
                            disjoint_variant sts uvs &&
                              check_subsumes (fresh_string "xx") c
                                (constraint_of constant ct uvs bef))
                       ccs)
                 (shows_prec_list Zero_nat "did not find " .
                   shows_prec_list Zero_nat
                     (case ct of {
                       Bound -> "bound";
                       Strict -> "strict";
                       Non_Strict -> "non-strict";
                     }) .
                     shows_prec_list Zero_nat " constraint for sequence " .
                       shows_rules (shows_prec Zero_nat)
                         (shows_prec_list Zero_nat) " -> " sts))
             (init_conds st))
           (\ x -> Inl (snd x)));

check_left_linear_trs ::
  forall a b.
    (Showa a, Ceq b, Ccompare b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_left_linear_trs trs =
  catch_errora
    (catch_errora
      (forallM (\ x -> (if linear_term (fst x) then Inr () else Inl x)) trs)
      (\ x -> Inl (snd x)))
    (\ _ ->
      Inl (((shows_prec_list Zero_nat trs . shows_nl) .
             shows_prec_list Zero_nat "is not left-linear") .
            shows_nl));

check_weakly_orthogonal ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_weakly_orthogonal r =
  catch_errora
    (bindb (check_left_linear_trs r)
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ (l, _) ->
                    check (not (is_Var l))
                      (shows_prec_list Zero_nat
                        "the TRS has variables as left-hand sides"))
                  r)
                (\ x -> Inl (snd x)))
          (\ _ ->
            catch_errora
              (forallM
                (\ (_, (s, t)) ->
                  check (equal_term s t)
                    (shows_prec_list Zero_nat
                       "there is a non-trivial critical pair: " .
                      shows_term (shows_prec Zero_nat)
                        (shows_prec_list Zero_nat) s .
                        shows_prec_list Zero_nat " <- . -> " .
                          shows_term (shows_prec Zero_nat)
                            (shows_prec_list Zero_nat) t))
                (critical_pairs_impl r r))
              (\ x -> Inl (snd x)))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list Zero_nat
                   "hence, the following TRS is not weakly orthogonal " .
                   shows_nl .
                     shows_trs (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                       "rewrite system:" " -> " r .
                       indent x));

validb ::
  forall a b c.
    Non_inf_order_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
validb (Non_inf_order_ext valid ns cc af desc more) = valid;

descc ::
  forall a b c. Non_inf_order_ext a b c -> [Prelude.Char] -> [Prelude.Char];
descc (Non_inf_order_ext valid ns cc af desc more) = desc;

nsb ::
  forall a b c.
    Non_inf_order_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsb (Non_inf_order_ext valid ns cc af desc more) = ns;

cc :: forall a b c.
        Non_inf_order_ext a b c ->
          C_constraint a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
cc (Non_inf_order_ext valid ns cc af desc more) = cc;

afb :: forall a b c. Non_inf_order_ext a b c -> (a, Nat) -> Nat -> Dependance;
afb (Non_inf_order_ext valid ns cc af desc more) = af;

range_vars_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
range_vars_impl sigma =
  let {
    a = mk_subst_domain sigma;
  } in concatMap (vars_term_list . snd) a;

cc_bound :: forall a b. [a] -> Cond_constraint b a -> Cond_constraint b a;
cc_bound [] c = c;
cc_bound (x : xs) c = CC_all x (cc_bound xs c);

cc_ih_prems ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) ->
                 b -> Term b a ->
                        [a] ->
                          [Cond_constraint b a] ->
                            Cond_constraint b a ->
                              [(Term b a, [a])] -> [Cond_constraint b a];
cc_ih_prems fresh f q xs phi psi rs_ys_list =
  map (\ (r, ys) ->
        let {
          rs = args r;
          mu = mk_subst Var (zip xs rs);
          vs = range_vars_impl (zip xs rs);
          mua = (\ c -> cc_subst_apply fresh c (mu, vs));
          a = CC_impl (CC_rewr r (subst_apply_term q mu) : map mua phi)
                (mua psi);
        } in cc_bound ys a)
    rs_ys_list;

cc_rule_constraint ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) ->
                 b -> [Term b a] ->
                        Term b a ->
                          Term b a ->
                            [a] ->
                              [Cond_constraint b a] ->
                                Cond_constraint b a ->
                                  [(Term b a, [a])] -> Cond_constraint b a;
cc_rule_constraint fresh f ls r q xs phi psi rs_ys_list =
  let {
    sigma = mk_subst Var (zip xs ls);
    vs = range_vars_impl (zip xs ls);
    rew = CC_rewr r (subst_apply_term q sigma);
    phi_sig = map (\ c -> cc_subst_apply fresh c (sigma, vs)) phi;
    psi_sig = cc_subst_apply fresh psi (sigma, vs);
    ihs = cc_ih_prems fresh f q xs phi psi rs_ys_list;
  } in CC_impl (rew : phi_sig ++ ihs) psi_sig;

cc_unbound :: forall a b. Cond_constraint a b -> ([b], Cond_constraint a b);
cc_unbound (CC_all x c) = let {
                            (xs, a) = cc_unbound c;
                          } in (x : xs, a);
cc_unbound (CC_cond v va) = ([], CC_cond v va);
cc_unbound (CC_rewr v va) = ([], CC_rewr v va);
cc_unbound (CC_impl v va) = ([], CC_impl v va);

funas_args_term_list :: forall a b. Term a b -> [(a, Nat)];
funas_args_term_list t = concatMap funas_term_list (args t);

check_rys ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> Bool) ->
                    Maybe (a, Nat) ->
                      Term a b ->
                        (Term a b, [b]) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rys d rt r rys =
  let {
    (ra, ys) = rys;
  } in bindb (check (root ra == rt)
               (shows_string "root of " .
                 shows_prec_term Zero_nat ra .
                   shows_string " is not " . shows_prec_prod Zero_nat (the rt)))
         (\ _ ->
           bindb (check (equal_term r ra || supt_impl r ra)
                   (shows_prec_term Zero_nat ra .
                     shows_string " is not a subterm of " .
                       shows_prec_term Zero_nat r))
             (\ _ ->
               bindb (catch_errora
                       (forallM
                         (\ f ->
                           check (not (d f))
                             (shows_string "the defined symbol " .
                               shows_prec_prod Zero_nat f .
                                 shows_string " occurs in the subterm " .
                                   shows_prec_term Zero_nat ra .
                                     shows_prec_list Zero_nat " of the rhs"))
                         (funas_args_term_list ra))
                       (\ x -> Inl (snd x)))
                 (\ _ ->
                   catch_errora (check_disjoint ys (vars_term_list r))
                     (\ x ->
                       Inl (shows_prec Zero_nat x .
                             shows_string " occurs in " .
                               shows_prec_term Zero_nat r)))));

shows_cc_aux ::
  forall a b.
    (Showa a,
      Showa b) => Bool ->
                    Cond_constraint a b -> [Prelude.Char] -> [Prelude.Char];
shows_cc_aux b (CC_rewr s t) =
  shows_prec_term Zero_nat s .
    shows_prec_list Zero_nat " = " . shows_prec_term Zero_nat t;
shows_cc_aux b (CC_cond stri (s, t)) =
  shows_prec_term Zero_nat s .
    shows_prec_list Zero_nat (if stri then " > " else " >= ") .
      shows_prec_term Zero_nat t;
shows_cc_aux b (CC_all x c) =
  let {
    s = shows_prec_list Zero_nat "ALL " .
          shows_prec Zero_nat x .
            shows_prec_list Zero_nat ". " . shows_cc_aux False c;
  } in (if b then shows_prec_list Zero_nat "(" .
                    s . shows_prec_list Zero_nat ")"
         else s);
shows_cc_aux b (CC_impl cs c2) =
  shows_string "(" .
    shows_list_gen (shows_cc_aux True) "True" [] " and " [] cs .
      shows_prec_list Zero_nat " => " .
        shows_cc_aux True c2 . shows_prec_list Zero_nat ")";

shows_cc ::
  forall a b.
    (Showa a,
      Showa b) => Cond_constraint a b -> [Prelude.Char] -> [Prelude.Char];
shows_cc = shows_cc_aux False;

prems_of :: forall a b. Cond_constraint a b -> [Cond_constraint a b];
prems_of (CC_impl c1 c2) = c1;
prems_of (CC_cond v va) = [];
prems_of (CC_rewr v va) = [];
prems_of (CC_all v va) = [];

concl_of :: forall a b. Cond_constraint a b -> Cond_constraint a b;
concl_of (CC_impl c1 c2) = c2;
concl_of (CC_cond v va) = CC_cond v va;
concl_of (CC_rewr v va) = CC_rewr v va;
concl_of (CC_all v va) = CC_all v va;

normalize_cc :: forall a b. Cond_constraint a b -> Cond_constraint a b;
normalize_cc c = CC_impl (prems_of c) (concl_of c);

check_cc_prf ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ((a, Nat) -> Bool) ->
                      [(a, Nat)] ->
                        Bool ->
                          Cond_constraint a [Prelude.Char] ->
                            Cond_constraint_prf a [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char])
                                [C_constraint a [Prelude.Char]];
check_cc_prf r d f m_ortho cc Final =
  (case normalize_cc cc of {
    CC_cond _ _ ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_rewr _ _ ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_cond stri st) -> Inr [Unconditional_C stri st];
    CC_impl [] (CC_rewr _ _) ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_impl _ _) ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_all _ _) ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond stri uv] (CC_cond stria st) ->
      (if stri == stria then Inr [Conditional_C stri uv st]
        else Inl (shows_prec_list Zero_nat
                    "problem in final constraint: different relations for finalizing " .
                   shows_cc cc));
    CC_impl [CC_cond _ _] (CC_rewr _ _) ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond _ _] (CC_impl _ _) ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond _ _] (CC_all _ _) ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_impl (CC_cond _ _ : _ : _) _ ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_impl (CC_rewr _ _ : _) _ ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_impl (CC_impl _ _ : _) _ ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_impl (CC_all _ _ : _) _ ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
    CC_all _ _ ->
      Inl (shows_prec_list Zero_nat
             "problem in final constraint: it is neither a condition nor an implification of two conditions, but it is " .
            shows_nl . shows_cc cc);
  });
check_cc_prf r da f m_ortho c (Delete_Condition d prf) =
  bindb (check (check_subsumes (fresh_string "xx") d c)
          (shows_string "problem in delete conditions when switching from " .
            shows_nl .
              shows_cc c . shows_string " to " . shows_nl . shows_cc d))
    (\ _ -> check_cc_prf r da f m_ortho d prf);
check_cc_prf r da f m_ortho c (Different_Constructor d) =
  let {
    (CC_impl cs _) = normalize_cc c;
  } in catch_errora
         (bindb
           (check (membera cs d)
             (shows_cc d .
               shows_nl . shows_string "is not a premise of " . shows_cc c))
           (\ _ ->
             (case d of {
               CC_cond _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list Zero_nat
                         " is not a rewrite condition of the correct shape");
               CC_rewr (Var _) _ ->
                 Inl (shows_cc d .
                       shows_prec_list Zero_nat
                         " is not a rewrite condition of the correct shape");
               CC_rewr (Fun _ _) (Var _) ->
                 Inl (shows_cc d .
                       shows_prec_list Zero_nat
                         " is not a rewrite condition of the correct shape");
               CC_rewr (Fun fa ss) (Fun g ts) ->
                 bindb (check (not (da (fa, size_list ss)))
                         (shows_prec Zero_nat fa .
                           shows_prec_list Zero_nat " is defined"))
                   (\ _ ->
                     bindb (check
                             (not ((fa, size_list ss) == (g, size_list ts)))
                             (shows_string "the root " .
                               shows_prec Zero_nat fa .
                                 shows_prec_list Zero_nat
                                   " is identical on both sides"))
                       (\ _ -> Inr []));
               CC_impl _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list Zero_nat
                         " is not a rewrite condition of the correct shape");
               CC_all _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list Zero_nat
                         " is not a rewrite condition of the correct shape");
             })))
         (\ x ->
           Inl (shows_string
                  "problem in Different Constructor with rewrite condition " .
                 shows_cc d .
                   shows_nl .
                     shows_string "on input constraint " .
                       shows_nl . shows_cc c . shows_nl . x));
check_cc_prf r da f m_ortho ca (Same_Constructor d c p) =
  let {
    (CC_impl cs con) = normalize_cc ca;
  } in bindb (catch_errora
               (bindb
                 (check (membera cs d)
                   (shows_cc d .
                     shows_nl .
                       shows_string "is not a premise of " . shows_cc ca))
                 (\ _ ->
                   (case d of {
                     CC_cond _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list Zero_nat
                               " is not a rewrite condition of the correct shape");
                     CC_rewr (Var _) _ ->
                       Inl (shows_cc d .
                             shows_prec_list Zero_nat
                               " is not a rewrite condition of the correct shape");
                     CC_rewr (Fun _ _) (Var _) ->
                       Inl (shows_cc d .
                             shows_prec_list Zero_nat
                               " is not a rewrite condition of the correct shape");
                     CC_rewr (Fun fa ss) (Fun g ts) ->
                       bindb (check (not (da (fa, size_list ss)))
                               (shows_prec Zero_nat fa .
                                 shows_prec_list Zero_nat " is defined"))
                         (\ _ ->
                           bindb (check
                                   ((fa, size_list ss) == (g, size_list ts))
                                   (shows_prec Zero_nat fa .
                                     shows_string " and " .
                                       shows_prec Zero_nat g .
 shows_prec_list Zero_nat " are not identical"))
                             (\ _ ->
                               let {
                                 ds = cs ++
map (\ (a, b) -> CC_rewr a b) (zip ss ts);
                                 db = CC_impl ds con;
                               } in check (check_subsumes (fresh_string "xx") c
    db)
                                      (shows_string "new constraint is " .
shows_cc c . shows_nl . shows_string "but expected was " . shows_cc db)));
                     CC_impl _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list Zero_nat
                               " is not a rewrite condition of the correct shape");
                     CC_all _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list Zero_nat
                               " is not a rewrite condition of the correct shape");
                   })))
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        "problem in Same Constructor with rewrite condition " .
                       shows_cc d .
                         shows_nl .
                           shows_string " when switching from " .
                             shows_nl .
                               shows_cc ca .
                                 shows_string " to " .
                                   shows_nl . shows_cc c . shows_nl . x)))
         (\ _ -> check_cc_prf r da f m_ortho c p);
check_cc_prf r da f m_ortho c (Variable_Equation x t d p) =
  let {
    (CC_impl cs _) = normalize_cc c;
  } in bindb (catch_errora
               (bindb
                 (check
                   (membera cs (CC_rewr (Var x) t) ||
                     membera cs (CC_rewr t (Var x)) &&
                       ball (funas_term t) (\ fa -> not (da fa)))
                   (shows_string "could not find " .
                     shows_cc (CC_rewr (Var x) t) .
                       shows_string " or reversed as a premise of " .
                         shows_nl . shows_cc c))
                 (\ _ ->
                   let {
                     ca = cc_subst_apply (fresh_string "xx") c
                            (fun_upd Var x t, vars_term_list t);
                   } in check (check_subsumes (fresh_string "xx") d ca)
                          (shows_string "new constraint is " .
                            shows_cc d .
                              shows_nl .
                                shows_string "but expected was " .
                                  shows_cc ca)))
               (\ xa ->
                 Inl (shows_prec_list Zero_nat
                        "problem in Variable Equation with substitution " .
                       shows_prec_list Zero_nat x .
                         shows_prec_list Zero_nat "/" .
                           shows_prec_term Zero_nat t .
                             shows_string " to switch from" .
                               shows_nl .
                                 shows_cc c .
                                   shows_nl .
                                     shows_string "to" .
                                       shows_nl . shows_cc d . shows_nl . xa)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho ca (Funarg_Into_Var c i x d p) =
  let {
    (CC_impl cs con) = normalize_cc ca;
  } in bindb (catch_errora
               (bindb
                 (check (membera cs c)
                   (shows_cc c .
                     shows_nl .
                       shows_string "is not a premise of " . shows_cc ca))
                 (\ _ ->
                   bindb (check (not (membera (vars_cc_list ca) x))
                           (shows_string "variable " .
                             shows_prec_list Zero_nat x .
                               shows_prec_list Zero_nat " is not fresh"))
                     (\ _ ->
                       (case c of {
                         CC_cond _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list Zero_nat
                                   " is not a rewrite condition of the correct shape");
                         CC_rewr (Var _) _ ->
                           Inl (shows_cc c .
                                 shows_prec_list Zero_nat
                                   " is not a rewrite condition of the correct shape");
                         CC_rewr (Fun fa ss) q ->
                           bindb (check (less_nat i (size_list ss))
                                   (shows_prec_list Zero_nat
                                     "invalid position"))
                             (\ _ ->
                               let {
                                 (bef, (pa, aft)) =
                                   (take i ss,
                                     (nth ss i,
                                       drop (plus_nat i (Nat_of_num One)) ss));
                               } in bindb (catch_errora
    (check_subseteq (funas_term_list pa) f)
    (\ xa ->
      Inl (shows_string "function symbol " .
            shows_prec_prod Zero_nat xa .
              shows_prec_list Zero_nat " is not allowed in argument")))
                                      (\ _ ->
let {
  px = CC_rewr pa (Var x);
  fq = CC_rewr (Fun fa (bef ++ Var x : aft)) q;
  ds = px : fq : cs;
  daa = CC_impl ds con;
} in check (check_subsumes (fresh_string "xx") d daa)
       (shows_string "new constraint is " .
         shows_cc d .
           shows_nl . shows_string "but expected was " . shows_cc daa)));
                         CC_impl _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list Zero_nat
                                   " is not a rewrite condition of the correct shape");
                         CC_all _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list Zero_nat
                                   " is not a rewrite condition of the correct shape");
                       }))))
               (\ xa ->
                 Inl (shows_prec_list Zero_nat
                        "problem in introducing fresh variable " .
                       shows_prec_list Zero_nat x .
                         shows_string " on " .
                           shows_prec_nat Zero_nat
                             (plus_nat i (Nat_of_num One)) .
                             shows_string "-th argument of lhs of " .
                               shows_cc c .
                                 shows_string " to switch from " .
                                   shows_cc ca .
                                     shows_string "to" .
                                       shows_nl . shows_cc d . shows_nl . xa)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho c (Simplify_Condition bc sigma d p) =
  let {
    (CC_impl cs psi) = normalize_cc c;
  } in bindb (catch_errora
               (bindb
                 (check (membera cs bc)
                   (shows_cc bc .
                     shows_nl .
                       shows_string "is not a premise of " . shows_cc c))
                 (\ _ ->
                   let {
                     (ys, cc) = cc_unbound bc;
                     (phi, psia) =
                       let {
                         (CC_impl a b) = normalize_cc cc;
                       } in (a, b);
                     dom_ran = mk_subst_domain sigma;
                   } in bindb (catch_errora
                                (check_subseteq (map fst dom_ran) ys)
                                (\ x ->
                                  Inl (shows_prec_list Zero_nat x .
shows_prec_list Zero_nat
  " is in the domain of sigma, but not a bound variable ")))
                          (\ _ ->
                            bindb (catch_errora
                                    (forallM
                                      (\ fn ->
bindb (check (not (da fn))
        (shows_string "symbol " .
          shows_prec_prod Zero_nat fn .
            shows_prec_list Zero_nat
              " is not allowed in range of sigma, as it is defined"))
  (\ _ ->
    check (membera f fn)
      (shows_string "symbol " .
        shows_prec_prod Zero_nat fn .
          shows_prec_list Zero_nat
            " is not allowed in range of sigma, as it is not in F")))
                                      (concatMap
(\ x_t -> funas_term_list (snd x_t)) dom_ran))
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                let {
                                  vs = remdups
 (concatMap (\ x_t -> vars_term_list (snd x_t)) dom_ran);
                                  sigmaa =
                                    (\ ca ->
                                      cc_subst_apply (fresh_string "xx") ca
(mk_subst Var sigma, vs));
                                } in bindb (catch_errora
     (forallM
       (\ ca ->
         check (any (\ caa ->
                      check_subsumes (fresh_string "xx") caa (sigmaa ca))
                 cs)
           (shows_cc (sigmaa ca) .
             shows_nl .
               shows_prec_list Zero_nat
                 "is not contained as premise of the input implication"))
       phi)
     (\ x -> Inl (snd x)))
                                       (\ _ ->
 let {
   daa = CC_impl (sigmaa psia : cs) psi;
 } in check (check_subsumes (fresh_string "xx") d daa)
        (shows_string "new constraint is " .
          shows_cc d .
            shows_nl . shows_string "but expected was " . shows_cc daa))))))
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        "problem in Simplify Condition with substitution " .
                       shows_prec_list Zero_nat sigma .
                         shows_string " on IH" .
                           shows_nl .
                             shows_cc bc .
                               shows_nl .
                                 shows_string "to switch from" .
                                   shows_nl .
                                     shows_cc c .
                                       shows_nl .
 shows_string "to" . shows_nl . shows_cc d . shows_nl . x)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho c (Induction d ccs ihs) =
  let {
    (CC_impl cs ca) = normalize_cc c;
  } in bindb (catch_errora
               (bindb
                 (check m_ortho
                   (shows_prec_list Zero_nat "CR or minimality required"))
                 (\ _ ->
                   bindb (catch_errora
                           (forallM
                             (\ cc ->
                               check (membera cs cc)
                                 (shows_cc cc .
                                   shows_nl .
                                     shows_string "is not a premise of " .
                                       shows_cc c))
                             (d : ccs))
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       (case d of {
                         CC_cond _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list Zero_nat
                                   " is not a rewrite condition of the correct shape");
                         CC_rewr (Var _) _ ->
                           Inl (shows_cc d .
                                 shows_prec_list Zero_nat
                                   " is not a rewrite condition of the correct shape");
                         CC_rewr (Fun fa xs) q ->
                           let {
                             csa = vars_cc_list
                                     (CC_impl (CC_rewr (Fun fa xs) q : ccs) ca);
                           } in bindb (check
(all is_Var xs && distinct (map the_Var xs))
(shows_prec_list Zero_nat "arguments of " .
  shows_prec_term Zero_nat (Fun fa xs) .
    shows_prec_list Zero_nat " are not different variables"))
                                  (\ _ ->
                                    let {
                                      xsa = map the_Var xs;
                                      rt = root (Fun fa xs);
                                    } in bindb
   (check (is_none (mgu (Fun fa xs) q))
     (shows_prec_list Zero_nat "lhs and rhs unify"))
   (\ _ ->
     bindb (catch_errora
             (forallM
               (\ lr ->
                 check (if root (fst lr) == rt
                         then any (\ lra ->
                                    eq_rule_mod_vars lr lra &&
                                      isOK
(check_disjoint csa (vars_rule_list lra)))
                                (map (\ (ra, _) -> ra) ihs)
                         else True)
                   (shows_prec_list Zero_nat
                      "could not find variable renamed version of rule " .
                     shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                       " -> " lr))
               r)
             (\ x -> Inl (snd x)))
       (\ _ ->
         catch_errora
           (forallM
             (\ (a, b) ->
               let {
                 (l, ra) = a;
               } in (\ (rys, (cc, _)) ->
                      catch_errora
                        (let {
                           cca = cc_rule_constraint (fresh_string "xx") fa
                                   (args l) ra q xsa ccs ca rys;
                         } in bindb (catch_errora
                                      (forallM (check_rys da rt ra) rys)
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  check (check_subsumes (fresh_string "xx") cc
  cca)
                                    (shows_string "new constraint is " .
                                      shows_cc cc .
shows_nl . shows_string "but expected was " . shows_cc cca)))
                        (\ x ->
                          Inl (shows_string "problem in constraint for rule " .
                                shows_rule (shows_prec Zero_nat)
                                  (shows_prec_list Zero_nat) " -> " (l, ra) .
                                  shows_nl . x)))
                 b)
             ihs)
           (\ x -> Inl (snd x)))));
                         CC_impl _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list Zero_nat
                                   " is not a rewrite condition of the correct shape");
                         CC_all _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list Zero_nat
                                   " is not a rewrite condition of the correct shape");
                       }))))
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        "problem in Induction rule with rewrite condition " .
                       shows_cc d .
                         shows_string " to switch from" .
                           shows_nl .
                             shows_cc c .
                               shows_nl .
                                 shows_string "to" .
                                   shows_nl .
                                     shows_list_gen
                                       (\ (_, (_, (cb, _))) ->
 shows_cc cb . shows_nl)
                                       [] [] [] [] ihs .
                                       x)))
         (\ _ ->
           bindb (mapM (\ (_, a) ->
                         let {
                           (_, aa) = a;
                           (ab, b) = aa;
                         } in check_cc_prf r da f m_ortho ab b)
                   ihs)
             (\ fcss -> Inr (concat fcss)));

check_cc_prfs ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ((a, Nat) -> Bool) ->
                      [(a, Nat)] ->
                        Bool ->
                          [(Cond_constraint a [Prelude.Char],
                             (b, Cond_constraint_prf a [Prelude.Char]))] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              [C_constraint a [Prelude.Char]];
check_cc_prfs r d f m_ortho [] = Inr [];
check_cc_prfs r d f m_ortho ((c, (uu, prf)) : cpfs) =
  bindb (check_cc_prf r d f m_ortho c prf)
    (\ l1 -> bindb (check_cc_prfs r d f m_ortho cpfs) (\ l2 -> Inr (l1 ++ l2)));

conditional_general_reduction_pair_proc ::
  forall a b.
    (Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    ([(b, Nat)] -> Non_inf_order_ext b [Prelude.Char] ()) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          Cond_red_pair_prf b [Prelude.Char] ->
                            Bool ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) [a];
conditional_general_reduction_pair_proc i grp pstrict pbound prof merge dpp =
  let {
    (Cond_Red_Pair_Prf c ccs bef aft) = prof;
    p = pairsa i dpp;
    r = rulesd i dpp;
    f = remdups
          (funas_trs_list r ++
            funas_args_trs_list p ++ concatMap funas_term_list (qc i dpp));
    rp = grp f;
  } in (case catch_errora
               (bindb (validb rp)
                 (\ _ ->
                   bindb (check (wwf_rulesa i dpp)
                           (shows_prec_list Zero_nat
                             "require well-formedness of TRS"))
                     (\ _ ->
                       let {
                         is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
                       } in bindb (check_varcond_subset p)
                              (\ _ ->
                                bindb (catch_errora
(forallM
  (\ (l, ra) ->
    bindb (check_no_var l)
      (\ _ -> bindb (check_no_var ra) (\ _ -> check_no_defined_root is_def ra)))
  p)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    let {
                                      ccsa =
map (\ (ca, (uvs, _)) -> (ca, uvs)) ccs;
                                      check_present =
check_constraint_present i dpp c p bef aft ccsa;
                                      (ps, pns) = split_pairsa i dpp pstrict;
                                      (pb, _) = split_pairsa i dpp pbound;
                                      pi = afb rp;
                                      us = usable_rules_gen pi r p;
                                    } in bindb
   (catch_errora (forallM (check_present Strict) ps) (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (catch_errora (forallM (check_present Non_Strict) pns)
             (\ x -> Inl (snd x)))
       (\ _ ->
         bindb (catch_errora (forallM (check_present Bound) pb)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             bindb (check (nFQ_subset_NF_rulesc i dpp)
                     (shows_prec_list Zero_nat "innermost required"))
               (\ _ ->
                 bindb (catch_errora
                         (catch_errora (forallM (nsb rp) us)
                           (\ x -> Inl (snd x)))
                         (\ x ->
                           Inl (shows_string
                                  "problem when orienting usable rules" .
                                 shows_nl . x)))
                   (\ _ ->
                     let {
                       m = minimal i dpp;
                       ortho = isOK (check_weakly_orthogonal r);
                     } in bindb (catch_errora
                                  (check_cc_prfs r
                                    (\ fn -> not (null (rules_mapb i dpp fn))) f
                                    (m || ortho) ccs)
                                  (\ x ->
                                    Inl (shows_string
   "problem when simplifying conditional constraints" .
  shows_nl . x)))
                            (\ fcs ->
                              catch_errora
                                (catch_errora (forallM (cc rp) fcs)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 "problem when orienting final (conditional) constraints for pairs" .
shows_nl . x)))))))))))))
               (\ x ->
                 Inl (shows_string
                        "could not apply the bounded increase processor with the following" .
                       shows_nl . descc rp . shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (if merge
                 then [delete_P_Pwa i dpp (list_inter pstrict pbound)
                         (list_inter pstrict pbound)]
                 else [delete_P_Pwa i dpp pstrict pstrict,
                        delete_P_Pwa i dpp pbound pbound]);
       });

critical_pairs_top_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])];
critical_pairs_top_impl p r =
  concatMap
    (\ (l, ra) ->
      (if is_Var l then []
        else concatMap
               (\ (la, rb) ->
                 (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                         (\ a -> 'y' : a) l la
                   of {
                   Nothing -> [];
                   Just (sigma, tau) ->
                     [(subst_apply_term ra sigma, subst_apply_term rb tau)];
                 }))
               r))
    p;

show_crit_pair ::
  forall a b.
    (Showa a,
      Showa b) => (Term a b, Term a b) -> [Prelude.Char] -> [Prelude.Char];
show_crit_pair lr =
  shows_prec_list Zero_nat "(" .
    shows_prec_term Zero_nat (fst lr) .
      shows_prec_list Zero_nat ", " .
        shows_prec_term Zero_nat (snd lr) . shows_prec_list Zero_nat ")";

check_critical_pairs_innermost ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_innermost r =
  catch_errora
    (forallM
      (\ (l, ra) ->
        check (equal_term l ra)
          (shows_prec_list Zero_nat "there is a non-trivial critical pair " .
            show_crit_pair (l, ra)))
      (critical_pairs_top_impl r r))
    (\ x -> Inl (snd x));

extract_fresh_var ::
  forall a b.
    [((Term a b, Term a b), (Term a b, Term a b))] ->
      Sum ([Prelude.Char] -> [Prelude.Char]) b;
extract_fresh_var sts =
  (case (case sts of {
          [] -> Nothing;
          (_, (Var _, _)) : _ -> Nothing;
          (_, (Fun _ ss, _)) : _ ->
            (if null ss then Nothing
              else (case last ss of {
                     Var a -> Just a;
                     Fun _ _ -> Nothing;
                   }));
        })
    of {
    Nothing ->
      Inl (shows_prec_list Zero_nat
            "could not extract fresh variable (as last argument from some lhs of new pairs)");
    Just a -> Inr a;
  });

extract_ren ::
  forall a b.
    (Eq a) => [((Term a b, Term a b), (Term a b, Term a b))] ->
                Sum ([Prelude.Char] -> [Prelude.Char]) ((a, Nat) -> a);
extract_ren ps_ps =
  bindb (check
          (all (\ (a, b) ->
                 let {
                   (s, t) = a;
                 } in (\ (sa, ta) ->
                        not (is_Var s) &&
                          not (is_Var t) && not (is_Var sa) && not (is_Var ta))
                   b)
            ps_ps)
          (shows_prec_list Zero_nat
            "all lhss and rhss of pairs must be non-variables"))
    (\ _ ->
      let {
        rt = (\ t -> the (root t));
        pair = (\ s sa -> (rt s, fst (rt sa)));
        pairs =
          (\ (st, sta) -> [pair (fst st) (fst sta), pair (snd st) (snd sta)]);
        ren = map_of (remdups (concatMap pairs ps_ps));
        a = (\ fn -> (case ren fn of {
                       Nothing -> fst fn;
                       Just f -> f;
                     }));
      } in Inr a);

check_drop ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> Term b a ->
                         ((b, Nat) -> b) ->
                           ((Term b a, Term b a), (Term b a, Term b a)) ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_drop x c ren st_st =
  let {
    ((s, t), (sa, ta)) = st_st;
    (Fun f ss) = s;
    (Fun g ts) = t;
  } in bindb (check
               (equal_term sa (Fun (ren (f, size_list ss)) (ss ++ [Var x])))
               (shows_prec_list Zero_nat "could not relate " .
                 shows_prec_term Zero_nat s .
                   shows_prec_list Zero_nat " with " .
                     shows_prec_term Zero_nat sa))
         (\ _ ->
           let {
             tsa = args ta;
             tsaa = take (minus_nat (size_list tsa) (Nat_of_num One)) tsa;
           } in check (equal_term ta
                         (Fun (ren (g, size_list ts)) (tsaa ++ [Var x])) &&
                        ts == map (\ tb -> subst_apply_term tb (subst x c))
                                tsaa)
                  (shows_prec_list Zero_nat "could not relate " .
                    shows_prec_term Zero_nat t .
                      shows_prec_list Zero_nat " with " .
                        shows_prec_term Zero_nat ta));

rwc :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = rw;

pwa :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pwa (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = pw;

rc :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = r;

pa :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pa (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = p;

is_NF_trs ::
  forall a b c.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, c)] -> Term a b -> Bool;
is_NF_trs r =
  is_NF_main (any (\ ra -> is_Var (fst ra)) r) (null r) (term_map (map fst r));

complex_constant_removal_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Complex_constant_removal_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
complex_constant_removal_proc i (Complex_Constant_Removal_Proof c ps) dpp =
  catch_errora
    (let {
       p = pa i dpp;
       pw = pwa i dpp;
       r = rwc i dpp;
       q = qc i dpp;
       pairs = pairsa i dpp;
     } in bindb (extract_fresh_var ps)
            (\ x ->
              bindb (extract_ren ps)
                (\ ren ->
                  let {
                    is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
                    rQs = remdups (map root q);
                  } in bindb (catch_errora
                               (forallM
                                 (\ (s, t) ->
                                   bindb (check_no_var s)
                                     (\ _ ->
                                       bindb (check_no_var t)
 (\ _ ->
   bindb (check_no_defined_root is_def t)
     (\ _ ->
       bindb (check (not (membera (vars_rule_list (s, t)) x))
               (shows_prec_list Zero_nat x .
                 shows_prec_list Zero_nat " is not fresh for pair " .
                   shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                     " -> " (s, t)))
         (\ _ ->
           let {
             f = the (root s);
             fa = (ren f, plus_nat (snd f) (Nat_of_num One));
           } in bindb (check (not (membera rQs (Just fa)))
                        (shows_prec_list Zero_nat
                          "renaming delivers defined symbol of Q"))
                  (\ _ ->
                    check (not (is_def fa))
                      (shows_prec_list Zero_nat
                        "renaming delivers defined symbol of R")))))))
                                 pairs)
                               (\ xa -> Inl (snd xa)))
                         (\ _ ->
                           let {
                             pps = filter (\ st_st -> membera p (fst st_st)) ps;
                             pwps =
                               filter (\ st_st -> membera pw (fst st_st)) ps;
                           } in bindb (catch_errora
(forallM
  (\ st ->
    check (membera (map fst pps) st)
      (shows_prec_list Zero_nat "could not find entry for pair " .
        shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " st))
  p)
(\ xa -> Inl (snd xa)))
                                  (\ _ ->
                                    bindb (catch_errora
    (forallM
      (\ st ->
        check (membera (map fst pwps) st)
          (shows_prec_list Zero_nat "could not find entry for pair " .
            shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> "
              st))
      pw)
    (\ xa -> Inl (snd xa)))
                                      (\ _ ->
bindb (check (ground c)
        (shows_prec_list Zero_nat "the term " .
          shows_prec_term Zero_nat c .
            shows_prec_list Zero_nat " is not ground"))
  (\ _ ->
    bindb (check (nFQ_subset_NF_rulesc i dpp)
            (shows_prec_list Zero_nat "innermost required"))
      (\ _ ->
        bindb (check (null (rc i dpp))
                (shows_prec_list Zero_nat "strict rules not allowed"))
          (\ _ ->
            bindb (check (rules_no_left_vara i dpp)
                    (shows_prec_list Zero_nat
                      "rules may not have variables as lhss"))
              (\ _ ->
                bindb (if is_NF_trs r c then Inr ()
                        else catch_errora (check_critical_pairs_innermost r)
                               (\ xa ->
                                 Inl (shows_prec_list Zero_nat
"could not ensure confluence" .
                                       shows_nl . xa)))
                  (\ _ ->
                    bindb (catch_errora
                            (forallM
                              (\ st_st ->
                                catch_errora (check_drop x c ren st_st)
                                  (\ xa ->
                                    Inl (shows_prec_list Zero_nat
   "problem in finding correspondence between rule " .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> "
    (fst st_st) .
    shows_prec_list Zero_nat " and rule " .
      shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> "
        (snd st_st) .
        shows_nl . xa)))
                              ps)
                            (\ xa -> Inl (snd xa)))
                      (\ _ ->
                        Inr (mkc i (nfsc i dpp) (minimal i dpp) (map snd pps)
                              (map snd pwps) q [] r)))))))))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "problem in complex constant removal proc: " .
            shows_nl . x));

fun_of_default :: forall a b. (Eq a) => [(a, b)] -> b -> a -> b;
fun_of_default m d =
  let {
    mm = map_of m;
  } in (\ i -> (case mm i of {
                 Nothing -> d;
                 Just e -> e;
               }));

get_arg :: forall a b. Term a b -> Nat -> Term a b;
get_arg t n =
  (if equal_nat n Zero_nat then t
    else nth (args t) (minus_nat n (Nat_of_num One)));

iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops ::
  forall a b.
    (Linorder a) => Rbt a () -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s =
  (\ c f -> rm_iterateoi (impl_of s) c (f . fst));

g_ball_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> (a -> Bool) -> Bool;
g_ball_dflt_basic_oops_rm_basic_ops s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ c -> c)
    (\ x _ -> p x) True;

subtract_list_sorted :: forall a. (Eq a, Linorder a) => [a] -> [a] -> [a];
subtract_list_sorted (x : xs) (y : ys) =
  (if x == y then subtract_list_sorted xs (y : ys)
    else (if less x y then x : subtract_list_sorted xs (y : ys)
           else subtract_list_sorted (x : xs) ys));
subtract_list_sorted [] ys = [];
subtract_list_sorted (v : va) [] = v : va;

comp :: forall a. (Eq a, Linorder a) => [(a, a)] -> [(a, a)] -> [(a, a)];
comp esa es =
  remdups_sort
    (concatMap
      (\ (x, y) ->
        concatMap (\ (ya, z) -> (if y == ya then [(x, z)] else [])) es)
      esa);

scg_comp ::
  forall a b.
    (Eq b, Linorder b) => (a -> a -> Bool) -> Scg a b -> Scg a b -> Scg a b;
scg_comp conn (Scg pa qa stra wka) (Scg p q str wk) =
  (if not (conn qa p) then Null
    else let {
           strs = remdups_sort (comp stra str ++ comp stra wk ++ comp wka str);
           a = subtract_list_sorted (remdups_sort (comp wka wk)) strs;
         } in Scg pa q strs a);
scg_comp conn Null g = Null;
scg_comp conn (Scg v va vb vc) Null = Null;

generate_scgs ::
  forall a b.
    (Eq a, Eq b,
      Linorder b) => (a -> a -> Bool) -> [Scg a b] -> Scg a b -> [Scg a b];
generate_scgs conn base g =
  filter (\ ga -> not (equal_scg ga Null)) (map (scg_comp conn g) base);

subsumes :: forall a b. (Eq a, Eq b) => Scg a b -> Scg a b -> Bool;
subsumes (Scg pa qa stra wka) (Scg p q str wk) =
  pa == p && qa == q && all (membera str) stra && all (membera (str ++ wk)) wka;
subsumes g Null = True;
subsumes Null (Scg v va vb vc) = False;

in_situ :: forall a b. (Eq b) => Scg a b -> Bool;
in_situ Null = True;
in_situ (Scg p q str wk) = any (\ (a, b) -> a == b) str;

union_list_sorted :: forall a. (Eq a, Ord a) => [a] -> [a] -> [a];
union_list_sorted (x : xs) (y : ys) =
  (if x == y then x : union_list_sorted xs ys
    else (if less x y then x : union_list_sorted xs (y : ys)
           else y : union_list_sorted (x : xs) ys));
union_list_sorted [] ys = ys;
union_list_sorted (v : va) [] = v : va;

combinea :: forall a b. (Eq b, Linorder b) => Scg a b -> Scg a b -> Scg a b;
combinea (Scg pa qa stra wka) (Scg p q str wk) =
  Scg pa qa (union_list_sorted stra str) (union_list_sorted wka wk);
combinea Null s = Null;
combinea (Scg v va vb vc) Null = Null;

sagiv ::
  forall a b. (Eq a, Eq b, Linorder b) => (a -> a -> Bool) -> Scg a b -> Bool;
sagiv conn g =
  (if in_situ g then True
    else let {
           gg = scg_comp conn g g;
         } in (if subsumes gg g then False else sagiv conn (combinea g gg)));

check_SCT ::
  forall a b.
    (Compare_order a, Eq a, Compare_order b,
      Eq b) => (a -> a -> Bool) -> [Scg a b] -> Bool;
check_SCT conn gs =
  g_ball_dflt_basic_oops_rm_basic_ops
    (mk_rtrancl_set (generate_scgs conn gs) gs) (sagiv conn);

sct_subterm_precise_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_precise_proc i gs dpp =
  catch_errora
    (let {
       p = pairsa i dpp;
       is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
       eidg = is_iedg_edge_dpp i dpp;
     } in bindb (catch_errora (check_subseteq p (map fst gs))
                  (\ x ->
                    Inl (shows_string
                           "there is no size-change graph for the pair " .
                          shows_rule (shows_prec Zero_nat)
                            (shows_prec_list Zero_nat) " -> " x)))
            (\ _ ->
              let {
                gGs = filter (\ g -> membera p (fst g)) gs;
              } in bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                           (shows_prec_list Zero_nat
                             "minimality or innermost required"))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulesd i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ (a, b) ->
                                       let {
 (s, t) = a;
                                       } in
 (\ (stri, nstri) ->
   catch_errora
     (bindb (check_no_var s)
       (\ _ ->
         bindb (check_no_var t)
           (\ _ ->
             bindb (check_no_defined_root is_def t)
               (\ _ ->
                 let {
                   m = size_list (args t);
                   n = size_list (args s);
                 } in bindb (catch_errora
                              (forallM
                                (\ (ia, j) ->
                                  check (less_eq_nat ia n &&
  less_eq_nat j m && isOK (check_supt (get_arg s ia) (get_arg t j)))
                                    (shows_string "problem with edge " .
                                      shows_prec_nat Zero_nat ia .
shows_string " |> " . shows_prec_nat Zero_nat j . shows_nl))
                                stri)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          catch_errora
                            (forallM
                              (\ (ia, j) ->
                                check (less_eq_nat ia n &&
less_eq_nat j m && isOK (check_supteq (get_arg s ia) (get_arg t j)))
                                  (shows_string "problem with edge " .
                                    shows_prec_nat Zero_nat ia .
                                      shows_string " |>= " .
shows_prec_nat Zero_nat j . shows_nl))
                              nstri)
                            (\ x -> Inl (snd x)))))))
     (\ x ->
       Inl (shows_string "problem with pair " .
             shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> "
               (s, t) .
               shows_nl . x)))
 b)
                                     gGs)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               let {
                                 n = size_list p;
                                 nums = upt Zero_nat n;
                                 numPs = zip p nums;
                                 num_of = fun_of_default numPs n;
                               } in check (check_SCT
    (\ (_, succs) (uv, _) -> membera succs uv)
    (map (\ (st, (stri, nstri)) ->
           let {
             eidg_st = eidg st;
             ia = num_of st;
             e = (ia, map_filter
                        (\ x ->
                          (if ((eidg_st . fst) . fst) x then Just (snd x)
                            else Nothing))
                        numPs);
           } in Scg e e (remdups_sort stri) (remdups_sort nstri))
      gGs))
                                      (shows_string
 "size-change analysis failed" .
shows_nl))))))
    (\ x ->
      Inl (shows_string
             "could not apply the size-change processor based on the subterm-relation" .
            shows_nl . x));

sct_subterm_approx_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_approx_proc i gs dpp =
  catch_errora
    (let {
       p = pairsa i dpp;
       is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
     } in bindb (catch_errora (check_subseteq p (map fst gs))
                  (\ x ->
                    Inl (shows_string
                           "there is no size-change graph for the pair " .
                          shows_rule (shows_prec Zero_nat)
                            (shows_prec_list Zero_nat) " -> " x)))
            (\ _ ->
              let {
                gGs = filter (\ g -> membera p (fst g)) gs;
              } in bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                           (shows_prec_list Zero_nat
                             "minimality or innermost required"))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulesd i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ (a, b) ->
                                       let {
 (s, t) = a;
                                       } in
 (\ (stri, nstri) ->
   catch_errora
     (bindb (check_no_var s)
       (\ _ ->
         bindb (check_no_var t)
           (\ _ ->
             bindb (check_no_defined_root is_def t)
               (\ _ ->
                 let {
                   m = size_list (args t);
                   n = size_list (args s);
                 } in bindb (catch_errora
                              (forallM
                                (\ (ia, j) ->
                                  check (less_eq_nat ia n &&
  less_eq_nat j m && isOK (check_supt (get_arg s ia) (get_arg t j)))
                                    (shows_string "problem with edge " .
                                      shows_prec_nat Zero_nat ia .
shows_string " |> " . shows_prec_nat Zero_nat j . shows_nl))
                                stri)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          catch_errora
                            (forallM
                              (\ (ia, j) ->
                                check (less_eq_nat ia n &&
less_eq_nat j m && isOK (check_supteq (get_arg s ia) (get_arg t j)))
                                  (shows_string "problem with edge " .
                                    shows_prec_nat Zero_nat ia .
                                      shows_string " |>= " .
shows_prec_nat Zero_nat j . shows_nl))
                              nstri)
                            (\ x -> Inl (snd x)))))))
     (\ x ->
       Inl (shows_string "problem with pair " .
             shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> "
               (s, t) .
               shows_nl . x)))
 b)
                                     gGs)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               check (check_SCT (\ (_, g) (h, _) -> g == h)
                                       (remdups
 (map (\ (st, (stri, nstri)) ->
        let {
          e = (the (root (fst st)), the (root (snd st)));
        } in Scg e e (remdups_sort stri) (remdups_sort nstri))
   gGs)))
                                 (shows_string "size-change analysis failed" .
                                   shows_nl))))))
    (\ x ->
      Inl (shows_string
             "could not apply the size-change processor based on the subterm-relation" .
            shows_nl . x));

sct_subterm_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_proc i gs dpp =
  (if isOK (sct_subterm_approx_proc i gs dpp) then Inr ()
    else sct_subterm_precise_proc i gs dpp);

sct_entry_to_sts ::
  forall a b c d. a -> Term b c -> [(d, Nat)] -> [(d, Nat)] -> [(a, Term b c)];
sct_entry_to_sts s t stri nstri =
  let {
    a = remdups (map snd (stri ++ nstri));
  } in map (\ j -> (s, get_arg t j)) a;

check_sct_entry ::
  forall a b c d e f.
    (Showa a,
      Showa b) => ((a, Nat) -> Bool) ->
                    ((Term a b, Term a b) -> Sum c d) ->
                      ((Term a b, Term a b) -> Sum e f) ->
                        Term a b ->
                          Term a b ->
                            [(Nat, Nat)] ->
                              [(Nat, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sct_entry is_def sa nst s t stri nstri =
  catch_errora
    (bindb (check_no_var s)
      (\ _ ->
        bindb (check_no_var t)
          (\ _ ->
            bindb (check_no_defined_root is_def t)
              (\ _ ->
                let {
                  m = size_list (args t);
                  n = size_list (args s);
                } in bindb (catch_errora
                             (forallM
                               (\ i ->
                                 check (less_eq_nat i n)
                                   (shows_string "left-index to large" .
                                     shows_prec_nat Zero_nat i . shows_nl))
                               (remdups (map fst (stri ++ nstri))))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM
                                   (\ j ->
                                     check (less_eq_nat j m)
                                       (shows_string
  "right-index to large or argument violates usable-rules condition" .
 shows_prec_nat Zero_nat j))
                                   (remdups (map snd (stri ++ nstri))))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             let {
                               _ = args s;
                               _ = args t;
                             } in bindb (catch_errora
  (forallM
    (\ (i, j) ->
      check (isOK (sa (get_arg s i, get_arg t j)))
        (shows_string "problem with edge " .
          shows_prec_nat Zero_nat i .
            shows_string " -S-> " . shows_prec_nat Zero_nat j))
    stri)
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      catch_errora
(forallM
  (\ (i, j) ->
    check (isOK (nst (get_arg s i, get_arg t j)))
      (shows_string "problem with edge " .
        shows_prec_nat Zero_nat i .
          shows_string " -NS-> " . shows_prec_nat Zero_nat j))
  nstri)
(\ x -> Inl (snd x)))))))))
    (\ x ->
      Inl (shows_string "problems with DP " .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
              (s, t) .
              shows_nl . x));

sct_ur_af_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [((Term b [Prelude.Char], Term b [Prelude.Char]),
                         ([(Nat, Nat)], [(Nat, Nat)]))] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_ur_af_proc i rp gs u_opt dpp =
  catch_errora
    (bindb (valid rp)
      (\ _ ->
        let {
          is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
          pi = af rp;
          sa = s rp;
          nsa = ns rp;
          nsta = nst rp;
          p = pairsa i dpp;
          gGs = filter (\ g -> membera p (fst g)) gs;
        } in bindb (catch_errora
                     (forallM (\ (l, _) -> check_no_var l) (rulesd i dpp))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (catch_errora
                         (forallM
                           (\ (a, b) ->
                             let {
                               (saa, t) = a;
                             } in (\ (aa, ba) ->
                                    check_sct_entry is_def sa nsta saa t aa ba)
                               b)
                           gGs)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     let {
                       sts = concatMap
                               (\ (a, b) ->
                                 let {
                                   (sb, t) = a;
                                 } in (\ (aa, ba) ->
sct_entry_to_sts sb t aa ba)
                                   b)
                               gGs;
                     } in bindb (smart_usable_rules_checker_impl i dpp pi u_opt
                                  sts)
                            (\ u ->
                              bindb (catch_errora
                                      (catch_errora (forallM nsa u)
(\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string "problem when orienting usable rules" . shows_nl . x)))
                                (\ _ ->
                                  let {
                                    eidg = is_iedg_edge_dpp i dpp;
                                  } in bindb
 (catch_errora (check_subseteq p (map fst gs))
   (\ x ->
     Inl (shows_string "there is no size-change graph for DP " .
           shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> "
             x)))
 (\ _ ->
   let {
     n = size_list p;
     nums = upt Zero_nat n;
     numPs = zip p nums;
     num_of = fun_of_default numPs n;
   } in check (check_SCT (\ (_, succs) (uv, _) -> membera succs uv)
                (map (\ (st, (stri, nstri)) ->
                       let {
                         eidg_st = eidg st;
                         ia = num_of st;
                         e = (ia, map_filter
                                    (\ x ->
                                      (if ((eidg_st . fst) . fst) x
then Just (snd x) else Nothing))
                                    numPs);
                       } in Scg e e stri nstri)
                  gGs))
          (shows_string "size-change analysis failed" . shows_nl))))))))
    (\ x ->
      Inl (shows_string
             "could not apply the size-change processor with the following " .
            shows_nl .
              desc rp .
                shows_nl .
                  shows_string "for the following reason" . shows_nl . x));

filter_prec_weight_repr ::
  forall a.
    ((a, Nat) -> Af_entry) ->
      ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
        ([((Filtered a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat);
filter_prec_weight_repr pi (prw, w0) =
  let {
    fprw =
      filter
        (\ (fn, _) ->
          (case pi fn of {
            Collapse _ -> False;
            AFList _ -> True;
          }))
        prw;
    mprw =
      map (\ (a, b) ->
            let {
              (f, n) = a;
            } in (\ aa ->
                   ((FPair f n,
                      (case pi (f, n) of {
                        Collapse _ -> Zero_nat;
                        AFList ab -> size_list ab;
                      })),
                     aa))
              b)
        fprw;
  } in (mprw, w0);

prec_repr_to_status ::
  forall a.
    (Key a) => [((a, Nat), (Nat, Order_tag))] -> (Filtered a, Nat) -> Order_tag;
prec_repr_to_status prs =
  let {
    m = ceta_map_of prs;
  } in (\ (FPair f a, _) ->
         (case m (f, a) of {
           Nothing -> Lex;
           Just aa -> snd aa;
         }));

prec_repr_to_pr ::
  forall a.
    (Key a) => [((a, Nat), (Nat, Order_tag))] -> (Filtered a, Nat) -> Nat;
prec_repr_to_pr prs =
  let {
    m = ceta_map_of prs;
  } in (\ (FPair f a, _) ->
         (case m (f, a) of {
           Nothing -> Zero_nat;
           Just aa -> fst aa;
         }));

plus_single_mono ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      Bool;
plus_single_mono
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = plus_single_mono;

maxa ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      a -> a -> a;
maxa (Partial_object_ext carrier
       (Monoid_ext mult one
         (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = max;

geq ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      a -> a -> Bool;
geq (Partial_object_ext carrier
      (Monoid_ext mult one
        (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = geq;

poly_c_max_inter_bcoeff ::
  forall a b c.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      [(c, Nat)] -> ((c, Nat) -> (a, [a])) -> a;
poly_c_max_inter_bcoeff r f pi =
  foldr (maxa r)
    (concatMap (\ fn -> filter (\ b -> not (geq r (one r) b)) (snd (pi fn))) f)
    (zero r);

derive_complexity ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
derive_complexity
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = derive_complexity;

smaller_one_complexity ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
smaller_one_complexity r bc =
  (if geq r (one r) bc then Inr Zero_nat else derive_complexity r bc);

convert_lpoly_complexity ::
  forall a b c d.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      ((c, Nat) -> (a, [a])) ->
        Complexity_measure c d ->
          Sum ([Prelude.Char] -> [Prelude.Char]) Complexity_class;
convert_lpoly_complexity r pi cc =
  let {
    f = (case cc of {
          Derivational_Complexity f -> f;
          Runtime_Complexity c _ -> c;
        });
    bc = poly_c_max_inter_bcoeff r f pi;
  } in map_sum (\ x -> x) (\ deg -> Comp_Poly (plus_nat deg (Nat_of_num One)))
         (smaller_one_complexity r bc);

check_poly_mono_npsm ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [(c, Nat)] ->
                      [((c, Nat), (a, [a]))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_poly_mono_npsm r f pi =
  bindb (catch_errora
          (forallM
            (\ (a, b) ->
              let {
                (fa, n) = a;
              } in (\ (c, cs) ->
                     catch_errora
                       (bindb
                         (check
                           (if equal_nat n (plus_nat Zero_nat (Nat_of_num One))
                             then c == zero r else True)
                           (shows_string "constant part " .
                             shows_prec Zero_nat c .
                               shows_string " must be 0 " . shows_nl))
                         (\ _ ->
                           bindb (check (equal_nat n (size_list cs))
                                   (shows_string
                                      "the arity is not the same as the number of arguments" .
                                     shows_nl))
                             (\ _ ->
                               check (less_eq_nat n
                                       (plus_nat Zero_nat (Nat_of_num One)))
                                 (shows_string
                                    "symbol has arity larger than 1" .
                                   shows_nl))))
                       (\ x ->
                         Inl (shows_string
                                "problem with monotonicity due to interpretation of " .
                               shows_prec Zero_nat fa .
                                 shows_string "/" .
                                   shows_prec_nat Zero_nat n . shows_nl . x)))
                b)
            pi)
          (\ x -> Inl (snd x)))
    (\ _ ->
      catch_errora (check_subseteq f (map fst pi))
        (\ x ->
          Inl (shows_string "unknown interpretation for " .
                shows_prec_prod Zero_nat x . shows_nl)));

arcpos ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Bool;
arcpos
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = arcpos;

carrier :: forall a b. Partial_object_ext a b -> Set a;
carrier (Partial_object_ext carrier more) = carrier;

check_lpoly_coeffs ::
  forall a b c.
    (Ceq a, Ccompare a, Showa a,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [((c, Nat), (a, [a]))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_coeffs r i =
  catch_errora
    (forallM
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ (c, cs) ->
               catch_errora
                 (bindb
                   (check (member c (carrier r))
                     (shows_string "constant part " .
                       shows_prec Zero_nat c .
                         shows_string " is not well-formed" . shows_nl))
                   (\ _ ->
                     bindb (check (less_eq_nat (size_list cs) n)
                             (shows_string
                                "number of coefficients exceeds arity of symbol " .
                               shows_prec Zero_nat f))
                       (\ _ ->
                         bindb (check (arcpos r c || any (arcpos r) cs)
                                 (shows_string
                                    "could not find positive entry which is required for arctic interpretations" .
                                   shows_nl))
                           (\ _ ->
                             catch_errora
                               (forallM
                                 (\ aa ->
                                   check (geq r aa (zero r) &&
   member aa (carrier r))
                                     (shows_string "coefficient " .
                                       shows_prec Zero_nat aa .
 shows_string " is not allowed" . shows_nl))
                                 cs)
                               (\ x -> Inl (snd x))))))
                 (\ x ->
                   Inl (shows_string "problem with interpretation of " .
                         shows_prec Zero_nat f .
                           shows_string "/" .
                             shows_prec_nat Zero_nat n . shows_nl . x)))
          b)
      i)
    (\ x -> Inl (snd x));

description ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      [Prelude.Char];
description
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = description;

defaultb ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a;
defaultb
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = defaulta;

to_lpoly_inter ::
  forall a b c.
    (Key c) => Partial_object_ext a
                 (Monoid_ext a
                   (Ring_ext a
                     (Ordered_semiring_ext a
                       (Lpoly_order_semiring_ext a b)))) ->
                 [((c, Nat), (a, [a]))] -> (c, Nat) -> (a, [a]);
to_lpoly_inter r i =
  fun_of_map_fun (ceta_map_of i)
    (\ fn -> (defaultb r, replicate (snd fn) (one r)));

show_pvars ::
  forall a b c.
    (Eq a, Showa a,
      Showa c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                    [(c, a)] -> [[Prelude.Char]];
show_pvars r [] = [];
show_pvars r ((x, c) : vas) =
  (if c == one r then id else shows_prec Zero_nat c)
    (shows_prec Zero_nat x []) :
    show_pvars r vas;

shows_lpoly ::
  forall a b c.
    (Eq a, Showa a,
      Showa c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                    L_poly c a -> [Prelude.Char] -> [Prelude.Char];
shows_lpoly r (LPoly c cs) =
  (case show_pvars r cs of {
    [] -> shows_prec Zero_nat c;
    a : list ->
      (if c == zero r then id else shows_prec Zero_nat c . shows_string " + ") .
        shows_list_gen (shows_prec_list Zero_nat) [] [] " + " [] (a : list);
  });

add_var ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 c -> a -> [(c, a)] -> [(c, a)];
add_var r x a [] = [(x, a)];
add_var r x a ((y, b) : vas) =
  (if x == y
    then let {
           s = add r a b;
         } in (if s == zero r then vas else (x, s) : vas)
    else (y, b) : add_var r x a vas);

sum_pvars ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 [(c, a)] -> [(c, a)] -> [(c, a)];
sum_pvars r [] vbs = vbs;
sum_pvars r ((x, a) : vas) vbs =
  (if a == zero r then sum_pvars r vas vbs
    else sum_pvars r vas (add_var r x a vbs));

sum_lpolya ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 L_poly c a -> L_poly c a -> L_poly c a;
sum_lpolya r (LPoly a vas) (LPoly b vbs) =
  LPoly (add r a b) (sum_pvars r vas vbs);

mul_pvars ::
  forall a b c.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                a -> [(c, a)] -> [(c, a)];
mul_pvars r a [] = [];
mul_pvars r a ((x, b) : vas) =
  let {
    p = mult r a b;
    res = mul_pvars r a vas;
  } in (if p == zero r then res else (x, p) : res);

mul_lpoly ::
  forall a b c.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                a -> L_poly c a -> L_poly c a;
mul_lpoly r a (LPoly b vas) = LPoly (mult r a b) (mul_pvars r a vas);

list_prod :: forall a b. Partial_object_ext a (Monoid_ext a b) -> [a] -> a;
list_prod r [] = one r;
list_prod r (x : xs) = mult r x (list_prod r xs);

wf_pvars ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Partial_object_ext a b -> [(c, a)] -> Bool;
wf_pvars r vas = less_eq_set (set (map snd vas)) (carrier r);

wf_lpoly ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Partial_object_ext a b -> L_poly c a -> Bool;
wf_lpoly r (LPoly a vas) = member a (carrier r) && wf_pvars r vas;

pleftI ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq d) => Partial_object_ext a
                 (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                 ((c, Nat) -> (a, [a])) -> Term c d -> L_poly d a;
pleftI r pi (Var x) = LPoly (zero r) [(x, one r)];
pleftI r pi (Fun f ts) =
  let {
    (c, asa) = pi (f, size_list ts);
  } in (case sum_lpolya r (LPoly c [])
               (list_prod
                 (Partial_object_ext (collect (wf_lpoly r))
                   (Monoid_ext (sum_lpolya r) (LPoly (zero r) []) ()))
                 (map (\ at -> mul_lpoly r (fst at) (pleftI r pi (snd at)))
                   (zip asa ts)))
         of {
         LPoly d [] -> LPoly (maxa r (zero r) d) [];
         LPoly d (ab : lista) -> LPoly d (ab : lista);
       });

create_lpoly_repr ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b, Key b,
      Showa b) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a ())))) ->
                    [((b, Nat), (a, [a]))] -> [Prelude.Char] -> [Prelude.Char];
create_lpoly_repr c i =
  let {
    pi = to_lpoly_inter c i;
  } in shows_string "polynomial interpretration over " .
         shows_string (description c) .
           shows_nl .
             shows_sep
               (\ (f, n) ->
                 let {
                   t = Fun f (map Var
                               (fresh_strings_list "x_" (Nat_of_num One) [] n));
                 } in shows_string "Pol(" .
                        shows_prec_term Zero_nat t .
                          shows_string ") = " . shows_lpoly c (pleftI c pi t))
               shows_nl (remdups (map fst i));

checkmono ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Bool;
checkmono
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = checkmono;

check_poly_mono ::
  forall a b c.
    (Showa a,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [((c, Nat), (a, [a]))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_poly_mono r =
  (\ xs ->
    catch_errora
      (forallM
        (\ (a, b) ->
          let {
            (f, n) = a;
          } in (\ (c, cs) ->
                 catch_errora
                   (bindb
                     (check (geq r c (zero r))
                       (shows_string "constant part " .
                         shows_prec Zero_nat c .
                           shows_string " must be at least " .
                             shows_prec Zero_nat (zero r) . shows_nl))
                     (\ _ ->
                       bindb (check (less_eq_nat n (size_list cs))
                               (shows_string "the last argument is ignored" .
                                 shows_nl))
                         (\ _ ->
                           catch_errora
                             (forallM
                               (\ d ->
                                 check (checkmono r d)
                                   (shows_string "coefficient " .
                                     shows_prec Zero_nat d .
                                       shows_string " is not allowed" .
 shows_nl))
                               cs)
                             (\ x -> Inl (snd x)))))
                   (\ x ->
                     Inl (shows_string
                            "problem with monotonicity due to interpretation of " .
                           shows_prec Zero_nat f .
                             shows_string "/" .
                               shows_prec_nat Zero_nat n . shows_nl . x)))
            b)
        xs)
      (\ x -> Inl (snd x)));

create_mono_af ::
  forall a b c.
    (Eq a,
      Key c) => Partial_object_ext a
                  (Monoid_ext a
                    (Ring_ext a
                      (Ordered_semiring_ext a
                        (Lpoly_order_semiring_ext a b)))) ->
                  [((c, Nat), (a, [a]))] -> (c, Nat) -> Set Nat;
create_mono_af r i =
  (if plus_single_mono r
    then fun_of_map_funa (ceta_map_of i) (\ (_, n) -> set (upt Zero_nat n))
           (\ (c, coeffs) ->
             set (if geq r c (zero r)
                   then concatMap
                          (\ (ca, ia) ->
                            (if ca == one r || checkmono r ca then [ia]
                              else []))
                          (zip coeffs (upt Zero_nat (size_list coeffs)))
                   else []))
    else empty_af);

lookup_rest :: forall a b. (Eq a) => a -> [(a, b)] -> Maybe (b, [(a, b)]);
lookup_rest x [] = Nothing;
lookup_rest x ((y, c) : ycs) =
  (if x == y then Just (c, ycs)
    else (case lookup_rest x ycs of {
           Nothing -> Nothing;
           Just (d, yccs) -> Just (d, (y, c) : yccs);
         }));

check_pvars ::
  forall a b c.
    (Showa a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 (a -> a -> Bool) -> [(c, a)] -> [(c, a)] -> Sum c ();
check_pvars r rel vas [] =
  catch_errora (forallM (\ va -> check (rel (snd va) (zero r)) (fst va)) vas)
    (\ x -> Inl (snd x));
check_pvars r rel vas ((x, b) : vbs) =
  let {
    a = (case lookup_rest x vas of {
          Nothing -> (zero r, vas);
          Just a -> let {
                      (aa, ba) = a;
                    } in (aa, ba);
        });
    (aa, vasa) = a;
  } in bindb (check (rel aa b) x) (\ _ -> check_pvars r rel vasa vbs);

check_lpoly_ns ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                    L_poly c a ->
                      L_poly c a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_ns r (LPoly a vas) (LPoly b vbs) =
  catch_errora
    (bindb
      (check (geq r a b) (shows_string "problem when comparing constant parts"))
      (\ _ ->
        catch_errora (check_pvars r (geq r) vas vbs)
          (\ x ->
            Inl (shows_string
                   "problem when comparing coefficients of variable " .
                  shows_prec Zero_nat x))))
    (\ x ->
      Inl (shows_string "problem when comparing " .
            shows_lpoly r (LPoly a vas) .
              shows_string " >= " .
                shows_lpoly r (LPoly b vbs) . shows_nl . x));

prightI ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a,
      Eq d) => Partial_object_ext a
                 (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                 ((c, Nat) -> (a, [a])) -> Term c d -> L_poly d a;
prightI r pi (Var x) = LPoly (zero r) [(x, one r)];
prightI r pi (Fun f ts) =
  let {
    (c, asa) = pi (f, size_list ts);
    (LPoly d a) =
      sum_lpolya r (LPoly c [])
        (list_prod
          (Partial_object_ext (collect (wf_lpoly r))
            (Monoid_ext (sum_lpolya r) (LPoly (zero r) []) ()))
          (map (\ at -> mul_lpoly r (fst at) (prightI r pi (snd at)))
            (zip asa ts)));
  } in LPoly (maxa r (zero r) d) a;

check_polo_ns ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Showa c, Eq d,
      Showa d) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    ((c, Nat) -> (a, [a])) ->
                      (Term c d, Term c d) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_polo_ns r pi (s, t) =
  let {
    left = pleftI r pi s;
    right = prightI r pi t;
  } in catch_errora (check_lpoly_ns r left right)
         (\ x ->
           Inl (shows_string "could not ensure " .
                 shows_prec_term Zero_nat s .
                   shows_string " >= " .
                     shows_prec_term Zero_nat t . shows_nl . x));

gt :: forall a b.
        Partial_object_ext a
          (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
          a -> a -> Bool;
gt (Partial_object_ext carrier
     (Monoid_ext mult one
       (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = gt;

check_lpoly_s ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    L_poly c a ->
                      L_poly c a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_s r (LPoly a vas) (LPoly b vbs) =
  catch_errora
    (bindb
      (check (gt r a b) (shows_string "problem when comparing constant part"))
      (\ _ ->
        catch_errora
          (check_pvars r (if plus_single_mono r then geq r else gt r) vas vbs)
          (\ x ->
            Inl (shows_string
                   "problem when comparing coefficients of variable " .
                  shows_prec Zero_nat x))))
    (\ x ->
      Inl (shows_string "problem when comparing " .
            shows_lpoly r (LPoly a vas) .
              shows_string " > " . shows_lpoly r (LPoly b vbs) . shows_nl . x));

check_polo_s ::
  forall a b c d.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Showa c, Eq d,
      Showa d) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    ((c, Nat) -> (a, [a])) ->
                      (Term c d, Term c d) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_polo_s r pi (s, t) =
  let {
    left = pleftI r pi s;
    right = prightI r pi t;
  } in catch_errora (check_lpoly_s r left right)
         (\ x ->
           Inl (shows_string "could not ensure " .
                 shows_prec_term Zero_nat s .
                   shows_string " > " .
                     shows_prec_term Zero_nat t . shows_nl . x));

create_af ::
  forall a b c.
    (Eq a,
      Key c) => Partial_object_ext a
                  (Monoid_ext a
                    (Ring_ext a
                      (Ordered_semiring_ext a
                        (Lpoly_order_semiring_ext a b)))) ->
                  [((c, Nat), (a, [a]))] -> (c, Nat) -> Set Nat;
create_af r i =
  fun_of_map_funa (ceta_map_of i) (\ (_, n) -> set (upt Zero_nat n))
    (\ (_, coeffs) ->
      set (concatMap (\ (c, ia) -> (if not (c == zero r) then [ia] else []))
            (zip coeffs (upt Zero_nat (size_list coeffs)))));

create_poly_redtriple ::
  forall a b c.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b, Key b,
      Showa b, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a ())))) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                      [((b, Nat), (a, [a]))] -> Redtriple_ext b c ();
create_poly_redtriple c cI i =
  let {
    pi = to_lpoly_inter c i;
    ns = check_polo_ns c pi;
  } in Redtriple_ext (bindb cI (\ _ -> check_lpoly_coeffs c i))
         (check_polo_s c pi) ns ns (create_af c i) (create_mono_af c i)
         (\ s_ns_nst ->
           (if plus_single_mono c then check_poly_mono c i
             else check_poly_mono_npsm c (funas_trs_list s_ns_nst) i))
         (create_lpoly_repr c i) (Just (map fst i))
         (if plus_single_mono c then convert_lpoly_complexity c pi
           else (\ _ ->
                  Inl (shows_prec_list Zero_nat
                        "complexity analysis unsupported")))
         ();

weak_gt_arctic_delta ::
  forall a. (Floor_ceiling a) => Arctic_delta a -> Arctic_delta a -> Bool;
weak_gt_arctic_delta uu MinInfty_delta = True;
weak_gt_arctic_delta MinInfty_delta (Num_arc_delta uv) = False;
weak_gt_arctic_delta (Num_arc_delta x) (Num_arc_delta y) = less y x;

check_poly_strict_mono_discrete ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => (a -> a -> Bool) -> [([(b, Nat)], a)] -> b -> Bool;
check_poly_strict_mono_discrete gt p v =
  check_poly_gt gt
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p)
    p;

check_monom_strict_mono :: forall a. (Eq a) => Bool -> [(a, Nat)] -> a -> Bool;
check_monom_strict_mono pm m v =
  not (null m) &&
    null (tl m) &&
      fst (hd m) == v &&
        (if pm then less_eq_nat (Nat_of_num One) (snd (hd m))
          else equal_nat (snd (hd m)) (Nat_of_num One));

check_poly_strict_mono ::
  forall a b. (Eq a, Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_strict_mono pm p v =
  any (\ (m, c) -> less_eq onea c && check_monom_strict_mono pm m v) p;

check_poly_strict_mono_smart ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => Bool ->
                 Bool -> (a -> a -> Bool) -> [([(b, Nat)], a)] -> b -> Bool;
check_poly_strict_mono_smart discrete pm gt p v =
  (if discrete then check_poly_strict_mono_discrete gt p v
    else check_poly_strict_mono pm p v);

check_poly_weak_mono_all ::
  forall a b. (Ordered_semiring_0 b) => [([(a, Nat)], b)] -> Bool;
check_poly_weak_mono_all p = all (\ (_, a) -> less_eq zeroa a) p;

check_poly_weak_mono_and_pos ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> Bool;
check_poly_weak_mono_and_pos discrete p =
  (if discrete
    then all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&
           less_eq zeroa (eval_poly (\ _ -> zeroa) p)
    else check_poly_weak_mono_all p);

poly_inter_to_mono_af ::
  forall a b.
    (Eq a, Poly_carrier a,
      Key b) => Bool ->
                  Bool ->
                    (a -> a -> Bool) ->
                      [((b, Nat), [([(Nat, Nat)], a)])] -> (b, Nat) -> Set Nat;
poly_inter_to_mono_af discrete power_mono gt i =
  fun_of_map_fun
    (ceta_map_of
      (map (\ (a, b) ->
             let {
               (f, n) = a;
             } in (\ e ->
                    ((f, n),
                      set (filter
                            (\ ia ->
                              check_poly_weak_mono_and_pos discrete e &&
                                check_poly_strict_mono_smart discrete power_mono
                                  gt e ia)
                            (upt Zero_nat n))))
               b)
        i))
    (\ fn -> set (upt Zero_nat (snd fn)));

check_poly_inter_list ::
  forall a b.
    (Eq a, Eq b,
      Poly_carrier b) => Bool ->
                           [((a, Nat), [([(Nat, Nat)], b)])] ->
                             Sum (Sum ([Prelude.Char] -> [Prelude.Char])
                                   (a, [([(Nat, Nat)], b)]))
                               ();
check_poly_inter_list discrete i =
  bindb (check (distinct (map fst i))
          (Inl (shows_prec_list Zero_nat
                 "some symbol has two interpretations")))
    (\ _ ->
      catch_errora
        (catch_errora
          (forallM
            (\ x ->
              (if let {
                    (_, a) = x;
                  } in check_poly_weak_mono_and_pos discrete a
                then Inr () else Inl x))
            i)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl (let {
                 (a, b) = x;
               } in let {
                      (f, _) = a;
                    } in (\ p -> Inr (f, p))
                      b)));

strongly_linear ::
  forall a. (Poly_carrier a) => Nat -> [([(Nat, Nat)], a)] -> a -> Bool;
strongly_linear x p v =
  (if equal_nat x Zero_nat then check_ge_v v p
    else let {
           a = poly_split
                 [(minus_nat x (Nat_of_num One),
                    plus_nat Zero_nat (Nat_of_num One))]
                 p;
           (aa, pa) = a;
         } in less_eq aa onea &&
                strongly_linear (minus_nat x (Nat_of_num One)) pa v);

sl_complexity_sig_check ::
  forall a b.
    (Poly_carrier b) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                          b -> [(a, Nat)] -> Sum (a, Nat) ();
sl_complexity_sig_check i v f =
  catch_errora
    (forallM (\ (fa, n) -> check (strongly_linear n (i (fa, n)) v) (fa, n)) f)
    (\ x -> Inl (snd x));

sl_complexity_check ::
  forall a b.
    (Poly_carrier a,
      Showa b) => a -> ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                         [(b, Nat)] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
sl_complexity_check v i f =
  let {
    w = max_v v i f;
  } in catch_errora (sl_complexity_sig_check i w f)
         (\ x ->
           Inl (let {
                  (fa, _) = x;
                } in shows_string "symbol " .
                       shows_prec Zero_nat fa .
                         shows_prec_list Zero_nat
                           " does not possess a strongly linear interpretation"));

nl_complexity_check ::
  forall a b c.
    (Showa a,
      Poly_carrier b) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                           Complexity_measure a c ->
                             Sum ([Prelude.Char] -> [Prelude.Char])
                               Complexity_class;
nl_complexity_check i (Derivational_Complexity f) =
  bindb (sl_complexity_check zeroa i f)
    (\ _ -> Inr (Comp_Poly (Nat_of_num One)));
nl_complexity_check i (Runtime_Complexity c d) =
  bindb (sl_complexity_check onea i c)
    (\ _ ->
      let {
        deg = max_list (map (\ f -> poly_degree (i f)) d);
      } in Inr (Comp_Poly deg));

poly_inter_to_af ::
  forall a b.
    (Key a) => [((a, Nat), [([(Nat, Nat)], b)])] -> (a, Nat) -> Set Nat;
poly_inter_to_af i =
  fun_of_map_fun (ceta_map_of (map (\ (fn, e) -> (fn, poly_vars e)) i))
    (\ fn -> set (upt Zero_nat (snd fn)));

create_nlpoly_redtriple ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                    a -> (a -> a -> Bool) ->
                           Bool ->
                             Bool ->
                               [((b, Nat), [([(Nat, Nat)], a)])] ->
                                 Redtriple_ext b c ();
create_nlpoly_redtriple cI def gt power_mono discrete i =
  let {
    j = poly_inter_list_to_inter def i;
    x = poly_subst
          (\ n -> poly_of (PVar ("x_" ++ shows_prec_nat Zero_nat n [])));
  } in Redtriple_ext
         (bindb cI
           (\ _ ->
             catch_errora (check_poly_inter_list discrete i)
               (\ xa ->
                 Inl (case xa of {
                       Inl a -> id a;
                       Inr (f, p) ->
                         shows_string "interpretation " .
                           shows_poly (x p) .
                             shows_string " of " .
                               shows_prec Zero_nat f . shows_string " invalid ";
                     }))))
         (check_s gt j) (check_ns j) (check_ns j) (poly_inter_to_af i)
         (poly_inter_to_mono_af discrete power_mono gt i)
         (\ _ ->
           catch_errora
             (catch_errora
               (forallM
                 (\ xa ->
                   (if let {
                         (a, b) = xa;
                       } in let {
                              (_, n) = a;
                            } in (\ p ->
                                   all_interval_nat
                                     (check_poly_strict_mono_smart discrete
                                       power_mono gt p)
                                     Zero_nat n)
                              b
                     then Inr () else Inl xa))
                 i)
               (\ xa -> Inl (snd xa)))
             (\ xa ->
               Inl (let {
                      (a, b) = xa;
                    } in let {
                           (f, _) = a;
                         } in (\ p ->
                                shows_string
                                  "could not ensure monotonicty of " .
                                  shows_poly (x p) .
                                    shows_string " as interpretation of " .
                                      shows_prec Zero_nat f)
                           b)))
         (shows_string "polynomial interpretation" .
           shows_nl .
             shows_sep
               (\ (a, b) ->
                 let {
                   (f, n) = a;
                 } in (\ p ->
                        shows_string "Pol(" .
                          shows_prec Zero_nat f .
                            shows_string "/" .
                              shows_prec_nat Zero_nat n .
                                shows_string ") = " . shows_poly (x p))
                   b)
               shows_nl i)
         (Just (map fst i)) (nl_complexity_check j) ();

pos_arctic_delta :: forall a. (Floor_ceiling a) => Arctic_delta a -> Bool;
pos_arctic_delta MinInfty_delta = False;
pos_arctic_delta (Num_arc_delta n) = less_eq zeroa n;

class_ordered_semiring ::
  forall a b.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => Itself a ->
                       (a -> a -> Bool) ->
                         b -> Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a (Ordered_semiring_ext a b)));
class_ordered_semiring a gt b =
  class_semiring a (Ordered_semiring_ext (\ x y -> less_eq y x) gt max b);

class_arc_complexity ::
  forall a. a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
class_arc_complexity a =
  Inl (shows_prec_list Zero_nat
        "complexity for arctic semirings not supported");

class_arc_lpoly_order ::
  forall a.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => a -> (a -> Bool) ->
                            (a -> a -> Bool) ->
                              Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a
                                    (Ordered_semiring_ext a
                                      (Lpoly_order_semiring_ext a ()))));
class_arc_lpoly_order def apos gt =
  class_ordered_semiring Type gt
    (Lpoly_order_semiring_ext False def apos (\ _ -> False) (\ _ -> Zero_nat)
      class_arc_complexity "polynomial interpretation over arctic semiring" ());

vec_comp_all :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
vec_comp_all r v w = all (\ (a, b) -> r a b) (zip v w);

mat_comp_all :: forall a. (a -> a -> Bool) -> [[a]] -> [[a]] -> Bool;
mat_comp_all r m1 m2 = all (\ (a, b) -> vec_comp_all r a b) (zip m1 m2);

mat_ge :: forall a. (Non_strict_order a) => [[a]] -> [[a]] -> Bool;
mat_ge = mat_comp_all (\ x y -> less_eq y x);

mat_both_ordered_semiring ::
  forall a b.
    (Ordered_semiring_1 a) => Nat ->
                                (a -> a -> Bool) ->
                                  b -> Partial_object_ext [[a]]
 (Monoid_ext [[a]] (Ring_ext [[a]] (Ordered_semiring_ext [[a]] b)));
mat_both_ordered_semiring n gt b =
  mat_ring n (Ordered_semiring_ext mat_ge (mat_comp_all gt) (mat_plusI max) b);

mat_arc_complexity :: forall a. a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
mat_arc_complexity m =
  Inl (shows_prec_list Zero_nat "complexity for arctic matrices not supported");

mat_arc_posI :: forall a. (a -> Bool) -> [[a]] -> Bool;
mat_arc_posI ap m = ap (nth (nth m Zero_nat) Zero_nat);

mat_arc_lpoly_order ::
  forall a.
    (Ordered_semiring_1 a) => Nat ->
                                a -> (a -> Bool) ->
                                       (a -> a -> Bool) ->
 Partial_object_ext [[a]]
   (Monoid_ext [[a]]
     (Ring_ext [[a]]
       (Ordered_semiring_ext [[a]] (Lpoly_order_semiring_ext [[a]] ()))));
mat_arc_lpoly_order n def apos gt =
  mat_both_ordered_semiring n gt
    (Lpoly_order_semiring_ext False (mat1I zeroa def n) (mat_arc_posI apos)
      (\ _ -> False) (\ _ -> Zero_nat) mat_arc_complexity
      "arctic matrix interpretation" ());

check_arc_dimension :: Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_arc_dimension n =
  check (less_nat Zero_nat n)
    (shows_prec_list Zero_nat "dimension must be at least 1");

class_complexity ::
  forall a.
    (Ordered_semiring_1 a) => a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
class_complexity a =
  (if less_eq a onea then Inr Zero_nat
    else Inl (shows_prec_list Zero_nat "value is larger than 1"));

class_lpoly_order ::
  forall a.
    (Ceq a, Ccompare a, Ordered_semiring_1 a,
      Set_impl a) => a -> (a -> Bool) ->
                            (a -> a -> Bool) ->
                              Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a
                                    (Ordered_semiring_ext a
                                      (Lpoly_order_semiring_ext a ()))));
class_lpoly_order def mon gt =
  class_ordered_semiring Type gt
    (Lpoly_order_semiring_ext True def (\ _ -> True) mon (\ _ -> Zero_nat)
      class_complexity "polynomial interpretation" ());

scf_repr_to_scf ::
  forall a. ((a, Nat) -> Maybe [Nat]) -> (a, Nat) -> Nat -> Nat;
scf_repr_to_scf scf fn i =
  (case scf fn of {
    Nothing -> Nat_of_num One;
    Just xs -> nth xs i;
  });

check_scf_entry ::
  forall a.
    (Showa a) => (a, Nat) ->
                   Maybe [Nat] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_scf_entry fn Nothing = Inr ();
check_scf_entry (f, n) (Just es) =
  catch_errora
    (bindb
      (check (equal_nat (size_list es) n)
        (shows_prec_list Zero_nat "nr of entries should be " .
          shows_prec_nat Zero_nat n))
      (\ _ ->
        check (all (less_nat Zero_nat) es)
          (shows_prec_list Zero_nat "all entries must be non-zero")))
    (\ x ->
      Inl (shows_prec_list Zero_nat "problem with subterm coefficients for " .
            shows_prec_prod Zero_nat (f, n) .
              shows_prec_list Zero_nat ": " . x . shows_nl));

prec_weight_repr_to_prec_weight ::
  forall a.
    (Eq a, Key a,
      Showa a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    (Sum ([Prelude.Char] -> [Prelude.Char]) (),
                      ((a, Nat) -> Nat,
                        ((a, Nat) -> Nat,
                          (Nat, (a -> Bool, (a, Nat) -> Nat -> Nat)))));
prec_weight_repr_to_prec_weight prw_w0 =
  let {
    (prw, w0) = prw_w0;
    prwm = ceta_map_of prw;
    w_fun =
      fun_of_map_funa prwm (\ _ -> plus_nat w0 (Nat_of_num One)) (fst . snd);
    p_fun = fun_of_map_funa prwm (\ _ -> Zero_nat) fst;
    scf_fun = fun_of_map_funa prwm (\ _ -> Nothing) (snd . snd);
    fs = map fst prw;
    p_max = max_list (map p_fun fs);
    cw_okay =
      catch_errora
        (forallM
          (\ fn ->
            check (if equal_nat (snd fn) Zero_nat then less_eq_nat w0 (w_fun fn)
                    else True)
              (shows_prec_list Zero_nat "weight of constant " .
                shows_prec Zero_nat (fst fn) .
                  shows_prec_list Zero_nat " must be at least w0"))
          (map fst prw))
        (\ x -> Inl (snd x));
    adm = catch_errora
            (forallM
              (\ fn ->
                check (if equal_nat (snd fn) (Nat_of_num One)
                        then (if equal_nat (w_fun fn) Zero_nat
                               then equal_nat (p_fun fn) p_max else True)
                        else True)
                  (shows_prec_list Zero_nat "unary symbol " .
                    shows_prec Zero_nat (fst fn) .
                      shows_prec_list Zero_nat
                        " with weight 0 does not have maximal precedence"))
              (map fst prw))
            (\ x -> Inl (snd x));
    scf_ok =
      catch_errora
        (forallM (\ fn -> check_scf_entry fn (scf_fun fn)) (map fst prw))
        (\ x -> Inl (snd x));
    cs = map_filter
           (\ x ->
             (if equal_nat (snd x) Zero_nat && equal_nat (w_fun x) w0
               then Just (fst x) else Nothing))
           fs;
    p_min = min_list (map (\ c -> p_fun (c, Zero_nat)) cs);
    lcs = filter (\ c -> equal_nat (p_fun (c, Zero_nat)) p_min) cs;
    least = membera lcs;
    ok = bindb (check (less_nat Zero_nat w0)
                 (shows_prec_list Zero_nat "w0 must be larger than 0"))
           (\ _ -> bindb adm (\ _ -> bindb cw_okay (\ _ -> scf_ok)));
  } in (ok, (p_fun, (w_fun, (w0, (least, scf_repr_to_scf scf_fun)))));

create_KBO_redtriple ::
  forall a b c.
    (Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => (([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    ([((b, Nat), (Nat, (Nat, Maybe [Nat])))], Nat)) ->
                    ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                      Redtriple_ext b c ();
create_KBO_redtriple f_to_g pr =
  let {
    (ch, (p, (w, (w0, (least, scf))))) =
      prec_weight_repr_to_prec_weight (f_to_g pr);
    ns = kbo_nstrict p w w0 least scf;
    s = kbo_strict p w w0 least scf;
  } in Redtriple_ext ch s ns ns full_af full_af (\ _ -> Inr ())
         (shows_kbo_repr pr) (Just [])
         (\ _ ->
           Inl (shows_prec_list Zero_nat "complexity analysis unsupported"))
         ();

check_dimensions ::
  Nat ->
    Nat ->
      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dimensions n sd c =
  bindb c
    (\ _ ->
      check (less_eq_nat sd n && less_nat Zero_nat sd)
        (shows_prec_list Zero_nat
          "strict dimension must be at least 1 and less than total dimension"));

fpair_f :: forall a. Filtered a -> a;
fpair_f (FPair x1 x2) = x1;

check_mono_afs ::
  forall a.
    (Ceq a, Ccompare a) => Afs a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_mono_afs pi =
  check (mono_afs pi)
    (shows_prec_list Zero_nat "argument filter is not monotone");

shows_afs ::
  forall a.
    (Showa a) => [((a, Nat), Af_entry)] -> [Prelude.Char] -> [Prelude.Char];
shows_afs af =
  foldr (\ (a, b) ->
          let {
            (f, n) = a;
          } in (\ e ->
                 (((((shows_prec_list Zero_nat "pi(" . shows_prec Zero_nat f) .
                      shows_prec_list Zero_nat "/") .
                     shows_prec_nat Zero_nat n) .
                    shows_prec_list Zero_nat ") = ") .
                   (case e of {
                     Collapse i ->
                       shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One));
                     AFList ids -> shows_prec_list Zero_nat (map suc ids);
                   })) .
                   shows_nl)
            b)
    af;

afs_to_af :: forall a. (Key a) => Afs a -> (a, Nat) -> Set Nat;
afs_to_af pi fn =
  (case afsa pi fn of {
    Collapse j -> inserta j (set_empty (of_phantom set_impl_nat));
    AFList a -> set a;
  });

afs_check ::
  forall a b.
    (Showa a,
      Showa b) => ([Prelude.Char] -> [Prelude.Char]) ->
                    Afs a ->
                      ((Term (Filtered a) b, Term (Filtered a) b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
afs_check r pi g lr =
  let {
    pl = afs_term pi (fst lr);
    pr = afs_term pi (snd lr);
  } in catch_errora (g (pl, pr))
         (\ x ->
           Inl (shows_string "could not orient " .
                 shows_prec_term Zero_nat (fst lr) .
                   shows_string " " .
                     r . shows_string " " .
                           shows_prec_term Zero_nat (snd lr) .
                             shows_nl .
                               shows_string "pi( " .
                                 shows_prec_term Zero_nat (fst lr) .
                                   shows_string " ) = " .
                                     shows_prec_term Zero_nat pl .
                                       shows_nl .
 shows_string "pi( " .
   shows_prec_term Zero_nat (snd lr) .
     shows_string " ) = " . shows_prec_term Zero_nat pr . shows_nl . x));

af_redtriple ::
  forall a b.
    (Ceq a, Ccompare a, Key a, Set_impl a, Showa a,
      Showa b) => [((a, Nat), Af_entry)] ->
                    Redtriple_ext (Filtered a) b () -> Redtriple_ext a b ();
af_redtriple pi rp =
  let {
    afso = afs_of pi;
    afs = the afso;
    af = afs_to_af afs;
  } in Redtriple_ext
         (bindb
           (check (not (is_none afso))
             (shows_prec_list Zero_nat "invalid positions in argument filter"))
           (\ _ -> valid rp))
         (afs_check (shows_prec_list Zero_nat ">") afs (s rp))
         (afs_check (shows_prec_list Zero_nat ">=") afs (ns rp))
         (afs_check (shows_prec_list Zero_nat ">=") afs (nst rp)) af empty_af
         (\ cs ->
           bindb (check_mono_afs afs) (\ _ -> mono rp (map (afs_rule afs) cs)))
         ((((shows_prec_list Zero_nat "Argument Filter: " . shows_nl) .
             shows_afs pi) .
            shows_nl) .
           desc rp)
         (map_option (\ fs -> map fst pi ++ map (\ (f, a) -> (fpair_f f, a)) fs)
           (not_ws_ns rp))
         (\ _ ->
           Inl (shows_prec_list Zero_nat "complexity analysis unsupported"))
         ();

pos_arctic :: Arctic -> Bool;
pos_arctic MinInfty = False;
pos_arctic (Num_arc n) = less_eq_int Zero_int n;

delta_mono :: forall a. (Floor_ceiling a) => a -> Bool;
delta_mono x = less_eq onea x;

vec_pre_gtI :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
vec_pre_gtI gt v w = any (\ (a, b) -> gt a b) (zip v w);

mat_pre_gtI :: forall a. (a -> a -> Bool) -> [[a]] -> [[a]] -> Bool;
mat_pre_gtI gt m1 m2 = any (\ (a, b) -> vec_pre_gtI gt a b) (zip m1 m2);

mat_gtI ::
  forall a.
    (Non_strict_order a) => (a -> a -> Bool) -> Nat -> [[a]] -> [[a]] -> Bool;
mat_gtI gt sd m1 m2 =
  mat_ge m1 m2 && mat_pre_gtI gt (sub_mat sd sd m1) (sub_mat sd sd m2);

mat_ordered_semiring ::
  forall a b.
    (Ordered_semiring_1 a) => Nat ->
                                Nat ->
                                  (a -> a -> Bool) ->
                                    b -> Partial_object_ext [[a]]
   (Monoid_ext [[a]] (Ring_ext [[a]] (Ordered_semiring_ext [[a]] b)));
mat_ordered_semiring n sd gt b =
  mat_ring n (Ordered_semiring_ext mat_ge (mat_gtI gt sd) (mat_plusI max) b);

mat_monoI :: forall a. (a -> Bool) -> Nat -> [[a]] -> Bool;
mat_monoI geq1 sd m = all (any geq1) (sub_mat sd sd m);

upper_triangular :: forall a. (One a, Zero a, Eq a, Ord a) => [[a]] -> Bool;
upper_triangular [] = True;
upper_triangular ((a : asa) : m) =
  less_eq a onea && all (\ b -> b == zeroa) asa && upper_triangular (map tl m);
upper_triangular ([] : m) = False;

mat_complexity ::
  forall a.
    (Eq a,
      Ordered_semiring_1 a) => Nat ->
                                 [[a]] ->
                                   Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
mat_complexity n m =
  (if upper_triangular m then Inr (minus_nat n (Nat_of_num One))
    else Inl (shows_prec_list Zero_nat "matrix is not upper triangular"));

mat_lpoly_order ::
  forall a.
    (Eq a,
      Ordered_semiring_1 a) => Nat ->
                                 Nat ->
                                   a -> (a -> Bool) ->
  (a -> a -> Bool) ->
    Partial_object_ext [[a]]
      (Monoid_ext [[a]]
        (Ring_ext [[a]]
          (Ordered_semiring_ext [[a]] (Lpoly_order_semiring_ext [[a]] ()))));
mat_lpoly_order n sd def mon gt =
  mat_ordered_semiring n sd gt
    (Lpoly_order_semiring_ext True (mat1I zeroa def n) (\ _ -> True)
      (mat_monoI mon sd) (\ _ -> Zero_nat) (mat_complexity n)
      "matrix interpretation" ());

int_mono :: Int -> Bool;
int_mono x = less_eq_int (Pos One) x;

delta_gt :: forall a. (Floor_ceiling a) => a -> a -> a -> Bool;
delta_gt delta = (\ x y -> less_eq delta (minus x y));

check_def_pos ::
  forall a. (Zero a, Ord a) => a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_def_pos d =
  check (less zeroa d)
    (shows_prec_list Zero_nat "default value must be positive");

rpo_nstrict_unbounded ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                    ((a, Nat) -> Order_tag) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
rpo_nstrict_unbounded pr c =
  (\ (s, t) ->
    check (snd (rpo_unbounded pr c s t))
      (shows_string "could not orient " .
        shows_prec_term Zero_nat s .
          shows_string " >=RPO " . shows_prec_term Zero_nat t . shows_nl));

rpo_strict_unbounded ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> (a, Nat) -> (Bool, Bool), (a, Nat) -> Bool) ->
                    ((a, Nat) -> Order_tag) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
rpo_strict_unbounded pr c =
  (\ (s, t) ->
    check (fst (rpo_unbounded pr c s t))
      (shows_string "could not orient " .
        shows_prec_term Zero_nat s .
          shows_string " >RPO " . shows_prec_term Zero_nat t . shows_nl));

create_RPO_redtriple ::
  forall a b c.
    (Showa a, Eq b, Showa b, Eq c,
      Showa c) => ([((a, Nat), (Nat, Order_tag))] ->
                    ((b, Nat) -> Nat, (b, Nat) -> Order_tag)) ->
                    [((a, Nat), (Nat, Order_tag))] -> Redtriple_ext b c ();
create_RPO_redtriple prec_repr_to_pr pr =
  let {
    (p, tau) = prec_repr_to_pr pr;
    ns = rpo_nstrict_unbounded (prc_nat p, prl_nat p) tau;
  } in Redtriple_ext (Inr ()) (rpo_strict_unbounded (prc_nat p, prl_nat p) tau)
         ns ns full_af full_af (\ _ -> Inr ()) (shows_rpo_repr pr) (Just [])
         (\ _ ->
           Inl (shows_prec_list Zero_nat "complexity analysis unsupported"))
         ();

get_redtriple ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => Redtriple_impl a -> Redtriple_ext a [Prelude.Char] ();
get_redtriple (Int_carrier i) =
  create_poly_redtriple
    (class_lpoly_order (Pos One) int_mono (\ x y -> less_int y x)) (Inr ()) i;
get_redtriple (Int_nl_carrier i) =
  create_nlpoly_redtriple (Inr ()) (Pos One) (\ x y -> less_int y x) True True
    i;
get_redtriple (Rat_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_rat delta_mono (\ x y -> less_rat y x))
    (check_def_pos one_rat) i;
get_redtriple (Rat_nl_carrier d i) =
  create_nlpoly_redtriple (check_def_pos d) d (delta_gt d)
    (less_eq_rat one_rat d) False i;
get_redtriple (Real_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_real delta_mono (\ x y -> less_real y x))
    (check_def_pos one_real) i;
get_redtriple (Real_nl_carrier d i) =
  create_nlpoly_redtriple (check_def_pos d) d (delta_gt d)
    (less_eq_real one_real d) False i;
get_redtriple (Arctic_carrier i) =
  create_poly_redtriple
    (class_arc_lpoly_order one_arctic pos_arctic (\ x y -> less_arctic y x))
    (Inr ()) i;
get_redtriple (Arctic_rat_carrier i) =
  create_poly_redtriple
    (class_arc_lpoly_order one_arctic_delta pos_arctic_delta
      weak_gt_arctic_delta)
    (Inr ()) i;
get_redtriple (Int_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd (Pos One) int_mono (\ x y -> less_int y x))
    (check_dimensions n sd (Inr ())) i;
get_redtriple (Rat_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_rat delta_mono (\ x y -> less_rat y x))
    (check_dimensions n sd (check_def_pos one_rat)) i;
get_redtriple (Real_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_real delta_mono (\ x y -> less_real y x))
    (check_dimensions n sd (check_def_pos one_real)) i;
get_redtriple (Arctic_mat_carrier n i) =
  create_poly_redtriple
    (mat_arc_lpoly_order n one_arctic pos_arctic (\ x y -> less_arctic y x))
    (check_arc_dimension n) i;
get_redtriple (Arctic_rat_mat_carrier n i) =
  create_poly_redtriple
    (mat_arc_lpoly_order n one_arctic_delta pos_arctic_delta
      weak_gt_arctic_delta)
    (check_arc_dimension n) i;
get_redtriple (RPO prec_tau pi) =
  af_redtriple pi
    (create_RPO_redtriple (\ pr -> (prec_repr_to_pr pr, prec_repr_to_status pr))
      prec_tau);
get_redtriple (KBO precw pi) =
  af_redtriple pi
    (create_KBO_redtriple
      (filter_prec_weight_repr
        (fun_of_map_fun (ceta_map_of pi) (\ fn -> default_af_entry (snd fn))))
      precw);
get_redtriple (WPO params rp) = wpo_redtriple (get_redtriple rp) params;

list_ext_name :: List_order_type -> [Prelude.Char];
list_ext_name MS_Ext = "MS";
list_ext_name Dms_Ext = "DMS";
list_ext_name Min_Ext = "MIN";
list_ext_name Max_Ext = "MAX";

lifta :: (Bool, Bool) -> (Bool, Bool);
lifta (uu, b) = (b, b);

or2 :: (Bool, Bool) -> (Bool, Bool) -> (Bool, Bool);
or2 (b1, b2) (b3, b4) = (b1 || b3, b2 || b4);

mul_ext_impl ::
  forall a. (Eq a) => (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
mul_ext_impl f [] [] = (False, True);
mul_ext_impl f [] (v : va) = (False, False);
mul_ext_impl f (v : va) [] = (True, True);
mul_ext_impl f (v : va) (y : ys) = ex_dominating f y (v : va) (v : va) ys;

ex_dominating ::
  forall a.
    (Eq a) => (a -> a -> (Bool, Bool)) ->
                a -> [a] -> [a] -> [a] -> (Bool, Bool);
ex_dominating f y [] uw ux = (False, False);
ex_dominating f y (b : bs) xs ys =
  (case f b y of {
    (True, _) ->
      or2 (lifta
            (mul_ext_impl f (remove1 b xs)
              (filter (\ ya -> not (fst (f b ya))) ys)))
        (ex_dominating f y bs xs ys);
    (False, True) ->
      or2 (mul_ext_impl f (remove1 b xs) ys) (ex_dominating f y bs xs ys);
    (False, False) -> ex_dominating f y bs xs ys;
  });

dms_preprocess :: [[(Nat, (Bool, Bool))]] -> [[(Nat, (Bool, Bool))]];
dms_preprocess p = map (filter (\ (_, a) -> let {
      (aa, b) = a;
    } in aa || b))
                     p;

dms_simplify ::
  Bool -> [Nat] -> [[(Nat, (Bool, Bool))]] -> [[(Nat, (Bool, Bool))]];
dms_simplify stri is p = (if any (\ i -> null (nth p i)) is then [[]] else p);

dms_decide_singletons :: Bool -> Nat -> [(Nat, (Bool, Bool))] -> Bool;
dms_decide_singletons stri n p =
  all_interval_nat
    (\ i ->
      let {
        (j, (s, ns)) = nth p i;
      } in s && not (membera (drop (plus_nat i (Nat_of_num One)) p)
                      (j, (False, True))) ||
             ns && not (membera (map fst (drop (plus_nat i (Nat_of_num One)) p))
                         j))
    Zero_nat (size_list p) &&
    (if stri
      then not (all_interval_nat
                 (not . (\ j -> not (membera p (j, (False, True))))) Zero_nat n)
      else True);

dms_select :: Bool -> [[(Nat, (Bool, Bool))]] -> Nat;
dms_select stri p =
  snd (hd (sort_key fst
            (filter (\ (l, _) -> less_nat (Nat_of_num One) l)
              (zip (map size_list p) (upt Zero_nat (size_list p))))));

dms_solve_or_select :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Sum Bool Nat;
dms_solve_or_select stri n p =
  (if all (\ jsns -> less_eq_nat (size_list jsns) (Nat_of_num One)) p
    then Inl (if membera p [] then False
               else dms_decide_singletons stri n (map hd p))
    else Inr (dms_select stri p));

dms_solve :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_solve stri n p =
  (case dms_solve_or_select stri n p of {
    Inl res -> res;
    Inr k ->
      let {
        ksns = nth p k;
      } in dms_solve stri n
             (dms_simplify stri [k] (list_update p k [hd ksns])) ||
             dms_solve stri n
               (dms_simplify stri [k] (list_update p k (tl ksns)));
  });

dms_bool_ex_idx_impl :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_bool_ex_idx_impl stri n p =
  dms_solve stri n
    (dms_simplify stri (upt Zero_nat (size_list p)) (dms_preprocess p));

dms_bool_ex_idx :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_bool_ex_idx = dms_bool_ex_idx_impl;

dms_convert ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> [[(Nat, (Bool, Bool))]];
dms_convert f asa bs =
  let {
    jbs = zip (upt Zero_nat (size_list bs)) bs;
  } in map (\ a -> map (\ (j, b) -> (j, f a b)) jbs) asa;

dms_order_ext ::
  forall a. Nat -> (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
dms_order_ext n f asa bs =
  let {
    p = dms_convert f asa bs;
    lts = size_list bs;
    len = less_eq_nat lts n || equal_nat (size_list asa) lts;
  } in (len && dms_bool_ex_idx True lts p, len && dms_bool_ex_idx False lts p);

min_set_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
min_set_ext s_ns =
  (\ asa bs ->
    (not (null bs) && all (\ a -> any (\ b -> fst (s_ns a b)) bs) asa,
      all (\ a -> any (\ b -> snd (s_ns a b)) bs) asa));

list_ext ::
  forall a.
    (Eq a) => Nat ->
                List_order_type ->
                  (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
list_ext uu MS_Ext = mul_ext_impl;
list_ext uv Max_Ext = set_ext;
list_ext uw Min_Ext = min_set_ext;
list_ext n Dms_Ext = dms_order_ext n;

label_s_ns_impl ::
  forall a b.
    (Showa a,
      Showa b) => ((Term a b, Term a b) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    ((Term a b, Term a b) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool);
label_s_ns_impl cS cNS s t =
  let {
    (sa, i) = s;
    (ta, j) = t;
  } in (if isOK (cS (sa, ta)) then (True, True)
         else (if isOK (cNS (sa, ta)) then (less_nat j i, less_eq_nat j i)
                else (False, False)));

nST_label_mul_impl ::
  forall a b.
    (Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    ((a, Nat) -> [(Nat, Nat)]) ->
                      ((Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        ((Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Term a b, Term a b) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
nST_label_mul_impl list_ext af cS cNS st =
  (case st of {
    (Var _, _) ->
      Inl (shows_prec_list Zero_nat "roots of " .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " st .
              shows_prec_list Zero_nat " must be non-variable");
    (Fun _ _, Var _) ->
      Inl (shows_prec_list Zero_nat "roots of " .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " st .
              shows_prec_list Zero_nat " must be non-variable");
    (Fun f ss, Fun g ts) ->
      check (snd (list_ext (label_s_ns_impl cS cNS) (lterms af (Fun f ss))
                   (lterms af (Fun g ts))))
        (shows_prec_list Zero_nat "cannot orient pair " .
          shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " st .
            shows_prec_list Zero_nat " weakly:" .
              shows_nl .
                shows_prec_list Zero_nat (lterms af (Fun f ss)) .
                  shows_prec_list Zero_nat " >=mu " .
                    shows_prec_list Zero_nat (lterms af (Fun g ts)) .
                      shows_prec_list Zero_nat " could not be ensured");
  });

s_label_mul_impl ::
  forall a b.
    (Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    ((a, Nat) -> [(Nat, Nat)]) ->
                      ((Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        ((Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Term a b, Term a b) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
s_label_mul_impl list_ext af cS cNS st =
  (case st of {
    (Var _, _) ->
      Inl (shows_prec_list Zero_nat "roots of " .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " st .
              shows_prec_list Zero_nat " must be non-variable");
    (Fun _ _, Var _) ->
      Inl (shows_prec_list Zero_nat "roots of " .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " st .
              shows_prec_list Zero_nat " must be non-variable");
    (Fun f ss, Fun g ts) ->
      check (fst (list_ext (label_s_ns_impl cS cNS) (lterms af (Fun f ss))
                   (lterms af (Fun g ts))))
        (shows_prec_list Zero_nat "cannot orient pair " .
          shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " st .
            shows_prec_list Zero_nat " strictly:" .
              shows_nl .
                shows_prec_list Zero_nat (lterms af (Fun f ss)) .
                  shows_prec_list Zero_nat " >mu " .
                    shows_prec_list Zero_nat (lterms af (Fun g ts)) .
                      shows_prec_list Zero_nat " could not be ensured");
  });

generate_scnp_rp ::
  forall a b c.
    (Key a, Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    [Prelude.Char] ->
                      [((a, Nat), [(Nat, Nat)])] ->
                        (c -> Redtriple_ext a b ()) ->
                          c -> Root_redtriple_ext a b ();
generate_scnp_rp list_ext list_ext_name afa rti x =
  let {
    rt = rti x;
    afaa = fun_of_map (ceta_map_of afa) [];
    pi = af rt;
    cS = s rt;
    cNS = ns rt;
  } in Root_redtriple_ext (valid rt) (s_label_mul_impl list_ext afaa cS cNS)
         (ns rt) (nST_label_mul_impl list_ext afaa cS cNS) pi
         (scnp_af_to_af afaa pi) (scnp_desc afa list_ext_name . desc rt) ();

get_root_redtriple ::
  forall a.
    (Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => Root_redtriple_impl a ->
                    Root_redtriple_ext a [Prelude.Char] ();
get_root_redtriple (SCNP typea af rp) =
  generate_scnp_rp (list_ext (scnp_arity af) typea) (list_ext_name typea) af
    get_redtriple rp;

faulty_non_inf_order ::
  forall a b c.
    (Showa b, Showa c) => [Prelude.Char] -> a -> Non_inf_order_ext b c ();
faulty_non_inf_order s f =
  Non_inf_order_ext (Inl (shows_string s)) (\ _ -> Inr ()) (\ _ -> Inr ())
    (\ _ _ -> Wild) id ();

check_non_inf_poly_inter_list ::
  forall a b.
    (Eq a, Eq b,
      Poly_carrier b) => Bool ->
                           [(a, Nat)] ->
                             [((a, Nat), [([(Nat, Nat)], b)])] ->
                               Sum (a, [([(Nat, Nat)], b)]) ();
check_non_inf_poly_inter_list discrete f i =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (_, a) = x;
              } in check_poly_weak_mono_and_pos discrete a
            then Inr () else Inl x))
        (filter (\ (fn, _) -> membera f fn) i))
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (let {
             (a, b) = x;
           } in let {
                  (fa, _) = a;
                } in (\ aa -> (fa, aa))
                  b));

create_nlpoly_non_inf_order ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                    a -> (a -> a -> Bool) ->
                           Bool ->
                             Bool ->
                               (a -> [a]) ->
                                 [((b, Nat), [([(Nat, Nat)], a)])] ->
                                   [(b, Nat)] -> Non_inf_order_ext b c ();
create_nlpoly_non_inf_order cI def gt power_mono discrete sqrt i f =
  let {
    j = poly_inter_list_to_inter def i;
    x = poly_subst
          (\ n -> poly_of (PVar ("x_" ++ shows_prec_nat Zero_nat n [])));
  } in Non_inf_order_ext
         (bindb cI
           (\ _ ->
             catch_errora (check_non_inf_poly_inter_list discrete f i)
               (\ xa ->
                 Inl (let {
                        (fa, p) = xa;
                      } in shows_string "interpretation " .
                             shows_poly (x p) .
                               shows_string " of " .
                                 shows_prec Zero_nat fa .
                                   shows_string " invalid "))))
         (check_ns j) (check_cc sqrt gt j) (create_dep discrete def i)
         (shows_string "polynomial interpretation" .
           shows_nl .
             shows_sep
               (\ (a, b) ->
                 let {
                   (fa, n) = a;
                 } in (\ p ->
                        shows_string "Pol(" .
                          shows_prec Zero_nat fa .
                            shows_string "/" .
                              shows_prec_nat Zero_nat n .
                                shows_string ") = " . shows_poly (x p))
                   b)
               shows_nl i)
         ();

sqrt_rat :: Rat -> [Rat];
sqrt_rat x =
  let {
    (z, n) = quotient_of x;
  } in (case sqrt_int n of {
         [] -> [];
         sn : _ ->
           map (\ sz -> divide_rat (of_int sz) (of_int sn)) (sqrt_int z);
       });

get_non_inf_order ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b,
      Showa b) => Redtriple_impl a -> [(a, Nat)] -> Non_inf_order_ext a b ();
get_non_inf_order (Int_nl_carrier i) =
  create_nlpoly_non_inf_order (Inr ()) (Pos One) (\ x y -> less_int y x) True
    True sqrt_int i;
get_non_inf_order (Rat_nl_carrier d i) =
  create_nlpoly_non_inf_order (check_def_pos d) d (delta_gt d)
    (less_eq_rat one_rat d) False sqrt_rat i;
get_non_inf_order (Real_nl_carrier d i) =
  create_nlpoly_non_inf_order (check_def_pos d) d (delta_gt d)
    (less_eq_real one_real d) False sqrt_real i;
get_non_inf_order (Int_carrier v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Rat_carrier v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Real_carrier v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Arctic_carrier v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Arctic_rat_carrier v) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Int_mat_carrier v va vb) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Rat_mat_carrier v va vb) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Real_mat_carrier v va vb) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Arctic_mat_carrier v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (Arctic_rat_mat_carrier v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (RPO v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (KBO v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";
get_non_inf_order (WPO v va) =
  faulty_non_inf_order
    "only integers, rationals and reals are supported for non-inf orders";

check_strict_one_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b, Term a b) ->
                      Maybe [(Pos, ((Term a b, Term a b), Term a b))]) ->
                      ((a, Nat) -> Nat) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strict_one_rstep ra rseqm p r =
  let {
    s = proj_term p (fst r);
    t = proj_term p (snd r);
  } in (case rseqm r of {
         Nothing -> check_supt s t;
         Just [] ->
           Inl (shows_string "more than a single rewrite step is not allowed");
         Just [(pos, (rule, u))] ->
           bindb (check_qrstep (\ _ -> True) False ra pos rule s u)
             (\ _ -> check_supteq u t);
         Just ((_, (_, _)) : _ : _) ->
           Inl (shows_string "more than a single rewrite step is not allowed");
       });

check_rsteps ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), Term a b))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rsteps = check_qrsteps (\ _ -> True) False;

rseq_last ::
  forall a b. Term a b -> [(Pos, ((Term a b, Term a b), Term a b))] -> Term a b;
rseq_last s steps = last (s : map (\ (_, (_, sa)) -> sa) steps);

check_rsteps_last ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      [(Pos, ((Term a b, Term a b), Term a b))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rsteps_last = (\ r s steps -> check_rsteps r steps s (rseq_last s steps));

check_strict_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b, Term a b) ->
                      Maybe [(Pos, ((Term a b, Term a b), Term a b))]) ->
                      ((a, Nat) -> Nat) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strict_rstep ra rseqm p r =
  let {
    s = proj_term p (fst r);
    t = proj_term p (snd r);
  } in (case rseqm r of {
         Nothing -> check_supt s t;
         Just rseq ->
           (if equal_nat (size_list rseq) Zero_nat then check_supt s t
             else bindb (check_rsteps_last ra s rseq)
                    (\ _ -> check_supteq (rseq_last s rseq) t));
       });

create_rseq_map ::
  forall a b.
    (Key a,
      Key b) => [((Term a b, Term a b),
                   [(Pos, ((Term a b, Term a b), Term a b))])] ->
                  (Term a b, Term a b) ->
                    Maybe [(Pos, ((Term a b, Term a b), Term a b))];
create_rseq_map rseqs = ceta_map_of rseqs;

check_weak ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> Nat) ->
                    (Term a b, Term a b) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_weak p r =
  catch_errora
    (check (equal_term (proj_term p (fst r)) (proj_term p (snd r)))
      (shows_string "the projected lhs is not equal to the projected rhs" .
        shows_nl))
    (\ x ->
      Inl (shows_string "Could not orient rule " .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " r .
              shows_string ", since" .
                shows_nl .
                  shows_prec_term Zero_nat (proj_term p (fst r)) .
                    shows_string " != " .
                      shows_prec_term Zero_nat (proj_term p (snd r)) .
                        shows_nl . x));

subterm_criterion_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Ccompare c, Eq c, Key c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    ProjL b ->
                      [((Term b c, Term b c),
                         [(Pos, ((Term b c, Term b c), Term b c))])] ->
                        [(Term b c, Term b c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
subterm_criterion_proc i pL rseqmL prm dpp =
  (case let {
          p = create_proj pL;
          rseqm = create_rseq_map rseqmL;
          pa = pairsa i dpp;
          _ = nfsc i dpp;
          r = rulesd i dpp;
          pb = snd (split_pairsa i dpp prm);
          wfR = wf_rules_impl r;
        } in bindb (catch_errora
                     (forallM
                       (\ (l, ra) ->
                         bindb (check_no_var l)
                           (\ _ ->
                             bindb (check_no_var ra)
                               (\ _ ->
                                 check_no_defined_root
                                   (\ fn -> not (null (rules_mapb i dpp fn)))
                                   ra)))
                       pa)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check (minimal i dpp || nFQ_subset_NF_rulesc i dpp)
                         (shows_prec_list Zero_nat
                           "minimality or innermost required"))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM (\ (l, _) -> check_no_var l) r)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (if q_emptyc i dpp
                                 then catch_errora
(forallM (check_strict_rstep r rseqm p) prm) (\ x -> Inl (snd x))
                                 else catch_errora
(forallM (check_strict_one_rstep wfR rseqm p) prm) (\ x -> Inl (snd x)))
                           (\ _ ->
                             catch_errora (forallM (check_weak p) pb)
                               (\ x -> Inl (snd x))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp prm prm);
  });

replace_paira ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> (Term b c, Term b c) -> [(Term b c, Term b c)] -> a;
replace_paira
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = replace_pair;

forward_instantiation_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
forward_instantiation_proc i st sts u_opt dpp =
  (case let {
          isnf = is_QNFc i dpp;
          (s, t) = st;
          iedg = is_iedg_edge_dpp i dpp (s, t);
          sy = map_term (\ x -> x) (\ a -> 'y' : a) s;
          ty = map_term (\ x -> x) (\ a -> 'y' : a) t;
          u = (case u_opt of {
                Nothing -> rulesd i dpp;
                Just u -> u;
              });
        } in bindb (if is_none u_opt then Inr ()
                     else let {
                            urc = is_ur_closed_impl_dpp_mv i dpp u;
                            check_urc =
                              (\ sa ta ->
                                check (urc sa ta)
                                  (shows_prec_list Zero_nat "term " .
                                    shows_prec_term Zero_nat ta .
                                      shows_prec_list Zero_nat
" is not closed under usable rules"));
                          } in bindb (check (nfsc i dpp || minimal i dpp)
                                       (shows_prec_list Zero_nat
 "minimality or normal subst required"))
                                 (\ _ ->
                                   bindb (check (nFQ_subset_NF_rulesc i dpp)
   (shows_prec_list Zero_nat "innermost rewriting required"))
                                     (\ _ ->
                                       bindb
 (catch_errora (forallM (\ (l, a) -> check_urc (args l) a) u)
   (\ x -> Inl (snd x)))
 (\ _ ->
   bindb (check_urc [s] t)
     (\ _ ->
       (if nfsc i dpp then Inr ()
         else catch_errora
                (check_subseteq (vars_term_list t) (vars_term_list s))
                (\ _ ->
                  Inl (shows_prec_list Zero_nat
                        "variable condition in pair violated"))))))))
               (\ _ ->
                 let {
                   ur = map (\ (l, r) -> (r, l)) u;
                   ic = icap_impl (is_NF_terms []) ur [];
                 } in catch_errora
                        (forallM
                          (\ (ua, v) ->
                            (case mgu_class (ic ua) t of {
                              Nothing -> Inr ();
                              Just mu ->
                                check (not (isnf (subst_apply_term sy mu)) ||
(not (isnf (subst_apply_term (map_term (\ x -> x) (\ a -> 'x' : a) ua) mu)) ||
  any (\ sta ->
        instance_rule sta st &&
          instance_rule (subst_apply_term sy mu, subst_apply_term ty mu) sta)
    sts))
                                  (shows_prec_list Zero_nat
                                     "could not find instance of pair " .
                                    shows_rule (shows_prec Zero_nat)
                                      (shows_prec_list Zero_nat) " -> "
                                      (subst_apply_term sy mu,
subst_apply_term ty mu) .
                                      shows_nl .
shows_prec_list Zero_nat "which resulted from DP " .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " (ua, v));
                            }))
                          (filter (\ (ua, _) -> iedg ua) (pairsa i dpp)))
                        (\ x -> Inl (snd x)))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

check_join ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      [(Pos, ((Term a b, Term a b), Term a b))] ->
                        Term a b ->
                          [(Pos, ((Term a b, Term a b), Term a b))] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join r s sseq t tseq =
  let {
    chk = check_rsteps_last r;
  } in bindb (chk s sseq)
         (\ _ ->
           bindb (chk t tseq)
             (\ _ ->
               let {
                 u = rseq_last s sseq;
                 v = rseq_last t tseq;
               } in check (equal_term u v)
                      (shows_prec_list Zero_nat
                         "the rewrite sequences end in different terms " .
                        shows_prec_term Zero_nat u .
                          shows_prec_list Zero_nat " and " .
                            shows_prec_term Zero_nat v)));

check_critical_pairs_guided ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Bool, (Term a b, Term a b))] ->
                      [(Term a b,
                         ([(Pos, ((Term a b, Term a b), Term a b))],
                           (Term a b,
                             [(Pos, ((Term a b, Term a b), Term a b))])))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_guided r cp joins =
  bindb (catch_errora
          (forallM
            (\ (s, a) ->
              let {
                (sseq, aa) = a;
                (ab, b) = aa;
              } in check_join r s sseq ab b)
            joins)
          (\ x -> Inl (snd x)))
    (\ _ ->
      let {
        cpa = map (\ (s, (_, (t, _))) -> (s, t)) joins;
      } in catch_errora
             (forallM
               (\ (_, (s, t)) ->
                 check (equal_term s t ||
                         any (\ st ->
                               instance_rule (s, t) st ||
                                 instance_rule (t, s) st)
                           cpa)
                   (shows_prec_list Zero_nat "critical pair " .
                     show_crit_pair (s, t) .
                       shows_prec_list Zero_nat " missing"))
               cp)
             (\ x -> Inl (snd x)));

iterative_join_search_main ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Nat -> Nat -> Bool;
iterative_join_search_main r s t i n =
  (if less_eq_nat i n
    then not (null (list_inter (reachable_terms r s i)
                     (reachable_terms r t i))) ||
           iterative_join_search_main r s t (plus_nat i (Nat_of_num One)) n
    else False);

iterative_join_search ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Nat -> Bool;
iterative_join_search r s t n = iterative_join_search_main r s t Zero_nat n;

check_join_BFS_limit ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Nat ->
                    [(Term a b, Term a b)] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join_BFS_limit n r s t =
  check (iterative_join_search r s t n)
    (shows_prec_list Zero_nat
       "could not find a joining sequence of length at most " .
      shows_prec_nat Zero_nat n .
        shows_prec_list Zero_nat " for the terms " .
          shows_prec_term Zero_nat s .
            shows_prec_list Zero_nat " and " .
              shows_prec_term Zero_nat t . shows_nl);

check_critical_pairs_BFS ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Nat ->
                    [(Term a b, Term a b)] ->
                      [(Bool, (Term a b, Term a b))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_BFS n r cp =
  catch_errora
    (forallM
      (\ (_, (s, t)) ->
        (if equal_term s t then Inr ()
          else catch_errora (check_join_BFS_limit n r s t)
                 (\ x ->
                   Inl (shows_prec_list Zero_nat
                          "problem when joining critical pair " .
                         show_crit_pair (s, t) . shows_nl . x))))
      cp)
    (\ x -> Inl (snd x));

check_critical_pairs_NF ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Bool, (Term a b, Term a b))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_NF r cp =
  catch_errora
    (forallM
      (\ (_, (s, t)) ->
        (if equal_term s t then Inr ()
          else catch_errora (check_join_NF r s t)
                 (\ x ->
                   Inl (shows_prec_list Zero_nat
                          "problem when joining critical pair " .
                         show_crit_pair (s, t) . shows_nl . x))))
      cp)
    (\ x -> Inl (snd x));

check_critical_pairs ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Bool, (Term a [Prelude.Char], Term a [Prelude.Char]))] ->
                      Join_info a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs r cp join_info =
  (case join_info of {
    Guided a -> check_critical_pairs_guided r cp a;
    Join_NF -> check_critical_pairs_NF r cp;
    Join_BFS n -> check_critical_pairs_BFS n r cp;
  });

switch_innermost_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_innermost_proc i joins_i dpp =
  let {
    r = rwc i dpp;
    p = pa i dpp;
    pw = pwa i dpp;
    nfs = nfsc i dpp;
  } in (case bindb (catch_errora
                     (forallM
                       (\ (l, _) ->
                         check (not (is_Var l))
                           (shows_prec_list Zero_nat
                             "left variables in R forbidden"))
                       (if nfs then r else []))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check (minimal i dpp)
                         (shows_prec_list Zero_nat "minimality required"))
                   (\ _ ->
                     bindb (check (null (qc i dpp))
                             (shows_prec_list Zero_nat
                               "non-empty Q not yet supported"))
                       (\ _ ->
                         bindb (check (null (rc i dpp))
                                 (shows_prec_list Zero_nat
                                   "strict rules not allowed"))
                           (\ _ ->
                             bindb (check
                                     (null (critical_pairs_impl (p ++ pw) r))
                                     (shows_prec_list Zero_nat
                                       "overlaps between P and R not allowed"))
                               (\ _ ->
                                 check_critical_pairs r
                                   (critical_pairs_impl r r) joins_i)))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs True p pw (map fst r) [] r);
       });

mk_dpp ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      (Bool,
        (Bool,
          ([(Term b c, Term b c)],
            ([(Term b c, Term b c)],
              ([Term b c],
                ([(Term b c, Term b c)], [(Term b c, Term b c)])))))) ->
        a;
mk_dpp i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkc i nfs m p pw q r rw;

check_assma ::
  forall a b c d e f g.
    (Countable b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      (a -> d -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (c -> e -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (([(Ctxt (Lab b [Nat]) [Prelude.Char],
                               (Term (Lab b [Nat]) [Prelude.Char], Location))],
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])]) ->
                            f -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([Prelude.Char] ->
                              g -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              Generic_assm_proof b [Nat] [Prelude.Char] d e f ()
                                g ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assma j i tp_check dp_check fptp_check unk_check (SN_assm_proof t prf) =
  tp_check (mk_tp j t) prf;
check_assma j i tp_check dp_check fptp_check unk_check (Finite_assm_proof t prf)
  = dp_check (mk_dpp i t) prf;
check_assma j i tp_check dp_check fptp_check unk_check
  (Unknown_assm_proof t prf) = unk_check t prf;
check_assma j i tp_check dp_check fptp_check unk_check (SN_FP_assm_proof t prf)
  = fptp_check t prf;
check_assma j i uu uv uw ux (Not_SN_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for non-termination assumptions in termination proof");
check_assma j i uu uv uw ux (Infinite_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for non-termination assumptions in termination proof");
check_assma j i uu uv uw ux (Not_RelSN_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for non-termination assumptions in termination proof");
check_assma j i uu uv uw ux (Not_SN_FP_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for non-termination assumptions in termination proof");
check_assma j i uu uv uw ux (Complexity_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for non-termination assumptions in termination proof");

quasi_splitter ::
  forall a b c.
    (Compare a, Eq a, Compare c,
      Eq c) => (a -> (a, b)) ->
                 [(Term a c, Term a c)] ->
                   Set (Term a c, Term a c) ->
                     ([(Term a c, Term a c)],
                       ([(Term a c, Term a c)], [(Term a c, Term a c)]));
quasi_splitter ld lAll uRw =
  let {
    unlab = (\ lf -> fst (ld lf));
    la = map (\ r -> (r, map_funs_rule unlab r)) lAll;
    (d, nD) =
      partition
        (\ (r, ur) ->
          equal_term (fst ur) (snd ur) && not (equal_term (fst r) (snd r)))
        la;
    (rw, r) = partition (\ (_, ur) -> member ur uRw) nD;
  } in (map fst r, (map fst rw, map fst d));

model_splitter ::
  forall a b c.
    (Compare a, Eq a, Compare c,
      Eq c) => (a -> (a, b)) ->
                 [(Term a c, Term a c)] ->
                   Set (Term a c, Term a c) ->
                     ([(Term a c, Term a c)],
                       ([(Term a c, Term a c)], [(Term a c, Term a c)]));
model_splitter ld lAll uRw =
  let {
    unlab = (\ lf -> fst (ld lf));
    la = map (\ r -> (r, map_funs_rule unlab r)) lAll;
    (rw, r) = partition (\ (_, ur) -> member ur uRw) la;
  } in (map fst r, (map fst rw, []));

check_sl_Q ::
  forall a b c.
    (Eq a, Showa a, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => (a -> (a, b)) ->
                    [Term a c] ->
                      [Term a c] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_Q ld lQ q =
  let {
    u = (\ l -> fst (ld l));
  } in catch_errora
         (forallM
           (\ lq ->
             check (let {
                      mlq = map_term u (\ x -> x) lq;
                    } in any (\ qa -> matches mlq qa && matches qa mlq) q)
               (shows_prec_list Zero_nat "unlabeling " .
                 shows_term (shows_prec Zero_nat) (shows_prec Zero_nat) lq .
                   shows_prec_list Zero_nat " yields a term not in Q"))
           lQ)
         (\ x -> Inl (snd x));

sem_lab_quasi_root_proc ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ceq d, Ccompare d, Compare d, Eq d,
      Mapping_impl d, Set_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([(Term a d, Term a d)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          ([(Term a d, Term a d)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([Term a d] ->
                              [Term a d] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                ([(Term a d, Term a d)] ->
                                  [(Term a d, Term a d)] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char])
                                      ()) ->
                                  (Set (Term a d, Term a d) ->
                                    [(Term a d, Term a d)] ->
                                      Sum ([Prelude.Char] -> [Prelude.Char])
()) ->
                                    [(Term a d, Term a d)] ->
                                      [Term a d] ->
[(Term a d, Term a d)] -> c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_quasi_root_proc ld i valid check_decra check_decr check_lhss_more
  check_lab_all check_lab_all_trs check_model_lab lPAll lQ lRAll dpp =
  let {
    r = rc i dpp;
    rw = rwc i dpp;
    pw = pwa i dpp;
    p = pa i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll (set pw);
    (lR, (lRw, d)) = quasi_splitter ld lRAll (set rw);
    qempty = q_emptyc i dpp;
  } in (case bindb valid
               (\ _ ->
                 bindb (check
                         (if nfs
                           then (if not qempty then wwf_rulesa i dpp else True)
                           else True)
                         (shows_prec_list Zero_nat "well formedness required"))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM
                               (\ (l, ra) ->
                                 bindb (check_no_var l)
                                   (\ _ ->
                                     bindb (check_no_var ra)
                                       (\ _ ->
 check_no_defined_root (\ fn -> not (null (rules_mapb i dpp fn))) ra)))
                               (pairsa i dpp))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM (\ (l, _) -> check_no_var l)
                                   (rulesd i dpp))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             let {
                               q = qc i dpp;
                             } in bindb (if nfs && not qempty
  then check_wf_trs d else Inr ())
                                    (\ _ ->
                                      bindb (check_decra d)
(\ _ ->
  bindb (check_decr d)
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ qa ->
                  check (linear_term qa)
                    (shows_prec_list Zero_nat
                      "Q must not contain non-linear terms"))
                q)
              (\ x -> Inl (snd x)))
        (\ _ ->
          catch_errora
            (bindb (check_lhss_more lQ q)
              (\ _ ->
                bindb (check_sl_Q ld lQ q)
                  (\ _ ->
                    bindb (check_lab_all (set lP) p)
                      (\ _ ->
                        bindb (check_lab_all (set lPw) pw)
                          (\ _ ->
                            bindb (check_model_lab (set lR) r)
                              (\ _ ->
                                bindb (check_model_lab (set lRw) rw)
                                  (\ _ ->
                                    bindb (check_lab_all_trs lR r)
                                      (\ _ -> check_lab_all_trs lRw rw))))))))
            (\ x ->
              Inl (shows_string "problem during labeling:" .
                    shows_nl . x))))))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs m lP lPw lQ lR (lRw ++ d));
       });

eval_lab ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> Nat -> c -> d) -> (e -> b) -> Term a e -> (b, Term d e);
eval_lab i l lc alpha (Var x) = (alpha x, Var x);
eval_lab i l lc alpha (Fun f ts) =
  let {
    clts = map (eval_lab i l lc alpha) ts;
    cs = map fst clts;
    c = i f cs;
    lts = map snd clts;
  } in (c, Fun (lc f (size_list ts) (l f cs)) lts);

check_sl_rule_ass ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => Bool ->
                    (a -> [b] -> b) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          (b -> b -> Bool) ->
                            Set (Term d e, Term d e) ->
                              (e -> b) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_ass mc i la lc cge lR alpha (l, r) =
  let {
    cl_ll = eval_lab i la lc alpha l;
    cr_lr = eval_lab i la lc alpha r;
  } in bindb (check (if mc then cge (fst cl_ll) (fst cr_lr) else True)
               (shows_string "rule " .
                 shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                   (l, r) .
                   shows_string " violates the model condition, [lhs] = " .
                     shows_prec Zero_nat (fst cl_ll) .
                       shows_string ", [rhs] = " .
                         shows_prec Zero_nat (fst cr_lr)))
         (\ _ ->
           check (member (snd cl_ll, snd cr_lr) lR)
             (shows_string "labeled rule " .
               shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                 (snd cl_ll, snd cr_lr) .
                 shows_string " missing"));

check_sl_rule ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> d) ->
                        [b] ->
                          (b -> b -> Bool) ->
                            Bool ->
                              Set (Term d e, Term d e) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule i l lc c cge mc lR lr =
  catch_errora
    (forallM (\ alpha -> check_sl_rule_ass mc i l lc cge lR alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_model_lab_trs_set ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_model_lab_trs_set i l c cge labl lR r =
  catch_errora (forallM (check_sl_rule i l labl c cge True lR) r)
    (\ x -> Inl (snd x));

check_sl_model_lab_trs ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_model_lab_trs i l c cge labl lR r =
  check_sl_model_lab_trs_set i l c cge labl lR r;

check_NF_vars_subset ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_vars_subset qa q =
  catch_errora (forallM (\ qaa -> check (any (matches qaa) q) qaa) qa)
    (\ x -> Inl (snd x));

flatten_term_enum :: forall a b. Term [a] b -> [Term a b];
flatten_term_enum (Var x) = [Var x];
flatten_term_enum (Fun fs ts) =
  let {
    lts = map flatten_term_enum ts;
    ss = concat_lists lts;
  } in concatMap (\ f -> map (Fun f) ss) fs;

lab_lhss_more_impl ::
  forall a b c d.
    (a -> Nat -> b -> c) -> (a -> Nat -> [b]) -> [Term a d] -> [Term c d];
lab_lhss_more_impl lc lS_gen q =
  let {
    f_all = (\ (f, n) -> map (lc f n) (lS_gen f n));
  } in concatMap (\ qa -> flatten_term_enum (map_funs_term_wa f_all qa)) q;

check_sl_lab_lhss_more ::
  forall a b c.
    (Eq a, Showa a, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => (a -> Nat -> b -> a) ->
                    (a -> Nat -> [b]) ->
                      [Term a c] ->
                        [Term a c] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_lhss_more lc lS_gen lQ q =
  catch_errora (check_NF_vars_subset (lab_lhss_more_impl lc lS_gen q) lQ)
    (\ x ->
      Inl (shows_term (shows_prec Zero_nat) (shows_prec Zero_nat) x .
            shows_prec_list Zero_nat " is missing in labeled Q"));

sl_check_decr ::
  forall a b c d e.
    Sl_ops_ext a b c d e ->
      [(Term a d, Term a d)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sl_check_decr
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_check_decr;

lab_root ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> [b] -> c) ->
          (a -> Nat -> c -> d) -> (e -> b) -> Term a e -> Term d e;
lab_root i la l lc alpha (Fun f ts) =
  let {
    clts = map (eval_lab i la lc alpha) ts;
    cs = map fst clts;
    a = map snd clts;
  } in Fun (lc f (size_list ts) (l f cs)) a;
lab_root uu uv uw ux uy (Var x) = Var x;

check_sl_rule_all_ass ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          (c -> [c]) ->
                            Set (Term d e, Term d e) ->
                              (e -> b) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_all_ass i lb la lc gen_smaller lR alpha (l, Fun f ts) =
  let {
    ll = lab_root i lb la lc alpha l;
    clts = map (eval_lab i lb lc alpha) ts;
    lts = map snd clts;
    ld = la f (map fst clts);
    n = size_list ts;
    small = gen_smaller ld;
  } in catch_errora
         (forallM
           (\ le ->
             check (member (ll, Fun (lc f n le) lts) lR)
               (shows_string "labeled rule " .
                 shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                   (ll, Fun (lc f n le) lts) .
                   shows_string " missing"))
           small)
         (\ x -> Inl (snd x));
check_sl_rule_all_ass i lb la lc gen_smaller lR alpha (l, Var x) =
  let {
    ll = lab_root i lb la lc alpha l;
    lr = lab_root i lb la lc alpha (Var x);
  } in check (member (ll, lr) lR)
         (shows_string "labeled rule " .
           shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
             (ll, lr) .
             shows_string " missing");

check_sl_rule_all ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          [b] ->
                            (c -> [c]) ->
                              Set (Term d e, Term d e) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_all i la l lc c gen_smaller lR lr =
  catch_errora
    (forallM
      (\ alpha -> check_sl_rule_all_ass i la l lc gen_smaller lR alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_lab_all_trs ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        [b] ->
                          (c -> [c]) ->
                            (a -> Nat -> c -> d) ->
                              Set (Term d e, Term d e) ->
                                [(Term a e, Term a e)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_all_trs i la l c gen labl lP p =
  catch_errora (forallM (check_sl_rule_all i la l labl c gen lP) p)
    (\ x -> Inl (snd x));

check_wf_sym_F_all ::
  forall a b c.
    (Eq c,
      Showa c) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        (c, Nat) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_sym_F_all lc ld ls =
  (\ (lf, n) ->
    let {
      (f, l) = ld lf;
    } in check (ls f n l && lf == lc f n l)
           (shows_prec_list Zero_nat "labeled symbol " .
             shows_prec Zero_nat lf . shows_prec_list Zero_nat " not allowed"));

insert_funas_term :: forall a b. (Eq a) => Term a b -> [(a, Nat)] -> [(a, Nat)];
insert_funas_term (Var x) fs = fs;
insert_funas_term (Fun f ts) fs =
  insertb (f, size_list ts) (foldr insert_funas_term ts fs);

check_wf_terms_F_all ::
  forall a b c d.
    (Eq c,
      Showa c) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        Term c d -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_terms_F_all lc ld ls lt =
  let {
    lfs = insert_funas_term lt [];
  } in catch_errora (forallM (check_wf_sym_F_all lc ld ls) lfs)
         (\ x -> Inl (snd x));

check_Lab_all_trs ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        [(Term a c, Term a c)] ->
                          [(Term a c, Term a c)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_Lab_all_trs lc ld ls lR r =
  catch_errora
    (forallM
      (\ (l, ra) ->
        catch_errora
          (bindb (check_wf_terms_F_all lc ld ls ra)
            (\ _ ->
              check (membera r (map_funs_rule (\ lf -> fst (ld lf)) (l, ra)))
                (shows_prec_list Zero_nat
                  "unlabeling of the rule does not yield original rule")))
          (\ x ->
            Inl (shows_prec_list Zero_nat "problem with labeled rule" .
                  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                    (l, ra) .
                    shows_nl . x)))
      lR)
    (\ x -> Inl (snd x));

sl_LS_gen :: forall a b c d e. Sl_ops_ext a b c d e -> a -> Nat -> [c];
sl_LS_gen
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_LS_gen;

sl_lgen :: forall a b c d e. Sl_ops_ext a b c d e -> c -> [c];
sl_lgen
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_lgen;

lge_to_lgr ::
  forall a b.
    (Eq b) => (a -> Nat -> b -> b -> Bool) ->
                (a -> Nat -> b -> Bool) -> a -> Nat -> b -> b -> Bool;
lge_to_lgr lge ls f n =
  let {
    lSfn = ls f n;
    lgefn = lge f n;
  } in (\ l la -> not (l == la) && lSfn l && lSfn la && lgefn l la);

check_sl_decr_rule ::
  forall a b c d.
    (Eq a, Eq b, Eq c,
      Eq d) => (a -> Nat -> b -> c) ->
                 (c -> (a, b)) ->
                   (a -> Nat -> b -> Bool) ->
                     (a -> Nat -> b -> b -> Bool) ->
                       (Term c d, Term c d) -> Bool;
check_sl_decr_rule lc ld ls lge (Fun lf ts, Fun lg us) =
  let {
    (f, l1) = ld lf;
    (g, l2) = ld lg;
    n = size_list ts;
  } in f == g &&
         ts == us &&
           lf == lc f n l1 &&
             lg == lc f n l2 &&
               ls f n l1 && ls f n l2 && lge_to_lgr lge ls f n l1 l2;
check_sl_decr_rule uu uv uw ux (Var vb, va) = False;
check_sl_decr_rule uu uv uw ux (v, Var vb) = False;

check_sl_decr ::
  forall a b c d.
    (Eq a, Eq b, Eq c, Showa c, Eq d,
      Showa d) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        (a -> Nat -> b -> b -> Bool) ->
                          [(Term c d, Term c d)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_decr lc ld ls lge d =
  catch_errora
    (forallM
      (\ lr ->
        check (check_sl_decr_rule lc ld ls lge lr)
          (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " lr .
            shows_prec_list Zero_nat " is not a decreasing rule"))
      d)
    (\ x -> Inl (snd x));

sl_LS :: forall a b c d e. Sl_ops_ext a b c d e -> a -> Nat -> c -> Bool;
sl_LS (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
        sl_LS_gen more)
  = sl_LSa;

sl_La :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> c;
sl_La (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
        sl_LS_gen more)
  = sl_L;

sl_L :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> c;
sl_L (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_La;

sl_I :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> b;
sl_I (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_I;

sl_C :: forall a b c d e. Sl_ops_ext a b c d e -> [b];
sl_C (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_C;

insert_funas_args_term ::
  forall a b. (Eq a) => Term a b -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_term t fs = foldr insert_funas_term (args t) fs;

insert_funas_args_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_rule r fs =
  insert_funas_args_term (fst r) (insert_funas_args_term (snd r) fs);

insert_funas_args_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_funas_args_trs trs = foldr insert_funas_args_rule trs;

option_to_list :: forall a. Maybe a -> [a];
option_to_list (Just a) = [a];
option_to_list Nothing = [];

insert_roots_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_roots_rule r fs =
  foldr insertb (option_to_list (root (fst r)) ++ option_to_list (root (snd r)))
    fs;

insert_roots_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_roots_trs trs = foldr insert_roots_rule trs;

insert_funas_rule ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)] -> [(a, Nat)];
insert_funas_rule r fs =
  insert_funas_term (fst r) (insert_funas_term (snd r) fs);

insert_funas_trs ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)] -> [(a, Nat)];
insert_funas_trs trs = foldr insert_funas_rule trs;

sem_lab_fin_quasi_root_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Eq b, Showa c, Ceq e, Ccompare e, Compare e,
      Eq e, Mapping_impl e, Set_impl e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      (c -> c -> Bool) ->
                        (a -> Nat -> b -> b -> Bool) ->
                          Dpp_ops_ext d a e () ->
                            ([(a, Nat)] ->
                              [(a, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char])
                                  (Sl_ops_ext a c b e ())) ->
                              [(Term a e, Term a e)] ->
                                [Term a e] ->
                                  [(Term a e, Term a e)] ->
                                    d -> Sum ([Prelude.Char] -> [Prelude.Char])
   d;
sem_lab_fin_quasi_root_proc lc ld cge lge i gen lPAll lQ lRAll dp =
  let {
    pairs = pairsa i dp;
  } in bindb (gen (list_union (insert_funas_trs (rulesd i dp) [])
                    (insert_funas_args_trs pairs []))
               (insert_roots_trs pairs []))
         (\ ops ->
           let {
             check_d = sl_check_decr ops;
             check_da = check_sl_decr lc ld (sl_LS ops) lge;
             check_q = check_sl_lab_lhss_more lc (sl_LS_gen ops);
             check_ml =
               check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) cge lc;
             check_l =
               check_sl_lab_all_trs (sl_I ops) (sl_L ops) (sl_La ops) (sl_C ops)
                 (sl_lgen ops) lc;
             check_la = check_Lab_all_trs lc ld (sl_LS ops);
           } in sem_lab_quasi_root_proc ld i (Inr ()) check_d check_da check_q
                  check_l check_la check_ml lPAll lQ lRAll dp);

check_sl_rule_root ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          [b] ->
                            Set (Term d e, Term d e) ->
                              (Term a e, Term a e) ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_root i la l lc c lR lr =
  catch_errora
    (forallM
      (\ alpha ->
        let {
          laa = lab_root i la l lc alpha;
          lb = laa (fst lr);
          r = laa (snd lr);
        } in check (member (lb, r) lR)
               (shows_prec_list Zero_nat "labeled rule " .
                 shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                   (lb, r) .
                   shows_prec_list Zero_nat " is missing"))
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_sl_lab_root_trs ::
  forall a b c d e.
    (Showa a, Showa b, Compare d, Eq d, Showa d, Compare e, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        [b] ->
                          (a -> Nat -> c -> d) ->
                            Set (Term d e, Term d e) ->
                              [(Term a e, Term a e)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_root_trs i la l c labl lP p =
  catch_errora (forallM (check_sl_rule_root i la l labl c lP) p)
    (\ x -> Inl (snd x));

sem_lab_root_proc ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([Term a d] ->
                          [Term a d] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Set (Term a d, Term a d) ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                [(Term a d, Term a d)] ->
                                  [Term a d] ->
                                    [(Term a d, Term a d)] ->
                                      c ->
Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_root_proc ld i valid check_Q check_laba check_lab check_model_lab lPAll
  lQ lRAll dpp =
  let {
    r = rc i dpp;
    rw = rwc i dpp;
    pw = pwa i dpp;
    p = pa i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll (set pw);
    (lR, (lRw, _)) = model_splitter ld lRAll (set rw);
  } in (case bindb valid
               (\ _ ->
                 bindb (catch_errora
                         (forallM
                           (\ (l, ra) ->
                             bindb (check_no_var l)
                               (\ _ ->
                                 bindb (check_no_var ra)
                                   (\ _ ->
                                     check_no_defined_root
                                       (\ fn ->
 not (null (rules_mapb i dpp fn)))
                                       ra)))
                           (pairsa i dpp))
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM (\ (l, _) -> check_no_var l)
                               (rulesd i dpp))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         let {
                           q = qc i dpp;
                         } in catch_errora
                                (bindb
                                  (check
                                    (if nfs
                                      then (if not (q_emptyc i dpp)
     then wwf_rulesa i dpp else True)
                                      else True)
                                    (shows_prec_list Zero_nat
                                      "well formedness required"))
                                  (\ _ ->
                                    bindb (check_Q lQ q)
                                      (\ _ ->
bindb (check_sl_Q ld lQ q)
  (\ _ ->
    bindb (check_laba (set lP) p)
      (\ _ ->
        bindb (check_laba (set lPw) pw)
          (\ _ ->
            bindb (check_model_lab (set lR) r)
              (\ _ ->
                bindb (check_model_lab (set lRw) rw)
                  (\ _ ->
                    bindb (check_lab lR r) (\ _ -> check_lab lRw rw)))))))))
                                (\ x ->
                                  Inl (shows_string "problem during labeling:" .
shows_nl . x)))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs m lP lPw lQ lR lRw);
       });

lab_rule_ass ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> Nat -> c -> d) ->
          (e -> b) -> (Term a e, Term a e) -> (Term d e, Term d e);
lab_rule_ass i l lc alpha rule =
  (snd (eval_lab i l lc alpha (fst rule)),
    snd (eval_lab i l lc alpha (snd rule)));

lab_rule_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) ->
                    [b] -> (Term a e, Term a e) -> [(Term d e, Term d e)];
lab_rule_list i l lc c lr =
  map (\ alpha -> lab_rule_ass i l lc alpha lr)
    (map fun_of (enum_vectors c (insert_vars_rule lr [])));

lab_trs_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) ->
                    [b] -> [(Term a e, Term a e)] -> [(Term d e, Term d e)];
lab_trs_list i l lc c r = concatMap (lab_rule_list i l lc c) r;

check_sl_lab ::
  forall a b c d.
    (Eq a, Showa a, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> a) ->
                        [b] ->
                          [(Term a d, Term a d)] ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab i l lc c lR r =
  bindb (check (not (null c))
          (shows_prec_list Zero_nat "carrier must be non-empty"))
    (\ _ ->
      catch_errora (check_subseteq lR (lab_trs_list i l lc c r))
        (\ x ->
          Inl (shows_prec_list Zero_nat "labeled rule " .
                shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                  x .
                  shows_prec_list Zero_nat " is not allowed")));

lab_lhs_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) -> [b] -> Term a e -> [Term d e];
lab_lhs_list i l lc c t =
  map (\ alpha -> snd (eval_lab i l lc alpha t))
    (map fun_of (enum_vectors c (insert_vars_term t [])));

lab_lhss_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) -> [b] -> [Term a e] -> [Term d e];
lab_lhss_list i l lc c q = concatMap (lab_lhs_list i l lc c) q;

check_sl_Qa ::
  forall a b c d.
    (Eq a, Showa a, Ccompare d, Eq d, Mapping_impl d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> a) ->
                        [b] ->
                          [Term a d] ->
                            [Term a d] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_Qa i l lc c lQ q =
  bindb (check (not (null c))
          (shows_prec_list Zero_nat "carrier must be non-empty"))
    (\ _ ->
      catch_errora (check_NF_vars_subset (lab_lhss_list i l lc c q) lQ)
        (\ x ->
          Inl (shows_prec_list Zero_nat "labeled term " .
                shows_term (shows_prec Zero_nat) (shows_prec Zero_nat) x .
                  shows_prec_list Zero_nat " is missing")));

sem_lab_fin_root_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d, Eq e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      Dpp_ops_ext c a d () ->
                        ([(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              (Sl_ops_ext a e b d ())) ->
                          [(Term a d, Term a d)] ->
                            [Term a d] ->
                              [(Term a d, Term a d)] ->
                                c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_fin_root_proc lc ld i gen lPAll lQ lRAll dp =
  let {
    pairs = pairsa i dp;
  } in bindb (gen (list_union (insert_funas_trs (rulesd i dp) [])
                    (insert_funas_args_trs pairs []))
               (insert_roots_trs pairs []))
         (\ ops ->
           let {
             check_q = check_sl_Qa (sl_I ops) (sl_L ops) lc (sl_C ops);
             check_ml =
               check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops)
                 (\ a b -> a == b) lc;
             check_l =
               check_sl_lab_root_trs (sl_I ops) (sl_L ops) (sl_La ops)
                 (sl_C ops) lc;
             check_la = check_sl_lab (sl_I ops) (sl_L ops) lc (sl_C ops);
           } in sem_lab_root_proc ld i (Inr ()) check_q check_l check_la
                  check_ml lPAll lQ lRAll dp);

slm_La :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> c;
slm_La (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_L;

slm_c :: forall a b c d. Slm_ops_ext a b c d -> b;
slm_c (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_c;

slm_L :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> c;
slm_L (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_La;

slm_I :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> b;
slm_I (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_I;

slm_C :: forall a b c d. Slm_ops_ext a b c d -> [b];
slm_C (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_C;

slm_to_sl :: forall a b c d. Slm_ops_ext a b c () -> Sl_ops_ext a b c d ();
slm_to_sl ops =
  Sl_ops_ext (slm_L ops) (\ _ _ _ -> True) (slm_I ops) (slm_C ops) (slm_c ops)
    (\ _ -> Inr ()) (slm_La ops) (\ _ _ _ -> True) (\ l -> [l]) (\ _ _ -> [])
    ();

slm_gen_to_sl_gen ::
  forall a b c d.
    ([(a, Nat)] ->
      [(a, Nat)] ->
        Sum ([Prelude.Char] -> [Prelude.Char]) (Slm_ops_ext a b c ())) ->
      [(a, Nat)] ->
        [(a, Nat)] ->
          Sum ([Prelude.Char] -> [Prelude.Char]) (Sl_ops_ext a b c d ());
slm_gen_to_sl_gen gen =
  (\ f g -> bindb (gen f g) (\ ops -> Inr (slm_to_sl ops)));

check_sl_lab_trs_set ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_trs_set i l c cge labl lP p =
  catch_errora (forallM (check_sl_rule i l labl c cge False lP) p)
    (\ x -> Inl (snd x));

check_sl_lab_trs ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Showa b, Compare d, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_trs i l c cge labl lP p = check_sl_lab_trs_set i l c cge labl lP p;

sem_lab_proc ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([Term a d] ->
                          [Term a d] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Set (Term a d, Term a d) ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              (Set (Term a d, Term a d) ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                [(Term a d, Term a d)] ->
                                  [Term a d] ->
                                    [(Term a d, Term a d)] ->
                                      c ->
Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_proc ld i valid check_Q check_laba check_lab check_model_lab lPAll lQ
  lRAll dpp =
  let {
    r = rc i dpp;
    rw = rwc i dpp;
    pw = pwa i dpp;
    p = pa i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll (set pw);
    (lR, (lRw, _)) = model_splitter ld lRAll (set rw);
  } in (case bindb valid
               (\ _ ->
                 let {
                   q = qc i dpp;
                 } in catch_errora
                        (bindb
                          (check
                            (if nfs
                              then (if not (q_emptyc i dpp)
                                     then wwf_rulesa i dpp else True)
                              else True)
                            (shows_prec_list Zero_nat
                              "well formedness required"))
                          (\ _ ->
                            bindb (check_Q lQ q)
                              (\ _ ->
                                bindb (check_sl_Q ld lQ q)
                                  (\ _ ->
                                    bindb (check_laba (set lP) p)
                                      (\ _ ->
bindb (check_laba (set lPw) pw)
  (\ _ ->
    bindb (check_model_lab (set lR) r)
      (\ _ ->
        bindb (check_model_lab (set lRw) rw)
          (\ _ -> bindb (check_lab lR r) (\ _ -> check_lab lRw rw)))))))))
                        (\ x ->
                          Inl (shows_string "problem during labeling:" .
                                shows_nl . x)))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs m lP lPw lQ lR lRw);
       });

sem_lab_fin_proc ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Ccompare d, Compare d, Eq d, Mapping_impl d,
      Showa d, Eq e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      Dpp_ops_ext c a d () ->
                        ([(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              (Sl_ops_ext a e b d ())) ->
                          [(Term a d, Term a d)] ->
                            [Term a d] ->
                              [(Term a d, Term a d)] ->
                                c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_fin_proc lc ld i gen lPAll lQ lRAll dp =
  bindb (gen (list_union (insert_funas_trs (rulesd i dp) [])
               (insert_funas_args_trs (pairsa i dp) []))
          [])
    (\ ops ->
      let {
        check_q = check_sl_Qa (sl_I ops) (sl_L ops) lc (sl_C ops);
        check_ml =
          check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops)
            (\ a b -> a == b) lc;
        check_l =
          check_sl_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) (\ a b -> a == b)
            lc;
        check_la = check_sl_lab (sl_I ops) (sl_L ops) lc (sl_C ops);
      } in sem_lab_proc ld i (Inr ()) check_q check_l check_la check_ml lPAll lQ
             lRAll dp);

get_largest_element :: forall a. Sl_inter a -> Nat;
get_largest_element (SL_Inter n uu) = n;

take_default :: forall a. a -> [a] -> Nat -> a;
take_default def [] uu = def;
take_default uv (x : xs) i =
  (if equal_nat i Zero_nat then x
    else take_default uv xs (minus_nat i (Nat_of_num One)));

eval_arithFun :: Nat -> [Nat] -> ArithFun -> Nat;
eval_arithFun c nats f = mod_nat (eval_arithFun_unbound c nats f) c;

eval_arithFun_unbound :: Nat -> [Nat] -> ArithFun -> Nat;
eval_arithFun_unbound c nats (Arg i) = take_default Zero_nat nats i;
eval_arithFun_unbound c nats (Const n) = n;
eval_arithFun_unbound c nats (Sum []) = Zero_nat;
eval_arithFun_unbound c nats (Sum (f : fs)) =
  plus_nat (eval_arithFun c nats f) (eval_arithFun c nats (Sum fs));
eval_arithFun_unbound c nats (Prod []) = Nat_of_num One;
eval_arithFun_unbound c nats (Prod (f : fs)) =
  times_nat (eval_arithFun c nats f) (eval_arithFun c nats (Prod fs));
eval_arithFun_unbound c nats (Max [f]) = eval_arithFun c nats f;
eval_arithFun_unbound c nats (Max (f : v : va)) =
  max (eval_arithFun c nats f) (eval_arithFun c nats (Max (v : va)));
eval_arithFun_unbound c nats (Min [f]) = eval_arithFun c nats f;
eval_arithFun_unbound c nats (Min (f : v : va)) =
  min (eval_arithFun c nats f) (eval_arithFun c nats (Min (v : va)));
eval_arithFun_unbound c nats (IfEqual f1 f2 ft fe) =
  (if equal_nat (eval_arithFun c nats f1) (eval_arithFun c nats f2)
    then eval_arithFun c nats ft else eval_arithFun c nats fe);

sl_inter_to_inter :: forall a. (Eq a) => Sl_inter a -> a -> [Nat] -> Nat;
sl_inter_to_inter (SL_Inter c ls) fl cs =
  (case map_of ls (fl, size_list cs) of {
    Nothing -> Zero_nat;
    Just a -> eval_arithFun (plus_nat c (Nat_of_num One)) cs a;
  });

sli_to_slm ::
  forall a.
    (Eq a) => Sl_inter (Lab a [Nat]) ->
                Slm_ops_ext (Lab a [Nat]) Nat (Sum [Nat] [Lab a [Nat]]) ();
sli_to_slm sli =
  let {
    c = get_largest_element sli;
  } in Slm_ops_ext (\ _ -> Inl) (sl_inter_to_inter sli)
         (upt Zero_nat (plus_nat c (Nat_of_num One))) c (\ _ -> Inl) ();

enum_vectors_nat :: forall a. [a] -> Nat -> [[a]];
enum_vectors_nat c n =
  (if equal_nat n Zero_nat then [[]]
    else let {
           a = enum_vectors_nat c (minus_nat n (Nat_of_num One));
         } in concatMap (\ vec -> map (\ ca -> ca : vec) c) a);

qmodel_check_interpretation ::
  ArithFun -> Nat -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_interpretation f n c =
  let {
    ca = upt Zero_nat (plus_nat c (Nat_of_num One));
    css = enum_vectors_nat ca n;
  } in catch_errora
         (forallM
           (\ cs ->
             catch_errora
               (forallM
                 (\ i ->
                   catch_errora
                     (forallM
                       (\ l ->
                         check (less_eq_nat
                                 (eval_arithFun (plus_nat c (Nat_of_num One)) cs
                                   f)
                                 (eval_arithFun (plus_nat c (Nat_of_num One))
                                   (list_update cs i l) f))
                           (shows_prec_list Zero_nat "not monotone in " .
                             shows_prec_nat Zero_nat
                               (plus_nat i (Nat_of_num One)) .
                               shows_prec_list Zero_nat ". argument"))
                       (upt (nth cs i) (plus_nat c (Nat_of_num One))))
                     (\ x -> Inl (snd x)))
                 (upt Zero_nat n))
               (\ x -> Inl (snd x)))
           css)
         (\ x -> Inl (snd x));

qmodel_check_valid ::
  forall a.
    (Showa a) => Sl_inter a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_valid (SL_Inter c ls) =
  catch_errora
    (forallM
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ g ->
               catch_errora (qmodel_check_interpretation g n c)
                 (\ x ->
                   Inl (shows_prec_list Zero_nat
                          "problem in weak-monotonicity of interpretation of " .
                         shows_prec Zero_nat f . shows_nl . x)))
          b)
      ls)
    (\ x -> Inl (snd x));

check_decr_present_aux_1 ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a (b, Nat), Term a (b, Nat))] ->
                           b -> a -> a -> Nat ->
    Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present_aux_1 r v f1 f2 n =
  let {
    vs = map (\ na -> Var (v, na)) (upt Zero_nat n);
    rule = (Fun f1 vs, Fun f2 vs);
  } in check (not (is_none (find (instance_rule rule) r))) rule;

check_decr_present_aux_2 ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           b -> [(a, (a, Nat))] ->
                                  Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present_aux_2 r v req =
  let {
    add_nats = map_term (\ x -> x) (\ va -> (va, Zero_nat));
    ra = map (\ (l, ra) -> (add_nats l, add_nats ra)) r;
  } in catch_errora
         (forallM
           (\ (f1, a) ->
             let {
               (aa, b) = a;
             } in check_decr_present_aux_1 ra v f1 aa b)
           req)
         (\ x -> Inl (snd x));

check_decr_present ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(a, Nat)] ->
                           (a -> [Nat] -> a) ->
                             b -> Nat ->
                                    [(Term a b, Term a b)] ->
                                      Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present sig l v c r =
  let {
    ca = upt Zero_nat (plus_nat c (Nat_of_num One));
    ls = (\ (f, n) ->
           concatMap
             (\ cs ->
               concatMap
                 (\ i ->
                   let {
                     ci = nth cs i;
                   } in (if less_nat ci c
                          then [(l f (list_update cs i
                                       (plus_nat ci (Nat_of_num One))),
                                  (l f cs, n))]
                          else []))
                 (upt Zero_nat n))
             (enum_vectors_nat ca n));
  } in check_decr_present_aux_2 r v (concatMap ls sig);

qmodel_check_decr ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b,
      Mapping_impl b) => [(Lab a [Nat], Nat)] ->
                           b -> Nat ->
                                  [(Term (Lab a [Nat]) b,
                                     Term (Lab a [Nat]) b)] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_decr sig v c =
  (\ lR ->
    catch_errora (check_decr_present sig Lab v c lR)
      (\ x ->
        Inl (let {
               display =
                 map_term (\ xa -> xa)
                   (\ (_, n) ->
                     (shows_prec_list Zero_nat "x" . shows_prec_nat Zero_nat n)
                       []);
             } in shows_prec_list Zero_nat "decreasing rule " .
                    shows_rule (shows_prec_lab Zero_nat)
                      (shows_prec_list Zero_nat) " -> "
                      (display (fst x), display (snd x)) .
                      shows_prec_list Zero_nat " missing")));

qmodel_LS_gen ::
  forall a b c. (Eq a) => [(a, Nat)] -> [b] -> a -> Nat -> [Sum [b] c];
qmodel_LS_gen sig ls =
  (\ f n ->
    (if membera sig (f, n) then map Inl (enum_vectors_nat ls n) else [Inl []]));

pointwise_lgen :: [Nat] -> [[Nat]];
pointwise_lgen ns =
  concat_lists (map (\ n -> upt Zero_nat (plus_nat n (Nat_of_num One))) ns);

qmodel_lgen :: forall a. Sum [Nat] a -> [Sum [Nat] a];
qmodel_lgen l =
  (case l of {
    Inl ns -> map Inl (pointwise_lgen ns);
    Inr _ -> [];
  });

qmodel_LSa :: forall a. Lab a [Nat] -> Nat -> Sum [Nat] [Lab a [Nat]] -> Bool;
qmodel_LSa = (\ _ _ a -> (case a of {
                           Inl _ -> True;
                           Inr _ -> False;
                         }));

qmodel_LS ::
  forall a b c.
    (Eq a, Eq b, Eq c) => [(a, Nat)] -> [b] -> a -> Nat -> Sum [b] c -> Bool;
qmodel_LS sig ls = (\ f n -> membera (qmodel_LS_gen sig ls f n));

qmodel_L ::
  forall a b c d.
    (Eq a, Eq b) => [(Lab a b, Nat)] -> Lab a b -> [c] -> Sum [c] d;
qmodel_L sig =
  (\ f cs -> (if membera sig (f, size_list cs) then Inl cs else Inl []));

qsli_to_sl_unsafe ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Showa b) => a -> [(Lab b [Nat], Nat)] ->
                         [(Lab b [Nat], Nat)] ->
                           Sl_inter (Lab b [Nat]) ->
                             Sl_ops_ext (Lab b [Nat]) Nat
                               (Sum [Nat] [Lab b [Nat]]) a ();
qsli_to_sl_unsafe v f g sli =
  let {
    c = get_largest_element sli;
    ca = upt Zero_nat (plus_nat c (Nat_of_num One));
  } in Sl_ops_ext (qmodel_L f) (qmodel_LS f ca) (sl_inter_to_inter sli) ca c
         (qmodel_check_decr f v c) (qmodel_L g) qmodel_LSa qmodel_lgen
         (qmodel_LS_gen f ca) ();

qsli_to_sl ::
  forall a b.
    (Ccompare a, Eq a, Mapping_impl a, Eq b,
      Showa b) => a -> [(Lab b [Nat], Nat)] ->
                         [(Lab b [Nat], Nat)] ->
                           Sl_inter (Lab b [Nat]) ->
                             Sum ([Prelude.Char] -> [Prelude.Char])
                               (Sl_ops_ext (Lab b [Nat]) Nat
                                 (Sum [Nat] [Lab b [Nat]]) a ());
qsli_to_sl v f g sli =
  bindb (qmodel_check_valid sli) (\ _ -> Inr (qsli_to_sl_unsafe v f g sli));

pointwise_ext ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
pointwise_ext f [] [] = (False, True);
pointwise_ext f (uu : uv) [] = (False, False);
pointwise_ext f [] (uw : ux) = (False, False);
pointwise_ext f (a : asa) (b : bs) =
  (case f a b of {
    (stri, True) ->
      (case pointwise_ext f asa bs of {
        (strir, True) -> (stri || strir, True);
        (_, False) -> (False, False);
      });
    (_, False) -> (False, False);
  });

qmodel_lge :: forall a b c d. a -> b -> Sum [Nat] c -> Sum [Nat] d -> Bool;
qmodel_lge f n =
  (\ l r ->
    (case (l, r) of {
      (Inl cs1, Inl cs2) ->
        snd (pointwise_ext (\ x y -> (less_nat y x, less_eq_nat y x)) cs1 cs2);
      (Inl _, Inr _) -> False;
      (Inr _, _) -> False;
    }));

qmodel_cge :: Nat -> Nat -> Bool;
qmodel_cge = (\ x y -> less_eq_nat y x);

rl_slm ::
  forall a b.
    (Eq a,
      Eq b) => Maybe (Lab a b, Nat) ->
                 [(Lab a b, Nat)] ->
                   [(Lab a b, Nat)] ->
                     Sum ([Prelude.Char] -> [Prelude.Char])
                       (Slm_ops_ext (Lab a b) (Lab a b) (Sum b [Lab a b]) ());
rl_slm delt_opt pre_fs g =
  let {
    fs = (if is_none delt_opt then pre_fs
           else filter (\ f -> not (f == the delt_opt)) pre_fs);
  } in bindb (check (not (null fs))
               (shows_string
                  "root-labeling requires at least one function symbol in the signature" .
                 shows_nl))
         (\ _ ->
           let {
             f = fst (hd fs);
           } in Inr (Slm_ops_ext (\ _ -> Inr)
                      (\ ga cs ->
                        (if membera fs (ga, size_list cs) then ga else f))
                      (map fst fs) f
                      (if is_none delt_opt then (\ _ -> Inr)
                        else (\ _ gs ->
                               Inr (replicate (size_list gs)
                                     (fst (the delt_opt)))))
                      ()));

semlab_fin_proc ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a (Lab b [Nat]) c () ->
                    Sl_variant (Lab b [Nat]) c ->
                      [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                        [Term (Lab b [Nat]) c] ->
                          [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
semlab_fin_proc j (Rootlab Nothing) =
  sem_lab_fin_proc label label_decomp j (slm_gen_to_sl_gen (rl_slm Nothing));
semlab_fin_proc j (Rootlab (Just d)) =
  sem_lab_fin_root_proc label label_decomp j
    (slm_gen_to_sl_gen (rl_slm (Just d)));
semlab_fin_proc j (Finitelab sli) =
  sem_lab_fin_proc label label_decomp j
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli)));
semlab_fin_proc j (QuasiFinitelab sli v) =
  sem_lab_fin_quasi_root_proc label label_decomp qmodel_cge qmodel_lge j
    (\ f g -> qsli_to_sl v f g sli);

all_terms_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    [([Term a [Prelude.Char]], Term a [Prelude.Char])];
all_terms_impl rr initt =
  remdups
    (map (\ (ss, (t, _)) -> (ss, t)) initt ++ map (\ (l, a) -> (args l, a)) rr);

all_subterms_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    [([Term a [Prelude.Char]], Term a [Prelude.Char])];
all_subterms_impl rr initt =
  remdups
    (concatMap (\ (ss, s) -> map (\ a -> (ss, a)) (supteq_list s))
      (all_terms_impl rr initt));

everything_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    [Sum ([Term a [Prelude.Char]],
                           (Term a [Prelude.Char],
                             (Term a [Prelude.Char], Term a [Prelude.Char])))
                       ((a, Nat), Nat)];
everything_impl rr initt =
  map Inl
    (concatMap
      (\ (ss, t) ->
        map (\ lr -> (ss, (t, lr))) (remdups (map (snd . snd) initt)))
      (all_subterms_impl rr initt)) ++
    remdups
      (map Inr
        (concatMap
          (\ t ->
            (if not (is_Var t)
              then concatMap
                     (\ (f, ts) ->
                       map (\ a -> ((f, size_list ts), a))
                         (upt Zero_nat (size_list ts)))
                     (let {
                        (Fun f ts) = t;
                      } in [(f, ts)])
              else []))
          (remdups (map snd (all_subterms_impl rr initt)))));

generate_impl ::
  forall a b c d.
    (Eq a, Key a, Eq b,
      Eq c) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                 (Term a [Prelude.Char] -> Bool) ->
                   ([Term a [Prelude.Char]] ->
                     Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                     ([Term a [Prelude.Char]] ->
                       Term a [Prelude.Char] -> [(b, c)]) ->
                       Sum ([Term a [Prelude.Char]],
                             (Term a [Prelude.Char], (b, c)))
                         d ->
                         [Sum ([Term a [Prelude.Char]],
                                (Term a [Prelude.Char], (b, c)))
                            ((a, Nat), Nat)];
generate_impl rr nfq e_cap uu (Inr v) = [];
generate_impl rr nfq e_cap uu (Inl (va, (Var ve, vd))) = [];
generate_impl rr nfq e_cap uu (Inl (ss, (Fun f ts, (l, r)))) =
  concatMap
    (\ i ->
      (if membera (uu ss (nth ts i)) (l, r)
        then map (\ u -> u)
               [Inl (ss, (nth ts i, (l, r))), Inr ((f, size_list ts), i)]
        else []))
    (upt Zero_nat (size_list ts)) ++
    concatMap
      (\ (la, ra) ->
        concatMap
          (\ mss ->
            (if rule_match_impl nfq (e_cap mss) mss f
                  (map (map_term (\ x -> x) (\ a -> 'x' : a)) ts) la
              then (if membera (uu (args la) ra) (l, r)
                     then [Inl (args la, (ra, (l, r)))] else [])
              else []))
          [map (map_term (\ x -> x) (\ a -> 'x' : a)) ss])
      rr;

mu_approx_impl ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [([Term a [Prelude.Char]],
                     (Term a [Prelude.Char],
                       (Term a [Prelude.Char], Term a [Prelude.Char])))] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])]) ->
                      (Term a [Prelude.Char] -> Bool) ->
                        ([Term a [Prelude.Char]] ->
                          Term a [Prelude.Char] ->
                            Term a (Sum () [Prelude.Char])) ->
                          ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
mu_approx_impl rr initt u_impl nfq e_cap =
  let {
    uu = precompute_fun (\ (a, b) -> u_impl a b) (all_subterms_impl rr initt);
    uua = (\ s t -> uu (s, t));
    fis = remdups
            (concatMap
              (\ entry ->
                map (\ fi -> fi)
                  (case entry of {
                    Inl _ -> [];
                    Inr fi -> [fi];
                  }))
              (inductive_set_impl (everything_impl rr initt) equal_sum
                (generate_impl rr nfq e_cap uua) (map Inl initt)));
    fs = remdups (map fst fis);
    mu = (\ f ->
           set (map_filter
                 (\ x ->
                   (if let {
                         (g, _) = x;
                       } in g == f
                     then Just (snd x) else Nothing))
                 fis));
  } in (fs, (precompute_fun mu fs, "innermost URM wrt. specific rules"));

inn_usable_rules_wf ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  ([Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      Bool ->
                        ([Term a [Prelude.Char]], Term a [Prelude.Char]) ->
                          [(Term a [Prelude.Char], Term a [Prelude.Char])];
inn_usable_rules_wf nfq e_cap r nfs =
  (\ (ss, t) ->
    (if nfs ||
          all (\ x -> any (contains_var_term x) ss) (remdups (vars_term_list t))
      then ur_calc_singleton nfq e_cap r (ss, t) else r));

inn_usable_rules_wf_dpp ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> Bool ->
                         ([Term b [Prelude.Char]], Term b [Prelude.Char]) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])];
inn_usable_rules_wf_dpp i d nfs =
  inn_usable_rules_wf (is_QNFc i d) (icap_impl_dpp i d) (rulesd i d) nfs;

get_innermost_strict_repl_map_dpp ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                         ([(b, Nat)], ((b, Nat) -> Set Nat, [Prelude.Char]));
get_innermost_strict_repl_map_dpp i d s =
  let {
    r = rulesd i d;
    p = pairsa i d;
    isNF = is_QNFc i d;
    u = inn_usable_rules_wf_dpp i d True;
    a = icap_impl_dpp i d;
  } in mu_approx_impl r
         (concatMap (\ (sa, t) -> map (\ lr -> ([sa], (t, lr))) s) p)
         (\ ss t -> u (ss, t)) isNF a;

show_position_set ::
  forall a. (a, Nat) -> Set Nat -> [Prelude.Char] -> [Prelude.Char];
show_position_set f s =
  shows_list_nat
    (concatMap
      (\ i -> (if member i s then [plus_nat i (Nat_of_num One)] else []))
      (upt Zero_nat (snd f)));

mono_af :: forall a b c. Redtriple_ext a b c -> (a, Nat) -> Set Nat;
mono_af (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  mono_af;

mono_urm_redpair_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_urm_redpair_proc i rp premove rremove dpp =
  (case catch_errora
          (let {
             (ps, pns) = split_pairsa i dpp premove;
             (rs, rns) = split_rulesc i dpp rremove;
             r = rulesd i dpp;
             _ = qc i dpp;
             p = pairsa i dpp;
           } in bindb (check_wf_trs p)
                  (\ _ ->
                    bindb (check_wf_trs r)
                      (\ _ ->
                        bindb (check (nFQ_subset_NF_rulesc i dpp)
                                (shows_prec_list Zero_nat "innermost required"))
                          (\ _ ->
                            let {
                              (fs, (mu, info)) =
                                get_innermost_strict_repl_map_dpp i dpp rs;
                            } in bindb (valid rp)
                                   (\ _ ->
                                     let {
                                       mua = mono_af rp;
                                     } in bindb
    (catch_errora
      (catch_errora
        (forallM
          (\ f ->
            check (subset (mu f) (mua f))
              (shows_string "error in monotonicity: strict order for " .
                shows_prec_prod Zero_nat f .
                  shows_string " ensures monotonicity in positions " .
                    show_position_set f (mua f) .
                      shows_string "\nbut usable replacement map is " .
                        show_position_set f (mu f)))
          fs)
        (\ x -> Inl (snd x)))
      (\ x ->
        Inl (x . shows_string "\nthe computed usable replacement map (" .
                   shows_string info .
                     shows_string ") is\n" .
                       shows_sep
                         (\ f ->
                           shows_prec_list Zero_nat "mu(" .
                             shows_prec_prod Zero_nat f .
                               shows_prec_list Zero_nat ") = " .
                                 show_position_set f (mu f))
                         shows_nl fs .
                         shows_prec_list Zero_nat
                           "\nand mu(f) = {} for all other symbols f")))
    (\ _ ->
      bindb (catch_errora
              (catch_errora (forallM (ns rp) rns) (\ x -> Inl (snd x)))
              (\ x ->
                Inl (shows_string "problem when orienting TRS" . shows_nl . x)))
        (\ _ ->
          bindb (catch_errora
                  (catch_errora (forallM (s rp) rs) (\ x -> Inl (snd x)))
                  (\ x ->
                    Inl (shows_string "problem when orienting TRS" .
                          shows_nl . x)))
            (\ _ ->
              bindb (catch_errora
                      (catch_errora (forallM (ns rp) pns) (\ x -> Inl (snd x)))
                      (\ x ->
                        Inl (shows_string "problem when orienting DPs" .
                              shows_nl . x)))
                (\ _ ->
                  catch_errora
                    (catch_errora (forallM (s rp) ps) (\ x -> Inl (snd x)))
                    (\ x ->
                      Inl (shows_string "problem when orienting DPs" .
                            shows_nl . x)))))))))))
          (\ x ->
            Inl (shows_string
                   "could not apply the reduction pair processor with usable repl. maps and the following" .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

partition_rules ::
  forall a b.
    (Eq a,
      Eq b) => [Ctxt a b] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     ([(Term a b, Term a b)], [(Term a b, Term a b)]);
partition_rules cs r =
  partition
    (\ lr ->
      any (\ (u, v) ->
            any (\ c -> lr == (ctxt_apply_term c u, ctxt_apply_term c v))
              (Hole : cs))
        r);

strip_unary_root :: forall a b. (Eq a) => a -> Term a b -> Term a b;
strip_unary_root f (Fun g [t]) = (if f == g then t else Fun g [t]);
strip_unary_root f (Var v) = Var v;
strip_unary_root f (Fun v []) = Fun v [];
strip_unary_root f (Fun v (vb : vd : ve)) = Fun v (vb : vd : ve);

has_unary_root :: forall a b. (Eq a) => a -> Term a b -> Bool;
has_unary_root f (Fun g [t]) = f == g;
has_unary_root f (Var v) = False;
has_unary_root f (Fun v []) = False;
has_unary_root f (Fun v (vb : vd : ve)) = False;

unblock_term :: forall a b. (Eq a) => a -> Term a b -> Term a b;
unblock_term f (Fun g ts) =
  (if all (has_unary_root f) ts then Fun g (map (strip_unary_root f) ts)
    else Fun g ts);
unblock_term f (Var v) = Var v;

unblock_rule ::
  forall a b. (Eq a) => a -> (Term a b, Term a b) -> (Term a b, Term a b);
unblock_rule f r = (unblock_term f (fst r), unblock_term f (snd r));

partition_pairs ::
  forall a b.
    (Eq a,
      Eq b) => a -> [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]);
partition_pairs f p = partition (\ r -> membera p (unblock_rule f r));

check_no_defined_root_defined ::
  forall a b.
    (Eq a, Showa a,
      Showa b) => [(a, Nat)] ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_defined_root_defined f t =
  check (not (membera f (the (root t))))
    (shows_string "the root of " .
      shows_prec_term Zero_nat t . shows_string " is defined");

block_term :: forall a b. a -> Term a b -> Term a b;
block_term f (Var x) = Var x;
block_term f (Fun g ts) = Fun g (map (\ t -> Fun f [t]) ts);

block_rule :: forall a b. a -> (Term a b, Term a b) -> (Term a b, Term a b);
block_rule f r = (block_term f (fst r), block_term f (snd r));

check_superset_of_blocked ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> [(Term a b, Term a b)] ->
                         [(Term a b, Term a b)] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_superset_of_blocked f pa p =
  catch_errora
    (catch_errora
      (catch_errora
        (forallM
          (\ x -> (if membera pa (block_rule f x) then Inr () else Inl x)) p)
        (\ x -> Inl (snd x)))
      (\ x ->
        Inl (shows_string "the rule " .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                (block_rule f x) .
                shows_string " is missing" . shows_nl)))
    (\ x ->
      Inl (shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
             "rewrite system:" " -> " p .
            shows_string "is not a subset of" .
              shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
                "rewrite system:" " -> " pa .
                x . shows_nl));

hole_at :: forall a b. (Eq a) => Nat -> Nat -> a -> Ctxt a b -> Bool;
hole_at n i f (More g ss1 Hole ss2) =
  g == f &&
    equal_nat (size_list ss1) i &&
      equal_nat (size_list ss2) (minus_nat (minus_nat n i) (Nat_of_num One));
hole_at n i f Hole = False;
hole_at n i f (More v va (More vd ve vf vg) vc) = False;

check_flat_ctxt_complete ::
  forall a b.
    (Eq a, Showa a,
      Showa b) => [Ctxt a b] ->
                    (a, Nat) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_flat_ctxt_complete fcs fa =
  check (all_interval_nat (\ i -> any (hole_at (snd fa) i (fst fa)) fcs)
          Zero_nat (snd fa))
    (shows_string "the list of flat contexts is incomplete" . shows_nl);

check_rule_reflecting ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [Ctxt a b] ->
                    [(Term a b, Term a b)] ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_reflecting fcs rs rule =
  check (any (\ (l, r) ->
               any (\ c ->
                     equal_term (fst rule) (ctxt_apply_term c l) &&
                       equal_term (snd rule) (ctxt_apply_term c r))
                 (Hole : fcs))
          rs)
    (shows_string "the rule " .
      shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " rule .
        shows_string
          " is neither contained in the original set of rules nor obtained by applying a flat context" .
          shows_nl);

check_rule_preserving ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [Ctxt a b] ->
                    [(Term a b, Term a b)] ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_preserving fcs rs rule =
  check (any (instance_rule rule) rs ||
          all (\ c ->
                any (instance_rule
                      (ctxt_apply_term c (fst rule),
                        ctxt_apply_term c (snd rule)))
                  rs)
            fcs)
    (shows_string "the rule " .
      shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " rule .
        shows_string
          " is neither contained in the resulting set of rules nor closed under all flat contexts" .
          shows_nl);

is_flat_ctxt_list ::
  forall a b. (Eq a, Eq b) => [a] -> [(b, Nat)] -> Ctxt b a -> Bool;
is_flat_ctxt_list vs fas (More f ss1 Hole ss2) =
  let {
    ss = ss1 ++ ss2;
  } in membera fas (f, plus_nat (size_list ss) (Nat_of_num One)) &&
         all is_Var ss && distinct ss && null (list_inter (map the_Var ss) vs);
is_flat_ctxt_list vs fas Hole = False;
is_flat_ctxt_list vs fas (More v va (More vd ve vf vg) vc) = False;

shows_prec_ctxt ::
  forall a b.
    (Showa a, Showa b) => Nat -> Ctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_ctxt p c = shows_ctxt (shows_prec Zero_nat) (shows_prec Zero_nat) c;

check_is_flat_ctxt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [a] ->
                    [(b, Nat)] ->
                      Ctxt b a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_is_flat_ctxt vs fas c =
  check (is_flat_ctxt_list vs fas c)
    (shows_prec_ctxt Zero_nat c .
      shows_string " is not a flat context" . shows_nl);

check_flat_ctxt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [a] -> Ctxt b a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_flat_ctxt vs c =
  (case c of {
    Hole ->
      Inl (shows_prec_ctxt Zero_nat c .
            shows_string " is not a flat context" . shows_nl);
    More _ ss1 Hole ss2 ->
      let {
        ss = ss1 ++ ss2;
      } in bindb (check (distinct ss)
                   (shows_prec_ctxt Zero_nat c .
                     shows_string " contains duplicate variables" . shows_nl))
             (\ _ ->
               bindb (check (all is_Var ss)
                       (shows_prec_ctxt Zero_nat c .
                         shows_string
                           " is not flat, i.e., has depth greater than one" .
                           shows_nl))
                 (\ _ ->
                   check (all (\ t -> not (membera vs (the_Var t)))
                           (ss1 ++ ss2))
                     (shows_prec_ctxt Zero_nat c .
                       shows_string " has to contain only fresh variables" .
                         shows_nl)));
    More _ _ (More _ _ _ _) _ ->
      Inl (shows_prec_ctxt Zero_nat c .
            shows_string " is not a flat context" . shows_nl);
  });

shows_terms ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] -> [Term a b] -> [Prelude.Char] -> [Prelude.Char];
shows_terms fun var name ts =
  ((shows_prec_list Zero_nat name . shows_nl) .
    shows_list_gen (shows_term fun var) [] [] "\n" [] ts) .
    shows_nl;

shows_dpp ::
  forall a b c.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Dpp_ops_ext c a b () -> c -> [Prelude.Char] -> [Prelude.Char];
shows_dpp fun var i d =
  let {
    m = minimal i d;
    nfs = nfsc i d;
    p = pa i d;
    pw = pwa i d;
    r = rc i d;
    rw = rwc i d;
    q = qc i d;
  } in shows_trs fun var "pairs:" " -> " p .
         (if null pw then id else shows_trs fun var "weak pairs:" " ->= " pw) .
           (if null r then id
             else shows_trs fun var "strict rules:" " ->! " r) .
             shows_trs fun var "rules:" " -> " rw .
               (if null q then id else shows_terms fun var "Q-component:" q) .
                 (if m then shows_nl . shows_prec_list Zero_nat "(minimal)"
                   else id) .
                   (if nfs && not (null q)
                     then shows_nl .
                            shows_prec_list Zero_nat
                              "(normal form substitutions)"
                     else id);

fcc_proc_cond ::
  forall a b c.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               [(Term b c, Term b c)] ->
                                 [(Term b c, Term b c)] ->
                                   a -> Sum ([Prelude.Char] -> [Prelude.Char])
  a;
fcc_proc_cond i f fcs p pw r rw dpp =
  let {
    paa = pa i dpp;
    pwaa = pwa i dpp;
    ra = rc i dpp;
    rwa = rwc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    new_dpp = mkc i nfs m p pw [] r rw;
  } in (case catch_errora
               (let {
                  pb = list_union paa pwaa;
                  rb = list_union ra rwa;
                  rba = list_union r rw;
                  fa = (f, Nat_of_num One);
                  cf = More f [] Hole [];
                  fcsa = cf : fcs;
                  vs = vars_trs_list rb;
                  fs = list_union (funas_trs_list rb) (funas_args_trs_list pb);
                  fas = fa : fs;
                  ds = defined_list rb;
                } in bindb (check (not (membera ds fa))
                             (shows_prec Zero_nat f .
                               shows_string "is not fresh" . shows_nl))
                       (\ _ ->
                         bindb (check_wf_trs rb)
                           (\ _ ->
                             bindb (catch_errora
                                     (forallM
                                       (\ rd ->
 bindb (check_no_var (fst rd))
   (\ _ ->
     bindb (check_no_var (snd rd))
       (\ _ -> check_no_defined_root_defined ds (snd rd))))
                                       pb)
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 bindb (catch_errora
 (forallM (check_flat_ctxt vs) fcsa) (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (catch_errora
     (forallM (check_is_flat_ctxt vs fas) fcsa) (\ x -> Inl (snd x)))
                                       (\ _ ->
 bindb (catch_errora (forallM (check_flat_ctxt_complete fcsa) fas)
         (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (catch_errora (forallM (check_rule_preserving fcsa r) ra)
             (\ x -> Inl (snd x)))
       (\ _ ->
         bindb (catch_errora (forallM (check_rule_preserving fcsa rba) rwa)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             bindb (catch_errora (forallM (check_rule_reflecting fcsa rb) rba)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check_superset_of_blocked f p paa)
                   (\ _ -> check_superset_of_blocked f pw pwaa)))))))))))
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        "problem when checking flat context closure conditions to switch from " .
                       shows_nl .
                         shows_dpp (shows_prec Zero_nat) (shows_prec Zero_nat) i
                           dpp .
                           shows_nl .
                             shows_prec_list Zero_nat "to the DP problem " .
                               shows_nl .
                                 shows_dpp (shows_prec Zero_nat)
                                   (shows_prec Zero_nat) i new_dpp .
                                   shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr new_dpp;
       });

g_to_list_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> [a];
g_to_list_dflt_basic_oops_rm_basic_ops s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ _ -> True)
    (\ a b -> a : b) [];

delete_rm_basic_ops :: forall a. (Compare_order a) => a -> Rbt a () -> Rbt a ();
delete_rm_basic_ops x s = delete x s;

ceta_list_diff :: forall a. (Key a) => [a] -> [a] -> [a];
ceta_list_diff xs ys =
  g_to_list_dflt_basic_oops_rm_basic_ops
    (foldl (\ a b -> delete_rm_basic_ops b a)
      (g_from_list_dflt_basic_oops_rm_basic_ops xs) ys);

fcc_split_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Ceq c, Ccompare c, Eq c, Key c, Mapping_impl c,
      Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               [(Term b c, Term b c)] ->
                                 [(Term b c, Term b c)] ->
                                   a -> Sum ([Prelude.Char] -> [Prelude.Char])
  (a, a);
fcc_split_proc i f fcs pb rb ps rs dpp =
  let {
    p = pa i dpp;
    pw = pwa i dpp;
    r = rc i dpp;
    rw = rwc i dpp;
    q = qc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    pba = list_union p pw;
    rba = rw;
    pns = ceta_list_diff pba ps;
    rns = ceta_list_diff rba rs;
    (paa, pwaa) = partition_pairs f ps pb;
    (ra, rwa) = partition_rules (More f [] Hole [] : fcs) rs rb;
    two = mkc i nfs m (ceta_list_diff p ps) (ceta_list_diff pw ps) [] [] rns;
    dpp_mid = mkc i nfs m ps pns [] rs rns;
  } in bindb (bindb
               (catch_errora (check_subseteq ps pba)
                 (\ x ->
                   Inl (shows_prec_list Zero_nat "pair " .
                         shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                           " -> " x .
                           shows_prec_list Zero_nat
                             " should be deleted but is not present")))
               (\ _ ->
                 bindb (catch_errora (check_subseteq rs rba)
                         (\ x ->
                           Inl (shows_prec_list Zero_nat "rule " .
                                 shows_rule (shows_prec Zero_nat)
                                   (shows_prec Zero_nat) " -> " x .
                                   shows_prec_list Zero_nat
                                     " should be deleted but is not present")))
                   (\ _ ->
                     bindb (check (null q)
                             (shows_string "Q is not empty" . shows_nl))
                       (\ _ ->
                         bindb (check (null r)
                                 (shows_prec_list Zero_nat
                                   "strict rules not allowed"))
                           (\ _ ->
                             bindb (check_left_linear_trs rw)
                               (\ _ ->
                                 fcc_proc_cond i f fcs paa pwaa ra rwa
                                   dpp_mid))))))
         (\ one -> Inr (one, two));

mono_redpair_proc ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_redpair_proc i rp premove rremove dpp =
  (case catch_errora
          (let {
             (ps, pns) = split_pairsa i dpp premove;
             (rs, rns) = split_rulesc i dpp rremove;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (catch_errora (mono rp (ps ++ rs ++ pns ++ rns))
                            (\ x ->
                              Inl (shows_string
                                     "problem with monotonicity of strict order" .
                                    shows_nl . x)))
                      (\ _ ->
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 "problem when orienting TRS" .
shows_nl . x)))
                          (\ _ ->
                            bindb (catch_errora
                                    (catch_errora (forallM (s rp) rs)
                                      (\ x -> Inl (snd x)))
                                    (\ x ->
                                      Inl
(shows_string "problem when orienting TRS" . shows_nl . x)))
                              (\ _ ->
                                bindb (catch_errora
(catch_errora (forallM (ns rp) pns) (\ x -> Inl (snd x)))
(\ x -> Inl (shows_string "problem when orienting DPs" . shows_nl . x)))
                                  (\ _ ->
                                    catch_errora
                                      (catch_errora (forallM (s rp) ps)
(\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string "problem when orienting DPs" . shows_nl . x))))))))
          (\ x ->
            Inl (shows_string
                   "could not apply the reduction pair processor with the following" .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

instantiation_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
instantiation_proc i st sts dpp =
  (case let {
          ic = icap_impl_dpp_mv i dpp;
          isnf = is_QNFc i dpp;
          (s, t) = st;
          sy = map_term (\ x -> x) (\ a -> 'y' : a) s;
          ty = map_term (\ x -> x) (\ a -> 'y' : a) t;
          iedg = is_iedg_edge_dpp i dpp;
        } in catch_errora
               (forallM
                 (\ (u, v) ->
                   (case mgu_class (ic [u] v) s of {
                     Nothing -> Inr ();
                     Just mu ->
                       check (not (isnf (subst_apply_term sy mu)) ||
                               (not (isnf (subst_apply_term
    (map_term (\ x -> x) (\ a -> 'x' : a) u) mu)) ||
                                 any (\ sta ->
                                       instance_rule sta st &&
 instance_rule (subst_apply_term sy mu, subst_apply_term ty mu) sta)
                                   sts))
                         (shows_prec_list Zero_nat
                            "could not find instance of pair " .
                           shows_rule (shows_prec Zero_nat)
                             (shows_prec_list Zero_nat) " -> "
                             (subst_apply_term sy mu, subst_apply_term ty mu) .
                             shows_nl .
                               shows_prec_list Zero_nat
                                 "which resulted from DP " .
                                 shows_rule (shows_prec Zero_nat)
                                   (shows_prec_list Zero_nat) " -> " (u, v));
                   }))
                 (filter (\ (u, v) -> iedg (u, v) s) (pairsa i dpp)))
               (\ x -> Inl (snd x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

intersect_pairsa ::
  forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_pairsa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = intersect_pairs;

graph_approx_rt_sym ::
  forall a b c d e f.
    (Ccompare a,
      Eq a) => Multimap (Maybe (a, Nat)) b -> (c, (d, (Gctxt a e, f))) -> [b];
graph_approx_rt_sym m (uu, (uv, (ct, uw))) =
  (case ct of {
    GCHole -> valuesa m;
    GCFun f ts -> lookupc m Nothing ++ lookupc m (Just (f, size_list ts));
  });

rules_non_collapsinga :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
rules_non_collapsinga
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_non_collapsing;

reverse_rules_mapa ::
  forall a b c d.
    Dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
reverse_rules_mapa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = reverse_rules_map;

reverse_tcapRM_dpp ::
  forall a b c.
    (Eq b, Eq c) => Dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
reverse_tcapRM_dpp i dpp =
  tcapRM (rules_non_collapsinga i dpp) (reverse_rules_mapa i dpp);

check_no_back_edges ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> a -> [a]) ->
        (a -> b -> b) ->
          ((a, a) -> Bool) ->
            b -> [[a]] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_back_edges ss candidates add_index g i [] = Inr ();
check_no_back_edges ss candidates add_index g i (asa : cs) =
  bindb (catch_errora
          (forallM
            (\ a ->
              catch_errora (forallM (check_no_edge ss g a) (candidates i a))
                (\ x -> Inl (snd x)))
            asa)
          (\ x -> Inl (snd x)))
    (\ _ ->
      check_no_back_edges ss candidates add_index g (foldr add_index asa i) cs);

check_graph_decomp ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      b -> (b -> a -> [a]) ->
             (a -> b -> b) ->
               ((a, a) -> Bool) ->
                 [(Bool, [a])] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_graph_decomp ss empty_index candidates add_index g rcs =
  bindb (check_no_back_edges ss candidates add_index g empty_index
          (map snd rcs))
    (\ _ ->
      catch_errora
        (forallM (\ c -> check_edges ss g c c)
          (map_filter (\ x -> (if not (fst x) then Just (snd x) else Nothing))
            rcs))
        (\ x -> Inl (snd x)));

check_dep_graph_proc ::
  forall a b c.
    (Ccompare b, Eq b, Key b, Mapping_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dep_graph_proc i dpp dps =
  let {
    c = tcapRM_dpp i dpp;
    rc = reverse_tcapRM_dpp i dpp;
    _ = nFQ_subset_NF_rulesc i dpp;
    _ = is_QNFc i dpp;
    _ = map fst (rulesd i dpp);
    iedg = is_iedg_edge_dpp i dpp;
    p = pairsa i dpp;
  } in bindb (catch_errora (check_subseteq p (concatMap snd dps))
               (\ x ->
                 Inl (shows_string "Dependency Pair " .
                       shows_rule (shows_prec Zero_nat)
                         (shows_prec_list Zero_nat) " -> " x .
                         shows_string " is missing in decomposition" .
                           shows_nl)))
         (\ _ ->
           catch_errora
             (check_graph_decomp (shows_prec_prod Zero_nat . fst)
               (emptyd ((root . fst) . fst)) graph_approx_rt_sym insertd
               (\ (a, b) ->
                 let {
                   (aa, ba) = a;
                 } in let {
                        (_, t) = aa;
                      } in (\ (_, (ct, ict)) (ab, bb) ->
                             let {
                               (u, _) = ab;
                             } in (\ (cu, (_, _)) ->
                                    matchb ct u && matchb cu t && ict u)
                               bb)
                        ba
                   b)
               (map (\ (real, cs) ->
                      (not (is_none real),
                        map (\ (s, t) -> ((s, t), (rc s, (c t, iedg (s, t)))))
                          cs))
                 dps))
             (\ x ->
               Inl (shows_string
                      "our estimation (EDG*** + IEDG***) could not show that you have a valid decomposition " .
                     shows_string "due to the following reason" .
                       shows_nl . x)));

dep_graph_proc ::
  forall a b c.
    (Ccompare b, Eq b, Key b, Mapping_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) [(c, a)];
dep_graph_proc i d dps =
  (case check_dep_graph_proc i d dps of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (map_filter
            (\ x ->
              (if not (is_none (fst x))
                then Just (the (fst x), intersect_pairsa i d (snd x))
                else Nothing))
            dps);
  });

check_NF_terms_subset ::
  forall a b. (Term a b -> Bool) -> [Term a b] -> Sum (Term a b) ();
check_NF_terms_subset is_Q_nf =
  (\ q ->
    catch_errora
      (forallM (\ x -> (if not (is_Q_nf x) then Inr () else Inl x)) q)
      (\ x -> Inl (snd x)));

check_NF_terms_eq ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_terms_eq qa q =
  bindb (check_NF_terms_subset (is_NF_terms qa) q)
    (\ _ -> check_NF_terms_subset (is_NF_terms q) qa);

check_dpp_subsumes ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c, Showa c, Ccompare d, Eq d,
      Mapping_impl d,
      Showa d) => Dpp_ops_ext a (Lab b c) d () ->
                    (Bool,
                      (Bool,
                        ([(Term (Lab b c) d, Term (Lab b c) d)],
                          ([(Term (Lab b c) d, Term (Lab b c) d)],
                            ([Term (Lab b c) d],
                              ([(Term (Lab b c) d, Term (Lab b c) d)],
                                [(Term (Lab b c) d, Term (Lab b c) d)])))))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dpp_subsumes i (nfs, (m, (p, (pw, (q, (r, rw)))))) d =
  catch_errora
    (let {
       paa = pa i d;
       pwaa = pwa i d;
       qa = qc i d;
       ra = rc i d;
       rwa = rwc i d;
       nfsa = nfsc i d;
       ma = minimal i d;
       pb = p ++ pw;
       rb = ra ++ rwa;
       rba = r ++ rw;
     } in bindb (check (ma == m)
                  (shows_prec_list Zero_nat "incompatible minimality flags"))
            (\ _ ->
              bindb (check (nfsa == nfs)
                      (shows_prec_list Zero_nat
                        "incompatible substitutions-in-normal-form flags"))
                (\ _ ->
                  bindb (catch_errora (check_subseteq paa p)
                          (\ x ->
                            Inl (toomuch "pair"
                                  (shows_rule (shows_prec_lab Zero_nat)
                                    (shows_prec Zero_nat) " -> " x))))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq pwaa pb)
                              (\ x ->
                                Inl (toomuch "weak pair"
                                      (shows_rule (shows_prec_lab Zero_nat)
(shows_prec Zero_nat) " -> " x))))
                        (\ _ ->
                          bindb (catch_errora (check_NF_terms_eq qa q)
                                  (\ x ->
                                    Inl (shows_prec_list Zero_nat
   "NF(Q) differs due to term " .
  shows_term (shows_prec_lab Zero_nat) (shows_prec Zero_nat) x)))
                            (\ _ ->
                              bindb (catch_errora (check_subseteq ra r)
                                      (\ x ->
Inl (toomuch "strict rule"
      (shows_rule (shows_prec_lab Zero_nat) (shows_prec Zero_nat) " -> " x))))
                                (\ _ ->
                                  bindb (catch_errora (check_subseteq rb rba)
  (\ x ->
    Inl (toomuch "strict/weak rule"
          (shows_rule (shows_prec_lab Zero_nat) (shows_prec Zero_nat) " -> "
            x))))
                                    (\ _ ->
                                      bindb
(catch_errora (check_subseteq rba rb)
  (\ x ->
    Inl (missing "strict/weak rule"
          (shows_rule (shows_prec_lab Zero_nat) (shows_prec Zero_nat) " -> "
            x))))
(\ _ -> Inr ())))))))))
    (\ x ->
      Inl (shows_string "finiteness of the problem" .
            shows_nl .
              shows_dpp (shows_prec_lab Zero_nat) (shows_prec Zero_nat) i d .
                shows_nl .
                  shows_string
                    "may not be concluded from assuming finiteness of the problem" .
                    shows_nl .
                      shows_dpp (shows_prec_lab Zero_nat) (shows_prec Zero_nat)
                        i (mkc i nfs m p pw q r rw) .
                        shows_nl . x . shows_nl));

fcc_proc ::
  forall a b c.
    (Eq b, Showa b, Ceq c, Ccompare c, Eq c, Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
fcc_proc i f fcs pb rw dpp =
  let {
    p = pa i dpp;
    q = qc i dpp;
    r = rc i dpp;
    (pc, pw) = partition_pairs f p pb;
  } in bindb (check (null q) (shows_string "Q is not empty" . shows_nl))
         (\ _ ->
           bindb (check (null r)
                   (shows_prec_list Zero_nat "strict rules not allowed"))
             (\ _ ->
               bindb (check_left_linear_trs (rwc i dpp))
                 (\ _ -> fcc_proc_cond i f fcs pc pw [] rw dpp)));

q_reduction_proc_non_min ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc_non_min i q dpp =
  (case catch_errora
          (bindb
            (catch_errora (check_NF_terms_subset (is_QNFc i dpp) q)
              (\ x ->
                Inl (shows_prec_list Zero_nat "the term " .
                      shows_prec_term Zero_nat x .
                        shows_prec_list Zero_nat " is not allowed in Q\' ")))
            (\ _ -> Inr ()))
          (\ x ->
            Inl (shows_prec_list Zero_nat
                   "problem when reducing Q in the DP problem " .
                  shows_nl .
                    shows_dpp (shows_prec Zero_nat) (shows_prec Zero_nat) i
                      dpp .
                      shows_nl .
                        shows_prec_list Zero_nat "to the set " .
                          shows_nl .
                            shows_terms (shows_prec Zero_nat)
                              (shows_prec Zero_nat) "Q\':" q .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (mkc i (nfsc i dpp) False (pa i dpp) (pwa i dpp) q (rc i dpp)
            (rwc i dpp));
  });

q_reduction_proc_min_inn ::
  forall a b c.
    (Eq b, Key b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc_min_inn i q dpp =
  let {
    pb = pairsa i dpp;
    rb = rulesd i dpp;
    f = map Just (funas_trs_list (pb ++ rb));
    qa = qc i dpp;
    isnf = is_QNFc i dpp;
    qq = filter (\ qb -> all isnf (args qb)) qa;
    rQ = filter (\ qb -> membera f (root qb)) qq;
  } in (case catch_errora
               (bindb
                 (check (nFQ_subset_NF_rulesc i dpp)
                   (shows_prec_list Zero_nat "innermost rewriting required"))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       bindb (catch_errora
                               (check_NF_terms_subset (is_NF_terms q) rQ)
                               (\ x ->
                                 Inl (shows_prec_list Zero_nat "the term " .
                                       shows_prec_term Zero_nat x .
 shows_prec_list Zero_nat " is missing in Q\' ")))
                         (\ _ ->
                           bindb (catch_errora
                                   (check_NF_terms_subset (is_NF_terms qq) q)
                                   (\ x ->
                                     Inl (shows_prec_list Zero_nat "the term " .
   shows_prec_term Zero_nat x .
     shows_prec_list Zero_nat " is not allowed in Q\' ")))
                             (\ _ ->
                               (if nfsc i dpp then Inr ()
                                 else check_varcond_subset pb))))))
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        "problem when reducing Q in the DP problem " .
                       shows_nl .
                         shows_dpp (shows_prec Zero_nat) (shows_prec Zero_nat) i
                           dpp .
                           shows_nl .
                             shows_prec_list Zero_nat "to the set " .
                               shows_nl .
                                 shows_terms (shows_prec Zero_nat)
                                   (shows_prec Zero_nat) "Q\':" q .
                                   shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (mkc i (nfsc i dpp) (minimal i dpp) (pa i dpp) (pwa i dpp) q
                 (rc i dpp) (rwc i dpp));
       });

q_reduction_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc i q dpp =
  (case q_reduction_proc_min_inn i q dpp of {
    Inl _ -> q_reduction_proc_non_min i q dpp;
    Inr a -> Inr a;
  });

get_fcc_option ::
  forall a b c.
    Dp_termination_proof a b c ->
      Maybe (Lab a b,
              ([Ctxt (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  ([(Term (Lab a b) c, Term (Lab a b) c)],
                    Dp_termination_proof a b c))));
get_fcc_option (Fcc_Proc f fcs pb rb prf) = Just (f, (fcs, (pb, (rb, prf))));
get_fcc_option P_is_Empty = Nothing;
get_fcc_option (Subterm_Criterion_Proc v va vb vc) = Nothing;
get_fcc_option (Redpair_Proc v va vb) = Nothing;
get_fcc_option (Redpair_UR_Proc v va vb vc) = Nothing;
get_fcc_option (Usable_Rules_Proc v va) = Nothing;
get_fcc_option (Dep_Graph_Proc v) = Nothing;
get_fcc_option (Mono_Redpair_Proc v va vb vc) = Nothing;
get_fcc_option (Mono_URM_Redpair_Proc v va vb vc) = Nothing;
get_fcc_option (Mono_Redpair_UR_Proc v va vb vc vd) = Nothing;
get_fcc_option (Size_Change_Subterm_Proc v) = Nothing;
get_fcc_option (Size_Change_Redpair_Proc v va vb) = Nothing;
get_fcc_option (Uncurry_Proc v va vb vc vd) = Nothing;
get_fcc_option (Split_Proc v va vb vc) = Nothing;
get_fcc_option (Semlab_Proc v va vb vc vd) = Nothing;
get_fcc_option (Switch_Innermost_Proc v va) = Nothing;
get_fcc_option (Rewriting_Proc v va vb vc vd ve vf) = Nothing;
get_fcc_option (Instantiation_Proc v va vb) = Nothing;
get_fcc_option (Forward_Instantiation_Proc v va vb vc) = Nothing;
get_fcc_option (Narrowing_Proc v va vb vc) = Nothing;
get_fcc_option (Assume_Finite v va) = Nothing;
get_fcc_option (Unlab_Proc v va vb) = Nothing;
get_fcc_option (Q_Reduction_Proc v va) = Nothing;
get_fcc_option (Complex_Constant_Removal_Proc v va) = Nothing;
get_fcc_option (General_Redpair_Proc v va vb vc vd) = Nothing;
get_fcc_option (To_Trs_Proc v) = Nothing;

uncurry_of_top_sig_list ::
  forall a.
    a -> Nat ->
           [((a, Nat), [a])] ->
             (a -> Nat -> [a]) ->
               [(Term a [Prelude.Char], Term a [Prelude.Char])];
uncurry_of_top_sig_list a m sml sm =
  concatMap
    (\ (b, c) ->
      let {
        (f, n) = b;
      } in (\ _ ->
             let {
               g = get_symbol sm f n;
             } in map (\ i ->
                        (Fun a (generate_f_xs (g i) (plus_nat n i) :
                                 map (\ ia -> Var (generate_var ia))
                                   (upt (plus_nat n i)
                                     (plus_nat (plus_nat n i)
                                       (minus_nat m (Nat_of_num One))))),
                          generate_f_xs (g (plus_nat i (Nat_of_num One)))
                            (plus_nat (plus_nat n i)
                              (minus_nat m (Nat_of_num One)))))
                    (upt Zero_nat (aarity sm f n)))
        c)
    sml;

eta_closed_top_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => a -> Nat ->
                         (a -> Nat -> [a]) ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
eta_closed_top_rules a n sm r p =
  catch_errora
    (forallM
      (\ (l, ra) ->
        (case l of {
          Var _ -> Inr ();
          Fun ff ls ->
            check (equal_nat (aarity sm ff (size_list ls)) Zero_nat ||
                    any (\ (lll, rrr) ->
                          (case (lll, rrr) of {
                            (Var _, _) -> False;
                            (Fun _ [], _) -> False;
                            (Fun _ (_ : _), Var _) -> False;
                            (Fun _ (_ : _), Fun _ []) -> False;
                            (Fun f (ll : yy), Fun g (rr : zz)) ->
                              f == a &&
                                g == a &&
                                  zz == yy &&
                                    equal_nat (size_list yy)
                                      (minus_nat n (Nat_of_num One)) &&
                                      distinct yy &&
all is_Var yy &&
  null (list_inter (map the_Var yy) (insert_vars_rule (ll, rr) [])) &&
    instance_rule (l, ra) (ll, rr);
                          }))
                      p)
              ((shows_prec_list Zero_nat "eta expansion of " .
                 shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                   (l, ra)) .
                shows_prec_list Zero_nat " missing");
        }))
      r)
    (\ x -> Inl (snd x));

uncurry_top_rules ::
  forall a b.
    (Eq a) => a -> Nat ->
                     (a -> Nat -> [a]) ->
                       [(Term a b, Term a b)] -> [(Term a b, Term a b)];
uncurry_top_rules a n sm =
  map (\ (l, r) -> (uncurry_top a n sm l, uncurry_top a n sm r));

map_funs_rules_wa ::
  forall a b c.
    ((a, Nat) -> b) -> [(Term a c, Term a c)] -> [(Term b c, Term b c)];
map_funs_rules_wa fg r =
  map (\ (l, ra) -> (map_funs_term_wa fg l, map_funs_term_wa fg ra)) r;

uncurry_top_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      Nat ->
                        ([((b, Nat), [b])] -> b -> Nat -> b) ->
                          (b -> Nat ->
                                  [((b, Nat), [b])] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char])
                                      ()) ->
                            [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                              [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                                a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_top_proc i info n fmap check_inj p r dpp =
  let {
    (a, (sml, (u, eb))) = info;
    paa = pa i dpp;
    pw = pwa i dpp;
    ra = rc i dpp;
    rw = rwc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (e, ew) = uncurry_eta_split eb ra;
    sm = sig_list_to_sig_map a sml fmap;
    p_eta = e ++ paa;
    pw_eta = ew ++ pw;
    uP = uncurry_top_rules a n sm p_eta;
    uPw = uncurry_top_rules a n sm pw_eta;
    uR = map_funs_rules_wa (\ (f, na) -> get_symbol sm f na Zero_nat) ra;
    uRw = map_funs_rules_wa (\ (f, na) -> get_symbol sm f na Zero_nat) rw;
  } in (case bindb (check (null (qc i dpp))
                     (shows_prec_list Zero_nat
                       "strategy currently unsupported"))
               (\ _ ->
                 bindb (check (not (equal_nat n Zero_nat))
                         (shows_prec_list Zero_nat
                           "the arity of the uncurried symbol must be at least 1"))
                   (\ _ ->
                     bindb (check_inj a n sml)
                       (\ _ ->
                         let {
                           pb = pairsa i dpp;
                           is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
                           rm = rules_mapb i dpp;
                         } in bindb (catch_errora
                                      (forallM
(\ (l, _) ->
  check (not (is_Var l))
    (shows_prec_list Zero_nat "lhs as variable is not allowed"))
(ra ++ rw))
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  bindb (catch_errora
  (forallM
    (\ (l, rb) ->
      bindb (check (hvf_top a n l)
              (shows_prec_list Zero_nat "head variable in lhs " .
                shows_term (shows_prec Zero_nat) (shows_prec_list Zero_nat) l .
                  shows_prec_list Zero_nat " not allowed"))
        (\ _ -> check_no_var rb))
    (pw_eta ++ p_eta))
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora
  (forallM
    (\ (_, rb) ->
      check (not (is_def (the (root rb))))
        (shows_prec_list Zero_nat "root of " .
          shows_term (shows_prec Zero_nat) (shows_prec_list Zero_nat) rb .
            shows_prec_list Zero_nat " must not be defined"))
    pb)
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (check (not (is_def (a, n)))
          (shows_prec_list Zero_nat "application symbol " .
            shows_prec Zero_nat a .
              shows_prec_list Zero_nat " must not be defined in R"))
    (\ _ ->
      bindb (if any (\ (_, rb) ->
                      the (root rb) == (a, n) &&
                        equal_gctxt (tcapRM2 rm (hd (args rb))) GCHole)
                  pb
              then bindb (catch_errora
                           (check_CS_subseteq
                             (uncurry_of_top_sig_list a n sml sm) u)
                           (\ x ->
                             Inl (shows_prec_list Zero_nat "uncurrying pair " .
                                   shows_rule (shows_prec Zero_nat)
                                     (shows_prec_list Zero_nat) " -> " x .
                                     shows_prec_list Zero_nat " is missing in" .
                                       shows_nl .
 shows_rules (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " u)))
                     (\ _ ->
                       bindb (eta_closed_top_rules a n sm ra p_eta)
                         (\ _ -> eta_closed_top_rules a n sm rw pw_eta))
              else Inr ())
        (\ _ ->
          bindb (catch_errora (check_subseteq uP p)
                  (\ x ->
                    Inl (shows_prec_list Zero_nat "uncurried pair " .
                          shows_rule (shows_prec Zero_nat)
                            (shows_prec_list Zero_nat) " -> " x .
                            shows_prec_list Zero_nat " is missing")))
            (\ _ ->
              bindb (catch_errora (check_subseteq uPw p)
                      (\ x ->
                        Inl (shows_prec_list Zero_nat "uncurried pair " .
                              shows_rule (shows_prec Zero_nat)
                                (shows_prec_list Zero_nat) " -> " x .
                                shows_prec_list Zero_nat " is missing")))
                (\ _ ->
                  bindb (catch_errora (check_subseteq u p)
                          (\ x ->
                            Inl (shows_prec_list Zero_nat "uncurrying pair " .
                                  shows_rule (shows_prec Zero_nat)
                                    (shows_prec_list Zero_nat) " -> " x .
                                    shows_prec_list Zero_nat
                                      " is missing in new pairs")))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq uR r)
                              (\ x ->
                                Inl (shows_prec_list Zero_nat "rule " .
                                      shows_rule (shows_prec Zero_nat)
(shows_prec_list Zero_nat) " -> " x .
shows_prec_list Zero_nat " is missing in new rules")))
                        (\ _ ->
                          catch_errora (check_subseteq uRw r)
                            (\ x ->
                              Inl (shows_prec_list Zero_nat "rule " .
                                    shows_rule (shows_prec Zero_nat)
                                      (shows_prec_list Zero_nat) " -> " x .
                                      shows_prec_list Zero_nat
" is missing in new rules"))))))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkc i nfs m uP (uPw ++ u) [] uR uRw);
       });

only_eta_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
only_eta_rules e r_eta =
  catch_errora
    (forallM
      (\ (l, r) ->
        check (case (l, r) of {
                (Var _, _) -> False;
                (Fun _ _, Var _) -> False;
                (Fun f ls, Fun g rs) ->
                  f == g &&
                    equal_nat (size_list ls) (Nat_of_num (Bit0 One)) &&
                      equal_nat (size_list rs) (Nat_of_num (Bit0 One)) &&
                        equal_term (nth ls (Nat_of_num One))
                          (nth rs (Nat_of_num One)) &&
                          any (\ (la, ra) ->
                                instance_rule (hd ls, hd rs) (la, ra))
                            r_eta;
              })
          (shows_prec_list Zero_nat "rule " .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
              (l, r) .
              shows_prec_list Zero_nat
                " is not an (eta-expanded) original rule"))
      e)
    (\ x -> Inl (snd x));

uncurry_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      ([((b, Nat), [b])] -> b -> Nat -> b) ->
                        (b -> Nat ->
                                [((b, Nat), [b])] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_proc i info fmap check_inj p r dpp =
  let {
    (a, (sml, (u, eb))) = info;
    paa = pa i dpp;
    pw = pwa i dpp;
    ra = rc i dpp;
    rw = rwc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (e, ew) = uncurry_eta_split eb ra;
    sm = sig_list_to_sig_map a sml fmap;
    uP = uncurry_rules a sm paa;
    uPw = uncurry_rules a sm pw;
    r_eta = e ++ ra;
    rw_eta = ew ++ rw;
    uR = uncurry_rules a sm r_eta;
    uRw = uncurry_rules a sm rw_eta;
  } in (case let {
               s = uncurry_of_sig_list a sml sm;
             } in bindb (check (null (qc i dpp))
                          (shows_prec_list Zero_nat
                            "strategy not supported for uncurrying"))
                    (\ _ ->
                      bindb (only_eta_rules e r_eta)
                        (\ _ ->
                          bindb (only_eta_rules ew rw_eta)
                            (\ _ ->
                              bindb (check_inj a (Nat_of_num (Bit0 One)) sml)
                                (\ _ ->
                                  bindb (catch_errora
  (forallM
    (\ (l, _) ->
      check (not (is_Var l))
        (shows_prec_list Zero_nat "lhs as variable is not allowed"))
    (ra ++ rw))
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catch_errora
  (forallM
    (\ (l, _) ->
      check (hvf_term a l)
        (shows_prec_list Zero_nat "head variable in lhs " .
          shows_term (shows_prec Zero_nat) (shows_prec_list Zero_nat) l .
            shows_prec_list Zero_nat " not allowed"))
    paa)
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (catch_errora
          (forallM
            (\ (l, _) ->
              check (hvf_term a l)
                (shows_prec_list Zero_nat "head variable in lhs " .
                  shows_term (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                    l .
                    shows_prec_list Zero_nat " not allowed"))
            pw)
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ (l, _) ->
                  check (hvf_term a l)
                    (shows_prec_list Zero_nat "head variable in lhs " .
                      shows_term (shows_prec Zero_nat)
                        (shows_prec_list Zero_nat) l .
                        shows_prec_list Zero_nat " not allowed"))
                r_eta)
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (catch_errora
                  (forallM
                    (\ (l, _) ->
                      check (hvf_term a l)
                        (shows_prec_list Zero_nat "head variable in lhs " .
                          shows_term (shows_prec Zero_nat)
                            (shows_prec_list Zero_nat) l .
                            shows_prec_list Zero_nat " not allowed"))
                    rw_eta)
                  (\ x -> Inl (snd x)))
            (\ _ ->
              bindb (eta_closed_rules a sm r_eta r_eta)
                (\ _ ->
                  bindb (eta_closed_rules a sm rw_eta rw_eta)
                    (\ _ ->
                      bindb (catch_errora (check_subseteq uP p)
                              (\ x ->
                                Inl (shows_prec_list Zero_nat
                                       "uncurried pair " .
                                      shows_rule (shows_prec Zero_nat)
(shows_prec_list Zero_nat) " -> " x .
shows_prec_list Zero_nat " is missing")))
                        (\ _ ->
                          bindb (catch_errora (check_subseteq uPw p)
                                  (\ x ->
                                    Inl (shows_prec_list Zero_nat
   "uncurried pair " .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " x .
    shows_prec_list Zero_nat " is missing")))
                            (\ _ ->
                              bindb (catch_errora (check_subseteq uR r)
                                      (\ x ->
Inl (shows_prec_list Zero_nat "uncurried rule " .
      shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " x .
        shows_prec_list Zero_nat " is missing")))
                                (\ _ ->
                                  bindb (catch_errora (check_subseteq uRw r)
  (\ x ->
    Inl (shows_prec_list Zero_nat "uncurried rule " .
          shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " x .
            shows_prec_list Zero_nat " is missing")))
                                    (\ _ ->
                                      bindb
(catch_errora (check_CS_subseteq s u)
  (\ x ->
    Inl (shows_prec_list Zero_nat "uncurry rule " .
          shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " x .
            shows_prec_list Zero_nat " is missing")))
(\ _ ->
  bindb (catch_errora (check_CS_subseteq u s)
          (\ x ->
            Inl (shows_prec_list Zero_nat "rule " .
                  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                    " -> " x .
                    shows_prec_list Zero_nat " is not an uncurry rule")))
    (\ _ ->
      catch_errora (check_subseteq u r)
        (\ x ->
          Inl (shows_prec_list Zero_nat "uncurry rule " .
                shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                  " -> " x .
                  shows_prec_list Zero_nat
                    " is missing in new TRS")))))))))))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkc i nfs m uP uPw [] uR (uRw ++ u));
       });

uncurry_proc_both ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Dpp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Maybe Nat ->
                      (Lab b c,
                        ([((Lab b c, Nat), [Lab b c])],
                          ([(Term (Lab b c) [Prelude.Char],
                              Term (Lab b c) [Prelude.Char])],
                            [(Term (Lab b c) [Prelude.Char],
                               Term (Lab b c) [Prelude.Char])]))) ->
                        [(Term (Lab b c) [Prelude.Char],
                           Term (Lab b c) [Prelude.Char])] ->
                          [(Term (Lab b c) [Prelude.Char],
                             Term (Lab b c) [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_proc_both i Nothing (a, (sml, (u, eb))) =
  uncurry_proc i (a, (sml, (u, eb))) (fmap a (Nat_of_num (Bit0 One))) check_inj;
uncurry_proc_both i (Just n) (a, (sml, (u, eb))) =
  uncurry_top_proc i (a, (sml, (u, eb))) n (fmap a n) check_inj;

check_rewrite_common_preconditions ::
  forall a b c d.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      (Term b [Prelude.Char], Term c [Prelude.Char]) ->
                        [Term b [Prelude.Char]] ->
                          [Term b [Prelude.Char]] ->
                            d -> (Term b [Prelude.Char],
                                   Term b [Prelude.Char]) ->
                                   Pos ->
                                     Bool ->
                                       a ->
 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rewrite_common_preconditions i u_opt st ss ts t lr p sound dpp =
  let {
    r = rulesd i dpp;
    s = fst st;
    ta = snd st;
    tp = subt_at ta p;
    u = (case u_opt of {
          Nothing -> concatMap (\ tb -> inn_usable_rules_pair i dpp (s, tb)) ts;
          Just u -> u;
        });
  } in bindb (catch_errora (check_subseteq u r)
               (\ x ->
                 Inl (shows_rule (shows_prec Zero_nat)
                        (shows_prec_list Zero_nat) " -> " x .
                       shows_prec_list Zero_nat
                         " is not a rule of the rewrite system ")))
         (\ _ ->
           let {
             urc = is_ur_closed_impl_dpp_mv i dpp u;
             check_urc =
               (\ sa tb ->
                 check (urc sa tb)
                   (shows_prec_list Zero_nat "term " .
                     shows_prec_term Zero_nat tb .
                       shows_prec_list Zero_nat
                         " is not closed under usable rules"));
             nfs = nfsc i dpp;
           } in bindb (catch_errora
                        (forallM
                          (\ (l, _) ->
                            check (not (is_Var l))
                              (shows_prec_list Zero_nat
                                "lhss must not be variables"))
                          u)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    bindb (check (wf_rule lr)
                            (shows_rule (shows_prec Zero_nat)
                               (shows_prec_list Zero_nat) " -> " lr .
                              shows_prec_list Zero_nat
                                " is not a well formed rule"))
                      (\ _ ->
                        bindb (if nfs && sound then Inr ()
                                else catch_errora
                                       (check_subseteq (vars_term_list tp)
 (vars_term_list s))
                                       (\ _ ->
 Inl (shows_prec_list Zero_nat "variable condition in pair violated")))
                          (\ _ ->
                            bindb (catch_errora (forallM (check_urc ss) ts)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (catch_errora
(forallM (\ (l, a) -> check_urc (args l) a) u) (\ x -> Inl (snd x)))
                                  (\ _ ->
                                    bindb (catch_errora
    (check_critical_pairs_innermost u)
    (\ x ->
      Inl (shows_prec_list Zero_nat "problem in showing UNF of usable rules" .
            shows_nl . x)))
                                      (\ _ ->
catch_errora
  (forallM
    (\ (_, (sa, tb)) ->
      check (equal_term sa tb)
        (shows_prec_list Zero_nat
          "non-trivial critical pair between rule to rewrite and usable rules"))
    (critical_pairs_impl [lr] u))
  (\ x -> Inl (snd x)))))))));

check_prop_rstepa ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstepa nfs pa r p rule s t =
  bindb (check (membera r rule)
          (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " rule .
            shows_string " is not a rule of" .
              shows_nl .
                shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
                  "rewrite system:" " -> " r .
                  shows_nl))
    (\ _ -> check_prop_rstep_rule nfs pa p rule s t);

check_rstep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Pos ->
                      (Term a b, Term a b) ->
                        Term a b ->
                          Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rstep = check_prop_rstepa False (\ _ -> Inr ());

rewriting_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                        (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                          (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                            (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                              Pos ->
                                a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rewriting_proc i u stb sta st lr p dpp =
  (case let {
          s = fst stb;
          t = snd sta;
        } in bindb (check_rstep (rulesd i dpp) p lr (snd stb) t)
               (\ _ ->
                 bindb (check (nFQ_subset_NF_rulesc i dpp)
                         (shows_prec_list Zero_nat
                           "innermost rewriting required"))
                   (\ _ ->
                     bindb (check_rewrite_common_preconditions i u stb [s]
                             [subt_at (snd stb) p] t lr p True dpp)
                       (\ _ ->
                         bindb (check (eq_rule_mod_vars sta st)
                                 (shows_prec_list Zero_nat "the rule " .
                                   shows_rule (shows_prec Zero_nat)
                                     (shows_prec_list Zero_nat) " -> " sta .
                                     shows_prec_list Zero_nat
                                       " is not a renamed variant of " .
                                       shows_rule (shows_prec Zero_nat)
 (shows_prec_list Zero_nat) " -> " st))
                           (\ _ ->
                             bindb (check (equal_term s (fst sta))
                                     (shows_prec_list Zero_nat
                                       "left-hand sides of old and new pair differ"))
                               (\ _ ->
                                 bindb (check
 (membera (pa i dpp) stb || null (rc i dpp))
 (shows_prec_list Zero_nat "strict DP or no strict rules required"))
                                   (\ _ ->
                                     check (nfsc i dpp || wwf_rulesa i dpp)
                                       (shows_prec_list Zero_nat
 "well-formed rules or normal subst. required")))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp stb [st]);
  });

nF_subst_impl ::
  forall a b.
    (Term a b -> Bool) ->
      Bool -> (Term a b, Term a b) -> (b -> Term a b) -> Bool;
nF_subst_impl nf nfs r sigma =
  (if nfs then all (\ x -> nf (sigma x)) (vars_rule_list r) else True);

qnarrows_impl ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                Bool ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Term a [Prelude.Char] ->
                      [(Term a [Prelude.Char],
                         [Prelude.Char] -> Term a [Prelude.Char])];
qnarrows_impl isnf nfs r t =
  concatMap
    (\ p ->
      let {
        tp = subt_at t p;
      } in (if not (is_Var tp)
             then concatMap
                    (\ (l, ra) ->
                      concatMap
                        (\ (mu_1, mu_2) ->
                          (if nF_subst_impl isnf nfs (l, ra) mu_2
                            then (if all isnf (args (subst_apply_term l mu_2))
                                   then [(ctxt_apply_term
    (ctxt_of_pos_term p (subst_apply_term t mu_1)) (subst_apply_term ra mu_2),
   mu_1)]
                                   else [])
                            else []))
                        (option_to_list
                          (mgu_var_disjoint_generic (\ a -> 'x' : a)
                            (\ a -> 'y' : a) tp l)))
                    r
             else []))
    (poss_list t);

narrowing_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      Pos ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
narrowing_proc i st p sts dpp =
  (case let {
          (s, t) = st;
          q = qc i dpp;
        } in bindb (check
                     (nFQ_subset_NF_rulesc i dpp || null q && linear_term t)
                     (shows_prec_list Zero_nat
                       "innermost or full rewriting required (and linearity of t in full rewriting case)"))
               (\ _ ->
                 let {
                   ic = icap_impl_dpp_mv i dpp;
                   isnf = is_QNFc i dpp;
                   pairs = pairsa i dpp;
                 } in bindb (check (membera (poss_list t) p)
                              (shows_prec_list Zero_nat
                                 "position not contained in " .
                                shows_prec_term Zero_nat t))
                        (\ _ ->
                          let {
                            tp = subt_at t p;
                            nftp = isnf tp;
                          } in bindb (check
                                       (membera (poss_list (ic [s] t)) p ||
 not nftp)
                                       (shows_prec_list Zero_nat
 "neither is position contained in capped term of t, nor is t|_p not in Q-normal form"))
                                 (\ _ ->
                                   let {
                                     nfs = nfsc i dpp;
                                     narrows =
                                       qnarrows_impl isnf nfs (rulesd i dpp) tp;
                                     stsa =
                                       filter (\ (smu, _) -> isnf smu)
 (map (\ (ta, mu) ->
        (subst_apply_term s mu,
          ctxt_apply_term (ctxt_of_pos_term p (subst_apply_term t mu)) ta))
   narrows);
                                   } in bindb
  (catch_errora
    (forallM
      (\ new ->
        check (any (\ sta ->
                     instance_rule new sta &&
                       (not nfs || (null q || wf_rule sta)))
                sts)
          (shows_prec_list Zero_nat "could not find narrowed pair " .
            shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> "
              new))
      stsa)
    (\ x -> Inl (snd x)))
  (\ _ ->
    let {
      iedg = is_iedg_edge_dpp i dpp (s, t);
    } in bindb (catch_errora
                 (check_subseteq (vars_term_list tp) (vars_term_list s))
                 (\ x ->
                   Inl (shows_prec_list Zero_nat
                         ("variable " ++ x ++ " only occurs on rhs of pair"))))
           (\ _ ->
             bindb (check (membera (pa i dpp) st || null (rc i dpp))
                     (shows_prec_list Zero_nat
                       "strict DP or no strict rules required"))
               (\ _ ->
                 (if nftp
                   then catch_errora
                          (forallM
                            (\ (u, v) ->
                              bindb (check (membera (poss_list u) p)
                                      (shows_prec_list Zero_nat
 "position not contained in lhs of pair " .
shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " (u, v)))
                                (\ _ ->
                                  (case mgu_var_disjoint_generic
  (\ a -> 'x' : a) (\ a -> 'y' : a) tp (subt_at u p)
                                    of {
                                    Nothing -> Inr ();
                                    Just (mu_1, mu_2) ->
                                      check
(not (isnf (subst_apply_term s mu_1)) || not (isnf (subst_apply_term u mu_2)))
(shows_prec_list Zero_nat
   "t |_ p and u |_ p unify and satisfy variable condition for pair (u,v) = " .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " (u, v));
                                  })))
                            (filter (\ (u, _) -> iedg u) pairs))
                          (\ x -> Inl (snd x))
                   else Inr ())))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

extract_renamings :: forall a. (Eq a) => [(a, a)] -> (a -> a, a -> a);
extract_renamings old_new =
  (fun_of_map_fun (map_of old_new) id,
    fun_of_map_fun (map_of (map swap old_new)) id);

extract_components ::
  forall a. (Eq a) => [(a, Nat)] -> [(a, a)] -> (a -> a, (a -> a, [a]));
extract_components mu old_new =
  let {
    (d, da) = extract_renamings old_new;
    c = map_filter
          (\ x ->
            (if let {
                  (_, a) = x;
                } in equal_nat a Zero_nat
              then Just (fst x) else Nothing))
          mu;
    nu = map d c;
  } in (d, (da, nu));

check_components ::
  forall a.
    (Eq a,
      Showa a) => [(a, Nat)] ->
                    (a -> a, (a -> a, [a])) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_components mu ddNU =
  let {
    (d, (da, nu)) = ddNU;
  } in bindb (catch_errora
               (forallM
                 (\ f ->
                   bindb (check (not (membera mu (f, Nat_of_num One)))
                           (shows_prec_list Zero_nat "new unary symbol " .
                             shows_prec Zero_nat f .
                               shows_prec_list Zero_nat
                                 " clashes with old symbol"))
                     (\ _ ->
                       bindb (check (d (da f) == f)
                               (shows_prec_list Zero_nat
                                  "problem with bijection for renaming of " .
                                 shows_prec Zero_nat f))
                         (\ _ ->
                           check (membera mu (da f, Zero_nat))
                             (shows_prec_list Zero_nat
                                "problem with inverse renaming of " .
                               shows_prec Zero_nat f))))
                 nu)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ (f, n) ->
                 bindb (check (less_eq_nat n (Nat_of_num One))
                         (shows_prec_list Zero_nat "arity > 1 for symbol " .
                           shows_prec Zero_nat f))
                   (\ _ ->
                     check (if equal_nat n Zero_nat
                             then membera nu (d f) && da (d f) == f else True)
                       (shows_prec_list Zero_nat
                          "problem with bijection for renaming of constant " .
                         shows_prec Zero_nat f)))
               mu)
             (\ x -> Inl (snd x)));

str :: forall a b. (a -> a) -> b -> Term a b -> Term a b;
str d x (Fun f (v : vb : vc)) = Fun (d f) [Var x];
str d x (Fun f []) = Fun (d f) [Var x];
str d x (Fun f [t]) = Fun f [str d x t];
str d uu (Var x) = Var x;

choose_var :: forall a b. a -> Term b a -> a;
choose_var x l = hd (vars_term_list l ++ [x]);

check_to_srs_sound ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showa a, Compare b, Eq b,
      Showa b) => a -> [(b, b)] ->
                         [(Term b a, Term b a)] ->
                           [(Term b a, Term b a)] ->
                             [(Term b a, Term b a)] ->
                               [(Term b a, Term b a)] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_to_srs_sound v old_new r s rw sw =
  let {
    mu = funas_trs_list (r ++ rw);
    (d, (da, nu)) = extract_components mu old_new;
  } in bindb (check_components mu (d, (da, nu)))
         (\ _ ->
           bindb (check_varcond_subset r)
             (\ _ ->
               bindb (check_varcond_subset rw)
                 (\ _ ->
                   let {
                     checka =
                       (\ ra sa ->
                         catch_errora
                           (forallM
                             (\ (l, rb) ->
                               let {
                                 y = choose_var v l;
                                 stra = str d y;
                                 slr = (stra l, stra rb);
                               } in check (less_eq_set (vars_term l)
     (inserta y bot_set) &&
    membera sa slr)
                                      (shows_prec_list Zero_nat
 "problem with new rule " .
shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " slr))
                             ra)
                           (\ x -> Inl (snd x)));
                   } in bindb (checka r s) (\ _ -> checka rw sw))));

const_to_string_sound_tt ::
  forall a b c.
    (Compare a, Eq a, Showa a, Finite_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare b, Eq b, Set_impl b,
      Showa b) => Const_string_sound_proof a b ->
                    Tp_ops_ext c a b () ->
                      c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
const_to_string_sound_tt (Const_string_sound_proof v old_new s sw) i tp =
  bindb (check_to_srs_sound v old_new (rb i tp) s (rwb i tp) sw)
    (\ _ -> Inr (mkb i False [] s sw));

dP_list ::
  forall a b.
    (Eq a,
      Eq b) => (a -> a) ->
                 [(Term a b, Term a b)] -> [(a, Nat)] -> [(Term a b, Term a b)];
dP_list shp r d_list =
  concatMap
    (\ lr ->
      let {
        l = fst lr;
        s = sharp_term shp l;
      } in map_filter
             (\ x ->
               (if not (supt_impl l x) &&
                     not (is_Var x) && membera d_list (the (root x))
                 then Just (s, sharp_term shp x) else Nothing))
             (supteq_list (snd lr)))
    r;

dependency_pairs_tt ::
  forall a b c d.
    (Compare b, Eq b, Linorder b, Showa b, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Linorder c,
      Showa c) => Tp_ops_ext a b c () ->
                    Dpp_ops_ext d b c () ->
                      a -> Bool ->
                             Bool ->
                               (b -> b) ->
                                 [(Term b c, Term b c)] ->
                                   Sum ([Prelude.Char] -> [Prelude.Char]) d;
dependency_pairs_tt i j tp nfs m shp p =
  let {
    r = rulesc i tp;
    q = qb i tp;
    iQ = is_QNFb i tp;
    u = filter (applicable_rule_impl iQ) r;
  } in (case catch_errora
               (bindb
                 (if isOK (check_wf_trs u) then Inr ()
                   else check (nfs &&
                                nfsb i tp &&
                                  nFQ_subset_NF_rulesb i tp &&
                                    all (\ l -> not (is_Var l)) (map fst r))
                          (shows_prec_list Zero_nat
                            "neither is the TRS well-formed, nor is the restriction to innermost with normal form substitutions present"))
                 (\ _ ->
                   bindb (catch_errora (forallM check_no_var q)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       let {
                         qr = map (\ (Fun f ss) -> (f, size_list ss)) q;
                         d = defined_list u;
                       } in bindb (catch_errora
                                    (forallM
                                      (\ (f, n) ->
check (not (membera d (shp f, n)))
  (shows_string "sharping " .
    shows_prec Zero_nat f .
      shows_string " yields the defined symbol " . shows_prec Zero_nat (shp f)))
                                      d)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (catch_errora
(forallM
  (\ (f, n) ->
    check (not (membera qr (shp f, n)))
      (shows_string "sharping " .
        shows_prec Zero_nat f .
          shows_string " yields the symbol " .
            shows_prec Zero_nat (shp f) . shows_string " which is a root of Q"))
  d)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    let {
                                      pa = set p;
                                    } in catch_errora
   (catch_errora
     (forallM
       (\ x ->
         (if member x pa || any (eq_rule_mod_vars x) p then Inr () else Inl x))
       (dP_list shp u d))
     (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string "the DP " .
           shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " x .
             shows_string " does not appear in the DP problem" . shows_nl)))))))
               (\ x ->
                 Inl (shows_string
                        "the DP-transformation is not applied correctly." .
                       shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc j nfs m p [] q [] r);
       });

switch_innermost_tt ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_innermost_tt i joins_i trs =
  let {
    r = rulesc i trs;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list Zero_nat
                                  "rules are not overlay"))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_critical_pairs r cp joins_i)
                        (\ _ -> check_wf_trs r))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i True (map fst r) r []);
       });

unary_term :: forall a b. Term a b -> Bool;
unary_term (Var x) = True;
unary_term (Fun f [t]) = unary_term t;
unary_term (Fun v []) = False;
unary_term (Fun v (vb : vd : ve)) = False;

check_unary_signature ::
  forall a b.
    (Showa a,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unary_signature r =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (l, ra) = x;
              } in unary_term l && unary_term ra
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string "the rule " .
            shows_nl .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " x .
                shows_nl .
                  shows_string
                    "violates the condition that all function symbols" .
                    shows_nl . shows_prec_list Zero_nat "have to be unary"));

rev_term :: forall a b. Ctxt a b -> Term a b -> Term a b;
rev_term c (Var x) = ctxt_apply_term c (Var x);
rev_term c (Fun f [t]) = rev_term (More f [] c []) t;

rev_rule :: forall a b. (Term a b, Term a b) -> (Term a b, Term a b);
rev_rule (l, r) = (rev_term Hole l, rev_term Hole r);

string_reversal_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_tt i trs =
  let {
    rs = rulesc i trs;
    r = rb i trs;
    s = rwb i trs;
  } in (case check_unary_signature rs of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (mkb i default_nfs_trs [] (map rev_rule r) (map rev_rule s));
       });

q_emptyb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
q_emptyb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = q_empty;

sem_lab_rel_tt ::
  forall a b c d.
    (Compare a, Eq a, Showa a, Ccompare b, Compare b, Eq b, Mapping_impl b,
      Showa b) => ([(Term a b, Term a b)] ->
                    Set (Term a b, Term a b) ->
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]))) ->
                    (a -> (a, c)) ->
                      Tp_ops_ext d a b () ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                          ([(Term a b, Term a b)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            (Set (Term a b, Term a b) ->
                              [(Term a b, Term a b)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              [Term a b] ->
                                [(Term a b, Term a b)] ->
                                  d -> Sum ([Prelude.Char] -> [Prelude.Char]) d;
sem_lab_rel_tt splitter ld i valid check_decr check_model_lab lQ lAll tp =
  let {
    r = rb i tp;
    rw = rwb i tp;
    nfs = nfsb i tp;
    (lR, (lRw, d)) = splitter lAll (set rw);
  } in (case bindb valid
               (\ _ ->
                 let {
                   q = qb i tp;
                 } in catch_errora
                        (bindb
                          (if nfs && not (q_emptyb i tp) then check_wf_trs d
                            else Inr ())
                          (\ _ ->
                            bindb (check_decr d)
                              (\ _ ->
                                bindb (check_sl_Q ld lQ q)
                                  (\ _ ->
                                    bindb (check_model_lab (set lR) r)
                                      (\ _ -> check_model_lab (set lRw) rw)))))
                        (\ x ->
                          Inl (shows_string "problem with labeled TRS:" .
                                shows_nl . x)))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i nfs lQ lR (lRw ++ d));
       });

sem_lab_fin_tt ::
  forall a b c d e.
    (Compare a, Eq a, Showa a, Ccompare b, Compare b, Eq b, Mapping_impl b,
      Showa b,
      Showa d) => ([(Term a b, Term a b)] ->
                    Set (Term a b, Term a b) ->
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]))) ->
                    (a -> Nat -> c -> a) ->
                      (a -> (a, c)) ->
                        (d -> d -> Bool) ->
                          Tp_ops_ext e a b () ->
                            ([(a, Nat)] ->
                              [(a, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char])
                                  (Sl_ops_ext a d c b ())) ->
                              [Term a b] ->
                                [(Term a b, Term a b)] ->
                                  e -> Sum ([Prelude.Char] -> [Prelude.Char]) e;
sem_lab_fin_tt splitter lc ld cge i gen lQ lAll tp =
  bindb (gen (insert_funas_trs (rulesc i tp) []) [])
    (\ ops ->
      let {
        check_ml =
          check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) cge lc;
        check_d = sl_check_decr ops;
      } in sem_lab_rel_tt splitter ld i (Inr ()) check_d check_ml lQ lAll tp);

semlab_fin_tt ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a (Lab b [Nat]) c () ->
                    Sl_variant (Lab b [Nat]) c ->
                      [Term (Lab b [Nat]) c] ->
                        [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
semlab_fin_tt j (Rootlab uu) =
  sem_lab_fin_tt (model_splitter label_decomp) label label_decomp equal_lab j
    (slm_gen_to_sl_gen (rl_slm Nothing));
semlab_fin_tt j (Finitelab sli) =
  sem_lab_fin_tt (model_splitter label_decomp) label label_decomp equal_nat j
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli)));
semlab_fin_tt j (QuasiFinitelab sli v) =
  sem_lab_fin_tt (quasi_splitter label_decomp) label label_decomp qmodel_cge j
    (\ f g -> qsli_to_sl v f g sli);

permutation_afs :: forall a. (Ceq a, Ccompare a) => Afs a -> Bool;
permutation_afs pi =
  ball (afs_syms pi)
    (\ (f, n) ->
      (case afsa pi (f, n) of {
        Collapse _ -> False;
        AFList xs -> eq_set (set xs) (set (upt Zero_nat n)) && distinct xs;
      }));

argument_filter_tt ::
  forall a b c.
    (Ceq b, Ccompare b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b c () ->
                    [((b, Nat), Af_entry)] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
argument_filter_tt i pi tp =
  (case afs_of pi of {
    Nothing -> Inl (shows_prec_list Zero_nat "invalid argument filter");
    Just af ->
      bindb (check (permutation_afs af)
              (shows_prec_list Zero_nat "argument filter is not a permutation"))
        (\ _ ->
          let {
            pia = af_rules af;
          } in Inr (mkb i default_nfs_trs [] (pia (rb i tp)) (pia (rwb i tp))));
  });

rule_removal_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_tt i rp rremove trs =
  (case catch_errora
          (let {
             (rs, rns) = split_rulesb i trs rremove;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (catch_errora (mono rp (rs ++ rns))
                            (\ x ->
                              Inl (shows_string
                                     "problem with monotonicity of strict order" .
                                    shows_nl . x)))
                      (\ _ ->
                        bindb (catch_errora
                                (catch_errora (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 "problem when orienting TRS" .
shows_nl . x)))
                          (\ _ ->
                            catch_errora
                              (catch_errora (forallM (s rp) rs)
                                (\ x -> Inl (snd x)))
                              (\ x ->
                                Inl (shows_string "problem when orienting TRS" .
                                      shows_nl . x))))))
          (\ x ->
            Inl (shows_string
                   "could not apply the reduction pair processor with the following" .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_R_Rwb i trs rremove rremove);
  });

check_wwf_qtrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => (Term a b -> Bool) ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wwf_qtrs nf r =
  catch_errora
    (catch_errora
      (forallM
        (\ ra ->
          (if applicable_rule_impl nf ra
            then catch_errora
                   (bindb
                     (check (not (is_Var (fst ra)))
                       (shows_string "variable left-hand side in"))
                     (\ _ ->
                       catch_errora
                         (check_subseteq (vars_term_list (snd ra))
                           (vars_term_list (fst ra)))
                         (\ x ->
                           Inl (shows_string "free variable " .
                                 shows_prec Zero_nat x .
                                   shows_string " in right-hand side of"))))
                   (\ x ->
                     Inl (x . shows_string " rule " .
                                shows_rule (shows_prec Zero_nat)
                                  (shows_prec Zero_nat) " -> " ra .
                                  shows_nl))
            else Inr ()))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string "the Q-TRS is not weakly well-formed" . shows_nl . x));

check_compatible_nfs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => Bool ->
                    (Term a b -> Bool) ->
                      [(Term a b, Term a b)] -> Bool -> [Term a b] -> Bool;
check_compatible_nfs nfs1 nf1 r1 nfs2 q2 =
  nfs1 == nfs2 || (null q2 || isOK (check_wwf_qtrs nf1 r1));

shows_tp ::
  forall a b c.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Tp_ops_ext c a b () -> c -> [Prelude.Char] -> [Prelude.Char];
shows_tp fun var i t =
  let {
    nfs = nfsb i t;
    r = rb i t;
    rw = rwb i t;
    q = qb i t;
  } in shows_trs fun var "rules:" " -> " r .
         (if null rw then id
           else shows_trs fun var "relative rules:" " ->= " rw) .
           (if null q then id else shows_terms fun var "Q-component:" q) .
             (if nfs
               then shows_string
                      "substitutions are assumed to be in normal form" .
                      shows_nl
               else id);

check_tp_subsumes ::
  forall a b c d.
    (Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => Tp_ops_ext a (Lab b c) d () ->
                    (Bool,
                      ([Term (Lab b c) d],
                        ([(Term (Lab b c) d, Term (Lab b c) d)],
                          [(Term (Lab b c) d, Term (Lab b c) d)]))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_tp_subsumes i (nfs, (q, (r, rw))) tp =
  catch_errora
    (let {
       nfsa = nfsb i tp;
       qa = is_QNFb i tp;
       ra = rb i tp;
       rwa = rwb i tp;
       rba = r ++ rw;
       nf1 = is_QNFb i tp;
     } in bindb (check (check_compatible_nfs nfsa nf1 (ra ++ rwa) nfs q)
                  (shows_prec_list Zero_nat
                    "incompatible substitutions-in-normal-form flags"))
            (\ _ ->
              bindb (catch_errora (check_NF_terms_subset qa q)
                      (\ x ->
                        Inl (shows_prec_list Zero_nat
                               "problem with innermost strategy due to term " .
                              shows_term (shows_prec_lab Zero_nat)
                                (shows_prec Zero_nat) x)))
                (\ _ ->
                  bindb (catch_errora (check_subseteq ra r)
                          (\ x ->
                            Inl (toomuch "rule"
                                  (shows_rule (shows_prec_lab Zero_nat)
                                    (shows_prec Zero_nat) " -> " x))))
                    (\ _ ->
                      bindb (catch_errora (check_subseteq rwa rba)
                              (\ x ->
                                Inl (toomuch "relative rule"
                                      (shows_rule (shows_prec_lab Zero_nat)
(shows_prec Zero_nat) " -> " x))))
                        (\ _ -> Inr ())))))
    (\ x ->
      Inl (shows_string "termination of the problem" .
            shows_nl .
              shows_tp (shows_prec_lab Zero_nat) (shows_prec Zero_nat) i tp .
                shows_nl .
                  shows_string
                    "may not be concluded from assuming termination of the problem" .
                    shows_nl .
                      shows_tp (shows_prec_lab Zero_nat) (shows_prec Zero_nat) i
                        (mkb i nfs q r rw) .
                        shows_nl . x . shows_nl));

fcc_tt ::
  forall a b c.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    [Ctxt b c] ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
fcc_tt i fcs cRb tp =
  let {
    r = rb i tp;
    rw = rwb i tp;
    nfs = nfsb i tp;
    rba = r ++ rw;
    (cR, cRw) = partition_rules fcs r cRb;
    _ = qb i tp;
    vs = vars_trs_list rba;
    fas = funas_trs_list rba;
  } in (case bindb (check (not (null fcs))
                     (shows_string
                        "at least one flat context is required for flat context closure" .
                       shows_nl))
               (\ _ ->
                 bindb (catch_errora (forallM (check_flat_ctxt vs) fcs)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catch_errora
                             (forallM (check_is_flat_ctxt vs fas) fcs)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catch_errora
                                 (forallM (check_flat_ctxt_complete fcs) fas)
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             bindb (catch_errora
                                     (forallM (check_rule_preserving fcs cR) r)
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 catch_errora
                                   (forallM (check_rule_preserving fcs cRb) rw)
                                   (\ x -> Inl (snd x)))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i nfs [] cR cRw);
       });

g_isEmpty_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> Bool;
g_isEmpty_dflt_basic_oops_rm_basic_ops s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ c -> c)
    (\ _ _ -> False) True;

ta_rhs_states_set :: forall a b c. Ta_impl_ext a b c -> Rbt a ();
ta_rhs_states_set
  (Ta_impl_ext ta_final_impl ta_rules_impl ta_r_lhs_states_impl
    ta_rhs_states_set ta_eps_impl ta_epss_impl ta_epsrs_impl more)
  = ta_rhs_states_set;

ta_rules_impl ::
  forall a b c. Ta_impl_ext a b c -> Rbt (b, Nat) [Ta_rule_impl a b];
ta_rules_impl
  (Ta_impl_ext ta_final_impl ta_rules_impl ta_r_lhs_states_impl
    ta_rhs_states_set ta_eps_impl ta_epss_impl ta_epsrs_impl more)
  = ta_rules_impl;

r_lhs_states_impl :: forall a b. Ta_rule_impl a b -> [a];
r_lhs_states_impl (TA_rule_impl f qsa q qs) = qsa;

rm_set_lookup :: forall a b. (Compare_order a) => Rbt a [b] -> a -> [b];
rm_set_lookup rm =
  (\ a -> (case lookup rm a of {
            Nothing -> [];
            Just rules -> rules;
          }));

g_union_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Rbt a ();
g_union_dflt_basic_oops_rm_basic_ops s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s1 (\ _ -> True)
    ins_rm_basic_ops s2;

rs_Union :: forall a. (Compare_order a) => [Rbt a ()] -> Rbt a ();
rs_Union = foldl g_union_dflt_basic_oops_rm_basic_ops (empty_rm_basic_ops ());

rqss_impl :: forall a b. Ta_rule_impl a b -> Rbt a ();
rqss_impl (TA_rule_impl f qsa q qs) = qs;

ta_res_impl_all ::
  forall a b c.
    (Compare_order a,
      Compare_order b) => Rbt a () ->
                            Rbt (b, Nat) [Ta_rule_impl a b] ->
                              Term b c -> Rbt a ();
ta_res_impl_all q ta (Var uu) = q;
ta_res_impl_all q ta (Fun f ts) =
  let {
    rec = map (ta_res_impl_all q ta) ts;
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    arules =
      filter
        (\ rule ->
          let {
            qs = r_lhs_states_impl rule;
          } in all_interval_nat
                 (\ i -> memb_rm_basic_ops (nth qs i) (nth rec i)) Zero_nat n)
        rules;
    a = map rqss_impl arules;
  } in rs_Union a;

rule_state_compatible_heuristic ::
  forall a b c.
    (Compare_order a, Compare_order b,
      Linorder c) => Ta_impl_ext a b () -> Term b c -> Bool;
rule_state_compatible_heuristic ta l =
  g_isEmpty_dflt_basic_oops_rm_basic_ops
    (ta_res_impl_all (ta_rhs_states_set ta) (ta_rules_impl ta) l);

ta_rules_impla :: forall a b. Tree_automaton a b -> [Ta_rule a b];
ta_rules_impla (Tree_Automaton x1 x2 x3) = x2;

check_state_raise_consistent ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Linorder a, Set_impl a, Showa a, Eq b,
      Showa b) => Tree_automaton a (b, Nat) ->
                    [(a, a)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_state_raise_consistent ta rel =
  let {
    rels = set rel;
    rls = ta_rules_impla ta;
  } in catch_errora
         (forallM
           (\ r1 ->
             let {
               (TA_rule (f1, i1) qs1 q1) = r1;
             } in catch_errora
                    (forallM
                      (\ r2 ->
                        let {
                          (TA_rule (f2, i2) qs2 q2) = r2;
                        } in (if f1 == f2 && less_nat i1 i2 && qs1 == qs2
                               then check (member (q1, q2) rels)
                                      (shows_prec_list Zero_nat
 "problem with raise consistency because of automaton-rules " .
shows_nl .
  shows_prec_ta_rule Zero_nat r1 .
    shows_nl .
      shows_prec_ta_rule Zero_nat r2 .
        shows_nl .
          shows_prec Zero_nat q1 .
            shows_prec_list Zero_nat " is not >>^* " . shows_prec Zero_nat q2)
                               else Inr ()))
                      rls)
                    (\ x -> Inl (snd x)))
           rls)
         (\ x -> Inl (snd x));

ta_epsrs_impl :: forall a b c. Ta_impl_ext a b c -> a -> Rbt a ();
ta_epsrs_impl
  (Ta_impl_ext ta_final_impl ta_rules_impl ta_r_lhs_states_impl
    ta_rhs_states_set ta_eps_impl ta_epss_impl ta_epsrs_impl more)
  = ta_epsrs_impl;

ta_epss_impl :: forall a b c. Ta_impl_ext a b c -> a -> Rbt a ();
ta_epss_impl
  (Ta_impl_ext ta_final_impl ta_rules_impl ta_r_lhs_states_impl
    ta_rhs_states_set ta_eps_impl ta_epss_impl ta_epsrs_impl more)
  = ta_epss_impl;

g_inter_dflt_basic_oops_rm_basic_ops ::
  forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Rbt a ();
g_inter_dflt_basic_oops_rm_basic_ops s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s1 (\ _ -> True)
    (\ x s -> (if memb_rm_basic_ops x s2 then ins_dj_rm_basic_ops x s else s))
    (empty_rm_basic_ops ());

ta_match_impl ::
  forall a b c.
    (Compare_order a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                 Rbt b () ->
                   (b -> Rbt b ()) -> Term a c -> [b] -> Rbt [(c, b)] ();
ta_match_impl ta qsig eps (Var x) q =
  g_from_list_dflt_basic_oops_rm_basic_ops
    (map (\ qa -> [(x, qa)])
      (g_to_list_dflt_basic_oops_rm_basic_ops
        (g_inter_dflt_basic_oops_rm_basic_ops (rs_Union (map eps q)) qsig)));
ta_match_impl ta qsig eps (Fun f ts) q =
  let {
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    ep = rs_Union (map eps q);
    fa = (\ rule ->
           g_from_list_dflt_basic_oops_rm_basic_ops
             (let {
                (TA_rule_impl _ qs qa _) = rule;
              } in (if memb_rm_basic_ops qa ep
                     then let {
                            rec = map (\ (tsi, qsi) ->
g_to_list_dflt_basic_oops_rm_basic_ops (ta_match_impl ta qsig eps tsi [qsi]))
                                    (zip ts qs);
                          } in map concat (concat_lists rec)
                     else [])));
  } in rs_Union (map fa rules);

ta_match_impla ::
  forall a b c.
    (Compare_order a, Compare_order b, Eq b, Compare_order c,
      Eq c) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                 Rbt b () ->
                   (b -> Rbt b ()) -> [b] -> Term a c -> Rbt [(c, b)] ();
ta_match_impla ta qsig eps rhs t = ta_match_impl ta qsig eps t rhs;

ta_res_impl ::
  forall a b.
    (Compare_order a,
      Compare_order b) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                            (b -> Rbt b ()) -> Term a b -> Rbt b ();
ta_res_impl ta eps (Var q) = eps q;
ta_res_impl ta eps (Fun f ts) =
  let {
    rec = map (ta_res_impl ta eps) ts;
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    arules =
      filter
        (\ rule ->
          let {
            qs = r_lhs_states_impl rule;
          } in all_interval_nat
                 (\ i -> memb_rm_basic_ops (nth qs i) (nth rec i)) Zero_nat n)
        rules;
    a = map rqss_impl arules;
  } in rs_Union a;

rule_state_compatible_eff_list ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => Ta_impl_ext a b () ->
                 (Rbt a () -> Rbt a () -> Maybe a) ->
                   (Term b c, Term b c) -> Sum ((Term b a, Term b a), a) ();
rule_state_compatible_eff_list ta rel (l, r) =
  let {
    rm = ta_rules_impl ta;
    eps = ta_epss_impl ta;
    epsa = ta_epsrs_impl ta;
    ta_res = ta_res_impl rm eps;
    rhs_rbt = ta_rhs_states_set ta;
    rhs = g_to_list_dflt_basic_oops_rm_basic_ops rhs_rbt;
  } in catch_errora
         (forallM
           (\ sigma ->
             let {
               sigmaa = fun_of sigma;
               l_sigma = map_term (\ x -> x) sigmaa l;
               r_sigma = map_term (\ x -> x) sigmaa r;
               qsl = ta_res l_sigma;
               qsr = ta_res r_sigma;
             } in (case rel qsl qsr of {
                    Nothing -> Inr ();
                    Just q -> Inl ((l_sigma, r_sigma), q);
                  }))
           (g_to_list_dflt_basic_oops_rm_basic_ops
             (ta_match_impla rm rhs_rbt epsa rhs l)))
         (\ x -> Inl (snd x));

state_compatible_eff_list ::
  forall a b c.
    (Compare_order a, Eq a, Compare_order b, Compare_order c,
      Eq c) => Ta_impl_ext a b () ->
                 (Rbt a () -> Rbt a () -> Maybe a) ->
                   [(Term b c, Term b c)] ->
                     Sum ((Term b c, Term b c), ((Term b a, Term b a), a)) ();
state_compatible_eff_list ta rel r =
  let {
    check = rule_state_compatible_eff_list ta rel;
  } in catch_errora
         (forallM (\ lr -> catch_errora (check lr) (\ x -> Inl (lr, x))) r)
         (\ x -> Inl (snd x));

ta_final_impl :: forall a b c. Ta_impl_ext a b c -> Rbt a ();
ta_final_impl
  (Ta_impl_ext ta_final_impl ta_rules_impl ta_r_lhs_states_impl
    ta_rhs_states_set ta_eps_impl ta_epss_impl ta_epsrs_impl more)
  = ta_final_impl;

flatten_term_enum_filter ::
  forall a b. (Term a b -> Bool) -> Term [a] b -> [Term a b];
flatten_term_enum_filter f (Var x) =
  let {
    tx = Var x;
  } in (if f tx then [tx] else []);
flatten_term_enum_filter f (Fun fs ts) =
  let {
    lts = map (flatten_term_enum_filter f) ts;
  } in (if any null lts then []
         else let {
                ss = concat_lists lts;
              } in filter f (concatMap (\ fa -> map (Fun fa) ss) fs));

inverse_base_term_filter ::
  forall a b. (Term (a, Nat) b -> Bool) -> Term a b -> Nat -> [Term (a, Nat) b];
inverse_base_term_filter filt l c =
  let {
    hs = upt Zero_nat (plus_nat c (Nat_of_num One));
  } in flatten_term_enum_filter filt
         (map_term (\ f -> map (\ h -> lift h f) hs) (\ x -> x) l);

size_multiset :: forall a. Multiset a -> Nat;
size_multiset (Bag ms) = foldd (\ _ -> plus_nat) Zero_nat ms;

compute_height ::
  forall a b.
    (Eq a,
      Eq b) => Relation_kind ->
                 Term a b -> Term a b -> Term (a, Nat) b -> Nat -> Nat;
compute_height (Weak_TRS Nothing) bl br =
  (if less_eq_nat (size_multiset (funs_term_ms br))
        (size_multiset (funs_term_ms bl))
    then (\ l x ->
           (if equal_term (map_term (lift x) (\ xa -> xa) bl) l then x
             else plus_nat x (Nat_of_num One)))
    else (\ _ -> suc));
compute_height (Weak_TRS (Just c)) bl br =
  (if less_eq_nat (size_multiset (funs_term_ms br))
        (size_multiset (funs_term_ms bl))
    then (\ l x ->
           (if equal_term (map_term (lift x) (\ xa -> xa) bl) l then min c x
             else min c (plus_nat x (Nat_of_num One))))
    else (\ _ x -> min c (plus_nat x (Nat_of_num One))));
compute_height Strict_TRS bl br = (\ _ -> suc);

cover_bound_list_filter ::
  forall a b.
    (Eq a,
      Eq b) => (Term (a, Nat) b -> Bool) ->
                 ((Term a b, Term a b) -> Term a b -> Bool) ->
                   Relation_kind ->
                     Nat ->
                       [(Term a b, Term a b)] ->
                         [(Term (a, Nat) b, Term (a, Nat) b)];
cover_bound_list_filter filt ff gg c r =
  concatMap
    (\ (l, ra) ->
      let {
        ch = compute_height gg l ra;
        ee = ff (l, ra);
      } in map (\ la ->
                 (la, map_term
                        (lift (ch la
                                (min_list
                                  (map height
                                    (sym_collect
                                      (\ t -> ee (map_term base (\ x -> x) t))
                                      la)))))
                        (\ x -> x) ra))
             (inverse_base_term_filter filt l c))
    r;

g_bex_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> (a -> Bool) -> Bool;
g_bex_dflt_basic_oops_rm_basic_ops s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s not (\ x _ -> p x)
    False;

ta_contains_aux_impl ::
  forall a b.
    (Compare_order a, Ceq b, Ccompare b, Eq b,
      Linorder b) => [(a, Nat)] ->
                       [b] -> Ta_impl_ext b a () -> Set b -> Sum (Term a b) ();
ta_contains_aux_impl f qs ta q =
  let {
    _ = ta_final_impl ta;
    look = rm_set_lookup (ta_rules_impl ta);
    _ = ta_epss_impl ta;
  } in catch_errora
         (forallM
           (\ (fa, n) ->
             let {
               rules = look (fa, n);
             } in catch_errora
                    (catch_errora
                      (forallM
                        (\ x ->
                          (if any (\ rule ->
                                    r_lhs_states_impl rule == x &&
                                      let {
qq = rqss_impl rule;
                                      } in
g_bex_dflt_basic_oops_rm_basic_ops qq (\ qa -> member qa q))
                                rules
                            then Inr () else Inl x))
                        (concat_lists (replicate n qs)))
                      (\ x -> Inl (snd x)))
                    (\ x -> Inl (Fun fa (map Var x))))
           f)
         (\ x -> Inl (snd x));

alpha_rm_basic_ops :: forall a. (Cenum a, Compare_order a) => Rbt a () -> Set a;
alpha_rm_basic_ops s = dom (lookup s);

ta_contains_impl ::
  forall a b.
    (Compare_order a, Cenum b, Ceq b, Ccompare b, Compare_order b, Eq b,
      Set_impl b) => [(a, Nat)] ->
                       [(a, Nat)] ->
                         Ta_impl_ext b a () -> [b] -> Sum (Term a b) ();
ta_contains_impl f g ta qs =
  bindb (ta_contains_aux_impl f qs ta (set qs))
    (\ _ ->
      ta_contains_aux_impl g qs ta (alpha_rm_basic_ops (ta_final_impl ta)));

check_coherent_rule ::
  forall a b.
    (Compare_order a, Eq a, Showa a, Eq b,
      Showa b) => (a -> [a]) ->
                    Rbt (a, a) () ->
                      [Ta_rule a b] ->
                        Ta_rule a b ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_coherent_rule iter rel rules (TA_rule f qs q) =
  catch_errora
    (forallM
      (\ i ->
        let {
          qi = nth qs i;
        } in catch_errora
               (forallM
                 (\ qia ->
                   let {
                     qsa = list_update qs i qia;
                   } in check (not (null (filter
   (\ (TA_rule g qsb qa) ->
     f == g && qsa == qsb && memb_rm_basic_ops (q, qa) rel)
   rules)))
                          (shows_prec_list Zero_nat "rule " .
                            shows_prec Zero_nat f .
                              shows_prec_list Zero_nat "(" .
                                shows_prec_list Zero_nat qs .
                                  shows_prec_list Zero_nat ") -> " .
                                    shows_prec Zero_nat q .
                                      shows_prec_list Zero_nat " with " .
shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) .
  shows_prec_list Zero_nat ". argument decreased to " .
    shows_prec Zero_nat qia . shows_prec_list Zero_nat " has no counterpart"))
                 (iter qi))
               (\ x -> Inl (snd x)))
      (upt Zero_nat (size_list qs)))
    (\ x -> Inl (snd x));

ntrancl ::
  forall a. (Ceq a, Ccompare a, Set_impl a) => Nat -> Set (a, a) -> Set (a, a);
ntrancl n r =
  (if equal_nat n Zero_nat then r
    else let {
           ra = ntrancl (minus_nat n (Nat_of_num One)) r;
         } in sup_set ra (relcomp ra r));

trancl ::
  forall a.
    (Card_UNIV a, Ceq a, Ccompare a, Set_impl a) => Set (a, a) -> Set (a, a);
trancl a =
  (if finite a then ntrancl (minus_nat (card a) (Nat_of_num One)) a
    else (error :: forall a. String -> (() -> a) -> a) "trancl: infinite set"
           (\ _ -> trancl a));

check_coherent ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showa a, Eq b,
      Showa b) => Tree_automaton a b ->
                    Ta_relation a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_coherent (Tree_Automaton fin rules eps) (Some_Relation rel) =
  let {
    iter =
      (\ q ->
        map_filter
          (\ x ->
            (if let {
                  (a, _) = x;
                } in a == q
              then Just (snd x) else Nothing))
          rel);
    rs = g_from_list_dflt_basic_oops_rm_basic_ops rel;
    ep = set eps;
    rell = converse (set rel);
  } in bindb (catch_errora (check_subseteq (concatMap iter fin) fin)
               (\ x ->
                 Inl (shows_prec Zero_nat x .
                       shows_prec_list Zero_nat
                         " is in relation to a final state, but not a final state itself")))
         (\ _ ->
           bindb (catch_errora
                   (forallM (check_coherent_rule iter rs rules) rules)
                   (\ x -> Inl (snd x)))
             (\ _ ->
               check (less_eq_set (relcomp rell ep)
                       (sup_set (relcomp (trancl ep) rell) rell))
                 (shows_prec_list Zero_nat
                   "problem in coherence of epsilon rules")));
check_coherent uu Decision_Proc = Inr ();
check_coherent uu Id_Relation = Inr ();

rtrancl_rbt_impl :: forall a. (Compare_order a) => [(a, a)] -> [a] -> Rbt a ();
rtrancl_rbt_impl =
  rtrancl_impl
    (\ r ->
      let {
        rm = elem_list_to_rm fst r;
      } in (\ asa ->
             g_to_list_dflt_basic_oops_rm_basic_ops
               (rs_Union
                 (map (\ a ->
                        g_from_list_dflt_basic_oops_rm_basic_ops
                          (map snd (rm_set_lookup rm a)))
                   asa))))
    (\ asa bs ->
      g_union_dflt_basic_oops_rm_basic_ops bs
        (g_from_list_dflt_basic_oops_rm_basic_ops asa))
    memb_rm_basic_ops (empty_rm_basic_ops ());

memo_rbt_rtrancl :: forall a. (Compare_order a) => [(a, a)] -> a -> Rbt a ();
memo_rbt_rtrancl r =
  let {
    tr = rtrancl_rbt_impl r;
    rm = g_list_to_map_rm_basic_ops
           (map (\ a -> (a, tr [a]))
             (((g_to_list_dflt_basic_oops_rm_basic_ops .
                 g_from_list_dflt_basic_oops_rm_basic_ops) .
                map fst)
               r));
  } in (\ a ->
         (case lookup rm a of {
           Nothing -> g_from_list_dflt_basic_oops_rm_basic_ops [a];
           Just asa -> asa;
         }));

conv_ta_rule :: forall a b. (a -> Rbt a ()) -> Ta_rule a b -> Ta_rule_impl a b;
conv_ta_rule eps (TA_rule f qs q) = TA_rule_impl f qs q (eps q);

r_sym_impl :: forall a b. Ta_rule_impl a b -> (b, Nat);
r_sym_impl (TA_rule_impl f qsa q qs) = (f, size_list qsa);

generate_ta ::
  forall a b.
    (Compare_order a,
      Compare_order b) => Tree_automaton a b -> Ta_impl_ext a b ();
generate_ta (Tree_Automaton fin rules eps) =
  let {
    ep = memo_rbt_rtrancl eps;
    epr = memo_rbt_rtrancl (map (\ (q, qa) -> (qa, q)) eps);
    rqs_rs = rs_Union (map (\ rule -> ep (r_rhs rule)) rules);
    rrules = map (conv_ta_rule ep) rules;
  } in Ta_impl_ext (g_from_list_dflt_basic_oops_rm_basic_ops fin)
         (elem_list_to_rm r_sym_impl rrules)
         (g_to_list_dflt_basic_oops_rm_basic_ops rqs_rs) rqs_rs eps ep epr ();

generate_ta_cond ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Ccompare a, Compare_order a, Eq a, Set_impl a,
      Showa a, Compare_order b, Eq b,
      Showa b) => Tree_automaton a b ->
                    Ta_relation a ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Ta_impl_ext a b ());
generate_ta_cond ta rel =
  bindb (catch_errora (check_coherent ta rel)
          (\ x ->
            Inl (shows_prec_list Zero_nat
                   "automaton is not coherent w.r.t. relation" .
                  shows_nl . x)))
    (\ _ -> Inr (generate_ta ta));

relation_as_list ::
  forall a. Ta_relation a -> Sum ([Prelude.Char] -> [Prelude.Char]) [(a, a)];
relation_as_list (Some_Relation rel) = Inr rel;
relation_as_list Id_Relation = Inr [];
relation_as_list Decision_Proc =
  Inl (shows_prec_list Zero_nat
        "decision procedure not available for non-left linear TRSs");

check_ta_bounded ::
  forall a b c.
    (Linorder b,
      Showa b) => Ta_impl_ext a (b, Nat) c ->
                    Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ta_bounded ta c =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (f, _) = x;
              } in less_eq_nat (height f) c
            then Inr () else Inl x))
        (map fst (g_to_list_rm_basic_ops (ta_rules_impl ta))))
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (let {
             (f, _) = x;
           } in shows_prec_prod Zero_nat f .
                  shows_prec_list Zero_nat
                    " is symbol in TA with height larger than c = " .
                    shows_prec_nat Zero_nat c));

bounds_condition ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => Boundstype ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_condition Roof uu = Inr ();
bounds_condition Match r =
  catch_errora
    (catch_errora
      (forallM
        (\ x ->
          (if let {
                (l, ra) = x;
              } in less_eq_multiset (vars_term_ms ra) (vars_term_ms l)
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (let {
             (l, ra) = x;
           } in shows_prec_list Zero_nat "rule " .
                  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                    (l, ra) .
                    shows_prec_list Zero_nat " is duplicating"));

non_collapsing_impl :: forall a b c. [(a, Term b c)] -> Bool;
non_collapsing_impl r = all ((\ t -> not (is_Var t)) . snd) r;

construct_c_opt :: forall a b. Nat -> [(Term a b, Term a b)] -> Maybe Nat;
construct_c_opt c r = (if non_collapsing_impl r then Just c else Nothing);

boundstype_fun ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => Boundstype -> (Term a b, Term a b) -> Term a b -> Bool;
boundstype_fun Roof = roof;
boundstype_fun Match = matcha;

iteratei_set_op_list_it_rs_ops ::
  forall a b.
    (Linorder a) => Rbt a () -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_set_op_list_it_rs_ops s =
  (\ c f -> rm_iterateoi (impl_of s) c (f . fst));

rs_subset :: forall a. (Compare_order a) => Rbt a () -> Rbt a () -> Maybe a;
rs_subset asa bs =
  iteratei_set_op_list_it_rs_ops asa
    (\ a -> (case a of {
              Nothing -> True;
              Just _ -> False;
            }))
    (\ a _ -> (if memb_rm_basic_ops a bs then Nothing else Just a)) Nothing;

rel_checker ::
  forall a.
    (Compare_order a, Eq a) => Ta_relation a -> Rbt a () -> Rbt a () -> Maybe a;
rel_checker (Some_Relation rel) =
  (\ lhs rhs ->
    let {
      rlist = g_to_list_dflt_basic_oops_rm_basic_ops rhs;
    } in (case catch_errora
                 (forallM
                   (\ l -> check (any (\ r -> membera rel (l, r)) rlist) l)
                   (g_to_list_dflt_basic_oops_rm_basic_ops lhs))
                 (\ x -> Inl (snd x))
           of {
           Inl a -> Just a;
           Inr _ -> Nothing;
         }));
rel_checker Id_Relation = rs_subset;
rel_checker Decision_Proc = rs_subset;

check_det ::
  forall a b.
    (Eq a,
      Eq b) => Tree_automaton a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_det (Tree_Automaton fin rules eps) =
  catch_errora
    (bindb
      (check (null eps)
        (shows_prec_list Zero_nat "epsilon transitions not allowed"))
      (\ _ ->
        check (distinct (map (\ (TA_rule f qs _) -> (f, qs)) (remdups rules)))
          (shows_prec_list Zero_nat "some lhs occurs twice")))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "problem when ensuring determinism of automata" .
            shows_nl . x));

check_bounds_generic ::
  forall a b c.
    (Compare_order a, Eq a, Showa a, Card_UNIV b, Cenum b, Ceq b, Ccompare b,
      Compare_order b, Eq b, Set_impl b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c,
      Showa c) => Bounds_info a b ->
                    [(Term a c, Term a c)] ->
                      [(Term a c, Term a c)] ->
                        [(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_bounds_generic (Bounds_Info typea c qfin preTA rel) r s f g =
  let {
    c_opt = construct_c_opt c r;
    rs = r ++ s;
  } in bindb (generate_ta_cond preTA rel)
         (\ ta ->
           let {
             rell = rel_checker rel;
           } in bindb (check_wf_trs rs)
                  (\ _ ->
                    bindb (check
                            (less_eq_set (set qfin)
                              (alpha_rm_basic_ops (ta_final_impl ta)))
                            (shows_prec_list Zero_nat
                              "explicitly mentioned final states must be final"))
                      (\ _ ->
                        bindb (if isOK (check_left_linear_trs rs) then Inr ()
                                else bindb (catch_errora (check_det preTA)
     (\ x ->
       Inl (shows_prec_list Zero_nat
              "for non left-linear TRS we require det. automaton" .
             shows_nl . x)))
                                       (\ _ ->
 bindb (relation_as_list rel) (check_state_raise_consistent preTA)))
                          (\ _ ->
                            bindb (bounds_condition typea rs)
                              (\ _ ->
                                bindb (check_ta_bounded ta c)
                                  (\ _ ->
                                    bindb (check
    (any (\ q -> memb_rm_basic_ops q (ta_rhs_states_set ta)) qfin)
    (shows_prec_list Zero_nat "did not find mentioned final state in TA"))
                                      (\ _ ->
bindb (catch_errora
        (ta_contains_impl (map (\ (fa, a) -> (lift Zero_nat fa, a)) f)
          (map (\ (fa, a) -> (lift Zero_nat fa, a)) g) ta qfin)
        (\ x ->
          Inl (shows_prec_list Zero_nat
                 "it could not be guaranteed that lift0(T(Sigma)) is accepted by TA" .
                shows_nl .
                  shows_prec_list Zero_nat "there is no transition from " .
                    shows_prec_term Zero_nat x .
                      shows_prec_list Zero_nat " to a final state")))
  (\ _ ->
    bindb (catch_errora
            (state_compatible_eff_list ta rell
              (cover_bound_list_filter
                (\ l -> not (rule_state_compatible_heuristic ta l))
                (boundstype_fun typea) Strict_TRS c r))
            (\ x ->
              Inl (let {
                     (lr, (lr_rhs, q)) = x;
                   } in shows_prec_list Zero_nat
                          "TA is not compatible with TRS" .
                          shows_nl .
                            shows_prec_list Zero_nat "for rule " .
                              shows_rule (shows_prec_prod Zero_nat)
                                (shows_prec Zero_nat) " -> " lr .
                                shows_nl .
                                  shows_prec_list Zero_nat
                                    "which is instantiated by states to " .
                                    shows_rule (shows_prec_prod Zero_nat)
                                      (shows_prec Zero_nat) " -> " lr_rhs .
                                      shows_nl .
shows_prec_list Zero_nat "the state " .
  shows_prec Zero_nat q .
    shows_prec_list Zero_nat " is only reachable from the lhs" . shows_nl)))
      (\ _ ->
        catch_errora
          (state_compatible_eff_list ta rell
            (cover_bound_list_filter
              (\ l -> not (rule_state_compatible_heuristic ta l)) matcha
              (Weak_TRS c_opt) c s))
          (\ x ->
            Inl (let {
                   (lr, (lr_rhs, q)) = x;
                 } in shows_prec_list Zero_nat
                        "TA is not compatible with relative TRS" .
                        shows_nl .
                          shows_prec_list Zero_nat "for rule " .
                            shows_rule (shows_prec_prod Zero_nat)
                              (shows_prec Zero_nat) " -> " lr .
                              shows_nl .
                                shows_prec_list Zero_nat
                                  "which is instantiated by states to " .
                                  shows_rule (shows_prec_prod Zero_nat)
                                    (shows_prec Zero_nat) " -> " lr_rhs .
                                    shows_nl .
                                      shows_prec_list Zero_nat "the state " .
shows_prec Zero_nat q .
  shows_prec_list Zero_nat " is only reachable from the lhs" .
    shows_nl)))))))))));

bounds_tt ::
  forall a b c d.
    (Compare_order b, Eq b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showa c,
      Card_UNIV d, Cenum d, Ceq d, Ccompare d, Compare_order d, Eq d,
      Set_impl d,
      Showa d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_tt i info tp =
  let {
    r = rulesc i tp;
    f = funas_trs_list r;
  } in check_bounds_generic info r [] f f;

check_trs_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_termination_proof_main j ia assms i tp R_is_Empty =
  debug (i []) "R is empty"
    (if null (rb j tp) then Inr ()
      else Inl (i . shows_string
                      ": R is not empty in the following termination-problem " .
                      shows_nl .
                        shows_tp (shows_prec_lab Zero_nat)
                          (shows_prec_list Zero_nat) j tp));
check_trs_termination_proof_main j ia assms i tp (Rule_Removal redp rR prf) =
  debug (i []) "Rule Removal"
    (let {
       r = rulesc j tp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora (rule_removal_tt j (get_redtriple redp) rr tp)
                  (\ x ->
                    Inl (i . shows_string
                               ": error when applying the rule removal technique on " .
                               shows_nl .
                                 shows_tp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) j tp .
                                   shows_nl .
                                     shows_string " to remove the rules " .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) " -> " rr .
   shows_nl . x)))
            (\ tpa ->
              catch_errora
                (check_trs_termination_proof_main j ia assms
                  (i . shows_string ".1") tpa prf)
                (\ x ->
                  Inl (i . shows_string
                             ": error below the rule removal technique" .
                             shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (DP_Trans nfs m p prf) =
  debug (i []) "DP trans"
    (bindb
      (catch_errora (dependency_pairs_tt j ia tp nfs m Sharp p)
        (\ x ->
          Inl (i . shows_string ": error when switching from the TRS" .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl .
                           shows_string
                             "to the initial DP problem with pairs " .
                             shows_nl .
                               shows_rules (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) " -> " p .
                                 shows_nl . x)))
      (\ dpp ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dpp prf)
          (\ x ->
            Inl (i . shows_string ": error below switch to dependency pairs" .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (String_Reversal prf) =
  debug (i []) "String Reversal"
    (bindb
      (catch_errora (string_reversal_tt j tp)
        (\ x ->
          Inl (i . shows_string ": error when applying string reversal on " .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (i . shows_string ".1")
            tpa prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the string reversal technique" .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Constant_String p prf) =
  debug (i []) "Constant to Unary"
    (bindb
      (catch_errora (const_to_string_sound_tt p j tp)
        (\ x ->
          Inl (i . shows_string
                     ": error when turning constants into unary symbols on " .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (i . shows_string ".1")
            tpa prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the constant to unary technique" .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Semlab sli lQ lAll prf) =
  debug (i []) "Semlab"
    (bindb
      (catch_errora (semlab_fin_tt j sli lQ lAll tp)
        (\ x ->
          Inl (i . shows_string ": error when applying semantic labelling on " .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (i . shows_string ".1")
            tpa prf)
          (\ x ->
            Inl (i . shows_string ": error below the sem.lab technique" .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Bounds info) =
  debug (i []) "Bounds"
    (catch_errora (bounds_tt j info tp)
      (\ x ->
        Inl (i . shows_string
                   ": error when applying bounds on the termination problem " .
                   shows_nl .
                     shows_tp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) j tp .
                       shows_nl . x)));
check_trs_termination_proof_main j ia assms i tp (Uncurry u_info rR prf) =
  debug (i []) "Uncurry"
    (bindb
      (catch_errora (uncurry_tt j u_info rR tp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying currying transformation" .
                     shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (i . shows_string ".1")
            tpa prf)
          (\ x ->
            Inl (i . shows_string ": error below the uncurrying technique" .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Fcc fcs r prf) =
  debug (i []) "Fcc"
    (bindb
      (catch_errora (fcc_tt j fcs r tp)
        (\ x ->
          Inl (i . shows_string ": error when applying flat context closure" .
                     shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (i . shows_string ".1")
            tpa prf)
          (\ x ->
            Inl (i . shows_string ": error below flat context closure" .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Split rrem prf1 prf2) =
  debug (i []) "Split"
    (let {
       (tp1, tp2) = split_tt j tp rrem;
     } in bindb (catch_errora
                  (check_trs_termination_proof_main j ia assms
                    (i . shows_string ".1") tp1 prf1)
                  (\ x ->
                    Inl (i . shows_string ": error below the splitting" .
                               shows_nl . indent x)))
            (\ _ ->
              catch_errora
                (check_trs_termination_proof_main j ia assms
                  (i . shows_string ".2") tp2 prf2)
                (\ x ->
                  Inl (i . shows_string ": error below the splitting" .
                             shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Switch_Innermost joins prf) =
  debug (i []) "Switch Innermost"
    (bindb
      (catch_errora (switch_innermost_tt j joins tp)
        (\ x ->
          Inl (i . shows_string ": error when switching to innermost on " .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (i . shows_string ".1")
            tpa prf)
          (\ x ->
            Inl (i . shows_string ": error below the switch to innermost" .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Drop_Equality prf) =
  debug (i []) "Drop Equality"
    (let {
       tpa = mkb j (nfsb j tp) (qb j tp) (rb j tp)
               (filter (\ (l, r) -> not (equal_term l r)) (rwb j tp));
     } in catch_errora
            (check_trs_termination_proof_main j ia assms (i . shows_string ".1")
              tpa prf)
            (\ x ->
              Inl (i . shows_string ": error below dropping equality rules" .
                         shows_nl . indent x)));
check_trs_termination_proof_main j ia assms i tp
  (Remove_Nonapplicable_Rules r prf) =
  debug (i []) "Removing non-applicable rules"
    (let {
       _ = rb j tp;
     } in bindb (catch_errora (check_non_applicable_rules (is_QNFb j tp) r)
                  (\ x ->
                    Inl (i . shows_string
                               ": error when removing non-applicable rules" .
                               shows_nl .
                                 indent
                                   (shows_rule (shows_prec_lab Zero_nat)
                                      (shows_prec_list Zero_nat) " -> " x .
                                     shows_prec_list Zero_nat
                                       " is applicable"))))
            (\ _ ->
              let {
                tpa = delete_R_Rwb j tp r r;
              } in catch_errora
                     (check_trs_termination_proof_main j ia assms
                       (i . shows_string ".1") tpa prf)
                     (\ x ->
                       Inl (i . shows_string
                                  ": error below the non-applicable rules removal" .
                                  shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Permuting_AFS pi prf) =
  debug (i []) "Permuting some rules"
    (bindb
      (catch_errora (argument_filter_tt j pi tp)
        (\ x ->
          Inl (i . shows_string ": error when permuting arguments on " .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_termination_proof_main j ia assms (i . shows_string ".1")
            tpa prf)
          (\ x ->
            Inl (i . shows_string ": error below the permutation of arguments" .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tpa (Assume_SN tp ass) =
  debug (i []) "Termination Assumption or Unknown Proof"
    (if assms
      then bindb (catch_errora (check_tp_subsumes j tp tpa)
                   (\ x ->
                     Inl (i . shows_string
                                ": error in termination assumption or unknown proof" .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      ": the proof contains a termination assumption or unknown proof" .
                      shows_nl));

check_fptrs_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b [Nat]) [Prelude.Char],
                              (Term (Lab b [Nat]) [Prelude.Char], Location))],
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])]) ->
                            Fptrs_termination_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fptrs_termination_proof_main j ia assms i tpa (Assume_FP_SN tp ass) =
  debug (i []) "Outermost Termination Assumption or Unknown Proof"
    (if assms
      then bindb (check (tpa == tp)
                   (shows_prec_list Zero_nat
                     "outermost assumption does not match current goal"))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      ": the proof contains a termination assumption or unknown proof" .
                      shows_nl));

check_dp_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          c -> Dp_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_termination_proof_main j ia assms i dpp P_is_Empty =
  debug (i []) "P is empty"
    (if null (pa ia dpp) && (null (pwa ia dpp) || null (rc ia dpp)) then Inr ()
      else Inl (i . shows_string
                      ": P is not empty in the following DP-problem " .
                      shows_nl .
                        shows_dpp (shows_prec_lab Zero_nat)
                          (shows_prec_list Zero_nat) ia dpp));
check_dp_termination_proof_main j ia assms i dpp
  (Subterm_Criterion_Proc p rseq rP prf) =
  debug (i []) "Subterm_Criterion_Proc"
    (let {
       pa = pairsa ia dpp;
       pr = ceta_list_diff pa rP;
     } in bindb (catch_errora (subterm_criterion_proc ia p rseq pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               ": error when applying the subterm criterion to the DP problem" .
                               shows_nl .
                                 shows_dpp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       "and trying to remove the pairs " .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) " -> " pr .
   shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ".1") dppa prf)
                (\ x ->
                  Inl (i . shows_string ": error below the subterm criterion" .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Redpair_Proc redp rP prf) =
  debug (i []) "Redpair_Proc"
    (let {
       p = pairsa ia dpp;
       pr = ceta_list_diff p rP;
       proc =
         (case redp of {
           Inl rrp ->
             generic_ur_af_root_redtriple_proc ia (get_root_redtriple rrp)
               Nothing;
           Inr rp -> generic_ur_af_redtriple_proc ia (get_redtriple rp) Nothing;
         });
     } in bindb (catch_errora (proc pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               ": error when applying the reduction pair processor to remove from the DP problem" .
                               shows_nl .
                                 shows_dpp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string " the pairs " .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) " -> " pr .
   shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ".1") dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             ": error below the reduction pair processor" .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Usable_Rules_Proc u prf) =
  debug (i []) "Usable_Rules_Proc"
    (bindb
      (catch_errora (usable_rules_proc ia u dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the usable rules processor to restrict the DP problem" .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl .
                           shows_string " to the usable rules " .
                             shows_nl .
                               shows_rules (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) " -> " u .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dppa prf)
          (\ x ->
            Inl (i . shows_string ": error below the usable rules processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Q_Reduction_Proc q prf) =
  debug (i []) "Q_Reduction_Proc"
    (bindb
      (catch_errora (q_reduction_proc ia q dpp)
        (\ x ->
          Inl (i . shows_prec_list Zero_nat
                     ": error when applying the Q-reduction processor" .
                     shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dppa prf)
          (\ x ->
            Inl (i . shows_string ": error below the Q-reduction processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_Redpair_Proc redp rP rR prf) =
  debug (i []) "Mono_Redpair_Proc"
    (let {
       p = pairsa ia dpp;
       pr = ceta_list_diff p rP;
       r = rulesd ia dpp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora
                  (mono_redpair_proc ia (get_redtriple redp) pr rr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               ": error when applying the mono reduction pair processor to remove from the DP problem" .
                               shows_nl .
                                 shows_dpp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string " the pairs " .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) " -> " pr .
   shows_nl .
     shows_string " and the rules " .
       shows_nl .
         shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) " -> "
           rr .
           shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ".1") dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             ": error below the mono reduction pair processor" .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_URM_Redpair_Proc redp pr rr prf) =
  debug (i []) "Mono_URM_Redpair_Proc"
    (bindb
      (catch_errora (mono_urm_redpair_proc ia (get_redtriple redp) pr rr dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the mono reduction pair processor with usable repl. map to remove from the DP problem" .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl .
                           shows_string " the pairs " .
                             shows_nl .
                               shows_rules (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) " -> " pr .
                                 shows_nl .
                                   shows_string " and the rules " .
                                     shows_nl .
                                       shows_rules (shows_prec_lab Zero_nat)
 (shows_prec_list Zero_nat) " -> " rr .
 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dppa prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the mono reduction pair processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Dep_Graph_Proc edpts) =
  debug (i []) "Dep_Graph_Proc"
    (bindb
      (catch_errora (dep_graph_proc ia dpp edpts)
        (\ x ->
          Inl (i . shows_string
                     ": error while trying to perform SCC-decomposition  on " .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl . x)))
      (\ pdpps ->
        catch_errora
          (catch_errora
            (forallM_index
              (\ (prof, dppa) ja ->
                check_dp_termination_proof_main j ia assms
                  (i . shows_string "." .
                         shows_prec_nat Zero_nat (plus_nat ja (Nat_of_num One)))
                  dppa prof)
              pdpps)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (i . shows_string
                       ": error below the dependency graph processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Redpair_UR_Proc redp rP ur prf) =
  debug (i []) "Redpair_UR_Proc"
    (let {
       p = pairsa ia dpp;
       pr = ceta_list_diff p rP;
       proc =
         (case redp of {
           Inl rrp ->
             generic_ur_af_root_redtriple_proc ia (get_root_redtriple rrp)
               (Just ur);
           Inr rp ->
             generic_ur_af_redtriple_proc ia (get_redtriple rp) (Just ur);
         });
     } in bindb (catch_errora (proc pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               ": error when applying the reduction pair processor with usable rules to remove from the DP problem" .
                               shows_nl .
                                 shows_dpp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string " the pairs " .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) " -> " pr .
   shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ".1") dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             ": error below the reduction pair processor" .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_Redpair_UR_Proc redp rP rR ur prf) =
  debug (i []) "Mono_Redpair_UR_Proc"
    (let {
       p = pairsa ia dpp;
       pr = ceta_list_diff p rP;
       r = rulesd ia dpp;
       rr = ceta_list_diff r rR;
     } in bindb (catch_errora
                  (generic_mono_ur_redpair_proc ia (get_redtriple redp) pr rr ur
                    dpp)
                  (\ x ->
                    Inl (i . shows_string
                               ": error when applying the mono reduction pair processor with usable rules to remove from the DP problem" .
                               shows_nl .
                                 shows_dpp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string " the pairs " .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) " -> " pr .
   shows_nl .
     shows_string " and the rules " .
       shows_nl .
         shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) " -> "
           rr .
           shows_nl . x)))
            (\ dppa ->
              catch_errora
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ".1") dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             ": error below the mono reduction pair processor with usable rules" .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Uncurry_Proc mode u_info p r prf) =
  debug (i []) "Uncurry_Proc"
    (bindb
      (catch_errora (uncurry_proc_both ia mode u_info p r dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the uncurrying processor on the DP problem" .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dppa prf)
          (\ x ->
            Inl (i . shows_string ": error below the uncurrying processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Size_Change_Subterm_Proc graphs) =
  debug (i []) "Size_Change_Subterm_Proc"
    (catch_errora (sct_subterm_proc ia graphs dpp)
      (\ x ->
        Inl (i . shows_string
                   ": error when applying the size-change (subterm) processor on the DP problem" .
                   shows_nl .
                     shows_dpp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) ia dpp .
                       shows_nl . x)));
check_dp_termination_proof_main j ia assms i dpp
  (Size_Change_Redpair_Proc redp u_opt graphs) =
  debug (i []) "Size_Change_Redpair_Proc"
    (catch_errora (sct_ur_af_proc ia (get_redtriple redp) graphs u_opt dpp)
      (\ x ->
        Inl (i . shows_string
                   ": error when applying the size-change (redpair) processor on the DP problem" .
                   shows_nl .
                     shows_dpp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) ia dpp .
                       shows_nl . x)));
check_dp_termination_proof_main j ia assms i dpp (Fcc_Proc f fcs pb r prf) =
  debug (i []) "Fcc_Proc"
    (bindb
      (catch_errora (fcc_proc ia f fcs pb r dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the flat context closure processor on the DP problem" .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dppa prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the flat context closure processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Split_Proc prem rrem prf1 prf2) =
  debug (i []) "Split_Proc"
    (case get_fcc_option prf1 of {
      Nothing ->
        let {
          (dpp1, dpp2) = split_proc ia dpp prem rrem;
        } in bindb (catch_errora
                     (check_dp_termination_proof_main j ia assms
                       (i . shows_string ".1") dpp1 prf1)
                     (\ x ->
                       Inl (i . shows_string
                                  ": error below the split processor" .
                                  shows_nl . indent x)))
               (\ _ ->
                 catch_errora
                   (check_dp_termination_proof_main j ia assms
                     (i . shows_string ".2") dpp2 prf2)
                   (\ x ->
                     Inl (i . shows_string ": error below the split processor" .
                                shows_nl . indent x)));
      Just (f, (fcs, (pb, (rb, prf1a)))) ->
        debug (i []) "Split_ProcFcc"
          (bindb (fcc_split_proc ia f fcs pb rb prem rrem dpp)
            (\ (dpp1, dpp2) ->
              bindb (catch_errora
                      (check_dp_termination_proof_main j ia assms
                        (i . shows_string ".1.1") dpp1 prf1a)
                      (\ x ->
                        Inl (i . shows_string
                                   ": error below the split and fcc processor" .
                                   shows_nl . indent x)))
                (\ _ ->
                  catch_errora
                    (check_dp_termination_proof_main j ia assms
                      (i . shows_string ".2") dpp2 prf2)
                    (\ x ->
                      Inl (i . shows_string
                                 ": error below the split processor" .
                                 shows_nl . indent x)))));
    });
check_dp_termination_proof_main j ia assms i dpp (Semlab_Proc sli lP lQ lR prf)
  = debug (i []) "Semlab_Proc"
      (bindb
        (catch_errora (semlab_fin_proc ia sli lP lQ lR dpp)
          (\ x ->
            Inl (i . shows_string
                       ": error when applying the semlab processor on the DP problem" .
                       shows_nl .
                         shows_dpp (shows_prec_lab Zero_nat)
                           (shows_prec_list Zero_nat) ia dpp .
                           shows_nl . x)))
        (\ dppa ->
          catch_errora
            (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
              dppa prf)
            (\ x ->
              Inl (i . shows_string ": error below the semlab processor" .
                         shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Switch_Innermost_Proc joins prf) =
  debug (i []) "Switch_Innermost_Proc"
    (bindb
      (catch_errora (switch_innermost_proc ia joins dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the processor to switch to innermost on the DP problem" .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dppa prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the switch to innermost processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dppa (Assume_Finite dpp ass) =
  debug (i []) "Finiteness Assumption or Unknown Proof"
    (if assms
      then bindb (catch_errora (check_dpp_subsumes ia dpp dppa)
                   (\ x ->
                     Inl (i . shows_string
                                ": error in finiteness assumption or unknown proof" .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assma j ia
                         (check_trs_termination_proof_main j ia assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_dp_termination_proof_main j ia assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_fptrs_termination_proof_main j ia assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_unknown_proof_main j ia assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string ": error below unknown proof" .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      ": the proof contains a finiteness assumption or unknown proof" .
                      shows_nl));
check_dp_termination_proof_main j ia assms i dpp
  (Rewriting_Proc u_opt stb sta st lr p prf) =
  debug (i []) "Rewriting_Proc"
    (bindb
      (catch_errora (rewriting_proc ia u_opt stb sta st lr p dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the rewriting processor to rewrite the pair " .
                     shows_nl .
                       shows_rule (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) " -> " stb .
                         shows_nl .
                           shows_string " to the pair " .
                             shows_nl .
                               shows_rule (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) " -> " st .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dppa prf)
          (\ x ->
            Inl (i . shows_string ": error below the rewriting processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Narrowing_Proc st p sts prf) =
  debug (i []) "Narrowing_Proc"
    (bindb
      (catch_errora (narrowing_proc ia st p sts dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the narrowing processor to narrow the pair " .
                     shows_nl .
                       shows_rule (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) " -> " st .
                         shows_nl .
                           shows_string " to the pairs " .
                             shows_nl .
                               shows_trs (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) "rewrite system:"
                                 " -> " sts .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dppa prf)
          (\ x ->
            Inl (i . shows_string ": error below the narrowing processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Instantiation_Proc st sts prf)
  = debug (i []) "Instantiation_Proc"
      (bindb
        (catch_errora (instantiation_proc ia st sts dpp)
          (\ x ->
            Inl (i . shows_string
                       ": error when applying the instantiation processor to instantiate the pair " .
                       shows_nl .
                         shows_rule (shows_prec_lab Zero_nat)
                           (shows_prec_list Zero_nat) " -> " st .
                           shows_nl .
                             shows_string " to the pairs " .
                               shows_nl .
                                 shows_trs (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) "rewrite system:"
                                   " -> " sts .
                                   shows_nl . x)))
        (\ dppa ->
          catch_errora
            (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
              dppa prf)
            (\ x ->
              Inl (i . shows_string
                         ": error below the instantiation processor" .
                         shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Forward_Instantiation_Proc st sts u_opt prf) =
  debug (i []) "Forward_Instantiation_Proc"
    (bindb
      (catch_errora (forward_instantiation_proc ia st sts u_opt dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the forward_instantiation processor to instantiate the pair " .
                     shows_nl .
                       shows_rule (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) " -> " st .
                         shows_nl .
                           shows_string " to the pairs " .
                             shows_nl .
                               shows_trs (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) "rewrite system:"
                                 " -> " sts .
                                 shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dppa prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the forward instantiation processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Unlab_Proc p r prf) =
  debug (i []) "Unlab_Proc"
    (Inl (shows_prec_list Zero_nat "unlabeling processor not supported"));
check_dp_termination_proof_main j ia assms i dpp
  (General_Redpair_Proc rp ps pb prof prfs) =
  debug (i []) "General_Redpair_ProcProc"
    (let {
       n = size_list prfs;
     } in bindb (check (less_nat Zero_nat n)
                  (shows_prec_list Zero_nat
                    "at least one subproof is required"))
            (\ _ ->
              let {
                merge = equal_nat n (Nat_of_num One);
              } in bindb (catch_errora
                           (conditional_general_reduction_pair_proc ia
                             (get_non_inf_order rp) ps pb prof merge dpp)
                           (\ x ->
                             Inl (i . shows_string
": error when applying the generic reduction pair processor to the DP problem" .
shows_nl .
  shows_dpp (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) ia dpp .
    shows_nl . x)))
                     (\ dpps ->
                       bindb (catch_errora
                               (check_dp_termination_proof_main j ia assms
                                 (i . shows_string ".1") (nth dpps Zero_nat)
                                 (nth prfs Zero_nat))
                               (\ x ->
                                 Inl (i . shows_string
    ": error below the generic reduction pair processor" .
    shows_nl . indent x)))
                         (\ _ ->
                           (if merge then Inr ()
                             else catch_errora
                                    (check_dp_termination_proof_main j ia assms
                                      (i . shows_string ".2")
                                      (nth dpps (Nat_of_num One))
                                      (nth prfs (Nat_of_num One)))
                                    (\ x ->
                                      Inl
(i . shows_string ": error below the generic reduction pair processor" .
       shows_nl . indent x)))))));
check_dp_termination_proof_main j ia assms i dpp
  (Complex_Constant_Removal_Proc p prf) =
  debug (i []) "Complex_Constant_Removal_Proc"
    (bindb
      (catch_errora (complex_constant_removal_proc ia p dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the complex constant removal processor to the DP problem" .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_termination_proof_main j ia assms (i . shows_string ".1")
            dppa prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the complex constant removal processor" .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (To_Trs_Proc prf) =
  debug (i []) "To_Trs_Proc"
    (catch_errora
      (check_trs_termination_proof_main j ia assms (i . shows_string ".1")
        (mk_tp j
          (nfsc ia dpp,
            (qc ia dpp, (pa ia dpp ++ rc ia dpp, pwa ia dpp ++ rwc ia dpp))))
        prf)
      (\ x ->
        Inl (i . shows_string ": error below the To-Trs processor" .
                   shows_nl . indent x)));

check_unknown_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Unknown_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_proof_main j ia assms i tpa (Assume_Unknown tp ass) =
  debug (i []) "Unknown Proof"
    (if assms
      then bindb (catch_errora
                   (check (tpa == tp)
                     (shows_prec_list Zero_nat
                        "unknown problems are not identical: " .
                       shows_nl .
                         shows_prec_list Zero_nat tpa .
                           shows_nl .
                             shows_prec_list Zero_nat " vs " .
                               shows_nl . shows_prec_list Zero_nat tp))
                   (\ x ->
                     Inl (i . shows_string
                                ": error in termination assumption or unknown proof" .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assma j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string ": the proof contains an unknown proof" .
                      shows_nl));

map_assm_proof ::
  forall a b c d e f g.
    (a -> a) ->
      (b -> b) ->
        (c -> c) ->
          (d -> d) ->
            Generic_assm_proof e f g a b c () d ->
              Generic_assm_proof e f g a b c () d;
map_assm_proof tp dpp fptp unk (SN_assm_proof r p) = SN_assm_proof r (tp p);
map_assm_proof tp dpp fptp unk (Finite_assm_proof d p) =
  Finite_assm_proof d (dpp p);
map_assm_proof tp dpp fptp unk (SN_FP_assm_proof r p) =
  SN_FP_assm_proof r (fptp p);
map_assm_proof tp dpp fptp unk (Unknown_assm_proof u p) =
  Unknown_assm_proof u (unk p);
map_assm_proof tp dpp fptp unk (Not_SN_assm_proof v va) =
  Not_SN_assm_proof v va;
map_assm_proof tp dpp fptp unk (Infinite_assm_proof v va) =
  Infinite_assm_proof v va;
map_assm_proof tp dpp fptp unk (Not_RelSN_assm_proof v va) =
  Not_RelSN_assm_proof v va;
map_assm_proof tp dpp fptp unk (Not_SN_FP_assm_proof v va) =
  Not_SN_FP_assm_proof v va;
map_assm_proof tp dpp fptp unk (Complexity_assm_proof v va) =
  Complexity_assm_proof v va;

no_decr ::
  forall a b c.
    (Eq a, Eq b,
      Eq c) => [(Term (Lab a b) c, Term (Lab a b) c)] ->
                 [(Term (Lab a b) c, Term (Lab a b) c)];
no_decr =
  filter
    (\ (l, r) ->
      not (not (equal_term l r) &&
            equal_term (map_term unlab (\ x -> x) l)
              (map_term unlab (\ x -> x) r)));

unlab_of_trs ::
  forall a b c.
    (Eq a, Eq b,
      Eq c) => [(Term (Lab a b) c, Term (Lab a b) c)] ->
                 [(Term (Lab a b) c, Term (Lab a b) c)];
unlab_of_trs r = map (map_funs_rule unlab) (no_decr r);

updatec :: forall a b c. (a -> b) -> (a, c) -> (b, c);
updatec p_to_p (p, info) = (p_to_p p, info);

unlab_to_split_trs ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Trs_termination_proof a b c -> Trs_termination_proof a b c;
unlab_to_split_trs (DP_Trans a1 a2 a3 p) =
  DP_Trans a1 a2 a3 (fst (unlab_to_split_dp p));
unlab_to_split_trs (Rule_Removal a1 a2 p) =
  Rule_Removal a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (String_Reversal p) = String_Reversal (unlab_to_split_trs p);
unlab_to_split_trs (Constant_String a1 p) =
  Constant_String a1 (unlab_to_split_trs p);
unlab_to_split_trs (Bounds a) = Bounds a;
unlab_to_split_trs (Uncurry a1 a2 p) = Uncurry a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (Semlab a1 a2 a3 p) = Semlab a1 a2 a3 (unlab_to_split_trs p);
unlab_to_split_trs R_is_Empty = R_is_Empty;
unlab_to_split_trs (Fcc a1 a2 p) = Fcc a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (Split a1 p q) =
  Split a1 (unlab_to_split_trs p) (unlab_to_split_trs q);
unlab_to_split_trs (Switch_Innermost a1 p) =
  Switch_Innermost a1 (unlab_to_split_trs p);
unlab_to_split_trs (Drop_Equality p) = Drop_Equality (unlab_to_split_trs p);
unlab_to_split_trs (Remove_Nonapplicable_Rules a1 p) =
  Remove_Nonapplicable_Rules a1 (unlab_to_split_trs p);
unlab_to_split_trs (Permuting_AFS a1 p) =
  Permuting_AFS a1 (unlab_to_split_trs p);
unlab_to_split_trs (Assume_SN a p) =
  Assume_SN a
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_unknown ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Unknown_proof a b c -> Unknown_proof a b c;
unlab_to_split_unknown (Assume_Unknown a1 p) =
  Assume_Unknown a1
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_otrs ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Fptrs_termination_proof a b c -> Fptrs_termination_proof a b c;
unlab_to_split_otrs (Assume_FP_SN a p) =
  Assume_FP_SN a
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_dp ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Dp_termination_proof a b c ->
                  (Dp_termination_proof a b c,
                    [([(Term (Lab a b) c, Term (Lab a b) c)],
                       ([(Term (Lab a b) c, Term (Lab a b) c)],
                         Dp_termination_proof a b c))]);
unlab_to_split_dp P_is_Empty = (P_is_Empty, []);
unlab_to_split_dp (Dep_Graph_Proc ps) =
  (Dep_Graph_Proc
     (map (\ (po, a) -> (map_option (fst . unlab_to_split_dp) po, a)) ps),
    []);
unlab_to_split_dp (Subterm_Criterion_Proc a1 a2 a3 p) =
  updatec (Subterm_Criterion_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Redpair_Proc a1 a2 p) =
  updatec (Redpair_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Redpair_UR_Proc a1 a2 a3 p) =
  updatec (Redpair_UR_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Usable_Rules_Proc a1 p) =
  updatec (Usable_Rules_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Q_Reduction_Proc a1 p) =
  updatec (Q_Reduction_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_Redpair_Proc a1 a2 a3 p) =
  updatec (Mono_Redpair_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_URM_Redpair_Proc a1 a2 a3 p) =
  updatec (Mono_URM_Redpair_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_Redpair_UR_Proc a1 a2 a3 a4 p) =
  updatec (Mono_Redpair_UR_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Size_Change_Subterm_Proc a1) =
  (Size_Change_Subterm_Proc a1, []);
unlab_to_split_dp (Size_Change_Redpair_Proc a1 a2 a3) =
  (Size_Change_Redpair_Proc a1 a2 a3, []);
unlab_to_split_dp (Uncurry_Proc a1 a2 a3 a4 p) =
  updatec (Uncurry_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Fcc_Proc a1 a2 a3 a4 p) =
  updatec (Fcc_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Switch_Innermost_Proc a1 p) =
  updatec (Switch_Innermost_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Rewriting_Proc a1 a2 a3 a4 a5 a6 p) =
  updatec (Rewriting_Proc a1 a2 a3 a4 a5 a6) (unlab_to_split_dp p);
unlab_to_split_dp (Narrowing_Proc a1 a2 a3 p) =
  updatec (Narrowing_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Instantiation_Proc a1 a2 p) =
  updatec (Instantiation_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Forward_Instantiation_Proc a1 a2 a3 p) =
  updatec (Forward_Instantiation_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Assume_Finite d p) =
  (Assume_Finite d
     (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
            unlab_to_split_otrs unlab_to_split_unknown)
       p),
    []);
unlab_to_split_dp (To_Trs_Proc p) = (To_Trs_Proc (unlab_to_split_trs p), []);
unlab_to_split_dp (Unlab_Proc pa r p) =
  let {
    (pb, list) = unlab_to_split_dp p;
  } in (P_is_Empty, (pa, (r, pb)) : list);
unlab_to_split_dp (Split_Proc a1 a2 p q) =
  (Split_Proc a1 a2 (fst (unlab_to_split_dp p)) (fst (unlab_to_split_dp q)),
    []);
unlab_to_split_dp (Semlab_Proc a1 lP a2 lR p) =
  let {
    (pa, list) = unlab_to_split_dp p;
    sl = Semlab_Proc a1 lP a2 lR pa;
  } in (case list of {
         [] -> (sl, list);
         (pb, (r, prof)) : lista ->
           let {
             ulP = unlab_of_trs lP;
             ulR = unlab_of_trs lR;
             pr = ceta_list_diff ulP pb;
             rr = ceta_list_diff ulR r;
           } in (Split_Proc pr rr sl prof, lista);
       });
unlab_to_split_dp (General_Redpair_Proc a1 a2 a3 a4 ps) =
  (General_Redpair_Proc a1 a2 a3 a4 ps, []);
unlab_to_split_dp (Complex_Constant_Removal_Proc a1 p) =
  updatec (Complex_Constant_Removal_Proc a1) (unlab_to_split_dp p);

check_trs_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_termination_proof ia j a i tp prf =
  check_trs_termination_proof_main ia j a i tp (unlab_to_split_trs prf);

rule_lab_repr_to_lab ::
  forall a b.
    (Key a,
      Key b) => [((Term a b, Term a b), Nat)] -> (Term a b, Term a b) -> Nat;
rule_lab_repr_to_lab ps = fun_of_map (ceta_map_of ps) Zero_nat;

critical_peaks_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Bool,
                     ((Term a [Prelude.Char],
                        ((Term a [Prelude.Char], Term a [Prelude.Char]),
                          (Pos, ([Prelude.Char] -> Term a [Prelude.Char],
                                  Term a [Prelude.Char])))),
                       (Term a [Prelude.Char],
                         ((Term a [Prelude.Char], Term a [Prelude.Char]),
                           (Pos, ([Prelude.Char] -> Term a [Prelude.Char],
                                   Term a [Prelude.Char]))))))];
critical_peaks_impl p r =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ pa ->
          let {
            c = ctxt_of_pos_term pa l;
            la = subt_at l pa;
            b = equal_ctxt c Hole;
          } in (if is_Var la then []
                 else concatMap
                        (\ (lb, rb) ->
                          (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                                  (\ a -> 'y' : a) la lb
                            of {
                            Nothing -> [];
                            Just (sigma, tau) ->
                              [(b, ((subst_apply_term l sigma,
                                      ((l, ra),
(Empty, (sigma, subst_apply_term ra sigma)))),
                                     (subst_apply_term l sigma,
                                       ((lb, rb),
 (pa, (tau, ctxt_apply_term (subst_apply_ctxt c sigma)
              (subst_apply_term rb tau)))))))];
                          }))
                        r))
        (poss_list l))
    p;

check_ELD_1_nat ::
  Nat ->
    Nat -> [Nat] -> [Nat] -> [Nat] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3 =
  bindb (catch_errora
          (forallM
            (\ x ->
              check (less_nat x beta)
                (shows_prec_list Zero_nat " labels are not decreasing"))
            sigma_1)
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ x ->
                  check (less_eq_nat x alpha)
                    (shows_prec_list Zero_nat " labels are not decreasing"))
                sigma_2)
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (check (less_eq_nat (size_list sigma_2) (Nat_of_num One))
                  (shows_prec_list Zero_nat
                    " length of middle sequence is greater 1 "))
            (\ _ ->
              catch_errora
                (forallM
                  (\ x ->
                    check (less_nat x alpha || less_nat x beta)
                      (shows_prec_list Zero_nat " labels are not decreasing"))
                  sigma_3)
                (\ x -> Inl (snd x)))));

rule_labeling ::
  forall a b.
    ((Term a b, Term a b) -> Nat) ->
      (Term a b, ((Term a b, Term a b), (Pos, (b -> Term a b, Term a b)))) ->
        Nat;
rule_labeling i (s, (rl, (p, (sigma, t)))) = i rl;

split_seq :: Nat -> Nat -> [Nat] -> ([Nat], ([Nat], [Nat]));
split_seq alpha beta ss =
  let {
    (ssa, r) = span (\ n -> less_nat n alpha) ss;
  } in (case r of {
         [] -> (ssa, ([], []));
         h : t ->
           (if less_eq_nat h beta then (ssa, ([h], t)) else (ssa, ([], r)));
       });

check_ELD_rule_labeling ::
  forall a b.
    ((Term a b, Term a b) -> Nat) ->
      (Term a b, Term a b) ->
        (Term a b, Term a b) ->
          (Term a b,
            [(Term a b,
               ((Term a b, Term a b), (Pos, (b -> Term a b, Term a b))))]) ->
            (Term a b,
              [(Term a b,
                 ((Term a b, Term a b), (Pos, (b -> Term a b, Term a b))))]) ->
              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ELD_rule_labeling lab r1 r2 j1 j2 =
  let {
    alpha = lab r1;
    beta = lab r2;
    tau = map (rule_labeling lab) (snd j1);
    sigma = map (rule_labeling lab) (snd j2);
    (tau_1, (tau_2, tau_3)) = split_seq alpha beta tau;
    (sigma_1, (sigma_2, sigma_3)) = split_seq beta alpha sigma;
  } in bindb (check_ELD_1_nat alpha beta tau_1 tau_2 tau_3)
         (\ _ -> check_ELD_1_nat beta alpha sigma_1 sigma_2 sigma_3);

check_rstepsa ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), Term a b))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rstepsa r [] s u =
  check (equal_term s u)
    (shows_string "the last term of the rewrite sequence" .
      shows_nl .
        shows_prec_term Zero_nat s .
          shows_nl .
            shows_string "does not correspond to the goal term" .
              shows_nl . shows_prec_term Zero_nat u . shows_nl);
check_rstepsa r ((p, (lr, t)) : rs) s u =
  bindb (check_rstep r p lr s t) (\ _ -> check_rstepsa r rs t u);

rseq_to_step_list ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => Term a b ->
                           [(Pos, ((Term a b, Term a b), Term a b))] ->
                             [(Term a b,
                                ((Term a b, Term a b),
                                  (Pos, (b -> Term a b, Term a b))))];
rseq_to_step_list s [] = [];
rseq_to_step_list s ((p, (lr, t)) : steps) =
  let {
    u = subt_at s p;
    v = subt_at t p;
    sigma =
      let {
        (Just tau) = match_list Var [(fst lr, u), (snd lr, v)];
      } in tau;
  } in (s, (lr, (p, (sigma, t)))) : rseq_to_step_list t steps;

rseq_to_ddseq ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => (Term a b,
                           [(Pos, ((Term a b, Term a b), Term a b))]) ->
                           (Term a b,
                             [(Term a b,
                                ((Term a b, Term a b),
                                  (Pos, (b -> Term a b, Term a b))))]);
rseq_to_ddseq (s, rseq) = (s, rseq_to_step_list s rseq);

check_cpeak_eld ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b,
                       ((Term a b, Term a b),
                         (Pos, (b -> Term a b, Term a b)))),
                      (Term a b,
                        ((Term a b, Term a b),
                          (Pos, (b -> Term a b, Term a b))))) ->
                      (Term a b, Term a b) ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          [(Pos, ((Term a b, Term a b), Term a b))] ->
                            ((Term a b, Term a b) -> Nat) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cpeak_eld r p cp j1 j2 lab =
  let {
    ((_, (r1, (_, (_, t1)))), (_, (r2, (_, (_, t2))))) = p;
  } in bindb (check (instance_rule (t1, t2) cp)
               (shows_prec_list Zero_nat
                 " critical peak and pair do not match "))
         (\ _ ->
           let {
             u = rseq_last (fst cp) j1;
             v = rseq_last (snd cp) j2;
           } in bindb (check_rstepsa r j1 (fst cp) u)
                  (\ _ ->
                    bindb (check_rstepsa r j2 (snd cp) v)
                      (\ _ ->
                        bindb (check (equal_term u v)
                                (shows_prec_list Zero_nat
                                   "the rewrite sequences end in different terms " .
                                  shows_prec_term Zero_nat u .
                                    shows_prec_list Zero_nat " and " .
                                      shows_prec_term Zero_nat v))
                          (\ _ ->
                            check_ELD_rule_labeling lab r1 r2
                              (rseq_to_ddseq (t1, j1))
                              (rseq_to_ddseq (t2, j2))))));

check_rule_labeling_dec ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [((Term a [Prelude.Char], Term a [Prelude.Char]), Nat)] ->
                      [(Term a [Prelude.Char],
                         ([(Pos, ((Term a [Prelude.Char],
                                    Term a [Prelude.Char]),
                                   Term a [Prelude.Char]))],
                           (Term a [Prelude.Char],
                             [(Pos, ((Term a [Prelude.Char],
                                       Term a [Prelude.Char]),
                                      Term a [Prelude.Char]))])))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_labeling_dec r lab js =
  let {
    cps = critical_peaks_impl r r;
    l = rule_lab_repr_to_lab lab;
    joins = js ++ map (\ (u, (j1, (v, j2))) -> (v, (j2, (u, j1)))) js;
  } in catch_errora
         (forallM
           (\ (_, a) ->
             let {
               (aa, b) = a;
             } in let {
                    (s1, (r1, (p1, (sigma_1, t1)))) = aa;
                  } in (\ (s2, (r2, (p2, (sigma_2, t2)))) ->
                         catch_errora
                           (check (equal_term t1 t2)
                             (shows_prec_list Zero_nat " pair non-trivial "))
                           (\ _ ->
                             catch_errora
                               (existsM
                                 (\ (u, (j1, (v, j2))) ->
                                   check_cpeak_eld r
                                     ((s1, (r1, (p1, (sigma_1, t1)))),
                                       (s2, (r2, (p2, (sigma_2, t2)))))
                                     (u, v) j1 j2 l)
                                 joins)
                               (\ _ ->
                                 Inl (shows_rule (shows_prec Zero_nat)
(shows_prec_list Zero_nat) " -> " (t1, t2) .
                                       shows_prec_list Zero_nat
 " could not be joined decreasingly "))))
                    b)
           cps)
         (\ x -> Inl (snd x));

check_estep ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Pos ->
                      (Term a b, Term a b) ->
                        Bool ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_estep e p rule l_to_r s t =
  bindb (check (any (eq_rule_mod_vars rule) e)
          (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " rule .
            shows_string " is not an equation of" .
              shows_nl .
                shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
                  "equational system:" " = " e .
                  shows_nl))
    (\ _ ->
      bindb (check (in_poss p s)
              (shows_prec_pos Zero_nat p .
                shows_string " is not a position of " .
                  shows_prec_term Zero_nat s . shows_nl))
        (\ _ ->
          bindb (check (in_poss p t)
                  (shows_prec_pos Zero_nat p .
                    shows_string " is not a position of " .
                      shows_prec_term Zero_nat t . shows_nl))
            (\ _ ->
              let {
                c = ctxt_of_pos_term p s;
                d = ctxt_of_pos_term p t;
                u = subt_at s p;
                v = subt_at t p;
                rrule = (if l_to_r then rule else (snd rule, fst rule));
                err = shows_string "the term " .
                        shows_prec_term Zero_nat t .
                          shows_string
                            " does not result from a proper application of term " .
                            shows_prec_term Zero_nat s .
                              shows_string " using equation " .
                                shows_nl .
                                  shows_rule (shows_prec Zero_nat)
                                    (shows_prec Zero_nat) " = " rrule .
                                    shows_string " at position " .
                                      shows_prec_pos Zero_nat p . shows_nl;
              } in (case match_list Var [(fst rrule, u), (snd rrule, v)] of {
                     Nothing -> Inl err;
                     Just _ -> check (equal_ctxt c d) err;
                   }))));

check_conversion ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conversion e [] s u =
  check (equal_term s u)
    (shows_string "the last term of the conversion " .
      shows_nl .
        shows_prec_term Zero_nat s .
          shows_nl .
            shows_string "does not correspond to the goal term" .
              shows_nl . shows_prec_term Zero_nat u . shows_nl);
check_conversion e ((p, (r, (l_to_r, t))) : c) s u =
  bindb (check_estep e p r l_to_r s t) (\ _ -> check_conversion e c t u);

check_redundant_rules ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Nat ->
                        [[(Pos, ((Term a b, Term a b), (Bool, Term a b)))]] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_redundant_rules ra r n convs =
  let {
    s = list_diff r ra;
    t = list_diff ra r;
  } in bindb (catch_errora
               (forallM
                 (\ (l, rb) ->
                   check (membera (reachable_terms ra l n) rb)
                     (shows_prec_list Zero_nat "could not simulate rule " .
                       shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                         " -> " (l, rb)))
                 s)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ (l, raa) ->
                 catch_errora
                   (existsM (\ conv -> check_conversion r conv l raa) convs)
                   (\ _ -> check_join_BFS_limit n r l raa))
               t)
             (\ x -> Inl (snd x)));

check_cr_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            Cr_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cr_proof a ia i j r (SN_WCR joins_i prf) =
  debug (ia []) "SN_WCR"
    (let {
       tp = mkb i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a (ia . shows_string ".1") tp
                    prf)
                  (\ x ->
                    Inl (ia . shows_string
                                ": error below strong normalization + wcr" .
                                shows_nl . indent x)))
            (\ _ ->
              catch_errora
                (check_critical_pairs r (critical_pairs_impl r r) joins_i)
                (\ x ->
                  Inl (ia . shows_prec_list Zero_nat
                              "error when proving local confluence of " .
                              shows_tp (shows_prec_lab Zero_nat)
                                (shows_prec_list Zero_nat) i tp .
                                shows_nl . indent x))));
check_cr_proof a ia i j r Weakly_Orthogonal =
  debug (ia []) "Weakly Orthogonal"
    (catch_errora (check_weakly_orthogonal r)
      (\ x ->
        Inl (ia . shows_prec_list Zero_nat
                    ": error in checking weakly orthogonal system for the TRS" .
                    shows_nl .
                      shows_trs (shows_prec_lab Zero_nat)
                        (shows_prec_list Zero_nat) "rewrite system:" " -> " r .
                        indent x)));
check_cr_proof a ia i j r (Strongly_Closed n) =
  debug (ia []) "Strongly Closed"
    (catch_errora (check_strongly_closed r n)
      (\ x ->
        Inl (ia . shows_prec_list Zero_nat
                    ": error in checking strong closedness for the TRS" .
                    shows_nl .
                      shows_trs (shows_prec_lab Zero_nat)
                        (shows_prec_list Zero_nat) "rewrite system:" " -> " r .
                        indent x)));
check_cr_proof a ia i j r (Rule_Labeling rl joins prf) =
  debug (ia []) "Rule Labeling"
    (bindb
      (case prf of {
        Nothing -> check_linear_trs r;
        Just prfa ->
          bindb (check_left_linear_trs r)
            (\ _ ->
              let {
                (rnd, rd) = partition (\ lr -> linear_term (snd lr)) r;
                tp = mkb i False [] rd rnd;
              } in catch_errora
                     (check_trs_termination_proof i j a (ia . shows_string ".1")
                       tp prfa)
                     (\ x ->
                       Inl (ia . shows_string
                                   ": error below relative termination for rule labeling" .
                                   shows_nl . indent x)));
      })
      (\ _ ->
        catch_errora (check_rule_labeling_dec r rl joins)
          (\ x ->
            Inl (ia . shows_prec_list Zero_nat
                        ": error in checking decreasingness of CPs using rule labeling for the TRS" .
                        shows_nl .
                          shows_trs (shows_prec_lab Zero_nat)
                            (shows_prec_list Zero_nat) "rewrite system:" " -> "
                            r .
                            indent x))));
check_cr_proof a ia i j r (Redundant_Rules rs n convs prf) =
  debug (ia []) "Redundant Rules"
    (bindb
      (catch_errora (check_cr_proof a (ia . shows_string ".1") i j rs prf)
        (\ x ->
          Inl (ia . shows_prec_list Zero_nat
                      ": error below confluence of modified TRS" .
                      shows_nl .
                        shows_trs (shows_prec_lab Zero_nat)
                          (shows_prec_list Zero_nat) "rewrite system:" " -> "
                          rs .
                          indent x)))
      (\ _ ->
        catch_errora (check_redundant_rules r rs n convs)
          (\ x ->
            Inl (ia . shows_prec_list Zero_nat
                        ": error in checking redundant rules transformation of the TRS" .
                        shows_nl .
                          shows_trs (shows_prec_lab Zero_nat)
                            (shows_prec_list Zero_nat) "rewrite system:" " -> "
                            r .
                            shows_prec_list Zero_nat "transformed to" .
                              shows_nl .
                                shows_trs (shows_prec_lab Zero_nat)
                                  (shows_prec_list Zero_nat) "rewrite system:"
                                  " -> " rs .
                                  indent x))));

pos_gctxt :: forall a b. (Compare a, Eq a, Compare b) => Gctxt a b -> Set Pos;
pos_gctxt GCHole = inserta Empty (set_empty (of_phantom set_impl_pos));
pos_gctxt (GCFun f cs) =
  sup_set (inserta Empty (set_empty (of_phantom set_impl_pos)))
    (sup_seta
      (image (\ (c, i) -> image (PCons i) (pos_gctxt c))
        (set (zip cs (upt Zero_nat (size_list cs))))));

check_dp_loop ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> Dp_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_loop i dpp (DP_loop_prf s prseq sigma c) =
  let {
    p = pairsa i dpp;
    r = rulesd i dpp;
    nfs = nfsc i dpp;
    q = qc i dpp;
  } in (if equal_ctxt c Hole
         then bindb (check (not (null prseq))
                      (shows_prec_list Zero_nat
                        "rewrite sequence must be non-empty"))
                (\ _ ->
                  (if null q
                    then check_qsteps (\ _ -> True) nfs p r prseq s
                           (subst_apply_term s (mk_subst Var sigma))
                    else check_qsteps_subst (check_NF_iteration sigma q) nfs p r
                           prseq s (subst_apply_term s (mk_subst Var sigma))))
         else check_loop q nfs s (map (\ (x, (y, (_, z))) -> (x, (y, z))) prseq)
                sigma c r);

check_rel_seq ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                        Term a b ->
                          Term a b ->
                            Bool -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_seq r sa [] s u True =
  check (equal_term s u)
    (shows_string "the last term of the rewrite sequence" .
      shows_nl .
        shows_prec_term Zero_nat s .
          shows_string (shows_nl "does not correspond to the goal term") .
            shows_nl . shows_prec_term Zero_nat u . shows_nl);
check_rel_seq r sa [] s u False =
  Inl (shows_prec_list Zero_nat "did not find strict step in rewrite sequence");
check_rel_seq ra sa ((p, (r, (True, t))) : prts) s u b =
  bindb (check_qrstep (\ _ -> True) False ra p r s t)
    (\ _ -> check_rel_seq ra sa prts t u True);
check_rel_seq ra sa ((p, (r, (False, t))) : prts) s u b =
  bindb (check_qrstep (\ _ -> True) False sa p r s t)
    (\ _ -> check_rel_seq ra sa prts t u b);

pat_dv_impl ::
  forall a b.
    (Eq a, Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) -> [b];
pat_dv_impl p =
  let {
    (_, (sigma, mu)) = p;
  } in remdups (map fst (mk_subst_domain sigma ++ mk_subst_domain mu));

shows_exp ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_exp (f, c) =
  shows_prec Zero_nat f .
    shows_prec_list Zero_nat "n+ " . shows_prec Zero_nat c;

shows_p ::
  forall a b c d e.
    (Showa a, Showa b, Showa c, Showa d,
      Showa e) => (a, ((b, (c, d)), e)) -> [Prelude.Char] -> [Prelude.Char];
shows_p (b, ((f, (c, m)), a)) =
  shows_prec Zero_nat b .
    shows_prec Zero_nat m .
      shows_prec_list Zero_nat " ^ (" .
        shows_exp (f, c) . shows_prec_list Zero_nat ")" . shows_prec Zero_nat a;

set_option :: forall a. (Ceq a, Ccompare a, Set_impl a) => Maybe a -> Set a;
set_option Nothing = bot_set;
set_option (Just x2) = inserta x2 bot_set;

enfc_cand ::
  forall a b.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  b -> ([Term a [Prelude.Char]], Term a [Prelude.Char]) ->
                         [([Term a [Prelude.Char]], Term a [Prelude.Char])];
enfc_cand isQnf r q (uu, Var uv) = [];
enfc_cand isQnf r q (s, Fun f ts) =
  map (\ a -> (s, a)) ts ++
    concatMap
      (\ (l, ra) ->
        (if (case mgu_class (Fun f (map (icap_impl isQnf r s) ts)) l of {
              Nothing -> False;
              Just mu ->
                all (\ u ->
                      isQnf (subst_apply_term
                              (map_term (\ x -> x) (\ a -> 'y' : a) u) mu))
                  (args l) &&
                  all (\ u ->
                        isQnf (subst_apply_term
                                (map_term (\ x -> x) (\ a -> 'x' : a) u) mu))
                    s;
            })
          then [(args l, ra)] else []))
      r;

enfc_impl ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                (Term a [Prelude.Char] -> Bool) ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [Term a [Prelude.Char]] ->
                      [Term a [Prelude.Char]] -> Term a [Prelude.Char] -> Bool;
enfc_impl isQnf isRnf r q s t =
  all (\ (a, b) -> enfc_q isQnf isRnf r q a b)
    (mk_rtrancl_list (\ a b -> a == b) (enfc_cand isQnf r q) [(s, t)]);

check_nfc ::
  forall a.
    (Eq a, Key a,
      Showa a) => Bool ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      [Term a [Prelude.Char]] ->
                        (Term a [Prelude.Char] -> Bool) ->
                          [Term a [Prelude.Char]] ->
                            Bool ->
                              Term a [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_nfc inn r q isQnf ss nfs t =
  bindb (check_wf_trs r)
    (\ _ ->
      (if inn then Inr ()
        else catch_errora
               (forallM
                 (\ ta ->
                   check (enfc_impl isQnf (is_NF_trs r) r q ss ta)
                     (shows_prec_list Zero_nat " nfc not satisfied for " .
                       shows_prec_term Zero_nat ta))
                 (supteq_list t))
               (\ x -> Inl (snd x))));

intersect_values ::
  forall a b.
    (Eq a, Compare_order b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
intersect_values key vs m = foldr (aux key m) vs empty;

intersect_rules ::
  forall a b.
    (Compare_order a, Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 Rbt (a, Nat) [(Bool, (Term a b, Term a b))] ->
                   Rbt (a, Nat) [(Bool, (Term a b, Term a b))];
intersect_rules rs =
  intersect_values key
    (map (\ a -> (True, a)) rs ++ map (\ a -> (False, a)) rs);

coherent_rule ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Set (a, a) ->
                 Set (Ta_rule a b) -> Ta_rule a b -> Set (a, Maybe a);
coherent_rule rel rules (TA_rule f qs q) =
  foldr (sup_set .
          (\ i ->
            let {
              qi = nth qs i;
              qi_s = image snd (filtera (\ qq -> fst qq == qi) rel);
              a = sup_seta
                    (image
                      (\ qia ->
                        let {
                          qsa = list_update qs i qia;
                          rls = filtera
                                  (\ (TA_rule g qsaa _) ->
                                    g == f && qsaa == qsa)
                                  rules;
                        } in (if less_eq_set rls
                                   (set_empty (of_phantom set_impl_ta_rule))
                               then inserta Nothing bot_set
                               else image (Just . r_rhs) rls))
                      qi_s);
            } in image (\ aa -> (q, aa)) a))
    (upt Zero_nat (size_list qs)) bot_set;

new_states ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Ta_ext a b () -> Set (a, a) -> Set (a, Maybe a);
new_states ta rel =
  let {
    rules = ta_rules ta;
  } in sup_seta (image (coherent_rule rel rules) rules);

check_wf_reltrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ([(Term a b, Term a b)], [(Term a b, Term a b)]) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_reltrs (r, s) =
  bindb (check_wf_trs r)
    (\ _ -> (if null r then Inr () else check_varcond_subset s));

create_ctxts :: forall a b. [(Term a b, Term a b)] -> Maybe (Nat -> Ctxt a b);
create_ctxts r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      bind (mapMa
             (\ a ->
               (case a of {
                 (Var _, _) -> Nothing;
                 (Fun _ [], _) -> Nothing;
                 (Fun u (_ : ts), _) -> Just (More u [] Hole ts);
               }))
             rr)
        (\ cs ->
          let {
            _ = size_list cs;
          } in Just (\ i ->
                      (if less_nat i (size_list cs) then nth cs i else Hole)));
  });

create_U ::
  forall a b.
    (Eq a,
      Eq b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                  [(Term a b, Term a b)])] ->
                 Maybe (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                         Nat -> Ctxt a b);
create_U c_rs =
  bind (mapMa
         (\ (cr, rs) ->
           bind (guarda
                  (equal_nat (size_list rs)
                    (plus_nat (size_list (snd cr)) (Nat_of_num One))))
             (\ _ -> bind (create_ctxts rs) (\ ctxt -> Just (cr, ctxt))))
         c_rs)
    (\ cr_ctxts ->
      let {
        m = map_of cr_ctxts;
      } in Just (\ cr ->
                  (case m cr of {
                    Nothing -> (\ _ -> Hole);
                    Just ctxt -> ctxt;
                  })));

create_zs :: forall a b. [(Term a b, Term a b)] -> Maybe (Nat -> [b]);
create_zs r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      bind (mapMa
             (\ a ->
               (case a of {
                 (Var _, _) -> Nothing;
                 (Fun _ [], _) -> Nothing;
                 (Fun _ (_ : ts), _) -> Just (map the_Var ts);
               }))
             rr)
        (\ cs ->
          Just (\ i -> (if less_nat i (size_list cs) then nth cs i else [])));
  });

create_Z ::
  forall a b.
    (Eq a,
      Eq b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                  [(Term a b, Term a b)])] ->
                 Maybe (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                         Nat -> [b]);
create_Z c_rs =
  bind (mapMa (\ (cr, rs) -> bind (create_zs rs) (\ zs -> Just (cr, zs))) c_rs)
    (\ cr_zs ->
      let {
        mc = map_of cr_zs;
      } in Just (\ cr ->
                  (case mc cr of {
                    Nothing -> (\ _ -> []);
                    Just zs -> zs;
                  })));

xml_ctrs_input ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => [((Term (Lab a [b]) c, Term (Lab a [b]) c),
                     [(Term (Lab a [b]) c, Term (Lab a [b]) c)])] ->
                    Xml;
xml_ctrs_input ctrs =
  XML "ctrsInput" [] [XML "conditionalRules" [] (map xml_crule ctrs)];

starts_with :: [Prelude.Char] -> [Prelude.Char] -> Bool;
starts_with t s = take (size_list s) (trim t) == s;

check_redundant_rules_ncr ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_redundant_rules_ncr ra r n =
  bindb (catch_errora (check_subseteq ra r)
          (\ _ ->
            Inl (shows_prec_list Zero_nat
                  "old TRS is not a subsystem of given TRS")))
    (\ _ ->
      let {
        s = list_diff r ra;
        t = list_diff ra r;
      } in bindb (catch_errora
                   (forallM
                     (\ (l, rb) ->
                       check (membera (reachable_terms ra l n) rb)
                         (shows_prec_list Zero_nat "could not simulate rule " .
                           shows_rule (shows_prec Zero_nat)
                             (shows_prec Zero_nat) " -> " (l, rb)))
                     s)
                   (\ x -> Inl (snd x)))
             (\ _ ->
               catch_errora
                 (forallM
                   (\ (l, raa) ->
                     check (membera (reachable_terms r l n) raa)
                       (shows_prec_list Zero_nat "could not simulate rule " .
                         shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                           " -> " (l, raa)))
                   t)
                 (\ x -> Inl (snd x))));

check_modularity_ncr ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Eq a, Set_impl a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_modularity_ncr ra r =
  bindb (catch_errora (check_subseteq r ra)
          (\ _ ->
            Inl (shows_prec_list Zero_nat
                  "new TRS is not a subsystem of given TRS")))
    (\ _ ->
      let {
        s = list_diff ra r;
        f = funas_trs_list r;
        g = funas_trs_list s;
      } in bindb (check (less_eq_set (inf_set (set f) (set g)) bot_set)
                   (shows_prec_list Zero_nat "signatures are not disjoint"))
             (\ _ ->
               bindb (check_varcond_subset r)
                 (\ _ ->
                   catch_errora
                     (catch_errora
                       (forallM
                         (\ x ->
                           (if let {
                                 (l, _) = x;
                               } in not (is_Var l)
                             then Inr () else Inl x))
                         s)
                       (\ x -> Inl (snd x)))
                     (\ _ ->
                       Inl (shows_prec_list Zero_nat
                             "lhss must not be variables")))));

shows_gctxt ::
  forall a b. (Showa a) => Gctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_gctxt GCHole = shows_string "_";
shows_gctxt (GCFun f ts) =
  shows_prec Zero_nat f .
    shows_list_gen id [] "(" ", " ")" (map shows_gctxt ts);

shows_prec_gctxt ::
  forall a b. (Showa a) => Nat -> Gctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_gctxt p c = shows_gctxt c;

gctxts_to_terms_intern ::
  forall a b. (Nat -> a) -> Nat -> [Gctxt b a] -> (Nat, [Term b a]);
gctxts_to_terms_intern iv i (GCFun f ts : cs) =
  let {
    (i1, res1) = gctxts_to_terms_intern iv i ts;
    (i2, res2) = gctxts_to_terms_intern iv i1 cs;
  } in (i2, Fun f res1 : res2);
gctxts_to_terms_intern iv i (GCHole : cs) =
  let {
    (ia, res) = gctxts_to_terms_intern iv (plus_nat i (Nat_of_num One)) cs;
  } in (ia, Var (iv i) : res);
gctxts_to_terms_intern iv i [] = (i, []);

gc_matcher ::
  forall a.
    (Eq a) => Gctxt a [Prelude.Char] ->
                Term a [Prelude.Char] ->
                  Maybe ([Prelude.Char] -> Term a [Prelude.Char]);
gc_matcher c l =
  map_option fst
    (mgu_var_disjoint_generic (\ a -> 'x' : a) (\ a -> 'y' : a) l
      (hd (snd (gctxts_to_terms_intern
                 (\ i -> 'x' : shows_prec_nat Zero_nat i []) Zero_nat [c]))));

check_contains_U0 ::
  forall a.
    (Compare a, Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Set (Term a [Prelude.Char], Term a [Prelude.Char]) ->
                      Term a [Prelude.Char] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_contains_U0 r u s =
  catch_errora
    (forallM
      (\ fts ->
        (case fts of {
          Var _ -> Inr ();
          Fun f ts ->
            let {
              tcapb = GCFun f (map (tcap u) ts);
            } in catch_errora
                   (forallM
                     (\ lr ->
                       (case gc_matcher tcapb (fst lr) of {
                         Nothing -> Inr ();
                         Just sigma ->
                           let {
                             irule =
                               (subst_apply_term (fst lr) sigma,
                                 subst_apply_term (snd lr) sigma);
                           } in check (in_rstep_impl (fst irule) (snd irule) u)
                                  (shows_prec_list Zero_nat
                                     "When considering the subterm " .
                                    shows_prec_term Zero_nat fts .
                                      shows_nl .
shows_prec_list Zero_nat "and the rule " .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " lr .
    shows_nl .
      shows_prec_list Zero_nat "the capped subterm is " .
        shows_prec_gctxt Zero_nat tcapb .
          shows_nl .
            shows_prec_list Zero_nat "leading to the mgu with the lhs: " .
              shows_prec_list Zero_nat
                (map (\ x -> (x, sigma x)) (vars_term_list (fst lr))) .
                shows_nl .
                  shows_prec_list Zero_nat "The instantiated rule " .
                    shows_prec_prod Zero_nat irule .
                      shows_nl .
                        shows_prec_list Zero_nat
                          "cannot be simulated by the given set of usable rules");
                       }))
                     r)
                   (\ x -> Inl (snd x));
        }))
      (supteq_list s))
    (\ x -> Inl (snd x));

check_usable_instantiation ::
  forall a.
    (Compare a, Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      Term a [Prelude.Char] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_usable_instantiation r u s =
  let {
    uu = set u;
  } in bindb (catch_errora (check_contains_U0 r uu s)
               (\ x ->
                 Inl (shows_prec_list Zero_nat "U <= U0(R,s) required" .
                       shows_nl . x)))
         (\ _ ->
           catch_errora
             (forallM
               (\ ra ->
                 catch_errora (check_contains_U0 r uu ra)
                   (\ x ->
                     Inl (shows_prec_list Zero_nat "U <= U0(R,r) for rhs r = " .
                           shows_prec_term Zero_nat ra .
                             shows_prec_list Zero_nat " required" .
                               shows_nl . x)))
               (map snd u))
             (\ x -> Inl (snd x)));

check_usable_rules_unif ::
  forall a.
    (Compare a, Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      Term a [Prelude.Char] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_usable_rules_unif r u s =
  catch_errora
    (bindb
      (check (ground s || all (\ l -> not (is_Var l)) (map fst r))
        (shows_string "since " .
          shows_prec_term Zero_nat s .
            shows_prec_list Zero_nat
              " is not ground, left-hand sides of R must not be variables"))
      (\ _ ->
        bindb (check_varcond_subset u)
          (\ _ ->
            catch_errora (check_usable_instantiation r u s)
              (\ x ->
                Inl (shows_string
                       "closure properties of usable rules not satisfied" .
                      shows_nl . x)))))
    (\ x ->
      Inl (shows_string "problem in checking validity of usable rules U = " .
            shows_nl .
              shows_trs (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                "rewrite system:" " -> " u .
                shows_nl .
                  shows_prec_list Zero_nat "for term " .
                    shows_prec_term Zero_nat s .
                      shows_nl .
                        shows_string "wrt TRS R = " .
                          shows_nl .
                            shows_trs (shows_prec Zero_nat)
                              (shows_prec_list Zero_nat) "rewrite system:"
                              " -> " r .
                              shows_nl . x));

sl_c :: forall a b c d e. Sl_ops_ext a b c d e -> b;
sl_c (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_c;

check_qmodel_rule_ass ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (a -> [b] -> b) ->
                    (b -> b -> Bool) ->
                      (c -> b) ->
                        (Term a c, Term a c) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel_rule_ass i cge alpha (l, r) =
  let {
    cl = eval i alpha l;
    cr = eval i alpha r;
  } in check (cge cl cr)
         (shows_string "rule " .
           shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
             (l, r) .
             shows_string " violates the model condition, [lhs] = " .
               shows_prec Zero_nat cl .
                 shows_string ", [rhs] = " . shows_prec Zero_nat cr);

check_qmodel_rule ::
  forall a b c.
    (Showa a, Showa b, Eq c,
      Showa c) => (a -> [b] -> b) ->
                    [b] ->
                      (b -> b -> Bool) ->
                        (Term a c, Term a c) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel_rule i c cge lr =
  catch_errora
    (forallM (\ alpha -> check_qmodel_rule_ass i cge alpha lr)
      (map fun_of (enum_vectors c (insert_vars_rule lr []))))
    (\ x -> Inl (snd x));

check_qmodel ::
  forall a b c.
    (Showa a, Showa b, Eq c,
      Showa c) => (a -> [b] -> b) ->
                    [b] ->
                      (b -> b -> Bool) ->
                        [(Term a c, Term a c)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel i c cge r =
  catch_errora (forallM (check_qmodel_rule i c cge) r) (\ x -> Inl (snd x));

check_non_join_model ::
  forall a b c d.
    (Showa a, Showa b, Eq d,
      Showa d) => (a -> a -> Bool) ->
                    ([(b, Nat)] ->
                      [(b, Nat)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char])
                          (Sl_ops_ext b a c d ())) ->
                      [(Term b d, Term b d)] ->
                        [(Term b d, Term b d)] ->
                          Term b d ->
                            Term b d ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_model cge gen rs rt s t =
  catch_errora
    (bindb (gen (funas_trs_list (rs ++ rt)) [])
      (\ ops ->
        let {
          i = sl_I ops;
          e = eval i (\ _ -> sl_c ops);
          es = e s;
          et = e t;
        } in bindb (check (not (cge et es))
                     (shows_prec_list Zero_nat
                        "the inequality must not hold: [" .
                       shows_prec_term Zero_nat t .
                         shows_prec_list Zero_nat "] = " .
                           shows_prec Zero_nat et .
                             shows_prec_list Zero_nat " >= " .
                               shows_prec Zero_nat es .
                                 shows_prec_list Zero_nat " = [" .
                                   shows_prec_term Zero_nat s .
                                     shows_prec_list Zero_nat "]"))
               (\ _ -> check_qmodel i (sl_C ops) cge (reverse_rules rs ++ rt))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "problem in disproving non-joinability via interpretations" .
            shows_nl . x));

check_non_join_finite_model ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Sl_variant (Lab a [Nat]) b ->
                    [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                      [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                        Term (Lab a [Nat]) b ->
                          Term (Lab a [Nat]) b ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_finite_model (Rootlab x) rs rt s t =
  check_non_join_model equal_lab (slm_gen_to_sl_gen (rl_slm x)) rs rt s t;
check_non_join_finite_model (Finitelab sli) rs rt s t =
  check_non_join_model equal_nat
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli))) rs rt s t;
check_non_join_finite_model (QuasiFinitelab sli v) rs rt s t =
  check_non_join_model qmodel_cge (\ f g -> qsli_to_sl v f g sli) rs rt s t;

match_tcap_below_impl ::
  forall a b.
    (Eq a, Eq b) => Term a b -> [(Term a b, Term a b)] -> Term a b -> Bool;
match_tcap_below_impl l r (Fun f ts) = matchb (GCFun f (map (tcapI r) ts)) l;
match_tcap_below_impl l r (Var x) = False;

usable_rules_reach_U0_impl ::
  forall a b.
    (Eq a,
      Eq b) => [(Term a b, Term a b)] -> Term a b -> [(Term a b, Term a b)];
usable_rules_reach_U0_impl r t =
  inductive_set_impl r
    (\ ta (l, _) ->
      is_Var l ||
        any (\ u -> not (is_Var u) && match_tcap_below_impl l r u)
          (supteq_list ta))
    (\ lr -> [snd lr]) [t];

usable_rules_reach_impl ::
  forall a b.
    (Compare a, Eq a, Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b,
      Compare b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       Term a b -> [(Term a b, Term a b)];
usable_rules_reach_impl r t =
  let {
    u0t = usable_rules_reach_U0_impl r t;
  } in (if all (\ (l, ra) -> less_eq_set (vars_term ra) (vars_term l)) u0t
         then u0t else r);

check_non_join_redpair ::
  forall a b.
    (Key a, Showa a,
      Showa b) => Redtriple_ext a b () ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        Term a b ->
                          Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_redpair rp rs rt sa t =
  catch_errora
    (bindb (valid rp)
      (\ _ ->
        bindb (catch_errora (forallM (ns rp) (reverse_rules rs ++ rt))
                (\ x -> Inl (snd x)))
          (\ _ -> s rp (sa, t))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "problem in disproving non-joinability via discrimination pairs" .
            shows_nl . x));

show_ta ::
  forall a b.
    (Showa a,
      Showa b) => Tree_automaton a b -> [Prelude.Char] -> [Prelude.Char];
show_ta (Tree_Automaton fin rules eps) =
  (((((((shows_prec_list Zero_nat "final: " . shows_prec_list Zero_nat fin) .
         shows_nl) .
        shows_prec_list Zero_nat "rules: ") .
       shows_lines rules) .
      shows_nl) .
     shows_prec_list Zero_nat "epsilon: ") .
    shows_prec_list Zero_nat eps) .
    shows_nl;

shows_prec_tree_automaton ::
  forall a b.
    (Showa a,
      Showa b) => Nat -> Tree_automaton a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_tree_automaton d r = show_ta r;

ta_rhs_states ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => Ta_ext a b () -> Set a;
ta_rhs_states ta =
  sup_set (image r_rhs (ta_rules ta))
    (compute_trancl (image r_rhs (ta_rules ta)) (ta_eps ta));

initial_rel ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) -> Set (a, Set a);
initial_rel ta r =
  let {
    rhs = ta_rhs_states ta;
    match = ta_matcha ta rhs;
    analyze_rule =
      (\ (l, ra) ->
        let {
          _ = vars_term l;
        } in sup_seta
               (image
                 (\ sigma ->
                   let {
                     qr = ta_res ta (map_term (\ x -> x) (fun_of sigma) ra);
                   } in image (\ q -> (q, qr))
                          (ta_res ta (map_term (\ x -> x) (fun_of sigma) l)))
                 (match l)));
  } in sup_seta (image analyze_rule r);

initial_relation ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) -> Maybe (Set (a, a));
initial_relation ta r =
  let {
    q_qs = initial_rel ta r;
  } in (if member bot_set (image snd q_qs) then Nothing
         else Just (sup_seta
                     (image (\ (q, a) -> image (\ aa -> (q, aa)) a) q_qs)));

decide_coherent_compatible_main ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) ->
                         (Maybe (Set (a, a)) -> Maybe (Set (a, a))) -> Bool;
decide_coherent_compatible_main ta r normalizer =
  (case normalizer (initial_relation ta r) of {
    Nothing -> False;
    Just rel -> less_eq_set (imagea rel (ta_final ta)) (ta_final ta);
  });

minus_set :: forall a. (Ceq a, Ccompare a) => Set a -> Set a -> Set a;
minus_set a b = inf_set a (uminus_set b);

normalize_main ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Ta_ext a b () -> Set (a, a) -> Set (a, a) -> Maybe (Set (a, a));
normalize_main ta rel accu =
  let {
    new = new_states ta rel;
  } in (if member Nothing (image snd new) then Nothing
         else let {
                new_rel = image (\ (x, y) -> (x, the y)) new;
                new_accu = sup_set accu rel;
                todo = minus_set new_rel new_accu;
              } in (if less_eq_set todo bot_set then Just new_accu
                     else normalize_main ta todo new_accu));

normalizea ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b,
      Eq b) => Ta_ext a b () -> Maybe (Set (a, a)) -> Maybe (Set (a, a));
normalizea ta (Just rel) = normalize_main ta rel bot_set;
normalizea ta Nothing = Nothing;

decide_coherent_compatible ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
decide_coherent_compatible ta r =
  decide_coherent_compatible_main ta r (normalizea ta);

closed_under_rewriting ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Default b, Eq b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
closed_under_rewriting ta r = decide_coherent_compatible (trim_ta ta) r;

is_Decision_Proc :: forall a. Ta_relation a -> Bool;
is_Decision_Proc Decision_Proc = True;
is_Decision_Proc Id_Relation = False;
is_Decision_Proc (Some_Relation v) = False;

ta_of_ta ::
  forall a b.
    (Ceq a, Ccompare a, Compare a, Eq a, Set_impl a, Compare b,
      Eq b) => Tree_automaton a b -> Ta_ext a b ();
ta_of_ta (Tree_Automaton fin rules eps) =
  Ta_ext (set fin) (set rules) (set eps) ();

tree_aut_trs_closed ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a, Showa a, Compare_order b, Default b, Eq b, Showa b,
      Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c, Compare_order c, Eq c,
      Set_impl c,
      Showa c) => Tree_automaton a b ->
                    Ta_relation a ->
                      [(Term b c, Term b c)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
tree_aut_trs_closed ta rel r =
  catch_errora
    (if is_Decision_Proc rel
      then bindb (check_varcond_subset r)
             (\ _ ->
               bindb (catch_errora (check_det ta)
                       (\ x ->
                         Inl (shows_prec_list Zero_nat
                                "decision procedure requires det. automaton as input" .
                               x)))
                 (\ _ ->
                   check (closed_under_rewriting (ta_of_ta ta) (set r))
                     (shows_prec_list Zero_nat
                       "the language of the automaton is not closed under rewriting")))
      else bindb (check_varcond_subset r)
             (\ _ ->
               bindb (generate_ta_cond ta rel)
                 (\ taa ->
                   bindb (if isOK (check_left_linear_trs r) then Inr ()
                           else catch_errora (check_det ta)
                                  (\ x ->
                                    Inl (shows_prec_list Zero_nat
   "could not ensure left-linearity or determinism" .
  shows_nl . x)))
                     (\ _ ->
                       catch_errora
                         (state_compatible_eff_list taa (rel_checker rel) r)
                         (\ x ->
                           Inl (let {
                                  (lr, (lrq, q)) = x;
                                } in shows_prec_list Zero_nat
                                       "TA is not compatible with R" .
                                       shows_nl .
 shows_prec_list Zero_nat "for rule " .
   shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " lr .
     shows_nl .
       shows_prec_list Zero_nat "which is instantiated by states to " .
         shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " lrq .
           shows_nl .
             shows_prec_list Zero_nat "the state " .
               shows_prec Zero_nat q .
                 shows_prec_list Zero_nat " is only reachable from the lhs" .
                   shows_nl))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "problem when ensuring compatibility of TRS with TA " .
            shows_nl . shows_prec_tree_automaton Zero_nat ta . shows_nl . x));

intersect_ta ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Finite_UNIV c,
      Cenum c, Ceq c, Cproper_interval c, Compare c, Eq c,
      Set_impl c) => Ta_ext a b () -> Ta_ext c b () -> Ta_ext (a, c) b ();
intersect_ta tA1 tA2 = prod_ta tA1 tA2 (productc (ta_final tA1) (ta_final tA2));

non_join_with_ta ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare_order a, Eq a,
      Set_impl a, Showa a, Ceq b, Ccompare b, Compare_order b, Default b, Eq b,
      Set_impl b, Showa b, Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c,
      Compare_order c, Eq c, Set_impl c,
      Showa c) => Tree_automaton a b ->
                    Ta_relation a ->
                      [(Term b c, Term b c)] ->
                        Term b c ->
                          Tree_automaton a b ->
                            Ta_relation a ->
                              [(Term b c, Term b c)] ->
                                Term b c ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
non_join_with_ta ta1 rel1 r1 t1 ta2 rel2 r2 t2 =
  let {
    tA1 = ta_of_ta ta1;
    tA2 = ta_of_ta ta2;
  } in bindb (check (ta_member t1 tA1)
               (shows_prec_term Zero_nat t1 .
                 shows_prec_list Zero_nat
                   " is not accepted by first automaton"))
         (\ _ ->
           bindb (check (ta_member t2 tA2)
                   (shows_prec_term Zero_nat t2 .
                     shows_prec_list Zero_nat
                       " is not accepted by first automaton"))
             (\ _ ->
               bindb (check (ta_empty (intersect_ta tA1 tA2))
                       (shows_prec_list Zero_nat
                         "intersection of automata is non-empty"))
                 (\ _ ->
                   bindb (catch_errora (tree_aut_trs_closed ta1 rel1 r1)
                           (\ x ->
                             Inl (shows_prec_list Zero_nat
                                    "could not ensure closure under rewriting for first automaton" .
                                   shows_nl . x)))
                     (\ _ ->
                       catch_errora (tree_aut_trs_closed ta2 rel2 r2)
                         (\ x ->
                           Inl (shows_prec_list Zero_nat
                                  "could not ensure closure under rewriting for second automaton" .
                                 shows_nl . x))))));

check_non_join ::
  forall a b.
    (Default a, Eq a, Key a, Showa a, Card_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b,
      Showa b) => [(Term (Lab a [Nat]) [Prelude.Char],
                     Term (Lab a [Nat]) [Prelude.Char])] ->
                    [(Term (Lab a [Nat]) [Prelude.Char],
                       Term (Lab a [Nat]) [Prelude.Char])] ->
                      Term (Lab a [Nat]) [Prelude.Char] ->
                        Term (Lab a [Nat]) [Prelude.Char] ->
                          Non_join_info (Lab a [Nat]) [Prelude.Char] b ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join rs rt s t Diff_NFs =
  bindb (check (not (equal_term s t))
          (shows_prec_list Zero_nat "the terms " .
            shows_prec_term Zero_nat s .
              shows_prec_list Zero_nat " and " .
                shows_prec_term Zero_nat t .
                  shows_prec_list Zero_nat " are identical"))
    (\ _ ->
      let {
        chknf =
          (\ sa r ->
            check (is_NF_trs r sa)
              (shows_prec_list Zero_nat "the term " .
                shows_term (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat)
                  sa .
                  shows_prec_list Zero_nat " is not in normal form"));
      } in bindb (chknf s rs) (\ _ -> chknf t rt));
check_non_join rs rt s t (Grounding sigma prf) =
  let {
    sigmaa = mk_subst Var sigma;
  } in check_non_join rs rt (subst_apply_term s sigmaa)
         (subst_apply_term t sigmaa) prf;
check_non_join rs rt s t (Subterm_NJ p prf) =
  bindb (check (member p (pos_gctxt (tcapI rs s)))
          (shows_prec_list Zero_nat "position " .
            shows_prec_pos Zero_nat p .
              shows_prec_list Zero_nat " not in capped term  of " .
                shows_prec_term Zero_nat s))
    (\ _ ->
      bindb (check (member p (pos_gctxt (tcapI rt t)))
              (shows_prec_list Zero_nat "position " .
                shows_prec_pos Zero_nat p .
                  shows_prec_list Zero_nat " not in capped term  of " .
                    shows_prec_term Zero_nat t))
        (\ _ -> check_non_join rs rt (subt_at s p) (subt_at t p) prf));
check_non_join rs rt s t (Tcap_Non_Unif grd_subst) =
  let {
    sigma = grd_subst s t;
    cs = tcapI rs (subst_apply_term s sigma);
    ct = tcapI rt (subst_apply_term t sigma);
  } in check (is_none (merge cs ct))
         (shows_prec_list Zero_nat "could not infer that " .
           shows_prec_term Zero_nat s .
             shows_prec_list Zero_nat " and " .
               shows_prec_term Zero_nat t .
                 shows_prec_list Zero_nat " are not joinable");
check_non_join rs rt s t (Tree_Aut_Intersect_Empty ta1 rel1 ta2 rel2) =
  catch_errora (non_join_with_ta ta1 rel1 rs s ta2 rel2 rt t)
    (\ x ->
      Inl (shows_prec_list Zero_nat "could not infer that " .
            shows_prec_term Zero_nat s .
              shows_prec_list Zero_nat " and " .
                shows_prec_term Zero_nat t .
                  shows_prec_list Zero_nat " are not joinable" . shows_nl . x));
check_non_join rs rt s t (Finite_Model_Gt i) =
  catch_errora (check_non_join_finite_model i rs rt s t)
    (\ x ->
      Inl (shows_prec_list Zero_nat "could not infer that " .
            shows_prec_term Zero_nat s .
              shows_prec_list Zero_nat " and " .
                shows_prec_term Zero_nat t .
                  shows_prec_list Zero_nat " are not joinable" . shows_nl . x));
check_non_join rs rt s t (Reduction_Pair_Gt rp) =
  catch_errora (check_non_join_redpair (get_redtriple rp) rs rt s t)
    (\ x ->
      Inl (shows_prec_list Zero_nat "could not infer that " .
            shows_prec_term Zero_nat s .
              shows_prec_list Zero_nat " and " .
                shows_prec_term Zero_nat t .
                  shows_prec_list Zero_nat " are not joinable" . shows_nl . x));
check_non_join rs rt s t (Usable_Rules_Reach_NJ prf) =
  check_non_join (usable_rules_reach_impl rs s) (usable_rules_reach_impl rt t) s
    t prf;
check_non_join rs rt s t (Usable_Rules_Reach_Unif_NJ u_sum prf) =
  (case u_sum of {
    Inl u ->
      bindb (check_usable_rules_unif rs u s)
        (\ _ -> check_non_join u rt s t prf);
    Inr u ->
      bindb (check_usable_rules_unif rt u t)
        (\ _ -> check_non_join rs u s t prf);
  });
check_non_join rs rt s t (Argument_Filter_NJ pi prf) =
  (case afs_of pi of {
    Nothing -> Inl (shows_prec_list Zero_nat "invalid argument filter");
    Just pia ->
      let {
        af = af_term pia;
        afs = af_rules pia;
      } in check_non_join (afs rs) (afs rt) (af s) (af t) prf;
  });

check_non_cr ::
  forall a b.
    (Default a, Eq a, Key a, Showa a, Card_UNIV b, Cenum b, Ceq b,
      Cproper_interval b, Compare_order b, Eq b, Set_impl b,
      Showa b) => [(Term (Lab a [Nat]) [Prelude.Char],
                     Term (Lab a [Nat]) [Prelude.Char])] ->
                    Term (Lab a [Nat]) [Prelude.Char] ->
                      [(Pos, ((Term (Lab a [Nat]) [Prelude.Char],
                                Term (Lab a [Nat]) [Prelude.Char]),
                               Term (Lab a [Nat]) [Prelude.Char]))] ->
                        [(Pos, ((Term (Lab a [Nat]) [Prelude.Char],
                                  Term (Lab a [Nat]) [Prelude.Char]),
                                 Term (Lab a [Nat]) [Prelude.Char]))] ->
                          Non_join_info (Lab a [Nat]) [Prelude.Char] b ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_cr r s seq1 seq2 reason =
  let {
    chk = check_rsteps_last r s;
  } in bindb (chk seq1)
         (\ _ ->
           bindb (chk seq2)
             (\ _ ->
               check_non_join r r (rseq_last s seq1) (rseq_last s seq2)
                 reason));

check_ncr_proof ::
  forall a b c.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            Ncr_proof b [Nat] [Prelude.Char] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ncr_proof a ia i j r (SN_NWCR prf) =
  debug (ia []) "SN_NWCR"
    (let {
       tp = mkb i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a (ia . shows_string ".1") tp
                    prf)
                  (\ x ->
                    Inl (ia . shows_string
                                ": error below strong normalization + wcr" .
                                shows_nl . indent x)))
            (\ _ ->
              catch_errora
                (check
                  (not (isOK (check_critical_pairs_NF r
                               (critical_pairs_impl r r))))
                  (shows_prec_list Zero_nat "all critical pairs are joinable"))
                (\ x ->
                  Inl (ia . shows_prec_list Zero_nat
                              "error when disproving local confluence of " .
                              shows_tp (shows_prec_lab Zero_nat)
                                (shows_prec_list Zero_nat) i tp .
                                shows_nl . indent x))));
check_ncr_proof a ia i j r (Non_Join s seq1 seq2 prf) =
  debug (ia []) "Non_Join"
    (catch_errora (check_non_cr r s seq1 seq2 prf)
      (\ x ->
        Inl (ia . shows_prec_list Zero_nat "error when disproving CR of " .
                    shows_trs (shows_prec_lab Zero_nat)
                      (shows_prec_list Zero_nat) "rewrite system:" " -> " r .
                      shows_nl . indent x)));
check_ncr_proof a ia i j ra (NCR_Disj_Subtrs r prf) =
  debug (ia []) "Modularity"
    (bindb
      (catch_errora (check_modularity_ncr ra r)
        (\ x ->
          Inl (ia . shows_prec_list Zero_nat
                      "error when applying modularity to switch to " .
                      shows_trs (shows_prec_lab Zero_nat)
                        (shows_prec_list Zero_nat) "rewrite system:" " -> " r .
                        shows_nl . indent x)))
      (\ _ ->
        catch_errora (check_ncr_proof a (ia . shows_string ".1") i j r prf)
          (\ x ->
            Inl (ia . shows_string ": error below the modular decomposition" .
                        shows_nl . indent x))));
check_ncr_proof a ia i j r (NCR_Redundant_Rules rs n prf) =
  debug (ia []) "Redundant Rules"
    (bindb
      (catch_errora (check_ncr_proof a (ia . shows_string ".1") i j rs prf)
        (\ x ->
          Inl (ia . shows_prec_list Zero_nat
                      ": error when proving nonconfluence of modified TRS" .
                      shows_nl .
                        shows_trs (shows_prec_lab Zero_nat)
                          (shows_prec_list Zero_nat) "rewrite system:" " -> "
                          rs .
                          indent x)))
      (\ _ ->
        catch_errora (check_redundant_rules_ncr r rs n)
          (\ x ->
            Inl (ia . shows_prec_list Zero_nat
                        "error in checking redundant rules transformation of the TRS" .
                        shows_nl .
                          shows_trs (shows_prec_lab Zero_nat)
                            (shows_prec_list Zero_nat) "rewrite system:" " -> "
                            r .
                            indent x))));

check_rel_loop ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => Term a b ->
                    [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                      [(b, Term a b)] ->
                        Ctxt a b ->
                          [(Term a b, Term a b)] ->
                            [(Term a b, Term a b)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_loop sa rseq sigma c r s =
  check_rel_seq r s rseq sa
    (ctxt_apply_term c (subst_apply_term sa (mk_subst Var sigma))) False;

check_trs_loop ::
  forall a b c.
    (Compare b, Eq b, Showa b, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Trs_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_loop i tp (TRS_loop_prf s rseq sigma c) =
  check_loop (qb i tp) (nfsb i tp) s rseq sigma c (rulesc i tp);

prems_ofa ::
  forall a.
    Dp_proof_step a ->
      [(([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))];
prems_ofa step =
  (case step of {
    OC1 _ _ -> [];
    OC2 _ p pa _ _ _ ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p))),
        (([], ((Zero_nat, (Zero_nat, [])), fst pa)),
          ([], ((Zero_nat, (Zero_nat, [])), snd pa)))];
    OC2p _ p pa _ _ _ ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p))),
        (([], ((Zero_nat, (Zero_nat, [])), fst pa)),
          ([], ((Zero_nat, (Zero_nat, [])), snd pa)))];
    OC3 _ p pa _ _ ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p))),
        (([], ((Zero_nat, (Zero_nat, [])), fst pa)),
          ([], ((Zero_nat, (Zero_nat, [])), snd pa)))];
    OC3p _ p pa _ _ ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p))),
        (([], ((Zero_nat, (Zero_nat, [])), fst pa)),
          ([], ((Zero_nat, (Zero_nat, [])), snd pa)))];
    OCDP1 _ p ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p)))];
    OCDP2 _ p ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p)))];
    WPEQ _ p -> [p];
    Lift _ p -> [p];
    DPOC1_1 _ p rl _ _ ->
      [p, (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
            ([], ((Zero_nat, (Zero_nat, [])), snd rl)))];
    DPOC1_2 _ p rl _ _ _ ->
      [p, (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
            ([], ((Zero_nat, (Zero_nat, [])), snd rl)))];
    DPOC2 _ p rl _ _ ->
      [p, (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
            ([], ((Zero_nat, (Zero_nat, [])), snd rl)))];
    DPOC3_1 _ p rl _ _ ->
      [p, (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
            ([], ((Zero_nat, (Zero_nat, [])), snd rl)))];
    DPOC3_2 _ p rl _ _ _ ->
      [p, (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
            ([], ((Zero_nat, (Zero_nat, [])), snd rl)))];
    DPDP1_1 _ p1 p2 _ _ -> [p1, p2];
    DPDP1_2 _ p1 p2 _ _ -> [p1, p2];
    DPDP2_1 _ p1 p2 _ _ -> [p1, p2];
    DPDP2_2 _ p1 p2 _ _ -> [p1, p2];
  });

shows_oc ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_oc (l, r) =
  shows_prec Zero_nat l .
    shows_prec_list Zero_nat " ->+ " . shows_prec Zero_nat r;

vars_subst_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
vars_subst_impl sigma =
  let {
    sigmaa = mk_subst_domain sigma;
  } in map fst sigmaa ++ concatMap (vars_term_list . snd) sigmaa;

unraveling_info ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(((Term a [Prelude.Char], Term a [Prelude.Char]),
              [(Term a [Prelude.Char], Term a [Prelude.Char])]),
             [(Term a [Prelude.Char], Term a [Prelude.Char])])];
unraveling_info xml2name =
  many "unravelingInformation"
    (many1 "unravelingEntry" (crule xml2name) (rule xml2name) (\ a b -> (a, b)))
    id;

check_same_set :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_same_set xs ys =
  bindb (check_subseteq xs ys) (\ _ -> check_subseteq ys xs);

mk_tpa ::
  forall a b c d.
    Tp_ops_ext a b c d -> (Bool, ([Term b c], [(Term b c, Term b c)])) -> a;
mk_tpa i (nfs, (q, r)) = mkb i nfs q r [];

show_pat_term ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                    [Prelude.Char] -> [Prelude.Char];
show_pat_term p =
  let {
    (s, (sigma, tau)) = p;
  } in shows_prec_prod Zero_nat
         (s, (mk_subst_domain sigma, mk_subst_domain tau));

show_pat_rule ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                    ((Term a b, ([(b, Term a b)], [(b, Term a b)])), Bool)) ->
                    [Prelude.Char] -> [Prelude.Char];
show_pat_rule pr =
  let {
    (p1, (p2, _)) = pr;
  } in show_pat_term p1 . shows_string " --> " . show_pat_term p2;

term_to_string :: forall a b. Term a b -> [a];
term_to_string (Fun f [t]) = f : term_to_string t;
term_to_string (Var v) = [];
term_to_string (Fun v []) = [];
term_to_string (Fun v (vb : vd : ve)) = [];

normalize_wp ::
  forall a.
    (Eq a) => ([a], ((Nat, (Nat, [a])), [a])) ->
                ([a], ((Nat, (Nat, [a])), [a]));
normalize_wp (x, ((xa, (xb, xc)), xd)) =
  let {
    (l, (f, aa)) = (x, (xa, (xb, (xc, xd))));
  } in (if equal_nat f Zero_nat
         then let {
                (aab, aaa) = aa;
              } in (if equal_nat aab Zero_nat
                     then let {
                            (_, r) = aaa;
                          } in ([], ((Zero_nat, (Zero_nat, [])), l ++ r))
                     else let {
                            (m, r) = aaa;
                          } in normalize_wp
                                 (l ++ concat
 (replicate (plus_nat (minus_nat aab (Nat_of_num One)) (Nat_of_num One)) m),
                                   ((Zero_nat, (Zero_nat, m)), r)))
         else (if equal_nat (minus_nat f (Nat_of_num One)) Zero_nat
                then let {
                       (aab, aaa) = aa;
                     } in (if equal_nat aab Zero_nat
                            then (case aaa of {
                                   ([], r) ->
                                     ([], ((Zero_nat, (Zero_nat, [])), l ++ r));
                                   (a : m, r) ->
                                     (case r of {
                                       [] ->
 (l, ((plus_nat Zero_nat (Nat_of_num One), (Zero_nat, a : m)), []));
                                       b : ra ->
 (if a == b
   then normalize_wp
          (l ++ [b],
            ((plus_nat Zero_nat (Nat_of_num One), (Zero_nat, m ++ [b])), ra))
   else (l, ((plus_nat Zero_nat (Nat_of_num One), (Zero_nat, a : m)), b : ra)));
                                     });
                                 })
                            else let {
                                   (m, r) = aaa;
                                 } in normalize_wp
(l ++ concat
        (replicate (plus_nat (minus_nat aab (Nat_of_num One)) (Nat_of_num One))
          m),
  ((plus_nat Zero_nat (Nat_of_num One), (Zero_nat, m)), r)))
                else let {
                       (aab, aaa) = aa;
                     } in (if equal_nat aab Zero_nat
                            then (case aaa of {
                                   ([], r) ->
                                     ([], ((Zero_nat, (Zero_nat, [])), l ++ r));
                                   (vb : vba, r) ->
                                     normalize_wp
                                       (l,
 ((plus_nat Zero_nat (Nat_of_num One),
    (Zero_nat,
      concat
        (replicate
          (plus_nat
            (plus_nat
              (minus_nat (minus_nat f (Nat_of_num One)) (Nat_of_num One))
              (Nat_of_num One))
            (Nat_of_num One))
          (vb : vba)))),
   r));
                                 })
                            else let {
                                   (m, r) = aaa;
                                 } in normalize_wp
(l ++ concat
        (replicate (plus_nat (minus_nat aab (Nat_of_num One)) (Nat_of_num One))
          m),
  ((plus_nat
      (plus_nat (minus_nat (minus_nat f (Nat_of_num One)) (Nat_of_num One))
        (Nat_of_num One))
      (Nat_of_num One),
     (Zero_nat, m)),
    r)))));

word_pat_equiv ::
  forall a.
    (Eq a) => ([a], ((Nat, (Nat, [a])), [a])) ->
                ([a], ((Nat, (Nat, [a])), [a])) -> Bool;
word_pat_equiv wp1 wp2 = wp1 == wp2 || normalize_wp wp1 == normalize_wp wp2;

shows_pat ::
  forall a b c d e f g h i j.
    (Showa a, Showa b, Showa c, Showa d, Showa e, Showa f, Showa g, Showa h,
      Showa i,
      Showa j) => ((a, ((b, (c, d)), e)), (f, ((g, (h, i)), j))) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_pat (p1, p2) = shows_p p1 . shows_prec_list Zero_nat " ->+ " . shows_p p2;

bounded_postfixes :: Pos -> [Pos] -> [Pos];
bounded_postfixes p ps =
  map_filter (\ x -> (if not (is_none x) then Just (the x) else Nothing))
    (map (pos_prefix p) ps);

rel_rules_of ::
  forall a b. Maybe [(Term a b, Term a b)] -> [(Term a b, Term a b)];
rel_rules_of Nothing = [];
rel_rules_of (Just r) = r;

subst_power_impl ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> Nat -> [(a, Term b a)];
subst_power_impl sigma n =
  (if equal_nat n Zero_nat then []
    else subst_compose_impl sigma
           (subst_power_impl sigma (minus_nat n (Nat_of_num One))));

impl_ofc ::
  forall b a.
    (Key b,
      Key a) => Tp b a ->
                  (Bool,
                    ([Term b a],
                      (Bool,
                        ([(Term b a, Term b a)],
                          ([(Term b a, Term b a)],
                            (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                              Term b a -> Bool))))));
impl_ofc (TP x) = x;

q_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      [Term a b];
q_impl (uu, (q, uv)) = q;

q :: forall a b. (Key a, Key b) => Tp a b -> [Term a b];
q tp = q_impl (impl_ofc tp);

r_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)];
r_impl (uu, (uv, (uw, (vR, (ux, (m, uy)))))) = vR ++ rules_with id m;

r :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
r tp = r_impl (impl_ofc tp);

rhs_n ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Term a b;
rhs_n u (lr, cs) n =
  (if less_nat n (size_list cs)
    then ctxt_apply_term (u (lr, cs) n) (fst (nth cs n)) else snd lr);

lhs_n ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Term a b;
lhs_n u (lr, cs) n =
  (if equal_nat n Zero_nat then fst lr
    else ctxt_apply_term (u (lr, cs) (minus_nat n (Nat_of_num One)))
           (snd (nth cs (minus_nat n (Nat_of_num One)))));

rules_impl ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> [(Term a b, Term a b)];
rules_impl u cr =
  map (\ i -> (lhs_n u cr i, rhs_n u cr i))
    (upt Zero_nat (plus_nat (size_list (snd cr)) (Nat_of_num One)));

default_nfs_nt_trs :: Bool;
default_nfs_nt_trs = False;

xml2inn_rel_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Bool,
                       ([Term (Lab a b) [Prelude.Char]],
                         ([(Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char])],
                           [(Term (Lab a b) [Prelude.Char],
                              Term (Lab a b) [Prelude.Char])])));
xml2inn_rel_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ -> errora "(innermost) TRS expected";
        Inn_TRS_input (inn, (r, so)) ->
          returna
            (default_nfs_nt_trs,
              (strategy_to_Q inn r,
                (r, (case so of {
                      Nothing -> [];
                      Just s -> s;
                    }))));
        COMP_input _ -> errora "(innermost) TRS expected";
        EQ_input _ -> errora "(innermost) TRS expected";
        CPX_input _ -> errora "(innermost) TRS expected";
        FP_TRS_input _ -> errora "(innermost) TRS expected";
        CTRS_input _ -> errora "(innermost) TRS expected";
        Unknown_input _ -> errora "(innermost) TRS expected";
      }));

xml2inn_fp_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Sum (Bool,
                            ([Term (Lab a b) [Prelude.Char]],
                              [(Term (Lab a b) [Prelude.Char],
                                 Term (Lab a b) [Prelude.Char])]))
                       ([(Ctxt (Lab a b) [Prelude.Char],
                           (Term (Lab a b) [Prelude.Char], Location))],
                         [(Term (Lab a b) [Prelude.Char],
                            Term (Lab a b) [Prelude.Char])]));
xml2inn_fp_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ -> errora "non-relative TRS expected";
        Inn_TRS_input (inn, (r, Nothing)) ->
          returna (Inl (default_nfs_nt_trs, (strategy_to_Q inn r, r)));
        Inn_TRS_input (_, (_, Just _)) -> errora "non-relative TRS expected";
        COMP_input _ -> errora "non-relative TRS expected";
        EQ_input _ -> errora "non-relative TRS expected";
        CPX_input _ -> errora "non-relative TRS expected";
        FP_TRS_input (fp, r) -> returna (Inr (strategy_to_fp fp r, r));
        CTRS_input _ -> errora "non-relative TRS expected";
        Unknown_input _ -> errora "non-relative TRS expected";
      }));

xml2fp_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     ([(Ctxt (Lab a b) [Prelude.Char],
                         (Term (Lab a b) [Prelude.Char], Location))],
                       [(Term (Lab a b) [Prelude.Char],
                          Term (Lab a b) [Prelude.Char])]);
xml2fp_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora "outermost/forbidden-pattern/context-sensitive TRS expected";
        Inn_TRS_input _ ->
          errora "outermost/forbidden-pattern/context-sensitive TRS expected";
        COMP_input _ ->
          errora "outermost/forbidden-pattern/context-sensitive TRS expected";
        EQ_input _ ->
          errora "outermost/forbidden-pattern/context-sensitive TRS expected";
        CPX_input _ ->
          errora "outermost/forbidden-pattern/context-sensitive TRS expected";
        FP_TRS_input (fp, r) -> returna (strategy_to_fp fp r, r);
        CTRS_input _ ->
          errora "outermost/forbidden-pattern/context-sensitive TRS expected";
        Unknown_input _ ->
          errora "outermost/forbidden-pattern/context-sensitive TRS expected";
      }));

xml2inn_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Bool,
                       ([Term (Lab a b) [Prelude.Char]],
                         [(Term (Lab a b) [Prelude.Char],
                            Term (Lab a b) [Prelude.Char])]));
xml2inn_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ -> errora "(innermost) TRS without relative rules expected";
        Inn_TRS_input (inn, (r, Nothing)) ->
          returna (default_nfs_nt_trs, (strategy_to_Q inn r, r));
        Inn_TRS_input (_, (_, Just _)) ->
          errora "(innermost) TRS without relative rules expected";
        COMP_input _ ->
          errora "(innermost) TRS without relative rules expected";
        EQ_input _ -> errora "(innermost) TRS without relative rules expected";
        CPX_input _ -> errora "(innermost) TRS without relative rules expected";
        FP_TRS_input _ ->
          errora "(innermost) TRS without relative rules expected";
        CTRS_input _ ->
          errora "(innermost) TRS without relative rules expected";
        Unknown_input _ ->
          errora "(innermost) TRS without relative rules expected";
      }));

xml2reltrs_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Reltrs_nontermination_proof a b [Prelude.Char]);
xml2reltrs_nontermination_proof xml2name x =
  singleton "relativeNonterminationProof"
    (options
      [("variableConditionViolated",
         leaf "variableConditionViolated" Rel_Not_Well_Formed),
        ("loop",
          change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              Rel_Loop (Rel_trs_loop_prf s rseq sigma c))),
        ("trsNonterminationProof",
          change (xml2trs_nontermination_proof xml2name) Rel_R_Not_SN),
        ("ruleRemoval",
          triple "ruleRemoval" (singleton "trs" (rules xml2name) Just)
            (singleton "trs" (rules xml2name) Just)
            (xml2reltrs_nontermination_proof xml2name)
            (\ r s -> Rel_Rule_Removal (Rule_removal_nonterm_reltrs_prf r s))),
        ("stringReversal",
          triple "stringReversal" (singleton "trs" (rules xml2name) Just)
            (singleton "trs" (rules xml2name) Just)
            (xml2reltrs_nontermination_proof xml2name)
            (\ _ _ -> Rel_TRS_String_Reversal)),
        ("nonterminationAssumption",
          singleton "nonterminationAssumption"
            (xml2inn_rel_nt_trs_assm xml2name)
            (\ qtrs -> Rel_TRS_Assume_Not_SN qtrs [])),
        ("unknownProof",
          many2 "unknownProof" (text "description")
            (xml2inn_rel_nt_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail "subProof" xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == "tr"
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == "dp"
then pair "subProof" (xml2dp_inputa False xml2name)
       (xml2dp_nontermination_proof xml2name) Infinite_assm_proof xa
else (if inp == "re"
       then pair "subProof" (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == "un"
              then pair "subProof" xml2unknown_input
                     (xml2unknown_disproof xml2name) Unknown_assm_proof xa
              else fail "subProof" xa))))))
            (\ _ -> Rel_TRS_Assume_Not_SN))])
    id x;

xml2trs_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Trs_nontermination_proof a b [Prelude.Char]);
xml2trs_nontermination_proof xml2name x =
  singleton "trsNonterminationProof"
    (options
      [("variableConditionViolated",
         leaf "variableConditionViolated" TRS_Not_Well_Formed),
        ("loop",
          change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              TRS_Loop
                (TRS_loop_prf s (map (\ (xa, (y, (_, z))) -> (xa, (y, z))) rseq)
                  sigma c))),
        ("nonLoop", change (nonloop xml2name) TRS_Nonloop),
        ("nonterminatingSRS", change (nonloop_srs xml2name) TRS_Nonloop_SRS),
        ("ruleRemoval",
          pair "ruleRemoval" (singleton "trs" (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ r -> TRS_Rule_Removal (Rule_removal_nonterm_trs_prf r))),
        ("dpTrans",
          triple "dpTrans" (singleton "dps" (rules xml2name) id)
            (bool "markedSymbols") (xml2dp_nontermination_proof xml2name)
            (\ p _ -> TRS_DP_Trans (DP_trans_nontermination_tt_prf p))),
        ("stringReversal",
          pair "stringReversal" (singleton "trs" (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ _ -> TRS_String_Reversal)),
        ("constantToUnary",
          tuple4 "constantToUnary" plain_var (renaming xml2name)
            (singleton "trs" (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ v ren s ->
              TRS_Constant_String (Const_string_complete_proof v ren s))),
        ("innermostLhssIncrease",
          pair "innermostLhssIncrease" (innermostLhss xml2name)
            (xml2trs_nontermination_proof xml2name)
            (\ q -> TRS_Q_Increase (Q_increase_nonterm_trs_prf q))),
        ("switchFullStrategy",
          pair "switchFullStrategy" (wcr_proof xml2name)
            (xml2trs_nontermination_proof xml2name) TRS_Termination_Switch),
        ("uncurry",
          triple "uncurry" (uncurry_info xml2name)
            (singleton "trs" (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ i r -> TRS_Uncurry (Uncurry_nt_proof i r))),
        ("nonterminationAssumption",
          singleton "nonterminationAssumption" (xml2inn_nt_trs_assm xml2name)
            (\ qtrs -> TRS_Assume_Not_SN qtrs [])),
        ("unknownProof",
          many2 "unknownProof" (text "description")
            (xml2inn_nt_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail "subProof" xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == "tr"
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == "dp"
then pair "subProof" (xml2dp_inputa False xml2name)
       (xml2dp_nontermination_proof xml2name) Infinite_assm_proof xa
else (if inp == "re"
       then pair "subProof" (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == "un"
              then pair "subProof" xml2unknown_input
                     (xml2unknown_disproof xml2name) Unknown_assm_proof xa
              else fail "subProof" xa))))))
            (\ _ -> TRS_Assume_Not_SN))])
    id x;

xml2fp_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Fp_nontermination_proof a b [Prelude.Char]);
xml2fp_nontermination_proof xml2name x =
  singleton "trsNonterminationProof"
    (options
      [("loop",
         change (loop xml2name)
           (\ (s, (rseq, (sigma, c))) ->
             FPTRS_Loop
               (FP_loop_prf c sigma s
                 (map (\ (xa, (y, (_, z))) -> (xa, (y, z))) rseq)))),
        ("ruleRemoval",
          pair "ruleRemoval" (singleton "trs" (rules xml2name) id)
            (xml2fp_nontermination_proof xml2name)
            (\ r -> FPTRS_Rule_Removal (Rule_removal_nonterm_trs_prf r))),
        ("nonterminationAssumption",
          singleton "nonterminationAssumption" (xml2fp_nt_trs_assm xml2name)
            (\ qtrs -> FPTRS_Assume_Not_SN qtrs [])),
        ("unknownProof",
          many2 "unknownProof" (text "description")
            (xml2fp_nt_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail "subProof" xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == "tr"
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == "dp"
then pair "subProof" (xml2dp_inputa False xml2name)
       (xml2dp_nontermination_proof xml2name) Infinite_assm_proof xa
else (if inp == "re"
       then pair "subProof" (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == "un"
              then pair "subProof" xml2unknown_input
                     (xml2unknown_disproof xml2name) Unknown_assm_proof xa
              else fail "subProof" xa))))))
            (\ _ -> FPTRS_Assume_Not_SN))])
    id x;

xml2dp_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Dp_nontermination_proof a b [Prelude.Char]);
xml2dp_nontermination_proof xml2name x =
  singleton "dpNonterminationProof"
    (options
      [("dpRuleRemoval",
         choice "dpRuleRemoval"
           [triple "dpRuleRemoval" (singleton "dps" (rules xml2name) Just)
              (singleton "trs" (rules xml2name) Just)
              (xml2dp_nontermination_proof xml2name)
              (\ p r -> DP_Rule_Removal (Rule_removal_nonterm_dp_prf p r)),
             pair "dpRuleRemoval" (singleton "trs" (rules xml2name) Just)
               (xml2dp_nontermination_proof xml2name)
               (\ r -> DP_Rule_Removal (Rule_removal_nonterm_dp_prf Nothing r)),
             pair "dpRuleRemoval" (singleton "dps" (rules xml2name) Just)
               (xml2dp_nontermination_proof xml2name)
               (\ p ->
                 DP_Rule_Removal (Rule_removal_nonterm_dp_prf p Nothing))]),
        ("loop",
          change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              DP_Loop (DP_loop_prf s rseq sigma c))),
        ("nonLoop", change (nonloop xml2name) DP_Nonloop),
        ("innermostLhssRemovalProc",
          pair "innermostLhssRemovalProc" (innermostLhss xml2name)
            (xml2dp_nontermination_proof xml2name)
            (\ q -> DP_Q_Reduction (DP_q_reduction_nonterm_prf q))),
        ("innermostLhssIncreaseProc",
          pair "innermostLhssIncreaseProc" (innermostLhss xml2name)
            (xml2dp_nontermination_proof xml2name)
            (\ q -> DP_Q_Increase (Q_increase_nonterm_dp_prf q))),
        ("instantiationProc",
          pair "instantiationProc" (singleton "dps" (rules xml2name) id)
            (xml2dp_nontermination_proof xml2name)
            (\ p -> DP_Instantiation (Instantiation_complete_proc_prf p))),
        ("narrowingProc",
          tuple4 "narrowingProc" (rule xml2name) pos
            (singleton "narrowings" (rules xml2name) id)
            (xml2dp_nontermination_proof xml2name)
            (\ st po p -> DP_Narrowing (Narrowing_complete_proc_prf st po p))),
        ("rewritingProc",
          guard (\ xa -> equal_nat (num_children xa) (Nat_of_num (Bit1 One)))
            (triple "rewritingProc" (rule xml2name) (rstep xml2name)
              (xml2dp_nontermination_proof xml2name)
              (\ (s, t) (p, (lr, ta)) ->
                DP_Rewriting
                  (Rewriting_complete_proc_prf Nothing (s, t) (s, ta) (s, ta) lr
                    p)))
            (guard
              (\ xa ->
                equal_nat (num_children xa) (Nat_of_num (Bit0 (Bit0 One))))
              (guard
                (\ xa ->
                  tag (nth (children xa) (Nat_of_num (Bit0 One))) ==
                    "usableRules")
                (tuple4 "rewritingProc" (rule xml2name) (rstep xml2name)
                  (singleton "usableRules" (rules xml2name) id)
                  (xml2dp_nontermination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) u ->
                    DP_Rewriting
                      (Rewriting_complete_proc_prf (Just u) (s, t) (s, ta)
                        (s, ta) lr p)))
                (tuple4 "rewritingProc" (rule xml2name) (rstep xml2name)
                  (rule xml2name) (xml2dp_nontermination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) st ->
                    DP_Rewriting
                      (Rewriting_complete_proc_prf Nothing (s, t) (s, ta) st lr
                        p))))
              (tuple5 "rewritingProc" (rule xml2name) (rstep xml2name)
                (rule xml2name) (singleton "usableRules" (rules xml2name) id)
                (xml2dp_nontermination_proof xml2name)
                (\ (s, t) (p, (lr, ta)) st u ->
                  DP_Rewriting
                    (Rewriting_complete_proc_prf (Just u) (s, t) (s, ta) st lr
                      p))))),
        ("switchFullStrategyProc",
          pair "switchFullStrategyProc" (wcr_proof xml2name)
            (xml2dp_nontermination_proof xml2name) DP_Termination_Switch),
        ("nonterminationAssumption",
          singleton "nonterminationAssumption" (xml2dp_inputa False xml2name)
            (\ qdp -> DP_Assume_Infinite qdp [])),
        ("unknownProof",
          many2 "unknownProof" (text "description")
            (xml2dp_inputa False xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail "subProof" xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == "tr"
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == "dp"
then pair "subProof" (xml2dp_inputa False xml2name)
       (xml2dp_nontermination_proof xml2name) Infinite_assm_proof xa
else (if inp == "re"
       then pair "subProof" (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == "un"
              then pair "subProof" xml2unknown_input
                     (xml2unknown_disproof xml2name) Unknown_assm_proof xa
              else fail "subProof" xa))))))
            (\ _ -> DP_Assume_Infinite))])
    id x;

xml2unknown_disproof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Neg_unknown_proof a b [Prelude.Char]);
xml2unknown_disproof xml2name x =
  singleton "unknownInputProof"
    (options
      [("unknownAssumption",
         singleton "unknownAssumption" xml2unknown_input
           (\ u -> Assume_NT_Unknown u [])),
        ("unknownProof",
          many2 "unknownProof" (text "description") xml2unknown_input
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail "subProof" xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == "tr"
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == "dp"
then pair "subProof" (xml2dp_inputa False xml2name)
       (xml2dp_nontermination_proof xml2name) Infinite_assm_proof xa
else (if inp == "re"
       then pair "subProof" (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == "un"
              then pair "subProof" xml2unknown_input
                     (xml2unknown_disproof xml2name) Unknown_assm_proof xa
              else fail "subProof" xa))))))
            (\ _ -> Assume_NT_Unknown))])
    id x;

xml2quasi_reductive_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Quasi_reductive_proof a [Nat] [Prelude.Char]);
xml2quasi_reductive_proof xml2name =
  singleton "quasiReductiveProof"
    (options
      [("unraveling",
         pair "unraveling" (unraveling_info xml2name)
           (xml2trs_termination_proof xml2name) Unravel)])
    id;

xml2conditional_cr_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Conditional_cr_proof a [Nat] [Prelude.Char]);
xml2conditional_cr_proof xml2name =
  singleton "conditionalCrProof"
    (options
      [("unraveling",
         pair "unraveling" (unraveling_info xml2name) (xml2cr_proof xml2name)
           Unravel_CR)])
    id;

subsumption_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]),
             [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                      (Bool, Term a [Prelude.Char])))])];
subsumption_proof xml2name =
  many "subsumptionProof"
    (pair "ruleSubsumptionProof" (rule xml2name) (conversion xml2name)
      (\ a b -> (a, b)))
    id;

xml2completion_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Completion_proof a [Nat] [Prelude.Char]);
xml2completion_proof xml2name =
  triple "completionProof" (wcr_proof xml2name)
    (xml2trs_termination_proof xml2name)
    (xml1to2elements "equivalenceProof" (subsumption_proof xml2name)
      (subsumption_proof xml2name) (\ a b -> (a, b)))
    (\ w t (a, b) -> SN_WCR_Eq w t a b);

xml2equational_disproof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Equational_disproof a [Nat] [Prelude.Char]);
xml2equational_disproof xml2name =
  singleton "equationalDisproof"
    (options
      [("completionAndNormalization",
         pair "completionAndNormalization" (singleton "trs" (rules xml2name) id)
           (xml2completion_proof xml2name)
           Completion_and_Normalization_Different)])
    id;

xml2equational_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Equational_proof a [Nat] [Prelude.Char]);
xml2equational_proof xml2name =
  singleton "equationalProof"
    (options
      [("equationalProofTree",
         singleton "equationalProofTree" (xml2eq_proof xml2name)
           Equational_Proof_Tree),
        ("conversion", change (conversion xml2name) Conversion),
        ("subsumptionProof",
          change (subsumption_proof xml2name) Conversion_With_History),
        ("completionAndNormalization",
          pair "completionAndNormalization"
            (singleton "trs" (rules xml2name) id)
            (xml2completion_proof xml2name) Completion_and_Normalization)])
    id;

xml2complexity_inputa ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     ([Term (Lab a b) [Prelude.Char]],
                       ([(Term (Lab a b) [Prelude.Char],
                           Term (Lab a b) [Prelude.Char])],
                         ([(Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char])],
                           (Complexity_measure (Lab a b) [Prelude.Char],
                             Complexity_class))));
xml2complexity_inputa xml2name =
  change (xml2complexity_input xml2name)
    (\ (q, (s, (w, (cm, cc)))) ->
      (strategy_to_Q q (s ++ rel_rules_of w), (s, (rel_rules_of w, (cm, cc)))));

xml2complexity_proof ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char] (Complexity_proof a b [Prelude.Char]);
xml2complexity_proof xml2name x =
  singleton "complexityProof"
    (options
      [("ruleShifting",
         guard (\ xa -> equal_nat (num_children xa) (Nat_of_num (Bit1 One)))
           (triple "ruleShifting" (ordering_constraint_proof True xml2name)
             (singleton "trs" (rules xml2name) id)
             (xml2complexity_proof xml2name)
             (\ rp del -> Rule_Shift_Complexity rp del Nothing))
           (tuple4 "ruleShifting" (ordering_constraint_proof True xml2name)
             (singleton "trs" (rules xml2name) id)
             (singleton "usableRules" (rules xml2name) Just)
             (xml2complexity_proof xml2name) Rule_Shift_Complexity)),
        ("usableRules",
          pair "usableRules" (singleton "nonUsableRules" (rules xml2name) id)
            (xml2complexity_proof xml2name) Usable_Rules_Complexity),
        ("split",
          triple "split" (singleton "trs" (rules xml2name) id)
            (xml2complexity_proof xml2name) (xml2complexity_proof xml2name)
            Split_Complexity),
        ("removeNonApplicableRules",
          pair "removeNonApplicableRules" (singleton "trs" (rules xml2name) id)
            (xml2complexity_proof xml2name)
            Remove_Nonapplicable_Rules_Complexity),
        ("bounds", change (bounds_info xml2name) Matchbounds_Complexity),
        ("relativeBounds",
          triple "relativeBounds" (bounds_info xml2name)
            (singleton "trs" (rules xml2name) id)
            (xml2complexity_proof xml2name) Matchbounds_Rel_Complexity),
        ("rIsEmpty", leaf "rIsEmpty" RisEmpty_Complexity),
        ("dtTransformation",
          tuple4 "dtTransformation"
            (rule_pairs "strictDTs" "ruleWithDT" xml2name)
            (rule_pairs "weakDTs" "ruleWithDT" xml2name)
            (innermostLhss xml2name) (xml2complexity_proof xml2name)
            (\ s w inn -> DT_Transformation (DT_Transformation_Info s w inn))),
        ("wdpTransformation",
          tuple5 "wdpTransformation" (symbols "compoundSymbols" xml2name)
            (rule_pairs "strictWDPs" "ruleWithWDP" xml2name)
            (rule_pairs "weakWDPs" "ruleWithWDP" xml2name)
            (innermostLhss xml2name) (xml2complexity_proof xml2name)
            (\ comp s w q ->
              WDP_Transformation (WDP_Trans_Info (set comp) s w q))),
        ("unknownProof",
          many2 "unknownProof" (text "description")
            (xml2complexity_inputa xml2name)
            (pair "subProof" (xml2complexity_inputa xml2name)
              (xml2complexity_proof xml2name) Complexity_assm_proof)
            (\ _ -> Complexity_Assumption)),
        ("complexityAssumption",
          singleton "complexityAssumption" (xml2complexity_inputa xml2name)
            (\ p -> Complexity_Assumption p []))])
    id x;

xml2cert_problem ::
  (Xml -> Sum_bot [Prelude.Char] [Prelude.Char]) ->
    (Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat])) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Cert_problem [Prelude.Char] [Nat] [Prelude.Char]);
xml2cert_problem xml2uname xml2name (XML name egal cs) =
  (if name == "certificationProblem" &&
        less_eq_nat (Nat_of_num (Bit1 One)) (size_list cs)
    then binda (xml2input xml2name (nth cs Zero_nat))
           (\ inp ->
             binda (text "cpfVersion" (nth cs (Nat_of_num One)))
               (\ _ ->
                 (case inp of {
                   DP_input (m, (p, (q, r))) ->
                     singleton "proof"
                       (options
                         [("dpProof",
                            change (xml2dp_termination_proof xml2name)
                              (DP_Termination_Proof default_nfs_dp m p [] q []
                                r)),
                           ("dpNonterminationProof",
                             change (xml2dp_nontermination_proof xml2name)
                               (DP_Nontermination_Proof default_nfs_dp m p q
                                 r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   Inn_TRS_input (q, (r, Nothing)) ->
                     singleton "proof"
                       (options
                         [("trsTerminationProof",
                            change (xml2trs_termination_proof xml2name)
                              (TRS_Termination_Proof default_nfs_trs q r
                                Nothing)),
                           ("crProof",
                             (if null (strategy_to_Q q r)
                               then change (xml2cr_proof xml2name)
                                      (TRS_Confluence_Proof False r)
                               else (\ _ ->
                                      errora
"strategies for confluence unsupported"))),
                           ("crDisproof",
                             (if null (strategy_to_Q q r)
                               then change (xml2ncr_proof xml2name)
                                      (TRS_Non_Confluence_Proof False r)
                               else (\ _ ->
                                      errora
"strategies for confluence unsupported"))),
                           ("trsNonterminationProof",
                             change (xml2trs_nontermination_proof xml2name)
                               (TRS_Nontermination_Proof default_nfs_trs q r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   Inn_TRS_input (q, (r, Just s)) ->
                     singleton "proof"
                       (options
                         [("relativeTerminationProof",
                            change (xml2trs_termination_proof xml2name)
                              (TRS_Termination_Proof default_nfs_trs q r
                                (Just s))),
                           ("relativeNonterminationProof",
                             change (xml2reltrs_nontermination_proof xml2name)
                               (Relative_TRS_Nontermination_Proof
                                 default_nfs_trs q r s))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   COMP_input (e, r) ->
                     singleton "proof"
                       (options
                         [("completionProof",
                            change (xml2completion_proof xml2name)
                              (Completion_Proof e r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   EQ_input (eqs, eq) ->
                     singleton "proof"
                       (options
                         [("equationalProof",
                            change (xml2equational_proof xml2name)
                              (Equational_Proof eqs eq)),
                           ("equationalDisproof",
                             change (xml2equational_disproof xml2name)
                               (Equational_Disproof eqs eq))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   CPX_input (q, (r, (s, (cm, cc)))) ->
                     singleton "proof"
                       (change (xml2complexity_proof xml2name)
                         (Complexity_Proof q r s cm cc))
                       id (nth cs (Nat_of_num (Bit0 One)));
                   FP_TRS_input (Outermost, r) ->
                     singleton "proof"
                       (options
                         [("trsTerminationProof",
                            change (xml2fptrs_termination_proof xml2name)
                              (Outermost_Termination_Proof r)),
                           ("trsNonterminationProof",
                             change (xml2fp_nontermination_proof xml2name)
                               (Outermost_Nontermination_Proof r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   FP_TRS_input (Context_Sensitive mu, r) ->
                     singleton "proof"
                       (options
                         [("trsTerminationProof",
                            change (xml2fptrs_termination_proof xml2name)
                              (CS_Termination_Proof mu r)),
                           ("trsNonterminationProof",
                             change (xml2fp_nontermination_proof xml2name)
                               (CS_Nontermination_Proof mu r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   FP_TRS_input (Forbidden_Patterns p, r) ->
                     singleton "proof"
                       (options
                         [("trsTerminationProof",
                            change (xml2fptrs_termination_proof xml2name)
                              (FP_Termination_Proof p r)),
                           ("trsNonterminationProof",
                             change (xml2fp_nontermination_proof xml2name)
                               (FP_Nontermination_Proof p r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   CTRS_input ctrs ->
                     singleton "proof"
                       (options
                         [("quasiReductiveProof",
                            change (xml2quasi_reductive_proof xml2name)
                              (Quasi_Reductive_Proof ctrs)),
                           ("conditionalCrProof",
                             change (xml2conditional_cr_proof xml2name)
                               (Conditional_CR_Proof ctrs))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   Unknown_input u ->
                     singleton "proof"
                       (choice "unknownInput"
                         [change (xml2unknown_proof xml2name) (Unknown_Proof u),
                           change (xml2unknown_disproof xml2name)
                             (Unknown_Disproof u)])
                       id (nth cs (Nat_of_num (Bit0 One)));
                 })))
    else errora ("could not parse root element <" ++ name ++ ">"));
xml2cert_problem uu uv (XML_text v) = fail "certificationProblem" (XML_text v);

xml_complexity_measure ::
  forall a b c. (Showa a, Showa b) => Complexity_measure (Lab a [b]) c -> Xml;
xml_complexity_measure (Derivational_Complexity f) =
  XML "derivationalComplexity" [] [xml_signature f];
xml_complexity_measure (Runtime_Complexity c d) =
  XML "runtimeComplexity" [] [xml_signature c, xml_signature d];

xml_complexity_class :: Complexity_class -> Xml;
xml_complexity_class (Comp_Poly n) =
  XML "polynomial" [] [XML_text (shows_prec_nat Zero_nat n [])];

xml_cert_problem ::
  forall a b c. (Showa a, Showa b, Showa c) => Cert_problem a [b] c -> Xml;
xml_cert_problem (TRS_Termination_Proof nfs q r s_o uu) =
  xml_trs_input (Inl q) r s_o;
xml_cert_problem (TRS_Nontermination_Proof nfs q r uv) =
  xml_trs_input (Inl q) r Nothing;
xml_cert_problem (Outermost_Nontermination_Proof r uw) =
  xml_trs_input (Inr Outermost) r Nothing;
xml_cert_problem (Outermost_Termination_Proof r ux) =
  xml_trs_input (Inr Outermost) r Nothing;
xml_cert_problem (FP_Nontermination_Proof p r uy) =
  xml_trs_input (Inr (Forbidden_Patterns p)) r Nothing;
xml_cert_problem (FP_Termination_Proof p r uz) =
  xml_trs_input (Inr (Forbidden_Patterns p)) r Nothing;
xml_cert_problem (CS_Nontermination_Proof mu r va) =
  xml_trs_input (Inr (Context_Sensitive mu)) r Nothing;
xml_cert_problem (CS_Termination_Proof mu r vb) =
  xml_trs_input (Inr (Context_Sensitive mu)) r Nothing;
xml_cert_problem (Relative_TRS_Nontermination_Proof nfs q r s vc) =
  xml_trs_input (Inl q) r (Just s);
xml_cert_problem (DP_Termination_Proof nfs m p pw q r rw vd) =
  XML "dpInput" []
    (xml_rules "trs" rw :
      xml_rules "dps" p :
        xml_strategy (Inl q) ++
          [XML "minimal" [] [XML_text (if m then "true" else "false")]]);
xml_cert_problem (DP_Nontermination_Proof nfs m p q r ve) =
  XML "dpInput" []
    (xml_rules "trs" r :
      xml_rules "dps" p :
        xml_strategy (Inl q) ++
          [XML "minimal" [] [XML_text (if m then "true" else "false")]]);
xml_cert_problem (TRS_Confluence_Proof nfs r vf) =
  xml_trs_input (Inl No_Strategy) r Nothing;
xml_cert_problem (TRS_Non_Confluence_Proof nfs r vg) =
  xml_trs_input (Inl No_Strategy) r Nothing;
xml_cert_problem (Completion_Proof e r vh) =
  XML "completionInput" [] [xml_rules "equations" e, xml_rules "trs" r];
xml_cert_problem (Equational_Proof e eq vi) =
  XML "equationalReasoningInput" []
    [xml_rules "equations" e,
      XML "equation" [] [xml_term (fst eq), xml_term (snd eq)]];
xml_cert_problem (Equational_Disproof e eq vj) =
  XML "equationalReasoningInput" []
    [xml_rules "equations" e,
      XML "equation" [] [xml_term (fst eq), xml_term (snd eq)]];
xml_cert_problem (Complexity_Proof q r s cm cc vk) =
  XML "complexityInput" []
    [xml_trs_input (Inl q) r s, xml_complexity_measure cm,
      xml_complexity_class cc];
xml_cert_problem (Quasi_Reductive_Proof ctrs vl) = xml_ctrs_input ctrs;
xml_cert_problem (Conditional_CR_Proof ctrs vm) = xml_ctrs_input ctrs;
xml_cert_problem (Unknown_Proof u vn) = XML "unknownInput" [] [XML_text u];
xml_cert_problem (Unknown_Disproof u vo) = XML "unknownInput" [] [XML_text u];

rules_non_collapsing_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
rules_non_collapsing_impl (uu, (uv, (uw, (ux, (uy, (uz, (nc, va))))))) = nc;

impl_ofd ::
  forall b a.
    (Key b) => Dpp b a ->
                 (Bool,
                   (Bool,
                     ([(Term b a, Term b a)],
                       ([(Term b a, Term b a)],
                         ([Term b a],
                           (Bool,
                             (Bool,
                               ([(Term b a, Term b a)],
                                 ([(Term b a, Term b a)],
                                   (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                                     (Rbt (b, Nat)
[(Bool, (Term b a, Term b a))],
                                       (Bool, Term b a -> Bool))))))))))));
impl_ofd (DPP x) = x;

rules_non_collapsing :: forall a b. (Key a) => Dpp a b -> Bool;
rules_non_collapsing d = rules_non_collapsing_impl (impl_ofd d);

nFQ_subset_NF_rules_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
nFQ_subset_NF_rules_impla (uu, (uv, (uw, (ux, (uy, (b, uz)))))) = b;

nFQ_subset_NF_rulesa :: forall a b. (Key a) => Dpp a b -> Bool;
nFQ_subset_NF_rulesa d = nFQ_subset_NF_rules_impla (impl_ofd d);

rules_no_left_var_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
rules_no_left_var_impl (uu, (uv, (uw, (ux, (uy, (uz, (va, ([], ([], vb)))))))))
  = True;
rules_no_left_var_impl (v, (vb, (ve, (vg, (vi, (vk, (vm, (vq : vr, vp)))))))) =
  False;
rules_no_left_var_impl
  (v, (vb, (ve, (vg, (vi, (vk, (vm, (vo, (vs : vt, vr))))))))) = False;

rules_no_left_var :: forall a b. (Key a) => Dpp a b -> Bool;
rules_no_left_var d = rules_no_left_var_impl (impl_ofd d);

reverse_rules_map_impl ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_map_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (m, ve))))))))))) fn =
  (case lookup m fn of {
    Nothing -> [];
    Just a -> map snd a;
  });

reverse_rules_map ::
  forall a b. (Key a) => Dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_map d = reverse_rules_map_impl (impl_ofd d);

is_NF_trs_subset ::
  forall a b. (Term a b -> Bool) -> [(Term a b, Term a b)] -> Bool;
is_NF_trs_subset is_Q_nf r = is_NF_subset is_Q_nf (map fst r);

wwf_qtrs_impl ::
  forall a b. (Eq b) => (Term a b -> Bool) -> [(Term a b, Term a b)] -> Bool;
wwf_qtrs_impl nf r =
  all (\ ra -> wf_rule ra || not (applicable_rule_impl nf ra)) r;

intersect_rules_impl ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   (Bool,
                     (Bool,
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([Term a b],
                             (Bool,
                               (Bool,
                                 ([(Term a b, Term a b)],
                                   ([(Term a b, Term a b)],
                                     (Rbt (a, Nat)
[(Bool, (Term a b, Term a b))],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Bool, Term a b -> Bool))))))))))));
intersect_rules_impl d ri =
  let {
    (nfs, (mi, (p, (pw, (q, (nfq, (nc, (vR,
 (vRw, (m, (rm, (wwf, isnf))))))))))))
      = d;
    (vri, ria) = partition (is_Var . fst) ri;
    vr = list_inter vR vri;
    vrw = list_inter vRw vri;
    ma = intersect_rules ria m;
    rma = intersect_rules (reverse_rules ri) rm;
    rs = vr ++ vrw ++ map snd (values ma);
  } in (nfs, (mi, (p, (pw, (q, (nfq || is_NF_trs_subset isnf rs,
                                 (nc || all (\ r -> not (is_Var (snd r))) rs,
                                   (vr, (vrw,
  (ma, (rma, (wwf || wwf_qtrs_impl isnf rs, isnf))))))))))));

intersect_rulesa ::
  forall a b.
    (Eq a, Key a, Eq b) => Dpp a b -> [(Term a b, Term a b)] -> Dpp a b;
intersect_rulesa d rs = DPP (intersect_rules_impl (impl_ofd d) rs);

intersect_pairs_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   (Bool,
                     (Bool,
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([Term a b],
                             (Bool,
                               (Bool,
                                 ([(Term a b, Term a b)],
                                   ([(Term a b, Term a b)],
                                     (Rbt (a, Nat)
[(Bool, (Term a b, Term a b))],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Bool, Term a b -> Bool))))))))))));
intersect_pairs_impl (nfs, (mi, (p, (pw, rest)))) ps =
  (nfs, (mi, (list_inter p ps, (list_inter pw ps, rest))));

intersect_pairs ::
  forall a b.
    (Eq a, Key a, Eq b) => Dpp a b -> [(Term a b, Term a b)] -> Dpp a b;
intersect_pairs d ps = DPP (intersect_pairs_impl (impl_ofd d) ps);

replace_pair_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (Term a b, Term a b) ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
replace_pair_impl (nfs, (mi, (p, (pw, rest)))) pair ps =
  (nfs, (mi, (replace_impl pair ps p, (replace_impl pair ps pw, rest))));

replace_pair ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 (Term a b, Term a b) -> [(Term a b, Term a b)] -> Dpp a b;
replace_pair d pair ps = DPP (replace_pair_impl (impl_ofd d) pair ps);

rules_implb ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)];
rules_implb (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vrw, (m, vb)))))))))) =
  vr ++ vrw ++ map snd (values m);

split_rules_impla ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules_impla d rs = partition (membera rs) (rules_implb d);

split_rulesa ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rulesa d = split_rules_impla (impl_ofd d);

pairs_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
pairs_impl (uu, (uv, (p, (pw, uw)))) = p ++ pw;

split_pairs_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_pairs_impl d ps = partition (membera ps) (pairs_impl d);

split_pairs ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_pairs d = split_pairs_impl (impl_ofd d);

delete_R_Rw_impla ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
delete_R_Rw_impla d r rw =
  let {
    (nfs, (mi, (p, (pw, (q, (nfq, (nc, (vR,
 (vRw, (m, (rm, (wwf, isnf))))))))))))
      = d;
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    vra = list_diff vR vr;
    vrwa = list_diff vRw vrw;
    ma = delete_rules True ra (delete_rules False rwa m);
    rma = delete_rules True (reverse_rules r)
            (delete_rules False (reverse_rules rw) rm);
    rs = vra ++ vrwa ++ map snd (values ma);
  } in (nfs, (mi, (p, (pw, (q, (nfq || is_NF_trs_subset isnf rs,
                                 (nc || all (\ rb -> not (is_Var (snd rb))) rs,
                                   (vra, (vrwa,
   (ma, (rma, (wwf || wwf_qtrs_impl isnf rs, isnf))))))))))));

delete_R_Rwa ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Dpp a b;
delete_R_Rwa d r rw = DPP (delete_R_Rw_impla (impl_ofd d) r rw);

delete_P_Pw_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
   (Bool, Term a b -> Bool))))))))))));
delete_P_Pw_impl (nfs, (mi, (p, (pw, rest)))) pd pwd =
  (nfs, (mi, (list_diff p pd, (list_diff pw pwd, rest))));

delete_P_Pw ::
  forall a b.
    (Eq a, Key a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Dpp a b;
delete_P_Pw d p pw = DPP (delete_P_Pw_impl (impl_ofd d) p pw);

rules_map_impla ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
rules_map_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (m, vd)))))))))) fn
  = (case lookup m fn of {
      Nothing -> [];
      Just a -> map snd a;
    });

rules_mapa ::
  forall a b. (Key a) => Dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_mapa d = rules_map_impla (impl_ofd d);

wwf_rules_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
wwf_rules_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, (wwf, vf)))))))))))) =
  wwf;

wwf_rules :: forall a b. (Key a) => Dpp a b -> Bool;
wwf_rules d = wwf_rules_impl (impl_ofd d);

q_empty_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
q_empty_impla (uu, (uv, (uw, (ux, (q, uy))))) = null q;

q_emptya :: forall a b. (Key a) => Dpp a b -> Bool;
q_emptya d = q_empty_impla (impl_ofd d);

is_QNF_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Term a b -> Bool;
is_QNF_impla
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, (vf, isnf)))))))))))) =
  isnf;

is_QNFa :: forall a b. (Key a) => Dpp a b -> Term a b -> Bool;
is_QNFa d = is_QNF_impla (impl_ofd d);

rulesb :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
rulesb d = rules_implb (impl_ofd d);

pairs :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
pairs d = pairs_impl (impl_ofd d);

dpp_impl ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 (Bool,
                   (Bool,
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b),
                         (Set (Term a b),
                           (Set (Term a b, Term a b),
                             Set (Term a b, Term a b)))))));
dpp_impl (nfs, (mi, (p, (pw, (q, (uu, (uv, (vr, (vrw, (m, uw)))))))))) =
  (nfs, (mi, (set p,
               (set pw,
                 (set q,
                   (set (vr ++ rules_with id m),
                     set (vrw ++ rules_with not m)))))));

dpp ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => Dpp a b ->
                 (Bool,
                   (Bool,
                     (Set (Term a b, Term a b),
                       (Set (Term a b, Term a b),
                         (Set (Term a b),
                           (Set (Term a b, Term a b),
                             Set (Term a b, Term a b)))))));
dpp d = dpp_impl (impl_ofd d);

nfs_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
nfs_impla (nfs, uu) = nfs;

nfsa :: forall a b. (Key a) => Dpp a b -> Bool;
nfsa d = nfs_impla (impl_ofd d);

mk_impla ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 [Term a b] ->
                                   [(Term a b, Term a b)] ->
                                     [(Term a b, Term a b)] ->
                                       (Bool,
 (Bool,
   ([(Term a b, Term a b)],
     ([(Term a b, Term a b)],
       ([Term a b],
         (Bool,
           (Bool,
             ([(Term a b, Term a b)],
               ([(Term a b, Term a b)],
                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                     (Bool, Term a b -> Bool))))))))))));
mk_impla nfs mi p pw q r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    rs = r ++ rw;
    isnf = is_NF_terms q;
  } in (nfs, (mi, (p, (pw, (q, (is_NF_trs_subset isnf rs,
                                 (all (\ rb -> not (is_Var (snd rb))) rs,
                                   (vr, (vrw,
  (insert_rules True ra (insert_rules False rwa empty),
    (insert_rules True (reverse_rules r)
       (insert_rules False (reverse_rules rw) empty),
      (wwf_qtrs_impl isnf rs, isnf))))))))))));

mka ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 [Term a b] ->
                                   [(Term a b, Term a b)] ->
                                     [(Term a b, Term a b)] -> Dpp a b;
mka nfs mi p pw q r rw = DPP (mk_impla nfs mi p pw q r rw);

rw_impla ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)];
rw_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vrw, (m, vc)))))))))) =
  vrw ++ rules_with not m;

rwa :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
rwa d = rw_impla (impl_ofd d);

pw_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
pw_impl (uu, (uv, (uw, (pw, ux)))) = pw;

pw :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
pw d = pw_impl (impl_ofd d);

r_impla ::
  forall a b.
    (Key a) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     (Bool, Term a b -> Bool)))))))))))) ->
                 [(Term a b, Term a b)];
r_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vb, (m, vc)))))))))) =
  vr ++ rules_with id m;

ra :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
ra d = r_impla (impl_ofd d);

q_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [Term a b];
q_impla (uu, (uv, (uw, (ux, (q, uy))))) = q;

qa :: forall a b. (Key a) => Dpp a b -> [Term a b];
qa d = q_impla (impl_ofd d);

p_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      [(Term a b, Term a b)];
p_impl (uu, (uv, (p, uw))) = p;

p :: forall a b. (Key a) => Dpp a b -> [(Term a b, Term a b)];
p d = p_impl (impl_ofd d);

m_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          (Bool, Term a b -> Bool)))))))))))) ->
      Bool;
m_impl (uu, (mi, uv)) = mi;

m :: forall a b. (Key a) => Dpp a b -> Bool;
m d = m_impl (impl_ofd d);

dpp_rbt_impl ::
  forall a b.
    (Eq a, Key a, Ccompare b, Compare b, Eq b,
      Mapping_impl b) => Dpp_ops_ext (Dpp a b) a b ();
dpp_rbt_impl =
  Dpp_ops_ext dpp p pw pairs qa ra rwa rulesb q_emptya rules_no_left_var
    rules_non_collapsing is_QNFa nFQ_subset_NF_rulesa rules_mapa
    reverse_rules_map intersect_pairs replace_pair intersect_rulesa delete_P_Pw
    delete_R_Rwa split_pairs split_rulesa mka m nfsa wwf_rules ();

nFQ_subset_NF_rules_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Bool;
nFQ_subset_NF_rules_impl (uu, (uv, (b, uw))) = b;

nFQ_subset_NF_rules :: forall a b. (Key a, Key b) => Tp a b -> Bool;
nFQ_subset_NF_rules tp = nFQ_subset_NF_rules_impl (impl_ofc tp);

rules_impla ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)];
rules_impla (uu, (uv, (uw, (vR, (vRw, (m, ux)))))) =
  vR ++ vRw ++ map snd (values m);

split_rules_impl ::
  forall a b.
    (Key a,
      Key b) => (Bool,
                  ([Term a b],
                    (Bool,
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)],
                          (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                            Term a b -> Bool)))))) ->
                  [(Term a b, Term a b)] ->
                    ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules_impl tp rs =
  let {
    m = ceta_set_of rs;
  } in partition m (rules_impla tp);

split_rules ::
  forall a b.
    (Key a,
      Key b) => Tp a b ->
                  [(Term a b, Term a b)] ->
                    ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules tp = split_rules_impl (impl_ofc tp);

delete_R_Rw_impl ::
  forall a b.
    (Eq a, Key a,
      Eq b) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       ([Term a b],
                         (Bool,
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                 Term a b -> Bool))))));
delete_R_Rw_impl (nfs, (q, (uu, (vR, (vRw, (m, isnf)))))) r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    vra = list_diff vR vr;
    vrwa = list_diff vRw vrw;
    ma = delete_rules True ra (delete_rules False rwa m);
  } in (nfs, (q, (is_NF_trs_subset isnf (vra ++ vrwa ++ map snd (values ma)),
                   (vra, (vrwa, (ma, isnf))))));

delete_R_Rw ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => Tp a b ->
                  [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Tp a b;
delete_R_Rw tp r rw = TP (delete_R_Rw_impl (impl_ofc tp) r rw);

rules_map_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 (a, Nat) -> [(Term a b, Term a b)];
rules_map_impl (uu, (uv, (uw, (ux, (uy, (m, uz)))))) fn =
  (case lookup m fn of {
    Nothing -> [];
    Just a -> map snd a;
  });

rules_map ::
  forall a b. (Key a, Key b) => Tp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_map tp = rules_map_impl (impl_ofc tp);

qreltrs_impl ::
  forall a b.
    (Eq a, Key a, Compare b,
      Eq b) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 (Bool,
                   (Set (Term a b),
                     (Set (Term a b, Term a b), Set (Term a b, Term a b))));
qreltrs_impl (nfs, (q, (uu, (vR, (vRw, (m, isnf)))))) =
  (nfs, (set q, (set (vR ++ rules_with id m), set (vRw ++ rules_with not m))));

qreltrs ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => Tp a b ->
                  (Bool,
                    (Set (Term a b),
                      (Set (Term a b, Term a b), Set (Term a b, Term a b))));
qreltrs tp = qreltrs_impl (impl_ofc tp);

q_empty_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Bool;
q_empty_impl (uu, (q, uv)) = null q;

q_empty :: forall a b. (Key a, Key b) => Tp a b -> Bool;
q_empty tp = q_empty_impl (impl_ofc tp);

is_QNF_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                Term a b -> Bool)))))) ->
      Term a b -> Bool;
is_QNF_impl (uu, (uv, (uw, (ux, (uy, (uz, isnf)))))) = isnf;

is_QNF :: forall a b. (Key a, Key b) => Tp a b -> Term a b -> Bool;
is_QNF tp = is_QNF_impl (impl_ofc tp);

rulesa :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
rulesa tp = rules_impla (impl_ofc tp);

nfs_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 Bool;
nfs_impl (nfs, uu) = nfs;

nfs :: forall a b. (Key a, Key b) => Tp a b -> Bool;
nfs tp = nfs_impl (impl_ofc tp);

mk_impl ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => Bool ->
                           [Term a b] ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 (Bool,
                                   ([Term a b],
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Term a b -> Bool))))));
mk_impl nfs q r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    isnf = is_NF_terms q;
  } in (nfs, (q, (is_NF_trs_subset isnf (r ++ rw),
                   (vr, (vrw, (insert_rules True ra
                                 (insert_rules False rwa empty),
                                isnf))))));

mk :: forall a b.
        (Eq a, Key a, Ccompare b, Eq b, Key b,
          Mapping_impl b) => Bool ->
                               [Term a b] ->
                                 [(Term a b, Term a b)] ->
                                   [(Term a b, Term a b)] -> Tp a b;
mk nfs q r rw = TP (mk_impl nfs q r rw);

rw_impl ::
  forall a b.
    (Key a) => (Bool,
                 ([Term a b],
                   (Bool,
                     ([(Term a b, Term a b)],
                       ([(Term a b, Term a b)],
                         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                           Term a b -> Bool)))))) ->
                 [(Term a b, Term a b)];
rw_impl (uu, (uv, (uw, (ux, (vRw, (m, uy)))))) = vRw ++ rules_with not m;

rw :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
rw tp = rw_impl (impl_ofc tp);

tp_rbt_impl ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b, Key b,
      Mapping_impl b) => Tp_ops_ext (Tp a b) a b ();
tp_rbt_impl =
  Tp_ops_ext qreltrs q r rw rulesa q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs ();

string_reversal_complete_rel_tt ::
  forall a b c d.
    (Showa b,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_complete_rel_tt i tp =
  bindb (check (q_emptyb i tp) (shows_prec_list Zero_nat "Q is not empty"))
    (\ _ ->
      bindb (check_unary_signature (rulesc i tp))
        (\ _ ->
          Inr (mkb i default_nfs_nt_trs [] (map rev_rule (rb i tp))
                (map rev_rule (rwb i tp)))));

check_to_srs_complete ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> [(b, b)] ->
                         [(Term b a, Term b a)] ->
                           [(Term b a, Term b a)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_to_srs_complete v old_new r s =
  let {
    mu = funas_trs_list r;
    (d, (da, nu)) = extract_components mu old_new;
  } in bindb (check_components mu (d, (da, nu)))
         (\ _ ->
           bindb (check_varcond_subset s)
             (\ _ ->
               catch_errora
                 (forallM
                   (\ slr ->
                     let {
                       y = choose_var v (fst slr);
                       stra = str d y;
                       to_slr = (\ (l, ra) -> (stra l, stra ra));
                     } in check (any (\ lr -> to_slr lr == slr) r)
                            (shows_prec_list Zero_nat
                               "could not find original rule for " .
                              shows_rule (shows_prec Zero_nat)
                                (shows_prec Zero_nat) " -> " slr))
                   s)
                 (\ x -> Inl (snd x))));

const_to_string_complete_tt ::
  forall a b c d.
    (Eq b, Showa b, Eq c,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Const_string_complete_proof b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
const_to_string_complete_tt i tp (Const_string_complete_proof v old_new s) =
  bindb (check (q_emptyb i tp) (shows_prec_list Zero_nat "Q is not empty"))
    (\ _ ->
      bindb (check_to_srs_complete v old_new (rulesc i tp) s)
        (\ _ -> Inr (mkb i False [] s [])));

check_NF_trs_subset ::
  forall a b.
    (Eq a, Key a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [Term a b] -> Sum (Term a b) ();
check_NF_trs_subset r = check_NF_terms_subset (is_NF_trs r);

switch_termination_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_termination_proc i joins_i dpp =
  let {
    p = pairsa i dpp;
    r = rulesd i dpp;
    q = qc i dpp;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list Zero_nat
                                  "rules are not overlay"))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_wf_trs r)
                        (\ _ ->
                          bindb (check_critical_pairs r cp joins_i)
                            (\ _ ->
                              bindb (check (null (critical_pairs_impl p r))
                                      (shows_prec_list Zero_nat
"there are overlaps between P and R"))
                                (\ _ ->
                                  catch_errora (check_NF_trs_subset r q)
                                    (\ x ->
                                      Inl
(shows_prec_term Zero_nat x .
  shows_prec_list Zero_nat " is not in normal form w.r.t. R"))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsc i dpp) False p [] [] [] r);
       });

check_instance ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_instance pa p =
  catch_errora
    (forallM
      (\ st ->
        check (any (instance_rule st) pa)
          (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> " st .
            shows_prec_list Zero_nat
              " is not an instance of any original pair"))
      p)
    (\ x -> Inl (snd x));

instantiation_complete_proc ::
  forall a b c d.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Instantiation_complete_proc_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
instantiation_complete_proc i dpp (Instantiation_complete_proc_prf p) =
  let {
    pa = pairsa i dpp;
    q = qc i dpp;
    r = rulesd i dpp;
    nfs = nfsc i dpp;
  } in bindb (check (not nfs || null q)
               (shows_prec_list Zero_nat
                 "normal form subst. currently not supported for innermost"))
         (\ _ ->
           bindb (check_instance pa p)
             (\ _ -> Inr (mkc i nfs False p [] q [] r)));

rule_removal_nonterm_dp ::
  forall a b c.
    (Key b, Showa b, Key c,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_dp_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_dp i dpp (Rule_removal_nonterm_dp_prf p r) =
  let {
    prm = (if is_none p then [] else ceta_list_diff (pairsa i dpp) (the p));
    rrm = (if is_none r then [] else ceta_list_diff (rulesd i dpp) (the r));
  } in Inr (delete_R_Rwc i (delete_P_Pwa i dpp prm prm) rrm rrm);

mk_rel_tp ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      (Bool, ([Term b c], ([(Term b c, Term b c)], [(Term b c, Term b c)]))) ->
        a;
mk_rel_tp i (nfs, (q, (r, rw))) = mkb i nfs q r rw;

mk_dppa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      (Bool,
        (Bool,
          ([(Term b c, Term b c)],
            ([(Term b c, Term b c)],
              ([Term b c],
                ([(Term b c, Term b c)], [(Term b c, Term b c)])))))) ->
        a;
mk_dppa i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkc i nfs m p pw q r rw;

check_assmb ::
  forall a b c d e f g h i.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      (a -> e -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (d -> f -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (a -> g -> Sum ([Prelude.Char] -> [Prelude.Char])
                                       ()) ->
                            (([(Ctxt (Lab b c) [Prelude.Char],
                                 (Term (Lab b c) [Prelude.Char], Location))],
                               [(Term (Lab b c) [Prelude.Char],
                                  Term (Lab b c) [Prelude.Char])]) ->
                              h -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              ([Prelude.Char] ->
                                i -> Sum ([Prelude.Char] -> [Prelude.Char])
                                       ()) ->
                                Generic_assm_proof b c [Prelude.Char] e f g h
                                  i ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_SN_assm_proof t prf) = tp_check (mk_tpa i t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_RelSN_assm_proof t prf) = rtp_check (mk_rel_tp i t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Infinite_assm_proof t prf) = dp_check (mk_dppa j t) prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_SN_FP_assm_proof t prf) = fptp_check t prf;
check_assmb i j tp_check dp_check rtp_check fptp_check unk_check
  (Unknown_assm_proof t prf) = unk_check t prf;
check_assmb i j uu uv uw ux uy (SN_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination assumptions in non-termination proof");
check_assmb i j uu uv uw ux uy (Finite_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination assumptions in non-termination proof");
check_assmb i j uu uv uw ux uy (SN_FP_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination assumptions in non-termination proof");
check_assmb i j uu uv uw ux uy (Complexity_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination assumptions in non-termination proof");

q_increase_nonterm_dp ::
  forall a b c.
    (Eq b,
      Eq c) => Dpp_ops_ext a b c () ->
                 a -> Q_increase_nonterm_dp_prf b c ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_increase_nonterm_dp i dpp (Q_increase_nonterm_dp_prf q) =
  let {
    p = pairsa i dpp;
    r = rulesd i dpp;
    qa = qc i dpp;
    nfs = nfsc i dpp;
  } in Inr (mkc i nfs False p [] (list_union qa q) [] r);

dp_q_reduction_nonterm ::
  forall a b c d.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b, Showa b, Ccompare c,
      Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Dp_q_reduction_nonterm_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
dp_q_reduction_nonterm i dpp (DP_q_reduction_nonterm_prf q) =
  let {
    p = pairsa i dpp;
    r = rulesd i dpp;
    qa = qc i dpp;
    nfs = nfsc i dpp;
    f = set (funas_trs_list (p ++ r));
    rQ = filter (\ qb -> less_eq_set (funas_term qb) f) qa;
  } in bindb (catch_errora (check_NF_terms_subset (is_NF_terms q) rQ)
               (\ x ->
                 Inl (shows_prec_list Zero_nat "the term " .
                       shows_prec_term Zero_nat x .
                         shows_prec_list Zero_nat " is missing in Q\' ")))
         (\ _ -> Inr (mkc i nfs False p [] q [] r));

check_dpp_subsumesa ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Dpp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      (Bool,
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          ([(Term (Lab b c) [Prelude.Char],
                              Term (Lab b c) [Prelude.Char])],
                            ([Term (Lab b c) [Prelude.Char]],
                              ([(Term (Lab b c) [Prelude.Char],
                                  Term (Lab b c) [Prelude.Char])],
                                [(Term (Lab b c) [Prelude.Char],
                                   Term (Lab b c) [Prelude.Char])])))))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dpp_subsumesa j dp dpp =
  let {
    (nfsa, (_, (p, (pw, (q, (r, rw)))))) = dp;
    pairsaa = p ++ pw;
    rulesa = r ++ rw;
    nfs = nfsc j dpp;
    pairs = pairsa j dpp;
    rules = rulesd j dpp;
    qa = qc j dpp;
  } in catch_errora
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list Zero_nat
               "incompatible substitutions-in-normal-form flags"))
           (\ _ ->
             bindb (catch_errora (check_subseteq pairsaa pairs)
                     (\ x ->
                       Inl (toomuch "pair"
                             (shows_rule (shows_prec_lab Zero_nat)
                               (shows_prec_list Zero_nat) " -> " x))))
               (\ _ ->
                 bindb (catch_errora (check_subseteq rulesa rules)
                         (\ x ->
                           Inl (toomuch "rule"
                                 (shows_rule (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) " -> " x))))
                   (\ _ ->
                     catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                       (\ x ->
                         Inl (shows_prec_list Zero_nat
                                "NF(Q) differs due to term " .
                               shows_term (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) x))))))
         (\ x ->
           Inl (shows_prec_list Zero_nat
                  "problem is showing subsumption for non-termination" .
                 shows_nl . x));

rewriting_complete_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Rewriting_complete_proc_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rewriting_complete_proc i (Rewriting_complete_proc_prf u_opt stb sta st lr p)
  dpp =
  (case catch_errora
          (let {
             s = fst stb;
             t = snd stb;
             ta = snd sta;
             r = rulesd i dpp;
           } in bindb (check_rstep r p lr t ta)
                  (\ _ ->
                    bindb (check (nFQ_subset_NF_rulesc i dpp)
                            (shows_prec_list Zero_nat
                              "innermost rewriting required"))
                      (\ _ ->
                        bindb (check_rewrite_common_preconditions i u_opt stb
                                (args s) (args (subt_at t p)) ta lr p False dpp)
                          (\ _ ->
                            bindb (check (not (is_Var s))
                                    (shows_prec_list Zero_nat
                                      "lhs of pair must not be variable"))
                              (\ _ ->
                                bindb (check (eq_rule_mod_vars sta st)
(shows_prec_list Zero_nat "the rule " .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " sta .
    shows_prec_list Zero_nat " is not a renamed variant of " .
      shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " st))
                                  (\ _ ->
                                    bindb (check (equal_term s (fst sta))
    (shows_prec_list Zero_nat "left-hand sides of old and new pair differ"))
                                      (\ _ ->
let {
  q = qc i dpp;
  inn = isOK (check_NF_trs_subset r q);
} in bindb (check_nfc inn r q (is_QNFc i dpp) (args s) (nfsc i dpp)
             (subt_at t p))
       (\ _ ->
         bindb (catch_errora
                 (forallM
                   (\ (l, _) ->
                     check (not (is_Var l))
                       (shows_prec_list Zero_nat "lhss must not be variables"))
                   r)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             (if not (is_Var t)
               then check (not (not (null (rules_mapb i dpp (the (root t))))))
                      (shows_prec_list Zero_nat "root of " .
                        shows_prec_term Zero_nat t .
                          shows_prec_list Zero_nat " must not be defined")
               else Inr ()))))))))))
          (\ x ->
            Inl (shows_string "error when rewriting the pair " .
                  shows_nl .
                    shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                      " -> " stb .
                      shows_nl .
                        shows_string " to the pair " .
                          shows_nl .
                            shows_rule (shows_prec Zero_nat)
                              (shows_prec_list Zero_nat) " -> " st .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp stb [st]);
  });

less_eq_pos :: Pos -> Pos -> Bool;
less_eq_pos (PCons i q1) (PCons j q2) = equal_nat i j && less_eq_pos q1 q2;
less_eq_pos (PCons i q1) Empty = False;
less_eq_pos Empty p = True;

rstep_enum_impl ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b ->
                             Term a b ->
                               Pos ->
                                 [((Term a b, Term a b), (b -> Term a b, Pos))];
rstep_enum_impl r ta t p =
  concat
    (map_filter
      (\ x ->
        (if less_eq_pos p x
          then Just (let {
                       tp = subt_at ta x;
                     } in (if membera (poss_list t) x
                            then (if equal_ctxt (ctxt_of_pos_term x ta)
                                       (ctxt_of_pos_term x t)
                                   then concatMap
  (\ tpa ->
    concatMap
      (\ (l, ra) ->
        map (\ mu -> ((l, ra), (mu, x)))
          (option_to_list (match_list Var [(l, tp), (ra, tpa)])))
      r)
  [subt_at t x]
                                   else [])
                            else []))
          else Nothing))
      (poss_list ta));

narrow_enum_impl ::
  forall a b.
    (Eq a, Ccompare b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           (Term a b, Term a b) ->
                             (Term a b, Term a b) ->
                               Pos ->
                                 [(b -> Term a b,
                                    ((Term a b, Term a b),
                                      (Pos, b -> Term a b)))];
narrow_enum_impl r sta st p =
  let {
    (s, t) = sta;
    (sa, ta) = st;
  } in concatMap
         (\ mu ->
           concatMap (\ (lr, (tau, q)) -> [(mu, (lr, (q, tau)))])
             (rstep_enum_impl r (subst_apply_term t mu) ta p))
         (option_to_list (match sa s));

check_narrow ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Bool ->
                    Dpp_ops_ext a b [Prelude.Char] () ->
                      a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Bool ->
                                 (Term b [Prelude.Char],
                                   Term b [Prelude.Char]) ->
                                   (Term b [Prelude.Char],
                                     Term b [Prelude.Char]) ->
                                     ([Prelude.Char] -> Term b [Prelude.Char],
                                       ((Term b [Prelude.Char],
  Term b [Prelude.Char]),
 (Pos, [Prelude.Char] -> Term b [Prelude.Char]))) ->
                                       Sum ([Prelude.Char] -> [Prelude.Char])
 ();
check_narrow inn i dpp r q nfs sta st quad =
  let {
    ((_, t), ((s, ta), (mu, (lr, (p, _))))) = (sta, (st, quad));
  } in bindb (check_nfc inn r q (is_QNFc i dpp) (args s) nfs
               (subt_at (subst_apply_term t mu) p))
         (\ _ ->
           check_rewrite_common_preconditions i Nothing
             (s, subst_apply_term t mu) (args s)
             (args (subt_at (subst_apply_term t mu) p)) ta lr p False dpp);

narrowing_complete_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Narrowing_complete_proc_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
narrowing_complete_proc i (Narrowing_complete_proc_prf st p sts) dpp =
  (case catch_errora
          (let {
             (s, t) = st;
             q = qc i dpp;
             nfs = nfsc i dpp;
             rules = rulesd i dpp;
             check_ndef =
               check_no_defined_root (\ fn -> not (null (rules_mapb i dpp fn)));
             inn = isOK (check_NF_trs_subset rules q);
             cnarrow = check_narrow inn i dpp rules q nfs st;
           } in bindb (check (null q || nFQ_subset_NF_rulesc i dpp)
                        (shows_prec_list Zero_nat
                          "full or innermost rewriting required"))
                  (\ _ ->
                    bindb (if null q then Inr ()
                            else bindb (check_no_var s)
                                   (\ _ ->
                                     bindb (check_no_var t)
                                       (\ _ ->
 bindb (check_ndef t)
   (\ _ ->
     (if nfs
       then bindb (catch_errora (forallM (\ (l, _) -> check_no_var l) rules)
                    (\ x -> Inl (snd x)))
              (\ _ ->
                check (wf_rule (s, t))
                  (shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                     " -> " (s, t) .
                    shows_prec_list Zero_nat " is not well formed"))
       else Inr ())))))
                      (\ _ ->
                        catch_errora
                          (forallM
                            (\ sta ->
                              let {
                                quads = narrow_enum_impl rules st sta p;
                              } in catch_errora
                                     (existsM
                                       (\ quad ->
 catch_errora (check (null q) (shows_prec_list Zero_nat "q not empty"))
   (\ _ -> cnarrow sta quad))
                                       quads)
                                     (\ x ->
                                       Inl
 (shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " sta .
   shows_prec_list Zero_nat
     (case quads of {
       [] -> " does not seem to be narrowed pair";
       _ : _ -> " violates side conditions for completeness";
     }) .
     shows_list_gen id [] [] [] [] x)))
                            sts)
                          (\ x -> Inl (snd x)))))
          (\ x ->
            Inl (shows_string "error when narrowing " .
                  shows_nl .
                    shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                      " -> " st .
                      shows_nl .
                        shows_string " to the pairs " .
                          shows_nl .
                            shows_trs (shows_prec Zero_nat)
                              (shows_prec_list Zero_nat) "rewrite system:"
                              " -> " sts .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

inverse_var_renaming_impl ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)];
inverse_var_renaming_impl sigma =
  let {
    a = mk_subst_domain sigma;
  } in map (\ (x, y) -> (the_Var y, Var x)) a;

vars_pat_term_impl ::
  forall a b.
    (Eq a, Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) -> [b];
vars_pat_term_impl p =
  let {
    (s, (sigma, mu)) = p;
  } in remdups
         (vars_term_list s ++ vars_subst_impl sigma ++ vars_subst_impl mu);

var_renaming_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> Bool;
var_renaming_impl sigma =
  let {
    sigmaa = map snd (mk_subst_domain sigma);
  } in all is_Var sigmaa && distinct sigmaa;

pat_dom_renaming_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                 [(b, Term a b)] -> Bool;
pat_dom_renaming_impl p rho =
  let {
    rhoa = mk_subst_domain rho;
    xs = map Var (vars_pat_term_impl p);
  } in var_renaming_impl rho &&
         all (membera (pat_dv_impl p)) (map fst rhoa) &&
           all (\ t -> not (membera xs t)) (map snd rhoa);

check_pat_eqv_prf ::
  forall a b.
    (Compare a, Eq a, Showa a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Set_impl b,
      Showa b) => Pat_eqv_prf a b ->
                    (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Term a b, ([(b, Term a b)], [(b, Term a b)]));
check_pat_eqv_prf (Pat_Irrelevant sigmaa mua) (t, (sigma, mu)) =
  let {
    w = w_impl (mk_subst_domain sigma) t;
    sig = mk_subst Var sigma;
    siga = mk_subst Var sigmaa;
    mub = mk_subst Var mu;
    muba = mk_subst Var mua;
  } in bindb (catch_errora
               (catch_errora
                 (forallM
                   (\ x ->
                     bindb (check (equal_term (sig x) (siga x))
                             (x, (sig x, (siga x, "pumping"))))
                       (\ _ ->
                         check (equal_term (mub x) (muba x))
                           (x, (mub x, (muba x, "closing")))))
                   w)
                 (\ x -> Inl (snd x)))
               (\ x ->
                 Inl (let {
                        (xa, (tb, (ta, sub))) = x;
                      } in shows_string
                             "error in equivalence (irrelevant): for variable " .
                             shows_prec Zero_nat xa .
                               shows_string " obtain different values for " .
                                 shows_prec_list Zero_nat sub .
                                   shows_string " substitution: " .
                                     shows_prec_term Zero_nat tb .
                                       shows_string " != " .
 shows_prec_term Zero_nat ta)))
         (\ _ -> Inr (t, (sigmaa, mua)));
check_pat_eqv_prf (Pat_Simplify mu_1 mu_2) (t, (sigma, mu)) =
  bindb (check (subst_eq mu (subst_compose_impl mu_1 mu_2))
          (shows_prec_list Zero_nat "mu != mu1 mu2"))
    (\ _ ->
      bindb (check (commutes_impl mu_1 sigma)
              (shows_prec_list Zero_nat "sigma and mu1 do not commute"))
        (\ _ -> Inr (subst_apply_term t (mk_subst Var mu_1), (sigma, mu_2))));
check_pat_eqv_prf (Pat_Dom_Renaming rho) (t, (sigma, mu)) =
  bindb (check (pat_dom_renaming_impl (t, (sigma, mu)) rho)
          (shows_prec_list Zero_nat "rho is not a domain renaming for p"))
    (\ _ ->
      let {
        i_rho = inverse_var_renaming_impl rho;
        sigmaa =
          mk_subst_case
            (map (the_Var . mk_subst Var rho) (map fst (mk_subst_domain sigma)))
            (\ x ->
              subst_apply_term
                (subst_apply_term
                  (subst_apply_term (Var x) (mk_subst Var i_rho))
                  (mk_subst Var sigma))
                (mk_subst Var rho))
            [];
        mua = mk_subst_case
                (map (the_Var . mk_subst Var rho)
                  (map fst (mk_subst_domain mu)))
                (\ x ->
                  subst_apply_term
                    (subst_apply_term (Var x) (mk_subst Var i_rho))
                    (mk_subst Var mu))
                i_rho;
      } in Inr (subst_apply_term t (mk_subst Var rho), (sigmaa, mua)));

subst_compose_impla ::
  forall a b.
    (Eq a, Eq b) => [(a, Term b a)] -> (a -> Term b a) -> [(a, Term b a)];
subst_compose_impla sigma rho =
  map (\ (x, s) -> (x, subst_apply_term s rho)) (mk_subst_domain sigma);

subst_replace_impl ::
  forall a b. (Eq a) => [(a, Term b a)] -> a -> Term b a -> [(a, Term b a)];
subst_replace_impl sigma x t = (x, t) : filter (\ (y, _) -> not (y == x)) sigma;

check_pat_rule_prf ::
  forall a b.
    (Compare a, Eq a, Showa a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Pat_rule_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char])
                          ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                            ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                              Bool));
check_pat_rule_prf ra p (Pat_OrigRule (l, r) isPair) =
  (if isPair
    then bindb (check (membera p (l, r))
                 (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                    (l, r) .
                   shows_prec_list Zero_nat " is not a pair"))
           (\ _ -> Inr ((l, ([], [])), ((r, ([], [])), isPair)))
    else bindb (check (membera ra (l, r))
                 (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " -> "
                    (l, r) .
                   shows_prec_list Zero_nat " is not a rule"))
           (\ _ -> Inr ((l, ([], [])), ((r, ([], [])), isPair))));
check_pat_rule_prf r p (Pat_InitPump pat sigma theta) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sig, tau)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (siga, taua)) = aa;
             } in (\ bb ->
                    catch_errora
                      (bindb
                        (check (null (sig ++ tau ++ siga ++ taua))
                          (shows_prec_list Zero_nat
                            "substitutions must be empty"))
                        (\ _ ->
                          bindb (check
                                  (equal_term
                                    (subst_apply_term s (mk_subst Var theta))
                                    (subst_apply_term t (mk_subst Var sigma)))
                                  (shows_prec_list Zero_nat
                                    "s theta != t sigma"))
                            (\ _ ->
                              bindb (check (commutes_impl theta sigma)
                                      (shows_prec_list Zero_nat
"sigma and theta do not commute"))
                                (\ _ ->
                                  Inr ((s, (sigma, [])),
((t, (theta, [])), bb))))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat "problem with " .
                              shows_prec_list Zero_nat "initial pumping" .
                                shows_prec_list Zero_nat
                                  " after deriving correct pattern rule " .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sig, tau)),
((t, (siga, taua)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r pa (Pat_InitPumpCtxt pat sigma p z) =
  bindb (check_pat_rule_prf r pa pat)
    (\ (a, b) ->
      let {
        (s, (sig, tau)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (siga, taua)) = aa;
             } in (\ bb ->
                    catch_errora
                      (bindb
                        (check (not bb)
                          (shows_prec_list Zero_nat
                            "pairs not allowed in init pump ctxt"))
                        (\ _ ->
                          bindb (check (null (sig ++ tau ++ siga ++ taua))
                                  (shows_prec_list Zero_nat
                                    "substitutions must be empty"))
                            (\ _ ->
                              bindb (check (in_poss p t)
                                      (shows_prec_list Zero_nat
"p is not a valid position"))
                                (\ _ ->
                                  bindb (check
  (equal_term s (subst_apply_term (subt_at t p) (mk_subst Var sigma)))
  (shows_prec_list Zero_nat "s != t |_ p sigma"))
                                    (\ _ ->
                                      bindb
(check
  (not (membera (vars_term_list s ++ vars_term_list t ++ vars_subst_impl sigma)
         z))
  (shows_prec_list Zero_nat "z is not fresh"))
(\ _ ->
  let {
    tz = ctxt_apply_term (ctxt_of_pos_term p t) (Var z);
  } in Inr ((s, (sigma, [])),
             ((tz, ((z, tz) : sigma, [(z, subt_at t p)])), bb))))))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat "problem with " .
                              shows_prec_list Zero_nat
                                "initial pumping (with ctxt) " .
                                shows_prec_list Zero_nat
                                  " after deriving correct pattern rule " .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sig, tau)),
((t, (siga, taua)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Equiv pat left eqv) =
  bindb (check_pat_rule_prf r p pat)
    (\ (pleft, (pright, b)) ->
      catch_errora
        (bindb (check_pat_eqv_prf eqv (if left then pleft else pright))
          (\ pnew ->
            Inr (if left then (pnew, (pright, b)) else (pleft, (pnew, b)))))
        (\ x ->
          Inl (shows_prec_list Zero_nat "problem with " .
                shows_prec_list Zero_nat "pattern equivalence" .
                  shows_prec_list Zero_nat
                    " after deriving correct pattern rule " .
                    shows_nl . show_pat_rule (pleft, (pright, b)) . x)));
check_pat_rule_prf r pa (Pat_Narrow pat1 pat2 p) =
  bindb (check_pat_rule_prf r pa pat1)
    (\ (a, b) ->
      let {
        (s, (sigma, mu)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sig, mua)) = aa;
             } in (\ b1 ->
                    bindb (check_pat_rule_prf r pa pat2)
                      (\ (ab, bb) ->
                        let {
                          (u, (sig1, mu1)) = ab;
                        } in (\ (ac, bc) ->
                               let {
                                 (v, (sig2, mu2)) = ac;
                               } in (\ b2 ->
                                      catch_errora
(bindb
  (check
    (subst_eq sig sigma &&
      subst_eq sig1 sigma &&
        subst_eq sig2 sigma &&
          subst_eq mua mu && subst_eq mu1 mu && subst_eq mu2 mu)
    (shows_prec_list Zero_nat "substitutions are not identical"))
  (\ _ ->
    bindb (check (in_poss p t)
            (shows_prec_list Zero_nat "p is not a valid position"))
      (\ _ ->
        bindb (check (equal_term (subt_at t p) u)
                (shows_prec_list Zero_nat "t |_ p != u"))
          (\ _ ->
            bindb (check (if b2 then equal_pos p Empty else True)
                    (shows_prec_list Zero_nat
                      "there is a P step, so p must be epsilon"))
              (\ _ ->
                Inr ((s, (sigma, mu)),
                      ((ctxt_apply_term (ctxt_of_pos_term p t) v, (sigma, mu)),
                        b1 || b2)))))))
(\ x ->
  Inl (shows_prec_list Zero_nat "problem with " .
        shows_prec_list Zero_nat "pattern narrowing" .
          shows_prec_list Zero_nat " after deriving correct pattern rules " .
            shows_nl .
              show_pat_rule ((s, (sigma, mu)), ((t, (sig, mua)), b1)) .
                shows_nl .
                  shows_prec_list Zero_nat " and " .
                    shows_nl .
                      show_pat_rule ((u, (sig1, mu1)), ((v, (sig2, mu2)), b2)) .
                        x)))
                                 bc)
                          bb))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Base) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         xs = map fst
                                (mk_subst_domain sigma_s ++
                                  mk_subst_domain mu_s ++
                                    mk_subst_domain sigma_t ++
                                      mk_subst_domain mu_t);
                       } in bindb (catch_errora
                                    (forallM
                                      (\ x ->
check (not (membera xs x)) (shows_prec_list Zero_nat "domains not disjoint"))
                                      (vars_subst_impl rho))
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                let {
                                  rhoa = mk_subst Var rho;
                                } in Inr ((subst_apply_term s rhoa,
    (subst_compose_impla sigma_s rhoa, subst_compose_impla mu_s rhoa)),
   ((subst_apply_term t rhoa,
      (subst_compose_impla sigma_t rhoa, subst_compose_impla mu_t rhoa)),
     bb))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat "problem with " .
                              shows_prec_list Zero_nat
                                "pattern instantiation (base)" .
                                shows_prec_list Zero_nat
                                  " after deriving correct pattern rule " .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Pump) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (bindb
                        (check (commutes_impl rho sigma_s)
                          (shows_prec_list Zero_nat
                            "rho does not commute with sigma_s"))
                        (\ _ ->
                          bindb (check (commutes_impl rho mu_s)
                                  (shows_prec_list Zero_nat
                                    "rho does not commute with mu_s"))
                            (\ _ ->
                              bindb (check (commutes_impl rho sigma_t)
                                      (shows_prec_list Zero_nat
"rho does not commute with sigma_t"))
                                (\ _ ->
                                  bindb (check (commutes_impl rho mu_t)
  (shows_prec_list Zero_nat "rho does not commute with mu_t"))
                                    (\ _ ->
                                      Inr
((s, (subst_compose_impl sigma_s rho, mu_s)),
  ((t, (subst_compose_impl sigma_t rho, mu_t)), bb)))))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat "problem with " .
                              shows_prec_list Zero_nat
                                "pattern instantiation (pumping)" .
                                shows_prec_list Zero_nat
                                  " after deriving correct pattern rule " .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Close) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    Inr ((s, (sigma_s, subst_compose_impl mu_s rho)),
                          ((t, (sigma_t, subst_compose_impl mu_t rho)), bb)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Base uu) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check (equal_term t ta)
                                    (shows_prec_list Zero_nat
                                      "terms t do not match"))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((tb, (sigma_t, mu_t)), bb)))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat "problem with " .
                              shows_prec_list Zero_nat
                                "pattern rewriting (base)" .
                                shows_prec_list Zero_nat
                                  " after deriving correct pattern rule " .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Pump x) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check
                                    (equal_term (mk_subst Var sigma_t x) ta)
                                    (shows_prec_list Zero_nat
                                      "sigma_t x does not match starting term"))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((t, (subst_replace_impl sigma_t x tb, mu_t)), bb)))))
                      (\ xa ->
                        Inl (shows_prec_list Zero_nat "problem with " .
                              shows_prec_list Zero_nat
                                "pattern rewriting (pumping)" .
                                shows_prec_list Zero_nat
                                  " after deriving correct pattern rule " .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      xa)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Close x) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catch_errora
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check (equal_term (mk_subst Var mu_t x) ta)
                                    (shows_prec_list Zero_nat
                                      "sigma_t x does not match starting term"))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((t, (sigma_t, subst_replace_impl mu_t x tb)), bb)))))
                      (\ xa ->
                        Inl (shows_prec_list Zero_nat "problem with " .
                              shows_prec_list Zero_nat
                                "pattern rewriting (closing)" .
                                shows_prec_list Zero_nat
                                  " after deriving correct pattern rule " .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      xa)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Exp_Sigma pat k) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    Inr ((subst_apply_term s
                            (mk_subst Var (subst_power_impl sigma_s k)),
                           (sigma_s, mu_s)),
                          ((subst_apply_term t
                              (mk_subst Var (subst_power_impl sigma_t k)),
                             (sigma_t, mu_t)),
                            bb)))
               ba)
        b);

check_non_loop_prf ::
  forall a b.
    (Compare a, Eq a, Showa a, Cenum b, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Non_loop_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_prf r pa (Non_loop_prf pat sigma mu m b p) =
  bindb (check_pat_rule_prf r pa pat)
    (\ (a, c) ->
      let {
        (s, (sigmaa, mua)) = a;
      } in (\ (aa, ca) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ is_pair ->
                    catch_errora
                      (bindb
                        (check (if is_pair then equal_pos p Empty else True)
                          (shows_prec_list Zero_nat
                            "p must be empty, since pairs are contained"))
                        (\ _ ->
                          bindb (check (commutes_impl sigmaa sigma)
                                  (shows_prec_list Zero_nat
                                    "sigma and sigma\' do not commute"))
                            (\ _ ->
                              bindb (check (commutes_impl mua sigma)
                                      (shows_prec_list Zero_nat
"mu and sigma\' do not commute"))
                                (\ _ ->
                                  bindb (check
  (subst_eq sigma_t (subst_compose_impl (subst_power_impl sigmaa m) sigma))
  (shows_prec_list Zero_nat "sigma_t != sigma^m sigma\' "))
                                    (\ _ ->
                                      bindb
(check (subst_eq mu_t (subst_compose_impl mua mu))
  (shows_prec_list Zero_nat "mu_t != mu mu\' "))
(\ _ ->
  bindb (check (in_poss p t)
          (shows_prec_list Zero_nat "p is not a position in t"))
    (\ _ ->
      check (equal_term
              (subst_apply_term s (mk_subst Var (subst_power_impl sigmaa b)))
              (subt_at t p))
        (shows_prec_list Zero_nat "s sigma^b != t |_ p"))))))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat "problem with " .
                              shows_prec_list Zero_nat
                                "application condition of non-loop theorem" .
                                shows_prec_list Zero_nat
                                  " after deriving correct pattern rule " .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigmaa, mua)),
((t, (sigma_t, mu_t)), is_pair)) .
                                      x)))
               ca)
        c);

check_non_loop_dp_prf ::
  forall a b c d.
    (Compare b, Eq b, Showa b, Cenum c, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Non_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_dp_prf i dpp prf =
  let {
    p = pairsa i dpp;
    r = rulesd i dpp;
  } in bindb (check (null (qc i dpp))
               (shows_prec_list Zero_nat "strategy for non-loops unsupported"))
         (\ _ -> check_non_loop_prf r p prf);

rule_removal_nonterm_trs ::
  forall a b c.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_trs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_trs i tp (Rule_removal_nonterm_trs_prf r) =
  let {
    ra = rulesc i tp;
    rrm = ceta_list_diff ra r;
  } in Inr (delete_R_Rwb i tp rrm rrm);

shows_prec_location :: Nat -> Location -> [Prelude.Char] -> [Prelude.Char];
shows_prec_location uu A = shows_prec_list Zero_nat "above";
shows_prec_location uv Ba = shows_prec_list Zero_nat "below";
shows_prec_location uw H = shows_prec_list Zero_nat "here";
shows_prec_location ux Ra = shows_prec_list Zero_nat "right";

shows_pattern ::
  forall a b.
    (Showa a,
      Showa b) => (Ctxt a b, (Term a b, Location)) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_pattern (c, (s, p)) =
  shows_prec_list Zero_nat "(" .
    shows_prec_term Zero_nat (ctxt_apply_term c s) .
      shows_prec_list Zero_nat ", " .
        shows_prec_pos Zero_nat (hole_pos c) .
          shows_prec_list Zero_nat ", " .
            shows_prec_location Zero_nat p . shows_prec_list Zero_nat ")";

fp_R_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_R_decide mu l oo q c t =
  not (bex (let {
              h = hole_pos c;
              q_s = filter (\ qa -> is_left_of qa q) (poss_list t);
              m1 = map (\ qa -> (subt_at t qa, l)) q_s;
              sterms =
                remdups
                  (map (si_subst mu)
                    (remdups (concatMap (\ qa -> si_W mu (subt_at t qa)) q_s)));
              uterms = concatMap supteq_list sterms;
              m2 = map (\ u -> (u, l)) (remdups uterms);
              p_s = filter (\ qa -> is_left_of qa h)
                      (poss_list (ctxt_apply_term c t));
              m3 = map (\ p -> (subt_at (ctxt_apply_term c t) p, l)) p_s;
              stermsa =
                remdups
                  (map (si_subst mu)
                    (remdups
                      (concatMap
                        (\ p -> si_W mu (subt_at (ctxt_apply_term c t) p))
                        p_s)));
              utermsa = concatMap supteq_list stermsa;
              m4 = map (\ u -> (u, l)) (remdups utermsa);
            } in set (m1 ++ m2 ++ m3 ++ m4))
        (match_decision mu));

size_pos :: Pos -> Nat;
size_pos Empty = Zero_nat;
size_pos (PCons x21 x22) =
  plus_nat (size_pos x22) (plus_nat Zero_nat (Nat_of_num One));

pos_dec :: Pos -> Pos -> Pos -> Maybe (Nat, Pos);
pos_dec p q oo =
  (if equal_pos p Empty
    then (case pos_suffix oo q of {
           Nothing -> Nothing;
           Just r -> Just (Zero_nat, r);
         })
    else let {
           n0 = nat (ceiling
                      (divide_rat
                        (of_nat (minus_nat (size_pos oo) (size_pos q)))
                        (of_nat (size_pos p))));
         } in (case pos_suffix oo (append (powera p n0) q) of {
                Nothing -> Nothing;
                Just r -> Just (n0, r);
              }));

ctxt_subst ::
  forall a b. Ctxt a b -> (b -> Term a b) -> Nat -> Term a b -> Term a b;
ctxt_subst uu uv n t =
  (if equal_nat n Zero_nat then t
    else ctxt_apply_term uu
           (subst_apply_term (ctxt_subst uu uv (minus_nat n (Nat_of_num One)) t)
             uv));

h_match_probs ::
  forall a b.
    (Compare a, Eq a, Compare b,
      Eq b) => (a -> Term b a) ->
                 Term b a ->
                   Pos ->
                     Pos -> Ctxt b a -> Term b a -> Set (Term b a, Term b a);
h_match_probs mu l oo q c t =
  (case pos_dec (hole_pos c) q oo of {
    Nothing ->
      set_empty
        (of_phantom (set_impl_prod :: Phantom (Term b a, Term b a) Set_impla));
    Just (n, o) ->
      inserta (subt_at (ctxt_subst c mu n t) o, l)
        (set_empty
          (of_phantom
            (set_impl_prod :: Phantom (Term b a, Term b a) Set_impla)));
  });

fp_H_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_H_decide mu l oo q c t =
  not (bex (h_match_probs (si_subst mu) l oo q c t) (match_decision mu));

decompositions :: Pos -> [(Pos, Pos)];
decompositions p = map (\ pa -> (pa, the (pos_prefix pa p))) (prefix_list p);

simplify_emp_main ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b,
                   (Term a b,
                     (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                   [(Term a b, Term a b)] ->
                     Maybe (Maybe (Ctxt a b,
                                    (Term a b,
                                      (Ctxt a b,
(Term a b, [(Term a b, Term a b)])))));
simplify_emp_main mu_incr (Hole, (Fun g ls, (c, (t, [])))) solved =
  (if gmatch_decision mu_incr ((t, Fun g ls) : solved) then Just Nothing
    else (if equal_ctxt c Hole then Nothing
           else simplify_emp_main mu_incr
                  (c, (Fun g ls,
                        (subst_apply_ctxt c (si_subst mu_incr),
                          (subst_apply_term t (si_subst mu_incr), []))))
                  solved));
simplify_emp_main mu_incr (More f bef d aft, (Fun g ls, (c, (t, [])))) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (guarda
             (equal_nat (size_list ls)
               (plus_nat (plus_nat (size_list bef) (size_list aft))
                 (Nat_of_num One))))
        (\ _ ->
          let {
            pairs_bef = zip bef (take (size_list bef) ls);
            pairs_aft =
              zip aft (drop (plus_nat (size_list bef) (Nat_of_num One)) ls);
          } in simplify_emp_main mu_incr
                 (d, (nth ls (size_list bef), (c, (t, pairs_bef ++ pairs_aft))))
                 solved));
simplify_emp_main mu_incr (d, (Var x, (c, (t, [])))) solved =
  Just (Just (d, (Var x, (c, (t, solved)))));
simplify_emp_main mu_incr (d, (l, (c, (t, (Var x, Fun f ls) : mp)))) solved =
  bind (guarda (member x (si_v_incr mu_incr)))
    (\ _ ->
      let {
        m = map (\ (s, a) -> (subst_apply_term s (si_subst mu_incr), a));
      } in simplify_emp_main mu_incr
             (subst_apply_ctxt d (si_subst mu_incr),
               (l, (subst_apply_ctxt c (si_subst mu_incr),
                     (subst_apply_term t (si_subst mu_incr),
                       m ((Var x, Fun f ls) : mp)))))
             (m solved));
simplify_emp_main mu_incr (d, (l, (c, (t, (Fun g ts, Fun f ls) : mp)))) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (zip_option ts ls)
        (\ pairs ->
          simplify_emp_main mu_incr (d, (l, (c, (t, pairs ++ mp)))) solved));
simplify_emp_main mu_incr (d, (l, (c, (t, (s, Var x) : mp)))) solved =
  simplify_emp_main mu_incr (d, (l, (c, (t, mp)))) ((s, Var x) : solved);

simplify_emp ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) ->
                   Sum (Ctxt a b,
                         (Term a b,
                           (Ctxt a b, (Term a b, [(Term a b, Term a b)]))))
                     Bool;
simplify_emp mu_incr emp =
  let {
    (d, (l, (c, t))) = emp;
  } in (case simplify_emp_main mu_incr (d, (l, (c, (t, [])))) [] of {
         Nothing -> Inr False;
         Just a -> (case a of {
                     Nothing -> Inr True;
                     Just aa -> Inl aa;
                   });
       });

eident_prob_to_ident_prob ::
  forall a b.
    (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) -> (Term a b, Term a b);
eident_prob_to_ident_prob (d, (si, (c, t))) = (ctxt_apply_term d t, si);

eident_prob_of_semp ::
  forall a b.
    (Eq a,
      Eq b) => (Ctxt a b,
                 (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                 Maybe (Ctxt a b, (Term a b, (Ctxt a b, Term a b)));
eident_prob_of_semp (d, (l, (c, (t, mp)))) =
  bind (map_of (reverse_rules mp) l) (\ si -> Just (d, (si, (c, t))));

ident_prob_of_semp ::
  forall a b.
    (Eq a,
      Eq b) => (Ctxt a b,
                 (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                 [(Term a b, Term a b)];
ident_prob_of_semp (d, (l, (c, (t, mp)))) = ident_prob_of_smp mp;

ident_prob_of_emp ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) ->
                   Maybe [(Term a b, Term a b)];
ident_prob_of_emp mu_incr emp =
  (case simplify_emp mu_incr emp of {
    Inl semp ->
      Just (map eident_prob_to_ident_prob
              (option_to_list (eident_prob_of_semp semp)) ++
             ident_prob_of_semp semp);
    Inr True -> Just [];
    Inr False -> Nothing;
  });

n0b :: Pos -> Pos -> Pos -> Nat;
n0b p q oo =
  nat (ceiling
        (divide_rat
          (of_nat
            (minus_nat (plus_nat (size_pos oo) (Nat_of_num One)) (size_pos q)))
          (of_nat (size_pos p))));

less_pos :: Pos -> Pos -> Bool;
less_pos p q = less_eq_pos p q && not (equal_pos p q);

fp_B_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_B_decide mu l oo q c t =
  not (bex (foldr (sup_set . (\ qa -> h_match_probs (si_subst mu) l oo qa c t))
             (proper_prefix_list q)
             (set_empty
               (of_phantom
                 (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla))))
        (match_decision mu)) &&
    not (bex (let {
                p = hole_pos c;
                n = (\ pa -> n0b p pa oo);
                ps = filter
                       (\ (pa, pb) ->
                         less_pos oo (append pb (powera p (n pb))) &&
                           less_pos pa p)
                       (remdups (decompositions p));
              } in set (map (\ (pb, pa) ->
                              (subt_at_ctxt c pb,
                                (l, (subst_apply_ctxt c (si_subst mu),
                                      subst_apply_term
(ctxt_subst c (si_subst mu) (n pa) t) (si_subst mu)))))
                         (remdups ps)))
          (\ ep ->
            bex (set_option (ident_prob_of_emp mu ep))
              (all (ident_decision mu))));

n0 :: Pos -> Pos -> Pos -> Nat;
n0 p q oo =
  nat (ceiling
        (divide_rat (of_nat (minus_nat (size_pos oo) (size_pos q)))
          (of_nat (size_pos p))));

fp_A_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_A_decide mu l oo q c t =
  not (bex (case subt_at t q of {
             Var _ ->
               set_empty
                 (of_phantom
                   (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla));
             Fun _ _ ->
               let {
                 h = hole_pos c;
                 n = n0 h q oo;
                 hn = powera h n;
                 cs = ctxt_subst c (si_subst mu) n t;
                 q_s = bounded_postfixes q (poss_list t);
                 qoo_s =
                   concatMap
                     (\ qa ->
                       map (\ a -> (qa, a))
                         (prefix_list (append hn (append q qa))))
                     q_s;
                 qoo_sf =
                   filter
                     (\ qoo -> less_pos (append hn q) (append (snd qoo) oo))
                     qoo_s;
                 m1 = map (\ qoo -> (subt_at cs (snd qoo), l)) qoo_sf;
                 sterms = remdups (map (si_subst mu) (si_W mu (subt_at t q)));
                 uterms =
                   concatMap (filter (\ ta -> not (is_Var ta)) . supteq_list)
                     sterms;
                 m2 = map (\ u -> (u, l)) (remdups uterms);
               } in set (m1 ++ m2);
           })
        (match_decision mu));

fp_decide ::
  forall a b.
    (Compare a, Eq a, Ceq b, Ccompare b, Compare b,
      Eq b) => Subst_incr a b ->
                 (Pos, (Ctxt a b, Term a b)) ->
                   (Ctxt a b, (Term a b, Location)) -> Bool;
fp_decide mu =
  (\ (q, (c, t)) (l, (la, loc)) ->
    (if equal_location loc H
      then fp_H_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
      else True) &&
      (if equal_location loc A
        then fp_A_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
        else True) &&
        (if equal_location loc Ba
          then fp_B_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
          else True) &&
          (if equal_location loc Ra
            then fp_R_decide mu (ctxt_apply_term l la) (hole_pos l) q c t
            else True));

fp_valid ::
  forall a b c.
    (Compare a, Eq a, Compare b, Eq b, Ceq c,
      Ccompare c) => Set (Ctxt a b, (Term a b, c)) -> Bool;
fp_valid p = ball p (\ (l, (la, _)) -> not (is_Var (ctxt_apply_term l la)));

check_fploop ::
  forall a b.
    (Compare a, Eq a, Showa a, Ceq b, Ccompare b, Compare b, Eq b,
      Mapping_impl b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Ctxt a b, (Term a b, Location))] ->
                      Fp_loop_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fploop r p (FP_loop_prf c sigma t seq) =
  let {
    mu = subst_incr sigma;
    mua = si_subst mu;
  } in bindb (check (not (null seq))
               (shows_prec_list Zero_nat "looping reduction must not be empty"))
         (\ _ ->
           bindb (check
                   (equal_term (let {
                                  (_, (_, ta)) = last seq;
                                } in ta)
                     (ctxt_apply_term c (subst_apply_term t mua)))
                   (shows_prec_list Zero_nat
                     "last term in sequence is not C[t sigma]"))
             (\ _ ->
               bindb (check (fp_valid (set p))
                       (shows_prec_list Zero_nat
                         "lhss in forbidden patterns must not be variables"))
                 (\ _ ->
                   bindb (catch_errora
                           (forallM
                             (\ (l, _) ->
                               check (not (is_Var l))
                                 (shows_prec_list Zero_nat
                                   "lhss of TRS must not be variables"))
                             r)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       let {
                         seqa = zip (t : map (\ (_, (_, ta)) -> ta) seq) seq;
                       } in catch_errora
                              (forallM
                                (\ (ta, (q, (ra, s))) ->
                                  bindb (check_rstep r q ra ta s)
                                    (\ _ ->
                                      let {
check_fpstep = fp_decide mu (q, (c, ta));
                                      } in
catch_errora
  (forallM
    (\ pt ->
      check (check_fpstep pt)
        (shows_prec_list Zero_nat "iterating reduction " .
          shows_prec_term Zero_nat ta .
            shows_prec_list Zero_nat " -->" .
              shows_prec_pos Zero_nat q .
                shows_prec_list Zero_nat " " .
                  shows_prec_term Zero_nat s .
                    shows_prec_list Zero_nat
                      " does not respect forbidden pattern " .
                      shows_pattern pt))
    p)
  (\ x -> Inl (snd x))))
                                seqa)
                              (\ x -> Inl (snd x))))));

check_fp_tp_subsumes ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ([(Ctxt (Lab a b) [Prelude.Char],
                      (Term (Lab a b) [Prelude.Char], Location))],
                    [(Term (Lab a b) [Prelude.Char],
                       Term (Lab a b) [Prelude.Char])]) ->
                    ([(Ctxt (Lab a b) [Prelude.Char],
                        (Term (Lab a b) [Prelude.Char], Location))],
                      [(Term (Lab a b) [Prelude.Char],
                         Term (Lab a b) [Prelude.Char])]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fp_tp_subsumes ta t =
  let {
    ((p, r), (pa, ra)) = (ta, t);
  } in catch_errora
         (bindb
           (check (p == pa)
             (shows_prec_list Zero_nat
               "difference in forbidden patterns strategy"))
           (\ _ ->
             catch_errora (check_subseteq r ra)
               (\ x ->
                 Inl (toomuch "rule"
                       (shows_rule (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) " -> " x)))))
         (\ x ->
           Inl (shows_prec_list Zero_nat
                  "problem in showing subsumption for non-termination" .
                 shows_nl . x));

string_reversal_complete_tt ::
  forall a b c d.
    (Showa b,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_complete_tt i tp =
  let {
    r = rulesc i tp;
  } in bindb (check (q_emptyb i tp) (shows_prec_list Zero_nat "Q is not empty"))
         (\ _ ->
           bindb (check_unary_signature r)
             (\ _ -> Inr (mkb i default_nfs_nt_trs [] (map rev_rule r) [])));

check_dps ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (a -> a) ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] -> Sum (Term a b, Term a b) ();
check_dps unshp r p =
  let {
    d = defined_list r;
  } in catch_errora
         (forallM
           (\ x ->
             (if let {
                   (ll, rr) = x;
                 } in not (is_Var rr) &&
                        not (membera d (the (root rr))) &&
                          any (\ (l, ra) ->
                                equal_term l (sharp_term unshp ll) &&
                                  (equal_term ra (sharp_term unshp rr) ||
                                    supt_impl ra (sharp_term unshp rr)))
                            r
               then Inr () else Inl x))
           p)
         (\ x -> Inl (snd x));

unsharp :: forall a b. Lab a b -> Lab a b;
unsharp (Sharp f) = f;
unsharp (Lab v va) = Lab v va;
unsharp (FunLab v va) = FunLab v va;
unsharp (UnLab v) = UnLab v;

dp_trans_nontermination_tt ::
  forall a b c d e f g.
    (Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => Tp_ops_ext a (Lab b c) d e ->
                    Dpp_ops_ext f (Lab b c) d g ->
                      a -> Dp_trans_nontermination_tt_prf b c d ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) f;
dp_trans_nontermination_tt i j tp (DP_trans_nontermination_tt_prf p) =
  let {
    r = rulesc i tp;
    q = qb i tp;
  } in bindb (check (null q || not (nfsb i tp))
               (shows_prec_list Zero_nat
                 "strategies and normal form substitutions problem"))
         (\ _ ->
           bindb (catch_errora (check_dps unsharp r p)
                   (\ x ->
                     Inl (shows_prec_list Zero_nat "problematic rule: " .
                           shows_rule (shows_prec_lab Zero_nat)
                             (shows_prec Zero_nat) " -> " x)))
             (\ _ -> Inr (mkc j False False p [] q [] r)));

switch_termination_tt ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_termination_tt i joins_i tp =
  let {
    r = rulesc i tp;
    q = qb i tp;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catch_errora
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list Zero_nat
                                  "rules are not overlay"))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_wf_trs r)
                        (\ _ ->
                          bindb (check_critical_pairs r cp joins_i)
                            (\ _ ->
                              catch_errora (check_NF_trs_subset r q)
                                (\ x ->
                                  Inl (shows_prec_term Zero_nat x .
shows_prec_list Zero_nat " is not in normal form w.r.t. R")))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i (nfsb i tp) [] r []);
       });

q_increase_nonterm_trs ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Q_increase_nonterm_trs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_increase_nonterm_trs i dpp (Q_increase_nonterm_trs_prf q) =
  let {
    r = rulesc i dpp;
    qa = qb i dpp;
    nfs = nfsb i dpp;
  } in Inr (mkb i nfs (list_union qa q) r []);

shows_srs_rule ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_srs_rule (l, r) =
  shows_prec Zero_nat l .
    shows_prec_list Zero_nat " -> " . shows_prec Zero_nat r;

check_step ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Dp_proof_step a ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_step r step =
  (case step of {
    OC1 uv _ ->
      check (member uv r)
        (shows_srs_rule uv .
          shows_prec_list Zero_nat " is not an original rule");
    OC2 oc_new oc1 oc2 t x l ->
      let {
        (wl, tr) = oc_new;
        (w, tx) = oc1;
        (xl, ra) = oc2;
      } in catch_errora
             (bindb
               (check (xl == x ++ l)
                 (shows_prec_list Zero_nat "problem: xl != x l"))
               (\ _ ->
                 bindb (check (tx == t ++ x)
                         (shows_prec_list Zero_nat "problem: tx != t x"))
                   (\ _ ->
                     bindb (check (wl == w ++ l)
                             (shows_prec_list Zero_nat "problem: wl != w l"))
                       (\ _ ->
                         check (tr == t ++ ra)
                           (shows_prec_list Zero_nat "problem: tr != t r")))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      "problem in checking overlap OC2 of " .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list Zero_nat "to yield" .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC2p oc_new oc1 oc2 x t l ->
      let {
        (lw, rt) = oc_new;
        (w, xt) = oc1;
        (lx, ra) = oc2;
      } in catch_errora
             (bindb
               (check (lx == l ++ x)
                 (shows_prec_list Zero_nat "problem: lx != l x"))
               (\ _ ->
                 bindb (check (lw == l ++ w)
                         (shows_prec_list Zero_nat "problem: lw != l w"))
                   (\ _ ->
                     bindb (check (rt == ra ++ t)
                             (shows_prec_list Zero_nat "problem: rt != r t"))
                       (\ _ ->
                         check (xt == x ++ t)
                           (shows_prec_list Zero_nat "problem: xt != x t")))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      "problem in checking overlap OC2\' of " .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list Zero_nat "to yield" .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC3 oc_new oc1 oc2 t1 t2 ->
      let {
        (w, t1rt2) = oc_new;
        (wa, t1xt2) = oc1;
        (x, ra) = oc2;
      } in catch_errora
             (bindb
               (check (t1rt2 == t1 ++ ra ++ t2)
                 (shows_prec_list Zero_nat "problem: t1_r_t2 != t1 r t2"))
               (\ _ ->
                 bindb (check (t1xt2 == t1 ++ x ++ t2)
                         (shows_prec_list Zero_nat
                           "problem: t1_x_t2 != t1 x t2"))
                   (\ _ ->
                     check (w == wa)
                       (shows_prec_list Zero_nat "problem: w differs"))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      "problem in checking overlap OC3 of " .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list Zero_nat "to yield" .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC3p oc_new oc1 oc2 t1 t2 ->
      let {
        (t1wt2, ra) = oc_new;
        (t1xt2, raa) = oc1;
        (w, x) = oc2;
      } in catch_errora
             (bindb
               (check (t1wt2 == t1 ++ w ++ t2)
                 (shows_prec_list Zero_nat "problem: t1_w_t2 != t1 w t2"))
               (\ _ ->
                 bindb (check (t1xt2 == t1 ++ x ++ t2)
                         (shows_prec_list Zero_nat
                           "problem: t1_x_t2 != t1 x t2"))
                   (\ _ ->
                     check (ra == raa)
                       (shows_prec_list Zero_nat "problem: r differs"))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      "problem in checking overlap OC3\' of " .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list Zero_nat "to yield" .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OCDP1 p oc1 ->
      let {
        (lc, cr) = oc1;
        a = p;
        (aa, b) = a;
      } in let {
             (e1, ab) = aa;
             (ac, ba) = ab;
           } in let {
                  (f, (d, l)) = ac;
                } in (\ c1 (c2, ad) ->
                       let {
                         (ae, bb) = ad;
                       } in let {
                              (fa, (da, ra)) = ae;
                            } in (\ e2 ->
                                   catch_errora
                                     (bindb
                                       (check (null e1)
 (shows_prec_list Zero_nat "problem: e1 not empty"))
                                       (\ _ ->
 bindb (check (null e2) (shows_prec_list Zero_nat "problem: e2 not empty"))
   (\ _ ->
     bindb (check (c1 == c2) (shows_prec_list Zero_nat "problem: c not equal"))
       (\ _ ->
         bindb (check
                 (equal_nat f (Nat_of_num One) &&
                   equal_nat fa (Nat_of_num One) &&
                     equal_nat d Zero_nat && equal_nat da Zero_nat)
                 (shows_prec_list Zero_nat
                   "problem: 0 and 1 conditions not met"))
           (\ _ ->
             bindb (check (lc == l ++ c1)
                     (shows_prec_list Zero_nat "problem: lc != l c"))
               (\ _ ->
                 check (cr == c1 ++ ra)
                   (shows_prec_list Zero_nat "problem: cr != c r")))))))
                                     (\ x ->
                                       Inl
 (shows_prec_list Zero_nat "problem in checking overlap OCDP1 of " .
   shows_nl .
     shows_oc oc1 .
       shows_nl .
         shows_prec_list Zero_nat "to yield" .
           shows_nl . shows_pat p . shows_nl . x)))
                              bb)
                  ba
             b;
    OCDP2 p oc1 ->
      let {
        (cl, rc) = oc1;
        a = p;
        (aa, b) = a;
      } in let {
             (c1, ab) = aa;
             (ac, ba) = ab;
           } in let {
                  (f, (d, l)) = ac;
                } in (\ e1 (e2, ad) ->
                       let {
                         (ae, bb) = ad;
                       } in let {
                              (fa, (da, ra)) = ae;
                            } in (\ c2 ->
                                   catch_errora
                                     (bindb
                                       (check (null e1 && null e2)
 (shows_prec_list Zero_nat "problem: e1 or e2 not empty"))
                                       (\ _ ->
 bindb (check (c1 == c2) (shows_prec_list Zero_nat "problem: c not equal"))
   (\ _ ->
     bindb (check
             (equal_nat f (Nat_of_num One) &&
               equal_nat fa (Nat_of_num One) &&
                 equal_nat d Zero_nat && equal_nat da Zero_nat)
             (shows_prec_list Zero_nat "problem: 0 and 1 conditions not met"))
       (\ _ ->
         bindb (check (cl == c1 ++ l)
                 (shows_prec_list Zero_nat "problem: lc != l c"))
           (\ _ ->
             check (rc == ra ++ c1)
               (shows_prec_list Zero_nat "problem: cr != c r"))))))
                                     (\ x ->
                                       Inl
 (shows_prec_list Zero_nat "problem in checking overlap OCDP1 of " .
   shows_nl .
     shows_oc oc1 .
       shows_nl .
         shows_prec_list Zero_nat "to yield" .
           shows_nl . shows_pat p . shows_nl . x)))
                              bb)
                  ba
             b;
    WPEQ p_new p ->
      let {
        (left, right) = p;
        (lefta, righta) = p_new;
      } in catch_errora
             (bindb
               (check (word_pat_equiv left lefta)
                 (shows_prec_list Zero_nat "problem: lhss are not equivalent"))
               (\ _ ->
                 check (word_pat_equiv right righta)
                   (shows_prec_list Zero_nat
                     "problem: rhss are not equivalent")))
             (\ x ->
               Inl (shows_prec_list Zero_nat
                      "problem in checking equivalence of " .
                     shows_nl .
                       shows_pat p .
                         shows_nl .
                           shows_prec_list Zero_nat "and" .
                             shows_nl . shows_pat p_new . shows_nl . x));
    Lift p_new p ->
      let {
        a = p;
        (aa, b) = a;
      } in let {
             (l1, ab) = aa;
             (ac, ba) = ab;
           } in let {
                  (f1, (c1, m1)) = ac;
                } in (\ r1 (l2, ad) ->
                       let {
                         (ae, bb) = ad;
                       } in let {
                              (f2, (c2, m2)) = ae;
                            } in (\ r2 ->
                                   let {
                                     af = p_new;
                                     (ag, bc) = af;
                                   } in let {
  (l1a, ah) = ag;
  (ai, bd) = ah;
} in let {
       (f1a, (c1a, m1a)) = ai;
     } in (\ r1a (l2a, aj) ->
            let {
              (ak, be) = aj;
            } in let {
                   (f2a, (c2a, m2a)) = ak;
                 } in (\ r2a ->
                        catch_errora
                          (bindb
                            (check (l1 == l1a && l2 == l2a)
                              (shows_prec_list Zero_nat
                                "problem: l and l\' do not match"))
                            (\ _ ->
                              bindb (check (r1 == r1a && r2 == r2a)
                                      (shows_prec_list Zero_nat
"problem: r and r\' do not match"))
                                (\ _ ->
                                  bindb (check
  (equal_nat f1 f1a && equal_nat f2 f2a)
  (shows_prec_list Zero_nat "problem: f and f\' do not match"))
                                    (\ _ ->
                                      bindb
(check (m1 == m1a && m2 == m2a)
  (shows_prec_list Zero_nat "problem: m and m\' do not match"))
(\ _ ->
  bindb (check (equal_nat c1a (plus_nat c1 f1))
          (shows_prec_list Zero_nat
            "problem: constant factor on the left not properly increased"))
    (\ _ ->
      check (equal_nat c2a (plus_nat c2 f2))
        (shows_prec_list Zero_nat
          "problem: constant factor on the right not properly increased")))))))
                          (\ x ->
                            Inl (shows_prec_list Zero_nat
                                   "problem in checking lifting of " .
                                  shows_nl .
                                    shows_pat p .
                                      shows_nl .
shows_prec_list Zero_nat "to yield" .
  shows_nl . shows_pat p_new . shows_nl . x)))
                   be)
       bd
  bc)
                              bb)
                  ba
             b;
    DPOC1_1 p_new p1 oc1 l ra ->
      let {
        (left, (lxr, (m2, r2))) = p1;
        (x, v) = oc1;
        (lefta, (lvr, (m2a, r2a))) = p_new;
      } in catch_errora
             (bindb
               (check (left == lefta)
                 (shows_prec_list Zero_nat "problem: lhss are not equal"))
               (\ _ ->
                 bindb (check (m2 == m2a)
                         (shows_prec_list Zero_nat
                           "problem: m2 and m2\' do not match"))
                   (\ _ ->
                     bindb (check (r2 == r2a)
                             (shows_prec_list Zero_nat
                               "problem: r2 and r2\' do not match"))
                       (\ _ ->
                         bindb (check (lxr == l ++ x ++ ra)
                                 (shows_prec_list Zero_nat
                                   "problem: l_x_r != l @ x @ r"))
                           (\ _ ->
                             check (lvr == l ++ v ++ ra)
                               (shows_prec_list Zero_nat
                                 "problem: l_v_r != l @ v @ r"))))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      "problem in checking overlap DPOC1_1 of " .
                     shows_nl .
                       shows_pat p1 .
                         shows_nl .
                           shows_oc oc1 .
                             shows_nl .
                               shows_prec_list Zero_nat "to yield" .
                                 shows_nl . shows_pat p_new . shows_nl . xa));
    DPOC1_2 p_new p1 oc1 l ra x ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (m1, r1)) = aa;
           } in (\ (xr, (m2, r2)) ->
                  let {
                    (lx, v) = oc1;
                    ab = p_new;
                    (ac, ba) = ab;
                  } in let {
                         (ll1, (m1a, r1a)) = ac;
                       } in (\ (vr, (m2a, r2a)) ->
                              catch_errora
                                (bindb
                                  (check (m1 == m1a && m2 == m2a)
                                    (shows_prec_list Zero_nat
                                      "problem: m components modified"))
                                  (\ _ ->
                                    bindb (check (r1 == r1a && r2 == r2a)
    (shows_prec_list Zero_nat "problem: r components modified"))
                                      (\ _ ->
bindb (check (ll1 == l ++ l1)
        (shows_prec_list Zero_nat "problem: l_l1 != l @ ll1"))
  (\ _ ->
    bindb (check (xr == x ++ ra)
            (shows_prec_list Zero_nat "problem: x_r != x @ r"))
      (\ _ ->
        bindb (check (lx == l ++ x)
                (shows_prec_list Zero_nat "problem: l_x != l @ x"))
          (\ _ ->
            check (vr == v ++ ra)
              (shows_prec_list Zero_nat "problem: v_r != v @ r")))))))
                                (\ xa ->
                                  Inl (shows_prec_list Zero_nat
 "problem in checking overlap DPOC1_2 of " .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list Zero_nat "to yield" .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPOC2 p_new p1 oc1 l ra ->
      let {
        a = p1;
        (left, aa) = a;
        (l2, ab) = aa;
        (ac, b) = ab;
      } in let {
             (f2, (c2, lxr)) = ac;
           } in (\ r2 ->
                  let {
                    (x, v) = oc1;
                    ad = p_new;
                    (lefta, ae) = ad;
                    (l2a, af) = ae;
                    (ag, ba) = af;
                  } in let {
                         (f2a, (c2a, lvr)) = ag;
                       } in (\ r2a ->
                              catch_errora
                                (bindb
                                  (check (left == lefta)
                                    (shows_prec_list Zero_nat
                                      "problem: left components modified"))
                                  (\ _ ->
                                    bindb (check (equal_nat f2 f2a)
    (shows_prec_list Zero_nat "problem: f components modified"))
                                      (\ _ ->
bindb (check (equal_nat c2 c2a)
        (shows_prec_list Zero_nat "problem: c components modified"))
  (\ _ ->
    bindb (check (l2 == l2a)
            (shows_prec_list Zero_nat "problem: l components modified"))
      (\ _ ->
        bindb (check (r2 == r2a)
                (shows_prec_list Zero_nat "problem: r components modified"))
          (\ _ ->
            bindb (check (lxr == l ++ x ++ ra)
                    (shows_prec_list Zero_nat "problem: l_x_r != l @ x @ r"))
              (\ _ ->
                check (lvr == l ++ v ++ ra)
                  (shows_prec_list Zero_nat
                    "problem: l_v_r != l @ v @ r"))))))))
                                (\ xa ->
                                  Inl (shows_prec_list Zero_nat
 "problem in checking overlap DPOC2 of " .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list Zero_nat "to yield" .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPOC3_1 p_new p1 oc1 l ra ->
      let {
        (left, (l2, (m2, lxr))) = p1;
        (x, v) = oc1;
        (lefta, (l2a, (m2a, lvr))) = p_new;
      } in catch_errora
             (bindb
               (check (left == lefta)
                 (shows_prec_list Zero_nat "problem: left components modified"))
               (\ _ ->
                 bindb (check (m2 == m2a)
                         (shows_prec_list Zero_nat
                           "problem: m components modified"))
                   (\ _ ->
                     bindb (check (l2 == l2a)
                             (shows_prec_list Zero_nat
                               "problem: l components modified"))
                       (\ _ ->
                         bindb (check (lxr == l ++ x ++ ra)
                                 (shows_prec_list Zero_nat
                                   "problem: l_x_r != l @ x @ r"))
                           (\ _ ->
                             check (lvr == l ++ v ++ ra)
                               (shows_prec_list Zero_nat
                                 "problem: l_v_r != l @ v @ r"))))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      "problem in checking overlap DPOC3_1 of " .
                     shows_nl .
                       shows_pat p1 .
                         shows_nl .
                           shows_oc oc1 .
                             shows_nl .
                               shows_prec_list Zero_nat "to yield" .
                                 shows_nl . shows_pat p_new . shows_nl . xa));
    DPOC3_2 p_new p1 oc1 l ra x ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (m1, r1)) = aa;
           } in (\ (l2, (m2, lx)) ->
                  let {
                    (xr, v) = oc1;
                    ab = p_new;
                    (ac, ba) = ab;
                  } in let {
                         (l1a, (m1a, r1r)) = ac;
                       } in (\ (l2a, (m2a, lv)) ->
                              catch_errora
                                (bindb
                                  (check (m2 == m2a && m1 == m1a)
                                    (shows_prec_list Zero_nat
                                      "problem: m components modified"))
                                  (\ _ ->
                                    bindb (check (l1 == l1a)
    (shows_prec_list Zero_nat "problem: l components modified"))
                                      (\ _ ->
bindb (check (l2 == l2a)
        (shows_prec_list Zero_nat "problem: l2 components modified"))
  (\ _ ->
    bindb (check (lx == l ++ x)
            (shows_prec_list Zero_nat "problem: l_x != l @ x"))
      (\ _ ->
        bindb (check (xr == x ++ ra)
                (shows_prec_list Zero_nat "problem: x_r != x @ r"))
          (\ _ ->
            bindb (check (r1r == r1 ++ ra)
                    (shows_prec_list Zero_nat "problem: r1_r != r1 @ r"))
              (\ _ ->
                check (lv == l ++ v)
                  (shows_prec_list Zero_nat "problem: l_v != l @ v"))))))))
                                (\ xa ->
                                  Inl (shows_prec_list Zero_nat
 "problem in checking overlap DPOC3_2 of " .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list Zero_nat "to yield" .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPDP1_1 p_new p1 p2 l ra ->
      let {
        (left, (ll2, (mm, r2r))) = p1;
        a = p2;
        (aa, b) = a;
      } in let {
             (l2, (mma, r2)) = aa;
           } in (\ (l2a, (mm2, r2a)) ->
                  let {
                    (lefta, (ll2a, (mm2a, r2pr))) = p_new;
                  } in catch_errora
                         (bindb
                           (check (left == lefta)
                             (shows_prec_list Zero_nat
                               "problem: left components modified"))
                           (\ _ ->
                             bindb (check (mm == mma)
                                     (shows_prec_list Zero_nat
                                       "problem: mm components modified"))
                               (\ _ ->
                                 bindb (check (mm2 == mm2a)
 (shows_prec_list Zero_nat "problem: mm2 components modified"))
                                   (\ _ ->
                                     bindb (check (ll2 == l ++ l2)
     (shows_prec_list Zero_nat "problem: l_l2 != l @ l2"))
                                       (\ _ ->
 bindb (check (r2r == r2 ++ ra)
         (shows_prec_list Zero_nat "problem: r2_r != r2 @ r"))
   (\ _ ->
     bindb (check (r2pr == r2a ++ ra)
             (shows_prec_list Zero_nat "problem: r2pr != r2\' @ r"))
       (\ _ ->
         check (ll2a == l ++ l2a)
           (shows_prec_list Zero_nat "problem: l_l2 != l @ l2 "))))))))
                         (\ x ->
                           Inl (shows_prec_list Zero_nat
                                  "problem in checking overlap DPDP1_1 of " .
                                 shows_nl .
                                   shows_pat p1 .
                                     shows_nl .
                                       shows_pat p2 .
 shows_nl .
   shows_prec_list Zero_nat "to yield" .
     shows_nl . shows_pat p_new . shows_nl . x)))
             b;
    DPDP1_2 p_new p1 p2 l ra ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (mm1, r1)) = aa;
           } in (\ (ll2, (mm, r1a)) ->
                  let {
                    ab = p2;
                    (ac, ba) = ab;
                  } in let {
                         (l2, (mm2, r1r)) = ac;
                       } in (\ (l2a, (mm2a, r2)) ->
                              let {
                                ad = p_new;
                                (ae, bb) = ad;
                              } in let {
                                     (l3, (mm3, r1pr)) = ae;
                                   } in (\ (ll2a, (mm3a, r3)) ->
  catch_errora
    (bindb
      (check (l1 == l3)
        (shows_prec_list Zero_nat "problem: l1\' components modified"))
      (\ _ ->
        bindb (check (mm1 == mm3)
                (shows_prec_list Zero_nat "problem: mm1\' components modified"))
          (\ _ ->
            bindb (check (mm == mm2)
                    (shows_prec_list Zero_nat
                      "problem: mm components modified"))
              (\ _ ->
                bindb (check (mm2a == mm3a)
                        (shows_prec_list Zero_nat
                          "problem: mm2\' components modified"))
                  (\ _ ->
                    bindb (check (r2 == r3)
                            (shows_prec_list Zero_nat
                              "problem: r2\' components modified"))
                      (\ _ ->
                        bindb (check (ll2 == l ++ l2)
                                (shows_prec_list Zero_nat
                                  "problem: l_l2 != l @ l2"))
                          (\ _ ->
                            bindb (check (r1pr == r1 ++ ra)
                                    (shows_prec_list Zero_nat
                                      "problem: r1\'r != r1\' @ r"))
                              (\ _ ->
                                bindb (check (r1r == r1a ++ ra)
(shows_prec_list Zero_nat "problem: r1r != r1 @ r"))
                                  (\ _ ->
                                    check (ll2a == l ++ l2a)
                                      (shows_prec_list Zero_nat
"problem: l_l2 != l @ l2 "))))))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat "problem in checking overlap DPDP1_2 of " .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list Zero_nat "to yield" .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
    DPDP2_1 p_new p1 p2 l ra ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (mm1, r1)) = aa;
           } in (\ (l1a, (mm, r2r)) ->
                  let {
                    ab = p2;
                    (ac, ba) = ab;
                  } in let {
                         (ll1, (mm2, r2)) = ac;
                       } in (\ (l2, (mm2a, r2a)) ->
                              let {
                                ad = p_new;
                                (ae, bb) = ad;
                              } in let {
                                     (ll1a, (mm3, r3)) = ae;
                                   } in (\ (l3, (mm3a, r2pr)) ->
  catch_errora
    (bindb
      (check (r2r == r2 ++ ra)
        (shows_prec_list Zero_nat "problem: r2r != r2 @ r"))
      (\ _ ->
        bindb (check (ll1 == l ++ l1a)
                (shows_prec_list Zero_nat "problem: l_l1 != l @ l1"))
          (\ _ ->
            bindb (check (ll1a == l ++ l1)
                    (shows_prec_list Zero_nat "problem: l_l1\' != l @ l1\' "))
              (\ _ ->
                bindb (check (mm1 == mm3)
                        (shows_prec_list Zero_nat
                          "problem: mm1\' component modified"))
                  (\ _ ->
                    bindb (check (r1 == r3)
                            (shows_prec_list Zero_nat
                              "problem: r1\' component modified"))
                      (\ _ ->
                        bindb (check (l2 == l3)
                                (shows_prec_list Zero_nat
                                  "problem: l2\' component modified"))
                          (\ _ ->
                            bindb (check (mm2a == mm3a)
                                    (shows_prec_list Zero_nat
                                      "problem: mm2\' components modified"))
                              (\ _ ->
                                bindb (check (mm == mm2)
(shows_prec_list Zero_nat "problem: mm components modified"))
                                  (\ _ ->
                                    check (r2pr == r2a ++ ra)
                                      (shows_prec_list Zero_nat
"problem: r2\'r != r2\' @ r"))))))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat "problem in checking overlap DPDP2_1 of " .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list Zero_nat "to yield" .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
    DPDP2_2 p_new p1 p2 l ra ->
      let {
        a = p1;
        (aa, b) = a;
      } in let {
             (l1, (mm1, r1)) = aa;
           } in (\ (l1a, (mm1a, r1a)) ->
                  let {
                    ab = p2;
                    (ac, ba) = ab;
                  } in let {
                         (ll1, (mm2, r1r)) = ac;
                       } in (\ right ->
                              let {
                                ad = p_new;
                                (ae, bb) = ad;
                              } in let {
                                     (ll1a, (mm3, r1pr)) = ae;
                                   } in (\ righta ->
  catch_errora
    (bindb
      (check (r1r == r1a ++ ra)
        (shows_prec_list Zero_nat "problem: r1r != r1 @ r"))
      (\ _ ->
        bindb (check (ll1 == l ++ l1a)
                (shows_prec_list Zero_nat "problem: l_l1 != l @ l1"))
          (\ _ ->
            bindb (check (ll1a == l ++ l1)
                    (shows_prec_list Zero_nat "problem: l_l1\' != l @ l1\' "))
              (\ _ ->
                bindb (check (r1pr == r1 ++ ra)
                        (shows_prec_list Zero_nat
                          "problem: r1\'_r != r1\' @ r "))
                  (\ _ ->
                    bindb (check (mm1 == mm3)
                            (shows_prec_list Zero_nat
                              "problem: mm1\' component modified"))
                      (\ _ ->
                        bindb (check (mm1a == mm2)
                                (shows_prec_list Zero_nat
                                  "problem: mm components modified"))
                          (\ _ ->
                            check (right == righta)
                              (shows_prec_list Zero_nat
                                "problem: right components modified"))))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat "problem in checking overlap DPDP2_ of " .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list Zero_nat "to yield" .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
  });

check_proof ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Set (([a], ((Nat, (Nat, [a])), [a])),
                          ([a], ((Nat, (Nat, [a])), [a]))) ->
                      [Dp_proof_step a] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_proof r delta (p : ps) =
  bindb (check_step r p)
    (\ _ ->
      bindb (catch_errora
              (forallM
                (\ pa ->
                  check (member pa delta)
                    (shows_prec_list Zero_nat
                       "problem: nothing known about premise " .
                      shows_pat pa))
                (prems_ofa p))
              (\ x -> Inl (snd x)))
        (\ _ ->
          check_proof r
            (sup_set delta
              (inserta (pat_of p)
                (set_empty
                  (of_phantom
                    (set_impl_prod ::
                      Phantom
                        (([a], ((Nat, (Nat, [a])), [a])),
                          ([a], ((Nat, (Nat, [a])), [a])))
                        Set_impla)))))
            ps));
check_proof r delta [] = Inr ();

check_non_loop_srs_proof ::
  forall a.
    (Ceq a, Ccompare a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Non_loop_srs_proof a ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_srs_proof ra (SE_OC (m, lmr) l r steps) =
  bindb (check
          (membera (map pat_of steps)
            (([], ((Zero_nat, (Zero_nat, [])), m)),
              ([], ((Zero_nat, (Zero_nat, [])), lmr))))
          (shows_prec_list Zero_nat "overlap closure not derived within proof"))
    (\ _ ->
      bindb (check (lmr == l ++ m ++ r)
              (shows_prec_list Zero_nat "no selfoverlap"))
        (\ _ ->
          check_proof ra
            (set_empty
              (of_phantom
                (set_impl_prod ::
                  Phantom
                    (([a], ((Nat, (Nat, [a])), [a])),
                      ([a], ((Nat, (Nat, [a])), [a])))
                    Set_impla)))
            steps));
check_non_loop_srs_proof ra (SE_DP (left, right) l r steps) =
  bindb (check (membera (map pat_of steps) (left, right))
          (shows_prec_list Zero_nat "overlap closure not derived within proof"))
    (\ _ ->
      let {
        a = left;
        (l1, aa) = a;
        (ab, b) = aa;
      } in let {
             (f1, (c1, m1)) = ab;
           } in (\ r1 ->
                  let {
                    ac = right;
                    (l2, ad) = ac;
                    (ae, ba) = ad;
                  } in let {
                         (f2, (c2, m2)) = ae;
                       } in (\ r2 ->
                              bindb (check
                                      (m1 == m2 &&
l2 == l ++ l1 && r2 == r1 ++ r)
                                      (shows_prec_list Zero_nat
"problem with selfoverlap"))
                                (\ _ ->
                                  bindb (check
  (less_eq_nat f1 f2 &&
    equal_nat (mod_nat (max (minus_nat c2 c1) (minus_nat c1 c2)) f1) Zero_nat &&
      (if less_nat f1 f2 then equal_nat (mod_nat f2 f1) Zero_nat else True) &&
        (if equal_nat f1 f2 then less_eq_nat c1 c2 else True))
  (shows_prec_list Zero_nat
    "could not ensure fitting condition for selfoverlap"))
                                    (\ _ ->
                                      check_proof ra
(set_empty
  (of_phantom
    (set_impl_prod ::
      Phantom (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
        Set_impla)))
steps)))
                         ba)
             b);

srs_of_trs_impl :: forall a b. [(Term a b, Term a b)] -> [([a], [a])];
srs_of_trs_impl r =
  concatMap
    (\ (l, ra) ->
      (if unary_term l
        then (if unary_term ra then [(term_to_string l, term_to_string ra)]
               else [])
        else []))
    r;

check_non_loop_srs_prf ::
  forall a b c d.
    (Ceq b, Ccompare b, Eq b,
      Showa b) => Tp_ops_ext a b c d ->
                    a -> Non_loop_srs_proof b ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_srs_prf i tp prf =
  let {
    r = rulesc i tp;
    s = set (srs_of_trs_impl r);
  } in bindb (check (null (qb i tp))
               (shows_prec_list Zero_nat "strategy for non-loops unsupported"))
         (\ _ -> check_non_loop_srs_proof s prf);

check_not_wwf_qtrs ::
  forall a b c.
    (Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_not_wwf_qtrs i tp =
  bindb (check (null (qb i tp) || not (nfsb i tp))
          (shows_prec_list Zero_nat
            "strategies and normal form substitutions problem"))
    (\ _ ->
      check (not (isOK (check_wwf_qtrs (is_QNFb i tp) (rulesc i tp))))
        (shows_string "The Q-TRS is well formed" . shows_nl));

check_tp_subsumesa ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      ([Term (Lab b c) [Prelude.Char]],
                        [(Term (Lab b c) [Prelude.Char],
                           Term (Lab b c) [Prelude.Char])])) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_tp_subsumesa i t tp =
  let {
    (nfsa, (q, rulesa)) = t;
    nfs = nfsb i tp;
    rules = rulesc i tp;
    qa = qb i tp;
  } in catch_errora
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list Zero_nat
               "incompatible substitutions-in-normal-form flags"))
           (\ _ ->
             bindb (catch_errora (check_subseteq rulesa rules)
                     (\ x ->
                       Inl (toomuch "rule"
                             (shows_rule (shows_prec_lab Zero_nat)
                               (shows_prec_list Zero_nat) " -> " x))))
               (\ _ ->
                 catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                   (\ x ->
                     Inl (shows_prec_list Zero_nat
                            "NF(Q) differs due to term " .
                           shows_term (shows_prec_lab Zero_nat)
                             (shows_prec_list Zero_nat) x)))))
         (\ x ->
           Inl (shows_prec_list Zero_nat
                  "problem in showing subsumption for non-termination" .
                 shows_nl . x));

check_non_loop_trs_prf ::
  forall a b c d.
    (Compare b, Eq b, Showa b, Cenum c, Ceq c, Ccompare c, Compare c, Eq c,
      Mapping_impl c, Set_impl c,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Non_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_trs_prf i tp prf =
  let {
    r = rulesc i tp;
  } in bindb (check (null (qb i tp))
               (shows_prec_list Zero_nat "strategy for non-loops unsupported"))
         (\ _ -> check_non_loop_prf r [] prf);

uncurry_nonterm_tt_check ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      ([((b, Nat), [b])] -> b -> Nat -> b) ->
                        (b -> Nat ->
                                [((b, Nat), [b])] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_nonterm_tt_check i info fmap check_inj r dpp =
  let {
    (a, (sml, (u, e))) = info;
    ra = rulesc i dpp;
    nfs = nfsb i dpp;
    sm = sig_list_to_sig_map a sml fmap;
    r_eta = e ++ ra;
    uR = uncurry_rules a sm r_eta;
  } in (case bindb (check (null (qb i dpp))
                     (shows_prec_list Zero_nat
                       "strategy not supported for uncurrying"))
               (\ _ ->
                 let {
                   s = uncurry_of_sig_list a sml sm;
                 } in bindb (only_eta_rules e r_eta)
                        (\ _ ->
                          bindb (check_inj a (Nat_of_num (Bit0 One)) sml)
                            (\ _ ->
                              bindb (catch_errora (check_CS_subseteq u s)
                                      (\ x ->
Inl (shows_prec_list Zero_nat "rule " .
      shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " x .
        shows_prec_list Zero_nat " is not an uncurry rule")))
                                (\ _ ->
                                  catch_errora (check_subseteq r (u ++ uR))
                                    (\ x ->
                                      Inl
(shows_prec_list Zero_nat "rule " .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " x .
    shows_prec_list Zero_nat
      " is neither uncurried rules nor uncurry rule"))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkb i nfs [] r []);
       });

uncurry_nonterm_tt ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Uncurry_nt_proof b c [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_nonterm_tt i (Uncurry_nt_proof (a, (sml, (u, e))) r) tp =
  uncurry_nonterm_tt_check i (a, (sml, (u, e))) (fmap a (Nat_of_num (Bit0 One)))
    check_inj r tp;

rule_removal_nonterm_reltrs ::
  forall a b c.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_reltrs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_reltrs i tp (Rule_removal_nonterm_reltrs_prf r s) =
  let {
    rrm = (if is_none r then [] else ceta_list_diff (rb i tp) (the r));
    srm = (if is_none s then [] else ceta_list_diff (rwb i tp) (the s));
  } in Inr (delete_R_Rwb i tp rrm srm);

check_rel_tp_subsumes ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      ([Term (Lab b c) [Prelude.Char]],
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          [(Term (Lab b c) [Prelude.Char],
                             Term (Lab b c) [Prelude.Char])]))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_tp_subsumes i t tp =
  let {
    (nfsa, (q, (r, rw))) = t;
    nfs = nfsb i tp;
    rules = rulesc i tp;
    ra = rb i tp;
    qa = qb i tp;
  } in catch_errora
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list Zero_nat
               "incompatible substitutions-in-normal-form flags"))
           (\ _ ->
             bindb (catch_errora (check_subseteq rw rules)
                     (\ x ->
                       Inl (toomuch "rule"
                             (shows_rule (shows_prec_lab Zero_nat)
                               (shows_prec_list Zero_nat) " -> " x))))
               (\ _ ->
                 bindb (catch_errora (check_subseteq r ra)
                         (\ x ->
                           Inl (toomuch "rule"
                                 (shows_rule (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) " -> " x))))
                   (\ _ ->
                     catch_errora (check_NF_terms_subset (is_NF_terms q) qa)
                       (\ x ->
                         Inl (shows_prec_list Zero_nat
                                "NF(Q) differs due to term " .
                               shows_term (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) x))))))
         (\ x ->
           Inl (shows_prec_list Zero_nat
                  "problem in showing subsumption for non-termination" .
                 shows_nl . x));

check_not_wf_reltrs ::
  forall a b c.
    (Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_not_wf_reltrs i tp =
  bindb (check (q_emptyb i tp)
          (shows_prec_list Zero_nat "currently only empty Q is supported"))
    (\ _ ->
      check (not (isOK (check_wf_reltrs (rb i tp, rwb i tp))))
        (shows_string "The TRSs R and S are well formed" . shows_nl));

reltrs_as_trs ::
  forall a b c.
    Tp_ops_ext a b c () -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
reltrs_as_trs i tp =
  let {
    q = qb i tp;
    r = rb i tp;
    nfs = nfsb i tp;
    a = mkb i nfs q r [];
  } in Inr a;

check_rel_trs_loop ::
  forall a b c.
    (Eq b, Showa b, Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rel_trs_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_trs_loop i tp (Rel_trs_loop_prf s rseq sigma c) =
  bindb (check (q_emptyb i tp) (shows_prec_list Zero_nat "Q is not empty"))
    (\ _ -> check_rel_loop s rseq sigma c (rb i tp) (rwb i tp));

check_reltrs_nontermination_proof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Reltrs_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_reltrs_nontermination_proof ia j assms i tp (Rel_Loop p) =
  debug (i []) "Loop"
    (catch_errora (check_rel_trs_loop ia tp p)
      (\ x -> Inl (i . shows_string ": error in loop proof" . shows_nl . x)));
check_reltrs_nontermination_proof ia j assms i tp (Rel_R_Not_SN prf) =
  bindb (reltrs_as_trs ia tp)
    (\ tpa ->
      catch_errora
        (check_trs_nontermination_proof ia j assms (i . shows_string ".1") tpa
          prf)
        (\ x ->
          Inl (i . shows_string ": error below the nontermination proof for R" .
                     shows_nl . indent x)));
check_reltrs_nontermination_proof ia j assms i tp Rel_Not_Well_Formed =
  debug (i []) "Not Well-Formed"
    (catch_errora (check_not_wf_reltrs ia tp)
      (\ x ->
        Inl (i . shows_string ": error in not-well-formed proof" .
                   shows_nl . x)));
check_reltrs_nontermination_proof ia j assms i tp (Rel_TRS_String_Reversal prf)
  = debug (i []) "String Reversal"
      (bindb
        (catch_errora (string_reversal_complete_rel_tt ia tp)
          (\ x ->
            Inl (i . shows_string ": error when applying string reversal on" .
                       shows_nl .
                         shows_tp (shows_prec_lab Zero_nat)
                           (shows_prec_list Zero_nat) ia tp .
                           shows_nl . x)))
        (\ tpa ->
          catch_errora
            (check_reltrs_nontermination_proof ia j assms
              (i . shows_string ".1") tpa prf)
            (\ x ->
              Inl (i . shows_string
                         ": error below the string reversal technique" .
                         shows_nl . indent x))));
check_reltrs_nontermination_proof ia j assms i tp (Rel_Rule_Removal p prf) =
  debug (i []) "Rule Removal"
    (bindb (rule_removal_nonterm_reltrs ia tp p)
      (\ tpa ->
        catch_errora
          (check_reltrs_nontermination_proof ia j assms (i . shows_string ".1")
            tpa prf)
          (\ x ->
            Inl (i . shows_string ": error below the rule removal" .
                       shows_nl . indent x))));
check_reltrs_nontermination_proof ia j assms i tp (Rel_TRS_Assume_Not_SN t ass)
  = debug (i []) "Finiteness Assumption or Unknown Proof"
      (if assms
        then bindb (catch_errora (check_rel_tp_subsumes ia t tp)
                     (\ x ->
                       Inl (i . shows_string
                                  ": error in non-termination assumption or unknown proof" .
                                  shows_nl . x . shows_nl)))
               (\ _ ->
                 catch_errora
                   (catch_errora
                     (forallM_index
                       (\ asa ja ->
                         check_assmb ia j
                           (check_trs_nontermination_proof ia j assms
                             (i . shows_string "." .
                                    shows_prec_nat Zero_nat
                                      (plus_nat ja (Nat_of_num One))))
                           (check_dp_nontermination_proof ia j assms
                             (i . shows_string "." .
                                    shows_prec_nat Zero_nat
                                      (plus_nat ja (Nat_of_num One))))
                           (check_reltrs_nontermination_proof ia j assms
                             (i . shows_string "." .
                                    shows_prec_nat Zero_nat
                                      (plus_nat ja (Nat_of_num One))))
                           (check_fp_nontermination_proof ia j assms
                             (i . shows_string "." .
                                    shows_prec_nat Zero_nat
                                      (plus_nat ja (Nat_of_num One))))
                           (check_unknown_disproof ia j assms
                             (i . shows_string "." .
                                    shows_prec_nat Zero_nat
                                      (plus_nat ja (Nat_of_num One))))
                           asa)
                       ass)
                     (\ x -> Inl (snd x)))
                   (\ x ->
                     Inl (i . shows_string ": error below unknown proof" .
                                shows_nl . indent x)))
        else Inl (i . shows_string
                        ": the proof contains an assumption or unknown proof" .
                        shows_nl));

check_trs_nontermination_proof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_nontermination_proof ia j assms i tp (TRS_Loop p) =
  debug (i []) "Loop"
    (catch_errora (check_trs_loop ia tp p)
      (\ x ->
        Inl (i . shows_string ": error when checking loop of " .
                   shows_nl .
                     shows_tp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) ia tp .
                       shows_nl . indent x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Nonloop p) =
  debug (i []) "Nonloop"
    (catch_errora (check_non_loop_trs_prf ia tp p)
      (\ x ->
        Inl (shows_prec_list Zero_nat
               "problem in checking possibly non-looping infinite reduction for " .
              shows_nl .
                shows_tp (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) ia
                  tp .
                  indent x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Nonloop_SRS p) =
  debug (i []) "Nonloop SRS"
    (catch_errora (check_non_loop_srs_prf ia tp p)
      (\ x ->
        Inl (shows_prec_list Zero_nat
               "problem in checking possibly non-looping infinite reduction for " .
              shows_nl .
                shows_tp (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) ia
                  tp .
                  indent x)));
check_trs_nontermination_proof ia j assms i tp TRS_Not_Well_Formed =
  debug (i []) "Not Well-Formed"
    (catch_errora (check_not_wwf_qtrs ia tp)
      (\ x ->
        Inl (i . shows_string ": error in not well-formed proof" .
                   shows_nl . x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Termination_Switch p prf) =
  debug (i []) "Switch to Termination"
    (bindb
      (catch_errora (switch_termination_tt ia p tp)
        (\ x ->
          Inl (i . shows_string
                     ": error in switching to full strategy for the DP-problem " .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . indent x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (i . shows_string ".1") tpa
            prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the termination switch technique" .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Rule_Removal p prf) =
  debug (i []) "Rule Removal"
    (bindb (rule_removal_nonterm_trs ia tp p)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (i . shows_string ".1") tpa
            prf)
          (\ x ->
            Inl (i . shows_string ": error below the rule removal" .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_String_Reversal prf) =
  debug (i []) "String Reversal"
    (bindb
      (catch_errora (string_reversal_complete_tt ia tp)
        (\ x ->
          Inl (i . shows_string ": error when applying string reversal on" .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (i . shows_string ".1") tpa
            prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the string reversal technique" .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Constant_String p prf) =
  debug (i []) "Constants into Unary"
    (bindb
      (catch_errora (const_to_string_complete_tt ia tp p)
        (\ x ->
          Inl (i . shows_string
                     ": error when turning constants into strings on" .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (i . shows_string ".1") tpa
            prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the constants into string technique" .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_DP_Trans p prf) =
  debug (i []) "DP Transformation"
    (bindb
      (catch_errora (dp_trans_nontermination_tt ia j tp p)
        (\ x ->
          Inl (i . shows_string ": error in DP transformation on" .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . x)))
      (\ dpp ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (i . shows_string ".1") dpp
            prf)
          (\ x ->
            Inl (i . shows_string ": error below the DP transformation" .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Q_Increase p prf) =
  debug (i []) "Q increase"
    (bindb (q_increase_nonterm_trs ia tp p)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (i . shows_string ".1") tpa
            prf)
          (\ x ->
            Inl (i . shows_string ": error below the Q increase technique" .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Uncurry p prf) =
  debug (i []) "Uncurrying"
    (bindb (uncurry_nonterm_tt ia p tp)
      (\ tpa ->
        catch_errora
          (check_trs_nontermination_proof ia j assms (i . shows_string ".1") tpa
            prf)
          (\ x ->
            Inl (i . shows_string ": error below the uncurrying technique" .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Assume_Not_SN t ass) =
  debug (i []) "Finiteness Assumption or Unknown Proof"
    (if assms
      then bindb (catch_errora (check_tp_subsumesa ia t tp)
                   (\ x ->
                     Inl (i . shows_string
                                ": error in non-termination assumption or unknown proof" .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_unknown_disproof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string ": error below unknown proof" .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      ": the proof contains an assumption or unknown proof" .
                      shows_nl));

check_fp_nontermination_proof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b c) [Prelude.Char],
                              (Term (Lab b c) [Prelude.Char], Location))],
                            [(Term (Lab b c) [Prelude.Char],
                               Term (Lab b c) [Prelude.Char])]) ->
                            Fp_nontermination_proof b c [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fp_nontermination_proof ia j assms i (pa, r) (FPTRS_Loop p) =
  debug (i []) "Loop"
    (catch_errora (check_fploop r pa p)
      (\ x ->
        Inl (i . shows_string ": error when checking forbidden pattern loop" .
                   shows_nl . indent x)));
check_fp_nontermination_proof ia j assms i (pa, r) (FPTRS_Rule_Removal p prf) =
  debug (i []) "Rule Removal"
    (bindb (rule_removal_nonterm_trs ia (mkb ia False [] r []) p)
      (\ tp ->
        catch_errora
          (check_fp_nontermination_proof ia j assms (i . shows_string ".1")
            (pa, rulesc ia tp) prf)
          (\ x ->
            Inl (i . shows_string ": error below the rule removal" .
                       shows_nl . indent x))));
check_fp_nontermination_proof ia j assms i tp (FPTRS_Assume_Not_SN t ass) =
  debug (i []) "Finiteness Assumption or Unknown Proof"
    (if assms
      then bindb (catch_errora (check_fp_tp_subsumes t tp)
                   (\ x ->
                     Inl (i . shows_string
                                ": error in non-termination assumption or unknown proof" .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_unknown_disproof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string ": error below unknown proof" .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      ": the proof contains an assumption or unknown proof" .
                      shows_nl));

check_dp_nontermination_proof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          d -> Dp_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_nontermination_proof ia j assms i dpp (DP_Loop p) =
  debug (i []) "Loop"
    (catch_errora (check_dp_loop j dpp p)
      (\ x ->
        Inl (i . shows_string
                   ": error in checking loop for the following DP-problem " .
                   shows_nl .
                     shows_dpp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) j dpp .
                       shows_nl . indent x)));
check_dp_nontermination_proof ia j assms i dpp (DP_Nonloop p) =
  debug (i []) "Nonloop"
    (catch_errora (check_non_loop_dp_prf j dpp p)
      (\ x ->
        Inl (i . shows_string
                   ": error in checking nonloop for the following DP-problem " .
                   shows_nl .
                     shows_dpp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) j dpp .
                       shows_nl . indent x)));
check_dp_nontermination_proof ia j assms i dpp (DP_Rule_Removal p prf) =
  debug (i []) "Rule Removal"
    (bindb (rule_removal_nonterm_dp j dpp p)
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (i . shows_string ".1") dppa
            prf)
          (\ x ->
            Inl (i . shows_string ": error below the pair and rule removal" .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Q_Reduction p prf) =
  debug (i []) "Q reduction"
    (bindb
      (catch_errora (dp_q_reduction_nonterm j dpp p)
        (\ x ->
          Inl (i . shows_string
                     ": error in reducing the innermost lhss in the following DP-problem " .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (i . shows_string ".1") dppa
            prf)
          (\ x ->
            Inl (i . shows_string ": error below the Q reduction" .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Q_Increase p prf) =
  debug (i []) "Q increase"
    (bindb (q_increase_nonterm_dp j dpp p)
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (i . shows_string ".1") dppa
            prf)
          (\ x ->
            Inl (i . shows_string ": error below the Q increase" .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Termination_Switch p prf) =
  debug (i []) "Switch to Termination"
    (bindb
      (catch_errora (switch_termination_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error in switching to full strategy for the DP-problem " .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (i . shows_string ".1") dppa
            prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below the termination switch processor" .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Instantiation p prf) =
  debug (i []) "Instantiation"
    (bindb
      (catch_errora (instantiation_complete_proc j dpp p)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the instantiation processor on " .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (i . shows_string ".1") dppa
            prf)
          (\ x ->
            Inl (i . shows_string ": error below the instantiation processor" .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Rewriting p prf) =
  debug (i []) "Rewriting"
    (bindb
      (catch_errora (rewriting_complete_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the rewriting processor" .
                     shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (i . shows_string ".1") dppa
            prf)
          (\ x ->
            Inl (i . shows_string ": error below the rewriting processor" .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Narrowing p prf) =
  debug (i []) "Narrowing"
    (bindb
      (catch_errora (narrowing_complete_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the narrowing processor" .
                     shows_nl . x)))
      (\ dppa ->
        catch_errora
          (check_dp_nontermination_proof ia j assms (i . shows_string ".1") dppa
            prf)
          (\ x ->
            Inl (i . shows_string ": error below the rewriting processor" .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Assume_Infinite dp ass) =
  debug (i []) "Finiteness Assumption or Unknown Proof"
    (if assms
      then bindb (catch_errora (check_dpp_subsumesa j dp dpp)
                   (\ x ->
                     Inl (i . shows_string
                                ": error in finiteness assumption or unknown proof" .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa ja ->
                       check_assmb ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_unknown_disproof ia j assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string ": error below unknown proof" .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      ": the proof contains an assumption or unknown proof" .
                      shows_nl));

check_unknown_disproof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Neg_unknown_proof b c [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_disproof ia j assms i tpa (Assume_NT_Unknown tp ass) =
  debug (i []) "Unknown Proof"
    (if assms
      then bindb (catch_errora
                   (check (tpa == tp)
                     (shows_prec_list Zero_nat
                        "unknown problems are not identical: " .
                       shows_nl .
                         shows_prec_list Zero_nat tpa .
                           shows_nl .
                             shows_prec_list Zero_nat " vs " .
                               shows_nl . shows_prec_list Zero_nat tp))
                   (\ x ->
                     Inl (i . shows_string
                                ": error in nontermination assumption or unknown proof" .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catch_errora
                 (forallM_index
                   (\ asa ja ->
                     check_assmb ia j
                       (check_trs_nontermination_proof ia j assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_dp_nontermination_proof ia j assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_reltrs_nontermination_proof ia j assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_fp_nontermination_proof ia j assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_unknown_disproof ia j assms
                         (i . shows_string "." .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string ": the proof contains an unknown proof" .
                      shows_nl));

check_unraveling ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                     [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        [(Term a b, Term a b)];
check_unraveling c_rs ctrs =
  catch_errora
    (bindb
      (catch_errora (check_subseteq ctrs (map fst c_rs))
        (\ x ->
          Inl (shows_prec_list Zero_nat "did not find rule " .
                shows_crule (shows_prec Zero_nat) (shows_prec Zero_nat) x .
                  shows_nl)))
      (\ _ ->
        bindb (case create_U c_rs of {
                Nothing ->
                  Inl (shows_prec_list Zero_nat
                        "unable to extract unraveling contexts");
                Just a -> Inr a;
              })
          (\ u ->
            bindb (catch_errora
                    (forallM
                      (\ (c, rs) ->
                        check (rules_impl u c == rs)
                          (shows_prec_list Zero_nat "problem with rules of " .
                            shows_crule (shows_prec Zero_nat)
                              (shows_prec Zero_nat) c .
                              shows_nl))
                      c_rs)
                    (\ x -> Inl (snd x)))
              (\ _ -> Inr (concatMap snd c_rs)))))
    (\ x ->
      Inl (shows_prec_list Zero_nat "problem in unraveling " . shows_nl . x));

check_quasi_reductive_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [((Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]),
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])])] ->
                            Quasi_reductive_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quasi_reductive_proof a ia i j ctrs (Unravel u_info prf) =
  debug (ia []) "Unravel"
    (bindb
      (catch_errora (check_unraveling u_info ctrs)
        (\ x ->
          Inl (ia . shows_string ": error in unraveling" .
                      shows_nl . indent x)))
      (\ r ->
        let {
          tp = mkb i False [] r [];
        } in catch_errora
               (check_trs_termination_proof i j a (ia . shows_string ".1") tp
                 prf)
               (\ x ->
                 Inl (ia . shows_string
                             ": error below strong normalization + wcr" .
                             shows_nl . indent x))));

check_subsumptions_guided ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [((Term a b, Term a b),
                       [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumptions_guided e [] = Inr ();
check_subsumptions_guided ea ((e, seq) : convs) =
  bindb (catch_errora (check_conversion ea seq (fst e) (snd e))
          (\ x ->
            Inl (shows_string "problem in conversion for equation " .
                  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " = "
                    e .
                    shows_nl . x)))
    (\ _ -> check_subsumptions_guided (e : ea) convs);

check_subsumption_guided ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption_guided ea e convs =
  bindb (catch_errora (check_subseteq ea (map fst convs))
          (\ x ->
            Inl (shows_string "could not find conversion for equation " .
                  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " = "
                    x)))
    (\ _ -> check_subsumptions_guided e convs);

check_subsumption_NF ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption_NF e r =
  catch_errora
    (forallM
      (\ ea ->
        catch_errora (check_join_NF r (fst ea) (snd ea))
          (\ x ->
            Inl (shows_string "could not join equation " .
                  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " = "
                    ea .
                    shows_nl . x)))
      e)
    (\ x -> Inl (snd x));

check_subsumption ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Maybe [((Term a b, Term a b),
                               [(Pos, ((Term a b, Term a b),
(Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption e r convs_o =
  (case convs_o of {
    Nothing -> check_subsumption_NF e r;
    Just a -> check_subsumption_guided e r a;
  });

check_completion_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])] ->
                              Completion_proof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_completion_proof a ia i j e r (SN_WCR_Eq joins_i prf conv1 conv2) =
  debug (ia []) "SN_WCR_Eq"
    (let {
       tp = mkb i False [] r [];
     } in bindb (catch_errora
                  (check_trs_termination_proof i j a (ia . shows_string ".1") tp
                    prf)
                  (\ x ->
                    Inl (ia . shows_string
                                ": error below strong normalization + wcr" .
                                shows_nl . indent x)))
            (\ _ ->
              bindb (catch_errora (check_subsumption_guided r e conv1)
                      (\ x ->
                        Inl (ia . shows_prec_list Zero_nat
                                    ": error when showing that rewrite relation can be simulated by equations" .
                                    shows_nl . indent x)))
                (\ _ ->
                  bindb (catch_errora (check_subsumption e r conv2)
                          (\ x ->
                            Inl (ia . shows_prec_list Zero_nat
": error when showing that equations can be simulated by rewrite system" .
shows_nl . indent x)))
                    (\ _ ->
                      catch_errora
                        (check_critical_pairs r (critical_pairs_impl r r)
                          joins_i)
                        (\ x ->
                          Inl (ia . shows_prec_list Zero_nat
                                      ": error when proving local confluence of " .
                                      shows_nl .
shows_tp (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) i tp .
  shows_nl . indent x))))));

check_equational_disproof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            (Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]) ->
                              Equational_disproof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_equational_disproof a ia i j e eq
  (Completion_and_Normalization_Different r p) =
  debug (ia []) "Completion_and_Normalization"
    (bindb (check_completion_proof a ia i j e r p)
      (\ _ ->
        let {
          s = fst eq;
          t = snd eq;
        } in (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
               (Nothing, _) ->
                 Inl (shows_string "error when computing normal forms of " .
                       shows_term (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) s .
                         shows_string " and " .
                           shows_term (shows_prec_lab Zero_nat)
                             (shows_prec_list Zero_nat) t);
               (Just _, Nothing) ->
                 Inl (shows_string "error when computing normal forms of " .
                       shows_term (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) s .
                         shows_string " and " .
                           shows_term (shows_prec_lab Zero_nat)
                             (shows_prec_list Zero_nat) t);
               (Just sa, Just ta) ->
                 (if not (equal_term sa ta) then Inr ()
                   else Inl (shows_term (shows_prec_lab Zero_nat)
                               (shows_prec_list Zero_nat) s .
                              shows_string " and " .
                                shows_term (shows_prec_lab Zero_nat)
                                  (shows_prec_list Zero_nat) t .
                                  shows_string " have same normal form " .
                                    shows_term (shows_prec_lab Zero_nat)
                                      (shows_prec_list Zero_nat) sa));
             })));

funs_crule_list ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> [a];
funs_crule_list r = add_funs_rule (fst r) (funs_trs_list (snd r));

funs_ctrs_list ::
  forall a b. [((Term a b, Term a b), [(Term a b, Term a b)])] -> [a];
funs_ctrs_list trs = concatMap funs_crule_list trs;

check_type3 ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_type3 r =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (check_subseteq (vars_term_list (snd (fst cr)))
              (vars_term_list (fst (fst cr)) ++ vars_trs_list (snd cr)))
            (\ x ->
              Inl (shows_string "variable " .
                    shows_prec Zero_nat x .
                      shows_string " occurs only in right-hand side of rule " .
                        shows_crule (shows_prec Zero_nat) (shows_prec Zero_nat)
                          cr .
                          shows_nl)))
        r)
      (\ x -> Inl (snd x)))
    (\ x -> Inl (shows_string "the CTRS is not of type 3" . shows_nl . x));

x_impl ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> [b];
x_impl cr i =
  concat
    (vars_term_list (fst (fst cr)) :
      map (vars_term_list . snd) (take i (snd cr)));

check_dctrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dctrs r =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                catch_errora
                  (check_subseteq (vars_term_list (fst (nth (snd cr) i)))
                    (x_impl cr i))
                  (\ x ->
                    Inl (shows_string "variable " .
                          shows_prec Zero_nat x .
                            shows_string " in condition " .
                              shows_rule (shows_prec Zero_nat)
                                (shows_prec Zero_nat) " -> " (nth (snd cr) i) .
                                shows_string " of rule " .
                                  shows_crule (shows_prec Zero_nat)
                                    (shows_prec Zero_nat) cr .
                                    shows_string "violates DCTRS condition" .
                                      shows_nl)))
              (upt Zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        r)
      (\ x -> Inl (snd x)))
    (\ x -> Inl (shows_string "the CTRS is not deterministic" . shows_nl . x));

check_wf_ctrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_ctrs r =
  catch_errora
    (bindb
      (catch_errora
        (forallM
          (\ cr ->
            check (not (is_Var (fst (fst cr))))
              (shows_string "variable left-hand side in rule " .
                shows_crule (shows_prec Zero_nat) (shows_prec Zero_nat) cr .
                  shows_nl))
          r)
        (\ x -> Inl (snd x)))
      (\ _ -> bindb (check_dctrs r) (\ _ -> check_type3 r)))
    (\ x -> Inl (shows_string "the CTRS is not well-formed" . shows_nl . x));

check_source_preserving ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> [b]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_source_preserving crs zv =
  catch_errora
    (forallM
      (\ cr ->
        catch_errora
          (forallM
            (\ i ->
              catch_errora
                (catch_errora
                  (check_subseteq (vars_term_list (fst (fst cr))) (zv cr i))
                  (\ _ ->
                    Inl (shows_prec_list Zero_nat
                           "Some variable in lhs does not occur in Z_" .
                          shows_prec_nat Zero_nat i .
                            shows_prec_list Zero_nat ". \n")))
                (\ x ->
                  Inl (shows_string
                         "The unraveling is not source preserving for rule " .
                        shows_crule (shows_prec Zero_nat) (shows_prec Zero_nat)
                          cr .
                          shows_nl . x)))
            (upt Zero_nat (size_list (snd cr))))
          (\ x -> Inl (snd x)))
      crs)
    (\ x -> Inl (snd x));

y_impl ::
  forall a b. ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> [b];
y_impl cr i =
  vars_term_list (snd (fst cr)) ++
    vars_term_list (snd (nth (snd cr) i)) ++ vars_trs_list (drop i (snd cr));

check_Z_vars ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                    (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                      Nat -> [b]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_Z_vars crs z =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                catch_errora
                  (bindb
                    (catch_errora
                      (check_subseteq (list_inter (x_impl cr i) (y_impl cr i))
                        (z cr i))
                      (\ x ->
                        Inl (shows_string "Variable " .
                              shows_prec Zero_nat x .
                                shows_string " does not occur." . shows_nl)))
                    (\ _ ->
                      check (distinct (z cr i))
                        (shows_string
                           " Z variables for rule are not distinct. " .
                          shows_nl)))
                  (\ x ->
                    Inl (shows_string "Conditions on Z variables  for " .
                          shows_crule (shows_prec Zero_nat)
                            (shows_prec Zero_nat) cr .
                            shows_string " are violated." . shows_nl . x)))
              (upt Zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        crs)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string
             "The CTRS does not fulfill the condition on Z variables. " .
            shows_nl . x));

check_U_cond ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    Nat -> Ctxt a b) ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      [a] ->
                        (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                          Nat -> [b]) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_U_cond u crs f z =
  catch_errora
    (catch_errora
      (forallM
        (\ cr ->
          catch_errora
            (forallM
              (\ i ->
                (case u cr i of {
                  Hole ->
                    Inl (shows_prec_list Zero_nat " Unexpected empty context.");
                  More fa [] Hole aft ->
                    catch_errora
                      (bindb
                        (catch_errora (check_disjoint [fa] f)
                          (\ _ ->
                            Inl (shows_string "The function symbol " .
                                  shows_string (shows_prec Zero_nat fa []) .
                                    shows_string " is not fresh. " . shows_nl)))
                        (\ _ ->
                          bindb (check (aft == map Var (z cr i))
                                  (shows_prec_list Zero_nat
                                    " U does not map to Z vars "))
                            (\ _ -> check_f cr i fa crs u)))
                      (\ x ->
                        Inl (shows_string "Conditions for " .
                              shows_crule (shows_prec Zero_nat)
                                (shows_prec Zero_nat) cr .
                                shows_string " at  " .
                                  shows_prec_nat Zero_nat i .
                                    shows_string " are violated." .
                                      shows_nl . x));
                  More _ [] (More _ _ _ _) _ ->
                    Inl (shows_prec_list Zero_nat " Unexpected empty context.");
                  More _ (_ : _) _ _ ->
                    Inl (shows_prec_list Zero_nat " Unexpected empty context.");
                }))
              (upt Zero_nat (size_list (snd cr))))
            (\ x -> Inl (snd x)))
        crs)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string
             "The CTRS does not fulfill the condition on the U symbols." .
            shows_nl . x));

create_Umap_cr ::
  forall a b.
    ((Term a b, Term a b), [(Term a b, Term a b)]) ->
      [(Term a b, Term a b)] ->
        Maybe [(a, (((Term a b, Term a b), [(Term a b, Term a b)]), Nat))];
create_Umap_cr cr r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      mapMa (\ (a, b) ->
              let {
                (l, _) = a;
              } in (\ i ->
                     (case l of {
                       Var _ -> Nothing;
                       Fun _ [] -> Nothing;
                       Fun u (_ : _) -> Just (u, (cr, i));
                     }))
                b)
        (zip rr (upt Zero_nat (size_list rr)));
  });

create_Umap ::
  forall a b.
    (Eq a) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                 [(Term a b, Term a b)])] ->
                a -> Maybe (((Term a b, Term a b), [(Term a b, Term a b)]),
                             Nat);
create_Umap c_rs =
  (case mapMa (\ (a, b) -> create_Umap_cr a b) c_rs of {
    Nothing -> (\ _ -> Nothing);
    Just u -> map_of (concat u);
  });

check_sp_unraveling ::
  forall a b.
    (Eq a, Showa a, Ceq b, Ccompare b, Eq b, Set_impl b,
      Showa b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                     [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        [(Term a b, Term a b)];
check_sp_unraveling c_rs ctrs =
  catch_errora
    (bindb
      (catch_errora (check_same_set ctrs (map fst c_rs))
        (\ x ->
          Inl (shows_prec_list Zero_nat "did not find rule " .
                shows_crule (shows_prec Zero_nat) (shows_prec Zero_nat) x .
                  shows_nl)))
      (\ _ ->
        bindb (case create_U c_rs of {
                Nothing ->
                  Inl (shows_prec_list Zero_nat
                        "unable to extract unraveling contexts");
                Just a -> Inr a;
              })
          (\ u ->
            bindb (case create_Z c_rs of {
                    Nothing ->
                      Inl (shows_prec_list Zero_nat
                            "unable to extract Z variables");
                    Just a -> Inr a;
                  })
              (\ z ->
                bindb (Inr (create_Umap c_rs))
                  (\ _ ->
                    bindb (check_U_cond u ctrs (funs_ctrs_list ctrs) z)
                      (\ _ ->
                        bindb (check_Z_vars ctrs z)
                          (\ _ ->
                            bindb (check_dctrs ctrs)
                              (\ _ ->
                                bindb (check_type3 ctrs)
                                  (\ _ ->
                                    bindb (catch_errora
    (forallM
      (\ (c, rs) ->
        check (rules_impl u c == rs)
          (shows_prec_list Zero_nat "problem with rules of " .
            shows_crule (shows_prec Zero_nat) (shows_prec Zero_nat) c .
              shows_nl))
      c_rs)
    (\ x -> Inl (snd x)))
                                      (\ _ ->
bindb (catch_errora (check_left_linear_trs (concatMap snd c_rs))
        (\ x ->
          Inl (shows_prec_list Zero_nat
                 "the unraveled TRS is not left-linear " .
                shows_nl . x)))
  (\ _ ->
    bindb (catch_errora (check_wf_ctrs ctrs)
            (\ x ->
              Inl (shows_prec_list Zero_nat "the CTRS is not well-formed " .
                    shows_nl . x)))
      (\ _ ->
        bindb (catch_errora (check_source_preserving ctrs z)
                (\ x ->
                  Inl (shows_prec_list Zero_nat
                         "unraveling is not source preserving " .
                        shows_nl . x)))
          (\ _ -> Inr (concatMap snd c_rs))))))))))))))
    (\ x ->
      Inl (shows_string "preconditions on the unraveling are not satisfied" .
            shows_nl . x));

check_conditional_cr_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [((Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]),
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])])] ->
                            Conditional_cr_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conditional_cr_proof a ia i j ctrs (Unravel_CR u_info prf) =
  debug (ia []) "Unravel"
    (bindb
      (catch_errora (check_sp_unraveling u_info ctrs)
        (\ x ->
          Inl (ia . shows_string ": error in unraveling" .
                      shows_nl . indent x)))
      (\ r ->
        catch_errora (check_cr_proof a (ia . shows_string ".1") i j r prf)
          (\ x ->
            Inl (ia . shows_string ": error below confluence proof" .
                        shows_nl . indent x))));

check_fptrs_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b [Nat]) [Prelude.Char],
                              (Term (Lab b [Nat]) [Prelude.Char], Location))],
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])]) ->
                            Fptrs_termination_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fptrs_termination_proof ia j a i tp prf =
  check_fptrs_termination_proof_main ia j a i tp (unlab_to_split_otrs prf);

check_single_subsumption ::
  forall a b.
    (Eq a, Showa a, Ccompare b, Eq b, Mapping_impl b,
      Showa b) => (Term a b, Term a b) ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_single_subsumption eq e convs =
  bindb (check (membera (map fst convs) eq)
          (shows_string "could not find conversion for equation " .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " = " eq))
    (\ _ -> check_subsumptions_guided e convs);

eq_proof_lines ::
  forall a b.
    (Showa a,
      Showa b) => Eq_proof a b ->
                    Nat ->
                      ([Prelude.Char] -> [Prelude.Char],
                        (Nat, (Term a b, Term a b)));
eq_proof_lines (Refl s) i =
  ((shows_nl .
     shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) .
       shows_string ": ") .
     shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " = " (s, s) .
       shows_string " [refl]",
    (plus_nat i (Nat_of_num One), (s, s)));
eq_proof_lines (Sym p) i =
  let {
    (s, (ia, (l, r))) = eq_proof_lines p i;
  } in (s . (shows_nl .
              shows_prec_nat Zero_nat (plus_nat ia (Nat_of_num One)) .
                shows_string ": ") .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " = "
                (r, l) .
                shows_string " [sym " .
                  shows_prec_nat Zero_nat ia . shows_string "]",
         (plus_nat ia (Nat_of_num One), (r, l)));
eq_proof_lines (Trans p1 p2) i =
  let {
    (s1, (i1, (s, _))) = eq_proof_lines p1 i;
    (s2, (i2, (_, v))) = eq_proof_lines p2 i1;
  } in (s1 . s2 . (shows_nl .
                    shows_prec_nat Zero_nat (plus_nat i2 (Nat_of_num One)) .
                      shows_string ": ") .
                    shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " = "
                      (s, v) .
                      shows_string " [trans " .
                        shows_prec_nat Zero_nat i1 .
                          shows_string ", " .
                            shows_prec_nat Zero_nat i2 . shows_string "]",
         (plus_nat i2 (Nat_of_num One), (s, v)));
eq_proof_lines (Assm (l, r) sigma) i =
  let {
    eq = (subst_apply_term l sigma, subst_apply_term r sigma);
  } in ((shows_nl .
          shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) .
            shows_string ": ") .
          shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " = " eq .
            shows_string " [assm " .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " = "
                (l, r) .
                shows_string "]",
         (plus_nat i (Nat_of_num One), eq));
eq_proof_lines (Cong f ps) i =
  let {
    (s, (is, (ls, rs))) = eq_proofs_lines ps i;
    eq = (Fun f ls, Fun f rs);
    ia = last is;
    isa = butlast is;
  } in (s . (shows_nl .
              shows_prec_nat Zero_nat (plus_nat ia (Nat_of_num One)) .
                shows_string ": ") .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) " = " eq .
                shows_list_gen (shows_prec_nat Zero_nat) " [cong]" " [cong "
                  ", " "]" isa,
         (plus_nat ia (Nat_of_num One), eq));

eq_proofs_lines ::
  forall a b.
    (Showa a,
      Showa b) => [Eq_proof a b] ->
                    Nat ->
                      ([Prelude.Char] -> [Prelude.Char],
                        ([Nat], ([Term a b], [Term a b])));
eq_proofs_lines [] i = (id, ([i], ([], [])));
eq_proofs_lines (p : ps) i =
  let {
    (s1, (ia, (l, r))) = eq_proof_lines p i;
    (s2, (is, (ls, rs))) = eq_proofs_lines ps ia;
  } in (s1 . s2, (ia : is, (l : ls, r : rs)));

check_proves ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Eq_proof a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Term a b, Term a b);
check_proves e (Refl s) = Inr (s, s);
check_proves e (Sym p) = bindb (check_proves e p) (\ (s, t) -> Inr (t, s));
check_proves e (Trans p1 p2) =
  bindb (check_proves e p1)
    (\ (s, t) ->
      bindb (check_proves e p2)
        (\ (ta, u) ->
          (if equal_term t ta then Inr (s, u)
            else Inl (shows_string "the error occurs in the following part " .
                       shows_nl .
                         fst (eq_proof_lines (Trans p1 p2) Zero_nat) .
                           shows_nl .
                             shows_nl .
                               shows_prec_term Zero_nat t .
                                 shows_string " is not equal to " .
                                   shows_prec_term Zero_nat ta))));
check_proves e (Assm (l, r) sigma) =
  (if membera e (l, r)
    then Inr (subst_apply_term l sigma, subst_apply_term r sigma)
    else Inl (shows_string "the error occurs in the following part " .
               shows_nl .
                 fst (eq_proof_lines (Assm (l, r) sigma) Zero_nat) .
                   shows_nl .
                     shows_nl .
                       shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                         " = " (l, r) .
                         shows_string " is not in the " .
                           shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
                             "equational system:" " = " e));
check_proves e (Cong f ps) =
  bindb (mapM (check_proves e) ps)
    (\ sts -> Inr (Fun f (map fst sts), Fun f (map snd sts)));

check_eq_proof ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Eq_proof a b ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_eq_proof e p eq =
  catch_errora
    (bindb (check_proves e p)
      (\ eqa ->
        (if eq == eqa then Inr ()
          else Inl (shows_string "the proof does not fit the goal"))))
    (\ x ->
      Inl (shows_string "there is an error in the equational logic proof" .
            shows_nl .
              fst (eq_proof_lines p Zero_nat) .
                shows_nl .
                  shows_nl .
                    shows_string "for proving the equation" .
                      shows_nl .
                        shows_nl .
                          shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                            " = " eq .
                            shows_nl .
                              shows_nl .
                                shows_string "using the " .
                                  shows_trs (shows_prec Zero_nat)
                                    (shows_prec Zero_nat) "equational system:"
                                    " = " e .
                                    shows_nl . x));

check_equational_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            (Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]) ->
                              Equational_proof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_equational_proof a ia i j e eq (Equational_Proof_Tree p) =
  debug (ia []) "Equational_Proof_Tree" (check_eq_proof e p eq);
check_equational_proof a ia i j e eq (Conversion eseq) =
  debug (ia []) "Conversion" (check_conversion e eseq (fst eq) (snd eq));
check_equational_proof a ia i j e eq (Conversion_With_History convs) =
  debug (ia []) "Conversion with History" (check_single_subsumption eq e convs);
check_equational_proof a ia i j e eq (Completion_and_Normalization r p) =
  debug (ia []) "Completion_and_Normalization"
    (bindb (check_completion_proof a ia i j e r p)
      (\ _ ->
        let {
          s = fst eq;
          t = snd eq;
        } in (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
               (Nothing, _) ->
                 Inl (shows_string "error when computing normal forms of " .
                       shows_term (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) s .
                         shows_string " and " .
                           shows_term (shows_prec_lab Zero_nat)
                             (shows_prec_list Zero_nat) t);
               (Just _, Nothing) ->
                 Inl (shows_string "error when computing normal forms of " .
                       shows_term (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) s .
                         shows_string " and " .
                           shows_term (shows_prec_lab Zero_nat)
                             (shows_prec_list Zero_nat) t);
               (Just sa, Just ta) ->
                 (if equal_term sa ta then Inr ()
                   else Inl (shows_term (shows_prec_lab Zero_nat)
                               (shows_prec_list Zero_nat) s .
                              shows_string " and " .
                                shows_term (shows_prec_lab Zero_nat)
                                  (shows_prec_list Zero_nat) t .
                                  shows_string " have different normal forms"));
             })));

check_dp_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          c -> Dp_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_termination_proof ia j a i dpp prf =
  check_dp_termination_proof_main ia j a i dpp (fst (unlab_to_split_dp prf));

get_args_impl :: forall a b. Bool -> Term a b -> [Term a b];
get_args_impl True t = args t;
get_args_impl False t = [t];

innermost_repl_map_impl ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                        [((a, Nat), Nat)];
innermost_repl_map_impl r ecap p =
  remdups
    (concatMap
      (\ ((l, ra), b) ->
        concatMap
          (\ u ->
            (if not (is_Var u)
              then concatMap
                     (\ rs ->
                       concatMap
                         (\ f ->
                           concatMap
                             (\ n ->
                               concatMap
                                 (\ i ->
                                   (if contains_var_term (Inl ())
 (ecap (get_args_impl b l) (nth rs i))
                                     then [(f, i)] else []))
                                 (upt Zero_nat n))
                             [snd f])
                         [the (root u)])
                     [args u]
              else []))
          (supteq_list ra))
      (map (\ lr -> (lr, True)) r ++ map (\ st -> (st, False)) p));

mu_i_P_impl ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                        ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
mu_i_P_impl r ecap p =
  let {
    fis = innermost_repl_map_impl r ecap p;
    fs = remdups (map fst fis);
    mu = (\ f ->
           set (map_filter
                 (\ x ->
                   (if let {
                         (g, _) = x;
                       } in g == f
                     then Just (snd x) else Nothing))
                 fis));
  } in (fs, (precompute_fun mu fs, "innermost URM"));

mu_i_impl ::
  forall a.
    (Eq a, Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
mu_i_impl r ecap = mu_i_P_impl r ecap [];

default_fs ::
  forall a.
    (Key a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(a, Nat)];
default_fs r = funas_trs_list r;

full_empty ::
  forall a.
    (Eq a) => [(a, Nat)] -> ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
full_empty fs =
  let {
    fsa = filter (\ (_, n) -> not (equal_nat n Zero_nat)) fs;
  } in (fsa, ((\ f ->
                (if membera fsa f then full_af f
                  else set_empty (of_phantom set_impl_nat))),
               "full AF"));

get_fs_mu ::
  forall a.
    (Cenum a, Ceq a, Ccompare a, Eq a, Key a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      Bool ->
                        Complexity_measure a [Prelude.Char] ->
                          ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
get_fs_mu r ecap inn (Runtime_Complexity c d) =
  (if inn && less_eq_set (inf_set (set c) (set (defined_list r))) bot_set
    then mu_i_impl r ecap else full_empty (remdups (c ++ d ++ default_fs r)));
get_fs_mu r ecap inn (Derivational_Complexity f) =
  full_empty (remdups (f ++ default_fs r));

is_Fsharp_term ::
  forall a b.
    (Cenum a, Ceq a, Ccompare a,
      Set_impl a) => Set (a, Nat) -> Set (a, Nat) -> Term a b -> Bool;
is_Fsharp_term uu uv (Var uw) = False;
is_Fsharp_term fs fa (Fun f ts) =
  member (f, size_list ts) fs &&
    less_eq_set (set (concatMap funas_term_list ts)) fa;

funas_mctxt_list :: forall a b. Mctxt a b -> [(a, Nat)];
funas_mctxt_list (MFun f cs) =
  (f, size_list cs) : concatMap funas_mctxt_list cs;
funas_mctxt_list (MVar v) = [];
funas_mctxt_list MHole = [];

split_term ::
  forall a b. (Term a b -> Bool) -> Term a b -> (Mctxt a b, [Term a b]);
split_term p (Var x) = (if p (Var x) then (MHole, [Var x]) else (MVar x, []));
split_term p (Fun f ts) =
  (if p (Fun f ts) then (MHole, [Fun f ts])
    else let {
           us = map (split_term p) ts;
         } in (MFun f (map fst us), concatMap snd us));

split_DP ::
  forall a b.
    (Ceq a,
      Ccompare a) => Set (a, Nat) ->
                       (Term a b, Term a b) -> (Mctxt a b, [Term a b]);
split_DP fs =
  (\ r ->
    split_term (\ t -> not (is_Var t) && member (the (root t)) fs) (snd r));

check_DP_complexity ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Set_impl a, Showa a,
      Showa b) => [(Term a b, Term a b)] ->
                    Complexity_measure a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        ([(Term a b, Term a b)],
                          ([(Term a b, Term a b)],
                            ([(a, Nat)], ([(a, Nat)], [(a, Nat)]))));
check_DP_complexity p (Derivational_Complexity uu) =
  Inl (shows_prec_list Zero_nat "require runtime complexity");
check_DP_complexity p (Runtime_Complexity c fs) =
  let {
    fsa = set fs;
    (rs, r) = partition (\ lr -> member (the (root (fst lr))) fsa) p;
    cs_ts = map (split_DP fsa) rs;
    cp = remdups (concatMap (funas_mctxt_list . fst) cs_ts);
    cpa = set cp;
    f = remdups
          (c ++ funas_trs_list r ++
                  concat
                    (concatMap (\ (fsb, _) -> map funas_term_list (args fsb))
                      rs) ++
                    concat
                      (concatMap
                        (\ (_, a) ->
                          concatMap (\ t -> map funas_term_list (args t)) a)
                        cs_ts));
    fa = set f;
  } in bindb (check
               (is_empty (inf_set fa fsa) &&
                 is_empty (inf_set fa cpa) && is_empty (inf_set fsa cpa))
               (shows_prec_list Zero_nat "symbols are not disjoint"))
         (\ _ ->
           bindb (check (all (\ lr -> is_Fsharp_term fsa fa (fst lr)) rs)
                   (shows_prec_list Zero_nat "lhss of RS are not sharp terms"))
             (\ _ -> Inr (rs, (r, (cp, (fs, f))))));

get_fs_mu_DP ::
  forall a.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Key a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ([Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] ->
                        Term a (Sum () [Prelude.Char])) ->
                      Bool ->
                        [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                          Complexity_measure a [Prelude.Char] ->
                            ([(a, Nat)], ((a, Nat) -> Set Nat, [Prelude.Char]));
get_fs_mu_DP r ecap inn s cm =
  let {
    (fs, (mu, info)) = get_fs_mu r ecap inn cm;
  } in (case check_DP_complexity r cm of {
         Inl _ -> (fs, (mu, info));
         Inr (rs, (_, (cp, (_, _)))) ->
           (if all (membera rs) s
             then (list_inter fs cp,
                    ((\ f ->
                       (if membera cp f then mu f
                         else set_empty (of_phantom set_impl_nat))),
                      info ++ " with DPs"))
             else (fs, (mu, info)));
       });

shows_prec_complexity_class ::
  Nat -> Complexity_class -> [Prelude.Char] -> [Prelude.Char];
shows_prec_complexity_class d c =
  (if equal_nat (degree c) Zero_nat then shows_prec_list Zero_nat "O(1)"
    else (if equal_nat (degree c) (Nat_of_num One)
           then shows_prec_list Zero_nat "O(n)"
           else shows_string "O(n^" .
                  shows_prec_nat Zero_nat (degree c) .
                    shows_prec_list Zero_nat ")"));

less_eq_complexity_class :: Complexity_class -> Complexity_class -> Bool;
less_eq_complexity_class x y = less_eq_nat (degree x) (degree y);

is_ur_closed_af_impl_tp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Set Nat) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Term b [Prelude.Char] -> Bool;
is_ur_closed_af_impl_tp_mv i d pi =
  let {
    ic = icap_impl_tp i d;
    qnf = is_QNFb i d;
    r = rulesc i d;
    urc = (\ s -> is_ur_closed_term_af_impl qnf (ic s) pi r);
  } in (\ u s ->
         let {
           sa = map (map_term (\ x -> x) (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_term (\ x -> x) (\ a -> 'x' : a) t)));

extract_rt_C_D ::
  forall a b.
    Complexity_measure a b ->
      Sum ([Prelude.Char] -> [Prelude.Char]) ([(a, Nat)], [(a, Nat)]);
extract_rt_C_D (Runtime_Complexity c d) = Inr (c, d);
extract_rt_C_D (Derivational_Complexity v) =
  Inl (shows_prec_list Zero_nat "runtime complexity required");

cpx ::
  forall a b c.
    Redtriple_ext a b c ->
      Complexity_measure a b ->
        Sum ([Prelude.Char] -> [Prelude.Char]) Complexity_class;
cpx (Redtriple_ext valid s ns nst af mono_af mono desc not_ws_ns cpx more) =
  cpx;

rule_shift_complexity_urm_ur_tt ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          Complexity_measure b [Prelude.Char] ->
                            Complexity_class ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_shift_complexity_urm_ur_tt i rp rdelete ur cm cc tp =
  let {
    rba = rulesc i tp;
    r = rb i tp;
    rw = rwb i tp;
    r2 = ceta_list_diff r rdelete;
    rremain = rw ++ r2;
    isnf = is_QNFb i tp;
    inn = nFQ_subset_NF_rulesb i tp;
  } in (case catch_errora
               (bindb
                 (catch_errora (check_subseteq rdelete rba)
                   (\ x ->
                     Inl (shows_string "rule " .
                           shows_rule (shows_prec Zero_nat)
                             (shows_prec_list Zero_nat) " -> " x .
                             shows_prec_list Zero_nat
                               " should be deleted, but does not occur in problem")))
                 (\ _ ->
                   bindb (check_wf_trs rba)
                     (\ _ ->
                       bindb (check (nFQ_subset_NF_rulesb i tp)
                               (shows_prec_list Zero_nat "innermost required"))
                         (\ _ ->
                           let {
                             (fs, (mu, info)) =
                               get_fs_mu_DP rba (icap_impl isnf rba) inn rdelete
                                 cm;
                             (_, (pi, _)) =
                               get_fs_mu_DP rba (icap_impl isnf rba) inn rremain
                                 cm;
                           } in bindb (extract_rt_C_D cm)
                                  (\ (cl, dl) ->
                                    let {
                                      c = set cl;
                                      d = set dl;
                                    } in bindb
   (check (null (list_inter cl (defined_list rba)))
     (shows_prec_list Zero_nat "constructors " .
       shows_prec_list Zero_nat cl .
         shows_prec_list Zero_nat " must not be defined"))
   (\ _ ->
     bindb (valid rp)
       (\ _ ->
         bindb (catch_errora
                 (forallM
                   (\ (l, ra) ->
                     check (not (member (the (root l)) d &&
                                  less_eq_set
                                    (foldr (sup_set . funas_term) (args l)
                                      bot_set)
                                    c))
                       (shows_rule (shows_prec Zero_nat)
                          (shows_prec_list Zero_nat) " -> " (l, ra) .
                         shows_prec_list Zero_nat " should be usable"))
                   (list_diff rba ur))
                 (\ x -> Inl (snd x)))
           (\ _ ->
             let {
               is_urc = is_ur_closed_af_impl_tp_mv i tp mu ur;
               pia = af_inter (af rp) pi;
               is_urc_pi = is_ur_closed_af_impl_tp_mv i tp pia ur;
             } in bindb (catch_errora
                          (forallM
                            (\ (l, ra) ->
                              check (is_urc (args l) ra &&
                                      is_urc_pi (args l) ra)
                                (shows_prec_list Zero_nat
                                   "problem with closure properties of usable rule " .
                                  shows_rule (shows_prec Zero_nat)
                                    (shows_prec_list Zero_nat) " -> " (l, ra) .
                                    shows_prec_list Zero_nat
                                      ": rhs is not closed under usable rules"))
                            ur)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (catch_errora
                              (catch_errora
                                (forallM
                                  (\ f ->
                                    check (subset (mu f) (mono_af rp f))
                                      (shows_string
 "error in monotonicity: strict order for " .
shows_prec_prod Zero_nat f .
  shows_string " ensures monotonicity in positions " .
    show_position_set f (mono_af rp f) .
      shows_string "\nbut usable replacement map is " .
        show_position_set f (mu f)))
                                  fs)
                                (\ x -> Inl (snd x)))
                              (\ x ->
                                Inl (x . shows_string
   "\nthe computed usable replacement map (" .
   shows_string info .
     shows_string ") is\n" .
       shows_sep
         (\ f ->
           shows_prec_list Zero_nat "mu(" .
             shows_prec_prod Zero_nat f .
               shows_prec_list Zero_nat ") = " . show_position_set f (mu f))
         shows_nl fs .
         shows_prec_list Zero_nat "\nand mu(f) = {} for all other symbols f")))
                        (\ _ ->
                          bindb (catch_errora
                                  (catch_errora
                                    (forallM (s rp) (list_inter rdelete ur))
                                    (\ x -> Inl (snd x)))
                                  (\ x ->
                                    Inl (shows_string
   "problem when orienting strict TRS\n" .
  x)))
                            (\ _ ->
                              bindb (catch_errora
                                      (catch_errora
(forallM (ns rp) (list_inter rremain ur)) (\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string "problem when orienting non-strict TRS\n" . x)))
                                (\ _ ->
                                  bindb (cpx rp cm)
                                    (\ cca ->
                                      check (less_eq_complexity_class cca cc)
(shows_prec_list Zero_nat "could only derive complexity " .
  shows_prec_complexity_class Zero_nat cca))))))))))))))
               (\ x ->
                 Inl (shows_string "could not derive the intended complexity " .
                       shows_prec_complexity_class Zero_nat cc .
                         shows_string " from the following\n" .
                           desc rp .
                             shows_nl .
                               x . shows_string "\nwith usable rules\n" .
                                     shows_trs (shows_prec Zero_nat)
                                       (shows_prec_list Zero_nat)
                                       "rewrite system:" " -> " ur))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i (nfsb i tp) (qb i tp) r2 (list_union rw rdelete));
       });

inn_usable_rules_wf_tp ::
  forall a b.
    (Eq b,
      Key b) => Tp_ops_ext a b [Prelude.Char] () ->
                  a -> Bool ->
                         ([Term b [Prelude.Char]], Term b [Prelude.Char]) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])];
inn_usable_rules_wf_tp i d nfs =
  inn_usable_rules_wf (is_QNFb i d) (icap_impl_tp i d) (rulesc i d) nfs;

x_1_to_x_n :: Nat -> [[Prelude.Char]];
x_1_to_x_n = fresh_strings_list "x" (Nat_of_num One) [];

get_innermost_strict_repl_map_rc ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                           Complexity_measure b c ->
                             ([(b, Nat)],
                               ((b, Nat) -> Set Nat, [Prelude.Char]));
get_innermost_strict_repl_map_rc i d s (Derivational_Complexity f) =
  full_empty (remdups (f ++ default_fs (rulesc i d)));
get_innermost_strict_repl_map_rc i da s (Runtime_Complexity c d) =
  let {
    r = rulesc i da;
  } in (if nFQ_subset_NF_rulesb i da &&
             less_eq_set (inf_set (set c) (set (defined_list r))) bot_set
         then let {
                isNF = is_QNFb i da;
                u = inn_usable_rules_wf_tp i da True;
                a = icap_impl_tp i da;
              } in mu_approx_impl r
                     (concatMap
                       (\ (f, n) ->
                         concatMap
                           (\ xs -> map (\ lr -> (xs, (Fun f xs, lr))) s)
                           [map Var (x_1_to_x_n n)])
                       d)
                     (\ ss t -> u (ss, t)) isNF a
         else full_empty (remdups (c ++ d ++ default_fs r)));

get_innermost_strict_repl_map_rc_DP ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                           Complexity_measure b [Prelude.Char] ->
                             ([(b, Nat)],
                               ((b, Nat) -> Set Nat, [Prelude.Char]));
get_innermost_strict_repl_map_rc_DP i d s t =
  let {
    (fs, (mu, info)) = get_innermost_strict_repl_map_rc i d s t;
  } in (case check_DP_complexity (rulesc i d) t of {
         Inl _ -> (fs, (mu, info));
         Inr (rs, (_, (cp, (_, _)))) ->
           (if all (membera rs) s
             then (list_inter fs cp,
                    ((\ f ->
                       (if membera cp f then mu f
                         else set_empty (of_phantom set_impl_nat))),
                      info ++ " with DPs"))
             else (fs, (mu, info)));
       });

rule_shift_complexity_urm_tt ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        Complexity_measure b [Prelude.Char] ->
                          Complexity_class ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_shift_complexity_urm_tt i rp rdelete cm cc tp =
  let {
    rba = rulesc i tp;
    r = rb i tp;
    rw = rwb i tp;
    r2 = ceta_list_diff r rdelete;
    _ = qb i tp;
  } in (case catch_errora
               (bindb
                 (catch_errora (check_subseteq rdelete rba)
                   (\ x ->
                     Inl (shows_string "rule " .
                           shows_rule (shows_prec Zero_nat)
                             (shows_prec_list Zero_nat) " -> " x .
                             shows_prec_list Zero_nat
                               " should be deleted, but does not occur in problem")))
                 (\ _ ->
                   bindb (check_wf_trs rba)
                     (\ _ ->
                       let {
                         (fs, (mu, info)) =
                           get_innermost_strict_repl_map_rc_DP i tp rdelete cm;
                       } in bindb (valid rp)
                              (\ _ ->
                                bindb (catch_errora
(catch_errora
  (forallM
    (\ f ->
      check (subset (mu f) (mono_af rp f))
        (shows_prec_list Zero_nat "error in monotonicity: strict order for " .
          shows_prec_prod Zero_nat f .
            shows_prec_list Zero_nat " ensures monotonicity in positions " .
              show_position_set f (mono_af rp f) .
                shows_nl .
                  shows_prec_list Zero_nat "but usable replacement map is " .
                    show_position_set f (mu f)))
    fs)
  (\ x -> Inl (snd x)))
(\ x ->
  Inl (x . shows_nl .
             shows_prec_list Zero_nat "the computed usable replacement map (" .
               shows_prec_list Zero_nat info .
                 shows_prec_list Zero_nat ") is" .
                   shows_nl .
                     shows_sep
                       (\ f ->
                         shows_prec_list Zero_nat "mu(" .
                           shows_prec_prod Zero_nat f .
                             shows_prec_list Zero_nat ") = " .
                               show_position_set f (mu f))
                       shows_nl fs .
                       shows_nl .
                         shows_prec_list Zero_nat
                           "and mu(f) = {} for all other symbols f")))
                                  (\ _ ->
                                    bindb (catch_errora
    (catch_errora (forallM (s rp) rdelete) (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string "problem when orienting strict TRS" . shows_nl . x)))
                                      (\ _ ->
bindb (catch_errora
        (catch_errora (forallM (ns rp) (rw ++ r2)) (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_string "problem when orienting non-strict TRS" .
                shows_nl . x)))
  (\ _ ->
    bindb (cpx rp cm)
      (\ cca ->
        check (less_eq_complexity_class cca cc)
          (shows_prec_list Zero_nat "could only derive complexity " .
            shows_prec_complexity_class Zero_nat cca)))))))))
               (\ x ->
                 Inl (shows_string "could not derive the intended complexity " .
                       shows_prec_complexity_class Zero_nat cc .
                         shows_prec_list Zero_nat " from the following" .
                           shows_nl . desc rp . shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i (nfsb i tp) (qb i tp) r2 (list_union rw rdelete));
       });

smart_rule_shift_complexity ::
  forall a b.
    (Card_UNIV b, Cenum b, Ceq b, Cproper_interval b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          Complexity_measure b [Prelude.Char] ->
                            Complexity_class ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
smart_rule_shift_complexity i rp rdelete (Just ur) cm cc tp =
  rule_shift_complexity_urm_ur_tt i rp rdelete ur cm cc tp;
smart_rule_shift_complexity i rp rdelete Nothing cm cc tp =
  rule_shift_complexity_urm_tt i rp rdelete cm cc tp;

usable_rules_complexity_innermost ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      Complexity_measure b [Prelude.Char] ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_complexity_innermost i nUr cm cc cp =
  catch_errora
    (let {
       s = rb i cp;
       w = rwb i cp;
       r = s ++ w;
     } in bindb (check (nFQ_subset_NF_rulesb i cp)
                  (shows_prec_list Zero_nat "innermost required"))
            (\ _ ->
              bindb (check_wf_trs r)
                (\ _ ->
                  bindb (extract_rt_C_D cm)
                    (\ (cl, dl) ->
                      let {
                        c = set cl;
                        d = set dl;
                        isnf = is_QNFb i cp;
                      } in bindb (check (null (list_inter cl (defined_list r)))
                                   (shows_prec_list Zero_nat "constructors " .
                                     shows_prec_list Zero_nat cl .
                                       shows_prec_list Zero_nat
 " must not be defined"))
                             (\ _ ->
                               bindb (catch_errora (check_subseteq nUr r)
                                       (\ _ ->
 Inl (shows_prec_list Zero_nat "rule " .
       shows_rules (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> " nUr .
         shows_prec_list Zero_nat " does not occur in problem")))
                                 (\ _ ->
                                   let {
                                     ur = list_diff r nUr;
                                   } in bindb
  (catch_errora
    (forallM
      (\ (l, ra) ->
        check (not (member (the (root l)) d &&
                     less_eq_set (foldr (sup_set . funas_term) (args l) bot_set)
                       c))
          (shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) " -> "
             (l, ra) .
            shows_prec_list Zero_nat " should be usable"))
      nUr)
    (\ x -> Inl (snd x)))
  (\ _ ->
    let {
      (_, (mu, _)) = get_fs_mu r (icap_impl isnf r) True cm;
      is_urc = is_ur_closed_af_impl_tp_mv i cp mu ur;
    } in bindb (catch_errora
                 (forallM
                   (\ (l, ra) ->
                     check (is_urc (args l) ra)
                       (shows_prec_list Zero_nat
                          "problem with closure properties of usable rule " .
                         shows_rule (shows_prec Zero_nat)
                           (shows_prec_list Zero_nat) " -> " (l, ra) .
                           shows_prec_list Zero_nat
                             ": rhs is not closed under usable rules"))
                   ur)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             Inr (mkb i (nfsb i cp) (qb i cp) (list_diff s nUr)
                   (list_diff w nUr))))))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "error when restricting to innermost usable rules" .
            shows_nl . x));

get_signature_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
get_signature_of_cm (Derivational_Complexity f) = f;
get_signature_of_cm (Runtime_Complexity c d) = c ++ d;

usable_rules_complexity_usymbols ::
  forall a b c.
    (Cenum b, Ceq b, Ccompare b, Compare b, Eq b, Set_impl b, Showa b,
      Compare c, Eq c,
      Showa c) => Tp_ops_ext a b c () ->
                    [(Term b c, Term b c)] ->
                      Complexity_measure b c ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_complexity_usymbols i nUr cm cc cp =
  catch_errora
    (let {
       s = rb i cp;
       w = rwb i cp;
       r = s ++ w;
     } in bindb (catch_errora (check_subseteq nUr r)
                  (\ _ ->
                    Inl (shows_prec_list Zero_nat "rule " .
                          shows_rules (shows_prec Zero_nat)
                            (shows_prec Zero_nat) " -> " nUr .
                            shows_prec_list Zero_nat
                              " does not occur in problem")))
            (\ _ ->
              let {
                ur = list_diff r nUr;
                us = set (concatMap (funas_term_list . snd) ur ++
                           get_signature_of_cm cm);
                urs = set ur;
              } in bindb (check_varcond_subset ur)
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ lr ->
                                   check (if less_eq_set (funas_term (fst lr))
       us
   then member lr urs else True)
                                     (shows_prec_list Zero_nat "rule " .
                                       shows_rule (shows_prec Zero_nat)
 (shows_prec Zero_nat) " -> " lr .
 shows_prec_list Zero_nat " should be usable"))
                                 r)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           Inr (mkb i (nfsb i cp) (qb i cp) (list_diff s nUr)
                                 (list_diff w nUr))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "error when restricting to usable rules w.r.t. usable symbols" .
            shows_nl . x));

usable_rules_complexity ::
  forall a b.
    (Cenum b, Ceq b, Ccompare b, Eq b, Key b, Set_impl b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      Complexity_measure b [Prelude.Char] ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_complexity i nUr cm cc cp =
  (case usable_rules_complexity_usymbols i nUr cm cc cp of {
    Inl e ->
      (case usable_rules_complexity_innermost i nUr cm cc cp of {
        Inl ea ->
          Inl (shows_prec_list Zero_nat
                 "neither of the usable rules processors is applicable: " .
                shows_nl .
                  shows_prec_list Zero_nat
                    "the one via usable symbols complains as follows" .
                    shows_nl .
                      e . shows_nl .
                            shows_nl .
                              shows_prec_list Zero_nat
                                "and the one via icap and innermost says " .
                                shows_nl . ea);
        Inr a -> Inr a;
      });
    Inr a -> Inr a;
  });

split_proc_complexity ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Tp_ops_ext a b c () ->
                    [(Term b c, Term b c)] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) (a, a);
split_proc_complexity i s1 cp =
  catch_errora
    (let {
       s = rb i cp;
       w = rwb i cp;
       nfs = nfsb i cp;
       q = qb i cp;
     } in bindb (catch_errora (check_subseteq s1 s)
                  (\ x ->
                    Inl (shows_prec_list Zero_nat "rule " .
                          shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                            " -> " x .
                            shows_prec_list Zero_nat " is not a strict rule")))
            (\ _ ->
              let {
                s2 = list_diff s s1;
              } in Inr (mkb i nfs q s1 (s2 ++ w), mkb i nfs q s2 (s1 ++ w))))
    (\ x ->
      Inl (shows_prec_list Zero_nat "error when splitting complexity problem" .
            shows_nl . x));

shows_complexity_measure ::
  forall a b.
    (Linorder a,
      Showa a) => Complexity_measure a b -> [Prelude.Char] -> [Prelude.Char];
shows_complexity_measure (Runtime_Complexity c d) =
  shows_prec_list Zero_nat "basic terms f(c1,..,cn) where f in " .
    shows_nl .
      shows_prec_list Zero_nat (sort_key (\ x -> x) d) .
        shows_nl .
          shows_prec_list Zero_nat " and ci is term over signature " .
            shows_nl .
              shows_prec_list Zero_nat (sort_key (\ x -> x) c) . shows_nl;
shows_complexity_measure (Derivational_Complexity f) =
  shows_prec_list Zero_nat "all terms over signature " .
    shows_nl . shows_prec_list Zero_nat (sort_key (\ x -> x) f) . shows_nl;

shows_complexityLL ::
  forall a b c.
    (Key a, Showa a, Key b, Showa b, Key c,
      Showa c) => ([Term (Lab a b) c],
                    ([(Term (Lab a b) c, Term (Lab a b) c)],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        (Complexity_measure (Lab a b) c, Complexity_class)))) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_complexityLL (q, (s, (w, (cm, cc)))) =
  shows_prec_list Zero_nat "strict rules" .
    shows_nl .
      shows_rules (shows_prec_lab Zero_nat) (shows_prec Zero_nat) " -> "
        (sort_key (\ x -> x) s) .
        shows_nl .
          shows_nl .
            shows_prec_list Zero_nat "weak rules" .
              shows_nl .
                shows_rules (shows_prec_lab Zero_nat) (shows_prec Zero_nat)
                  " -> " (sort_key (\ x -> x) w) .
                  shows_nl .
                    shows_nl .
                      shows_prec_list Zero_nat "innermost lhss (Q)" .
                        shows_nl .
                          shows_lines (sort_key (\ x -> x) q) .
                            shows_nl .
                              shows_nl .
                                shows_prec_list Zero_nat "starting terms: " .
                                  shows_complexity_measure cm .
                                    shows_nl .
                                      shows_prec_list Zero_nat
"intended complexity: " .
shows_prec_complexity_class Zero_nat cc . shows_nl;

check_terms_of_main ::
  forall a b.
    (Eq a,
      Showa a) => Complexity_measure a b ->
                    Complexity_measure a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_terms_of_main (Derivational_Complexity f) (Derivational_Complexity g) =
  catch_errora (check_subseteq f g)
    (\ x ->
      Inl (shows_prec_list Zero_nat "consider of symbol " .
            shows_prec_prod Zero_nat x));
check_terms_of_main (Runtime_Complexity f h) (Derivational_Complexity g) =
  catch_errora (check_subseteq (f ++ h) g)
    (\ x ->
      Inl (shows_prec_list Zero_nat "consider of symbol " .
            shows_prec_prod Zero_nat x));
check_terms_of_main (Runtime_Complexity f h) (Runtime_Complexity f1 h1) =
  bindb (catch_errora (check_subseteq f f1)
          (\ x ->
            Inl (shows_prec_list Zero_nat "consider symbol " .
                  shows_prec_prod Zero_nat x)))
    (\ _ ->
      catch_errora (check_subseteq h h1)
        (\ x ->
          Inl (shows_prec_list Zero_nat "consider symbol " .
                shows_prec_prod Zero_nat x)));
check_terms_of_main (Derivational_Complexity g) (Runtime_Complexity f1 h1) =
  Inl (shows_prec_list Zero_nat
        "mixing runtime complexity and derivational complexity");

check_terms_of_nat ::
  forall a b.
    (Eq a,
      Showa a) => Complexity_measure a b ->
                    Complexity_measure a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_terms_of_nat cm1 cm2 =
  catch_errora (check_terms_of_main cm1 cm2)
    (\ x ->
      Inl (shows_prec_list Zero_nat "error comparing start terms" .
            shows_nl . x));

check_complexity_subsumes ::
  forall a b c.
    (Eq a, Key a, Showa a, Eq b, Key b, Showa b, Ccompare c, Eq c, Key c,
      Mapping_impl c,
      Showa c) => ([Term (Lab a b) c],
                    ([(Term (Lab a b) c, Term (Lab a b) c)],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        (Complexity_measure (Lab a b) c, Complexity_class)))) ->
                    ([Term (Lab a b) c],
                      ([(Term (Lab a b) c, Term (Lab a b) c)],
                        ([(Term (Lab a b) c, Term (Lab a b) c)],
                          (Complexity_measure (Lab a b) c,
                            Complexity_class)))) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_complexity_subsumes (q1, (s1, (w1, (cm1, cc1))))
  (q2, (s2, (w2, (cm2, cc2)))) =
  catch_errora
    (bindb
      (catch_errora (check_subseteq s2 s1)
        (\ x ->
          Inl (shows_prec_list Zero_nat "strict rule " .
                shows_rule (shows_prec_lab Zero_nat) (shows_prec Zero_nat)
                  " -> " x .
                  shows_prec_list Zero_nat " is missing")))
      (\ _ ->
        bindb (catch_errora (check_subseteq w2 w1)
                (\ x ->
                  Inl (shows_prec_list Zero_nat "weak rule " .
                        shows_rule (shows_prec_lab Zero_nat)
                          (shows_prec Zero_nat) " -> " x .
                          shows_prec_list Zero_nat " is missing")))
          (\ _ ->
            bindb (catch_errora (check_NF_terms_subset (is_NF_terms q2) q1)
                    (\ x ->
                      Inl (shows_prec_list Zero_nat
                             "NF(Q) differs due to term " .
                            shows_prec_term Zero_nat x)))
              (\ _ ->
                bindb (check (less_eq_complexity_class cc1 cc2)
                        (shows_prec_list Zero_nat
                          "complexity classes do not match"))
                  (\ _ -> check_terms_of_nat cm2 cm1)))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "could not ensure that assumption matches current complexity problem" .
            shows_nl .
              x . shows_nl .
                    shows_nl .
                      shows_prec_list Zero_nat "assumption is " .
                        shows_nl .
                          shows_complexityLL (q1, (s1, (w1, (cm1, cc1)))) .
                            shows_nl .
                              shows_nl .
                                shows_prec_list Zero_nat "current problem is " .
                                  shows_nl .
                                    shows_complexityLL
                                      (q2, (s2, (w2, (cm2, cc2))))));

check_tup :: forall a b. (Ceq a, Ccompare a) => Set a -> Term a b -> Bool;
check_tup t (Var x) = False;
check_tup t (Fun f ts) = member f t;

dPos_impl ::
  forall a b.
    (Ceq a,
      Ccompare a) => Set (a, Nat) -> (a -> a) -> Term a b -> [(Pos, Term a b)];
dPos_impl d shp (Var x) = [];
dPos_impl d shp (Fun f ts) =
  let {
    n = size_list ts;
  } in (if member (f, n) d then (\ a -> (Empty, Fun (shp f) ts) : a) else id)
         (concatMap
           (\ (i, ti) -> map (\ (p, a) -> (PCons i p, a)) (dPos_impl d shp ti))
           (zip (upt Zero_nat n) ts));

check_rule_dt ::
  forall a b.
    (Ceq a, Ccompare a, Eq a, Showa a, Eq b,
      Showa b) => Set (a, Nat) ->
                    Set a ->
                      (a -> a) ->
                        ((Term a b, Term a b), (Term a b, Term a b)) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_dt d ds shp =
  (\ (a, b) ->
    let {
      (l, r) = a;
    } in (\ (dl, dr) ->
           catch_errora
             (let {
                sl = sharp_term shp l;
              } in bindb (check (equal_term sl dl)
                           (shows_string "wrong lhs, expected " .
                             shows_prec_term Zero_nat sl .
                               shows_string " but got " .
                                 shows_prec_term Zero_nat dl))
                     (\ _ ->
                       let {
                         pts = dPos_impl d shp r;
                         spts = map snd pts;
                         (_, dts) = split_term (check_tup ds) dr;
                       } in check (equal_multiset (multiset_of dts)
                                    (multiset_of spts))
                              (shows_prec_list Zero_nat
                                "multiset of subterms with defined roots differs")))
             (\ x ->
               Inl (shows_string "could not ensure that " .
                     shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                       " -> " (dl, dr) .
                       shows_string " is a valid dependency tuple for " .
                         shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                           " -> " (l, r) .
                           shows_nl . x)))
      b);

dt_transformation ::
  forall a b c.
    (Card_UNIV b, Ceq b, Cproper_interval b, Eq b, Set_impl b, Showa b,
      Ccompare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    Dt_transformation_info b c ->
                      (b -> b) ->
                        Complexity_measure b c ->
                          Complexity_class ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char])
                                   (Complexity_measure b c, a);
dt_transformation i info shp cm cc cp =
  catch_errora
    (let {
       (DT_Transformation_Info s_DT_s w_DT_w q) = info;
     } in (case cm of {
            Derivational_Complexity _ ->
              Inl (shows_prec_list Zero_nat
                    "only runtime complexity supported for dependency tuples");
            Runtime_Complexity c d ->
              let {
                s = rb i cp;
                w = rwb i cp;
                sa = map fst s_DT_s;
                wa = map fst w_DT_w;
                r = sa ++ wa;
                dd = defined_list r;
                dda = set d;
              } in bindb (catch_errora
                           (forallM
                             (\ lr ->
                               check (any (eq_rule_mod_vars lr) sa)
                                 (shows_prec_list Zero_nat
                                    "could not find DT for strict rule " .
                                   shows_prec_prod Zero_nat lr))
                             s)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ lr ->
                                   check (any (eq_rule_mod_vars lr) wa)
                                     (shows_prec_list Zero_nat
"could not find DT for weak rule " .
                                       shows_prec_prod Zero_nat lr))
                                 w)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catch_errora
                                   (forallM
                                     (\ f ->
                                       check (member f dda)
 (shows_prec_list Zero_nat "defined symbol " .
   shows_prec_prod Zero_nat f .
     shows_prec_list Zero_nat " does not occur in defined symbols from RC"))
                                     dd)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               let {
                                 dTs = map snd s_DT_s;
                                 dTw = map snd w_DT_w;
                                 da = set dd;
                                 shpf = (\ (f, a) -> (shp f, a));
                                 ds = image shpf da;
                                 ddd = image (shp . fst) da;
                                 f = funas_trs_list r ++ c ++ d;
                                 fs = set f;
                               } in bindb (catch_errora
    (forallM
      (\ qa ->
        check (not (is_Var qa) && not (member (the (root qa)) fs))
          (shows_prec_list Zero_nat "new Q-term " .
            shows_prec_term Zero_nat qa .
              shows_prec_list Zero_nat " not allowed"))
      q)
    (\ x -> Inl (snd x)))
                                      (\ _ ->
bindb (check_wf_trs r)
  (\ _ ->
    bindb (catch_errora (check_NF_terms_subset (is_QNFb i cp) (map fst r))
            (\ _ -> Inl (shows_prec_list Zero_nat "innermost required")))
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ fa ->
                    check (not (member fa ds))
                      (shows_prec_prod Zero_nat fa .
                        shows_prec_list Zero_nat
                          " as sharped symbol is not fresh"))
                  f)
                (\ x -> Inl (snd x)))
          (\ _ ->
            bindb (check (is_empty (inf_set (set c) da))
                    (shows_prec_list Zero_nat
                      "constructors of RC and defined symbols of TRSs are not disjoint"))
              (\ _ ->
                bindb (catch_errora (forallM (check_rule_dt da ddd shp) s_DT_s)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    bindb (catch_errora
                            (forallM (check_rule_dt da ddd shp) w_DT_w)
                            (\ x -> Inl (snd x)))
                      (\ _ ->
                        Inr (Runtime_Complexity c (map shpf d),
                              mkb i False (qb i cp ++ q) dTs
                                (r ++ dTw))))))))))));
          }))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "error when switching to dependency tuples" .
            shows_nl . x));

shows_mctxt ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Mctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_mctxt fun var MHole = shows_string "[]";
shows_mctxt fun var (MVar x) = var x;
shows_mctxt fun var (MFun f cs) =
  fun f . shows_list_gen id [] "(" ", " ")" (map (shows_mctxt fun var) cs);

shows_prec_mctxt ::
  forall a b.
    (Showa a, Showa b) => Nat -> Mctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_mctxt p c =
  shows_mctxt (shows_prec Zero_nat) (shows_prec Zero_nat) c;

ground_mctxt :: forall a b. Mctxt a b -> Bool;
ground_mctxt (MVar uu) = False;
ground_mctxt MHole = True;
ground_mctxt (MFun f cs) = all ground_mctxt cs;

funas_mctxt ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Mctxt a b -> Set (a, Nat);
funas_mctxt (MFun f cs) =
  sup_set (inserta (f, size_list cs) bot_set)
    (sup_seta (image funas_mctxt (set cs)));
funas_mctxt (MVar v) = bot_set;
funas_mctxt MHole = bot_set;

is_compound_context ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Compare b, Eq b) => Set (a, Nat) -> Mctxt a b -> Bool;
is_compound_context cComp c =
  ground_mctxt c && less_eq_set (funas_mctxt c) cComp;

if_Fun_in_set ::
  forall a b. (Ceq a, Ccompare a) => Set (a, Nat) -> Term a b -> Bool;
if_Fun_in_set f = (\ t -> is_Var t || member (the (root t)) f);

uncap_till :: forall a b. (Term a b -> Bool) -> Term a b -> [Term a b];
uncap_till p (Var x) = (if p (Var x) then [Var x] else []);
uncap_till p (Fun f ts) =
  (if p (Fun f ts) then [Fun f ts] else concatMap (uncap_till p) ts);

check_rule_wdp ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Compare a, Eq a,
      Set_impl a, Showa a, Compare b, Eq b,
      Showa b) => Set (a, Nat) ->
                    (a -> a) ->
                      ((Term a b, Term a b), (Term a b, Term a b)) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_wdp cComp shp =
  (\ (a, b) ->
    let {
      (l, r) = a;
    } in (\ (p, q) ->
           catch_errora
             (let {
                la = sharp_term shp l;
              } in bindb (check (equal_term la p)
                           (shows_string "wrong lhs, expected " .
                             shows_prec_term Zero_nat la .
                               shows_string " but got " .
                                 shows_prec_term Zero_nat p))
                     (\ _ ->
                       let {
                         us = uncap_till (if_Fun_in_set (uminus_set cComp)) r;
                         (c, usa) =
                           split_term (if_Fun_in_set (uminus_set cComp)) q;
                       } in bindb (check (map (sharp_term shp) us == usa)
                                    (shows_prec_list Zero_nat
                                      "lists of maximal subterms with defined root differ"))
                              (\ _ ->
                                check (is_compound_context cComp c)
                                  (shows_prec_mctxt Zero_nat c .
                                    shows_string
                                      " is not a proper compound context of " .
                                      shows_prec_term Zero_nat q))))
             (\ x ->
               Inl (shows_string "could not ensure that " .
                     shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                       " -> " (p, q) .
                       shows_string " is a valid weak dependency pair for " .
                         shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                           " -> " (l, r) .
                           shows_nl . x)))
      b);

check_wdp_trans ::
  forall a b c.
    (Finite_UNIV b, Cenum b, Ceq b, Cproper_interval b, Compare b, Eq b,
      Set_impl b, Showa b, Ccompare c, Compare c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    Wdp_trans_info b c ->
                      (b -> b) ->
                        Complexity_measure b c ->
                          Complexity_class ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char])
                                   (Complexity_measure b c, a);
check_wdp_trans i info shp cm cc cp =
  catch_errora
    (let {
       (WDP_Trans_Info compa s_wdps w_wdps q) = info;
     } in (case cm of {
            Derivational_Complexity _ ->
              Inl (shows_prec_list Zero_nat
                    "only runtime complexity supported for weak dependency pairs");
            Runtime_Complexity c d ->
              let {
                s = rb i cp;
                w = rwb i cp;
                sa = map fst s_wdps;
                wa = map fst w_wdps;
                r = sa ++ wa;
                fs = funas_trs_list r;
                ds = defined_list r;
                ca = minus_set (set fs) (set (defined_list r));
              } in bindb (catch_errora
                           (forallM
                             (\ ra ->
                               check (any (eq_rule_mod_vars ra) sa)
                                 (shows_prec_list Zero_nat
                                    "could not find weak dependency pair for strict rule " .
                                   shows_prec_prod Zero_nat ra))
                             s)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catch_errora
                               (forallM
                                 (\ ra ->
                                   check (any (eq_rule_mod_vars ra) wa)
                                     (shows_prec_list Zero_nat
"could not find weak dependency pair for weak rule " .
                                       shows_prec_prod Zero_nat ra))
                                 w)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           let {
                             wDP_S = map snd s_wdps;
                             wDP_W = map snd w_wdps;
                             shpf = (\ (f, a) -> (shp f, a));
                             f = fs ++ c ++ d;
                             f_sharps = map shpf f;
                             _ = image shpf (set f);
                             cComp = sup_set ca compa;
                           } in bindb (catch_errora
(forallM
  (\ qa ->
    check (not (is_Var qa) && not (membera f (the (root qa))))
      (shows_prec_list Zero_nat "new Q-term " .
        shows_prec_term Zero_nat qa . shows_prec_list Zero_nat " not allowed"))
  q)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    bindb (check_wf_trs r)
                                      (\ _ ->
bindb (catch_errora
        (forallM
          (\ fa ->
            check (not (member fa cComp))
              (shows_prec_prod Zero_nat fa .
                shows_prec_list Zero_nat " clashes with sharp symbols"))
          f_sharps)
        (\ x -> Inl (snd x)))
  (\ _ ->
    bindb (catch_errora
            (forallM
              (\ fa ->
                check (not (member fa cComp))
                  (shows_prec_prod Zero_nat fa .
                    shows_prec_list Zero_nat
                      " clashes with defined symbols of RC"))
              d)
            (\ x -> Inl (snd x)))
      (\ _ ->
        bindb (catch_errora
                (forallM
                  (\ fa ->
                    check (not (member fa cComp))
                      (shows_prec_prod Zero_nat fa .
                        shows_prec_list Zero_nat
                          " clashes with defined symbols"))
                  ds)
                (\ x -> Inl (snd x)))
          (\ _ ->
            bindb (catch_errora (forallM (check_rule_wdp cComp shp) s_wdps)
                    (\ x -> Inl (snd x)))
              (\ _ ->
                bindb (catch_errora (forallM (check_rule_wdp cComp shp) w_wdps)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    Inr (Runtime_Complexity c (map shpf d),
                          mkb i (nfsb i cp) (qb i cp ++ q) (wDP_S ++ sa)
                            (wDP_W ++ wa)))))))))));
          }))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "error when switching to weak dependency pairs" .
            shows_nl . x));

equal_boundstype :: Boundstype -> Boundstype -> Bool;
equal_boundstype Roof Match = False;
equal_boundstype Match Roof = False;
equal_boundstype Match Match = True;
equal_boundstype Roof Roof = True;

boundstype :: forall a b. Bounds_info a b -> Boundstype;
boundstype (Bounds_Info x1 x2 x3 x4 x5) = x1;

stackable_of_cm :: forall a b. Complexity_measure a b -> [(a, Nat)];
stackable_of_cm (Derivational_Complexity f) = f;
stackable_of_cm (Runtime_Complexity c d) = c;

bounds_complexity_rel ::
  forall a b c d.
    (Eq b, Key b, Showa b, Finite_UNIV c, Cenum c, Ceq c, Cproper_interval c,
      Eq c, Key c, Set_impl c, Showa c, Card_UNIV d, Cenum d, Ceq d, Ccompare d,
      Compare_order d, Eq d, Set_impl d,
      Showa d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      [(Term b c, Term b c)] ->
                        Complexity_measure b c ->
                          Complexity_class ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
bounds_complexity_rel i info rdelete cm cc tp =
  catch_errora
    (let {
       r = rb i tp;
       rw = rwb i tp;
       r2 = ceta_list_diff r rdelete;
     } in bindb (catch_errora (check_subseteq rdelete (rulesc i tp))
                  (\ x ->
                    Inl (shows_prec_list Zero_nat "could not find rule " .
                          shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                            " -> " x .
                            shows_prec_list Zero_nat
                              " in current complexity problem")))
            (\ _ ->
              bindb (check
                      (less_eq_complexity_class (Comp_Poly (Nat_of_num One)) cc)
                      (shows_prec_list Zero_nat
                        "can only ensure linear complexity"))
                (\ _ ->
                  bindb (check (equal_boundstype (boundstype info) Match)
                          (shows_prec_list Zero_nat
                            "complexity analysis requires boundstype match"))
                    (\ _ ->
                      let {
                        _ = rulesc i tp;
                      } in bindb (check_bounds_generic info rdelete (rw ++ r2)
                                   (stackable_of_cm cm) (roots_of_cm cm))
                             (\ _ ->
                               Inr (mkb i (nfsb i tp) (qb i tp) r2
                                     (list_union rw rdelete)))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "problem in ensuring match-RT boundedness of " .
            shows_nl .
              shows_tp (shows_prec Zero_nat) (shows_prec Zero_nat) i tp .
                shows_nl .
                  shows_prec_list Zero_nat "with deletion of rules" .
                    shows_nl .
                      shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
                        "rewrite system:" " -> " rdelete .
                        x));

bounds_complexity ::
  forall a b c d.
    (Compare_order b, Eq b, Showa b, Finite_UNIV c, Cenum c, Ceq c,
      Cproper_interval c, Compare_order c, Eq c, Set_impl c, Showa c,
      Card_UNIV d, Cenum d, Ceq d, Ccompare d, Compare_order d, Eq d,
      Set_impl d,
      Showa d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      Complexity_measure b c ->
                        Complexity_class ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_complexity i info cm cc tp =
  catch_errora
    (bindb
      (check (less_eq_complexity_class (Comp_Poly (Nat_of_num One)) cc)
        (shows_prec_list Zero_nat "can only ensure linear complexity"))
      (\ _ ->
        bindb (check (equal_boundstype (boundstype info) Match)
                (shows_prec_list Zero_nat
                  "complexity analysis requires boundstype match"))
          (\ _ ->
            check_bounds_generic info (rulesc i tp) [] (stackable_of_cm cm)
              (roots_of_cm cm))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             "problem in ensuring match boundedness of " .
            shows_nl .
              shows_tp (shows_prec Zero_nat) (shows_prec Zero_nat) i tp .
                shows_nl . x));

check_assm ::
  forall a b c d.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    ((a, (Complexity_measure (Lab b c) [Prelude.Char],
                           Complexity_class)) ->
                      d -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      Generic_assm_proof b c [Prelude.Char] d () () () () ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assm i cpx_check (Complexity_assm_proof cp prf) =
  cpx_check (mk_cpx i cp) prf;
check_assm i uu (SN_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Finite_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (SN_FP_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Not_SN_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Infinite_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Not_RelSN_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Not_SN_FP_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination or non-termination assumptions in complexity proof");
check_assm i uu (Unknown_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        "no support for termination or non-termination assumptions in complexity proof");

check_complexity_proof ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Bool ->
                      ([Prelude.Char] -> [Prelude.Char]) ->
                        (a, (Complexity_measure (Lab b c) [Prelude.Char],
                              Complexity_class)) ->
                          Complexity_proof b c [Prelude.Char] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_complexity_proof ia assms i (tp, (cm, cc))
  (Rule_Shift_Complexity redp rdelete ur_opt prf) =
  debug (i []) "Rule Removal Complexity"
    (bindb
      (catch_errora
        (smart_rule_shift_complexity ia (get_redtriple redp) rdelete ur_opt cm
          cc tp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the rule shifting technique on " .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ".1")
            (tpa, (cm, cc)) prf)
          (\ x ->
            Inl (i . shows_string ": error below the rule shifting processor" .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) RisEmpty_Complexity =
  debug (i []) "R is empty for complexity"
    (check (null (rb ia tp))
      (i . shows_string ": R is not empty in " .
             shows_nl .
               shows_tp (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) ia
                 tp));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Remove_Nonapplicable_Rules_Complexity r prf) =
  debug (i []) "Removing non-applicable rules"
    (let {
       _ = rb ia tp;
     } in bindb (catch_errora (check_non_applicable_rules (is_QNFb ia tp) r)
                  (\ x ->
                    Inl (i . shows_string
                               ": error when removing non-applicable rules" .
                               shows_nl .
                                 indent
                                   (shows_rule (shows_prec_lab Zero_nat)
                                      (shows_prec_list Zero_nat) " -> " x .
                                     shows_prec_list Zero_nat
                                       " is applicable"))))
            (\ _ ->
              let {
                tpa = delete_R_Rwb ia tp r r;
              } in catch_errora
                     (check_complexity_proof ia assms (i . shows_string ".1")
                       (tpa, (cm, cc)) prf)
                     (\ x ->
                       Inl (i . shows_string
                                  ": error below the non-applicable rules removal" .
                                  shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (Matchbounds_Complexity info) =
  debug (i []) "Matchbounds"
    (catch_errora (bounds_complexity ia info cm cc tp)
      (\ x ->
        Inl (i . shows_string ": error when applying matchbounds" .
                   shows_nl . indent x)));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Matchbounds_Rel_Complexity info rdel prf) =
  debug (i []) "Matchbounds-Rel"
    (bindb
      (catch_errora (bounds_complexity_rel ia info rdel cm cc tp)
        (\ x ->
          Inl (i . shows_string ": error when applying relative matchbounds" .
                     shows_nl . indent x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ".1")
            (tpa, (cm, cc)) prf)
          (\ x ->
            Inl (i . shows_string
                       ": error below applying relative matchbounds" .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (DT_Transformation info prf) =
  debug (i []) "DT Transformation"
    (bindb
      (catch_errora (dt_transformation ia info Sharp cm cc tp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the DT transformation on " .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . x)))
      (\ (cma, tpa) ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ".1")
            (tpa, (cma, cc)) prf)
          (\ x ->
            Inl (i . shows_string ": error below the DT transformation" .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (WDP_Transformation info prf) =
  debug (i []) "WDP Transformation"
    (bindb
      (catch_errora (check_wdp_trans ia info Sharp cm cc tp)
        (\ x ->
          Inl (i . shows_string
                     ": error when applying the WDP transformation on " .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . x)))
      (\ (cma, tpa) ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ".1")
            (tpa, (cma, cc)) prf)
          (\ x ->
            Inl (i . shows_string ": error below the WDP transformation" .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Usable_Rules_Complexity ur prf) =
  debug (i []) "Usable Rules"
    (bindb
      (catch_errora (usable_rules_complexity ia ur cm cc tp)
        (\ x ->
          Inl (i . shows_string ": error when applying usable rules" .
                     shows_nl . indent x)))
      (\ tpa ->
        catch_errora
          (check_complexity_proof ia assms (i . shows_string ".1")
            (tpa, (cm, cc)) prf)
          (\ x ->
            Inl (i . shows_string ": error below applying usable rules" .
                       shows_nl . indent x))));
check_complexity_proof ia assms i (tp, (cm, cc)) (Complexity_Assumption a ass) =
  debug (i []) "Complexity Assumption"
    (if assms
      then bindb (catch_errora
                   (check_complexity_subsumes a
                     (qb ia tp, (rb ia tp, (rwb ia tp, (cm, cc)))))
                   (\ x ->
                     Inl (i . shows_prec_list Zero_nat
                                ": error in complexity assumption or unknown proof" .
                                shows_nl . x)))
             (\ _ ->
               catch_errora
                 (catch_errora
                   (forallM_index
                     (\ asa j ->
                       check_assm ia
                         (check_complexity_proof ia assms
                           (i . shows_string "." .
                                  shows_prec_nat Zero_nat
                                    (plus_nat j (Nat_of_num One))))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string ": error below unknown proof" .
                              shows_nl . indent x)))
      else Inl (shows_prec_list Zero_nat
                 "the proof contains an assumption or unknown proof which have to be manually allowed"));
check_complexity_proof ia assms i (tp, (cm, cc))
  (Split_Complexity info prf1 prf2) =
  debug (i []) "Split"
    (bindb
      (catch_errora (split_proc_complexity ia info tp)
        (\ x ->
          Inl (i . shows_string ": error when applying split processor" .
                     shows_nl . indent x)))
      (\ (tp1, tp2) ->
        bindb (catch_errora
                (check_complexity_proof ia assms (i . shows_string ".1")
                  (tp1, (cm, cc)) prf1)
                (\ x ->
                  Inl (i . shows_string
                             ": error below applying split processor" .
                             shows_nl . indent x)))
          (\ _ ->
            catch_errora
              (check_complexity_proof ia assms (i . shows_string ".2")
                (tp2, (cm, cc)) prf2)
              (\ x ->
                Inl (i . shows_string ": error below applying split processor" .
                           shows_nl . indent x)))));

check_unknown_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Unknown_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_proof ia j a i u prf =
  check_unknown_proof_main ia j a i u (unlab_to_split_unknown prf);

certify_cert_problem ::
  forall a b c.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Bool ->
                    Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                      Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                        Cert_problem b [Nat] [Prelude.Char] -> Cert_result;
certify_cert_problem a i j (TRS_Termination_Proof nfs q r Nothing prf) =
  (case check_trs_termination_proof i j a (shows_string "1")
          (mkb i nfs (strategy_to_Q q r) r []) prf
    of {
    Inl err ->
      Error ((shows_string "termination proof not accepted" . shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Termination_Proof nfs q r Nothing prf));
  });
certify_cert_problem a i j (TRS_Termination_Proof nfs q r (Just s) prf) =
  (case check_trs_termination_proof i j a (shows_string "1")
          (mkb i nfs (strategy_to_Q q r) r s) prf
    of {
    Inl err ->
      Error ((shows_string "relative termination proof not accepted" .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Termination_Proof nfs q r (Just s) prf));
  });
certify_cert_problem a i j (Complexity_Proof q r s_o cm cc prf) =
  (case check_complexity_proof i a (shows_string "1")
          (mkb i True (strategy_to_Q q (r ++ rel_rules_of s_o)) r
             (rel_rules_of s_o),
            (cm, cc))
          prf
    of {
    Inl err ->
      Error ((shows_string "complexity proof not accepted" . shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Complexity_Proof q r s_o cm cc prf));
  });
certify_cert_problem a i j (TRS_Nontermination_Proof nfs q r prf) =
  (case check_trs_nontermination_proof i j a (shows_string "1")
          (mkb i nfs (strategy_to_Q q r) r []) prf
    of {
    Inl err ->
      Error ((shows_string "nontermination proof not accepted" . shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Nontermination_Proof nfs q r prf));
  });
certify_cert_problem a i j (Outermost_Nontermination_Proof r prf) =
  (case check_fp_nontermination_proof i j a (shows_string "1")
          (o_to_fp_impl (map fst r), r) prf
    of {
    Inl err ->
      Error ((shows_string "outermost nontermination proof not accepted" .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Outermost_Nontermination_Proof r prf));
  });
certify_cert_problem a i j (Outermost_Termination_Proof r prf) =
  (case check_fptrs_termination_proof i j a (shows_string "1")
          (o_to_fp_impl (map fst r), r) prf
    of {
    Inl err ->
      Error ((shows_string "outermost termination proof not accepted" .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Outermost_Termination_Proof r prf));
  });
certify_cert_problem a i j (CS_Nontermination_Proof mu r prf) =
  (case check_fp_nontermination_proof i j a (shows_string "1")
          (mu_to_fp_impl mu, r) prf
    of {
    Inl err ->
      Error ((shows_string "outermost nontermination proof not accepted" .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (CS_Nontermination_Proof mu r prf));
  });
certify_cert_problem a i j (CS_Termination_Proof mu r prf) =
  (case check_fptrs_termination_proof i j a (shows_string "1")
          (mu_to_fp_impl mu, r) prf
    of {
    Inl err ->
      Error ((shows_string "outermost termination proof not accepted" .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (CS_Termination_Proof mu r prf));
  });
certify_cert_problem a i j (FP_Termination_Proof p r prf) =
  (case check_fptrs_termination_proof i j a (shows_string "1") (p, r) prf of {
    Inl err ->
      Error ((shows_string "forbidden pattern termination proof not accepted" .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (FP_Termination_Proof p r prf));
  });
certify_cert_problem a i j (FP_Nontermination_Proof p r prf) =
  (case check_fp_nontermination_proof i j a (shows_string "1") (p, r) prf of {
    Inl err ->
      Error ((shows_string
                "forbidden pattern nontermination proof not accepted" .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (FP_Nontermination_Proof p r prf));
  });
certify_cert_problem a i j (Relative_TRS_Nontermination_Proof nfs q r s prf) =
  (case check_reltrs_nontermination_proof i j a (shows_string "1")
          (mkb i nfs (strategy_to_Q q r) r s) prf
    of {
    Inl err ->
      Error ((shows_string "relative nontermination proof not accepted" .
               shows_nl . err)
              []);
    Inr _ ->
      Certified (xml_tag (Relative_TRS_Nontermination_Proof nfs q r s prf));
  });
certify_cert_problem a i j (DP_Termination_Proof nfs m p pw q r rw prf) =
  (case check_dp_termination_proof i j a (shows_string "1")
          (mkc j nfs m p pw (strategy_to_Q q (r ++ rw)) r rw) prf
    of {
    Inl err ->
      Error ((shows_string "finiteness proof not accepted" . shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (DP_Termination_Proof nfs m p pw q r rw prf));
  });
certify_cert_problem a i j (DP_Nontermination_Proof nfs m p q r prf) =
  (case check_dp_nontermination_proof i j a (shows_string "1")
          (mkc j nfs m p [] (strategy_to_Q q r) [] r) prf
    of {
    Inl err ->
      Error ((shows_string "infiniteness proof not accepted" . shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (DP_Nontermination_Proof nfs m p q r prf));
  });
certify_cert_problem a i j (TRS_Confluence_Proof nfs r prf) =
  (case check_cr_proof a (shows_string "1") i j r prf of {
    Inl err ->
      Error ((shows_string "confluence proof not accepted" . shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Confluence_Proof nfs r prf));
  });
certify_cert_problem a i j (TRS_Non_Confluence_Proof nfs r prf) =
  (case check_ncr_proof a (shows_string "1") i j r prf of {
    Inl err ->
      Error ((shows_string "confluence disproof not accepted" . shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Non_Confluence_Proof nfs r prf));
  });
certify_cert_problem a i j (Completion_Proof e r prf) =
  (case check_completion_proof a (shows_string "1") i j e r prf of {
    Inl err ->
      Error ((shows_string "completion proof not accepted" . shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Completion_Proof e r prf));
  });
certify_cert_problem a i j (Equational_Proof e eq prf) =
  (case check_equational_proof a (shows_string "1") i j e eq prf of {
    Inl err ->
      Error ((shows_string "equational proof not accepted" . shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Equational_Proof e eq prf));
  });
certify_cert_problem a i j (Equational_Disproof e eq prf) =
  (case check_equational_disproof a (shows_string "1") i j e eq prf of {
    Inl err ->
      Error ((shows_string "equational disproof not accepted" . shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Equational_Disproof e eq prf));
  });
certify_cert_problem a i j (Quasi_Reductive_Proof ctrs prf) =
  (case check_quasi_reductive_proof a (shows_string "1") i j ctrs prf of {
    Inl err ->
      Error ((shows_string "quasi reductive proof not accepted" .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Quasi_Reductive_Proof ctrs prf));
  });
certify_cert_problem a i j (Conditional_CR_Proof ctrs prf) =
  (case check_conditional_cr_proof a (shows_string "1") i j ctrs prf of {
    Inl err ->
      Error ((shows_string "conditional confluence proof not accepted" .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Conditional_CR_Proof ctrs prf));
  });
certify_cert_problem a i j (Unknown_Proof up prf) =
  (case check_unknown_proof i j a (shows_string "1") up prf of {
    Inl err ->
      Error ((shows_string "unknown proof not accepted" . shows_nl . err) []);
    Inr _ -> Certified (xml_tag (Unknown_Proof up prf));
  });
certify_cert_problem a i j (Unknown_Disproof up prf) =
  (case check_unknown_disproof i j a (shows_string "1") up prf of {
    Inl err ->
      Error ((shows_string "unknown proof not accepted" . shows_nl . err) []);
    Inr _ -> Certified (xml_tag (Unknown_Disproof up prf));
  });

find_ctxt_len ::
  [Prelude.Char] ->
    [Prelude.Char] -> Nat -> Maybe ([Prelude.Char], [Prelude.Char]);
find_ctxt_len [] ys n = Nothing;
find_ctxt_len (v : va) ys n =
  (if take n (v : va) == ys then Just ([], drop n (v : va))
    else bind (find_ctxt_len (tl (v : va)) ys n)
           (\ (us, vs) -> Just (hd (v : va) : us, vs)));

extract_input_proof ::
  [Prelude.Char] -> Maybe ([Prelude.Char], ([Prelude.Char], [Prelude.Char]));
extract_input_proof s =
  bind (find_ctxt_len (filter (\ c -> not (membera " \n\t\r" c)) s) "<input>"
         (size_list "<input>"))
    (\ (_, minput) ->
      bind (find_ctxt_len minput "</input>" (size_list "</input>"))
        (\ (input, sa) ->
          bind (find_ctxt_len sa "<proof>" (size_list "<proof>"))
            (\ (version, proof) -> Just (input, (version, proof)))));

eval_list_haskell :: forall a. [a] -> Sum_bot [Prelude.Char] [a];
eval_list_haskell (x : xs) =
  binda (eval_list_haskell xs) (\ ys -> returna (x : ys));
eval_list_haskell [] = returna [];

xmldoc2cert_problem ::
  Xmldoc ->
    Sum_bot [Prelude.Char] (Cert_problem [Prelude.Char] [Nat] [Prelude.Char]);
xmldoc2cert_problem (XMLDOC header xml) =
  debug "0" "parsing xml to certification problem"
    (xml2cert_problem (text "name") plain_name xml);

parse_cert_problem ::
  [Prelude.Char] ->
    Sum_bot [Prelude.Char] (Cert_problem [Prelude.Char] [Nat] [Prelude.Char]);
parse_cert_problem s =
  (case doc_of_stringa s of {
    Inl a -> errora a;
    Inr a -> xmldoc2cert_problem a;
  });

eq_white_space :: [Prelude.Char] -> [Prelude.Char] -> Bool;
eq_white_space s1 s2 =
  debug "0" "comparing whether parsed input corresponds to real input"
    (filter (\ c -> not (membera " \n\t\r" c)) s1 == s2);

certify_proof :: Bool -> [Prelude.Char] -> Sum_bot [Prelude.Char] Cert_result;
certify_proof a s =
  catch_error
    (case extract_input_proof s of {
      Nothing ->
        returna
          (Unsupported "could not extract input and proof from given string");
      Just (the_input, (_, the_proof)) ->
        binda (eval_list_haskell (take max_tag (trim the_proof)))
          (\ short_prf ->
            binda (parse_cert_problem s)
              (\ cp ->
                returna
                  (if eq_white_space
                        (shows_prec_xml Zero_nat (xml_cert_problem cp) [])
                        the_input
                    then (case certify_cert_problem a tp_rbt_impl dpp_rbt_impl
                                 cp
                           of {
                           Certified tag ->
                             (if starts_with short_prf tag then Certified tag
                               else Error ("proven property " ++
    tag ++ " does not correspond to proof in input string: " ++ short_prf));
                           Unsupported aa -> Unsupported aa;
                           Error aa -> Error aa;
                         })
                    else Unsupported
                           (concat
                             ["parsed problem does not correspond to input",
                               "\n", "input:", "\n",
                               filter (\ c -> not (membera " \n\t\r" c))
                                 the_input,
                               "\n", "\n", "parsed:", "\n",
                               filter (\ c -> not (membera " \n\t\r" c))
                                 (shows_prec_xml Zero_nat (xml_cert_problem cp)
                                   []),
                               "\n"]))));
    })
    (\ err -> returna (Unsupported ("error while parsing" ++ "\n" ++ err)));

}
