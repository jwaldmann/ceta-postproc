{-# LANGUAGE EmptyDataDecls, RankNTypes, ScopedTypeVariables #-}

module
  Ceta(Nat, Nibble, Sum(..), Lab, Xml, Sum_bot(..), Cert_result(..),
        Cert_problem, Tp, Dpp, Tp_ops_ext, Dpp_ops_ext, certify_proof)
  where {

import Prelude ((==), (/=), (<), (<=), (>=), (>), (+), (-), (*), (/), (**),
  (>>=), (>>), (=<<), (&&), (||), (^), (^^), (.), ($), ($!), (++), (!!), Eq,
  error, id, return, not, fst, snd, map, filter, concat, concatMap, reverse,
  zip, null, takeWhile, dropWhile, all, any, Integer, negate, abs, divMod,
  String, Bool(True, False), Maybe(Nothing, Just));
import qualified Prelude;

data Num = One | Bit0 Num | Bit1 Num;

equal_num :: Num -> Num -> Bool;
equal_num (Bit0 numa) (Bit1 num) = False;
equal_num (Bit1 numa) (Bit0 num) = False;
equal_num One (Bit1 num) = False;
equal_num (Bit1 num) One = False;
equal_num One (Bit0 num) = False;
equal_num (Bit0 num) One = False;
equal_num (Bit1 numa) (Bit1 num) = equal_num numa num;
equal_num (Bit0 numa) (Bit0 num) = equal_num numa num;
equal_num One One = True;

data Int = Zero_int | Pos Num | Neg Num;

equal_int :: Int -> Int -> Bool;
equal_int (Neg k) (Neg l) = equal_num k l;
equal_int (Neg k) (Pos l) = False;
equal_int (Neg k) Zero_int = False;
equal_int (Pos k) (Neg l) = False;
equal_int (Pos k) (Pos l) = equal_num k l;
equal_int (Pos k) Zero_int = False;
equal_int Zero_int (Neg l) = False;
equal_int Zero_int (Pos l) = False;
equal_int Zero_int Zero_int = True;

instance Eq Int where {
  a == b = equal_int a b;
};

plus_num :: Num -> Num -> Num;
plus_num (Bit1 m) (Bit1 n) = Bit0 (plus_num (plus_num m n) One);
plus_num (Bit1 m) (Bit0 n) = Bit1 (plus_num m n);
plus_num (Bit1 m) One = Bit0 (plus_num m One);
plus_num (Bit0 m) (Bit1 n) = Bit1 (plus_num m n);
plus_num (Bit0 m) (Bit0 n) = Bit0 (plus_num m n);
plus_num (Bit0 m) One = Bit1 m;
plus_num One (Bit1 n) = Bit0 (plus_num n One);
plus_num One (Bit0 n) = Bit1 n;
plus_num One One = Bit0 One;

times_num :: Num -> Num -> Num;
times_num (Bit1 m) (Bit1 n) =
  Bit1 (plus_num (plus_num m n) (Bit0 (times_num m n)));
times_num (Bit1 m) (Bit0 n) = Bit0 (times_num (Bit1 m) n);
times_num (Bit0 m) (Bit1 n) = Bit0 (times_num m (Bit1 n));
times_num (Bit0 m) (Bit0 n) = Bit0 (Bit0 (times_num m n));
times_num One n = n;
times_num m One = m;

times_int :: Int -> Int -> Int;
times_int (Neg m) (Neg n) = Pos (times_num m n);
times_int (Neg m) (Pos n) = Neg (times_num m n);
times_int (Pos m) (Neg n) = Neg (times_num m n);
times_int (Pos m) (Pos n) = Pos (times_num m n);
times_int Zero_int l = Zero_int;
times_int k Zero_int = Zero_int;

class Times a where {
  times :: a -> a -> a;
};

class (Times a) => Dvd a where {
};

instance Times Int where {
  times = times_int;
};

instance Dvd Int where {
};

class Ord a where {
  less_eq :: a -> a -> Bool;
  less :: a -> a -> Bool;
};

class Plus a where {
  plus :: a -> a -> a;
};

class One a where {
  onea :: a;
};

class (Plus a) => Semigroup_add a where {
};

class (One a, Semigroup_add a) => Numeral a where {
};

numeral :: forall a. (Numeral a) => Num -> a;
numeral (Bit1 n) = let {
                     m = numeral n;
                   } in plus (plus m m) onea;
numeral (Bit0 n) = let {
                     m = numeral n;
                   } in plus m m;
numeral One = onea;

class Minus a where {
  minus :: a -> a -> a;
};

class (Semigroup_add a) => Cancel_semigroup_add a where {
};

class (Semigroup_add a) => Ab_semigroup_add a where {
};

class (Ab_semigroup_add a,
        Cancel_semigroup_add a) => Cancel_ab_semigroup_add a where {
};

class Zero a where {
  zeroa :: a;
};

class (Semigroup_add a, Zero a) => Monoid_add a where {
};

class (Ab_semigroup_add a, Monoid_add a) => Comm_monoid_add a where {
};

class (Cancel_ab_semigroup_add a,
        Comm_monoid_add a) => Cancel_comm_monoid_add a where {
};

class (Times a, Zero a) => Mult_zero a where {
};

class (Times a) => Semigroup_mult a where {
};

class (Ab_semigroup_add a, Semigroup_mult a) => Semiring a where {
};

class (Comm_monoid_add a, Mult_zero a, Semiring a) => Semiring_0 a where {
};

class (Cancel_comm_monoid_add a, Semiring_0 a) => Semiring_0_cancel a where {
};

class (Semigroup_mult a) => Ab_semigroup_mult a where {
};

class (Ab_semigroup_mult a, Semiring a) => Comm_semiring a where {
};

class (Comm_semiring a, Semiring_0 a) => Comm_semiring_0 a where {
};

class (Comm_semiring_0 a,
        Semiring_0_cancel a) => Comm_semiring_0_cancel a where {
};

class (One a, Times a) => Power a where {
};

class (Semigroup_mult a, Power a) => Monoid_mult a where {
};

class (Monoid_mult a, Numeral a, Semiring a) => Semiring_numeral a where {
};

class (One a, Zero a) => Zero_neq_one a where {
};

class (Semiring_numeral a, Semiring_0 a, Zero_neq_one a) => Semiring_1 a where {
};

class (Semiring_0_cancel a, Semiring_1 a) => Semiring_1_cancel a where {
};

class (Ab_semigroup_mult a, Monoid_mult a) => Comm_monoid_mult a where {
};

class (Comm_monoid_mult a, Comm_semiring_0 a, Dvd a,
        Semiring_1 a) => Comm_semiring_1 a where {
};

class (Comm_semiring_0_cancel a, Comm_semiring_1 a,
        Semiring_1_cancel a) => Comm_semiring_1_cancel a where {
};

class (Times a, Zero a) => No_zero_divisors a where {
};

class (Dvd a) => Div a where {
  div :: a -> a -> a;
  mod :: a -> a -> a;
};

class (Div a, Comm_semiring_1_cancel a,
        No_zero_divisors a) => Semiring_div a where {
};

class (Semiring_div a) => Semiring_div_parity a where {
};

class (Ord a) => Preorder a where {
};

class (Preorder a) => Order a where {
};

class (Ab_semigroup_add a, Order a) => Ordered_ab_semigroup_add a where {
};

class (Comm_monoid_add a, Ordered_ab_semigroup_add a,
        Semiring a) => Ordered_semiring a where {
};

class (Ordered_semiring a,
        Semiring_0_cancel a) => Ordered_cancel_semiring a where {
};

class (Comm_semiring_0 a, Ordered_semiring a) => Ordered_comm_semiring a where {
};

class (Comm_semiring_0_cancel a, Ordered_cancel_semiring a,
        Ordered_comm_semiring a) => Ordered_cancel_comm_semiring a where {
};

class (Cancel_ab_semigroup_add a,
        Ordered_ab_semigroup_add a) => Ordered_cancel_ab_semigroup_add a where {
};

class (Ordered_cancel_ab_semigroup_add a) => Ordered_ab_semigroup_add_imp_le a where {
};

class (Order a) => Linorder a where {
};

class (Ordered_ab_semigroup_add a,
        Linorder a) => Linordered_ab_semigroup_add a where {
};

class (Linordered_ab_semigroup_add a,
        Ordered_ab_semigroup_add_imp_le a) => Linordered_cancel_ab_semigroup_add a where {
};

class (Comm_monoid_add a,
        Ordered_cancel_ab_semigroup_add a) => Ordered_comm_monoid_add a where {
};

class (Linordered_cancel_ab_semigroup_add a, Ordered_comm_monoid_add a,
        Ordered_cancel_semiring a) => Linordered_semiring a where {
};

class (Linordered_semiring a) => Linordered_semiring_strict a where {
};

class (Linordered_semiring_strict a,
        Ordered_cancel_comm_semiring a) => Linordered_comm_semiring_strict a where {
};

class (Semiring_1 a) => Semiring_char_0 a where {
};

class (Semiring_char_0 a, Comm_semiring_1_cancel a,
        Linordered_comm_semiring_strict a) => Linordered_semidom a where {
};

class (Semiring_div_parity a, Minus a,
        Linordered_semidom a) => Semiring_numeral_div a where {
};

divmod_step :: forall a. (Semiring_numeral_div a) => Num -> (a, a) -> (a, a);
divmod_step l (q, r) =
  (if less_eq (numeral l) r
    then (plus (times (numeral (Bit0 One)) q) onea, minus r (numeral l))
    else (times (numeral (Bit0 One)) q, r));

less_num :: Num -> Num -> Bool;
less_num (Bit1 m) (Bit0 n) = less_num m n;
less_num (Bit1 m) (Bit1 n) = less_num m n;
less_num (Bit0 m) (Bit1 n) = less_eq_num m n;
less_num (Bit0 m) (Bit0 n) = less_num m n;
less_num One (Bit1 n) = True;
less_num One (Bit0 n) = True;
less_num m One = False;

less_eq_num :: Num -> Num -> Bool;
less_eq_num (Bit1 m) (Bit0 n) = less_num m n;
less_eq_num (Bit1 m) (Bit1 n) = less_eq_num m n;
less_eq_num (Bit0 m) (Bit1 n) = less_eq_num m n;
less_eq_num (Bit0 m) (Bit0 n) = less_eq_num m n;
less_eq_num (Bit1 m) One = False;
less_eq_num (Bit0 m) One = False;
less_eq_num One n = True;

divmod :: forall a. (Semiring_numeral_div a) => Num -> Num -> (a, a);
divmod (Bit1 m) (Bit0 n) =
  let {
    (q, r) = divmod m n;
  } in (q, plus (times (numeral (Bit0 One)) r) onea);
divmod (Bit0 m) (Bit0 n) =
  let {
    (q, r) = divmod m n;
  } in (q, times (numeral (Bit0 One)) r);
divmod m n =
  (if less_num m n then (zeroa, numeral m)
    else divmod_step n (divmod m (Bit0 n)));

data Nat = Zero_nat | Nat_of_num Num;

times_nat :: Nat -> Nat -> Nat;
times_nat Zero_nat n = Zero_nat;
times_nat m Zero_nat = Zero_nat;
times_nat (Nat_of_num k) (Nat_of_num l) = Nat_of_num (times_num k l);

less_eq_nat :: Nat -> Nat -> Bool;
less_eq_nat (Nat_of_num k) (Nat_of_num l) = less_eq_num k l;
less_eq_nat (Nat_of_num k) Zero_nat = False;
less_eq_nat Zero_nat n = True;

equal_nat :: Nat -> Nat -> Bool;
equal_nat (Nat_of_num k) (Nat_of_num l) = equal_num k l;
equal_nat (Nat_of_num k) Zero_nat = False;
equal_nat Zero_nat (Nat_of_num l) = False;
equal_nat Zero_nat Zero_nat = True;

plus_nat :: Nat -> Nat -> Nat;
plus_nat Zero_nat n = n;
plus_nat m Zero_nat = m;
plus_nat (Nat_of_num k) (Nat_of_num l) = Nat_of_num (plus_num k l);

map_option :: forall a b. (a -> b) -> Maybe a -> Maybe b;
map_option fi Nothing = Nothing;
map_option fi (Just x2a) = Just (fi x2a);

dupa :: Nat -> Nat;
dupa (Nat_of_num k) = Nat_of_num (Bit0 k);
dupa Zero_nat = Zero_nat;

bitM :: Num -> Num;
bitM One = One;
bitM (Bit0 n) = Bit1 (bitM n);
bitM (Bit1 n) = Bit1 (Bit0 n);

minus_nat :: Nat -> Nat -> Nat;
minus_nat Zero_nat n = Zero_nat;
minus_nat m Zero_nat = m;
minus_nat (Nat_of_num k) (Nat_of_num l) =
  (case suba k l of {
    Nothing -> Zero_nat;
    Just j -> j;
  });

suba :: Num -> Num -> Maybe Nat;
suba (Bit0 m) (Bit1 n) =
  (case suba m n of {
    Nothing -> Nothing;
    Just q ->
      (if equal_nat q Zero_nat then Nothing
        else Just (minus_nat (dupa q) (Nat_of_num One)));
  });
suba (Bit1 m) (Bit0 n) =
  map_option (\ q -> plus_nat (dupa q) (Nat_of_num One)) (suba m n);
suba (Bit1 m) (Bit1 n) = map_option dupa (suba m n);
suba (Bit0 m) (Bit0 n) = map_option dupa (suba m n);
suba One (Bit1 n) = Nothing;
suba One (Bit0 n) = Nothing;
suba (Bit1 m) One = Just (Nat_of_num (Bit0 m));
suba (Bit0 m) One = Just (Nat_of_num (bitM m));
suba One One = Just Zero_nat;

less_nat :: Nat -> Nat -> Bool;
less_nat (Nat_of_num k) (Nat_of_num l) = less_num k l;
less_nat Zero_nat (Nat_of_num l) = True;
less_nat m Zero_nat = False;

one_nat :: Nat;
one_nat = Nat_of_num One;

instance Plus Nat where {
  plus = plus_nat;
};

instance Semigroup_add Nat where {
};

instance Cancel_semigroup_add Nat where {
};

instance Ab_semigroup_add Nat where {
};

instance Cancel_ab_semigroup_add Nat where {
};

instance Zero Nat where {
  zeroa = Zero_nat;
};

instance Monoid_add Nat where {
};

instance Comm_monoid_add Nat where {
};

instance Cancel_comm_monoid_add Nat where {
};

instance Times Nat where {
  times = times_nat;
};

instance Mult_zero Nat where {
};

instance Semigroup_mult Nat where {
};

instance Semiring Nat where {
};

instance Semiring_0 Nat where {
};

instance Semiring_0_cancel Nat where {
};

instance Ab_semigroup_mult Nat where {
};

instance Comm_semiring Nat where {
};

instance Comm_semiring_0 Nat where {
};

instance Comm_semiring_0_cancel Nat where {
};

instance One Nat where {
  onea = one_nat;
};

instance Power Nat where {
};

instance Monoid_mult Nat where {
};

instance Numeral Nat where {
};

instance Semiring_numeral Nat where {
};

instance Zero_neq_one Nat where {
};

instance Semiring_1 Nat where {
};

instance Semiring_1_cancel Nat where {
};

instance Comm_monoid_mult Nat where {
};

instance Dvd Nat where {
};

instance Comm_semiring_1 Nat where {
};

instance Comm_semiring_1_cancel Nat where {
};

instance No_zero_divisors Nat where {
};

instance Ord Nat where {
  less_eq = less_eq_nat;
  less = less_nat;
};

instance Preorder Nat where {
};

instance Order Nat where {
};

instance Ordered_ab_semigroup_add Nat where {
};

instance Ordered_semiring Nat where {
};

instance Ordered_cancel_semiring Nat where {
};

instance Ordered_comm_semiring Nat where {
};

instance Ordered_cancel_comm_semiring Nat where {
};

instance Ordered_cancel_ab_semigroup_add Nat where {
};

instance Ordered_ab_semigroup_add_imp_le Nat where {
};

instance Linorder Nat where {
};

instance Linordered_ab_semigroup_add Nat where {
};

instance Linordered_cancel_ab_semigroup_add Nat where {
};

instance Ordered_comm_monoid_add Nat where {
};

instance Linordered_semiring Nat where {
};

instance Linordered_semiring_strict Nat where {
};

instance Linordered_comm_semiring_strict Nat where {
};

instance Semiring_char_0 Nat where {
};

instance Linordered_semidom Nat where {
};

instance Minus Nat where {
  minus = minus_nat;
};

mod_nat :: Nat -> Nat -> Nat;
mod_nat m n = snd (divmod_nat m n);

instance Semiring_numeral_div Nat where {
};

divmod_nat :: Nat -> Nat -> (Nat, Nat);
divmod_nat Zero_nat n = (Zero_nat, Zero_nat);
divmod_nat m Zero_nat = (Zero_nat, m);
divmod_nat (Nat_of_num k) (Nat_of_num l) = divmod k l;

div_nat :: Nat -> Nat -> Nat;
div_nat m n = fst (divmod_nat m n);

instance Div Nat where {
  div = div_nat;
  mod = mod_nat;
};

instance Semiring_div Nat where {
};

instance Semiring_div_parity Nat where {
};

data Nibble = Nibble0 | Nibble1 | Nibble2 | Nibble3 | Nibble4 | Nibble5
  | Nibble6 | Nibble7 | Nibble8 | Nibble9 | NibbleA | NibbleB | NibbleC
  | NibbleD | NibbleE | NibbleF;

digit2string :: Nat -> [Prelude.Char];
digit2string n =
  (if equal_nat n Zero_nat then ['0']
    else (if equal_nat n (Nat_of_num One) then ['1']
           else (if equal_nat n (Nat_of_num (Bit0 One)) then ['2']
                  else (if equal_nat n (Nat_of_num (Bit1 One)) then ['3']
                         else (if equal_nat n (Nat_of_num (Bit0 (Bit0 One)))
                                then ['4']
                                else (if equal_nat n
   (Nat_of_num (Bit1 (Bit0 One)))
                                       then ['5']
                                       else (if equal_nat n
          (Nat_of_num (Bit0 (Bit1 One)))
      then ['6']
      else (if equal_nat n (Nat_of_num (Bit1 (Bit1 One))) then ['7']
             else (if equal_nat n (Nat_of_num (Bit0 (Bit0 (Bit0 One))))
                    then ['8'] else ['9'])))))))));

shows_string :: [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
shows_string = (\ a b -> a ++ b);

shows_nat :: Nat -> [Prelude.Char] -> [Prelude.Char];
shows_nat n =
  (if less_nat n (Nat_of_num (Bit0 (Bit1 (Bit0 One))))
    then shows_string (digit2string n)
    else shows_nat (div_nat n (Nat_of_num (Bit0 (Bit1 (Bit0 One))))) .
           shows_string
             (digit2string (mod_nat n (Nat_of_num (Bit0 (Bit1 (Bit0 One)))))));

shows_prec_nat :: Nat -> Nat -> [Prelude.Char] -> [Prelude.Char];
shows_prec_nat d n = shows_nat n;

shows_prec_char :: Nat -> Prelude.Char -> [Prelude.Char] -> [Prelude.Char];
shows_prec_char d c = (\ a -> c : a);

uminus_int :: Int -> Int;
uminus_int (Neg m) = Pos m;
uminus_int (Pos m) = Neg m;
uminus_int Zero_int = Zero_int;

less_int :: Int -> Int -> Bool;
less_int (Neg k) (Neg l) = less_num l k;
less_int (Neg k) (Pos l) = True;
less_int (Neg k) Zero_int = True;
less_int (Pos k) (Neg l) = False;
less_int (Pos k) (Pos l) = less_num k l;
less_int (Pos k) Zero_int = False;
less_int Zero_int (Neg l) = False;
less_int Zero_int (Pos l) = True;
less_int Zero_int Zero_int = False;

nat :: Int -> Nat;
nat (Pos k) = Nat_of_num k;
nat Zero_int = Zero_nat;
nat (Neg k) = Zero_nat;

shows_prec_int :: Nat -> Int -> [Prelude.Char] -> [Prelude.Char];
shows_prec_int d i =
  (if less_int i Zero_int
    then shows_prec_char Zero_nat '-' .
           shows_prec_nat Zero_nat (nat (uminus_int i))
    else shows_prec_nat Zero_nat (nat i));

shows_between ::
  ([Prelude.Char] -> [Prelude.Char]) ->
    ([Prelude.Char] -> [Prelude.Char]) ->
      ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_between l p r = l . p . r;

shows_sep ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ([Prelude.Char] -> [Prelude.Char]) ->
        [a] -> [Prelude.Char] -> [Prelude.Char];
shows_sep s sep [] = shows_string [];
shows_sep s sep [x] = s x;
shows_sep s sep (x : v : va) = s x . sep . shows_sep s sep (v : va);

shows_list_gen ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      [Prelude.Char] ->
        [Prelude.Char] ->
          [Prelude.Char] ->
            [Prelude.Char] -> [a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_gen elt e l s r xs =
  (if null xs then shows_string e
    else shows_between (shows_string l) (shows_sep elt (shows_string s) xs)
           (shows_string r));

shows_list_aux ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      [a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_aux s xs = shows_list_gen s ['[', ']'] ['['] [',', ' '] [']'] xs;

shows_list_int :: [Int] -> [Prelude.Char] -> [Prelude.Char];
shows_list_int = shows_list_aux (shows_prec_int Zero_nat);

class Showa a where {
  shows_prec :: Nat -> a -> [Prelude.Char] -> [Prelude.Char];
  shows_list :: [a] -> [Prelude.Char] -> [Prelude.Char];
};

instance Showa Int where {
  shows_prec = shows_prec_int;
  shows_list = shows_list_int;
};

one_int :: Int;
one_int = Pos One;

instance One Int where {
  onea = one_int;
};

dup :: Int -> Int;
dup (Neg n) = Neg (Bit0 n);
dup (Pos n) = Pos (Bit0 n);
dup Zero_int = Zero_int;

minus_int :: Int -> Int -> Int;
minus_int (Neg m) (Neg n) = sub n m;
minus_int (Neg m) (Pos n) = Neg (plus_num m n);
minus_int (Pos m) (Neg n) = Pos (plus_num m n);
minus_int (Pos m) (Pos n) = sub m n;
minus_int Zero_int l = uminus_int l;
minus_int k Zero_int = k;

sub :: Num -> Num -> Int;
sub (Bit0 m) (Bit1 n) = minus_int (dup (sub m n)) (Pos One);
sub (Bit1 m) (Bit0 n) = plus_int (dup (sub m n)) (Pos One);
sub (Bit1 m) (Bit1 n) = dup (sub m n);
sub (Bit0 m) (Bit0 n) = dup (sub m n);
sub One (Bit1 n) = Neg (Bit0 n);
sub One (Bit0 n) = Neg (bitM n);
sub (Bit1 m) One = Pos (Bit0 m);
sub (Bit0 m) One = Pos (bitM m);
sub One One = Zero_int;

plus_int :: Int -> Int -> Int;
plus_int (Neg m) (Neg n) = Neg (plus_num m n);
plus_int (Neg m) (Pos n) = sub n m;
plus_int (Pos m) (Neg n) = sub m n;
plus_int (Pos m) (Pos n) = Pos (plus_num m n);
plus_int Zero_int l = l;
plus_int k Zero_int = k;

sgn_int :: Int -> Int;
sgn_int i =
  (if equal_int i Zero_int then Zero_int
    else (if less_int Zero_int i then Pos One else Neg One));

abs_int :: Int -> Int;
abs_int i = (if less_int i Zero_int then uminus_int i else i);

apsnd :: forall a b c. (a -> b) -> (c, a) -> (c, b);
apsnd f (x, y) = (x, f y);

less_eq_int :: Int -> Int -> Bool;
less_eq_int (Neg k) (Neg l) = less_eq_num l k;
less_eq_int (Neg k) (Pos l) = True;
less_eq_int (Neg k) Zero_int = True;
less_eq_int (Pos k) (Neg l) = False;
less_eq_int (Pos k) (Pos l) = less_eq_num k l;
less_eq_int (Pos k) Zero_int = False;
less_eq_int Zero_int (Neg l) = False;
less_eq_int Zero_int (Pos l) = True;
less_eq_int Zero_int Zero_int = True;

instance Plus Int where {
  plus = plus_int;
};

instance Semigroup_add Int where {
};

instance Cancel_semigroup_add Int where {
};

instance Ab_semigroup_add Int where {
};

instance Cancel_ab_semigroup_add Int where {
};

instance Zero Int where {
  zeroa = Zero_int;
};

instance Monoid_add Int where {
};

instance Comm_monoid_add Int where {
};

instance Cancel_comm_monoid_add Int where {
};

instance Mult_zero Int where {
};

instance Semigroup_mult Int where {
};

instance Semiring Int where {
};

instance Semiring_0 Int where {
};

instance Semiring_0_cancel Int where {
};

instance Ab_semigroup_mult Int where {
};

instance Comm_semiring Int where {
};

instance Comm_semiring_0 Int where {
};

instance Comm_semiring_0_cancel Int where {
};

instance Power Int where {
};

instance Monoid_mult Int where {
};

instance Numeral Int where {
};

instance Semiring_numeral Int where {
};

instance Zero_neq_one Int where {
};

instance Semiring_1 Int where {
};

instance Semiring_1_cancel Int where {
};

instance Comm_monoid_mult Int where {
};

instance Comm_semiring_1 Int where {
};

instance Comm_semiring_1_cancel Int where {
};

instance No_zero_divisors Int where {
};

instance Ord Int where {
  less_eq = less_eq_int;
  less = less_int;
};

instance Preorder Int where {
};

instance Order Int where {
};

instance Ordered_ab_semigroup_add Int where {
};

instance Ordered_semiring Int where {
};

instance Ordered_cancel_semiring Int where {
};

instance Ordered_comm_semiring Int where {
};

instance Ordered_cancel_comm_semiring Int where {
};

instance Ordered_cancel_ab_semigroup_add Int where {
};

instance Ordered_ab_semigroup_add_imp_le Int where {
};

instance Linorder Int where {
};

instance Linordered_ab_semigroup_add Int where {
};

instance Linordered_cancel_ab_semigroup_add Int where {
};

instance Ordered_comm_monoid_add Int where {
};

instance Linordered_semiring Int where {
};

instance Linordered_semiring_strict Int where {
};

instance Linordered_comm_semiring_strict Int where {
};

instance Semiring_char_0 Int where {
};

instance Linordered_semidom Int where {
};

instance Minus Int where {
  minus = minus_int;
};

instance Div Int where {
  div = div_int;
  mod = mod_int;
};

instance Semiring_div Int where {
};

instance Semiring_div_parity Int where {
};

instance Semiring_numeral_div Int where {
};

divmod_abs :: Int -> Int -> (Int, Int);
divmod_abs Zero_int j = (Zero_int, Zero_int);
divmod_abs j Zero_int = (Zero_int, abs_int j);
divmod_abs (Pos k) (Neg l) = divmod k l;
divmod_abs (Neg k) (Pos l) = divmod k l;
divmod_abs (Neg k) (Neg l) = divmod k l;
divmod_abs (Pos k) (Pos l) = divmod k l;

divmod_int :: Int -> Int -> (Int, Int);
divmod_int k l =
  (if equal_int k Zero_int then (Zero_int, Zero_int)
    else (if equal_int l Zero_int then (Zero_int, k)
           else apsnd (times_int (sgn_int l))
                  (if equal_int (sgn_int k) (sgn_int l) then divmod_abs k l
                    else let {
                           (r, s) = divmod_abs k l;
                         } in (if equal_int s Zero_int
                                then (uminus_int r, Zero_int)
                                else (minus_int (uminus_int r) (Pos One),
                                       minus_int (abs_int l) s)))));

div_int :: Int -> Int -> Int;
div_int a b = fst (divmod_int a b);

mod_int :: Int -> Int -> Int;
mod_int a b = snd (divmod_int a b);

ceq_int :: Maybe (Int -> Int -> Bool);
ceq_int = Just equal_int;

class Ceq a where {
  ceq :: Maybe (a -> a -> Bool);
};

instance Ceq Int where {
  ceq = ceq_int;
};

newtype Phantom a b = Phantom b;

data Set_impla = Set_Choose | Set_Collect | Set_DList | Set_RBT | Set_Monada;

set_impl_int :: Phantom Int Set_impla;
set_impl_int = Phantom Set_RBT;

class Set_impl a where {
  set_impl :: Phantom a Set_impla;
};

instance Set_impl Int where {
  set_impl = set_impl_int;
};

cEnum_int :: Maybe ([Int], ((Int -> Bool) -> Bool, (Int -> Bool) -> Bool));
cEnum_int = Nothing;

class Cenum a where {
  cEnum :: Maybe ([a], ((a -> Bool) -> Bool, (a -> Bool) -> Bool));
};

instance Cenum Int where {
  cEnum = cEnum_int;
};

class (Ord a) => Non_strict_order a where {
};

class (Ab_semigroup_add a, Monoid_add a,
        Non_strict_order a) => Ordered_ab_semigroup a where {
};

class (Semiring_0 a, Ordered_ab_semigroup a) => Ordered_semiring_0 a where {
};

class (Semiring_1 a, Ordered_semiring_0 a) => Ordered_semiring_1 a where {
};

class (Comm_semiring_1 a, Ordered_semiring_1 a) => Poly_carrier a where {
};

instance Non_strict_order Int where {
};

instance Ordered_ab_semigroup Int where {
};

instance Ordered_semiring_0 Int where {
};

instance Ordered_semiring_1 Int where {
};

instance Poly_carrier Int where {
};

corder_int :: Maybe (Int -> Int -> Bool, Int -> Int -> Bool);
corder_int = Just (less_eq_int, less_int);

class Corder a where {
  corder :: Maybe (a -> a -> Bool, a -> a -> Bool);
};

instance Corder Int where {
  corder = corder_int;
};

instance Eq Nat where {
  a == b = equal_nat a b;
};

shows_list_nat :: [Nat] -> [Prelude.Char] -> [Prelude.Char];
shows_list_nat = shows_list_aux (shows_prec_nat Zero_nat);

instance Showa Nat where {
  shows_prec = shows_prec_nat;
  shows_list = shows_list_nat;
};

class (Linorder a) => Key a where {
};

instance Key Nat where {
};

ceq_nat :: Maybe (Nat -> Nat -> Bool);
ceq_nat = Just equal_nat;

instance Ceq Nat where {
  ceq = ceq_nat;
};

set_impl_nat :: Phantom Nat Set_impla;
set_impl_nat = Phantom Set_RBT;

instance Set_impl Nat where {
  set_impl = set_impl_nat;
};

finite_UNIV_nat :: Phantom Nat Bool;
finite_UNIV_nat = Phantom False;

card_UNIV_nat :: Phantom Nat Nat;
card_UNIV_nat = Phantom Zero_nat;

class Finite_UNIV a where {
  finite_UNIV :: Phantom a Bool;
};

class (Finite_UNIV a) => Card_UNIV a where {
  card_UNIVa :: Phantom a Nat;
};

instance Finite_UNIV Nat where {
  finite_UNIV = finite_UNIV_nat;
};

instance Card_UNIV Nat where {
  card_UNIVa = card_UNIV_nat;
};

cEnum_nat :: Maybe ([Nat], ((Nat -> Bool) -> Bool, (Nat -> Bool) -> Bool));
cEnum_nat = Nothing;

instance Cenum Nat where {
  cEnum = cEnum_nat;
};

corder_nat :: Maybe (Nat -> Nat -> Bool, Nat -> Nat -> Bool);
corder_nat = Just (less_eq_nat, less_nat);

instance Corder Nat where {
  corder = corder_nat;
};

data Mapping_impla = Mapping_Choose | Mapping_Assoc_List | Mapping_RBT
  | Mapping_Mapping;

mapping_impl_nat :: Phantom Nat Mapping_impla;
mapping_impl_nat = Phantom Mapping_RBT;

class Mapping_impl a where {
  mapping_impl :: Phantom a Mapping_impla;
};

instance Mapping_impl Nat where {
  mapping_impl = mapping_impl_nat;
};

newtype Rat = Frct (Int, Int);

quotient_of :: Rat -> (Int, Int);
quotient_of (Frct x) = x;

equal_rat :: Rat -> Rat -> Bool;
equal_rat a b = quotient_of a == quotient_of b;

instance Eq Rat where {
  a == b = equal_rat a b;
};

gcd_int :: Int -> Int -> Int;
gcd_int k l =
  abs_int
    (if equal_int l Zero_int then k
      else gcd_int l (mod_int (abs_int k) (abs_int l)));

normalize :: (Int, Int) -> (Int, Int);
normalize p =
  (if less_int Zero_int (snd p)
    then let {
           a = gcd_int (fst p) (snd p);
         } in (div_int (fst p) a, div_int (snd p) a)
    else (if equal_int (snd p) Zero_int then (Zero_int, Pos One)
           else let {
                  a = uminus_int (gcd_int (fst p) (snd p));
                } in (div_int (fst p) a, div_int (snd p) a)));

times_rat :: Rat -> Rat -> Rat;
times_rat p q =
  Frct (let {
          (a, c) = quotient_of p;
          (b, d) = quotient_of q;
        } in normalize (times_int a b, times_int c d));

instance Times Rat where {
  times = times_rat;
};

instance Dvd Rat where {
};

show_rat :: Rat -> [Prelude.Char];
show_rat x =
  let {
    (den, num) = quotient_of x;
  } in (if equal_int num (Pos One) then shows_prec_int Zero_nat den []
         else ((shows_prec_int Zero_nat den . shows_prec_char Zero_nat '/') .
                shows_prec_int Zero_nat num)
                []);

shows_prec_rat :: Nat -> Rat -> [Prelude.Char] -> [Prelude.Char];
shows_prec_rat d x = shows_string (show_rat x);

shows_list_rat :: [Rat] -> [Prelude.Char] -> [Prelude.Char];
shows_list_rat = shows_list_aux (shows_prec_rat Zero_nat);

instance Showa Rat where {
  shows_prec = shows_prec_rat;
  shows_list = shows_list_rat;
};

abs_rat :: Rat -> Rat;
abs_rat p = Frct (let {
                    (a, b) = quotient_of p;
                  } in (abs_int a, b));

class Abs a where {
  absa :: a -> a;
};

instance Abs Rat where {
  absa = abs_rat;
};

one_rat :: Rat;
one_rat = Frct (Pos One, Pos One);

instance One Rat where {
  onea = one_rat;
};

sgn_rat :: Rat -> Rat;
sgn_rat p = Frct (sgn_int (fst (quotient_of p)), Pos One);

class Sgn a where {
  sgn :: a -> a;
};

instance Sgn Rat where {
  sgn = sgn_rat;
};

uminus_rat :: Rat -> Rat;
uminus_rat p = Frct (let {
                       (a, b) = quotient_of p;
                     } in (uminus_int a, b));

minus_rat :: Rat -> Rat -> Rat;
minus_rat p q =
  Frct (let {
          (a, c) = quotient_of p;
          (b, d) = quotient_of q;
        } in normalize
               (minus_int (times_int a d) (times_int b c), times_int c d));

zero_rat :: Rat;
zero_rat = Frct (Zero_int, Pos One);

plus_rat :: Rat -> Rat -> Rat;
plus_rat p q =
  Frct (let {
          (a, c) = quotient_of p;
          (b, d) = quotient_of q;
        } in normalize
               (plus_int (times_int a d) (times_int b c), times_int c d));

class Uminus a where {
  uminus :: a -> a;
};

class (Comm_semiring_1_cancel a) => Comm_semiring_1_cancel_crossproduct a where {
};

class (Cancel_semigroup_add a, Minus a, Monoid_add a,
        Uminus a) => Group_add a where {
};

class (Cancel_comm_monoid_add a, Group_add a) => Ab_group_add a where {
};

class (Ab_group_add a, Semiring_0_cancel a) => Ring a where {
};

class (No_zero_divisors a, Ring a) => Ring_no_zero_divisors a where {
};

class (Group_add a, Numeral a) => Neg_numeral a where {
};

class (Neg_numeral a, Ring a, Semiring_1_cancel a) => Ring_1 a where {
};

class (Ring_1 a, Ring_no_zero_divisors a) => Ring_1_no_zero_divisors a where {
};

class (Comm_semiring_0_cancel a, Ring a) => Comm_ring a where {
};

class (Comm_ring a, Comm_semiring_1_cancel a, Ring_1 a) => Comm_ring_1 a where {
};

class (Comm_ring_1 a, Ring_1_no_zero_divisors a,
        Comm_semiring_1_cancel_crossproduct a) => Idom a where {
};

instance Plus Rat where {
  plus = plus_rat;
};

instance Semigroup_add Rat where {
};

instance Cancel_semigroup_add Rat where {
};

instance Ab_semigroup_add Rat where {
};

instance Cancel_ab_semigroup_add Rat where {
};

instance Zero Rat where {
  zeroa = zero_rat;
};

instance Monoid_add Rat where {
};

instance Comm_monoid_add Rat where {
};

instance Cancel_comm_monoid_add Rat where {
};

instance Mult_zero Rat where {
};

instance Semigroup_mult Rat where {
};

instance Semiring Rat where {
};

instance Semiring_0 Rat where {
};

instance Semiring_0_cancel Rat where {
};

instance Ab_semigroup_mult Rat where {
};

instance Comm_semiring Rat where {
};

instance Comm_semiring_0 Rat where {
};

instance Comm_semiring_0_cancel Rat where {
};

instance Power Rat where {
};

instance Monoid_mult Rat where {
};

instance Numeral Rat where {
};

instance Semiring_numeral Rat where {
};

instance Zero_neq_one Rat where {
};

instance Semiring_1 Rat where {
};

instance Semiring_1_cancel Rat where {
};

instance Comm_monoid_mult Rat where {
};

instance Comm_semiring_1 Rat where {
};

instance Comm_semiring_1_cancel Rat where {
};

instance Comm_semiring_1_cancel_crossproduct Rat where {
};

instance No_zero_divisors Rat where {
};

instance Uminus Rat where {
  uminus = uminus_rat;
};

instance Minus Rat where {
  minus = minus_rat;
};

instance Group_add Rat where {
};

instance Ab_group_add Rat where {
};

instance Ring Rat where {
};

instance Ring_no_zero_divisors Rat where {
};

instance Neg_numeral Rat where {
};

instance Ring_1 Rat where {
};

instance Ring_1_no_zero_divisors Rat where {
};

instance Comm_ring Rat where {
};

instance Comm_ring_1 Rat where {
};

instance Idom Rat where {
};

inverse_rat :: Rat -> Rat;
inverse_rat p =
  Frct (let {
          (a, b) = quotient_of p;
        } in (if equal_int a Zero_int then (Zero_int, Pos One)
               else (times_int (sgn_int a) b, abs_int a)));

divide_rat :: Rat -> Rat -> Rat;
divide_rat p q =
  Frct (let {
          (a, c) = quotient_of p;
          (b, d) = quotient_of q;
        } in normalize (times_int a d, times_int c b));

class Inverse a where {
  inverse :: a -> a;
  divide :: a -> a -> a;
};

class (Inverse a, Ring_1_no_zero_divisors a) => Division_ring a where {
};

class (Division_ring a, Idom a) => Field a where {
};

instance Inverse Rat where {
  inverse = inverse_rat;
  divide = divide_rat;
};

instance Division_ring Rat where {
};

instance Field Rat where {
};

less_eq_rat :: Rat -> Rat -> Bool;
less_eq_rat p q =
  let {
    (a, c) = quotient_of p;
    (b, d) = quotient_of q;
  } in less_eq_int (times_int a d) (times_int c b);

less_rat :: Rat -> Rat -> Bool;
less_rat p q =
  let {
    (a, c) = quotient_of p;
    (b, d) = quotient_of q;
  } in less_int (times_int a d) (times_int c b);

class (Abs a, Minus a, Uminus a, Zero a, Ord a) => Abs_if a where {
};

instance Ord Rat where {
  less_eq = less_eq_rat;
  less = less_rat;
};

instance Abs_if Rat where {
};

class (Minus a, One a, Sgn a, Uminus a, Zero a, Ord a) => Sgn_if a where {
};

instance Sgn_if Rat where {
};

class (Semiring_char_0 a, Ring_1 a) => Ring_char_0 a where {
};

instance Semiring_char_0 Rat where {
};

instance Ring_char_0 Rat where {
};

instance Preorder Rat where {
};

instance Order Rat where {
};

class (Order a) => No_bot a where {
};

instance No_bot Rat where {
};

class (Order a) => No_top a where {
};

instance No_top Rat where {
};

class (Field a, Ring_char_0 a) => Field_char_0 a where {
};

instance Field_char_0 Rat where {
};

ceq_rat :: Maybe (Rat -> Rat -> Bool);
ceq_rat = Just equal_rat;

instance Ceq Rat where {
  ceq = ceq_rat;
};

set_impl_rat :: Phantom Rat Set_impla;
set_impl_rat = Phantom Set_RBT;

instance Set_impl Rat where {
  set_impl = set_impl_rat;
};

instance Linorder Rat where {
};

class (Ab_group_add a, Ordered_ab_semigroup_add_imp_le a,
        Ordered_comm_monoid_add a) => Ordered_ab_group_add a where {
};

class (Ordered_ab_group_add a, Ordered_cancel_semiring a,
        Ring a) => Ordered_ring a where {
};

instance Ordered_ab_semigroup_add Rat where {
};

instance Ordered_semiring Rat where {
};

instance Ordered_cancel_semiring Rat where {
};

instance Ordered_cancel_ab_semigroup_add Rat where {
};

instance Ordered_ab_semigroup_add_imp_le Rat where {
};

instance Ordered_comm_monoid_add Rat where {
};

instance Ordered_ab_group_add Rat where {
};

instance Ordered_ring Rat where {
};

cEnum_rat :: Maybe ([Rat], ((Rat -> Bool) -> Bool, (Rat -> Bool) -> Bool));
cEnum_rat = Nothing;

instance Cenum Rat where {
  cEnum = cEnum_rat;
};

class (Order a) => Dense_order a where {
};

instance Dense_order Rat where {
};

class (Linordered_semiring a, Semiring_1 a) => Linordered_semiring_1 a where {
};

class (Linordered_semiring_1 a,
        Linordered_semiring_strict a) => Linordered_semiring_1_strict a where {
};

class (Abs a, Ordered_ab_group_add a) => Ordered_ab_group_add_abs a where {
};

class (Linordered_cancel_ab_semigroup_add a,
        Ordered_ab_group_add a) => Linordered_ab_group_add a where {
};

class (Abs_if a, Linordered_ab_group_add a, Ordered_ab_group_add_abs a,
        Linordered_semiring a, Ordered_ring a) => Linordered_ring a where {
};

class (Linordered_ring a, Linordered_semiring_strict a,
        Ring_no_zero_divisors a) => Linordered_ring_strict a where {
};

class (Comm_ring a, Ordered_cancel_comm_semiring a,
        Ordered_ring a) => Ordered_comm_ring a where {
};

class (Ordered_ab_group_add_abs a, Ordered_ring a) => Ordered_ring_abs a where {
};

class (Sgn_if a, Ring_char_0 a, Idom a, Linordered_ring_strict a,
        Linordered_semidom a, Linordered_semiring_1_strict a,
        Ordered_comm_ring a, Ordered_ring_abs a) => Linordered_idom a where {
};

instance Linordered_ab_semigroup_add Rat where {
};

instance Linordered_cancel_ab_semigroup_add Rat where {
};

instance Linordered_semiring Rat where {
};

instance Linordered_semiring_strict Rat where {
};

instance Linordered_semiring_1 Rat where {
};

instance Linordered_semiring_1_strict Rat where {
};

instance Ordered_ab_group_add_abs Rat where {
};

instance Linordered_ab_group_add Rat where {
};

instance Linordered_ring Rat where {
};

instance Linordered_ring_strict Rat where {
};

instance Ordered_comm_semiring Rat where {
};

instance Ordered_cancel_comm_semiring Rat where {
};

instance Linordered_comm_semiring_strict Rat where {
};

instance Linordered_semidom Rat where {
};

instance Ordered_comm_ring Rat where {
};

instance Ordered_ring_abs Rat where {
};

instance Linordered_idom Rat where {
};

instance Non_strict_order Rat where {
};

instance Ordered_ab_semigroup Rat where {
};

instance Ordered_semiring_0 Rat where {
};

instance Ordered_semiring_1 Rat where {
};

instance Poly_carrier Rat where {
};

corder_rat :: Maybe (Rat -> Rat -> Bool, Rat -> Rat -> Bool);
corder_rat = Just (less_eq_rat, less_rat);

instance Corder Rat where {
  corder = corder_rat;
};

class (Dense_order a, Linorder a) => Dense_linorder a where {
};

class (Dense_linorder a, No_bot a,
        No_top a) => Unbounded_dense_linorder a where {
};

class (Unbounded_dense_linorder a, Field_char_0 a,
        Linordered_idom a) => Linordered_field a where {
};

instance Dense_linorder Rat where {
};

instance Unbounded_dense_linorder Rat where {
};

instance Linordered_field Rat where {
};

class (Linordered_field a) => Archimedean_field a where {
};

class (Poly_carrier a) => Large_ordered_semiring_1 a where {
};

class (Archimedean_field a,
        Large_ordered_semiring_1 a) => Floor_ceiling a where {
  floor :: a -> Int;
};

floor_rat :: Rat -> Int;
floor_rat p = let {
                (a, b) = quotient_of p;
              } in div_int a b;

instance Archimedean_field Rat where {
};

instance Large_ordered_semiring_1 Rat where {
};

instance Floor_ceiling Rat where {
  floor = floor_rat;
};

newtype Generator a b = Generator (b -> Bool, b -> (a, b));

generator :: forall a b. Generator a b -> (b -> Bool, b -> (a, b));
generator (Generator x) = x;

has_next :: forall a b. Generator a b -> b -> Bool;
has_next g = fst (generator g);

next :: forall a b. Generator a b -> b -> (a, b);
next g = snd (generator g);

sorted_list_subset_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
sorted_list_subset_fusion less eq g1 g2 s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in has_next g2 s2 &&
                let {
                  (y, s2a) = next g2 s2;
                } in (if eq x y
                       then sorted_list_subset_fusion less eq g1 g2 s1a s2a
                       else less y x &&
                              sorted_list_subset_fusion less eq g1 g2 s1 s2a)
    else True);

list_all_fusion :: forall a b. Generator a b -> (a -> Bool) -> b -> Bool;
list_all_fusion g p s =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in p x && list_all_fusion g p sa
    else True);

data Color = R | B;

data Rbta a b = Emptya | Branch Color (Rbta a b) a b (Rbta a b);

rbt_keys_next ::
  forall a b. ([(a, Rbta a b)], Rbta a b) -> (a, ([(a, Rbta a b)], Rbta a b));
rbt_keys_next ((k, t) : kts, Emptya) = (k, (kts, t));
rbt_keys_next (kts, Branch c l k v r) = rbt_keys_next ((k, r) : kts, l);

rbt_has_next :: forall a b c. ([(a, Rbta b c)], Rbta b c) -> Bool;
rbt_has_next ([], Emptya) = False;
rbt_has_next (vb : vc, va) = True;
rbt_has_next (v, Branch vb vc vd ve vf) = True;

rbt_keys_generator :: forall a b. Generator a ([(a, Rbta a b)], Rbta a b);
rbt_keys_generator = Generator (rbt_has_next, rbt_keys_next);

newtype Mapping_rbt b a = Mapping_RBTa (Rbta b a);

newtype Set_dlist a = Abs_dlist [a];

data Set a = Collect_set (a -> Bool) | DList_set (Set_dlist a)
  | RBT_set (Mapping_rbt a ()) | Set_Monad [a] | Complement (Set a);

list_of_dlist :: forall a. (Ceq a) => Set_dlist a -> [a];
list_of_dlist (Abs_dlist x) = x;

dlist_all :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Bool;
dlist_all x xc = all x (list_of_dlist xc);

impl_ofb :: forall b a. (Corder b) => Mapping_rbt b a -> Rbta b a;
impl_ofb (Mapping_RBTa x) = x;

rbt_init :: forall a b c. Rbta a b -> ([(c, Rbta a b)], Rbta a b);
rbt_init = (\ a -> ([], a));

init ::
  forall a b c. (Corder a) => Mapping_rbt a b -> ([(c, Rbta a b)], Rbta a b);
init xa = rbt_init (impl_ofb xa);

mk_eq :: forall a. (a -> a -> Bool) -> a -> a -> Bool;
mk_eq le x y = le x y && le y x;

collect :: forall a. (Cenum a) => (a -> Bool) -> Set a;
collect p =
  (case cEnum of {
    Nothing -> Collect_set p;
    Just (enum, _) -> Set_Monad (filter p enum);
  });

list_member :: forall a. (a -> a -> Bool) -> [a] -> a -> Bool;
list_member equal (x : xs) y = equal x y || list_member equal xs y;
list_member equal [] y = False;

the :: forall a. Maybe a -> a;
the (Just x2) = x2;

memberc :: forall a. (Ceq a) => Set_dlist a -> a -> Bool;
memberc xa = list_member (the ceq) (list_of_dlist xa);

rbt_lookup :: forall a b. (a -> a -> Bool) -> Rbta a b -> a -> Maybe b;
rbt_lookup less (Branch uu l x y r) k =
  (if less k x then rbt_lookup less l k
    else (if less x k then rbt_lookup less r k else Just y));
rbt_lookup less Emptya k = Nothing;

lookupc :: forall a b. (Corder a) => Mapping_rbt a b -> a -> Maybe b;
lookupc xa = rbt_lookup (snd (the corder)) (impl_ofb xa);

memberb :: forall a. (Corder a) => Mapping_rbt a () -> a -> Bool;
memberb t x = lookupc t x == Just ();

member :: forall a. (Ceq a, Corder a) => a -> Set a -> Bool;
member x (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      error "member Set_Monad: ceq = None" (\ _ -> member x (Set_Monad xs));
    Just eq -> list_member eq xs x;
  });
member xa (Complement x) = not (member xa x);
member x (RBT_set rbt) = memberb rbt x;
member x (DList_set dxs) = memberc dxs x;
member x (Collect_set a) = a x;

subset_eq :: forall a. (Cenum a, Ceq a, Corder a) => Set a -> Set a -> Bool;
subset_eq (RBT_set rbt1) (RBT_set rbt2) =
  (case corder of {
    Nothing ->
      error "subset RBT_set RBT_set: corder = None"
        (\ _ -> subset_eq (RBT_set rbt1) (RBT_set rbt2));
    Just (le, lt) ->
      (case ceq of {
        Nothing ->
          sorted_list_subset_fusion lt (mk_eq le) rbt_keys_generator
            rbt_keys_generator (init rbt1) (init rbt2);
        Just eq ->
          sorted_list_subset_fusion lt eq rbt_keys_generator rbt_keys_generator
            (init rbt1) (init rbt2);
      });
  });
subset_eq (Complement a1) (Complement a2) = subset_eq a2 a1;
subset_eq (Collect_set p) (Complement a) =
  subset_eq a (collect (\ x -> not (p x)));
subset_eq (Set_Monad xs) c = all (\ x -> member x c) xs;
subset_eq (DList_set dxs) c =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "subset DList_set1: ceq = None"
        (\ _ -> subset_eq (DList_set dxs) c);
    Just _ -> dlist_all (\ x -> member x c) dxs;
  });
subset_eq (RBT_set rbt) b =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "subset RBT_set1: corder = None" (\ _ -> subset_eq (RBT_set rbt) b);
    Just _ -> list_all_fusion rbt_keys_generator (\ x -> member x b) (init rbt);
  });

less_eq_set :: forall a. (Cenum a, Ceq a, Corder a) => Set a -> Set a -> Bool;
less_eq_set = subset_eq;

list_all2_fusion ::
  forall a b c d.
    (a -> b -> Bool) -> Generator a c -> Generator b d -> c -> d -> Bool;
list_all2_fusion p g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 &&
           let {
             (x, s1a) = next g1 s1;
             (y, s2a) = next g2 s2;
           } in p x y && list_all2_fusion p g1 g2 s1a s2a
    else not (has_next g2 s2));

set_eq :: forall a. (Cenum a, Ceq a, Corder a) => Set a -> Set a -> Bool;
set_eq (RBT_set rbt1) (RBT_set rbt2) =
  (case corder of {
    Nothing ->
      error "set_eq RBT_set RBT_set: corder = None"
        (\ _ -> set_eq (RBT_set rbt1) (RBT_set rbt2));
    Just (le, _) ->
      (case ceq of {
        Nothing ->
          list_all2_fusion (mk_eq le) rbt_keys_generator rbt_keys_generator
            (init rbt1) (init rbt2);
        Just eq ->
          list_all2_fusion eq rbt_keys_generator rbt_keys_generator (init rbt1)
            (init rbt2);
      });
  });
set_eq (Complement a) (Complement b) = set_eq a b;
set_eq a b = less_eq_set a b && less_eq_set b a;

ceq_set ::
  forall a. (Cenum a, Ceq a, Corder a) => Maybe (Set a -> Set a -> Bool);
ceq_set =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing -> Nothing;
    Just _ -> Just set_eq;
  });

instance (Cenum a, Ceq a, Corder a) => Ceq (Set a) where {
  ceq = ceq_set;
};

set_impl_set :: forall a. Phantom (Set a) Set_impla;
set_impl_set = Phantom Set_Choose;

instance Set_impl (Set a) where {
  set_impl = set_impl_set;
};

sublists :: forall a. [a] -> [[a]];
sublists [] = [[]];
sublists (x : xs) = let {
                      xss = sublists xs;
                    } in map (\ a -> x : a) xss ++ xss;

of_phantom :: forall a b. Phantom a b -> b;
of_phantom (Phantom x) = x;

emptyd :: forall a b. (Corder a) => Mapping_rbt a b;
emptyd = Mapping_RBTa Emptya;

emptyc :: forall a. (Ceq a) => Set_dlist a;
emptyc = Abs_dlist [];

set_empty_choose :: forall a. (Ceq a, Corder a) => Set a;
set_empty_choose =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing -> Set_Monad [];
        Just _ -> DList_set emptyc;
      });
    Just _ -> RBT_set emptyd;
  });

set_empty :: forall a. (Ceq a, Corder a) => Set_impla -> Set a;
set_empty Set_Choose = set_empty_choose;
set_empty Set_Monada = Set_Monad [];
set_empty Set_RBT = RBT_set emptyd;
set_empty Set_DList = DList_set emptyc;
set_empty Set_Collect = Collect_set (\ _ -> False);

fun_upda :: forall a b. (a -> a -> Bool) -> (a -> b) -> a -> b -> a -> b;
fun_upda equal f aa b a = (if equal aa a then b else f a);

balance :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance (Branch R a w x b) s t (Branch R c y z d) =
  Branch R (Branch B a w x b) s t (Branch B c y z d);
balance (Branch R (Branch R a w x b) s t c) y z Emptya =
  Branch R (Branch B a w x b) s t (Branch B c y z Emptya);
balance (Branch R (Branch R a w x b) s t c) y z (Branch B va vb vc vd) =
  Branch R (Branch B a w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch R Emptya w x (Branch R b s t c)) y z Emptya =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z Emptya);
balance (Branch R (Branch B va vb vc vd) w x (Branch R b s t c)) y z Emptya =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z Emptya);
balance (Branch R Emptya w x (Branch R b s t c)) y z (Branch B va vb vc vd) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch R (Branch B ve vf vg vh) w x (Branch R b s t c)) y z
  (Branch B va vb vc vd) =
  Branch R (Branch B (Branch B ve vf vg vh) w x b) s t
    (Branch B c y z (Branch B va vb vc vd));
balance Emptya w x (Branch R b s t (Branch R c y z d)) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z d);
balance (Branch B va vb vc vd) w x (Branch R b s t (Branch R c y z d)) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z d);
balance Emptya w x (Branch R (Branch R b s t c) y z Emptya) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z Emptya);
balance Emptya w x (Branch R (Branch R b s t c) y z (Branch B va vb vc vd)) =
  Branch R (Branch B Emptya w x b) s t (Branch B c y z (Branch B va vb vc vd));
balance (Branch B va vb vc vd) w x (Branch R (Branch R b s t c) y z Emptya) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t (Branch B c y z Emptya);
balance (Branch B va vb vc vd) w x
  (Branch R (Branch R b s t c) y z (Branch B ve vf vg vh)) =
  Branch R (Branch B (Branch B va vb vc vd) w x b) s t
    (Branch B c y z (Branch B ve vf vg vh));
balance Emptya s t Emptya = Branch B Emptya s t Emptya;
balance Emptya s t (Branch B va vb vc vd) =
  Branch B Emptya s t (Branch B va vb vc vd);
balance Emptya s t (Branch v Emptya vb vc Emptya) =
  Branch B Emptya s t (Branch v Emptya vb vc Emptya);
balance Emptya s t (Branch v (Branch B ve vf vg vh) vb vc Emptya) =
  Branch B Emptya s t (Branch v (Branch B ve vf vg vh) vb vc Emptya);
balance Emptya s t (Branch v Emptya vb vc (Branch B vf vg vh vi)) =
  Branch B Emptya s t (Branch v Emptya vb vc (Branch B vf vg vh vi));
balance Emptya s t
  (Branch v (Branch B ve vj vk vl) vb vc (Branch B vf vg vh vi)) =
  Branch B Emptya s t
    (Branch v (Branch B ve vj vk vl) vb vc (Branch B vf vg vh vi));
balance (Branch B va vb vc vd) s t Emptya =
  Branch B (Branch B va vb vc vd) s t Emptya;
balance (Branch B va vb vc vd) s t (Branch B ve vf vg vh) =
  Branch B (Branch B va vb vc vd) s t (Branch B ve vf vg vh);
balance (Branch B va vb vc vd) s t (Branch v Emptya vf vg Emptya) =
  Branch B (Branch B va vb vc vd) s t (Branch v Emptya vf vg Emptya);
balance (Branch B va vb vc vd) s t
  (Branch v (Branch B vi vj vk vl) vf vg Emptya) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v (Branch B vi vj vk vl) vf vg Emptya);
balance (Branch B va vb vc vd) s t
  (Branch v Emptya vf vg (Branch B vj vk vl vm)) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v Emptya vf vg (Branch B vj vk vl vm));
balance (Branch B va vb vc vd) s t
  (Branch v (Branch B vi vn vo vp) vf vg (Branch B vj vk vl vm)) =
  Branch B (Branch B va vb vc vd) s t
    (Branch v (Branch B vi vn vo vp) vf vg (Branch B vj vk vl vm));
balance (Branch v Emptya vb vc Emptya) s t Emptya =
  Branch B (Branch v Emptya vb vc Emptya) s t Emptya;
balance (Branch v Emptya vb vc (Branch B ve vf vg vh)) s t Emptya =
  Branch B (Branch v Emptya vb vc (Branch B ve vf vg vh)) s t Emptya;
balance (Branch v (Branch B vf vg vh vi) vb vc Emptya) s t Emptya =
  Branch B (Branch v (Branch B vf vg vh vi) vb vc Emptya) s t Emptya;
balance (Branch v (Branch B vf vg vh vi) vb vc (Branch B ve vj vk vl)) s t
  Emptya =
  Branch B (Branch v (Branch B vf vg vh vi) vb vc (Branch B ve vj vk vl)) s t
    Emptya;
balance (Branch v Emptya vf vg Emptya) s t (Branch B va vb vc vd) =
  Branch B (Branch v Emptya vf vg Emptya) s t (Branch B va vb vc vd);
balance (Branch v Emptya vf vg (Branch B vi vj vk vl)) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v Emptya vf vg (Branch B vi vj vk vl)) s t
    (Branch B va vb vc vd);
balance (Branch v (Branch B vj vk vl vm) vf vg Emptya) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v (Branch B vj vk vl vm) vf vg Emptya) s t
    (Branch B va vb vc vd);
balance (Branch v (Branch B vj vk vl vm) vf vg (Branch B vi vn vo vp)) s t
  (Branch B va vb vc vd) =
  Branch B (Branch v (Branch B vj vk vl vm) vf vg (Branch B vi vn vo vp)) s t
    (Branch B va vb vc vd);

rbt_ins ::
  forall a b.
    (a -> a -> Bool) -> (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_ins less f k v (Branch R l x y r) =
  (if less k x then Branch R (rbt_ins less f k v l) x y r
    else (if less x k then Branch R l x y (rbt_ins less f k v r)
           else Branch R l x (f k y v) r));
rbt_ins less f k v (Branch B l x y r) =
  (if less k x then balance (rbt_ins less f k v l) x y r
    else (if less x k then balance l x y (rbt_ins less f k v r)
           else Branch B l x (f k y v) r));
rbt_ins less f k v Emptya = Branch R Emptya k v Emptya;

paint :: forall a b. Color -> Rbta a b -> Rbta a b;
paint c Emptya = Emptya;
paint c (Branch uu l k v r) = Branch c l k v r;

rbt_insert_with_key ::
  forall a b.
    (a -> a -> Bool) -> (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_insert_with_key less f k v t = paint B (rbt_ins less f k v t);

rbt_insert :: forall a b. (a -> a -> Bool) -> a -> b -> Rbta a b -> Rbta a b;
rbt_insert less = rbt_insert_with_key less (\ _ _ nv -> nv);

insertd ::
  forall a b. (Corder a) => a -> b -> Mapping_rbt a b -> Mapping_rbt a b;
insertd xc xd xe =
  Mapping_RBTa (rbt_insert (snd (the corder)) xc xd (impl_ofb xe));

list_insert :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
list_insert equal x xs = (if list_member equal xs x then xs else x : xs);

insertc :: forall a. (Ceq a) => a -> Set_dlist a -> Set_dlist a;
insertc xb xc = Abs_dlist (list_insert (the ceq) xb (list_of_dlist xc));

balance_right :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance_right a k x (Branch R b s y c) = Branch R a k x (Branch B b s y c);
balance_right (Branch B a k x b) s y Emptya =
  balance (Branch R a k x b) s y Emptya;
balance_right (Branch B a k x b) s y (Branch B va vb vc vd) =
  balance (Branch R a k x b) s y (Branch B va vb vc vd);
balance_right (Branch R a k x (Branch B b s y c)) t z Emptya =
  Branch R (balance (paint R a) k x b) s y (Branch B c t z Emptya);
balance_right (Branch R a k x (Branch B b s y c)) t z (Branch B va vb vc vd) =
  Branch R (balance (paint R a) k x b) s y
    (Branch B c t z (Branch B va vb vc vd));
balance_right Emptya k x Emptya = Emptya;
balance_right (Branch R va vb vc Emptya) k x Emptya = Emptya;
balance_right (Branch R va vb vc (Branch R ve vf vg vh)) k x Emptya = Emptya;
balance_right Emptya k x (Branch B va vb vc vd) = Emptya;
balance_right (Branch R ve vf vg Emptya) k x (Branch B va vb vc vd) = Emptya;
balance_right (Branch R ve vf vg (Branch R vi vj vk vl)) k x
  (Branch B va vb vc vd) = Emptya;

balance_left :: forall a b. Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
balance_left (Branch R a k x b) s y c = Branch R (Branch B a k x b) s y c;
balance_left Emptya k x (Branch B a s y b) =
  balance Emptya k x (Branch R a s y b);
balance_left (Branch B va vb vc vd) k x (Branch B a s y b) =
  balance (Branch B va vb vc vd) k x (Branch R a s y b);
balance_left Emptya k x (Branch R (Branch B a s y b) t z c) =
  Branch R (Branch B Emptya k x a) s y (balance b t z (paint R c));
balance_left (Branch B va vb vc vd) k x (Branch R (Branch B a s y b) t z c) =
  Branch R (Branch B (Branch B va vb vc vd) k x a) s y
    (balance b t z (paint R c));
balance_left Emptya k x Emptya = Emptya;
balance_left Emptya k x (Branch R Emptya vb vc vd) = Emptya;
balance_left Emptya k x (Branch R (Branch R ve vf vg vh) vb vc vd) = Emptya;
balance_left (Branch B va vb vc vd) k x Emptya = Emptya;
balance_left (Branch B va vb vc vd) k x (Branch R Emptya vf vg vh) = Emptya;
balance_left (Branch B va vb vc vd) k x
  (Branch R (Branch R vi vj vk vl) vf vg vh) = Emptya;

combine :: forall a b. Rbta a b -> Rbta a b -> Rbta a b;
combine Emptya x = x;
combine (Branch v va vb vc vd) Emptya = Branch v va vb vc vd;
combine (Branch R a k x b) (Branch R c s y d) =
  (case combine b c of {
    Emptya -> Branch R a k x (Branch R Emptya s y d);
    Branch R b2 t z c2 -> Branch R (Branch R a k x b2) t z (Branch R c2 s y d);
    Branch B b2 t z c2 -> Branch R a k x (Branch R (Branch B b2 t z c2) s y d);
  });
combine (Branch B a k x b) (Branch B c s y d) =
  (case combine b c of {
    Emptya -> balance_left a k x (Branch B Emptya s y d);
    Branch R b2 t z c2 -> Branch R (Branch B a k x b2) t z (Branch B c2 s y d);
    Branch B b2 t z c2 ->
      balance_left a k x (Branch B (Branch B b2 t z c2) s y d);
  });
combine (Branch B va vb vc vd) (Branch R b k x c) =
  Branch R (combine (Branch B va vb vc vd) b) k x c;
combine (Branch R a k x b) (Branch B va vb vc vd) =
  Branch R a k x (combine b (Branch B va vb vc vd));

rbt_del :: forall a b. (a -> a -> Bool) -> a -> Rbta a b -> Rbta a b;
rbt_del less x (Branch c a y s b) =
  (if less x y then rbt_del_from_left less x a y s b
    else (if less y x then rbt_del_from_right less x a y s b else combine a b));
rbt_del less x Emptya = Emptya;

rbt_del_from_left ::
  forall a b.
    (a -> a -> Bool) -> a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_left less x (Branch R va vb vc vd) y s b =
  Branch R (rbt_del less x (Branch R va vb vc vd)) y s b;
rbt_del_from_left less x Emptya y s b = Branch R (rbt_del less x Emptya) y s b;
rbt_del_from_left less x (Branch B lt z v rt) y s b =
  balance_left (rbt_del less x (Branch B lt z v rt)) y s b;

rbt_del_from_right ::
  forall a b.
    (a -> a -> Bool) -> a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_right less x a y s (Branch R va vb vc vd) =
  Branch R a y s (rbt_del less x (Branch R va vb vc vd));
rbt_del_from_right less x a y s Emptya = Branch R a y s (rbt_del less x Emptya);
rbt_del_from_right less x a y s (Branch B lt z v rt) =
  balance_right a y s (rbt_del less x (Branch B lt z v rt));

rbt_delete :: forall a b. (a -> a -> Bool) -> a -> Rbta a b -> Rbta a b;
rbt_delete less k t = paint B (rbt_del less k t);

deletea :: forall a b. (Corder a) => a -> Mapping_rbt a b -> Mapping_rbt a b;
deletea xb xc = Mapping_RBTa (rbt_delete (snd (the corder)) xb (impl_ofb xc));

list_remove1 :: forall a. (a -> a -> Bool) -> a -> [a] -> [a];
list_remove1 equal x (y : xs) =
  (if equal x y then xs else y : list_remove1 equal x xs);
list_remove1 equal x [] = [];

removea :: forall a. (Ceq a) => a -> Set_dlist a -> Set_dlist a;
removea xb xc = Abs_dlist (list_remove1 (the ceq) xb (list_of_dlist xc));

inserta :: forall a. (Ceq a, Corder a) => a -> Set a -> Set a;
inserta xa (Complement x) = Complement (remove xa x);
inserta x (RBT_set rbt) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "insert RBT_set: corder = None" (\ _ -> inserta x (RBT_set rbt));
    Just _ -> RBT_set (insertd x () rbt);
  });
inserta x (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "insert DList_set: ceq = None" (\ _ -> inserta x (DList_set dxs));
    Just _ -> DList_set (insertc x dxs);
  });
inserta x (Set_Monad xs) = Set_Monad (x : xs);
inserta x (Collect_set a) =
  (case ceq of {
    Nothing ->
      error "insert Collect_set: ceq = None" (\ _ -> inserta x (Collect_set a));
    Just eq -> Collect_set (fun_upda eq a x True);
  });

remove :: forall a. (Ceq a, Corder a) => a -> Set a -> Set a;
remove x (Complement a) = Complement (inserta x a);
remove x (RBT_set rbt) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "remove RBT_set: corder = None" (\ _ -> remove x (RBT_set rbt));
    Just _ -> RBT_set (deletea x rbt);
  });
remove x (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "remove DList_set: ceq = None" (\ _ -> remove x (DList_set dxs));
    Just _ -> DList_set (removea x dxs);
  });
remove x (Collect_set a) =
  (case ceq of {
    Nothing ->
      error "remove Collect: ceq = None" (\ _ -> remove x (Collect_set a));
    Just eq -> Collect_set (fun_upda eq a x False);
  });

foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a;
foldl f a [] = a;
foldl f a (x : xs) = foldl f (f a x) xs;

set_aux :: forall a. (Ceq a, Corder a) => Set_impla -> [a] -> Set a;
set_aux Set_Monada = Set_Monad;
set_aux Set_Choose =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing -> Set_Monad;
        Just _ -> foldl (\ s x -> inserta x s) (DList_set emptyc);
      });
    Just _ -> foldl (\ s x -> inserta x s) (RBT_set emptyd);
  });
set_aux impl = foldl (\ s x -> inserta x s) (set_empty impl);

set :: forall a. (Ceq a, Corder a, Set_impl a) => [a] -> Set a;
set xs = set_aux (of_phantom (set_impl :: Phantom a Set_impla)) xs;

cEnum_set ::
  forall a.
    (Cenum a, Ceq a, Corder a,
      Set_impl a) => Maybe ([Set a],
                             ((Set a -> Bool) -> Bool,
                               (Set a -> Bool) -> Bool));
cEnum_set =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (_, _)) ->
      Just (map set (sublists enum_a),
             ((\ p -> all p (map set (sublists enum_a))),
               (\ p -> any p (map set (sublists enum_a)))));
  });

instance (Cenum a, Ceq a, Corder a, Set_impl a) => Cenum (Set a) where {
  cEnum = cEnum_set;
};

finite_UNIV_set :: forall a. (Finite_UNIV a) => Phantom (Set a) Bool;
finite_UNIV_set = Phantom (of_phantom (finite_UNIV :: Phantom a Bool));

instance (Finite_UNIV a) => Finite_UNIV (Set a) where {
  finite_UNIV = finite_UNIV_set;
};

class (Corder a) => Cproper_interval a where {
  cproper_interval :: Maybe a -> Maybe a -> Bool;
};

set_less_eq_aux_Compl_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
set_less_eq_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then let {
                  (x, s1a) = next g1 s1;
                  (y, s2a) = next g2 s2;
                } in (if less x y
                       then proper_interval ao (Just x) ||
                              set_less_eq_aux_Compl_fusion less proper_interval
                                g1 g2 (Just x) s1a s2
                       else (if less y x
                              then proper_interval ao (Just y) ||
                                     set_less_eq_aux_Compl_fusion less
                                       proper_interval g1 g2 (Just y) s1 s2a
                              else proper_interval ao (Just y)))
           else True)
    else True);

compl_set_less_eq_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
compl_set_less_eq_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then not (proper_interval ao (Just x)) &&
                                   compl_set_less_eq_aux_fusion less
                                     proper_interval g1 g2 (Just x) s1a s2
                            else (if less y x
                                   then not (proper_interval ao (Just y)) &&
  compl_set_less_eq_aux_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                   else not (proper_interval ao (Just y))))
                else not (proper_interval ao (Just x)) &&
                       compl_set_less_eq_aux_fusion less proper_interval g1 g2
                         (Just x) s1a s2)
    else (if has_next g2 s2
           then let {
                  (y, s2a) = next g2 s2;
                } in not (proper_interval ao (Just y)) &&
                       compl_set_less_eq_aux_fusion less proper_interval g1 g2
                         (Just y) s1 s2a
           else not (proper_interval ao Nothing)));

set_less_eq_aux_Compl ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
set_less_eq_aux_Compl less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           set_less_eq_aux_Compl less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  set_less_eq_aux_Compl less proper_interval (Just y) (x : xs)
                    ys
           else proper_interval ao (Just y)));
set_less_eq_aux_Compl less proper_interval ao xs [] = True;
set_less_eq_aux_Compl less proper_interval ao [] ys = True;

compl_set_less_eq_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
compl_set_less_eq_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           compl_set_less_eq_aux less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  compl_set_less_eq_aux less proper_interval (Just y) (x : xs)
                    ys
           else not (proper_interval ao (Just y))));
compl_set_less_eq_aux less proper_interval ao (x : xs) [] =
  not (proper_interval ao (Just x)) &&
    compl_set_less_eq_aux less proper_interval (Just x) xs [];
compl_set_less_eq_aux less proper_interval ao [] (y : ys) =
  not (proper_interval ao (Just y)) &&
    compl_set_less_eq_aux less proper_interval (Just y) [] ys;
compl_set_less_eq_aux less proper_interval ao [] [] =
  not (proper_interval ao Nothing);

lexord_eq_fusion ::
  forall a b c.
    (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
lexord_eq_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then has_next g2 s2 &&
           let {
             (x, s1a) = next g1 s1;
             (y, s2a) = next g2 s2;
           } in less x y ||
                  not (less y x) && lexord_eq_fusion less g1 g2 s1a s2a
    else True);

remdups_sorted :: forall a. (a -> a -> Bool) -> [a] -> [a];
remdups_sorted less (x : y : xs) =
  (if less x y then x : remdups_sorted less (y : xs)
    else remdups_sorted less (y : xs));
remdups_sorted less [x] = [x];
remdups_sorted less [] = [];

quicksort_acc :: forall a. (a -> a -> Bool) -> [a] -> [a] -> [a];
quicksort_acc less ac (x : v : va) = quicksort_part less ac x [] [] [] (v : va);
quicksort_acc less ac [x] = x : ac;
quicksort_acc less ac [] = ac;

quicksort_part ::
  forall a. (a -> a -> Bool) -> [a] -> a -> [a] -> [a] -> [a] -> [a] -> [a];
quicksort_part less ac x lts eqs gts (z : zs) =
  (if less x z then quicksort_part less ac x lts eqs (z : gts) zs
    else (if less z x then quicksort_part less ac x (z : lts) eqs gts zs
           else quicksort_part less ac x lts (z : eqs) gts zs));
quicksort_part less ac x lts eqs gts [] =
  quicksort_acc less (eqs ++ x : quicksort_acc less ac gts) lts;

quicksort :: forall a. (a -> a -> Bool) -> [a] -> [a];
quicksort less = quicksort_acc less [];

gen_keys :: forall a b. [(a, Rbta a b)] -> Rbta a b -> [a];
gen_keys kts (Branch c l k v r) = gen_keys ((k, r) : kts) l;
gen_keys ((k, t) : kts) Emptya = k : gen_keys kts t;
gen_keys [] Emptya = [];

keys :: forall a b. Rbta a b -> [a];
keys = gen_keys [];

keysa :: forall a. (Corder a) => Mapping_rbt a () -> [a];
keysa xa = keys (impl_ofb xa);

csorted_list_of_set :: forall a. (Ceq a, Corder a) => Set a -> [a];
csorted_list_of_set (Set_Monad xs) =
  (case corder of {
    Nothing ->
      error "csorted_list_of_set Set_Monad: corder = None"
        (\ _ -> csorted_list_of_set (Set_Monad xs));
    Just (_, lt) -> remdups_sorted lt (quicksort lt xs);
  });
csorted_list_of_set (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "csorted_list_of_set DList_set: ceq = None"
        (\ _ -> csorted_list_of_set (DList_set dxs));
    Just _ ->
      (case corder of {
        Nothing ->
          error "csorted_list_of_set DList_set: corder = None"
            (\ _ -> csorted_list_of_set (DList_set dxs));
        Just (_, lt) -> quicksort lt (list_of_dlist dxs);
      });
  });
csorted_list_of_set (RBT_set rbt) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "csorted_list_of_set RBT_set: corder = None"
        (\ _ -> csorted_list_of_set (RBT_set rbt));
    Just _ -> keysa rbt;
  });

uminus_set :: forall a. Set a -> Set a;
uminus_set (Complement b) = b;
uminus_set (Collect_set p) = Collect_set (\ x -> not (p x));
uminus_set a = Complement a;

bot_set :: forall a. (Ceq a, Corder a, Set_impl a) => Set a;
bot_set = set_empty (of_phantom (set_impl :: Phantom a Set_impla));

top_set :: forall a. (Ceq a, Corder a, Set_impl a) => Set a;
top_set = uminus_set bot_set;

lexordp_eq :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
lexordp_eq less (x : xs) (y : ys) =
  less x y || not (less y x) && lexordp_eq less xs ys;
lexordp_eq less (x : xs) [] = False;
lexordp_eq less xs [] = null xs;
lexordp_eq less [] ys = True;

finite :: forall a. (Finite_UNIV a, Ceq a, Corder a) => Set a -> Bool;
finite (Collect_set p) =
  of_phantom (finite_UNIV :: Phantom a Bool) ||
    error "finite Collect_set" (\ _ -> finite (Collect_set p));
finite (Set_Monad xs) = True;
finite (Complement a) =
  (if of_phantom (finite_UNIV :: Phantom a Bool) then True
    else (if finite a then False
           else error "finite Complement: infinite set"
                  (\ _ -> finite (Complement a))));
finite (RBT_set rbt) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "finite RBT_set: corder = None" (\ _ -> finite (RBT_set rbt));
    Just _ -> True;
  });
finite (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "finite DList_set: ceq = None" (\ _ -> finite (DList_set dxs));
    Just _ -> True;
  });

set_less_aux_Compl_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
set_less_aux_Compl_fusion less proper_interval g1 g2 ao s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then proper_interval ao (Just x) ||
                                   set_less_aux_Compl_fusion less
                                     proper_interval g1 g2 (Just x) s1a s2
                            else (if less y x
                                   then proper_interval ao (Just y) ||
  set_less_aux_Compl_fusion less proper_interval g1 g2 (Just y) s1 s2a
                                   else proper_interval ao (Just y)))
                else proper_interval ao (Just x) ||
                       set_less_aux_Compl_fusion less proper_interval g1 g2
                         (Just x) s1a s2)
    else (if has_next g2 s2
           then let {
                  (y, s2a) = next g2 s2;
                } in proper_interval ao (Just y) ||
                       set_less_aux_Compl_fusion less proper_interval g1 g2
                         (Just y) s1 s2a
           else proper_interval ao Nothing));

compl_set_less_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
compl_set_less_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 &&
    has_next g2 s2 &&
      let {
        (x, s1a) = next g1 s1;
        (y, s2a) = next g2 s2;
      } in (if less x y
             then not (proper_interval ao (Just x)) &&
                    compl_set_less_aux_fusion less proper_interval g1 g2
                      (Just x) s1a s2
             else (if less y x
                    then not (proper_interval ao (Just y)) &&
                           compl_set_less_aux_fusion less proper_interval g1 g2
                             (Just y) s1 s2a
                    else not (proper_interval ao (Just y))));

set_less_aux_Compl ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
set_less_aux_Compl less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           set_less_aux_Compl less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  set_less_aux_Compl less proper_interval (Just y) (x : xs) ys
           else proper_interval ao (Just y)));
set_less_aux_Compl less proper_interval ao (x : xs) [] =
  proper_interval ao (Just x) ||
    set_less_aux_Compl less proper_interval (Just x) xs [];
set_less_aux_Compl less proper_interval ao [] (y : ys) =
  proper_interval ao (Just y) ||
    set_less_aux_Compl less proper_interval (Just y) [] ys;
set_less_aux_Compl less proper_interval ao [] [] = proper_interval ao Nothing;

compl_set_less_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
compl_set_less_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           compl_set_less_aux less proper_interval (Just x) xs (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  compl_set_less_aux less proper_interval (Just y) (x : xs) ys
           else not (proper_interval ao (Just y))));
compl_set_less_aux less proper_interval ao xs [] = False;
compl_set_less_aux less proper_interval ao [] ys = False;

lexord_fusion ::
  forall a b c.
    (a -> a -> Bool) -> Generator a b -> Generator a c -> b -> c -> Bool;
lexord_fusion less g1 g2 s1 s2 =
  (if has_next g1 s1
    then (if has_next g2 s2
           then let {
                  (x, s1a) = next g1 s1;
                  (y, s2a) = next g2 s2;
                } in less x y ||
                       not (less y x) && lexord_fusion less g1 g2 s1a s2a
           else False)
    else has_next g2 s2);

lexordp :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
lexordp less (x : xs) (y : ys) =
  less x y || not (less y x) && lexordp less xs ys;
lexordp less xs [] = False;
lexordp less [] ys = not (null ys);

corder_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Maybe (Set a -> Set a -> Bool, Set a -> Set a -> Bool);
corder_set =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing -> Nothing;
    Just _ -> Just (cless_eq_set, cless_set);
  });

cless_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Set a -> Set a -> Bool;
cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case corder of {
    Nothing ->
      error "cless_set (Complement RBT_set) RBT_set: corder = None"
        (\ _ -> cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2));
    Just (_, lt) ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        compl_set_less_aux_fusion lt cproper_interval rbt_keys_generator
          rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =
  (case corder of {
    Nothing ->
      error "cless_set RBT_set (Complement RBT_set): corder = None"
        (\ _ -> cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)));
    Just (_, lt) ->
      (if (finite :: Set a -> Bool) (top_set :: Set a)
        then set_less_aux_Compl_fusion lt cproper_interval rbt_keys_generator
               rbt_keys_generator Nothing (init rbt1) (init rbt2)
        else True);
  });
cless_set (RBT_set rbta) (RBT_set rbt) =
  (case corder of {
    Nothing ->
      error "cless_set RBT_set RBT_set: corder = None"
        (\ _ -> cless_set (RBT_set rbta) (RBT_set rbt));
    Just (_, lt) ->
      lexord_fusion (\ x y -> lt y x) rbt_keys_generator rbt_keys_generator
        (init rbta) (init rbt);
  });
cless_set (Complement a) (Complement b) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "cless_set Complement Complement: corder = None"
        (\ _ -> cless_set (Complement a) (Complement b));
    Just _ -> snd (the corder_set) b a;
  });
cless_set (Complement a) b =
  (case corder of {
    Nothing ->
      error "cless_set Complement1: corder = None"
        (\ _ -> cless_set (Complement a) b);
    Just (_, lt) ->
      (if finite a && finite b
        then (finite :: Set a -> Bool) (top_set :: Set a) &&
               compl_set_less_aux lt cproper_interval Nothing
                 (csorted_list_of_set a) (csorted_list_of_set b)
        else error "cless_set Complement1: infinite set"
               (\ _ -> cless_set (Complement a) b));
  });
cless_set a (Complement b) =
  (case corder of {
    Nothing ->
      error "cless_set Complement2: corder = None"
        (\ _ -> cless_set a (Complement b));
    Just (_, lt) ->
      (if finite a && finite b
        then (if (finite :: Set a -> Bool) (top_set :: Set a)
               then set_less_aux_Compl lt cproper_interval Nothing
                      (csorted_list_of_set a) (csorted_list_of_set b)
               else True)
        else error "cless_set Complement2: infinite set"
               (\ _ -> cless_set a (Complement b)));
  });
cless_set a b =
  (case corder of {
    Nothing -> error "cless_set: corder = None" (\ _ -> cless_set a b);
    Just (_, lt) ->
      (if finite a && finite b
        then lexordp (\ x y -> lt y x) (csorted_list_of_set a)
               (csorted_list_of_set b)
        else error "cless_set: infinite set" (\ _ -> cless_set a b));
  });

cless_eq_set ::
  forall a.
    (Finite_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Set a -> Set a -> Bool;
cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) =
  (case corder of {
    Nothing ->
      error "cless_eq_set (Complement RBT_set) RBT_set: corder = None"
        (\ _ -> cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2));
    Just (_, lt) ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        compl_set_less_eq_aux_fusion lt cproper_interval rbt_keys_generator
          rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) =
  (case corder of {
    Nothing ->
      error "cless_eq_set RBT_set (Complement RBT_set): corder = None"
        (\ _ -> cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)));
    Just (_, lt) ->
      (if (finite :: Set a -> Bool) (top_set :: Set a)
        then set_less_eq_aux_Compl_fusion lt cproper_interval rbt_keys_generator
               rbt_keys_generator Nothing (init rbt1) (init rbt2)
        else True);
  });
cless_eq_set (RBT_set rbta) (RBT_set rbt) =
  (case corder of {
    Nothing ->
      error "cless_eq_set RBT_set RBT_set: corder = None"
        (\ _ -> cless_eq_set (RBT_set rbta) (RBT_set rbt));
    Just (_, lt) ->
      lexord_eq_fusion (\ x y -> lt y x) rbt_keys_generator rbt_keys_generator
        (init rbta) (init rbt);
  });
cless_eq_set (Complement a) (Complement b) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "cless_eq_set Complement Complement: corder = None"
        (\ _ -> fst (the corder_set) (Complement a) (Complement b));
    Just (_, _) -> cless_eq_set b a;
  });
cless_eq_set (Complement a) b =
  (case corder of {
    Nothing ->
      error "cless_eq_set Complement1: corder = None"
        (\ _ -> cless_eq_set (Complement a) b);
    Just (_, lt) ->
      (if finite a && finite b
        then (finite :: Set a -> Bool) (top_set :: Set a) &&
               compl_set_less_eq_aux lt cproper_interval Nothing
                 (csorted_list_of_set a) (csorted_list_of_set b)
        else error "cless_eq_set Complement1: infinite set"
               (\ _ -> cless_eq_set (Complement a) b));
  });
cless_eq_set a (Complement b) =
  (case corder of {
    Nothing ->
      error "cless_eq_set Complement2: corder = None"
        (\ _ -> cless_eq_set a (Complement b));
    Just (_, lt) ->
      (if finite a && finite b
        then (if (finite :: Set a -> Bool) (top_set :: Set a)
               then set_less_eq_aux_Compl lt cproper_interval Nothing
                      (csorted_list_of_set a) (csorted_list_of_set b)
               else True)
        else error "cless_eq_set Complement2: infinite set"
               (\ _ -> cless_eq_set a (Complement b)));
  });
cless_eq_set a b =
  (case corder of {
    Nothing -> error "cless_eq_set: corder = None" (\ _ -> cless_eq_set a b);
    Just (_, lt) ->
      (if finite a && finite b
        then lexordp_eq (\ x y -> lt y x) (csorted_list_of_set a)
               (csorted_list_of_set b)
        else error "cless_eq_set: infinite set" (\ _ -> cless_eq_set a b));
  });

instance (Finite_UNIV a, Ceq a, Cproper_interval a,
           Set_impl a) => Corder (Set a) where {
  corder = corder_set;
};

fold_fusion :: forall a b c. Generator a b -> (a -> c -> c) -> b -> c -> c;
fold_fusion g f s b =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in fold_fusion g f sa (f x b)
    else b);

length_last_fusion :: forall a b. Generator a b -> b -> (Nat, a);
length_last_fusion g s =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in fold_fusion g (\ xa (n, _) -> (plus_nat n (Nat_of_num One), xa))
                sa (Nat_of_num One, x)
    else (Zero_nat, error "undefined"));

gen_length_fusion :: forall a b. Generator a b -> Nat -> b -> Nat;
gen_length_fusion g n s =
  (if has_next g s
    then gen_length_fusion g (plus_nat n (Nat_of_num One)) (snd (next g s))
    else n);

length_fusion :: forall a b. Generator a b -> b -> Nat;
length_fusion g = gen_length_fusion g Zero_nat;

card_UNIV :: forall a. (Card_UNIV a) => Phantom a Nat;
card_UNIV = card_UNIVa;

proper_interval_set_Compl_aux_fusion ::
  forall a b c.
    (Card_UNIV a) => (a -> a -> Bool) ->
                       (Maybe a -> Maybe a -> Bool) ->
                         Generator a b ->
                           Generator a c -> Maybe a -> Nat -> b -> c -> Bool;
proper_interval_set_Compl_aux_fusion less proper_interval g1 g2 ao n s1 s2 =
  (if has_next g1 s1
    then let {
           (x, s1a) = next g1 s1;
         } in (if has_next g2 s2
                then let {
                       (y, s2a) = next g2 s2;
                     } in (if less x y
                            then proper_interval ao (Just x) ||
                                   proper_interval_set_Compl_aux_fusion less
                                     proper_interval g1 g2 (Just x)
                                     (plus_nat n (Nat_of_num One)) s1a s2
                            else (if less y x
                                   then proper_interval ao (Just y) ||
  proper_interval_set_Compl_aux_fusion less proper_interval g1 g2 (Just y)
    (plus_nat n (Nat_of_num One)) s1 s2a
                                   else proper_interval ao (Just x) &&
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
  } in not (equal_nat (minus_nat m (length_fusion g2 s2a))
             (Nat_of_num (Bit0 One))) ||
         not (equal_nat (minus_nat m (length_fusion g1 s1a))
               (Nat_of_num (Bit0 One)))))
                else let {
                       m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat))
                             n;
                       (len_x, xa) = length_last_fusion g1 s1;
                     } in not (equal_nat m len_x) &&
                            (if equal_nat m (plus_nat len_x (Nat_of_num One))
                              then not (proper_interval (Just xa) Nothing)
                              else True))
    else (if has_next g2 s2
           then let {
                  (_, _) = next g2 s2;
                  m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                  (len_y, y) = length_last_fusion g2 s2;
                } in not (equal_nat m len_y) &&
                       (if equal_nat m (plus_nat len_y (Nat_of_num One))
                         then not (proper_interval (Just y) Nothing) else True)
           else less_nat (plus_nat n (Nat_of_num One))
                  (of_phantom (card_UNIV :: Phantom a Nat))));

proper_interval_Compl_set_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> Maybe a -> b -> c -> Bool;
proper_interval_Compl_set_aux_fusion less proper_interval g1 g2 ao s1 s2 =
  has_next g1 s1 &&
    has_next g2 s2 &&
      let {
        (x, s1a) = next g1 s1;
        (y, s2a) = next g2 s2;
      } in (if less x y
             then not (proper_interval ao (Just x)) &&
                    proper_interval_Compl_set_aux_fusion less proper_interval g1
                      g2 (Just x) s1a s2
             else (if less y x
                    then not (proper_interval ao (Just y)) &&
                           proper_interval_Compl_set_aux_fusion less
                             proper_interval g1 g2 (Just y) s1 s2a
                    else not (proper_interval ao (Just x)) &&
                           (has_next g2 s2a || has_next g1 s1a)));

exhaustive_above_fusion ::
  forall a b. (Maybe a -> Maybe a -> Bool) -> Generator a b -> a -> b -> Bool;
exhaustive_above_fusion proper_interval g y s =
  (if has_next g s
    then let {
           (x, sa) = next g s;
         } in not (proper_interval (Just y) (Just x)) &&
                exhaustive_above_fusion proper_interval g x sa
    else not (proper_interval (Just y) Nothing));

proper_interval_set_aux_fusion ::
  forall a b c.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) ->
        Generator a b -> Generator a c -> b -> c -> Bool;
proper_interval_set_aux_fusion less proper_interval g1 g2 s1 s2 =
  has_next g2 s2 &&
    let {
      (y, s2a) = next g2 s2;
    } in (if has_next g1 s1
           then let {
                  (x, s1a) = next g1 s1;
                } in (if less x y then False
                       else (if less y x
                              then proper_interval (Just y) (Just x) ||
                                     (has_next g2 s2a ||
                                       not
 (exhaustive_above_fusion proper_interval g1 x s1a))
                              else proper_interval_set_aux_fusion less
                                     proper_interval g1 g2 s1a s2a))
           else has_next g2 s2a || proper_interval (Just y) Nothing);

gen_length :: forall a. Nat -> [a] -> Nat;
gen_length n (x : xs) = gen_length (plus_nat n (Nat_of_num One)) xs;
gen_length n [] = n;

size_list :: forall a. [a] -> Nat;
size_list = gen_length Zero_nat;

fold :: forall a b. (a -> b -> b) -> [a] -> b -> b;
fold f (x : xs) s = fold f xs (f x s);
fold f [] s = s;

length_last :: forall a. [a] -> (Nat, a);
length_last (x : xs) =
  fold (\ xa (n, _) -> (plus_nat n (Nat_of_num One), xa)) xs
    (Nat_of_num One, x);
length_last [] = (Zero_nat, error "undefined");

proper_interval_set_Compl_aux ::
  forall a.
    (Card_UNIV a) => (a -> a -> Bool) ->
                       (Maybe a -> Maybe a -> Bool) ->
                         Maybe a -> Nat -> [a] -> [a] -> Bool;
proper_interval_set_Compl_aux less proper_interval ao n (x : xs) (y : ys) =
  (if less x y
    then proper_interval ao (Just x) ||
           proper_interval_set_Compl_aux less proper_interval (Just x)
             (plus_nat n (Nat_of_num One)) xs (y : ys)
    else (if less y x
           then proper_interval ao (Just y) ||
                  proper_interval_set_Compl_aux less proper_interval (Just y)
                    (plus_nat n (Nat_of_num One)) (x : xs) ys
           else proper_interval ao (Just x) &&
                  let {
                    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
                  } in not (equal_nat (minus_nat m (size_list ys))
                             (Nat_of_num (Bit0 One))) ||
                         not (equal_nat (minus_nat m (size_list xs))
                               (Nat_of_num (Bit0 One)))));
proper_interval_set_Compl_aux less proper_interval ao n (x : xs) [] =
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
    (len_x, xa) = length_last (x : xs);
  } in not (equal_nat m len_x) &&
         (if equal_nat m (plus_nat len_x (Nat_of_num One))
           then not (proper_interval (Just xa) Nothing) else True);
proper_interval_set_Compl_aux less proper_interval ao n [] (y : ys) =
  let {
    m = minus_nat (of_phantom (card_UNIV :: Phantom a Nat)) n;
    (len_y, ya) = length_last (y : ys);
  } in not (equal_nat m len_y) &&
         (if equal_nat m (plus_nat len_y (Nat_of_num One))
           then not (proper_interval (Just ya) Nothing) else True);
proper_interval_set_Compl_aux less proper_interval ao n [] [] =
  less_nat (plus_nat n (Nat_of_num One))
    (of_phantom (card_UNIV :: Phantom a Nat));

proper_interval_Compl_set_aux ::
  forall a.
    (a -> a -> Bool) ->
      (Maybe a -> Maybe a -> Bool) -> Maybe a -> [a] -> [a] -> Bool;
proper_interval_Compl_set_aux less proper_interval ao uu [] = False;
proper_interval_Compl_set_aux less proper_interval ao [] uv = False;
proper_interval_Compl_set_aux less proper_interval ao (x : xs) (y : ys) =
  (if less x y
    then not (proper_interval ao (Just x)) &&
           proper_interval_Compl_set_aux less proper_interval (Just x) xs
             (y : ys)
    else (if less y x
           then not (proper_interval ao (Just y)) &&
                  proper_interval_Compl_set_aux less proper_interval (Just y)
                    (x : xs) ys
           else not (proper_interval ao (Just x)) &&
                  (if null ys then not (null xs) else True)));

exhaustive_above :: forall a. (Maybe a -> Maybe a -> Bool) -> a -> [a] -> Bool;
exhaustive_above proper_interval x (y : ys) =
  not (proper_interval (Just x) (Just y)) &&
    exhaustive_above proper_interval y ys;
exhaustive_above proper_interval x [] = not (proper_interval (Just x) Nothing);

proper_interval_set_aux ::
  forall a.
    (a -> a -> Bool) -> (Maybe a -> Maybe a -> Bool) -> [a] -> [a] -> Bool;
proper_interval_set_aux less proper_interval (x : xs) (y : ys) =
  (if less x y then False
    else (if less y x
           then proper_interval (Just y) (Just x) ||
                  (not (null ys) || not (exhaustive_above proper_interval x xs))
           else proper_interval_set_aux less proper_interval xs ys));
proper_interval_set_aux less proper_interval [] (y : ys) =
  not (null ys) || proper_interval (Just y) Nothing;
proper_interval_set_aux less proper_interval xs [] = False;

exhaustive_fusion ::
  forall a b. (Maybe a -> Maybe a -> Bool) -> Generator a b -> b -> Bool;
exhaustive_fusion proper_interval g s =
  has_next g s &&
    let {
      (x, sa) = next g s;
    } in not (proper_interval Nothing (Just x)) &&
           exhaustive_above_fusion proper_interval g x sa;

list_remdups :: forall a. (a -> a -> Bool) -> [a] -> [a];
list_remdups equal (x : xs) =
  (if list_member equal xs x then list_remdups equal xs
    else x : list_remdups equal xs);
list_remdups equal [] = [];

length :: forall a. (Ceq a) => Set_dlist a -> Nat;
length xa = size_list (list_of_dlist xa);

card :: forall a. (Card_UNIV a, Ceq a, Corder a) => Set a -> Nat;
card (Complement a) =
  let {
    aa = card a;
    s = of_phantom (card_UNIV :: Phantom a Nat);
  } in (if less_nat Zero_nat s then minus_nat s aa
         else (if finite a then Zero_nat
                else error "card Complement: infinite"
                       (\ _ -> card (Complement a))));
card (Set_Monad xs) =
  (case ceq of {
    Nothing -> error "card Set_Monad: ceq = None" (\ _ -> card (Set_Monad xs));
    Just eq -> size_list (list_remdups eq xs);
  });
card (RBT_set rbt) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing -> error "card RBT_set: corder = None" (\ _ -> card (RBT_set rbt));
    Just _ -> size_list (keysa rbt);
  });
card (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing -> error "card DList_set: ceq = None" (\ _ -> card (DList_set dxs));
    Just _ -> length dxs;
  });

is_UNIV :: forall a. (Card_UNIV a, Ceq a, Cproper_interval a) => Set a -> Bool;
is_UNIV (RBT_set rbt) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "is_UNIV RBT_set: corder = None" (\ _ -> is_UNIV (RBT_set rbt));
    Just _ ->
      of_phantom (finite_UNIV :: Phantom a Bool) &&
        exhaustive_fusion cproper_interval rbt_keys_generator (init rbt);
  });
is_UNIV a =
  let {
    aa = of_phantom (card_UNIV :: Phantom a Nat);
    b = card a;
  } in (if less_nat Zero_nat aa then equal_nat aa b
         else (if less_nat Zero_nat b then False
                else error "is_UNIV called on infinite type and set"
                       (\ _ -> is_UNIV a)));

is_emptya :: forall a b. (Corder a) => Mapping_rbt a b -> Bool;
is_emptya xa =
  (case impl_ofb xa of {
    Emptya -> True;
    Branch _ _ _ _ _ -> False;
  });

nulla :: forall a. (Ceq a) => Set_dlist a -> Bool;
nulla xa = null (list_of_dlist xa);

is_empty :: forall a. (Card_UNIV a, Ceq a, Cproper_interval a) => Set a -> Bool;
is_empty (Complement a) = is_UNIV a;
is_empty (RBT_set rbt) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "is_empty RBT_set: corder = None" (\ _ -> is_empty (RBT_set rbt));
    Just _ -> is_emptya rbt;
  });
is_empty (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "is_empty DList_set: ceq = None" (\ _ -> is_empty (DList_set dxs));
    Just _ -> nulla dxs;
  });
is_empty (Set_Monad xs) = null xs;

cproper_interval_set ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => Maybe (Set a) -> Maybe (Set a) -> Bool;
cproper_interval_set (Just (Complement (RBT_set rbt1))) (Just (RBT_set rbt2)) =
  (case corder of {
    Nothing ->
      error "cproper_interval (Complement RBT_set) RBT_set: corder = None"
        (\ _ ->
          cproper_interval_set (Just (Complement (RBT_set rbt1)))
            (Just (RBT_set rbt2)));
    Just (_, lt) ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_Compl_set_aux_fusion lt cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing (init rbt1) (init rbt2);
  });
cproper_interval_set (Just (RBT_set rbt1)) (Just (Complement (RBT_set rbt2))) =
  (case corder of {
    Nothing ->
      error "cproper_interval RBT_set (Complement RBT_set): corder = None"
        (\ _ ->
          cproper_interval_set (Just (RBT_set rbt1))
            (Just (Complement (RBT_set rbt2))));
    Just (_, lt) ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_Compl_aux_fusion lt cproper_interval
          rbt_keys_generator rbt_keys_generator Nothing Zero_nat (init rbt1)
          (init rbt2);
  });
cproper_interval_set (Just (RBT_set rbt1)) (Just (RBT_set rbt2)) =
  (case corder of {
    Nothing ->
      error "cproper_interval RBT_set RBT_set: corder = None"
        (\ _ ->
          cproper_interval_set (Just (RBT_set rbt1)) (Just (RBT_set rbt2)));
    Just (_, lt) ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_aux_fusion lt cproper_interval rbt_keys_generator
          rbt_keys_generator (init rbt1) (init rbt2);
  });
cproper_interval_set (Just (Complement a)) (Just (Complement b)) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "cproper_interval Complement Complement: corder = None"
        (\ _ ->
          cproper_interval_set (Just (Complement a)) (Just (Complement b)));
    Just _ -> cproper_interval_set (Just b) (Just a);
  });
cproper_interval_set (Just (Complement a)) (Just b) =
  (case corder of {
    Nothing ->
      error "cproper_interval Complement1: corder = None"
        (\ _ -> cproper_interval_set (Just (Complement a)) (Just b));
    Just (_, lt) ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_Compl_set_aux lt cproper_interval Nothing
          (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) (Just (Complement b)) =
  (case corder of {
    Nothing ->
      error "cproper_interval Complement2: corder = None"
        (\ _ -> cproper_interval_set (Just a) (Just (Complement b)));
    Just (_, lt) ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_Compl_aux lt cproper_interval Nothing Zero_nat
          (csorted_list_of_set a) (csorted_list_of_set b);
  });
cproper_interval_set (Just a) (Just b) =
  (case corder of {
    Nothing ->
      error "cproper_interval: corder = None"
        (\ _ -> cproper_interval_set (Just a) (Just b));
    Just (_, lt) ->
      (finite :: Set a -> Bool) (top_set :: Set a) &&
        proper_interval_set_aux lt cproper_interval (csorted_list_of_set a)
          (csorted_list_of_set b);
  });
cproper_interval_set (Just a) Nothing = not (is_UNIV a);
cproper_interval_set Nothing (Just b) = not (is_empty b);
cproper_interval_set Nothing Nothing = True;

instance (Card_UNIV a, Ceq a, Cproper_interval a,
           Set_impl a) => Cproper_interval (Set a) where {
  cproper_interval = cproper_interval_set;
};

shows_prec_list ::
  forall a. (Showa a) => Nat -> [a] -> [Prelude.Char] -> [Prelude.Char];
shows_prec_list d l = shows_list l;

shows_list_list ::
  forall a. (Showa a) => [[a]] -> [Prelude.Char] -> [Prelude.Char];
shows_list_list = shows_list_aux (shows_prec_list Zero_nat);

instance (Showa a) => Showa [a] where {
  shows_prec = shows_prec_list;
  shows_list = shows_list_list;
};

default_list :: forall a. [a];
default_list = [];

class Default a where {
  defaulta :: a;
};

instance Default [a] where {
  defaulta = default_list;
};

less_eq_list :: forall a. (Eq a, Order a) => [a] -> [a] -> Bool;
less_eq_list (x : xs) (y : ys) = less x y || x == y && less_eq_list xs ys;
less_eq_list [] xs = True;
less_eq_list (x : xs) [] = False;

less_list :: forall a. (Eq a, Order a) => [a] -> [a] -> Bool;
less_list (x : xs) (y : ys) = less x y || x == y && less_list xs ys;
less_list [] (x : xs) = True;
less_list xs [] = False;

instance (Eq a, Order a) => Ord [a] where {
  less_eq = less_eq_list;
  less = less_list;
};

instance (Eq a, Order a) => Preorder [a] where {
};

instance (Eq a, Order a) => Order [a] where {
};

instance (Eq a, Linorder a) => Linorder [a] where {
};

instance (Eq a, Key a) => Key [a] where {
};

rec_list :: forall a b. a -> (b -> [b] -> a -> a) -> [b] -> a;
rec_list f1 f2 [] = f1;
rec_list f1 f2 (x21 : x22) = f2 x21 x22 (rec_list f1 f2 x22);

ceq_list :: forall a. (Ceq a) => Maybe ([a] -> [a] -> Bool);
ceq_list =
  (case ceq of {
    Nothing -> Nothing;
    Just eq_0 ->
      Just (rec_list (\ a -> (case a of {
                               [] -> True;
                               _ : _ -> False;
                             }))
             (\ x_0 _ res_0 a ->
               (case a of {
                 [] -> False;
                 y_0 : y_1 -> eq_0 x_0 y_0 && res_0 y_1;
               })));
  });

instance (Ceq a) => Ceq [a] where {
  ceq = ceq_list;
};

set_impl_list :: forall a. Phantom [a] Set_impla;
set_impl_list = Phantom Set_Choose;

instance Set_impl [a] where {
  set_impl = set_impl_list;
};

class Countable a where {
};

instance (Countable a) => Countable [a] where {
};

finite_UNIV_list :: forall a. Phantom [a] Bool;
finite_UNIV_list = Phantom False;

card_UNIV_list :: forall a. Phantom [a] Nat;
card_UNIV_list = Phantom Zero_nat;

instance Finite_UNIV [a] where {
  finite_UNIV = finite_UNIV_list;
};

instance Card_UNIV [a] where {
  card_UNIVa = card_UNIV_list;
};

cEnum_list ::
  forall a. Maybe ([[a]], (([a] -> Bool) -> Bool, ([a] -> Bool) -> Bool));
cEnum_list = Nothing;

instance Cenum [a] where {
  cEnum = cEnum_list;
};

corder_list ::
  forall a. (Corder a) => Maybe ([a] -> [a] -> Bool, [a] -> [a] -> Bool);
corder_list = map_option (\ (_, lt) -> (lexordp_eq lt, lexordp lt)) corder;

instance (Corder a) => Corder [a] where {
  corder = corder_list;
};

mapping_impl_list :: forall a. Phantom [a] Mapping_impla;
mapping_impl_list = Phantom Mapping_Choose;

instance Mapping_impl [a] where {
  mapping_impl = mapping_impl_list;
};

cproper_interval_list :: forall a. (Corder a) => Maybe [a] -> Maybe [a] -> Bool;
cproper_interval_list xso yso = error "undefined";

instance (Corder a) => Cproper_interval [a] where {
  cproper_interval = cproper_interval_list;
};

newtype Mini_alg = Abs_mini_alg (Rat, (Rat, Nat));

newtype Mini_alg_unique = Abs_mini_alg_unique Mini_alg;

newtype Real = Real_of_u Mini_alg_unique;

rep_mini_alg_unique :: Mini_alg_unique -> Mini_alg;
rep_mini_alg_unique (Abs_mini_alg_unique x) = x;

rep_mini_alg :: Mini_alg -> (Rat, (Rat, Nat));
rep_mini_alg (Abs_mini_alg x) = x;

ma_identity :: Mini_alg -> Mini_alg -> Bool;
ma_identity xa xc = rep_mini_alg xa == rep_mini_alg xc;

mau_equal :: Mini_alg_unique -> Mini_alg_unique -> Bool;
mau_equal xa xc = ma_identity (rep_mini_alg_unique xa) (rep_mini_alg_unique xc);

equal_real :: Real -> Real -> Bool;
equal_real (Real_of_u r1) (Real_of_u r2) = mau_equal r1 r2;

instance Eq Real where {
  a == b = equal_real a b;
};

ma_compatible :: Mini_alg -> Mini_alg -> Bool;
ma_compatible xa xc =
  let {
    (_, (q1, b1)) = rep_mini_alg xa;
  } in (\ (_, (q2, b2)) ->
         equal_rat q1 zero_rat || (equal_rat q2 zero_rat || equal_nat b1 b2))
    (rep_mini_alg xc);

mau_compatible :: Mini_alg_unique -> Mini_alg_unique -> Bool;
mau_compatible xa xc =
  ma_compatible (rep_mini_alg_unique xa) (rep_mini_alg_unique xc);

of_nat :: forall a. (Semiring_1 a) => Nat -> a;
of_nat (Nat_of_num k) = numeral k;
of_nat Zero_nat = zeroa;

ma_normalize :: (Rat, (Rat, Nat)) -> (Rat, (Rat, Nat));
ma_normalize x =
  let {
    (a, (b, c)) = x;
  } in (if equal_rat b zero_rat then (a, (zero_rat, Zero_nat))
         else (a, (b, c)));

ma_times :: Mini_alg -> Mini_alg -> Mini_alg;
ma_times xb xc =
  Abs_mini_alg
    (let {
       (p1, (q1, b1)) = rep_mini_alg xb;
     } in (\ (p2, (q2, b2)) ->
            (if equal_rat q1 zero_rat
              then ma_normalize (times_rat p1 p2, (times_rat p1 q2, b2))
              else ma_normalize
                     (plus_rat (times_rat p1 p2)
                        (times_rat (times_rat (of_nat b2) q1) q2),
                       (plus_rat (times_rat p1 q2) (times_rat q1 p2), b1))))
      (rep_mini_alg xc));

mau_times :: Mini_alg_unique -> Mini_alg_unique -> Mini_alg_unique;
mau_times xb xc =
  Abs_mini_alg_unique
    (ma_times (rep_mini_alg_unique xb) (rep_mini_alg_unique xc));

times_real :: Real -> Real -> Real;
times_real (Real_of_u r1) (Real_of_u r2) =
  (if mau_compatible r1 r2 then Real_of_u (mau_times r1 r2)
    else error "different base"
           (\ _ -> times_real (Real_of_u r1) (Real_of_u r2)));

instance Times Real where {
  times = times_real;
};

instance Dvd Real where {
};

shows_list_char :: [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
shows_list_char cs = shows_string cs;

instance Showa Prelude.Char where {
  shows_prec = shows_prec_char;
  shows_list = shows_list_char;
};

ma_show_real :: Mini_alg -> [Prelude.Char];
ma_show_real xa =
  let {
    (p, (q, b)) = rep_mini_alg xa;
    sb = (shows_prec_list Zero_nat ['s', 'q', 'r', 't', '('] .
           shows_prec_nat Zero_nat b) .
           shows_prec_list Zero_nat [')'];
    qb = (if equal_rat q one_rat then sb
           else (if equal_rat q (uminus_rat one_rat)
                  then shows_prec_list Zero_nat ['-'] . sb
                  else (shows_prec_rat Zero_nat q .
                         shows_prec_list Zero_nat ['*']) .
                         sb));
  } in (if equal_rat q zero_rat then shows_prec_rat Zero_nat p []
         else (if equal_rat p zero_rat then qb []
                else (if less_rat q zero_rat
                       then shows_prec_rat Zero_nat p (qb [])
                       else shows_prec_rat Zero_nat p
                              (shows_prec_list Zero_nat ['+'] (qb [])))));

mau_show_real :: Mini_alg_unique -> [Prelude.Char];
mau_show_real xa = ma_show_real (rep_mini_alg_unique xa);

show_real :: Real -> [Prelude.Char];
show_real (Real_of_u x) = mau_show_real x;

shows_paren ::
  ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_paren p = shows_prec_char Zero_nat '(' . p . shows_prec_char Zero_nat ')';

ma_is_rat :: Mini_alg -> Bool;
ma_is_rat xa = let {
                 (_, (q, _)) = rep_mini_alg xa;
               } in equal_rat q zero_rat;

mau_is_rat :: Mini_alg_unique -> Bool;
mau_is_rat xa = ma_is_rat (rep_mini_alg_unique xa);

is_rat :: Real -> Bool;
is_rat (Real_of_u x) = mau_is_rat x;

shows_prec_real :: Nat -> Real -> [Prelude.Char] -> [Prelude.Char];
shows_prec_real d x =
  (if is_rat x then id else shows_paren) (shows_string (show_real x));

shows_list_real :: [Real] -> [Prelude.Char] -> [Prelude.Char];
shows_list_real = shows_list_aux (shows_prec_real Zero_nat);

instance Showa Real where {
  shows_prec = shows_prec_real;
  shows_list = shows_list_real;
};

ma_uminus :: Mini_alg -> Mini_alg;
ma_uminus xa =
  Abs_mini_alg
    (let {
       (p1, (q1, b1)) = rep_mini_alg xa;
     } in (uminus_rat p1, (uminus_rat q1, b1)));

mau_uminus :: Mini_alg_unique -> Mini_alg_unique;
mau_uminus xa = Abs_mini_alg_unique (ma_uminus (rep_mini_alg_unique xa));

uminus_real :: Real -> Real;
uminus_real (Real_of_u r) = Real_of_u (mau_uminus r);

ma_of_rat :: Rat -> Mini_alg;
ma_of_rat xa = Abs_mini_alg (xa, (zero_rat, Zero_nat));

mau_of_rat :: Rat -> Mini_alg_unique;
mau_of_rat xa = Abs_mini_alg_unique (ma_of_rat xa);

zero_real :: Real;
zero_real = Real_of_u (mau_of_rat zero_rat);

ma_plus :: Mini_alg -> Mini_alg -> Mini_alg;
ma_plus xb xc =
  Abs_mini_alg
    (let {
       (p1, (q1, b1)) = rep_mini_alg xb;
     } in (\ (p2, (q2, b2)) ->
            (if equal_rat q1 zero_rat then (plus_rat p1 p2, (q2, b2))
              else ma_normalize (plus_rat p1 p2, (plus_rat q1 q2, b1))))
      (rep_mini_alg xc));

mau_plus :: Mini_alg_unique -> Mini_alg_unique -> Mini_alg_unique;
mau_plus xb xc =
  Abs_mini_alg_unique
    (ma_plus (rep_mini_alg_unique xb) (rep_mini_alg_unique xc));

plus_real :: Real -> Real -> Real;
plus_real (Real_of_u r1) (Real_of_u r2) =
  (if mau_compatible r1 r2 then Real_of_u (mau_plus r1 r2)
    else error "different base"
           (\ _ -> plus_real (Real_of_u r1) (Real_of_u r2)));

minus_real :: Real -> Real -> Real;
minus_real x y = plus_real x (uminus_real y);

sqrt_int_maina :: Int -> Int -> (Int, Bool);
sqrt_int_maina x n =
  let {
    x2 = times_int x x;
  } in (if less_eq_int x2 n then (x, equal_int x2 n)
         else sqrt_int_maina
                (div_int (plus_int (div_int n x) x) (Pos (Bit0 One))) n);

ceiling :: forall a. (Floor_ceiling a) => a -> Int;
ceiling x = uminus_int (floor (uminus x));

power :: forall a. a -> (a -> a -> a) -> a -> Nat -> a;
power one times a n =
  (if equal_nat n Zero_nat then one
    else times a (power one times a (minus_nat n (Nat_of_num One))));

powera :: forall a. (Power a) => a -> Nat -> a;
powera = power onea times;

log_ceil_impl :: Nat -> Int -> Int -> Nat -> Nat;
log_ceil_impl b x prod sum =
  (if less_eq_int x prod then sum
    else log_ceil_impl b x (times_int prod (of_nat b))
           (plus_nat sum (Nat_of_num One)));

log_ceil :: Nat -> Int -> Nat;
log_ceil b x =
  (if less_nat (Nat_of_num One) b && less_eq_int Zero_int x
    then log_ceil_impl b x (Pos One) Zero_nat else Zero_nat);

of_int :: Int -> Rat;
of_int a = Frct (a, Pos One);

start_value :: Int -> Nat -> Int;
start_value n p =
  powera (Pos (Bit0 One))
    (nat (ceiling
           (divide_rat (of_int (of_nat (log_ceil (Nat_of_num (Bit0 One)) n)))
             (of_nat p))));

sqrt_int_main :: Int -> (Int, Bool);
sqrt_int_main x = sqrt_int_maina (start_value x (Nat_of_num (Bit0 One))) x;

sqrt_int_ceiling_pos :: Int -> Int;
sqrt_int_ceiling_pos x =
  (case sqrt_int_main x of {
    (y, True) -> y;
    (y, False) -> plus_int y (Pos One);
  });

sqrt_int_floor_pos :: Int -> Int;
sqrt_int_floor_pos x = fst (sqrt_int_main x);

ma_floor :: Mini_alg -> Int;
ma_floor xa =
  let {
    (p, (q, b)) = rep_mini_alg xa;
    ((z1, n1), (z2, n2)) = (quotient_of p, quotient_of q);
    z2n1 = times_int z2 n1;
    z1n2 = times_int z1 n2;
    n12 = times_int n1 n2;
    prod = times_int (times_int z2n1 z2n1) (of_nat b);
  } in div_int
         (plus_int z1n2
           (if less_eq_int Zero_int z2n1 then sqrt_int_floor_pos prod
             else uminus_int (sqrt_int_ceiling_pos prod)))
         n12;

mau_floor :: Mini_alg_unique -> Int;
mau_floor xa = ma_floor (rep_mini_alg_unique xa);

floor_real :: Real -> Int;
floor_real (Real_of_u r) = mau_floor r;

of_inta :: forall a. (Ring_1 a) => Int -> a;
of_inta (Pos k) = numeral k;
of_inta Zero_int = zeroa;
of_inta (Neg k) = uminus (numeral k);

one_real :: Real;
one_real = Real_of_u (mau_of_rat one_rat);

instance Plus Real where {
  plus = plus_real;
};

instance Semigroup_add Real where {
};

instance Cancel_semigroup_add Real where {
};

instance Ab_semigroup_add Real where {
};

instance Cancel_ab_semigroup_add Real where {
};

instance Zero Real where {
  zeroa = zero_real;
};

instance Monoid_add Real where {
};

instance Comm_monoid_add Real where {
};

instance Cancel_comm_monoid_add Real where {
};

instance Mult_zero Real where {
};

instance Semigroup_mult Real where {
};

instance Semiring Real where {
};

instance Semiring_0 Real where {
};

instance Semiring_0_cancel Real where {
};

instance One Real where {
  onea = one_real;
};

instance Power Real where {
};

instance Monoid_mult Real where {
};

instance Numeral Real where {
};

instance Semiring_numeral Real where {
};

instance Zero_neq_one Real where {
};

instance Semiring_1 Real where {
};

instance Semiring_1_cancel Real where {
};

instance Uminus Real where {
  uminus = uminus_real;
};

instance Minus Real where {
  minus = minus_real;
};

instance Group_add Real where {
};

instance Neg_numeral Real where {
};

instance Ab_group_add Real where {
};

instance Ring Real where {
};

instance Ring_1 Real where {
};

real_lt :: Real -> Real -> Bool;
real_lt x y =
  let {
    fx = floor_real x;
    fy = floor_real y;
  } in (if less_int fx fy then True
         else (if less_int fy fx then False
                else real_lt
                       (times_real x
                         (of_inta
                           (Pos (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))))))
                       (times_real y
                         (of_inta
                           (Pos (Bit0 (Bit0
(Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 (Bit0 One)))))))))))))));

ma_ge_0 :: Mini_alg -> Bool;
ma_ge_0 xa =
  let {
    (p, (q, b)) = rep_mini_alg xa;
    bqq = times_rat (times_rat (of_nat b) q) q;
    pp = times_rat p p;
  } in less_eq_rat zero_rat p && less_eq_rat bqq pp ||
         less_eq_rat zero_rat q && less_eq_rat pp bqq;

mau_ge_0 :: Mini_alg_unique -> Bool;
mau_ge_0 xa = ma_ge_0 (rep_mini_alg_unique xa);

ge_0 :: Real -> Bool;
ge_0 (Real_of_u x) = mau_ge_0 x;

less_real :: Real -> Real -> Bool;
less_real (Real_of_u x) (Real_of_u y) =
  not (equal_real (Real_of_u x) (Real_of_u y)) &&
    (if mau_compatible x y then ge_0 (minus_real (Real_of_u y) (Real_of_u x))
      else real_lt (Real_of_u x) (Real_of_u y));

abs_real :: Real -> Real;
abs_real a = (if less_real a zero_real then uminus_real a else a);

instance Abs Real where {
  absa = abs_real;
};

sgn_real :: Real -> Real;
sgn_real a =
  (if equal_real a zero_real then zero_real
    else (if less_real zero_real a then one_real else uminus_real one_real));

instance Sgn Real where {
  sgn = sgn_real;
};

instance Ab_semigroup_mult Real where {
};

instance Comm_semiring Real where {
};

instance Comm_semiring_0 Real where {
};

instance Comm_semiring_0_cancel Real where {
};

instance Comm_monoid_mult Real where {
};

instance Comm_semiring_1 Real where {
};

instance Comm_semiring_1_cancel Real where {
};

instance Comm_semiring_1_cancel_crossproduct Real where {
};

instance No_zero_divisors Real where {
};

instance Ring_no_zero_divisors Real where {
};

instance Ring_1_no_zero_divisors Real where {
};

instance Comm_ring Real where {
};

instance Comm_ring_1 Real where {
};

instance Idom Real where {
};

ma_inverse :: Mini_alg -> Mini_alg;
ma_inverse xa =
  Abs_mini_alg
    (let {
       (p, (q, b)) = rep_mini_alg xa;
       d = inverse_rat
             (minus_rat (times_rat p p) (times_rat (times_rat (of_nat b) q) q));
     } in ma_normalize (times_rat p d, (times_rat (uminus_rat q) d, b)));

mau_inverse :: Mini_alg_unique -> Mini_alg_unique;
mau_inverse xa = Abs_mini_alg_unique (ma_inverse (rep_mini_alg_unique xa));

inverse_real :: Real -> Real;
inverse_real (Real_of_u r) = Real_of_u (mau_inverse r);

divide_real :: Real -> Real -> Real;
divide_real x y = times_real x (inverse_real y);

instance Inverse Real where {
  inverse = inverse_real;
  divide = divide_real;
};

instance Division_ring Real where {
};

instance Field Real where {
};

less_eq_real :: Real -> Real -> Bool;
less_eq_real (Real_of_u x) (Real_of_u y) =
  equal_real (Real_of_u x) (Real_of_u y) ||
    (if mau_compatible x y then ge_0 (minus_real (Real_of_u y) (Real_of_u x))
      else real_lt (Real_of_u x) (Real_of_u y));

instance Ord Real where {
  less_eq = less_eq_real;
  less = less_real;
};

instance Abs_if Real where {
};

instance Sgn_if Real where {
};

instance Semiring_char_0 Real where {
};

instance Ring_char_0 Real where {
};

instance Preorder Real where {
};

instance Order Real where {
};

instance No_bot Real where {
};

instance No_top Real where {
};

instance Field_char_0 Real where {
};

ceq_real :: Maybe (Real -> Real -> Bool);
ceq_real = Just equal_real;

instance Ceq Real where {
  ceq = ceq_real;
};

set_impl_real :: Phantom Real Set_impla;
set_impl_real = Phantom Set_RBT;

instance Set_impl Real where {
  set_impl = set_impl_real;
};

instance Linorder Real where {
};

instance Ordered_ab_semigroup_add Real where {
};

instance Ordered_semiring Real where {
};

instance Ordered_cancel_semiring Real where {
};

instance Ordered_cancel_ab_semigroup_add Real where {
};

instance Ordered_ab_semigroup_add_imp_le Real where {
};

instance Ordered_comm_monoid_add Real where {
};

instance Ordered_ab_group_add Real where {
};

instance Ordered_ring Real where {
};

cEnum_real :: Maybe ([Real], ((Real -> Bool) -> Bool, (Real -> Bool) -> Bool));
cEnum_real = Nothing;

instance Cenum Real where {
  cEnum = cEnum_real;
};

instance Dense_order Real where {
};

instance Linordered_ab_semigroup_add Real where {
};

instance Linordered_cancel_ab_semigroup_add Real where {
};

instance Linordered_semiring Real where {
};

instance Linordered_semiring_strict Real where {
};

instance Linordered_semiring_1 Real where {
};

instance Linordered_semiring_1_strict Real where {
};

instance Ordered_ab_group_add_abs Real where {
};

instance Linordered_ab_group_add Real where {
};

instance Linordered_ring Real where {
};

instance Linordered_ring_strict Real where {
};

instance Ordered_comm_semiring Real where {
};

instance Ordered_cancel_comm_semiring Real where {
};

instance Linordered_comm_semiring_strict Real where {
};

instance Linordered_semidom Real where {
};

instance Ordered_comm_ring Real where {
};

instance Ordered_ring_abs Real where {
};

instance Linordered_idom Real where {
};

instance Non_strict_order Real where {
};

instance Ordered_ab_semigroup Real where {
};

instance Ordered_semiring_0 Real where {
};

instance Ordered_semiring_1 Real where {
};

instance Poly_carrier Real where {
};

corder_real :: Maybe (Real -> Real -> Bool, Real -> Real -> Bool);
corder_real = Just (less_eq_real, less_real);

instance Corder Real where {
  corder = corder_real;
};

instance Dense_linorder Real where {
};

instance Unbounded_dense_linorder Real where {
};

instance Linordered_field Real where {
};

instance Archimedean_field Real where {
};

instance Large_ordered_semiring_1 Real where {
};

instance Floor_ceiling Real where {
  floor = floor_real;
};

data Term a b = Var b | Fun a [Term a b];

data Ctxt a b = Hole | More a [Term a b] (Ctxt a b) [Term a b];

instance (Eq a, Eq b) => Eq (Term a b) where {
  a == b = equal_term a b;
};

equal_term :: forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Bool;
equal_term (Var x1) (Fun x21 x22) = False;
equal_term (Fun x21 x22) (Var x1) = False;
equal_term (Fun x21 x22) (Fun y21 y22) = x21 == y21 && x22 == y22;
equal_term (Var x1) (Var y1) = x1 == y1;

equal_ctxt :: forall a b. (Eq a, Eq b) => Ctxt a b -> Ctxt a b -> Bool;
equal_ctxt Hole (More x21 x22 x23 x24) = False;
equal_ctxt (More x21 x22 x23 x24) Hole = False;
equal_ctxt (More x21 x22 x23 x24) (More y21 y22 y23 y24) =
  x21 == y21 && x22 == y22 && equal_ctxt x23 y23 && x24 == y24;
equal_ctxt Hole Hole = True;

instance (Eq a, Eq b) => Eq (Ctxt a b) where {
  a == b = equal_ctxt a b;
};

ceq_ctxt :: forall a b. (Eq a, Eq b) => Maybe (Ctxt a b -> Ctxt a b -> Bool);
ceq_ctxt = Just equal_ctxt;

instance (Eq a, Eq b) => Ceq (Ctxt a b) where {
  ceq = ceq_ctxt;
};

set_impl_ctxt :: forall a b. Phantom (Ctxt a b) Set_impla;
set_impl_ctxt = Phantom Set_RBT;

instance Set_impl (Ctxt a b) where {
  set_impl = set_impl_ctxt;
};

rec_ctxt ::
  forall a b c.
    a -> (b -> [Term b c] -> Ctxt b c -> [Term b c] -> a -> a) -> Ctxt b c -> a;
rec_ctxt f1 f2 Hole = f1;
rec_ctxt f1 f2 (More x21 x22 x23 x24) = f2 x21 x22 x23 x24 (rec_ctxt f1 f2 x23);

n2m_term_rec ::
  forall a b c d.
    (a -> b) ->
      (c -> [Term c a] -> d -> b) ->
        d -> (Term c a -> [Term c a] -> b -> d -> d) -> Term c a -> b;
n2m_term_rec f11 f12 f21 f22 (Var x11) = f11 x11;
n2m_term_rec f11 f12 f21 f22 (Fun x121 x122) =
  f12 x121 x122 (n2m_term_list_rec f11 f12 f21 f22 x122);

n2m_term_list_rec ::
  forall a b c d.
    (a -> b) ->
      (c -> [Term c a] -> d -> b) ->
        d -> (Term c a -> [Term c a] -> b -> d -> d) -> [Term c a] -> d;
n2m_term_list_rec f11 f12 f21 f22 [] = f21;
n2m_term_list_rec f11 f12 f21 f22 (x221 : x222) =
  f22 x221 x222 (n2m_term_rec f11 f12 f21 f22 x221)
    (n2m_term_list_rec f11 f12 f21 f22 x222);

less_eq_term ::
  forall a b. (Eq a, Ord a, Eq b, Ord b) => Term a b -> Term a b -> Bool;
less_eq_term =
  (\ x y ->
    n2m_term_rec
      (\ x_0 a -> (case a of {
                    Var aa -> less x_0 aa;
                    Fun _ _ -> True;
                  }))
      (\ x_0 _ res_0 a ->
        (case a of {
          Var _ -> False;
          Fun y_0 y_1 -> less x_0 y_0 || x_0 == y_0 && res_0 y_1;
        }))
      (\ a -> (case a of {
                [] -> False;
                _ : _ -> True;
              }))
      (\ x_0 _ res_0 res_1 a ->
        (case a of {
          [] -> False;
          y_0 : y_1 -> res_0 y_0 || equal_term x_0 y_0 && res_1 y_1;
        }))
      x y ||
      equal_term x y);

less_term ::
  forall a b. (Eq a, Ord a, Eq b, Ord b) => Term a b -> Term a b -> Bool;
less_term =
  n2m_term_rec
    (\ x_0 a -> (case a of {
                  Var aa -> less x_0 aa;
                  Fun _ _ -> True;
                }))
    (\ x_0 _ res_0 a ->
      (case a of {
        Var _ -> False;
        Fun y_0 y_1 -> less x_0 y_0 || x_0 == y_0 && res_0 y_1;
      }))
    (\ a -> (case a of {
              [] -> False;
              _ : _ -> True;
            }))
    (\ x_0 _ res_0 res_1 a ->
      (case a of {
        [] -> False;
        y_0 : y_1 -> res_0 y_0 || equal_term x_0 y_0 && res_1 y_1;
      }));

instance (Eq a, Ord a, Eq b, Ord b) => Ord (Term a b) where {
  less_eq = less_eq_term;
  less = less_term;
};

instance (Eq a, Order a, Eq b, Order b) => Preorder (Term a b) where {
};

instance (Eq a, Order a, Eq b, Order b) => Order (Term a b) where {
};

corder_ctxt ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => Maybe (Ctxt a b -> Ctxt a b -> Bool,
                             Ctxt a b -> Ctxt a b -> Bool);
corder_ctxt =
  Just ((\ x y ->
          rec_ctxt (\ a -> (case a of {
                             Hole -> False;
                             More _ _ _ _ -> True;
                           }))
            (\ x_0 x_1 x_2 x_3 res_0 a ->
              (case a of {
                Hole -> False;
                More y_0 y_1 y_2 y_3 ->
                  less x_0 y_0 ||
                    x_0 == y_0 &&
                      (less_list x_1 y_1 ||
                        x_1 == y_1 &&
                          (res_0 y_2 ||
                            equal_ctxt x_2 y_2 && less_list x_3 y_3));
              }))
            x y ||
            equal_ctxt x y),
         rec_ctxt (\ a -> (case a of {
                            Hole -> False;
                            More _ _ _ _ -> True;
                          }))
           (\ x_0 x_1 x_2 x_3 res_0 a ->
             (case a of {
               Hole -> False;
               More y_0 y_1 y_2 y_3 ->
                 less x_0 y_0 ||
                   x_0 == y_0 &&
                     (less_list x_1 y_1 ||
                       x_1 == y_1 &&
                         (res_0 y_2 ||
                           equal_ctxt x_2 y_2 && less_list x_3 y_3));
             })));

instance (Eq a, Linorder a, Eq b, Linorder b) => Corder (Ctxt a b) where {
  corder = corder_ctxt;
};

shows_term ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Term a b -> [Prelude.Char] -> [Prelude.Char];
shows_term fun var (Var x) = var x;
shows_term fun var (Fun f ts) =
  fun f .
    shows_list_gen id [] ['('] [',', ' '] [')'] (map (shows_term fun var) ts);

shows_prec_term ::
  forall a b.
    (Showa a, Showa b) => Nat -> Term a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_term d t = shows_term (shows_prec Zero_nat) (shows_prec Zero_nat) t;

shows_list_term ::
  forall a b.
    (Showa a, Showa b) => [Term a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_term = shows_list_aux (shows_prec_term Zero_nat);

instance (Showa a, Showa b) => Showa (Term a b) where {
  shows_prec = shows_prec_term;
  shows_list = shows_list_term;
};

instance (Eq a, Linorder a, Eq b, Linorder b) => Linorder (Term a b) where {
};

instance (Eq a, Key a, Eq b, Key b) => Key (Term a b) where {
};

ceq_term :: forall a b. (Eq a, Eq b) => Maybe (Term a b -> Term a b -> Bool);
ceq_term = Just equal_term;

instance (Eq a, Eq b) => Ceq (Term a b) where {
  ceq = ceq_term;
};

set_impl_term :: forall a b. Phantom (Term a b) Set_impla;
set_impl_term = Phantom Set_RBT;

instance Set_impl (Term a b) where {
  set_impl = set_impl_term;
};

cEnum_term ::
  forall a b.
    Maybe ([Term a b],
            ((Term a b -> Bool) -> Bool, (Term a b -> Bool) -> Bool));
cEnum_term = Nothing;

instance Cenum (Term a b) where {
  cEnum = cEnum_term;
};

corder_term ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => Maybe (Term a b -> Term a b -> Bool,
                             Term a b -> Term a b -> Bool);
corder_term = Just (less_eq_term, less_term);

instance (Eq a, Linorder a, Eq b, Linorder b) => Corder (Term a b) where {
  corder = corder_term;
};

instance Ord Prelude.Char where {
  less_eq = (\ a b -> a <= b);
  less = (\ a b -> a < b);
};

instance Preorder Prelude.Char where {
};

instance Order Prelude.Char where {
};

instance Linorder Prelude.Char where {
};

instance Key Prelude.Char where {
};

ceq_char :: Maybe (Prelude.Char -> Prelude.Char -> Bool);
ceq_char = Just (\ a b -> a == b);

instance Ceq Prelude.Char where {
  ceq = ceq_char;
};

instance Countable Prelude.Char where {
};

corder_char ::
  Maybe (Prelude.Char -> Prelude.Char -> Bool,
          Prelude.Char -> Prelude.Char -> Bool);
corder_char = Just ((\ a b -> a <= b), (\ a b -> a < b));

instance Corder Prelude.Char where {
  corder = corder_char;
};

data Pos = Empty | PCons Nat Pos;

equal_pos :: Pos -> Pos -> Bool;
equal_pos Empty (PCons x21 x22) = False;
equal_pos (PCons x21 x22) Empty = False;
equal_pos (PCons x21 x22) (PCons y21 y22) =
  equal_nat x21 y21 && equal_pos x22 y22;
equal_pos Empty Empty = True;

instance Eq Pos where {
  a == b = equal_pos a b;
};

one_pos :: Pos;
one_pos = Empty;

instance One Pos where {
  onea = one_pos;
};

append :: Pos -> Pos -> Pos;
append Empty q = q;
append (PCons i p) q = PCons i (append p q);

times_pos :: Pos -> Pos -> Pos;
times_pos p q = append p q;

instance Times Pos where {
  times = times_pos;
};

instance Power Pos where {
};

data Sum a b = Inl a | Inr b;

equal_sum :: forall a b. (Eq a, Eq b) => Sum a b -> Sum a b -> Bool;
equal_sum (Inl x1) (Inr x2) = False;
equal_sum (Inr x2) (Inl x1) = False;
equal_sum (Inr x2) (Inr y2) = x2 == y2;
equal_sum (Inl x1) (Inl y1) = x1 == y1;

instance (Eq a, Eq b) => Eq (Sum a b) where {
  a == b = equal_sum a b;
};

data Lab a b = Lab (Lab a b) b | FunLab (Lab a b) [Lab a b] | UnLab a
  | Sharp (Lab a b);

instance (Eq a, Eq b) => Eq (Lab a b) where {
  a == b = equal_lab a b;
};

equal_lab :: forall a b. (Eq a, Eq b) => Lab a b -> Lab a b -> Bool;
equal_lab (UnLab x3) (Sharp x4) = False;
equal_lab (Sharp x4) (UnLab x3) = False;
equal_lab (FunLab x21 x22) (Sharp x4) = False;
equal_lab (Sharp x4) (FunLab x21 x22) = False;
equal_lab (FunLab x21 x22) (UnLab x3) = False;
equal_lab (UnLab x3) (FunLab x21 x22) = False;
equal_lab (Lab x11 x12) (Sharp x4) = False;
equal_lab (Sharp x4) (Lab x11 x12) = False;
equal_lab (Lab x11 x12) (UnLab x3) = False;
equal_lab (UnLab x3) (Lab x11 x12) = False;
equal_lab (Lab x11 x12) (FunLab x21 x22) = False;
equal_lab (FunLab x21 x22) (Lab x11 x12) = False;
equal_lab (Sharp x4) (Sharp y4) = equal_lab x4 y4;
equal_lab (UnLab x3) (UnLab y3) = x3 == y3;
equal_lab (FunLab x21 x22) (FunLab y21 y22) = equal_lab x21 y21 && x22 == y22;
equal_lab (Lab x11 x12) (Lab y11 y12) = equal_lab x11 y11 && x12 == y12;

shows_map ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      [a] -> [Prelude.Char] -> [Prelude.Char];
shows_map s [] = id;
shows_map s (x : xs) = s x . shows_map s xs;

shows_lab ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Lab a b -> [Prelude.Char] -> [Prelude.Char];
shows_lab fun lab (UnLab f) = fun f;
shows_lab fun lab (Lab f l) =
  shows_lab fun lab f . shows_string ['['] . lab l . shows_string [']'];
shows_lab fun lab (Sharp f) = shows_lab fun lab f . shows_string ['#'];
shows_lab fun lab (FunLab f l) =
  shows_lab fun lab f .
    shows_string ['['] . shows_map (shows_lab fun lab) l . shows_string [']'];

shows_prec_lab ::
  forall a b.
    (Showa a, Showa b) => Nat -> Lab a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_lab d l = shows_lab (shows_prec Zero_nat) (shows_prec Zero_nat) l;

shows_list_lab ::
  forall a b.
    (Showa a, Showa b) => [Lab a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_lab = shows_list_aux (shows_prec_lab Zero_nat);

instance (Showa a, Showa b) => Showa (Lab a b) where {
  shows_prec = shows_prec_lab;
  shows_list = shows_list_lab;
};

default_lab :: forall a b. (Default a) => Lab a b;
default_lab = UnLab defaulta;

instance (Default a) => Default (Lab a b) where {
  defaulta = default_lab;
};

n2m_lab_rec ::
  forall a b c d.
    (Lab a b -> b -> c -> c) ->
      (Lab a b -> [Lab a b] -> c -> d -> c) ->
        (a -> c) ->
          (Lab a b -> c -> c) ->
            d -> (Lab a b -> [Lab a b] -> c -> d -> d) -> Lab a b -> c;
n2m_lab_rec f11 f12 f13 f14 f21 f22 (Lab x111 x112) =
  f11 x111 x112 (n2m_lab_rec f11 f12 f13 f14 f21 f22 x111);
n2m_lab_rec f11 f12 f13 f14 f21 f22 (FunLab x121 x122) =
  f12 x121 x122 (n2m_lab_rec f11 f12 f13 f14 f21 f22 x121)
    (n2m_lab_list_rec f11 f12 f13 f14 f21 f22 x122);
n2m_lab_rec f11 f12 f13 f14 f21 f22 (UnLab x13) = f13 x13;
n2m_lab_rec f11 f12 f13 f14 f21 f22 (Sharp x14) =
  f14 x14 (n2m_lab_rec f11 f12 f13 f14 f21 f22 x14);

n2m_lab_list_rec ::
  forall a b c d.
    (Lab a b -> b -> c -> c) ->
      (Lab a b -> [Lab a b] -> c -> d -> c) ->
        (a -> c) ->
          (Lab a b -> c -> c) ->
            d -> (Lab a b -> [Lab a b] -> c -> d -> d) -> [Lab a b] -> d;
n2m_lab_list_rec f11 f12 f13 f14 f21 f22 [] = f21;
n2m_lab_list_rec f11 f12 f13 f14 f21 f22 (x221 : x222) =
  f22 x221 x222 (n2m_lab_rec f11 f12 f13 f14 f21 f22 x221)
    (n2m_lab_list_rec f11 f12 f13 f14 f21 f22 x222);

less_eq_lab ::
  forall a b. (Eq a, Ord a, Eq b, Ord b) => Lab a b -> Lab a b -> Bool;
less_eq_lab =
  (\ x y ->
    n2m_lab_rec
      (\ x_0 x_1 res_0 a ->
        (case a of {
          Lab y_0 y_1 -> res_0 y_0 || equal_lab x_0 y_0 && less x_1 y_1;
          FunLab _ _ -> True;
          UnLab _ -> True;
          Sharp _ -> True;
        }))
      (\ x_0 _ res_0 res_1 a ->
        (case a of {
          Lab _ _ -> False;
          FunLab y_0 y_1 -> res_0 y_0 || equal_lab x_0 y_0 && res_1 y_1;
          UnLab _ -> True;
          Sharp _ -> True;
        }))
      (\ x_0 a ->
        (case a of {
          Lab _ _ -> False;
          FunLab _ _ -> False;
          UnLab aa -> less x_0 aa;
          Sharp _ -> True;
        }))
      (\ _ a b ->
        (case b of {
          Lab _ _ -> False;
          FunLab _ _ -> False;
          UnLab _ -> False;
          Sharp ba -> a ba;
        }))
      (\ a -> (case a of {
                [] -> False;
                _ : _ -> True;
              }))
      (\ x_0 _ res_0 res_1 a ->
        (case a of {
          [] -> False;
          y_0 : y_1 -> res_0 y_0 || equal_lab x_0 y_0 && res_1 y_1;
        }))
      x y ||
      equal_lab x y);

less_lab ::
  forall a b. (Eq a, Ord a, Eq b, Ord b) => Lab a b -> Lab a b -> Bool;
less_lab =
  n2m_lab_rec
    (\ x_0 x_1 res_0 a ->
      (case a of {
        Lab y_0 y_1 -> res_0 y_0 || equal_lab x_0 y_0 && less x_1 y_1;
        FunLab _ _ -> True;
        UnLab _ -> True;
        Sharp _ -> True;
      }))
    (\ x_0 _ res_0 res_1 a ->
      (case a of {
        Lab _ _ -> False;
        FunLab y_0 y_1 -> res_0 y_0 || equal_lab x_0 y_0 && res_1 y_1;
        UnLab _ -> True;
        Sharp _ -> True;
      }))
    (\ x_0 a ->
      (case a of {
        Lab _ _ -> False;
        FunLab _ _ -> False;
        UnLab aa -> less x_0 aa;
        Sharp _ -> True;
      }))
    (\ _ a b ->
      (case b of {
        Lab _ _ -> False;
        FunLab _ _ -> False;
        UnLab _ -> False;
        Sharp ba -> a ba;
      }))
    (\ a -> (case a of {
              [] -> False;
              _ : _ -> True;
            }))
    (\ x_0 _ res_0 res_1 a ->
      (case a of {
        [] -> False;
        y_0 : y_1 -> res_0 y_0 || equal_lab x_0 y_0 && res_1 y_1;
      }));

instance (Eq a, Ord a, Eq b, Ord b) => Ord (Lab a b) where {
  less_eq = less_eq_lab;
  less = less_lab;
};

instance (Eq a, Order a, Eq b, Order b) => Preorder (Lab a b) where {
};

instance (Eq a, Order a, Eq b, Order b) => Order (Lab a b) where {
};

instance (Eq a, Linorder a, Eq b, Linorder b) => Linorder (Lab a b) where {
};

instance (Eq a, Key a, Eq b, Key b) => Key (Lab a b) where {
};

ceq_lab :: forall a b. (Eq a, Eq b) => Maybe (Lab a b -> Lab a b -> Bool);
ceq_lab = Just equal_lab;

instance (Eq a, Eq b) => Ceq (Lab a b) where {
  ceq = ceq_lab;
};

set_impl_lab :: forall a b. Phantom (Lab a b) Set_impla;
set_impl_lab = Phantom Set_RBT;

instance Set_impl (Lab a b) where {
  set_impl = set_impl_lab;
};

cEnum_lab ::
  forall a b.
    Maybe ([Lab a b], ((Lab a b -> Bool) -> Bool, (Lab a b -> Bool) -> Bool));
cEnum_lab = Nothing;

instance Cenum (Lab a b) where {
  cEnum = cEnum_lab;
};

corder_lab ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => Maybe (Lab a b -> Lab a b -> Bool,
                             Lab a b -> Lab a b -> Bool);
corder_lab = Just (less_eq_lab, less_lab);

instance (Eq a, Linorder a, Eq b, Linorder b) => Corder (Lab a b) where {
  corder = corder_lab;
};

rec_option :: forall a b. a -> (b -> a) -> Maybe b -> a;
rec_option f1 f2 Nothing = f1;
rec_option f1 f2 (Just x2) = f2 x2;

ceq_option :: forall a. (Ceq a) => Maybe (Maybe a -> Maybe a -> Bool);
ceq_option =
  (case ceq of {
    Nothing -> Nothing;
    Just eq_0 ->
      Just (rec_option
             (\ a -> (case a of {
                       Nothing -> True;
                       Just _ -> False;
                     }))
             (\ x_0 a ->
               (case a of {
                 Nothing -> False;
                 Just aa -> eq_0 x_0 aa;
               })));
  });

instance (Ceq a) => Ceq (Maybe a) where {
  ceq = ceq_option;
};

set_impl_option :: forall a. (Set_impl a) => Phantom (Maybe a) Set_impla;
set_impl_option = Phantom (of_phantom (set_impl :: Phantom a Set_impla));

instance (Set_impl a) => Set_impl (Maybe a) where {
  set_impl = set_impl_option;
};

cEnum_option ::
  forall a.
    (Cenum a) => Maybe ([Maybe a],
                         ((Maybe a -> Bool) -> Bool,
                           (Maybe a -> Bool) -> Bool));
cEnum_option =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (enum_all_a, enum_ex_a)) ->
      Just (Nothing : map Just enum_a,
             ((\ p -> p Nothing && enum_all_a (\ x -> p (Just x))),
               (\ p -> p Nothing || enum_ex_a (\ x -> p (Just x)))));
  });

instance (Cenum a) => Cenum (Maybe a) where {
  cEnum = cEnum_option;
};

finite_UNIV_option :: forall a. (Finite_UNIV a) => Phantom (Maybe a) Bool;
finite_UNIV_option = Phantom (of_phantom (finite_UNIV :: Phantom a Bool));

instance (Finite_UNIV a) => Finite_UNIV (Maybe a) where {
  finite_UNIV = finite_UNIV_option;
};

corder_option ::
  forall a.
    (Corder a) => Maybe (Maybe a -> Maybe a -> Bool,
                          Maybe a -> Maybe a -> Bool);
corder_option =
  map_option
    (\ (leq, lt) ->
      ((\ x y ->
         (case x of {
           Nothing -> True;
           Just xa -> (case y of {
                        Nothing -> False;
                        Just a -> leq xa a;
                      });
         })),
        (\ x a ->
          (case a of {
            Nothing -> False;
            Just y -> (case x of {
                        Nothing -> True;
                        Just xa -> lt xa y;
                      });
          }))))
    corder;

instance (Corder a) => Corder (Maybe a) where {
  corder = corder_option;
};

is_none :: forall a. Maybe a -> Bool;
is_none (Just x) = False;
is_none Nothing = True;

cproper_interval_option ::
  forall a. (Cproper_interval a) => Maybe (Maybe a) -> Maybe (Maybe a) -> Bool;
cproper_interval_option Nothing Nothing = True;
cproper_interval_option Nothing (Just x) = not (is_none x);
cproper_interval_option (Just x) Nothing = cproper_interval x Nothing;
cproper_interval_option (Just x) (Just Nothing) = False;
cproper_interval_option (Just x) (Just (Just y)) = cproper_interval x (Just y);

instance (Cproper_interval a) => Cproper_interval (Maybe a) where {
  cproper_interval = cproper_interval_option;
};

newtype Alist b a = Alist [(b, a)];

newtype Multiset a = Bag (Alist a Nat);

map_of :: forall a b. (Eq a) => [(a, b)] -> a -> Maybe b;
map_of ((l, v) : ps) k = (if l == k then Just v else map_of ps k);
map_of [] k = Nothing;

count_of :: forall a. (Eq a) => [(a, Nat)] -> a -> Nat;
count_of xs x = (case map_of xs x of {
                  Nothing -> Zero_nat;
                  Just n -> n;
                });

impl_ofa :: forall b a. Alist b a -> [(b, a)];
impl_ofa (Alist x) = x;

count :: forall a. (Eq a) => Multiset a -> a -> Nat;
count (Bag xs) = count_of (impl_ofa xs);

less_eq_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Bool;
less_eq_multiset (Bag xs) a =
  all (\ (x, n) -> less_eq_nat n (count a x)) (impl_ofa xs);

equal_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Bool;
equal_multiset m1 m2 = less_eq_multiset m1 m2 && less_eq_multiset m2 m1;

instance (Eq a) => Eq (Multiset a) where {
  a == b = equal_multiset a b;
};

shows_prec_prod ::
  forall a b.
    (Showa a, Showa b) => Nat -> (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_prec_prod d p =
  shows_paren
    (shows_prec Zero_nat (fst p) .
      shows_prec_char Zero_nat ',' . shows_prec Zero_nat (snd p));

shows_list_prod ::
  forall a b.
    (Showa a, Showa b) => [(a, b)] -> [Prelude.Char] -> [Prelude.Char];
shows_list_prod = shows_list_aux (shows_prec_prod Zero_nat);

instance (Showa a, Showa b) => Showa (a, b) where {
  shows_prec = shows_prec_prod;
  shows_list = shows_list_prod;
};

less_eq_proda :: forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Bool;
less_eq_proda (x1, y1) (x2, y2) = less x1 x2 || less_eq x1 x2 && less_eq y1 y2;

less_proda :: forall a b. (Ord a, Ord b) => (a, b) -> (a, b) -> Bool;
less_proda (x1, y1) (x2, y2) = less x1 x2 || less_eq x1 x2 && less y1 y2;

instance (Ord a, Ord b) => Ord (a, b) where {
  less_eq = less_eq_proda;
  less = less_proda;
};

instance (Preorder a, Preorder b) => Preorder (a, b) where {
};

instance (Order a, Order b) => Order (a, b) where {
};

instance (Linorder a, Linorder b) => Linorder (a, b) where {
};

instance (Key a, Key b) => Key (a, b) where {
};

rec_prod :: forall a b c. (a -> b -> c) -> (a, b) -> c;
rec_prod f1 (a, b) = f1 a b;

ceq_prod :: forall a b. (Ceq a, Ceq b) => Maybe ((a, b) -> (a, b) -> Bool);
ceq_prod =
  (case ceq of {
    Nothing -> Nothing;
    Just eq_0 ->
      (case ceq of {
        Nothing -> Nothing;
        Just eq_1 ->
          Just (rec_prod
                 (\ x_0 x_1 (y_0, y_1) -> eq_0 x_0 y_0 && eq_1 x_1 y_1));
      });
  });

instance (Ceq a, Ceq b) => Ceq (a, b) where {
  ceq = ceq_prod;
};

set_impl_choose2 :: Set_impla -> Set_impla -> Set_impla;
set_impl_choose2 Set_Monada Set_Monada = Set_Monada;
set_impl_choose2 Set_RBT Set_RBT = Set_RBT;
set_impl_choose2 Set_DList Set_DList = Set_DList;
set_impl_choose2 Set_Collect Set_Collect = Set_Collect;
set_impl_choose2 x y = Set_Choose;

set_impl_prod ::
  forall a b. (Set_impl a, Set_impl b) => Phantom (a, b) Set_impla;
set_impl_prod =
  Phantom
    (set_impl_choose2 (of_phantom (set_impl :: Phantom a Set_impla))
      (of_phantom (set_impl :: Phantom b Set_impla)));

instance (Set_impl a, Set_impl b) => Set_impl (a, b) where {
  set_impl = set_impl_prod;
};

finite_UNIV_prod ::
  forall a b. (Finite_UNIV a, Finite_UNIV b) => Phantom (a, b) Bool;
finite_UNIV_prod =
  Phantom
    (of_phantom (finite_UNIV :: Phantom a Bool) &&
      of_phantom (finite_UNIV :: Phantom b Bool));

card_UNIV_prod :: forall a b. (Card_UNIV a, Card_UNIV b) => Phantom (a, b) Nat;
card_UNIV_prod =
  Phantom
    (times_nat (of_phantom (card_UNIVa :: Phantom a Nat))
      (of_phantom (card_UNIVa :: Phantom b Nat)));

instance (Finite_UNIV a, Finite_UNIV b) => Finite_UNIV (a, b) where {
  finite_UNIV = finite_UNIV_prod;
};

instance (Card_UNIV a, Card_UNIV b) => Card_UNIV (a, b) where {
  card_UNIVa = card_UNIV_prod;
};

product :: forall a b. [a] -> [b] -> [(a, b)];
product [] uu = [];
product (x : xs) ys = map (\ a -> (x, a)) ys ++ product xs ys;

cEnum_prod ::
  forall a b.
    (Cenum a,
      Cenum b) => Maybe ([(a, b)],
                          (((a, b) -> Bool) -> Bool, ((a, b) -> Bool) -> Bool));
cEnum_prod =
  (case cEnum of {
    Nothing -> Nothing;
    Just (enum_a, (enum_all_a, enum_ex_a)) ->
      (case cEnum of {
        Nothing -> Nothing;
        Just (enum_b, (enum_all_b, enum_ex_b)) ->
          Just (product enum_a enum_b,
                 ((\ p -> enum_all_a (\ x -> enum_all_b (\ y -> p (x, y)))),
                   (\ p -> enum_ex_a (\ x -> enum_ex_b (\ y -> p (x, y))))));
      });
  });

instance (Cenum a, Cenum b) => Cenum (a, b) where {
  cEnum = cEnum_prod;
};

less_eq_prod ::
  forall a b.
    (a -> a -> Bool) ->
      (a -> a -> Bool) -> (b -> b -> Bool) -> (a, b) -> (a, b) -> Bool;
less_eq_prod leq_a less_a leq_b =
  (\ (x1, x2) (y1, y2) -> less_a x1 y1 || leq_a x1 y1 && leq_b x2 y2);

less_prod ::
  forall a b.
    (a -> a -> Bool) ->
      (a -> a -> Bool) -> (b -> b -> Bool) -> (a, b) -> (a, b) -> Bool;
less_prod leq_a less_a less_b =
  (\ (x1, x2) (y1, y2) -> less_a x1 y1 || leq_a x1 y1 && less_b x2 y2);

corder_prod ::
  forall a b.
    (Corder a,
      Corder b) => Maybe ((a, b) -> (a, b) -> Bool, (a, b) -> (a, b) -> Bool);
corder_prod =
  (case corder of {
    Nothing -> Nothing;
    Just (leq_a, lt_a) ->
      (case corder of {
        Nothing -> Nothing;
        Just (leq_b, lt_b) ->
          Just (less_eq_prod leq_a lt_a leq_b, less_prod leq_a lt_a lt_b);
      });
  });

instance (Corder a, Corder b) => Corder (a, b) where {
  corder = corder_prod;
};

mapping_impl_choose2 :: Mapping_impla -> Mapping_impla -> Mapping_impla;
mapping_impl_choose2 Mapping_RBT Mapping_RBT = Mapping_RBT;
mapping_impl_choose2 Mapping_Assoc_List Mapping_Assoc_List = Mapping_Assoc_List;
mapping_impl_choose2 Mapping_Mapping Mapping_Mapping = Mapping_Mapping;
mapping_impl_choose2 x y = Mapping_Choose;

mapping_impl_prod ::
  forall a b. (Mapping_impl a, Mapping_impl b) => Phantom (a, b) Mapping_impla;
mapping_impl_prod =
  Phantom
    (mapping_impl_choose2 (of_phantom (mapping_impl :: Phantom a Mapping_impla))
      (of_phantom (mapping_impl :: Phantom b Mapping_impla)));

instance (Mapping_impl a, Mapping_impl b) => Mapping_impl (a, b) where {
  mapping_impl = mapping_impl_prod;
};

cproper_interval_prod ::
  forall a b.
    (Cproper_interval a,
      Cproper_interval b) => Maybe (a, b) -> Maybe (a, b) -> Bool;
cproper_interval_prod Nothing Nothing = True;
cproper_interval_prod Nothing (Just (y1, y2)) =
  cproper_interval Nothing (Just y1) || cproper_interval Nothing (Just y2);
cproper_interval_prod (Just (x1, x2)) Nothing =
  cproper_interval (Just x1) Nothing || cproper_interval (Just x2) Nothing;
cproper_interval_prod (Just (x1, x2)) (Just (y1, y2)) =
  cproper_interval (Just x1) (Just y1) ||
    (snd (the corder) x1 y1 &&
       (cproper_interval (Just x2) Nothing ||
         cproper_interval Nothing (Just y2)) ||
      not (snd (the corder) y1 x1) && cproper_interval (Just x2) (Just y2));

instance (Cproper_interval a,
           Cproper_interval b) => Cproper_interval (a, b) where {
  cproper_interval = cproper_interval_prod;
};

data Gctxt a b = GCHole | GCFun a [Gctxt a b];

instance (Eq a) => Eq (Gctxt a b) where {
  a == b = equal_gctxt a b;
};

equal_gctxt :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Bool;
equal_gctxt GCHole (GCFun x21 x22) = False;
equal_gctxt (GCFun x21 x22) GCHole = False;
equal_gctxt (GCFun x21 x22) (GCFun y21 y22) = x21 == y21 && x22 == y22;
equal_gctxt GCHole GCHole = True;

data Ta_rule a b = TA_rule b [a] a;

equal_ta_rule :: forall a b. (Eq a, Eq b) => Ta_rule a b -> Ta_rule a b -> Bool;
equal_ta_rule (TA_rule x1 x2 x3) (TA_rule y1 y2 y3) =
  x1 == y1 && x2 == y2 && x3 == y3;

instance (Eq a, Eq b) => Eq (Ta_rule a b) where {
  a == b = equal_ta_rule a b;
};

show_ta_rule ::
  forall a b.
    (Showa a, Showa b) => Ta_rule a b -> [Prelude.Char] -> [Prelude.Char];
show_ta_rule (TA_rule f qs q) =
  shows_prec Zero_nat f .
    shows_prec_list Zero_nat qs .
      shows_prec_list Zero_nat [' ', '-', '>', ' '] . shows_prec Zero_nat q;

shows_prec_ta_rule ::
  forall a b.
    (Showa a,
      Showa b) => Nat -> Ta_rule a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_ta_rule d r = show_ta_rule r;

shows_list_ta_rule ::
  forall a b.
    (Showa a, Showa b) => [Ta_rule a b] -> [Prelude.Char] -> [Prelude.Char];
shows_list_ta_rule = shows_list_aux (shows_prec_ta_rule Zero_nat);

instance (Showa a, Showa b) => Showa (Ta_rule a b) where {
  shows_prec = shows_prec_ta_rule;
  shows_list = shows_list_ta_rule;
};

ceq_ta_rule ::
  forall a b. (Eq a, Eq b) => Maybe (Ta_rule a b -> Ta_rule a b -> Bool);
ceq_ta_rule = Just equal_ta_rule;

instance (Eq a, Eq b) => Ceq (Ta_rule a b) where {
  ceq = ceq_ta_rule;
};

set_impl_ta_rule :: forall a b. Phantom (Ta_rule a b) Set_impla;
set_impl_ta_rule = Phantom Set_RBT;

instance Set_impl (Ta_rule a b) where {
  set_impl = set_impl_ta_rule;
};

cEnum_ta_rule ::
  forall a b.
    Maybe ([Ta_rule a b],
            ((Ta_rule a b -> Bool) -> Bool, (Ta_rule a b -> Bool) -> Bool));
cEnum_ta_rule = Nothing;

instance Cenum (Ta_rule a b) where {
  cEnum = cEnum_ta_rule;
};

finite_UNIV_ta_rule :: forall a b. Phantom (Ta_rule a b) Bool;
finite_UNIV_ta_rule = Phantom False;

instance Finite_UNIV (Ta_rule a b) where {
  finite_UNIV = finite_UNIV_ta_rule;
};

rec_ta_rule :: forall a b c. (a -> [b] -> b -> c) -> Ta_rule b a -> c;
rec_ta_rule f (TA_rule x1 x2 x3) = f x1 x2 x3;

less_eq_ta_rule ::
  forall a b.
    (Eq a, Order a, Eq b, Ord b) => Ta_rule a b -> Ta_rule a b -> Bool;
less_eq_ta_rule =
  (\ x y ->
    rec_ta_rule
      (\ x_0 x_1 x_2 (TA_rule y_0 y_1 y_2) ->
        less x_0 y_0 ||
          x_0 == y_0 && (less_list x_1 y_1 || x_1 == y_1 && less x_2 y_2))
      x y ||
      equal_ta_rule x y);

less_ta_rule ::
  forall a b.
    (Eq a, Order a, Eq b, Ord b) => Ta_rule a b -> Ta_rule a b -> Bool;
less_ta_rule =
  rec_ta_rule
    (\ x_0 x_1 x_2 (TA_rule y_0 y_1 y_2) ->
      less x_0 y_0 ||
        x_0 == y_0 && (less_list x_1 y_1 || x_1 == y_1 && less x_2 y_2));

corder_ta_rule ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => Maybe (Ta_rule a b -> Ta_rule a b -> Bool,
                             Ta_rule a b -> Ta_rule a b -> Bool);
corder_ta_rule = Just (less_eq_ta_rule, less_ta_rule);

instance (Eq a, Linorder a, Eq b, Linorder b) => Corder (Ta_rule a b) where {
  corder = corder_ta_rule;
};

cproper_interval_ta_rule ::
  forall a b.
    (Linorder a,
      Linorder b) => Maybe (Ta_rule a b) -> Maybe (Ta_rule a b) -> Bool;
cproper_interval_ta_rule = (\ _ _ -> False);

instance (Eq a, Linorder a, Eq b,
           Linorder b) => Cproper_interval (Ta_rule a b) where {
  cproper_interval = cproper_interval_ta_rule;
};

data Arctic = MinInfty | Num_arc Int;

equal_arctic :: Arctic -> Arctic -> Bool;
equal_arctic MinInfty (Num_arc int) = False;
equal_arctic (Num_arc int) MinInfty = False;
equal_arctic (Num_arc inta) (Num_arc int) = equal_int inta int;
equal_arctic MinInfty MinInfty = True;

instance Eq Arctic where {
  a == b = equal_arctic a b;
};

shows_arctic :: Arctic -> [Prelude.Char] -> [Prelude.Char];
shows_arctic (Num_arc i) = shows_prec_int Zero_nat i;
shows_arctic MinInfty = shows_string ['-', 'i', 'n', 'f'];

shows_prec_arctic :: Nat -> Arctic -> [Prelude.Char] -> [Prelude.Char];
shows_prec_arctic d ai = shows_arctic ai;

shows_list_arctic :: [Arctic] -> [Prelude.Char] -> [Prelude.Char];
shows_list_arctic = shows_list_aux (shows_prec_arctic Zero_nat);

instance Showa Arctic where {
  shows_prec = shows_prec_arctic;
  shows_list = shows_list_arctic;
};

one_arctic :: Arctic;
one_arctic = Num_arc Zero_int;

instance One Arctic where {
  onea = one_arctic;
};

max :: forall a. (Ord a) => a -> a -> a;
max a b = (if less_eq a b then b else a);

plus_arctic :: Arctic -> Arctic -> Arctic;
plus_arctic MinInfty y = y;
plus_arctic (Num_arc v) MinInfty = Num_arc v;
plus_arctic (Num_arc x) (Num_arc y) = Num_arc (max x y);

instance Plus Arctic where {
  plus = plus_arctic;
};

zero_arctic :: Arctic;
zero_arctic = MinInfty;

instance Zero Arctic where {
  zeroa = zero_arctic;
};

instance Semigroup_add Arctic where {
};

instance Numeral Arctic where {
};

times_arctic :: Arctic -> Arctic -> Arctic;
times_arctic MinInfty y = MinInfty;
times_arctic (Num_arc v) MinInfty = MinInfty;
times_arctic (Num_arc x) (Num_arc y) = Num_arc (plus_int x y);

instance Times Arctic where {
  times = times_arctic;
};

instance Power Arctic where {
};

less_eq_arctic :: Arctic -> Arctic -> Bool;
less_eq_arctic MinInfty x = True;
less_eq_arctic (Num_arc uu) MinInfty = False;
less_eq_arctic (Num_arc y) (Num_arc x) = less_eq_int y x;

less_arctic :: Arctic -> Arctic -> Bool;
less_arctic MinInfty x = True;
less_arctic (Num_arc uu) MinInfty = False;
less_arctic (Num_arc y) (Num_arc x) = less_int y x;

instance Ord Arctic where {
  less_eq = less_eq_arctic;
  less = less_arctic;
};

instance Ab_semigroup_add Arctic where {
};

instance Semigroup_mult Arctic where {
};

instance Semiring Arctic where {
};

instance Mult_zero Arctic where {
};

instance Monoid_add Arctic where {
};

instance Comm_monoid_add Arctic where {
};

instance Semiring_0 Arctic where {
};

instance Monoid_mult Arctic where {
};

instance Semiring_numeral Arctic where {
};

instance Zero_neq_one Arctic where {
};

instance Semiring_1 Arctic where {
};

ceq_arctic :: Maybe (Arctic -> Arctic -> Bool);
ceq_arctic = Just equal_arctic;

instance Ceq Arctic where {
  ceq = ceq_arctic;
};

set_impl_arctic :: Phantom Arctic Set_impla;
set_impl_arctic = Phantom Set_RBT;

instance Set_impl Arctic where {
  set_impl = set_impl_arctic;
};

cEnum_arctic ::
  Maybe ([Arctic], ((Arctic -> Bool) -> Bool, (Arctic -> Bool) -> Bool));
cEnum_arctic = Nothing;

instance Cenum Arctic where {
  cEnum = cEnum_arctic;
};

rec_arctic :: forall a. a -> (Int -> a) -> Arctic -> a;
rec_arctic f1 f2 MinInfty = f1;
rec_arctic f1 f2 (Num_arc int) = f2 int;

corder_arctic :: Maybe (Arctic -> Arctic -> Bool, Arctic -> Arctic -> Bool);
corder_arctic =
  Just ((\ x y ->
          rec_arctic
            (\ a -> (case a of {
                      MinInfty -> False;
                      Num_arc _ -> True;
                    }))
            (\ x_0 a ->
              (case a of {
                MinInfty -> False;
                Num_arc aa -> less_int x_0 aa;
              }))
            x y ||
            equal_arctic x y),
         rec_arctic
           (\ a -> (case a of {
                     MinInfty -> False;
                     Num_arc _ -> True;
                   }))
           (\ x_0 a ->
             (case a of {
               MinInfty -> False;
               Num_arc aa -> less_int x_0 aa;
             })));

instance Corder Arctic where {
  corder = corder_arctic;
};

instance Non_strict_order Arctic where {
};

instance Ordered_ab_semigroup Arctic where {
};

instance Ordered_semiring_0 Arctic where {
};

instance Ordered_semiring_1 Arctic where {
};

data Filtered a = FPair a Nat;

equal_filtered :: forall a. (Eq a) => Filtered a -> Filtered a -> Bool;
equal_filtered (FPair x1 x2) (FPair y1 y2) = x1 == y1 && equal_nat x2 y2;

instance (Eq a) => Eq (Filtered a) where {
  a == b = equal_filtered a b;
};

filtered_fun :: forall a. Filtered a -> a;
filtered_fun (FPair f n) = f;

shows_prec_filtered ::
  forall a. (Showa a) => Nat -> Filtered a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_filtered d ff = shows_prec Zero_nat (filtered_fun ff);

shows_list_filtered ::
  forall a. (Showa a) => [Filtered a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_filtered = shows_list_aux (shows_prec_filtered Zero_nat);

instance (Showa a) => Showa (Filtered a) where {
  shows_prec = shows_prec_filtered;
  shows_list = shows_list_filtered;
};

rec_filtered :: forall a b. (a -> Nat -> b) -> Filtered a -> b;
rec_filtered f (FPair x1 x2) = f x1 x2;

less_eq_filtered :: forall a. (Eq a, Ord a) => Filtered a -> Filtered a -> Bool;
less_eq_filtered =
  (\ x y ->
    rec_filtered
      (\ x_0 x_1 (FPair y_0 y_1) ->
        less x_0 y_0 || x_0 == y_0 && less_nat x_1 y_1)
      x y ||
      equal_filtered x y);

less_filtered :: forall a. (Eq a, Ord a) => Filtered a -> Filtered a -> Bool;
less_filtered =
  rec_filtered
    (\ x_0 x_1 (FPair y_0 y_1) ->
      less x_0 y_0 || x_0 == y_0 && less_nat x_1 y_1);

instance (Eq a, Ord a) => Ord (Filtered a) where {
  less_eq = less_eq_filtered;
  less = less_filtered;
};

instance (Eq a, Order a) => Preorder (Filtered a) where {
};

instance (Eq a, Order a) => Order (Filtered a) where {
};

instance (Eq a, Linorder a) => Linorder (Filtered a) where {
};

instance (Eq a, Key a) => Key (Filtered a) where {
};

data L_poly a b = LPoly b [(a, b)];

cEnum_l_poly ::
  forall a b.
    Maybe ([L_poly a b],
            ((L_poly a b -> Bool) -> Bool, (L_poly a b -> Bool) -> Bool));
cEnum_l_poly = Nothing;

instance Cenum (L_poly a b) where {
  cEnum = cEnum_l_poly;
};

data Location = H | A | Ba | Ra;

equal_location :: Location -> Location -> Bool;
equal_location Ba Ra = False;
equal_location Ra Ba = False;
equal_location A Ra = False;
equal_location Ra A = False;
equal_location A Ba = False;
equal_location Ba A = False;
equal_location H Ra = False;
equal_location Ra H = False;
equal_location H Ba = False;
equal_location Ba H = False;
equal_location H A = False;
equal_location A H = False;
equal_location Ra Ra = True;
equal_location Ba Ba = True;
equal_location A A = True;
equal_location H H = True;

instance Eq Location where {
  a == b = equal_location a b;
};

ceq_location :: Maybe (Location -> Location -> Bool);
ceq_location = Just equal_location;

instance Ceq Location where {
  ceq = ceq_location;
};

set_impl_location :: Phantom Location Set_impla;
set_impl_location = Phantom Set_DList;

instance Set_impl Location where {
  set_impl = set_impl_location;
};

rec_location :: forall a. a -> a -> a -> a -> Location -> a;
rec_location f1 f2 f3 f4 H = f1;
rec_location f1 f2 f3 f4 A = f2;
rec_location f1 f2 f3 f4 Ba = f3;
rec_location f1 f2 f3 f4 Ra = f4;

corder_location ::
  Maybe (Location -> Location -> Bool, Location -> Location -> Bool);
corder_location =
  Just ((\ x y ->
          rec_location
            (\ a ->
              (case a of {
                H -> False;
                A -> True;
                Ba -> True;
                Ra -> True;
              }))
            (\ a ->
              (case a of {
                H -> False;
                A -> False;
                Ba -> True;
                Ra -> True;
              }))
            (\ a ->
              (case a of {
                H -> False;
                A -> False;
                Ba -> False;
                Ra -> True;
              }))
            (\ a ->
              (case a of {
                H -> False;
                A -> False;
                Ba -> False;
                Ra -> False;
              }))
            x y ||
            equal_location x y),
         rec_location
           (\ a ->
             (case a of {
               H -> False;
               A -> True;
               Ba -> True;
               Ra -> True;
             }))
           (\ a ->
             (case a of {
               H -> False;
               A -> False;
               Ba -> True;
               Ra -> True;
             }))
           (\ a ->
             (case a of {
               H -> False;
               A -> False;
               Ba -> False;
               Ra -> True;
             }))
           (\ a ->
             (case a of {
               H -> False;
               A -> False;
               Ba -> False;
               Ra -> False;
             })));

instance Corder Location where {
  corder = corder_location;
};

data Scg a b = Null | Scg a a [(b, b)] [(b, b)];

equal_scg :: forall a b. (Eq a, Eq b) => Scg a b -> Scg a b -> Bool;
equal_scg Null (Scg x21 x22 x23 x24) = False;
equal_scg (Scg x21 x22 x23 x24) Null = False;
equal_scg (Scg x21 x22 x23 x24) (Scg y21 y22 y23 y24) =
  x21 == y21 && x22 == y22 && x23 == y23 && x24 == y24;
equal_scg Null Null = True;

instance (Eq a, Eq b) => Eq (Scg a b) where {
  a == b = equal_scg a b;
};

rec_scg ::
  forall a b c. a -> (b -> b -> [(c, c)] -> [(c, c)] -> a) -> Scg b c -> a;
rec_scg f1 f2 Null = f1;
rec_scg f1 f2 (Scg x21 x22 x23 x24) = f2 x21 x22 x23 x24;

less_eq_scg ::
  forall a b. (Eq a, Ord a, Eq b, Order b) => Scg a b -> Scg a b -> Bool;
less_eq_scg =
  (\ x y ->
    rec_scg (\ a -> (case a of {
                      Null -> False;
                      Scg _ _ _ _ -> True;
                    }))
      (\ x_0 x_1 x_2 x_3 a ->
        (case a of {
          Null -> False;
          Scg y_0 y_1 y_2 y_3 ->
            less x_0 y_0 ||
              x_0 == y_0 &&
                (less x_1 y_1 ||
                  x_1 == y_1 &&
                    (less_list x_2 y_2 || x_2 == y_2 && less_list x_3 y_3));
        }))
      x y ||
      equal_scg x y);

less_scg ::
  forall a b. (Eq a, Ord a, Eq b, Order b) => Scg a b -> Scg a b -> Bool;
less_scg =
  rec_scg (\ a -> (case a of {
                    Null -> False;
                    Scg _ _ _ _ -> True;
                  }))
    (\ x_0 x_1 x_2 x_3 a ->
      (case a of {
        Null -> False;
        Scg y_0 y_1 y_2 y_3 ->
          less x_0 y_0 ||
            x_0 == y_0 &&
              (less x_1 y_1 ||
                x_1 == y_1 &&
                  (less_list x_2 y_2 || x_2 == y_2 && less_list x_3 y_3));
      }));

instance (Eq a, Ord a, Eq b, Order b) => Ord (Scg a b) where {
  less_eq = less_eq_scg;
  less = less_scg;
};

instance (Eq a, Order a, Eq b, Order b) => Preorder (Scg a b) where {
};

instance (Eq a, Order a, Eq b, Order b) => Order (Scg a b) where {
};

instance (Eq a, Linorder a, Eq b, Linorder b) => Linorder (Scg a b) where {
};

data Arctic_delta a = MinInfty_delta | Num_arc_delta a;

equal_arctic_delta ::
  forall a. (Eq a) => Arctic_delta a -> Arctic_delta a -> Bool;
equal_arctic_delta MinInfty_delta (Num_arc_delta a) = False;
equal_arctic_delta (Num_arc_delta a) MinInfty_delta = False;
equal_arctic_delta (Num_arc_delta aa) (Num_arc_delta a) = aa == a;
equal_arctic_delta MinInfty_delta MinInfty_delta = True;

instance (Eq a) => Eq (Arctic_delta a) where {
  a == b = equal_arctic_delta a b;
};

shows_arctic_delta ::
  forall a. (Showa a) => Arctic_delta a -> [Prelude.Char] -> [Prelude.Char];
shows_arctic_delta (Num_arc_delta i) = shows_prec Zero_nat i;
shows_arctic_delta MinInfty_delta = shows_string ['-', 'i', 'n', 'f'];

shows_prec_arctic_delta ::
  forall a.
    (Showa a) => Nat -> Arctic_delta a -> [Prelude.Char] -> [Prelude.Char];
shows_prec_arctic_delta d ari = shows_arctic_delta ari;

shows_list_arctic_delta ::
  forall a. (Showa a) => [Arctic_delta a] -> [Prelude.Char] -> [Prelude.Char];
shows_list_arctic_delta = shows_list_aux (shows_prec_arctic_delta Zero_nat);

instance (Showa a) => Showa (Arctic_delta a) where {
  shows_prec = shows_prec_arctic_delta;
  shows_list = shows_list_arctic_delta;
};

one_arctic_delta :: forall a. (Linordered_field a) => Arctic_delta a;
one_arctic_delta = Num_arc_delta zeroa;

instance (Linordered_field a) => One (Arctic_delta a) where {
  onea = one_arctic_delta;
};

plus_arctic_delta ::
  forall a.
    (Linordered_field a) => Arctic_delta a -> Arctic_delta a -> Arctic_delta a;
plus_arctic_delta MinInfty_delta y = y;
plus_arctic_delta (Num_arc_delta v) MinInfty_delta = Num_arc_delta v;
plus_arctic_delta (Num_arc_delta x) (Num_arc_delta y) = Num_arc_delta (max x y);

instance (Linordered_field a) => Plus (Arctic_delta a) where {
  plus = plus_arctic_delta;
};

zero_arctic_delta :: forall a. (Linordered_field a) => Arctic_delta a;
zero_arctic_delta = MinInfty_delta;

instance (Linordered_field a) => Zero (Arctic_delta a) where {
  zeroa = zero_arctic_delta;
};

instance (Linordered_field a) => Semigroup_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Numeral (Arctic_delta a) where {
};

times_arctic_delta ::
  forall a.
    (Linordered_field a) => Arctic_delta a -> Arctic_delta a -> Arctic_delta a;
times_arctic_delta MinInfty_delta y = MinInfty_delta;
times_arctic_delta (Num_arc_delta v) MinInfty_delta = MinInfty_delta;
times_arctic_delta (Num_arc_delta x) (Num_arc_delta y) =
  Num_arc_delta (plus x y);

instance (Linordered_field a) => Times (Arctic_delta a) where {
  times = times_arctic_delta;
};

instance (Linordered_field a) => Power (Arctic_delta a) where {
};

less_eq_arctic_delta ::
  forall a. (Ord a) => Arctic_delta a -> Arctic_delta a -> Bool;
less_eq_arctic_delta MinInfty_delta x = True;
less_eq_arctic_delta (Num_arc_delta uu) MinInfty_delta = False;
less_eq_arctic_delta (Num_arc_delta y) (Num_arc_delta x) = less_eq y x;

less_arctic_delta ::
  forall a. (Ord a) => Arctic_delta a -> Arctic_delta a -> Bool;
less_arctic_delta MinInfty_delta x = True;
less_arctic_delta (Num_arc_delta uu) MinInfty_delta = False;
less_arctic_delta (Num_arc_delta y) (Num_arc_delta x) = less y x;

instance (Ord a) => Ord (Arctic_delta a) where {
  less_eq = less_eq_arctic_delta;
  less = less_arctic_delta;
};

instance (Linordered_field a) => Ab_semigroup_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Semigroup_mult (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring (Arctic_delta a) where {
};

instance (Linordered_field a) => Mult_zero (Arctic_delta a) where {
};

instance (Linordered_field a) => Monoid_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Comm_monoid_add (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_0 (Arctic_delta a) where {
};

instance (Linordered_field a) => Monoid_mult (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_numeral (Arctic_delta a) where {
};

instance (Linordered_field a) => Zero_neq_one (Arctic_delta a) where {
};

instance (Linordered_field a) => Semiring_1 (Arctic_delta a) where {
};

ceq_arctic_delta ::
  forall a. (Eq a) => Maybe (Arctic_delta a -> Arctic_delta a -> Bool);
ceq_arctic_delta = Just equal_arctic_delta;

instance (Eq a) => Ceq (Arctic_delta a) where {
  ceq = ceq_arctic_delta;
};

set_impl_arctic_delta :: forall a. Phantom (Arctic_delta a) Set_impla;
set_impl_arctic_delta = Phantom Set_RBT;

instance Set_impl (Arctic_delta a) where {
  set_impl = set_impl_arctic_delta;
};

cEnum_arctic_delta ::
  forall a.
    Maybe ([Arctic_delta a],
            ((Arctic_delta a -> Bool) -> Bool,
              (Arctic_delta a -> Bool) -> Bool));
cEnum_arctic_delta = Nothing;

instance Cenum (Arctic_delta a) where {
  cEnum = cEnum_arctic_delta;
};

rec_arctic_delta :: forall a b. a -> (b -> a) -> Arctic_delta b -> a;
rec_arctic_delta f1 f2 MinInfty_delta = f1;
rec_arctic_delta f1 f2 (Num_arc_delta a) = f2 a;

corder_arctic_delta ::
  forall a.
    (Eq a,
      Linorder a) => Maybe (Arctic_delta a -> Arctic_delta a -> Bool,
                             Arctic_delta a -> Arctic_delta a -> Bool);
corder_arctic_delta =
  Just ((\ x y ->
          rec_arctic_delta
            (\ a ->
              (case a of {
                MinInfty_delta -> False;
                Num_arc_delta _ -> True;
              }))
            (\ x_0 a ->
              (case a of {
                MinInfty_delta -> False;
                Num_arc_delta aa -> less x_0 aa;
              }))
            x y ||
            equal_arctic_delta x y),
         rec_arctic_delta
           (\ a ->
             (case a of {
               MinInfty_delta -> False;
               Num_arc_delta _ -> True;
             }))
           (\ x_0 a ->
             (case a of {
               MinInfty_delta -> False;
               Num_arc_delta aa -> less x_0 aa;
             })));

instance (Eq a, Linorder a) => Corder (Arctic_delta a) where {
  corder = corder_arctic_delta;
};

instance (Linordered_field a) => Non_strict_order (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_ab_semigroup (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_semiring_0 (Arctic_delta a) where {
};

instance (Linordered_field a) => Ordered_semiring_1 (Arctic_delta a) where {
};

data Cond_constraint a b = CC_cond Bool (Term a b, Term a b)
  | CC_rewr (Term a b) (Term a b)
  | CC_impl [Cond_constraint a b] (Cond_constraint a b)
  | CC_all b (Cond_constraint a b);

instance (Eq a, Eq b) => Eq (Cond_constraint a b) where {
  a == b = equal_cond_constraint a b;
};

equal_cond_constraint ::
  forall a b.
    (Eq a, Eq b) => Cond_constraint a b -> Cond_constraint a b -> Bool;
equal_cond_constraint (CC_impl x31 x32) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_impl x31 x32) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_all x41 x42) = False;
equal_cond_constraint (CC_all x41 x42) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_impl x31 x32) = False;
equal_cond_constraint (CC_impl x31 x32) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_cond x11 x12) (CC_rewr x21 x22) = False;
equal_cond_constraint (CC_rewr x21 x22) (CC_cond x11 x12) = False;
equal_cond_constraint (CC_all x41 x42) (CC_all y41 y42) =
  x41 == y41 && equal_cond_constraint x42 y42;
equal_cond_constraint (CC_impl x31 x32) (CC_impl y31 y32) =
  x31 == y31 && equal_cond_constraint x32 y32;
equal_cond_constraint (CC_rewr x21 x22) (CC_rewr y21 y22) =
  equal_term x21 y21 && equal_term x22 y22;
equal_cond_constraint (CC_cond x11 x12) (CC_cond y11 y12) =
  x11 == y11 && x12 == y12;

data Itself a = Type;

newtype Rbt b a = RBT (Rbta b a);

data Xml =
  XML [Prelude.Char] [([Prelude.Char], [Prelude.Char])] [Xml]
    (Maybe [Prelude.Char]);

data Xmldoc = XMLDOC [Prelude.Char] Xml;

data Order_tag = Lex | Mul;

data Mapping a b = Assoc_List_Mapping (Alist a b)
  | RBT_Mapping (Mapping_rbt a b) | Mapping (a -> Maybe b);

data Complexity_measure a b = Derivational_Complexity [(a, Nat)]
  | Runtime_Complexity [(a, Nat)] [(a, Nat)];

newtype Complexity_class = Comp_Poly Nat;

data Strategy a b = No_Strategy | Innermost | Innermost_Q [Term a b];

data Fp_strategy a b = Outermost | Context_Sensitive [((a, Nat), [Nat])]
  | Forbidden_Patterns [(Ctxt a b, (Term a b, Location))];

data Input a b =
  DP_input
    (Bool, ([(Term a b, Term a b)], (Strategy a b, [(Term a b, Term a b)])))
  | Inn_TRS_input
      (Strategy a b, ([(Term a b, Term a b)], Maybe [(Term a b, Term a b)]))
  | COMP_input ([(Term a b, Term a b)], [(Term a b, Term a b)])
  | EQ_input ([(Term a b, Term a b)], (Term a b, Term a b))
  | CPX_input
      (Strategy a b,
        ([(Term a b, Term a b)],
          (Maybe [(Term a b, Term a b)],
            (Complexity_measure a b, Complexity_class))))
  | FP_TRS_input (Fp_strategy a b, [(Term a b, Term a b)])
  | CTRS_input [((Term a b, Term a b), [(Term a b, Term a b)])]
  | Unknown_input [Prelude.Char];

data Tpoly a b = PVar a | PNum b | PSum [Tpoly a b] | PMult [Tpoly a b];

data Compare = LT | GT | EQ;

data Domain = Natural Nat | Integera | Arctic | Arctic_rat | Int_mat Nat Nat
  | Arctic_mat Nat | Arctic_rat_mat Nat | Rational Rat Nat | Rat_mat Nat Nat
  | Mini_Alg Real Nat | Mini_Alg_mat Nat Nat;

data Const_string_sound_proof a b =
  Const_string_sound_proof b [(a, a)] [(Term a b, Term a b)];

data Af_entry = Collapse Nat | AFList [Nat];

data Redtriple_impl a = Int_carrier [((a, Nat), (Int, [Int]))]
  | Int_nl_carrier [((a, Nat), [([(Nat, Nat)], Int)])]
  | Rat_carrier [((a, Nat), (Rat, [Rat]))]
  | Rat_nl_carrier Rat [((a, Nat), [([(Nat, Nat)], Rat)])]
  | Real_carrier [((a, Nat), (Real, [Real]))]
  | Real_nl_carrier Real [((a, Nat), [([(Nat, Nat)], Real)])]
  | Arctic_carrier [((a, Nat), (Arctic, [Arctic]))]
  | Arctic_rat_carrier [((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]))]
  | Int_mat_carrier Nat Nat [((a, Nat), ([[Int]], [[[Int]]]))]
  | Rat_mat_carrier Nat Nat [((a, Nat), ([[Rat]], [[[Rat]]]))]
  | Real_mat_carrier Nat Nat [((a, Nat), ([[Real]], [[[Real]]]))]
  | Arctic_mat_carrier Nat [((a, Nat), ([[Arctic]], [[[Arctic]]]))]
  | Arctic_rat_mat_carrier Nat
      [((a, Nat), ([[Arctic_delta Rat]], [[[Arctic_delta Rat]]]))]
  | RPO [((a, Nat), (Nat, Order_tag))] [((a, Nat), Af_entry)]
  | KBO ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) [((a, Nat), Af_entry)];

data Complex_constant_removal_prf a b =
  Complex_Constant_Removal_Proof (Term a b)
    [((Term a b, Term a b), (Term a b, Term a b))];

data List_order_type = MS_Ext | Max_Ext | Min_Ext | Dms_Ext;

data Root_redtriple_impl a =
  SCNP List_order_type [((a, Nat), [(Nat, Nat)])] (Redtriple_impl a);

data Cond_constraint_prf a b = Final
  | Delete_Condition (Cond_constraint a b) (Cond_constraint_prf a b)
  | Different_Constructor (Cond_constraint a b)
  | Same_Constructor (Cond_constraint a b) (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Variable_Equation b (Term a b) (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Funarg_Into_Var (Cond_constraint a b) Nat b (Cond_constraint a b)
      (Cond_constraint_prf a b)
  | Simplify_Condition (Cond_constraint a b) [(b, Term a b)]
      (Cond_constraint a b) (Cond_constraint_prf a b)
  | Induction (Cond_constraint a b) [Cond_constraint a b]
      [((Term a b, Term a b),
         ([(Term a b, [b])], (Cond_constraint a b, Cond_constraint_prf a b)))];

data Cond_red_pair_prf a b =
  Cond_Red_Pair_Prf a
    [(Cond_constraint a b, ([(Term a b, Term a b)], Cond_constraint_prf a b))]
    Nat Nat;

data ArithFun = Arg Nat | Const Nat | Sum [ArithFun] | Max [ArithFun]
  | Min [ArithFun] | Prod [ArithFun]
  | IfEqual ArithFun ArithFun ArithFun ArithFun;

data Sl_inter a = SL_Inter Nat [((a, Nat), ArithFun)];

data Sl_variant a b = Rootlab (Maybe (a, Nat)) | Finitelab (Sl_inter a)
  | QuasiFinitelab (Sl_inter a) b;

data Generic_assm_proof a b c d e f g h =
  SN_assm_proof
    (Bool,
      ([Term (Lab a b) c],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          [(Term (Lab a b) c, Term (Lab a b) c)])))
    d
  | Finite_assm_proof
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      e
  | SN_FP_assm_proof
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      f
  | Not_SN_assm_proof
      (Bool, ([Term (Lab a b) c], [(Term (Lab a b) c, Term (Lab a b) c)])) d
  | Infinite_assm_proof
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      e
  | Not_RelSN_assm_proof
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      f
  | Not_SN_FP_assm_proof
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      g
  | Unknown_assm_proof [Prelude.Char] h;

data Join_info a =
  Guided
    [(Term a [Prelude.Char],
       ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                 Term a [Prelude.Char]))],
         (Term a [Prelude.Char],
           [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                    Term a [Prelude.Char]))])))]
  | Join_NF | Join_BFS Nat;

newtype ProjL a = Projection [((a, Nat), Nat)];

data Tree_automaton a b = Tree_Automaton [a] [Ta_rule a b] [(a, a)];

data Ta_relation a = Decision_Proc | Id_Relation | Some_Relation [(a, a)];

data Boundstype = Roof | Match;

data Bounds_info a b =
  Bounds_Info Boundstype Nat [b] (Tree_automaton b (a, Nat)) (Ta_relation b);

data Trs_termination_proof a b c =
  DP_Trans Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
    (Dp_termination_proof a b c)
  | Rule_Removal (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | String_Reversal (Trs_termination_proof a b c)
  | Constant_String (Const_string_sound_proof (Lab a b) c)
      (Trs_termination_proof a b c)
  | Bounds (Bounds_info (Lab a b) c)
  | Uncurry
      (Lab a b,
        ([((Lab a b, Nat), [Lab a b])],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | Semlab (Sl_variant (Lab a b) c) [Term (Lab a b) c]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
  | R_is_Empty
  | Fcc [Ctxt (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c)
  | Split [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_termination_proof a b c)
      (Trs_termination_proof a b c)
  | Switch_Innermost (Join_info (Lab a b)) (Trs_termination_proof a b c)
  | Drop_Equality (Trs_termination_proof a b c)
  | Remove_Nonapplicable_Rules [(Term (Lab a b) c, Term (Lab a b) c)]
      (Trs_termination_proof a b c)
  | Permuting_AFS [((Lab a b, Nat), Af_entry)] (Trs_termination_proof a b c)
  | Assume_SN
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [Generic_assm_proof a b c (Trs_termination_proof a b c)
         (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
         (Unknown_proof a b c)];

data Fptrs_termination_proof a b c =
  Assume_FP_SN
    ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
      [(Term (Lab a b) c, Term (Lab a b) c)])
    [Generic_assm_proof a b c (Trs_termination_proof a b c)
       (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
       (Unknown_proof a b c)];

data Dp_termination_proof a b c = P_is_Empty
  | Subterm_Criterion_Proc (ProjL (Lab a b))
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Redpair_Proc
      (Sum (Root_redtriple_impl (Lab a b)) (Redtriple_impl (Lab a b)))
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Redpair_UR_Proc
      (Sum (Root_redtriple_impl (Lab a b)) (Redtriple_impl (Lab a b)))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Usable_Rules_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_termination_proof a b c)
  | Dep_Graph_Proc
      [(Maybe (Dp_termination_proof a b c),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
  | Mono_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Mono_Redpair_UR_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Size_Change_Subterm_Proc
      [((Term (Lab a b) c, Term (Lab a b) c), ([(Nat, Nat)], [(Nat, Nat)]))]
  | Size_Change_Redpair_Proc (Redtriple_impl (Lab a b))
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      [((Term (Lab a b) c, Term (Lab a b) c), ([(Nat, Nat)], [(Nat, Nat)]))]
  | Uncurry_Proc (Maybe Nat)
      (Lab a b,
        ([((Lab a b, Nat), [Lab a b])],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Fcc_Proc (Lab a b) [Ctxt (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Split_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
      (Dp_termination_proof a b c)
  | Semlab_Proc (Sl_variant (Lab a b) c) [(Term (Lab a b) c, Term (Lab a b) c)]
      [Term (Lab a b) c] [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_termination_proof a b c)
  | Switch_Innermost_Proc (Join_info (Lab a b)) (Dp_termination_proof a b c)
  | Rewriting_Proc (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Term (Lab a b) c, Term (Lab a b) c) (Term (Lab a b) c, Term (Lab a b) c)
      (Term (Lab a b) c, Term (Lab a b) c) (Term (Lab a b) c, Term (Lab a b) c)
      Pos (Dp_termination_proof a b c)
  | Instantiation_Proc (Term (Lab a b) c, Term (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Forward_Instantiation_Proc (Term (Lab a b) c, Term (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Dp_termination_proof a b c)
  | Narrowing_Proc (Term (Lab a b) c, Term (Lab a b) c) Pos
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Assume_Finite
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      [Generic_assm_proof a b c (Trs_termination_proof a b c)
         (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
         (Unknown_proof a b c)]
  | Unlab_Proc [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | Q_Reduction_Proc [Term (Lab a b) c] (Dp_termination_proof a b c)
  | Complex_Constant_Removal_Proc (Complex_constant_removal_prf (Lab a b) c)
      (Dp_termination_proof a b c)
  | General_Redpair_Proc (Redtriple_impl (Lab a b))
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Cond_red_pair_prf (Lab a b) c)
      [Dp_termination_proof a b c]
  | To_Trs_Proc (Trs_termination_proof a b c);

data Unknown_proof a b c =
  Assume_Unknown [Prelude.Char]
    [Generic_assm_proof a b c (Trs_termination_proof a b c)
       (Dp_termination_proof a b c) (Fptrs_termination_proof a b c) ()
       (Unknown_proof a b c)];

data Cr_proof a b c = SN_WCR (Join_info (Lab a b)) (Trs_termination_proof a b c)
  | Weakly_Orthogonal | Strongly_Closed Nat;

data Ring_ext a b = Ring_ext a (a -> a -> a) b;

newtype Sum_bot a b = Sumbot (Sum a b);

data Non_join_info a b c = Diff_NFs
  | Tcap_Non_Unif (Term a b -> Term a b -> b -> Term a b)
  | Tree_Aut_Intersect_Empty (Tree_automaton c a) (Ta_relation c)
      (Tree_automaton c a) (Ta_relation c)
  | Finite_Model_Gt (Sl_variant a b) | Reduction_Pair_Gt (Redtriple_impl a)
  | Usable_Rules_Reach_NJ (Non_join_info a b c)
  | Argument_Filter_NJ [((a, Nat), Af_entry)] (Non_join_info a b c)
  | Grounding [(b, Term a b)] (Non_join_info a b c);

data Ncr_proof a b c d = SN_NWCR (Trs_termination_proof a b c)
  | Non_Join (Term (Lab a b) c)
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))]
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), Term (Lab a b) c))]
      (Non_join_info (Lab a b) c d)
  | NCR_Disj_Subtrs [(Term (Lab a b) c, Term (Lab a b) c)] (Ncr_proof a b c d);

data Dp_loop_prf a b =
  DP_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), (Bool, Term a b)))]
    [(b, Term a b)] (Ctxt a b);

data Monoid_ext a b = Monoid_ext (a -> a -> a) a b;

data Trs_loop_prf a b =
  TRS_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), Term a b))]
    [(b, Term a b)] (Ctxt a b);

data Ta_ext a b c = Ta_ext (Set a) (Set (Ta_rule a b)) (Set (a, a)) c;

data Dependance = Ignore | Increase | Decrease | Wild;

data Pat_eqv_prf a b = Pat_Dom_Renaming [(b, Term a b)]
  | Pat_Irrelevant [(b, Term a b)] [(b, Term a b)]
  | Pat_Simplify [(b, Term a b)] [(b, Term a b)];

data Interpretation a = Int_linear_poly ((a, Nat), (Int, [Int]))
  | Rat_linear_poly ((a, Nat), (Rat, [Rat]))
  | Arctic_linear_poly ((a, Nat), (Arctic, [Arctic]))
  | Arctic_rat_linear_poly ((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]))
  | Real_linear_poly ((a, Nat), (Real, [Real]))
  | Int_matrix ((a, Nat), ([[Int]], [[[Int]]]))
  | Rat_matrix ((a, Nat), ([[Rat]], [[[Rat]]]))
  | Arctic_matrix ((a, Nat), ([[Arctic]], [[[Arctic]]]))
  | Arctic_rat_matrix ((a, Nat), ([[Arctic_delta Rat]], [[[Arctic_delta Rat]]]))
  | Real_matrix ((a, Nat), ([[Real]], [[[Real]]]))
  | Int_non_linear_poly ((a, Nat), [([(Nat, Nat)], Int)])
  | Rat_non_linear_poly ((a, Nat), [([(Nat, Nat)], Rat)])
  | Real_non_linear_poly ((a, Nat), [([(Nat, Nat)], Real)]);

data Pat_rule_pos = Pat_Base | Pat_Pump | Pat_Close;

data Pat_rule_prf a b = Pat_OrigRule (Term a b, Term a b) Bool
  | Pat_InitPump (Pat_rule_prf a b) [(b, Term a b)] [(b, Term a b)]
  | Pat_InitPumpCtxt (Pat_rule_prf a b) [(b, Term a b)] Pos b
  | Pat_Equiv (Pat_rule_prf a b) Bool (Pat_eqv_prf a b)
  | Pat_Narrow (Pat_rule_prf a b) (Pat_rule_prf a b) Pos
  | Pat_Inst (Pat_rule_prf a b) [(b, Term a b)] Pat_rule_pos
  | Pat_Rewr (Pat_rule_prf a b)
      (Term a b, [(Pos, ((Term a b, Term a b), Term a b))]) Pat_rule_pos b
  | Pat_Exp_Sigma (Pat_rule_prf a b) Nat;

data Non_loop_prf a b =
  Non_loop_prf (Pat_rule_prf a b) [(b, Term a b)] [(b, Term a b)] Nat Nat Pos;

data Cert_result = Certified [Prelude.Char] | Unsupported [Prelude.Char]
  | Error [Prelude.Char];

newtype Subst_incr a b = Abs_subst_incr
  (b -> Term a b, (Set b, Term a b -> [b]));

data Memory_ext a b c d =
  Memory_ext (() -> a) (a -> b -> Maybe c) (a -> (b, c) -> a) d;

data Rule_removal_nonterm_reltrs_prf a b =
  Rule_removal_nonterm_reltrs_prf (Maybe [(Term a b, Term a b)])
    (Maybe [(Term a b, Term a b)]);

newtype Dp_trans_nontermination_tt_prf a b c = DP_trans_nontermination_tt_prf
  [(Term (Lab a b) c, Term (Lab a b) c)];

data Const_string_complete_proof a b =
  Const_string_complete_proof [(a, a)] [(Term a b, Term a b)];

newtype Rule_removal_nonterm_trs_prf a b = Rule_removal_nonterm_trs_prf
  [(Term a b, Term a b)];

newtype Q_increase_nonterm_trs_prf a b = Q_increase_nonterm_trs_prf [Term a b];

newtype Instantiation_complete_proc_prf a b = Instantiation_complete_proc_prf
  [(Term a b, Term a b)];

data Rule_removal_nonterm_dp_prf a b =
  Rule_removal_nonterm_dp_prf (Maybe [(Term a b, Term a b)])
    (Maybe [(Term a b, Term a b)]);

newtype Q_increase_nonterm_dp_prf a b = Q_increase_nonterm_dp_prf [Term a b];

newtype Dp_q_reduction_nonterm_prf a b = DP_q_reduction_nonterm_prf [Term a b];

data Rewriting_complete_proc_prf a b =
  Rewriting_complete_proc_prf (Maybe [(Term a b, Term a b)])
    (Term a b, Term a b) (Term a b, Term a b) (Term a b, Term a b)
    (Term a b, Term a b) Pos;

data Narrowing_complete_proc_prf a b =
  Narrowing_complete_proc_prf (Term a b, Term a b) Pos [(Term a b, Term a b)];

data Fp_loop_prf a b =
  FP_loop_prf (Ctxt a b) [(b, Term a b)] (Term a b)
    [(Pos, ((Term a b, Term a b), Term a b))];

data Dp_proof_step a = OC1 ([a], [a]) Bool
  | OC2 ([a], [a]) ([a], [a]) ([a], [a]) [a] [a] [a]
  | OC2p ([a], [a]) ([a], [a]) ([a], [a]) [a] [a] [a]
  | OC3 ([a], [a]) ([a], [a]) ([a], [a]) [a] [a]
  | OC3p ([a], [a]) ([a], [a]) ([a], [a]) [a] [a]
  | OCDP1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a])
  | OCDP2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a])
  | WPEQ (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
  | Lift (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
  | DPOC1_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC1_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a] [a]
  | DPOC2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC3_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a]
  | DPOC3_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      ([a], [a]) [a] [a] [a]
  | DPDP1_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP1_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP2_1 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a] [a]
  | DPDP2_2 (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a]
      [a];

data Non_loop_srs_proof a = SE_OC ([a], [a]) [a] [a] [Dp_proof_step a]
  | SE_DP (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a]))) [a]
      [a] [Dp_proof_step a];

data Uncurry_nt_proof a b c =
  Uncurry_nt_proof
    (Lab a b,
      ([((Lab a b, Nat), [Lab a b])],
        ([(Term (Lab a b) c, Term (Lab a b) c)],
          [(Term (Lab a b) c, Term (Lab a b) c)])))
    [(Term (Lab a b) c, Term (Lab a b) c)];

data Rel_trs_loop_prf a b =
  Rel_trs_loop_prf (Term a b) [(Pos, ((Term a b, Term a b), (Bool, Term a b)))]
    [(b, Term a b)] (Ctxt a b);

data Reltrs_nontermination_proof a b c = Rel_Loop (Rel_trs_loop_prf (Lab a b) c)
  | Rel_TRS_String_Reversal (Reltrs_nontermination_proof a b c)
  | Rel_Not_Well_Formed
  | Rel_Rule_Removal (Rule_removal_nonterm_reltrs_prf (Lab a b) c)
      (Reltrs_nontermination_proof a b c)
  | Rel_R_Not_SN (Trs_nontermination_proof a b c)
  | Rel_TRS_Assume_Not_SN
      (Bool,
        ([Term (Lab a b) c],
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            [(Term (Lab a b) c, Term (Lab a b) c)])))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Trs_nontermination_proof a b c = TRS_Loop (Trs_loop_prf (Lab a b) c)
  | TRS_Not_Well_Formed
  | TRS_Rule_Removal (Rule_removal_nonterm_trs_prf (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_String_Reversal (Trs_nontermination_proof a b c)
  | TRS_Constant_String (Const_string_complete_proof (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_DP_Trans (Dp_trans_nontermination_tt_prf a b c)
      (Dp_nontermination_proof a b c)
  | TRS_Termination_Switch (Join_info (Lab a b))
      (Trs_nontermination_proof a b c)
  | TRS_Nonloop (Non_loop_prf (Lab a b) c)
  | TRS_Nonloop_SRS (Non_loop_srs_proof (Lab a b))
  | TRS_Q_Increase (Q_increase_nonterm_trs_prf (Lab a b) c)
      (Trs_nontermination_proof a b c)
  | TRS_Uncurry (Uncurry_nt_proof a b c) (Trs_nontermination_proof a b c)
  | TRS_Assume_Not_SN
      (Bool, ([Term (Lab a b) c], [(Term (Lab a b) c, Term (Lab a b) c)]))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Fp_nontermination_proof a b c = FPTRS_Loop (Fp_loop_prf (Lab a b) c)
  | FPTRS_Rule_Removal (Rule_removal_nonterm_trs_prf (Lab a b) c)
      (Fp_nontermination_proof a b c)
  | FPTRS_Assume_Not_SN
      ([(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))],
        [(Term (Lab a b) c, Term (Lab a b) c)])
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Dp_nontermination_proof a b c = DP_Loop (Dp_loop_prf (Lab a b) c)
  | DP_Nonloop (Non_loop_prf (Lab a b) c)
  | DP_Rule_Removal (Rule_removal_nonterm_dp_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Q_Increase (Q_increase_nonterm_dp_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Q_Reduction (Dp_q_reduction_nonterm_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Termination_Switch (Join_info (Lab a b)) (Dp_nontermination_proof a b c)
  | DP_Instantiation (Instantiation_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Rewriting (Rewriting_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Narrowing (Narrowing_complete_proc_prf (Lab a b) c)
      (Dp_nontermination_proof a b c)
  | DP_Assume_Infinite
      (Bool,
        (Bool,
          ([(Term (Lab a b) c, Term (Lab a b) c)],
            ([(Term (Lab a b) c, Term (Lab a b) c)],
              ([Term (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  [(Term (Lab a b) c, Term (Lab a b) c)]))))))
      [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
         (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
         (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Neg_unknown_proof a b c =
  Assume_NT_Unknown [Prelude.Char]
    [Generic_assm_proof a b c (Trs_nontermination_proof a b c)
       (Dp_nontermination_proof a b c) (Reltrs_nontermination_proof a b c)
       (Fp_nontermination_proof a b c) (Neg_unknown_proof a b c)];

data Quasi_reductive_proof a b c =
  Unravel
    [(((Term (Lab a b) c, Term (Lab a b) c),
        [(Term (Lab a b) c, Term (Lab a b) c)]),
       [(Term (Lab a b) c, Term (Lab a b) c)])]
    (Trs_termination_proof a b c);

data Completion_proof a b c =
  SN_WCR_Eq (Join_info (Lab a b)) (Trs_termination_proof a b c)
    [((Term (Lab a b) c, Term (Lab a b) c),
       [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                (Bool, Term (Lab a b) c)))])]
    (Maybe [((Term (Lab a b) c, Term (Lab a b) c),
              [(Pos, ((Term (Lab a b) c, Term (Lab a b) c),
                       (Bool, Term (Lab a b) c)))])]);

data Equational_disproof a b c =
  Completion_and_Normalization_Different [(Term (Lab a b) c, Term (Lab a b) c)]
    (Completion_proof a b c);

data Eq_proof a b = Refl (Term a b) | Sym (Eq_proof a b)
  | Trans (Eq_proof a b) (Eq_proof a b)
  | Assm (Term a b, Term a b) (b -> Term a b) | Cong a [Eq_proof a b];

data Equational_proof a b c = Equational_Proof_Tree (Eq_proof (Lab a b) c)
  | Completion_and_Normalization [(Term (Lab a b) c, Term (Lab a b) c)]
      (Completion_proof a b c)
  | Conversion
      [(Pos, ((Term (Lab a b) c, Term (Lab a b) c), (Bool, Term (Lab a b) c)))];

data Complexity_proof a b =
  Rule_Shift_Complexity (Redtriple_impl a) [(Term a b, Term a b)]
    (Complexity_proof a b)
  | RisEmpty_Complexity
  | Remove_Nonapplicable_Rules_Complexity [(Term a b, Term a b)]
      (Complexity_proof a b);

data Cert_problem a b c =
  TRS_Termination_Proof Bool (Strategy (Lab a b) c)
    [(Term (Lab a b) c, Term (Lab a b) c)]
    (Maybe [(Term (Lab a b) c, Term (Lab a b) c)]) (Trs_termination_proof a b c)
  | Complexity_Proof (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      (Maybe [(Term (Lab a b) c, Term (Lab a b) c)])
      (Complexity_measure (Lab a b) c) Complexity_class
      (Complexity_proof (Lab a b) c)
  | DP_Termination_Proof Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Dp_termination_proof a b c)
  | DP_Nontermination_Proof Bool Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      (Strategy (Lab a b) c) [(Term (Lab a b) c, Term (Lab a b) c)]
      (Dp_nontermination_proof a b c)
  | TRS_Nontermination_Proof Bool (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)] (Trs_nontermination_proof a b c)
  | Outermost_Termination_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Fptrs_termination_proof a b c)
  | Outermost_Nontermination_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Fp_nontermination_proof a b c)
  | CS_Termination_Proof [((Lab a b, Nat), [Nat])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fptrs_termination_proof a b c)
  | CS_Nontermination_Proof [((Lab a b, Nat), [Nat])]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fp_nontermination_proof a b c)
  | FP_Termination_Proof [(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fptrs_termination_proof a b c)
  | FP_Nontermination_Proof [(Ctxt (Lab a b) c, (Term (Lab a b) c, Location))]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Fp_nontermination_proof a b c)
  | Relative_TRS_Nontermination_Proof Bool (Strategy (Lab a b) c)
      [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Reltrs_nontermination_proof a b c)
  | TRS_Confluence_Proof Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      (Cr_proof a b c)
  | TRS_Non_Confluence_Proof Bool [(Term (Lab a b) c, Term (Lab a b) c)]
      (Ncr_proof a b c c)
  | Completion_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      [(Term (Lab a b) c, Term (Lab a b) c)] (Completion_proof a b c)
  | Equational_Proof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Term (Lab a b) c, Term (Lab a b) c) (Equational_proof a b c)
  | Equational_Disproof [(Term (Lab a b) c, Term (Lab a b) c)]
      (Term (Lab a b) c, Term (Lab a b) c) (Equational_disproof a b c)
  | Quasi_Reductive_Proof
      [((Term (Lab a b) c, Term (Lab a b) c),
         [(Term (Lab a b) c, Term (Lab a b) c)])]
      (Quasi_reductive_proof a b c)
  | Unknown_Proof [Prelude.Char] (Unknown_proof a b c)
  | Unknown_Disproof [Prelude.Char] (Neg_unknown_proof a b c);

newtype Tp b a = TP
  (Bool,
    ([Term b a],
      (Bool,
        ([(Term b a, Term b a)],
          ([(Term b a, Term b a)],
            Rbt (b, Nat) [(Bool, (Term b a, Term b a))])))));

data C_constraint a b =
  Conditional_C Bool (Term a b, Term a b) (Term a b, Term a b)
  | Unconditional_C Bool (Term a b, Term a b);

data Ta_rule_impl a b = TA_rule_impl b [a] a (Rbt a ());

newtype Dpp b a = DPP
  (Bool,
    (Bool,
      ([(Term b a, Term b a)],
        ([(Term b a, Term b a)],
          ([Term b a],
            (Bool,
              (Bool,
                ([(Term b a, Term b a)],
                  ([(Term b a, Term b a)],
                    (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                      (Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
                        Bool)))))))))));

data Ta_impl_ext a b c =
  Ta_impl_ext (Rbt a ()) (Rbt (b, Nat) [Ta_rule_impl a b]) [a] (Rbt a ())
    [(a, a)] (a -> Rbt a ()) (a -> Rbt a ()) c;

data Condition_type = Bound | Strict | Non_Strict;

data Redtriple_ext a b c =
  Redtriple_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Nat -> Bool)
    ([(Term a b, Term a b)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ([Prelude.Char] -> [Prelude.Char])
    (Complexity_measure a b ->
      Sum ([Prelude.Char] -> [Prelude.Char]) Complexity_class)
    c;

data Sl_ops_ext a b c d e =
  Sl_ops_ext (a -> [b] -> c) (a -> Nat -> c -> Bool) (a -> [b] -> b) [b] b
    ([(Term a d, Term a d)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    (a -> [b] -> c) (a -> Nat -> c -> Bool) (c -> [c]) (a -> Nat -> [c]) e;

data Slm_ops_ext a b c d =
  Slm_ops_ext (a -> [b] -> c) (a -> [b] -> b) [b] b (a -> [b] -> c) d;

data Tp_ops_ext a b c d =
  Tp_ops_ext
    (a -> (Bool,
            (Set (Term b c),
              (Set (Term b c, Term b c), Set (Term b c, Term b c)))))
    (a -> [Term b c]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)]) (a -> Bool)
    (a -> Term b c -> Bool) (a -> Bool)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (Bool ->
      [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> Bool) d;

data Partial_object_ext a b = Partial_object_ext (Set a) b;

data Dpp_ops_ext a b c d =
  Dpp_ops_ext
    (a -> (Bool,
            (Bool,
              (Set (Term b c, Term b c),
                (Set (Term b c, Term b c),
                  (Set (Term b c),
                    (Set (Term b c, Term b c), Set (Term b c, Term b c))))))))
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> [Term b c])
    (a -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)])
    (a -> [(Term b c, Term b c)]) (a -> Bool) (a -> Bool) (a -> Bool)
    (a -> Term b c -> Bool) (a -> Bool)
    (a -> (b, Nat) -> [(Term b c, Term b c)])
    (a -> (b, Nat) -> [(Term b c, Term b c)]) (a -> [(Term b c, Term b c)] -> a)
    (a -> (Term b c, Term b c) -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (a -> [(Term b c, Term b c)] ->
            ([(Term b c, Term b c)], [(Term b c, Term b c)]))
    (Bool ->
      Bool ->
        [(Term b c, Term b c)] ->
          [(Term b c, Term b c)] ->
            [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a)
    (a -> Bool) (a -> Bool) (a -> Bool) d;

data Root_redtriple_ext a b c =
  Root_redtriple_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Nat -> Bool) ((a, Nat) -> Nat -> Bool)
    ([Prelude.Char] -> [Prelude.Char]) c;

data Non_inf_order_ext a b c =
  Non_inf_order_ext (Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    (C_constraint a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ())
    ((a, Nat) -> Nat -> Dependance) ([Prelude.Char] -> [Prelude.Char]) c;

data Ordered_semiring_ext a b =
  Ordered_semiring_ext (a -> a -> Bool) (a -> a -> Bool) (a -> a -> a) b;

data Lpoly_order_semiring_ext a b =
  Lpoly_order_semiring_ext Bool a (a -> Bool) (a -> Bool) (a -> Nat)
    (a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat) [Prelude.Char] b;

suc :: Nat -> Nat;
suc n = plus_nat n (Nat_of_num One);

dlist_ex :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Bool;
dlist_ex x xc = any x (list_of_dlist xc);

rBT_Impl_rbt_ex :: forall a b. (a -> b -> Bool) -> Rbta a b -> Bool;
rBT_Impl_rbt_ex p (Branch c l k v r) =
  p k v || (rBT_Impl_rbt_ex p l || rBT_Impl_rbt_ex p r);
rBT_Impl_rbt_ex p Emptya = False;

ex :: forall a b. (Corder a) => (a -> b -> Bool) -> Mapping_rbt a b -> Bool;
ex x xc = rBT_Impl_rbt_ex x (impl_ofb xc);

bex :: forall a. (Ceq a, Corder a) => Set a -> (a -> Bool) -> Bool;
bex (RBT_set rbt) p =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing -> error "Bex RBT_set: corder = None" (\ _ -> bex (RBT_set rbt) p);
    Just _ -> ex (\ k _ -> p k) rbt;
  });
bex (DList_set dxs) p =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing -> error "Bex DList_set: ceq = None" (\ _ -> bex (DList_set dxs) p);
    Just _ -> dlist_ex p dxs;
  });
bex (Set_Monad xs) p = any p xs;

tag :: Xml -> [Prelude.Char];
tag (XML name uu uv uw) = name;

nth :: forall a. [a] -> Nat -> a;
nth (x : xs) n =
  (if equal_nat n Zero_nat then x else nth xs (minus_nat n (Nat_of_num One)));

upt :: Nat -> Nat -> [Nat];
upt i j =
  (if less_nat i j then i : upt (plus_nat i (Nat_of_num One)) j else []);

rBT_Impl_rbt_all :: forall a b. (a -> b -> Bool) -> Rbta a b -> Bool;
rBT_Impl_rbt_all p (Branch c l k v r) =
  p k v && rBT_Impl_rbt_all p l && rBT_Impl_rbt_all p r;
rBT_Impl_rbt_all p Emptya = True;

alla :: forall a b. (Corder a) => (a -> b -> Bool) -> Mapping_rbt a b -> Bool;
alla x xc = rBT_Impl_rbt_all x (impl_ofb xc);

ball :: forall a. (Ceq a, Corder a) => Set a -> (a -> Bool) -> Bool;
ball (RBT_set rbt) p =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "Ball RBT_set: corder = None" (\ _ -> ball (RBT_set rbt) p);
    Just _ -> alla (\ k _ -> p k) rbt;
  });
ball (DList_set dxs) p =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "Ball DList_set: ceq = None" (\ _ -> ball (DList_set dxs) p);
    Just _ -> dlist_all p dxs;
  });
ball (Set_Monad xs) p = all p xs;

returna :: forall a b. a -> Sum_bot b a;
returna x = Sumbot (Inr x);

errora :: forall a b. a -> Sum_bot a b;
errora x = Sumbot (Inl x);

int_of_digit :: Prelude.Char -> Sum_bot [Prelude.Char] Int;
int_of_digit x =
  (if x == '0' then returna Zero_int
    else (if x == '1' then returna (Pos One)
           else (if x == '2' then returna (Pos (Bit0 One))
                  else (if x == '3' then returna (Pos (Bit1 One))
                         else (if x == '4' then returna (Pos (Bit0 (Bit0 One)))
                                else (if x == '5'
                                       then returna (Pos (Bit1 (Bit0 One)))
                                       else (if x == '6'
      then returna (Pos (Bit0 (Bit1 One)))
      else (if x == '7' then returna (Pos (Bit1 (Bit1 One)))
             else (if x == '8' then returna (Pos (Bit0 (Bit0 (Bit0 One))))
                    else (if x == '9'
                           then returna (Pos (Bit1 (Bit0 (Bit0 One))))
                           else errora
                                  [x, ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                                    'a', ' ', 'd', 'i', 'g', 'i',
                                    't']))))))))));

binda :: forall a b c. Sum_bot a b -> (b -> Sum_bot a c) -> Sum_bot a c;
binda (Sumbot a) f = (case a of {
                       Inl b -> Sumbot (Inl b);
                       Inr aa -> f aa;
                     });

int_of_string_aux :: Int -> [Prelude.Char] -> Sum_bot [Prelude.Char] Int;
int_of_string_aux n [] = returna n;
int_of_string_aux n (d : s) =
  binda (int_of_digit d)
    (\ m ->
      int_of_string_aux
        (plus_int (times_int (Pos (Bit0 (Bit1 (Bit0 One)))) n) m) s);

tl :: forall a. [a] -> [a];
tl [] = [];
tl (x21 : x22) = x22;

take :: forall a. Nat -> [a] -> [a];
take n [] = [];
take n (x : xs) =
  (if equal_nat n Zero_nat then []
    else x : take (minus_nat n (Nat_of_num One)) xs);

int_of_string :: [Prelude.Char] -> Sum_bot [Prelude.Char] Int;
int_of_string s =
  (if null s
    then errora
           ['c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'o', 'n', 'v', 'e', 'r',
             't', ' ', 'e', 'm', 'p', 't', 'y', ' ', 's', 't', 'r', 'i', 'n',
             'g', ' ', 'i', 'n', 't', 'o', ' ', 'n', 'u', 'm', 'b', 'e', 'r']
    else (if take (Nat_of_num One) s == ['-']
           then binda (int_of_string_aux Zero_int (tl s))
                  (\ i -> returna (minus_int Zero_int i))
           else int_of_string_aux Zero_int s));

shows_attr ::
  ([Prelude.Char], [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_attr av =
  shows_prec_list Zero_nat (fst av) .
    shows_string ['='] . shows_string ('\"' : snd av ++ ['\"']);

shows_attrs ::
  [([Prelude.Char], [Prelude.Char])] -> [Prelude.Char] -> [Prelude.Char];
shows_attrs asa = shows_map (\ a -> shows_string [' '] . shows_attr a) asa;

replicate :: forall a. Nat -> a -> [a];
replicate n x =
  (if equal_nat n Zero_nat then []
    else x : replicate (minus_nat n (Nat_of_num One)) x);

shows_XML_indent ::
  [Prelude.Char] -> Nat -> Xml -> [Prelude.Char] -> [Prelude.Char];
shows_XML_indent ind i (XML n a c t) =
  shows_string ind .
    shows_string ['<'] .
      shows_prec_list Zero_nat n .
        shows_attrs a .
          (if null c && is_none t then shows_string ['/', '>']
            else shows_string ['>'] .
                   (if not (null c)
                     then shows_map
                            (shows_XML_indent (ind ++ replicate i ' ') i) c .
                            shows_string ind
                     else id) .
                     (if is_none t then id else shows_string (the t)) .
                       shows_string ['<', '/'] .
                         shows_prec_list Zero_nat n . shows_string ['>']);

shows_prec_xml :: Nat -> Xml -> [Prelude.Char] -> [Prelude.Char];
shows_prec_xml d xml = shows_XML_indent ['\n'] (Nat_of_num (Bit0 One)) xml;

text :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
text tag (XML n atts cs t) =
  (if n == tag && null atts && null cs && not (is_none t) && not (null (the t))
    then returna (the t)
    else errora
           (concat
             [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't',
                'r', 'a', 'c', 't', ' ', 't', 'e', 'x', 't', ' ', 'f', 'o', 'r',
                ' '],
               tag, [' ', 'f', 'r', 'o', 'm', ' '], ['\n'],
               shows_prec_xml Zero_nat (XML n atts cs t) []]));

int :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Int;
int tag x = binda (text tag x) int_of_string;

nata :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Nat;
nata tag x =
  binda (text tag x)
    (\ txt -> binda (int_of_string txt) (\ i -> returna (nat i)));

options ::
  forall a.
    [([Prelude.Char], Xml -> Sum_bot [Prelude.Char] a)] ->
      Xml -> Sum_bot [Prelude.Char] a;
options ps x =
  (case map_of ps (tag x) of {
    Nothing ->
      errora
        (concat
          [['e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'o', 'n', 'e', ' ',
             'o', 'f', ':', ' '],
            concatMap (\ p -> fst p ++ [' ']) ps, ['\n'],
            ['b', 'u', 't', ' ', 'f', 'o', 'u', 'n', 'd'], ['\n'],
            shows_prec_xml Zero_nat x []]);
    Just p -> p x;
  });

change ::
  forall a b.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      (a -> b) -> Xml -> Sum_bot [Prelude.Char] b;
change p f x = binda (p x) (\ a -> returna (f a));

list2elements :: forall a. [a] -> Maybe (a, a);
list2elements [x, y] = Just (x, y);
list2elements [] = Nothing;
list2elements [v] = Nothing;
list2elements (v : vb : vd : ve) = Nothing;

fail :: forall a. [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] a;
fail tag xml =
  errora
    (concat
      [['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 't', 'r', 'a', 'n',
         's', 'f', 'o', 'r', 'm', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
         'o', 'w', 'i', 'n', 'g', ' ', 'x', 'm', 'l', ' ', 'e', 'l', 'e', 'm',
         'e', 'n', 't', ' ', '(', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' '],
        tag, [')'], ['\n'], shows_prec_xml Zero_nat xml []]);

pair ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> b -> c) -> Xml -> Sum_bot [Prelude.Char] c;
pair tag p1 p2 f xml =
  let {
    (XML name atts cs text) = xml;
  } in (if name == tag && null atts && is_none text
         then (case list2elements cs of {
                Nothing -> fail tag xml;
                Just (cs1, cs2) ->
                  binda (p1 cs1)
                    (\ a -> binda (p2 cs2) (\ b -> returna (f a b)));
              })
         else fail tag xml);

rat :: Xml -> Sum_bot [Prelude.Char] Rat;
rat = options
        [(['i', 'n', 't', 'e', 'g', 'e', 'r'],
           change (int ['i', 'n', 't', 'e', 'g', 'e', 'r']) of_int),
          (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l'],
            pair ['r', 'a', 't', 'i', 'o', 'n', 'a', 'l']
              (int ['n', 'u', 'm', 'e', 'r', 'a', 't', 'o', 'r'])
              (int ['d', 'e', 'n', 'o', 'm', 'i', 'n', 'a', 't', 'o', 'r'])
              (\ x y -> divide_rat (of_int x) (of_int y)))];

drop :: forall a. Nat -> [a] -> [a];
drop n [] = [];
drop n (x : xs) =
  (if equal_nat n Zero_nat then x : xs
    else drop (minus_nat n (Nat_of_num One)) xs);

find :: forall a. (a -> Bool) -> [a] -> Maybe a;
find uu [] = Nothing;
find p (x : xs) = (if p x then Just x else find p xs);

last :: forall a. [a] -> a;
last (x : xs) = (if null xs then x else last xs);

empty :: forall a b. (Linorder a) => Rbt a b;
empty = RBT Emptya;

foldd :: forall a b. (Ceq a) => (a -> b -> b) -> Set_dlist a -> b -> b;
foldd x xc = fold x (list_of_dlist xc);

foldb :: forall a b c. (a -> b -> c -> c) -> Rbta a b -> c -> c;
foldb f (Branch c lt k v rt) x = foldb f rt (f k v (foldb f lt x));
foldb f Emptya x = x;

foldc :: forall a b. (Corder a) => (a -> b -> b) -> Mapping_rbt a () -> b -> b;
foldc x xc = foldb (\ a _ -> x a) (impl_ofb xc);

image ::
  forall a b.
    (Ceq a, Corder a, Ceq b, Corder b,
      Set_impl b) => (a -> b) -> Set a -> Set b;
image h (RBT_set rbt) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "image RBT_set: corder = None" (\ _ -> image h (RBT_set rbt));
    Just _ -> foldc (inserta . h) rbt bot_set;
  });
image g (DList_set dxs) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "image DList_set: ceq = None" (\ _ -> image g (DList_set dxs));
    Just _ -> foldd (inserta . g) dxs bot_set;
  });
image f (Complement (Complement b)) = image f b;
image f (Collect_set a) =
  error "image Collect_set" (\ _ -> image f (Collect_set a));
image f (Set_Monad xs) = Set_Monad (map f xs);

args :: forall a b. Term a b -> [Term a b];
args (Var x) = [];
args (Fun f ts) = ts;

folda :: forall a b c. (a -> b) -> (c -> [b] -> b) -> Term c a -> b;
folda var fun (Var x) = var x;
folda var fun (Fun f ts) = fun f (map (folda var fun) ts);

root :: forall a b. Term a b -> Maybe (a, Nat);
root (Var x) = Nothing;
root (Fun f ts) = Just (f, size_list ts);

flip :: forall a b c. (a -> b -> c) -> b -> a -> c;
flip f = (\ x y -> f y x);

bool_of_string :: [Prelude.Char] -> Sum_bot [Prelude.Char] Bool;
bool_of_string s =
  (if s == ['t', 'r', 'u', 'e'] then returna True
    else (if s == ['f', 'a', 'l', 's', 'e'] then returna False
           else errora
                  (['c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'o', 'n', 'v', 'e',
                     'r', 't', ' '] ++
                    s ++ [' ', 'i', 'n', 't', 'o', ' ', 'B', 'o', 'o', 'l', 'e',
                           'a', 'n'])));

bool :: [Prelude.Char] -> Xml -> Sum_bot [Prelude.Char] Bool;
bool tag node = binda (text tag node) bool_of_string;

leaf :: forall a. [Prelude.Char] -> a -> Xml -> Sum_bot [Prelude.Char] a;
leaf tag x (XML name atts cs text) =
  (if name == tag && null atts && null cs && is_none text then returna x
    else fail tag (XML name atts cs text));

map_sum_bot :: forall a b c. (a -> Sum_bot b c) -> [a] -> Sum_bot b [c];
map_sum_bot f [] = returna [];
map_sum_bot f (x : xs) =
  binda (f x) (\ y -> binda (map_sum_bot f xs) (\ ys -> returna (y : ys)));

many ::
  forall a b.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        ([a] -> b) -> Xml -> Sum_bot [Prelude.Char] b;
many tag p f (XML name atts cs text) =
  (if name == tag && null atts && is_none text
    then binda (map_sum_bot p cs) (returna . f)
    else fail tag (XML name atts cs text));

foldr :: forall a b. (a -> b -> b) -> [a] -> b -> b;
foldr f [] = id;
foldr f (x : xs) = f x . foldr f xs;

funpow :: forall a. Nat -> (a -> a) -> a -> a;
funpow n f =
  (if equal_nat n Zero_nat then id
    else f . funpow (minus_nat n (Nat_of_num One)) f);

rbt_dela :: forall a b. (Ord a) => a -> Rbta a b -> Rbta a b;
rbt_dela x Emptya = Emptya;
rbt_dela x (Branch c a y s b) =
  (if less x y then rbt_del_from_lefta x a y s b
    else (if less y x then rbt_del_from_righta x a y s b else combine a b));

rbt_del_from_lefta ::
  forall a b. (Ord a) => a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_lefta x (Branch B lt z v rt) y s b =
  balance_left (rbt_dela x (Branch B lt z v rt)) y s b;
rbt_del_from_lefta x Emptya y s b = Branch R (rbt_dela x Emptya) y s b;
rbt_del_from_lefta x (Branch R va vb vc vd) y s b =
  Branch R (rbt_dela x (Branch R va vb vc vd)) y s b;

rbt_del_from_righta ::
  forall a b. (Ord a) => a -> Rbta a b -> a -> b -> Rbta a b -> Rbta a b;
rbt_del_from_righta x a y s (Branch B lt z v rt) =
  balance_right a y s (rbt_dela x (Branch B lt z v rt));
rbt_del_from_righta x a y s Emptya = Branch R a y s (rbt_dela x Emptya);
rbt_del_from_righta x a y s (Branch R va vb vc vd) =
  Branch R a y s (rbt_dela x (Branch R va vb vc vd));

rbt_deletea :: forall a b. (Ord a) => a -> Rbta a b -> Rbta a b;
rbt_deletea k t = paint B (rbt_dela k t);

impl_of :: forall b a. (Linorder b) => Rbt b a -> Rbta b a;
impl_of (RBT x) = x;

delete :: forall a b. (Linorder a) => a -> Rbt a b -> Rbt a b;
delete xb xc = RBT (rbt_deletea xb (impl_of xc));

rbt_insa ::
  forall a b. (Ord a) => (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_insa f k v Emptya = Branch R Emptya k v Emptya;
rbt_insa f k v (Branch B l x y r) =
  (if less k x then balance (rbt_insa f k v l) x y r
    else (if less x k then balance l x y (rbt_insa f k v r)
           else Branch B l x (f k y v) r));
rbt_insa f k v (Branch R l x y r) =
  (if less k x then Branch R (rbt_insa f k v l) x y r
    else (if less x k then Branch R l x y (rbt_insa f k v r)
           else Branch R l x (f k y v) r));

rbt_insert_with_keya ::
  forall a b. (Ord a) => (a -> b -> b -> b) -> a -> b -> Rbta a b -> Rbta a b;
rbt_insert_with_keya f k v t = paint B (rbt_insa f k v t);

rbt_inserta :: forall a b. (Ord a) => a -> b -> Rbta a b -> Rbta a b;
rbt_inserta = rbt_insert_with_keya (\ _ _ nv -> nv);

insert :: forall a b. (Linorder a) => a -> b -> Rbt a b -> Rbt a b;
insert xc xd xe = RBT (rbt_inserta xc xd (impl_of xe));

rbt_lookupa :: forall a b. (Ord a) => Rbta a b -> a -> Maybe b;
rbt_lookupa Emptya k = Nothing;
rbt_lookupa (Branch uu l x y r) k =
  (if less k x then rbt_lookupa l k
    else (if less x k then rbt_lookupa r k else Just y));

lookup :: forall a b. (Linorder a) => Rbt a b -> a -> Maybe b;
lookup x = rbt_lookupa (impl_of x);

proja :: forall a b. Term a b -> Nat -> Term a b;
proja (Fun f ts) i = (if less_nat i (size_list ts) then nth ts i else Fun f ts);

sunion_with ::
  forall a b.
    (a -> a -> Bool) -> (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
sunion_with less f asa [] = asa;
sunion_with less f [] bs = bs;
sunion_with less f ((ka, va) : asa) ((k, v) : bs) =
  (if less k ka then (k, v) : sunion_with less f ((ka, va) : asa) bs
    else (if less ka k then (ka, va) : sunion_with less f asa ((k, v) : bs)
           else (ka, f ka va v) : sunion_with less f asa bs));

skip_red :: forall a b. Rbta a b -> Rbta a b;
skip_red (Branch R l k v r) = l;
skip_red Emptya = Emptya;
skip_red (Branch B va vb vc vd) = Branch B va vb vc vd;

skip_black :: forall a b. Rbta a b -> Rbta a b;
skip_black t =
  let {
    ta = skip_red t;
  } in (case ta of {
         Emptya -> ta;
         Branch R l _ _ _ -> ta;
         Branch B l _ _ _ -> l;
       });

compare_height ::
  forall a b. Rbta a b -> Rbta a b -> Rbta a b -> Rbta a b -> Compare;
compare_height sx s t tx =
  (case (skip_red sx, (skip_red s, (skip_red t, skip_red tx))) of {
    (Emptya, (Emptya, (_, Emptya))) -> EQ;
    (Emptya, (Emptya, (_, Branch _ _ _ _ _))) -> LT;
    (Emptya, (Branch _ sa _ _ _, (Emptya, b))) -> EQ;
    (Emptya, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Emptya))) -> EQ;
    (Emptya, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Branch _ txa _ _ _))) ->
      compare_height Emptya sa ta (skip_black txa);
    (Branch _ sxa _ _ _, (Emptya, (Emptya, Emptya))) -> GT;
    (Branch _ sxa _ _ _, (Emptya, (Emptya, Branch _ _ _ _ _))) -> LT;
    (Branch _ sxa _ _ _, (Emptya, (Branch _ _ _ _ _, Emptya))) -> EQ;
    (Branch _ sxa _ _ _, (Emptya, (Branch _ _ _ _ _, Branch _ _ _ _ _))) -> LT;
    (Branch _ sxa _ _ _, (Branch _ sa _ _ _, (Emptya, xf))) -> GT;
    (Branch _ sxa _ _ _, (Branch _ sa _ _ _, (Branch _ ta _ _ _, Emptya))) ->
      compare_height (skip_black sxa) sa ta Emptya;
    (Branch _ sxa _ _ _,
      (Branch _ sa _ _ _, (Branch _ ta _ _ _, Branch _ txa _ _ _)))
      -> compare_height (skip_black sxa) sa ta (skip_black txa);
  });

apfst :: forall a b c. (a -> b) -> (a, c) -> (b, c);
apfst f (x, y) = (f x, y);

rbtreeify_g :: forall a b. Nat -> [(a, b)] -> (Rbta a b, [(a, b)]);
rbtreeify_g n kvs =
  (if equal_nat n Zero_nat || equal_nat n (Nat_of_num One) then (Emptya, kvs)
    else let {
           (na, r) = divmod_nat n (Nat_of_num (Bit0 One));
         } in (if equal_nat r Zero_nat
                then let {
                       (t1, (k, v) : kvsa) = rbtreeify_g na kvs;
                     } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)
                else let {
                       (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                     } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)));

rbtreeify_f :: forall a b. Nat -> [(a, b)] -> (Rbta a b, [(a, b)]);
rbtreeify_f n kvs =
  (if equal_nat n Zero_nat then (Emptya, kvs)
    else (if equal_nat n (Nat_of_num One)
           then let {
                  ((k, v) : kvsa) = kvs;
                } in (Branch R Emptya k v Emptya, kvsa)
           else let {
                  (na, r) = divmod_nat n (Nat_of_num (Bit0 One));
                } in (if equal_nat r Zero_nat
                       then let {
                              (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                            } in apfst (Branch B t1 k v) (rbtreeify_g na kvsa)
                       else let {
                              (t1, (k, v) : kvsa) = rbtreeify_f na kvs;
                            } in apfst (Branch B t1 k v)
                                   (rbtreeify_f na kvsa))));

rbtreeify :: forall a b. [(a, b)] -> Rbta a b;
rbtreeify kvs =
  fst (rbtreeify_g (plus_nat (size_list kvs) (Nat_of_num One)) kvs);

gen_entries :: forall a b. [((a, b), Rbta a b)] -> Rbta a b -> [(a, b)];
gen_entries kvts (Branch c l k v r) = gen_entries (((k, v), r) : kvts) l;
gen_entries ((kv, t) : kvts) Emptya = kv : gen_entries kvts t;
gen_entries [] Emptya = [];

entries :: forall a b. Rbta a b -> [(a, b)];
entries = gen_entries [];

rbt_union_with_key ::
  forall a b.
    (a -> a -> Bool) -> (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_union_with_key less f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> foldb (rbt_insert_with_key less (\ k v w -> f k w v)) t1 t2;
    GT -> foldb (rbt_insert_with_key less f) t2 t1;
    EQ -> rbtreeify (sunion_with less f (entries t1) (entries t2));
  });

join ::
  forall a b.
    (Corder a) => (a -> b -> b -> b) ->
                    Mapping_rbt a b -> Mapping_rbt a b -> Mapping_rbt a b;
join xc xd xe =
  Mapping_RBTa
    (rbt_union_with_key (snd (the corder)) xc (impl_ofb xd) (impl_ofb xe));

union :: forall a. (Ceq a) => Set_dlist a -> Set_dlist a -> Set_dlist a;
union = foldd insertc;

inter_list ::
  forall a. (Corder a) => Mapping_rbt a () -> [a] -> Mapping_rbt a ();
inter_list xb xc =
  Mapping_RBTa
    (fold (\ k -> rbt_insert (snd (the corder)) k ())
      (filter
        (\ x -> not (is_none (rbt_lookup (snd (the corder)) (impl_ofb xb) x)))
        xc)
      Emptya);

filterc ::
  forall a b.
    (Corder a) => ((a, b) -> Bool) -> Mapping_rbt a b -> Mapping_rbt a b;
filterc xb xc = Mapping_RBTa (rbtreeify (filter xb (entries (impl_ofb xc))));

sinter_with ::
  forall a b.
    (a -> a -> Bool) -> (a -> b -> b -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
sinter_with less f uv [] = [];
sinter_with less f [] uu = [];
sinter_with less f ((ka, va) : asa) ((k, v) : bs) =
  (if less k ka then sinter_with less f ((ka, va) : asa) bs
    else (if less ka k then sinter_with less f asa ((k, v) : bs)
           else (ka, f ka va v) : sinter_with less f asa bs));

map_filter :: forall a b. (a -> Maybe b) -> [a] -> [b];
map_filter f [] = [];
map_filter f (x : xs) =
  (case f x of {
    Nothing -> map_filter f xs;
    Just y -> y : map_filter f xs;
  });

rbt_inter_with_key ::
  forall a b.
    (a -> a -> Bool) -> (a -> b -> b -> b) -> Rbta a b -> Rbta a b -> Rbta a b;
rbt_inter_with_key less f t1 t2 =
  (case compare_height t1 t1 t2 t2 of {
    LT -> rbtreeify
            (map_filter
              (\ (k, v) ->
                map_option (\ w -> (k, f k v w)) (rbt_lookup less t2 k))
              (entries t1));
    GT -> rbtreeify
            (map_filter
              (\ (k, v) ->
                map_option (\ w -> (k, f k w v)) (rbt_lookup less t1 k))
              (entries t2));
    EQ -> rbtreeify (sinter_with less f (entries t1) (entries t2));
  });

meet ::
  forall a b.
    (Corder a) => (a -> b -> b -> b) ->
                    Mapping_rbt a b -> Mapping_rbt a b -> Mapping_rbt a b;
meet xc xd xe =
  Mapping_RBTa
    (rbt_inter_with_key (snd (the corder)) xc (impl_ofb xd) (impl_ofb xe));

filterb :: forall a. (Ceq a) => (a -> Bool) -> Set_dlist a -> Set_dlist a;
filterb xb xc = Abs_dlist (filter xb (list_of_dlist xc));

inf_set :: forall a. (Ceq a, Corder a) => Set a -> Set a -> Set a;
inf_set (RBT_set rbt1) (Set_Monad xs) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "inter RBT_set Set_Monad: corder = None"
        (\ _ -> inf_set (RBT_set rbt1) (Set_Monad xs));
    Just _ -> RBT_set (inter_list rbt1 xs);
  });
inf_set (RBT_set rbt) (DList_set dxs) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "inter RBT_set DList_set: corder = None"
        (\ _ -> inf_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          error "inter RBT_set DList_set: ceq = None"
            (\ _ -> inf_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (inter_list rbt (list_of_dlist dxs));
      });
  });
inf_set (RBT_set rbt1) (RBT_set rbt2) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "inter RBT_set RBT_set: corder = None"
        (\ _ -> inf_set (RBT_set rbt1) (RBT_set rbt2));
    Just _ -> RBT_set (meet (\ _ _ -> id) rbt1 rbt2);
  });
inf_set (DList_set dxs1) (Set_Monad xs) =
  (case ceq of {
    Nothing ->
      error "inter DList_set Set_Monad: ceq = None"
        (\ _ -> inf_set (DList_set dxs1) (Set_Monad xs));
    Just eq -> DList_set (filterb (list_member eq xs) dxs1);
  });
inf_set (DList_set dxs1) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "inter DList_set DList_set: ceq = None"
        (\ _ -> inf_set (DList_set dxs1) (DList_set dxs2));
    Just _ -> DList_set (filterb (memberc dxs2) dxs1);
  });
inf_set (DList_set dxs) (RBT_set rbt) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "inter DList_set RBT_set: corder = None"
        (\ _ -> inf_set (DList_set dxs) (RBT_set rbt));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          error "inter DList_set RBT_set: ceq = None"
            (\ _ -> inf_set (DList_set dxs) (RBT_set rbt));
        Just _ -> RBT_set (inter_list rbt (list_of_dlist dxs));
      });
  });
inf_set (Set_Monad xs1) (Set_Monad xs2) =
  (case ceq of {
    Nothing ->
      error "inter Set_Monad Set_Monad: ceq = None"
        (\ _ -> inf_set (Set_Monad xs1) (Set_Monad xs2));
    Just eq -> Set_Monad (filter (list_member eq xs2) xs1);
  });
inf_set (Set_Monad xs) (DList_set dxs2) =
  (case ceq of {
    Nothing ->
      error "inter Set_Monad DList_set: ceq = None"
        (\ _ -> inf_set (Set_Monad xs) (DList_set dxs2));
    Just eq -> DList_set (filterb (list_member eq xs) dxs2);
  });
inf_set (Set_Monad xs) (RBT_set rbt1) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "inter Set_Monad RBT_set: corder = None"
        (\ _ -> inf_set (RBT_set rbt1) (Set_Monad xs));
    Just _ -> RBT_set (inter_list rbt1 xs);
  });
inf_set (Complement ba) (Complement b) = Complement (sup_set ba b);
inf_set g (RBT_set rbt2) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "inter RBT_set2: corder = None" (\ _ -> inf_set g (RBT_set rbt2));
    Just _ -> RBT_set (filterc ((\ x -> member x g) . fst) rbt2);
  });
inf_set (RBT_set rbt1) g =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "inter RBT_set1: corder = None" (\ _ -> inf_set (RBT_set rbt1) g);
    Just _ -> RBT_set (filterc ((\ x -> member x g) . fst) rbt1);
  });
inf_set h (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "inter DList_set2: ceq = None" (\ _ -> inf_set h (DList_set dxs2));
    Just _ -> DList_set (filterb (\ x -> member x h) dxs2);
  });
inf_set (DList_set dxs1) h =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "inter DList_set1: ceq = None" (\ _ -> inf_set (DList_set dxs1) h);
    Just _ -> DList_set (filterb (\ x -> member x h) dxs1);
  });
inf_set i (Set_Monad xs) = Set_Monad (filter (\ x -> member x i) xs);
inf_set (Set_Monad xs) i = Set_Monad (filter (\ x -> member x i) xs);
inf_set j (Collect_set a) = Collect_set (\ x -> a x && member x j);
inf_set (Collect_set a) j = Collect_set (\ x -> a x && member x j);

sup_set :: forall a. (Ceq a, Corder a) => Set a -> Set a -> Set a;
sup_set ba (Complement b) = Complement (inf_set (uminus_set ba) b);
sup_set (Complement ba) b = Complement (inf_set ba (uminus_set b));
sup_set b (Collect_set a) = Collect_set (\ x -> a x || member x b);
sup_set (Collect_set a) b = Collect_set (\ x -> a x || member x b);
sup_set (Set_Monad xs) (Set_Monad ys) = Set_Monad (xs ++ ys);
sup_set (DList_set dxs1) (Set_Monad ws) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "union DList_set Set_Monad: ceq = None"
        (\ _ -> sup_set (DList_set dxs1) (Set_Monad ws));
    Just _ -> DList_set (fold insertc ws dxs1);
  });
sup_set (Set_Monad ws) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "union Set_Monad DList_set: ceq = None"
        (\ _ -> sup_set (Set_Monad ws) (DList_set dxs2));
    Just _ -> DList_set (fold insertc ws dxs2);
  });
sup_set (RBT_set rbt1) (Set_Monad zs) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "union RBT_set Set_Monad: corder = None"
        (\ _ -> sup_set (RBT_set rbt1) (Set_Monad zs));
    Just _ -> RBT_set (fold (\ k -> insertd k ()) zs rbt1);
  });
sup_set (Set_Monad zs) (RBT_set rbt2) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "union Set_Monad RBT_set: corder = None"
        (\ _ -> sup_set (Set_Monad zs) (RBT_set rbt2));
    Just _ -> RBT_set (fold (\ k -> insertd k ()) zs rbt2);
  });
sup_set (DList_set dxs1) (DList_set dxs2) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "union DList_set DList_set: ceq = None"
        (\ _ -> sup_set (DList_set dxs1) (DList_set dxs2));
    Just _ -> DList_set (union dxs1 dxs2);
  });
sup_set (DList_set dxs) (RBT_set rbt) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "union DList_set RBT_set: corder = None"
        (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          error "union DList_set RBT_set: ceq = None"
            (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (foldd (\ k -> insertd k ()) dxs rbt);
      });
  });
sup_set (RBT_set rbt) (DList_set dxs) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "union RBT_set DList_set: corder = None"
        (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
    Just _ ->
      (case (ceq :: Maybe (a -> a -> Bool)) of {
        Nothing ->
          error "union RBT_set DList_set: ceq = None"
            (\ _ -> sup_set (RBT_set rbt) (DList_set dxs));
        Just _ -> RBT_set (foldd (\ k -> insertd k ()) dxs rbt);
      });
  });
sup_set (RBT_set rbt1) (RBT_set rbt2) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "union RBT_set RBT_set: corder = None"
        (\ _ -> sup_set (RBT_set rbt1) (RBT_set rbt2));
    Just _ -> RBT_set (join (\ _ _ -> id) rbt1 rbt2);
  });

filtera :: forall a. (Ceq a, Corder a) => (a -> Bool) -> Set a -> Set a;
filtera p a = inf_set a (Collect_set p);

fun_upd :: forall a b. (Eq a) => (a -> b) -> a -> b -> a -> b;
fun_upd f a b = (\ x -> (if x == a then b else f x));

subst :: forall a b. (Eq a) => a -> Term b a -> a -> Term b a;
subst x t = fun_upd Var x t;

const :: forall a b. a -> b -> a;
const = (\ x _ -> x);

debug :: forall a. [Prelude.Char] -> [Prelude.Char] -> a -> a;
debug i t x = x;

guard ::
  forall a.
    (Xml -> Bool) ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] a;
guard p p1 p2 x = (if p x then p1 x else p2 x);

many1_gen ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> [b] -> c) -> Xml -> Sum_bot [Prelude.Char] c;
many1_gen tag p1 p2 f (XML name atts cs text) =
  (if name == tag && null atts && is_none text && not (null cs)
    then let {
           (h : t) = cs;
         } in binda (p1 h)
                (\ x -> binda (map_sum_bot (p2 x) t) (\ xs -> returna (f x xs)))
    else fail tag (XML name atts cs text));

many1 ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> [b] -> c) -> Xml -> Sum_bot [Prelude.Char] c;
many1 tag p1 p2 = many1_gen tag p1 (\ _ -> p2);

length_ge_2 :: forall a. [a] -> Bool;
length_ge_2 (uu : uv : uw) = True;
length_ge_2 [] = False;
length_ge_2 [v] = False;

many2 ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> b -> [c] -> d) -> Xml -> Sum_bot [Prelude.Char] d;
many2 tag p1 p2 p3 f (XML name atts cs text) =
  (if name == tag && null atts && is_none text && length_ge_2 cs
    then let {
           (cs0 : cs1 : t) = cs;
         } in binda (p1 cs0)
                (\ x ->
                  binda (p2 cs1)
                    (\ y ->
                      binda (map_sum_bot p3 t) (\ xs -> returna (f x y xs))))
    else fail tag (XML name atts cs text));

membera :: forall a. (Eq a) => [a] -> a -> Bool;
membera [] y = False;
membera (x : xs) y = x == y || membera xs y;

insertb :: forall a. (Eq a) => a -> [a] -> [a];
insertb x xs = (if membera xs x then xs else x : xs);

bind :: forall a b. Maybe a -> (a -> Maybe b) -> Maybe b;
bind Nothing f = Nothing;
bind (Just x) f = f x;

prc_nat :: forall a. (a -> Nat -> Nat) -> a -> Nat -> a -> Nat -> (Bool, Bool);
prc_nat pr =
  (\ f n g m ->
    let {
      pf = pr f n;
      pg = pr g m;
    } in (less_nat pg pf, less_eq_nat pg pf));

prl_nat :: forall a. (a -> Nat -> Nat) -> a -> Bool;
prl_nat pr = (\ f -> equal_nat (pr f Zero_nat) Zero_nat);

lterms ::
  forall a b. ((a, Nat) -> [(Nat, Nat)]) -> Term a b -> [(Term a b, Nat)];
lterms pi =
  (\ (Fun f ts) ->
    map (\ (i, a) -> (proja (Fun f ts) i, a)) (pi (f, size_list ts)));

ground :: forall a b. Term a b -> Bool;
ground (Var x) = False;
ground (Fun f ts) = all ground ts;

add_vars_term_list :: forall a b. Term a b -> [b] -> [b];
add_vars_term_list =
  folda (\ a b -> a : b) (const (flip (foldr (\ a b -> a . b)) id));

vars_term_lista :: forall a b. Term a b -> [b];
vars_term_lista t = add_vars_term_list t [];

remdups :: forall a. (Eq a) => [a] -> [a];
remdups [] = [];
remdups (x : xs) = (if membera xs x then remdups xs else x : remdups xs);

vars_term_list :: forall a b. (Eq b) => Term a b -> [b];
vars_term_list = remdups . vars_term_lista;

is_Var :: forall a b. Term a b -> Bool;
is_Var (Var x1) = True;
is_Var (Fun x21 x22) = False;

wf_rule :: forall a b. (Eq b) => (Term a b, Term a b) -> Bool;
wf_rule r =
  not (is_Var (fst r)) &&
    all (membera (vars_term_list (fst r))) (vars_term_list (snd r));

fun_of :: forall a b. (Eq a) => [(a, b)] -> a -> b;
fun_of vec x = the (map_of vec x);

letters :: [Prelude.Char];
letters =
  ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D',
    'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', '0', '1', '2', '3', '4', '5', '6',
    '7', '8', '9', '&', ';', ':', '-'];

catch :: forall a b c. Sum_bot a b -> (a -> Sum_bot c b) -> Sum_bot c b;
catch (Sumbot a) f = (case a of {
                       Inl aa -> f aa;
                       Inr aa -> Sumbot (Inr aa);
                     });

choice ::
  forall a.
    [Prelude.Char] ->
      [Xml -> Sum_bot [Prelude.Char] a] -> Xml -> Sum_bot [Prelude.Char] a;
choice e [] x =
  errora
    (concat
      [['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'p', 'a', 'r', 's', 'i',
         'n', 'g', ' ', 'c', 'h', 'o', 'i', 'c', 'e', ' ', 'f', 'o', 'r', ' '],
        e, ['\n'], shows_prec_xml Zero_nat x []]);
choice e (p : ps) x = catch (p x) (\ _ -> choice e ps x);

list3elements :: forall a. [a] -> Maybe (a, (a, a));
list3elements [x, y, z] = Just (x, (y, z));
list3elements [] = Nothing;
list3elements [v] = Nothing;
list3elements [v, vb] = Nothing;
list3elements (v : vb : vd : vf : vg) = Nothing;

triple ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> b -> c -> d) -> Xml -> Sum_bot [Prelude.Char] d;
triple tag p1 p2 p3 f xml =
  let {
    (XML name atts cs text) = xml;
  } in (if name == tag && null atts && is_none text
         then (case list3elements cs of {
                Nothing -> fail tag xml;
                Just (cs1, (cs2, cs3)) ->
                  binda (p1 cs1)
                    (\ a ->
                      binda (p2 cs2)
                        (\ b -> binda (p3 cs3) (\ c -> returna (f a b c))));
              })
         else fail tag xml);

list4elements :: forall a. [a] -> Maybe (a, (a, (a, a)));
list4elements [x, y, z, u] = Just (x, (y, (z, u)));
list4elements [] = Nothing;
list4elements [v] = Nothing;
list4elements [v, vb] = Nothing;
list4elements [v, vb, vd] = Nothing;
list4elements (v : vb : vd : vf : vh : vi) = Nothing;

tuple4 ::
  forall a b c d e.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (a -> b -> c -> d -> e) -> Xml -> Sum_bot [Prelude.Char] e;
tuple4 tag p1 p2 p3 p4 f xml =
  let {
    (XML name atts cs text) = xml;
  } in (if name == tag && null atts && is_none text
         then (case list4elements cs of {
                Nothing -> fail tag xml;
                Just (cs1, (cs2, (cs3, cs4))) ->
                  binda (p1 cs1)
                    (\ a ->
                      binda (p2 cs2)
                        (\ b ->
                          binda (p3 cs3)
                            (\ c ->
                              binda (p4 cs4) (\ d -> returna (f a b c d)))));
              })
         else fail tag xml);

list5elements :: forall a. [a] -> Maybe (a, (a, (a, (a, a))));
list5elements [x, y, z, u, v] = Just (x, (y, (z, (u, v))));
list5elements [] = Nothing;
list5elements [v] = Nothing;
list5elements [v, vb] = Nothing;
list5elements [v, vb, vd] = Nothing;
list5elements [v, vb, vd, vf] = Nothing;
list5elements (v : vb : vd : vf : vh : vj : vk) = Nothing;

tuple5 ::
  forall a b c d e f.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (Xml -> Sum_bot [Prelude.Char] e) ->
                (a -> b -> c -> d -> e -> f) -> Xml -> Sum_bot [Prelude.Char] f;
tuple5 tag p1 p2 p3 p4 p5 f xml =
  let {
    (XML name atts cs text) = xml;
  } in (if name == tag && null atts && is_none text
         then (case list5elements cs of {
                Nothing -> fail tag xml;
                Just (cs1, (cs2, (cs3, (cs4, cs5)))) ->
                  binda (p1 cs1)
                    (\ a ->
                      binda (p2 cs2)
                        (\ b ->
                          binda (p3 cs3)
                            (\ c ->
                              binda (p4 cs4)
                                (\ d ->
                                  binda (p5 cs5)
                                    (\ e -> returna (f a b c d e))))));
              })
         else fail tag xml);

list6elements :: forall a. [a] -> Maybe (a, (a, (a, (a, (a, a)))));
list6elements [x, y, z, u, v, w] = Just (x, (y, (z, (u, (v, w)))));
list6elements [] = Nothing;
list6elements [v] = Nothing;
list6elements [v, vb] = Nothing;
list6elements [v, vb, vd] = Nothing;
list6elements [v, vb, vd, vf] = Nothing;
list6elements [v, vb, vd, vf, vh] = Nothing;
list6elements (v : vb : vd : vf : vh : vj : vl : vm) = Nothing;

tuple6 ::
  forall a b c d e f g.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (Xml -> Sum_bot [Prelude.Char] e) ->
                (Xml -> Sum_bot [Prelude.Char] f) ->
                  (a -> b -> c -> d -> e -> f -> g) ->
                    Xml -> Sum_bot [Prelude.Char] g;
tuple6 tag p1 p2 p3 p4 p5 p6 f xml =
  let {
    (XML name atts cs text) = xml;
  } in (if name == tag && null atts && is_none text
         then (case list6elements cs of {
                Nothing -> fail tag xml;
                Just (cs1, (cs2, (cs3, (cs4, (cs5, cs6))))) ->
                  binda (p1 cs1)
                    (\ a ->
                      binda (p2 cs2)
                        (\ b ->
                          binda (p3 cs3)
                            (\ c ->
                              binda (p4 cs4)
                                (\ d ->
                                  binda (p5 cs5)
                                    (\ e ->
                                      binda (p6 cs6)
(\ ff -> returna (f a b c d e ff)))))));
              })
         else fail tag xml);

update :: forall a b. (Eq a) => a -> b -> [(a, b)] -> [(a, b)];
update k v [] = [(k, v)];
update k v (p : ps) = (if fst p == k then (k, v) : ps else p : update k v ps);

emptya :: forall a b. Alist a b;
emptya = Alist [];

scf_list :: forall a. (Nat -> Nat) -> [a] -> [a];
scf_list scf xs =
  concatMap (\ (x, i) -> replicate (scf i) x)
    (zip xs (upt Zero_nat (size_list xs)));

scf_term :: forall a b. ((a, Nat) -> Nat -> Nat) -> Term a b -> Term a b;
scf_term scf (Var x) = Var x;
scf_term scf (Fun f ts) =
  Fun f (scf_list (scf (f, size_list ts)) (map (scf_term scf) ts));

butlast :: forall a. [a] -> [a];
butlast [] = [];
butlast (x : xs) = (if null xs then [] else x : butlast xs);

extract :: forall a. (a -> Bool) -> [a] -> Maybe ([a], (a, [a]));
extract p (x : xs) =
  (if p x then Just ([], (x, xs))
    else (case extract p xs of {
           Nothing -> Nothing;
           Just (ys, (y, zs)) -> Just (x : ys, (y, zs));
         }));
extract p [] = Nothing;

hd :: forall a. [a] -> a;
hd (x21 : x22) = x21;

productb ::
  forall a b. (Ceq a, Ceq b) => Set_dlist a -> Set_dlist b -> Set_dlist (a, b);
productb dxs1 dxs2 =
  Abs_dlist (foldd (\ a -> foldd (\ c -> (\ b -> (a, c) : b)) dxs2) dxs1 []);

rbt_product ::
  forall a b c d e.
    (a -> b -> c -> d -> e) -> Rbta a b -> Rbta c d -> Rbta (a, c) e;
rbt_product f rbt1 rbt2 =
  rbtreeify
    (reverse
      (foldb (\ a b -> foldb (\ c d -> (\ e -> ((a, c), f a b c d) : e)) rbt2)
        rbt1 []));

productd ::
  forall a d b e c.
    (Corder a,
      Corder b) => (a -> d -> b -> e -> c) ->
                     Mapping_rbt a d -> Mapping_rbt b e -> Mapping_rbt (a, b) c;
productd xc xd xe = Mapping_RBTa (rbt_product xc (impl_ofb xd) (impl_ofb xe));

producta ::
  forall a b.
    (Corder a,
      Corder b) => Mapping_rbt a () ->
                     Mapping_rbt b () -> Mapping_rbt (a, b) ();
producta rbt1 rbt2 = productd (\ _ _ _ _ -> ()) rbt1 rbt2;

productc ::
  forall a b.
    (Ceq a, Corder a, Set_impl a, Ceq b, Corder b,
      Set_impl b) => Set a -> Set b -> Set (a, b);
productc (RBT_set rbt1) (RBT_set rbt2) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "product RBT_set RBT_set: corder1 = None"
        (\ _ -> productc (RBT_set rbt1) (RBT_set rbt2));
    Just _ ->
      (case (corder :: Maybe (b -> b -> Bool, b -> b -> Bool)) of {
        Nothing ->
          error "product RBT_set RBT_set: corder2 = None"
            (\ _ -> productc (RBT_set rbt1) (RBT_set rbt2));
        Just _ -> RBT_set (producta rbt1 rbt2);
      });
  });
productc a2 (RBT_set rbt2) =
  (case (corder :: Maybe (b -> b -> Bool, b -> b -> Bool)) of {
    Nothing ->
      error "product RBT_set: corder2 = None"
        (\ _ -> productc a2 (RBT_set rbt2));
    Just _ -> foldc (\ y -> sup_set (image (\ x -> (x, y)) a2)) rbt2 bot_set;
  });
productc (RBT_set rbt1) b2 =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "product RBT_set: corder1 = None"
        (\ _ -> productc (RBT_set rbt1) b2);
    Just _ -> foldc (\ x -> sup_set (image (\ a -> (x, a)) b2)) rbt1 bot_set;
  });
productc (DList_set dxs) (DList_set dys) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "product DList_set DList_set: ceq1 = None"
        (\ _ -> productc (DList_set dxs) (DList_set dys));
    Just _ ->
      (case (ceq :: Maybe (b -> b -> Bool)) of {
        Nothing ->
          error "product DList_set DList_set: ceq2 = None"
            (\ _ -> productc (DList_set dxs) (DList_set dys));
        Just _ -> DList_set (productb dxs dys);
      });
  });
productc a1 (DList_set dys) =
  (case (ceq :: Maybe (b -> b -> Bool)) of {
    Nothing ->
      error "product DList_set2: ceq = None"
        (\ _ -> productc a1 (DList_set dys));
    Just _ -> foldd (\ y -> sup_set (image (\ x -> (x, y)) a1)) dys bot_set;
  });
productc (DList_set dxs) b1 =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "product DList_set1: ceq = None"
        (\ _ -> productc (DList_set dxs) b1);
    Just _ -> foldd (\ x -> sup_set (image (\ a -> (x, a)) b1)) dxs bot_set;
  });
productc (Set_Monad xs) (Set_Monad ys) =
  Set_Monad (fold (\ x -> fold (\ y -> (\ a -> (x, y) : a)) ys) xs []);
productc a b = Collect_set (\ (x, y) -> member x a && member y b);

set_Cons ::
  forall a. (Ceq a, Corder a, Set_impl a) => Set a -> Set [a] -> Set [a];
set_Cons a xs =
  image (\ (aa, b) -> aa : b)
    (productc (inf_set (image (\ x -> x) a) top_set)
      (inf_set top_set (image (\ xsa -> xsa) xs)));

listset :: forall a. (Ceq a, Corder a, Set_impl a) => [Set a] -> Set [a];
listset [] = inserta [] (set_empty (of_phantom set_impl_list));
listset (a : asa) = set_Cons a (listset asa);

remove1 :: forall a. (Eq a) => a -> [a] -> [a];
remove1 x [] = [];
remove1 x (y : xs) = (if x == y then xs else y : remove1 x xs);

l2m_lookup ::
  forall a b c. (Eq a, Eq b) => [(a, [(b, c)])] -> (a, b) -> Maybe c;
l2m_lookup [] uu = Nothing;
l2m_lookup ((a, kvs) : rec) (k1, k2) =
  (case k1 == a of {
    True -> map_of kvs k2;
    False -> l2m_lookup rec (k1, k2);
  });

lm_store_acc ::
  forall a b. (Eq a) => [(a, b)] -> (a, b) -> [(a, b)] -> [(a, b)];
lm_store_acc [] kv accu = kv : accu;
lm_store_acc ((a, uu) : rec) (k, v) accu =
  (case k == a of {
    True -> accu;
    False -> lm_store_acc rec (k, v) accu;
  });

lm_store :: forall a b. (Eq a) => [(a, b)] -> (a, b) -> [(a, b)];
lm_store m kv = lm_store_acc m kv m;

l2m_store ::
  forall a b c.
    (Eq a, Eq b) => [(a, [(b, c)])] -> ((a, b), c) -> [(a, [(b, c)])];
l2m_store [] ((k1, k2), v) = [(k1, [(k2, v)])];
l2m_store ((a, kvs) : rec) ((k1, k2), v) =
  (case k1 == a of {
    True -> (a, lm_store kvs (k2, v)) : rec;
    False -> (a, kvs) : l2m_store rec ((k1, k2), v);
  });

l2m :: forall a b c. (Eq a, Eq b) => Memory_ext [(a, [(b, c)])] (a, b) c ();
l2m = Memory_ext (\ _ -> []) l2m_lookup l2m_store ();

aux ::
  forall a b.
    (Eq a,
      Linorder b) => (a -> Maybe b) -> Rbt b [a] -> a -> Rbt b [a] -> Rbt b [a];
aux key ma v m =
  (case key v of {
    Nothing -> m;
    Just k ->
      (case lookup ma k of {
        Nothing -> m;
        Just ws ->
          (if membera ws v
            then (case lookup m k of {
                   Nothing -> insert k [v] m;
                   Just vs -> insert k (insertb v vs) m;
                 })
            else m);
      });
  });

ma_coeff :: Mini_alg -> Rat;
ma_coeff xa = fst (snd (rep_mini_alg xa));

mau_coeff :: Mini_alg_unique -> Rat;
mau_coeff xa = ma_coeff (rep_mini_alg_unique xa);

root_int_maina :: Nat -> Int -> Int -> Int -> Int -> (Int, Bool);
root_int_maina pm ipm ip x n =
  let {
    xpm = powera x pm;
    xp = times_int xpm x;
  } in (if less_eq_int xp n then (x, equal_int xp n)
         else root_int_maina pm ipm ip
                (div_int (plus_int (div_int n xpm) (times_int x ipm)) ip) n);

root_int_main :: Nat -> Int -> (Int, Bool);
root_int_main p n =
  (if equal_nat p Zero_nat then (Pos One, equal_int n (Pos One))
    else let {
           pm = minus_nat p (Nat_of_num One);
         } in root_int_maina pm (of_nat pm) (of_nat p) (start_value n p) n);

root_int_floor_pos :: Nat -> Int -> Int;
root_int_floor_pos p x =
  (if equal_nat p Zero_nat then Zero_int else fst (root_int_main p x));

root_nat_floor :: Nat -> Nat -> Int;
root_nat_floor p x = root_int_floor_pos p (of_nat x);

sqrt_int :: Int -> [Int];
sqrt_int x =
  (if less_int x Zero_int then []
    else (case sqrt_int_main x of {
           (y, True) ->
             (if equal_int y Zero_int then [Zero_int] else [y, uminus_int y]);
           (y, False) -> [];
         }));

sqrt_nat :: Nat -> [Nat];
sqrt_nat x = map nat (take (Nat_of_num One) (sqrt_int (of_nat x)));

dvd :: forall a. (Semiring_div a, Eq a) => a -> a -> Bool;
dvd a b = mod b a == zeroa;

prime_product_factor_main :: Nat -> Nat -> Nat -> Nat -> Nat -> (Nat, Nat);
prime_product_factor_main factor_sq factor_pr limit n i =
  (if less_eq_nat i limit && less_eq_nat (Nat_of_num (Bit0 One)) i
    then (if dvd i n
           then let {
                  na = div_nat n i;
                } in (if dvd i na
                       then let {
                              nb = div_nat na i;
                            } in prime_product_factor_main
                                   (times_nat factor_sq i) factor_pr
                                   (nat (root_nat_floor (Nat_of_num (Bit1 One))
  nb))
                                   nb i
                       else (case sqrt_nat na of {
                              [] -> prime_product_factor_main factor_sq
                                      (times_nat factor_pr i)
                                      (nat
(root_nat_floor (Nat_of_num (Bit1 One)) na))
                                      na (plus_nat i (Nat_of_num One));
                              sn : _ ->
                                (times_nat factor_sq sn, times_nat factor_pr i);
                            }))
           else prime_product_factor_main factor_sq factor_pr limit n
                  (plus_nat i (Nat_of_num One)))
    else (factor_sq, times_nat factor_pr n));

prime_product_factor :: Nat -> (Nat, Nat);
prime_product_factor n =
  (case sqrt_nat n of {
    [] -> prime_product_factor_main (Nat_of_num One) (Nat_of_num One)
            (nat (root_nat_floor (Nat_of_num (Bit1 One)) n)) n
            (Nat_of_num (Bit0 One));
    s : _ -> (s, Nat_of_num One);
  });

ma_sqrt :: Mini_alg -> Mini_alg;
ma_sqrt xa =
  Abs_mini_alg
    (let {
       (p, (_, _)) = rep_mini_alg xa;
       (a, b) = quotient_of p;
       aa = abs_int (times_int a b);
     } in (case sqrt_int aa of {
            [] -> (zero_rat, (inverse_rat (of_int b), nat aa));
            s : _ -> (divide_rat (of_int s) (of_int b), (zero_rat, Zero_nat));
          }));

ma_rat :: Mini_alg -> Rat;
ma_rat xa = fst (rep_mini_alg xa);

mau_sqrt :: Mini_alg_unique -> Mini_alg_unique;
mau_sqrt xa =
  Abs_mini_alg_unique
    (let {
       (a, b) = quotient_of (ma_rat (rep_mini_alg_unique xa));
       (sq, fact) = prime_product_factor (nat (times_int (abs_int a) b));
       ma = ma_of_rat
              (divide_rat (times_rat (of_int (sgn_int a)) (of_nat sq))
                (of_int b));
     } in ma_times ma (ma_sqrt (ma_of_rat (of_nat fact))));

sqrt :: Real -> Real;
sqrt (Real_of_u r) =
  (if equal_rat (mau_coeff r) zero_rat then Real_of_u (mau_sqrt r)
    else error "cannot represent sqrt of irrational number"
           (\ _ -> sqrt (Real_of_u r)));

rev :: Pos -> Pos;
rev Empty = Empty;
rev (PCons i p) = append (rev p) (PCons i Empty);

key :: forall a b c. (a, (Term b c, Term b c)) -> Maybe (b, Nat);
key (uu, (Fun f ts, uv)) = Just (f, size_list ts);
key (uw, (Var ux, uy)) = Nothing;

subt_at :: forall a b. Term a b -> Pos -> Term a b;
subt_at s Empty = s;
subt_at (Fun f ss) (PCons i p) = subt_at (nth ss i) p;

map_term :: forall a b c. (a -> b) -> Term a c -> Term b c;
map_term fun (Var x) = Var x;
map_term fun (Fun f ts) = Fun (fun f) (map (map_term fun) ts);

map_rule ::
  forall a b c. (a -> b) -> (Term a c, Term a c) -> (Term b c, Term b c);
map_rule fg lr = (map_term fg (fst lr), map_term fg (snd lr));

children :: Xml -> [Xml];
children (XML uu uv cs uw) = cs;

lookupa :: forall a b. (Eq a) => Alist a b -> a -> Maybe b;
lookupa xa = map_of (impl_ofa xa);

updatea :: forall a b. (Eq a) => a -> b -> Alist a b -> Alist a b;
updatea xc xd xe = Alist (update xc xd (impl_ofa xe));

zip_option :: forall a b. [a] -> [b] -> Maybe [(a, b)];
zip_option [] [] = Just [];
zip_option (x : xs) (y : ys) =
  bind (zip_option xs ys) (\ zs -> Just ((x, y) : zs));
zip_option (x : xs) [] = Nothing;
zip_option [] (y : ys) = Nothing;

guarda :: Bool -> Maybe ();
guarda b = (if b then Just () else Nothing);

match_lista ::
  forall a b. (Eq a) => [(Gctxt a b, Term a b)] -> Maybe [(Gctxt a b, b)];
match_lista ((GCFun f ss, Var x) : ps) =
  bind (match_lista ps) (\ psa -> Just ((GCFun f ss, x) : psa));
match_lista ((GCFun f ss, Fun g ts) : ps) =
  bind (guarda (f == g))
    (\ _ -> bind (zip_option ss ts) (\ psa -> match_lista (psa ++ ps)));
match_lista ((GCHole, t) : ps) = match_lista ps;
match_lista [] = Just [];

merge_lists ::
  forall a b. (Eq a) => [Gctxt a b] -> [Gctxt a b] -> Maybe [Gctxt a b];
merge_lists (c : cs) [] = Nothing;
merge_lists [] (d : ds) = Nothing;
merge_lists (GCFun f ss : cs) (GCFun g ts : ds) =
  bind (guarda (f == g))
    (\ _ ->
      bind (merge_lists ss ts)
        (\ us -> bind (merge_lists cs ds) (\ es -> Just (GCFun f us : es))));
merge_lists (c : cs) (GCHole : ds) =
  bind (merge_lists cs ds) (\ es -> Just (c : es));
merge_lists (GCHole : cs) (d : ds) =
  bind (merge_lists cs ds) (\ es -> Just (d : es));
merge_lists [] [] = Just [];

merge :: forall a b. (Eq a) => Gctxt a b -> Gctxt a b -> Maybe (Gctxt a b);
merge c d = bind (merge_lists [c] [d]) (\ es -> Just (nth es Zero_nat));

merge_var ::
  forall a b.
    (Eq a,
      Eq b) => a -> Gctxt b a ->
                      [(Gctxt b a, a)] ->
                        Maybe ((Gctxt b a, a), [(Gctxt b a, a)]);
merge_var x c ((d, y) : ps) =
  (if x == y then bind (merge c d) (\ e -> merge_var x e ps)
    else bind (merge_var x c ps) (\ (b, psa) -> Just (b, (d, y) : psa)));
merge_var x c [] = Just ((c, x), []);

merge_all ::
  forall a b. (Eq a, Eq b) => [(Gctxt a b, b)] -> Maybe [(Gctxt a b, b)];
merge_all [] = Just [];
merge_all ((c, x) : ps) =
  bind (merge_var x c ps)
    (\ (cx, psa) -> bind (merge_all psa) (\ psb -> Just (cx : psb)));

matchc ::
  forall a b. (Eq a, Eq b) => (Gctxt a b, Term a b) -> Maybe [(Gctxt a b, b)];
matchc (c, t) = bind (match_lista [(c, t)]) merge_all;

matchb :: forall a b. (Eq a, Eq b) => Gctxt a b -> Term a b -> Bool;
matchb c t = not (is_none (matchc (c, t)));

capI ::
  forall a b. (Eq a, Eq b) => [(Term a b, Term a b)] -> Term a b -> Gctxt a b;
capI uu (Var uv) = GCHole;
capI r (Fun f ts) =
  let {
    h = GCFun f (map (capI r) ts);
  } in (if any (\ ra -> matchb h (fst ra)) r then GCHole else h);

distinct :: forall a. (Eq a) => [a] -> Bool;
distinct [] = True;
distinct (x : xs) = not (membera xs x) && distinct xs;

mapping_empty_choose :: forall a b. (Corder a) => Mapping a b;
mapping_empty_choose =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing -> Assoc_List_Mapping emptya;
    Just _ -> RBT_Mapping emptyd;
  });

mapping_empty :: forall a b. (Corder a) => Mapping_impla -> Mapping a b;
mapping_empty Mapping_RBT = RBT_Mapping emptyd;
mapping_empty Mapping_Assoc_List = Assoc_List_Mapping emptya;
mapping_empty Mapping_Mapping = Mapping (\ _ -> Nothing);
mapping_empty Mapping_Choose = mapping_empty_choose;

emptyb :: forall a b. (Corder a, Mapping_impl a) => Mapping a b;
emptyb = mapping_empty (of_phantom (mapping_impl :: Phantom a Mapping_impla));

add ::
  forall a b. Partial_object_ext a (Monoid_ext a (Ring_ext a b)) -> a -> a -> a;
add (Partial_object_ext carrier (Monoid_ext mult one (Ring_ext zero add more)))
  = add;

shows_nl :: [Prelude.Char] -> [Prelude.Char];
shows_nl = shows_prec_char Zero_nat '\n';

hole_pos :: forall a b. Ctxt a b -> Pos;
hole_pos Hole = Empty;
hole_pos (More f ss d ts) = PCons (size_list ss) (hole_pos d);

map_vars :: forall a b c. (a -> b) -> Term c a -> Term c b;
map_vars m (Var x) = Var (m x);
map_vars m (Fun f ts) = Fun f (map (map_vars m) ts);

num_args :: forall a b. Term a b -> Nat;
num_args (Var x) = Zero_nat;
num_args (Fun f ts) = size_list ts;

vars_term :: forall a b. (Ceq b, Corder b, Set_impl b) => Term a b -> Set b;
vars_term (Var x) = inserta x bot_set;
vars_term (Fun f ts) = foldr (sup_set . vars_term) ts bot_set;

vars_rule ::
  forall a b. (Ceq b, Corder b, Set_impl b) => (Term a b, Term a b) -> Set b;
vars_rule r = sup_set (vars_term (fst r)) (vars_term (snd r));

unapp :: forall a b. (Eq a) => a -> Term a b -> (Term a b, [Term a b]);
unapp a (Var x) = (Var x, []);
unapp a (Fun f ss) =
  (if f == a && equal_nat (size_list ss) (Nat_of_num (Bit0 One))
    then let {
           (r, ts) = unapp a (nth ss Zero_nat);
         } in (r, ts ++ [nth ss (Nat_of_num One)])
    else (Fun f ss, []));

update_tokens :: forall a. ([a] -> [a]) -> [a] -> Sum [Prelude.Char] ([a], [a]);
update_tokens f ts = Inr (ts, f ts);

remove_comments_aux_acc ::
  [Prelude.Char] -> Bool -> [Prelude.Char] -> [Prelude.Char];
remove_comments_aux_acc a False (c : cs) =
  (if c == '<' && take (Nat_of_num (Bit1 One)) cs == ['!', '-', '-']
    then remove_comments_aux_acc a True (tl cs)
    else remove_comments_aux_acc (c : a) False cs);
remove_comments_aux_acc a True (c : cs) =
  (if c == '-' && take (Nat_of_num (Bit0 One)) cs == ['-', '>']
    then remove_comments_aux_acc a False (drop (Nat_of_num (Bit0 One)) cs)
    else remove_comments_aux_acc a True cs);
remove_comments_aux_acc a uu [] = a;

remove_comments_aux :: Bool -> [Prelude.Char] -> [Prelude.Char];
remove_comments_aux False (c : cs) =
  (if c == '<' && take (Nat_of_num (Bit1 One)) cs == ['!', '-', '-']
    then remove_comments_aux True (tl cs)
    else c : remove_comments_aux False cs);
remove_comments_aux True (c : cs) =
  (if c == '-' && take (Nat_of_num (Bit0 One)) cs == ['-', '>']
    then remove_comments_aux False (drop (Nat_of_num (Bit0 One)) cs)
    else remove_comments_aux True cs);
remove_comments_aux uu [] = [];

remove_comments :: [Prelude.Char] -> [Prelude.Char];
remove_comments =
  (if False then reverse . remove_comments_aux_acc [] False
    else remove_comments_aux False);

returnb :: forall a b. a -> [b] -> Sum [Prelude.Char] (a, [b]);
returnb x = (\ ts -> Inr (x, ts));

bindb :: forall a b c. Sum a b -> (b -> Sum a c) -> Sum a c;
bindb m f = (case m of {
              Inl a -> Inl a;
              Inr a -> f a;
            });

bindc ::
  forall a b c.
    ([a] -> Sum [Prelude.Char] (b, [a])) ->
      (b -> [a] -> Sum [Prelude.Char] (c, [a])) ->
        [a] -> Sum [Prelude.Char] (c, [a]);
bindc m f ts = bindb (m ts) (\ (a, b) -> f a b);

shows_quote ::
  ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
shows_quote s =
  shows_between (shows_prec_char Zero_nat '\'') s
    (shows_prec_char Zero_nat '\'');

scan_upto ::
  [Prelude.Char] ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
scan_upto end (t : ts) =
  (if map snd (zip end (t : ts)) == end
    then Inr (end, drop (size_list end) (t : ts))
    else bindb (scan_upto end ts) (\ (res, tsa) -> Inr (t : res, tsa)));
scan_upto end [] =
  Inl (['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 'e',
         'n', 'd', '-', 'm', 'a', 'r', 'k', 'e', 'r', ' '] ++
        shows_quote (shows_prec_list Zero_nat end) []);

trim :: [Prelude.Char] -> [Prelude.Char];
trim = dropWhile (membera [' ', '\n', '\t', '\r']);

manya ::
  (Prelude.Char -> Bool) ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
manya p (t : ts) =
  (if p t then bindb (manya p ts) (\ (rs, tsa) -> Inr (t : rs, tsa))
    else Inr ([], t : ts));
manya p [] = Inr ([], []);

parse_header ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
parse_header ts =
  (if take (Nat_of_num (Bit0 One)) (trim ts) == ['<', '?']
    then bindc (scan_upto ['?', '>'])
           (\ h -> bindc parse_header (\ hs -> returnb (h ++ hs))) ts
    else bindc (bindc (manya (membera [' ', '\n', '\t', '\r']))
                 (\ _ -> returnb ()))
           (\ _ -> returnb []) ts);

err_expecting ::
  forall a b. (Showa a) => [Prelude.Char] -> [a] -> Sum [Prelude.Char] (b, [a]);
err_expecting msg ts =
  Inl (['e', 'x', 'p', 'e', 'c', 't', 'i', 'n', 'g', ' '] ++
        msg ++
          [',', ' ', 'b', 'u', 't', ' ', 'f', 'o', 'u', 'n', 'd', ':', ' '] ++
            shows_quote
              (shows_prec_list Zero_nat
                (take (Nat_of_num (Bit0 (Bit1 (Bit1 (Bit1 One))))) ts))
              []);

eoi :: forall a. (Showa a) => [a] -> Sum [Prelude.Char] ((), [a]);
eoi [] = Inr ((), []);
eoi (v : va) =
  err_expecting ['e', 'n', 'd', ' ', 'o', 'f', ' ', 'i', 'n', 'p', 'u', 't']
    (v : va);

exactly_aux ::
  [Prelude.Char] ->
    [Prelude.Char] ->
      [Prelude.Char] ->
        [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
exactly_aux s i (x : xs) (y : ys) =
  (if x == y then exactly_aux s i xs ys
    else err_expecting (['\"'] ++ s ++ ['\"']) i);
exactly_aux s i [] xs = Inr (s, trim xs);
exactly_aux s i (x : xs) [] = err_expecting (['\"'] ++ s ++ ['\"']) i;

exactly ::
  [Prelude.Char] ->
    [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
exactly s x = exactly_aux s x s x;

parse_attribute_value ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
parse_attribute_value =
  bindc (exactly ['\"'])
    (\ _ ->
      bindc (manya (\ y -> not ('\"' == y)))
        (\ v -> bindc (exactly ['\"']) (\ _ -> returnb v)));

errorb :: forall a b. [Prelude.Char] -> [a] -> Sum [Prelude.Char] (b, [a]);
errorb e = (\ _ -> Inl e);

letters_impl :: Prelude.Char -> Bool;
letters_impl c =
  'a' <= c && c <= 'z' ||
    ('A' <= c && c <= 'Z' ||
      ('0' <= c && c <= '9' || membera ['_', '&', ';', ':', '-'] c));

parse_name ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
parse_name s =
  bindc (manya letters_impl)
    (\ n ->
      bindc (bindc (manya (membera [' ', '\n', '\t', '\r']))
              (\ _ -> returnb ()))
        (\ _ ->
          (if null n
            then errorb
                   (['e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'l', 'e', 't',
                      't', 'e', 'r', ' '] ++
                     letters ++
                       [' ', 'b', 'u', 't', ' ', 'f', 'i', 'r', 's', 't', ' ',
                         's', 'y', 'm', 'b', 'o', 'l', ' ', 'i', 's', ' ',
                         '\"'] ++
                         take (Nat_of_num One) s ++ ['\"'])
            else returnb n)))
    s;

parse_attributes ::
  [Prelude.Char] ->
    Sum [Prelude.Char] ([([Prelude.Char], [Prelude.Char])], [Prelude.Char]);
parse_attributes [] = Inr ([], []);
parse_attributes (c : s) =
  (if membera ['/', '>'] c then Inr ([], c : s)
    else bindc parse_name
           (\ k ->
             bindc (exactly ['='])
               (\ _ ->
                 bindc parse_attribute_value
                   (\ v ->
                     bindc parse_attributes
                       (\ atts -> returnb ((k, v) : atts)))))
           (c : s));

oneof_closed ::
  [Prelude.Char] -> Sum [Prelude.Char] ([Prelude.Char], [Prelude.Char]);
oneof_closed (x : xs) =
  (if x == '>' then Inr (['>'], trim xs)
    else (if x == '/' && (case xs of {
                           [] -> False;
                           y : _ -> y == '>';
                         })
           then Inr (['/', '>'], trim (tl xs))
           else err_expecting
                  ['o', 'n', 'e', ' ', 'o', 'f', ' ', '[', '/', '>', ',', ' ',
                    '>', ']']
                  (x : xs)));
oneof_closed [] =
  err_expecting
    ['o', 'n', 'e', ' ', 'o', 'f', ' ', '[', '/', '>', ',', ' ', '>', ']'] [];

parse_text ::
  [Prelude.Char] -> Sum [Prelude.Char] (Maybe [Prelude.Char], [Prelude.Char]);
parse_text =
  bindc (manya (\ y -> not ('<' == y)))
    (\ ts ->
      let {
        text = trim ts;
      } in (if null text then returnb Nothing
             else returnb (Just (reverse (trim (reverse text))))));

parse_nodes :: [Prelude.Char] -> Sum [Prelude.Char] ([Xml], [Prelude.Char]);
parse_nodes ts =
  (if null ts || take (Nat_of_num (Bit0 One)) ts == ['<', '/']
    then returnb [] ts
    else bindc (exactly ['<'])
           (\ _ ->
             bindc parse_name
               (\ n ->
                 bindc parse_attributes
                   (\ atts ->
                     bindc oneof_closed
                       (\ e ->
                         (if e == ['/', '>']
                           then bindc parse_nodes
                                  (\ cs -> returnb (XML n atts [] Nothing : cs))
                           else bindc parse_text
                                  (\ t ->
                                    bindc parse_nodes
                                      (\ cs ->
bindc (exactly ['<', '/'])
  (\ _ ->
    bindc (exactly n)
      (\ _ ->
        bindc (exactly ['>'])
          (\ _ ->
            bindc parse_nodes (\ ns -> returnb (XML n atts cs t : ns))))))))))))
           ts);

parse_node :: [Prelude.Char] -> Sum [Prelude.Char] (Xml, [Prelude.Char]);
parse_node =
  bindc (exactly ['<'])
    (\ _ ->
      bindc parse_name
        (\ n ->
          bindc parse_attributes
            (\ atts ->
              bindc oneof_closed
                (\ e ->
                  (if e == ['/', '>'] then returnb (XML n atts [] Nothing)
                    else bindc parse_text
                           (\ t ->
                             bindc parse_nodes
                               (\ cs ->
                                 bindc (exactly ['<', '/'])
                                   (\ _ ->
                                     bindc (exactly n)
                                       (\ _ ->
 bindc (exactly ['>']) (\ _ -> returnb (XML n atts cs t)))))))))));

parse_doc :: [Prelude.Char] -> Sum [Prelude.Char] (Xmldoc, [Prelude.Char]);
parse_doc =
  bindc (update_tokens remove_comments)
    (\ _ ->
      bindc parse_header
        (\ h ->
          bindc parse_node
            (\ xml -> bindc eoi (\ _ -> returnb (XMLDOC h xml)))));

position :: Xml -> Sum_bot [Prelude.Char] Nat;
position =
  change (nata ['p', 'o', 's', 'i', 't', 'i', 'o', 'n'])
    (\ n -> minus_nat n (Nat_of_num One));

afs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), Af_entry)];
afs xml2name =
  many ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r']
    (triple
      ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r',
        'E', 'n', 't', 'r', 'y']
      xml2name (nata ['a', 'r', 'i', 't', 'y'])
      (options
        [(['c', 'o', 'l', 'l', 'a', 'p', 's', 'i', 'n', 'g'],
           change (nata ['c', 'o', 'l', 'l', 'a', 'p', 's', 'i', 'n', 'g'])
             (\ i -> Collapse (minus_nat i (Nat_of_num One)))),
          (['n', 'o', 'n', 'C', 'o', 'l', 'l', 'a', 'p', 's', 'i', 'n', 'g'],
            many ['n', 'o', 'n', 'C', 'o', 'l', 'l', 'a', 'p', 's', 'i', 'n',
                   'g']
              position AFList)])
      (\ f a -> (\ b -> ((f, a), b))))
    id;

list2position :: [Nat] -> Pos;
list2position [] = Empty;
list2position (n : ns) = PCons n (list2position ns);

pos :: Xml -> Sum_bot [Prelude.Char] Pos;
pos = many ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', 'I', 'n', 'T', 'e', 'r',
             'm']
        position list2position;

scg_position :: Xml -> Sum_bot [Prelude.Char] Nat;
scg_position = nata ['p', 'o', 's', 'i', 't', 'i', 'o', 'n'];

list1element :: forall a. [a] -> Maybe a;
list1element [x] = Just x;
list1element [] = Nothing;
list1element (v : vb : vc) = Nothing;

singleton ::
  forall a b.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> b) -> Xml -> Sum_bot [Prelude.Char] b;
singleton tag p1 f xml =
  let {
    (XML name atts cs text) = xml;
  } in (if name == tag && null atts && is_none text
         then (case list1element cs of {
                Nothing -> fail tag xml;
                Just cs1 -> binda (p1 cs1) (\ a -> returna (f a));
              })
         else fail tag xml);

var :: forall a. Xml -> Sum_bot [Prelude.Char] (Term a [Prelude.Char]);
var x = binda (text ['v', 'a', 'r'] x) (returna . Var);

term ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Term a [Prelude.Char]);
term xml2name x =
  options
    [(['v', 'a', 'r'], var),
      (['f', 'u', 'n', 'a', 'p', 'p'],
        many1 ['f', 'u', 'n', 'a', 'p', 'p'] xml2name
          (singleton ['a', 'r', 'g'] (term xml2name) id) Fun)]
    x;

rule ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char] (Term a [Prelude.Char], Term a [Prelude.Char]);
rule xml2name =
  pair ['r', 'u', 'l', 'e'] (singleton ['l', 'h', 's'] (term xml2name) id)
    (singleton ['r', 'h', 's'] (term xml2name) id) (\ a b -> (a, b));

scg ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ((Term a [Prelude.Char], Term a [Prelude.Char]),
            ([(Nat, Nat)], [(Nat, Nat)]));
scg xml2name =
  many1 ['s', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'G', 'r', 'a', 'p',
          'h']
    (rule xml2name)
    (triple ['e', 'd', 'g', 'e'] scg_position
      (bool ['s', 't', 'r', 'i', 'c', 't']) scg_position
      (\ p s q -> (s, (p, q))))
    (\ lr edges ->
      (lr, (map_filter (\ x -> (if fst x then Just (snd x) else Nothing)) edges,
             map_filter (\ x -> (if not (fst x) then Just (snd x) else Nothing))
               edges)));

capRM2 ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> [(Term a b, Term a b)]) -> Term a b -> Gctxt a b;
capRM2 uu (Var uv) = GCHole;
capRM2 rm (Fun f ts) =
  let {
    h = GCFun f (map (capRM2 rm) ts);
    n = size_list ts;
  } in (if any (\ r -> matchb h (fst r)) (rm (f, n)) then GCHole else h);

capRM ::
  forall a b.
    (Eq a,
      Eq b) => Bool ->
                 ((a, Nat) -> [(Term a b, Term a b)]) -> Term a b -> Gctxt a b;
capRM nlv rm = (if nlv then capRM2 rm else (\ _ -> GCHole));

class_to_term_intern ::
  forall a b. (Nat -> a) -> Nat -> Term b (Sum () a) -> (Nat, Term b a);
class_to_term_intern iv i (Fun f ts) =
  let {
    (k, ss) =
      foldr (\ t (j, ss) ->
              let {
                (k, s) = class_to_term_intern iv j t;
              } in (k, s : ss))
        ts (i, []);
  } in (k, Fun f ss);
class_to_term_intern iv i (Var (Inl uu)) =
  (plus_nat i (Nat_of_num One), Var (iv i));
class_to_term_intern iv i (Var (Inr x)) = (i, Var x);

class_to_term ::
  forall a.
    Prelude.Char -> Term a (Sum () [Prelude.Char]) -> Term a [Prelude.Char];
class_to_term c t =
  snd (class_to_term_intern (\ i -> c : shows_prec_nat Zero_nat i []) Zero_nat
        t);

subst_apply_term :: forall a b c. Term a b -> (b -> Term a c) -> Term a c;
subst_apply_term (Var x) sigma = sigma x;
subst_apply_term (Fun f ss) sigma =
  Fun f (map (\ t -> subst_apply_term t sigma) ss);

subst_compose ::
  forall a b c d. (a -> Term b c) -> (c -> Term b d) -> a -> Term b d;
subst_compose sigma tau = (\ x -> subst_apply_term (sigma x) tau);

subst_of :: forall a b. (Eq a) => [(a, Term b a)] -> a -> Term b a;
subst_of ss = foldr (\ (x, t) sigma -> subst_compose sigma (subst x t)) ss Var;

contains_var_term :: forall a b. (Eq a) => a -> Term b a -> Bool;
contains_var_term x (Var y) = x == y;
contains_var_term x (Fun uu ts) = any (contains_var_term x) ts;

subst_list ::
  forall a b.
    (a -> Term b a) -> [(Term b a, Term b a)] -> [(Term b a, Term b a)];
subst_list sigma ys =
  map (\ p -> (subst_apply_term (fst p) sigma, subst_apply_term (snd p) sigma))
    ys;

decompose ::
  forall a b c. (Eq a) => Term a b -> Term a c -> Maybe [(Term a b, Term a c)];
decompose s t =
  (case (s, t) of {
    (Var _, b) -> Nothing;
    (Fun f ss, Var _) -> Nothing;
    (Fun f ss, Fun g ts) -> (if f == g then zip_option ss ts else Nothing);
  });

unify ::
  forall a b.
    (Eq a,
      Eq b) => [(Term a b, Term a b)] ->
                 [(b, Term a b)] -> Maybe [(b, Term a b)];
unify [] bs = Just bs;
unify ((Fun f ss, Fun g ts) : e) bs =
  (case decompose (Fun f ss) (Fun g ts) of {
    Nothing -> Nothing;
    Just us -> unify (us ++ e) bs;
  });
unify ((Var x, t) : e) bs =
  (if equal_term t (Var x) then unify e bs
    else (if contains_var_term x t then Nothing
           else unify (subst_list (subst x t) e) ((x, t) : bs)));
unify ((Fun v va, Var x) : e) bs =
  (if contains_var_term x (Fun v va) then Nothing
    else unify (subst_list (subst x (Fun v va)) e) ((x, Fun v va) : bs));

mgu ::
  forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Maybe (b -> Term a b);
mgu s t =
  (case unify [(s, t)] [] of {
    Nothing -> Nothing;
    Just res -> Just (subst_of res);
  });

mgu_class ::
  forall a.
    (Eq a) => Term a (Sum () [Prelude.Char]) ->
                Term a [Prelude.Char] ->
                  Maybe ([Prelude.Char] -> Term a [Prelude.Char]);
mgu_class cs t = mgu (class_to_term 'z' cs) (map_vars (\ a -> 'y' : a) t);

partition :: forall a. (a -> Bool) -> [a] -> ([a], [a]);
partition p [] = ([], []);
partition p (x : xs) =
  let {
    (yes, no) = partition p xs;
  } in (if p x then (x : yes, no) else (yes, x : no));

removeAll :: forall a. (Eq a) => a -> [a] -> [a];
removeAll x [] = [];
removeAll x (y : xs) = (if x == y then removeAll x xs else y : removeAll x xs);

lookupb :: forall a b. (Corder a, Eq a) => Mapping a b -> a -> Maybe b;
lookupb (RBT_Mapping t) = lookupc t;
lookupb (Assoc_List_Mapping al) = lookupa al;

updateb :: forall a b. (Corder a, Eq a) => a -> b -> Mapping a b -> Mapping a b;
updateb k v (RBT_Mapping t) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "update RBT_Mapping: corder = None"
        (\ _ -> updateb k v (RBT_Mapping t));
    Just _ -> RBT_Mapping (insertd k v t);
  });
updateb k v (Assoc_List_Mapping al) = Assoc_List_Mapping (updatea k v al);
updateb k v (Mapping m) = Mapping (fun_upd m k (Just v));

match_term_list_code ::
  forall a b c.
    (Eq a, Corder b, Eq b,
      Eq c) => [(Term a b, Term a c)] ->
                 Mapping b (Term a c) -> Maybe (Mapping b (Term a c));
match_term_list_code ((Fun f ss, Var x) : p) sigma = Nothing;
match_term_list_code ((Fun f ss, Fun g ts) : p) sigma =
  (case decompose (Fun f ss) (Fun g ts) of {
    Nothing -> Nothing;
    Just us -> match_term_list_code (us ++ p) sigma;
  });
match_term_list_code ((Var x, t) : p) sigma =
  (if is_none (lookupb sigma x) || lookupb sigma x == Just t
    then match_term_list_code p (updateb x t sigma) else Nothing);
match_term_list_code [] sigma = Just sigma;

subst_of_map :: forall a b. (a -> b) -> (a -> Maybe b) -> a -> b;
subst_of_map d sigma x = (case sigma x of {
                           Nothing -> d x;
                           Just t -> t;
                         });

match_list ::
  forall a b c.
    (Corder a, Eq a, Mapping_impl a, Eq b,
      Eq c) => (a -> Term b c) ->
                 [(Term b a, Term b c)] -> Maybe (a -> Term b c);
match_list d p =
  map_option (subst_of_map d . lookupb) (match_term_list_code p emptyb);

match ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => Term a b -> Term a b -> Maybe (b -> Term a b);
match t l = match_list Var [(l, t)];

imagea ::
  forall a b.
    (Ceq a, Corder a, Ceq b, Corder b,
      Set_impl b) => Set (a, b) -> Set a -> Set b;
imagea (RBT_set rbt) c =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "Image RBT_set: corder1 = None" (\ _ -> imagea (RBT_set rbt) c);
    Just _ ->
      (case (corder :: Maybe (b -> b -> Bool, b -> b -> Bool)) of {
        Nothing ->
          error "Image RBT_set: corder2 = None" (\ _ -> imagea (RBT_set rbt) c);
        Just _ ->
          foldc (\ (x, y) acc -> (if member x c then inserta y acc else acc))
            rbt bot_set;
      });
  });
imagea (DList_set dxs) b =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "Image DList_set: ceq1 = None" (\ _ -> imagea (DList_set dxs) b);
    Just _ ->
      (case (ceq :: Maybe (b -> b -> Bool)) of {
        Nothing ->
          error "Image DList_set: ceq2 = None"
            (\ _ -> imagea (DList_set dxs) b);
        Just _ ->
          foldd (\ (x, y) acc -> (if member x b then inserta y acc else acc))
            dxs bot_set;
      });
  });
imagea (Set_Monad rxs) a =
  Set_Monad
    (fold (\ (x, y) rest -> (if member x a then y : rest else rest)) rxs []);
imagea x y = image snd (filtera (\ (xa, _) -> member xa y) x);

zero :: forall a b. Partial_object_ext a (Monoid_ext a (Ring_ext a b)) -> a;
zero (Partial_object_ext carrier (Monoid_ext mult one (Ring_ext zero add more)))
  = zero;

sharp_term :: forall a b. (a -> a) -> Term a b -> Term a b;
sharp_term shp (Var x) = Var x;
sharp_term shp (Fun f ss) = Fun (shp f) ss;

aarity :: forall a. (a -> Nat -> [a]) -> a -> Nat -> Nat;
aarity sm f n = minus_nat (size_list (sm f n)) (Nat_of_num One);

ctxt ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Ctxt a [Prelude.Char]);
ctxt xml2name x =
  options
    [(['b', 'o', 'x'], leaf ['b', 'o', 'x'] Hole),
      (['f', 'u', 'n', 'C', 'o', 'n', 't', 'e', 'x', 't'],
        tuple4 ['f', 'u', 'n', 'C', 'o', 'n', 't', 'e', 'x', 't'] xml2name
          (many ['b', 'e', 'f', 'o', 'r', 'e'] (term xml2name) id)
          (ctxt xml2name) (many ['a', 'f', 't', 'e', 'r'] (term xml2name) id)
          More)]
    x;

xml3to4elements ::
  forall a b c d e.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (a -> b -> Maybe c -> d -> e) -> Xml -> Sum_bot [Prelude.Char] e;
xml3to4elements tag p1 p2 p3 p4 f (XML name atts cs text) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts &&
               less_eq_nat (Nat_of_num (Bit1 One)) l &&
                 less_eq_nat l (Nat_of_num (Bit0 (Bit0 One))) && is_none text
         then binda (p1 (nth cs Zero_nat))
                (\ x1 ->
                  binda (p2 (nth cs (Nat_of_num One)))
                    (\ x2 ->
                      (if equal_nat l (Nat_of_num (Bit0 (Bit0 One)))
                        then binda (p3 (nth cs (Nat_of_num (Bit0 One))))
                               (\ x3 ->
                                 binda (p4 (nth cs (Nat_of_num (Bit1 One))))
                                   (\ x4 -> returna (f x1 x2 (Just x3) x4)))
                        else binda (p4 (nth cs (Nat_of_num (Bit0 One))))
                               (\ x4 -> returna (f x1 x2 Nothing x4)))))
         else fail tag (XML name atts cs text));

relstep ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                  (Bool, Term a [Prelude.Char])));
relstep xml2name =
  xml3to4elements ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 't', 'e', 'p'] pos
    (rule xml2name) (leaf ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e'] ())
    (term xml2name) (\ p r rel t -> (p, (r, (is_none rel, t))));

relsteps ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                     (Bool, Term a [Prelude.Char])))]);
relsteps xml2name =
  many1 ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c',
          'e']
    (singleton ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm'] (term xml2name) id)
    (relstep xml2name) (\ a b -> (a, b));

substa ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [([Prelude.Char], Term a [Prelude.Char])];
substa xml2name =
  many ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n']
    (pair ['s', 'u', 'b', 's', 't', 'E', 'n', 't', 'r', 'y']
      (text ['v', 'a', 'r']) (term xml2name) (\ a b -> (a, b)))
    id;

loop ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                      (Bool, Term a [Prelude.Char])))],
              ([([Prelude.Char], Term a [Prelude.Char])],
                Ctxt a [Prelude.Char])));
loop xml2name =
  triple ['l', 'o', 'o', 'p'] (relsteps xml2name) (substa xml2name)
    (ctxt xml2name) (\ (s, rseq) sigma c -> (s, (rseq, (sigma, c))));

proj ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (ProjL a);
proj xml2name =
  change (afs xml2name)
    (\ afl ->
      Projection
        (map (\ a ->
               (case a of {
                 (fa, Collapse aa) -> (fa, aa);
                 (fa, AFList _) -> (fa, snd fa);
               }))
          afl));

of_rat :: forall a. (Field_char_0 a) => Rat -> a;
of_rat p = let {
             (a, b) = quotient_of p;
           } in divide (of_inta a) (of_inta b);

real :: Xml -> Sum_bot [Prelude.Char] Real;
real x =
  catch (change rat of_rat x)
    (\ _ ->
      triple ['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c'] rat rat rat
        (\ a b c ->
          plus_real (of_rat a) (times_real (of_rat b) (sqrt (of_rat c))))
        x);

proj_term :: forall a b. ((a, Nat) -> Nat) -> Term a b -> Term a b;
proj_term p (Var x) = Var x;
proj_term p (Fun f ts) =
  let {
    n = size_list ts;
    i = p (f, n);
  } in (if less_nat i n then nth ts i else Fun f ts);

start_term ::
  forall a.
    (Eq a) => (Xml -> Sum_bot [Prelude.Char] a) ->
                Term a [Prelude.Char] ->
                  Xml -> Sum_bot [Prelude.Char] (Term a [Prelude.Char]);
start_term xml2name t =
  singleton ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm']
    (\ xml ->
      binda (term xml2name xml)
        (\ s ->
          (if equal_term s t then returna t
            else errora
                   ['<', 's', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm', '>', ' ',
                     'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                     'c', 'h', ' ', 'l', 'h', 's'])))
    id;

rstep ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                  Term a [Prelude.Char]));
rstep xml2name =
  triple ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 't', 'e', 'p'] pos
    (rule xml2name) (term xml2name) (\ p r t -> (p, (r, t)));

rseq ::
  forall a.
    (Eq a) => (Xml -> Sum_bot [Prelude.Char] a) ->
                ((a, Nat) -> Nat) ->
                  (Term a [Prelude.Char], Term a [Prelude.Char]) ->
                    Xml ->
                      Sum_bot [Prelude.Char]
                        ((Term a [Prelude.Char], Term a [Prelude.Char]),
                          [(Pos, ((Term a [Prelude.Char],
                                    Term a [Prelude.Char]),
                                   Term a [Prelude.Char]))]);
rseq xml2name pi r =
  many1 ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c',
          'e']
    (start_term xml2name (proj_term pi (fst r))) (rstep xml2name)
    (\ _ -> (\ a -> (r, a)));

supteq_list :: forall a b. Term a b -> [Term a b];
supteq_list (Var x) = [Var x];
supteq_list (Fun f ts) = Fun f ts : concatMap supteq_list ts;

matches ::
  forall a b c.
    (Eq a, Eq b, Corder c, Eq c,
      Mapping_impl c) => Term a b -> Term a c -> Bool;
matches t p =
  (case match_list (\ _ -> t) [(p, t)] of {
    Nothing -> False;
    Just _ -> True;
  });

is_NF ::
  forall a b.
    (Eq a, Key a, Corder b, Eq b,
      Mapping_impl b) => Bool ->
                           [Term a b] -> (a -> [Term a b]) -> Term a b -> Bool;
is_NF var_cond r m =
  (if var_cond then (\ _ -> False)
    else (if null r then (\ _ -> True)
           else (\ t ->
                  all (\ u ->
                        (if not (is_Var u)
                          then all (\ l -> not (matches u l))
                                 (m (fst (the (root u))))
                          else True))
                    (supteq_list t))));

label :: forall a b. Lab a b -> Nat -> Sum b [Lab a b] -> Lab a b;
label f n (Inl l) = Lab f l;
label f n (Inr l) = FunLab f l;

unlab :: forall a b. Lab a b -> Lab a b;
unlab (Lab f l) = f;
unlab (FunLab f l) = f;
unlab (UnLab v) = UnLab v;
unlab (Sharp v) = Sharp v;

rm_iterateoi ::
  forall a b c. Rbta a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
rm_iterateoi Emptya c f sigma = sigma;
rm_iterateoi (Branch col l k v r) c f sigma =
  (if c sigma
    then let {
           sigmaa = rm_iterateoi l c f sigma;
         } in (if c sigmaa then rm_iterateoi r c f (f (k, v) sigmaa)
                else sigmaa)
    else sigma);

iteratei_bmap_op_list_it_rm_basic_ops ::
  forall a b c.
    (Linorder a) => Rbt a b -> (c -> Bool) -> ((a, b) -> c -> c) -> c -> c;
iteratei_bmap_op_list_it_rm_basic_ops s = rm_iterateoi (impl_of s);

g_to_list_rm_basic_ops :: forall a b. (Linorder a) => Rbt a b -> [(a, b)];
g_to_list_rm_basic_ops m =
  iteratei_bmap_op_list_it_rm_basic_ops m (\ _ -> True) (\ a b -> a : b) [];

values :: forall a b. (Linorder a) => Rbt a [b] -> [b];
values m = concatMap snd (g_to_list_rm_basic_ops m);

single :: forall a. (Eq a) => a -> Multiset a;
single x = Bag (updatea x (Nat_of_num One) emptya);

ctxt_apply :: forall a b. Ctxt a b -> Term a b -> Term a b;
ctxt_apply Hole s = s;
ctxt_apply (More f ss1 c ss2) s = Fun f (ss1 ++ ctxt_apply c s : ss2);

funas_term ::
  forall a b. (Ceq a, Corder a, Set_impl a) => Term a b -> Set (a, Nat);
funas_term (Var uu) = bot_set;
funas_term (Fun f ts) =
  sup_set (inserta (f, size_list ts) bot_set)
    (foldr (sup_set . funas_term) ts bot_set);

hvf_top :: forall a b. (Eq a) => a -> Nat -> Term a b -> Bool;
hvf_top a n (Fun f ts) =
  (if f == a && equal_nat (size_list ts) n then not (is_Var (hd ts)) else True);
hvf_top a n (Var uu) = False;

crule ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ((Term a [Prelude.Char], Term a [Prelude.Char]),
            [(Term a [Prelude.Char], Term a [Prelude.Char])]);
crule xml2name =
  many1 ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'u', 'l',
          'e']
    (rule xml2name) (rule xml2name) (\ a b -> (a, b));

estep ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                  (Bool, Term a [Prelude.Char])));
estep xml2name =
  tuple4 ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'S', 't', 'e', 'p'] pos
    (rule xml2name)
    (options
      [(['l', 'e', 'f', 't', 'R', 'i', 'g', 'h', 't'],
         leaf ['l', 'e', 'f', 't', 'R', 'i', 'g', 'h', 't'] True),
        (['r', 'i', 'g', 'h', 't', 'L', 'e', 'f', 't'],
          leaf ['r', 'i', 'g', 'h', 't', 'L', 'e', 'f', 't'] False)])
    (term xml2name) (\ p r b t -> (p, (r, (b, t))));

rules ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char] [(Term a [Prelude.Char], Term a [Prelude.Char])];
rules xml2name = many ['r', 'u', 'l', 'e', 's'] (rule xml2name) id;

state :: Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
state = text ['s', 't', 'a', 't', 'e'];

isOK :: forall a b. Sum a b -> Bool;
isOK m = (case m of {
           Inl _ -> False;
           Inr _ -> True;
         });

mapM :: forall a b c. (a -> Sum b c) -> [a] -> Sum b [c];
mapM f [] = Inr [];
mapM f (x : xs) = bindb (f x) (\ y -> bindb (mapM f xs) (\ ys -> Inr (y : ys)));

one :: forall a b. Partial_object_ext a (Monoid_ext a b) -> a;
one (Partial_object_ext carrier (Monoid_ext mult one more)) = one;

list_update :: forall a. [a] -> Nat -> a -> [a];
list_update [] i y = [];
list_update (x : xs) i y =
  (if equal_nat i Zero_nat then y : xs
    else x : list_update xs (minus_nat i (Nat_of_num One)) y);

remdups_adj :: forall a. (Eq a) => [a] -> [a];
remdups_adj [] = [];
remdups_adj [x] = [x];
remdups_adj (x : y : xs) =
  (if x == y then remdups_adj (x : xs) else x : remdups_adj (y : xs));

base :: forall a. (a, Nat) -> a;
base (f, h) = f;

lift :: forall a. Nat -> a -> (a, Nat);
lift h f = (f, h);

roof :: forall a b. (Eq b) => (Term a b, Term a b) -> Term a b -> Bool;
roof (l, r) =
  let {
    xs = vars_term_list r;
  } in (\ t -> let {
                 xt = vars_term_list t;
               } in all (membera xt) xs);

vec :: forall a. Nat -> [a] -> Bool;
vec n x = equal_nat (size_list x) n;

mat :: forall a. Nat -> Nat -> [[a]] -> Bool;
mat nr nc m = equal_nat (size_list m) nc && all (vec nr) m;

eq_monom :: forall a. (Eq a) => [(a, Nat)] -> [(a, Nat)] -> Bool;
eq_monom [] n = null n;
eq_monom ((x, p) : m) n =
  (case extract (\ yq -> fst yq == x) n of {
    Nothing -> False;
    Just (n1, ((_, q), n2)) -> equal_nat p q && eq_monom m (n1 ++ n2);
  });

poly_split ::
  forall a b.
    (Eq a, Zero b) => [(a, Nat)] -> [([(a, Nat)], b)] -> (b, [([(a, Nat)], b)]);
poly_split m p =
  (case extract (\ (n, _) -> eq_monom m n) p of {
    Nothing -> (zeroa, p);
    Just (p1, ((_, c), p2)) -> (c, p1 ++ p2);
  });

max_v ::
  forall a b.
    (Zero a,
      Ord a) => a -> ((b, Nat) -> [([(Nat, Nat)], a)]) -> [(b, Nat)] -> a;
max_v v i fs =
  max v (foldr (\ f m -> max m (fst (poly_split [] (i f)))) fs zeroa);

to_list :: Pos -> [Nat];
to_list Empty = [];
to_list (PCons i p) = i : to_list p;

relcomp ::
  forall a b c.
    (Ceq a, Corder a, Set_impl a, Ceq b, Corder b, Ceq c, Corder c,
      Set_impl c) => Set (a, b) -> Set (b, c) -> Set (a, c);
relcomp (Set_Monad xs6) (DList_set dxs4) =
  (case ceq of {
    Nothing ->
      error "relcomp Set_Monad DList_set: ceq1 = None"
        (\ _ -> relcomp (Set_Monad xs6) (DList_set dxs4));
    Just eq ->
      (case (ceq :: Maybe (c -> c -> Bool)) of {
        Nothing ->
          error "relcomp Set_Monad DList_set: ceq2 = None"
            (\ _ -> relcomp (Set_Monad xs6) (DList_set dxs4));
        Just _ ->
          fold (\ (x, y) ->
                 foldd (\ (ya, z) a ->
                         (if eq y ya then inserta (x, z) a else a))
                   dxs4)
            xs6 bot_set;
      });
  });
relcomp (DList_set dxs3) (Set_Monad xs5) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "relcomp DList_set Set_Monad: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs3) (Set_Monad xs5));
    Just _ ->
      (case ceq of {
        Nothing ->
          error "relcomp DList_set Set_Monad: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs3) (Set_Monad xs5));
        Just eq ->
          foldd (\ (x, y) ->
                  fold (\ (ya, z) a ->
                         (if eq y ya then inserta (x, z) a else a))
                    xs5)
            dxs3 bot_set;
      });
  });
relcomp (Set_Monad xs4) (RBT_set rbt5) =
  (case (corder :: Maybe (c -> c -> Bool, c -> c -> Bool)) of {
    Nothing ->
      error "relcomp Set_Monad RBT_set: corder1 = None"
        (\ _ -> relcomp (Set_Monad xs4) (RBT_set rbt5));
    Just _ ->
      (case corder of {
        Nothing ->
          error "relcomp Set_Monad RBT_set: corder2 = None"
            (\ _ -> relcomp (Set_Monad xs4) (RBT_set rbt5));
        Just (_, lt_b) ->
          fold (\ (x, y) ->
                 foldc (\ (ya, z) a ->
                         (if lt_b y ya || lt_b ya y then a
                           else inserta (x, z) a))
                   rbt5)
            xs4 bot_set;
      });
  });
relcomp (RBT_set rbt1) (Set_Monad xs3) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "relcomp RBT_set Set_Monad: corder1 = None"
        (\ _ -> relcomp (RBT_set rbt1) (Set_Monad xs3));
    Just _ ->
      (case corder of {
        Nothing ->
          error "relcomp RBT_set Set_Monad: corder2 = None"
            (\ _ -> relcomp (RBT_set rbt1) (Set_Monad xs3));
        Just (_, lt_b) ->
          foldc (\ (x, y) ->
                  fold (\ (ya, z) a ->
                         (if lt_b y ya || lt_b ya y then a
                           else inserta (x, z) a))
                    xs3)
            rbt1 bot_set;
      });
  });
relcomp (Set_Monad xs1) (Set_Monad xs2) =
  (case ceq of {
    Nothing ->
      error "relcomp Set_Monad Set_Monad: ceq = None"
        (\ _ -> relcomp (Set_Monad xs1) (Set_Monad xs2));
    Just eq ->
      fold (\ (x, y) ->
             fold (\ (ya, z) a -> (if eq y ya then inserta (x, z) a else a))
               xs2)
        xs1 bot_set;
  });
relcomp (DList_set dxs3) (DList_set dxs4) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "relcomp DList_set DList_set: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
    Just _ ->
      (case ceq of {
        Nothing ->
          error "relcomp DList_set DList_set: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
        Just eq ->
          (case (ceq :: Maybe (c -> c -> Bool)) of {
            Nothing ->
              error "relcomp DList_set DList_set: ceq3 = None"
                (\ _ -> relcomp (DList_set dxs3) (DList_set dxs4));
            Just _ ->
              foldd (\ (x, y) ->
                      foldd (\ (ya, z) a ->
                              (if eq y ya then inserta (x, z) a else a))
                        dxs4)
                dxs3 bot_set;
          });
      });
  });
relcomp (DList_set dxs2) (RBT_set rbt4) =
  (case (ceq :: Maybe (a -> a -> Bool)) of {
    Nothing ->
      error "relcomp DList_set RBT_set: ceq1 = None"
        (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
    Just _ ->
      (case (corder :: Maybe (b -> b -> Bool, b -> b -> Bool)) of {
        Nothing ->
          error "relcomp DList_set RBT_set: ceq2 = None"
            (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
        Just _ ->
          (case ceq of {
            Nothing ->
              error "relcomp DList_set RBT_set: corder2 = None"
                (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
            Just eq ->
              (case (corder :: Maybe (c -> c -> Bool, c -> c -> Bool)) of {
                Nothing ->
                  error "relcomp DList_set RBT_set: corder3 = None"
                    (\ _ -> relcomp (DList_set dxs2) (RBT_set rbt4));
                Just _ ->
                  foldd (\ (x, y) ->
                          foldc (\ (ya, z) a ->
                                  (if eq y ya then inserta (x, z) a else a))
                            rbt4)
                    dxs2 bot_set;
              });
          });
      });
  });
relcomp (RBT_set rbt3) (DList_set dxs1) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "relcomp RBT_set DList_set: corder1 = None"
        (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
    Just _ ->
      (case (corder :: Maybe (b -> b -> Bool, b -> b -> Bool)) of {
        Nothing ->
          error "relcomp RBT_set DList_set: corder2 = None"
            (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
        Just _ ->
          (case ceq of {
            Nothing ->
              error "relcomp RBT_set DList_set: ceq2 = None"
                (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
            Just eq ->
              (case (ceq :: Maybe (c -> c -> Bool)) of {
                Nothing ->
                  error "relcomp RBT_set DList_set: ceq3 = None"
                    (\ _ -> relcomp (RBT_set rbt3) (DList_set dxs1));
                Just _ ->
                  foldc (\ (x, y) ->
                          foldd (\ (ya, z) a ->
                                  (if eq y ya then inserta (x, z) a else a))
                            dxs1)
                    rbt3 bot_set;
              });
          });
      });
  });
relcomp (RBT_set rbt1) (RBT_set rbt2) =
  (case (corder :: Maybe (a -> a -> Bool, a -> a -> Bool)) of {
    Nothing ->
      error "relcomp RBT_set RBT_set: corder1 = None"
        (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
    Just _ ->
      (case corder of {
        Nothing ->
          error "relcomp RBT_set RBT_set: corder2 = None"
            (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
        Just (_, lt_b) ->
          (case (corder :: Maybe (c -> c -> Bool, c -> c -> Bool)) of {
            Nothing ->
              error "relcomp RBT_set RBT_set: corder3 = None"
                (\ _ -> relcomp (RBT_set rbt1) (RBT_set rbt2));
            Just _ ->
              foldc (\ (x, y) ->
                      foldc (\ (ya, z) a ->
                              (if lt_b y ya || lt_b ya y then a
                                else inserta (x, z) a))
                        rbt2)
                rbt1 bot_set;
          });
      });
  });

shows_lines :: forall a. (Showa a) => [a] -> [Prelude.Char] -> [Prelude.Char];
shows_lines = shows_sep (shows_prec Zero_nat) shows_nl;

map_sum :: forall a b c d. (a -> b) -> (c -> d) -> Sum a c -> Sum b d;
map_sum f1 f2 (Inl a) = Inl (f1 a);
map_sum f1 f2 (Inr a) = Inr (f2 a);

linear_term_impl ::
  forall a b. (Ceq a, Corder a) => Set a -> Term b a -> Maybe (Set a);
linear_term_impl xs (Var x) =
  (if member x xs then Nothing else Just (inserta x xs));
linear_term_impl xs (Fun uu []) = Just xs;
linear_term_impl xs (Fun f (t : ts)) =
  (case linear_term_impl xs t of {
    Nothing -> Nothing;
    Just ys -> linear_term_impl ys (Fun f ts);
  });

linear_term :: forall a b. (Ceq b, Corder b, Set_impl b) => Term a b -> Bool;
linear_term t = not (is_none (linear_term_impl bot_set t));

map_term_wa :: forall a b c. ((a, Nat) -> b) -> Term a c -> Term b c;
map_term_wa fg (Var x) = Var x;
map_term_wa fg (Fun f ts) =
  Fun (fg (f, size_list ts)) (map (map_term_wa fg) ts);

newline :: Prelude.Char;
newline = '\n';

ctxt_of_pos_term :: forall a b. Pos -> Term a b -> Ctxt a b;
ctxt_of_pos_term Empty t = Hole;
ctxt_of_pos_term (PCons i ps) (Fun f ts) =
  More f (take i ts) (ctxt_of_pos_term ps (nth ts i))
    (drop (plus_nat i (Nat_of_num One)) ts);

poss_list :: forall a b. Term a b -> [Pos];
poss_list (Var x) = [Empty];
poss_list (Fun f ss) =
  Empty :
    concatMap (\ (i, a) -> map (PCons i) a)
      (zip (upt Zero_nat (size_list ss)) (map poss_list ss));

rewrite ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> [Term a b];
rewrite r s =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ p ->
          (case match (subt_at s p) l of {
            Nothing -> [];
            Just sigma ->
              [ctxt_apply (ctxt_of_pos_term p s) (subst_apply_term ra sigma)];
          }))
        (poss_list s))
    r;

hvf_term :: forall a b. (Eq a) => a -> Term a b -> Bool;
hvf_term a t =
  (case unapp a t of {
    (Var _, ts) -> null ts;
    (Fun _ us, ts) -> all (hvf_term a) (us ++ ts);
  });

max_list :: [Nat] -> Nat;
max_list [] = Zero_nat;
max_list (x : xs) = max x (max_list xs);

num_children :: Xml -> Nat;
num_children (XML uu uv cs uw) = size_list cs;

map_default :: forall a b. (Eq a) => a -> b -> (b -> b) -> [(a, b)] -> [(a, b)];
map_default k v f [] = [(k, v)];
map_default k v f (p : ps) =
  (if fst p == k then (k, f (snd p)) : ps else p : map_default k v f ps);

crules ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]),
             [(Term a [Prelude.Char], Term a [Prelude.Char])])];
crules xml2name =
  many ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'u', 'l',
         'e', 's']
    (crule xml2name) id;

string ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] [a];
string xml2name = many ['s', 't', 'r', 'i', 'n', 'g'] xml2name id;

oc_srs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ([a], [a]);
oc_srs xml2name =
  pair ['o', 'v', 'e', 'r', 'l', 'a', 'p', 'C', 'l', 'o', 's', 'u', 'r', 'e',
         'S', 'R', 'S']
    (string xml2name) (string xml2name) (\ a b -> (a, b));

rsteps ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                     Term a [Prelude.Char]))]);
rsteps xml2name =
  many1 ['r', 'e', 'w', 'r', 'i', 't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c',
          'e']
    (singleton ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm'] (term xml2name) id)
    (rstep xml2name) (\ a b -> (a, b));

check :: forall a. Bool -> a -> Sum a ();
check b e = (if b then Inr () else Inl e);

degree :: Complexity_class -> Nat;
degree (Comp_Poly d) = d;

catcha :: forall a b c. Sum a b -> (a -> Sum c b) -> Sum c b;
catcha m f = (case m of {
               Inl a -> f a;
               Inr a -> Inr a;
             });

forallM :: forall a b. (a -> Sum b ()) -> [a] -> Sum (a, b) ();
forallM f [] = Inr ();
forallM f (x : xs) =
  bindb (catcha (f x) (\ xa -> Inl (x, xa))) (\ _ -> forallM f xs);

check_edges ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ((a, a) -> Bool) ->
        [a] -> [a] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_edges ss g c d =
  catcha
    (forallM
      (\ n ->
        catcha
          (forallM
            (\ m ->
              check (not (g (m, n)))
                (shows_string
                   ['e', 'd', 'g', 'e', ' ', 'f', 'r', 'o', 'm', ' '] .
                  ss m . shows_string [' ', 't', 'o', ' '] . ss n))
            d)
          (\ x -> Inl (snd x)))
      c)
    (\ x -> Inl (snd x));

mult :: forall a b. Partial_object_ext a (Monoid_ext a b) -> a -> a -> a;
mult (Partial_object_ext carrier (Monoid_ext mult one more)) = mult;

matcha :: forall a b. (Term a b, Term a b) -> Term a b -> Bool;
matcha = (\ _ _ -> True);

fresh_strings_list ::
  [Prelude.Char] -> Nat -> [[Prelude.Char]] -> Nat -> [[Prelude.Char]];
fresh_strings_list name offset used n =
  take n
    (filter (\ s -> not (membera (remdups used) s))
      (map (\ i -> name ++ shows_prec_nat Zero_nat (plus_nat i offset) [])
        (upt Zero_nat (plus_nat n (size_list (remdups used))))));

fresh_string :: [Prelude.Char] -> [[Prelude.Char]] -> [Prelude.Char];
fresh_string pre =
  (\ s -> hd (fresh_strings_list pre (Nat_of_num One) s (Nat_of_num One)));

mapMa :: forall a b. (a -> Maybe b) -> [a] -> Maybe [b];
mapMa f [] = Just [];
mapMa f (x : xs) =
  bind (f x) (\ y -> bind (mapMa f xs) (\ ys -> Just (y : ys)));

equal_order_tag :: Order_tag -> Order_tag -> Bool;
equal_order_tag Lex Mul = False;
equal_order_tag Mul Lex = False;
equal_order_tag Mul Mul = True;
equal_order_tag Lex Lex = True;

any_nstri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> (Bool, b);
any_nstri_efficient_m f [] m = (False, m);
any_nstri_efficient_m f (a : asa) m =
  let {
    (aa, b) = f a m;
  } in let {
         (_, ns) = aa;
       } in (\ ma ->
              (if ns then (True, ma) else any_nstri_efficient_m f asa ma))
         b;

all_stri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> (Bool, b);
all_stri_efficient_m f [] m = (True, m);
all_stri_efficient_m f (a : asa) m =
  let {
    (aa, b) = f a m;
  } in let {
         (s, _) = aa;
       } in (\ ma -> (if s then all_stri_efficient_m f asa ma else (False, ma)))
         b;

filter_not_stri_efficient_m_aux ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ([a], b);
filter_not_stri_efficient_m_aux f [] bs m = (bs, m);
filter_not_stri_efficient_m_aux f (a : asa) bs m =
  let {
    (b, c) = f a m;
  } in let {
         (s, _) = b;
       } in (\ ma ->
              (if s then filter_not_stri_efficient_m_aux f asa bs ma
                else filter_not_stri_efficient_m_aux f asa (a : bs) ma))
         c;

filter_not_stri_efficient_m ::
  forall a b. (a -> b -> ((Bool, Bool), b)) -> [a] -> b -> ([a], b);
filter_not_stri_efficient_m f asa m =
  let {
    (ys, a) = filter_not_stri_efficient_m_aux f asa [] m;
  } in (reverse ys, a);

mul_ext_efficient_m ::
  forall a b.
    (Eq a) => (a -> a -> b -> ((Bool, Bool), b)) ->
                [a] -> [a] -> b -> ((Bool, Bool), b);
mul_ext_efficient_m f [] [] m = ((False, True), m);
mul_ext_efficient_m f [] (v : va) m = ((False, False), m);
mul_ext_efficient_m f (v : va) [] m = ((True, True), m);
mul_ext_efficient_m f (v : va) (y : ys) m =
  ex_dom_efficient_m f y (v : va) (v : va) ys m;

ex_dom_efficient_m ::
  forall a b.
    (Eq a) => (a -> a -> b -> ((Bool, Bool), b)) ->
                a -> [a] -> [a] -> [a] -> b -> ((Bool, Bool), b);
ex_dom_efficient_m f y [] uw ux m = ((False, False), m);
ex_dom_efficient_m f y (b : bs) xs ys m =
  let {
    (a, c) = f b y m;
  } in let {
         (s, ns) = a;
       } in (\ ma ->
              (if s then let {
                           (ysa, m2) = filter_not_stri_efficient_m (f b) ys ma;
                           (aa, ba) =
                             mul_ext_efficient_m f (remove1 b xs) ysa m2;
                         } in let {
                                (_, ns1) = aa;
                              } in (\ m3 ->
                                     (if ns1 then ((True, True), m3)
                                       else ex_dom_efficient_m f y bs xs ys m3))
                                ba
                else (if ns
                       then let {
                              (aa, ba) =
                                mul_ext_efficient_m f (remove1 b xs) ys ma;
                            } in let {
                                   (s1, ns1) = aa;
                                 } in (\ mb ->
(if s1 then ((True, True), mb)
  else let {
         (ab, bb) = ex_dom_efficient_m f y bs xs ys mb;
       } in let {
              (s2, ns2) = ab;
            } in (\ m3 ->
                   (if s2 then ((True, True), m3)
                     else ((False, ns1 || ns2), m3)))
              bb))
                                   ba
                       else ex_dom_efficient_m f y bs xs ys ma)))
         c;

lex_ext_efficient_m ::
  forall a b.
    (a -> a -> b -> ((Bool, Bool), b)) -> [a] -> [a] -> b -> ((Bool, Bool), b);
lex_ext_efficient_m f [] [] m = ((False, True), m);
lex_ext_efficient_m f (uu : uv) [] m = ((True, True), m);
lex_ext_efficient_m f [] (uw : ux) m = ((False, False), m);
lex_ext_efficient_m f (a : asa) (b : bs) m =
  let {
    (aa, ba) = f a b m;
  } in let {
         (s, ns) = aa;
       } in (\ ma ->
              (if s then ((True, True), ma)
                else (if ns then lex_ext_efficient_m f asa bs ma
                       else ((False, False), ma))))
         ba;

lookupd :: forall a b c d. Memory_ext a b c d -> a -> b -> Maybe c;
lookupd (Memory_ext empty lookup store more) = lookup;

store :: forall a b c d. Memory_ext a b c d -> a -> (b, c) -> a;
store (Memory_ext empty lookup store more) = store;

diag_l :: forall a b. (a, b) -> ((a, a), b);
diag_l (a, b) = ((a, a), b);

rpo_efficient_m ::
  forall a b c.
    (Eq b,
      Eq c) => Memory_ext a (Term b c, Term b c) (Bool, Bool) () ->
                 (b -> Nat -> b -> Nat -> (Bool, Bool), b -> Bool) ->
                   (b -> Nat -> Order_tag) ->
                     Term b c -> Term b c -> a -> ((Bool, Bool), a);
rpo_efficient_m model pr tag s t m =
  (case lookupd model m (s, t) of {
    Nothing ->
      let {
        (res, res_m) =
          (case (s, t) of {
            (Var x, Var y) -> ((False, x == y), m);
            (Var x, Fun g ts) -> ((False, null ts && snd pr g), m);
            (Fun f ss, Var y) ->
              diag_l
                (any_nstri_efficient_m
                  (\ sa -> rpo_efficient_m model pr tag sa (Var y)) ss m);
            (Fun f ss, Fun g ts) ->
              (case any_nstri_efficient_m
                      (\ sa -> rpo_efficient_m model pr tag sa (Fun g ts)) ss m
                of {
                (True, ma) -> ((True, True), ma);
                (False, ma) ->
                  let {
                    maa = size_list ss;
                    n = size_list ts;
                  } in (case fst pr f maa g n of {
                         (prs, True) ->
                           (case all_stri_efficient_m
                                   (rpo_efficient_m model pr tag (Fun f ss)) ts
                                   ma
                             of {
                             (True, mb) ->
                               (if prs then ((True, True), mb)
                                 else let {
cf = tag f maa;
                                      } in
(if equal_order_tag cf (tag g n)
  then (if equal_order_tag cf Mul
         then mul_ext_efficient_m (rpo_efficient_m model pr tag) ss ts mb
         else lex_ext_efficient_m (rpo_efficient_m model pr tag) ss ts mb)
  else let {
         b = equal_nat n Zero_nat;
       } in ((not (equal_nat maa Zero_nat) && b, b), mb)));
                             (False, mb) -> ((False, False), mb);
                           });
                         (prs, False) -> ((False, False), ma);
                       });
              });
          });
      } in (res, store model res_m ((s, t), res));
    Just v -> (v, m);
  });

emptye :: forall a b c d. Memory_ext a b c d -> () -> a;
emptye (Memory_ext empty lookup store more) = empty;

efficient_rpo_2 ::
  forall a b.
    (Eq a,
      Eq b) => (a -> Nat -> a -> Nat -> (Bool, Bool), a -> Bool) ->
                 (a -> Nat -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
efficient_rpo_2 pr tag p q =
  fst (rpo_efficient_m l2m pr tag p q (emptye l2m ()));

rpo_unbounded_impl ::
  forall a b.
    (Eq a,
      Eq b) => (a -> Nat -> a -> Nat -> (Bool, Bool), a -> Bool) ->
                 (a -> Nat -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
rpo_unbounded_impl = efficient_rpo_2;

rpo_unbounded ::
  forall a b.
    (Eq a,
      Eq b) => (a -> Nat -> a -> Nat -> (Bool, Bool), a -> Bool) ->
                 (a -> Nat -> Order_tag) ->
                   Term a b -> Term a b -> (Bool, Bool);
rpo_unbounded = rpo_unbounded_impl;

converse ::
  forall a b.
    (Ceq a, Corder a, Set_impl a, Ceq b, Corder b,
      Set_impl b) => Set (a, b) -> Set (b, a);
converse r = image (\ (x, y) -> (y, x)) r;

shows_concat ::
  [[Prelude.Char] -> [Prelude.Char]] -> [Prelude.Char] -> [Prelude.Char];
shows_concat [] = id;
shows_concat (s : ss) = s . shows_concat ss;

subt_at_ctxt :: forall a b. Ctxt a b -> Pos -> Ctxt a b;
subt_at_ctxt c Empty = c;
subt_at_ctxt (More f bef c aft) (PCons i p) = subt_at_ctxt c p;

the_Var :: forall a b. Term a b -> b;
the_Var (Var x1) = x1;

in_poss :: forall a b. Pos -> Term a b -> Bool;
in_poss Empty uu = True;
in_poss (PCons i p) (Fun f ts) =
  less_nat i (size_list ts) && in_poss p (nth ts i);
in_poss (PCons i p) (Var uv) = False;

instance_rule ::
  forall a b c.
    (Eq a, Eq b, Corder c, Eq c,
      Mapping_impl c) => (Term a b, Term a b) -> (Term a c, Term a c) -> Bool;
instance_rule lr st =
  not (is_none
        (match_list (\ _ -> fst lr) [(fst st, fst lr), (snd st, snd lr)]));

label_depth :: forall a b. Lab a b -> Nat;
label_depth (UnLab uu) = Zero_nat;
label_depth (Lab f uv) = plus_nat (label_depth f) (Nat_of_num One);
label_depth (FunLab f uw) = plus_nat (label_depth f) (Nat_of_num One);
label_depth (Sharp f) = plus_nat (label_depth f) (Nat_of_num One);

gen_label :: forall a b. Lab a b -> Nat -> Lab a b;
gen_label f n =
  (if equal_nat n Zero_nat then f
    else FunLab (gen_label f (minus_nat n (Nat_of_num One))) []);

fmap ::
  forall a b.
    (Eq a,
      Eq b) => Lab a b ->
                 Nat ->
                   [((Lab a b, Nat), [Lab a b])] -> Lab a b -> Nat -> Lab a b;
fmap a nn sml =
  let {
    m = plus_nat (max_list (map label_depth (a : concatMap snd sml)))
          (Nat_of_num One);
  } in (\ f n -> (if (f, n) == (a, nn) then a else gen_label f m));

enum_vectors :: forall a b. [a] -> [b] -> [[(b, a)]];
enum_vectors c [] = [[]];
enum_vectors c (x : xs) =
  let {
    a = enum_vectors c xs;
  } in concatMap (\ vec -> map (\ ca -> (x, ca) : vec) c) a;

replace_impl :: forall a. (Eq a) => a -> [a] -> [a] -> [a];
replace_impl a bs m =
  (if membera m a then bs ++ filter (\ b -> not (b == a)) m else m);

doc_of_string :: [Prelude.Char] -> Sum [Prelude.Char] Xmldoc;
doc_of_string s = bindb (parse_doc s) (\ (doc, _) -> Inr doc);

pat_eqv_prf ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Pat_eqv_prf a [Prelude.Char]);
pat_eqv_prf xml2name =
  let {
    sub = substa xml2name;
  } in singleton
         ['p', 'a', 't', 't', 'e', 'r', 'n', 'E', 'q', 'u', 'i', 'v', 'a', 'l',
           'e', 'n', 'c', 'e']
         (options
           [(['d', 'o', 'm', 'a', 'i', 'n', 'R', 'e', 'n', 'a', 'm', 'i', 'n',
               'g'],
              singleton
                ['d', 'o', 'm', 'a', 'i', 'n', 'R', 'e', 'n', 'a', 'm', 'i',
                  'n', 'g']
                sub Pat_Dom_Renaming),
             (['i', 'r', 'r', 'e', 'l', 'e', 'v', 'a', 'n', 't'],
               pair ['i', 'r', 'r', 'e', 'l', 'e', 'v', 'a', 'n', 't'] sub sub
                 Pat_Irrelevant),
             (['s', 'i', 'm', 'p', 'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o',
                'n'],
               pair ['s', 'i', 'm', 'p', 'l', 'i', 'f', 'i', 'c', 'a', 't', 'i',
                      'o', 'n']
                 sub sub Pat_Simplify)])
         id;

pat_term ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Term a [Prelude.Char],
            ([([Prelude.Char], Term a [Prelude.Char])],
              [([Prelude.Char], Term a [Prelude.Char])]));
pat_term xml2name =
  triple ['p', 'a', 't', 't', 'e', 'r', 'n', 'T', 'e', 'r', 'm'] (term xml2name)
    (substa xml2name) (substa xml2name) (\ t s1 s2 -> (t, (s1, s2)));

pat_rule_prf ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Pat_rule_prf a [Prelude.Char]);
pat_rule_prf xml2name x =
  let {
    pat = pat_rule_prf xml2name;
    sub = substa xml2name;
    pt = pat_term xml2name;
    var = text ['v', 'a', 'r'];
  } in triple ['p', 'a', 't', 't', 'e', 'r', 'n', 'R', 'u', 'l', 'e'] pt pt
         (options
           [(['o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', 'R', 'u', 'l', 'e'],
              pair ['o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', 'R', 'u', 'l', 'e']
                (rule xml2name) (bool ['i', 's', 'P', 'a', 'i', 'r'])
                Pat_OrigRule),
             (['i', 'n', 'i', 't', 'i', 'a', 'l', 'P', 'u', 'm', 'p', 'i', 'n',
                'g'],
               triple
                 ['i', 'n', 'i', 't', 'i', 'a', 'l', 'P', 'u', 'm', 'p', 'i',
                   'n', 'g']
                 pat sub sub Pat_InitPump),
             (['i', 'n', 'i', 't', 'i', 'a', 'l', 'P', 'u', 'm', 'p', 'i', 'n',
                'g', 'C', 'o', 'n', 't', 'e', 'x', 't'],
               tuple4
                 ['i', 'n', 'i', 't', 'i', 'a', 'l', 'P', 'u', 'm', 'p', 'i',
                   'n', 'g', 'C', 'o', 'n', 't', 'e', 'x', 't']
                 pat sub pos var Pat_InitPumpCtxt),
             (['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e'],
               triple ['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e']
                 pat (options
                       [(['l', 'e', 'f', 't'], leaf ['l', 'e', 'f', 't'] True),
                         (['r', 'i', 'g', 'h', 't'],
                           leaf ['r', 'i', 'g', 'h', 't'] False)])
                 (pat_eqv_prf xml2name) Pat_Equiv),
             (['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g'],
               triple ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g'] pat pat pos
                 Pat_Narrow),
             (['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n'],
               triple
                 ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o',
                   'n']
                 pat sub
                 (options
                   [(['b', 'a', 's', 'e'], leaf ['b', 'a', 's', 'e'] Pat_Base),
                     (['p', 'u', 'm', 'p', 'i', 'n', 'g'],
                       leaf ['p', 'u', 'm', 'p', 'i', 'n', 'g'] Pat_Pump),
                     (['c', 'l', 'o', 's', 'i', 'n', 'g'],
                       leaf ['c', 'l', 'o', 's', 'i', 'n', 'g'] Pat_Close)])
                 Pat_Inst),
             (['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                'P', 'u', 'm', 'p', 'i', 'n', 'g'],
               pair ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o',
                      'n', 'P', 'u', 'm', 'p', 'i', 'n', 'g']
                 pat (nata ['p', 'o', 'w', 'e', 'r']) Pat_Exp_Sigma),
             (['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g'],
               triple ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g'] pat
                 (rsteps xml2name)
                 (options
                   [(['b', 'a', 's', 'e'],
                      leaf ['b', 'a', 's', 'e'] (Pat_Base, [])),
                     (['p', 'u', 'm', 'p', 'i', 'n', 'g'],
                       singleton ['p', 'u', 'm', 'p', 'i', 'n', 'g'] var
                         (\ a -> (Pat_Pump, a))),
                     (['c', 'l', 'o', 's', 'i', 'n', 'g'],
                       singleton ['c', 'l', 'o', 's', 'i', 'n', 'g'] var
                         (\ a -> (Pat_Close, a)))])
                 (\ p seq (a, b) -> Pat_Rewr p seq a b))])
         (\ _ _ z -> z) x;

nonloop ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Non_loop_prf a [Prelude.Char]);
nonloop xml2name =
  tuple6 ['n', 'o', 'n', 'L', 'o', 'o', 'p'] (pat_rule_prf xml2name)
    (substa xml2name) (substa xml2name)
    (nata ['n', 'a', 't', 'u', 'r', 'a', 'l'])
    (nata ['n', 'a', 't', 'u', 'r', 'a', 'l']) pos Non_loop_prf;

xml_lab :: forall a b. (Showa a, Showa b) => Lab a [b] -> Xml;
xml_lab (UnLab x) =
  XML ['n', 'a', 'm', 'e'] [] [] (Just (shows_prec Zero_nat x []));
xml_lab (Sharp x) = XML ['s', 'h', 'a', 'r', 'p'] [] [xml_lab x] Nothing;
xml_lab (FunLab x l) =
  XML ['l', 'a', 'b', 'e', 'l', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l'] []
    [xml_lab x,
      XML ['s', 'y', 'm', 'b', 'o', 'l', 'L', 'a', 'b', 'e', 'l'] []
        (map xml_lab l) Nothing]
    Nothing;
xml_lab (Lab x l) =
  XML ['l', 'a', 'b', 'e', 'l', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l'] []
    [xml_lab x,
      XML ['n', 'u', 'm', 'b', 'e', 'r', 'L', 'a', 'b', 'e', 'l'] []
        (map (\ n ->
               XML ['n', 'u', 'm', 'b', 'e', 'r'] [] []
                 (Just (shows_prec Zero_nat n [])))
          l)
        Nothing]
    Nothing;

xml_single_pos :: Nat -> Xml;
xml_single_pos i =
  XML ['p', 'o', 's', 'i', 't', 'i', 'o', 'n'] [] []
    (Just (shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) []));

xml_pos :: Pos -> Xml;
xml_pos p =
  XML ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', 'I', 'n', 'T', 'e', 'r', 'm'] []
    (map xml_single_pos (to_list p)) Nothing;

eq_set ::
  forall a. (Card_UNIV a, Cenum a, Ceq a, Corder a) => Set a -> Set a -> Bool;
eq_set = set_eq;

rules_no_left_vara :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
rules_no_left_vara
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_no_left_var;

rules_mapb ::
  forall a b c d.
    Dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
rules_mapb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_map;

capRM_dpp ::
  forall a b c.
    (Eq b, Eq c) => Dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
capRM_dpp i dpp = capRM (rules_no_left_vara i dpp) (rules_mapb i dpp);

elem_list_to_rm :: forall a b. (Linorder b) => (a -> b) -> [a] -> Rbt b [a];
elem_list_to_rm key (d : ds) =
  let {
    rm = elem_list_to_rm key ds;
    k = key d;
  } in (case lookup rm k of {
         Nothing -> insert k [d] rm;
         Just dataa -> insert k (d : dataa) rm;
       });
elem_list_to_rm key [] = empty;

fun_of_map :: forall a b. (a -> Maybe b) -> b -> a -> b;
fun_of_map m d a = (case m a of {
                     Nothing -> d;
                     Just b -> b;
                   });

term_map :: forall a b. (Key a) => [Term a b] -> a -> [Term a b];
term_map ts = fun_of_map (lookup (elem_list_to_rm ((fst . the) . root) ts)) [];

min :: forall a. (Ord a) => a -> a -> a;
min a b = (if less_eq a b then a else b);

min_list :: forall a. (Linorder a) => [a] -> a;
min_list [x] = x;
min_list (x : v : va) = min x (min_list (v : va));

height :: forall a. (a, Nat) -> Nat;
height (f, h) = h;

vec0I :: forall a. a -> Nat -> [a];
vec0I ze n = replicate n ze;

mat0I :: forall a. a -> Nat -> Nat -> [[a]];
mat0I ze nr nc = replicate nc (vec0I ze nr);

vec1I :: forall a. a -> a -> Nat -> Nat -> [a];
vec1I ze on n i =
  replicate i ze ++
    on : replicate (minus_nat (minus_nat n (Nat_of_num One)) i) ze;

mat1I :: forall a. a -> a -> Nat -> [[a]];
mat1I ze on n = map (vec1I ze on n) (upt Zero_nat n);

check_poly_ge ::
  forall a b.
    (Eq a,
      Ordered_semiring_0 b) => [([(a, Nat)], b)] -> [([(a, Nat)], b)] -> Bool;
check_poly_ge [] q = all (\ (_, d) -> less_eq d zeroa) q;
check_poly_ge ((m, c) : p) q =
  (case extract (\ nd -> eq_monom (fst nd) m) q of {
    Nothing -> less_eq zeroa c && check_poly_ge p q;
    Just (q1, ((_, d), q2)) -> less_eq d c && check_poly_ge p (q1 ++ q2);
  });

check_poly_gt ::
  forall a b.
    (Ordered_semiring_0 a,
      Eq b) => (a -> a -> Bool) ->
                 [([(b, Nat)], a)] -> [([(b, Nat)], a)] -> Bool;
check_poly_gt gt p q =
  let {
    (a1, p1) = poly_split [] p;
    (b1, q1) = poly_split [] q;
  } in gt a1 b1 && check_poly_ge p1 q1;

shows_monom ::
  forall a. (Showa a) => [(a, Nat)] -> [Prelude.Char] -> [Prelude.Char];
shows_monom [(x, p)] =
  (if equal_nat p (Nat_of_num One) then shows_prec Zero_nat x
    else shows_prec Zero_nat x .
           shows_string ['^'] . shows_prec_nat Zero_nat p);
shows_monom ((x, p) : v : va) =
  (if equal_nat p (Nat_of_num One) then shows_prec Zero_nat x
    else shows_prec Zero_nat x .
           shows_string ['^'] . shows_prec_nat Zero_nat p) .
    shows_string ['*'] . shows_monom (v : va);
shows_monom [] = shows_string ['1'];

shows_poly ::
  forall a b.
    (Showa a, Eq b, Poly_carrier b,
      Showa b) => [([(a, Nat)], b)] -> [Prelude.Char] -> [Prelude.Char];
shows_poly [] = shows_string ['0'];
shows_poly ((m, c) : p) =
  (if c == onea then shows_monom m
    else (if null m then shows_prec Zero_nat c
           else shows_prec Zero_nat c . shows_string ['*'] . shows_monom m)) .
    (if null p then shows_string []
      else shows_string [' ', '+', ' '] . shows_poly p);

monom_mult :: forall a. (Eq a) => [(a, Nat)] -> [(a, Nat)] -> [(a, Nat)];
monom_mult [] n = n;
monom_mult ((x, p) : m) n =
  (case extract (\ yq -> fst yq == x) n of {
    Nothing -> (x, p) : monom_mult m n;
    Just (n1, ((_, q), n2)) -> (x, plus_nat p q) : monom_mult m (n1 ++ n2);
  });

monom_mult_poly ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => ([(a, Nat)], b) ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
monom_mult_poly uu [] = [];
monom_mult_poly (ma, c) ((m, d) : p) =
  (if times c d == zeroa then monom_mult_poly (ma, c) p
    else (monom_mult ma m, times c d) : monom_mult_poly (ma, c) p);

poly_add ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
poly_add [] q = q;
poly_add ((m, c) : p) q =
  (case extract (\ mc -> eq_monom (fst mc) m) q of {
    Nothing -> (m, c) : poly_add p q;
    Just (q1, ((_, d), q2)) ->
      (if plus c d == zeroa then poly_add p (q1 ++ q2)
        else (m, plus c d) : poly_add p (q1 ++ q2));
  });

poly_mult ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] ->
                         [([(a, Nat)], b)] -> [([(a, Nat)], b)];
poly_mult [] q = [];
poly_mult (mc : p) q = poly_add (monom_mult_poly mc q) (poly_mult p q);

one_poly :: forall a b. (Semiring_1 b) => [([(a, Nat)], b)];
one_poly = [([], onea)];

poly_power ::
  forall a b.
    (Eq a, Eq b,
      Comm_semiring_1 b) => [([(a, Nat)], b)] -> Nat -> [([(a, Nat)], b)];
poly_power uu n =
  (if equal_nat n Zero_nat then one_poly
    else poly_mult uu (poly_power uu (minus_nat n (Nat_of_num One))));

monom_subst ::
  forall a b c.
    (Eq b, Eq c,
      Comm_semiring_1 c) => (a -> [([(b, Nat)], c)]) ->
                              [(a, Nat)] -> [([(b, Nat)], c)];
monom_subst sigma [] = one_poly;
monom_subst sigma ((x, p) : m) =
  poly_mult (poly_power (sigma x) p) (monom_subst sigma m);

zero_poly :: forall a b. [([(a, Nat)], b)];
zero_poly = [];

poly_subst ::
  forall a b c.
    (Eq b, Eq c,
      Comm_semiring_1 c) => (a -> [([(b, Nat)], c)]) ->
                              [([(a, Nat)], c)] -> [([(b, Nat)], c)];
poly_subst sigma [] = zero_poly;
poly_subst sigma ((m, c) : p) =
  poly_add (poly_mult [([], c)] (monom_subst sigma m)) (poly_subst sigma p);

eval_term ::
  forall a b c.
    (Eq b, Poly_carrier b,
      Eq c) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                 Term a c -> [([(c, Nat)], b)];
eval_term uu (Var x) = [([(x, Nat_of_num One)], onea)];
eval_term i (Fun f ts) =
  let {
    ps = map (eval_term i) ts;
    n = size_list ts;
  } in poly_subst (\ ia -> (if less_nat ia n then nth ps ia else zero_poly))
         (i (f, n));

check_s ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Showa b, Eq c,
      Showa c) => (a -> a -> Bool) ->
                    ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                      (Term b c, Term b c) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_s gt i =
  (\ (s, t) ->
    let {
      p = eval_term i s;
      q = eval_term i t;
    } in check (check_poly_gt gt p q)
           (shows_string
              ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
                'u', 'r', 'e', ' '] .
             shows_prec_term Zero_nat s .
               shows_string [' ', '>', ' '] .
                 shows_prec_term Zero_nat t .
                   shows_string
                     [' ', 's', 'i', 'n', 'c', 'e', ' ', 'w', 'e', ' '] .
                     shows_nl .
                       shows_string
                         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e',
                           'n', 's', 'u', 'r', 'e', ' '] .
                         shows_poly p .
                           shows_string [' ', '>', ' '] . shows_poly q));

poly_of ::
  forall a b. (Eq a, Eq b, Comm_semiring_1 b) => Tpoly a b -> [([(a, Nat)], b)];
poly_of (PNum i) = (if i == zeroa then [] else [([], i)]);
poly_of (PVar x) = [([(x, Nat_of_num One)], onea)];
poly_of (PSum []) = zero_poly;
poly_of (PSum (p : ps)) = poly_add (poly_of p) (poly_of (PSum ps));
poly_of (PMult []) = one_poly;
poly_of (PMult (p : ps)) = poly_mult (poly_of p) (poly_of (PMult ps));

shows_pos :: Pos -> [Prelude.Char] -> [Prelude.Char];
shows_pos (PCons i Empty) =
  shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One));
shows_pos (PCons i (PCons v va)) =
  shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) .
    shows_pos (PCons v va);
shows_pos Empty = shows_string ['e', 'p', 's', 'i', 'l', 'o', 'n'];

shows_rpo_repr ::
  forall a.
    (Showa a) => [((a, Nat), (Nat, Order_tag))] ->
                   [Prelude.Char] -> [Prelude.Char];
shows_rpo_repr prs =
  shows_string
    ['R', 'P', 'O', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'e', ' ', 'f', 'o',
      'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'p', 'r', 'e', 'c', 'e', 'd', 'e',
      'n', 'c', 'e'] .
    shows_nl .
      shows_map
        (\ (a, b) ->
          let {
            (f, n) = a;
          } in (\ (pr, _) ->
                 shows_string
                   ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', '('] .
                   shows_prec Zero_nat f .
                     shows_string ['['] .
                       shows_prec_nat Zero_nat n .
                         shows_string [']', ')', ' ', '=', ' '] .
                           shows_prec_nat Zero_nat pr . shows_nl)
            b)
        prs .
        shows_nl .
          shows_string
            ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', '(', '_', ')',
              ' ', '=', ' ', '0'] .
            shows_nl .
              shows_string
                ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                  'o', 'w', 'i', 'n', 'g', ' ', 's', 't', 'a', 't', 'u', 's'] .
                shows_nl .
                  shows_map
                    (\ (a, b) ->
                      let {
                        (f, n) = a;
                      } in (\ (_, s) ->
                             shows_string ['s', 't', 'a', 't', 'u', 's', '('] .
                               shows_prec Zero_nat f .
                                 shows_string ['['] .
                                   shows_prec_nat Zero_nat n .
                                     shows_string [']', ')', ' ', '=', ' '] .
                                       shows_string
 (case s of {
   Lex -> ['l', 'e', 'x'];
   Mul -> ['m', 'u', 'l'];
 }) .
 shows_nl)
                        b)
                    prs .
                    shows_nl .
                      shows_string
                        ['s', 't', 'a', 't', 'u', 's', '(', '_', ')', ' ', '=',
                          ' ', 'l', 'e', 'x'] .
                        shows_nl;

scnp_af_to_af ::
  forall a.
    ((a, Nat) -> [(Nat, Nat)]) ->
      ((a, Nat) -> Nat -> Bool) -> (a, Nat) -> Nat -> Bool;
scnp_af_to_af pia pi =
  (\ (f, n) ->
    let {
      is = map fst (pia (f, n));
    } in (if any (less_eq_nat n) is
           then let {
                  isa = pi (f, n);
                } in (\ i -> isa i || membera is i)
           else membera is));

mk_subst ::
  forall a b c. (Eq a) => (a -> Term b c) -> [(a, Term b c)] -> a -> Term b c;
mk_subst d xts =
  (\ x -> (case map_of xts x of {
            Nothing -> d x;
            Just t -> t;
          }));

mk_subst_domain ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)];
mk_subst_domain sigma =
  let {
    tau = mk_subst Var sigma;
  } in filter (\ (x, t) -> not (equal_term (Var x) t))
         (map (\ x -> (x, tau x)) (remdups (map fst sigma)));

subst_eq ::
  forall a b.
    (Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b,
      Linorder b) => [(a, Term b a)] -> [(a, Term b a)] -> Bool;
subst_eq sigma tau =
  let {
    sigmaa = mk_subst_domain sigma;
    taua = mk_subst_domain tau;
  } in set_eq (set sigmaa) (set taua);

full_af :: forall a. (a, Nat) -> Nat -> Bool;
full_af fn i = True;

apply_args :: forall a b. a -> Term a b -> [Term a b] -> Term a b;
apply_args a t [] = t;
apply_args a t (s : ss) = apply_args a (Fun a [t, s]) ss;

get_symbol :: forall a. (a -> Nat -> [a]) -> a -> Nat -> Nat -> a;
get_symbol sm f n i = nth (sm f n) i;

xml2nd_choice ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        [Prelude.Char] ->
          (Xml -> Sum_bot [Prelude.Char] b) ->
            (a -> Maybe b -> c) -> Xml -> Sum_bot [Prelude.Char] c;
xml2nd_choice tag p1 cn p2 f (XML name atts cs text) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts && less_eq_nat (Nat_of_num (Bit0 One)) l && is_none text
         then binda (p1 (nth cs Zero_nat))
                (\ x1 ->
                  binda (bool cn (nth cs (Nat_of_num One)))
                    (\ b ->
                      (if b then binda (p2
 (nth cs (minus_nat l (Nat_of_num One))))
                                   (\ x2 -> returna (f x1 (Just x2)))
                        else returna (f x1 Nothing))))
         else fail tag (XML name atts cs text));

sum_lpoly ::
  forall a.
    Partial_object_ext a (Monoid_ext a (Ring_ext a ())) -> [a] -> [a] -> [a];
sum_lpoly c [] ys = ys;
sum_lpoly c (v : va) [] = v : va;
sum_lpoly c (x : xs) (y : ys) = add c x y : sum_lpoly c xs ys;

lpoly_of ::
  forall a.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a ())) ->
                Tpoly Nat a -> Sum_bot [Prelude.Char] (a, [a]);
lpoly_of c (PNum i) = returna (i, []);
lpoly_of c (PVar x) = returna (zero c, replicate x (zero c) ++ [one c]);
lpoly_of c (PSum []) = returna (zero c, []);
lpoly_of c (PSum (p : ps)) =
  binda (lpoly_of c p)
    (\ (cp, ncp) ->
      binda (lpoly_of c (PSum ps))
        (\ (cq, ncq) -> returna (add c cp cq, sum_lpoly c ncp ncq)));
lpoly_of c (PMult []) = returna (one c, []);
lpoly_of c (PMult (p : ps)) =
  binda (lpoly_of c p)
    (\ (cp, ncp) ->
      binda (lpoly_of c (PMult ps))
        (\ (cq, ncq) ->
          (if all (\ a -> zero c == a) ncp
            then returna (mult c cp cq, map (mult c cp) ncq)
            else (if all (\ a -> zero c == a) ncq
                   then returna (mult c cp cq, map (\ x -> mult c x cq) ncp)
                   else errora
                          ['c', 'a', 'n', 'n', 'o', 't', ' ', 't', 'r', 'a',
                            'n', 's', 'f', 'o', 'r', 'm', ' ', 'n', 'o', 'n',
                            '-', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'p', 'o',
                            'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 't',
                            'o', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'p',
                            'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']))));

renaming ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] [(a, a)];
renaming xml2name =
  many ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g']
    (pair ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', 'E', 'n', 't', 'r', 'y']
      xml2name xml2name (\ a b -> (a, b)))
    id;

innermostLhss ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [Term a [Prelude.Char]];
innermostLhss xml2name =
  many ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's']
    (term xml2name) id;

strategy ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Strategy a [Prelude.Char]);
strategy xml2name =
  singleton ['s', 't', 'r', 'a', 't', 'e', 'g', 'y']
    (options
      [(['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'],
         leaf ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'] Innermost),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's'],
          change (innermostLhss xml2name) Innermost_Q)])
    id;

xml_term ::
  forall a b c. (Showa a, Showa b, Showa c) => Term (Lab a [b]) c -> Xml;
xml_term (Var x) = XML ['v', 'a', 'r'] [] [] (Just (shows_prec Zero_nat x []));
xml_term (Fun f ts) =
  XML ['f', 'u', 'n', 'a', 'p', 'p'] []
    (xml_lab f : map (\ t -> XML ['a', 'r', 'g'] [] [xml_term t] Nothing) ts)
    Nothing;

xml_rule ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (Term (Lab a [b]) c, Term (Lab a [b]) c) -> Xml;
xml_rule =
  (\ (l, r) ->
    XML ['r', 'u', 'l', 'e'] []
      [XML ['l', 'h', 's'] [] [xml_term l] Nothing,
        XML ['r', 'h', 's'] [] [xml_term r] Nothing]
      Nothing);

subset ::
  forall a. (Card_UNIV a, Cenum a, Ceq a, Corder a) => Set a -> Set a -> Bool;
subset = subset_eq;

existsM :: forall a b. (a -> Sum b ()) -> [a] -> Sum [b] ();
existsM f [] = Inl [];
existsM f (x : xs) =
  catcha (f x) (\ e -> catcha (existsM f xs) (\ xa -> Inl (e : xa)));

nF_subset ::
  forall a b.
    (Eq a, Corder b, Eq b, Mapping_impl b) => [Term a b] -> [Term a b] -> Bool;
nF_subset ls q =
  all (\ l -> any (\ t -> any (\ u -> matches u t) (supteq_list l)) q) ls;

icap_impl ::
  forall a.
    (Eq a) => Bool ->
                (Term a [Prelude.Char] -> Bool) ->
                  [Term a [Prelude.Char]] ->
                    [Term a [Prelude.Char]] ->
                      ([Prelude.Char] -> Bool) ->
                        Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char]);
icap_impl nf isQnf ls s sx (Var x) =
  (if nf && sx x then Var (Inr x) else Var (Inl ()));
icap_impl nf isQnf ls s sx (Fun f ts) =
  let {
    t = Fun f (map (icap_impl nf isQnf ls s sx) ts);
  } in (if any (\ l ->
                 (case mgu_class t l of {
                   Nothing -> False;
                   Just mu ->
                     all (\ u ->
                           isQnf (subst_apply_term (map_vars (\ a -> 'y' : a) u)
                                   mu))
                       (args l) &&
                       all (\ u -> isQnf (subst_apply_term u mu)) s;
                 }))
             ls
         then Var (Inl ()) else t);

lex_ext_unbounded ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
lex_ext_unbounded f [] [] = (False, True);
lex_ext_unbounded f (uu : uv) [] = (True, True);
lex_ext_unbounded f [] (uw : ux) = (False, False);
lex_ext_unbounded f (a : asa) (b : bs) =
  (case f a b of {
    (True, nstri) -> (True, True);
    (False, True) -> lex_ext_unbounded f asa bs;
    (False, False) -> (False, False);
  });

zero_multiset :: forall a. Multiset a;
zero_multiset = Bag emptya;

join_raw ::
  forall a b. (Eq a) => (a -> (b, b) -> b) -> [(a, b)] -> [(a, b)] -> [(a, b)];
join_raw f xs ys =
  foldr (\ (k, v) -> map_default k v (\ va -> f k (va, v))) ys xs;

joina ::
  forall a b.
    (Eq a) => (a -> (b, b) -> b) -> Alist a b -> Alist a b -> Alist a b;
joina xc xd xe = Alist (join_raw xc (impl_ofa xd) (impl_ofa xe));

plus_multiset :: forall a. (Eq a) => Multiset a -> Multiset a -> Multiset a;
plus_multiset (Bag xs) (Bag ys) =
  Bag (joina (\ _ (a, b) -> plus_nat a b) xs ys);

fold_impl :: forall a b. (a -> Nat -> b -> b) -> b -> [(a, Nat)] -> b;
fold_impl fn e ((a, n) : ms) = fold_impl fn (fn a n e) ms;
fold_impl fn e [] = e;

folde :: forall a b. (a -> Nat -> b -> b) -> b -> Alist a Nat -> b;
folde f e al = fold_impl f e (impl_ofa al);

union_mset :: forall a. (Eq a) => Multiset (Multiset a) -> Multiset a;
union_mset (Bag ms) =
  folde (\ a n -> funpow n (plus_multiset a)) zero_multiset ms;

multiset_of :: forall a. (Eq a) => [a] -> Multiset a;
multiset_of (a : x) = plus_multiset (multiset_of x) (single a);
multiset_of [] = zero_multiset;

vars_term_ms :: forall a b. (Eq b) => Term a b -> Multiset b;
vars_term_ms (Var x) = single x;
vars_term_ms (Fun f ts) = union_mset (multiset_of (map vars_term_ms ts));

listsum :: forall a. (Monoid_add a) => [a] -> a;
listsum xs = foldr plus xs zeroa;

weight ::
  forall a b.
    ((a, Nat) -> Nat) -> Nat -> ((a, Nat) -> Nat -> Nat) -> Term a b -> Nat;
weight w w0 scf (Fun f ts) =
  let {
    n = size_list ts;
    scff = scf (f, n);
  } in plus_nat (w (f, n))
         (listsum
           (map (\ (ti, i) -> times_nat (weight w w0 scf ti) (scff i))
             (zip ts (upt Zero_nat n))));
weight w w0 scf (Var x) = w0;

kbo_impl ::
  forall a b.
    (Eq b) => ((a, Nat) -> Nat) ->
                Nat ->
                  ((a, Nat) -> Nat) ->
                    (a -> Bool) ->
                      ((a, Nat) -> Nat -> Nat) ->
                        Term a b -> Term a b -> (Bool, Bool);
kbo_impl w w0 prc least scf s t =
  let {
    wt = weight w w0 scf t;
    ws = weight w w0 scf s;
  } in (if less_eq_multiset (vars_term_ms (scf_term scf t))
             (vars_term_ms (scf_term scf s)) &&
             less_eq_nat wt ws
         then (if less_nat wt ws then (True, True)
                else (case s of {
                       Var _ ->
                         (False,
                           (case t of {
                             Var _ -> True;
                             Fun g ts -> null ts && least g;
                           }));
                       Fun f ss ->
                         (case t of {
                           Var _ -> (True, True);
                           Fun g ts ->
                             let {
                               pf = prc (f, size_list ss);
                               pg = prc (g, size_list ts);
                             } in (if less_nat pg pf then (True, True)
                                    else (if less_eq_nat pg pf
   then lex_ext_unbounded (kbo_impl w w0 prc least scf) ss ts
   else (False, False)));
                         });
                     }))
         else (False, False));

kbo_strict ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ((a, Nat) -> Nat) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        (a -> Bool) ->
                          ((a, Nat) -> Nat -> Nat) ->
                            (Term a b, Term a b) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
kbo_strict pr w w0 least scf =
  (\ (s, t) ->
    check (fst (kbo_impl w w0 pr least scf s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term Zero_nat s .
          shows_string [' ', '>', 'K', 'B', 'O', ' '] .
            shows_prec_term Zero_nat t . shows_nl));

list_diff :: forall a. (Eq a) => [a] -> [a] -> [a];
list_diff [] ys = [];
list_diff (x : xs) ys =
  let {
    zs = list_diff xs ys;
  } in (if membera ys x then zs else x : zs);

eval :: forall a b c. (a -> [b] -> b) -> (c -> b) -> Term a c -> b;
eval i alpha (Var x) = alpha x;
eval i alpha (Fun f ts) = i f (map (eval i alpha) ts);

poly_vars_list :: forall a b. (Eq a) => [([(a, Nat)], b)] -> [a];
poly_vars_list p = remdups (concatMap (map fst . fst) p);

concat_lists :: forall a. [[a]] -> [[a]];
concat_lists [] = [[]];
concat_lists (asa : xs) =
  concatMap (\ vec -> map (\ a -> a : vec) asa) (concat_lists xs);

square_possibilities ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => (a -> [a]) -> [([(b, Nat)], a)] -> [[([(b, Nat)], a)]];
square_possibilities sqrt p =
  let {
    roots =
      map (\ x ->
            map (\ a -> (x, a))
              (sqrt (fst (poly_split [(x, Nat_of_num (Bit0 One))] p))))
        (poly_vars_list p);
    choices = (if membera roots [] then [] else concat_lists roots);
    polys =
      map (\ xas ->
            poly_of (PSum (map (\ (x, a) -> PMult [PVar x, PNum a]) xas)))
        choices;
  } in polys;

check_poly_eq ::
  forall a b.
    (Eq a, Eq b,
      Semiring_0 b) => [([(a, Nat)], b)] -> [([(a, Nat)], b)] -> Bool;
check_poly_eq [] q = null q;
check_poly_eq ((m, c) : p) q =
  (case extract (\ nd -> eq_monom (fst nd) m) q of {
    Nothing -> False;
    Just (q1, ((_, d), q2)) -> c == d && check_poly_eq p (q1 ++ q2);
  });

monom_degree :: forall a. [(a, Nat)] -> Nat;
monom_degree xps = listsum (map snd xps);

poly_degree :: forall a b. [([(a, Nat)], b)] -> Nat;
poly_degree p = max_list (map (\ (m, _) -> monom_degree m) p);

check_quadratic ::
  forall a.
    (Eq a,
      Poly_carrier a) => (a -> [a]) ->
                           [([(Nat, Nat)], a)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quadratic sqrt p =
  bindb (check (equal_nat (poly_degree p) (Nat_of_num (Bit0 One)))
          (shows_prec_list Zero_nat
            ['n', 'o', 't', ' ', 'q', 'u', 'a', 'd', 'r', 'a', 't', 'i', 'c']))
    (\ _ ->
      let {
        polys = square_possibilities sqrt p;
      } in check (any (\ q -> check_poly_eq (poly_mult q q) p) polys)
             (shows_prec_list Zero_nat
               ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
                 'd', ' ', 'q', 'u', 'a', 'd', 'r', 'a', 't', 'i', 'c', ' ',
                 'p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']));

check_quadratic_ge_const ::
  forall a b c.
    (Eq a, Poly_carrier a,
      Eq c) => (a -> [a]) ->
                 ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                   (Term b c, Term b c) ->
                     Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quadratic_ge_const sq i st =
  let {
    (s, t) = st;
  } in bindb (check (not (is_Var s))
               (shows_prec_list Zero_nat
                 ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'n', 'o', 'n', '-',
                   'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's',
                   ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's']))
         (\ _ ->
           let {
             pt = eval_term i t;
             (c, p0) = poly_split [] pt;
           } in bindb (check (p0 == zero_poly)
                        (shows_prec_list Zero_nat
                          ['r', 'h', 's', ' ', 'm', 'u', 's', 't', ' ', 'e',
                            'v', 'a', 'l', 'u', 'a', 't', 'e', ' ', 't', 'o',
                            ' ', 'c', 'o', 'n', 's', 't', 'a', 'n', 't']))
                  (\ _ ->
                    let {
                      ps = i (the (root s));
                      (d, psx) = poly_split [] ps;
                    } in bindb (check (less_eq c d)
                                 (shows_prec_list Zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                     'n', ' ', 'c', 'o', 'm', 'p', 'a', 'r',
                                     'i', 'n', 'g', ' ', 'c', 'o', 'n', 's',
                                     't', 'a', 'n', 't', 's']))
                           (\ _ -> check_quadratic sq psx)));

check_ns ::
  forall a b c.
    (Showa a, Eq b, Poly_carrier b, Showa b, Eq c,
      Showa c) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                    (Term a c, Term a c) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ns i =
  (\ (s, t) ->
    let {
      p = eval_term i s;
      q = eval_term i t;
    } in check (check_poly_ge p q)
           (shows_string
              ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's',
                'u', 'r', 'e', ' '] .
             shows_prec_term Zero_nat s .
               shows_string [' ', '>', '=', ' '] .
                 shows_prec_term Zero_nat t .
                   shows_string
                     [' ', 's', 'i', 'n', 'c', 'e', ' ', 'w', 'e', ' '] .
                     shows_nl .
                       shows_string
                         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e',
                           'n', 's', 'u', 'r', 'e', ' '] .
                         shows_poly p .
                           shows_string [' ', '>', '=', ' '] . shows_poly q));

check_cc ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Showa b, Eq c,
      Showa c) => (a -> [a]) ->
                    (a -> a -> Bool) ->
                      ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                        C_constraint b c ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cc sq gt i (Unconditional_C False st) =
  (if isOK (check_quadratic_ge_const sq i st) then Inr () else check_ns i st);
check_cc sq gt i (Unconditional_C True st) = check_s gt i st;
check_cc sq gt i (Conditional_C True (u, v) (s, t)) =
  let {
    ss = eval_term i s;
    tt = eval_term i t;
    uu = eval_term i u;
    vv = eval_term i v;
  } in (if check_poly_gt gt ss tt then Inr ()
         else check (check_poly_ge (poly_add ss vv) (poly_add tt uu))
                (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                     's', 'u', 'r', 'e', ' '] .
                  shows_prec_term Zero_nat u .
                    shows_string [' ', '>', ' '] .
                      shows_prec_term Zero_nat v .
                        shows_string [' ', '=', '=', '>', ' '] .
                          shows_prec_term Zero_nat s .
                            shows_string [' ', '>', ' '] .
                              shows_prec_term Zero_nat t));
check_cc sq gt i (Conditional_C False (u, v) (s, t)) =
  (if isOK (check_quadratic_ge_const sq i (s, t)) then Inr ()
    else let {
           ss = eval_term i s;
           tt = eval_term i t;
           uu = eval_term i u;
           vv = eval_term i v;
         } in (if check_poly_ge ss tt then Inr ()
                else check (check_poly_ge (poly_add ss vv) (poly_add tt uu))
                       (shows_string
                          ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                            'e', 'n', 's', 'u', 'r', 'e', ' '] .
                         shows_prec_term Zero_nat u .
                           shows_string [' ', '>', '=', ' '] .
                             shows_prec_term Zero_nat v .
                               shows_string [' ', '=', '=', '>', ' '] .
                                 shows_prec_term Zero_nat s .
                                   shows_string [' ', '>', '=', ' '] .
                                     shows_prec_term Zero_nat t)));

is_left_of :: Pos -> Pos -> Bool;
is_left_of Empty q = False;
is_left_of (PCons i p) q =
  (case q of {
    Empty -> False;
    PCons j qa ->
      (if less_nat i j then True
        else (if less_nat j i then False else is_left_of p qa));
  });

pos_prefix :: Pos -> Pos -> Maybe Pos;
pos_prefix Empty q = Just q;
pos_prefix (PCons i p) q =
  (case q of {
    Empty -> Nothing;
    PCons j qa -> (if equal_nat i j then pos_prefix p qa else Nothing);
  });

pos_suffix :: Pos -> Pos -> Maybe Pos;
pos_suffix p q =
  (case pos_prefix (rev p) (rev q) of {
    Nothing -> Nothing;
    Just qa -> Just (rev qa);
  });

sqrt_real :: Real -> [Real];
sqrt_real x =
  (if is_rat x && less_eq_real zero_real x
    then (if equal_real x zero_real then [zero_real]
           else let {
                  sx = sqrt x;
                } in [sx, uminus_real sx])
    else []);

rules_with ::
  forall a b c.
    (Linorder b) => (a -> Bool) ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        [(Term b c, Term b c)];
rules_with p m =
  map_filter (\ x -> (if (p . fst) x then Just (snd x) else Nothing))
    (values m);

scnp_desc ::
  forall a.
    (Showa a) => [((a, Nat), [(Nat, Nat)])] ->
                   [Prelude.Char] -> [Prelude.Char] -> [Prelude.Char];
scnp_desc af mu =
  shows_prec_list Zero_nat
    ['S', 'C', 'N', 'P', '-', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'w', 'i',
      't', 'h', ' ', 'm', 'u', ' ', '=', ' '] .
    shows_prec_list Zero_nat mu .
      shows_prec_list Zero_nat
        [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'l', 'e', 'v', 'e', 'l',
          ' ', 'm', 'a', 'p', 'p', 'i', 'n', 'g', ' ', 'd', 'e', 'f', 'i', 'n',
          'e', 'd', ' ', 'b', 'y', ' '] .
        shows_nl .
          shows_sep
            (\ (a, b) ->
              let {
                (f, n) = a;
              } in (\ asa ->
                     shows_prec_list Zero_nat ['p', 'i', '('] .
                       shows_prec Zero_nat f .
                         shows_prec_list Zero_nat [')', ' ', '=', ' '] .
                           shows_list_aux
                             (\ (p, l) ->
                               shows_prec_list Zero_nat ['('] .
                                 (if less_nat p n
                                   then shows_prec_nat Zero_nat
  (plus_nat p (Nat_of_num One))
                                   else shows_prec_list Zero_nat
  ['e', 'p', 's', 'i', 'l', 'o', 'n']) .
                                   shows_prec_list Zero_nat [','] .
                                     shows_prec_nat Zero_nat l .
                                       shows_prec_list Zero_nat [')'])
                             asa)
                b)
            shows_nl af .
            shows_nl;

split_rulesb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_rulesb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = split_rules;

delete_R_Rwb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_R_Rwb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = delete_R_Rw;

nfsb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
nfsb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
       rules_map delete_R_Rw split_rules mk nfs more)
  = nfs;

mkb ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      Bool ->
        [Term b c] -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
      rules_map delete_R_Rw split_rules mk nfs more)
  = mk;

qb :: forall a b c d. Tp_ops_ext a b c d -> a -> [Term b c];
qb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
     delete_R_Rw split_rules mk nfs more)
  = q;

split_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () -> a -> [(Term b c, Term b c)] -> (a, a);
split_tt i tp r_remove =
  let {
    (r, rw) = split_rulesb i tp r_remove;
    tp1 = mkb i (nfsb i tp) (qb i tp) r rw;
    a = delete_R_Rwb i tp r_remove r_remove;
  } in (tp1, a);

supt_impl :: forall a b. (Eq a, Eq b) => Term a b -> Term a b -> Bool;
supt_impl (Var x) t = False;
supt_impl (Fun f ss) t = membera ss t || any (\ s -> supt_impl s t) ss;

r_rhs :: forall a b. Ta_rule a b -> a;
r_rhs (TA_rule f qs q) = q;

r_sym :: forall a b. Ta_rule a b -> (b, Nat);
r_sym (TA_rule f qs q) = (f, size_list qs);

shows_rule ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          (Term a b, Term a b) -> [Prelude.Char] -> [Prelude.Char];
shows_rule fun var arr (l, r) =
  shows_term fun var l . shows_string arr . shows_term fun var r;

shows_rules ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          [(Term a b, Term a b)] -> [Prelude.Char] -> [Prelude.Char];
shows_rules fun var arr trs =
  shows_list_gen (shows_rule fun var arr) [] [] [newline] [] trs . shows_nl;

shows_trs ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] ->
          [Prelude.Char] ->
            [(Term a b, Term a b)] -> [Prelude.Char] -> [Prelude.Char];
shows_trs fun var name arr r =
  shows_string name . shows_nl . shows_nl . shows_rules fun var arr r;

aarity_term ::
  forall a b. (Eq a) => a -> (a -> Nat -> [a]) -> Term a b -> Maybe Nat;
aarity_term a sm t =
  (case unapp a t of {
    (Var _, ts) -> Nothing;
    (Fun f ss, ts) ->
      Just (minus_nat (aarity sm f (size_list ss)) (size_list ts));
  });

uncurry_top ::
  forall a b. (Eq a) => a -> Nat -> (a -> Nat -> [a]) -> Term a b -> Term a b;
uncurry_top a n sm (Fun f ts) =
  let {
    mt = map (map_term_wa (\ (fa, na) -> get_symbol sm fa na Zero_nat));
    (h, m) = the (root (hd ts));
  } in (if f == a &&
             equal_nat (size_list ts) n &&
               not (is_Var (hd ts)) && not (equal_nat (aarity sm h m) Zero_nat)
         then let {
                (Fun g ss) = hd ts;
              } in Fun (get_symbol sm g (size_list ss) (Nat_of_num One))
                     (mt (ss ++ tl ts))
         else Fun (let {
                     (fa, na) = (f, size_list ts);
                   } in get_symbol sm fa na Zero_nat)
                (mt ts));
uncurry_top a n sm (Var x) = Var x;

arith_fun :: Xml -> Sum_bot [Prelude.Char] ArithFun;
arith_fun xml =
  singleton ['a', 'r', 'i', 't', 'h', 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n']
    (options
      [(['n', 'a', 't', 'u', 'r', 'a', 'l'],
         change (nata ['n', 'a', 't', 'u', 'r', 'a', 'l']) Const),
        (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'],
          change (nata ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'])
            (\ n -> Arg (minus_nat n (Nat_of_num One)))),
        (['s', 'u', 'm'], many ['s', 'u', 'm'] arith_fun Sum),
        (['p', 'r', 'o', 'd', 'u', 'c', 't'],
          many ['p', 'r', 'o', 'd', 'u', 'c', 't'] arith_fun Prod),
        (['m', 'i', 'n'], many ['m', 'i', 'n'] arith_fun Min),
        (['m', 'a', 'x'], many ['m', 'a', 'x'] arith_fun Max),
        (['i', 'f', 'E', 'q', 'u', 'a', 'l'],
          tuple4 ['i', 'f', 'E', 'q', 'u', 'a', 'l'] arith_fun arith_fun
            arith_fun arith_fun IfEqual)])
    id xml;

int_coeff :: Xml -> Sum_bot [Prelude.Char] Int;
int_coeff = int ['i', 'n', 't', 'e', 'g', 'e', 'r'];

vec_coeff ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) -> Xml -> Sum_bot [Prelude.Char] [a];
vec_coeff xml2coeff =
  many ['v', 'e', 'c', 't', 'o', 'r']
    (singleton ['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't'] xml2coeff
      id)
    id;

mat_coeff ::
  forall a.
    a -> (Xml -> Sum_bot [Prelude.Char] a) ->
           Xml -> Sum_bot [Prelude.Char] [[a]];
mat_coeff ze xml2coeff =
  options
    [(['m', 'a', 't', 'r', 'i', 'x'],
       many ['m', 'a', 't', 'r', 'i', 'x'] (vec_coeff xml2coeff) id),
      (['v', 'e', 'c', 't', 'o', 'r'],
        change (vec_coeff xml2coeff)
          (\ v ->
            v : replicate (minus_nat (size_list v) (Nat_of_num One))
                  (replicate (size_list v) ze)))];

plain_var :: Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
plain_var x = text ['v', 'a', 'r'] x;

precedence_weight ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Nat -> ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat));
precedence_weight xml2name =
  many ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'W', 'e', 'i', 'g',
         'h', 't']
    (guard (\ x -> equal_nat (num_children x) (Nat_of_num (Bit0 (Bit0 One))))
      (tuple4
        ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'W', 'e', 'i', 'g',
          'h', 't', 'E', 'n', 't', 'r', 'y']
        xml2name (nata ['a', 'r', 'i', 't', 'y'])
        (nata ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e'])
        (nata ['w', 'e', 'i', 'g', 'h', 't'])
        (\ f a p w -> ((f, a), (p, (w, Nothing)))))
      (tuple5
        ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', 'W', 'e', 'i', 'g',
          'h', 't', 'E', 'n', 't', 'r', 'y']
        xml2name (nata ['a', 'r', 'i', 't', 'y'])
        (nata ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e'])
        (nata ['w', 'e', 'i', 'g', 'h', 't'])
        (many ['s', 'u', 'b', 't', 'e', 'r', 'm', 'C', 'o', 'e', 'f', 'f', 'i',
                'c', 'i', 'e', 'n', 't', 'E', 'n', 't', 'r', 'i', 'e', 's']
          (nata ['e', 'n', 't', 'r', 'y']) id)
        (\ f a p w e -> ((f, a), (p, (w, Just e))))))
    (\ a b -> (a, b));

xml2to3elements ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> b -> Maybe c -> d) -> Xml -> Sum_bot [Prelude.Char] d;
xml2to3elements tag p1 p2 p3 f (XML name atts cs text) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts &&
               less_eq_nat (Nat_of_num (Bit0 One)) l &&
                 less_eq_nat l (Nat_of_num (Bit1 One)) && is_none text
         then binda (p1 (nth cs Zero_nat))
                (\ x1 ->
                  binda (p2 (nth cs (Nat_of_num One)))
                    (\ x2 ->
                      (if equal_nat l (Nat_of_num (Bit1 One))
                        then binda (p3 (nth cs (Nat_of_num (Bit0 One))))
                               (\ x3 -> returna (f x1 x2 (Just x3)))
                        else returna (f x1 x2 Nothing))))
         else fail tag (XML name atts cs text));

knuth_bendix_order ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
knuth_bendix_order xml2name =
  xml2to3elements
    ['k', 'n', 'u', 't', 'h', 'B', 'e', 'n', 'd', 'i', 'x', 'O', 'r', 'd', 'e',
      'r']
    (nata ['w', '0']) (precedence_weight xml2name) (afs xml2name)
    (\ w0 prw afo ->
      let {
        a = (case afo of {
              Nothing -> [];
              Just af -> af;
            });
      } in KBO (prw w0) a);

arctic_rat_linear_poly ::
  forall a.
    Interpretation a -> ((a, Nat), (Arctic_delta Rat, [Arctic_delta Rat]));
arctic_rat_linear_poly (Arctic_rat_linear_poly x4) = x4;

real_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Real)]);
real_non_linear_poly (Real_non_linear_poly x13) = x13;

rat_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Rat)]);
rat_non_linear_poly (Rat_non_linear_poly x12) = x12;

int_non_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), [([(Nat, Nat)], Int)]);
int_non_linear_poly (Int_non_linear_poly x11) = x11;

arctic_linear_poly ::
  forall a. Interpretation a -> ((a, Nat), (Arctic, [Arctic]));
arctic_linear_poly (Arctic_linear_poly x3) = x3;

arctic_rat_matrix ::
  forall a.
    Interpretation a ->
      ((a, Nat), ([[Arctic_delta Rat]], [[[Arctic_delta Rat]]]));
arctic_rat_matrix (Arctic_rat_matrix x9) = x9;

real_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Real, [Real]));
real_linear_poly (Real_linear_poly x5) = x5;

rat_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Rat, [Rat]));
rat_linear_poly (Rat_linear_poly x2) = x2;

int_linear_poly :: forall a. Interpretation a -> ((a, Nat), (Int, [Int]));
int_linear_poly (Int_linear_poly x1) = x1;

arctic_matrix ::
  forall a. Interpretation a -> ((a, Nat), ([[Arctic]], [[[Arctic]]]));
arctic_matrix (Arctic_matrix x8) = x8;

real_matrix :: forall a. Interpretation a -> ((a, Nat), ([[Real]], [[[Real]]]));
real_matrix (Real_matrix x10) = x10;

rat_matrix :: forall a. Interpretation a -> ((a, Nat), ([[Rat]], [[[Rat]]]));
rat_matrix (Rat_matrix x7) = x7;

int_matrix :: forall a. Interpretation a -> ((a, Nat), ([[Int]], [[[Int]]]));
int_matrix (Int_matrix x6) = x6;

class_semiring ::
  forall a b.
    (Ceq a, Corder a, One a, Plus a, Times a, Zero a,
      Set_impl a) => Itself a ->
                       b -> Partial_object_ext a (Monoid_ext a (Ring_ext a b));
class_semiring uu b =
  Partial_object_ext top_set (Monoid_ext times onea (Ring_ext zeroa plus b));

real_domain :: Xml -> Sum_bot [Prelude.Char] Real;
real_domain =
  singleton
    ['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c', 'N', 'u', 'm', 'b', 'e', 'r',
      's']
    (singleton ['d', 'e', 'l', 't', 'a'] real id) id;

rat_domain :: Xml -> Sum_bot [Prelude.Char] Rat;
rat_domain =
  singleton ['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's']
    (singleton ['d', 'e', 'l', 't', 'a'] rat id) id;

basic_domain :: Xml -> Sum_bot [Prelude.Char] (Nat -> Domain);
basic_domain =
  options
    [(['n', 'a', 't', 'u', 'r', 'a', 'l', 's'],
       leaf ['n', 'a', 't', 'u', 'r', 'a', 'l', 's'] Natural),
      (['i', 'n', 't', 'e', 'g', 'e', 'r', 's'],
        leaf ['i', 'n', 't', 'e', 'g', 'e', 'r', 's'] (\ _ -> Integera)),
      (['a', 'r', 'c', 't', 'i', 'c'],
        singleton ['a', 'r', 'c', 't', 'i', 'c']
          (singleton ['d', 'o', 'm', 'a', 'i', 'n']
            (options
              [(['n', 'a', 't', 'u', 'r', 'a', 'l', 's'],
                 leaf ['n', 'a', 't', 'u', 'r', 'a', 'l', 's'] (\ _ -> Arctic)),
                (['i', 'n', 't', 'e', 'g', 'e', 'r', 's'],
                  leaf ['i', 'n', 't', 'e', 'g', 'e', 'r', 's']
                    (\ _ -> Arctic)),
                (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's'],
                  change rat_domain (\ _ _ -> Arctic_rat))])
            id)
          id),
      (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's'],
        change rat_domain Rational),
      (['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c', 'N', 'u', 'm', 'b', 'e',
         'r', 's'],
        change real_domain Mini_Alg)];

interpretation_type :: Xml -> Sum_bot [Prelude.Char] Domain;
interpretation_type =
  singleton ['t', 'y', 'p', 'e']
    (options
      [(['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l'],
         pair ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']
           (singleton ['d', 'o', 'm', 'a', 'i', 'n']
             (options
               [(['n', 'a', 't', 'u', 'r', 'a', 'l', 's'], basic_domain),
                 (['i', 'n', 't', 'e', 'g', 'e', 'r', 's'], basic_domain),
                 (['a', 'r', 'c', 't', 'i', 'c'], basic_domain),
                 (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's'], basic_domain),
                 (['a', 'l', 'g', 'e', 'b', 'r', 'a', 'i', 'c', 'N', 'u', 'm',
                    'b', 'e', 'r', 's'],
                   basic_domain),
                 (['m', 'a', 't', 'r', 'i', 'c', 'e', 's'],
                   triple ['m', 'a', 't', 'r', 'i', 'c', 'e', 's']
                     (nata ['d', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n'])
                     (nata ['s', 't', 'r', 'i', 'c', 't', 'D', 'i', 'm', 'e',
                             'n', 's', 'i', 'o', 'n'])
                     (singleton ['d', 'o', 'm', 'a', 'i', 'n'] basic_domain id)
                     (\ di sd domain d ->
                       (case domain d of {
                         Natural _ -> Int_mat di sd;
                         Integera -> Int_mat di sd;
                         Arctic -> Arctic_mat di;
                         Arctic_rat -> Arctic_rat_mat di;
                         Rational _ _ -> Rat_mat di sd;
                         Mini_Alg _ _ -> Mini_Alg_mat di sd;
                       })))])
             id)
           (nata ['d', 'e', 'g', 'r', 'e', 'e']) (\ typea -> typea)),
        (['m', 'a', 't', 'r', 'i', 'x', 'I', 'n', 't', 'e', 'r', 'p', 'r', 'e',
           't', 'a', 't', 'i', 'o', 'n'],
          triple
            ['m', 'a', 't', 'r', 'i', 'x', 'I', 'n', 't', 'e', 'r', 'p', 'r',
              'e', 't', 'a', 't', 'i', 'o', 'n']
            (singleton ['d', 'o', 'm', 'a', 'i', 'n'] basic_domain id)
            (nata ['d', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n'])
            (nata ['s', 't', 'r', 'i', 'c', 't', 'D', 'i', 'm', 'e', 'n', 's',
                    'i', 'o', 'n'])
            (\ domain di sd ->
              (case domain Zero_nat of {
                Natural _ -> Int_mat di sd;
                Integera -> Int_mat di sd;
                Arctic -> Arctic_mat di;
                Arctic_rat -> Arctic_rat_mat di;
                Rational _ _ -> Rat_mat di sd;
                Mini_Alg _ _ -> Mini_Alg_mat di sd;
              })))])
    id;

arctic_rat_coeff :: Xml -> Sum_bot [Prelude.Char] (Arctic_delta Rat);
arctic_rat_coeff =
  options
    [(['i', 'n', 't', 'e', 'g', 'e', 'r'], change rat Num_arc_delta),
      (['r', 'a', 't', 'i', 'o', 'n', 'a', 'l'], change rat Num_arc_delta),
      (['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y'],
        leaf ['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y']
          MinInfty_delta)];

arctic_coeff :: Xml -> Sum_bot [Prelude.Char] Arctic;
arctic_coeff =
  options
    [(['i', 'n', 't', 'e', 'g', 'e', 'r'],
       change (int ['i', 'n', 't', 'e', 'g', 'e', 'r']) Num_arc),
      (['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y'],
        leaf ['m', 'i', 'n', 'u', 's', 'I', 'n', 'f', 'i', 'n', 'i', 't', 'y']
          MinInfty)];

vec_plusI :: forall a. (a -> a -> a) -> [a] -> [a] -> [a];
vec_plusI pl v w = map (\ xy -> pl (fst xy) (snd xy)) (zip v w);

mat_plusI :: forall a. (a -> a -> a) -> [[a]] -> [[a]] -> [[a]];
mat_plusI pl m1 m2 = map (\ uv -> vec_plusI pl (fst uv) (snd uv)) (zip m1 m2);

scalar_prodI ::
  forall a. a -> (a -> a -> a) -> (a -> a -> a) -> [a] -> [a] -> a;
scalar_prodI ze pl ti v w = foldr (\ (x, y) -> pl (ti x y)) (zip v w) ze;

matT_vec_multI ::
  forall a. a -> (a -> a -> a) -> (a -> a -> a) -> [[a]] -> [a] -> [a];
matT_vec_multI ze pl ti m v = map (\ w -> scalar_prodI ze pl ti w v) m;

transpose :: forall a. Nat -> [[a]] -> [[a]];
transpose nr [] = replicate nr [];
transpose nr (v : m) = map (\ (a, b) -> a : b) (zip v (transpose nr m));

mat_multI ::
  forall a.
    a -> (a -> a -> a) -> (a -> a -> a) -> Nat -> [[a]] -> [[a]] -> [[a]];
mat_multI ze pl ti nr m1 m2 =
  map (matT_vec_multI ze pl ti (transpose nr m1)) m2;

mat_ring ::
  forall a b.
    (One b, Plus b, Times b,
      Zero b) => Nat ->
                   a -> Partial_object_ext [[b]]
                          (Monoid_ext [[b]] (Ring_ext [[b]] a));
mat_ring n b =
  Partial_object_ext (collect (mat n n))
    (Monoid_ext (mat_multI zeroa plus times n) (mat1I zeroa onea n)
      (Ring_ext (mat0I zeroa n n) (mat_plusI plus) b));

polynomial ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Tpoly Nat a);
polynomial xml2coeff x =
  singleton ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']
    (options
      [(['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't'],
         singleton ['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't']
           xml2coeff PNum),
        (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'],
          change (nata ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e'])
            (\ n -> PVar (minus_nat n (Nat_of_num One)))),
        (['s', 'u', 'm'], many ['s', 'u', 'm'] (polynomial xml2coeff) PSum),
        (['p', 'r', 'o', 'd', 'u', 'c', 't'],
          many ['p', 'r', 'o', 'd', 'u', 'c', 't'] (polynomial xml2coeff)
            PMult)])
    id x;

fit_length ::
  forall a.
    Partial_object_ext a (Monoid_ext a (Ring_ext a ())) -> Nat -> [a] -> [a];
fit_length c n uu =
  (if equal_nat n Zero_nat then []
    else (case uu of {
           [] -> replicate
                   (plus_nat (minus_nat n (Nat_of_num One)) (Nat_of_num One))
                   (zero c);
           b : bs -> b : fit_length c (minus_nat n (Nat_of_num One)) bs;
         }));

interpretation ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
interpretation bi xml2name =
  many1_gen
    ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
    interpretation_type
    (\ a ->
      (case a of {
        Natural deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial int_coeff x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Int_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial int_coeff x)
                       (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Int_non_linear_poly ((f, aa), poly)));
        Integera ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x -> binda (polynomial int_coeff x) (\ p -> returna (poly_of p)))
            (\ f aa poly -> Int_non_linear_poly ((f, aa), poly));
        Arctic ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial arctic_coeff x)
                (lpoly_of (class_semiring Type ())))
            (\ f aa poly ->
              Arctic_linear_poly
                ((f, aa),
                  (fst poly,
                    fit_length (class_semiring Type ()) aa (snd poly))));
        Arctic_rat ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial arctic_rat_coeff x)
                (lpoly_of (class_semiring Type ())))
            (\ f aa poly ->
              Arctic_rat_linear_poly
                ((f, aa),
                  (fst poly,
                    fit_length (class_semiring Type ()) aa (snd poly))));
        Int_mat n _ ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff Zero_int int_coeff) x)
                (lpoly_of (mat_ring n ())))
            (\ f aa poly ->
              Int_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring n ()) aa (snd poly))));
        Arctic_mat n ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff MinInfty arctic_coeff) x)
                (lpoly_of (mat_ring n ())))
            (\ f aa poly ->
              Arctic_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring n ()) aa (snd poly))));
        Arctic_rat_mat n ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff MinInfty_delta arctic_rat_coeff) x)
                (lpoly_of (mat_ring n ())))
            (\ f aa poly ->
              Arctic_rat_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring n ()) aa (snd poly))));
        Rational _ deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial rat x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Rat_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial rat x) (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Rat_non_linear_poly ((f, aa), poly)));
        Rat_mat n _ ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff zero_rat rat) x)
                (lpoly_of (mat_ring n ())))
            (\ f aa poly ->
              Rat_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring n ()) aa (snd poly))));
        Mini_Alg _ deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial real x)
                       (lpoly_of (class_semiring Type ())))
                   (\ f aa poly ->
                     Real_linear_poly
                       ((f, aa),
                         (fst poly,
                           fit_length (class_semiring Type ()) aa (snd poly))))
            else triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
                   (nata ['a', 'r', 'i', 't', 'y'])
                   (\ x ->
                     binda (polynomial real x) (\ p -> returna (poly_of p)))
                   (\ f aa poly -> Real_non_linear_poly ((f, aa), poly)));
        Mini_Alg_mat n _ ->
          triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
            (nata ['a', 'r', 'i', 't', 'y'])
            (\ x ->
              binda (polynomial (mat_coeff zero_real real) x)
                (lpoly_of (mat_ring n ())))
            (\ f aa poly ->
              Real_matrix
                ((f, aa),
                  (fst poly, fit_length (mat_ring n ()) aa (snd poly))));
      }))
    (\ typea pi ->
      (case typea of {
        Natural deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then Int_carrier (map int_linear_poly pi)
            else Int_nl_carrier (map int_non_linear_poly pi));
        Integera -> Int_nl_carrier (map int_non_linear_poly pi);
        Arctic -> Arctic_carrier (map arctic_linear_poly pi);
        Arctic_rat -> Arctic_rat_carrier (map arctic_rat_linear_poly pi);
        Int_mat n sd -> Int_mat_carrier n sd (map int_matrix pi);
        Arctic_mat n -> Arctic_mat_carrier n (map arctic_matrix pi);
        Arctic_rat_mat n -> Arctic_rat_mat_carrier n (map arctic_rat_matrix pi);
        Rational d deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then Rat_carrier (map rat_linear_poly pi)
            else Rat_nl_carrier d (map rat_non_linear_poly pi));
        Rat_mat n sd -> Rat_mat_carrier n sd (map rat_matrix pi);
        Mini_Alg d deg ->
          (if less_eq_nat deg (Nat_of_num One) && not bi
            then Real_carrier (map real_linear_poly pi)
            else Real_nl_carrier d (map real_non_linear_poly pi));
        Mini_Alg_mat n sd -> Real_mat_carrier n sd (map real_matrix pi);
      }));

status_precedence ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), (Nat, Order_tag))];
status_precedence xml2name =
  many ['s', 't', 'a', 't', 'u', 's', 'P', 'r', 'e', 'c', 'e', 'd', 'e', 'n',
         'c', 'e']
    (tuple4
      ['s', 't', 'a', 't', 'u', 's', 'P', 'r', 'e', 'c', 'e', 'd', 'e', 'n',
        'c', 'e', 'E', 'n', 't', 'r', 'y']
      xml2name (nata ['a', 'r', 'i', 't', 'y'])
      (nata ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e'])
      (options
        [(['l', 'e', 'x'], leaf ['l', 'e', 'x'] Lex),
          (['m', 'u', 'l'], leaf ['m', 'u', 'l'] Mul)])
      (\ f a p s -> ((f, a), (p, s))))
    id;

xml1to2elements ::
  forall a b c.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (a -> Maybe b -> c) -> Xml -> Sum_bot [Prelude.Char] c;
xml1to2elements tag p1 p2 f (XML name atts cs text) =
  let {
    l = size_list cs;
  } in (if name == tag &&
             null atts &&
               less_eq_nat (Nat_of_num One) l &&
                 less_eq_nat l (Nat_of_num (Bit0 One)) && is_none text
         then binda (p1 (nth cs Zero_nat))
                (\ x1 ->
                  (if equal_nat l (Nat_of_num (Bit0 One))
                    then binda (p2 (nth cs (Nat_of_num One)))
                           (\ x2 -> returna (f x1 (Just x2)))
                    else returna (f x1 Nothing)))
         else fail tag (XML name atts cs text));

path_order ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
path_order xml2name =
  xml1to2elements ['p', 'a', 't', 'h', 'O', 'r', 'd', 'e', 'r']
    (status_precedence xml2name) (afs xml2name)
    (\ prec_tau afo ->
      let {
        a = (case afo of {
              Nothing -> [];
              Just af -> af;
            });
      } in RPO prec_tau a);

redtriple ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
redtriple bi xml2name =
  singleton ['r', 'e', 'd', 'P', 'a', 'i', 'r']
    (options
      [(['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n'],
         interpretation bi xml2name),
        (['p', 'a', 't', 'h', 'O', 'r', 'd', 'e', 'r'], path_order xml2name),
        (['k', 'n', 'u', 't', 'h', 'B', 'e', 'n', 'd', 'i', 'x', 'O', 'r', 'd',
           'e', 'r'],
          knuth_bendix_order xml2name)])
    id;

signature ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [(a, Nat)];
signature xml2name =
  many ['s', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e']
    (pair ['s', 'y', 'm', 'b', 'o', 'l'] xml2name
      (nata ['a', 'r', 'i', 't', 'y']) (\ a b -> (a, b)))
    id;

joinable_critical_pairs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(Term a [Prelude.Char],
             ([(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                       Term a [Prelude.Char]))],
               (Term a [Prelude.Char],
                 [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                          Term a [Prelude.Char]))])))];
joinable_critical_pairs xml2name =
  let {
    rew = rsteps xml2name;
  } in many ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i',
              'c', 'a', 'l', 'P', 'a', 'i', 'r', 's']
         (pair ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i',
                 'c', 'a', 'l', 'P', 'a', 'i', 'r']
           rew rew (\ (s, sseq) (t, tseq) -> (s, (sseq, (t, tseq)))))
         id;

wcr_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Join_info a);
wcr_proof xml2name =
  singleton ['w', 'c', 'r', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i', 'c',
          'a', 'l', 'P', 'a', 'i', 'r', 's'],
         change (joinable_critical_pairs xml2name) Guided),
        (['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i', 'c',
           'a', 'l', 'P', 'a', 'i', 'r', 's', 'B', 'F', 'S'],
          change
            (nata ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't',
                    'i', 'c', 'a', 'l', 'P', 'a', 'i', 'r', 's', 'B', 'F', 'S'])
            Join_BFS),
        (['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i', 'c',
           'a', 'l', 'P', 'a', 'i', 'r', 's', 'A', 'u', 't', 'o'],
          leaf ['j', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'C', 'r', 'i', 't', 'i',
                 'c', 'a', 'l', 'P', 'a', 'i', 'r', 's', 'A', 'u', 't', 'o']
            Join_NF)])
    id;

xml2equational_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ([(Term a [Prelude.Char], Term a [Prelude.Char])],
            (Term a [Prelude.Char], Term a [Prelude.Char]));
xml2equational_input xml2name =
  pair ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'a', 's',
         'o', 'n', 'i', 'n', 'g', 'I', 'n', 'p', 'u', 't']
    (singleton ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] (rules xml2name)
      id)
    (pair ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n'] (term xml2name)
      (term xml2name) (\ a b -> (a, b)))
    (\ a b -> (a, b));

complexity_measure ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Complexity_measure a [Prelude.Char]);
complexity_measure xml2name =
  options
    [(['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o',
        'm', 'p', 'l', 'e', 'x', 'i', 't', 'y'],
       singleton
         ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o',
           'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
         (signature xml2name) Derivational_Complexity),
      (['r', 'u', 'n', 't', 'i', 'm', 'e', 'C', 'o', 'm', 'p', 'l', 'e', 'x',
         'i', 't', 'y'],
        pair ['r', 'u', 'n', 't', 'i', 'm', 'e', 'C', 'o', 'm', 'p', 'l', 'e',
               'x', 'i', 't', 'y']
          (signature xml2name) (signature xml2name) Runtime_Complexity)];

complexity_class :: Xml -> Sum_bot [Prelude.Char] Complexity_class;
complexity_class =
  change (nata ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l']) Comp_Poly;

forbidden_pattern ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location));
forbidden_pattern xml2name xml =
  binda (triple
          ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e',
            'r', 'n']
          (term xml2name) pos
          (options
            [(['h', 'e', 'r', 'e'], leaf ['h', 'e', 'r', 'e'] H),
              (['a', 'b', 'o', 'v', 'e'], leaf ['a', 'b', 'o', 'v', 'e'] A),
              (['b', 'e', 'l', 'o', 'w'], leaf ['b', 'e', 'l', 'o', 'w'] Ba),
              (['r', 'i', 'g', 'h', 't'], leaf ['b', 'e', 'l', 'o', 'w'] Ra)])
          (\ t p l -> (t, (p, l))) xml)
    (\ (t, (p, l)) ->
      (if in_poss p t then returna (ctxt_of_pos_term p t, (subt_at t p, l))
        else errora
               ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'd', 'o', 'e', 's',
                 ' ', 'n', 'o', 't', ' ', 'e', 'x', 'i', 's', 't', ' ', 'i',
                 'n', ' ', 't', 'e', 'r', 'm']));

forbidden_patterns ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
forbidden_patterns xml2name =
  many ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e',
         'r', 'n', 's']
    (forbidden_pattern xml2name) id;

replacement_map ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), [Nat])];
replacement_map xml2name =
  many ['c', 'o', 'n', 't', 'e', 'x', 't', 'S', 'e', 'n', 's', 'i', 't', 'i',
         'v', 'e']
    (many2
      ['r', 'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', 'M', 'a', 'p',
        'E', 'n', 't', 'r', 'y']
      xml2name (nata ['a', 'r', 'i', 't', 'y']) position
      (\ f a -> (\ b -> ((f, a), b))))
    id;

inn_fp_strategy ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Sum (Strategy a [Prelude.Char]) (Fp_strategy a [Prelude.Char]));
inn_fp_strategy xml2name =
  singleton ['s', 't', 'r', 'a', 't', 'e', 'g', 'y']
    (options
      [(['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'],
         leaf ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'] (Inl Innermost)),
        (['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't'],
          leaf ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't'] (Inr Outermost)),
        (['c', 'o', 'n', 't', 'e', 'x', 't', 'S', 'e', 'n', 's', 'i', 't', 'i',
           'v', 'e'],
          change (replacement_map xml2name) (\ p -> Inr (Context_Sensitive p))),
        (['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e',
           'r', 'n', 's'],
          change (forbidden_patterns xml2name)
            (\ p -> Inr (Forbidden_Patterns p))),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's'],
          change (innermostLhss xml2name) (\ q -> Inl (Innermost_Q q)))])
    id;

xml2pre_trs_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Input a [Prelude.Char]);
xml2pre_trs_input xml2name x =
  let {
    e = fail ['t', 'r', 's', 'I', 'n', 'p', 'u', 't'] x;
  } in binda (case x of {
               XML taga [] [] option -> e;
               XML taga [] (c : cs) Nothing ->
                 (if less_eq_nat (size_list cs) (Nat_of_num (Bit0 One)) &&
                       taga == ['t', 'r', 's', 'I', 'n', 'p', 'u', 't']
                   then binda (singleton ['t', 'r', 's'] (rules xml2name) id c)
                          (\ r ->
                            binda (if null cs ||
not (tag (hd cs) == ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'])
                                    then returna (Inl No_Strategy, cs)
                                    else binda
   (inn_fp_strategy xml2name (hd cs)) (\ s -> returna (s, tl cs)))
                              (\ (str, csa) ->
                                binda (if null csa ||
    not (tag (hd csa) ==
          ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'R', 'u', 'l', 'e', 's'])
then returna (Nothing, csa)
else binda (singleton
             ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'R', 'u', 'l', 'e', 's']
             (rules xml2name) id (hd csa))
       (\ s -> returna (Just s, tl csa)))
                                  (\ (s_opt, csb) ->
                                    (if null csb then returna (str, (r, s_opt))
                                      else e))))
                   else e);
               XML taga [] (c : cs) (Just _) -> e;
               XML taga (_ : _) list3 option -> e;
             })
         (\ a ->
           (case a of {
             (Inl istrat, (r, so)) -> returna (Inn_TRS_input (istrat, (r, so)));
             (Inr fpstrat, (r, Nothing)) -> returna (FP_TRS_input (fpstrat, r));
             (Inr fpstrat, (r, Just _)) ->
               errora
                 ['t', 'h', 'e', ' ', 'c', 'o', 'm', 'b', 'i', 'n', 'a', 't',
                   'i', 'o', 'n', ' ', 'o', 'f', ' ', 'r', 'e', 'l', 'a', 't',
                   'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'w', 'i',
                   't', 'h', ' ', 's', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e',
                   's', ' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 's', 'u',
                   'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'f', 'o', 'r', ' ',
                   'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'];
           }));

xml2trs_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Strategy a [Prelude.Char],
            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
              Maybe [(Term a [Prelude.Char], Term a [Prelude.Char])]));
xml2trs_input xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        Inn_TRS_input aa -> returna aa;
        COMP_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        EQ_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        CPX_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        FP_TRS_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        CTRS_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
        Unknown_input _ ->
          errora
            ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'i', 'n', 'n', 'e', 'r',
              'm', 'o', 's', 't', ' ', 't', 'r', 's', ' ', 'a', 't', ' ', 't',
              'h', 'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
      }));

xml2complexity_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Strategy a [Prelude.Char],
            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
              (Maybe [(Term a [Prelude.Char], Term a [Prelude.Char])],
                (Complexity_measure a [Prelude.Char], Complexity_class))));
xml2complexity_input xml2name =
  triple
    ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'I', 'n', 'p', 'u', 't']
    (xml2trs_input xml2name) (complexity_measure xml2name) complexity_class
    (\ (q, (r, s)) cm cc -> (q, (r, (s, (cm, cc)))));

xml2completion_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ([(Term a [Prelude.Char], Term a [Prelude.Char])],
            [(Term a [Prelude.Char], Term a [Prelude.Char])]);
xml2completion_input xml2name =
  pair ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'I', 'n', 'p', 'u',
         't']
    (singleton ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] (rules xml2name)
      id)
    (singleton ['t', 'r', 's'] (rules xml2name) id) (\ a b -> (a, b));

xml2unknown_input :: Xml -> Sum_bot [Prelude.Char] [Prelude.Char];
xml2unknown_input =
  text ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't'];

xml2ctrs_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]),
             [(Term a [Prelude.Char], Term a [Prelude.Char])])];
xml2ctrs_input xml2name =
  singleton ['c', 't', 'r', 's', 'I', 'n', 'p', 'u', 't'] (crules xml2name) id;

xml2dp_input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Bool,
            ([(Term a [Prelude.Char], Term a [Prelude.Char])],
              (Strategy a [Prelude.Char],
                [(Term a [Prelude.Char], Term a [Prelude.Char])])));
xml2dp_input xml2name =
  guard (\ x -> equal_nat (num_children x) (Nat_of_num (Bit0 (Bit0 One))))
    (tuple4 ['d', 'p', 'I', 'n', 'p', 'u', 't']
      (singleton ['t', 'r', 's'] (rules xml2name) id)
      (singleton ['d', 'p', 's'] (rules xml2name) id) (strategy xml2name)
      (bool ['m', 'i', 'n', 'i', 'm', 'a', 'l'])
      (\ r p s m -> (m, (p, (s, r)))))
    (triple ['d', 'p', 'I', 'n', 'p', 'u', 't']
      (singleton ['t', 'r', 's'] (rules xml2name) id)
      (singleton ['d', 'p', 's'] (rules xml2name) id)
      (bool ['m', 'i', 'n', 'i', 'm', 'a', 'l'])
      (\ r p m -> (m, (p, (No_Strategy, r)))));

xml2input ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Input a [Prelude.Char]);
xml2input xml2name =
  singleton ['i', 'n', 'p', 'u', 't']
    (options
      [(['d', 'p', 'I', 'n', 'p', 'u', 't'],
         change (xml2dp_input xml2name) DP_input),
        (['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'I', 'n', 'p', 'u',
           't'],
          change (xml2completion_input xml2name) COMP_input),
        (['t', 'r', 's', 'I', 'n', 'p', 'u', 't'], xml2pre_trs_input xml2name),
        (['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'a', 's',
           'o', 'n', 'i', 'n', 'g', 'I', 'n', 'p', 'u', 't'],
          change (xml2equational_input xml2name) EQ_input),
        (['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'I', 'n', 'p', 'u',
           't'],
          change (xml2complexity_input xml2name) CPX_input),
        (['c', 't', 'r', 's', 'I', 'n', 'p', 'u', 't'],
          change (xml2ctrs_input xml2name) CTRS_input),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't'],
          change xml2unknown_input Unknown_input)])
    id;

xml_crule ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => ((Term (Lab a [b]) c, Term (Lab a [b]) c),
                    [(Term (Lab a [b]) c, Term (Lab a [b]) c)]) ->
                    Xml;
xml_crule =
  (\ (c, rs) ->
    XML ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'u', 'l',
          'e']
      [] (map xml_rule (c : rs)) Nothing);

xml_rules ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => [Prelude.Char] ->
                    [(Term (Lab a [b]) c, Term (Lab a [b]) c)] -> Xml;
xml_rules tag rls =
  XML tag [] [XML ['r', 'u', 'l', 'e', 's'] [] (map xml_rule rls) Nothing]
    Nothing;

missing ::
  [Prelude.Char] ->
    ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
missing s x =
  shows_string ['t', 'h', 'e', ' '] .
    shows_string s .
      shows_string [' '] .
        x . shows_string
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'];

toomuch ::
  [Prelude.Char] ->
    ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
toomuch s x =
  shows_string ['s', 'u', 'p', 'e', 'r', 'f', 'l', 'u', 'o', 'u', 's', ' '] .
    shows_string s . shows_string [' '] . x . x;

ins_rm_basic_ops :: forall a. (Linorder a) => a -> Rbt a () -> Rbt a ();
ins_rm_basic_ops x s = insert x () s;

g_from_list_aux_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> [a] -> Rbt a ();
g_from_list_aux_dflt_basic_oops_rm_basic_ops y [] = y;
g_from_list_aux_dflt_basic_oops_rm_basic_ops accs (x : l) =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops (ins_rm_basic_ops x accs) l;

empty_rm_basic_ops :: forall a. (Linorder a) => () -> Rbt a ();
empty_rm_basic_ops = (\ _ -> empty);

g_from_list_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => [a] -> Rbt a ();
g_from_list_dflt_basic_oops_rm_basic_ops l =
  g_from_list_aux_dflt_basic_oops_rm_basic_ops (empty_rm_basic_ops ()) l;

memb_rm_basic_ops :: forall a. (Linorder a) => a -> Rbt a () -> Bool;
memb_rm_basic_ops x s = not (is_none (lookup s x));

ceta_set_of :: forall a. (Key a) => [a] -> a -> Bool;
ceta_set_of ps =
  let {
    tree = g_from_list_dflt_basic_oops_rm_basic_ops ps;
  } in (\ a -> memb_rm_basic_ops a tree);

icap_impla ::
  forall a.
    (Eq a,
      Key a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [Term a [Prelude.Char]] ->
                    [Term a [Prelude.Char]] ->
                      Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char]);
icap_impla r q =
  let {
    ls = map fst r;
    isnf = is_NF (any is_Var q) q (term_map q);
    nf = nF_subset ls q;
    ic = icap_impl nf isnf ls;
  } in (\ s ->
         let {
           sa = map (map_vars (\ a -> 'x' : a)) s;
           sx = ceta_set_of (concatMap vars_term_list sa);
         } in (\ t -> ic sa sx (map_vars (\ a -> 'x' : a) t)));

rep_subst_incr ::
  forall a b. Subst_incr a b -> (b -> Term a b, (Set b, Term a b -> [b]));
rep_subst_incr (Abs_subst_incr x) = x;

si_W :: forall a b. Subst_incr a b -> Term a b -> [b];
si_W xa = snd (snd (rep_subst_incr xa));

kbo_nstrict ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ((a, Nat) -> Nat) ->
                    ((a, Nat) -> Nat) ->
                      Nat ->
                        (a -> Bool) ->
                          ((a, Nat) -> Nat -> Nat) ->
                            (Term a b, Term a b) ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
kbo_nstrict pr w w0 least scf =
  (\ (s, t) ->
    check (snd (kbo_impl w w0 pr least scf s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term Zero_nat s .
          shows_string [' ', '>', '=', 'K', 'B', 'O', ' '] .
            shows_prec_term Zero_nat t . shows_nl));

list_inter :: forall a. (Eq a) => [a] -> [a] -> [a];
list_inter [] bs = [];
list_inter (a : asa) bs =
  (if membera bs a then a : list_inter asa bs else list_inter asa bs);

list_union :: forall a. (Eq a) => [a] -> [a] -> [a];
list_union [] ys = ys;
list_union (x : xs) ys =
  let {
    zs = list_union xs ys;
  } in (if membera zs x then zs else x : zs);

sub_vec :: forall a. Nat -> [a] -> [a];
sub_vec = take;

sub_mat :: forall a. Nat -> Nat -> [[a]] -> [[a]];
sub_mat nr nc m = map (sub_vec nr) (take nc m);

default_I :: forall a. (Poly_carrier a) => a -> Nat -> [([(Nat, Nat)], a)];
default_I def n =
  ([], def) : map (\ i -> ([(i, Nat_of_num One)], onea)) (upt Zero_nat n);

eval_monom :: forall a b. (Comm_semiring_1 b) => (a -> b) -> [(a, Nat)] -> b;
eval_monom alpha [] = onea;
eval_monom alpha ((x, p) : m) = times (eval_monom alpha m) (powera (alpha x) p);

eval_poly ::
  forall a b. (Comm_semiring_1 b) => (a -> b) -> [([(a, Nat)], b)] -> b;
eval_poly alpha [] = zeroa;
eval_poly alpha (mc : p) =
  plus (times (eval_monom alpha (fst mc)) (snd mc)) (eval_poly alpha p);

poly_vars ::
  forall a b. (Ceq a, Corder a, Set_impl a) => [([(a, Nat)], b)] -> Set a;
poly_vars p = set (concatMap (map fst . fst) p);

proper_prefix_list :: Pos -> [Pos];
proper_prefix_list Empty = [];
proper_prefix_list (PCons i p) = Empty : map (PCons i) (proper_prefix_list p);

prefix_list :: Pos -> [Pos];
prefix_list p = p : proper_prefix_list p;

scnp_arity :: forall a. [((a, Nat), [(Nat, Nat)])] -> Nat;
scnp_arity af = max_list (map (\ (_, a) -> size_list a) af);

check_supt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Term a b ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_supt s t =
  check (supt_impl s t)
    (shows_prec_term Zero_nat t .
      shows_string
        [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r', 'o', 'p',
          'e', 'r', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', ' ', 'o', 'f',
          ' '] .
        shows_prec_term Zero_nat s);

compute_trancl ::
  forall a.
    (Cenum a, Ceq a, Corder a, Set_impl a) => Set a -> Set (a, a) -> Set a;
compute_trancl a r =
  let {
    b = imagea r a;
  } in (if less_eq_set b bot_set then bot_set
         else sup_set b
                (compute_trancl b
                  (filtera
                    (\ ab -> not (member (fst ab) a) && not (member (snd ab) b))
                    r)));

r_lhs_states :: forall a b. Ta_rule a b -> [a];
r_lhs_states (TA_rule f qs q) = qs;

ta_rules :: forall a b c. Ta_ext a b c -> Set (Ta_rule a b);
ta_rules (Ta_ext ta_final ta_rules ta_eps more) = ta_rules;

ta_eps :: forall a b c. Ta_ext a b c -> Set (a, a);
ta_eps (Ta_ext ta_final ta_rules ta_eps more) = ta_eps;

ta_res ::
  forall a b.
    (Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b,
      Linorder b) => Ta_ext a b () -> Term b a -> Set a;
ta_res ta (Fun f ts) =
  let {
    qs = map (ta_res ta) ts;
    g = (f, size_list ts);
  } in sup_set
         (image r_rhs
           (filtera
             (\ r ->
               r_sym r == g &&
                 all (\ qq -> member (snd qq) (fst qq))
                   (zip qs (r_lhs_states r)))
             (ta_rules ta)))
         (compute_trancl
           (image r_rhs
             (filtera
               (\ r ->
                 r_sym r == g &&
                   all (\ qq -> member (snd qq) (fst qq))
                     (zip qs (r_lhs_states r)))
               (ta_rules ta)))
           (ta_eps ta));
ta_res ta (Var q) =
  sup_set (inserta q bot_set) (compute_trancl (inserta q bot_set) (ta_eps ta));

eq_rule_mod_vars ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => (Term a b, Term a b) -> (Term a b, Term a b) -> Bool;
eq_rule_mod_vars lr st = instance_rule lr st && instance_rule st lr;

generate_var :: Nat -> [Prelude.Char];
generate_var i = 'x' : shows_prec_nat Zero_nat i [];

uncurry_term ::
  forall a b. (Eq a) => a -> (a -> Nat -> [a]) -> Term a b -> Term a b;
uncurry_term a sm t =
  (case unapp a t of {
    (Var x, ts) -> apply_args a (Var x) (map (uncurry_term a sm) ts);
    (Fun f ss, ts) ->
      let {
        n = size_list ss;
        uss = map (uncurry_term a sm) ss;
        uts = map (uncurry_term a sm) ts;
        aa = aarity sm f n;
        m = min (size_list ts) aa;
        fm = get_symbol sm f n m;
      } in apply_args a (Fun fm (uss ++ take m uts)) (drop m uts);
  });

conversion ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                   (Bool, Term a [Prelude.Char])))];
conversion xml2name =
  many1 ['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n']
    (singleton ['s', 't', 'a', 'r', 't', 'T', 'e', 'r', 'm'] (term xml2name) id)
    (estep xml2name) (\ _ x -> x);

plain_name :: Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat]);
plain_name x =
  options
    [(['n', 'a', 'm', 'e'], change (text ['n', 'a', 'm', 'e']) UnLab),
      (['s', 'h', 'a', 'r', 'p'],
        singleton ['s', 'h', 'a', 'r', 'p'] plain_name Sharp),
      (['l', 'a', 'b', 'e', 'l', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l'],
        pair ['l', 'a', 'b', 'e', 'l', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l']
          plain_name
          (options
            [(['n', 'u', 'm', 'b', 'e', 'r', 'L', 'a', 'b', 'e', 'l'],
               many ['n', 'u', 'm', 'b', 'e', 'r', 'L', 'a', 'b', 'e', 'l']
                 (nata ['n', 'u', 'm', 'b', 'e', 'r']) Inl),
              (['s', 'y', 'm', 'b', 'o', 'l', 'L', 'a', 'b', 'e', 'l'],
                many ['s', 'y', 'm', 'b', 'o', 'l', 'L', 'a', 'b', 'e', 'l']
                  plain_name Inr)])
          (\ f a ->
            (case a of {
              Inl aa -> Lab f aa;
              Inr aa -> FunLab f aa;
            })))]
    x;

xml1or2many_elements ::
  forall a b c d.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (a -> Maybe b -> [c] -> d) -> Xml -> Sum_bot [Prelude.Char] d;
xml1or2many_elements tag p1 p2 p3 f (XML name atts cs text) =
  (if name == tag && null atts && is_none text && not (null cs)
    then let {
           (cs0 : tt) = cs;
         } in binda (p1 cs0)
                (\ x ->
                  (case tt of {
                    [] -> returna (f x Nothing []);
                    cs1 : t ->
                      catch (binda (p2 cs1)
                              (\ y ->
                                binda (map_sum_bot p3 t)
                                  (\ xs -> returna (f x (Just y) xs))))
                        (\ _ ->
                          binda (map_sum_bot p3 tt)
                            (\ xs -> returna (f x Nothing xs)));
                  }))
    else fail tag (XML name atts cs text));

sl_variant ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Sl_variant a [Prelude.Char]);
sl_variant xml2name =
  singleton ['m', 'o', 'd', 'e', 'l']
    (options
      [(['f', 'i', 'n', 'i', 't', 'e', 'M', 'o', 'd', 'e', 'l'],
         xml1or2many_elements
           ['f', 'i', 'n', 'i', 't', 'e', 'M', 'o', 'd', 'e', 'l']
           (change
             (nata ['c', 'a', 'r', 'r', 'i', 'e', 'r', 'S', 'i', 'z', 'e'])
             (\ n -> minus_nat n (Nat_of_num One)))
           (singleton ['t', 'u', 'p', 'l', 'e', 'O', 'r', 'd', 'e', 'r']
             (leaf ['p', 'o', 'i', 'n', 't', 'W', 'i', 's', 'e'] ()) id)
           (triple ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't'] xml2name
             (nata ['a', 'r', 'i', 't', 'y']) arith_fun
             (\ f a -> (\ b -> ((f, a), b))))
           (\ n model xs ->
             (if is_none model then Finitelab (SL_Inter n xs)
               else QuasiFinitelab (SL_Inter n xs) []))),
        (['r', 'o', 'o', 't', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g'],
          guard (\ x -> equal_nat (num_children x) Zero_nat)
            (leaf ['r', 'o', 'o', 't', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
              (Rootlab Nothing))
            (singleton
              ['r', 'o', 'o', 't', 'L', 'a', 'b', 'e', 'l', 'i', 'n', 'g']
              xml2name (\ f -> Rootlab (Just (f, Nat_of_num One)))))])
    id;

transition_lhs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Sum a [Prelude.Char]);
transition_lhs xml2lhs =
  choice ['l', 'h', 's']
    [singleton ['l', 'h', 's'] state Inr, change xml2lhs Inl];

transition ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]])) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Sum (Ta_rule [Prelude.Char] a) ([Prelude.Char], [Prelude.Char]));
transition xml2lhs =
  pair ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n']
    (transition_lhs xml2lhs) (singleton ['r', 'h', 's'] state id)
    (\ lhs q ->
      (case lhs of {
        Inl (f, qs) -> Inl (TA_rule f qs q);
        Inr qa -> Inr (qa, q);
      }));

max_tag :: Nat;
max_tag = Nat_of_num (Bit1 (Bit0 (Bit1 (Bit1 One))));

all_interval_nat :: (Nat -> Bool) -> Nat -> Nat -> Bool;
all_interval_nat p i j =
  less_eq_nat j i || p i && all_interval_nat p (plus_nat i (Nat_of_num One)) j;

shows_prec_pos :: Nat -> Pos -> [Prelude.Char] -> [Prelude.Char];
shows_prec_pos d p = shows_pos p;

vars_rule_lista :: forall a b. (Term a b, Term a b) -> [b];
vars_rule_lista r = vars_term_lista (fst r) ++ vars_term_lista (snd r);

vars_rule_list :: forall a b. (Eq b) => (Term a b, Term a b) -> [b];
vars_rule_list r = remdups (vars_rule_lista r);

check_prop_rstep_rule ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      Pos ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstep_rule nfs pa p rule s t =
  bindb (check (in_poss p s)
          (shows_prec_pos Zero_nat p .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o', 's',
                'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
              shows_prec_term Zero_nat s . shows_nl))
    (\ _ ->
      bindb (check (in_poss p t)
              (shows_prec_pos Zero_nat p .
                shows_string
                  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
                    's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                  shows_prec_term Zero_nat t . shows_nl))
        (\ _ ->
          let {
            c = ctxt_of_pos_term p s;
            d = ctxt_of_pos_term p t;
            u = subt_at s p;
            v = subt_at t p;
          } in (case match_list Var [(fst rule, u), (snd rule, v)] of {
                 Nothing ->
                   Inl (shows_string
                          ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                         shows_prec_term Zero_nat t .
                           shows_string
                             [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                               'r', 'e', 's', 'u', 'l', 't', ' ', 'f', 'r', 'o',
                               'm', ' ', 'a', ' ', 'p', 'r', 'o', 'p', 'e', 'r',
                               ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                               'o', 'n', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e',
                               ' '] .
                             shows_nl .
                               shows_rule (shows_prec Zero_nat)
                                 (shows_prec Zero_nat) [' ', '-', '>', ' ']
                                 rule .
                                 shows_string
                                   [' ', 'a', 't', ' ', 'p', 'o', 's', 'i', 't',
                                     'i', 'o', 'n', ' '] .
                                   shows_prec_pos Zero_nat p . shows_nl);
                 Just tau ->
                   bindb (catcha
                           (forallM pa
                             (args u ++
                               (if nfs then map tau (vars_rule_list rule)
                                 else [])))
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       check (equal_ctxt c d)
                         (shows_string
                            ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                           shows_prec_term Zero_nat t .
                             shows_string
                               [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't',
                                 ' ', 'r', 'e', 's', 'u', 'l', 't', ' ', 'f',
                                 'r', 'o', 'm', ' ', 'a', ' ', 'p', 'r', 'o',
                                 'p', 'e', 'r', ' ', 'a', 'p', 'p', 'l', 'i',
                                 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
                                 ' ', 'r', 'u', 'l', 'e', ' '] .
                               shows_nl .
                                 shows_rule (shows_prec Zero_nat)
                                   (shows_prec Zero_nat) [' ', '-', '>', ' ']
                                   rule .
                                   shows_string
                                     [' ', 'a', 't', ' ', 'p', 'o', 's', 'i',
                                       't', 'i', 'o', 'n', ' '] .
                                     shows_prec_pos Zero_nat p . shows_nl));
               })));

check_prop_rstep ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstep nfs pa r p rule s t =
  check (any (\ ra ->
               eq_rule_mod_vars rule ra &&
                 isOK (check_prop_rstep_rule nfs pa p ra s t))
          r)
    (shows_prec_list Zero_nat
       ['t', 'h', 'e', ' ', 's', 't', 'e', 'p', ' ', 'f', 'r', 'o', 'm', ' '] .
      shows_prec_term Zero_nat s .
        shows_prec_list Zero_nat [' ', 't', 'o', ' '] .
          shows_prec_term Zero_nat t .
            shows_prec_list Zero_nat
              [' ', 'v', 'i', 'a', ' ', 'r', 'u', 'l', 'e', ' '] .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                [' ', '-', '>', ' '] rule .
                shows_prec_list Zero_nat
                  [' ', 'a', 't', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n',
                    ' '] .
                  shows_prec_pos Zero_nat p .
                    shows_prec_list Zero_nat
                      [' ', 'i', 's', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                        'a', 't', 'i', 'c'] .
                      shows_nl);

check_qrstep_subst ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrstep_subst cni nfs =
  let {
    main =
      check_prop_rstep nfs
        (\ t ->
          catcha (cni t)
            (\ _ ->
              Inl (shows_prec_term Zero_nat t .
                    shows_prec_list Zero_nat
                      [' ', 'm', 'u', ' ', '^', '^', ' ', 'i', ' ', 'i', 's',
                        ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'Q', '-', 'n',
                        'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ',
                        'f', 'o', 'r', ' ', 'a', 'l', 'l', ' ', 'i'])));
  } in (\ r p ra s t ->
         bindb (check (not (is_Var (fst ra)))
                 (shows_prec_list Zero_nat
                   ['l', 'o', 'o', 'p', ' ', 'c', 'h', 'e', 'c', 'k', ' ', 'r',
                     'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'l', 'h', 's', 's',
                     ' ', 't', 'o', ' ', 'b', 'e', ' ', 'n', 'o', 'n', '-', 'v',
                     'a', 'r', 'i', 'a', 'b', 'l', 'e']))
           (\ _ -> main r p ra s t));

check_rqrstep_subst ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rqrstep_subst cni nfs = (\ r -> check_qrstep_subst cni nfs r Empty);

check_qsteps_subst ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qsteps_subst cni nfs p r [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term Zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term Zero_nat u . shows_nl);
check_qsteps_subst cni nfs p ra ((uu, (r, (True, t))) : prts) s u =
  bindb (check_rqrstep_subst cni nfs p r s t)
    (\ _ -> check_qsteps_subst cni nfs p ra prts t u);
check_qsteps_subst cni nfs pa ra ((p, (r, (False, t))) : prts) s u =
  bindb (check_qrstep_subst cni nfs ra p r s t)
    (\ _ -> check_qsteps_subst cni nfs pa ra prts t u);

check_qrsteps_subst ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Sum (Term a b, Term a b) ()) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrsteps_subst cni nfs r prts s u =
  check_qsteps_subst cni nfs [] r
    (map (\ (p, (ra, t)) -> (p, (ra, (False, t)))) prts) s u;

check_qrstep ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrstep nf nfs =
  check_prop_rstep nfs
    (\ t ->
      check (nf t)
        (shows_prec_term Zero_nat t .
          shows_prec_list Zero_nat
            [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'Q', '-',
              'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']));

check_rqrstep ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        (Term a b, Term a b) ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rqrstep nf nfs r rule s t = check_qrstep nf nfs r Empty rule s t;

check_qsteps ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Term a b, Term a b)] ->
                          [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qsteps nf nfs p r [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term Zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term Zero_nat u . shows_nl);
check_qsteps nf nfs p ra ((uu, (r, (True, t))) : prts) s u =
  bindb (check_rqrstep nf nfs p r s t)
    (\ _ -> check_qsteps nf nfs p ra prts t u);
check_qsteps nf nfs pa ra ((p, (r, (False, t))) : prts) s u =
  bindb (check_qrstep nf nfs ra p r s t)
    (\ _ -> check_qsteps nf nfs pa ra prts t u);

check_qrsteps ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => (Term a b -> Bool) ->
                    Bool ->
                      [(Term a b, Term a b)] ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qrsteps nf nfs r prts s u =
  check_qsteps nf nfs [] r (map (\ (p, (ra, t)) -> (p, (ra, (False, t)))) prts)
    s u;

si_subst :: forall a b. Subst_incr a b -> b -> Term a b;
si_subst xa = fst (rep_subst_incr xa);

match_prob_of_rp_impl ::
  forall a b.
    (Eq a,
      Eq b) => Subst_incr a b -> (Term a b, Term a b) -> [(Term a b, Term a b)];
match_prob_of_rp_impl mu (t, Var x) = [(t, Var x)];
match_prob_of_rp_impl mu (t, Fun v va) =
  let {
    sterms = remdups (t : map (si_subst mu) (si_W mu t));
    uterms = concatMap (filter (\ ta -> not (is_Var ta)) . supteq_list) sterms;
  } in map (\ u -> (u, Fun v va)) (remdups uterms);

si_v_incr :: forall a b. Subst_incr a b -> Set b;
si_v_incr xa = fst (snd (rep_subst_incr xa));

simplify_mp ::
  forall a b.
    (Eq a, Ceq b,
      Corder b) => Subst_incr a b ->
                     [(Term a b, Term a b)] ->
                       [(Term a b, Term a b)] ->
                         Maybe ([(Term a b, Term a b)], Nat);
simplify_mp mu_incr ((Var x, Fun f ls) : mp) solved =
  bind (guarda (member x (si_v_incr mu_incr)))
    (\ _ ->
      let {
        m = map (\ (s, a) -> (subst_apply_term s (si_subst mu_incr), a));
      } in bind (simplify_mp mu_incr (m ((Var x, Fun f ls) : mp)) (m solved))
             (\ (smp, i) -> Just (smp, plus_nat i (Nat_of_num One))));
simplify_mp mu_incr ((Fun g ts, Fun f ls) : mp) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (zip_option ts ls)
        (\ pairs -> simplify_mp mu_incr (pairs ++ mp) solved));
simplify_mp mu_incr ((s, Var x) : mp) solved =
  simplify_mp mu_incr mp ((s, Var x) : solved);
simplify_mp mu_incr [] solved = Just (solved, Zero_nat);

conflicts ::
  forall a b.
    (Eq a,
      Eq b) => (a -> Term b a) ->
                 (Term b a, (Term b a, Nat)) -> [(Term b a, (Term b a, Nat))];
conflicts mu (Fun f ts, (Fun g ss, n)) =
  (if f == g && equal_nat (size_list ts) (size_list ss)
    then concatMap (\ (s, t) -> conflicts mu (s, (t, n))) (zip ts ss)
    else [(Fun f ts, (Fun g ss, n))]);
conflicts mu (Var x, (Fun g ss, n)) = [(Var x, (Fun g ss, n))];
conflicts mu (Fun f ts, (Var y, n)) =
  (if equal_nat n Zero_nat then [(Var y, (Fun f ts, Zero_nat))]
    else conflicts mu (Fun f ts, (mu y, minus_nat n (Nat_of_num One))));
conflicts mu (Var x, (Var y, n)) =
  (if equal_nat n Zero_nat
    then (if x == y then [] else [(Var x, (Var y, Zero_nat))])
    else conflicts mu (Var x, (mu y, minus_nat n (Nat_of_num One))));

ident_solvea ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => Subst_incr a b ->
                       Set (Term a b, (Term a b, Nat)) ->
                         (Term a b, (Term a b, Nat)) -> Maybe Nat;
ident_solvea mu_incr cps st =
  let {
    cp = conflicts (si_subst mu_incr) st;
  } in (if any (\ (u, (_, _)) -> not (is_Var u)) cp then Nothing
         else (if any (\ (u, (v, _)) ->
                        member (u, v) (image (\ (ua, (va, _)) -> (ua, va)) cps))
                    cp
                then Nothing
                else bind (mapMa
                            (\ (u, (v, m)) ->
                              ident_solvea mu_incr (inserta (u, (v, m)) cps)
                                (subst_apply_term u (si_subst mu_incr),
                                  (v, plus_nat m (Nat_of_num One))))
                            (conflicts (si_subst mu_incr) st))
                       (\ is -> Just (max_list (map suc is)))));

ident_solve ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => Subst_incr a b -> (Term a b, Term a b) -> Maybe Nat;
ident_solve mu_incr =
  (\ (s, t) ->
    ident_solvea mu_incr
      (set_empty
        (of_phantom
          (set_impl_prod :: Phantom (Term a b, (Term a b, Nat)) Set_impla)))
      (s, (t, Zero_nat)));

ident_decision ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
ident_decision sigma ip = not (is_none (ident_solve sigma ip));

ident_prob_of_smp ::
  forall a b. (Eq a, Eq b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)];
ident_prob_of_smp [] = [];
ident_prob_of_smp ((t, l) : other) =
  map_filter
    (\ x ->
      (if let {
            (_, s) = x;
          } in equal_term s l
        then Just (let {
                     (s, _) = x;
                   } in (t, s))
        else Nothing))
    other ++
    ident_prob_of_smp other;

gmatch_decision ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b -> [(Term a b, Term a b)] -> Bool;
gmatch_decision sigma mp =
  not (is_none
        (bind (simplify_mp sigma mp [])
          (\ (smp, _) ->
            guarda (all (ident_decision sigma) (ident_prob_of_smp smp)))));

match_decision ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
match_decision mu mp = gmatch_decision mu [mp];

redex_decision ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b -> (Term a b, Term a b) -> Bool;
redex_decision mu rp = any (match_decision mu) (match_prob_of_rp_impl mu rp);

new_as :: forall a b. (a -> b -> Bool) -> [a] -> [b] -> [b];
new_as p bs asa = filter (\ a -> any (\ b -> p b a) bs) asa;

the_set_impl_main ::
  forall a b.
    (Eq a, Eq b) => (a -> b -> Bool) -> (b -> [a]) -> [b] -> [b] -> [a] -> [b];
the_set_impl_main p q remain have bs =
  let {
    new = new_as p bs remain;
  } in (if null new then have
         else the_set_impl_main p q (list_diff remain new) (new ++ have)
                (remdups (concatMap q new)));

the_set_impl ::
  forall a b.
    (Eq a, Eq b) => [a] -> (b -> a -> Bool) -> (a -> [b]) -> [b] -> [a];
the_set_impl r p q bs = the_set_impl_main p q r [] bs;

inductive_set_impl ::
  forall a b.
    (Eq a, Eq b) => [a] -> (b -> a -> Bool) -> (a -> [b]) -> [b] -> [a];
inductive_set_impl = the_set_impl;

v_incr_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
v_incr_impl mu =
  inductive_set_impl (map fst mu) (\ a b -> a == b)
    (\ x ->
      concatMap (\ (y, t) -> (if equal_term t (Var x) then [y] else [])) mu)
    (concatMap (\ (y, t) -> (if not (is_Var t) then [y] else [])) mu);

relpow_impl ::
  forall a b.
    ([a] -> [a]) -> ([a] -> b -> b) -> (a -> b -> Bool) -> [a] -> b -> Nat -> b;
relpow_impl succ un memb new have m =
  (if equal_nat m Zero_nat then un new have
    else (if null new then have
           else let {
                  maybe = succ new;
                  havea = un new have;
                  newa = filter (\ n -> not (memb n havea)) maybe;
                } in relpow_impl succ un memb newa havea
                       (minus_nat m (Nat_of_num One))));

rtrancl_impl ::
  forall a b.
    ([(a, a)] -> [a] -> [a]) ->
      ([a] -> b -> b) -> (a -> b -> Bool) -> b -> [(a, a)] -> [a] -> b;
rtrancl_impl gen_succ un memb emp rel =
  let {
    succ = gen_succ rel;
    n = size_list rel;
  } in (\ asa -> relpow_impl succ un memb asa emp n);

rtrancl_list_impl :: forall a. (Eq a) => [(a, a)] -> [a] -> [a];
rtrancl_list_impl =
  rtrancl_impl
    (\ r asa ->
      remdups
        (map_filter
          (\ x ->
            (if let {
                  (a, _) = x;
                } in membera asa a
              then Just (snd x) else Nothing))
          r))
    (\ xs ys -> filter (\ x -> not (membera ys x)) xs ++ ys)
    (\ x xs -> membera xs x) [];

w_impl :: forall a b. (Eq a) => [(a, Term b a)] -> Term b a -> [a];
w_impl d =
  let {
    filt = filter (\ (x, y) -> not (x == y));
    xvs = concatMap (\ (x, t) -> map (\ a -> (x, a)) (vars_term_list t)) d;
    rel = filt xvs;
    rtran = rtrancl_list_impl rel;
  } in (\ t -> rtran (vars_term_list t));

subst_incr ::
  forall a b.
    (Ceq a, Corder a, Eq a, Set_impl a,
      Eq b) => [(a, Term b a)] -> Subst_incr b a;
subst_incr xa =
  Abs_subst_incr
    (let {
       dom = mk_subst_domain xa;
     } in (mk_subst Var xa, (set (v_incr_impl dom), w_impl dom)));

redex_rps_decision ::
  forall a b.
    (Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b,
      Linorder b) => [(a, Term b a)] ->
                       [(Term b a, Term b a)] -> Sum (Term b a, Term b a) ();
redex_rps_decision mu =
  let {
    mua = subst_incr mu;
    main = redex_decision mua;
  } in (\ xs ->
         catcha (forallM (\ tl -> check (not (main tl)) tl) xs)
           (\ x -> Inl (snd x)));

check_NF_iteration ::
  forall a b.
    (Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b,
      Linorder b) => [(a, Term b a)] ->
                       [Term b a] -> Term b a -> Sum (Term b a, Term b a) ();
check_NF_iteration mu =
  let {
    dec = redex_rps_decision mu;
  } in (\ q t -> dec (map (\ a -> (t, a)) q));

check_loop ::
  forall a b.
    (Eq a, Linorder a, Showa a, Ceq b, Corder b, Eq b, Mapping_impl b,
      Linorder b, Set_impl b,
      Showa b) => [Term a b] ->
                    Bool ->
                      Term a b ->
                        [(Pos, ((Term a b, Term a b), Term a b))] ->
                          [(b, Term a b)] ->
                            Ctxt a b ->
                              [(Term a b, Term a b)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_loop q nfs s rseq sigma c r =
  bindb (check (not (null rseq))
          (shows_prec_list Zero_nat
            ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'e', 'q', 'u', 'e',
              'n', 'c', 'e', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n',
              'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
    (\ _ ->
      (if null q
        then check_qrsteps (\ _ -> True) nfs r rseq s
               (ctxt_apply c (subst_apply_term s (mk_subst Var sigma)))
        else check_qrsteps_subst (check_NF_iteration sigma q) nfs r rseq s
               (ctxt_apply c (subst_apply_term s (mk_subst Var sigma)))));

delete_value ::
  forall a b.
    (Eq a, Linorder b) => (a -> Maybe b) -> a -> Rbt b [a] -> Rbt b [a];
delete_value key v m =
  (case key v of {
    Nothing -> m;
    Just k ->
      (case lookup m k of {
        Nothing -> m;
        Just vs -> insert k (removeAll v vs) m;
      });
  });

insert_value ::
  forall a b.
    (Eq a, Linorder b) => (a -> Maybe b) -> a -> Rbt b [a] -> Rbt b [a];
insert_value key v m =
  (case key v of {
    Nothing -> m;
    Just k ->
      (case lookup m k of {
        Nothing -> insert k [v] m;
        Just vs -> insert k (insertb v vs) m;
      });
  });

check_ge_v :: forall a. (Poly_carrier a) => a -> [([(Nat, Nat)], a)] -> Bool;
check_ge_v v p =
  (case p of {
    [] -> True;
    [([], c)] -> less_eq c v;
    ([], c) : _ : _ -> False;
    (_ : _, c) : list -> False;
  });

check_poly_weak_anti_mono_discrete ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono_discrete p v =
  check_poly_ge p
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p);

check_poly_weak_anti_mono ::
  forall a b.
    (Ceq a, Corder a, Set_impl a,
      Ordered_semiring_0 b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono p v =
  all (\ (m, c) -> less_eq c zeroa || not (member v (image fst (set m)))) p;

check_poly_weak_anti_mono_smart ::
  forall a b.
    (Ceq a, Corder a, Eq a, Set_impl a, Eq b,
      Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_anti_mono_smart discrete =
  (if discrete then check_poly_weak_anti_mono_discrete
    else check_poly_weak_anti_mono);

check_poly_weak_mono_discrete ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono_discrete p v =
  check_poly_ge
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p)
    p;

check_poly_weak_mono ::
  forall a b.
    (Ceq a, Corder a, Set_impl a,
      Ordered_semiring_0 b) => [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono p v =
  all (\ (m, c) -> less_eq zeroa c || not (member v (image fst (set m)))) p;

check_poly_weak_mono_smart ::
  forall a b.
    (Ceq a, Corder a, Eq a, Set_impl a, Eq b,
      Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_weak_mono_smart discrete =
  (if discrete then check_poly_weak_mono_discrete else check_poly_weak_mono);

fun_of_map_fun :: forall a b. (a -> Maybe b) -> (a -> b) -> a -> b;
fun_of_map_fun m d a = (case m a of {
                         Nothing -> d a;
                         Just b -> b;
                       });

g_list_to_map_rm_basic_ops :: forall a b. (Linorder a) => [(a, b)] -> Rbt a b;
g_list_to_map_rm_basic_ops l =
  foldl (\ m (k, v) -> insert k v m) empty (reverse l);

ceta_map_of :: forall a b. (Key a) => [(a, b)] -> a -> Maybe b;
ceta_map_of ps = lookup (g_list_to_map_rm_basic_ops ps);

poly_inter_list_to_inter ::
  forall a b.
    (Poly_carrier a,
      Key b) => a -> [((b, Nat), [([(Nat, Nat)], a)])] ->
                       (b, Nat) -> [([(Nat, Nat)], a)];
poly_inter_list_to_inter def i =
  fun_of_map_fun (ceta_map_of i) (\ fn -> default_I def (snd fn));

fun_of_map_funa ::
  forall a b c. (a -> Maybe b) -> (a -> c) -> (b -> c) -> a -> c;
fun_of_map_funa m d f a = (case m a of {
                            Nothing -> d a;
                            Just aa -> f aa;
                          });

create_dep ::
  forall a b.
    (Eq a, Poly_carrier a, Eq b,
      Key b) => Bool ->
                  a -> [((b, Nat), [([(Nat, Nat)], a)])] ->
                         (b, Nat) -> Nat -> Dependance;
create_dep discrete def i =
  let {
    fs = remdups (map fst i);
    ii = poly_inter_list_to_inter def i;
    fsres =
      map (\ fn ->
            let {
              p = ii fn;
              vars = poly_vars_list p;
              is = upt Zero_nat (snd fn);
              a = map (\ ia ->
                        (if membera vars ia
                          then (if check_poly_weak_mono_smart discrete p ia
                                 then Increase
                                 else (if check_poly_weak_anti_mono_smart
    discrete p ia
then Decrease else Wild))
                          else Ignore))
                    is;
            } in (fn, a))
        fs;
    iii = fun_of_map_funa (ceta_map_of fsres) (\ _ _ -> Increase) nth;
  } in iii;

xml_tag :: forall a b c. Cert_problem a b c -> [Prelude.Char];
xml_tag (TRS_Termination_Proof uu uv uw (Just ux) uy) =
  ['<', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm', 'i', 'n',
    'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (TRS_Termination_Proof uz va vb Nothing vc) =
  ['<', 't', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
    'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (Complexity_Proof vd ve vf vg vh vi) =
  ['<', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'P', 'r', 'o', 'o',
    'f', '>'];
xml_tag (TRS_Nontermination_Proof vj vk vl vm) =
  ['<', 't', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
    'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (Outermost_Nontermination_Proof vn vo) =
  ['<', 't', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
    'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (Outermost_Termination_Proof vp vq) =
  ['<', 't', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
    'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (FP_Nontermination_Proof vr vs vt) =
  ['<', 't', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
    'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (FP_Termination_Proof vu vv vw) =
  ['<', 't', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
    'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (CS_Nontermination_Proof vx vy vz) =
  ['<', 't', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
    'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (CS_Termination_Proof wa wb wc) =
  ['<', 't', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
    'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (Relative_TRS_Nontermination_Proof wd we wf wg wh) =
  ['<', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'N', 'o', 'n', 't', 'e', 'r',
    'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (DP_Termination_Proof wi wj wk wl wm wn wo wp) =
  ['<', 'd', 'p', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (DP_Nontermination_Proof wq wr ws wt wu wv) =
  ['<', 'd', 'p', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
    'o', 'n', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (TRS_Confluence_Proof ww wx wy) =
  ['<', 'c', 'r', 'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (TRS_Non_Confluence_Proof wz xa xb) =
  ['<', 'c', 'r', 'D', 'i', 's', 'p', 'r', 'o', 'o', 'f', '>'];
xml_tag (Completion_Proof xc xd xe) =
  ['<', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o',
    'f', '>'];
xml_tag (Equational_Proof xf xg xh) =
  ['<', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o', 'o',
    'f', '>'];
xml_tag (Equational_Disproof xi xj xk) =
  ['<', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'D', 'i', 's', 'p',
    'r', 'o', 'o', 'f', '>'];
xml_tag (Quasi_Reductive_Proof xl xm) =
  ['<', 'q', 'u', 'a', 's', 'i', 'R', 'e', 'd', 'u', 'c', 't', 'i', 'v', 'e',
    'P', 'r', 'o', 'o', 'f', '>'];
xml_tag (Unknown_Proof xn xo) =
  ['<', 'u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't', 'P', 'r',
    'o', 'o', 'f', '>'];
xml_tag (Unknown_Disproof xp xq) =
  ['<', 'u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't', 'P', 'r',
    'o', 'o', 'f', '>'];

enfc_q ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  (Term a [Prelude.Char] -> Bool) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      [Term a [Prelude.Char]] ->
                        [Term a [Prelude.Char]] ->
                          Term a [Prelude.Char] -> Bool;
enfc_q isQnf isRnf r q s (Var x) = True;
enfc_q isQnf isRnf r q s (Fun f ts) =
  all (\ qa ->
        (case mgu_class (Fun f (map (icap_impla r q s) ts)) qa of {
          Nothing -> True;
          Just mu ->
            not (all (\ u ->
                       isQnf (subst_apply_term (map_vars (\ a -> 'x' : a) u)
                               mu))
                   s &&
                  isRnf (subst_apply_term (map_vars (\ a -> 'y' : a) qa) mu));
        }))
    q;

delete_values ::
  forall a b.
    (Eq a, Linorder b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
delete_values uu [] m = m;
delete_values key (v : vs) m = delete_value key v (delete_values key vs m);

delete_rules ::
  forall a b c.
    (Eq a, Eq b, Linorder b,
      Eq c) => a -> [(Term b c, Term b c)] ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        Rbt (b, Nat) [(a, (Term b c, Term b c))];
delete_rules a rs = delete_values key (map (\ b -> (a, b)) rs);

insert_values ::
  forall a b.
    (Eq a, Linorder b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
insert_values uu [] m = m;
insert_values key (v : vs) m = insert_value key v (insert_values key vs m);

insert_rules ::
  forall a b c.
    (Eq a, Eq b, Linorder b,
      Eq c) => a -> [(Term b c, Term b c)] ->
                      Rbt (b, Nat) [(a, (Term b c, Term b c))] ->
                        Rbt (b, Nat) [(a, (Term b c, Term b c))];
insert_rules a rs = insert_values key (map (\ b -> (a, b)) rs);

split_rulesc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_rulesc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = split_rules;

split_pairsa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] ->
             ([(Term b c, Term b c)], [(Term b c, Term b c)]);
split_pairsa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = split_pairs;

delete_R_Rwc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_R_Rwc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = delete_R_Rw;

delete_P_Pwa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
delete_P_Pwa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = delete_P_Pw;

minimal :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
minimal
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = minimal;

nfsc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
nfsc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
       rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
       reverse_rules_map intersect_pairs replace_pair intersect_rules
       delete_P_Pw delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules
       more)
  = nfs;

mkc ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      Bool ->
        Bool ->
          [(Term b c, Term b c)] ->
            [(Term b c, Term b c)] ->
              [Term b c] ->
                [(Term b c, Term b c)] -> [(Term b c, Term b c)] -> a;
mkc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = mk;

qc :: forall a b c d. Dpp_ops_ext a b c d -> a -> [Term b c];
qc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = q;

split_proc ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> [(Term b c, Term b c)] ->
                           [(Term b c, Term b c)] -> (a, a);
split_proc i d p_remove r_remove =
  let {
    (p, pw) = split_pairsa i d p_remove;
    (r, rw) = split_rulesc i d r_remove;
    dpp1 = mkc i (nfsc i d) (minimal i d) p pw (qc i d) r rw;
    a = delete_R_Rwc i (delete_P_Pwa i d p_remove p_remove) r_remove r_remove;
  } in (dpp1, a);

map_subst_domain ::
  forall a b c d. (a -> b) -> (b -> Term c d) -> a -> Term c d;
map_subst_domain m sigma = (\ v -> sigma (m v));

subst_apply_ctxt :: forall a b c. Ctxt a b -> (b -> Term a c) -> Ctxt a c;
subst_apply_ctxt Hole sigma = Hole;
subst_apply_ctxt (More f ss1 d ss2) sigma =
  More f (map (\ t -> subst_apply_term t sigma) ss1) (subst_apply_ctxt d sigma)
    (map (\ t -> subst_apply_term t sigma) ss2);

shows_ctxt ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Ctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_ctxt fun var Hole = shows_string ['[', ']'];
shows_ctxt fun var (More f ss1 d ss2) =
  fun f .
    shows_string ['('] .
      shows_list_gen (shows_term fun var) [] [] [',', ' '] [',', ' '] ss1 .
        shows_ctxt fun var d .
          shows_list_gen (shows_term fun var) [')'] [',', ' '] [',', ' '] [')']
            ss2;

sup_seta ::
  forall a.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a,
      Set_impl a) => Set (Set a) -> Set a;
sup_seta (RBT_set rbt) =
  (case (corder_set :: Maybe (Set a -> Set a -> Bool, Set a -> Set a -> Bool))
    of {
    Nothing ->
      error "Sup RBT_set: corder = None" (\ _ -> sup_seta (RBT_set rbt));
    Just _ -> foldc sup_set rbt bot_set;
  });
sup_seta (DList_set dxs) =
  (case (ceq_set :: Maybe (Set a -> Set a -> Bool)) of {
    Nothing ->
      error "Sup DList_set: ceq = None" (\ _ -> sup_seta (DList_set dxs));
    Just _ -> foldd sup_set dxs bot_set;
  });
sup_seta (Set_Monad xs) = fold sup_set xs bot_set;

ta_final :: forall a b c. Ta_ext a b c -> Set a;
ta_final (Ta_ext ta_final ta_rules ta_eps more) = ta_final;

r_states :: forall a b. (Ceq a, Corder a, Set_impl a) => Ta_rule a b -> Set a;
r_states = (\ ta_rule -> inserta (r_rhs ta_rule) (set (r_lhs_states ta_rule)));

ta_states ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b, Linorder b) => Ta_ext a b () -> Set a;
ta_states ta =
  sup_set
    (sup_set (sup_seta (image r_states (ta_rules ta)))
      (sup_seta
        (image (\ (q, qa) -> inserta q (inserta qa bot_set)) (ta_eps ta))))
    (ta_final ta);

ta_syms ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b, Linorder b,
      Set_impl b) => Ta_ext a b () -> Set (b, Nat);
ta_syms ta = image r_sym (ta_rules ta);

prod_ta ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Ceq b, Corder b, Eq b, Linorder b, Set_impl b, Finite_UNIV c,
      Cenum c, Ceq c, Cproper_interval c, Eq c, Linorder c,
      Set_impl c) => Ta_ext a b () ->
                       Ta_ext c b () -> Set (a, c) -> Ta_ext (a, c) b ();
prod_ta tA1 tA2 f =
  Ta_ext f
    (image
      (\ (TA_rule fa qs1 q1, TA_rule _ qs2 q2) ->
        TA_rule fa (zip qs1 qs2) (q1, q2))
      (sup_seta
        (image
          (\ fa ->
            productc (filtera (\ r -> r_sym r == fa) (ta_rules tA1))
              (filtera (\ r -> r_sym r == fa) (ta_rules tA2)))
          (ta_syms tA1))))
    (sup_set
      (image (\ (a, b) -> let {
                            (q, qa) = a;
                          } in (\ p -> ((q, p), (qa, p)))
                            b)
        (productc (ta_eps tA1) (ta_states tA2)))
      (image (\ (p, (q, qa)) -> ((p, q), (p, qa)))
        (productc (ta_states tA1) (ta_eps tA2))))
    ();

reduced_TA ::
  forall a b c.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b, Linorder b,
      Set_impl b) => a -> Ta_ext b a c -> Set b -> Ta_ext b a ();
reduced_TA f ta q =
  Ta_ext bot_set
    (sup_set
      (image
        (\ (TA_rule fa qs a) ->
          TA_rule fa (filter (\ qa -> not (member qa q)) qs) a)
        (filtera (\ r -> not (member (r_rhs r) q)) (ta_rules ta)))
      (image (\ p -> TA_rule f [] (snd p))
        (filtera (\ p -> member (fst p) q && not (member (snd p) q))
          (ta_eps ta))))
    (filtera (\ p -> not (member (fst p) q) && not (member (snd p) q))
      (ta_eps ta))
    ();

new_reach ::
  forall a b c.
    (Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b,
      Linorder b) => Ta_ext a b c -> Set a;
new_reach ta =
  image r_rhs (filtera (\ r -> null (r_lhs_states r)) (ta_rules ta));

ta_reachable_states ::
  forall a b.
    (Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Default b, Eq b,
      Linorder b) => Ta_ext a b () -> Set a;
ta_reachable_states ta =
  let {
    q = new_reach ta;
  } in (if less_eq_set q bot_set then bot_set
         else sup_set q (ta_reachable_states (reduced_TA defaulta ta q)));

productive_relation ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b, Linorder b) => Ta_ext a b () -> Set (a, a);
productive_relation ta =
  sup_set (image (\ (a, b) -> (b, a)) (ta_eps ta))
    (sup_seta
      (image (\ r -> image (\ a -> (r_rhs r, a)) (set (r_lhs_states r)))
        (ta_rules ta)));

ta_productive ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b, Linorder b) => Ta_ext a b () -> Set a;
ta_productive ta =
  sup_set (ta_final ta) (compute_trancl (ta_final ta) (productive_relation ta));

ta_restrict ::
  forall a b c.
    (Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b,
      Linorder b) => Ta_ext a b c -> Set a -> Ta_ext a b ();
ta_restrict ta q =
  Ta_ext (inf_set (ta_final ta) q)
    (filtera (\ r -> less_eq_set (r_states r) q) (ta_rules ta))
    (inf_set (ta_eps ta) (productc q q)) ();

trim_ta ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Default b, Eq b,
      Linorder b) => Ta_ext a b () -> Ta_ext a b ();
trim_ta ta =
  (if finite (ta_states ta)
    then let {
           taa = ta_restrict (ta_restrict ta (ta_reachable_states ta))
                   (ta_productive (ta_restrict ta (ta_reachable_states ta)));
         } in (if set_eq (ta_states ta) (ta_states taa) then ta
                else trim_ta taa)
    else ta);

check_subseteq :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_subseteq xs ys =
  catcha (forallM (\ x -> (if membera ys x then Inr () else Inl x)) xs)
    (\ x -> Inl (snd x));

check_varcond_subset ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_varcond_subset r =
  catcha
    (forallM
      (\ rule ->
        catcha
          (check_subseteq (vars_term_list (snd rule))
            (vars_term_list (fst rule)))
          (\ x ->
            Inl (shows_string
                   ['f', 'r', 'e', 'e', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
                     'e', ' '] .
                  shows_prec Zero_nat x .
                    shows_string
                      [' ', 'i', 'n', ' ', 'r', 'i', 'g', 'h', 't', '-', 'h',
                        'a', 'n', 'd', ' ', 's', 'i', 'd', 'e', ' ', 'o', 'f',
                        ' ', 'r', 'u', 'l', 'e', ' '] .
                      shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                        [' ', '-', '>', ' '] rule .
                        shows_nl)))
      r)
    (\ x -> Inl (snd x));

check_wf_trs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_trs r =
  catcha
    (bindb
      (catcha
        (forallM
          (\ rule ->
            check (not (is_Var (fst rule)))
              (shows_string
                 ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'l', 'e', 'f',
                   't', '-', 'h', 'a', 'n', 'd', ' ', 's', 'i', 'd', 'e', ' ',
                   'i', 'n', ' ', 'r', 'u', 'l', 'e', ' '] .
                shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                  [' ', '-', '>', ' '] rule .
                  shows_nl))
          r)
        (\ x -> Inl (snd x)))
      (\ _ -> check_varcond_subset r))
    (\ x ->
      Inl (shows_string
             ['t', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n', 'o',
               't', ' ', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e',
               'd'] .
            shows_nl . x));

defined_list :: forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)];
defined_list r =
  remdups
    (concatMap (\ (l, _) -> (if not (is_Var l) then [the (root l)] else [])) r);

map_rules_wa ::
  forall a b c.
    ((a, Nat) -> b) -> [(Term a c, Term a c)] -> [(Term b c, Term b c)];
map_rules_wa fg r = map (\ (l, ra) -> (map_term_wa fg l, map_term_wa fg ra)) r;

generate_f_xs :: forall a. a -> Nat -> Term a [Prelude.Char];
generate_f_xs f n = Fun f (map (\ i -> Var (generate_var i)) (upt Zero_nat n));

closed_criterion :: Xml -> Sum_bot [Prelude.Char] (Ta_relation [Prelude.Char]);
closed_criterion =
  singleton ['c', 'r', 'i', 't', 'e', 'r', 'i', 'o', 'n']
    (options
      [(['c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y'],
         leaf ['c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y']
           Id_Relation),
        (['s', 't', 'a', 't', 'e', 'C', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'i',
           'l', 'i', 't', 'y'],
          singleton
            ['s', 't', 'a', 't', 'e', 'C', 'o', 'm', 'p', 'a', 't', 'i', 'b',
              'i', 'l', 'i', 't', 'y']
            (many ['r', 'e', 'l', 'a', 't', 'i', 'o', 'n']
              (pair ['e', 'n', 't', 'r', 'y'] state state (\ a b -> (a, b))) id)
            Some_Relation),
        (['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', 'P', 'r', 'o', 'c', 'e', 'd',
           'u', 'r', 'e'],
          leaf ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', 'P', 'r', 'o', 'c', 'e',
                 'd', 'u', 'r', 'e']
            Decision_Proc)])
    id;

final_states :: Xml -> Sum_bot [Prelude.Char] [[Prelude.Char]];
final_states =
  many ['f', 'i', 'n', 'a', 'l', 'S', 't', 'a', 't', 'e', 's'] state id;

transitions ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]])) ->
      Xml ->
        Sum_bot [Prelude.Char]
          ([Ta_rule [Prelude.Char] a], [([Prelude.Char], [Prelude.Char])]);
transitions xml2lhs =
  many ['t', 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', 's']
    (transition xml2lhs)
    (\ rls ->
      let {
        (rules, eps) =
          partition (\ a -> (case a of {
                              Inl _ -> True;
                              Inr _ -> False;
                            }))
            rls;
        ruls = map (\ (Inl r) -> r) rules;
        a = map (\ (Inr e) -> e) eps;
      } in (ruls, a));

tree_automaton ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]])) ->
      Xml -> Sum_bot [Prelude.Char] (Tree_automaton [Prelude.Char] a);
tree_automaton xml2lhs =
  pair ['t', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n']
    final_states (transitions xml2lhs) (\ f (a, b) -> Tree_Automaton f a b);

ta_bounds_lhs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ((a, Nat), [[Prelude.Char]]);
ta_bounds_lhs xml2name =
  many2 ['l', 'h', 's'] xml2name (nata ['h', 'e', 'i', 'g', 'h', 't']) state
    (\ f h -> (\ a -> ((f, h), a)));

bounds_bound :: Xml -> Sum_bot [Prelude.Char] Nat;
bounds_bound = nata ['b', 'o', 'u', 'n', 'd'];

bounds_type :: Xml -> Sum_bot [Prelude.Char] Boundstype;
bounds_type =
  singleton ['t', 'y', 'p', 'e']
    (options
      [(['r', 'o', 'o', 'f'], leaf ['r', 'o', 'o', 'f'] Roof),
        (['m', 'a', 't', 'c', 'h'], leaf ['m', 'a', 't', 'c', 'h'] Match)])
    id;

bounds_info ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Bounds_info a [Prelude.Char]);
bounds_info xml2name =
  guard (\ x -> equal_nat (num_children x) (Nat_of_num (Bit0 (Bit0 One))))
    (tuple4 ['b', 'o', 'u', 'n', 'd', 's'] bounds_type bounds_bound final_states
      (tree_automaton (ta_bounds_lhs xml2name))
      (\ a b c d -> Bounds_Info a b c d Id_Relation))
    (tuple5 ['b', 'o', 'u', 'n', 'd', 's'] bounds_type bounds_bound final_states
      (tree_automaton (ta_bounds_lhs xml2name)) closed_criterion Bounds_Info);

word_pattern ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ([a], ((Nat, (Nat, [a])), [a]));
word_pattern xml2name =
  let {
    s = string xml2name;
  } in tuple5 ['w', 'o', 'r', 'd', 'P', 'a', 't', 't', 'e', 'r', 'n'] s s
         (nata ['f', 'a', 'c', 't', 'o', 'r'])
         (nata ['c', 'o', 'n', 's', 't', 'a', 'n', 't']) s
         (\ l m f c r -> (l, ((f, (c, m)), r)));

derivation_pattern ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])));
derivation_pattern xml2name =
  pair ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'P', 'a', 't', 't',
         'e', 'r', 'n']
    (word_pattern xml2name) (word_pattern xml2name) (\ a b -> (a, b));

derivation_pattern_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Dp_proof_step a);
derivation_pattern_proof xml2name =
  let {
    oc = oc_srs xml2name;
    dp = derivation_pattern xml2name;
    s = string xml2name;
  } in singleton
         ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'P', 'a', 't', 't',
           'e', 'r', 'n', 'P', 'r', 'o', 'o', 'f']
         (options
           [(['O', 'C', '1'],
              pair ['O', 'C', '1'] oc (bool ['i', 's', 'P', 'a', 'i', 'r'])
                OC1),
             (['O', 'C', '2'], tuple6 ['O', 'C', '2'] oc oc oc s s s OC2),
             (['O', 'C', '2', 'p', 'r', 'i', 'm', 'e'],
               tuple6 ['O', 'C', '2', 'p', 'r', 'i', 'm', 'e'] oc oc oc s s s
                 OC2p),
             (['O', 'C', '3'], tuple5 ['O', 'C', '3'] oc oc oc s s OC3),
             (['O', 'C', '3', 'p', 'r', 'i', 'm', 'e'],
               tuple5 ['O', 'C', '3', 'p', 'r', 'i', 'm', 'e'] oc oc oc s s
                 OC3p),
             (['O', 'C', 'i', 'n', 't', 'o', 'D', 'P', '1'],
               pair ['O', 'C', 'i', 'n', 't', 'o', 'D', 'P', '1'] dp oc OCDP1),
             (['O', 'C', 'i', 'n', 't', 'o', 'D', 'P', '2'],
               pair ['O', 'C', 'i', 'n', 't', 'o', 'D', 'P', '2'] dp oc OCDP2),
             (['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 't'],
               pair ['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 't'] dp dp
                 WPEQ),
             (['l', 'i', 'f', 't'], pair ['l', 'i', 'f', 't'] dp dp Lift),
             (['D', 'P', '_', 'O', 'C', '_', '1', '_', '1'],
               tuple5 ['D', 'P', '_', 'O', 'C', '_', '1', '_', '1'] dp dp oc s s
                 DPOC1_1),
             (['D', 'P', '_', 'O', 'C', '_', '1', '_', '2'],
               tuple6 ['D', 'P', '_', 'O', 'C', '_', '1', '_', '2'] dp dp oc s s
                 s DPOC1_2),
             (['D', 'P', '_', 'O', 'C', '_', '2'],
               tuple5 ['D', 'P', '_', 'O', 'C', '_', '2'] dp dp oc s s DPOC2),
             (['D', 'P', '_', 'O', 'C', '_', '3', '_', '1'],
               tuple5 ['D', 'P', '_', 'O', 'C', '_', '3', '_', '1'] dp dp oc s s
                 DPOC3_1),
             (['D', 'P', '_', 'O', 'C', '_', '3', '_', '2'],
               tuple6 ['D', 'P', '_', 'O', 'C', '_', '3', '_', '2'] dp dp oc s s
                 s DPOC3_2),
             (['D', 'P', '_', 'D', 'P', '_', '1', '_', '1'],
               tuple5 ['D', 'P', '_', 'D', 'P', '_', '1', '_', '1'] dp dp dp s s
                 DPDP1_1),
             (['D', 'P', '_', 'D', 'P', '_', '1', '_', '2'],
               tuple5 ['D', 'P', '_', 'D', 'P', '_', '1', '_', '2'] dp dp dp s s
                 DPDP1_2),
             (['D', 'P', '_', 'D', 'P', '_', '2', '_', '1'],
               tuple5 ['D', 'P', '_', 'D', 'P', '_', '2', '_', '1'] dp dp dp s s
                 DPDP2_1),
             (['D', 'P', '_', 'D', 'P', '_', '2', '_', '2'],
               tuple5 ['D', 'P', '_', 'D', 'P', '_', '2', '_', '2'] dp dp dp s s
                 DPDP2_2)])
         id;

nonloop_srs_reason ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] ([Dp_proof_step a] -> Non_loop_srs_proof a);
nonloop_srs_reason xml2name =
  let {
    s = string xml2name;
  } in options
         [(['s', 'e', 'l', 'f', 'E', 'm', 'b', 'e', 'd', 'd', 'i', 'n', 'g',
             'O', 'C'],
            triple
              ['s', 'e', 'l', 'f', 'E', 'm', 'b', 'e', 'd', 'd', 'i', 'n', 'g',
                'O', 'C']
              s s s (\ l m r -> SE_OC (m, l ++ m ++ r) l r)),
           (['s', 'e', 'l', 'f', 'E', 'm', 'b', 'e', 'd', 'd', 'i', 'n', 'g',
              'D', 'P'],
             triple
               ['s', 'e', 'l', 'f', 'E', 'm', 'b', 'e', 'd', 'd', 'i', 'n', 'g',
                 'D', 'P']
               (derivation_pattern xml2name) s s SE_DP)];

nonloop_srs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Non_loop_srs_proof a);
nonloop_srs xml2name =
  pair ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'n', 'g',
         'S', 'R', 'S']
    (many ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'P', 'a', 't', 't',
            'e', 'r', 'n', 's']
      (derivation_pattern_proof xml2name) id)
    (nonloop_srs_reason xml2name) (\ list prf -> prf list);

label_decomp :: forall a b. Lab a b -> (Lab a b, Sum b [Lab a b]);
label_decomp (Lab f l) = (f, Inl l);
label_decomp (FunLab f l) = (f, Inr l);

is_partition_impl ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a,
      Set_impl a) => [Set a] -> Maybe (Set a);
is_partition_impl [] = Just bot_set;
is_partition_impl (asa : rest) =
  bind (is_partition_impl rest)
    (\ alla ->
      (if is_empty (inf_set asa alla) then Just (sup_set alla asa)
        else Nothing));

is_partition ::
  forall a.
    (Card_UNIV a, Ceq a, Cproper_interval a, Set_impl a) => [Set a] -> Bool;
is_partition asa = not (is_none (is_partition_impl asa));

sequences :: forall a b. (Linorder b) => (a -> b) -> [a] -> [[a]];
sequences key (a : b : xs) =
  (if less (key b) (key a) then desca key b [a] xs
    else asc key b (\ ba -> a : ba) xs);
sequences key [] = [[]];
sequences key [v] = [[v]];

asc ::
  forall a b. (Linorder b) => (a -> b) -> a -> ([a] -> [a]) -> [a] -> [[a]];
asc key a f (b : bs) =
  (if not (less (key b) (key a)) then asc key b (f . (\ ba -> a : ba)) bs
    else f [a] : sequences key (b : bs));
asc key a f [] = f [a] : sequences key [];

desca :: forall a b. (Linorder b) => (a -> b) -> a -> [a] -> [a] -> [[a]];
desca key a asa (b : bs) =
  (if less (key b) (key a) then desca key b (a : asa) bs
    else (a : asa) : sequences key (b : bs));
desca key a asa [] = (a : asa) : sequences key [];

mergea :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a] -> [a];
mergea key (a : asa) (b : bs) =
  (if less (key b) (key a) then b : mergea key (a : asa) bs
    else a : mergea key asa (b : bs));
mergea key [] bs = bs;
mergea key (v : va) [] = v : va;

merge_pairs :: forall a b. (Linorder b) => (a -> b) -> [[a]] -> [[a]];
merge_pairs key (a : b : xs) = mergea key a b : merge_pairs key xs;
merge_pairs key [] = [];
merge_pairs key [v] = [v];

merge_alla :: forall a b. (Linorder b) => (a -> b) -> [[a]] -> [a];
merge_alla key [] = [];
merge_alla key [x] = x;
merge_alla key (v : vb : vc) = merge_alla key (merge_pairs key (v : vb : vc));

sort_key :: forall a b. (Linorder b) => (a -> b) -> [a] -> [a];
sort_key key = merge_alla key . sequences key;

remdups_sort :: forall a. (Eq a, Linorder a) => [a] -> [a];
remdups_sort xs = remdups_adj (sort_key (\ x -> x) xs);

swap :: forall a b. (a, b) -> (b, a);
swap p = (snd p, fst p);

set_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
set_ext s_ns =
  (\ asa bs ->
    (not (null asa) && all (\ b -> any (\ a -> fst (s_ns a b)) asa) bs,
      all (\ b -> any (\ a -> snd (s_ns a b)) asa) bs));

check_no_var ::
  forall a b.
    (Showa a, Showa b) => Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_var t =
  check (not (is_Var t))
    (shows_string
       ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'f', 'o', 'u', 'n', 'd'] .
      shows_nl);

check_supteq ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Term a b ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_supteq s t =
  check (equal_term s t || supt_impl s t)
    (shows_prec_term Zero_nat t .
      shows_string
        [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 't',
          'e', 'r', 'm', ' ', 'o', 'f', ' '] .
        shows_prec_term Zero_nat s);

ta_empty ::
  forall a b.
    (Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Default b, Eq b,
      Linorder b) => Ta_ext a b () -> Bool;
ta_empty ta =
  less_eq_set (inf_set (ta_reachable_states ta) (ta_final ta)) bot_set;

ta_match ::
  forall a b c.
    (Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b, Linorder b,
      Ceq c,
      Corder c) => Ta_ext a b () -> Set a -> Term b c -> Set a -> Set [(c, a)];
ta_match ta qsig (Fun f ts) q =
  let {
    n = size_list ts;
    rls = filtera
            (\ rule ->
              r_sym rule == (f, n) &&
                bex (sup_set (inserta (r_rhs rule) bot_set)
                      (compute_trancl (inserta (r_rhs rule) bot_set)
                        (ta_eps ta)))
                  (\ qa -> member qa q))
            (ta_rules ta);
  } in sup_seta
         (image
           (\ (TA_rule _ qs _) ->
             image concat
               (listset
                 (map (\ (tsi, qsi) ->
                        ta_match ta qsig tsi (inserta qsi bot_set))
                   (zip ts qs))))
           rls);
ta_match ta qsig (Var x) q =
  image (\ qa -> [(x, qa)])
    (filtera (\ qa -> member qa qsig)
      (sup_set q (compute_trancl q (converse (ta_eps ta)))));

compute_NF :: forall a. (a -> Maybe a) -> a -> Maybe a;
compute_NF f a =
  (case f a of {
    Nothing -> Just a;
    Just aa -> compute_NF f aa;
  });

first_rewrite ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
first_rewrite r s = (case rewrite r s of {
                      [] -> Nothing;
                      t : _ -> Just t;
                    });

compute_rstep_NF ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] -> Term a b -> Maybe (Term a b);
compute_rstep_NF r s = compute_NF (first_rewrite r) s;

check_join_NF ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join_NF r s t =
  (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
    (Nothing, b) ->
      Inl (shows_prec_list Zero_nat
            ['s', 't', 'r', 'a', 'n', 'g', 'e', ' ', 'e', 'r', 'r', 'o', 'r',
              ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
              'r', 'm', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'a', 't', 'i', 'o',
              'n']);
    (Just sa, Nothing) ->
      Inl (shows_prec_list Zero_nat
            ['s', 't', 'r', 'a', 'n', 'g', 'e', ' ', 'e', 'r', 'r', 'o', 'r',
              ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
              'r', 'm', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'a', 't', 'i', 'o',
              'n']);
    (Just sa, Just ta) ->
      check (equal_term sa ta)
        (shows_string
           ['t', 'h', 'e', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
             'r', 'm', ' '] .
          shows_prec_term Zero_nat sa .
            shows_prec_list Zero_nat [' ', 'o', 'f', ' '] .
              shows_prec_term Zero_nat s .
                shows_prec_list Zero_nat
                  [' ', 'd', 'i', 'f', 'f', 'e', 'r', 's', ' ', 'f', 'r', 'o',
                    'm', ' '] .
                  shows_nl .
                    shows_prec_list Zero_nat
                      ['t', 'h', 'e', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ',
                        'f', 'o', 'r', 'm', ' '] .
                      shows_prec_term Zero_nat ta .
                        shows_prec_list Zero_nat [' ', 'o', 'f', ' '] .
                          shows_prec_term Zero_nat t);
  });

reverse_rules :: forall a b. [(Term a b, Term a b)] -> [(Term a b, Term a b)];
reverse_rules rs = map swap rs;

vars_trs_list :: forall a b. (Eq b) => [(Term a b, Term a b)] -> [b];
vars_trs_list trs = remdups (concatMap vars_rule_lista trs);

wf_rules_impl ::
  forall a b. (Eq b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)];
wf_rules_impl r = filter wf_rule r;

check_pairwise :: forall a b. (a -> a -> Sum b ()) -> [a] -> Sum b ();
check_pairwise c [] = Inr ();
check_pairwise c (x : xs) =
  bindb (catcha (forallM (c x) xs) (\ xa -> Inl (snd xa)))
    (\ _ -> check_pairwise c xs);

check_disjoint :: forall a. (Eq a) => [a] -> [a] -> Sum a ();
check_disjoint xs ys =
  catcha (forallM (\ x -> (if not (membera ys x) then Inr () else Inl x)) xs)
    (\ x -> Inl (snd x));

check_partition :: forall a. (Eq a) => [[a]] -> Sum a ();
check_partition xss = check_pairwise check_disjoint xss;

check_inj ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => Lab a b ->
                    Nat ->
                      [((Lab a b, Nat), [Lab a b])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_inj a nn sml =
  let {
    symbols =
      map (\ (aa, b) ->
            let {
              (_, n) = aa;
            } in (\ fs ->
                   map (\ (g, i) ->
                         (g, plus_nat n
                               (times_nat i (minus_nat nn (Nat_of_num One)))))
                     (zip fs (upt Zero_nat (size_list fs))))
              b)
        sml;
    fsymbols = concat symbols;
  } in bindb (catcha (check_partition symbols)
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
                       shows_prec_prod Zero_nat x .
                         shows_prec_list Zero_nat
                           [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 't', 'w',
                             'i', 'c', 'e', ')'])))
         (\ _ ->
           bindb (check (not (membera fsymbols (a, nn)))
                   (shows_prec_list Zero_nat
                      ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n',
                        ' ', 's', 'y', 'm', 'b', 'o', 'l'] .
                     shows_prec_lab Zero_nat a .
                       shows_prec_list Zero_nat
                         [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'o',
                           'c', 'c', 'u', 'r', ' ', 'a', 's', ' ', 'n', 'e',
                           'w', ' ', 's', 'y', 'm', 'b', 'o', 'l']))
             (\ _ ->
               bindb (check (not (membera (map fst sml) (a, nn)))
                       (shows_prec_list Zero_nat
                          ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o',
                            'n', ' ', 's', 'y', 'm', 'b', 'o', 'l'] .
                         shows_prec_lab Zero_nat a .
                           shows_prec_list Zero_nat
                             [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                               'b', 'e', ' ', 'u', 'n', 'c', 'u', 'r', 'r', 'i',
                               'e', 'd']))
                 (\ _ ->
                   (if less_eq_nat nn (Nat_of_num One)
                     then catcha
                            (forallM
                              (check_pairwise
                                (\ gn1 gn2 ->
                                  check (not (gn1 == gn2))
                                    (shows_prec_list Zero_nat
                                       ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
                                      shows_prec_prod Zero_nat gn1 .
shows_prec_list Zero_nat
  [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 't', 'w', 'i', 'c', 'e'])))
                              symbols)
                            (\ x -> Inl (snd x))
                     else Inr ()))));

apply_af_entry :: forall a b. a -> Af_entry -> [Term a b] -> Term a b;
apply_af_entry uu (Collapse i) ts = nth ts i;
apply_af_entry f (AFList is) ts = Fun f (map (nth ts) is);

afs_term ::
  forall a b. ((a, Nat) -> Af_entry) -> Term a b -> Term (Filtered a) b;
afs_term pi (Fun f ts) =
  let {
    l = size_list ts;
  } in apply_af_entry (FPair f l) (pi (f, l)) (map (afs_term pi) ts);
afs_term pi (Var x) = Var x;

afs_rule ::
  forall a b.
    ((a, Nat) -> Af_entry) ->
      (Term a b, Term a b) -> (Term (Filtered a) b, Term (Filtered a) b);
afs_rule pi lr = (afs_term pi (fst lr), afs_term pi (snd lr));

af_rule ::
  forall a b.
    ((a, Nat) -> Af_entry) -> (Term a b, Term a b) -> (Term a b, Term a b);
af_rule pi = (\ t -> map_rule filtered_fun (afs_rule pi t));

af_term :: forall a b. ((a, Nat) -> Af_entry) -> Term a b -> Term a b;
af_term pi t = map_term filtered_fun (afs_term pi t);

uncurry_info ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (a, ([((a, Nat), [a])],
                ([(Term a [Prelude.Char], Term a [Prelude.Char])],
                  [(Term a [Prelude.Char], Term a [Prelude.Char])])));
uncurry_info xml2name =
  tuple4
    ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'I', 'n', 'f', 'o', 'r', 'm', 'a', 't',
      'i', 'o', 'n']
    xml2name
    (many ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', 'S', 'y', 'm', 'b', 'o',
            'l', 's']
      (many2
        ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', 'S', 'y', 'm', 'b', 'o',
          'l', 'E', 'n', 't', 'r', 'y']
        xml2name (nata ['a', 'r', 'i', 't', 'y']) xml2name
        (\ f n -> (\ a -> ((f, n), a))))
      id)
    (singleton ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'R', 'u', 'l', 'e', 's']
      (rules xml2name) id)
    (singleton ['e', 't', 'a', 'R', 'u', 'l', 'e', 's'] (rules xml2name) id)
    (\ a sml u e -> (a, (sml, (u, e))));

level_mapping ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [((a, Nat), [(Nat, Nat)])];
level_mapping xml2name =
  many ['l', 'e', 'v', 'e', 'l', 'M', 'a', 'p', 'p', 'i', 'n', 'g']
    (many2
      ['l', 'e', 'v', 'e', 'l', 'M', 'a', 'p', 'p', 'i', 'n', 'g', 'E', 'n',
        't', 'r', 'y']
      xml2name (nata ['a', 'r', 'i', 't', 'y'])
      (pair ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', 'L', 'e', 'v', 'e', 'l',
              'E', 'n', 't', 'r', 'y']
        (nata ['p', 'o', 's', 'i', 't', 'i', 'o', 'n'])
        (nata ['l', 'e', 'v', 'e', 'l']) (\ a b -> (a, b)))
      (\ f a ps ->
        ((f, a),
          map (\ (p, b) ->
                ((if equal_nat p Zero_nat then a
                   else minus_nat p (Nat_of_num One)),
                  b))
            ps)))
    id;

root_redtriple ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Root_redtriple_impl a);
root_redtriple xml2name =
  singleton ['r', 'e', 'd', 'P', 'a', 'i', 'r']
    (triple ['s', 'c', 'n', 'p']
      (singleton ['s', 't', 'a', 't', 'u', 's']
        (options
          [(['m', 's'], leaf ['m', 's'] MS_Ext),
            (['m', 'i', 'n'], leaf ['m', 'i', 'n'] Min_Ext),
            (['d', 'm', 's'], leaf ['d', 'm', 's'] Dms_Ext),
            (['m', 'a', 'x'], leaf ['m', 'a', 'x'] Max_Ext)])
        id)
      (level_mapping xml2name) (redtriple False xml2name) SCNP)
    id;

root_ordering_constraint_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Root_redtriple_impl a);
root_ordering_constraint_proof xml2name =
  singleton
    ['o', 'r', 'd', 'e', 'r', 'i', 'n', 'g', 'C', 'o', 'n', 's', 't', 'r', 'a',
      'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
    (root_redtriple xml2name) id;

ordering_constraint_proof ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml -> Sum_bot [Prelude.Char] (Redtriple_impl a);
ordering_constraint_proof bi xml2name =
  singleton
    ['o', 'r', 'd', 'e', 'r', 'i', 'n', 'g', 'C', 'o', 'n', 's', 't', 'r', 'a',
      'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
    (redtriple bi xml2name) id;

ordering_constraint_proofa ::
  forall a.
    Bool ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml ->
          Sum_bot [Prelude.Char]
            (Sum (Root_redtriple_impl a) (Redtriple_impl a));
ordering_constraint_proofa bi xml2name =
  choice ['r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r']
    [change (ordering_constraint_proof bi xml2name) Inr,
      change (root_ordering_constraint_proof xml2name) Inl];

create_proj :: forall a. (Key a) => ProjL a -> (a, Nat) -> Nat;
create_proj (Projection p) =
  let {
    i = ceta_map_of p;
  } in (\ f -> (case i f of {
                 Nothing -> Zero_nat;
                 Just n -> n;
               }));

xml2cond_constraint ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Cond_constraint a [Prelude.Char]);
xml2cond_constraint xml2name x =
  singleton
    ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o', 'n', 's',
      't', 'r', 'a', 'i', 'n', 't']
    (options
      [(['a', 'l', 'l'],
         pair ['a', 'l', 'l'] (text ['v', 'a', 'r'])
           (xml2cond_constraint xml2name) CC_all),
        (['i', 'm', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n'],
          many1 ['i', 'm', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n']
            (xml2cond_constraint xml2name) (xml2cond_constraint xml2name)
            (\ c cs ->
              let {
                ccs = c : cs;
              } in CC_impl (take (size_list cs) ccs) (last ccs))),
        (['c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't'],
          triple ['c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't']
            (term xml2name)
            (options
              [(['r', 'e', 'w', 'r', 'i', 't', 'e'],
                 leaf ['r', 'e', 'w', 'r', 'i', 't', 'e'] Nothing),
                (['s', 't', 'r', 'i', 'c', 't'],
                  leaf ['s', 't', 'r', 'i', 'c', 't'] (Just True)),
                (['n', 'o', 'n', 'S', 't', 'r', 'i', 'c', 't'],
                  leaf ['n', 'o', 'n', 'S', 't', 'r', 'i', 'c', 't']
                    (Just False))])
            (term xml2name)
            (\ s rel t ->
              (case rel of {
                Nothing -> CC_rewr s t;
                Just stri -> CC_cond stri (s, t);
              })))])
    id x;

xml2cond_constraint_prf ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Cond_constraint_prf a [Prelude.Char]);
xml2cond_constraint_prf xml2name x =
  let {
    cc = xml2cond_constraint xml2name;
  } in singleton
         ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o', 'n',
           's', 't', 'r', 'a', 'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
         (options
           [(['f', 'i', 'n', 'a', 'l'], leaf ['f', 'i', 'n', 'a', 'l'] Final),
             (['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', 'C', 'o', 'n', 's',
                't', 'r', 'u', 'c', 't', 'o', 'r'],
               singleton
                 ['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', 'C', 'o', 'n',
                   's', 't', 'r', 'u', 'c', 't', 'o', 'r']
                 cc Different_Constructor),
             (['s', 'a', 'm', 'e', 'C', 'o', 'n', 's', 't', 'r', 'u', 'c', 't',
                'o', 'r'],
               triple
                 ['s', 'a', 'm', 'e', 'C', 'o', 'n', 's', 't', 'r', 'u', 'c',
                   't', 'o', 'r']
                 cc cc (xml2cond_constraint_prf xml2name) Same_Constructor),
             (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'E', 'q', 'u', 'a', 't',
                'i', 'o', 'n'],
               tuple4
                 ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'E', 'q', 'u', 'a',
                   't', 'i', 'o', 'n']
                 (text ['v', 'a', 'r']) (term xml2name) cc
                 (xml2cond_constraint_prf xml2name) Variable_Equation),
             (['f', 'u', 'n', 'a', 'r', 'g', 'I', 'n', 't', 'o', 'V', 'a', 'r'],
               tuple5
                 ['f', 'u', 'n', 'a', 'r', 'g', 'I', 'n', 't', 'o', 'V', 'a',
                   'r']
                 cc position (text ['v', 'a', 'r']) cc
                 (xml2cond_constraint_prf xml2name) Funarg_Into_Var),
             (['s', 'i', 'm', 'p', 'l', 'i', 'f', 'y', 'C', 'o', 'n', 'd', 'i',
                't', 'i', 'o', 'n'],
               tuple4
                 ['s', 'i', 'm', 'p', 'l', 'i', 'f', 'y', 'C', 'o', 'n', 'd',
                   'i', 't', 'i', 'o', 'n']
                 cc (substa xml2name) cc (xml2cond_constraint_prf xml2name)
                 Simplify_Condition),
             (['i', 'n', 'd', 'u', 'c', 't', 'i', 'o', 'n'],
               triple ['i', 'n', 'd', 'u', 'c', 't', 'i', 'o', 'n'] cc
                 (many ['c', 'o', 'n', 'j', 'u', 'n', 'c', 't', 's'] cc id)
                 (many ['r', 'u', 'l', 'e', 'C', 'o', 'n', 's', 't', 'r', 'a',
                         'i', 'n', 't', 'P', 'r', 'o', 'o', 'f', 's']
                   (tuple4
                     ['r', 'u', 'l', 'e', 'C', 'o', 'n', 's', 't', 'r', 'a',
                       'i', 'n', 't', 'P', 'r', 'o', 'o', 'f']
                     (rule xml2name)
                     (many ['s', 'u', 'b', 't', 'e', 'r', 'm', 'V', 'a', 'r',
                             'E', 'n', 't', 'r', 'i', 'e', 's']
                       (many1
                         ['s', 'u', 'b', 't', 'e', 'r', 'm', 'V', 'a', 'r', 'E',
                           'n', 't', 'r', 'y']
                         (term xml2name) (text ['v', 'a', 'r'])
                         (\ a b -> (a, b)))
                       id)
                     cc (xml2cond_constraint_prf xml2name)
                     (\ lr rys cca p -> (lr, (rys, (cca, p)))))
                   id)
                 Induction),
             (['d', 'e', 'l', 'e', 't', 'e', 'C', 'o', 'n', 'd', 'i', 't', 'i',
                'o', 'n'],
               pair ['d', 'e', 'l', 'e', 't', 'e', 'C', 'o', 'n', 'd', 'i', 't',
                      'i', 'o', 'n']
                 cc (xml2cond_constraint_prf xml2name) Delete_Condition)])
         id x;

xml2cond_red_pair_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Cond_red_pair_prf a [Prelude.Char]);
xml2cond_red_pair_proof xml2name =
  tuple4
    ['c', 'o', 'n', 'd', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'o',
      'f']
    xml2name (nata ['b', 'e', 'f', 'o', 'r', 'e'])
    (nata ['a', 'f', 't', 'e', 'r'])
    (many ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's']
      (triple ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n']
        (xml2cond_constraint xml2name)
        (singleton ['d', 'p', 'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e']
          (rules xml2name) id)
        (xml2cond_constraint_prf xml2name) (\ c s p -> (c, (s, p))))
      id)
    (\ c b a ccs -> Cond_Red_Pair_Prf c ccs b a);

strategy_to_Q ::
  forall a b.
    (Eq a, Eq b) => Strategy a b -> [(Term a b, Term a b)] -> [Term a b];
strategy_to_Q No_Strategy uu = [];
strategy_to_Q Innermost r = remdups (map fst r);
strategy_to_Q (Innermost_Q q) uv = q;

o_to_fp_term :: forall a b. Term a b -> (Ctxt a b, (Term a b, Location));
o_to_fp_term t = (Hole, (t, Ba));

o_to_fp_impl :: forall a b. [Term a b] -> [(Ctxt a b, (Term a b, Location))];
o_to_fp_impl = map o_to_fp_term;

mu_to_fp_impl ::
  forall a.
    (Eq a) => [((a, Nat), [Nat])] ->
                [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
mu_to_fp_impl mu =
  let {
    fs = remdups (map fst mu);
    m = map_of mu;
    a = concatMap
          (\ f ->
            let {
              xs = map Var (fresh_strings_list ['x'] Zero_nat [] (snd f));
            } in map (\ i -> (f, (xs, i)))
                   (concatMap
                     (\ i -> (if not (membera (the (m f)) i) then [i] else []))
                     (upt Zero_nat (snd f))))
          fs;
  } in concatMap
         (\ ((f, _), (xs, i)) ->
           map (\ loc ->
                 (ctxt_of_pos_term (PCons i Empty) (Fun f xs), (nth xs i, loc)))
             [Ba, H])
         a;

strategy_to_fp ::
  forall a.
    (Eq a) => Fp_strategy a [Prelude.Char] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Ctxt a [Prelude.Char], (Term a [Prelude.Char], Location))];
strategy_to_fp (Forbidden_Patterns p) r = p;
strategy_to_fp Outermost r = o_to_fp_impl (map fst r);
strategy_to_fp (Context_Sensitive mu) r = mu_to_fp_impl mu;

default_nfs_trs :: Bool;
default_nfs_trs = False;

xml2inn_fp_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Sum (Bool,
                            ([Term (Lab a b) [Prelude.Char]],
                              ([(Term (Lab a b) [Prelude.Char],
                                  Term (Lab a b) [Prelude.Char])],
                                [(Term (Lab a b) [Prelude.Char],
                                   Term (Lab a b) [Prelude.Char])])))
                       ([(Ctxt (Lab a b) [Prelude.Char],
                           (Term (Lab a b) [Prelude.Char], Location))],
                         [(Term (Lab a b) [Prelude.Char],
                            Term (Lab a b) [Prelude.Char])]));
xml2inn_fp_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        Inn_TRS_input (inn, (r, so)) ->
          returna
            (Inl (default_nfs_trs,
                   (strategy_to_Q inn r,
                     (r, (case so of {
                           Nothing -> [];
                           Just s -> s;
                         })))));
        COMP_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        EQ_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        CPX_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        FP_TRS_input (fp, r) -> returna (Inr (strategy_to_fp fp r, r));
        CTRS_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
        Unknown_input _ ->
          errora
            ['t', 'r', 's', ' ', 'a', 's', ' ', 'i', 'n', 'p', 'u', 't', ' ',
              'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'];
      }));

default_nfs_nt_dp :: Bool;
default_nfs_nt_dp = False;

default_nfs_dp :: Bool;
default_nfs_dp = True;

xml2dp_inputa ::
  forall a b.
    (Eq a,
      Eq b) => Bool ->
                 (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                   Xml ->
                     Sum_bot [Prelude.Char]
                       (Bool,
                         (Bool,
                           ([(Term (Lab a b) [Prelude.Char],
                               Term (Lab a b) [Prelude.Char])],
                             ([(Term (Lab a b) [Prelude.Char],
                                 Term (Lab a b) [Prelude.Char])],
                               ([Term (Lab a b) [Prelude.Char]],
                                 ([(Term (Lab a b) [Prelude.Char],
                                     Term (Lab a b) [Prelude.Char])],
                                   [(Term (Lab a b) [Prelude.Char],
                                      Term (Lab a b) [Prelude.Char])]))))));
xml2dp_inputa termination xml2name =
  change (xml2dp_input xml2name)
    (\ (m, (p, (q, r))) ->
      ((if termination then default_nfs_dp else default_nfs_nt_dp),
        (m, (p, ([], (strategy_to_Q q r, ([], r)))))));

xml1many2elements_gen ::
  forall a b c d e.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        (a -> Xml -> Sum_bot [Prelude.Char] b) ->
          (Xml -> Sum_bot [Prelude.Char] c) ->
            (Xml -> Sum_bot [Prelude.Char] d) ->
              (a -> [b] -> c -> d -> e) -> Xml -> Sum_bot [Prelude.Char] e;
xml1many2elements_gen tag p1 p2 p3 p4 f (XML name atts cs text) =
  let {
    ds = reverse cs;
    l = size_list cs;
  } in (if name == tag &&
             null atts && is_none text && less_eq_nat (Nat_of_num (Bit1 One)) l
         then binda (p1 (nth cs Zero_nat))
                (\ x ->
                  binda (map_sum_bot (p2 x)
                          (tl (take (minus_nat l (Nat_of_num (Bit0 One))) cs)))
                    (\ xs ->
                      binda (p3 (nth ds (Nat_of_num One)))
                        (\ y ->
                          binda (p4 (nth ds Zero_nat))
                            (\ z -> returna (f x xs y z)))))
         else fail tag (XML name atts cs text));

projected_rseq ::
  forall a.
    (Eq a) => (Xml -> Sum_bot [Prelude.Char] a) ->
                ((a, Nat) -> Nat) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      ((Term a [Prelude.Char], Term a [Prelude.Char]),
                        [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                                 Term a [Prelude.Char]))]);
projected_rseq xml2name pi (XML name atts cs text) =
  let {
    tag = ['p', 'r', 'o', 'j', 'e', 'c', 't', 'e', 'd', 'R', 'e', 'w', 'r', 'i',
            't', 'e', 'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e'];
  } in (if name == tag &&
             null atts &&
               is_none text && equal_nat (size_list cs) (Nat_of_num (Bit0 One))
         then binda (rule xml2name (nth cs Zero_nat))
                (\ r -> rseq xml2name pi r (nth cs (Nat_of_num One)))
         else fail tag (XML name atts cs text));

flat_contexts ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] [Ctxt a [Prelude.Char]];
flat_contexts xml2name =
  many ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 's']
    (ctxt xml2name) id;

xml2fp_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     ([(Ctxt (Lab a b) [Prelude.Char],
                         (Term (Lab a b) [Prelude.Char], Location))],
                       [(Term (Lab a b) [Prelude.Char],
                          Term (Lab a b) [Prelude.Char])]);
xml2fp_trs_assm xml2name x =
  binda (xml2inn_fp_trs_assm xml2name x)
    (\ a ->
      (case a of {
        Inl _ ->
          errora
            ['F', 'P', ' ', 'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't',
              'e', 'd', ' ', 'a', 't', ' ', 't', 'h', 'i', 's', ' ', 'p', 'o',
              'i', 'n', 't'];
        Inr aa -> returna aa;
      }));

xml2inn_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Bool,
                       ([Term (Lab a b) [Prelude.Char]],
                         ([(Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char])],
                           [(Term (Lab a b) [Prelude.Char],
                              Term (Lab a b) [Prelude.Char])])));
xml2inn_trs_assm xml2name x =
  binda (xml2inn_fp_trs_assm xml2name x)
    (\ a ->
      (case a of {
        Inl aa -> returna aa;
        Inr _ ->
          errora
            ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', '(', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ')', ' ', 'T', 'R', 'S', ' ', 'e',
              'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'a', 't', ' ', 't', 'h',
              'i', 's', ' ', 'p', 'o', 'i', 'n', 't'];
      }));

xml2trs_termination_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Trs_termination_proof a b [Prelude.Char]);
xml2trs_termination_proof xml2name x =
  options
    [(['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
        'P', 'r', 'o', 'o', 'f'],
       singleton
         ['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
           'P', 'r', 'o', 'o', 'f']
         (options
           [(['r', 'I', 's', 'E', 'm', 'p', 't', 'y'],
              leaf ['r', 'I', 's', 'E', 'm', 'p', 't', 'y'] R_is_Empty),
             (['s', 'e', 'm', 'l', 'a', 'b'],
               guard (\ xa ->
                       equal_nat (num_children xa) (Nat_of_num (Bit1 One)))
                 (triple ['s', 'e', 'm', 'l', 'a', 'b'] (sl_variant xml2name)
                   (singleton ['t', 'r', 's'] (rules xml2name) id)
                   (xml2trs_termination_proof xml2name)
                   (\ sli -> Semlab sli []))
                 (tuple4 ['s', 'e', 'm', 'l', 'a', 'b'] (sl_variant xml2name)
                   (singleton ['t', 'r', 's'] (rules xml2name) id)
                   (innermostLhss xml2name) (xml2trs_termination_proof xml2name)
                   (\ sli lr lq -> Semlab sli lq lr))),
             (['s', 'p', 'l', 'i', 't'],
               triple ['s', 'p', 'l', 'i', 't']
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name)
                 (xml2trs_termination_proof xml2name) Split),
             (['d', 'p', 'T', 'r', 'a', 'n', 's'],
               triple ['d', 'p', 'T', 'r', 'a', 'n', 's']
                 (singleton ['d', 'p', 's'] (rules xml2name) id)
                 (bool ['m', 'a', 'r', 'k', 'e', 'd', 'S', 'y', 'm', 'b', 'o',
                         'l', 's'])
                 (xml2dp_termination_proof xml2name)
                 (\ dps _ -> DP_Trans default_nfs_dp True dps)),
             (['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
               triple ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
                 (ordering_constraint_proof False xml2name)
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) Rule_Removal),
             (['b', 'o', 'u', 'n', 'd', 's'],
               (\ xml -> binda (bounds_info xml2name xml) (returna . Bounds))),
             (['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a',
                'l'],
               pair ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's',
                      'a', 'l']
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) (\ _ -> String_Reversal)),
             (['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U', 'n', 'a',
                'r', 'y'],
               tuple4
                 ['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U', 'n',
                   'a', 'r', 'y']
                 plain_var (renaming xml2name)
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name)
                 (\ v ren s ->
                   Constant_String (Const_string_sound_proof v ren s))),
             (['r', 'e', 'm', 'o', 'v', 'e', 'N', 'o', 'n', 'A', 'p', 'p', 'l',
                'i', 'c', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's'],
               pair ['r', 'e', 'm', 'o', 'v', 'e', 'N', 'o', 'n', 'A', 'p', 'p',
                      'l', 'i', 'c', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e',
                      's']
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name)
                 Remove_Nonapplicable_Rules),
             (['u', 'n', 'c', 'u', 'r', 'r', 'y'],
               triple ['u', 'n', 'c', 'u', 'r', 'r', 'y']
                 (uncurry_info xml2name)
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) Uncurry),
             (['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C', 'l',
                'o', 's', 'u', 'r', 'e'],
               triple
                 ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C',
                   'l', 'o', 's', 'u', 'r', 'e']
                 (flat_contexts xml2name)
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2trs_termination_proof xml2name) Fcc),
             (['s', 'w', 'i', 't', 'c', 'h', 'I', 'n', 'n', 'e', 'r', 'm', 'o',
                's', 't'],
               pair ['s', 'w', 'i', 't', 'c', 'h', 'I', 'n', 'n', 'e', 'r', 'm',
                      'o', 's', 't']
                 (wcr_proof xml2name) (xml2trs_termination_proof xml2name)
                 Switch_Innermost),
             (['p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', 'A', 'r', 'g', 'u',
                'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r'],
               pair ['p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', 'A', 'r', 'g',
                      'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r']
                 (afs xml2name) (xml2trs_termination_proof xml2name)
                 Permuting_AFS),
             (['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'A', 's',
                's', 'u', 'm', 'p', 't', 'i', 'o', 'n'],
               singleton
                 ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'A',
                   's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
                 (xml2inn_trs_assm xml2name) (\ qtrs -> Assume_SN qtrs [])),
             (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
               many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o',
                       'f']
                 (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
                 (xml2inn_trs_assm xml2name)
                 (\ xa ->
                   let {
                     cs = children xa;
                   } in (if not (equal_nat (size_list cs)
                                  (Nat_of_num (Bit0 One)))
                          then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                          else let {
                                 inp = take (Nat_of_num (Bit0 One))
 (tag (nth cs (Nat_of_num One)));
                               } in (if inp == ['t', 'r'] || inp == ['r', 'e']
                                      then binda
     (xml2inn_fp_trs_assm xml2name (hd cs))
     (\ io_trs ->
       (case io_trs of {
         Inl qtrs ->
           change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
         Inr fptrs ->
           change (xml2fptrs_termination_proof xml2name)
             (SN_FP_assm_proof fptrs);
       })
         (nth cs (Nat_of_num One)))
                                      else (if inp == ['d', 'p']
     then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
            (xml2dp_inputa True xml2name) (xml2dp_termination_proof xml2name)
            Finite_assm_proof xa
     else (if inp == ['u', 'n']
            then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xml2unknown_input
                   (xml2unknown_proof xml2name) Unknown_assm_proof xa
            else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa)))))
                 (\ _ -> Assume_SN))])
         id),
      (['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm', 'i', 'n',
         'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
        singleton
          ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm', 'i', 'n',
            'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f']
          (options
            [(['r', 'I', 's', 'E', 'm', 'p', 't', 'y'],
               leaf ['r', 'I', 's', 'E', 'm', 'p', 't', 'y'] R_is_Empty),
              (['s', 'I', 's', 'E', 'm', 'p', 't', 'y'],
                singleton ['s', 'I', 's', 'E', 'm', 'p', 't', 'y']
                  (xml2trs_termination_proof xml2name) id),
              (['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
                tuple4 ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
                  (ordering_constraint_proof False xml2name)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ rp one two -> Rule_Removal rp (one ++ two))),
              (['s', 'e', 'm', 'l', 'a', 'b'],
                guard (\ xa ->
                        equal_nat (num_children xa)
                          (Nat_of_num (Bit0 (Bit0 One))))
                  (tuple4 ['s', 'e', 'm', 'l', 'a', 'b'] (sl_variant xml2name)
                    (singleton ['t', 'r', 's'] (rules xml2name) id)
                    (singleton ['t', 'r', 's'] (rules xml2name) id)
                    (xml2trs_termination_proof xml2name)
                    (\ sli lr lrw -> Semlab sli [] (lr ++ lrw)))
                  (tuple5 ['s', 'e', 'm', 'l', 'a', 'b'] (sl_variant xml2name)
                    (singleton ['t', 'r', 's'] (rules xml2name) id)
                    (singleton ['t', 'r', 's'] (rules xml2name) id)
                    (innermostLhss xml2name)
                    (xml2trs_termination_proof xml2name)
                    (\ sli lr lrw lq -> Semlab sli lq (lr ++ lrw)))),
              (['u', 'n', 'c', 'u', 'r', 'r', 'y'],
                tuple4 ['u', 'n', 'c', 'u', 'r', 'r', 'y']
                  (uncurry_info xml2name)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ i r s -> Uncurry i (r ++ s))),
              (['p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', 'A', 'r', 'g', 'u',
                 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r'],
                pair ['p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', 'A', 'r',
                       'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e',
                       'r']
                  (afs xml2name) (xml2trs_termination_proof xml2name)
                  Permuting_AFS),
              (['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C', 'l',
                 'o', 's', 'u', 'r', 'e'],
                tuple4
                  ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C',
                    'l', 'o', 's', 'u', 'r', 'e']
                  (flat_contexts xml2name)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ fcc r s -> Fcc fcc (r ++ s))),
              (['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a',
                 'l'],
                triple
                  ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's',
                    'a', 'l']
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (singleton ['t', 'r', 's'] (rules xml2name) id)
                  (xml2trs_termination_proof xml2name)
                  (\ _ _ -> String_Reversal)),
              (['e', 'q', 'u', 'a', 'l', 'i', 't', 'y', 'R', 'e', 'm', 'o', 'v',
                 'a', 'l'],
                singleton
                  ['e', 'q', 'u', 'a', 'l', 'i', 't', 'y', 'R', 'e', 'm', 'o',
                    'v', 'a', 'l']
                  (xml2trs_termination_proof xml2name) Drop_Equality),
              (['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm', 'i',
                 'n', 'a', 't', 'i', 'o', 'n', 'A', 's', 's', 'u', 'm', 'p',
                 't', 'i', 'o', 'n'],
                singleton
                  ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e', 'r', 'm',
                    'i', 'n', 'a', 't', 'i', 'o', 'n', 'A', 's', 's', 'u', 'm',
                    'p', 't', 'i', 'o', 'n']
                  (xml1to2elements ['t', 'r', 's', 'I', 'n', 'p', 'u', 't']
                    (singleton ['t', 'r', 's'] (rules xml2name) id)
                    (singleton
                      ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'R', 'u', 'l',
                        'e', 's']
                      (rules xml2name) id)
                    (\ r a ->
                      (case a of {
                        Nothing ->
                          Assume_SN (default_nfs_trs, ([], (r, []))) [];
                        Just rw ->
                          Assume_SN (default_nfs_trs, ([], (r, rw))) [];
                      })))
                  id),
              (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
                many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o',
                        'f']
                  (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
                  (xml2inn_trs_assm xml2name)
                  (\ xa ->
                    let {
                      cs = children xa;
                    } in (if not (equal_nat (size_list cs)
                                   (Nat_of_num (Bit0 One)))
                           then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                           else let {
                                  inp = take (Nat_of_num (Bit0 One))
  (tag (nth cs (Nat_of_num One)));
                                } in (if inp == ['t', 'r'] || inp == ['r', 'e']
                                       then binda
      (xml2inn_fp_trs_assm xml2name (hd cs))
      (\ io_trs ->
        (case io_trs of {
          Inl qtrs ->
            change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
          Inr fptrs ->
            change (xml2fptrs_termination_proof xml2name)
              (SN_FP_assm_proof fptrs);
        })
          (nth cs (Nat_of_num One)))
                                       else (if inp == ['d', 'p']
      then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
             (xml2dp_inputa True xml2name) (xml2dp_termination_proof xml2name)
             Finite_assm_proof xa
      else (if inp == ['u', 'n']
             then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                    xml2unknown_input (xml2unknown_proof xml2name)
                    Unknown_assm_proof xa
             else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa)))))
                  (\ _ -> Assume_SN))])
          id)]
    x;

xml2fptrs_termination_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Fptrs_termination_proof a b [Prelude.Char]);
xml2fptrs_termination_proof xml2name x =
  singleton
    ['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'P',
      'r', 'o', 'o', 'f']
    (options
      [(['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'A', 's', 's',
          'u', 'm', 'p', 't', 'i', 'o', 'n'],
         singleton
           ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'A', 's',
             's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
           (xml2fp_trs_assm xml2name) (\ qtrs -> Assume_FP_SN qtrs [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2fp_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == ['t', 'r'] || inp == ['r', 'e']
                                 then binda
(xml2inn_fp_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fptrs_termination_proof xml2name) (SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] (xml2dp_inputa True xml2name)
       (xml2dp_termination_proof xml2name) Finite_assm_proof xa
else (if inp == ['u', 'n']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xml2unknown_input
              (xml2unknown_proof xml2name) Unknown_assm_proof xa
       else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa)))))
            (\ _ -> Assume_FP_SN))])
    id x;

xml2dp_termination_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Dp_termination_proof a b [Prelude.Char]);
xml2dp_termination_proof xml2name x =
  singleton ['d', 'p', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['p', 'I', 's', 'E', 'm', 'p', 't', 'y'],
         leaf ['p', 'I', 's', 'E', 'm', 'p', 't', 'y'] P_is_Empty),
        (['d', 'e', 'p', 'G', 'r', 'a', 'p', 'h', 'P', 'r', 'o', 'c'],
          many ['d', 'e', 'p', 'G', 'r', 'a', 'p', 'h', 'P', 'r', 'o', 'c']
            (xml2nd_choice ['c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't']
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              ['r', 'e', 'a', 'l', 'S', 'c', 'c']
              (xml2dp_termination_proof xml2name)
              (\ dps prfOpt -> (prfOpt, dps)))
            Dep_Graph_Proc),
        (['r', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c'],
          triple ['r', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o', 'c']
            (ordering_constraint_proofa False xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Redpair_Proc),
        (['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'P', 'r', 'o',
           'c'],
          pair ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'P', 'r',
                 'o', 'c']
            (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Usable_Rules_Proc),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's', 'R',
           'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c'],
          pair ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's',
                 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c']
            (innermostLhss xml2name) (xml2dp_termination_proof xml2name)
            Q_Reduction_Proc),
        (['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o', 'c'],
          guard (\ xa -> equal_nat (num_children xa) (Nat_of_num (Bit1 One)))
            (triple
              ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o', 'c']
              (rule xml2name) (rstep xml2name)
              (xml2dp_termination_proof xml2name)
              (\ (s, t) (p, (lr, ta)) ->
                Rewriting_Proc Nothing (s, t) (s, ta) (s, ta) lr p))
            (guard
              (\ xa ->
                equal_nat (num_children xa) (Nat_of_num (Bit0 (Bit0 One))))
              (guard
                (\ xa ->
                  tag (nth (children xa) (Nat_of_num (Bit0 One))) ==
                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's'])
                (tuple4
                  ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                    'c']
                  (rule xml2name) (rstep xml2name)
                  (singleton
                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                    (rules xml2name) id)
                  (xml2dp_termination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) u ->
                    Rewriting_Proc (Just u) (s, t) (s, ta) (s, ta) lr p))
                (tuple4
                  ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                    'c']
                  (rule xml2name) (rstep xml2name) (rule xml2name)
                  (xml2dp_termination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) st ->
                    Rewriting_Proc Nothing (s, t) (s, ta) st lr p)))
              (tuple5
                ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                  'c']
                (rule xml2name) (rstep xml2name) (rule xml2name)
                (singleton
                  ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                  (rules xml2name) id)
                (xml2dp_termination_proof xml2name)
                (\ (s, t) (p, (lr, ta)) st u ->
                  Rewriting_Proc (Just u) (s, t) (s, ta) st lr p)))),
        (['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 'P', 'r', 'o', 'c'],
          tuple4
            ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 'P', 'r', 'o', 'c']
            (rule xml2name) pos
            (singleton ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Narrowing_Proc),
        (['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n', 'P',
           'r', 'o', 'c'],
          triple
            ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
              'P', 'r', 'o', 'c']
            (rule xml2name)
            (singleton
              ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Instantiation_Proc),
        (['f', 'o', 'r', 'w', 'a', 'r', 'd', 'I', 'n', 's', 't', 'a', 'n', 't',
           'i', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'c'],
          xml3to4elements
            ['f', 'o', 'r', 'w', 'a', 'r', 'd', 'I', 'n', 's', 't', 'a', 'n',
              't', 'i', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'c']
            (rule xml2name)
            (singleton
              ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                's']
              (rules xml2name) id)
            (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Forward_Instantiation_Proc),
        (['s', 'e', 'm', 'l', 'a', 'b', 'P', 'r', 'o', 'c'],
          guard (\ xa ->
                  equal_nat (num_children xa) (Nat_of_num (Bit0 (Bit0 One))))
            (tuple4 ['s', 'e', 'm', 'l', 'a', 'b', 'P', 'r', 'o', 'c']
              (sl_variant xml2name)
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              (singleton ['t', 'r', 's'] (rules xml2name) id)
              (xml2dp_termination_proof xml2name)
              (\ sli lp -> Semlab_Proc sli lp []))
            (tuple5 ['s', 'e', 'm', 'l', 'a', 'b', 'P', 'r', 'o', 'c']
              (sl_variant xml2name)
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              (singleton ['t', 'r', 's'] (rules xml2name) id)
              (innermostLhss xml2name) (xml2dp_termination_proof xml2name)
              (\ sli lp lr lq -> Semlab_Proc sli lp lq lr))),
        (['s', 'u', 'b', 't', 'e', 'r', 'm', 'P', 'r', 'o', 'c'],
          xml1many2elements_gen
            ['s', 'u', 'b', 't', 'e', 'r', 'm', 'P', 'r', 'o', 'c']
            (proj xml2name) (\ pi -> projected_rseq xml2name (create_proj pi))
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Subterm_Criterion_Proc),
        (['r', 'e', 'd', 'P', 'a', 'i', 'r', 'U', 'r', 'P', 'r', 'o', 'c'],
          tuple4
            ['r', 'e', 'd', 'P', 'a', 'i', 'r', 'U', 'r', 'P', 'r', 'o', 'c']
            (ordering_constraint_proofa False xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Redpair_UR_Proc),
        (['m', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'U', 'r', 'P',
           'r', 'o', 'c'],
          tuple5
            ['m', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'U', 'r',
              'P', 'r', 'o', 'c']
            (ordering_constraint_proof False xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (singleton ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
              (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Mono_Redpair_UR_Proc),
        (['m', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r', 'o',
           'c'],
          tuple4
            ['m', 'o', 'n', 'o', 'R', 'e', 'd', 'P', 'a', 'i', 'r', 'P', 'r',
              'o', 'c']
            (ordering_constraint_proof False xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Mono_Redpair_Proc),
        (['u', 'n', 'c', 'u', 'r', 'r', 'y', 'P', 'r', 'o', 'c'],
          guard (\ xa ->
                  equal_nat (num_children xa) (Nat_of_num (Bit0 (Bit0 One))))
            (tuple4 ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'P', 'r', 'o', 'c']
              (uncurry_info xml2name)
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              (singleton ['t', 'r', 's'] (rules xml2name) id)
              (xml2dp_termination_proof xml2name) (Uncurry_Proc Nothing))
            (tuple5 ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'P', 'r', 'o', 'c']
              (nata ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'v', 'e', 'T',
                      'o', 'p'])
              (uncurry_info xml2name)
              (singleton ['d', 'p', 's'] (rules xml2name) id)
              (singleton ['t', 'r', 's'] (rules xml2name) id)
              (xml2dp_termination_proof xml2name)
              (\ n -> Uncurry_Proc (Just n)))),
        (['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C', 'l', 'o',
           's', 'u', 'r', 'e', 'P', 'r', 'o', 'c'],
          tuple5
            ['f', 'l', 'a', 't', 'C', 'o', 'n', 't', 'e', 'x', 't', 'C', 'l',
              'o', 's', 'u', 'r', 'e', 'P', 'r', 'o', 'c']
            (singleton ['f', 'r', 'e', 's', 'h', 'S', 'y', 'm', 'b', 'o', 'l']
              xml2name id)
            (flat_contexts xml2name)
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Fcc_Proc),
        (['s', 'w', 'i', 't', 'c', 'h', 'I', 'n', 'n', 'e', 'r', 'm', 'o', 's',
           't', 'P', 'r', 'o', 'c'],
          pair ['s', 'w', 'i', 't', 'c', 'h', 'I', 'n', 'n', 'e', 'r', 'm', 'o',
                 's', 't', 'P', 'r', 'o', 'c']
            (wcr_proof xml2name) (xml2dp_termination_proof xml2name)
            Switch_Innermost_Proc),
        (['s', 'p', 'l', 'i', 't', 'P', 'r', 'o', 'c'],
          tuple4 ['s', 'p', 'l', 'i', 't', 'P', 'r', 'o', 'c']
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name)
            (xml2dp_termination_proof xml2name) Split_Proc),
        (['f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', 'A', 's', 's', 'u',
           'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', 'A', 's', 's',
              'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2dp_inputa True xml2name) (\ dpp -> Assume_Finite dpp [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2dp_inputa True xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == ['t', 'r'] || inp == ['r', 'e']
                                 then binda
(xml2inn_fp_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fptrs_termination_proof xml2name) (SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] (xml2dp_inputa True xml2name)
       (xml2dp_termination_proof xml2name) Finite_assm_proof xa
else (if inp == ['u', 'n']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xml2unknown_input
              (xml2unknown_proof xml2name) Unknown_assm_proof xa
       else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa)))))
            (\ _ -> Assume_Finite)),
        (['s', 'w', 'i', 't', 'c', 'h', 'T', 'o', 'T', 'R', 'S'],
          singleton ['s', 'w', 'i', 't', 'c', 'h', 'T', 'o', 'T', 'R', 'S']
            (xml2trs_termination_proof xml2name) To_Trs_Proc),
        (['u', 'n', 'l', 'a', 'b', 'P', 'r', 'o', 'c'],
          triple ['u', 'n', 'l', 'a', 'b', 'P', 'r', 'o', 'c']
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2dp_termination_proof xml2name) Unlab_Proc),
        (['g', 'e', 'n', 'e', 'r', 'a', 'l', 'R', 'e', 'd', 'P', 'a', 'i', 'r',
           'P', 'r', 'o', 'c'],
          guard (\ xa ->
                  equal_nat (num_children xa) (Nat_of_num (Bit1 (Bit0 One))))
            (tuple5
              ['g', 'e', 'n', 'e', 'r', 'a', 'l', 'R', 'e', 'd', 'P', 'a', 'i',
                'r', 'P', 'r', 'o', 'c']
              (ordering_constraint_proof True xml2name)
              (singleton ['s', 't', 'r', 'i', 'c', 't'] (rules xml2name) id)
              (singleton ['b', 'o', 'u', 'n', 'd'] (rules xml2name) id)
              (xml2cond_red_pair_proof xml2name)
              (xml2dp_termination_proof xml2name)
              (\ rp s b c p -> General_Redpair_Proc rp s b c [p]))
            (tuple6
              ['g', 'e', 'n', 'e', 'r', 'a', 'l', 'R', 'e', 'd', 'P', 'a', 'i',
                'r', 'P', 'r', 'o', 'c']
              (ordering_constraint_proof True xml2name)
              (singleton ['s', 't', 'r', 'i', 'c', 't'] (rules xml2name) id)
              (singleton ['b', 'o', 'u', 'n', 'd'] (rules xml2name) id)
              (xml2cond_red_pair_proof xml2name)
              (xml2dp_termination_proof xml2name)
              (xml2dp_termination_proof xml2name)
              (\ rp s b c ps pb -> General_Redpair_Proc rp s b c [ps, pb]))),
        (['c', 'o', 'm', 'p', 'l', 'e', 'x', 'C', 'o', 'n', 's', 't', 'a', 'n',
           't', 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c'],
          triple
            ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'C', 'o', 'n', 's', 't', 'a',
              'n', 't', 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c']
            (term xml2name)
            (many ['r', 'u', 'l', 'e', 'M', 'a', 'p']
              (pair ['r', 'u', 'l', 'e', 'M', 'a', 'p', 'E', 'n', 't', 'r', 'y']
                (rule xml2name) (rule xml2name) (\ a b -> (a, b)))
              id)
            (xml2dp_termination_proof xml2name)
            (\ t rls ->
              Complex_Constant_Removal_Proc
                (Complex_Constant_Removal_Proof t rls))),
        (['s', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'P', 'r', 'o', 'c'],
          many1 ['s', 'i', 'z', 'e', 'C', 'h', 'a', 'n', 'g', 'e', 'P', 'r',
                  'o', 'c']
            (options
              [(['s', 'u', 'b', 't', 'e', 'r', 'm', 'C', 'r', 'i', 't', 'e',
                  'r', 'i', 'o', 'n'],
                 leaf ['s', 'u', 'b', 't', 'e', 'r', 'm', 'C', 'r', 'i', 't',
                        'e', 'r', 'i', 'o', 'n']
                   Nothing),
                (['r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', 'P', 'a', 'i',
                   'r'],
                  xml1to2elements
                    ['r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', 'P', 'a', 'i',
                      'r']
                    (ordering_constraint_proof False xml2name)
                    (singleton
                      ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                      (rules xml2name) id)
                    (\ redp ur -> Just (redp, ur)))])
            (scg xml2name)
            (\ a ->
              (case a of {
                Nothing -> Size_Change_Subterm_Proc;
                Just redp_ur ->
                  Size_Change_Redpair_Proc (fst redp_ur) (snd redp_ur);
              })))])
    id x;

xml2unknown_proof ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                  Xml ->
                    Sum_bot [Prelude.Char] (Unknown_proof a b [Prelude.Char]);
xml2unknown_proof xml2name x =
  singleton
    ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't', 'P', 'r', 'o',
      'o', 'f']
    (options
      [(['u', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 's', 's', 'u', 'm', 'p', 't',
          'i', 'o', 'n'],
         singleton
           ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 's', 's', 'u', 'm', 'p',
             't', 'i', 'o', 'n']
           xml2unknown_input (\ u -> Assume_Unknown u [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            xml2unknown_input
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == ['t', 'r'] || inp == ['r', 'e']
                                 then binda
(xml2inn_fp_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_termination_proof xml2name) (SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fptrs_termination_proof xml2name) (SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] (xml2dp_inputa True xml2name)
       (xml2dp_termination_proof xml2name) Finite_assm_proof xa
else (if inp == ['u', 'n']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xml2unknown_input
              (xml2unknown_proof xml2name) Unknown_assm_proof xa
       else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa)))))
            (\ _ -> Assume_Unknown))])
    id x;

xml2cr_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char] (Cr_proof a [Nat] [Prelude.Char]);
xml2cr_proof xml2name x =
  singleton ['c', 'r', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['w', 'c', 'r', 'A', 'n', 'd', 'S', 'N'],
         pair ['w', 'c', 'r', 'A', 'n', 'd', 'S', 'N'] (wcr_proof xml2name)
           (xml2trs_termination_proof xml2name) SN_WCR),
        (['o', 'r', 't', 'h', 'o', 'g', 'o', 'n', 'a', 'l'],
          leaf ['o', 'r', 't', 'h', 'o', 'g', 'o', 'n', 'a', 'l']
            Weakly_Orthogonal),
        (['s', 't', 'r', 'o', 'n', 'g', 'l', 'y', 'C', 'l', 'o', 's', 'e', 'd'],
          change
            (nata ['s', 't', 'r', 'o', 'n', 'g', 'l', 'y', 'C', 'l', 'o', 's',
                    'e', 'd'])
            Strongly_Closed)])
    id x;

xml2eq_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Eq_proof a [Prelude.Char]);
xml2eq_proof xml2name x =
  options
    [(['r', 'e', 'f', 'l'],
       singleton ['r', 'e', 'f', 'l'] (term xml2name) Refl),
      (['s', 'y', 'm'], singleton ['s', 'y', 'm'] (xml2eq_proof xml2name) Sym),
      (['t', 'r', 'a', 'n', 's'],
        pair ['t', 'r', 'a', 'n', 's'] (xml2eq_proof xml2name)
          (xml2eq_proof xml2name) Trans),
      (['a', 's', 's', 'm'],
        pair ['a', 's', 's', 'm'] (rule xml2name) (substa xml2name)
          (\ r s -> Assm r (mk_subst Var s))),
      (['c', 'o', 'n', 'g'],
        many1 ['c', 'o', 'n', 'g'] xml2name (xml2eq_proof xml2name) Cong)]
    x;

xml_repl_map ::
  forall a b. (Showa a, Showa b) => ((Lab a [b], Nat), [Nat]) -> Xml;
xml_repl_map =
  (\ (a, b) ->
    let {
      (f, aa) = a;
    } in (\ l ->
           XML ['r', 'e', 'p', 'l', 'a', 'c', 'e', 'm', 'e', 'n', 't', 'M', 'a',
                 'p', 'E', 'n', 't', 'r', 'y']
             [] (xml_lab f :
                  XML ['a', 'r', 'i', 't', 'y'] [] []
                    (Just (shows_prec_nat Zero_nat aa [])) :
                    map xml_single_pos l)
             Nothing)
      b);

xml_forbidden_pattern ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (Ctxt (Lab a [b]) c, (Term (Lab a [b]) c, Location)) -> Xml;
xml_forbidden_pattern =
  (\ (c, (t, l)) ->
    XML ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e',
          'r', 'n']
      [] [xml_term (ctxt_apply c t), xml_pos (hole_pos c),
           (case l of {
             H -> XML ['h', 'e', 'r', 'e'] [] [] Nothing;
             A -> XML ['a', 'b', 'o', 'v', 'e'] [] [] Nothing;
             Ba -> XML ['b', 'e', 'l', 'o', 'w'] [] [] Nothing;
             Ra -> XML ['r', 'i', 'g', 'h', 't'] [] [] Nothing;
           })]
      Nothing);

xml_strategy ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => Sum (Strategy (Lab a [b]) c) (Fp_strategy (Lab a [b]) c) ->
                    [Xml];
xml_strategy (Inl No_Strategy) = [];
xml_strategy (Inl Innermost) =
  [XML ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'] []
     [XML ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't'] [] [] Nothing] Nothing];
xml_strategy (Inr Outermost) =
  [XML ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'] []
     [XML ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't'] [] [] Nothing] Nothing];
xml_strategy (Inr (Forbidden_Patterns p)) =
  [XML ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'] []
     [XML ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', 'P', 'a', 't', 't', 'e',
            'r', 'n', 's']
        [] (map xml_forbidden_pattern p) Nothing]
     Nothing];
xml_strategy (Inr (Context_Sensitive mu)) =
  [XML ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'] []
     [XML ['c', 'o', 'n', 't', 'e', 'x', 't', 'S', 'e', 'n', 's', 'i', 't', 'i',
            'v', 'e']
        [] (map xml_repl_map mu) Nothing]
     Nothing];
xml_strategy (Inl (Innermost_Q q)) =
  [XML ['s', 't', 'r', 'a', 't', 'e', 'g', 'y'] []
     [XML ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's'] []
        (map xml_term q) Nothing]
     Nothing];

mk_tp ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      (Bool, ([Term b c], ([(Term b c, Term b c)], [(Term b c, Term b c)]))) ->
        a;
mk_tp i (nfs, (q, (r, rw))) = mkb i nfs q r rw;

nFQ_subset_NF_rulesb :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
nFQ_subset_NF_rulesb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = nFQ_subset_NF_rules;

is_QNFc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Term b c -> Bool;
is_QNFc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = is_QNF;

rulesd :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulesd
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules;

icap_impl_dpp ::
  forall a b.
    (Eq b) => Dpp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_dpp i d =
  let {
    qr = nFQ_subset_NF_rulesb i d;
    qnf = is_QNFc i d;
    r = rulesd i d;
    ic = icap_impl qr qnf (map fst r);
  } in (\ s -> let {
                 a = ceta_set_of (concatMap vars_term_list s);
               } in ic s a);

shows_kbo_repr ::
  forall a.
    (Showa a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                   [Prelude.Char] -> [Prelude.Char];
shows_kbo_repr (prs, w0) =
  shows_string
    ['K', 'B', 'O', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'e', ' ', 'f', 'o',
      'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'p', 'r', 'e', 'c', 'e', 'd', 'e',
      'n', 'c', 'e', ' ', 'a', 'n', 'd', ' ', 'w', 'e', 'i', 'g', 'h', 't', ' ',
      'f', 'u', 'n', 'c', 't', 'i', 'o', 'n'] .
    shows_nl .
      shows_map
        (\ (a, b) ->
          let {
            (f, n) = a;
          } in (\ (pr, (_, _)) ->
                 shows_string
                   ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', '('] .
                   shows_prec Zero_nat f .
                     shows_string ['['] .
                       shows_prec_nat Zero_nat n .
                         shows_string [']', ')', ' ', '=', ' '] .
                           shows_prec_nat Zero_nat pr . shows_nl)
            b)
        prs .
        shows_nl .
          shows_string
            ['p', 'r', 'e', 'c', 'e', 'd', 'e', 'n', 'c', 'e', '(', '_', ')',
              ' ', '=', ' ', '0'] .
            shows_nl .
              shows_string
                ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                  'o', 'w', 'i', 'n', 'g', ' ', 'w', 'e', 'i', 'g', 'h', 't'] .
                shows_nl .
                  shows_map
                    (\ (a, b) ->
                      let {
                        (f, n) = a;
                      } in (\ (_, (w, _)) ->
                             shows_string ['w', 'e', 'i', 'g', 'h', 't', '('] .
                               shows_prec Zero_nat f .
                                 shows_string ['['] .
                                   shows_prec_nat Zero_nat n .
                                     shows_string [']', ')', ' ', '=', ' '] .
                                       shows_prec_nat Zero_nat w . shows_nl)
                        b)
                    prs .
                    shows_nl .
                      shows_string
                        ['w', 'e', 'i', 'g', 'h', 't', '(', '_', ')', ' ', '=',
                          ' '] .
                        shows_prec_nat Zero_nat (plus_nat w0 (Nat_of_num One)) .
                          shows_nl .
                            shows_prec_list Zero_nat ['w', '0', ' ', '=', ' '] .
                              shows_prec_nat Zero_nat w0 .
                                shows_string
                                  (shows_nl
                                    ['a', 'n', 'd', ' ', 't', 'h', 'e', ' ',
                                      'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n',
                                      'g', ' ', 's', 'u', 'b', 't', 'e', 'r',
                                      'm', ' ', 'c', 'o', 'e', 'f', 'f', 'i',
                                      'c', 'i', 'e', 'n', 't', ' ', 'f', 'u',
                                      'n', 'c', 't', 'i', 'o', 'n', 's']) .
                                  shows_nl .
                                    shows_map
                                      (\ (a, b) ->
let {
  (f, n) = a;
} in (\ (_, (_, scf)) ->
       shows_string ['s', 'c', 'f', '('] .
         shows_prec Zero_nat f .
           shows_string ['['] .
             shows_prec_nat Zero_nat n .
               shows_string [']', ')', ' ', '=', ' '] .
                 (if is_none scf
                   then shows_prec_list Zero_nat ['a', 'l', 'l', ' ', '1']
                   else shows_prec_list Zero_nat (the scf)) .
                   shows_nl)
  b)
                                      prs .
                                      shows_nl .
shows_prec_list Zero_nat
  ['s', 'c', 'f', '(', '_', ')', ' ', '=', ' ', 'a', 'l', 'l', ' ', '1'] .
  shows_nl;

sym_collect :: forall a b. (Term a b -> Bool) -> Term a b -> [a];
sym_collect p (Var x) = [];
sym_collect p (Fun f ts) =
  (if p (Fun f ts) then [f] else []) ++ concatMap (sym_collect p) ts;

pat_of ::
  forall a.
    Dp_proof_step a ->
      (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])));
pat_of (OC1 rl uu) =
  (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
    ([], ((Zero_nat, (Zero_nat, [])), snd rl)));
pat_of (OC2 rl uv uw ux uy uz) =
  (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
    ([], ((Zero_nat, (Zero_nat, [])), snd rl)));
pat_of (OC2p rl va vb vc vd ve) =
  (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
    ([], ((Zero_nat, (Zero_nat, [])), snd rl)));
pat_of (OC3 rl vf vg vh vi) =
  (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
    ([], ((Zero_nat, (Zero_nat, [])), snd rl)));
pat_of (OC3p rl vj vk vl vm) =
  (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
    ([], ((Zero_nat, (Zero_nat, [])), snd rl)));
pat_of (OCDP1 p vn) = p;
pat_of (OCDP2 p vo) = p;
pat_of (WPEQ p vp) = p;
pat_of (Lift p vq) = p;
pat_of (DPOC1_1 p vr vs vt vu) = p;
pat_of (DPOC1_2 p vv vw vx vy vz) = p;
pat_of (DPOC2 p wa wb wc wd) = p;
pat_of (DPOC3_1 p we wf wg wh) = p;
pat_of (DPOC3_2 p wi wj wk wl wm) = p;
pat_of (DPDP1_1 p wn wo wp wq) = p;
pat_of (DPDP1_2 p wr ws wt wu) = p;
pat_of (DPDP2_1 p wv ww wx wy) = p;
pat_of (DPDP2_2 p wz xa xb xc) = p;

mk_rtrancl_list_main ::
  forall a. (a -> a -> Bool) -> (a -> [a]) -> [a] -> [a] -> [a];
mk_rtrancl_list_main subsumes r todo fin =
  (case todo of {
    [] -> fin;
    a : tod ->
      (if any (\ b -> subsumes b a) fin
        then mk_rtrancl_list_main subsumes r tod fin
        else mk_rtrancl_list_main subsumes r (r a ++ tod) (a : fin));
  });

mk_rtrancl_list :: forall a. (a -> a -> Bool) -> (a -> [a]) -> [a] -> [a];
mk_rtrancl_list subsumes r init = mk_rtrancl_list_main subsumes r init [];

ins_dj_rm_basic_ops :: forall a. (Linorder a) => a -> Rbt a () -> Rbt a ();
ins_dj_rm_basic_ops x s = insert x () s;

mk_rtrancl_set_main ::
  forall a. (Linorder a) => (a -> [a]) -> [a] -> Rbt a () -> Rbt a ();
mk_rtrancl_set_main r todo fin =
  (case todo of {
    [] -> fin;
    a : tod ->
      (if memb_rm_basic_ops a fin then mk_rtrancl_set_main r tod fin
        else mk_rtrancl_set_main r (r a ++ tod) (ins_dj_rm_basic_ops a fin));
  });

mk_rtrancl_set :: forall a. (Linorder a) => (a -> [a]) -> [a] -> Rbt a ();
mk_rtrancl_set r init = mk_rtrancl_set_main r init (empty_rm_basic_ops ());

subst_compose_impl ::
  forall a b.
    (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)] -> [(a, Term b a)];
subst_compose_impl sigma tau =
  let {
    sigmaa = mk_subst_domain sigma;
    taua = mk_subst_domain tau;
    d_sigma = map fst sigmaa;
  } in map (\ (x, t) -> (x, subst_apply_term t (mk_subst Var taua))) sigmaa ++
         filter (\ (x, _) -> not (membera d_sigma x)) taua;

commutes_impl ::
  forall a b.
    (Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b,
      Linorder b) => [(a, Term b a)] -> [(a, Term b a)] -> Bool;
commutes_impl sigma mu =
  subst_eq (subst_compose_impl sigma mu) (subst_compose_impl mu sigma);

mk_subst_case ::
  forall a b.
    (Eq a,
      Eq b) => [a] -> (a -> Term b a) -> [(a, Term b a)] -> [(a, Term b a)];
mk_subst_case xs sigma tau =
  subst_compose_impl (map (\ x -> (x, sigma x)) xs) tau;

ta_matcha ::
  forall a b c.
    (Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b, Linorder b,
      Ceq c, Corder c) => Ta_ext a b () -> Set a -> Term b c -> Set [(c, a)];
ta_matcha ta q t = ta_match ta q t q;

adapt_vars :: forall a b c. Term a b -> Term a c;
adapt_vars (Fun f ts) = Fun f (map adapt_vars ts);

ta_member ::
  forall a b c.
    (Eq a, Linorder a, Cenum c, Ceq c, Corder c, Eq c, Linorder c,
      Set_impl c) => Term a b -> Ta_ext c a () -> Bool;
ta_member t ta =
  ground t &&
    not (less_eq_set (inf_set (ta_final ta) (ta_res ta (adapt_vars t)))
          bot_set);

funas_term_lista :: forall a b. Term a b -> [(a, Nat)];
funas_term_lista (Var uu) = [];
funas_term_lista (Fun f ts) = (f, size_list ts) : concatMap funas_term_lista ts;

funas_rule_list :: forall a b. (Term a b, Term a b) -> [(a, Nat)];
funas_rule_list r = funas_term_lista (fst r) ++ funas_term_lista (snd r);

funas_trs_list :: forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)];
funas_trs_list r = remdups (concatMap funas_rule_list r);

add_funs_term_list :: forall a b. Term a b -> [a] -> [a];
add_funs_term_list =
  folda (const id) (\ f xs -> (\ a -> f : a) . foldr (\ a b -> a . b) xs id);

funs_term_list :: forall a b. Term a b -> [a];
funs_term_list t = add_funs_term_list t [];

funs_rule_lista :: forall a b. (Term a b, Term a b) -> [a];
funs_rule_lista r = funs_term_list (fst r) ++ funs_term_list (snd r);

funs_rule_list :: forall a b. (Eq a) => (Term a b, Term a b) -> [a];
funs_rule_list r = remdups (funs_rule_lista r);

rwb :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules
      rules_map delete_R_Rw split_rules mk nfs more)
  = rw;

rb :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rb (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
     delete_R_Rw split_rules mk nfs more)
  = r;

uncurry_of_sig_list ::
  forall a.
    a -> [((a, Nat), [a])] ->
           (a -> Nat -> [a]) ->
             [(Term a [Prelude.Char], Term a [Prelude.Char])];
uncurry_of_sig_list a sml sm =
  concatMap
    (\ (b, c) ->
      let {
        (f, n) = b;
      } in (\ _ ->
             let {
               g = get_symbol sm f n;
             } in map (\ i ->
                        (Fun a [generate_f_xs (g i) (plus_nat n i),
                                 Var (generate_var (plus_nat n i))],
                          generate_f_xs (g (plus_nat i (Nat_of_num One)))
                            (plus_nat n (plus_nat i (Nat_of_num One)))))
                    (upt Zero_nat (aarity sm f n)))
        c)
    sml;

sig_list_to_sig_map ::
  forall a.
    (Eq a) => a -> [((a, Nat), [a])] ->
                     ([((a, Nat), [a])] -> a -> Nat -> a) -> a -> Nat -> [a];
sig_list_to_sig_map a sml fmap =
  let {
    fm = fmap sml;
  } in (\ f n ->
         (case map_of sml (f, n) of {
           Nothing -> [fm f n];
           Just xs -> (if null xs then [fm f n] else xs);
         }));

uncurry_eta_split ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             ([(Term a b, Term a b)], [(Term a b, Term a b)]);
uncurry_eta_split eboth rtest =
  let {
    test =
      (\ (l, r) ->
        less_nat Zero_nat (num_args l) &&
          less_nat Zero_nat (num_args r) &&
            any (eq_rule_mod_vars (hd (args l), hd (args r))) rtest);
  } in partition test eboth;

eta_closed_rules ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => a -> (a -> Nat -> [a]) ->
                         [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
eta_closed_rules a sm ra r =
  catcha
    (forallM
      (\ (l, raa) ->
        (case aarity_term a sm l of {
          Nothing -> Inr ();
          Just ab ->
            (if equal_nat ab Zero_nat then Inr ()
              else check (any (\ (lll, rrr) ->
                                (case (lll, rrr) of {
                                  (Var _, b) -> False;
                                  (Fun f [], b) -> False;
                                  (Fun f [ll], b) -> False;
                                  (Fun f [ll, Var x], Var _) -> False;
                                  (Fun f [ll, Var x], Fun g []) -> False;
                                  (Fun f [ll, Var x], Fun g [rr]) -> False;
                                  (Fun f [ll, Var x], Fun g [rr, Var y]) ->
                                    f == a &&
                                      g == a &&
x == y &&
  not (membera (vars_rule_list (ll, rr)) x) && instance_rule (l, raa) (ll, rr);
                                  (Fun f [ll, Var x],
                                    Fun g (rr : Var y : _ : _))
                                    -> False;
                                  (Fun f [ll, Var x],
                                    Fun g (rr : Fun _ _ : list))
                                    -> False;
                                  (Fun f (ll : Var x : _ : _), b) -> False;
                                  (Fun f (ll : Fun _ _ : list), b) -> False;
                                }))
                           r)
                     (shows_prec_list Zero_nat
                        ['e', 't', 'a', ' ', 'e', 'x', 'p', 'a', 'n', 's', 'i',
                          'o', 'n', ' ', 'o', 'f', ' '] .
                       shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                         [' ', '-', '>', ' '] (l, raa) .
                         shows_prec_list Zero_nat
                           [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']));
        }))
      ra)
    (\ x -> Inl (snd x));

uncurry_rules ::
  forall a b.
    (Eq a) => a -> (a -> Nat -> [a]) ->
                     [(Term a b, Term a b)] -> [(Term a b, Term a b)];
uncurry_rules a sm =
  map (\ (l, r) -> (uncurry_term a sm l, uncurry_term a sm r));

check_CS_subseteq ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           [(Term a b, Term a b)] ->
                             Sum (Term a b, Term a b) ();
check_CS_subseteq r s =
  catcha
    (forallM (\ (l, ra) -> check (any (instance_rule (l, ra)) s) (l, ra)) r)
    (\ x -> Inl (snd x));

uncurry_tt ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_tt i info r tp =
  let {
    (a, (sml, (u, eb))) = info;
    ra = rb i tp;
    rw = rwb i tp;
    (e, ew) = uncurry_eta_split eb ra;
    r_eta = e ++ ra;
    rw_eta = ew ++ rw;
    rb_eta = r_eta ++ rw_eta;
    fmap = (\ _ f _ -> f);
    sm = sig_list_to_sig_map a sml fmap;
    uR = uncurry_rules a sm r_eta;
    uRw = uncurry_rules a sm rw_eta;
  } in (case let {
               s = uncurry_of_sig_list a sml sm;
             } in bindb (catcha
                          (forallM
                            (\ (l, _) ->
                              check (hvf_term a l)
                                (shows_prec_list Zero_nat
                                   ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i',
                                     'a', 'b', 'l', 'e', ' ', 'i', 'n', ' ',
                                     'l', 'h', 's', ' '] .
                                  shows_term (shows_prec Zero_nat)
                                    (shows_prec_list Zero_nat) l .
                                    shows_prec_list Zero_nat
                                      [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l',
'o', 'w', 'e', 'd']))
                            r_eta)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (catcha
                              (forallM
                                (\ (l, _) ->
                                  check (hvf_term a l)
                                    (shows_prec_list Zero_nat
                                       ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r',
 'i', 'a', 'b', 'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                                      shows_term (shows_prec Zero_nat)
(shows_prec_list Zero_nat) l .
shows_prec_list Zero_nat
  [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                                rw_eta)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          bindb (eta_closed_rules a sm r_eta r_eta)
                            (\ _ ->
                              bindb (eta_closed_rules a sm rb_eta rb_eta)
                                (\ _ ->
                                  bindb (catcha
  (forallM
    (\ (l, rc) ->
      check (not (is_Var l))
        (shows_prec_list Zero_nat
           ['l', 'h', 's', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
             'b', 'e', ' ', 'a', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
             ' ', 'i', 'n', ' ', 'r', 'u', 'l', 'e', ' '] .
          shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
            [' ', '-', '>', ' '] (l, rc)))
    rw_eta)
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catcha (check_subseteq uR r)
  (\ x ->
    Inl (shows_prec_list Zero_nat
           ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l',
             'e', ' '] .
          shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
            [' ', '-', '>', ' '] x .
            shows_prec_list Zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
(\ _ ->
  bindb (catcha (check_subseteq uRw r)
          (\ x ->
            Inl (shows_prec_list Zero_nat
                   ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u',
                     'l', 'e', ' '] .
                  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                    [' ', '-', '>', ' '] x .
                    shows_prec_list Zero_nat
                      [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
    (\ _ ->
      bindb (catcha (check_CS_subseteq s u)
              (\ x ->
                Inl (shows_prec_list Zero_nat
                       ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l',
                         'e', ' '] .
                      shows_rule (shows_prec Zero_nat)
                        (shows_prec_list Zero_nat) [' ', '-', '>', ' '] x .
                        shows_prec_list Zero_nat
                          [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                            'g'])))
        (\ _ ->
          catcha (check_subseteq u r)
            (\ x ->
              Inl (shows_prec_list Zero_nat
                     ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l',
                       'e', ' '] .
                    shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                      [' ', '-', '>', ' '] x .
                      shows_prec_list Zero_nat
                        [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g',
                          ' ', 'i', 'n', ' ', 'n', 'e', 'w', ' ', 'T', 'R',
                          'S']))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkb i (nfsb i tp) [] uR (uRw ++ u));
       });

af_rules ::
  forall a b.
    ((a, Nat) -> Af_entry) -> [(Term a b, Term a b)] -> [(Term a b, Term a b)];
af_rules pi r = map (af_rule pi) r;

ta_normal_lhs ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (a, [[Prelude.Char]]);
ta_normal_lhs xml2name = many1 ['l', 'h', 's'] xml2name state (\ a b -> (a, b));

compatible_ta ::
  forall a.
    [Prelude.Char] ->
      (Xml -> Sum_bot [Prelude.Char] a) ->
        Xml ->
          Sum_bot [Prelude.Char]
            (Tree_automaton [Prelude.Char] a, Ta_relation [Prelude.Char]);
compatible_ta tag xml2name =
  guard (\ x -> equal_nat (num_children x) (Nat_of_num One))
    (singleton tag (tree_automaton (ta_normal_lhs xml2name))
      (\ ta -> (ta, Id_Relation)))
    (pair tag (tree_automaton (ta_normal_lhs xml2name)) closed_criterion
      (\ a b -> (a, b)));

doc_of_stringa :: [Prelude.Char] -> Sum [Prelude.Char] Xmldoc;
doc_of_stringa =
  debug ['0']
    ['p', 'a', 'r', 's', 'i', 'n', 'g', ' ', 't', 'x', 't', ' ', 't', 'o', ' ',
      'x', 'm', 'l']
    doc_of_string;

default_grd_fun ::
  forall a.
    (Eq a) => Term (Lab [Prelude.Char] a) [Prelude.Char] ->
                Term (Lab [Prelude.Char] a) [Prelude.Char] ->
                  [Prelude.Char] -> Term (Lab [Prelude.Char] a) [Prelude.Char];
default_grd_fun s t =
  let {
    f = funs_rule_list (s, t);
    m = fold (\ fa m ->
               (case fa of {
                 Lab _ _ -> m;
                 FunLab _ _ -> m;
                 UnLab _ -> m;
                 Sharp (Lab _ _) -> m;
                 Sharp (FunLab _ _) -> m;
                 Sharp (UnLab g) -> max (size_list g) m;
                 Sharp (Sharp _) -> m;
               }))
          f Zero_nat;
    suffix = replicate (plus_nat m (Nat_of_num One)) 'a';
  } in (\ x -> Fun (Sharp (UnLab (x ++ suffix))) []);

xml2non_join_info ::
  (Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat])) ->
    Xml ->
      Sum_bot [Prelude.Char]
        (Non_join_info (Lab [Prelude.Char] [Nat]) [Prelude.Char]
          [Prelude.Char]);
xml2non_join_info xml2name x =
  options
    [(['d', 'i', 's', 't', 'i', 'n', 'c', 't', 'N', 'o', 'r', 'm', 'a', 'l',
        'F', 'o', 'r', 'm', 's'],
       leaf ['d', 'i', 's', 't', 'i', 'n', 'c', 't', 'N', 'o', 'r', 'm', 'a',
              'l', 'F', 'o', 'r', 'm', 's']
         Diff_NFs),
      (['c', 'a', 'p', 'N', 'o', 't', 'U', 'n', 'i', 'f'],
        leaf ['c', 'a', 'p', 'N', 'o', 't', 'U', 'n', 'i', 'f']
          (Tcap_Non_Unif default_grd_fun)),
      (['g', 'r', 'o', 'u', 'n', 'd', 'i', 'n', 'g'],
        pair ['g', 'r', 'o', 'u', 'n', 'd', 'i', 'n', 'g'] (substa xml2name)
          (xml2non_join_info xml2name) Grounding),
      (['e', 'm', 'p', 't', 'y', 'T', 'r', 'e', 'e', 'A', 'u', 't', 'o', 'm',
         'a', 't', 'a', 'I', 'n', 't', 'e', 'r', 's', 'e', 'c', 't', 'i', 'o',
         'n'],
        pair ['e', 'm', 'p', 't', 'y', 'T', 'r', 'e', 'e', 'A', 'u', 't', 'o',
               'm', 'a', 't', 'a', 'I', 'n', 't', 'e', 'r', 's', 'e', 'c', 't',
               'i', 'o', 'n']
          (compatible_ta
            ['f', 'i', 'r', 's', 't', 'A', 'u', 't', 'o', 'm', 'a', 't', 'o',
              'n']
            xml2name)
          (compatible_ta
            ['s', 'e', 'c', 'o', 'n', 'd', 'A', 'u', 't', 'o', 'm', 'a', 't',
              'o', 'n']
            xml2name)
          (\ (ta1, rel1) (a, b) -> Tree_Aut_Intersect_Empty ta1 rel1 a b)),
      (['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', 'I', 'n', 't', 'e', 'r',
         'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n'],
        singleton
          ['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', 'I', 'n', 't', 'e', 'r',
            'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
          (sl_variant xml2name) Finite_Model_Gt),
      (['s', 't', 'r', 'i', 'c', 't', 'D', 'e', 'c', 'r', 'e', 'a', 's', 'e'],
        singleton
          ['s', 't', 'r', 'i', 'c', 't', 'D', 'e', 'c', 'r', 'e', 'a', 's', 'e']
          (ordering_constraint_proof False xml2name) Reduction_Pair_Gt),
      (['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e', 'r',
         'N', 'o', 'n', 'J', 'o', 'i', 'n'],
        pair ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 'F', 'i', 'l', 't', 'e',
               'r', 'N', 'o', 'n', 'J', 'o', 'i', 'n']
          (afs xml2name) (xml2non_join_info xml2name) Argument_Filter_NJ),
      (['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'N', 'o', 'n',
         'J', 'o', 'i', 'n'],
        singleton
          ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's', 'N', 'o', 'n',
            'J', 'o', 'i', 'n']
          (xml2non_join_info xml2name) Usable_Rules_Reach_NJ)]
    x;

xml2ncr_proof ::
  (Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat])) ->
    Xml ->
      Sum_bot [Prelude.Char]
        (Ncr_proof [Prelude.Char] [Nat] [Prelude.Char] [Prelude.Char]);
xml2ncr_proof xml2name x =
  let {
    rew = rsteps xml2name;
  } in singleton ['c', 'r', 'D', 'i', 's', 'p', 'r', 'o', 'o', 'f']
         (options
           [(['n', 'o', 'n', 'W', 'c', 'r', 'A', 'n', 'd', 'S', 'N'],
              pair ['n', 'o', 'n', 'W', 'c', 'r', 'A', 'n', 'd', 'S', 'N']
                (\ _ -> returna ()) (xml2trs_termination_proof xml2name)
                (\ _ -> SN_NWCR)),
             (['n', 'o', 'n', 'J', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'F', 'o',
                'r', 'k'],
               triple
                 ['n', 'o', 'n', 'J', 'o', 'i', 'n', 'a', 'b', 'l', 'e', 'F',
                   'o', 'r', 'k']
                 rew rew (xml2non_join_info xml2name)
                 (\ (s, seq1) (_, a) -> Non_Join s seq1 a)),
             (['m', 'o', 'd', 'u', 'l', 'a', 'r', 'i', 't', 'y', 'D', 'i', 's',
                'j', 'o', 'i', 'n', 't'],
               pair ['m', 'o', 'd', 'u', 'l', 'a', 'r', 'i', 't', 'y', 'D', 'i',
                      's', 'j', 'o', 'i', 'n', 't']
                 (singleton ['t', 'r', 's'] (rules xml2name) id)
                 (xml2ncr_proof xml2name) NCR_Disj_Subtrs)])
         id x;

xml_signature :: forall a b. (Showa a, Showa b) => [(Lab a [b], Nat)] -> Xml;
xml_signature fs =
  XML ['s', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e'] []
    (map (\ (f, n) ->
           XML ['s', 'y', 'm', 'b', 'o', 'l'] []
             [xml_lab f,
               XML ['a', 'r', 'i', 't', 'y'] [] []
                 (Just (shows_prec_nat Zero_nat n []))]
             Nothing)
      fs)
    Nothing;

xml_trs_input ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => Sum (Strategy (Lab a [b]) c) (Fp_strategy (Lab a [b]) c) ->
                    [(Term (Lab a [b]) c, Term (Lab a [b]) c)] ->
                      Maybe [(Term (Lab a [b]) c, Term (Lab a [b]) c)] -> Xml;
xml_trs_input strat r Nothing =
  XML ['t', 'r', 's', 'I', 'n', 'p', 'u', 't'] []
    ([xml_rules ['t', 'r', 's'] r] ++ xml_strategy strat) Nothing;
xml_trs_input strat r (Just s) =
  XML ['t', 'r', 's', 'I', 'n', 'p', 'u', 't'] []
    (xml_rules ['t', 'r', 's'] r :
      xml_strategy strat ++
        [xml_rules
           ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'R', 'u', 'l', 'e', 's'] s])
    Nothing;

mgu_var_disjoint_generic ::
  forall a b c d.
    (Eq b,
      Eq d) => (a -> b) ->
                 (c -> b) ->
                   Term d a -> Term d c -> Maybe (a -> Term d b, c -> Term d b);
mgu_var_disjoint_generic vu wu s t =
  (case mgu (map_vars vu s) (map_vars wu t) of {
    Nothing -> Nothing;
    Just gamma -> Just (map_subst_domain vu gamma, map_subst_domain wu gamma);
  });

critical_pairs_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Bool, (Term a [Prelude.Char], Term a [Prelude.Char]))];
critical_pairs_impl p r =
  concatMap
    (\ (l, ra) ->
      concatMap
        (\ pa ->
          let {
            c = ctxt_of_pos_term pa l;
            la = subt_at l pa;
            b = equal_ctxt c Hole;
          } in (if is_Var la then []
                 else concatMap
                        (\ (laa, rb) ->
                          (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                                  (\ a -> 'y' : a) la laa
                            of {
                            Nothing -> [];
                            Just (sigma, tau) ->
                              [(b, (subst_apply_term ra sigma,
                                     ctxt_apply (subst_apply_ctxt c sigma)
                                       (subst_apply_term rb tau)))];
                          }))
                        r))
        (poss_list l))
    p;

check_linear_trs ::
  forall a b.
    (Showa a, Ceq b, Corder b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_linear_trs r =
  catcha
    (catcha
      (forallM
        (\ x ->
          (if let {
                (l, ra) = x;
              } in linear_term l && linear_term ra
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ _ ->
      Inl (shows_prec_list Zero_nat r .
            shows_nl .
              shows_string
                ['i', 's', ' ', 'n', 'o', 't', ' ', 'l', 'i', 'n', 'e', 'a',
                  'r'] .
                shows_nl));

indent ::
  ([Prelude.Char] -> [Prelude.Char]) -> [Prelude.Char] -> [Prelude.Char];
indent p s =
  concatMap (\ c -> (if c == newline then [newline, ' '] else [c])) (p s);

reachable_terms ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Nat -> [Term a b];
reachable_terms r s n =
  (if equal_nat n Zero_nat then [s]
    else let {
           ts = reachable_terms r s (minus_nat n (Nat_of_num One));
         } in remdups (ts ++ concatMap (rewrite r) ts));

check_strongly_closed ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strongly_closed r n =
  catcha
    (bindb (check_linear_trs r)
      (\ _ ->
        catcha
          (forallM
            (\ (_, (s, t)) ->
              check (not (is_none
                           (find (membera (reachable_terms r s n))
                             (reachable_terms r t
                               (plus_nat Zero_nat (Nat_of_num One))))) &&
                      not (is_none
                            (find (membera (reachable_terms r t n))
                              (reachable_terms r s
                                (plus_nat Zero_nat (Nat_of_num One))))))
                (shows_prec_list Zero_nat
                   ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', ' ', 'c',
                     'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'a', 'i', 'r',
                     ' ', 't', 'h', 'a', 't', ' ', 'i', 's', ' ', 'n', 'o', 't',
                     ' ', 's', 't', 'r', 'o', 'n', 'g', 'l', 'y', ' ', 'c', 'l',
                     'o', 's', 'e', 'd', ':', ' '] .
                  shows_term (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                    s .
                    shows_prec_list Zero_nat
                      [' ', '<', '-', ' ', '.', ' ', '-', '>', ' '] .
                      shows_term (shows_prec Zero_nat)
                        (shows_prec_list Zero_nat) t))
            (critical_pairs_impl r r))
          (\ x -> Inl (snd x))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list Zero_nat
                   ['h', 'e', 'n', 'c', 'e', ',', ' ', 't', 'h', 'e', ' ', 'f',
                     'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'T', 'R', 'S',
                     ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 't', 'r', 'o',
                     'n', 'g', 'l', 'y', ' ', 'c', 'l', 'o', 's', 'e', 'd',
                     ' '] .
                   shows_nl .
                     shows_trs (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                         't', 'e', 'm', ':']
                       [' ', '-', '>', ' '] r .
                       indent x));

applicable_rule_implb ::
  forall a b. (Term a b -> Bool) -> (Term a b, Term a b) -> Bool;
applicable_rule_implb isNF = (\ (l, _) -> all isNF (args l));

check_non_applicable_rules ::
  forall a b.
    (Term a b -> Bool) -> [(Term a b, Term a b)] -> Sum (Term a b, Term a b) ();
check_non_applicable_rules isNF r =
  catcha
    (forallM
      (\ x -> (if not (applicable_rule_implb isNF x) then Inr () else Inl x)) r)
    (\ x -> Inl (snd x));

is_ur_closed_term_af_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   ((a, Nat) -> Nat -> Bool) ->
                     [(Term a [Prelude.Char], c)] ->
                       [(Term a [Prelude.Char], c)] ->
                         [Term a [Prelude.Char]] -> Term a b -> Bool;
is_ur_closed_term_af_impl nfq e_cap pi r u s (Var x) = True;
is_ur_closed_term_af_impl nfq e_cap pi r u s (Fun f ts) =
  let {
    n = size_list ts;
    pi_f = pi (f, n);
  } in all (\ (i, t) ->
             (if pi_f i then is_ur_closed_term_af_impl nfq e_cap pi r u s t
               else True))
         (zip (upt Zero_nat n) ts) &&
         all (\ (l, ra) ->
               membera u (l, ra) ||
                 (case mgu_class (Fun f (map e_cap ts)) l of {
                   Nothing -> True;
                   Just mu ->
                     not (all (\ ua ->
                                nfq (subst_apply_term
                                      (map_vars (\ a -> 'y' : a) ua) mu))
                           (args l)) ||
                       not (all (\ ua -> nfq (subst_apply_term ua mu)) s);
                 }))
           r;

is_ur_closed_af_impl_dpp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Nat -> Bool) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Term b [Prelude.Char] -> Bool;
is_ur_closed_af_impl_dpp_mv i d pi =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulesd i d;
    urc = (\ s -> is_ur_closed_term_af_impl qnf (ic s) pi r);
  } in (\ u s ->
         let {
           sa = map (map_vars (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_vars (\ a -> 'x' : a) t)));

wwf_rulesa :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
wwf_rulesa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = wwf_rules;

q_emptyc :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
q_emptyc
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = q_empty;

matchCapRMBelow ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                 Term a b -> Term a b -> Bool;
matchCapRMBelow rm l (Fun f ts) = matchb (GCFun f (map (capRM2 rm) ts)) l;

forallM_index_aux ::
  forall a b. (a -> Nat -> Sum b ()) -> Nat -> [a] -> Sum ((a, Nat), b) ();
forallM_index_aux p i [] = Inr ();
forallM_index_aux p i (x : xs) =
  bindb (catcha (p x i) (\ xa -> Inl ((x, i), xa)))
    (\ _ -> forallM_index_aux p (plus_nat i (Nat_of_num One)) xs);

forallM_index ::
  forall a b. (a -> Nat -> Sum b ()) -> [a] -> Sum ((a, Nat), b) ();
forallM_index p xs = forallM_index_aux p Zero_nat xs;

check_ur_closed_term_rm_af ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                    [(Term a b, Term a b)] ->
                      ((a, Nat) -> Nat -> Bool) ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ur_closed_term_rm_af uu uv uw (Var x) = Inr ();
check_ur_closed_term_rm_af rm ur pi (Fun f ts) =
  let {
    n = size_list ts;
    pia = pi (f, n);
  } in bindb (catcha
               (forallM_index
                 (\ t i ->
                   (if pia i then check_ur_closed_term_rm_af rm ur pi t
                     else Inr ()))
                 ts)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catcha
             (forallM
               (\ lr ->
                 check (membera ur lr ||
                         not (matchCapRMBelow rm (fst lr) (Fun f ts)))
                   (shows_string
                      ['d', 'u', 'e', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ',
                        's', 'u', 'b', 't', 'e', 'r', 'm', ' '] .
                     shows_prec_term Zero_nat (Fun f ts) .
                       shows_string
                         [' ', 'o', 'f', ' ', 's', 'o', 'm', 'e', ' ', 'u', 's',
                           'a', 'b', 'l', 'e', ' ', 'r', 'h', 's', ',', ' ',
                           'r', 'u', 'l', 'e', ' '] .
                         shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                           [' ', '-', '>', ' '] lr .
                           shows_string
                             [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e',
                               ' ', 'u', 's', 'a', 'b', 'l', 'e', '.']))
               (rm (f, n)))
             (\ x -> Inl (snd x)));

check_ur_P_closed_rm_af ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> [(Term a b, Term a b)]) ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        ((a, Nat) -> Nat -> Bool) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ur_P_closed_rm_af rm ur p pi =
  bindb (catcha
          (catcha
            (forallM (\ lr -> check_ur_closed_term_rm_af rm ur pi (snd lr)) ur)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (shows_string
                   ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
                     'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'c', 'l', 'o', 's',
                     'u', 'r', 'e', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'i',
                     'e', 's', ' ', 'o', 'f', ' ', 'r', 'h', 's', ' ', 'o', 'f',
                     ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                     's'] .
                  shows_nl . x)))
    (\ _ ->
      catcha
        (catcha
          (forallM (\ st -> check_ur_closed_term_rm_af rm ur pi (snd st)) p)
          (\ x -> Inl (snd x)))
        (\ x ->
          Inl (shows_string
                 ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
                   'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'c', 'l', 'o', 's',
                   'u', 'r', 'e', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'i',
                   'e', 's', ' ', 'o', 'f', ' ', 'r', 'h', 's', ' ', 'o', 'f',
                   ' ', 'D', 'P', 's'] .
                shows_nl . x)));

smart_usable_rules_checker_impl ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> ((b, Nat) -> Nat -> Bool) ->
                           Maybe [(Term b [Prelude.Char],
                                    Term b [Prelude.Char])] ->
                             [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                               Sum ([Prelude.Char] -> [Prelude.Char])
                                 [(Term b [Prelude.Char],
                                    Term b [Prelude.Char])];
smart_usable_rules_checker_impl i d pi u_opt sts =
  let {
    nfs = nfsc i d;
    m = minimal i d;
    wwf = wwf_rulesa i d;
    qempty = q_emptyc i d;
  } in (case u_opt of {
         Nothing -> Inr (rulesd i d);
         Just u ->
           (if nFQ_subset_NF_rulesb i d &&
                 (nfs || isOK (check_varcond_subset sts)) && (nfs || (m || wwf))
             then let {
                    urc = is_ur_closed_af_impl_dpp_mv i d pi u;
                    check_urc =
                      (\ s t ->
                        check (urc s t)
                          (shows_prec_list Zero_nat ['t', 'e', 'r', 'm', ' '] .
                            shows_prec_term Zero_nat t .
                              shows_prec_list Zero_nat
                                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c',
                                  'l', 'o', 's', 'e', 'd', ' ', 'u', 'n', 'd',
                                  'e', 'r', ' ', 'u', 's', 'a', 'b', 'l', 'e',
                                  ' ', 'r', 'u', 'l', 'e', 's']));
                  } in bindb (catcha (forallM (\ (s, a) -> check_urc [s] a) sts)
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catcha
                                   (forallM (\ (l, a) -> check_urc (args l) a)
                                     u)
                                   (\ x -> Inl (snd x)))
                             (\ _ -> Inr u))
             else bindb (check (m && (if nfs then qempty || wwf else True))
                          (shows_prec_list Zero_nat
                            ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                              ' ', 'a', 'n', 'd', ' ', 'w', 'e', 'l', 'l', ' ',
                              'f', 'o', 'r', 'm', 'e', 'd', 'n', 'e', 's', 's',
                              ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                    (\ _ ->
                      bindb (catcha
                              (forallM
                                (\ (l, _) ->
                                  check (not (is_Var l))
                                    (shows_prec_list Zero_nat
                                      ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
's', ' ', 'a', 's', ' ', 'l', 'h', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l',
'l', 'o', 'w', 'e', 'd']))
                                (rulesd i d))
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          let {
                            rm = rules_mapb i d;
                          } in bindb (check_ur_P_closed_rm_af rm u sts pi)
                                 (\ _ -> Inr u))));
       });

root_aft_to_entry ::
  forall a b c. a -> Term b c -> ((b, Nat) -> Nat -> Bool) -> [(a, Term b c)];
root_aft_to_entry s t pi =
  let {
    rt = the (root t);
    pi_t = pi rt;
    ts = args t;
  } in map_filter (\ x -> (if pi_t x then Just (s, nth ts x) else Nothing))
         (upt Zero_nat (snd rt));

check_no_defined_root ::
  forall a b.
    (Showa a,
      Showa b) => ((a, Nat) -> Bool) ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_defined_root isdef t =
  check (not (isdef (the (root t))))
    (shows_string ['t', 'h', 'e', ' ', 'r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
      shows_prec_term Zero_nat t .
        shows_string [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd']);

pairsa :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pairsa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = pairs;

valida ::
  forall a b c.
    Root_redtriple_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
valida (Root_redtriple_ext valid s ns nst af aft desc more) = valid;

descb ::
  forall a b c. Root_redtriple_ext a b c -> [Prelude.Char] -> [Prelude.Char];
descb (Root_redtriple_ext valid s ns nst af aft desc more) = desc;

nsta ::
  forall a b c.
    Root_redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsta (Root_redtriple_ext valid s ns nst af aft desc more) = nst;

aft :: forall a b c. Root_redtriple_ext a b c -> (a, Nat) -> Nat -> Bool;
aft (Root_redtriple_ext valid s ns nst af aft desc more) = aft;

nsa ::
  forall a b c.
    Root_redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsa (Root_redtriple_ext valid s ns nst af aft desc more) = ns;

afa :: forall a b c. Root_redtriple_ext a b c -> (a, Nat) -> Nat -> Bool;
afa (Root_redtriple_ext valid s ns nst af aft desc more) = af;

sa :: forall a b c.
        Root_redtriple_ext a b c ->
          (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sa (Root_redtriple_ext valid s ns nst af aft desc more) = s;

generic_ur_af_root_redtriple_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Root_redtriple_ext b [Prelude.Char] () ->
                      Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_ur_af_root_redtriple_proc i rp u_opt premove dpp =
  (case catcha
          (bindb (valida rp)
            (\ _ ->
              let {
                (ps, pns) = split_pairsa i dpp premove;
                p = pairsa i dpp;
                pi = afa rp;
                pia = aft rp;
                is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
              } in bindb (catcha
                           (forallM
                             (\ (l, r) ->
                               bindb (check_no_var l)
                                 (\ _ ->
                                   bindb (check_no_var r)
                                     (\ _ -> check_no_defined_root is_def r)))
                             p)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       bindb (catcha
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulesd i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (smart_usable_rules_checker_impl i dpp pi u_opt
                                   (concatMap
                                     (\ (s, t) -> root_aft_to_entry s t pia) p))
                             (\ u ->
                               bindb (catcha
                                       (catcha (forallM (nsa rp) u)
 (\ x -> Inl (snd x)))
                                       (\ x ->
 Inl (shows_string
        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
          'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', '(', 'u', 's', 'a', 'b',
          'l', 'e', ')', ' ', 'r', 'u', 'l', 'e', 's'] .
       shows_nl . x)))
                                 (\ _ ->
                                   bindb (catcha
   (catcha (forallM (nsta rp) pns) (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
              'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
           shows_nl . x)))
                                     (\ _ ->
                                       catcha
 (catcha (forallM (sa rp) ps) (\ x -> Inl (snd x)))
 (\ x ->
   Inl (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
            'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
         shows_nl . x)))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e',
                     'r', 'i', 'c', ' ', 'r', 'o', 'o', 't', ' ', 'r', 'e', 'd',
                     'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ',
                     'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i',
                     't', 'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o',
                     'w', 'i', 'n', 'g'] .
                  shows_nl . descb rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp premove premove);
  });

valid ::
  forall a b c.
    Redtriple_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
valid (Redtriple_ext valid s ns nst af mono desc cpx more) = valid;

desc :: forall a b c. Redtriple_ext a b c -> [Prelude.Char] -> [Prelude.Char];
desc (Redtriple_ext valid s ns nst af mono desc cpx more) = desc;

nst ::
  forall a b c.
    Redtriple_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nst (Redtriple_ext valid s ns nst af mono desc cpx more) = nst;

ns :: forall a b c.
        Redtriple_ext a b c ->
          (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
ns (Redtriple_ext valid s ns nst af mono desc cpx more) = ns;

af :: forall a b c. Redtriple_ext a b c -> (a, Nat) -> Nat -> Bool;
af (Redtriple_ext valid s ns nst af mono desc cpx more) = af;

s :: forall a b c.
       Redtriple_ext a b c ->
         (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
s (Redtriple_ext valid s ns nst af mono desc cpx more) = s;

generic_ur_af_redtriple_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_ur_af_redtriple_proc i rp u_opt premove dpp =
  (case catcha
          (bindb (valid rp)
            (\ _ ->
              let {
                (ps, pns) = split_pairsa i dpp premove;
                p = pairsa i dpp;
              } in bindb (smart_usable_rules_checker_impl i dpp (af rp) u_opt p)
                     (\ u ->
                       bindb (catcha
                               (catcha (forallM (ns rp) u) (\ x -> Inl (snd x)))
                               (\ x ->
                                 Inl (shows_string
['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r', 'i',
  'e', 'n', 't', 'i', 'n', 'g', ' ', '(', 'u', 's', 'a', 'b', 'l', 'e', ')',
  ' ', 'r', 'u', 'l', 'e', 's'] .
                                       shows_nl . x)))
                         (\ _ ->
                           bindb (catcha
                                   (catcha (forallM (nst rp) pns)
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (shows_string
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
      'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
   shows_nl . x)))
                             (\ _ ->
                               catcha
                                 (catcha (forallM (s rp) ps)
                                   (\ x -> Inl (snd x)))
                                 (\ x ->
                                   Inl (shows_string
  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
    'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
 shows_nl . x)))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e',
                     'r', 'i', 'c', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o',
                     'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e',
                     's', 's', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h',
                     'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp premove premove);
  });

is_ur_closed_term_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   [(Term a [Prelude.Char], c)] ->
                     [(Term a [Prelude.Char], c)] ->
                       [Term a [Prelude.Char]] -> Term a b -> Bool;
is_ur_closed_term_impl nfq e_cap r u s (Var x) = True;
is_ur_closed_term_impl nfq e_cap r u s (Fun f ts) =
  all (is_ur_closed_term_impl nfq e_cap r u s) ts &&
    all (\ (l, ra) ->
          membera u (l, ra) ||
            (case mgu_class (Fun f (map e_cap ts)) l of {
              Nothing -> True;
              Just mu ->
                not (all (\ ua ->
                           nfq (subst_apply_term (map_vars (\ a -> 'y' : a) ua)
                                 mu))
                      (args l)) ||
                  not (all (\ ua -> nfq (subst_apply_term ua mu)) s);
            }))
      r;

is_ur_closed_impl_dpp_mv ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                           [Term b [Prelude.Char]] ->
                             Term b [Prelude.Char] -> Bool;
is_ur_closed_impl_dpp_mv i d =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulesd i d;
    urc = (\ s -> is_ur_closed_term_impl qnf (ic s) r);
  } in (\ u s ->
         let {
           sa = map (map_vars (\ a -> 'x' : a)) s;
         } in (\ t -> urc sa u sa (map_vars (\ a -> 'x' : a) t)));

intersect_rulesb ::
  forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_rulesb
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = intersect_rules;

usable_rules_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
usable_rules_proc i u dpp =
  (case bindb (check (nFQ_subset_NF_rulesb i dpp)
                (shows_prec_list Zero_nat
                  ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e',
                    'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'r', 'e', 'q', 'u',
                    'i', 'r', 'e', 'd']))
          (\ _ ->
            bindb (check (nfsc i dpp || (minimal i dpp || wwf_rulesa i dpp))
                    (shows_prec_list Zero_nat
                      ['n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm',
                        ' ', 's', 'u', 'b', 's', 't', ',', ' ', 'm', 'i', 'n',
                        'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'o', 'r', ' ',
                        'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd',
                        'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                        'e', 'd']))
              (\ _ ->
                let {
                  p = pairsa i dpp;
                  urc = is_ur_closed_impl_dpp_mv i dpp u;
                  check_urc =
                    (\ s t ->
                      check (urc s t)
                        (shows_prec_list Zero_nat ['t', 'e', 'r', 'm', ' '] .
                          shows_prec_term Zero_nat t .
                            shows_prec_list Zero_nat
                              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l',
                                'o', 's', 'e', 'd', ' ', 'u', 'n', 'd', 'e',
                                'r', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                                'r', 'u', 'l', 'e', 's']));
                  nfs = nfsc i dpp;
                } in bindb (catcha
                             (forallM
                               (\ (l, r) ->
                                 bindb (if nfs then Inr ()
 else catcha (check_subseteq (vars_term_list r) (vars_term_list l))
        (\ _ ->
          Inl (shows_prec_list Zero_nat
                ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'n',
                  'd', 'i', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'P', ' ',
                  'v', 'i', 'o', 'l', 'a', 't', 'e', 'd'])))
                                   (\ _ -> check_urc [l] r))
                               p)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         catcha (forallM (\ (l, a) -> check_urc (args l) a) u)
                           (\ x -> Inl (snd x)))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (intersect_rulesb i dpp u);
  });

mono ::
  forall a b c.
    Redtriple_ext a b c ->
      [(Term a b, Term a b)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
mono (Redtriple_ext valid s ns nst af mono desc cpx more) = mono;

mono_inn_usable_rules_ce_proc ::
  forall a b.
    (Ceq b, Corder b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_inn_usable_rules_ce_proc i rp premove rremove ur dpp =
  (case catcha
          (bindb (usable_rules_proc i ur dpp)
            (\ _ ->
              let {
                p = pairsa i dpp;
                us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
                filt =
                  (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
                (pms, pns) = split_pairsa i dpp premove;
                (ps, pnwf) = partition filt pms;
                (urms, urns) = partition (membera rremove) ur;
                (urs, urnwf) = partition filt urms;
              } in bindb (valid rp)
                     (\ _ ->
                       bindb (mono rp
                               (ps ++ urs ++ urns ++ urnwf ++ pns ++ pnwf))
                         (\ _ ->
                           bindb (catcha
                                   (catcha (forallM (ns rp) (urns ++ urnwf))
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (shows_string
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
      'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
      'r', 'u', 'l', 'e', 's'] .
   shows_nl . x)))
                             (\ _ ->
                               bindb (catcha
                                       (catcha (forallM (s rp) urs)
 (\ x -> Inl (snd x)))
                                       (\ x ->
 Inl (shows_string
        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
          'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l',
          'e', ' ', 'r', 'u', 'l', 'e', 's'] .
       shows_nl . x)))
                                 (\ _ ->
                                   bindb (catcha
   (catcha (forallM (ns rp) (pns ++ pnwf)) (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
              'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
           shows_nl . x)))
                                     (\ _ ->
                                       catcha
 (catcha (forallM (s rp) ps) (\ x -> Inl (snd x)))
 (\ x ->
   Inl (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
            'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
         shows_nl . x)))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'i', 'n', 'n', 'e',
                     'r', 'm', 'o', 's', 't', ' ', 'u', 's', 'a', 'b', 'l', 'e',
                     ' ', 'r', 'u', 'l', 'e', 's', ' ', 'r', 'e', 'd', 'u', 'c',
                     't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r',
                     'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't', 'h',
                     ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i',
                     'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

mono_ur_redpair_proc ::
  forall a b c.
    (Ceq b, Corder b, Eq b, Set_impl b, Showa b, Eq c,
      Showa c) => Dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          [(Term b c, Term b c)] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_ur_redpair_proc i rp premove rremove ur dpp =
  (case catcha
          (bindb
            (check (minimal i dpp)
              (shows_prec_list Zero_nat
                ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'r',
                  'e', 'q', 'u', 'i', 'r', 'e', 'd']))
            (\ _ ->
              bindb (check
                      (if nfsc i dpp
                        then (if not (q_emptyc i dpp) then wwf_rulesa i dpp
                               else True)
                        else True)
                      (shows_prec_list Zero_nat
                        ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e', 'd',
                          'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                          'e', 'd']))
                (\ _ ->
                  let {
                    p = pairsa i dpp;
                    us = foldr (sup_set . funas_term . snd) (p ++ ur) bot_set;
                    filt =
                      (\ lr -> ball (funas_term (fst lr)) (\ f -> member f us));
                    (pms, pns) = split_pairsa i dpp premove;
                    (ps, pnwf) = partition filt pms;
                    (urms, urns) = partition (membera rremove) ur;
                    (urs, urnwf) = partition filt urms;
                    rm = rules_mapb i dpp;
                  } in bindb (valid rp)
                         (\ _ ->
                           bindb (mono rp
                                   (ps ++ urs ++ urns ++ urnwf ++ pns ++ pnwf))
                             (\ _ ->
                               bindb (check_ur_P_closed_rm_af rm ur p full_af)
                                 (\ _ ->
                                   bindb (catcha
   (forallM
     (\ (l, _) ->
       check (not (is_Var l))
         (shows_prec_list Zero_nat
           ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ',
             'l', 'h', 's', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
             'w', 'e', 'd']))
     (rulesd i dpp))
   (\ x -> Inl (snd x)))
                                     (\ _ ->
                                       bindb
 (catcha (catcha (forallM (ns rp) (urns ++ urnwf)) (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
              'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a',
              'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
           shows_nl . x)))
 (\ _ ->
   bindb (catcha (catcha (forallM (s rp) urs) (\ x -> Inl (snd x)))
           (\ x ->
             Inl (shows_string
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                      ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ',
                      'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                      's'] .
                   shows_nl . x)))
     (\ _ ->
       bindb (catcha
               (catcha (forallM (ns rp) (pns ++ pnwf)) (\ x -> Inl (snd x)))
               (\ x ->
                 Inl (shows_string
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                          'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                          ' ', 'D', 'P', 's'] .
                       shows_nl . x)))
         (\ _ ->
           catcha (catcha (forallM (s rp) ps) (\ x -> Inl (snd x)))
             (\ x ->
               Inl (shows_string
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                        'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g',
                        ' ', 'D', 'P', 's'] .
                     shows_nl . x))))))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'n', 'o',
                     't', 'o', 'n', 'i', 'c', ' ', 'r', 'e', 'd', 'u', 'c', 't',
                     'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o',
                     'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ',
                     't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n',
                     'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

generic_mono_ur_redpair_proc ::
  forall a b.
    (Ceq b, Corder b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
generic_mono_ur_redpair_proc i rp premove rremove ur dpp =
  (if nFQ_subset_NF_rulesb i dpp
    then mono_inn_usable_rules_ce_proc i rp premove rremove ur dpp
    else bindb (check (minimal i dpp)
                 (shows_prec_list Zero_nat
                   ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'o',
                     'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ',
                     'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ', 'f', 'o', 'r',
                     ' ', 'm', 'o', 'n', '.', ' ', 'r', 'e', 'd', '.', ' ', 'p',
                     'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c', '.', ' ', 'w', 'i',
                     't', 'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u',
                     'l', 'e', 's']))
           (\ _ -> mono_ur_redpair_proc i rp premove rremove ur dpp));

compat_roota :: forall a b. (Eq a) => Term a b -> Maybe (a, Nat) -> Bool;
compat_roota uu Nothing = False;
compat_roota (Var uv) (Just v) = False;
compat_roota (Fun va vb) (Just v) = root (Fun va vb) == Just v;

usable_rules_gen2 ::
  forall a b.
    (Eq a) => [(Term a b, Term a b)] ->
                (Maybe (a, Nat), Bool) -> [(Term a b, Term a b)];
usable_rules_gen2 r (fn, b) =
  let {
    rr = concatMap (\ (l, ra) -> (if compat_roota l fn then [(l, ra)] else []))
           r;
  } in (if b then rr else map (\ (l, ra) -> (ra, l)) rr);

rel_dep_prod :: Bool -> Dependance -> [Bool];
rel_dep_prod uu Ignore = [];
rel_dep_prod b Increase = [b];
rel_dep_prod b Decrease = [not b];
rel_dep_prod uv Wild = [True, False];

compat_root :: forall a b c. (Eq a) => Term a b -> Term a c -> Bool;
compat_root uu (Var uv) = False;
compat_root (Var uw) (Fun v va) = False;
compat_root (Fun vb vc) (Fun v va) = root (Fun vb vc) == root (Fun v va);

usable_rules_gen1 ::
  forall a b.
    (Eq a) => ((a, Nat) -> Nat -> Dependance) ->
                [(Term a b, Term a b)] ->
                  (Term a b, Bool) -> [(Term a b, Bool)];
usable_rules_gen1 pi r (Var uu, uv) = [];
usable_rules_gen1 pi r (Fun f ts, b) =
  let {
    n = size_list ts;
  } in concatMap
         (\ (l, ra) -> (if compat_root l (Fun f ts) then [(ra, b)] else []))
         r ++
         concatMap
           (\ i -> map (\ a -> (nth ts i, a)) (rel_dep_prod b (pi (f, n) i)))
           (upt Zero_nat n);

usable_rules_gen ::
  forall a b.
    (Eq a,
      Eq b) => ((a, Nat) -> Nat -> Dependance) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] -> [(Term a b, Term a b)];
usable_rules_gen pi r p =
  concatMap (usable_rules_gen2 r)
    (remdups
      (map (\ (t, a) -> (root t, a))
        (mk_rtrancl_list (\ a b -> a == b) (usable_rules_gen1 pi r)
          (map (\ (_, t) -> (t, True)) p))));

generate_lists :: forall a. Nat -> [a] -> [[a]];
generate_lists n xs = concat_lists (map (\ _ -> xs) (upt Zero_nat n));

initial_conditions_gen_impl ::
  forall a. (a -> a -> Bool) -> Nat -> Nat -> [a] -> a -> [[a]];
initial_conditions_gen_impl pa bef_len aft_len p st =
  let {
    pairs = (\ n -> generate_lists n p);
    a = concatMap (\ bef -> map (\ aft -> bef ++ st : aft) (pairs aft_len))
          (pairs bef_len);
  } in filter
         (\ bef_st_aft ->
           all_interval_nat
             (\ i ->
               pa (nth bef_st_aft i)
                 (nth bef_st_aft (plus_nat i (Nat_of_num One))))
             Zero_nat (plus_nat bef_len aft_len))
         a;

disjoint_variant ::
  forall a b.
    (Eq a, Card_UNIV b, Ceq b, Cproper_interval b, Eq b, Mapping_impl b,
      Set_impl b) => [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Bool;
disjoint_variant sts uvs =
  equal_nat (size_list sts) (size_list uvs) &&
    all_interval_nat (\ i -> eq_rule_mod_vars (nth sts i) (nth uvs i)) Zero_nat
      (size_list sts) &&
      is_partition (map vars_rule uvs);

condition_of ::
  forall a b.
    a -> Condition_type -> (Term a b, Term a b) -> Cond_constraint a b;
condition_of c Bound (s, uu) = CC_cond False (s, Fun c []);
condition_of c Strict st = CC_cond True st;
condition_of c Non_Strict st = CC_cond False st;

constraint_of ::
  forall a b.
    a -> Condition_type -> [(Term a b, Term a b)] -> Nat -> Cond_constraint a b;
constraint_of c ctype uvs bef =
  CC_impl
    (map (\ i ->
           CC_rewr (snd (nth uvs i))
             (fst (nth uvs (plus_nat i (Nat_of_num One)))))
      (upt Zero_nat (minus_nat (size_list uvs) (Nat_of_num One))))
    (condition_of c ctype (nth uvs bef));

ur_term_impl ::
  forall a b c.
    (Eq a,
      Eq c) => (Term a [Prelude.Char] -> Bool) ->
                 (Term a b -> Term a (Sum () [Prelude.Char])) ->
                   [(Term a [Prelude.Char], c)] ->
                     ((a, Nat) -> Nat -> Bool) ->
                       [Term a [Prelude.Char]] ->
                         Term a b -> [(Term a [Prelude.Char], c)];
ur_term_impl nfq e_cap r pi s (Var x) = [];
ur_term_impl nfq e_cap r pi s (Fun f ts) =
  let {
    n = size_list ts;
    rec = map (ur_term_impl nfq e_cap r pi s) ts;
  } in remdups
         (concatMap (\ (i, urs) -> (if pi (f, n) i then urs else []))
            (zip (upt Zero_nat n) rec) ++
           filter
             (\ (l, _) ->
               (case mgu_class (Fun f (map e_cap ts)) l of {
                 Nothing -> False;
                 Just mu ->
                   all (\ u -> nfq (subst_apply_term u mu))
                     (s ++ map (map_vars (\ a -> 'y' : a)) (args l));
               }))
             r);

precompute_fun :: forall a b. (Key a) => (a -> b) -> [a] -> a -> b;
precompute_fun f asa =
  fun_of_map_fun (ceta_map_of (map (\ a -> (a, f a)) asa)) f;

usable_rules_calculator ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  ([Term a [Prelude.Char]] ->
                    Term a [Prelude.Char] -> Term a (Sum () [Prelude.Char])) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      ((a, Nat) -> Nat -> Bool) ->
                        (Term a [Prelude.Char], Term a [Prelude.Char]) ->
                          [(Term a [Prelude.Char], Term a [Prelude.Char])];
usable_rules_calculator nfq e_cap r pi =
  let {
    urt = (\ (s, t) ->
            let {
              sa = map (map_vars (\ a -> 'x' : a)) s;
              a = ur_term_impl nfq (e_cap sa) r pi sa
                    (map_vars (\ a -> 'x' : a) t);
            } in membera a);
    urules = map (\ (l, a) -> (args l, a)) r;
    ufun = precompute_fun urt urules;
  } in (\ (s, t) ->
         inductive_set_impl r ufun (\ (l, ra) -> [(args l, ra)]) [([s], t)]);

get_ur_calc_impl_dpp ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> ((b, Nat) -> Nat -> Bool) ->
                         (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                           [(Term b [Prelude.Char], Term b [Prelude.Char])];
get_ur_calc_impl_dpp i d pi =
  let {
    ic = icap_impl_dpp i d;
    qnf = is_QNFc i d;
    r = rulesd i d;
  } in usable_rules_calculator qnf ic r pi;

inn_usable_rules_pair ::
  forall a b.
    (Eq b,
      Key b) => Dpp_ops_ext a b [Prelude.Char] () ->
                  a -> (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                         [(Term b [Prelude.Char], Term b [Prelude.Char])];
inn_usable_rules_pair i d =
  let {
    inn = nFQ_subset_NF_rulesb i d;
    r = rulesd i d;
    _ = is_QNFc i d;
    calc = get_ur_calc_impl_dpp i d full_af;
    nfs = nfsc i d;
    wwf = wwf_rulesa i d;
    m = minimal i d;
  } in (\ (s, t) ->
         (if inn &&
               (nfs || subset (vars_term t) (vars_term s)) &&
                 (nfs || (m || wwf))
           then calc (s, t) else r));

icap_impl_dpp_mv ::
  forall a b.
    (Eq b) => Dpp_ops_ext a b [Prelude.Char] () ->
                a -> [Term b [Prelude.Char]] ->
                       Term b [Prelude.Char] -> Term b (Sum () [Prelude.Char]);
icap_impl_dpp_mv i d =
  let {
    qr = nFQ_subset_NF_rulesb i d;
    qnf = is_QNFc i d;
    r = rulesd i d;
    ic = icap_impl qr qnf (map fst r);
  } in (\ s ->
         let {
           sa = map (map_vars (\ a -> 'x' : a)) s;
           sx = ceta_set_of (concatMap vars_term_list sa);
         } in (\ t -> ic sa sx (map_vars (\ a -> 'x' : a) t)));

is_iedg_edge_dpp ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                           Term b [Prelude.Char] -> Bool;
is_iedg_edge_dpp i d =
  let {
    qnf = is_QNFc i d;
    ic = icap_impl_dpp_mv i d;
    _ = rulesd i d;
    urules = inn_usable_rules_pair i d;
  } in (\ (s, t) ->
         let {
           cst = ic [s] t;
           urls = reverse_rules (urules (s, t));
           ica = icap_impla urls [];
         } in (\ u ->
                (case mgu_class cst u of {
                  Nothing -> False;
                  Just mu ->
                    qnf (subst_apply_term (map_vars (\ a -> 'x' : a) s) mu) &&
                      qnf (subst_apply_term (map_vars (\ a -> 'y' : a) u) mu);
                }) &&
                  let {
                    cu = ica [] u;
                  } in (case mgu_class cu t of {
                         Nothing -> False;
                         Just mu ->
                           qnf (subst_apply_term (map_vars (\ a -> 'y' : a) s)
                                 mu);
                       })));

deep_normalize_cca :: forall a b. Cond_constraint a b -> Cond_constraint a b;
deep_normalize_cca (CC_impl [] c) = deep_normalize_cca c;
deep_normalize_cca (CC_impl (v : va) c) =
  CC_impl (map deep_normalize_cca (v : va)) (deep_normalize_cca c);
deep_normalize_cca (CC_cond s c) = CC_cond s c;
deep_normalize_cca (CC_all s c) = CC_all s (deep_normalize_cca c);
deep_normalize_cca (CC_rewr s c) = CC_rewr s c;

vars_cc_list :: forall a b. (Eq b) => Cond_constraint a b -> [b];
vars_cc_list (CC_cond ct (s, t)) = vars_term_list s ++ vars_term_list t;
vars_cc_list (CC_rewr s t) = vars_term_list s ++ vars_term_list t;
vars_cc_list (CC_impl c1 c2) = concatMap vars_cc_list c1 ++ vars_cc_list c2;
vars_cc_list (CC_all x c) =
  concatMap (\ y -> (if not (y == x) then [y] else [])) (vars_cc_list c);

cc_subst_apply ::
  forall a b.
    (Eq a) => ([a] -> a) ->
                Cond_constraint b a ->
                  (a -> Term b a, [a]) -> Cond_constraint b a;
cc_subst_apply fresh (CC_all x c) (sigma, vs) =
  let {
    y = fresh (vs ++ vars_cc_list (CC_all x c));
  } in CC_all y (cc_subst_apply fresh c (fun_upd sigma x (Var y), y : vs));
cc_subst_apply fresh (CC_impl c1 c2) sigma =
  CC_impl (map (\ c -> cc_subst_apply fresh c sigma) c1)
    (cc_subst_apply fresh c2 sigma);
cc_subst_apply fresh (CC_rewr s t) (sigma, uv) =
  CC_rewr (subst_apply_term s sigma) (subst_apply_term t sigma);
cc_subst_apply fresh (CC_cond ct (s, t)) (sigma, uu) =
  CC_cond ct (subst_apply_term s sigma, subst_apply_term t sigma);

normalize_alpha ::
  forall a b.
    (Eq a) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a;
normalize_alpha fresh c = cc_subst_apply fresh c (Var, []);

deep_normalize_cc ::
  forall a b.
    (Eq a) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a;
deep_normalize_cc fresh c = normalize_alpha fresh (deep_normalize_cca c);

check_subsumesa ::
  forall a b.
    (Eq a, Eq b) => Cond_constraint a b -> Cond_constraint a b -> Bool;
check_subsumesa (CC_impl cs c) (CC_impl ds d) =
  check_subsumesa c d &&
    all (\ ca -> any (\ da -> check_subsumesa da ca) ds) cs;
check_subsumesa (CC_cond v va) (CC_impl ds d) =
  check_subsumesa (CC_cond v va) d;
check_subsumesa (CC_rewr v va) (CC_impl ds d) =
  check_subsumesa (CC_rewr v va) d;
check_subsumesa (CC_all v va) (CC_impl ds d) = check_subsumesa (CC_all v va) d;
check_subsumesa (CC_all x c) (CC_all y d) = x == y && check_subsumesa c d;
check_subsumesa (CC_cond v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_cond vb vc);
check_subsumesa (CC_cond v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_rewr vb vc);
check_subsumesa (CC_cond v va) (CC_all vb vc) =
  equal_cond_constraint (CC_cond v va) (CC_all vb vc);
check_subsumesa (CC_rewr v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_cond vb vc);
check_subsumesa (CC_rewr v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_rewr vb vc);
check_subsumesa (CC_rewr v va) (CC_all vb vc) =
  equal_cond_constraint (CC_rewr v va) (CC_all vb vc);
check_subsumesa (CC_all v va) (CC_cond vb vc) =
  equal_cond_constraint (CC_all v va) (CC_cond vb vc);
check_subsumesa (CC_all v va) (CC_rewr vb vc) =
  equal_cond_constraint (CC_all v va) (CC_rewr vb vc);
check_subsumesa c (CC_cond v va) = equal_cond_constraint c (CC_cond v va);
check_subsumesa c (CC_rewr v va) = equal_cond_constraint c (CC_rewr v va);
check_subsumesa (CC_impl vb vc) (CC_all v va) =
  equal_cond_constraint (CC_impl vb vc) (CC_all v va);

check_subsumes ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) -> Cond_constraint b a -> Cond_constraint b a -> Bool;
check_subsumes fresh c d =
  let {
    n = deep_normalize_cc fresh;
  } in check_subsumesa (n c) (n d);

check_constraint_present ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> b -> [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                                Nat ->
                                  Nat ->
                                    [(Cond_constraint b [Prelude.Char],
                                       [(Term b [Prelude.Char],
  Term b [Prelude.Char])])] ->
                                      Condition_type ->
(Term b [Prelude.Char], Term b [Prelude.Char]) ->
  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_constraint_present i dpp constant p bef aft ccs =
  let {
    edg = is_iedg_edge_dpp i dpp;
    init_conds =
      initial_conditions_gen_impl (\ st uv -> edg st (fst uv)) bef aft p;
  } in (\ ct st ->
         catcha
           (forallM
             (\ sts ->
               check (any (\ (c, uvs) ->
                            disjoint_variant sts uvs &&
                              check_subsumes (fresh_string ['x', 'x']) c
                                (constraint_of constant ct uvs bef))
                       ccs)
                 (shows_prec_list Zero_nat
                    ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
                      ' '] .
                   shows_prec_list Zero_nat
                     (case ct of {
                       Bound -> ['b', 'o', 'u', 'n', 'd'];
                       Strict -> ['s', 't', 'r', 'i', 'c', 't'];
                       Non_Strict ->
                         ['n', 'o', 'n', '-', 's', 't', 'r', 'i', 'c', 't'];
                     }) .
                     shows_prec_list Zero_nat
                       [' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't',
                         ' ', 'f', 'o', 'r', ' ', 's', 'e', 'q', 'u', 'e', 'n',
                         'c', 'e', ' '] .
                       shows_rules (shows_prec Zero_nat)
                         (shows_prec_list Zero_nat) [' ', '-', '>', ' '] sts))
             (init_conds st))
           (\ x -> Inl (snd x)));

check_left_linear_trs ::
  forall a b.
    (Showa a, Ceq b, Corder b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_left_linear_trs trs =
  catcha
    (catcha
      (forallM (\ x -> (if linear_term (fst x) then Inr () else Inl x)) trs)
      (\ x -> Inl (snd x)))
    (\ _ ->
      Inl (shows_prec_list Zero_nat trs .
            shows_nl .
              shows_string
                ['i', 's', ' ', 'n', 'o', 't', ' ', 'l', 'e', 'f', 't', '-',
                  'l', 'i', 'n', 'e', 'a', 'r'] .
                shows_nl));

check_weakly_orthogonal ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_weakly_orthogonal r =
  catcha
    (bindb (check_left_linear_trs r)
      (\ _ ->
        bindb (catcha
                (forallM
                  (\ (l, _) ->
                    check (not (is_Var l))
                      (shows_prec_list Zero_nat
                        ['t', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'h', 'a', 's',
                          ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', ' ',
                          'a', 's', ' ', 'l', 'e', 'f', 't', '-', 'h', 'a', 'n',
                          'd', ' ', 's', 'i', 'd', 'e', 's']))
                  r)
                (\ x -> Inl (snd x)))
          (\ _ ->
            catcha
              (forallM
                (\ (_, (s, t)) ->
                  check (equal_term s t)
                    (shows_prec_list Zero_nat
                       ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', ' ',
                         'n', 'o', 'n', '-', 't', 'r', 'i', 'v', 'i', 'a', 'l',
                         ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p',
                         'a', 'i', 'r', ':', ' '] .
                      shows_term (shows_prec Zero_nat)
                        (shows_prec_list Zero_nat) s .
                        shows_prec_list Zero_nat
                          [' ', '<', '-', ' ', '.', ' ', '-', '>', ' '] .
                          shows_term (shows_prec Zero_nat)
                            (shows_prec_list Zero_nat) t))
                (critical_pairs_impl r r))
              (\ x -> Inl (snd x)))))
    (\ x ->
      Inl (x . shows_nl .
                 shows_prec_list Zero_nat
                   ['h', 'e', 'n', 'c', 'e', ',', ' ', 't', 'h', 'e', ' ', 'f',
                     'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'T', 'R', 'S',
                     ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'w', 'e', 'a', 'k',
                     'l', 'y', ' ', 'o', 'r', 't', 'h', 'o', 'g', 'o', 'n', 'a',
                     'l', ' '] .
                   shows_nl .
                     shows_trs (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                       ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                         't', 'e', 'm', ':']
                       [' ', '-', '>', ' '] r .
                       indent x));

validb ::
  forall a b c.
    Non_inf_order_ext a b c -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
validb (Non_inf_order_ext valid ns cc af desc more) = valid;

descc ::
  forall a b c. Non_inf_order_ext a b c -> [Prelude.Char] -> [Prelude.Char];
descc (Non_inf_order_ext valid ns cc af desc more) = desc;

nsb ::
  forall a b c.
    Non_inf_order_ext a b c ->
      (Term a b, Term a b) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
nsb (Non_inf_order_ext valid ns cc af desc more) = ns;

cc :: forall a b c.
        Non_inf_order_ext a b c ->
          C_constraint a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
cc (Non_inf_order_ext valid ns cc af desc more) = cc;

afb :: forall a b c. Non_inf_order_ext a b c -> (a, Nat) -> Nat -> Dependance;
afb (Non_inf_order_ext valid ns cc af desc more) = af;

range_vars_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
range_vars_impl sigma =
  let {
    a = mk_subst_domain sigma;
  } in concatMap (vars_term_list . snd) a;

cc_bound :: forall a b. [a] -> Cond_constraint b a -> Cond_constraint b a;
cc_bound [] c = c;
cc_bound (x : xs) c = CC_all x (cc_bound xs c);

cc_ih_prems ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) ->
                 b -> Term b a ->
                        [a] ->
                          [Cond_constraint b a] ->
                            Cond_constraint b a ->
                              [(Term b a, [a])] -> [Cond_constraint b a];
cc_ih_prems fresh f q xs phi psi rs_ys_list =
  map (\ (r, ys) ->
        let {
          rs = args r;
          mu = mk_subst Var (zip xs rs);
          vs = range_vars_impl (zip xs rs);
          mua = (\ c -> cc_subst_apply fresh c (mu, vs));
          a = CC_impl (CC_rewr r (subst_apply_term q mu) : map mua phi)
                (mua psi);
        } in cc_bound ys a)
    rs_ys_list;

cc_rule_constraint ::
  forall a b.
    (Eq a,
      Eq b) => ([a] -> a) ->
                 b -> [Term b a] ->
                        Term b a ->
                          Term b a ->
                            [a] ->
                              [Cond_constraint b a] ->
                                Cond_constraint b a ->
                                  [(Term b a, [a])] -> Cond_constraint b a;
cc_rule_constraint fresh f ls r q xs phi psi rs_ys_list =
  let {
    sigma = mk_subst Var (zip xs ls);
    vs = range_vars_impl (zip xs ls);
    rew = CC_rewr r (subst_apply_term q sigma);
    phi_sig = map (\ c -> cc_subst_apply fresh c (sigma, vs)) phi;
    psi_sig = cc_subst_apply fresh psi (sigma, vs);
    ihs = cc_ih_prems fresh f q xs phi psi rs_ys_list;
  } in CC_impl (rew : phi_sig ++ ihs) psi_sig;

cc_unbound :: forall a b. Cond_constraint a b -> ([b], Cond_constraint a b);
cc_unbound (CC_all x c) = let {
                            (xs, a) = cc_unbound c;
                          } in (x : xs, a);
cc_unbound (CC_cond v va) = ([], CC_cond v va);
cc_unbound (CC_rewr v va) = ([], CC_rewr v va);
cc_unbound (CC_impl v va) = ([], CC_impl v va);

funas_args_term_lista :: forall a b. Term a b -> [(a, Nat)];
funas_args_term_lista t = concatMap funas_term_lista (args t);

funas_args_term_list :: forall a b. (Eq a) => Term a b -> [(a, Nat)];
funas_args_term_list = remdups . funas_args_term_lista;

check_rys ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> Bool) ->
                    Maybe (a, Nat) ->
                      Term a b ->
                        (Term a b, [b]) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rys d rt r rys =
  let {
    (ra, ys) = rys;
  } in bindb (check (root ra == rt)
               (shows_string ['r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
                 shows_prec_term Zero_nat ra .
                   shows_string [' ', 'i', 's', ' ', 'n', 'o', 't', ' '] .
                     shows_prec_prod Zero_nat (the rt)))
         (\ _ ->
           bindb (check (equal_term r ra || supt_impl r ra)
                   (shows_prec_term Zero_nat ra .
                     shows_string
                       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's',
                         'u', 'b', 't', 'e', 'r', 'm', ' ', 'o', 'f', ' '] .
                       shows_prec_term Zero_nat r))
             (\ _ ->
               bindb (catcha
                       (forallM
                         (\ f ->
                           check (not (d f))
                             (shows_string
                                ['t', 'h', 'e', ' ', 'd', 'e', 'f', 'i', 'n',
                                  'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l',
                                  ' '] .
                               shows_prec_prod Zero_nat f .
                                 shows_string
                                   [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 'i',
                                     'n', ' ', 't', 'h', 'e', ' ', 's', 'u',
                                     'b', 't', 'e', 'r', 'm', ' '] .
                                   shows_prec_term Zero_nat ra .
                                     shows_prec_list Zero_nat
                                       [' ', 'o', 'f', ' ', 't', 'h', 'e', ' ',
 'r', 'h', 's']))
                         (funas_args_term_list ra))
                       (\ x -> Inl (snd x)))
                 (\ _ ->
                   catcha (check_disjoint ys (vars_term_list r))
                     (\ x ->
                       Inl (shows_prec Zero_nat x .
                             shows_string
                               [' ', 'o', 'c', 'c', 'u', 'r', 's', ' ', 'i',
                                 'n', ' '] .
                               shows_prec_term Zero_nat r)))));

shows_cc_aux ::
  forall a b.
    (Showa a,
      Showa b) => Bool ->
                    Cond_constraint a b -> [Prelude.Char] -> [Prelude.Char];
shows_cc_aux b (CC_rewr s t) =
  shows_prec_term Zero_nat s .
    shows_prec_list Zero_nat [' ', '=', ' '] . shows_prec_term Zero_nat t;
shows_cc_aux b (CC_cond stri (s, t)) =
  shows_prec_term Zero_nat s .
    shows_prec_list Zero_nat
      (if stri then [' ', '>', ' '] else [' ', '>', '=', ' ']) .
      shows_prec_term Zero_nat t;
shows_cc_aux b (CC_all x c) =
  let {
    s = shows_prec_list Zero_nat ['A', 'L', 'L', ' '] .
          shows_prec Zero_nat x .
            shows_prec_list Zero_nat ['.', ' '] . shows_cc_aux False c;
  } in (if b then shows_prec_list Zero_nat ['('] .
                    s . shows_prec_list Zero_nat [')']
         else s);
shows_cc_aux b (CC_impl cs c2) =
  shows_string ['('] .
    shows_list_gen (shows_cc_aux True) ['T', 'r', 'u', 'e'] []
      [' ', 'a', 'n', 'd', ' '] [] cs .
      shows_prec_list Zero_nat [' ', '=', '>', ' '] .
        shows_cc_aux True c2 . shows_prec_list Zero_nat [')'];

shows_cc ::
  forall a b.
    (Showa a,
      Showa b) => Cond_constraint a b -> [Prelude.Char] -> [Prelude.Char];
shows_cc = shows_cc_aux False;

prems_of :: forall a b. Cond_constraint a b -> [Cond_constraint a b];
prems_of (CC_impl c1 c2) = c1;
prems_of (CC_cond v va) = [];
prems_of (CC_rewr v va) = [];
prems_of (CC_all v va) = [];

concl_of :: forall a b. Cond_constraint a b -> Cond_constraint a b;
concl_of (CC_impl c1 c2) = c2;
concl_of (CC_cond v va) = CC_cond v va;
concl_of (CC_rewr v va) = CC_rewr v va;
concl_of (CC_all v va) = CC_all v va;

normalize_cc :: forall a b. Cond_constraint a b -> Cond_constraint a b;
normalize_cc c = CC_impl (prems_of c) (concl_of c);

funas_term_list :: forall a b. (Eq a) => Term a b -> [(a, Nat)];
funas_term_list = remdups . funas_term_lista;

check_cc_prf ::
  forall a.
    (Ceq a, Corder a, Eq a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ((a, Nat) -> Bool) ->
                      [(a, Nat)] ->
                        Bool ->
                          Cond_constraint a [Prelude.Char] ->
                            Cond_constraint_prf a [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char])
                                [C_constraint a [Prelude.Char]];
check_cc_prf r d f m_ortho cc Final =
  (case normalize_cc cc of {
    CC_cond _ _ ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_rewr _ _ ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_cond stri st) -> Inr [Unconditional_C stri st];
    CC_impl [] (CC_rewr _ _) ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_impl _ _) ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [] (CC_all _ _) ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond stri uv] (CC_cond stria st) ->
      (if stri == stria then Inr [Conditional_C stri uv st]
        else Inl (shows_prec_list Zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f',
                      'i', 'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r',
                      'a', 'i', 'n', 't', ':', ' ', 'd', 'i', 'f', 'f', 'e',
                      'r', 'e', 'n', 't', ' ', 'r', 'e', 'l', 'a', 't', 'i',
                      'o', 'n', 's', ' ', 'f', 'o', 'r', ' ', 'f', 'i', 'n',
                      'a', 'l', 'i', 'z', 'i', 'n', 'g', ' '] .
                   shows_cc cc));
    CC_impl [CC_cond stri uv] (CC_rewr _ _) ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond stri uv] (CC_impl _ _) ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl [CC_cond stri uv] (CC_all _ _) ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_cond stri uv : _ : _) cond_constraint ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_rewr _ _ : lista) cond_constraint ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_impl _ _ : lista) cond_constraint ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_impl (CC_all _ _ : lista) cond_constraint ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
    CC_all _ _ ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i',
               'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
               't', ':', ' ', 'i', 't', ' ', 'i', 's', ' ', 'n', 'e', 'i', 't',
               'h', 'e', 'r', ' ', 'a', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
               'o', 'n', ' ', 'n', 'o', 'r', ' ', 'a', 'n', ' ', 'i', 'm', 'p',
               'l', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
               ' ', 't', 'w', 'o', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ',', ' ', 'b', 'u', 't', ' ', 'i', 't', ' ', 'i', 's',
               ' '] .
            shows_nl . shows_cc cc);
  });
check_cc_prf r da f m_ortho c (Delete_Condition d prf) =
  bindb (check (check_subsumes (fresh_string ['x', 'x']) d c)
          (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'd', 'e',
               'l', 'e', 't', 'e', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o',
               'n', 's', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'w', 'i', 't', 'c',
               'h', 'i', 'n', 'g', ' ', 'f', 'r', 'o', 'm', ' '] .
            shows_nl .
              shows_cc c .
                shows_string [' ', 't', 'o', ' '] . shows_nl . shows_cc d))
    (\ _ -> check_cc_prf r da f m_ortho d prf);
check_cc_prf r da f m_ortho c (Different_Constructor d) =
  let {
    (CC_impl cs _) = normalize_cc c;
  } in catcha
         (bindb
           (check (membera cs d)
             (shows_cc d .
               shows_nl .
                 shows_string
                   ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r', 'e',
                     'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                   shows_cc c))
           (\ _ ->
             (case d of {
               CC_cond _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list Zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_rewr (Var _) term2 ->
                 Inl (shows_cc d .
                       shows_prec_list Zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_rewr (Fun fa ss) (Var _) ->
                 Inl (shows_cc d .
                       shows_prec_list Zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_rewr (Fun fa ss) (Fun g ts) ->
                 bindb (check (not (da (fa, size_list ss)))
                         (shows_prec Zero_nat fa .
                           shows_prec_list Zero_nat
                             [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e',
                               'd']))
                   (\ _ ->
                     bindb (check
                             (not ((fa, size_list ss) == (g, size_list ts)))
                             (shows_string
                                ['t', 'h', 'e', ' ', 'r', 'o', 'o', 't', ' '] .
                               shows_prec Zero_nat fa .
                                 shows_prec_list Zero_nat
                                   [' ', 'i', 's', ' ', 'i', 'd', 'e', 'n', 't',
                                     'i', 'c', 'a', 'l', ' ', 'o', 'n', ' ',
                                     'b', 'o', 't', 'h', ' ', 's', 'i', 'd',
                                     'e', 's']))
                       (\ _ -> Inr []));
               CC_impl _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list Zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
               CC_all _ _ ->
                 Inl (shows_cc d .
                       shows_prec_list Zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                           'd', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                           't', 'h', 'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                           't', ' ', 's', 'h', 'a', 'p', 'e']);
             })))
         (\ x ->
           Inl (shows_string
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'D',
                    'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', ' ', 'C', 'o', 'n',
                    's', 't', 'r', 'u', 'c', 't', 'o', 'r', ' ', 'w', 'i', 't',
                    'h', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o',
                    'n', 'd', 'i', 't', 'i', 'o', 'n', ' '] .
                 shows_cc d .
                   shows_nl .
                     shows_string
                       ['o', 'n', ' ', 'i', 'n', 'p', 'u', 't', ' ', 'c', 'o',
                         'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' '] .
                       shows_nl . shows_cc c . shows_nl . x));
check_cc_prf r da f m_ortho ca (Same_Constructor d c p) =
  let {
    (CC_impl cs con) = normalize_cc ca;
  } in bindb (catcha
               (bindb
                 (check (membera cs d)
                   (shows_cc d .
                     shows_nl .
                       shows_string
                         ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r',
                           'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_cc ca))
                 (\ _ ->
                   (case d of {
                     CC_cond _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list Zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_rewr (Var _) term2 ->
                       Inl (shows_cc d .
                             shows_prec_list Zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_rewr (Fun fa ss) (Var _) ->
                       Inl (shows_cc d .
                             shows_prec_list Zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_rewr (Fun fa ss) (Fun g ts) ->
                       bindb (check (not (da (fa, size_list ss)))
                               (shows_prec Zero_nat fa .
                                 shows_prec_list Zero_nat
                                   [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n',
                                     'e', 'd']))
                         (\ _ ->
                           bindb (check
                                   ((fa, size_list ss) == (g, size_list ts))
                                   (shows_prec Zero_nat fa .
                                     shows_string [' ', 'a', 'n', 'd', ' '] .
                                       shows_prec Zero_nat g .
 shows_prec_list Zero_nat
   [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i',
     'c', 'a', 'l']))
                             (\ _ ->
                               let {
                                 ds = cs ++
map (\ (a, b) -> CC_rewr a b) (zip ss ts);
                                 db = CC_impl ds con;
                               } in check (check_subsumes
    (fresh_string ['x', 'x']) c db)
                                      (shows_string
 ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ',
   'i', 's', ' '] .
shows_cc c .
  shows_nl .
    shows_string
      ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'w',
        'a', 's', ' '] .
      shows_cc db)));
                     CC_impl _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list Zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                     CC_all _ _ ->
                       Inl (shows_cc d .
                             shows_prec_list Zero_nat
                               [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                 ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ',
                                 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                                 ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'c',
                                 'o', 'r', 'r', 'e', 'c', 't', ' ', 's', 'h',
                                 'a', 'p', 'e']);
                   })))
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'S', 'a', 'm', 'e', ' ', 'C', 'o', 'n', 's', 't', 'r',
                          'u', 'c', 't', 'o', 'r', ' ', 'w', 'i', 't', 'h', ' ',
                          'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n',
                          'd', 'i', 't', 'i', 'o', 'n', ' '] .
                       shows_cc d .
                         shows_nl .
                           shows_string
                             [' ', 'w', 'h', 'e', 'n', ' ', 's', 'w', 'i', 't',
                               'c', 'h', 'i', 'n', 'g', ' ', 'f', 'r', 'o', 'm',
                               ' '] .
                             shows_nl .
                               shows_cc ca .
                                 shows_string [' ', 't', 'o', ' '] .
                                   shows_nl . shows_cc c . shows_nl . x)))
         (\ _ -> check_cc_prf r da f m_ortho c p);
check_cc_prf r da f m_ortho c (Variable_Equation x t d p) =
  let {
    (CC_impl cs _) = normalize_cc c;
  } in bindb (catcha
               (bindb
                 (check
                   (membera cs (CC_rewr (Var x) t) ||
                     membera cs (CC_rewr t (Var x)) &&
                       ball (funas_term t) (\ fa -> not (da fa)))
                   (shows_string
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                        'i', 'n', 'd', ' '] .
                     shows_cc (CC_rewr (Var x) t) .
                       shows_string
                         [' ', 'o', 'r', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'e',
                           'd', ' ', 'a', 's', ' ', 'a', ' ', 'p', 'r', 'e',
                           'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_nl . shows_cc c))
                 (\ _ ->
                   let {
                     ca = cc_subst_apply (fresh_string ['x', 'x']) c
                            (fun_upd Var x t, vars_term_list t);
                   } in check (check_subsumes (fresh_string ['x', 'x']) d ca)
                          (shows_string
                             ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r',
                               'a', 'i', 'n', 't', ' ', 'i', 's', ' '] .
                            shows_cc d .
                              shows_nl .
                                shows_string
                                  ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c',
                                    't', 'e', 'd', ' ', 'w', 'a', 's', ' '] .
                                  shows_cc ca)))
               (\ xa ->
                 Inl (shows_prec_list Zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'V', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'E', 'q',
                          'u', 'a', 't', 'i', 'o', 'n', ' ', 'w', 'i', 't', 'h',
                          ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i',
                          'o', 'n', ' '] .
                       shows_prec_list Zero_nat x .
                         shows_prec_list Zero_nat ['/'] .
                           shows_prec_term Zero_nat t .
                             shows_string
                               [' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c',
                                 'h', ' ', 'f', 'r', 'o', 'm'] .
                               shows_nl .
                                 shows_cc c .
                                   shows_nl .
                                     shows_string ['t', 'o'] .
                                       shows_nl . shows_cc d . shows_nl . xa)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho ca (Funarg_Into_Var c i x d p) =
  let {
    (CC_impl cs con) = normalize_cc ca;
  } in bindb (catcha
               (bindb
                 (check (membera cs c)
                   (shows_cc c .
                     shows_nl .
                       shows_string
                         ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r',
                           'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_cc ca))
                 (\ _ ->
                   bindb (check (not (membera (vars_cc_list ca) x))
                           (shows_string
                              ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                             shows_prec_list Zero_nat x .
                               shows_prec_list Zero_nat
                                 [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f',
                                   'r', 'e', 's', 'h']))
                     (\ _ ->
                       (case c of {
                         CC_cond _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list Zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Var _) q ->
                           Inl (shows_cc c .
                                 shows_prec_list Zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Fun fa ss) q ->
                           bindb (check (less_nat i (size_list ss))
                                   (shows_prec_list Zero_nat
                                     ['i', 'n', 'v', 'a', 'l', 'i', 'd', ' ',
                                       'p', 'o', 's', 'i', 't', 'i', 'o', 'n']))
                             (\ _ ->
                               let {
                                 (bef, (pa, aft)) =
                                   (take i ss,
                                     (nth ss i,
                                       drop (plus_nat i (Nat_of_num One)) ss));
                               } in bindb (catcha
    (check_subseteq (funas_term_list pa) f)
    (\ xa ->
      Inl (shows_string
             ['f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 's', 'y', 'm', 'b',
               'o', 'l', ' '] .
            shows_prec_prod Zero_nat xa .
              shows_prec_list Zero_nat
                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
                  'w', 'e', 'd', ' ', 'i', 'n', ' ', 'a', 'r', 'g', 'u', 'm',
                  'e', 'n', 't'])))
                                      (\ _ ->
let {
  px = CC_rewr pa (Var x);
  fq = CC_rewr (Fun fa (bef ++ Var x : aft)) q;
  ds = px : fq : cs;
  daa = CC_impl ds con;
} in check (check_subsumes (fresh_string ['x', 'x']) d daa)
       (shows_string
          ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't',
            ' ', 'i', 's', ' '] .
         shows_cc d .
           shows_nl .
             shows_string
               ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ',
                 'w', 'a', 's', ' '] .
               shows_cc daa)));
                         CC_impl _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list Zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_all _ _ ->
                           Inl (shows_cc c .
                                 shows_prec_list Zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                       }))))
               (\ xa ->
                 Inl (shows_prec_list Zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'i', 'n', 't', 'r', 'o', 'd', 'u', 'c', 'i', 'n', 'g',
                          ' ', 'f', 'r', 'e', 's', 'h', ' ', 'v', 'a', 'r', 'i',
                          'a', 'b', 'l', 'e', ' '] .
                       shows_prec_list Zero_nat x .
                         shows_string [' ', 'o', 'n', ' '] .
                           shows_prec_nat Zero_nat
                             (plus_nat i (Nat_of_num One)) .
                             shows_string
                               ['-', 't', 'h', ' ', 'a', 'r', 'g', 'u', 'm',
                                 'e', 'n', 't', ' ', 'o', 'f', ' ', 'l', 'h',
                                 's', ' ', 'o', 'f', ' '] .
                               shows_cc c .
                                 shows_string
                                   [' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c',
                                     'h', ' ', 'f', 'r', 'o', 'm', ' '] .
                                   shows_cc ca .
                                     shows_string ['t', 'o'] .
                                       shows_nl . shows_cc d . shows_nl . xa)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho c (Simplify_Condition bc sigma d p) =
  let {
    (CC_impl cs psi) = normalize_cc c;
  } in bindb (catcha
               (bindb
                 (check (membera cs bc)
                   (shows_cc bc .
                     shows_nl .
                       shows_string
                         ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'r',
                           'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                         shows_cc c))
                 (\ _ ->
                   let {
                     (ys, cc) = cc_unbound bc;
                     (phi, psia) =
                       let {
                         (CC_impl a b) = normalize_cc cc;
                       } in (a, b);
                     dom_ran = mk_subst_domain sigma;
                   } in bindb (catcha (check_subseteq (map fst dom_ran) ys)
                                (\ x ->
                                  Inl (shows_prec_list Zero_nat x .
shows_prec_list Zero_nat
  [' ', 'i', 's', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'd', 'o', 'm', 'a',
    'i', 'n', ' ', 'o', 'f', ' ', 's', 'i', 'g', 'm', 'a', ',', ' ', 'b', 'u',
    't', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'b', 'o', 'u', 'n', 'd', ' ', 'v',
    'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '])))
                          (\ _ ->
                            bindb (catcha
                                    (forallM
                                      (\ fn ->
bindb (check (not (da fn))
        (shows_string ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
          shows_prec_prod Zero_nat fn .
            shows_prec_list Zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                'e', 'd', ' ', 'i', 'n', ' ', 'r', 'a', 'n', 'g', 'e', ' ', 'o',
                'f', ' ', 's', 'i', 'g', 'm', 'a', ',', ' ', 'a', 's', ' ', 'i',
                't', ' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd']))
  (\ _ ->
    check (membera f fn)
      (shows_string ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
        shows_prec_prod Zero_nat fn .
          shows_prec_list Zero_nat
            [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
              'e', 'd', ' ', 'i', 'n', ' ', 'r', 'a', 'n', 'g', 'e', ' ', 'o',
              'f', ' ', 's', 'i', 'g', 'm', 'a', ',', ' ', 'a', 's', ' ', 'i',
              't', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ',
              'F'])))
                                      (concatMap
(\ x_t -> funas_term_list (snd x_t)) dom_ran))
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                let {
                                  vs = remdups
 (concatMap (\ x_t -> vars_term_list (snd x_t)) dom_ran);
                                  sigmaa =
                                    (\ ca ->
                                      cc_subst_apply (fresh_string ['x', 'x'])
ca (mk_subst Var sigma, vs));
                                } in bindb (catcha
     (forallM
       (\ ca ->
         check (any (\ caa ->
                      check_subsumes (fresh_string ['x', 'x']) caa (sigmaa ca))
                 cs)
           (shows_cc (sigmaa ca) .
             shows_nl .
               shows_prec_list Zero_nat
                 ['i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'n', 't', 'a',
                   'i', 'n', 'e', 'd', ' ', 'a', 's', ' ', 'p', 'r', 'e', 'm',
                   'i', 's', 'e', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'i',
                   'n', 'p', 'u', 't', ' ', 'i', 'm', 'p', 'l', 'i', 'c', 'a',
                   't', 'i', 'o', 'n']))
       phi)
     (\ x -> Inl (snd x)))
                                       (\ _ ->
 let {
   daa = CC_impl (sigmaa psia : cs) psi;
 } in check (check_subsumes (fresh_string ['x', 'x']) d daa)
        (shows_string
           ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n',
             't', ' ', 'i', 's', ' '] .
          shows_cc d .
            shows_nl .
              shows_string
                ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',
                  ' ', 'w', 'a', 's', ' '] .
                shows_cc daa))))))
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'S', 'i', 'm', 'p', 'l', 'i', 'f', 'y', ' ', 'C', 'o',
                          'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'w', 'i', 't',
                          'h', ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't',
                          'i', 'o', 'n', ' '] .
                       shows_prec_list Zero_nat sigma .
                         shows_string [' ', 'o', 'n', ' ', 'I', 'H'] .
                           shows_nl .
                             shows_cc bc .
                               shows_nl .
                                 shows_string
                                   ['t', 'o', ' ', 's', 'w', 'i', 't', 'c', 'h',
                                     ' ', 'f', 'r', 'o', 'm'] .
                                   shows_nl .
                                     shows_cc c .
                                       shows_nl .
 shows_string ['t', 'o'] . shows_nl . shows_cc d . shows_nl . x)))
         (\ _ -> check_cc_prf r da f m_ortho d p);
check_cc_prf r da f m_ortho c (Induction d ccs ihs) =
  let {
    (CC_impl cs ca) = normalize_cc c;
  } in bindb (catcha
               (bindb
                 (check m_ortho
                   (shows_prec_list Zero_nat
                     ['C', 'R', ' ', 'o', 'r', ' ', 'm', 'i', 'n', 'i', 'm',
                       'a', 'l', 'i', 't', 'y', ' ', 'r', 'e', 'q', 'u', 'i',
                       'r', 'e', 'd']))
                 (\ _ ->
                   bindb (catcha
                           (forallM
                             (\ cc ->
                               check (membera cs cc)
                                 (shows_cc cc .
                                   shows_nl .
                                     shows_string
                                       ['i', 's', ' ', 'n', 'o', 't', ' ', 'a',
 ' ', 'p', 'r', 'e', 'm', 'i', 's', 'e', ' ', 'o', 'f', ' '] .
                                       shows_cc c))
                             (d : ccs))
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       (case d of {
                         CC_cond _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list Zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Var _) q ->
                           Inl (shows_cc d .
                                 shows_prec_list Zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_rewr (Fun fa xs) q ->
                           let {
                             csa = vars_cc_list
                                     (CC_impl (CC_rewr (Fun fa xs) q : ccs) ca);
                           } in bindb (check
(all is_Var xs && distinct (map the_Var xs))
(shows_prec_list Zero_nat
   ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ' ', 'o', 'f', ' '] .
  shows_prec_term Zero_nat (Fun fa xs) .
    shows_prec_list Zero_nat
      [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'i', 'f', 'f', 'e',
        'r', 'e', 'n', 't', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
                                  (\ _ ->
                                    let {
                                      xsa = map the_Var xs;
                                      rt = root (Fun fa xs);
                                    } in bindb
   (check (is_none (mgu (Fun fa xs) q))
     (shows_prec_list Zero_nat
       ['l', 'h', 's', ' ', 'a', 'n', 'd', ' ', 'r', 'h', 's', ' ', 'u', 'n',
         'i', 'f', 'y']))
   (\ _ ->
     bindb (catcha
             (forallM
               (\ lr ->
                 check (if root (fst lr) == rt
                         then any (\ lra ->
                                    eq_rule_mod_vars lr lra &&
                                      isOK
(check_disjoint csa (vars_rule_list lra)))
                                (map (\ (ra, _) -> ra) ihs)
                         else True)
                   (shows_prec_list Zero_nat
                      ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                        'i', 'n', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
                        'e', ' ', 'r', 'e', 'n', 'a', 'm', 'e', 'd', ' ', 'v',
                        'e', 'r', 's', 'i', 'o', 'n', ' ', 'o', 'f', ' ', 'r',
                        'u', 'l', 'e', ' '] .
                     shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                       [' ', '-', '>', ' '] lr))
               r)
             (\ x -> Inl (snd x)))
       (\ _ ->
         catcha
           (forallM
             (\ (a, b) ->
               let {
                 (l, ra) = a;
               } in (\ (rys, (cc, _)) ->
                      catcha
                        (let {
                           cca = cc_rule_constraint (fresh_string ['x', 'x']) fa
                                   (args l) ra q xsa ccs ca rys;
                         } in bindb (catcha (forallM (check_rys da rt ra) rys)
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  check (check_subsumes
  (fresh_string ['x', 'x']) cc cca)
                                    (shows_string
                                       ['n', 'e', 'w', ' ', 'c', 'o', 'n', 's',
 't', 'r', 'a', 'i', 'n', 't', ' ', 'i', 's', ' '] .
                                      shows_cc cc .
shows_nl .
  shows_string
    ['b', 'u', 't', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', 'w', 'a',
      's', ' '] .
    shows_cc cca)))
                        (\ x ->
                          Inl (shows_string
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                   'n', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a',
                                   'i', 'n', 't', ' ', 'f', 'o', 'r', ' ', 'r',
                                   'u', 'l', 'e', ' '] .
                                shows_rule (shows_prec Zero_nat)
                                  (shows_prec_list Zero_nat)
                                  [' ', '-', '>', ' '] (l, ra) .
                                  shows_nl . x)))
                 b)
             ihs)
           (\ x -> Inl (snd x)))));
                         CC_impl _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list Zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                         CC_all _ _ ->
                           Inl (shows_cc d .
                                 shows_prec_list Zero_nat
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                     ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                                     ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i',
                                     'o', 'n', ' ', 'o', 'f', ' ', 't', 'h',
                                     'e', ' ', 'c', 'o', 'r', 'r', 'e', 'c',
                                     't', ' ', 's', 'h', 'a', 'p', 'e']);
                       }))))
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                          'I', 'n', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'r',
                          'u', 'l', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'r', 'e',
                          'w', 'r', 'i', 't', 'e', ' ', 'c', 'o', 'n', 'd', 'i',
                          't', 'i', 'o', 'n', ' '] .
                       shows_cc d .
                         shows_string
                           [' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c', 'h',
                             ' ', 'f', 'r', 'o', 'm'] .
                           shows_nl .
                             shows_cc c .
                               shows_nl .
                                 shows_string ['t', 'o'] .
                                   shows_nl .
                                     shows_list_gen
                                       (\ (_, (_, (cb, _))) ->
 shows_cc cb . shows_nl)
                                       [] [] [] [] ihs .
                                       x)))
         (\ _ ->
           bindb (mapM (\ (_, (_, (a, b))) -> check_cc_prf r da f m_ortho a b)
                   ihs)
             (\ fcss -> Inr (concat fcss)));

check_cc_prfs ::
  forall a b.
    (Ceq a, Corder a, Eq a, Set_impl a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    ((a, Nat) -> Bool) ->
                      [(a, Nat)] ->
                        Bool ->
                          [(Cond_constraint a [Prelude.Char],
                             (b, Cond_constraint_prf a [Prelude.Char]))] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              [C_constraint a [Prelude.Char]];
check_cc_prfs r d f m_ortho [] = Inr [];
check_cc_prfs r d f m_ortho ((c, (uu, prf)) : cpfs) =
  bindb (check_cc_prf r d f m_ortho c prf)
    (\ l1 -> bindb (check_cc_prfs r d f m_ortho cpfs) (\ l2 -> Inr (l1 ++ l2)));

funas_args_rule_list :: forall a b. (Term a b, Term a b) -> [(a, Nat)];
funas_args_rule_list r =
  funas_args_term_lista (fst r) ++ funas_args_term_lista (snd r);

funas_args_trs_list ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)];
funas_args_trs_list r = remdups (concatMap funas_args_rule_list r);

conditional_general_reduction_pair_proc ::
  forall a b.
    (Ceq b, Corder b, Eq b, Key b, Set_impl b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    ([(b, Nat)] -> Non_inf_order_ext b [Prelude.Char] ()) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          Cond_red_pair_prf b [Prelude.Char] ->
                            Bool ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) [a];
conditional_general_reduction_pair_proc i grp pstrict pbound prof merge dpp =
  let {
    (Cond_Red_Pair_Prf c ccs bef aft) = prof;
    p = pairsa i dpp;
    r = rulesd i dpp;
    f = remdups
          (funas_trs_list r ++
            funas_args_trs_list p ++ concatMap funas_term_list (qc i dpp));
    rp = grp f;
  } in (case catcha
               (bindb (validb rp)
                 (\ _ ->
                   bindb (check (wwf_rulesa i dpp)
                           (shows_prec_list Zero_nat
                             ['r', 'e', 'q', 'u', 'i', 'r', 'e', ' ', 'w', 'e',
                               'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd', 'n',
                               'e', 's', 's', ' ', 'o', 'f', ' ', 'T', 'R',
                               'S']))
                     (\ _ ->
                       let {
                         is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
                       } in bindb (check_varcond_subset p)
                              (\ _ ->
                                bindb (catcha
(forallM
  (\ (l, ra) ->
    bindb (check_no_var l)
      (\ _ -> bindb (check_no_var ra) (\ _ -> check_no_defined_root is_def ra)))
  p)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    let {
                                      ccsa =
map (\ (ca, (uvs, _)) -> (ca, uvs)) ccs;
                                      check_present =
check_constraint_present i dpp c p bef aft ccsa;
                                      (ps, pns) = split_pairsa i dpp pstrict;
                                      (pb, _) = split_pairsa i dpp pbound;
                                      pi = afb rp;
                                      us = usable_rules_gen pi r p;
                                    } in bindb
   (catcha (forallM (check_present Strict) ps) (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (catcha (forallM (check_present Non_Strict) pns)
             (\ x -> Inl (snd x)))
       (\ _ ->
         bindb (catcha (forallM (check_present Bound) pb) (\ x -> Inl (snd x)))
           (\ _ ->
             bindb (check (nFQ_subset_NF_rulesb i dpp)
                     (shows_prec_list Zero_nat
                       ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r',
                         'e', 'q', 'u', 'i', 'r', 'e', 'd']))
               (\ _ ->
                 bindb (catcha
                         (catcha (forallM (nsb rp) us) (\ x -> Inl (snd x)))
                         (\ x ->
                           Inl (shows_string
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                    'h', 'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n',
                                    't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b',
                                    'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
                                 shows_nl . x)))
                   (\ _ ->
                     let {
                       m = minimal i dpp;
                       ortho = isOK (check_weakly_orthogonal r);
                     } in bindb (catcha
                                  (check_cc_prfs r
                                    (\ fn -> not (null (rules_mapb i dpp fn))) f
                                    (m || ortho) ccs)
                                  (\ x ->
                                    Inl (shows_string
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'i',
     'm', 'p', 'l', 'i', 'f', 'y', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 'd', 'i',
     't', 'i', 'o', 'n', 'a', 'l', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i',
     'n', 't', 's'] .
  shows_nl . x)))
                            (\ fcs ->
                              catcha
                                (catcha (forallM (cc rp) fcs)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'f', 'i', 'n', 'a', 'l', ' ', '(',
   'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', ')', ' ', 'c', 'o',
   'n', 's', 't', 'r', 'a', 'i', 'n', 't', 's', ' ', 'f', 'o', 'r', ' ', 'p',
   'a', 'i', 'r', 's'] .
shows_nl . x)))))))))))))
               (\ x ->
                 Inl (shows_string
                        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a',
                          'p', 'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'b', 'o',
                          'u', 'n', 'd', 'e', 'd', ' ', 'i', 'n', 'c', 'r', 'e',
                          'a', 's', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                          'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'e',
                          ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g'] .
                       shows_nl . descc rp . shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (if merge
                 then [delete_P_Pwa i dpp (list_inter pstrict pbound)
                         (list_inter pstrict pbound)]
                 else [delete_P_Pwa i dpp pstrict pstrict,
                        delete_P_Pwa i dpp pbound pbound]);
       });

critical_pairs_top_impl ::
  forall a.
    (Eq a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])];
critical_pairs_top_impl p r =
  concatMap
    (\ (l, ra) ->
      (if is_Var l then []
        else concatMap
               (\ (la, rb) ->
                 (case mgu_var_disjoint_generic (\ a -> 'x' : a)
                         (\ a -> 'y' : a) l la
                   of {
                   Nothing -> [];
                   Just (sigma, tau) ->
                     [(subst_apply_term ra sigma, subst_apply_term rb tau)];
                 }))
               r))
    p;

show_crit_pair ::
  forall a b.
    (Showa a,
      Showa b) => (Term a b, Term a b) -> [Prelude.Char] -> [Prelude.Char];
show_crit_pair lr =
  shows_prec_list Zero_nat ['('] .
    shows_prec_term Zero_nat (fst lr) .
      shows_prec_list Zero_nat [',', ' '] .
        shows_prec_term Zero_nat (snd lr) . shows_prec_list Zero_nat [')'];

check_critical_pairs_innermost ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_innermost r =
  catcha
    (forallM
      (\ (l, ra) ->
        check (equal_term l ra)
          (shows_prec_list Zero_nat
             ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', ' ', 'n', 'o',
               'n', '-', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ', 'c', 'r', 'i',
               't', 'i', 'c', 'a', 'l', ' ', 'p', 'a', 'i', 'r', ' '] .
            show_crit_pair (l, ra)))
      (critical_pairs_top_impl r r))
    (\ x -> Inl (snd x));

extract_fresh_var ::
  forall a b.
    [((Term a b, Term a b), (Term a b, Term a b))] ->
      Sum ([Prelude.Char] -> [Prelude.Char]) b;
extract_fresh_var sts =
  (case (case sts of {
          [] -> Nothing;
          (_, (Var _, _)) : _ -> Nothing;
          (_, (Fun _ ss, _)) : _ ->
            (if null ss then Nothing
              else (case last ss of {
                     Var a -> Just a;
                     Fun _ _ -> Nothing;
                   }));
        })
    of {
    Nothing ->
      Inl (shows_prec_list Zero_nat
            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x', 't',
              'r', 'a', 'c', 't', ' ', 'f', 'r', 'e', 's', 'h', ' ', 'v', 'a',
              'r', 'i', 'a', 'b', 'l', 'e', ' ', '(', 'a', 's', ' ', 'l', 'a',
              's', 't', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f',
              'r', 'o', 'm', ' ', 's', 'o', 'm', 'e', ' ', 'l', 'h', 's', ' ',
              'o', 'f', ' ', 'n', 'e', 'w', ' ', 'p', 'a', 'i', 'r', 's', ')']);
    Just a -> Inr a;
  });

extract_ren ::
  forall a b.
    (Eq a) => [((Term a b, Term a b), (Term a b, Term a b))] ->
                Sum ([Prelude.Char] -> [Prelude.Char]) ((a, Nat) -> a);
extract_ren ps_ps =
  bindb (check
          (all (\ (a, b) ->
                 let {
                   (s, t) = a;
                 } in (\ (sa, ta) ->
                        not (is_Var s) &&
                          not (is_Var t) && not (is_Var sa) && not (is_Var ta))
                   b)
            ps_ps)
          (shows_prec_list Zero_nat
            ['a', 'l', 'l', ' ', 'l', 'h', 's', 's', ' ', 'a', 'n', 'd', ' ',
              'r', 'h', 's', 's', ' ', 'o', 'f', ' ', 'p', 'a', 'i', 'r', 's',
              ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n', '-',
              'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
    (\ _ ->
      let {
        rt = (\ t -> the (root t));
        pair = (\ s sa -> (rt s, fst (rt sa)));
        pairs =
          (\ (st, sta) -> [pair (fst st) (fst sta), pair (snd st) (snd sta)]);
        ren = map_of (remdups (concatMap pairs ps_ps));
        a = (\ fn -> (case ren fn of {
                       Nothing -> fst fn;
                       Just f -> f;
                     }));
      } in Inr a);

check_drop ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> Term b a ->
                         ((b, Nat) -> b) ->
                           ((Term b a, Term b a), (Term b a, Term b a)) ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_drop x c ren st_st =
  let {
    ((s, t), (sa, ta)) = st_st;
    (Fun f ss) = s;
    (Fun g ts) = t;
  } in bindb (check
               (equal_term sa (Fun (ren (f, size_list ss)) (ss ++ [Var x])))
               (shows_prec_list Zero_nat
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'r', 'e',
                    'l', 'a', 't', 'e', ' '] .
                 shows_prec_term Zero_nat s .
                   shows_prec_list Zero_nat [' ', 'w', 'i', 't', 'h', ' '] .
                     shows_prec_term Zero_nat sa))
         (\ _ ->
           let {
             tsa = args ta;
             tsaa = take (minus_nat (size_list tsa) (Nat_of_num One)) tsa;
           } in check (equal_term ta
                         (Fun (ren (g, size_list ts)) (tsaa ++ [Var x])) &&
                        ts == map (\ tb -> subst_apply_term tb (subst x c))
                                tsaa)
                  (shows_prec_list Zero_nat
                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'r',
                       'e', 'l', 'a', 't', 'e', ' '] .
                    shows_prec_term Zero_nat t .
                      shows_prec_list Zero_nat [' ', 'w', 'i', 't', 'h', ' '] .
                        shows_prec_term Zero_nat ta));

rwc :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rwc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = rw;

pwa :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pwa (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
      rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map
      reverse_rules_map intersect_pairs replace_pair intersect_rules delete_P_Pw
      delete_R_Rw split_pairs split_rules mk minimal nfs wwf_rules more)
  = pw;

rc :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rc (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = r;

pa :: forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
pa (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
     rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
     intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
     split_pairs split_rules mk minimal nfs wwf_rules more)
  = p;

nF_terms_list ::
  forall a b c.
    (Eq a, Corder b, Eq b, Mapping_impl b,
      Eq c) => [Term a b] -> Term a c -> Bool;
nF_terms_list ls t =
  all (\ s -> all (\ l -> not (matches s l)) ls) (supteq_list t);

complex_constant_removal_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Complex_constant_removal_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
complex_constant_removal_proc i (Complex_Constant_Removal_Proof c ps) dpp =
  catcha
    (let {
       p = pa i dpp;
       pw = pwa i dpp;
       r = rwc i dpp;
       q = qc i dpp;
       pairs = pairsa i dpp;
     } in bindb (extract_fresh_var ps)
            (\ x ->
              bindb (extract_ren ps)
                (\ ren ->
                  let {
                    is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
                    rQs = remdups (map root q);
                  } in bindb (catcha
                               (forallM
                                 (\ (s, t) ->
                                   bindb (check_no_var s)
                                     (\ _ ->
                                       bindb (check_no_var t)
 (\ _ ->
   bindb (check_no_defined_root is_def t)
     (\ _ ->
       bindb (check (not (membera (vars_rule_list (s, t)) x))
               (shows_prec_list Zero_nat x .
                 shows_prec_list Zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's',
                     'h', ' ', 'f', 'o', 'r', ' ', 'p', 'a', 'i', 'r', ' '] .
                   shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                     [' ', '-', '>', ' '] (s, t)))
         (\ _ ->
           let {
             f = the (root s);
             fa = (ren f, plus_nat (snd f) (Nat_of_num One));
           } in bindb (check (not (membera rQs (Just fa)))
                        (shows_prec_list Zero_nat
                          ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', ' ', 'd',
                            'e', 'l', 'i', 'v', 'e', 'r', 's', ' ', 'd', 'e',
                            'f', 'i', 'n', 'e', 'd', ' ', 's', 'y', 'm', 'b',
                            'o', 'l', ' ', 'o', 'f', ' ', 'Q']))
                  (\ _ ->
                    check (not (is_def fa))
                      (shows_prec_list Zero_nat
                        ['r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', ' ', 'd', 'e',
                          'l', 'i', 'v', 'e', 'r', 's', ' ', 'd', 'e', 'f', 'i',
                          'n', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ',
                          'o', 'f', ' ', 'R'])))))))
                                 pairs)
                               (\ xa -> Inl (snd xa)))
                         (\ _ ->
                           let {
                             pps = filter (\ st_st -> membera p (fst st_st)) ps;
                             pwps =
                               filter (\ st_st -> membera pw (fst st_st)) ps;
                           } in bindb (catcha
(forallM
  (\ st ->
    check (membera (map fst pps) st)
      (shows_prec_list Zero_nat
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
           ' ', 'e', 'n', 't', 'r', 'y', ' ', 'f', 'o', 'r', ' ', 'p', 'a', 'i',
           'r', ' '] .
        shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
          [' ', '-', '>', ' '] st))
  p)
(\ xa -> Inl (snd xa)))
                                  (\ _ ->
                                    bindb (catcha
    (forallM
      (\ st ->
        check (membera (map fst pwps) st)
          (shows_prec_list Zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
               'd', ' ', 'e', 'n', 't', 'r', 'y', ' ', 'f', 'o', 'r', ' ', 'p',
               'a', 'i', 'r', ' '] .
            shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
              [' ', '-', '>', ' '] st))
      pw)
    (\ xa -> Inl (snd xa)))
                                      (\ _ ->
bindb (check (ground c)
        (shows_prec_list Zero_nat
           ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
          shows_prec_term Zero_nat c .
            shows_prec_list Zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'g', 'r', 'o', 'u', 'n',
                'd']))
  (\ _ ->
    bindb (check (nFQ_subset_NF_rulesb i dpp)
            (shows_prec_list Zero_nat
              ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e', 'q',
                'u', 'i', 'r', 'e', 'd']))
      (\ _ ->
        bindb (check (null (rc i dpp))
                (shows_prec_list Zero_nat
                  ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's',
                    ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
                    'd']))
          (\ _ ->
            bindb (check (rules_no_left_vara i dpp)
                    (shows_prec_list Zero_nat
                      ['r', 'u', 'l', 'e', 's', ' ', 'm', 'a', 'y', ' ', 'n',
                        'o', 't', ' ', 'h', 'a', 'v', 'e', ' ', 'v', 'a', 'r',
                        'i', 'a', 'b', 'l', 'e', 's', ' ', 'a', 's', ' ', 'l',
                        'h', 's', 's']))
              (\ _ ->
                bindb (if nF_terms_list (map fst r) c then Inr ()
                        else catcha (check_critical_pairs_innermost r)
                               (\ xa ->
                                 Inl (shows_prec_list Zero_nat
['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's', 'u', 'r', 'e',
  ' ', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e'] .
                                       shows_nl . xa)))
                  (\ _ ->
                    bindb (catcha
                            (forallM
                              (\ st_st ->
                                catcha (check_drop x c ren st_st)
                                  (\ xa ->
                                    Inl (shows_prec_list Zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'f', 'i', 'n', 'd',
     'i', 'n', 'g', ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd', 'e',
     'n', 'c', 'e', ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', 'r', 'u', 'l',
     'e', ' '] .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
    [' ', '-', '>', ' '] (fst st_st) .
    shows_prec_list Zero_nat
      [' ', 'a', 'n', 'd', ' ', 'r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
        [' ', '-', '>', ' '] (snd st_st) .
        shows_nl . xa)))
                              ps)
                            (\ xa -> Inl (snd xa)))
                      (\ _ ->
                        Inr (mkc i (nfsc i dpp) (minimal i dpp) (map snd pps)
                              (map snd pwps) q [] r)))))))))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'o',
               'm', 'p', 'l', 'e', 'x', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n',
               't', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'p', 'r', 'o',
               'c', ':', ' '] .
            shows_nl . x));

fun_of_default :: forall a b. (Eq a) => [(a, b)] -> b -> a -> b;
fun_of_default m d =
  let {
    mm = map_of m;
  } in (\ i -> (case mm i of {
                 Nothing -> d;
                 Just e -> e;
               }));

get_arg :: forall a b. Term a b -> Nat -> Term a b;
get_arg t n =
  (if equal_nat n Zero_nat then t
    else nth (args t) (minus_nat n (Nat_of_num One)));

iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops ::
  forall a b.
    (Linorder a) => Rbt a () -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s =
  (\ c f -> rm_iterateoi (impl_of s) c (f . fst));

g_ball_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> (a -> Bool) -> Bool;
g_ball_dflt_basic_oops_rm_basic_ops s p =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ c -> c)
    (\ x _ -> p x) True;

subtract_list_sorted :: forall a. (Eq a, Linorder a) => [a] -> [a] -> [a];
subtract_list_sorted (x : xs) (y : ys) =
  (if x == y then subtract_list_sorted xs (y : ys)
    else (if less x y then x : subtract_list_sorted xs (y : ys)
           else subtract_list_sorted (x : xs) ys));
subtract_list_sorted [] ys = [];
subtract_list_sorted (v : va) [] = v : va;

comp :: forall a. (Eq a, Linorder a) => [(a, a)] -> [(a, a)] -> [(a, a)];
comp esa es =
  remdups_sort
    (concatMap
      (\ (x, y) ->
        concatMap (\ (ya, z) -> (if y == ya then [(x, z)] else [])) es)
      esa);

scg_comp ::
  forall a b.
    (Eq b, Linorder b) => (a -> a -> Bool) -> Scg a b -> Scg a b -> Scg a b;
scg_comp conn (Scg pa qa stra wka) (Scg p q str wk) =
  (if not (conn qa p) then Null
    else let {
           strs = remdups_sort (comp stra str ++ comp stra wk ++ comp wka str);
           a = subtract_list_sorted (remdups_sort (comp wka wk)) strs;
         } in Scg pa q strs a);
scg_comp conn Null g = Null;
scg_comp conn (Scg v va vb vc) Null = Null;

generate_scgs ::
  forall a b.
    (Eq a, Eq b,
      Linorder b) => (a -> a -> Bool) -> [Scg a b] -> Scg a b -> [Scg a b];
generate_scgs conn base g =
  filter (\ ga -> not (equal_scg ga Null)) (map (scg_comp conn g) base);

subsumes :: forall a b. (Eq a, Eq b) => Scg a b -> Scg a b -> Bool;
subsumes (Scg pa qa stra wka) (Scg p q str wk) =
  pa == p && qa == q && all (membera str) stra && all (membera (str ++ wk)) wka;
subsumes g Null = True;
subsumes Null (Scg v va vb vc) = False;

in_situ :: forall a b. (Eq b) => Scg a b -> Bool;
in_situ Null = True;
in_situ (Scg p q str wk) = any (\ (a, b) -> a == b) str;

union_list_sorted :: forall a. (Eq a, Ord a) => [a] -> [a] -> [a];
union_list_sorted (x : xs) (y : ys) =
  (if x == y then x : union_list_sorted xs ys
    else (if less x y then x : union_list_sorted xs (y : ys)
           else y : union_list_sorted (x : xs) ys));
union_list_sorted [] ys = ys;
union_list_sorted (v : va) [] = v : va;

combinea :: forall a b. (Eq b, Linorder b) => Scg a b -> Scg a b -> Scg a b;
combinea (Scg pa qa stra wka) (Scg p q str wk) =
  Scg pa qa (union_list_sorted stra str) (union_list_sorted wka wk);
combinea Null s = Null;
combinea (Scg v va vb vc) Null = Null;

sagiv ::
  forall a b. (Eq a, Eq b, Linorder b) => (a -> a -> Bool) -> Scg a b -> Bool;
sagiv conn g =
  (if in_situ g then True
    else let {
           gg = scg_comp conn g g;
         } in (if subsumes gg g then False else sagiv conn (combinea g gg)));

check_SCT ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => (a -> a -> Bool) -> [Scg a b] -> Bool;
check_SCT conn gs =
  g_ball_dflt_basic_oops_rm_basic_ops
    (mk_rtrancl_set (generate_scgs conn gs) gs) (sagiv conn);

sct_subterm_precise_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_precise_proc i gs dpp =
  catcha
    (let {
       p = pairsa i dpp;
       is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
       eidg = is_iedg_edge_dpp i dpp;
     } in bindb (catcha (check_subseteq p (map fst gs))
                  (\ x ->
                    Inl (shows_string
                           ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n',
                             'o', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a',
                             'n', 'g', 'e', ' ', 'g', 'r', 'a', 'p', 'h', ' ',
                             'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                             'i', 'r', ' '] .
                          shows_rule (shows_prec Zero_nat)
                            (shows_prec_list Zero_nat) [' ', '-', '>', ' '] x)))
            (\ _ ->
              let {
                gGs = filter (\ g -> membera p (fst g)) gs;
              } in bindb (check (minimal i dpp || nFQ_subset_NF_rulesb i dpp)
                           (shows_prec_list Zero_nat
                             ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                               ' ', 'o', 'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                               'o', 's', 't', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                               'e', 'd']))
                     (\ _ ->
                       bindb (catcha
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulesd i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catcha
                                   (forallM
                                     (\ (a, b) ->
                                       let {
 (s, t) = a;
                                       } in
 (\ (stri, nstri) ->
   catcha
     (bindb (check_no_var s)
       (\ _ ->
         bindb (check_no_var t)
           (\ _ ->
             bindb (check_no_defined_root is_def t)
               (\ _ ->
                 let {
                   m = num_args t;
                   n = num_args s;
                 } in bindb (catcha
                              (forallM
                                (\ (ia, j) ->
                                  check (less_eq_nat ia n &&
  less_eq_nat j m && isOK (check_supt (get_arg s ia) (get_arg t j)))
                                    (shows_string
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
 'w', 'i', 't', 'h', ' ', 'e', 'd', 'g', 'e', ' '] .
                                      shows_prec_nat Zero_nat ia .
shows_string [' ', '|', '>', ' '] . shows_prec_nat Zero_nat j . shows_nl))
                                stri)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          catcha
                            (forallM
                              (\ (ia, j) ->
                                check (less_eq_nat ia n &&
less_eq_nat j m && isOK (check_supteq (get_arg s ia) (get_arg t j)))
                                  (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'e', 'd', 'g',
                                       'e', ' '] .
                                    shows_prec_nat Zero_nat ia .
                                      shows_string [' ', '|', '>', '=', ' '] .
shows_prec_nat Zero_nat j . shows_nl))
                              nstri)
                            (\ x -> Inl (snd x)))))))
     (\ x ->
       Inl (shows_string
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
                'p', 'a', 'i', 'r', ' '] .
             shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
               [' ', '-', '>', ' '] (s, t) .
               shows_nl . x)))
 b)
                                     gGs)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               let {
                                 n = size_list p;
                                 nums = upt Zero_nat n;
                                 numPs = zip p nums;
                                 num_of = fun_of_default numPs n;
                               } in check (check_SCT
    (\ (_, succs) (uv, _) -> membera succs uv)
    (map (\ (st, (stri, nstri)) ->
           let {
             eidg_st = eidg st;
             ia = num_of st;
             e = (ia, map_filter
                        (\ x ->
                          (if ((eidg_st . fst) . fst) x then Just (snd x)
                            else Nothing))
                        numPs);
           } in Scg e e (remdups_sort stri) (remdups_sort nstri))
      gGs))
                                      (shows_string
 ['s', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'a', 'n', 'a',
   'l', 'y', 's', 'i', 's', ' ', 'f', 'a', 'i', 'l', 'e', 'd'] .
shows_nl))))))
    (\ x ->
      Inl (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
               'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'i', 'z', 'e', '-', 'c',
               'h', 'a', 'n', 'g', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
               'o', 'r', ' ', 'b', 'a', 's', 'e', 'd', ' ', 'o', 'n', ' ', 't',
               'h', 'e', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', '-', 'r', 'e',
               'l', 'a', 't', 'i', 'o', 'n'] .
            shows_nl . x));

sct_subterm_approx_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_approx_proc i gs dpp =
  catcha
    (let {
       p = pairsa i dpp;
       is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
     } in bindb (catcha (check_subseteq p (map fst gs))
                  (\ x ->
                    Inl (shows_string
                           ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n',
                             'o', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a',
                             'n', 'g', 'e', ' ', 'g', 'r', 'a', 'p', 'h', ' ',
                             'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                             'i', 'r', ' '] .
                          shows_rule (shows_prec Zero_nat)
                            (shows_prec_list Zero_nat) [' ', '-', '>', ' '] x)))
            (\ _ ->
              let {
                gGs = filter (\ g -> membera p (fst g)) gs;
              } in bindb (check (minimal i dpp || nFQ_subset_NF_rulesb i dpp)
                           (shows_prec_list Zero_nat
                             ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                               ' ', 'o', 'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                               'o', 's', 't', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                               'e', 'd']))
                     (\ _ ->
                       bindb (catcha
                               (forallM (\ (l, _) -> check_no_var l)
                                 (rulesd i dpp))
                               (\ x -> Inl (snd x)))
                         (\ _ ->
                           bindb (catcha
                                   (forallM
                                     (\ (a, b) ->
                                       let {
 (s, t) = a;
                                       } in
 (\ (stri, nstri) ->
   catcha
     (bindb (check_no_var s)
       (\ _ ->
         bindb (check_no_var t)
           (\ _ ->
             bindb (check_no_defined_root is_def t)
               (\ _ ->
                 let {
                   m = num_args t;
                   n = num_args s;
                 } in bindb (catcha
                              (forallM
                                (\ (ia, j) ->
                                  check (less_eq_nat ia n &&
  less_eq_nat j m && isOK (check_supt (get_arg s ia) (get_arg t j)))
                                    (shows_string
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
 'w', 'i', 't', 'h', ' ', 'e', 'd', 'g', 'e', ' '] .
                                      shows_prec_nat Zero_nat ia .
shows_string [' ', '|', '>', ' '] . shows_prec_nat Zero_nat j . shows_nl))
                                stri)
                              (\ x -> Inl (snd x)))
                        (\ _ ->
                          catcha
                            (forallM
                              (\ (ia, j) ->
                                check (less_eq_nat ia n &&
less_eq_nat j m && isOK (check_supteq (get_arg s ia) (get_arg t j)))
                                  (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'e', 'd', 'g',
                                       'e', ' '] .
                                    shows_prec_nat Zero_nat ia .
                                      shows_string [' ', '|', '>', '=', ' '] .
shows_prec_nat Zero_nat j . shows_nl))
                              nstri)
                            (\ x -> Inl (snd x)))))))
     (\ x ->
       Inl (shows_string
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
                'p', 'a', 'i', 'r', ' '] .
             shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
               [' ', '-', '>', ' '] (s, t) .
               shows_nl . x)))
 b)
                                     gGs)
                                   (\ x -> Inl (snd x)))
                             (\ _ ->
                               check (check_SCT (\ (_, g) (h, _) -> g == h)
                                       (remdups
 (map (\ (st, (stri, nstri)) ->
        let {
          e = (the (root (fst st)), the (root (snd st)));
        } in Scg e e (remdups_sort stri) (remdups_sort nstri))
   gGs)))
                                 (shows_string
                                    ['s', 'i', 'z', 'e', '-', 'c', 'h', 'a',
                                      'n', 'g', 'e', ' ', 'a', 'n', 'a', 'l',
                                      'y', 's', 'i', 's', ' ', 'f', 'a', 'i',
                                      'l', 'e', 'd'] .
                                   shows_nl))))))
    (\ x ->
      Inl (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
               'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'i', 'z', 'e', '-', 'c',
               'h', 'a', 'n', 'g', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
               'o', 'r', ' ', 'b', 'a', 's', 'e', 'd', ' ', 'o', 'n', ' ', 't',
               'h', 'e', ' ', 's', 'u', 'b', 't', 'e', 'r', 'm', '-', 'r', 'e',
               'l', 'a', 't', 'i', 'o', 'n'] .
            shows_nl . x));

sct_subterm_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    [((Term b [Prelude.Char], Term b [Prelude.Char]),
                       ([(Nat, Nat)], [(Nat, Nat)]))] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_subterm_proc i gs dpp =
  (if isOK (sct_subterm_approx_proc i gs dpp) then Inr ()
    else sct_subterm_precise_proc i gs dpp);

sct_entry_to_sts ::
  forall a b c d. a -> Term b c -> [(d, Nat)] -> [(d, Nat)] -> [(a, Term b c)];
sct_entry_to_sts s t stri nstri =
  let {
    a = remdups (map snd (stri ++ nstri));
  } in map (\ j -> (s, get_arg t j)) a;

check_sct_entry ::
  forall a b c d e f.
    (Showa a,
      Showa b) => ((a, Nat) -> Bool) ->
                    ((Term a b, Term a b) -> Sum c d) ->
                      ((Term a b, Term a b) -> Sum e f) ->
                        Term a b ->
                          Term a b ->
                            [(Nat, Nat)] ->
                              [(Nat, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sct_entry is_def sa nst s t stri nstri =
  catcha
    (bindb (check_no_var s)
      (\ _ ->
        bindb (check_no_var t)
          (\ _ ->
            bindb (check_no_defined_root is_def t)
              (\ _ ->
                let {
                  m = num_args t;
                  n = num_args s;
                } in bindb (catcha
                             (forallM
                               (\ i ->
                                 check (less_eq_nat i n)
                                   (shows_string
                                      ['l', 'e', 'f', 't', '-', 'i', 'n', 'd',
'e', 'x', ' ', 't', 'o', ' ', 'l', 'a', 'r', 'g', 'e'] .
                                     shows_prec_nat Zero_nat i . shows_nl))
                               (remdups (map fst (stri ++ nstri))))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catcha
                                 (forallM
                                   (\ j ->
                                     check (less_eq_nat j m)
                                       (shows_string
  ['r', 'i', 'g', 'h', 't', '-', 'i', 'n', 'd', 'e', 'x', ' ', 't', 'o', ' ',
    'l', 'a', 'r', 'g', 'e', ' ', 'o', 'r', ' ', 'a', 'r', 'g', 'u', 'm', 'e',
    'n', 't', ' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 'u', 's', 'a',
    'b', 'l', 'e', '-', 'r', 'u', 'l', 'e', 's', ' ', 'c', 'o', 'n', 'd', 'i',
    't', 'i', 'o', 'n'] .
 shows_prec_nat Zero_nat j))
                                   (remdups (map snd (stri ++ nstri))))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             let {
                               _ = args s;
                               _ = args t;
                             } in bindb (catcha
  (forallM
    (\ (i, j) ->
      check (isOK (sa (get_arg s i, get_arg t j)))
        (shows_string
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
             'e', 'd', 'g', 'e', ' '] .
          shows_prec_nat Zero_nat i .
            shows_string [' ', '-', 'S', '-', '>', ' '] .
              shows_prec_nat Zero_nat j))
    stri)
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      catcha
(forallM
  (\ (i, j) ->
    check (isOK (nst (get_arg s i, get_arg t j)))
      (shows_string
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 'e',
           'd', 'g', 'e', ' '] .
        shows_prec_nat Zero_nat i .
          shows_string [' ', '-', 'N', 'S', '-', '>', ' '] .
            shows_prec_nat Zero_nat j))
  nstri)
(\ x -> Inl (snd x)))))))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', 's', ' ', 'w', 'i', 't', 'h',
               ' ', 'D', 'P', ' '] .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
              [' ', '-', '>', ' '] (s, t) .
              shows_nl . x));

sct_ur_af_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Redtriple_ext b [Prelude.Char] () ->
                      [((Term b [Prelude.Char], Term b [Prelude.Char]),
                         ([(Nat, Nat)], [(Nat, Nat)]))] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sct_ur_af_proc i rp gs u_opt dpp =
  catcha
    (bindb (valid rp)
      (\ _ ->
        let {
          is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
          pi = af rp;
          sa = s rp;
          nsa = ns rp;
          nsta = nst rp;
          p = pairsa i dpp;
          gGs = filter (\ g -> membera p (fst g)) gs;
        } in bindb (catcha (forallM (\ (l, _) -> check_no_var l) (rulesd i dpp))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (catcha
                         (forallM
                           (\ (a, b) ->
                             let {
                               (saa, t) = a;
                             } in (\ (aa, ba) ->
                                    check_sct_entry is_def sa nsta saa t aa ba)
                               b)
                           gGs)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     let {
                       sts = concatMap
                               (\ (a, b) ->
                                 let {
                                   (sb, t) = a;
                                 } in (\ (aa, ba) ->
sct_entry_to_sts sb t aa ba)
                                   b)
                               gGs;
                     } in bindb (smart_usable_rules_checker_impl i dpp pi u_opt
                                  sts)
                            (\ u ->
                              bindb (catcha
                                      (catcha (forallM nsa u)
(\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
         'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'u', 's', 'a', 'b', 'l',
         'e', ' ', 'r', 'u', 'l', 'e', 's'] .
      shows_nl . x)))
                                (\ _ ->
                                  let {
                                    eidg = is_iedg_edge_dpp i dpp;
                                  } in bindb
 (catcha (check_subseteq p (map fst gs))
   (\ x ->
     Inl (shows_string
            ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n', 'o', ' ', 's',
              'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'g', 'r',
              'a', 'p', 'h', ' ', 'f', 'o', 'r', ' ', 'D', 'P', ' '] .
           shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
             [' ', '-', '>', ' '] x)))
 (\ _ ->
   let {
     n = size_list p;
     nums = upt Zero_nat n;
     numPs = zip p nums;
     num_of = fun_of_default numPs n;
   } in check (check_SCT (\ (_, succs) (uv, _) -> membera succs uv)
                (map (\ (st, (stri, nstri)) ->
                       let {
                         eidg_st = eidg st;
                         ia = num_of st;
                         e = (ia, map_filter
                                    (\ x ->
                                      (if ((eidg_st . fst) . fst) x
then Just (snd x) else Nothing))
                                    numPs);
                       } in Scg e e stri nstri)
                  gGs))
          (shows_string
             ['s', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g', 'e', ' ', 'a',
               'n', 'a', 'l', 'y', 's', 'i', 's', ' ', 'f', 'a', 'i', 'l', 'e',
               'd'] .
            shows_nl))))))))
    (\ x ->
      Inl (shows_string
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
               'l', 'y', ' ', 't', 'h', 'e', ' ', 's', 'i', 'z', 'e', '-', 'c',
               'h', 'a', 'n', 'g', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
               'o', 'r', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'e', ' ', 'f',
               'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' '] .
            shows_nl .
              desc rp .
                shows_nl .
                  shows_string
                    ['f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l',
                      'o', 'w', 'i', 'n', 'g', ' ', 'r', 'e', 'a', 's', 'o',
                      'n'] .
                    shows_nl . x));

filter_prec_weight_repr ::
  forall a.
    ((a, Nat) -> Af_entry) ->
      ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
        ([((Filtered a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat);
filter_prec_weight_repr pi (prw, w0) =
  let {
    fprw =
      filter
        (\ (fn, _) ->
          (case pi fn of {
            Collapse _ -> False;
            AFList _ -> True;
          }))
        prw;
    mprw =
      map (\ (a, b) ->
            let {
              (f, n) = a;
            } in (\ aa ->
                   ((FPair f n,
                      (case pi (f, n) of {
                        Collapse _ -> Zero_nat;
                        AFList ab -> size_list ab;
                      })),
                     aa))
              b)
        fprw;
  } in (mprw, w0);

prec_repr_to_status ::
  forall a.
    (Key a) => [((a, Nat), (Nat, Order_tag))] -> Filtered a -> Nat -> Order_tag;
prec_repr_to_status prs =
  let {
    m = ceta_map_of prs;
  } in (\ fp _ ->
         let {
           (FPair f a) = fp;
         } in (case m (f, a) of {
                Nothing -> Lex;
                Just aa -> snd aa;
              }));

prec_repr_to_pr ::
  forall a.
    (Key a) => [((a, Nat), (Nat, Order_tag))] -> Filtered a -> Nat -> Nat;
prec_repr_to_pr prs =
  let {
    m = ceta_map_of prs;
  } in (\ fp _ ->
         let {
           (FPair f a) = fp;
         } in (case m (f, a) of {
                Nothing -> Zero_nat;
                Just aa -> fst aa;
              }));

plus_single_mono ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      Bool;
plus_single_mono
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = plus_single_mono;

maxa ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      a -> a -> a;
maxa (Partial_object_ext carrier
       (Monoid_ext mult one
         (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = max;

geq ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      a -> a -> Bool;
geq (Partial_object_ext carrier
      (Monoid_ext mult one
        (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = geq;

poly_c_max_inter_bcoeff ::
  forall a b c.
    Partial_object_ext a
      (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
      [(c, Nat)] -> ((c, Nat) -> (a, [a])) -> a;
poly_c_max_inter_bcoeff r f pi =
  foldr (maxa r)
    (concatMap (\ fn -> filter (\ b -> not (geq r (one r) b)) (snd (pi fn))) f)
    (zero r);

derive_complexity ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
derive_complexity
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = derive_complexity;

smaller_one_complexity ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
smaller_one_complexity r bc =
  (if geq r (one r) bc then Inr Zero_nat else derive_complexity r bc);

convert_lpoly_complexity ::
  forall a b c d.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      ((c, Nat) -> (a, [a])) ->
        Complexity_measure c d ->
          Sum ([Prelude.Char] -> [Prelude.Char]) Complexity_class;
convert_lpoly_complexity r pi cc =
  let {
    f = (case cc of {
          Derivational_Complexity f -> f;
          Runtime_Complexity c _ -> c;
        });
    bc = poly_c_max_inter_bcoeff r f pi;
  } in map_sum (\ x -> x) (\ deg -> Comp_Poly (plus_nat deg (Nat_of_num One)))
         (smaller_one_complexity r bc);

check_poly_mono_npsm ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [(c, Nat)] ->
                      [((c, Nat), (a, [a]))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_poly_mono_npsm r f pi =
  bindb (catcha
          (forallM
            (\ (a, b) ->
              let {
                (fa, n) = a;
              } in (\ (c, cs) ->
                     catcha
                       (bindb
                         (check
                           (if equal_nat n (plus_nat Zero_nat (Nat_of_num One))
                             then c == zero r else True)
                           (shows_string
                              ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'p',
                                'a', 'r', 't', ' '] .
                             shows_prec Zero_nat c .
                               shows_string
                                 [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ',
                                   '0', ' '] .
                                 shows_nl))
                         (\ _ ->
                           bindb (check (equal_nat n (size_list cs))
                                   (shows_string
                                      ['t', 'h', 'e', ' ', 'a', 'r', 'i', 't',
'y', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 't', 'h', 'e', ' ', 's', 'a', 'm',
'e', ' ', 'a', 's', ' ', 't', 'h', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ',
'o', 'f', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's'] .
                                     shows_nl))
                             (\ _ ->
                               check (less_eq_nat n
                                       (plus_nat Zero_nat (Nat_of_num One)))
                                 (shows_string
                                    ['s', 'y', 'm', 'b', 'o', 'l', ' ', 'h',
                                      'a', 's', ' ', 'a', 'r', 'i', 't', 'y',
                                      ' ', 'l', 'a', 'r', 'g', 'e', 'r', ' ',
                                      't', 'h', 'a', 'n', ' ', '1'] .
                                   shows_nl))))
                       (\ x ->
                         Inl (shows_string
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                  'i', 't', 'h', ' ', 'm', 'o', 'n', 'o', 't',
                                  'o', 'n', 'i', 'c', 'i', 't', 'y', ' ', 'd',
                                  'u', 'e', ' ', 't', 'o', ' ', 'i', 'n', 't',
                                  'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i',
                                  'o', 'n', ' ', 'o', 'f', ' '] .
                               shows_prec Zero_nat fa .
                                 shows_string ['/'] .
                                   shows_prec_nat Zero_nat n . shows_nl . x)))
                b)
            pi)
          (\ x -> Inl (snd x)))
    (\ _ ->
      catcha (check_subseteq f (map fst pi))
        (\ x ->
          Inl (shows_string
                 ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'i', 'n', 't', 'e',
                   'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'f',
                   'o', 'r', ' '] .
                shows_prec_prod Zero_nat x . shows_nl)));

arcpos ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Bool;
arcpos
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = arcpos;

carrier :: forall a b. Partial_object_ext a b -> Set a;
carrier (Partial_object_ext carrier more) = carrier;

check_lpoly_coeffs ::
  forall a b c.
    (Ceq a, Corder a, Showa a,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [((c, Nat), (a, [a]))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_coeffs r i =
  catcha
    (forallM
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ (c, cs) ->
               catcha
                 (bindb
                   (check (member c (carrier r))
                     (shows_string
                        ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'p', 'a',
                          'r', 't', ' '] .
                       shows_prec Zero_nat c .
                         shows_string
                           [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'w', 'e',
                             'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd'] .
                           shows_nl))
                   (\ _ ->
                     bindb (check (arcpos r c || any (arcpos r) (take n cs))
                             (shows_string
                                ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                  ' ', 'f', 'i', 'n', 'd', ' ', 'p', 'o', 's',
                                  'i', 't', 'i', 'v', 'e', ' ', 'e', 'n', 't',
                                  'r', 'y', ' ', 'w', 'h', 'i', 'c', 'h', ' ',
                                  'i', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                                  'e', 'd', ' ', 'f', 'o', 'r', ' ', 'a', 'r',
                                  'c', 't', 'i', 'c', ' ', 'i', 'n', 't', 'e',
                                  'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o',
                                  'n', 's'] .
                               shows_nl))
                       (\ _ ->
                         catcha
                           (forallM
                             (\ aa ->
                               check (geq r aa (zero r) &&
                                       member aa (carrier r))
                                 (shows_string
                                    ['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i',
                                      'e', 'n', 't', ' '] .
                                   shows_prec Zero_nat aa .
                                     shows_string
                                       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
 'a', 'l', 'l', 'o', 'w', 'e', 'd'] .
                                       shows_nl))
                             cs)
                           (\ x -> Inl (snd x)))))
                 (\ x ->
                   Inl (shows_string
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                            't', 'h', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r',
                            'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
                            ' '] .
                         shows_prec Zero_nat f .
                           shows_string ['/'] .
                             shows_prec_nat Zero_nat n . shows_nl . x)))
          b)
      i)
    (\ x -> Inl (snd x));

description ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      [Prelude.Char];
description
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = description;

defaultb ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a;
defaultb
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = defaulta;

to_lpoly_inter ::
  forall a b c.
    (Key c) => Partial_object_ext a
                 (Monoid_ext a
                   (Ring_ext a
                     (Ordered_semiring_ext a
                       (Lpoly_order_semiring_ext a b)))) ->
                 [((c, Nat), (a, [a]))] -> (c, Nat) -> (a, [a]);
to_lpoly_inter r i =
  fun_of_map_fun (ceta_map_of i)
    (\ fn -> (defaultb r, replicate (snd fn) (one r)));

show_pvars ::
  forall a b c.
    (Eq a, Showa a,
      Showa c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                    [(c, a)] -> [[Prelude.Char]];
show_pvars r [] = [];
show_pvars r ((x, c) : vas) =
  (if c == one r then id else shows_prec Zero_nat c)
    (shows_prec Zero_nat x []) :
    show_pvars r vas;

shows_lpoly ::
  forall a b c.
    (Eq a, Showa a,
      Showa c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                    L_poly c a -> [Prelude.Char] -> [Prelude.Char];
shows_lpoly r (LPoly c cs) =
  (case show_pvars r cs of {
    [] -> shows_prec Zero_nat c;
    a : list ->
      (if c == zero r then id
        else shows_prec Zero_nat c . shows_string [' ', '+', ' ']) .
        shows_list_gen (shows_prec_list Zero_nat) [] [] [' ', '+', ' '] []
          (a : list);
  });

add_var ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 c -> a -> [(c, a)] -> [(c, a)];
add_var r x a [] = [(x, a)];
add_var r x a ((y, b) : vas) =
  (if x == y
    then let {
           s = add r a b;
         } in (if s == zero r then vas else (x, s) : vas)
    else (y, b) : add_var r x a vas);

sum_pvars ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 [(c, a)] -> [(c, a)] -> [(c, a)];
sum_pvars r [] vbs = vbs;
sum_pvars r ((x, a) : vas) vbs =
  (if a == zero r then sum_pvars r vas vbs
    else sum_pvars r vas (add_var r x a vbs));

sum_lpolya ::
  forall a b c.
    (Eq a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 L_poly c a -> L_poly c a -> L_poly c a;
sum_lpolya r (LPoly a vas) (LPoly b vbs) =
  LPoly (add r a b) (sum_pvars r vas vbs);

mul_pvars ::
  forall a b c.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                a -> [(c, a)] -> [(c, a)];
mul_pvars r a [] = [];
mul_pvars r a ((x, b) : vas) =
  let {
    p = mult r a b;
    res = mul_pvars r a vas;
  } in (if p == zero r then res else (x, p) : res);

mul_lpoly ::
  forall a b c.
    (Eq a) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                a -> L_poly c a -> L_poly c a;
mul_lpoly r a (LPoly b vas) = LPoly (mult r a b) (mul_pvars r a vas);

list_prod :: forall a b. Partial_object_ext a (Monoid_ext a b) -> [a] -> a;
list_prod r [] = one r;
list_prod r (x : xs) = mult r x (list_prod r xs);

wf_pvars ::
  forall a b c.
    (Cenum a, Ceq a, Corder a,
      Set_impl a) => Partial_object_ext a b -> [(c, a)] -> Bool;
wf_pvars r vas = less_eq_set (set (map snd vas)) (carrier r);

wf_lpoly ::
  forall a b c.
    (Cenum a, Ceq a, Corder a,
      Set_impl a) => Partial_object_ext a b -> L_poly c a -> Bool;
wf_lpoly r (LPoly a vas) = member a (carrier r) && wf_pvars r vas;

pleftI ::
  forall a b c d.
    (Cenum a, Ceq a, Corder a, Eq a, Set_impl a,
      Eq d) => Partial_object_ext a
                 (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                 ((c, Nat) -> (a, [a])) -> Term c d -> L_poly d a;
pleftI r pi (Var x) = LPoly (zero r) [(x, one r)];
pleftI r pi (Fun f ts) =
  let {
    (c, asa) = pi (f, size_list ts);
  } in (case sum_lpolya r (LPoly c [])
               (list_prod
                 (Partial_object_ext (collect (wf_lpoly r))
                   (Monoid_ext (sum_lpolya r) (LPoly (zero r) []) ()))
                 (map (\ at -> mul_lpoly r (fst at) (pleftI r pi (snd at)))
                   (zip asa ts)))
         of {
         LPoly d [] -> LPoly (maxa r (zero r) d) [];
         LPoly d (ab : lista) -> LPoly d (ab : lista);
       });

create_lpoly_repr ::
  forall a b.
    (Cenum a, Ceq a, Corder a, Eq a, Set_impl a, Showa a, Eq b, Key b,
      Showa b) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a ())))) ->
                    [((b, Nat), (a, [a]))] -> [Prelude.Char] -> [Prelude.Char];
create_lpoly_repr c i =
  let {
    pi = to_lpoly_inter c i;
  } in shows_string
         ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n', 't',
           'e', 'r', 'p', 'r', 'e', 't', 'r', 'a', 't', 'i', 'o', 'n', ' ', 'o',
           'v', 'e', 'r', ' '] .
         shows_string (description c) .
           shows_nl .
             shows_sep
               (\ (f, n) ->
                 let {
                   t = Fun f (map Var
                               (fresh_strings_list ['x', '_'] (Nat_of_num One)
                                 [] n));
                 } in shows_string ['P', 'o', 'l', '('] .
                        shows_prec_term Zero_nat t .
                          shows_string [')', ' ', '=', ' '] .
                            shows_lpoly c (pleftI c pi t))
               shows_nl (remdups (map fst i));

checkmono ::
  forall a b.
    Partial_object_ext a
      (Monoid_ext a
        (Ring_ext a (Ordered_semiring_ext a (Lpoly_order_semiring_ext a b)))) ->
      a -> Bool;
checkmono
  (Partial_object_ext carrier
    (Monoid_ext mult one
      (Ring_ext zero add
        (Ordered_semiring_ext geq gt max
          (Lpoly_order_semiring_ext plus_single_mono defaulta arcpos checkmono
            bound derive_complexity description more)))))
  = checkmono;

check_poly_mono ::
  forall a b c.
    (Showa a,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    [((c, Nat), (a, [a]))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_poly_mono r =
  (\ xs ->
    catcha
      (forallM
        (\ (a, b) ->
          let {
            (f, n) = a;
          } in (\ (c, cs) ->
                 catcha
                   (bindb
                     (check (geq r c (zero r))
                       (shows_string
                          ['c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'p',
                            'a', 'r', 't', ' '] .
                         shows_prec Zero_nat c .
                           shows_string
                             [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a',
                               't', ' ', 'l', 'e', 'a', 's', 't', ' '] .
                             shows_prec Zero_nat (zero r) . shows_nl))
                     (\ _ ->
                       bindb (check (less_eq_nat n (size_list cs))
                               (shows_string
                                  ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ',
                                    'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ',
                                    'i', 's', ' ', 'i', 'g', 'n', 'o', 'r', 'e',
                                    'd'] .
                                 shows_nl))
                         (\ _ ->
                           catcha
                             (forallM
                               (\ d ->
                                 check (checkmono r d)
                                   (shows_string
                                      ['c', 'o', 'e', 'f', 'f', 'i', 'c', 'i',
'e', 'n', 't', ' '] .
                                     shows_prec Zero_nat d .
                                       shows_string
 [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd'] .
 shows_nl))
                               cs)
                             (\ x -> Inl (snd x)))))
                   (\ x ->
                     Inl (shows_string
                            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                              't', 'h', ' ', 'm', 'o', 'n', 'o', 't', 'o', 'n',
                              'i', 'c', 'i', 't', 'y', ' ', 'd', 'u', 'e', ' ',
                              't', 'o', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r',
                              'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f',
                              ' '] .
                           shows_prec Zero_nat f .
                             shows_string ['/'] .
                               shows_prec_nat Zero_nat n . shows_nl . x)))
            b)
        xs)
      (\ x -> Inl (snd x)));

lookup_rest :: forall a b. (Eq a) => a -> [(a, b)] -> Maybe (b, [(a, b)]);
lookup_rest x [] = Nothing;
lookup_rest x ((y, c) : ycs) =
  (if x == y then Just (c, ycs)
    else (case lookup_rest x ycs of {
           Nothing -> Nothing;
           Just (d, yccs) -> Just (d, (y, c) : yccs);
         }));

check_pvars ::
  forall a b c.
    (Showa a,
      Eq c) => Partial_object_ext a (Monoid_ext a (Ring_ext a b)) ->
                 (a -> a -> Bool) -> [(c, a)] -> [(c, a)] -> Sum c ();
check_pvars r rel vas [] =
  catcha (forallM (\ va -> check (rel (snd va) (zero r)) (fst va)) vas)
    (\ x -> Inl (snd x));
check_pvars r rel vas ((x, b) : vbs) =
  let {
    (a, vasa) =
      (case lookup_rest x vas of {
        Nothing -> (zero r, vas);
        Just (a, ba) -> (a, ba);
      });
  } in bindb (check (rel a b) x) (\ _ -> check_pvars r rel vasa vbs);

check_lpoly_ns ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                    L_poly c a ->
                      L_poly c a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_ns r (LPoly a vas) (LPoly b vbs) =
  catcha
    (bindb
      (check (geq r a b)
        (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
            'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 's',
            't', 'a', 'n', 't', ' ', 'p', 'a', 'r', 't', 's']))
      (\ _ ->
        catcha (check_pvars r (geq r) vas vbs)
          (\ x ->
            Inl (shows_string
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c',
                     'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', 's', ' ',
                     'o', 'f', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
                     ' '] .
                  shows_prec Zero_nat x))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' '] .
            shows_lpoly r (LPoly a vas) .
              shows_string [' ', '>', '=', ' '] .
                shows_lpoly r (LPoly b vbs) . shows_nl . x));

prightI ::
  forall a b c d.
    (Cenum a, Ceq a, Corder a, Eq a, Set_impl a,
      Eq d) => Partial_object_ext a
                 (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
                 ((c, Nat) -> (a, [a])) -> Term c d -> L_poly d a;
prightI r pi (Var x) = LPoly (zero r) [(x, one r)];
prightI r pi (Fun f ts) =
  let {
    (c, asa) = pi (f, size_list ts);
    (LPoly d a) =
      sum_lpolya r (LPoly c [])
        (list_prod
          (Partial_object_ext (collect (wf_lpoly r))
            (Monoid_ext (sum_lpolya r) (LPoly (zero r) []) ()))
          (map (\ at -> mul_lpoly r (fst at) (prightI r pi (snd at)))
            (zip asa ts)));
  } in LPoly (maxa r (zero r) d) a;

check_polo_ns ::
  forall a b c d.
    (Cenum a, Ceq a, Corder a, Eq a, Set_impl a, Showa a, Showa c, Eq d,
      Showa d) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    ((c, Nat) -> (a, [a])) ->
                      (Term c d, Term c d) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_polo_ns r pi (s, t) =
  let {
    left = pleftI r pi s;
    right = prightI r pi t;
  } in catcha (check_lpoly_ns r left right)
         (\ x ->
           Inl (shows_string
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                    's', 'u', 'r', 'e', ' '] .
                 shows_prec_term Zero_nat s .
                   shows_string [' ', '>', '=', ' '] .
                     shows_prec_term Zero_nat t . shows_nl . x));

gt :: forall a b.
        Partial_object_ext a
          (Monoid_ext a (Ring_ext a (Ordered_semiring_ext a b))) ->
          a -> a -> Bool;
gt (Partial_object_ext carrier
     (Monoid_ext mult one
       (Ring_ext zero add (Ordered_semiring_ext geq gt max more))))
  = gt;

check_lpoly_s ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    L_poly c a ->
                      L_poly c a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_lpoly_s r (LPoly a vas) (LPoly b vbs) =
  catcha
    (bindb
      (check (gt r a b)
        (shows_string
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'c',
            'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 's',
            't', 'a', 'n', 't', ' ', 'p', 'a', 'r', 't']))
      (\ _ ->
        catcha
          (check_pvars r (if plus_single_mono r then geq r else gt r) vas vbs)
          (\ x ->
            Inl (shows_string
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'c',
                     'o', 'e', 'f', 'f', 'i', 'c', 'i', 'e', 'n', 't', 's', ' ',
                     'o', 'f', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
                     ' '] .
                  shows_prec Zero_nat x))))
    (\ x ->
      Inl (shows_string
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' '] .
            shows_lpoly r (LPoly a vas) .
              shows_string [' ', '>', ' '] .
                shows_lpoly r (LPoly b vbs) . shows_nl . x));

check_polo_s ::
  forall a b c d.
    (Cenum a, Ceq a, Corder a, Eq a, Set_impl a, Showa a, Showa c, Eq d,
      Showa d) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a b)))) ->
                    ((c, Nat) -> (a, [a])) ->
                      (Term c d, Term c d) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_polo_s r pi (s, t) =
  let {
    left = pleftI r pi s;
    right = prightI r pi t;
  } in catcha (check_lpoly_s r left right)
         (\ x ->
           Inl (shows_string
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n',
                    's', 'u', 'r', 'e', ' '] .
                 shows_prec_term Zero_nat s .
                   shows_string [' ', '>', ' '] .
                     shows_prec_term Zero_nat t . shows_nl . x));

create_af ::
  forall a b c.
    (Eq a,
      Key c) => Partial_object_ext a
                  (Monoid_ext a
                    (Ring_ext a
                      (Ordered_semiring_ext a
                        (Lpoly_order_semiring_ext a b)))) ->
                  [((c, Nat), (a, [a]))] -> (c, Nat) -> Nat -> Bool;
create_af r i =
  fun_of_map_funa (ceta_map_of i) (\ _ _ -> True)
    (\ (_, coeffs) ->
      let {
        len = size_list coeffs;
      } in (\ ia -> less_nat ia len && not (nth coeffs ia == zero r)));

create_poly_redtriple ::
  forall a b c.
    (Cenum a, Ceq a, Corder a, Eq a, Set_impl a, Showa a, Eq b, Key b, Showa b,
      Eq c,
      Showa c) => Partial_object_ext a
                    (Monoid_ext a
                      (Ring_ext a
                        (Ordered_semiring_ext a
                          (Lpoly_order_semiring_ext a ())))) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                      [((b, Nat), (a, [a]))] -> Redtriple_ext b c ();
create_poly_redtriple c cI i =
  let {
    pi = to_lpoly_inter c i;
    ns = check_polo_ns c pi;
  } in Redtriple_ext (bindb cI (\ _ -> check_lpoly_coeffs c i))
         (check_polo_s c pi) ns ns (create_af c i)
         (\ s_ns_nst ->
           (if plus_single_mono c then check_poly_mono c i
             else check_poly_mono_npsm c (funas_trs_list s_ns_nst) i))
         (create_lpoly_repr c i)
         (if plus_single_mono c then convert_lpoly_complexity c pi
           else (\ _ ->
                  Inl (shows_prec_list Zero_nat
                        ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ',
                          'a', 'n', 'a', 'l', 'y', 's', 'i', 's', ' ', 'u', 'n',
                          's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd'])))
         ();

weak_gt_arctic_delta ::
  forall a. (Floor_ceiling a) => Arctic_delta a -> Arctic_delta a -> Bool;
weak_gt_arctic_delta uu MinInfty_delta = True;
weak_gt_arctic_delta MinInfty_delta (Num_arc_delta uv) = False;
weak_gt_arctic_delta (Num_arc_delta x) (Num_arc_delta y) = less y x;

check_poly_strict_mono_discrete ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => (a -> a -> Bool) -> [([(b, Nat)], a)] -> b -> Bool;
check_poly_strict_mono_discrete gt p v =
  check_poly_gt gt
    (poly_subst
      (\ w -> poly_of (if w == v then PSum [PNum onea, PVar v] else PVar w)) p)
    p;

check_monom_strict_mono :: forall a. (Eq a) => Bool -> [(a, Nat)] -> a -> Bool;
check_monom_strict_mono pm m v =
  not (null m) &&
    null (tl m) &&
      fst (hd m) == v &&
        (if pm then less_eq_nat (Nat_of_num One) (snd (hd m))
          else equal_nat (snd (hd m)) (Nat_of_num One));

check_poly_strict_mono ::
  forall a b. (Eq a, Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> a -> Bool;
check_poly_strict_mono pm p v =
  any (\ (m, c) -> less_eq onea c && check_monom_strict_mono pm m v) p;

check_poly_strict_mono_smart ::
  forall a b.
    (Eq a, Poly_carrier a,
      Eq b) => Bool ->
                 Bool -> (a -> a -> Bool) -> [([(b, Nat)], a)] -> b -> Bool;
check_poly_strict_mono_smart discrete pm gt p v =
  (if discrete then check_poly_strict_mono_discrete gt p v
    else check_poly_strict_mono pm p v);

check_poly_weak_mono_all ::
  forall a b. (Ordered_semiring_0 b) => [([(a, Nat)], b)] -> Bool;
check_poly_weak_mono_all p = all (\ (_, a) -> less_eq zeroa a) p;

check_poly_weak_mono_and_pos ::
  forall a b. (Eq a, Eq b, Poly_carrier b) => Bool -> [([(a, Nat)], b)] -> Bool;
check_poly_weak_mono_and_pos discrete p =
  (if discrete
    then all (check_poly_weak_mono_discrete p) (poly_vars_list p) &&
           less_eq zeroa (eval_poly (\ _ -> zeroa) p)
    else check_poly_weak_mono_all p);

check_poly_inter_list ::
  forall a b.
    (Eq b,
      Poly_carrier b) => Bool ->
                           [((a, Nat), [([(Nat, Nat)], b)])] ->
                             Sum (a, [([(Nat, Nat)], b)]) ();
check_poly_inter_list discrete i =
  catcha
    (catcha
      (forallM
        (\ x ->
          (if let {
                (_, a) = x;
              } in check_poly_weak_mono_and_pos discrete a
            then Inr () else Inl x))
        i)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (let {
             (a, b) = x;
           } in let {
                  (f, _) = a;
                } in (\ aa -> (f, aa))
                  b));

strongly_linear ::
  forall a. (Poly_carrier a) => Nat -> [([(Nat, Nat)], a)] -> a -> Bool;
strongly_linear x p v =
  (if equal_nat x Zero_nat then check_ge_v v p
    else let {
           (a, pa) =
             poly_split
               [(minus_nat x (Nat_of_num One),
                  plus_nat Zero_nat (Nat_of_num One))]
               p;
         } in less_eq a onea &&
                strongly_linear (minus_nat x (Nat_of_num One)) pa v);

sl_complexity_sig_check ::
  forall a b.
    (Poly_carrier b) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                          b -> [(a, Nat)] -> Sum (a, Nat) ();
sl_complexity_sig_check i v f =
  catcha
    (forallM (\ (fa, n) -> check (strongly_linear n (i (fa, n)) v) (fa, n)) f)
    (\ x -> Inl (snd x));

sl_complexity_check ::
  forall a b.
    (Poly_carrier a,
      Showa b) => a -> ((b, Nat) -> [([(Nat, Nat)], a)]) ->
                         [(b, Nat)] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
sl_complexity_check v i f =
  let {
    w = max_v v i f;
  } in catcha (sl_complexity_sig_check i w f)
         (\ x ->
           Inl (let {
                  (fa, _) = x;
                } in shows_string ['s', 'y', 'm', 'b', 'o', 'l', ' '] .
                       shows_prec Zero_nat fa .
                         shows_prec_list Zero_nat
                           [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                             'p', 'o', 's', 's', 'e', 's', 's', ' ', 'a', ' ',
                             's', 't', 'r', 'o', 'n', 'g', 'l', 'y', ' ', 'l',
                             'i', 'n', 'e', 'a', 'r', ' ', 'i', 'n', 't', 'e',
                             'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o',
                             'n']));

nl_complexity_check ::
  forall a b c.
    (Showa a,
      Poly_carrier b) => ((a, Nat) -> [([(Nat, Nat)], b)]) ->
                           Complexity_measure a c ->
                             Sum ([Prelude.Char] -> [Prelude.Char])
                               Complexity_class;
nl_complexity_check i (Derivational_Complexity f) =
  bindb (sl_complexity_check zeroa i f)
    (\ _ -> Inr (Comp_Poly (Nat_of_num One)));
nl_complexity_check i (Runtime_Complexity c d) =
  bindb (sl_complexity_check onea i c)
    (\ _ ->
      let {
        deg = max_list (map (\ f -> poly_degree (i f)) d);
      } in Inr (Comp_Poly deg));

poly_inter_to_af ::
  forall a b. ((a, Nat) -> [([(Nat, Nat)], b)]) -> (a, Nat) -> Nat -> Bool;
poly_inter_to_af i fn = (\ ia -> member ia (poly_vars (i fn)));

create_nlpoly_redtriple ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Key b, Showa b, Eq c,
      Showa c) => Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                    a -> (a -> a -> Bool) ->
                           Bool ->
                             Bool ->
                               [((b, Nat), [([(Nat, Nat)], a)])] ->
                                 Redtriple_ext b c ();
create_nlpoly_redtriple cI def gt power_mono discrete i =
  let {
    j = poly_inter_list_to_inter def i;
    x = poly_subst
          (\ n -> poly_of (PVar (['x', '_'] ++ shows_prec_nat Zero_nat n [])));
  } in Redtriple_ext
         (bindb cI
           (\ _ ->
             catcha (check_poly_inter_list discrete i)
               (\ xa ->
                 Inl (let {
                        (f, p) = xa;
                      } in shows_string
                             ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a',
                               't', 'i', 'o', 'n', ' '] .
                             shows_poly (x p) .
                               shows_string [' ', 'o', 'f', ' '] .
                                 shows_prec Zero_nat f .
                                   shows_string
                                     [' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd',
                                       ' ']))))
         (check_s gt j) (check_ns j) (check_ns j) (poly_inter_to_af j)
         (\ _ ->
           catcha
             (catcha
               (forallM
                 (\ xa ->
                   (if let {
                         (a, b) = xa;
                       } in let {
                              (_, n) = a;
                            } in (\ p ->
                                   all_interval_nat
                                     (check_poly_strict_mono_smart discrete
                                       power_mono gt p)
                                     Zero_nat n)
                              b
                     then Inr () else Inl xa))
                 i)
               (\ xa -> Inl (snd xa)))
             (\ xa ->
               Inl (let {
                      (a, b) = xa;
                    } in let {
                           (f, _) = a;
                         } in (\ p ->
                                shows_string
                                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                    ' ', 'e', 'n', 's', 'u', 'r', 'e', ' ', 'm',
                                    'o', 'n', 'o', 't', 'o', 'n', 'i', 'c', 't',
                                    'y', ' ', 'o', 'f', ' '] .
                                  shows_poly (x p) .
                                    shows_string
                                      [' ', 'a', 's', ' ', 'i', 'n', 't', 'e',
'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                                      shows_prec Zero_nat f)
                           b)))
         (shows_string
            ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n',
              't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n'] .
           shows_nl .
             shows_sep
               (\ (a, b) ->
                 let {
                   (f, n) = a;
                 } in (\ p ->
                        shows_string ['P', 'o', 'l', '('] .
                          shows_prec Zero_nat f .
                            shows_string ['/'] .
                              shows_prec_nat Zero_nat n .
                                shows_string [')', ' ', '=', ' '] .
                                  shows_poly (x p))
                   b)
               shows_nl i)
         (nl_complexity_check j) ();

pos_arctic_delta :: forall a. (Floor_ceiling a) => Arctic_delta a -> Bool;
pos_arctic_delta MinInfty_delta = False;
pos_arctic_delta (Num_arc_delta n) = less_eq zeroa n;

class_ordered_semiring ::
  forall a b.
    (Ceq a, Corder a, Ordered_semiring_1 a,
      Set_impl a) => Itself a ->
                       (a -> a -> Bool) ->
                         b -> Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a (Ordered_semiring_ext a b)));
class_ordered_semiring a gt b =
  class_semiring a (Ordered_semiring_ext (\ x y -> less_eq y x) gt max b);

class_arc_complexity ::
  forall a. a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
class_arc_complexity a =
  Inl (shows_prec_list Zero_nat
        ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'f', 'o', 'r',
          ' ', 'a', 'r', 'c', 't', 'i', 'c', ' ', 's', 'e', 'm', 'i', 'r', 'i',
          'n', 'g', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r',
          't', 'e', 'd']);

class_arc_lpoly_order ::
  forall a.
    (Ceq a, Corder a, Ordered_semiring_1 a,
      Set_impl a) => a -> (a -> Bool) ->
                            (a -> a -> Bool) ->
                              Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a
                                    (Ordered_semiring_ext a
                                      (Lpoly_order_semiring_ext a ()))));
class_arc_lpoly_order def apos gt =
  class_ordered_semiring Type gt
    (Lpoly_order_semiring_ext False def apos (\ _ -> False) (\ _ -> Zero_nat)
      class_arc_complexity
      ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n', 't',
        'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'v',
        'e', 'r', ' ', 'a', 'r', 'c', 't', 'i', 'c', ' ', 's', 'e', 'm', 'i',
        'r', 'i', 'n', 'g']
      ());

vec_comp_all :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
vec_comp_all r v w = all (\ (a, b) -> r a b) (zip v w);

mat_comp_all :: forall a. (a -> a -> Bool) -> [[a]] -> [[a]] -> Bool;
mat_comp_all r m1 m2 = all (\ (a, b) -> vec_comp_all r a b) (zip m1 m2);

mat_ge :: forall a. (Non_strict_order a) => [[a]] -> [[a]] -> Bool;
mat_ge = mat_comp_all (\ x y -> less_eq y x);

mat_both_ordered_semiring ::
  forall a b.
    (Ordered_semiring_1 a) => Nat ->
                                (a -> a -> Bool) ->
                                  b -> Partial_object_ext [[a]]
 (Monoid_ext [[a]] (Ring_ext [[a]] (Ordered_semiring_ext [[a]] b)));
mat_both_ordered_semiring n gt b =
  mat_ring n (Ordered_semiring_ext mat_ge (mat_comp_all gt) (mat_plusI max) b);

mat_arc_complexity :: forall a. a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
mat_arc_complexity m =
  Inl (shows_prec_list Zero_nat
        ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'f', 'o', 'r',
          ' ', 'a', 'r', 'c', 't', 'i', 'c', ' ', 'm', 'a', 't', 'r', 'i', 'c',
          'e', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
          'e', 'd']);

mat_arc_posI :: forall a. (a -> Bool) -> [[a]] -> Bool;
mat_arc_posI ap m = ap (nth (nth m Zero_nat) Zero_nat);

mat_arc_lpoly_order ::
  forall a.
    (Ordered_semiring_1 a) => Nat ->
                                a -> (a -> Bool) ->
                                       (a -> a -> Bool) ->
 Partial_object_ext [[a]]
   (Monoid_ext [[a]]
     (Ring_ext [[a]]
       (Ordered_semiring_ext [[a]] (Lpoly_order_semiring_ext [[a]] ()))));
mat_arc_lpoly_order n def apos gt =
  mat_both_ordered_semiring n gt
    (Lpoly_order_semiring_ext False (mat1I zeroa def n) (mat_arc_posI apos)
      (\ _ -> False) (\ _ -> Zero_nat) mat_arc_complexity
      ['a', 'r', 'c', 't', 'i', 'c', ' ', 'm', 'a', 't', 'r', 'i', 'x', ' ',
        'i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
      ());

check_arc_dimension :: Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_arc_dimension n =
  check (less_nat Zero_nat n)
    (shows_prec_list Zero_nat
      ['d', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n', ' ', 'm', 'u', 's', 't',
        ' ', 'b', 'e', ' ', 'a', 't', ' ', 'l', 'e', 'a', 's', 't', ' ', '1']);

default_af_entry :: Nat -> Af_entry;
default_af_entry n = AFList (upt Zero_nat n);

afs_list_to_afs ::
  forall a. (Key a) => [((a, Nat), Af_entry)] -> (a, Nat) -> Af_entry;
afs_list_to_afs pi =
  fun_of_map_fun (ceta_map_of pi) (\ fn -> default_af_entry (snd fn));

class_complexity ::
  forall a.
    (Ordered_semiring_1 a) => a -> Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
class_complexity a =
  (if less_eq a onea then Inr Zero_nat
    else Inl (shows_prec_list Zero_nat
               ['v', 'a', 'l', 'u', 'e', ' ', 'i', 's', ' ', 'l', 'a', 'r', 'g',
                 'e', 'r', ' ', 't', 'h', 'a', 'n', ' ', '1']));

class_lpoly_order ::
  forall a.
    (Ceq a, Corder a, Ordered_semiring_1 a,
      Set_impl a) => a -> (a -> Bool) ->
                            (a -> a -> Bool) ->
                              Partial_object_ext a
                                (Monoid_ext a
                                  (Ring_ext a
                                    (Ordered_semiring_ext a
                                      (Lpoly_order_semiring_ext a ()))));
class_lpoly_order def mon gt =
  class_ordered_semiring Type gt
    (Lpoly_order_semiring_ext True def (\ _ -> True) mon (\ _ -> Zero_nat)
      class_complexity
      ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n', 't',
        'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n']
      ());

scf_repr_to_scf ::
  forall a. ((a, Nat) -> Maybe [Nat]) -> (a, Nat) -> Nat -> Nat;
scf_repr_to_scf scf fn i =
  (case scf fn of {
    Nothing -> Nat_of_num One;
    Just xs -> nth xs i;
  });

check_scf_entry ::
  forall a.
    (Showa a) => (a, Nat) ->
                   Maybe [Nat] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_scf_entry fn Nothing = Inr ();
check_scf_entry (f, n) (Just es) =
  catcha
    (bindb
      (check (equal_nat (size_list es) n)
        (shows_prec_list Zero_nat
           ['n', 'r', ' ', 'o', 'f', ' ', 'e', 'n', 't', 'r', 'i', 'e', 's',
             ' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e', ' '] .
          shows_prec_nat Zero_nat n))
      (\ _ ->
        check (all (less_nat Zero_nat) es)
          (shows_prec_list Zero_nat
            ['a', 'l', 'l', ' ', 'e', 'n', 't', 'r', 'i', 'e', 's', ' ', 'm',
              'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n', '-', 'z', 'e',
              'r', 'o'])))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ',
               's', 'u', 'b', 't', 'e', 'r', 'm', ' ', 'c', 'o', 'e', 'f', 'f',
               'i', 'c', 'i', 'e', 'n', 't', 's', ' ', 'f', 'o', 'r', ' '] .
            shows_prec_prod Zero_nat (f, n) .
              shows_prec_list Zero_nat [':', ' '] . x . shows_nl));

prec_weight_repr_to_prec_weight ::
  forall a.
    (Eq a, Key a,
      Showa a) => ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    (Sum ([Prelude.Char] -> [Prelude.Char]) (),
                      ((a, Nat) -> Nat,
                        ((a, Nat) -> Nat,
                          (Nat, (a -> Bool, (a, Nat) -> Nat -> Nat)))));
prec_weight_repr_to_prec_weight prw_w0 =
  let {
    (prw, w0) = prw_w0;
    prwm = ceta_map_of prw;
    w_fun =
      fun_of_map_funa prwm (\ _ -> plus_nat w0 (Nat_of_num One)) (fst . snd);
    p_fun = fun_of_map_funa prwm (\ _ -> Zero_nat) fst;
    scf_fun = fun_of_map_funa prwm (\ _ -> Nothing) (snd . snd);
    fs = map fst prw;
    p_max = max_list (map p_fun fs);
    cw_okay =
      catcha
        (forallM
          (\ fn ->
            check (if equal_nat (snd fn) Zero_nat then less_eq_nat w0 (w_fun fn)
                    else True)
              (shows_prec_list Zero_nat
                 ['w', 'e', 'i', 'g', 'h', 't', ' ', 'o', 'f', ' ', 'c', 'o',
                   'n', 's', 't', 'a', 'n', 't', ' '] .
                shows_prec Zero_nat (fst fn) .
                  shows_prec_list Zero_nat
                    [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', 't', ' ',
                      'l', 'e', 'a', 's', 't', ' ', 'w', '0']))
          (map fst prw))
        (\ x -> Inl (snd x));
    adm = catcha
            (forallM
              (\ fn ->
                check (if equal_nat (snd fn) (Nat_of_num One)
                        then (if equal_nat (w_fun fn) Zero_nat
                               then equal_nat (p_fun fn) p_max else True)
                        else True)
                  (shows_prec_list Zero_nat
                     ['u', 'n', 'a', 'r', 'y', ' ', 's', 'y', 'm', 'b', 'o',
                       'l', ' '] .
                    shows_prec Zero_nat (fst fn) .
                      shows_prec_list Zero_nat
                        [' ', 'w', 'i', 't', 'h', ' ', 'w', 'e', 'i', 'g', 'h',
                          't', ' ', '0', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o',
                          't', ' ', 'h', 'a', 'v', 'e', ' ', 'm', 'a', 'x', 'i',
                          'm', 'a', 'l', ' ', 'p', 'r', 'e', 'c', 'e', 'd', 'e',
                          'n', 'c', 'e']))
              (map fst prw))
            (\ x -> Inl (snd x));
    scf_ok =
      catcha (forallM (\ fn -> check_scf_entry fn (scf_fun fn)) (map fst prw))
        (\ x -> Inl (snd x));
    cs = map_filter
           (\ x ->
             (if equal_nat (snd x) Zero_nat && equal_nat (w_fun x) w0
               then Just (fst x) else Nothing))
           fs;
    p_min = min_list (map (\ c -> p_fun (c, Zero_nat)) cs);
    lcs = filter (\ c -> equal_nat (p_fun (c, Zero_nat)) p_min) cs;
    least = membera lcs;
    ok = bindb (check (less_nat Zero_nat w0)
                 (shows_prec_list Zero_nat
                   ['w', '0', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'l',
                     'a', 'r', 'g', 'e', 'r', ' ', 't', 'h', 'a', 'n', ' ',
                     '0']))
           (\ _ -> bindb adm (\ _ -> bindb cw_okay (\ _ -> scf_ok)));
  } in (ok, (p_fun, (w_fun, (w0, (least, scf_repr_to_scf scf_fun)))));

create_KBO_redtriple ::
  forall a b c.
    (Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => (([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                    ([((b, Nat), (Nat, (Nat, Maybe [Nat])))], Nat)) ->
                    ([((a, Nat), (Nat, (Nat, Maybe [Nat])))], Nat) ->
                      Redtriple_ext b c ();
create_KBO_redtriple f_to_g pr =
  let {
    (ch, (p, (w, (w0, (least, scf))))) =
      prec_weight_repr_to_prec_weight (f_to_g pr);
    ns = kbo_nstrict p w w0 least scf;
    s = kbo_strict p w w0 least scf;
  } in Redtriple_ext ch s ns ns full_af (\ _ -> Inr ()) (shows_kbo_repr pr)
         (\ _ ->
           Inl (shows_prec_list Zero_nat
                 ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'a',
                   'n', 'a', 'l', 'y', 's', 'i', 's', ' ', 'u', 'n', 's', 'u',
                   'p', 'p', 'o', 'r', 't', 'e', 'd']))
         ();

check_dimensions ::
  Nat ->
    Nat ->
      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dimensions n sd c =
  bindb c
    (\ _ ->
      check (less_eq_nat sd n && less_nat Zero_nat sd)
        (shows_prec_list Zero_nat
          ['s', 't', 'r', 'i', 'c', 't', ' ', 'd', 'i', 'm', 'e', 'n', 's', 'i',
            'o', 'n', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', 't',
            ' ', 'l', 'e', 'a', 's', 't', ' ', '1', ' ', 'a', 'n', 'd', ' ',
            'l', 'e', 's', 's', ' ', 't', 'h', 'a', 'n', ' ', 't', 'o', 't',
            'a', 'l', ' ', 'd', 'i', 'm', 'e', 'n', 's', 'i', 'o', 'n']));

check_mono_afs_help ::
  forall a b c. (Showa a) => ((a, b), c) -> [Prelude.Char] -> [Prelude.Char];
check_mono_afs_help ((f, a), e) =
  shows_string ['e', 'n', 't', 'r', 'y', ' ', 'f', 'o', 'r', ' '] .
    shows_prec Zero_nat f .
      shows_string
        [' ', 'n', 'o', 't', ' ', 'm', 'o', 'n', 'o', 't', 'o', 'n', 'i', 'c'] .
        shows_nl;

mono_af_entry :: Nat -> Af_entry -> Bool;
mono_af_entry n (Collapse i) = less_eq_nat n (Nat_of_num One);
mono_af_entry n (AFList ids) = all_interval_nat (membera ids) Zero_nat n;

check_mono_afs ::
  forall a.
    (Showa a) => [((a, Nat), Af_entry)] ->
                   Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_mono_afs pi =
  catcha
    (catcha
      (forallM
        (\ x -> (if mono_af_entry (snd (fst x)) (snd x) then Inr () else Inl x))
        pi)
      (\ x -> Inl (snd x)))
    (\ x -> Inl (check_mono_afs_help x));

afs_list_to_af ::
  forall a. (Key a) => [((a, Nat), Af_entry)] -> (a, Nat) -> Nat -> Bool;
afs_list_to_af pi =
  fun_of_map_funa (ceta_map_of pi) (\ _ _ -> True)
    (\ a ->
      (case a of {
        Collapse aa -> equal_nat aa;
        AFList aa -> membera aa;
      }));

check_wf_afs ::
  forall a.
    (Showa a) => [((a, Nat), Af_entry)] ->
                   Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_afs pi =
  catcha
    (forallM
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ e ->
               catcha
                 (case e of {
                   Collapse i -> check (less_nat i n) i;
                   AFList ids ->
                     catcha
                       (forallM
                         (\ x -> (if less_nat x n then Inr () else Inl x)) ids)
                       (\ x -> Inl (snd x));
                 })
                 (\ x ->
                   Inl (shows_string ['i', 'n', 'd', 'e', 'x', ' '] .
                         shows_prec_nat Zero_nat x .
                           shows_string
                             [' ', 't', 'o', 'o', ' ', 'h', 'i', 'g', 'h', ' ',
                               'f', 'o', 'r', ' ', 'A', 'F', '-', 'e', 'n', 't',
                               'r', 'y', ' ', 'o', 'f'] .
                             shows_prec_prod Zero_nat (f, n) . shows_nl)))
          b)
      pi)
    (\ x -> Inl (snd x));

shows_afs ::
  forall a.
    (Showa a) => [((a, Nat), Af_entry)] -> [Prelude.Char] -> [Prelude.Char];
shows_afs af =
  shows_map
    (\ (a, b) ->
      let {
        (f, n) = a;
      } in (\ e ->
             shows_string ['p', 'i', '('] .
               shows_prec Zero_nat f .
                 shows_string ['/'] .
                   shows_prec_nat Zero_nat n .
                     shows_string [')', ' ', '=', ' '] .
                       (case e of {
                         Collapse i ->
                           shows_prec_nat Zero_nat
                             (plus_nat i (Nat_of_num One));
                         AFList ids -> shows_prec_list Zero_nat (map suc ids);
                       }) .
                         shows_nl)
        b)
    af;

afs_check ::
  forall a b.
    (Showa a,
      Showa b) => ([Prelude.Char] -> [Prelude.Char]) ->
                    ((a, Nat) -> Af_entry) ->
                      ((Term (Filtered a) b, Term (Filtered a) b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
afs_check r pi g lr =
  let {
    pl = afs_term pi (fst lr);
    pr = afs_term pi (snd lr);
  } in catcha (g (pl, pr))
         (\ x ->
           Inl (shows_string
                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r',
                    'i', 'e', 'n', 't', ' '] .
                 shows_prec_term Zero_nat (fst lr) .
                   shows_string [' '] .
                     r . shows_string [' '] .
                           shows_prec_term Zero_nat (snd lr) .
                             shows_nl .
                               shows_string ['p', 'i', '(', ' '] .
                                 shows_prec_term Zero_nat (fst lr) .
                                   shows_string [' ', ')', ' ', '=', ' '] .
                                     shows_prec_term Zero_nat pl .
                                       shows_nl .
 shows_string ['p', 'i', '(', ' '] .
   shows_prec_term Zero_nat (snd lr) .
     shows_string [' ', ')', ' ', '=', ' '] .
       shows_prec_term Zero_nat pr . shows_nl . x));

af_redtriple ::
  forall a b.
    (Key a, Showa a,
      Showa b) => [((a, Nat), Af_entry)] ->
                    Redtriple_ext (Filtered a) b () -> Redtriple_ext a b ();
af_redtriple pi rp =
  let {
    af = afs_list_to_af pi;
    afs = afs_list_to_afs pi;
  } in Redtriple_ext (bindb (check_wf_afs pi) (\ _ -> valid rp))
         (afs_check (shows_string ['>']) afs (s rp))
         (afs_check (shows_string ['>', '=']) afs (ns rp))
         (afs_check (shows_string ['>', '=']) afs (nst rp)) af
         (\ cs ->
           bindb (check_mono_afs pi) (\ _ -> mono rp (map (afs_rule afs) cs)))
         (shows_string
            ['A', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'F', 'i', 'l', 't',
              'e', 'r', ':', ' '] .
           shows_nl . shows_afs pi . shows_nl . desc rp)
         (\ _ ->
           Inl (shows_prec_list Zero_nat
                 ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'a',
                   'n', 'a', 'l', 'y', 's', 'i', 's', ' ', 'u', 'n', 's', 'u',
                   'p', 'p', 'o', 'r', 't', 'e', 'd']))
         ();

pos_arctic :: Arctic -> Bool;
pos_arctic MinInfty = False;
pos_arctic (Num_arc n) = less_eq_int Zero_int n;

delta_mono :: forall a. (Floor_ceiling a) => a -> Bool;
delta_mono x = less_eq onea x;

vec_pre_gtI :: forall a. (a -> a -> Bool) -> [a] -> [a] -> Bool;
vec_pre_gtI gt v w = any (\ (a, b) -> gt a b) (zip v w);

mat_pre_gtI :: forall a. (a -> a -> Bool) -> [[a]] -> [[a]] -> Bool;
mat_pre_gtI gt m1 m2 = any (\ (a, b) -> vec_pre_gtI gt a b) (zip m1 m2);

mat_gtI ::
  forall a.
    (Non_strict_order a) => (a -> a -> Bool) -> Nat -> [[a]] -> [[a]] -> Bool;
mat_gtI gt sd m1 m2 =
  mat_ge m1 m2 && mat_pre_gtI gt (sub_mat sd sd m1) (sub_mat sd sd m2);

mat_ordered_semiring ::
  forall a b.
    (Ordered_semiring_1 a) => Nat ->
                                Nat ->
                                  (a -> a -> Bool) ->
                                    b -> Partial_object_ext [[a]]
   (Monoid_ext [[a]] (Ring_ext [[a]] (Ordered_semiring_ext [[a]] b)));
mat_ordered_semiring n sd gt b =
  mat_ring n (Ordered_semiring_ext mat_ge (mat_gtI gt sd) (mat_plusI max) b);

mat_monoI :: forall a. (a -> Bool) -> Nat -> [[a]] -> Bool;
mat_monoI geq1 sd m = all (any geq1) (sub_mat sd sd m);

upper_triangular :: forall a. (One a, Zero a, Eq a, Ord a) => [[a]] -> Bool;
upper_triangular [] = True;
upper_triangular ((a : asa) : m) =
  less_eq a onea && all (\ b -> b == zeroa) asa && upper_triangular (map tl m);
upper_triangular ([] : m) = False;

mat_complexity ::
  forall a.
    (Eq a,
      Ordered_semiring_1 a) => Nat ->
                                 [[a]] ->
                                   Sum ([Prelude.Char] -> [Prelude.Char]) Nat;
mat_complexity n m =
  (if upper_triangular m then Inr (minus_nat n (Nat_of_num One))
    else Inl (shows_prec_list Zero_nat
               ['m', 'a', 't', 'r', 'i', 'x', ' ', 'i', 's', ' ', 'n', 'o', 't',
                 ' ', 'u', 'p', 'p', 'e', 'r', ' ', 't', 'r', 'i', 'a', 'n',
                 'g', 'u', 'l', 'a', 'r']));

mat_lpoly_order ::
  forall a.
    (Eq a,
      Ordered_semiring_1 a) => Nat ->
                                 Nat ->
                                   a -> (a -> Bool) ->
  (a -> a -> Bool) ->
    Partial_object_ext [[a]]
      (Monoid_ext [[a]]
        (Ring_ext [[a]]
          (Ordered_semiring_ext [[a]] (Lpoly_order_semiring_ext [[a]] ()))));
mat_lpoly_order n sd def mon gt =
  mat_ordered_semiring n sd gt
    (Lpoly_order_semiring_ext True (mat1I zeroa def n) (\ _ -> True)
      (mat_monoI mon sd) (\ _ -> Zero_nat) (mat_complexity n)
      ['m', 'a', 't', 'r', 'i', 'x', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r',
        'e', 't', 'a', 't', 'i', 'o', 'n']
      ());

int_mono :: Int -> Bool;
int_mono x = less_eq_int (Pos One) x;

delta_gt :: forall a. (Floor_ceiling a) => a -> a -> a -> Bool;
delta_gt delta = (\ x y -> less_eq delta (minus x y));

check_def_pos ::
  forall a. (Zero a, Ord a) => a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_def_pos d =
  check (less zeroa d)
    (shows_prec_list Zero_nat
      ['d', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'v', 'a', 'l', 'u', 'e', ' ',
        'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'p', 'o', 's', 'i', 't', 'i',
        'v', 'e']);

rpo_nstrict_unbounded ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (a -> Nat -> a -> Nat -> (Bool, Bool), a -> Bool) ->
                    (a -> Nat -> Order_tag) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
rpo_nstrict_unbounded pr c =
  (\ (s, t) ->
    check (snd (rpo_unbounded pr c s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term Zero_nat s .
          shows_string [' ', '>', '=', 'R', 'P', 'O', ' '] .
            shows_prec_term Zero_nat t . shows_nl));

rpo_strict_unbounded ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (a -> Nat -> a -> Nat -> (Bool, Bool), a -> Bool) ->
                    (a -> Nat -> Order_tag) ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
rpo_strict_unbounded pr c =
  (\ (s, t) ->
    check (fst (rpo_unbounded pr c s t))
      (shows_string
         ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e',
           'n', 't', ' '] .
        shows_prec_term Zero_nat s .
          shows_string [' ', '>', 'R', 'P', 'O', ' '] .
            shows_prec_term Zero_nat t . shows_nl));

create_RPO_redtriple ::
  forall a b c.
    (Showa a, Eq b, Showa b, Eq c,
      Showa c) => ([((a, Nat), (Nat, Order_tag))] ->
                    (b -> Nat -> Nat, b -> Nat -> Order_tag)) ->
                    [((a, Nat), (Nat, Order_tag))] -> Redtriple_ext b c ();
create_RPO_redtriple prec_repr_to_pr pr =
  let {
    (p, tau) = prec_repr_to_pr pr;
    ns = rpo_nstrict_unbounded (prc_nat p, prl_nat p) tau;
  } in Redtriple_ext (Inr ()) (rpo_strict_unbounded (prc_nat p, prl_nat p) tau)
         ns ns full_af (\ _ -> Inr ()) (shows_rpo_repr pr)
         (\ _ ->
           Inl (shows_prec_list Zero_nat
                 ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'a',
                   'n', 'a', 'l', 'y', 's', 'i', 's', ' ', 'u', 'n', 's', 'u',
                   'p', 'p', 'o', 'r', 't', 'e', 'd']))
         ();

get_redtriple ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b,
      Showa b) => Redtriple_impl a -> Redtriple_ext a b ();
get_redtriple (Int_carrier i) =
  create_poly_redtriple
    (class_lpoly_order (Pos One) int_mono (\ x y -> less_int y x)) (Inr ()) i;
get_redtriple (Int_nl_carrier i) =
  create_nlpoly_redtriple (Inr ()) (Pos One) (\ x y -> less_int y x) True True
    i;
get_redtriple (Rat_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_rat delta_mono (\ x y -> less_rat y x))
    (check_def_pos one_rat) i;
get_redtriple (Rat_nl_carrier d i) =
  create_nlpoly_redtriple (check_def_pos d) d (delta_gt d)
    (less_eq_rat one_rat d) False i;
get_redtriple (Real_carrier i) =
  create_poly_redtriple
    (class_lpoly_order one_real delta_mono (\ x y -> less_real y x))
    (check_def_pos one_real) i;
get_redtriple (Real_nl_carrier d i) =
  create_nlpoly_redtriple (check_def_pos d) d (delta_gt d)
    (less_eq_real one_real d) False i;
get_redtriple (Arctic_carrier i) =
  create_poly_redtriple
    (class_arc_lpoly_order one_arctic pos_arctic (\ x y -> less_arctic y x))
    (Inr ()) i;
get_redtriple (Arctic_rat_carrier i) =
  create_poly_redtriple
    (class_arc_lpoly_order one_arctic_delta pos_arctic_delta
      weak_gt_arctic_delta)
    (Inr ()) i;
get_redtriple (Int_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd (Pos One) int_mono (\ x y -> less_int y x))
    (check_dimensions n sd (Inr ())) i;
get_redtriple (Rat_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_rat delta_mono (\ x y -> less_rat y x))
    (check_dimensions n sd (check_def_pos one_rat)) i;
get_redtriple (Real_mat_carrier n sd i) =
  create_poly_redtriple
    (mat_lpoly_order n sd one_real delta_mono (\ x y -> less_real y x))
    (check_dimensions n sd (check_def_pos one_real)) i;
get_redtriple (Arctic_mat_carrier n i) =
  create_poly_redtriple
    (mat_arc_lpoly_order n one_arctic pos_arctic (\ x y -> less_arctic y x))
    (check_arc_dimension n) i;
get_redtriple (Arctic_rat_mat_carrier n i) =
  create_poly_redtriple
    (mat_arc_lpoly_order n one_arctic_delta pos_arctic_delta
      weak_gt_arctic_delta)
    (check_arc_dimension n) i;
get_redtriple (RPO prec_tau pi) =
  af_redtriple pi
    (create_RPO_redtriple (\ pr -> (prec_repr_to_pr pr, prec_repr_to_status pr))
      prec_tau);
get_redtriple (KBO precw pi) =
  af_redtriple pi
    (create_KBO_redtriple (filter_prec_weight_repr (afs_list_to_afs pi)) precw);

list_ext_name :: List_order_type -> [Prelude.Char];
list_ext_name MS_Ext = ['M', 'S'];
list_ext_name Dms_Ext = ['D', 'M', 'S'];
list_ext_name Min_Ext = ['M', 'I', 'N'];
list_ext_name Max_Ext = ['M', 'A', 'X'];

lifta :: (Bool, Bool) -> (Bool, Bool);
lifta (uu, b) = (b, b);

or2 :: (Bool, Bool) -> (Bool, Bool) -> (Bool, Bool);
or2 (b1, b2) (b3, b4) = (b1 || b3, b2 || b4);

mul_ext_impl ::
  forall a. (Eq a) => (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
mul_ext_impl f [] [] = (False, True);
mul_ext_impl f [] (v : va) = (False, False);
mul_ext_impl f (v : va) [] = (True, True);
mul_ext_impl f (v : va) (y : ys) = ex_dominating f y (v : va) (v : va) ys;

ex_dominating ::
  forall a.
    (Eq a) => (a -> a -> (Bool, Bool)) ->
                a -> [a] -> [a] -> [a] -> (Bool, Bool);
ex_dominating f y [] uw ux = (False, False);
ex_dominating f y (b : bs) xs ys =
  (case f b y of {
    (True, ns) ->
      or2 (lifta
            (mul_ext_impl f (remove1 b xs)
              (filter (\ ya -> not (fst (f b ya))) ys)))
        (ex_dominating f y bs xs ys);
    (False, True) ->
      or2 (mul_ext_impl f (remove1 b xs) ys) (ex_dominating f y bs xs ys);
    (False, False) -> ex_dominating f y bs xs ys;
  });

dms_preprocess :: [[(Nat, (Bool, Bool))]] -> [[(Nat, (Bool, Bool))]];
dms_preprocess p = map (filter (\ (_, (a, b)) -> a || b)) p;

dms_simplify ::
  Bool -> [Nat] -> [[(Nat, (Bool, Bool))]] -> [[(Nat, (Bool, Bool))]];
dms_simplify stri is p = (if any (\ i -> null (nth p i)) is then [[]] else p);

dms_decide_singletons :: Bool -> Nat -> [(Nat, (Bool, Bool))] -> Bool;
dms_decide_singletons stri n p =
  all_interval_nat
    (\ i ->
      let {
        (j, (s, ns)) = nth p i;
      } in s && not (membera (drop (plus_nat i (Nat_of_num One)) p)
                      (j, (False, True))) ||
             ns && not (membera (map fst (drop (plus_nat i (Nat_of_num One)) p))
                         j))
    Zero_nat (size_list p) &&
    (if stri
      then not (all_interval_nat
                 (not . (\ j -> not (membera p (j, (False, True))))) Zero_nat n)
      else True);

dms_select :: Bool -> [[(Nat, (Bool, Bool))]] -> Nat;
dms_select stri p =
  snd (hd (sort_key fst
            (filter (\ (l, _) -> less_nat (Nat_of_num One) l)
              (zip (map size_list p) (upt Zero_nat (size_list p))))));

dms_solve_or_select :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Sum Bool Nat;
dms_solve_or_select stri n p =
  (if all (\ jsns -> less_eq_nat (size_list jsns) (Nat_of_num One)) p
    then Inl (if membera p [] then False
               else dms_decide_singletons stri n (map hd p))
    else Inr (dms_select stri p));

dms_solve :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_solve stri n p =
  (case dms_solve_or_select stri n p of {
    Inl res -> res;
    Inr k ->
      let {
        ksns = nth p k;
      } in dms_solve stri n
             (dms_simplify stri [k] (list_update p k [hd ksns])) ||
             dms_solve stri n
               (dms_simplify stri [k] (list_update p k (tl ksns)));
  });

dms_bool_ex_idx_impl :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_bool_ex_idx_impl stri n p =
  dms_solve stri n
    (dms_simplify stri (upt Zero_nat (size_list p)) (dms_preprocess p));

dms_bool_ex_idx :: Bool -> Nat -> [[(Nat, (Bool, Bool))]] -> Bool;
dms_bool_ex_idx = dms_bool_ex_idx_impl;

dms_convert ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> [[(Nat, (Bool, Bool))]];
dms_convert f asa bs =
  let {
    jbs = zip (upt Zero_nat (size_list bs)) bs;
  } in map (\ a -> map (\ (j, b) -> (j, f a b)) jbs) asa;

dms_order_ext ::
  forall a. Nat -> (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
dms_order_ext n f asa bs =
  let {
    p = dms_convert f asa bs;
    lts = size_list bs;
    len = less_eq_nat lts n || equal_nat (size_list asa) lts;
  } in (len && dms_bool_ex_idx True lts p, len && dms_bool_ex_idx False lts p);

min_set_ext :: forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
min_set_ext s_ns =
  (\ asa bs ->
    (not (null bs) && all (\ a -> any (\ b -> fst (s_ns a b)) bs) asa,
      all (\ a -> any (\ b -> snd (s_ns a b)) bs) asa));

list_ext ::
  forall a.
    (Eq a) => Nat ->
                List_order_type ->
                  (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
list_ext uu MS_Ext = mul_ext_impl;
list_ext uv Max_Ext = set_ext;
list_ext uw Min_Ext = min_set_ext;
list_ext n Dms_Ext = dms_order_ext n;

label_s_ns_impl ::
  forall a b.
    (Showa a,
      Showa b) => ((Term a b, Term a b) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                    ((Term a b, Term a b) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      (Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool);
label_s_ns_impl cS cNS s t =
  let {
    (sa, i) = s;
    (ta, j) = t;
  } in (if isOK (cS (sa, ta)) then (True, True)
         else (if isOK (cNS (sa, ta)) then (less_nat j i, less_eq_nat j i)
                else (False, False)));

nST_label_mul_impl ::
  forall a b.
    (Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    ((a, Nat) -> [(Nat, Nat)]) ->
                      ((Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        ((Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Term a b, Term a b) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
nST_label_mul_impl list_ext af cS cNS st =
  (case st of {
    (Var _, b) ->
      Inl (shows_prec_list Zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list Zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun f ss, Var _) ->
      Inl (shows_prec_list Zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list Zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun f ss, Fun g ts) ->
      check (snd (list_ext (label_s_ns_impl cS cNS) (lterms af (Fun f ss))
                   (lterms af (Fun g ts))))
        (shows_prec_list Zero_nat
           ['c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e', 'n', 't',
             ' ', 'p', 'a', 'i', 'r', ' '] .
          shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
            [' ', '-', '>', ' '] st .
            shows_prec_list Zero_nat [' ', 'w', 'e', 'a', 'k', 'l', 'y', ':'] .
              shows_nl .
                shows_prec_list Zero_nat (lterms af (Fun f ss)) .
                  shows_prec_list Zero_nat [' ', '>', '=', 'm', 'u', ' '] .
                    shows_prec_list Zero_nat (lterms af (Fun g ts)) .
                      shows_prec_list Zero_nat
                        [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                          'b', 'e', ' ', 'e', 'n', 's', 'u', 'r', 'e', 'd']);
  });

s_label_mul_impl ::
  forall a b.
    (Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    ((a, Nat) -> [(Nat, Nat)]) ->
                      ((Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        ((Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (Term a b, Term a b) ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
s_label_mul_impl list_ext af cS cNS st =
  (case st of {
    (Var _, b) ->
      Inl (shows_prec_list Zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list Zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun f ss, Var _) ->
      Inl (shows_prec_list Zero_nat
             ['r', 'o', 'o', 't', 's', ' ', 'o', 'f', ' '] .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
              [' ', '-', '>', ' '] st .
              shows_prec_list Zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'n', 'o', 'n',
                  '-', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']);
    (Fun f ss, Fun g ts) ->
      check (fst (list_ext (label_s_ns_impl cS cNS) (lterms af (Fun f ss))
                   (lterms af (Fun g ts))))
        (shows_prec_list Zero_nat
           ['c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'r', 'i', 'e', 'n', 't',
             ' ', 'p', 'a', 'i', 'r', ' '] .
          shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
            [' ', '-', '>', ' '] st .
            shows_prec_list Zero_nat
              [' ', 's', 't', 'r', 'i', 'c', 't', 'l', 'y', ':'] .
              shows_nl .
                shows_prec_list Zero_nat (lterms af (Fun f ss)) .
                  shows_prec_list Zero_nat [' ', '>', 'm', 'u', ' '] .
                    shows_prec_list Zero_nat (lterms af (Fun g ts)) .
                      shows_prec_list Zero_nat
                        [' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                          'b', 'e', ' ', 'e', 'n', 's', 'u', 'r', 'e', 'd']);
  });

generate_scnp_rp ::
  forall a b c.
    (Key a, Showa a,
      Showa b) => (((Term a b, Nat) -> (Term a b, Nat) -> (Bool, Bool)) ->
                    [(Term a b, Nat)] -> [(Term a b, Nat)] -> (Bool, Bool)) ->
                    [Prelude.Char] ->
                      [((a, Nat), [(Nat, Nat)])] ->
                        (c -> Redtriple_ext a b ()) ->
                          c -> Root_redtriple_ext a b ();
generate_scnp_rp list_ext list_ext_name afa rti x =
  let {
    rt = rti x;
    afaa = fun_of_map (ceta_map_of afa) [];
    pi = af rt;
    cS = s rt;
    cNS = ns rt;
  } in Root_redtriple_ext (valid rt) (s_label_mul_impl list_ext afaa cS cNS)
         (ns rt) (nST_label_mul_impl list_ext afaa cS cNS) pi
         (scnp_af_to_af afaa pi) (scnp_desc afa list_ext_name . desc rt) ();

get_root_redtriple ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b,
      Showa b) => Root_redtriple_impl a -> Root_redtriple_ext a b ();
get_root_redtriple (SCNP typea af rp) =
  generate_scnp_rp (list_ext (scnp_arity af) typea) (list_ext_name typea) af
    get_redtriple rp;

faulty_non_inf_order ::
  forall a b c.
    (Showa b, Showa c) => [Prelude.Char] -> a -> Non_inf_order_ext b c ();
faulty_non_inf_order s f =
  Non_inf_order_ext (Inl (shows_string s)) (\ _ -> Inr ()) (\ _ -> Inr ())
    (\ _ _ -> Wild) id ();

check_non_inf_poly_inter_list ::
  forall a b.
    (Eq a, Eq b,
      Poly_carrier b) => Bool ->
                           [(a, Nat)] ->
                             [((a, Nat), [([(Nat, Nat)], b)])] ->
                               Sum (a, [([(Nat, Nat)], b)]) ();
check_non_inf_poly_inter_list discrete f i =
  catcha
    (catcha
      (forallM
        (\ x ->
          (if let {
                (_, a) = x;
              } in check_poly_weak_mono_and_pos discrete a
            then Inr () else Inl x))
        (filter (\ (fn, _) -> membera f fn) i))
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (let {
             (a, b) = x;
           } in let {
                  (fa, _) = a;
                } in (\ aa -> (fa, aa))
                  b));

create_nlpoly_non_inf_order ::
  forall a b c.
    (Eq a, Poly_carrier a, Showa a, Eq b, Key b, Showa b, Eq c,
      Showa c) => Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                    a -> (a -> a -> Bool) ->
                           Bool ->
                             Bool ->
                               (a -> [a]) ->
                                 [((b, Nat), [([(Nat, Nat)], a)])] ->
                                   [(b, Nat)] -> Non_inf_order_ext b c ();
create_nlpoly_non_inf_order cI def gt power_mono discrete sqrt i f =
  let {
    j = poly_inter_list_to_inter def i;
    x = poly_subst
          (\ n -> poly_of (PVar (['x', '_'] ++ shows_prec_nat Zero_nat n [])));
  } in Non_inf_order_ext
         (bindb cI
           (\ _ ->
             catcha (check_non_inf_poly_inter_list discrete f i)
               (\ xa ->
                 Inl (let {
                        (fa, p) = xa;
                      } in shows_string
                             ['i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a',
                               't', 'i', 'o', 'n', ' '] .
                             shows_poly (x p) .
                               shows_string [' ', 'o', 'f', ' '] .
                                 shows_prec Zero_nat fa .
                                   shows_string
                                     [' ', 'i', 'n', 'v', 'a', 'l', 'i', 'd',
                                       ' ']))))
         (check_ns j) (check_cc sqrt gt j) (create_dep discrete def i)
         (shows_string
            ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l', ' ', 'i', 'n',
              't', 'e', 'r', 'p', 'r', 'e', 't', 'a', 't', 'i', 'o', 'n'] .
           shows_nl .
             shows_sep
               (\ (a, b) ->
                 let {
                   (fa, n) = a;
                 } in (\ p ->
                        shows_string ['P', 'o', 'l', '('] .
                          shows_prec Zero_nat fa .
                            shows_string ['/'] .
                              shows_prec_nat Zero_nat n .
                                shows_string [')', ' ', '=', ' '] .
                                  shows_poly (x p))
                   b)
               shows_nl i)
         ();

sqrt_rat :: Rat -> [Rat];
sqrt_rat x =
  let {
    (z, n) = quotient_of x;
  } in (case sqrt_int n of {
         [] -> [];
         sn : _ ->
           map (\ sz -> divide_rat (of_int sz) (of_int sn)) (sqrt_int z);
       });

get_non_inf_order ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b,
      Showa b) => Redtriple_impl a -> [(a, Nat)] -> Non_inf_order_ext a b ();
get_non_inf_order (Int_nl_carrier i) =
  create_nlpoly_non_inf_order (Inr ()) (Pos One) (\ x y -> less_int y x) True
    True sqrt_int i;
get_non_inf_order (Rat_nl_carrier d i) =
  create_nlpoly_non_inf_order (check_def_pos d) d (delta_gt d)
    (less_eq_rat one_rat d) False sqrt_rat i;
get_non_inf_order (Real_nl_carrier d i) =
  create_nlpoly_non_inf_order (check_def_pos d) d (delta_gt d)
    (less_eq_real one_real d) False sqrt_real i;
get_non_inf_order (Int_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Rat_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Real_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_rat_carrier v) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Int_mat_carrier v va vb) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Rat_mat_carrier v va vb) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Real_mat_carrier v va vb) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_mat_carrier v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (Arctic_rat_mat_carrier v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (RPO v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];
get_non_inf_order (KBO v va) =
  faulty_non_inf_order
    ['o', 'n', 'l', 'y', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', 's', ',', ' ',
      'r', 'a', 't', 'i', 'o', 'n', 'a', 'l', 's', ' ', 'a', 'n', 'd', ' ', 'r',
      'e', 'a', 'l', 's', ' ', 'a', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'o', 'r',
      't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'i', 'n', 'f',
      ' ', 'o', 'r', 'd', 'e', 'r', 's'];

check_strict_one_rstep ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b, Term a b) ->
                      Maybe [(Pos, ((Term a b, Term a b), Term a b))]) ->
                      ((a, Nat) -> Nat) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strict_one_rstep ra rseqm p r =
  let {
    s = proj_term p (fst r);
    t = proj_term p (snd r);
  } in (case rseqm r of {
         Nothing -> check_supt s t;
         Just [] ->
           Inl (shows_string
                 ['m', 'o', 'r', 'e', ' ', 't', 'h', 'a', 'n', ' ', 'a', ' ',
                   's', 'i', 'n', 'g', 'l', 'e', ' ', 'r', 'e', 'w', 'r', 'i',
                   't', 'e', ' ', 's', 't', 'e', 'p', ' ', 'i', 's', ' ', 'n',
                   'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']);
         Just [(pos, (rule, u))] ->
           bindb (check_qrstep (\ _ -> True) False ra pos rule s u)
             (\ _ -> check_supteq u t);
         Just ((pos, (rule, u)) : _ : _) ->
           Inl (shows_string
                 ['m', 'o', 'r', 'e', ' ', 't', 'h', 'a', 'n', ' ', 'a', ' ',
                   's', 'i', 'n', 'g', 'l', 'e', ' ', 'r', 'e', 'w', 'r', 'i',
                   't', 'e', ' ', 's', 't', 'e', 'p', ' ', 'i', 's', ' ', 'n',
                   'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']);
       });

check_rsteps ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), Term a b))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rsteps = check_qrsteps (\ _ -> True) False;

rseq_last ::
  forall a b. Term a b -> [(Pos, ((Term a b, Term a b), Term a b))] -> Term a b;
rseq_last s steps = last (s : map (\ (_, (_, sa)) -> sa) steps);

check_rsteps_last ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      [(Pos, ((Term a b, Term a b), Term a b))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rsteps_last = (\ r s steps -> check_rsteps r steps s (rseq_last s steps));

check_strict_rstep ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    ((Term a b, Term a b) ->
                      Maybe [(Pos, ((Term a b, Term a b), Term a b))]) ->
                      ((a, Nat) -> Nat) ->
                        (Term a b, Term a b) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_strict_rstep ra rseqm p r =
  let {
    s = proj_term p (fst r);
    t = proj_term p (snd r);
  } in (case rseqm r of {
         Nothing -> check_supt s t;
         Just rseq ->
           (if equal_nat (size_list rseq) Zero_nat then check_supt s t
             else bindb (check_rsteps_last ra s rseq)
                    (\ _ -> check_supteq (rseq_last s rseq) t));
       });

create_rseq_map ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => [((Term a b, Term a b),
                   [(Pos, ((Term a b, Term a b), Term a b))])] ->
                  (Term a b, Term a b) ->
                    Maybe [(Pos, ((Term a b, Term a b), Term a b))];
create_rseq_map rseqs = ceta_map_of rseqs;

check_weak ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((a, Nat) -> Nat) ->
                    (Term a b, Term a b) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_weak p r =
  catcha
    (check (equal_term (proj_term p (fst r)) (proj_term p (snd r)))
      (shows_string
         ['t', 'h', 'e', ' ', 'p', 'r', 'o', 'j', 'e', 'c', 't', 'e', 'd', ' ',
           'l', 'h', 's', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'q', 'u',
           'a', 'l', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'j',
           'e', 'c', 't', 'e', 'd', ' ', 'r', 'h', 's'] .
        shows_nl))
    (\ x ->
      Inl (shows_string
             ['C', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'o', 'r', 'i',
               'e', 'n', 't', ' ', 'r', 'u', 'l', 'e', ' '] .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
              [' ', '-', '>', ' '] r .
              shows_string [',', ' ', 's', 'i', 'n', 'c', 'e'] .
                shows_nl .
                  shows_prec_term Zero_nat (proj_term p (fst r)) .
                    shows_string [' ', '!', '=', ' '] .
                      shows_prec_term Zero_nat (proj_term p (snd r)) .
                        shows_nl . x));

subterm_criterion_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Corder c, Eq c, Key c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    ProjL b ->
                      [((Term b c, Term b c),
                         [(Pos, ((Term b c, Term b c), Term b c))])] ->
                        [(Term b c, Term b c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
subterm_criterion_proc i pL rseqmL prm dpp =
  (case let {
          p = create_proj pL;
          rseqm = create_rseq_map rseqmL;
          pa = pairsa i dpp;
          _ = nfsc i dpp;
          r = rulesd i dpp;
          pb = snd (split_pairsa i dpp prm);
          wfR = wf_rules_impl r;
        } in bindb (catcha
                     (forallM
                       (\ (l, ra) ->
                         bindb (check_no_var l)
                           (\ _ ->
                             bindb (check_no_var ra)
                               (\ _ ->
                                 check_no_defined_root
                                   (\ fn -> not (null (rules_mapb i dpp fn)))
                                   ra)))
                       pa)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check (minimal i dpp || nFQ_subset_NF_rulesb i dpp)
                         (shows_prec_list Zero_nat
                           ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                             ' ', 'o', 'r', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                             'o', 's', 't', ' ', 'r', 'e', 'q', 'u', 'i', 'r',
                             'e', 'd']))
                   (\ _ ->
                     bindb (catcha (forallM (\ (l, _) -> check_no_var l) r)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (if q_emptyc i dpp
                                 then catcha
(forallM (check_strict_rstep r rseqm p) prm) (\ x -> Inl (snd x))
                                 else catcha
(forallM (check_strict_one_rstep wfR rseqm p) prm) (\ x -> Inl (snd x)))
                           (\ _ ->
                             catcha (forallM (check_weak p) pb)
                               (\ x -> Inl (snd x))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_P_Pwa i dpp prm prm);
  });

replace_paira ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      a -> (Term b c, Term b c) -> [(Term b c, Term b c)] -> a;
replace_paira
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = replace_pair;

forward_instantiation_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        Maybe [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
forward_instantiation_proc i st sts u_opt dpp =
  (case let {
          isnf = is_QNFc i dpp;
          (s, t) = st;
          iedg = is_iedg_edge_dpp i dpp (s, t);
          sy = map_vars (\ a -> 'y' : a) s;
          ty = map_vars (\ a -> 'y' : a) t;
          u = (case u_opt of {
                Nothing -> rulesd i dpp;
                Just u -> u;
              });
        } in bindb (if is_none u_opt then Inr ()
                     else let {
                            urc = is_ur_closed_impl_dpp_mv i dpp u;
                            check_urc =
                              (\ sa ta ->
                                check (urc sa ta)
                                  (shows_prec_list Zero_nat
                                     ['t', 'e', 'r', 'm', ' '] .
                                    shows_prec_term Zero_nat ta .
                                      shows_prec_list Zero_nat
[' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'u',
  'n', 'd', 'e', 'r', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
  'e', 's']));
                          } in bindb (check (nfsc i dpp || minimal i dpp)
                                       (shows_prec_list Zero_nat
 ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y', ' ', 'o', 'r', ' ', 'n',
   'o', 'r', 'm', 'a', 'l', ' ', 's', 'u', 'b', 's', 't', ' ', 'r', 'e', 'q',
   'u', 'i', 'r', 'e', 'd']))
                                 (\ _ ->
                                   bindb (check (nFQ_subset_NF_rulesb i dpp)
   (shows_prec_list Zero_nat
     ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e', 'w', 'r', 'i',
       't', 'i', 'n', 'g', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                                     (\ _ ->
                                       bindb
 (catcha (forallM (\ (l, a) -> check_urc (args l) a) u) (\ x -> Inl (snd x)))
 (\ _ ->
   bindb (check_urc [s] t)
     (\ _ ->
       (if nfsc i dpp then Inr ()
         else catcha (check_subseteq (vars_term_list t) (vars_term_list s))
                (\ _ ->
                  Inl (shows_prec_list Zero_nat
                        ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'c', 'o',
                          'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ',
                          'p', 'a', 'i', 'r', ' ', 'v', 'i', 'o', 'l', 'a', 't',
                          'e', 'd']))))))))
               (\ _ ->
                 let {
                   ur = map (\ (l, r) -> (r, l)) u;
                   ic = icap_impla ur [] [];
                 } in catcha
                        (forallM
                          (\ (ua, v) ->
                            (case mgu_class (ic ua) t of {
                              Nothing -> Inr ();
                              Just mu ->
                                check (not (isnf (subst_apply_term sy mu)) ||
(not (isnf (subst_apply_term (map_vars (\ a -> 'x' : a) ua) mu)) ||
  any (\ sta ->
        instance_rule sta st &&
          instance_rule (subst_apply_term sy mu, subst_apply_term ty mu) sta)
    sts))
                                  (shows_prec_list Zero_nat
                                     ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                       't', ' ', 'f', 'i', 'n', 'd', ' ', 'i',
                                       'n', 's', 't', 'a', 'n', 'c', 'e', ' ',
                                       'o', 'f', ' ', 'p', 'a', 'i', 'r', ' '] .
                                    shows_rule (shows_prec Zero_nat)
                                      (shows_prec_list Zero_nat)
                                      [' ', '-', '>', ' ']
                                      (subst_apply_term sy mu,
subst_apply_term ty mu) .
                                      shows_nl .
shows_prec_list Zero_nat
  ['w', 'h', 'i', 'c', 'h', ' ', 'r', 'e', 's', 'u', 'l', 't', 'e', 'd', ' ',
    'f', 'r', 'o', 'm', ' ', 'D', 'P', ' '] .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
    [' ', '-', '>', ' '] (ua, v));
                            }))
                          (filter (\ (ua, _) -> iedg ua) (pairsa i dpp)))
                        (\ x -> Inl (snd x)))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

check_join ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Term a b ->
                      [(Pos, ((Term a b, Term a b), Term a b))] ->
                        Term a b ->
                          [(Pos, ((Term a b, Term a b), Term a b))] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join r s sseq t tseq =
  let {
    chk = check_rsteps_last r;
  } in bindb (chk s sseq)
         (\ _ ->
           bindb (chk t tseq)
             (\ _ ->
               let {
                 u = rseq_last s sseq;
                 v = rseq_last t tseq;
               } in check (equal_term u v)
                      (shows_prec_list Zero_nat
                         ['t', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
                           ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 's',
                           ' ', 'e', 'n', 'd', ' ', 'i', 'n', ' ', 'd', 'i',
                           'f', 'f', 'e', 'r', 'e', 'n', 't', ' ', 't', 'e',
                           'r', 'm', 's', ' '] .
                        shows_prec_term Zero_nat u .
                          shows_prec_list Zero_nat [' ', 'a', 'n', 'd', ' '] .
                            shows_prec_term Zero_nat v)));

check_critical_pairs_guided ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Bool, (Term a b, Term a b))] ->
                      [(Term a b,
                         ([(Pos, ((Term a b, Term a b), Term a b))],
                           (Term a b,
                             [(Pos, ((Term a b, Term a b), Term a b))])))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_guided r cp joins =
  bindb (catcha
          (forallM (\ (s, (sseq, (a, b))) -> check_join r s sseq a b) joins)
          (\ x -> Inl (snd x)))
    (\ _ ->
      let {
        cpa = map (\ (s, (_, (t, _))) -> (s, t)) joins;
      } in catcha
             (forallM
               (\ (_, (s, t)) ->
                 check (equal_term s t ||
                         any (\ st ->
                               instance_rule (s, t) st ||
                                 instance_rule (t, s) st)
                           cpa)
                   (shows_prec_list Zero_nat
                      ['c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'a',
                        'i', 'r', ' '] .
                     show_crit_pair (s, t) .
                       shows_prec_list Zero_nat
                         [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']))
               cp)
             (\ x -> Inl (snd x)));

iterative_join_search_main ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Nat -> Nat -> Bool;
iterative_join_search_main r s t i n =
  (if less_eq_nat i n
    then not (null (list_inter (reachable_terms r s i)
                     (reachable_terms r t i))) ||
           iterative_join_search_main r s t (plus_nat i (Nat_of_num One)) n
    else False);

iterative_join_search ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b -> Term a b -> Nat -> Bool;
iterative_join_search r s t n = iterative_join_search_main r s t Zero_nat n;

check_join_BFS_limit ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => Nat ->
                    [(Term a b, Term a b)] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_join_BFS_limit n r s t =
  check (iterative_join_search r s t n)
    (shows_prec_list Zero_nat
       ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
         ' ', 'a', ' ', 'j', 'o', 'i', 'n', 'i', 'n', 'g', ' ', 's', 'e', 'q',
         'u', 'e', 'n', 'c', 'e', ' ', 'o', 'f', ' ', 'l', 'e', 'n', 'g', 't',
         'h', ' ', 'a', 't', ' ', 'm', 'o', 's', 't', ' '] .
      shows_prec_nat Zero_nat n .
        shows_prec_list Zero_nat
          [' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm', 's',
            ' '] .
          shows_prec_term Zero_nat s .
            shows_prec_list Zero_nat [' ', 'a', 'n', 'd', ' '] .
              shows_prec_term Zero_nat t . shows_nl);

check_critical_pairs_BFS ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => Nat ->
                    [(Term a b, Term a b)] ->
                      [(Bool, (Term a b, Term a b))] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_BFS n r cp =
  catcha
    (forallM
      (\ (_, (s, t)) ->
        (if equal_term s t then Inr ()
          else catcha (check_join_BFS_limit n r s t)
                 (\ x ->
                   Inl (shows_prec_list Zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h',
                            'e', 'n', ' ', 'j', 'o', 'i', 'n', 'i', 'n', 'g',
                            ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ',
                            'p', 'a', 'i', 'r', ' '] .
                         show_crit_pair (s, t) . shows_nl . x))))
      cp)
    (\ x -> Inl (snd x));

check_critical_pairs_NF ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Bool, (Term a b, Term a b))] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs_NF r cp =
  catcha
    (forallM
      (\ (_, (s, t)) ->
        (if equal_term s t then Inr ()
          else catcha (check_join_NF r s t)
                 (\ x ->
                   Inl (shows_prec_list Zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h',
                            'e', 'n', ' ', 'j', 'o', 'i', 'n', 'i', 'n', 'g',
                            ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', ' ',
                            'p', 'a', 'i', 'r', ' '] .
                         show_crit_pair (s, t) . shows_nl . x))))
      cp)
    (\ x -> Inl (snd x));

check_critical_pairs ::
  forall a.
    (Eq a,
      Showa a) => [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [(Bool, (Term a [Prelude.Char], Term a [Prelude.Char]))] ->
                      Join_info a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_critical_pairs r cp join_info =
  (case join_info of {
    Guided a -> check_critical_pairs_guided r cp a;
    Join_NF -> check_critical_pairs_NF r cp;
    Join_BFS n -> check_critical_pairs_BFS n r cp;
  });

switch_innermost_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_innermost_proc i joins_i dpp =
  let {
    r = rwc i dpp;
    p = pa i dpp;
    pw = pwa i dpp;
    nfs = nfsc i dpp;
  } in (case bindb (catcha
                     (forallM
                       (\ (l, _) ->
                         check (not (is_Var l))
                           (shows_prec_list Zero_nat
                             ['l', 'e', 'f', 't', ' ', 'v', 'a', 'r', 'i', 'a',
                               'b', 'l', 'e', 's', ' ', 'i', 'n', ' ', 'R', ' ',
                               'f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n']))
                       (if nfs then r else []))
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check (minimal i dpp)
                         (shows_prec_list Zero_nat
                           ['m', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                             ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                   (\ _ ->
                     bindb (check (null (qc i dpp))
                             (shows_prec_list Zero_nat
                               ['n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y',
                                 ' ', 'Q', ' ', 'n', 'o', 't', ' ', 'y', 'e',
                                 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
                                 'e', 'd']))
                       (\ _ ->
                         bindb (check (null (rc i dpp))
                                 (shows_prec_list Zero_nat
                                   ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u',
                                     'l', 'e', 's', ' ', 'n', 'o', 't', ' ',
                                     'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                           (\ _ ->
                             bindb (check
                                     (null (critical_pairs_impl (p ++ pw) r))
                                     (shows_prec_list Zero_nat
                                       ['o', 'v', 'e', 'r', 'l', 'a', 'p', 's',
 ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', 'P', ' ', 'a', 'n', 'd', ' ', 'R',
 ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                               (\ _ ->
                                 check_critical_pairs r
                                   (critical_pairs_impl r r) joins_i)))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs True p pw (map fst r) [] r);
       });

mk_dpp ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      (Bool,
        (Bool,
          ([(Term b c, Term b c)],
            ([(Term b c, Term b c)],
              ([Term b c],
                ([(Term b c, Term b c)], [(Term b c, Term b c)])))))) ->
        a;
mk_dpp i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkc i nfs m p pw q r rw;

check_assm ::
  forall a b c d e f g.
    (Countable b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      (a -> d -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (c -> e -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (([(Ctxt (Lab b [Nat]) [Prelude.Char],
                               (Term (Lab b [Nat]) [Prelude.Char], Location))],
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])]) ->
                            f -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([Prelude.Char] ->
                              g -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              Generic_assm_proof b [Nat] [Prelude.Char] d e f ()
                                g ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assm j i tp_check dp_check fptp_check unk_check (SN_assm_proof t prf) =
  tp_check (mk_tp j t) prf;
check_assm j i tp_check dp_check fptp_check unk_check (Finite_assm_proof t prf)
  = dp_check (mk_dpp i t) prf;
check_assm j i tp_check dp_check fptp_check unk_check (Unknown_assm_proof t prf)
  = unk_check t prf;
check_assm j i tp_check dp_check fptp_check unk_check (SN_FP_assm_proof t prf) =
  fptp_check t prf;
check_assm j i uu uv uw ux (Not_SN_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm j i uu uv uw ux (Infinite_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm j i uu uv uw ux (Not_RelSN_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assm j i uu uv uw ux (Not_SN_FP_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
          'o', 'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's',
          ' ', 'i', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);

quasi_splitter ::
  forall a b c.
    (Eq a,
      Eq c) => (a -> (a, b)) ->
                 [(Term a c, Term a c)] ->
                   [(Term a c, Term a c)] ->
                     ([(Term a c, Term a c)],
                       ([(Term a c, Term a c)], [(Term a c, Term a c)]));
quasi_splitter ld lAll uRw =
  let {
    unlab = (\ lf -> fst (ld lf));
    la = map (\ r -> (r, map_rule unlab r)) lAll;
    (d, nD) =
      partition
        (\ (r, ur) ->
          equal_term (fst ur) (snd ur) && not (equal_term (fst r) (snd r)))
        la;
    (rw, r) = partition (\ (_, a) -> membera uRw a) nD;
  } in (map fst r, (map fst rw, map fst d));

model_splitter ::
  forall a b c.
    (Eq a,
      Eq c) => (a -> (a, b)) ->
                 [(Term a c, Term a c)] ->
                   [(Term a c, Term a c)] ->
                     ([(Term a c, Term a c)],
                       ([(Term a c, Term a c)], [(Term a c, Term a c)]));
model_splitter ld lAll uRw =
  let {
    unlab = (\ lf -> fst (ld lf));
    la = map (\ r -> (r, map_rule unlab r)) lAll;
    (rw, r) = partition (\ (_, a) -> membera uRw a) la;
  } in (map fst r, (map fst rw, []));

check_sl_Q ::
  forall a b c.
    (Eq a, Showa a, Corder c, Eq c, Mapping_impl c,
      Showa c) => (a -> (a, b)) ->
                    [Term a c] ->
                      [Term a c] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_Q ld lQ q =
  let {
    u = (\ l -> fst (ld l));
  } in catcha
         (forallM
           (\ lq ->
             check (let {
                      mlq = map_term u lq;
                    } in any (\ qa -> matches mlq qa && matches qa mlq) q)
               (shows_prec_list Zero_nat
                  ['u', 'n', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ' '] .
                 shows_term (shows_prec Zero_nat) (shows_prec Zero_nat) lq .
                   shows_prec_list Zero_nat
                     [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 'a', ' ', 't',
                       'e', 'r', 'm', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ',
                       'Q']))
           lQ)
         (\ x -> Inl (snd x));

sem_lab_quasi_root_proc ::
  forall a b c d.
    (Eq a, Showa a, Ceq d, Corder d, Eq d, Mapping_impl d, Set_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([(Term a d, Term a d)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          ([(Term a d, Term a d)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([Term a d] ->
                              [Term a d] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              ([(Term a d, Term a d)] ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                ([(Term a d, Term a d)] ->
                                  [(Term a d, Term a d)] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char])
                                      ()) ->
                                  ([(Term a d, Term a d)] ->
                                    [(Term a d, Term a d)] ->
                                      Sum ([Prelude.Char] -> [Prelude.Char])
()) ->
                                    [(Term a d, Term a d)] ->
                                      [Term a d] ->
[(Term a d, Term a d)] -> c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_quasi_root_proc ld i valid check_decra check_decr check_lhss_more
  check_lab_all check_lab_all_trs check_model_lab lPAll lQ lRAll dpp =
  let {
    r = rc i dpp;
    rw = rwc i dpp;
    pw = pwa i dpp;
    p = pa i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll pw;
    (lR, (lRw, d)) = quasi_splitter ld lRAll rw;
    qempty = q_emptyc i dpp;
  } in (case bindb valid
               (\ _ ->
                 bindb (check
                         (if nfs
                           then (if not qempty then wwf_rulesa i dpp else True)
                           else True)
                         (shows_prec_list Zero_nat
                           ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e',
                             'd', 'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u',
                             'i', 'r', 'e', 'd']))
                   (\ _ ->
                     bindb (catcha
                             (forallM
                               (\ (l, ra) ->
                                 bindb (check_no_var l)
                                   (\ _ ->
                                     bindb (check_no_var ra)
                                       (\ _ ->
 check_no_defined_root (\ fn -> not (null (rules_mapb i dpp fn))) ra)))
                               (pairsa i dpp))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catcha
                                 (forallM (\ (l, _) -> check_no_var l)
                                   (rulesd i dpp))
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             let {
                               q = qc i dpp;
                             } in bindb (if nfs && not qempty
  then check_wf_trs d else Inr ())
                                    (\ _ ->
                                      bindb (check_decra d)
(\ _ ->
  bindb (check_decr d)
    (\ _ ->
      bindb (catcha
              (forallM
                (\ qa ->
                  check (linear_term qa)
                    (shows_prec_list Zero_nat
                      ['Q', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                        'c', 'o', 'n', 't', 'a', 'i', 'n', ' ', 'n', 'o', 'n',
                        '-', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 't', 'e', 'r',
                        'm', 's']))
                q)
              (\ x -> Inl (snd x)))
        (\ _ ->
          catcha
            (bindb (check_lhss_more lQ q)
              (\ _ ->
                bindb (check_sl_Q ld lQ q)
                  (\ _ ->
                    bindb (check_lab_all lP p)
                      (\ _ ->
                        bindb (check_lab_all lPw pw)
                          (\ _ ->
                            bindb (check_model_lab lR r)
                              (\ _ ->
                                bindb (check_model_lab lRw rw)
                                  (\ _ ->
                                    bindb (check_lab_all_trs lR r)
                                      (\ _ -> check_lab_all_trs lRw rw))))))))
            (\ x ->
              Inl (shows_string
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'd', 'u', 'r',
                       'i', 'n', 'g', ' ', 'l', 'a', 'b', 'e', 'l', 'i', 'n',
                       'g', ':'] .
                    shows_nl . x))))))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs m lP lPw lQ lR (lRw ++ d));
       });

eval_lab ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> Nat -> c -> d) -> (e -> b) -> Term a e -> (b, Term d e);
eval_lab i l lc alpha (Var x) = (alpha x, Var x);
eval_lab i l lc alpha (Fun f ts) =
  let {
    clts = map (eval_lab i l lc alpha) ts;
    cs = map fst clts;
    c = i f cs;
    lts = map snd clts;
  } in (c, Fun (lc f (size_list ts) (l f cs)) lts);

check_sl_rule_ass ::
  forall a b c d e.
    (Showa a, Showa b, Eq d, Linorder d, Showa d, Eq e, Linorder e,
      Showa e) => Bool ->
                    (a -> [b] -> b) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          (b -> b -> Bool) ->
                            Set (Term d e, Term d e) ->
                              (e -> b) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_ass mc i la lc cge lR alpha (l, r) =
  let {
    cl_ll = eval_lab i la lc alpha l;
    cr_lr = eval_lab i la lc alpha r;
  } in bindb (check (if mc then cge (fst cl_ll) (fst cr_lr) else True)
               (shows_string ['r', 'u', 'l', 'e', ' '] .
                 shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                   [' ', '-', '>', ' '] (l, r) .
                   shows_string
                     [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 't',
                       'h', 'e', ' ', 'm', 'o', 'd', 'e', 'l', ' ', 'c', 'o',
                       'n', 'd', 'i', 't', 'i', 'o', 'n', ',', ' ', '[', 'l',
                       'h', 's', ']', ' ', '=', ' '] .
                     shows_prec Zero_nat (fst cl_ll) .
                       shows_string
                         [',', ' ', '[', 'r', 'h', 's', ']', ' ', '=', ' '] .
                         shows_prec Zero_nat (fst cr_lr)))
         (\ _ ->
           check (member (snd cl_ll, snd cr_lr) lR)
             (shows_string
                ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                  ' '] .
               shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                 [' ', '-', '>', ' '] (snd cl_ll, snd cr_lr) .
                 shows_string [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']));

check_sl_rule ::
  forall a b c d e.
    (Showa a, Showa b, Eq d, Linorder d, Showa d, Eq e, Linorder e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> d) ->
                        [b] ->
                          (b -> b -> Bool) ->
                            Bool ->
                              Set (Term d e, Term d e) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule i l lc c cge mc lR lr =
  catcha
    (forallM (\ alpha -> check_sl_rule_ass mc i l lc cge lR alpha lr)
      (map fun_of (enum_vectors c (vars_rule_list lr))))
    (\ x -> Inl (snd x));

check_sl_model_lab_trs_set ::
  forall a b c d.
    (Eq a, Linorder a, Showa a, Showa b, Eq d, Linorder d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_model_lab_trs_set i l c cge label lR r =
  catcha (forallM (check_sl_rule i l label c cge True lR) r)
    (\ x -> Inl (snd x));

check_sl_model_lab_trs ::
  forall a b c d.
    (Eq a, Linorder a, Showa a, Showa b, Eq d, Linorder d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            [(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_model_lab_trs i l c cge label lR r =
  check_sl_model_lab_trs_set i l c cge label (set lR) r;

check_NF_vars_subset ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_vars_subset qa q =
  catcha (forallM (\ qaa -> check (any (matches qaa) q) qaa) qa)
    (\ x -> Inl (snd x));

flatten_term_enum :: forall a b. Term [a] b -> [Term a b];
flatten_term_enum (Var x) = [Var x];
flatten_term_enum (Fun fs ts) =
  let {
    lts = map flatten_term_enum ts;
    ss = concat_lists lts;
  } in concatMap (\ f -> map (Fun f) ss) fs;

lab_lhss_more_impl ::
  forall a b c d.
    (a -> Nat -> b -> c) -> (a -> Nat -> [b]) -> [Term a d] -> [Term c d];
lab_lhss_more_impl lc lS_gen q =
  let {
    f_all = (\ (f, n) -> map (lc f n) (lS_gen f n));
  } in concatMap (\ qa -> flatten_term_enum (map_term_wa f_all qa)) q;

check_sl_lab_lhss_more ::
  forall a b c.
    (Eq a, Showa a, Corder c, Eq c, Mapping_impl c,
      Showa c) => (a -> Nat -> b -> a) ->
                    (a -> Nat -> [b]) ->
                      [Term a c] ->
                        [Term a c] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_lhss_more lc lS_gen lQ q =
  catcha (check_NF_vars_subset (lab_lhss_more_impl lc lS_gen q) lQ)
    (\ x ->
      Inl (shows_term (shows_prec Zero_nat) (shows_prec Zero_nat) x .
            shows_prec_list Zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i',
                'n', ' ', 'l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'Q']));

sl_check_decr ::
  forall a b c d e.
    Sl_ops_ext a b c d e ->
      [(Term a d, Term a d)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
sl_check_decr
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_check_decr;

lab_root ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> [b] -> c) ->
          (a -> Nat -> c -> d) -> (e -> b) -> Term a e -> Term d e;
lab_root i la l lc alpha (Fun f ts) =
  let {
    clts = map (eval_lab i la lc alpha) ts;
    cs = map fst clts;
    a = map snd clts;
  } in Fun (lc f (size_list ts) (l f cs)) a;
lab_root uu uv uw ux uy (Var x) = Var x;

check_sl_rule_all_ass ::
  forall a b c d e.
    (Showa a, Showa b, Eq d, Showa d, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          (c -> [c]) ->
                            [(Term d e, Term d e)] ->
                              (e -> b) ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_all_ass i lb la lc gen_smaller lR alpha (l, Fun f ts) =
  let {
    ll = lab_root i lb la lc alpha l;
    clts = map (eval_lab i lb lc alpha) ts;
    lts = map snd clts;
    ld = la f (map fst clts);
    n = size_list ts;
    small = gen_smaller ld;
  } in catcha
         (forallM
           (\ le ->
             check (membera lR (ll, Fun (lc f n le) lts))
               (shows_string
                  ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                    ' '] .
                 shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                   [' ', '-', '>', ' '] (ll, Fun (lc f n le) lts) .
                   shows_string [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']))
           small)
         (\ x -> Inl (snd x));
check_sl_rule_all_ass i lb la lc gen_smaller lR alpha (l, Var x) =
  let {
    ll = lab_root i lb la lc alpha l;
    lr = lab_root i lb la lc alpha (Var x);
  } in check (membera lR (ll, lr))
         (shows_string
            ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e', ' '] .
           shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
             [' ', '-', '>', ' '] (ll, lr) .
             shows_string [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']);

check_sl_rule_all ::
  forall a b c d e.
    (Showa a, Showa b, Eq d, Showa d, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          [b] ->
                            (c -> [c]) ->
                              [(Term d e, Term d e)] ->
                                (Term a e, Term a e) ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_all i la l lc c gen_smaller lR lr =
  catcha
    (forallM
      (\ alpha -> check_sl_rule_all_ass i la l lc gen_smaller lR alpha lr)
      (map fun_of (enum_vectors c (vars_rule_list lr))))
    (\ x -> Inl (snd x));

check_sl_lab_all_trs ::
  forall a b c d e.
    (Showa a, Showa b, Eq d, Showa d, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        [b] ->
                          (c -> [c]) ->
                            (a -> Nat -> c -> d) ->
                              [(Term d e, Term d e)] ->
                                [(Term a e, Term a e)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_all_trs i la l c gen label lP p =
  catcha (forallM (check_sl_rule_all i la l label c gen lP) p)
    (\ x -> Inl (snd x));

check_wf_sym_F_all ::
  forall a b c.
    (Eq c,
      Showa c) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        (c, Nat) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_sym_F_all lc ld ls =
  (\ (lf, n) ->
    let {
      (f, l) = ld lf;
    } in check (ls f n l && lf == lc f n l)
           (shows_prec_list Zero_nat
              ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o',
                'l', ' '] .
             shows_prec Zero_nat lf .
               shows_prec_list Zero_nat
                 [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']));

check_wf_terms_F_all ::
  forall a b c d.
    (Eq c,
      Showa c) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        Term c d -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_terms_F_all lc ld ls lt =
  let {
    lfs = funas_term_list lt;
  } in catcha (forallM (check_wf_sym_F_all lc ld ls) lfs) (\ x -> Inl (snd x));

check_Lab_all_trs ::
  forall a b c.
    (Eq a, Showa a, Eq c,
      Showa c) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        [(Term a c, Term a c)] ->
                          [(Term a c, Term a c)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_Lab_all_trs lc ld ls lR r =
  catcha
    (forallM
      (\ (l, ra) ->
        catcha
          (bindb (check_wf_terms_F_all lc ld ls ra)
            (\ _ ->
              check (membera r (map_rule (\ lf -> fst (ld lf)) (l, ra)))
                (shows_prec_list Zero_nat
                  ['u', 'n', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ' ', 'o',
                    'f', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' ', 'd',
                    'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'y', 'i', 'e', 'l',
                    'd', ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 'r',
                    'u', 'l', 'e'])))
          (\ x ->
            Inl (shows_prec_list Zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h',
                     ' ', 'l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l',
                     'e'] .
                  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                    [' ', '-', '>', ' '] (l, ra) .
                    shows_nl . x)))
      lR)
    (\ x -> Inl (snd x));

sl_LS_gen :: forall a b c d e. Sl_ops_ext a b c d e -> a -> Nat -> [c];
sl_LS_gen
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_LS_gen;

sl_lgen :: forall a b c d e. Sl_ops_ext a b c d e -> c -> [c];
sl_lgen
  (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
    sl_LS_gen more)
  = sl_lgen;

lge_to_lgr ::
  forall a b.
    (Eq b) => (a -> Nat -> b -> b -> Bool) ->
                (a -> Nat -> b -> Bool) -> a -> Nat -> b -> b -> Bool;
lge_to_lgr lge ls f n =
  let {
    lSfn = ls f n;
    lgefn = lge f n;
  } in (\ l la -> not (l == la) && lSfn l && lSfn la && lgefn l la);

check_sl_decr_rule ::
  forall a b c d.
    (Eq a, Eq b, Eq c,
      Eq d) => (a -> Nat -> b -> c) ->
                 (c -> (a, b)) ->
                   (a -> Nat -> b -> Bool) ->
                     (a -> Nat -> b -> b -> Bool) ->
                       (Term c d, Term c d) -> Bool;
check_sl_decr_rule lc ld ls lge (Fun lf ts, Fun lg us) =
  let {
    (f, l1) = ld lf;
    (g, l2) = ld lg;
    n = size_list ts;
  } in f == g &&
         ts == us &&
           lf == lc f n l1 &&
             lg == lc f n l2 &&
               ls f n l1 && ls f n l2 && lge_to_lgr lge ls f n l1 l2;
check_sl_decr_rule uu uv uw ux (Var vb, va) = False;
check_sl_decr_rule uu uv uw ux (v, Var vb) = False;

check_sl_decr ::
  forall a b c d.
    (Eq a, Eq b, Eq c, Showa c, Eq d,
      Showa d) => (a -> Nat -> b -> c) ->
                    (c -> (a, b)) ->
                      (a -> Nat -> b -> Bool) ->
                        (a -> Nat -> b -> b -> Bool) ->
                          [(Term c d, Term c d)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_decr lc ld ls lge d =
  catcha
    (forallM
      (\ lr ->
        check (check_sl_decr_rule lc ld ls lge lr)
          (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
             [' ', '-', '>', ' '] lr .
            shows_prec_list Zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'd', 'e', 'c',
                'r', 'e', 'a', 's', 'i', 'n', 'g', ' ', 'r', 'u', 'l', 'e']))
      d)
    (\ x -> Inl (snd x));

sl_LS :: forall a b c d e. Sl_ops_ext a b c d e -> a -> Nat -> c -> Bool;
sl_LS (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
        sl_LS_gen more)
  = sl_LSa;

sl_La :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> c;
sl_La (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
        sl_LS_gen more)
  = sl_L;

sl_L :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> c;
sl_L (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_La;

sl_I :: forall a b c d e. Sl_ops_ext a b c d e -> a -> [b] -> b;
sl_I (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_I;

sl_C :: forall a b c d e. Sl_ops_ext a b c d e -> [b];
sl_C (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_C;

option_to_list :: forall a. Maybe a -> [a];
option_to_list (Just a) = [a];
option_to_list Nothing = [];

funas_root_rule_list ::
  forall a b. (Eq a) => (Term a b, Term a b) -> [(a, Nat)];
funas_root_rule_list r =
  remdups (option_to_list (root (fst r)) ++ option_to_list (root (snd r)));

funas_root_rules_list ::
  forall a b. (Eq a) => [(Term a b, Term a b)] -> [(a, Nat)];
funas_root_rules_list r = remdups (concatMap funas_root_rule_list r);

sem_lab_fin_quasi_root_proc ::
  forall a b c d e.
    (Eq a, Linorder a, Showa a, Eq b, Showa c, Ceq e, Corder e, Eq e,
      Mapping_impl e, Linorder e, Set_impl e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      (c -> c -> Bool) ->
                        (a -> Nat -> b -> b -> Bool) ->
                          Dpp_ops_ext d a e () ->
                            ([(a, Nat)] ->
                              [(a, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char])
                                  (Sl_ops_ext a c b e ())) ->
                              [(Term a e, Term a e)] ->
                                [Term a e] ->
                                  [(Term a e, Term a e)] ->
                                    d -> Sum ([Prelude.Char] -> [Prelude.Char])
   d;
sem_lab_fin_quasi_root_proc lc ld cge lge i gen lPAll lQ lRAll dp =
  let {
    pairs = pairsa i dp;
  } in bindb (gen (list_union (funas_trs_list (rulesd i dp))
                    (funas_args_trs_list pairs))
               (funas_root_rules_list pairs))
         (\ ops ->
           let {
             check_d = sl_check_decr ops;
             check_da = check_sl_decr lc ld (sl_LS ops) lge;
             check_q = check_sl_lab_lhss_more lc (sl_LS_gen ops);
             check_ml =
               check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) cge lc;
             check_l =
               check_sl_lab_all_trs (sl_I ops) (sl_L ops) (sl_La ops) (sl_C ops)
                 (sl_lgen ops) lc;
             check_la = check_Lab_all_trs lc ld (sl_LS ops);
           } in sem_lab_quasi_root_proc ld i (Inr ()) check_d check_da check_q
                  check_l check_la check_ml lPAll lQ lRAll dp);

check_sl_rule_root ::
  forall a b c d e.
    (Showa a, Showa b, Eq d, Showa d, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        (a -> Nat -> c -> d) ->
                          [b] ->
                            [(Term d e, Term d e)] ->
                              (Term a e, Term a e) ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_rule_root i la l lc c lR lr =
  catcha
    (forallM
      (\ alpha ->
        let {
          laa = lab_root i la l lc alpha;
          lb = laa (fst lr);
          r = laa (snd lr);
        } in check (membera lR (lb, r))
               (shows_prec_list Zero_nat
                  ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                    ' '] .
                 shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                   [' ', '-', '>', ' '] (lb, r) .
                   shows_prec_list Zero_nat
                     [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g']))
      (map fun_of (enum_vectors c (vars_rule_list lr))))
    (\ x -> Inl (snd x));

check_sl_lab_root_trs ::
  forall a b c d e.
    (Showa a, Showa b, Eq d, Showa d, Eq e,
      Showa e) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> [b] -> c) ->
                        [b] ->
                          (a -> Nat -> c -> d) ->
                            [(Term d e, Term d e)] ->
                              [(Term a e, Term a e)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_root_trs i la l c label lP p =
  catcha (forallM (check_sl_rule_root i la l label c lP) p)
    (\ x -> Inl (snd x));

sem_lab_root_proc ::
  forall a b c d.
    (Eq a, Showa a, Corder d, Eq d, Mapping_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([Term a d] ->
                          [Term a d] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          ([(Term a d, Term a d)] ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              ([(Term a d, Term a d)] ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                [(Term a d, Term a d)] ->
                                  [Term a d] ->
                                    [(Term a d, Term a d)] ->
                                      c ->
Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_root_proc ld i valid check_Q check_laba check_lab check_model_lab lPAll
  lQ lRAll dpp =
  let {
    r = rc i dpp;
    rw = rwc i dpp;
    pw = pwa i dpp;
    p = pa i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll pw;
    (lR, (lRw, _)) = model_splitter ld lRAll rw;
  } in (case bindb valid
               (\ _ ->
                 bindb (catcha
                         (forallM
                           (\ (l, ra) ->
                             bindb (check_no_var l)
                               (\ _ ->
                                 bindb (check_no_var ra)
                                   (\ _ ->
                                     check_no_defined_root
                                       (\ fn ->
 not (null (rules_mapb i dpp fn)))
                                       ra)))
                           (pairsa i dpp))
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catcha
                             (forallM (\ (l, _) -> check_no_var l)
                               (rulesd i dpp))
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         let {
                           q = qc i dpp;
                         } in catcha
                                (bindb
                                  (check
                                    (if nfs
                                      then (if not (q_emptyc i dpp)
     then wwf_rulesa i dpp else True)
                                      else True)
                                    (shows_prec_list Zero_nat
                                      ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r',
'm', 'e', 'd', 'n', 'e', 's', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e',
'd']))
                                  (\ _ ->
                                    bindb (check_Q lQ q)
                                      (\ _ ->
bindb (check_sl_Q ld lQ q)
  (\ _ ->
    bindb (check_laba lP p)
      (\ _ ->
        bindb (check_laba lPw pw)
          (\ _ ->
            bindb (check_model_lab lR r)
              (\ _ ->
                bindb (check_model_lab lRw rw)
                  (\ _ ->
                    bindb (check_lab lR r) (\ _ -> check_lab lRw rw)))))))))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'd', 'u', 'r', 'i', 'n', 'g', ' ',
   'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ':'] .
shows_nl . x)))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs m lP lPw lQ lR lRw);
       });

lab_rule_ass ::
  forall a b c d e.
    (a -> [b] -> b) ->
      (a -> [b] -> c) ->
        (a -> Nat -> c -> d) ->
          (e -> b) -> (Term a e, Term a e) -> (Term d e, Term d e);
lab_rule_ass i l lc alpha rule =
  (snd (eval_lab i l lc alpha (fst rule)),
    snd (eval_lab i l lc alpha (snd rule)));

lab_rule_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) ->
                    [b] -> (Term a e, Term a e) -> [(Term d e, Term d e)];
lab_rule_list i l lc c lr =
  map (\ alpha -> lab_rule_ass i l lc alpha lr)
    (map fun_of (enum_vectors c (vars_rule_list lr)));

lab_trs_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) ->
                    [b] -> [(Term a e, Term a e)] -> [(Term d e, Term d e)];
lab_trs_list i l lc c r = concatMap (lab_rule_list i l lc c) r;

check_sl_lab ::
  forall a b c d.
    (Eq a, Showa a, Eq d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> a) ->
                        [b] ->
                          [(Term a d, Term a d)] ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab i l lc c lR r =
  bindb (check (not (null c))
          (shows_prec_list Zero_nat
            ['c', 'a', 'r', 'r', 'i', 'e', 'r', ' ', 'm', 'u', 's', 't', ' ',
              'b', 'e', ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
    (\ _ ->
      catcha (check_subseteq lR (lab_trs_list i l lc c r))
        (\ x ->
          Inl (shows_prec_list Zero_nat
                 ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
                   ' '] .
                shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                  [' ', '-', '>', ' '] x .
                  shows_prec_list Zero_nat
                    [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
                      'w', 'e', 'd'])));

lab_lhs_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) -> [b] -> Term a e -> [Term d e];
lab_lhs_list i l lc c t =
  map (\ alpha -> snd (eval_lab i l lc alpha t))
    (map fun_of (enum_vectors c (vars_term_list t)));

lab_lhss_list ::
  forall a b c d e.
    (Eq e) => (a -> [b] -> b) ->
                (a -> [b] -> c) ->
                  (a -> Nat -> c -> d) -> [b] -> [Term a e] -> [Term d e];
lab_lhss_list i l lc c q = concatMap (lab_lhs_list i l lc c) q;

check_sl_Qa ::
  forall a b c d.
    (Eq a, Showa a, Corder d, Eq d, Mapping_impl d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      (a -> Nat -> c -> a) ->
                        [b] ->
                          [Term a d] ->
                            [Term a d] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_Qa i l lc c lQ q =
  bindb (check (not (null c))
          (shows_prec_list Zero_nat
            ['c', 'a', 'r', 'r', 'i', 'e', 'r', ' ', 'm', 'u', 's', 't', ' ',
              'b', 'e', ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't', 'y']))
    (\ _ ->
      catcha (check_NF_vars_subset (lab_lhss_list i l lc c q) lQ)
        (\ x ->
          Inl (shows_prec_list Zero_nat
                 ['l', 'a', 'b', 'e', 'l', 'e', 'd', ' ', 't', 'e', 'r', 'm',
                   ' '] .
                shows_term (shows_prec Zero_nat) (shows_prec Zero_nat) x .
                  shows_prec_list Zero_nat
                    [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])));

sem_lab_fin_root_proc ::
  forall a b c d e.
    (Eq a, Linorder a, Showa a, Corder d, Eq d, Mapping_impl d, Linorder d,
      Showa d, Eq e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      Dpp_ops_ext c a d () ->
                        ([(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              (Sl_ops_ext a e b d ())) ->
                          [(Term a d, Term a d)] ->
                            [Term a d] ->
                              [(Term a d, Term a d)] ->
                                c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_fin_root_proc lc ld i gen lPAll lQ lRAll dp =
  let {
    pairs = pairsa i dp;
  } in bindb (gen (list_union (funas_trs_list (rulesd i dp))
                    (funas_args_trs_list pairs))
               (funas_root_rules_list pairs))
         (\ ops ->
           let {
             check_q = check_sl_Qa (sl_I ops) (sl_L ops) lc (sl_C ops);
             check_ml =
               check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops)
                 (\ a b -> a == b) lc;
             check_l =
               check_sl_lab_root_trs (sl_I ops) (sl_L ops) (sl_La ops)
                 (sl_C ops) lc;
             check_la = check_sl_lab (sl_I ops) (sl_L ops) lc (sl_C ops);
           } in sem_lab_root_proc ld i (Inr ()) check_q check_l check_la
                  check_ml lPAll lQ lRAll dp);

slm_La :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> c;
slm_La (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_L;

slm_c :: forall a b c d. Slm_ops_ext a b c d -> b;
slm_c (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_c;

slm_L :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> c;
slm_L (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_La;

slm_I :: forall a b c d. Slm_ops_ext a b c d -> a -> [b] -> b;
slm_I (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_I;

slm_C :: forall a b c d. Slm_ops_ext a b c d -> [b];
slm_C (Slm_ops_ext slm_La slm_I slm_C slm_c slm_L more) = slm_C;

slm_to_sl :: forall a b c d. Slm_ops_ext a b c () -> Sl_ops_ext a b c d ();
slm_to_sl ops =
  Sl_ops_ext (slm_L ops) (\ _ _ _ -> True) (slm_I ops) (slm_C ops) (slm_c ops)
    (\ _ -> Inr ()) (slm_La ops) (\ _ _ _ -> True) (\ l -> [l]) (\ _ _ -> [])
    ();

slm_gen_to_sl_gen ::
  forall a b c d.
    ([(a, Nat)] ->
      [(a, Nat)] ->
        Sum ([Prelude.Char] -> [Prelude.Char]) (Slm_ops_ext a b c ())) ->
      [(a, Nat)] ->
        [(a, Nat)] ->
          Sum ([Prelude.Char] -> [Prelude.Char]) (Sl_ops_ext a b c d ());
slm_gen_to_sl_gen gen =
  (\ f g -> bindb (gen f g) (\ ops -> Inr (slm_to_sl ops)));

check_sl_lab_trs_set ::
  forall a b c d.
    (Eq a, Linorder a, Showa a, Showa b, Eq d, Linorder d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            Set (Term a d, Term a d) ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_trs_set i l c cge label lP p =
  catcha (forallM (check_sl_rule i l label c cge False lP) p)
    (\ x -> Inl (snd x));

check_sl_lab_trs ::
  forall a b c d.
    (Eq a, Linorder a, Showa a, Showa b, Eq d, Linorder d,
      Showa d) => (a -> [b] -> b) ->
                    (a -> [b] -> c) ->
                      [b] ->
                        (b -> b -> Bool) ->
                          (a -> Nat -> c -> a) ->
                            [(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_sl_lab_trs i l c cge label lP p =
  check_sl_lab_trs_set i l c cge label (set lP) p;

sem_lab_proc ::
  forall a b c d.
    (Eq a, Showa a, Corder d, Eq d, Mapping_impl d,
      Showa d) => (a -> (a, b)) ->
                    Dpp_ops_ext c a d () ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                        ([Term a d] ->
                          [Term a d] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          ([(Term a d, Term a d)] ->
                            [(Term a d, Term a d)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([(Term a d, Term a d)] ->
                              [(Term a d, Term a d)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              ([(Term a d, Term a d)] ->
                                [(Term a d, Term a d)] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                                [(Term a d, Term a d)] ->
                                  [Term a d] ->
                                    [(Term a d, Term a d)] ->
                                      c ->
Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_proc ld i valid check_Q check_laba check_lab check_model_lab lPAll lQ
  lRAll dpp =
  let {
    r = rc i dpp;
    rw = rwc i dpp;
    pw = pwa i dpp;
    p = pa i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (lP, (lPw, _)) = model_splitter ld lPAll pw;
    (lR, (lRw, _)) = model_splitter ld lRAll rw;
  } in (case bindb valid
               (\ _ ->
                 let {
                   q = qc i dpp;
                 } in catcha
                        (bindb
                          (check
                            (if nfs
                              then (if not (q_emptyc i dpp)
                                     then wwf_rulesa i dpp else True)
                              else True)
                            (shows_prec_list Zero_nat
                              ['w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e',
                                'd', 'n', 'e', 's', 's', ' ', 'r', 'e', 'q',
                                'u', 'i', 'r', 'e', 'd']))
                          (\ _ ->
                            bindb (check_Q lQ q)
                              (\ _ ->
                                bindb (check_sl_Q ld lQ q)
                                  (\ _ ->
                                    bindb (check_laba lP p)
                                      (\ _ ->
bindb (check_laba lPw pw)
  (\ _ ->
    bindb (check_model_lab lR r)
      (\ _ ->
        bindb (check_model_lab lRw rw)
          (\ _ -> bindb (check_lab lR r) (\ _ -> check_lab lRw rw)))))))))
                        (\ x ->
                          Inl (shows_string
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'd',
                                   'u', 'r', 'i', 'n', 'g', ' ', 'l', 'a', 'b',
                                   'e', 'l', 'i', 'n', 'g', ':'] .
                                shows_nl . x)))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i nfs m lP lPw lQ lR lRw);
       });

sem_lab_fin_proc ::
  forall a b c d e.
    (Eq a, Linorder a, Showa a, Corder d, Eq d, Mapping_impl d, Linorder d,
      Showa d, Eq e,
      Showa e) => (a -> Nat -> b -> a) ->
                    (a -> (a, b)) ->
                      Dpp_ops_ext c a d () ->
                        ([(a, Nat)] ->
                          [(a, Nat)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char])
                              (Sl_ops_ext a e b d ())) ->
                          [(Term a d, Term a d)] ->
                            [Term a d] ->
                              [(Term a d, Term a d)] ->
                                c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
sem_lab_fin_proc lc ld i gen lPAll lQ lRAll dp =
  bindb (gen (list_union (funas_trs_list (rulesd i dp))
               (funas_args_trs_list (pairsa i dp)))
          [])
    (\ ops ->
      let {
        check_q = check_sl_Qa (sl_I ops) (sl_L ops) lc (sl_C ops);
        check_ml =
          check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops)
            (\ a b -> a == b) lc;
        check_l =
          check_sl_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) (\ a b -> a == b)
            lc;
        check_la = check_sl_lab (sl_I ops) (sl_L ops) lc (sl_C ops);
      } in sem_lab_proc ld i (Inr ()) check_q check_l check_la check_ml lPAll lQ
             lRAll dp);

get_largest_element :: forall a. Sl_inter a -> Nat;
get_largest_element (SL_Inter n uu) = n;

take_default :: forall a. a -> [a] -> Nat -> a;
take_default def [] uu = def;
take_default uv (x : xs) i =
  (if equal_nat i Zero_nat then x
    else take_default uv xs (minus_nat i (Nat_of_num One)));

eval_arithFun :: Nat -> [Nat] -> ArithFun -> Nat;
eval_arithFun c nats f = mod_nat (eval_arithFun_unbound c nats f) c;

eval_arithFun_unbound :: Nat -> [Nat] -> ArithFun -> Nat;
eval_arithFun_unbound c nats (Arg i) = take_default Zero_nat nats i;
eval_arithFun_unbound c nats (Const n) = n;
eval_arithFun_unbound c nats (Sum []) = Zero_nat;
eval_arithFun_unbound c nats (Sum (f : fs)) =
  plus_nat (eval_arithFun c nats f) (eval_arithFun c nats (Sum fs));
eval_arithFun_unbound c nats (Prod []) = Nat_of_num One;
eval_arithFun_unbound c nats (Prod (f : fs)) =
  times_nat (eval_arithFun c nats f) (eval_arithFun c nats (Prod fs));
eval_arithFun_unbound c nats (Max [f]) = eval_arithFun c nats f;
eval_arithFun_unbound c nats (Max (f : v : va)) =
  max (eval_arithFun c nats f) (eval_arithFun c nats (Max (v : va)));
eval_arithFun_unbound c nats (Min [f]) = eval_arithFun c nats f;
eval_arithFun_unbound c nats (Min (f : v : va)) =
  min (eval_arithFun c nats f) (eval_arithFun c nats (Min (v : va)));
eval_arithFun_unbound c nats (IfEqual f1 f2 ft fe) =
  (if equal_nat (eval_arithFun c nats f1) (eval_arithFun c nats f2)
    then eval_arithFun c nats ft else eval_arithFun c nats fe);

sl_inter_to_inter :: forall a. (Eq a) => Sl_inter a -> a -> [Nat] -> Nat;
sl_inter_to_inter (SL_Inter c ls) fl cs =
  (case map_of ls (fl, size_list cs) of {
    Nothing -> Zero_nat;
    Just a -> eval_arithFun (plus_nat c (Nat_of_num One)) cs a;
  });

sli_to_slm ::
  forall a.
    (Eq a) => Sl_inter (Lab a [Nat]) ->
                Slm_ops_ext (Lab a [Nat]) Nat (Sum [Nat] [Lab a [Nat]]) ();
sli_to_slm sli =
  let {
    c = get_largest_element sli;
  } in Slm_ops_ext (\ _ -> Inl) (sl_inter_to_inter sli)
         (upt Zero_nat (plus_nat c (Nat_of_num One))) c (\ _ -> Inl) ();

enum_vectors_nat :: forall a. [a] -> Nat -> [[a]];
enum_vectors_nat c n =
  (if equal_nat n Zero_nat then [[]]
    else let {
           a = enum_vectors_nat c (minus_nat n (Nat_of_num One));
         } in concatMap (\ vec -> map (\ ca -> ca : vec) c) a);

qmodel_check_interpretation ::
  ArithFun -> Nat -> Nat -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_interpretation f n c =
  let {
    ca = upt Zero_nat (plus_nat c (Nat_of_num One));
    css = enum_vectors_nat ca n;
  } in catcha
         (forallM
           (\ cs ->
             catcha
               (forallM
                 (\ i ->
                   catcha
                     (forallM
                       (\ l ->
                         check (less_eq_nat
                                 (eval_arithFun (plus_nat c (Nat_of_num One)) cs
                                   f)
                                 (eval_arithFun (plus_nat c (Nat_of_num One))
                                   (list_update cs i l) f))
                           (shows_prec_list Zero_nat
                              ['n', 'o', 't', ' ', 'm', 'o', 'n', 'o', 't', 'o',
                                'n', 'e', ' ', 'i', 'n', ' '] .
                             shows_prec_nat Zero_nat
                               (plus_nat i (Nat_of_num One)) .
                               shows_prec_list Zero_nat
                                 ['.', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n',
                                   't']))
                       (upt (nth cs i) (plus_nat c (Nat_of_num One))))
                     (\ x -> Inl (snd x)))
                 (upt Zero_nat n))
               (\ x -> Inl (snd x)))
           css)
         (\ x -> Inl (snd x));

qmodel_check_valid ::
  forall a.
    (Showa a) => Sl_inter a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_valid (SL_Inter c ls) =
  catcha
    (forallM
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ g ->
               catcha (qmodel_check_interpretation g n c)
                 (\ x ->
                   Inl (shows_prec_list Zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n',
                            ' ', 'w', 'e', 'a', 'k', '-', 'm', 'o', 'n', 'o',
                            't', 'o', 'n', 'i', 'c', 'i', 't', 'y', ' ', 'o',
                            'f', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r', 'e',
                            't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                         shows_prec Zero_nat f . shows_nl . x)))
          b)
      ls)
    (\ x -> Inl (snd x));

check_decr_present_aux_1 ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a (b, Nat), Term a (b, Nat))] ->
                           b -> a -> a -> Nat ->
    Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present_aux_1 r v f1 f2 n =
  let {
    vs = map (\ na -> Var (v, na)) (upt Zero_nat n);
    rule = (Fun f1 vs, Fun f2 vs);
  } in check (not (is_none (find (instance_rule rule) r))) rule;

check_decr_present_aux_2 ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           b -> [(a, (a, Nat))] ->
                                  Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present_aux_2 r v req =
  let {
    add_nats = map_vars (\ va -> (va, Zero_nat));
    ra = map (\ (l, ra) -> (add_nats l, add_nats ra)) r;
  } in catcha
         (forallM (\ (f1, (a, b)) -> check_decr_present_aux_1 ra v f1 a b) req)
         (\ x -> Inl (snd x));

check_decr_present ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(a, Nat)] ->
                           (a -> [Nat] -> a) ->
                             b -> Nat ->
                                    [(Term a b, Term a b)] ->
                                      Sum (Term a (b, Nat), Term a (b, Nat)) ();
check_decr_present sig l v c r =
  let {
    ca = upt Zero_nat (plus_nat c (Nat_of_num One));
    ls = (\ (f, n) ->
           concatMap
             (\ cs ->
               concatMap
                 (\ i ->
                   let {
                     ci = nth cs i;
                   } in (if less_nat ci c
                          then [(l f (list_update cs i
                                       (plus_nat ci (Nat_of_num One))),
                                  (l f cs, n))]
                          else []))
                 (upt Zero_nat n))
             (enum_vectors_nat ca n));
  } in check_decr_present_aux_2 r v (concatMap ls sig);

qmodel_check_decr ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b,
      Mapping_impl b) => [(Lab a [Nat], Nat)] ->
                           b -> Nat ->
                                  [(Term (Lab a [Nat]) b,
                                     Term (Lab a [Nat]) b)] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
qmodel_check_decr sig v c =
  (\ lR ->
    catcha (check_decr_present sig Lab v c lR)
      (\ x ->
        Inl (let {
               display =
                 map_vars
                   (\ (_, n) ->
                     (shows_prec_list Zero_nat ['x'] .
                       shows_prec_nat Zero_nat n)
                       []);
             } in shows_prec_list Zero_nat
                    ['d', 'e', 'c', 'r', 'e', 'a', 's', 'i', 'n', 'g', ' ', 'r',
                      'u', 'l', 'e', ' '] .
                    shows_rule (shows_prec_lab Zero_nat)
                      (shows_prec_list Zero_nat) [' ', '-', '>', ' ']
                      (display (fst x), display (snd x)) .
                      shows_prec_list Zero_nat
                        [' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])));

qmodel_LS_gen ::
  forall a b c. (Eq a) => [(a, Nat)] -> [b] -> a -> Nat -> [Sum [b] c];
qmodel_LS_gen sig ls =
  (\ f n ->
    (if membera sig (f, n) then map Inl (enum_vectors_nat ls n) else [Inl []]));

pointwise_lgen :: [Nat] -> [[Nat]];
pointwise_lgen ns =
  concat_lists (map (\ n -> upt Zero_nat (plus_nat n (Nat_of_num One))) ns);

qmodel_lgen :: forall a. Sum [Nat] a -> [Sum [Nat] a];
qmodel_lgen l =
  (case l of {
    Inl ns -> map Inl (pointwise_lgen ns);
    Inr _ -> [];
  });

qmodel_LSa :: forall a. Lab a [Nat] -> Nat -> Sum [Nat] [Lab a [Nat]] -> Bool;
qmodel_LSa = (\ _ _ a -> (case a of {
                           Inl _ -> True;
                           Inr _ -> False;
                         }));

qmodel_LS ::
  forall a b c.
    (Eq a, Eq b, Eq c) => [(a, Nat)] -> [b] -> a -> Nat -> Sum [b] c -> Bool;
qmodel_LS sig ls = (\ f n -> membera (qmodel_LS_gen sig ls f n));

qmodel_L ::
  forall a b c d.
    (Eq a, Eq b) => [(Lab a b, Nat)] -> Lab a b -> [c] -> Sum [c] d;
qmodel_L sig =
  (\ f cs -> (if membera sig (f, size_list cs) then Inl cs else Inl []));

qsli_to_sl_unsafe ::
  forall a b.
    (Corder a, Eq a, Mapping_impl a, Eq b,
      Showa b) => a -> [(Lab b [Nat], Nat)] ->
                         [(Lab b [Nat], Nat)] ->
                           Sl_inter (Lab b [Nat]) ->
                             Sl_ops_ext (Lab b [Nat]) Nat
                               (Sum [Nat] [Lab b [Nat]]) a ();
qsli_to_sl_unsafe v f g sli =
  let {
    c = get_largest_element sli;
    ca = upt Zero_nat (plus_nat c (Nat_of_num One));
  } in Sl_ops_ext (qmodel_L f) (qmodel_LS f ca) (sl_inter_to_inter sli) ca c
         (qmodel_check_decr f v c) (qmodel_L g) qmodel_LSa qmodel_lgen
         (qmodel_LS_gen f ca) ();

qsli_to_sl ::
  forall a b.
    (Corder a, Eq a, Mapping_impl a, Eq b,
      Showa b) => a -> [(Lab b [Nat], Nat)] ->
                         [(Lab b [Nat], Nat)] ->
                           Sl_inter (Lab b [Nat]) ->
                             Sum ([Prelude.Char] -> [Prelude.Char])
                               (Sl_ops_ext (Lab b [Nat]) Nat
                                 (Sum [Nat] [Lab b [Nat]]) a ());
qsli_to_sl v f g sli =
  bindb (qmodel_check_valid sli) (\ _ -> Inr (qsli_to_sl_unsafe v f g sli));

pointwise_ext ::
  forall a. (a -> a -> (Bool, Bool)) -> [a] -> [a] -> (Bool, Bool);
pointwise_ext f [] [] = (False, True);
pointwise_ext f (uu : uv) [] = (False, False);
pointwise_ext f [] (uw : ux) = (False, False);
pointwise_ext f (a : asa) (b : bs) =
  (case f a b of {
    (stri, True) ->
      (case pointwise_ext f asa bs of {
        (strir, True) -> (stri || strir, True);
        (strir, False) -> (False, False);
      });
    (stri, False) -> (False, False);
  });

qmodel_lge :: forall a b c d. a -> b -> Sum [Nat] c -> Sum [Nat] d -> Bool;
qmodel_lge f n =
  (\ l r ->
    (case (l, r) of {
      (Inl cs1, Inl cs2) ->
        snd (pointwise_ext (\ x y -> (less_nat y x, less_eq_nat y x)) cs1 cs2);
      (Inl cs1, Inr _) -> False;
      (Inr _, b) -> False;
    }));

qmodel_cge :: Nat -> Nat -> Bool;
qmodel_cge = (\ x y -> less_eq_nat y x);

rl_slm ::
  forall a b.
    (Eq a,
      Eq b) => Maybe (Lab a b, Nat) ->
                 [(Lab a b, Nat)] ->
                   [(Lab a b, Nat)] ->
                     Sum ([Prelude.Char] -> [Prelude.Char])
                       (Slm_ops_ext (Lab a b) (Lab a b) (Sum b [Lab a b]) ());
rl_slm delt_opt pre_fs g =
  let {
    fs = (if is_none delt_opt then pre_fs
           else filter (\ f -> not (f == the delt_opt)) pre_fs);
  } in bindb (check (not (null fs))
               (shows_string
                  ['r', 'o', 'o', 't', '-', 'l', 'a', 'b', 'e', 'l', 'i', 'n',
                    'g', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'a',
                    't', ' ', 'l', 'e', 'a', 's', 't', ' ', 'o', 'n', 'e', ' ',
                    'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 's', 'y', 'm',
                    'b', 'o', 'l', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 's',
                    'i', 'g', 'n', 'a', 't', 'u', 'r', 'e'] .
                 shows_nl))
         (\ _ ->
           let {
             f = fst (hd fs);
           } in Inr (Slm_ops_ext (\ _ -> Inr)
                      (\ ga cs ->
                        (if membera fs (ga, size_list cs) then ga else f))
                      (map fst fs) f
                      (if is_none delt_opt then (\ _ -> Inr)
                        else (\ _ gs ->
                               Inr (replicate (size_list gs)
                                     (fst (the delt_opt)))))
                      ()));

semlab_fin_proc ::
  forall a b c.
    (Eq b, Linorder b, Showa b, Ceq c, Corder c, Eq c, Mapping_impl c,
      Linorder c, Set_impl c,
      Showa c) => Dpp_ops_ext a (Lab b [Nat]) c () ->
                    Sl_variant (Lab b [Nat]) c ->
                      [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                        [Term (Lab b [Nat]) c] ->
                          [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
semlab_fin_proc j (Rootlab Nothing) =
  sem_lab_fin_proc label label_decomp j (slm_gen_to_sl_gen (rl_slm Nothing));
semlab_fin_proc j (Rootlab (Just d)) =
  sem_lab_fin_root_proc label label_decomp j
    (slm_gen_to_sl_gen (rl_slm (Just d)));
semlab_fin_proc j (Finitelab sli) =
  sem_lab_fin_proc label label_decomp j
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli)));
semlab_fin_proc j (QuasiFinitelab sli v) =
  sem_lab_fin_quasi_root_proc label label_decomp qmodel_cge qmodel_lge j
    (\ f g -> qsli_to_sl v f g sli);

partition_rules ::
  forall a b.
    (Eq a,
      Eq b) => [Ctxt a b] ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     ([(Term a b, Term a b)], [(Term a b, Term a b)]);
partition_rules cs r =
  partition
    (\ lr ->
      any (\ (u, v) ->
            any (\ c -> lr == (ctxt_apply c u, ctxt_apply c v)) (Hole : cs))
        r);

strip_unary_root :: forall a b. (Eq a) => a -> Term a b -> Term a b;
strip_unary_root f (Fun g [t]) = (if f == g then t else Fun g [t]);
strip_unary_root f (Var v) = Var v;
strip_unary_root f (Fun v []) = Fun v [];
strip_unary_root f (Fun v (vb : vd : ve)) = Fun v (vb : vd : ve);

has_unary_root :: forall a b. (Eq a) => a -> Term a b -> Bool;
has_unary_root f (Fun g [t]) = f == g;
has_unary_root f (Var v) = False;
has_unary_root f (Fun v []) = False;
has_unary_root f (Fun v (vb : vd : ve)) = False;

unblock_term :: forall a b. (Eq a) => a -> Term a b -> Term a b;
unblock_term f (Fun g ts) =
  (if all (has_unary_root f) ts then Fun g (map (strip_unary_root f) ts)
    else Fun g ts);
unblock_term f (Var v) = Var v;

unblock_rule ::
  forall a b. (Eq a) => a -> (Term a b, Term a b) -> (Term a b, Term a b);
unblock_rule f r = (unblock_term f (fst r), unblock_term f (snd r));

partition_pairs ::
  forall a b.
    (Eq a,
      Eq b) => a -> [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]);
partition_pairs f p = partition (\ r -> membera p (unblock_rule f r));

check_no_defined_root_defined ::
  forall a b.
    (Eq a, Showa a,
      Showa b) => [(a, Nat)] ->
                    Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_no_defined_root_defined f t =
  check (not (membera f (the (root t))))
    (shows_string ['t', 'h', 'e', ' ', 'r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
      shows_prec_term Zero_nat t .
        shows_string [' ', 'i', 's', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd']);

block_term :: forall a b. a -> Term a b -> Term a b;
block_term f (Var x) = Var x;
block_term f (Fun g ts) = Fun g (map (\ t -> Fun f [t]) ts);

block_rule :: forall a b. a -> (Term a b, Term a b) -> (Term a b, Term a b);
block_rule f r = (block_term f (fst r), block_term f (snd r));

check_superset_of_blocked ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => a -> [(Term a b, Term a b)] ->
                         [(Term a b, Term a b)] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_superset_of_blocked f pa p =
  catcha
    (catcha
      (catcha
        (forallM
          (\ x -> (if membera pa (block_rule f x) then Inr () else Inl x)) p)
        (\ x -> Inl (snd x)))
      (\ x ->
        Inl (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                [' ', '-', '>', ' '] (block_rule f x) .
                shows_string
                  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'] .
                  shows_nl)))
    (\ x ->
      Inl (shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
             ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't', 'e',
               'm', ':']
             [' ', '-', '>', ' '] p .
            shows_string
              ['i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 's',
                'e', 't', ' ', 'o', 'f'] .
              shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
                ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't',
                  'e', 'm', ':']
                [' ', '-', '>', ' '] pa .
                x . shows_nl));

hole_at :: forall a b. (Eq a) => Nat -> Nat -> a -> Ctxt a b -> Bool;
hole_at n i f (More g ss1 Hole ss2) =
  g == f &&
    equal_nat (size_list ss1) i &&
      equal_nat (size_list ss2) (minus_nat (minus_nat n i) (Nat_of_num One));
hole_at n i f Hole = False;
hole_at n i f (More v va (More vd ve vf vg) vc) = False;

check_flat_ctxt_complete ::
  forall a b.
    (Eq a, Showa a,
      Showa b) => [Ctxt a b] ->
                    (a, Nat) -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_flat_ctxt_complete fcs fa =
  check (all_interval_nat (\ i -> any (hole_at (snd fa) i (fst fa)) fcs)
          Zero_nat (snd fa))
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'i', 's', 't', ' ', 'o', 'f', ' ', 'f', 'l',
         'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', 's', ' ', 'i', 's',
         ' ', 'i', 'n', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'e'] .
      shows_nl);

check_rule_reflecting ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [Ctxt a b] ->
                    [(Term a b, Term a b)] ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_reflecting fcs rs rule =
  check (any (\ (l, r) ->
               any (\ c ->
                     equal_term (fst rule) (ctxt_apply c l) &&
                       equal_term (snd rule) (ctxt_apply c r))
                 (Hole : fcs))
          rs)
    (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
        [' ', '-', '>', ' '] rule .
        shows_string
          [' ', 'i', 's', ' ', 'n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'c', 'o',
            'n', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h',
            'e', ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 's', 'e',
            't', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'n', 'o',
            'r', ' ', 'o', 'b', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'b', 'y',
            ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'a', ' ', 'f',
            'l', 'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
          shows_nl);

check_rule_preserving ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [Ctxt a b] ->
                    [(Term a b, Term a b)] ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rule_preserving fcs rs rule =
  check (any (instance_rule rule) rs ||
          all (\ c ->
                any (instance_rule
                      (ctxt_apply c (fst rule), ctxt_apply c (snd rule)))
                  rs)
            fcs)
    (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
        [' ', '-', '>', ' '] rule .
        shows_string
          [' ', 'i', 's', ' ', 'n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'c', 'o',
            'n', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h',
            'e', ' ', 'r', 'e', 's', 'u', 'l', 't', 'i', 'n', 'g', ' ', 's',
            'e', 't', ' ', 'o', 'f', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'n',
            'o', 'r', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ', 'u', 'n', 'd',
            'e', 'r', ' ', 'a', 'l', 'l', ' ', 'f', 'l', 'a', 't', ' ', 'c',
            'o', 'n', 't', 'e', 'x', 't', 's'] .
          shows_nl);

is_flat_ctxt_list ::
  forall a b. (Eq a, Eq b) => [a] -> [(b, Nat)] -> Ctxt b a -> Bool;
is_flat_ctxt_list vs fas (More f ss1 Hole ss2) =
  let {
    ss = ss1 ++ ss2;
  } in membera fas (f, plus_nat (size_list ss) (Nat_of_num One)) &&
         all is_Var ss && distinct ss && null (list_inter (map the_Var ss) vs);
is_flat_ctxt_list vs fas Hole = False;
is_flat_ctxt_list vs fas (More v va (More vd ve vf vg) vc) = False;

shows_prec_ctxt ::
  forall a b.
    (Showa a, Showa b) => Nat -> Ctxt a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_ctxt d c = shows_ctxt (shows_prec Zero_nat) (shows_prec Zero_nat) c;

check_is_flat_ctxt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [a] ->
                    [(b, Nat)] ->
                      Ctxt b a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_is_flat_ctxt vs fas c =
  check (is_flat_ctxt_list vs fas c)
    (shows_prec_ctxt Zero_nat c .
      shows_string
        [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'f', 'l', 'a', 't',
          ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
        shows_nl);

check_flat_ctxt ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [a] -> Ctxt b a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_flat_ctxt vs c =
  (case c of {
    Hole ->
      Inl (shows_prec_ctxt Zero_nat c .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'f', 'l', 'a',
                't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
              shows_nl);
    More _ ss1 Hole ss2 ->
      let {
        ss = ss1 ++ ss2;
      } in bindb (check (distinct ss)
                   (shows_prec_ctxt Zero_nat c .
                     shows_string
                       [' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'd',
                         'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', ' ', 'v', 'a',
                         'r', 'i', 'a', 'b', 'l', 'e', 's'] .
                       shows_nl))
             (\ _ ->
               bindb (check (all is_Var ss)
                       (shows_prec_ctxt Zero_nat c .
                         shows_string
                           [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'l',
                             'a', 't', ',', ' ', 'i', '.', 'e', '.', ',', ' ',
                             'h', 'a', 's', ' ', 'd', 'e', 'p', 't', 'h', ' ',
                             'g', 'r', 'e', 'a', 't', 'e', 'r', ' ', 't', 'h',
                             'a', 'n', ' ', 'o', 'n', 'e'] .
                           shows_nl))
                 (\ _ ->
                   check (all (\ t -> not (membera vs (the_Var t)))
                           (ss1 ++ ss2))
                     (shows_prec_ctxt Zero_nat c .
                       shows_string
                         [' ', 'h', 'a', 's', ' ', 't', 'o', ' ', 'c', 'o', 'n',
                           't', 'a', 'i', 'n', ' ', 'o', 'n', 'l', 'y', ' ',
                           'f', 'r', 'e', 's', 'h', ' ', 'v', 'a', 'r', 'i',
                           'a', 'b', 'l', 'e', 's'] .
                         shows_nl)));
    More _ ss1 (More _ _ _ _) ss2 ->
      Inl (shows_prec_ctxt Zero_nat c .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'f', 'l', 'a',
                't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't'] .
              shows_nl);
  });

shows_terms ::
  forall a b.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        [Prelude.Char] -> [Term a b] -> [Prelude.Char] -> [Prelude.Char];
shows_terms fun var name ts =
  shows_string name .
    shows_nl .
      shows_list_gen (shows_term fun var) [] [] [newline] [] ts . shows_nl;

shows_dpp ::
  forall a b c.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Dpp_ops_ext c a b () -> c -> [Prelude.Char] -> [Prelude.Char];
shows_dpp fun var i d =
  let {
    m = minimal i d;
    nfs = nfsc i d;
    p = pa i d;
    pw = pwa i d;
    r = rc i d;
    rw = rwc i d;
    q = qc i d;
  } in shows_trs fun var ['p', 'a', 'i', 'r', 's', ':'] [' ', '-', '>', ' '] p .
         (if null pw then id
           else shows_trs fun var
                  ['w', 'e', 'a', 'k', ' ', 'p', 'a', 'i', 'r', 's', ':']
                  [' ', '-', '>', '=', ' '] pw) .
           (if null r then id
             else shows_trs fun var
                    ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's',
                      ':']
                    [' ', '-', '>', '!', ' '] r) .
             shows_trs fun var ['r', 'u', 'l', 'e', 's', ':']
               [' ', '-', '>', ' '] rw .
               (if null q then id
                 else shows_terms fun var
                        ['Q', '-', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't',
                          ':']
                        q) .
                 (if m then shows_nl .
                              shows_prec_list Zero_nat
                                ['(', 'm', 'i', 'n', 'i', 'm', 'a', 'l', ')']
                   else id) .
                   (if nfs && not (null q)
                     then shows_nl .
                            shows_prec_list Zero_nat
                              ['(', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
                                'r', 'm', ' ', 's', 'u', 'b', 's', 't', 'i',
                                't', 'u', 't', 'i', 'o', 'n', 's', ')']
                     else id);

fcc_proc_cond ::
  forall a b c.
    (Eq b, Showa b, Corder c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               [(Term b c, Term b c)] ->
                                 [(Term b c, Term b c)] ->
                                   a -> Sum ([Prelude.Char] -> [Prelude.Char])
  a;
fcc_proc_cond i f fcs p pw r rw dpp =
  let {
    paa = pa i dpp;
    pwaa = pwa i dpp;
    ra = rc i dpp;
    rwa = rwc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    new_dpp = mkc i nfs m p pw [] r rw;
  } in (case catcha
               (let {
                  pb = list_union paa pwaa;
                  rb = list_union ra rwa;
                  rba = list_union r rw;
                  fa = (f, Nat_of_num One);
                  cf = More f [] Hole [];
                  fcsa = cf : fcs;
                  vs = vars_trs_list rb;
                  fs = list_union (funas_trs_list rb) (funas_args_trs_list pb);
                  fas = fa : fs;
                  ds = defined_list rb;
                } in bindb (check (not (membera ds fa))
                             (shows_prec Zero_nat f .
                               shows_string
                                 ['i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r',
                                   'e', 's', 'h'] .
                                 shows_nl))
                       (\ _ ->
                         bindb (check_wf_trs rb)
                           (\ _ ->
                             bindb (catcha
                                     (forallM
                                       (\ rd ->
 bindb (check_no_var (fst rd))
   (\ _ ->
     bindb (check_no_var (snd rd))
       (\ _ -> check_no_defined_root_defined ds (snd rd))))
                                       pb)
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 bindb (catcha
 (forallM (check_flat_ctxt vs) fcsa) (\ x -> Inl (snd x)))
                                   (\ _ ->
                                     bindb (catcha
     (forallM (check_is_flat_ctxt vs fas) fcsa) (\ x -> Inl (snd x)))
                                       (\ _ ->
 bindb (catcha (forallM (check_flat_ctxt_complete fcsa) fas)
         (\ x -> Inl (snd x)))
   (\ _ ->
     bindb (catcha (forallM (check_rule_preserving fcsa r) ra)
             (\ x -> Inl (snd x)))
       (\ _ ->
         bindb (catcha (forallM (check_rule_preserving fcsa rba) rwa)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             bindb (catcha (forallM (check_rule_reflecting fcsa rb) rba)
                     (\ x -> Inl (snd x)))
               (\ _ ->
                 bindb (check_superset_of_blocked f p paa)
                   (\ _ -> check_superset_of_blocked f pw pwaa)))))))))))
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                          'n', ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ',
                          'f', 'l', 'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x',
                          't', ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e', ' ', 'c',
                          'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ', 't',
                          'o', ' ', 's', 'w', 'i', 't', 'c', 'h', ' ', 'f', 'r',
                          'o', 'm', ' '] .
                       shows_nl .
                         shows_dpp (shows_prec Zero_nat) (shows_prec Zero_nat) i
                           dpp .
                           shows_nl .
                             shows_prec_list Zero_nat
                               ['t', 'o', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                                 ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                               shows_nl .
                                 shows_dpp (shows_prec Zero_nat)
                                   (shows_prec Zero_nat) i new_dpp .
                                   shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr new_dpp;
       });

g_to_list_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> [a];
g_to_list_dflt_basic_oops_rm_basic_ops s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ _ -> True)
    (\ a b -> a : b) [];

delete_rm_basic_ops :: forall a. (Linorder a) => a -> Rbt a () -> Rbt a ();
delete_rm_basic_ops x s = delete x s;

ceta_list_diff :: forall a. (Key a) => [a] -> [a] -> [a];
ceta_list_diff xs ys =
  g_to_list_dflt_basic_oops_rm_basic_ops
    (foldl (\ a b -> delete_rm_basic_ops b a)
      (g_from_list_dflt_basic_oops_rm_basic_ops xs) ys);

fcc_split_proc ::
  forall a b c.
    (Eq b, Key b, Showa b, Ceq c, Corder c, Eq c, Key c, Mapping_impl c,
      Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               [(Term b c, Term b c)] ->
                                 [(Term b c, Term b c)] ->
                                   a -> Sum ([Prelude.Char] -> [Prelude.Char])
  (a, a);
fcc_split_proc i f fcs pb rb ps rs dpp =
  let {
    p = pa i dpp;
    pw = pwa i dpp;
    r = rc i dpp;
    rw = rwc i dpp;
    q = qc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    pba = list_union p pw;
    rba = rw;
    pns = ceta_list_diff pba ps;
    rns = ceta_list_diff rba rs;
    (paa, pwaa) = partition_pairs f ps pb;
    (ra, rwa) = partition_rules (More f [] Hole [] : fcs) rs rb;
    two = mkc i nfs m (ceta_list_diff p ps) (ceta_list_diff pw ps) [] [] rns;
    dpp_mid = mkc i nfs m ps pns [] rs rns;
  } in bindb (bindb
               (catcha (check_subseteq ps pba)
                 (\ x ->
                   Inl (shows_prec_list Zero_nat ['p', 'a', 'i', 'r', ' '] .
                         shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                           [' ', '-', '>', ' '] x .
                           shows_prec_list Zero_nat
                             [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e',
                               ' ', 'd', 'e', 'l', 'e', 't', 'e', 'd', ' ', 'b',
                               'u', 't', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                               'p', 'r', 'e', 's', 'e', 'n', 't'])))
               (\ _ ->
                 bindb (catcha (check_subseteq rs rba)
                         (\ x ->
                           Inl (shows_prec_list Zero_nat
                                  ['r', 'u', 'l', 'e', ' '] .
                                 shows_rule (shows_prec Zero_nat)
                                   (shows_prec Zero_nat) [' ', '-', '>', ' ']
                                   x .
                                   shows_prec_list Zero_nat
                                     [' ', 's', 'h', 'o', 'u', 'l', 'd', ' ',
                                       'b', 'e', ' ', 'd', 'e', 'l', 'e', 't',
                                       'e', 'd', ' ', 'b', 'u', 't', ' ', 'i',
                                       's', ' ', 'n', 'o', 't', ' ', 'p', 'r',
                                       'e', 's', 'e', 'n', 't'])))
                   (\ _ ->
                     bindb (check (null q)
                             (shows_string
                                ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                                  'e', 'm', 'p', 't', 'y'] .
                               shows_nl))
                       (\ _ ->
                         bindb (check (null r)
                                 (shows_prec_list Zero_nat
                                   ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u',
                                     'l', 'e', 's', ' ', 'n', 'o', 't', ' ',
                                     'a', 'l', 'l', 'o', 'w', 'e', 'd']))
                           (\ _ ->
                             bindb (check_left_linear_trs rw)
                               (\ _ ->
                                 fcc_proc_cond i f fcs paa pwaa ra rwa
                                   dpp_mid))))))
         (\ one -> Inr (one, two));

mono_redpair_proc ::
  forall a b c.
    (Showa b,
      Showa c) => Dpp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        [(Term b c, Term b c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
mono_redpair_proc i rp premove rremove dpp =
  (case catcha
          (let {
             (ps, pns) = split_pairsa i dpp premove;
             (rs, rns) = split_rulesc i dpp rremove;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (catcha (mono rp (ps ++ rs ++ pns ++ rns))
                            (\ x ->
                              Inl (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'm', 'o', 'n',
                                       'o', 't', 'o', 'n', 'i', 'c', 'i', 't',
                                       'y', ' ', 'o', 'f', ' ', 's', 't', 'r',
                                       'i', 'c', 't', ' ', 'o', 'r', 'd', 'e',
                                       'r'] .
                                    shows_nl . x)))
                      (\ _ ->
                        bindb (catcha
                                (catcha (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T', 'R', 'S'] .
shows_nl . x)))
                          (\ _ ->
                            bindb (catcha
                                    (catcha (forallM (s rp) rs)
                                      (\ x -> Inl (snd x)))
                                    (\ x ->
                                      Inl
(shows_string
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
     'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T', 'R', 'S'] .
  shows_nl . x)))
                              (\ _ ->
                                bindb (catcha
(catcha (forallM (ns rp) pns) (\ x -> Inl (snd x)))
(\ x ->
  Inl (shows_string
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
           'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
        shows_nl . x)))
                                  (\ _ ->
                                    catcha
                                      (catcha (forallM (s rp) ps)
(\ x -> Inl (snd x)))
                                      (\ x ->
Inl (shows_string
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o',
         'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'D', 'P', 's'] .
      shows_nl . x))))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'd', 'u',
                     'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                     'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w',
                     'i', 'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (delete_R_Rwc i (delete_P_Pwa i dpp premove premove) rremove rremove);
  });

instantiation_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
instantiation_proc i st sts dpp =
  (case let {
          ic = icap_impl_dpp_mv i dpp;
          isnf = is_QNFc i dpp;
          (s, t) = st;
          sy = map_vars (\ a -> 'y' : a) s;
          ty = map_vars (\ a -> 'y' : a) t;
          iedg = is_iedg_edge_dpp i dpp;
        } in catcha
               (forallM
                 (\ (u, v) ->
                   (case mgu_class (ic [u] v) s of {
                     Nothing -> Inr ();
                     Just mu ->
                       check (not (isnf (subst_apply_term sy mu)) ||
                               (not (isnf (subst_apply_term
    (map_vars (\ a -> 'x' : a) u) mu)) ||
                                 any (\ sta ->
                                       instance_rule sta st &&
 instance_rule (subst_apply_term sy mu, subst_apply_term ty mu) sta)
                                   sts))
                         (shows_prec_list Zero_nat
                            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                              'f', 'i', 'n', 'd', ' ', 'i', 'n', 's', 't', 'a',
                              'n', 'c', 'e', ' ', 'o', 'f', ' ', 'p', 'a', 'i',
                              'r', ' '] .
                           shows_rule (shows_prec Zero_nat)
                             (shows_prec_list Zero_nat) [' ', '-', '>', ' ']
                             (subst_apply_term sy mu, subst_apply_term ty mu) .
                             shows_nl .
                               shows_prec_list Zero_nat
                                 ['w', 'h', 'i', 'c', 'h', ' ', 'r', 'e', 's',
                                   'u', 'l', 't', 'e', 'd', ' ', 'f', 'r', 'o',
                                   'm', ' ', 'D', 'P', ' '] .
                                 shows_rule (shows_prec Zero_nat)
                                   (shows_prec_list Zero_nat)
                                   [' ', '-', '>', ' '] (u, v));
                   }))
                 (filter (\ (u, v) -> iedg (u, v) s) (pairsa i dpp)))
               (\ x -> Inl (snd x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

intersect_pairsa ::
  forall a b c d. Dpp_ops_ext a b c d -> a -> [(Term b c, Term b c)] -> a;
intersect_pairsa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = intersect_pairs;

rules_non_collapsinga :: forall a b c d. Dpp_ops_ext a b c d -> a -> Bool;
rules_non_collapsinga
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = rules_non_collapsing;

reverse_rules_mapa ::
  forall a b c d.
    Dpp_ops_ext a b c d -> a -> (b, Nat) -> [(Term b c, Term b c)];
reverse_rules_mapa
  (Dpp_ops_ext dpp p pw pairs q r rw rules q_empty rules_no_left_var
    rules_non_collapsing is_QNF nFQ_subset_NF_rules rules_map reverse_rules_map
    intersect_pairs replace_pair intersect_rules delete_P_Pw delete_R_Rw
    split_pairs split_rules mk minimal nfs wwf_rules more)
  = reverse_rules_map;

reverse_capRM_dpp ::
  forall a b c.
    (Eq b, Eq c) => Dpp_ops_ext a b c () -> a -> Term b c -> Gctxt b c;
reverse_capRM_dpp i dpp =
  capRM (rules_non_collapsinga i dpp) (reverse_rules_mapa i dpp);

check_graph_decomp ::
  forall a.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      ((a, a) -> Bool) ->
        [(Bool, [a])] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_graph_decomp ss g rcs =
  bindb (check_pairwise (check_edges ss g) (map snd rcs))
    (\ _ ->
      catcha
        (forallM (\ c -> check_edges ss g c c)
          (map_filter (\ x -> (if not (fst x) then Just (snd x) else Nothing))
            rcs))
        (\ x -> Inl (snd x)));

check_dep_graph_proc ::
  forall a b c.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dep_graph_proc i dpp dps =
  let {
    c = capRM_dpp i dpp;
    rc = reverse_capRM_dpp i dpp;
    _ = nFQ_subset_NF_rulesb i dpp;
    _ = is_QNFc i dpp;
    _ = map fst (rulesd i dpp);
    iedg = is_iedg_edge_dpp i dpp;
    p = pairsa i dpp;
  } in bindb (catcha (check_subseteq p (concatMap snd dps))
               (\ x ->
                 Inl (shows_string
                        ['D', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c', 'y', ' ',
                          'P', 'a', 'i', 'r', ' '] .
                       shows_rule (shows_prec Zero_nat)
                         (shows_prec_list Zero_nat) [' ', '-', '>', ' '] x .
                         shows_string
                           [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                             'g', ' ', 'i', 'n', ' ', 'd', 'e', 'c', 'o', 'm',
                             'p', 'o', 's', 'i', 't', 'i', 'o', 'n'] .
                           shows_nl)))
         (\ _ ->
           catcha
             (check_graph_decomp (shows_prec_prod Zero_nat . fst)
               (\ (a, b) ->
                 let {
                   (aa, ba) = a;
                 } in let {
                        (_, t) = aa;
                      } in (\ (_, (ct, ict)) (ab, bb) ->
                             let {
                               (u, _) = ab;
                             } in (\ (cu, (_, _)) ->
                                    matchb ct u && matchb cu t && ict u)
                               bb)
                        ba
                   b)
               (map (\ (real, cs) ->
                      (not (is_none real),
                        map (\ (s, t) -> ((s, t), (rc s, (c t, iedg (s, t)))))
                          cs))
                 dps))
             (\ x ->
               Inl (shows_string
                      ['o', 'u', 'r', ' ', 'e', 's', 't', 'i', 'm', 'a', 't',
                        'i', 'o', 'n', ' ', '(', 'E', 'D', 'G', '*', '*', '*',
                        ' ', '+', ' ', 'I', 'E', 'D', 'G', '*', '*', '*', ')',
                        ' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ',
                        's', 'h', 'o', 'w', ' ', 't', 'h', 'a', 't', ' ', 'y',
                        'o', 'u', ' ', 'h', 'a', 'v', 'e', ' ', 'a', ' ', 'v',
                        'a', 'l', 'i', 'd', ' ', 'd', 'e', 'c', 'o', 'm', 'p',
                        'o', 's', 'i', 't', 'i', 'o', 'n', ' '] .
                     shows_string
                       ['d', 'u', 'e', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ',
                         'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'r',
                         'e', 'a', 's', 'o', 'n'] .
                       shows_nl . x)));

dep_graph_proc ::
  forall a b c.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    a -> [(Maybe c,
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])])] ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) [(c, a)];
dep_graph_proc i d dps =
  (case check_dep_graph_proc i d dps of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (map_filter
            (\ x ->
              (if not (is_none (fst x))
                then Just (the (fst x), intersect_pairsa i d (snd x))
                else Nothing))
            dps);
  });

check_NF_terms_subset ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_terms_subset qa q =
  catcha
    (forallM (\ x -> (if not (nF_terms_list qa x) then Inr () else Inl x)) q)
    (\ x -> Inl (snd x));

check_NF_terms_eq ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [Term a b] -> [Term a b] -> Sum (Term a b) ();
check_NF_terms_eq qa q =
  bindb (check_NF_terms_subset qa q) (\ _ -> check_NF_terms_subset q qa);

check_dpp_subsumes ::
  forall a b c d.
    (Eq b, Showa b, Eq c, Showa c, Corder d, Eq d, Mapping_impl d,
      Showa d) => Dpp_ops_ext a (Lab b c) d () ->
                    (Bool,
                      (Bool,
                        ([(Term (Lab b c) d, Term (Lab b c) d)],
                          ([(Term (Lab b c) d, Term (Lab b c) d)],
                            ([Term (Lab b c) d],
                              ([(Term (Lab b c) d, Term (Lab b c) d)],
                                [(Term (Lab b c) d, Term (Lab b c) d)])))))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dpp_subsumes i (nfs, (m, (p, (pw, (q, (r, rw)))))) d =
  catcha
    (let {
       paa = pa i d;
       pwaa = pwa i d;
       qa = qc i d;
       ra = rc i d;
       rwa = rwc i d;
       nfsa = nfsc i d;
       ma = minimal i d;
       pb = p ++ pw;
       rb = ra ++ rwa;
       rba = r ++ rw;
     } in bindb (check (ma == m)
                  (shows_prec_list Zero_nat
                    ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e',
                      ' ', 'm', 'i', 'n', 'i', 'm', 'a', 'l', 'i', 't', 'y',
                      ' ', 'f', 'l', 'a', 'g', 's']))
            (\ _ ->
              bindb (check (nfsa == nfs)
                      (shows_prec_list Zero_nat
                        ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l',
                          'e', ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't',
                          'i', 'o', 'n', 's', '-', 'i', 'n', '-', 'n', 'o', 'r',
                          'm', 'a', 'l', '-', 'f', 'o', 'r', 'm', ' ', 'f', 'l',
                          'a', 'g', 's']))
                (\ _ ->
                  bindb (catcha (check_subseteq paa p)
                          (\ x ->
                            Inl (toomuch ['p', 'a', 'i', 'r']
                                  (shows_rule (shows_prec_lab Zero_nat)
                                    (shows_prec Zero_nat) [' ', '-', '>', ' ']
                                    x))))
                    (\ _ ->
                      bindb (catcha (check_subseteq pwaa pb)
                              (\ x ->
                                Inl (toomuch
                                      ['w', 'e', 'a', 'k', ' ', 'p', 'a', 'i',
'r']
                                      (shows_rule (shows_prec_lab Zero_nat)
(shows_prec Zero_nat) [' ', '-', '>', ' '] x))))
                        (\ _ ->
                          bindb (catcha (check_NF_terms_eq qa q)
                                  (\ x ->
                                    Inl (shows_prec_list Zero_nat
   ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f', 'f', 'e', 'r', 's', ' ', 'd',
     'u', 'e', ' ', 't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
  shows_term (shows_prec_lab Zero_nat) (shows_prec Zero_nat) x)))
                            (\ _ ->
                              bindb (catcha (check_subseteq ra r)
                                      (\ x ->
Inl (toomuch ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e']
      (shows_rule (shows_prec_lab Zero_nat) (shows_prec Zero_nat)
        [' ', '-', '>', ' '] x))))
                                (\ _ ->
                                  bindb (catcha (check_subseteq rb rba)
  (\ x ->
    Inl (toomuch
          ['s', 't', 'r', 'i', 'c', 't', '/', 'w', 'e', 'a', 'k', ' ', 'r', 'u',
            'l', 'e']
          (shows_rule (shows_prec_lab Zero_nat) (shows_prec Zero_nat)
            [' ', '-', '>', ' '] x))))
                                    (\ _ ->
                                      bindb
(catcha (check_subseteq rba rb)
  (\ x ->
    Inl (missing
          ['s', 't', 'r', 'i', 'c', 't', '/', 'w', 'e', 'a', 'k', ' ', 'r', 'u',
            'l', 'e']
          (shows_rule (shows_prec_lab Zero_nat) (shows_prec Zero_nat)
            [' ', '-', '>', ' '] x))))
(\ _ -> Inr ())))))))))
    (\ x ->
      Inl (shows_string
             ['f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'o', 'f',
               ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
            shows_nl .
              shows_dpp (shows_prec_lab Zero_nat) (shows_prec Zero_nat) i d .
                shows_nl .
                  shows_string
                    ['m', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'c',
                      'o', 'n', 'c', 'l', 'u', 'd', 'e', 'd', ' ', 'f', 'r',
                      'o', 'm', ' ', 'a', 's', 's', 'u', 'm', 'i', 'n', 'g',
                      ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's',
                      ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o',
                      'b', 'l', 'e', 'm'] .
                    shows_nl .
                      shows_dpp (shows_prec_lab Zero_nat) (shows_prec Zero_nat)
                        i (mkc i nfs m p pw q r rw) .
                        shows_nl . x . shows_nl));

fcc_proc ::
  forall a b c.
    (Eq b, Showa b, Ceq c, Corder c, Eq c, Mapping_impl c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    b -> [Ctxt b c] ->
                           [(Term b c, Term b c)] ->
                             [(Term b c, Term b c)] ->
                               a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
fcc_proc i f fcs pb rw dpp =
  let {
    p = pa i dpp;
    q = qc i dpp;
    r = rc i dpp;
    (pc, pw) = partition_pairs f p pb;
  } in bindb (check (null q)
               (shows_string
                  ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p',
                    't', 'y'] .
                 shows_nl))
         (\ _ ->
           bindb (check (null r)
                   (shows_prec_list Zero_nat
                     ['s', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e',
                       's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                       'e', 'd']))
             (\ _ ->
               bindb (check_left_linear_trs (rwc i dpp))
                 (\ _ -> fcc_proc_cond i f fcs pc pw [] rw dpp)));

q_reduction_proc_non_min ::
  forall a b c.
    (Eq b, Showa b, Corder c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc_non_min i q dpp =
  (case catcha
          (bindb
            (catcha (check_NF_terms_subset (qc i dpp) q)
              (\ x ->
                Inl (shows_prec_list Zero_nat
                       ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                      shows_prec_term Zero_nat x .
                        shows_prec_list Zero_nat
                          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l',
                            'l', 'o', 'w', 'e', 'd', ' ', 'i', 'n', ' ', 'Q',
                            '\'', ' '])))
            (\ _ -> Inr ()))
          (\ x ->
            Inl (shows_prec_list Zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'r', 'e', 'd', 'u', 'c', 'i', 'n', 'g', ' ', 'Q', ' ',
                     'i', 'n', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r',
                     'o', 'b', 'l', 'e', 'm', ' '] .
                  shows_nl .
                    shows_dpp (shows_prec Zero_nat) (shows_prec Zero_nat) i
                      dpp .
                      shows_nl .
                        shows_prec_list Zero_nat
                          ['t', 'o', ' ', 't', 'h', 'e', ' ', 's', 'e', 't',
                            ' '] .
                          shows_nl .
                            shows_terms (shows_prec Zero_nat)
                              (shows_prec Zero_nat) ['Q', '\'', ':'] q .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ ->
      Inr (mkc i (nfsc i dpp) False (pa i dpp) (pwa i dpp) q (rc i dpp)
            (rwc i dpp));
  });

q_reduction_proc_min_inn ::
  forall a b c.
    (Eq b, Showa b, Corder c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc_min_inn i q dpp =
  let {
    pb = pairsa i dpp;
    rb = rulesd i dpp;
    f = map Just (funas_trs_list (pb ++ rb));
    qa = qc i dpp;
    isnf = is_QNFc i dpp;
    qq = filter (\ qb -> all isnf (args qb)) qa;
    rQ = filter (\ qb -> membera f (root qb)) qq;
  } in (case catcha
               (bindb
                 (check (nFQ_subset_NF_rulesb i dpp)
                   (shows_prec_list Zero_nat
                     ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r',
                       'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'r', 'e',
                       'q', 'u', 'i', 'r', 'e', 'd']))
                 (\ _ ->
                   bindb (check_wf_trs rb)
                     (\ _ ->
                       bindb (catcha (check_NF_terms_subset q rQ)
                               (\ x ->
                                 Inl (shows_prec_list Zero_nat
['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                                       shows_prec_term Zero_nat x .
 shows_prec_list Zero_nat
   [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 'n', ' ',
     'Q', '\'', ' '])))
                         (\ _ ->
                           bindb (catcha (check_NF_terms_subset qq q)
                                   (\ x ->
                                     Inl (shows_prec_list Zero_nat
    ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
   shows_prec_term Zero_nat x .
     shows_prec_list Zero_nat
       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
         'd', ' ', 'i', 'n', ' ', 'Q', '\'', ' '])))
                             (\ _ ->
                               (if nfsc i dpp then Inr ()
                                 else check_varcond_subset pb))))))
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e',
                          'n', ' ', 'r', 'e', 'd', 'u', 'c', 'i', 'n', 'g', ' ',
                          'Q', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                          ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                       shows_nl .
                         shows_dpp (shows_prec Zero_nat) (shows_prec Zero_nat) i
                           dpp .
                           shows_nl .
                             shows_prec_list Zero_nat
                               ['t', 'o', ' ', 't', 'h', 'e', ' ', 's', 'e',
                                 't', ' '] .
                               shows_nl .
                                 shows_terms (shows_prec Zero_nat)
                                   (shows_prec Zero_nat) ['Q', '\'', ':'] q .
                                   shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (mkc i (nfsc i dpp) (minimal i dpp) (pa i dpp) (pwa i dpp) q
                 (rc i dpp) (rwc i dpp));
       });

q_reduction_proc ::
  forall a b c.
    (Eq b, Showa b, Corder c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    [Term b c] -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_reduction_proc i q dpp =
  (case q_reduction_proc_min_inn i q dpp of {
    Inl _ -> q_reduction_proc_non_min i q dpp;
    Inr a -> Inr a;
  });

get_fcc_option ::
  forall a b c.
    Dp_termination_proof a b c ->
      Maybe (Lab a b,
              ([Ctxt (Lab a b) c],
                ([(Term (Lab a b) c, Term (Lab a b) c)],
                  ([(Term (Lab a b) c, Term (Lab a b) c)],
                    Dp_termination_proof a b c))));
get_fcc_option (Fcc_Proc f fcs pb rb prf) = Just (f, (fcs, (pb, (rb, prf))));
get_fcc_option P_is_Empty = Nothing;
get_fcc_option (Subterm_Criterion_Proc v va vb vc) = Nothing;
get_fcc_option (Redpair_Proc v va vb) = Nothing;
get_fcc_option (Redpair_UR_Proc v va vb vc) = Nothing;
get_fcc_option (Usable_Rules_Proc v va) = Nothing;
get_fcc_option (Dep_Graph_Proc v) = Nothing;
get_fcc_option (Mono_Redpair_Proc v va vb vc) = Nothing;
get_fcc_option (Mono_Redpair_UR_Proc v va vb vc vd) = Nothing;
get_fcc_option (Size_Change_Subterm_Proc v) = Nothing;
get_fcc_option (Size_Change_Redpair_Proc v va vb) = Nothing;
get_fcc_option (Uncurry_Proc v va vb vc vd) = Nothing;
get_fcc_option (Split_Proc v va vb vc) = Nothing;
get_fcc_option (Semlab_Proc v va vb vc vd) = Nothing;
get_fcc_option (Switch_Innermost_Proc v va) = Nothing;
get_fcc_option (Rewriting_Proc v va vb vc vd ve vf) = Nothing;
get_fcc_option (Instantiation_Proc v va vb) = Nothing;
get_fcc_option (Forward_Instantiation_Proc v va vb vc) = Nothing;
get_fcc_option (Narrowing_Proc v va vb vc) = Nothing;
get_fcc_option (Assume_Finite v va) = Nothing;
get_fcc_option (Unlab_Proc v va vb) = Nothing;
get_fcc_option (Q_Reduction_Proc v va) = Nothing;
get_fcc_option (Complex_Constant_Removal_Proc v va) = Nothing;
get_fcc_option (General_Redpair_Proc v va vb vc vd) = Nothing;
get_fcc_option (To_Trs_Proc v) = Nothing;

uncurry_of_top_sig_list ::
  forall a.
    a -> Nat ->
           [((a, Nat), [a])] ->
             (a -> Nat -> [a]) ->
               [(Term a [Prelude.Char], Term a [Prelude.Char])];
uncurry_of_top_sig_list a m sml sm =
  concatMap
    (\ (b, c) ->
      let {
        (f, n) = b;
      } in (\ _ ->
             let {
               g = get_symbol sm f n;
             } in map (\ i ->
                        (Fun a (generate_f_xs (g i) (plus_nat n i) :
                                 map (\ ia -> Var (generate_var ia))
                                   (upt (plus_nat n i)
                                     (plus_nat (plus_nat n i)
                                       (minus_nat m (Nat_of_num One))))),
                          generate_f_xs (g (plus_nat i (Nat_of_num One)))
                            (plus_nat (plus_nat n i)
                              (minus_nat m (Nat_of_num One)))))
                    (upt Zero_nat (aarity sm f n)))
        c)
    sml;

eta_closed_top_rules ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => a -> Nat ->
                         (a -> Nat -> [a]) ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] ->
                               Sum ([Prelude.Char] -> [Prelude.Char]) ();
eta_closed_top_rules a n sm r p =
  catcha
    (forallM
      (\ (l, ra) ->
        (case l of {
          Var _ -> Inr ();
          Fun ff ls ->
            check (equal_nat (aarity sm ff (size_list ls)) Zero_nat ||
                    any (\ (lll, rrr) ->
                          (case (lll, rrr) of {
                            (Var _, b) -> False;
                            (Fun f [], b) -> False;
                            (Fun f (ll : yy), Var _) -> False;
                            (Fun f (ll : yy), Fun g []) -> False;
                            (Fun f (ll : yy), Fun g (rr : zz)) ->
                              f == a &&
                                g == a &&
                                  zz == yy &&
                                    equal_nat (size_list yy)
                                      (minus_nat n (Nat_of_num One)) &&
                                      distinct yy &&
all is_Var yy &&
  null (list_inter (map the_Var yy) (vars_rule_list (ll, rr))) &&
    instance_rule (l, ra) (ll, rr);
                          }))
                      p)
              (shows_prec_list Zero_nat
                 ['e', 't', 'a', ' ', 'e', 'x', 'p', 'a', 'n', 's', 'i', 'o',
                   'n', ' ', 'o', 'f', ' '] .
                shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                  [' ', '-', '>', ' '] (l, ra) .
                  shows_prec_list Zero_nat
                    [' ', 'm', 'i', 's', 's', 'i', 'n', 'g']);
        }))
      r)
    (\ x -> Inl (snd x));

uncurry_top_rules ::
  forall a b.
    (Eq a) => a -> Nat ->
                     (a -> Nat -> [a]) ->
                       [(Term a b, Term a b)] -> [(Term a b, Term a b)];
uncurry_top_rules a n sm =
  map (\ (l, r) -> (uncurry_top a n sm l, uncurry_top a n sm r));

uncurry_top_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      Nat ->
                        ([((b, Nat), [b])] -> b -> Nat -> b) ->
                          (b -> Nat ->
                                  [((b, Nat), [b])] ->
                                    Sum ([Prelude.Char] -> [Prelude.Char])
                                      ()) ->
                            [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                              [(Term b [Prelude.Char],
                                 Term b [Prelude.Char])] ->
                                a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_top_proc i info n fmap check_inj p r dpp =
  let {
    (a, (sml, (u, eb))) = info;
    paa = pa i dpp;
    pw = pwa i dpp;
    ra = rc i dpp;
    rw = rwc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (e, ew) = uncurry_eta_split eb ra;
    sm = sig_list_to_sig_map a sml fmap;
    p_eta = e ++ paa;
    pw_eta = ew ++ pw;
    uP = uncurry_top_rules a n sm p_eta;
    uPw = uncurry_top_rules a n sm pw_eta;
    uR = map_rules_wa (\ (f, na) -> get_symbol sm f na Zero_nat) ra;
    uRw = map_rules_wa (\ (f, na) -> get_symbol sm f na Zero_nat) rw;
  } in (case bindb (check (null (qc i dpp))
                     (shows_prec_list Zero_nat
                       ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'c', 'u',
                         'r', 'r', 'e', 'n', 't', 'l', 'y', ' ', 'u', 'n', 's',
                         'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
               (\ _ ->
                 bindb (check (not (equal_nat n Zero_nat))
                         (shows_prec_list Zero_nat
                           ['t', 'h', 'e', ' ', 'a', 'r', 'i', 't', 'y', ' ',
                             'o', 'f', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c',
                             'u', 'r', 'r', 'i', 'e', 'd', ' ', 's', 'y', 'm',
                             'b', 'o', 'l', ' ', 'm', 'u', 's', 't', ' ', 'b',
                             'e', ' ', 'a', 't', ' ', 'l', 'e', 'a', 's', 't',
                             ' ', '1']))
                   (\ _ ->
                     bindb (check_inj a n sml)
                       (\ _ ->
                         let {
                           pb = pairsa i dpp;
                           is_def = (\ fn -> not (null (rules_mapb i dpp fn)));
                           rm = rules_mapb i dpp;
                         } in bindb (catcha
                                      (forallM
(\ (l, _) ->
  check (not (is_Var l))
    (shows_prec_list Zero_nat
      ['l', 'h', 's', ' ', 'a', 's', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
        'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
        'e', 'd']))
(ra ++ rw))
                                      (\ x -> Inl (snd x)))
                                (\ _ ->
                                  bindb (catcha
  (forallM
    (\ (l, rb) ->
      bindb (check (hvf_top a n l)
              (shows_prec_list Zero_nat
                 ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
                   'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                shows_term (shows_prec Zero_nat) (shows_prec_list Zero_nat) l .
                  shows_prec_list Zero_nat
                    [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
                      'd']))
        (\ _ -> check_no_var rb))
    (pw_eta ++ p_eta))
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catcha
  (forallM
    (\ (_, rb) ->
      check (not (is_def (the (root rb))))
        (shows_prec_list Zero_nat ['r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
          shows_term (shows_prec Zero_nat) (shows_prec_list Zero_nat) rb .
            shows_prec_list Zero_nat
              [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ',
                'd', 'e', 'f', 'i', 'n', 'e', 'd']))
    pb)
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (check (not (is_def (a, n)))
          (shows_prec_list Zero_nat
             ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 's',
               'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec Zero_nat a .
              shows_prec_list Zero_nat
                [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e',
                  ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ',
                  'R']))
    (\ _ ->
      bindb (if any (\ (_, rb) ->
                      the (root rb) == (a, n) &&
                        equal_gctxt (capRM2 rm (hd (args rb))) GCHole)
                  pb
              then bindb (catcha
                           (check_CS_subseteq
                             (uncurry_of_top_sig_list a n sml sm) u)
                           (\ x ->
                             Inl (shows_prec_list Zero_nat
                                    ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'i',
                                      'n', 'g', ' ', 'p', 'a', 'i', 'r', ' '] .
                                   shows_rule (shows_prec Zero_nat)
                                     (shows_prec_list Zero_nat)
                                     [' ', '-', '>', ' '] x .
                                     shows_prec_list Zero_nat
                                       [' ', 'i', 's', ' ', 'm', 'i', 's', 's',
 'i', 'n', 'g', ' ', 'i', 'n'] .
                                       shows_nl .
 shows_rules (shows_prec Zero_nat) (shows_prec_list Zero_nat)
   [' ', '-', '>', ' '] u)))
                     (\ _ ->
                       bindb (eta_closed_top_rules a n sm ra p_eta)
                         (\ _ -> eta_closed_top_rules a n sm rw pw_eta))
              else Inr ())
        (\ _ ->
          bindb (catcha (check_subseteq uP p)
                  (\ x ->
                    Inl (shows_prec_list Zero_nat
                           ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ',
                             'p', 'a', 'i', 'r', ' '] .
                          shows_rule (shows_prec Zero_nat)
                            (shows_prec_list Zero_nat) [' ', '-', '>', ' '] x .
                            shows_prec_list Zero_nat
                              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                                'g'])))
            (\ _ ->
              bindb (catcha (check_subseteq uPw p)
                      (\ x ->
                        Inl (shows_prec_list Zero_nat
                               ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd',
                                 ' ', 'p', 'a', 'i', 'r', ' '] .
                              shows_rule (shows_prec Zero_nat)
                                (shows_prec_list Zero_nat) [' ', '-', '>', ' ']
                                x .
                                shows_prec_list Zero_nat
                                  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i',
                                    'n', 'g'])))
                (\ _ ->
                  bindb (catcha (check_subseteq u p)
                          (\ x ->
                            Inl (shows_prec_list Zero_nat
                                   ['u', 'n', 'c', 'u', 'r', 'r', 'y', 'i', 'n',
                                     'g', ' ', 'p', 'a', 'i', 'r', ' '] .
                                  shows_rule (shows_prec Zero_nat)
                                    (shows_prec_list Zero_nat)
                                    [' ', '-', '>', ' '] x .
                                    shows_prec_list Zero_nat
                                      [' ', 'i', 's', ' ', 'm', 'i', 's', 's',
'i', 'n', 'g', ' ', 'i', 'n', ' ', 'n', 'e', 'w', ' ', 'p', 'a', 'i', 'r',
's'])))
                    (\ _ ->
                      bindb (catcha (check_subseteq uR r)
                              (\ x ->
                                Inl (shows_prec_list Zero_nat
                                       ['r', 'u', 'l', 'e', ' '] .
                                      shows_rule (shows_prec Zero_nat)
(shows_prec_list Zero_nat) [' ', '-', '>', ' '] x .
shows_prec_list Zero_nat
  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 'n', ' ',
    'n', 'e', 'w', ' ', 'r', 'u', 'l', 'e', 's'])))
                        (\ _ ->
                          catcha (check_subseteq uRw r)
                            (\ x ->
                              Inl (shows_prec_list Zero_nat
                                     ['r', 'u', 'l', 'e', ' '] .
                                    shows_rule (shows_prec Zero_nat)
                                      (shows_prec_list Zero_nat)
                                      [' ', '-', '>', ' '] x .
                                      shows_prec_list Zero_nat
[' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'i', 'n', ' ', 'n',
  'e', 'w', ' ', 'r', 'u', 'l', 'e', 's']))))))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkc i nfs m uP (uPw ++ u) [] uR uRw);
       });

only_eta_rules ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
only_eta_rules e r_eta =
  catcha
    (forallM
      (\ (l, r) ->
        check (case (l, r) of {
                (Var _, b) -> False;
                (Fun f ls, Var _) -> False;
                (Fun f ls, Fun g rs) ->
                  f == g &&
                    equal_nat (size_list ls) (Nat_of_num (Bit0 One)) &&
                      equal_nat (size_list rs) (Nat_of_num (Bit0 One)) &&
                        equal_term (nth ls (Nat_of_num One))
                          (nth rs (Nat_of_num One)) &&
                          any (\ (la, ra) ->
                                instance_rule (hd ls, hd rs) (la, ra))
                            r_eta;
              })
          (shows_prec_list Zero_nat ['r', 'u', 'l', 'e', ' '] .
            shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
              [' ', '-', '>', ' '] (l, r) .
              shows_prec_list Zero_nat
                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', '(',
                  'e', 't', 'a', '-', 'e', 'x', 'p', 'a', 'n', 'd', 'e', 'd',
                  ')', ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 'r',
                  'u', 'l', 'e']))
      e)
    (\ x -> Inl (snd x));

uncurry_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      ([((b, Nat), [b])] -> b -> Nat -> b) ->
                        (b -> Nat ->
                                [((b, Nat), [b])] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                              a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_proc i info fmap check_inj p r dpp =
  let {
    (a, (sml, (u, eb))) = info;
    paa = pa i dpp;
    pw = pwa i dpp;
    ra = rc i dpp;
    rw = rwc i dpp;
    nfs = nfsc i dpp;
    m = minimal i dpp;
    (e, ew) = uncurry_eta_split eb ra;
    sm = sig_list_to_sig_map a sml fmap;
    uP = uncurry_rules a sm paa;
    uPw = uncurry_rules a sm pw;
    r_eta = e ++ ra;
    rw_eta = ew ++ rw;
    uR = uncurry_rules a sm r_eta;
    uRw = uncurry_rules a sm rw_eta;
  } in (case let {
               s = uncurry_of_sig_list a sml sm;
             } in bindb (check (null (qc i dpp))
                          (shows_prec_list Zero_nat
                            ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'n',
                              'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't',
                              'e', 'd', ' ', 'f', 'o', 'r', ' ', 'u', 'n', 'c',
                              'u', 'r', 'r', 'y', 'i', 'n', 'g']))
                    (\ _ ->
                      bindb (only_eta_rules e r_eta)
                        (\ _ ->
                          bindb (only_eta_rules ew rw_eta)
                            (\ _ ->
                              bindb (check_inj a (Nat_of_num (Bit0 One)) sml)
                                (\ _ ->
                                  bindb (catcha
  (forallM
    (\ (l, _) ->
      check (not (is_Var l))
        (shows_prec_list Zero_nat
          ['l', 'h', 's', ' ', 'a', 's', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
            'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o',
            'w', 'e', 'd']))
    (ra ++ rw))
  (\ x -> Inl (snd x)))
                                    (\ _ ->
                                      bindb
(catcha
  (forallM
    (\ (l, _) ->
      check (hvf_term a l)
        (shows_prec_list Zero_nat
           ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e',
             ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
          shows_term (shows_prec Zero_nat) (shows_prec_list Zero_nat) l .
            shows_prec_list Zero_nat
              [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']))
    paa)
  (\ x -> Inl (snd x)))
(\ _ ->
  bindb (catcha
          (forallM
            (\ (l, _) ->
              check (hvf_term a l)
                (shows_prec_list Zero_nat
                   ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l',
                     'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                  shows_term (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                    l .
                    shows_prec_list Zero_nat
                      [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e',
                        'd']))
            pw)
          (\ x -> Inl (snd x)))
    (\ _ ->
      bindb (catcha
              (forallM
                (\ (l, _) ->
                  check (hvf_term a l)
                    (shows_prec_list Zero_nat
                       ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'b',
                         'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' '] .
                      shows_term (shows_prec Zero_nat)
                        (shows_prec_list Zero_nat) l .
                        shows_prec_list Zero_nat
                          [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                            'e', 'd']))
                r_eta)
              (\ x -> Inl (snd x)))
        (\ _ ->
          bindb (catcha
                  (forallM
                    (\ (l, _) ->
                      check (hvf_term a l)
                        (shows_prec_list Zero_nat
                           ['h', 'e', 'a', 'd', ' ', 'v', 'a', 'r', 'i', 'a',
                             'b', 'l', 'e', ' ', 'i', 'n', ' ', 'l', 'h', 's',
                             ' '] .
                          shows_term (shows_prec Zero_nat)
                            (shows_prec_list Zero_nat) l .
                            shows_prec_list Zero_nat
                              [' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w',
                                'e', 'd']))
                    rw_eta)
                  (\ x -> Inl (snd x)))
            (\ _ ->
              bindb (eta_closed_rules a sm r_eta r_eta)
                (\ _ ->
                  bindb (eta_closed_rules a sm rw_eta rw_eta)
                    (\ _ ->
                      bindb (catcha (check_subseteq uP p)
                              (\ x ->
                                Inl (shows_prec_list Zero_nat
                                       ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e',
 'd', ' ', 'p', 'a', 'i', 'r', ' '] .
                                      shows_rule (shows_prec Zero_nat)
(shows_prec_list Zero_nat) [' ', '-', '>', ' '] x .
shows_prec_list Zero_nat
  [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                        (\ _ ->
                          bindb (catcha (check_subseteq uPw p)
                                  (\ x ->
                                    Inl (shows_prec_list Zero_nat
   ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'p', 'a', 'i', 'r', ' '] .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
    [' ', '-', '>', ' '] x .
    shows_prec_list Zero_nat
      [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                            (\ _ ->
                              bindb (catcha (check_subseteq uR r)
                                      (\ x ->
Inl (shows_prec_list Zero_nat
       ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l', 'e',
         ' '] .
      shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
        [' ', '-', '>', ' '] x .
        shows_prec_list Zero_nat
          [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                                (\ _ ->
                                  bindb (catcha (check_subseteq uRw r)
  (\ x ->
    Inl (shows_prec_list Zero_nat
           ['u', 'n', 'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l',
             'e', ' '] .
          shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
            [' ', '-', '>', ' '] x .
            shows_prec_list Zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
                                    (\ _ ->
                                      bindb
(catcha (check_CS_subseteq s u)
  (\ x ->
    Inl (shows_prec_list Zero_nat
           ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l', 'e', ' '] .
          shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
            [' ', '-', '>', ' '] x .
            shows_prec_list Zero_nat
              [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g'])))
(\ _ ->
  bindb (catcha (check_CS_subseteq u s)
          (\ x ->
            Inl (shows_prec_list Zero_nat ['r', 'u', 'l', 'e', ' '] .
                  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                    [' ', '-', '>', ' '] x .
                    shows_prec_list Zero_nat
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ',
                        'u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l',
                        'e'])))
    (\ _ ->
      catcha (check_subseteq u r)
        (\ x ->
          Inl (shows_prec_list Zero_nat
                 ['u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l', 'e',
                   ' '] .
                shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                  [' ', '-', '>', ' '] x .
                  shows_prec_list Zero_nat
                    [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ',
                      'i', 'n', ' ', 'n', 'e', 'w', ' ', 'T', 'R',
                      'S'])))))))))))))))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkc i nfs m uP uPw [] uR (uRw ++ u));
       });

uncurry_proc_both ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Dpp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Maybe Nat ->
                      (Lab b c,
                        ([((Lab b c, Nat), [Lab b c])],
                          ([(Term (Lab b c) [Prelude.Char],
                              Term (Lab b c) [Prelude.Char])],
                            [(Term (Lab b c) [Prelude.Char],
                               Term (Lab b c) [Prelude.Char])]))) ->
                        [(Term (Lab b c) [Prelude.Char],
                           Term (Lab b c) [Prelude.Char])] ->
                          [(Term (Lab b c) [Prelude.Char],
                             Term (Lab b c) [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_proc_both i Nothing (a, (sml, (u, eb))) =
  uncurry_proc i (a, (sml, (u, eb))) (fmap a (Nat_of_num (Bit0 One))) check_inj;
uncurry_proc_both i (Just n) (a, (sml, (u, eb))) =
  uncurry_top_proc i (a, (sml, (u, eb))) n (fmap a n) check_inj;

check_rewrite_common_preconditions ::
  forall a b c d.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      (Term b [Prelude.Char], Term c [Prelude.Char]) ->
                        [Term b [Prelude.Char]] ->
                          [Term b [Prelude.Char]] ->
                            d -> (Term b [Prelude.Char],
                                   Term b [Prelude.Char]) ->
                                   Pos ->
                                     Bool ->
                                       a ->
 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rewrite_common_preconditions i u_opt st ss ts t lr p sound dpp =
  let {
    r = rulesd i dpp;
    s = fst st;
    ta = snd st;
    tp = subt_at ta p;
    u = (case u_opt of {
          Nothing -> concatMap (\ tb -> inn_usable_rules_pair i dpp (s, tb)) ts;
          Just u -> u;
        });
  } in bindb (catcha (check_subseteq u r)
               (\ x ->
                 Inl (shows_rule (shows_prec Zero_nat)
                        (shows_prec_list Zero_nat) [' ', '-', '>', ' '] x .
                       shows_prec_list Zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                           'u', 'l', 'e', ' ', 'o', 'f', ' ', 't', 'h', 'e',
                           ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                           'y', 's', 't', 'e', 'm', ' '])))
         (\ _ ->
           let {
             urc = is_ur_closed_impl_dpp_mv i dpp u;
             check_urc =
               (\ sa tb ->
                 check (urc sa tb)
                   (shows_prec_list Zero_nat ['t', 'e', 'r', 'm', ' '] .
                     shows_prec_term Zero_nat tb .
                       shows_prec_list Zero_nat
                         [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'l', 'o',
                           's', 'e', 'd', ' ', 'u', 'n', 'd', 'e', 'r', ' ',
                           'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                           'e', 's']));
             nfs = nfsc i dpp;
           } in bindb (catcha
                        (forallM
                          (\ (l, _) ->
                            check (not (is_Var l))
                              (shows_prec_list Zero_nat
                                ['l', 'h', 's', 's', ' ', 'm', 'u', 's', 't',
                                  ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'v',
                                  'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
                          u)
                        (\ x -> Inl (snd x)))
                  (\ _ ->
                    bindb (check (wf_rule lr)
                            (shows_rule (shows_prec Zero_nat)
                               (shows_prec_list Zero_nat) [' ', '-', '>', ' ']
                               lr .
                              shows_prec_list Zero_nat
                                [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a',
                                  ' ', 'w', 'e', 'l', 'l', ' ', 'f', 'o', 'r',
                                  'm', 'e', 'd', ' ', 'r', 'u', 'l', 'e']))
                      (\ _ ->
                        bindb (if nfs && sound then Inr ()
                                else catcha
                                       (check_subseteq (vars_term_list tp)
 (vars_term_list s))
                                       (\ _ ->
 Inl (shows_prec_list Zero_nat
       ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'n', 'd', 'i',
         't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'v',
         'i', 'o', 'l', 'a', 't', 'e', 'd'])))
                          (\ _ ->
                            bindb (catcha (forallM (check_urc ss) ts)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (catcha
(forallM (\ (l, a) -> check_urc (args l) a) u) (\ x -> Inl (snd x)))
                                  (\ _ ->
                                    bindb (catcha
    (check_critical_pairs_innermost u)
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's', 'h',
               'o', 'w', 'i', 'n', 'g', ' ', 'U', 'N', 'F', ' ', 'o', 'f', ' ',
               'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's'] .
            shows_nl . x)))
                                      (\ _ ->
catcha
  (forallM
    (\ (_, (sa, tb)) ->
      check (equal_term sa tb)
        (shows_prec_list Zero_nat
          ['n', 'o', 'n', '-', 't', 'r', 'i', 'v', 'i', 'a', 'l', ' ', 'c', 'r',
            'i', 't', 'i', 'c', 'a', 'l', ' ', 'p', 'a', 'i', 'r', ' ', 'b',
            'e', 't', 'w', 'e', 'e', 'n', ' ', 'r', 'u', 'l', 'e', ' ', 't',
            'o', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 'a', 'n', 'd',
            ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']))
    (critical_pairs_impl [lr] u))
  (\ x -> Inl (snd x)))))))));

check_prop_rstepa ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => Bool ->
                    (Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                      [(Term a b, Term a b)] ->
                        Pos ->
                          (Term a b, Term a b) ->
                            Term a b ->
                              Term a b ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_prop_rstepa nfs pa r p rule s t =
  bindb (check (membera r rule)
          (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
             [' ', '-', '>', ' '] rule .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r', 'u', 'l',
                'e', ' ', 'o', 'f'] .
              shows_nl .
                shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
                  ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's', 't',
                    'e', 'm', ':']
                  [' ', '-', '>', ' '] r .
                  shows_nl))
    (\ _ -> check_prop_rstep_rule nfs pa p rule s t);

check_rstep ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Pos ->
                      (Term a b, Term a b) ->
                        Term a b ->
                          Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rstep = check_prop_rstepa False (\ _ -> Inr ());

rewriting_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Maybe [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                      (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                        (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                          (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                            (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                              Pos ->
                                a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rewriting_proc i u stb sta st lr p dpp =
  (case let {
          s = fst stb;
          t = snd sta;
        } in bindb (check_rstep (rulesd i dpp) p lr (snd stb) t)
               (\ _ ->
                 bindb (check (nFQ_subset_NF_rulesb i dpp)
                         (shows_prec_list Zero_nat
                           ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ',
                             'r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                             'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                   (\ _ ->
                     bindb (check_rewrite_common_preconditions i u stb [s]
                             [subt_at (snd stb) p] t lr p True dpp)
                       (\ _ ->
                         bindb (check (eq_rule_mod_vars sta st)
                                 (shows_prec_list Zero_nat
                                    ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                                      ' '] .
                                   shows_rule (shows_prec Zero_nat)
                                     (shows_prec_list Zero_nat)
                                     [' ', '-', '>', ' '] sta .
                                     shows_prec_list Zero_nat
                                       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
 'a', ' ', 'r', 'e', 'n', 'a', 'm', 'e', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'n',
 't', ' ', 'o', 'f', ' '] .
                                       shows_rule (shows_prec Zero_nat)
 (shows_prec_list Zero_nat) [' ', '-', '>', ' '] st))
                           (\ _ ->
                             bindb (check (equal_term s (fst sta))
                                     (shows_prec_list Zero_nat
                                       ['l', 'e', 'f', 't', '-', 'h', 'a', 'n',
 'd', ' ', 's', 'i', 'd', 'e', 's', ' ', 'o', 'f', ' ', 'o', 'l', 'd', ' ', 'a',
 'n', 'd', ' ', 'n', 'e', 'w', ' ', 'p', 'a', 'i', 'r', ' ', 'd', 'i', 'f', 'f',
 'e', 'r']))
                               (\ _ ->
                                 bindb (check
 (membera (pa i dpp) stb || null (rc i dpp))
 (shows_prec_list Zero_nat
   ['s', 't', 'r', 'i', 'c', 't', ' ', 'D', 'P', ' ', 'o', 'r', ' ', 'n', 'o',
     ' ', 's', 't', 'r', 'i', 'c', 't', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'r',
     'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                                   (\ _ ->
                                     check (nfsc i dpp || wwf_rulesa i dpp)
                                       (shows_prec_list Zero_nat
 ['w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd', ' ', 'r', 'u', 'l',
   'e', 's', ' ', 'o', 'r', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 's', 'u',
   'b', 's', 't', '.', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd'])))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp stb [st]);
  });

nF_subst_impl ::
  forall a b.
    (Eq b) => (Term a b -> Bool) ->
                Bool -> (Term a b, Term a b) -> (b -> Term a b) -> Bool;
nF_subst_impl nf nfs r sigma =
  (if nfs then all (\ x -> nf (sigma x)) (vars_rule_list r) else True);

qnarrows_impl ::
  forall a.
    (Eq a) => (Term a [Prelude.Char] -> Bool) ->
                Bool ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    Term a [Prelude.Char] ->
                      [(Term a [Prelude.Char],
                         [Prelude.Char] -> Term a [Prelude.Char])];
qnarrows_impl isnf nfs r t =
  concatMap
    (\ p ->
      let {
        tp = subt_at t p;
      } in (if not (is_Var tp)
             then concatMap
                    (\ (l, ra) ->
                      concatMap
                        (\ (mu_1, mu_2) ->
                          (if nF_subst_impl isnf nfs (l, ra) mu_2
                            then (if all isnf (args (subst_apply_term l mu_2))
                                   then [(ctxt_apply
    (ctxt_of_pos_term p (subst_apply_term t mu_1)) (subst_apply_term ra mu_2),
   mu_1)]
                                   else [])
                            else []))
                        (option_to_list
                          (mgu_var_disjoint_generic (\ a -> 'x' : a)
                            (\ a -> 'y' : a) tp l)))
                    r
             else []))
    (poss_list t);

narrowing_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    (Term b [Prelude.Char], Term b [Prelude.Char]) ->
                      Pos ->
                        [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
narrowing_proc i st p sts dpp =
  (case let {
          (s, t) = st;
          q = qc i dpp;
        } in bindb (check
                     (nFQ_subset_NF_rulesb i dpp || null q && linear_term t)
                     (shows_prec_list Zero_nat
                       ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'o',
                         'r', ' ', 'f', 'u', 'l', 'l', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'r', 'e', 'q', 'u', 'i',
                         'r', 'e', 'd', ' ', '(', 'a', 'n', 'd', ' ', 'l', 'i',
                         'n', 'e', 'a', 'r', 'i', 't', 'y', ' ', 'o', 'f', ' ',
                         't', ' ', 'i', 'n', ' ', 'f', 'u', 'l', 'l', ' ', 'r',
                         'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'c', 'a',
                         's', 'e', ')']))
               (\ _ ->
                 let {
                   ic = icap_impl_dpp_mv i dpp;
                   isnf = is_QNFc i dpp;
                   pairs = pairsa i dpp;
                 } in bindb (check (membera (poss_list t) p)
                              (shows_prec_list Zero_nat
                                 ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ',
                                   'n', 'o', 't', ' ', 'c', 'o', 'n', 't', 'a',
                                   'i', 'n', 'e', 'd', ' ', 'i', 'n', ' '] .
                                shows_prec_term Zero_nat t))
                        (\ _ ->
                          let {
                            tp = subt_at t p;
                            nftp = isnf tp;
                          } in bindb (check
                                       (membera (poss_list (ic [s] t)) p ||
 not nftp)
                                       (shows_prec_list Zero_nat
 ['n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'i', 's', ' ', 'p', 'o', 's', 'i',
   't', 'i', 'o', 'n', ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 'e', 'd', ' ',
   'i', 'n', ' ', 'c', 'a', 'p', 'p', 'e', 'd', ' ', 't', 'e', 'r', 'm', ' ',
   'o', 'f', ' ', 't', ',', ' ', 'n', 'o', 'r', ' ', 'i', 's', ' ', 't', '|',
   '_', 'p', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'Q', '-', 'n', 'o', 'r',
   'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']))
                                 (\ _ ->
                                   let {
                                     nfs = nfsc i dpp;
                                     narrows =
                                       qnarrows_impl isnf nfs (rulesd i dpp) tp;
                                     stsa =
                                       filter (\ (smu, _) -> isnf smu)
 (map (\ (ta, mu) ->
        (subst_apply_term s mu,
          ctxt_apply (ctxt_of_pos_term p (subst_apply_term t mu)) ta))
   narrows);
                                   } in bindb
  (catcha
    (forallM
      (\ new ->
        check (any (\ sta ->
                     instance_rule new sta &&
                       (not nfs || (null q || wf_rule sta)))
                sts)
          (shows_prec_list Zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n',
               'd', ' ', 'n', 'a', 'r', 'r', 'o', 'w', 'e', 'd', ' ', 'p', 'a',
               'i', 'r', ' '] .
            shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
              [' ', '-', '>', ' '] new))
      stsa)
    (\ x -> Inl (snd x)))
  (\ _ ->
    let {
      iedg = is_iedg_edge_dpp i dpp (s, t);
    } in bindb (catcha (check_subseteq (vars_term_list tp) (vars_term_list s))
                 (\ x ->
                   Inl (shows_prec_list Zero_nat
                         (['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] ++
                           x ++ [' ', 'o', 'n', 'l', 'y', ' ', 'o', 'c', 'c',
                                  'u', 'r', 's', ' ', 'o', 'n', ' ', 'r', 'h',
                                  's', ' ', 'o', 'f', ' ', 'p', 'a', 'i',
                                  'r']))))
           (\ _ ->
             bindb (check (membera (pa i dpp) st || null (rc i dpp))
                     (shows_prec_list Zero_nat
                       ['s', 't', 'r', 'i', 'c', 't', ' ', 'D', 'P', ' ', 'o',
                         'r', ' ', 'n', 'o', ' ', 's', 't', 'r', 'i', 'c', 't',
                         ' ', 'r', 'u', 'l', 'e', 's', ' ', 'r', 'e', 'q', 'u',
                         'i', 'r', 'e', 'd']))
               (\ _ ->
                 (if nftp
                   then catcha
                          (forallM
                            (\ (u, v) ->
                              bindb (check (membera (poss_list u) p)
                                      (shows_prec_list Zero_nat
 ['p', 'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'n', 'o', 't', ' ', 'c', 'o',
   'n', 't', 'a', 'i', 'n', 'e', 'd', ' ', 'i', 'n', ' ', 'l', 'h', 's', ' ',
   'o', 'f', ' ', 'p', 'a', 'i', 'r', ' '] .
shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat) [' ', '-', '>', ' ']
  (u, v)))
                                (\ _ ->
                                  (case mgu_var_disjoint_generic
  (\ a -> 'x' : a) (\ a -> 'y' : a) tp (subt_at u p)
                                    of {
                                    Nothing -> Inr ();
                                    Just (mu_1, mu_2) ->
                                      check
(not (isnf (subst_apply_term s mu_1)) || not (isnf (subst_apply_term u mu_2)))
(shows_prec_list Zero_nat
   ['t', ' ', '|', '_', ' ', 'p', ' ', 'a', 'n', 'd', ' ', 'u', ' ', '|', '_',
     ' ', 'p', ' ', 'u', 'n', 'i', 'f', 'y', ' ', 'a', 'n', 'd', ' ', 's', 'a',
     't', 'i', 's', 'f', 'y', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ',
     'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'p',
     'a', 'i', 'r', ' ', '(', 'u', ',', 'v', ')', ' ', '=', ' '] .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
    [' ', '-', '>', ' '] (u, v));
                                  })))
                            (filter (\ (u, _) -> iedg u) pairs))
                          (\ x -> Inl (snd x))
                   else Inr ())))))))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

extract_renamings :: forall a. (Eq a) => [(a, a)] -> (a -> a, a -> a);
extract_renamings old_new =
  (fun_of_map_fun (map_of old_new) id,
    fun_of_map_fun (map_of (map swap old_new)) id);

extract_components ::
  forall a. (Eq a) => [(a, Nat)] -> [(a, a)] -> (a -> a, (a -> a, [a]));
extract_components mu old_new =
  let {
    (d, da) = extract_renamings old_new;
    c = map_filter
          (\ x ->
            (if let {
                  (_, a) = x;
                } in equal_nat a Zero_nat
              then Just (fst x) else Nothing))
          mu;
    nu = map d c;
  } in (d, (da, nu));

check_components ::
  forall a.
    (Eq a,
      Showa a) => [(a, Nat)] ->
                    (a -> a, (a -> a, [a])) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_components mu ddNU =
  let {
    (d, (da, nu)) = ddNU;
  } in bindb (catcha
               (forallM
                 (\ f ->
                   bindb (check (not (membera mu (f, Nat_of_num One)))
                           (shows_prec_list Zero_nat
                              ['n', 'e', 'w', ' ', 'u', 'n', 'a', 'r', 'y', ' ',
                                's', 'y', 'm', 'b', 'o', 'l', ' '] .
                             shows_prec Zero_nat f .
                               shows_prec_list Zero_nat
                                 [' ', 'c', 'l', 'a', 's', 'h', 'e', 's', ' ',
                                   'w', 'i', 't', 'h', ' ', 'o', 'l', 'd', ' ',
                                   's', 'y', 'm', 'b', 'o', 'l']))
                     (\ _ ->
                       bindb (check (d (da f) == f)
                               (shows_prec_list Zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                    'i', 't', 'h', ' ', 'b', 'i', 'j', 'e', 'c',
                                    't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ',
                                    'r', 'e', 'n', 'a', 'm', 'i', 'n', 'g', ' ',
                                    'o', 'f', ' '] .
                                 shows_prec Zero_nat f))
                         (\ _ ->
                           check (membera mu (da f, Zero_nat))
                             (shows_prec_list Zero_nat
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                  'i', 't', 'h', ' ', 'i', 'n', 'v', 'e', 'r',
                                  's', 'e', ' ', 'r', 'e', 'n', 'a', 'm', 'i',
                                  'n', 'g', ' ', 'o', 'f', ' '] .
                               shows_prec Zero_nat f))))
                 nu)
               (\ x -> Inl (snd x)))
         (\ _ ->
           catcha
             (forallM
               (\ (f, n) ->
                 bindb (check (less_eq_nat n (Nat_of_num One))
                         (shows_prec_list Zero_nat
                            ['a', 'r', 'i', 't', 'y', ' ', '>', ' ', '1', ' ',
                              'f', 'o', 'r', ' ', 's', 'y', 'm', 'b', 'o', 'l',
                              ' '] .
                           shows_prec Zero_nat f))
                   (\ _ ->
                     check (if equal_nat n Zero_nat
                             then membera nu (d f) && da (d f) == f else True)
                       (shows_prec_list Zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                            't', 'h', ' ', 'b', 'i', 'j', 'e', 'c', 't', 'i',
                            'o', 'n', ' ', 'f', 'o', 'r', ' ', 'r', 'e', 'n',
                            'a', 'm', 'i', 'n', 'g', ' ', 'o', 'f', ' ', 'c',
                            'o', 'n', 's', 't', 'a', 'n', 't', ' '] .
                         shows_prec Zero_nat f)))
               mu)
             (\ x -> Inl (snd x)));

str :: forall a b. (a -> a) -> b -> Term a b -> Term a b;
str d x (Fun f (v : vb : vc)) = Fun (d f) [Var x];
str d x (Fun f []) = Fun (d f) [Var x];
str d x (Fun f [t]) = Fun f [str d x t];
str d uu (Var x) = Var x;

choose_var :: forall a b. (Eq a) => a -> Term b a -> a;
choose_var x l = hd (vars_term_list l ++ [x]);

check_to_srs_sound ::
  forall a b.
    (Cenum a, Ceq a, Corder a, Eq a, Set_impl a, Showa a, Eq b,
      Showa b) => a -> [(b, b)] ->
                         [(Term b a, Term b a)] ->
                           [(Term b a, Term b a)] ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_to_srs_sound v old_new r s =
  let {
    mu = funas_trs_list r;
    (d, (da, nu)) = extract_components mu old_new;
  } in bindb (check_components mu (d, (da, nu)))
         (\ _ ->
           bindb (check_varcond_subset r)
             (\ _ ->
               catcha
                 (forallM
                   (\ (l, ra) ->
                     let {
                       y = choose_var v l;
                       stra = str d y;
                       slr = (stra l, stra ra);
                     } in check (less_eq_set (vars_term l)
                                   (inserta y bot_set) &&
                                  membera s slr)
                            (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' ', 'n', 'e', 'w', ' ', 'r',
                                 'u', 'l', 'e', ' '] .
                              shows_rule (shows_prec Zero_nat)
                                (shows_prec Zero_nat) [' ', '-', '>', ' '] slr))
                   r)
                 (\ x -> Inl (snd x))));

rulesc :: forall a b c d. Tp_ops_ext a b c d -> a -> [(Term b c, Term b c)];
rulesc
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = rules;

const_to_string_sound_tt ::
  forall a b c.
    (Eq a, Showa a, Cenum b, Ceq b, Corder b, Eq b, Set_impl b,
      Showa b) => Const_string_sound_proof a b ->
                    Tp_ops_ext c a b () ->
                      c -> Sum ([Prelude.Char] -> [Prelude.Char]) c;
const_to_string_sound_tt (Const_string_sound_proof v old_new s) i tp =
  bindb (check_to_srs_sound v old_new (rulesc i tp) s)
    (\ _ -> Inr (mkb i False [] s []));

applicable_rule_impla ::
  forall a b. (Term a b -> Bool) -> (Term a b, Term a b) -> Bool;
applicable_rule_impla q lr = all q (args (fst lr));

is_QNFb :: forall a b c d. Tp_ops_ext a b c d -> a -> Term b c -> Bool;
is_QNFb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = is_QNF;

dP_list ::
  forall a b.
    (Eq a,
      Eq b) => (a -> a) ->
                 [(Term a b, Term a b)] -> [(a, Nat)] -> [(Term a b, Term a b)];
dP_list shp r d_list =
  concatMap
    (\ lr ->
      let {
        l = fst lr;
        s = sharp_term shp l;
      } in map_filter
             (\ x ->
               (if not (supt_impl l x) &&
                     not (is_Var x) && membera d_list (the (root x))
                 then Just (s, sharp_term shp x) else Nothing))
             (supteq_list (snd lr)))
    r;

dependency_pairs_tt ::
  forall a b c d.
    (Eq b, Linorder b, Showa b, Corder c, Eq c, Mapping_impl c, Linorder c,
      Showa c) => Tp_ops_ext a b c () ->
                    Dpp_ops_ext d b c () ->
                      a -> Bool ->
                             Bool ->
                               (b -> b) ->
                                 [(Term b c, Term b c)] ->
                                   Sum ([Prelude.Char] -> [Prelude.Char]) d;
dependency_pairs_tt i j tp nfs m shp p =
  let {
    r = rulesc i tp;
    q = qb i tp;
    iQ = is_QNFb i tp;
    u = filter (applicable_rule_impla iQ) r;
  } in (case catcha
               (bindb
                 (if isOK (check_wf_trs u) then Inr ()
                   else check (nfs &&
                                nfsb i tp &&
                                  isOK (check_NF_terms_subset q (map fst r)) &&
                                    all (\ l -> not (is_Var l)) (map fst r))
                          (shows_prec_list Zero_nat
                            ['n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'i', 's',
                              ' ', 't', 'h', 'e', ' ', 'T', 'R', 'S', ' ', 'w',
                              'e', 'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd',
                              ',', ' ', 'n', 'o', 'r', ' ', 'i', 's', ' ', 't',
                              'h', 'e', ' ', 'r', 'e', 's', 't', 'r', 'i', 'c',
                              't', 'i', 'o', 'n', ' ', 't', 'o', ' ', 'i', 'n',
                              'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'w', 'i',
                              't', 'h', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ',
                              'f', 'o', 'r', 'm', ' ', 's', 'u', 'b', 's', 't',
                              'i', 't', 'u', 't', 'i', 'o', 'n', 's', ' ', 'p',
                              'r', 'e', 's', 'e', 'n', 't']))
                 (\ _ ->
                   bindb (catcha (forallM check_no_var q) (\ x -> Inl (snd x)))
                     (\ _ ->
                       let {
                         qr = map (\ (Fun f ss) -> (f, size_list ss)) q;
                         d = defined_list u;
                       } in bindb (catcha
                                    (forallM
                                      (\ (f, n) ->
check (not (membera d (shp f, n)))
  (shows_string ['s', 'h', 'a', 'r', 'p', 'i', 'n', 'g', ' '] .
    shows_prec Zero_nat f .
      shows_string
        [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 't', 'h', 'e', ' ', 'd', 'e',
          'f', 'i', 'n', 'e', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' '] .
        shows_prec Zero_nat (shp f)))
                                      d)
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                bindb (catcha
(forallM
  (\ (f, n) ->
    check (not (membera qr (shp f, n)))
      (shows_string ['s', 'h', 'a', 'r', 'p', 'i', 'n', 'g', ' '] .
        shows_prec Zero_nat f .
          shows_string
            [' ', 'y', 'i', 'e', 'l', 'd', 's', ' ', 't', 'h', 'e', ' ', 's',
              'y', 'm', 'b', 'o', 'l', ' '] .
            shows_prec Zero_nat (shp f) .
              shows_string
                [' ', 'w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'a', ' ',
                  'r', 'o', 'o', 't', ' ', 'o', 'f', ' ', 'Q']))
  d)
(\ x -> Inl (snd x)))
                                  (\ _ ->
                                    let {
                                      pa = set p;
                                    } in catcha
   (catcha
     (forallM
       (\ x ->
         (if member x pa || any (eq_rule_mod_vars x) p then Inr () else Inl x))
       (dP_list shp u d))
     (\ x -> Inl (snd x)))
   (\ x ->
     Inl (shows_string ['t', 'h', 'e', ' ', 'D', 'P', ' '] .
           shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
             [' ', '-', '>', ' '] x .
             shows_string
               [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p',
                 'e', 'a', 'r', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'D',
                 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
               shows_nl)))))))
               (\ x ->
                 Inl (shows_string
                        ['t', 'h', 'e', ' ', 'D', 'P', '-', 't', 'r', 'a', 'n',
                          's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n', ' ',
                          'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p', 'l',
                          'i', 'e', 'd', ' ', 'c', 'o', 'r', 'r', 'e', 'c', 't',
                          'l', 'y', '.'] .
                       shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc j nfs m p [] q [] r);
       });

switch_innermost_tt ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_innermost_tt i joins_i trs =
  let {
    r = rulesc i trs;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catcha
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list Zero_nat
                                  ['r', 'u', 'l', 'e', 's', ' ', 'a', 'r', 'e',
                                    ' ', 'n', 'o', 't', ' ', 'o', 'v', 'e', 'r',
                                    'l', 'a', 'y']))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_critical_pairs r cp joins_i)
                        (\ _ -> check_wf_trs r))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i True (map fst r) r []);
       });

unary_term :: forall a b. Term a b -> Bool;
unary_term (Var x) = True;
unary_term (Fun f [t]) = unary_term t;
unary_term (Fun v []) = False;
unary_term (Fun v (vb : vd : ve)) = False;

check_unary_signature ::
  forall a b.
    (Showa a,
      Showa b) => [(Term a b, Term a b)] ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unary_signature r =
  catcha
    (catcha
      (forallM
        (\ x ->
          (if let {
                (l, ra) = x;
              } in unary_term l && unary_term ra
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
            shows_nl .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                [' ', '-', '>', ' '] x .
                shows_nl .
                  shows_string
                    ['v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 't', 'h', 'e',
                      ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', ' ',
                      't', 'h', 'a', 't', ' ', 'a', 'l', 'l', ' ', 'f', 'u',
                      'n', 'c', 't', 'i', 'o', 'n', ' ', 's', 'y', 'm', 'b',
                      'o', 'l', 's'] .
                    shows_nl .
                      shows_prec_list Zero_nat
                        ['h', 'a', 'v', 'e', ' ', 't', 'o', ' ', 'b', 'e', ' ',
                          'u', 'n', 'a', 'r', 'y']));

rev_term :: forall a b. Ctxt a b -> Term a b -> Term a b;
rev_term c (Var x) = ctxt_apply c (Var x);
rev_term c (Fun f [t]) = rev_term (More f [] c []) t;

rev_rule :: forall a b. (Term a b, Term a b) -> (Term a b, Term a b);
rev_rule (l, r) = (rev_term Hole l, rev_term Hole r);

string_reversal_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_tt i trs =
  let {
    rs = rulesc i trs;
    r = rb i trs;
    s = rwb i trs;
  } in (case check_unary_signature rs of {
         Inl a -> Inl a;
         Inr _ ->
           Inr (mkb i default_nfs_trs [] (map rev_rule r) (map rev_rule s));
       });

q_emptyb :: forall a b c d. Tp_ops_ext a b c d -> a -> Bool;
q_emptyb
  (Tp_ops_ext qreltrs q r rw rules q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs more)
  = q_empty;

sem_lab_rel_tt ::
  forall a b c d.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => ([(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]))) ->
                    (a -> (a, c)) ->
                      Tp_ops_ext d a b () ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) () ->
                          ([(Term a b, Term a b)] ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                            ([(Term a b, Term a b)] ->
                              [(Term a b, Term a b)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              [Term a b] ->
                                [(Term a b, Term a b)] ->
                                  d -> Sum ([Prelude.Char] -> [Prelude.Char]) d;
sem_lab_rel_tt splitter ld i valid check_decr check_model_lab lQ lAll tp =
  let {
    r = rb i tp;
    rw = rwb i tp;
    nfs = nfsb i tp;
    (lR, (lRw, d)) = splitter lAll rw;
  } in (case bindb valid
               (\ _ ->
                 let {
                   q = qb i tp;
                 } in catcha
                        (bindb
                          (if nfs && not (q_emptyb i tp) then check_wf_trs d
                            else Inr ())
                          (\ _ ->
                            bindb (check_decr d)
                              (\ _ ->
                                bindb (check_sl_Q ld lQ q)
                                  (\ _ ->
                                    bindb (check_model_lab lR r)
                                      (\ _ -> check_model_lab lRw rw)))))
                        (\ x ->
                          Inl (shows_string
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                   'i', 't', 'h', ' ', 'l', 'a', 'b', 'e', 'l',
                                   'e', 'd', ' ', 'T', 'R', 'S', ':'] .
                                shows_nl . x)))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i nfs lQ lR (lRw ++ d));
       });

sem_lab_fin_tt ::
  forall a b c d e.
    (Eq a, Linorder a, Showa a, Corder b, Eq b, Mapping_impl b, Linorder b,
      Showa b,
      Showa d) => ([(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)], [(Term a b, Term a b)]))) ->
                    (a -> Nat -> c -> a) ->
                      (a -> (a, c)) ->
                        (d -> d -> Bool) ->
                          Tp_ops_ext e a b () ->
                            ([(a, Nat)] ->
                              [(a, Nat)] ->
                                Sum ([Prelude.Char] -> [Prelude.Char])
                                  (Sl_ops_ext a d c b ())) ->
                              [Term a b] ->
                                [(Term a b, Term a b)] ->
                                  e -> Sum ([Prelude.Char] -> [Prelude.Char]) e;
sem_lab_fin_tt splitter lc ld cge i gen lQ lAll tp =
  bindb (gen (funas_trs_list (rulesc i tp)) [])
    (\ ops ->
      let {
        check_ml =
          check_sl_model_lab_trs (sl_I ops) (sl_L ops) (sl_C ops) cge lc;
        check_d = sl_check_decr ops;
      } in sem_lab_rel_tt splitter ld i (Inr ()) check_d check_ml lQ lAll tp);

semlab_fin_tt ::
  forall a b c.
    (Eq b, Linorder b, Showa b, Corder c, Eq c, Mapping_impl c, Linorder c,
      Showa c) => Tp_ops_ext a (Lab b [Nat]) c () ->
                    Sl_variant (Lab b [Nat]) c ->
                      [Term (Lab b [Nat]) c] ->
                        [(Term (Lab b [Nat]) c, Term (Lab b [Nat]) c)] ->
                          a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
semlab_fin_tt j (Rootlab uu) =
  sem_lab_fin_tt (model_splitter label_decomp) label label_decomp equal_lab j
    (slm_gen_to_sl_gen (rl_slm Nothing));
semlab_fin_tt j (Finitelab sli) =
  sem_lab_fin_tt (model_splitter label_decomp) label label_decomp equal_nat j
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli)));
semlab_fin_tt j (QuasiFinitelab sli v) =
  sem_lab_fin_tt (quasi_splitter label_decomp) label label_decomp qmodel_cge j
    (\ f g -> qsli_to_sl v f g sli);

check_permutation_afs ::
  forall a.
    (Showa a) => [((a, Nat), Af_entry)] ->
                   Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_permutation_afs pi =
  catcha
    (forallM
      (\ (a, b) ->
        let {
          (f, n) = a;
        } in (\ e ->
               catcha
                 (case e of {
                   Collapse _ ->
                     Inl (shows_prec_list Zero_nat
                           ['c', 'o', 'l', 'l', 'a', 'p', 's', 'i', 'n', 'g',
                             ' ', 'e', 'n', 't', 'r', 'y', ' ', 'n', 'o', 't',
                             ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd']);
                   AFList ids ->
                     check (distinct ids &&
                             eq_set (set ids) (set (upt Zero_nat n)))
                       (shows_prec_list Zero_nat
                         ['e', 'v', 'e', 'r', 'y', ' ', 'p', 'o', 's', 'i', 't',
                           'i', 'o', 'n', ' ', 'n', 'e', 'e', 'd', 's', ' ',
                           't', 'o', ' ', 'o', 'c', 'c', 'u', 'r', ' ', 'e',
                           'x', 'a', 'c', 't', 'l', 'y', ' ', 'o', 'n', 'c',
                           'e']);
                 })
                 (\ x ->
                   Inl (shows_prec_list Zero_nat
                          ['a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'f',
                            'i', 'l', 't', 'e', 'r', ' ', 'i', 's', ' ', 'n',
                            'o', 't', ' ', 'a', ' ', 'p', 'e', 'r', 'm', 'u',
                            't', 'a', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r',
                            ' '] .
                         shows_prec_prod Zero_nat (f, n) . shows_nl . x)))
          b)
      pi)
    (\ x -> Inl (snd x));

argument_filter_tt ::
  forall a b c.
    (Key b,
      Showa b) => Tp_ops_ext a b c () ->
                    [((b, Nat), Af_entry)] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
argument_filter_tt i pi tp =
  bindb (check_permutation_afs pi)
    (\ _ ->
      let {
        pia = af_rules (afs_list_to_afs pi);
      } in Inr (mkb i default_nfs_trs [] (pia (rb i tp)) (pia (rwb i tp))));

rule_removal_tt ::
  forall a b c.
    (Showa b,
      Showa c) => Tp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_tt i rp rremove trs =
  (case catcha
          (let {
             (rs, rns) = split_rulesb i trs rremove;
           } in bindb (valid rp)
                  (\ _ ->
                    bindb (catcha (mono rp (rs ++ rns))
                            (\ x ->
                              Inl (shows_string
                                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                       'w', 'i', 't', 'h', ' ', 'm', 'o', 'n',
                                       'o', 't', 'o', 'n', 'i', 'c', 'i', 't',
                                       'y', ' ', 'o', 'f', ' ', 's', 't', 'r',
                                       'i', 'c', 't', ' ', 'o', 'r', 'd', 'e',
                                       'r'] .
                                    shows_nl . x)))
                      (\ _ ->
                        bindb (catcha
                                (catcha (forallM (ns rp) rns)
                                  (\ x -> Inl (snd x)))
                                (\ x ->
                                  Inl (shows_string
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
   'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T', 'R', 'S'] .
shows_nl . x)))
                          (\ _ ->
                            catcha
                              (catcha (forallM (s rp) rs) (\ x -> Inl (snd x)))
                              (\ x ->
                                Inl (shows_string
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
 'w', 'h', 'e', 'n', ' ', 'o', 'r', 'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'T',
 'R', 'S'] .
                                      shows_nl . x))))))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'a', 'p',
                     'p', 'l', 'y', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'd', 'u',
                     'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                     'h', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w',
                     'i', 'n', 'g'] .
                  shows_nl . desc rp . shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (delete_R_Rwb i trs rremove rremove);
  });

applicable_rule_impl ::
  forall a b. (Term a b -> Bool) -> (Term a b, Term a b) -> Bool;
applicable_rule_impl nf r = all nf (args (fst r));

check_wwf_qtrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => (Term a b -> Bool) ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wwf_qtrs nf r =
  catcha
    (catcha
      (forallM
        (\ ra ->
          (if applicable_rule_impl nf ra
            then catcha
                   (bindb
                     (check (not (is_Var (fst ra)))
                       (shows_string
                         ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'l', 'e',
                           'f', 't', '-', 'h', 'a', 'n', 'd', ' ', 's', 'i',
                           'd', 'e', ' ', 'i', 'n']))
                     (\ _ ->
                       catcha
                         (check_subseteq (vars_term_list (snd ra))
                           (vars_term_list (fst ra)))
                         (\ x ->
                           Inl (shows_string
                                  ['f', 'r', 'e', 'e', ' ', 'v', 'a', 'r', 'i',
                                    'a', 'b', 'l', 'e', ' '] .
                                 shows_prec Zero_nat x .
                                   shows_string
                                     [' ', 'i', 'n', ' ', 'r', 'i', 'g', 'h',
                                       't', '-', 'h', 'a', 'n', 'd', ' ', 's',
                                       'i', 'd', 'e', ' ', 'o', 'f']))))
                   (\ x ->
                     Inl (x . shows_string [' ', 'r', 'u', 'l', 'e', ' '] .
                                shows_rule (shows_prec Zero_nat)
                                  (shows_prec Zero_nat) [' ', '-', '>', ' ']
                                  ra .
                                  shows_nl))
            else Inr ()))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (shows_string
             ['t', 'h', 'e', ' ', 'Q', '-', 'T', 'R', 'S', ' ', 'i', 's', ' ',
               'n', 'o', 't', ' ', 'w', 'e', 'a', 'k', 'l', 'y', ' ', 'w', 'e',
               'l', 'l', '-', 'f', 'o', 'r', 'm', 'e', 'd'] .
            shows_nl . x));

check_compatible_nfs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => Bool ->
                    (Term a b -> Bool) ->
                      [(Term a b, Term a b)] -> Bool -> [Term a b] -> Bool;
check_compatible_nfs nfs1 nf1 r1 nfs2 q2 =
  nfs1 == nfs2 || (null q2 || isOK (check_wwf_qtrs nf1 r1));

shows_tp ::
  forall a b c.
    (a -> [Prelude.Char] -> [Prelude.Char]) ->
      (b -> [Prelude.Char] -> [Prelude.Char]) ->
        Tp_ops_ext c a b () -> c -> [Prelude.Char] -> [Prelude.Char];
shows_tp fun var i t =
  let {
    nfs = nfsb i t;
    r = rb i t;
    rw = rwb i t;
    q = qb i t;
  } in shows_trs fun var ['r', 'u', 'l', 'e', 's', ':'] [' ', '-', '>', ' '] r .
         (if null rw then id
           else shows_trs fun var
                  ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l',
                    'e', 's', ':']
                  [' ', '-', '>', '=', ' '] rw) .
           (if null q then id
             else shows_terms fun var
                    ['Q', '-', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', ':']
                    q) .
             (if nfs
               then shows_string
                      ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o',
                        'n', 's', ' ', 'a', 'r', 'e', ' ', 'a', 's', 's', 'u',
                        'm', 'e', 'd', ' ', 't', 'o', ' ', 'b', 'e', ' ', 'i',
                        'n', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
                        'r', 'm'] .
                      shows_nl
               else id);

check_tp_subsumes ::
  forall a b c d.
    (Eq b, Showa b, Eq c, Showa c, Corder d, Eq d, Mapping_impl d,
      Showa d) => Tp_ops_ext a (Lab b c) d () ->
                    (Bool,
                      ([Term (Lab b c) d],
                        ([(Term (Lab b c) d, Term (Lab b c) d)],
                          [(Term (Lab b c) d, Term (Lab b c) d)]))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_tp_subsumes i (nfs, (q, (r, rw))) tp =
  catcha
    (let {
       nfsa = nfsb i tp;
       qa = qb i tp;
       ra = rb i tp;
       rwa = rwb i tp;
       rba = r ++ rw;
       nf1 = is_QNFb i tp;
     } in bindb (check (check_compatible_nfs nfsa nf1 (ra ++ rwa) nfs q)
                  (shows_prec_list Zero_nat
                    ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e',
                      ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i',
                      'o', 'n', 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm',
                      'a', 'l', '-', 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a',
                      'g', 's']))
            (\ _ ->
              bindb (catcha (check_NF_terms_subset qa q)
                      (\ x ->
                        Inl (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' ', 'i', 'n', 'n', 'e', 'r',
                                 'm', 'o', 's', 't', ' ', 's', 't', 'r', 'a',
                                 't', 'e', 'g', 'y', ' ', 'd', 'u', 'e', ' ',
                                 't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
                              shows_term (shows_prec_lab Zero_nat)
                                (shows_prec Zero_nat) x)))
                (\ _ ->
                  bindb (catcha (check_subseteq ra r)
                          (\ x ->
                            Inl (toomuch ['r', 'u', 'l', 'e']
                                  (shows_rule (shows_prec_lab Zero_nat)
                                    (shows_prec Zero_nat) [' ', '-', '>', ' ']
                                    x))))
                    (\ _ ->
                      bindb (catcha (check_subseteq rwa rba)
                              (\ x ->
                                Inl (toomuch
                                      ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e',
' ', 'r', 'u', 'l', 'e']
                                      (shows_rule (shows_prec_lab Zero_nat)
(shows_prec Zero_nat) [' ', '-', '>', ' '] x))))
                        (\ _ -> Inr ())))))
    (\ x ->
      Inl (shows_string
             ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'o',
               'f', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'b', 'l', 'e',
               'm'] .
            shows_nl .
              shows_tp (shows_prec_lab Zero_nat) (shows_prec Zero_nat) i tp .
                shows_nl .
                  shows_string
                    ['m', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'c',
                      'o', 'n', 'c', 'l', 'u', 'd', 'e', 'd', ' ', 'f', 'r',
                      'o', 'm', ' ', 'a', 's', 's', 'u', 'm', 'i', 'n', 'g',
                      ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                      'n', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'p', 'r',
                      'o', 'b', 'l', 'e', 'm'] .
                    shows_nl .
                      shows_tp (shows_prec_lab Zero_nat) (shows_prec Zero_nat) i
                        (mkb i nfs q r rw) .
                        shows_nl . x . shows_nl));

fcc_tt ::
  forall a b c.
    (Eq b, Showa b, Corder c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    [Ctxt b c] ->
                      [(Term b c, Term b c)] ->
                        a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
fcc_tt i fcs cRb tp =
  let {
    r = rb i tp;
    rw = rwb i tp;
    nfs = nfsb i tp;
    rba = r ++ rw;
    (cR, cRw) = partition_rules fcs r cRb;
    _ = qb i tp;
    vs = vars_trs_list rba;
    fas = funas_trs_list rba;
  } in (case bindb (check (not (null fcs))
                     (shows_string
                        ['a', 't', ' ', 'l', 'e', 'a', 's', 't', ' ', 'o', 'n',
                          'e', ' ', 'f', 'l', 'a', 't', ' ', 'c', 'o', 'n', 't',
                          'e', 'x', 't', ' ', 'i', 's', ' ', 'r', 'e', 'q', 'u',
                          'i', 'r', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'f', 'l',
                          'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', ' ',
                          'c', 'l', 'o', 's', 'u', 'r', 'e'] .
                       shows_nl))
               (\ _ ->
                 bindb (catcha (forallM (check_flat_ctxt vs) fcs)
                         (\ x -> Inl (snd x)))
                   (\ _ ->
                     bindb (catcha (forallM (check_is_flat_ctxt vs fas) fcs)
                             (\ x -> Inl (snd x)))
                       (\ _ ->
                         bindb (catcha
                                 (forallM (check_flat_ctxt_complete fcs) fas)
                                 (\ x -> Inl (snd x)))
                           (\ _ ->
                             bindb (catcha
                                     (forallM (check_rule_preserving fcs cR) r)
                                     (\ x -> Inl (snd x)))
                               (\ _ ->
                                 catcha
                                   (forallM (check_rule_preserving fcs cRb) rw)
                                   (\ x -> Inl (snd x)))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i nfs [] cR cRw);
       });

g_isEmpty_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> Bool;
g_isEmpty_dflt_basic_oops_rm_basic_ops s =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s (\ c -> c)
    (\ _ _ -> False) True;

ta_rhs_states_set :: forall a b c. Ta_impl_ext a b c -> Rbt a ();
ta_rhs_states_set
  (Ta_impl_ext ta_final_impl ta_rules_impl ta_r_lhs_states_impl
    ta_rhs_states_set ta_eps_impl ta_epss_impl ta_epsrs_impl more)
  = ta_rhs_states_set;

ta_rules_impl ::
  forall a b c. Ta_impl_ext a b c -> Rbt (b, Nat) [Ta_rule_impl a b];
ta_rules_impl
  (Ta_impl_ext ta_final_impl ta_rules_impl ta_r_lhs_states_impl
    ta_rhs_states_set ta_eps_impl ta_epss_impl ta_epsrs_impl more)
  = ta_rules_impl;

r_lhs_states_impl :: forall a b. Ta_rule_impl a b -> [a];
r_lhs_states_impl (TA_rule_impl f qsa q qs) = qsa;

rm_set_lookup :: forall a b. (Linorder a) => Rbt a [b] -> a -> [b];
rm_set_lookup rm =
  (\ a -> (case lookup rm a of {
            Nothing -> [];
            Just rules -> rules;
          }));

g_union_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> Rbt a () -> Rbt a ();
g_union_dflt_basic_oops_rm_basic_ops s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s1 (\ _ -> True)
    ins_rm_basic_ops s2;

rs_Union :: forall a. (Linorder a) => [Rbt a ()] -> Rbt a ();
rs_Union = foldl g_union_dflt_basic_oops_rm_basic_ops (empty_rm_basic_ops ());

rqss_impl :: forall a b. Ta_rule_impl a b -> Rbt a ();
rqss_impl (TA_rule_impl f qsa q qs) = qs;

ta_res_impl_all ::
  forall a b c.
    (Linorder a,
      Linorder b) => Rbt a () ->
                       Rbt (b, Nat) [Ta_rule_impl a b] -> Term b c -> Rbt a ();
ta_res_impl_all q ta (Var uu) = q;
ta_res_impl_all q ta (Fun f ts) =
  let {
    rec = map (ta_res_impl_all q ta) ts;
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    arules =
      filter
        (\ rule ->
          let {
            qs = r_lhs_states_impl rule;
          } in all_interval_nat
                 (\ i -> memb_rm_basic_ops (nth qs i) (nth rec i)) Zero_nat n)
        rules;
    a = map rqss_impl arules;
  } in rs_Union a;

rule_state_compatible_heuristic ::
  forall a b c.
    (Linorder a, Linorder b,
      Linorder c) => Ta_impl_ext a b () -> Term b c -> Bool;
rule_state_compatible_heuristic ta l =
  g_isEmpty_dflt_basic_oops_rm_basic_ops
    (ta_res_impl_all (ta_rhs_states_set ta) (ta_rules_impl ta) l);

ta_rules_impla :: forall a b. Tree_automaton a b -> [Ta_rule a b];
ta_rules_impla (Tree_Automaton x1 x2 x3) = x2;

rtrancl_rbt_impl :: forall a. (Linorder a) => [(a, a)] -> [a] -> Rbt a ();
rtrancl_rbt_impl =
  rtrancl_impl
    (\ r ->
      let {
        rm = elem_list_to_rm fst r;
      } in (\ asa ->
             g_to_list_dflt_basic_oops_rm_basic_ops
               (rs_Union
                 (map (\ a ->
                        g_from_list_dflt_basic_oops_rm_basic_ops
                          (map snd (rm_set_lookup rm a)))
                   asa))))
    (\ asa bs ->
      g_union_dflt_basic_oops_rm_basic_ops bs
        (g_from_list_dflt_basic_oops_rm_basic_ops asa))
    memb_rm_basic_ops (empty_rm_basic_ops ());

memo_rbt_rtrancl :: forall a. (Linorder a) => [(a, a)] -> a -> Rbt a ();
memo_rbt_rtrancl r =
  let {
    tr = rtrancl_rbt_impl r;
    rm = g_list_to_map_rm_basic_ops
           (map (\ a -> (a, tr [a]))
             (((g_to_list_dflt_basic_oops_rm_basic_ops .
                 g_from_list_dflt_basic_oops_rm_basic_ops) .
                map fst)
               r));
  } in (\ a ->
         (case lookup rm a of {
           Nothing -> g_from_list_dflt_basic_oops_rm_basic_ops [a];
           Just asa -> asa;
         }));

check_state_raise_consistent ::
  forall a b.
    (Eq a, Linorder a, Showa a, Eq b,
      Showa b) => Tree_automaton a (b, Nat) ->
                    [(a, a)] -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_state_raise_consistent ta rel =
  let {
    rels = memo_rbt_rtrancl rel;
    rls = ta_rules_impla ta;
  } in catcha
         (forallM
           (\ r1 ->
             let {
               (TA_rule (f1, i1) qs1 q1) = r1;
             } in catcha
                    (forallM
                      (\ r2 ->
                        let {
                          (TA_rule (f2, i2) qs2 q2) = r2;
                        } in (if f1 == f2 && less_nat i1 i2 && qs1 == qs2
                               then check (memb_rm_basic_ops q2 (rels q1))
                                      (shows_prec_list Zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 'r', 'a',
   'i', 's', 'e', ' ', 'c', 'o', 'n', 's', 'i', 's', 't', 'e', 'n', 'c', 'y',
   ' ', 'b', 'e', 'c', 'a', 'u', 's', 'e', ' ', 'o', 'f', ' ', 'a', 'u', 't',
   'o', 'm', 'a', 't', 'o', 'n', '-', 'r', 'u', 'l', 'e', 's', ' '] .
shows_nl .
  shows_prec_ta_rule Zero_nat r1 .
    shows_nl .
      shows_prec_ta_rule Zero_nat r2 .
        shows_nl .
          shows_prec Zero_nat q1 .
            shows_prec_list Zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', '>', '>', '^', '*',
                ' '] .
              shows_prec Zero_nat q2)
                               else Inr ()))
                      rls)
                    (\ x -> Inl (snd x)))
           rls)
         (\ x -> Inl (snd x));

ta_epsrs_impl :: forall a b c. Ta_impl_ext a b c -> a -> Rbt a ();
ta_epsrs_impl
  (Ta_impl_ext ta_final_impl ta_rules_impl ta_r_lhs_states_impl
    ta_rhs_states_set ta_eps_impl ta_epss_impl ta_epsrs_impl more)
  = ta_epsrs_impl;

ta_epss_impl :: forall a b c. Ta_impl_ext a b c -> a -> Rbt a ();
ta_epss_impl
  (Ta_impl_ext ta_final_impl ta_rules_impl ta_r_lhs_states_impl
    ta_rhs_states_set ta_eps_impl ta_epss_impl ta_epsrs_impl more)
  = ta_epss_impl;

g_inter_dflt_basic_oops_rm_basic_ops ::
  forall a. (Linorder a) => Rbt a () -> Rbt a () -> Rbt a ();
g_inter_dflt_basic_oops_rm_basic_ops s1 s2 =
  iteratei_bset_op_list_it_dflt_basic_oops_rm_basic_ops s1 (\ _ -> True)
    (\ x s -> (if memb_rm_basic_ops x s2 then ins_dj_rm_basic_ops x s else s))
    (empty_rm_basic_ops ());

ta_match_impl ::
  forall a b c.
    (Linorder a, Eq b, Linorder b, Eq c,
      Linorder c) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                       Rbt b () ->
                         (b -> Rbt b ()) -> Term a c -> [b] -> Rbt [(c, b)] ();
ta_match_impl ta qsig eps (Var x) q =
  g_from_list_dflt_basic_oops_rm_basic_ops
    (map (\ qa -> [(x, qa)])
      (g_to_list_dflt_basic_oops_rm_basic_ops
        (g_inter_dflt_basic_oops_rm_basic_ops (rs_Union (map eps q)) qsig)));
ta_match_impl ta qsig eps (Fun f ts) q =
  let {
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    ep = rs_Union (map eps q);
    fa = (\ rule ->
           g_from_list_dflt_basic_oops_rm_basic_ops
             (let {
                (TA_rule_impl _ qs qa _) = rule;
              } in (if memb_rm_basic_ops qa ep
                     then let {
                            rec = map (\ (tsi, qsi) ->
g_to_list_dflt_basic_oops_rm_basic_ops (ta_match_impl ta qsig eps tsi [qsi]))
                                    (zip ts qs);
                          } in map concat (concat_lists rec)
                     else [])));
  } in rs_Union (map fa rules);

ta_match_impla ::
  forall a b c.
    (Linorder a, Eq b, Linorder b, Eq c,
      Linorder c) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                       Rbt b () ->
                         (b -> Rbt b ()) -> [b] -> Term a c -> Rbt [(c, b)] ();
ta_match_impla ta qsig eps rhs t = ta_match_impl ta qsig eps t rhs;

ta_res_impl ::
  forall a b.
    (Linorder a,
      Linorder b) => Rbt (a, Nat) [Ta_rule_impl b a] ->
                       (b -> Rbt b ()) -> Term a b -> Rbt b ();
ta_res_impl ta eps (Var q) = eps q;
ta_res_impl ta eps (Fun f ts) =
  let {
    rec = map (ta_res_impl ta eps) ts;
    n = size_list ts;
    rules = rm_set_lookup ta (f, n);
    arules =
      filter
        (\ rule ->
          let {
            qs = r_lhs_states_impl rule;
          } in all_interval_nat
                 (\ i -> memb_rm_basic_ops (nth qs i) (nth rec i)) Zero_nat n)
        rules;
    a = map rqss_impl arules;
  } in rs_Union a;

rule_state_compatible_eff_list ::
  forall a b c.
    (Eq a, Linorder a, Linorder b, Eq c,
      Linorder c) => Ta_impl_ext a b () ->
                       (Rbt a () -> Rbt a () -> Maybe a) ->
                         (Term b c, Term b c) ->
                           Sum ((Term b a, Term b a), a) ();
rule_state_compatible_eff_list ta rel (l, r) =
  let {
    rm = ta_rules_impl ta;
    eps = ta_epss_impl ta;
    epsa = ta_epsrs_impl ta;
    ta_res = ta_res_impl rm eps;
    rhs_rbt = ta_rhs_states_set ta;
    rhs = g_to_list_dflt_basic_oops_rm_basic_ops rhs_rbt;
  } in catcha
         (forallM
           (\ sigma ->
             let {
               sigmaa = fun_of sigma;
               l_sigma = map_vars sigmaa l;
               r_sigma = map_vars sigmaa r;
               qsl = ta_res l_sigma;
               qsr = ta_res r_sigma;
             } in (case rel qsl qsr of {
                    Nothing -> Inr ();
                    Just q -> Inl ((l_sigma, r_sigma), q);
                  }))
           (g_to_list_dflt_basic_oops_rm_basic_ops
             (ta_match_impla rm rhs_rbt epsa rhs l)))
         (\ x -> Inl (snd x));

state_compatible_eff_list ::
  forall a b c.
    (Eq a, Linorder a, Linorder b, Eq c,
      Linorder c) => Ta_impl_ext a b () ->
                       (Rbt a () -> Rbt a () -> Maybe a) ->
                         [(Term b c, Term b c)] ->
                           Sum ((Term b c, Term b c), ((Term b a, Term b a), a))
                             ();
state_compatible_eff_list ta rel r =
  let {
    check = rule_state_compatible_eff_list ta rel;
  } in catcha (forallM (\ lr -> catcha (check lr) (\ x -> Inl (lr, x))) r)
         (\ x -> Inl (snd x));

flatten_term_enum_filter ::
  forall a b. (Term a b -> Bool) -> Term [a] b -> [Term a b];
flatten_term_enum_filter f (Var x) =
  let {
    tx = Var x;
  } in (if f tx then [tx] else []);
flatten_term_enum_filter f (Fun fs ts) =
  let {
    lts = map (flatten_term_enum_filter f) ts;
  } in (if any null lts then []
         else let {
                ss = concat_lists lts;
              } in filter f (concatMap (\ fa -> map (Fun fa) ss) fs));

inverse_base_term_filter ::
  forall a b. (Term (a, Nat) b -> Bool) -> Term a b -> Nat -> [Term (a, Nat) b];
inverse_base_term_filter filt l c =
  let {
    hs = upt Zero_nat (plus_nat c (Nat_of_num One));
  } in flatten_term_enum_filter filt
         (map_term (\ f -> map (\ h -> lift h f) hs) l);

cover_bound_list_filter ::
  forall a b.
    (Term (a, Nat) b -> Bool) ->
      ((Term a b, Term a b) -> Term a b -> Bool) ->
        Nat -> [(Term a b, Term a b)] -> [(Term (a, Nat) b, Term (a, Nat) b)];
cover_bound_list_filter filt ff c r =
  concatMap
    (\ (l, ra) ->
      let {
        ee = ff (l, ra);
      } in map (\ la ->
                 (la, map_term
                        (lift (plus_nat
                                (min_list
                                  (map height
                                    (sym_collect (\ t -> ee (map_term base t))
                                      la)))
                                (Nat_of_num One)))
                        ra))
             (inverse_base_term_filter filt l c))
    r;

ta_final_impl :: forall a b c. Ta_impl_ext a b c -> Rbt a ();
ta_final_impl
  (Ta_impl_ext ta_final_impl ta_rules_impl ta_r_lhs_states_impl
    ta_rhs_states_set ta_eps_impl ta_epss_impl ta_epsrs_impl more)
  = ta_final_impl;

ta_contains_impl ::
  forall a b.
    (Linorder a, Eq b,
      Linorder b) => [(a, Nat)] ->
                       Ta_impl_ext b a () -> [b] -> Sum (Sum b (Term a b)) ();
ta_contains_impl f ta qs =
  let {
    fin = ta_final_impl ta;
    look = rm_set_lookup (ta_rules_impl ta);
    _ = ta_epss_impl ta;
  } in bindb (catcha
               (catcha (forallM (\ q -> check (memb_rm_basic_ops q fin) q) qs)
                 (\ x -> Inl (snd x)))
               (\ x -> Inl (Inl x)))
         (\ _ ->
           catcha
             (catcha
               (forallM
                 (\ (fa, n) ->
                   let {
                     rules = look (fa, n);
                   } in catcha
                          (catcha
                            (forallM
                              (\ x ->
                                (if any (\ rule ->
  r_lhs_states_impl rule == x &&
    let {
      qq = rqss_impl rule;
    } in any (\ q -> memb_rm_basic_ops q qq) qs)
                                      rules
                                  then Inr () else Inl x))
                              (concat_lists (replicate n qs)))
                            (\ x -> Inl (snd x)))
                          (\ x -> Inl (Fun fa (map Var x))))
                 f)
               (\ x -> Inl (snd x)))
             (\ x -> Inl (Inr x)));

check_coherent_rule ::
  forall a b.
    (Eq a, Linorder a, Showa a, Eq b,
      Showa b) => (a -> [a]) ->
                    Rbt (a, a) () ->
                      [Ta_rule a b] ->
                        Ta_rule a b ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_coherent_rule iter rel rules (TA_rule f qs q) =
  catcha
    (forallM
      (\ i ->
        let {
          qi = nth qs i;
        } in catcha
               (forallM
                 (\ qia ->
                   let {
                     qsa = list_update qs i qia;
                   } in check (not (null (filter
   (\ (TA_rule g qsb qa) ->
     f == g && qsa == qsb && memb_rm_basic_ops (q, qa) rel)
   rules)))
                          (shows_prec_list Zero_nat ['r', 'u', 'l', 'e', ' '] .
                            shows_prec Zero_nat f .
                              shows_prec_list Zero_nat ['('] .
                                shows_prec_list Zero_nat qs .
                                  shows_prec_list Zero_nat
                                    [')', ' ', '-', '>', ' '] .
                                    shows_prec Zero_nat q .
                                      shows_prec_list Zero_nat
[' ', 'w', 'i', 't', 'h', ' '] .
shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) .
  shows_prec_list Zero_nat
    ['.', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'd', 'e', 'c', 'r',
      'e', 'a', 's', 'e', 'd', ' ', 't', 'o', ' '] .
    shows_prec Zero_nat qia .
      shows_prec_list Zero_nat
        [' ', 'h', 'a', 's', ' ', 'n', 'o', ' ', 'c', 'o', 'u', 'n', 't', 'e',
          'r', 'p', 'a', 'r', 't']))
                 (iter qi))
               (\ x -> Inl (snd x)))
      (upt Zero_nat (size_list qs)))
    (\ x -> Inl (snd x));

ntrancl ::
  forall a. (Ceq a, Corder a, Set_impl a) => Nat -> Set (a, a) -> Set (a, a);
ntrancl n r =
  (if equal_nat n Zero_nat then r
    else let {
           ra = ntrancl (minus_nat n (Nat_of_num One)) r;
         } in sup_set ra (relcomp ra r));

trancl ::
  forall a.
    (Card_UNIV a, Ceq a, Corder a, Set_impl a) => Set (a, a) -> Set (a, a);
trancl a =
  (if finite a then ntrancl (minus_nat (card a) (Nat_of_num One)) a
    else error "trancl: infinite set" (\ _ -> trancl a));

check_coherent ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a,
      Showa a, Eq b,
      Showa b) => Tree_automaton a b ->
                    Ta_relation a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_coherent (Tree_Automaton fin rules eps) (Some_Relation rel) =
  let {
    iter =
      (\ q ->
        map_filter
          (\ x ->
            (if let {
                  (a, _) = x;
                } in a == q
              then Just (snd x) else Nothing))
          rel);
    rs = g_from_list_dflt_basic_oops_rm_basic_ops rel;
    ep = set eps;
    rell = converse (set rel);
  } in bindb (catcha (check_subseteq (concatMap iter fin) fin)
               (\ x ->
                 Inl (shows_prec Zero_nat x .
                       shows_prec_list Zero_nat
                         [' ', 'i', 's', ' ', 'i', 'n', ' ', 'r', 'e', 'l', 'a',
                           't', 'i', 'o', 'n', ' ', 't', 'o', ' ', 'a', ' ',
                           'f', 'i', 'n', 'a', 'l', ' ', 's', 't', 'a', 't',
                           'e', ',', ' ', 'b', 'u', 't', ' ', 'n', 'o', 't',
                           ' ', 'a', ' ', 'f', 'i', 'n', 'a', 'l', ' ', 's',
                           't', 'a', 't', 'e', ' ', 'i', 't', 's', 'e', 'l',
                           'f'])))
         (\ _ ->
           bindb (catcha (forallM (check_coherent_rule iter rs rules) rules)
                   (\ x -> Inl (snd x)))
             (\ _ ->
               check (less_eq_set (relcomp rell ep)
                       (sup_set (relcomp (trancl ep) rell) rell))
                 (shows_prec_list Zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c',
                     'o', 'h', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 'o', 'f', ' ',
                     'e', 'p', 's', 'i', 'l', 'o', 'n', ' ', 'r', 'u', 'l', 'e',
                     's'])));
check_coherent uu Decision_Proc = Inr ();
check_coherent uu Id_Relation = Inr ();

conv_ta_rule :: forall a b. (a -> Rbt a ()) -> Ta_rule a b -> Ta_rule_impl a b;
conv_ta_rule eps (TA_rule f qs q) = TA_rule_impl f qs q (eps q);

r_sym_impl :: forall a b. Ta_rule_impl a b -> (b, Nat);
r_sym_impl (TA_rule_impl f qsa q qs) = (f, size_list qsa);

generate_ta ::
  forall a b.
    (Linorder a, Linorder b) => Tree_automaton a b -> Ta_impl_ext a b ();
generate_ta (Tree_Automaton fin rules eps) =
  let {
    ep = memo_rbt_rtrancl eps;
    epr = memo_rbt_rtrancl (map (\ (q, qa) -> (qa, q)) eps);
    rqs_rs = rs_Union (map (\ rule -> ep (r_rhs rule)) rules);
    rrules = map (conv_ta_rule ep) rules;
  } in Ta_impl_ext (g_from_list_dflt_basic_oops_rm_basic_ops fin)
         (elem_list_to_rm r_sym_impl rrules)
         (g_to_list_dflt_basic_oops_rm_basic_ops rqs_rs) rqs_rs eps ep epr ();

generate_ta_cond ::
  forall a b.
    (Card_UNIV a, Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a,
      Showa a, Eq b, Linorder b,
      Showa b) => Tree_automaton a b ->
                    Ta_relation a ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Ta_impl_ext a b ());
generate_ta_cond ta rel =
  bindb (catcha (check_coherent ta rel)
          (\ x ->
            Inl (shows_prec_list Zero_nat
                   ['a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n', ' ', 'i', 's',
                     ' ', 'n', 'o', 't', ' ', 'c', 'o', 'h', 'e', 'r', 'e', 'n',
                     't', ' ', 'w', '.', 'r', '.', 't', '.', ' ', 'r', 'e', 'l',
                     'a', 't', 'i', 'o', 'n'] .
                  shows_nl . x)))
    (\ _ -> Inr (generate_ta ta));

relation_as_list ::
  forall a. Ta_relation a -> Sum ([Prelude.Char] -> [Prelude.Char]) [(a, a)];
relation_as_list (Some_Relation rel) = Inr rel;
relation_as_list Id_Relation = Inr [];
relation_as_list Decision_Proc =
  Inl (shows_prec_list Zero_nat
        ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e',
          'd', 'u', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l',
          'a', 'b', 'l', 'e', ' ', 'f', 'o', 'r', ' ', 'n', 'o', 'n', '-', 'l',
          'e', 'f', 't', ' ', 'l', 'i', 'n', 'e', 'a', 'r', ' ', 'T', 'R', 'S',
          's']);

bounds_condition ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => Boundstype ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_condition Roof uu = Inr ();
bounds_condition Match r =
  catcha
    (catcha
      (forallM
        (\ x ->
          (if let {
                (l, ra) = x;
              } in less_eq_multiset (vars_term_ms ra) (vars_term_ms l)
            then Inr () else Inl x))
        r)
      (\ x -> Inl (snd x)))
    (\ x ->
      Inl (let {
             (l, ra) = x;
           } in shows_prec_list Zero_nat ['r', 'u', 'l', 'e', ' '] .
                  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                    [' ', '-', '>', ' '] (l, ra) .
                    shows_prec_list Zero_nat
                      [' ', 'i', 's', ' ', 'd', 'u', 'p', 'l', 'i', 'c', 'a',
                        't', 'i', 'n', 'g']));

boundstype_fun ::
  forall a b. (Eq b) => Boundstype -> (Term a b, Term a b) -> Term a b -> Bool;
boundstype_fun Roof = roof;
boundstype_fun Match = matcha;

iteratei_set_op_list_it_rs_ops ::
  forall a b.
    (Linorder a) => Rbt a () -> (b -> Bool) -> (a -> b -> b) -> b -> b;
iteratei_set_op_list_it_rs_ops s =
  (\ c f -> rm_iterateoi (impl_of s) c (f . fst));

rs_subset :: forall a. (Linorder a) => Rbt a () -> Rbt a () -> Maybe a;
rs_subset asa bs =
  iteratei_set_op_list_it_rs_ops asa
    (\ a -> (case a of {
              Nothing -> True;
              Just _ -> False;
            }))
    (\ a _ -> (if memb_rm_basic_ops a bs then Nothing else Just a)) Nothing;

rel_checker ::
  forall a.
    (Eq a, Linorder a) => Ta_relation a -> Rbt a () -> Rbt a () -> Maybe a;
rel_checker (Some_Relation rel) =
  (\ lhs rhs ->
    let {
      rlist = g_to_list_dflt_basic_oops_rm_basic_ops rhs;
    } in (case catcha
                 (forallM
                   (\ l -> check (any (\ r -> membera rel (l, r)) rlist) l)
                   (g_to_list_dflt_basic_oops_rm_basic_ops lhs))
                 (\ x -> Inl (snd x))
           of {
           Inl a -> Just a;
           Inr _ -> Nothing;
         }));
rel_checker Id_Relation = rs_subset;
rel_checker Decision_Proc = rs_subset;

check_det ::
  forall a b.
    (Eq a,
      Eq b) => Tree_automaton a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_det (Tree_Automaton fin rules eps) =
  catcha
    (bindb
      (check (null eps)
        (shows_prec_list Zero_nat
          ['e', 'p', 's', 'i', 'l', 'o', 'n', ' ', 't', 'r', 'a', 'n', 's', 'i',
            't', 'i', 'o', 'n', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l',
            'o', 'w', 'e', 'd']))
      (\ _ ->
        check (distinct (map (\ (TA_rule f qs _) -> (f, qs)) (remdups rules)))
          (shows_prec_list Zero_nat
            ['s', 'o', 'm', 'e', ' ', 'l', 'h', 's', ' ', 'o', 'c', 'c', 'u',
              'r', 's', ' ', 't', 'w', 'i', 'c', 'e'])))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'e', 'n', 's', 'u', 'r', 'i', 'n', 'g', ' ', 'd', 'e', 't', 'e',
               'r', 'm', 'i', 'n', 'i', 's', 'm', ' ', 'o', 'f', ' ', 'a', 'u',
               't', 'o', 'm', 'a', 't', 'a'] .
            shows_nl . x));

check_bounds ::
  forall a b c.
    (Eq a, Linorder a, Showa a, Card_UNIV b, Cenum b, Ceq b, Corder b, Eq b,
      Linorder b, Set_impl b, Showa b, Ceq c, Corder c, Eq c, Linorder c,
      Set_impl c,
      Showa c) => Bounds_info a b ->
                    [(Term a c, Term a c)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_bounds (Bounds_Info typea c qfin preTA rel) r =
  bindb (generate_ta_cond preTA rel)
    (\ ta ->
      let {
        rell = rel_checker rel;
      } in bindb (check_wf_trs r)
             (\ _ ->
               bindb (if isOK (check_left_linear_trs r) then Inr ()
                       else bindb (catcha (check_det preTA)
                                    (\ x ->
                                      Inl
(shows_prec_list Zero_nat
   ['f', 'o', 'r', ' ', 'n', 'o', 'n', ' ', 'l', 'e', 'f', 't', '-', 'l', 'i',
     'n', 'e', 'a', 'r', ' ', 'T', 'R', 'S', ' ', 'w', 'e', ' ', 'r', 'e', 'q',
     'u', 'i', 'r', 'e', ' ', 'd', 'e', 't', '.', ' ', 'a', 'u', 't', 'o', 'm',
     'a', 't', 'o', 'n'] .
  shows_nl . x)))
                              (\ _ ->
                                bindb (relation_as_list rel)
                                  (check_state_raise_consistent preTA)))
                 (\ _ ->
                   bindb (bounds_condition typea r)
                     (\ _ ->
                       bindb (check
                               (any (\ q ->
                                      memb_rm_basic_ops q
(ta_rhs_states_set ta))
                                 qfin)
                               (shows_prec_list Zero_nat
                                 ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f',
                                   'i', 'n', 'd', ' ', 'm', 'e', 'n', 't', 'i',
                                   'o', 'n', 'e', 'd', ' ', 'f', 'i', 'n', 'a',
                                   'l', ' ', 's', 't', 'a', 't', 'e', ' ', 'i',
                                   'n', ' ', 'T', 'A']))
                         (\ _ ->
                           bindb (catcha
                                   (catcha
                                     (forallM
                                       (\ x ->
 (if let {
       (f, _) = x;
     } in less_eq_nat (height f) c
   then Inr () else Inl x))
                                       (map fst
 (g_to_list_rm_basic_ops (ta_rules_impl ta))))
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (let {
    (f, _) = x;
  } in shows_prec_prod Zero_nat f .
         shows_prec_list Zero_nat
           [' ', 'i', 's', ' ', 's', 'y', 'm', 'b', 'o', 'l', ' ', 'i', 'n',
             ' ', 'T', 'A', ' ', 'w', 'i', 't', 'h', ' ', 'h', 'e', 'i', 'g',
             'h', 't', ' ', 'l', 'a', 'r', 'g', 'e', 'r', ' ', 't', 'h', 'a',
             'n', ' ', 'c', ' ', '=', ' '] .
           shows_prec_nat Zero_nat c)))
                             (\ _ ->
                               bindb (catcha
                                       (ta_contains_impl
 (map (\ (f, a) -> (lift Zero_nat f, a)) (funas_trs_list r)) ta qfin)
                                       (\ x ->
 Inl (shows_prec_list Zero_nat
        ['i', 't', ' ', 'c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'b',
          'e', ' ', 'g', 'u', 'a', 'r', 'a', 'n', 't', 'e', 'e', 'd', ' ', 't',
          'h', 'a', 't', ' ', 'l', 'i', 'f', 't', '0', '(', 'T', '(', 'S', 'i',
          'g', 'm', 'a', ')', ')', ' ', 'i', 's', ' ', 'a', 'c', 'c', 'e', 'p',
          't', 'e', 'd', ' ', 'b', 'y', ' ', 'T', 'A'] .
       shows_nl .
         (case x of {
           Inl q ->
             shows_prec_list Zero_nat ['s', 't', 'a', 't', 'e', ' '] .
               shows_prec Zero_nat q .
                 shows_prec_list Zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'a',
                     'l'];
           Inr fqs ->
             shows_prec_list Zero_nat
               ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'n', 'o', ' ', 't',
                 'r', 'a', 'n', 's', 'i', 't', 'i', 'o', 'n', ' ', 'f', 'r',
                 'o', 'm', ' '] .
               shows_prec_term Zero_nat fqs .
                 shows_prec_list Zero_nat
                   [' ', 't', 'o', ' ', 'a', ' ', 'f', 'i', 'n', 'a', 'l', ' ',
                     's', 't', 'a', 't', 'e'];
         }))))
                                 (\ _ ->
                                   catcha
                                     (state_compatible_eff_list ta rell
                                       (cover_bound_list_filter
 (\ l -> not (rule_state_compatible_heuristic ta l)) (boundstype_fun typea) c
 r))
                                     (\ x ->
                                       Inl
 (let {
    (lr, (lr_rhs, q)) = x;
  } in shows_prec_list Zero_nat
         ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm', 'p',
           'a', 't', 'i', 'b', 'l', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'R'] .
         shows_nl .
           shows_prec_list Zero_nat
             ['f', 'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
             shows_rule (shows_prec_prod Zero_nat) (shows_prec Zero_nat)
               [' ', '-', '>', ' '] lr .
               shows_nl .
                 shows_prec_list Zero_nat
                   ['w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'i', 'n', 's',
                     't', 'a', 'n', 't', 'i', 'a', 't', 'e', 'd', ' ', 'b', 'y',
                     ' ', 's', 't', 'a', 't', 'e', 's', ' ', 't', 'o', ' '] .
                   shows_rule (shows_prec_prod Zero_nat) (shows_prec Zero_nat)
                     [' ', '-', '>', ' '] lr_rhs .
                     shows_nl .
                       shows_prec_list Zero_nat
                         ['t', 'h', 'e', ' ', 's', 't', 'a', 't', 'e', ' '] .
                         shows_prec Zero_nat q .
                           shows_prec_list Zero_nat
                             [' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'r',
                               'e', 'a', 'c', 'h', 'a', 'b', 'l', 'e', ' ', 'f',
                               'r', 'o', 'm', ' ', 't', 'h', 'e', ' ', 'l', 'h',
                               's'] .
                             shows_nl)))))))));

bounds_tt ::
  forall a b c d.
    (Eq b, Linorder b, Showa b, Ceq c, Corder c, Eq c, Linorder c, Set_impl c,
      Showa c, Card_UNIV d, Cenum d, Ceq d, Corder d, Eq d, Linorder d,
      Set_impl d,
      Showa d) => Tp_ops_ext a b c () ->
                    Bounds_info b d ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
bounds_tt i info tp = let {
                        a = rulesc i tp;
                      } in check_bounds info a;

check_trs_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_termination_proof_main j ia assms i tp R_is_Empty =
  debug (i []) ['R', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y']
    (if null (rb j tp) then Inr ()
      else Inl (i . shows_string
                      [':', ' ', 'R', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                        'e', 'm', 'p', 't', 'y', ' ', 'i', 'n', ' ', 't', 'h',
                        'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                        ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                        'n', '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                      shows_nl .
                        shows_tp (shows_prec_lab Zero_nat)
                          (shows_prec_list Zero_nat) j tp));
check_trs_termination_proof_main j ia assms i tp (Rule_Removal redp rR prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (let {
       r = rulesc j tp;
       rr = ceta_list_diff r rR;
     } in bindb (catcha (rule_removal_tt j (get_redtriple redp) rr tp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'r',
                                 'u', 'l', 'e', ' ', 'r', 'e', 'm', 'o', 'v',
                                 'a', 'l', ' ', 't', 'e', 'c', 'h', 'n', 'i',
                                 'q', 'u', 'e', ' ', 'o', 'n', ' '] .
                               shows_nl .
                                 shows_tp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) j tp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
 'v', 'e', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat)
   [' ', '-', '>', ' '] rr .
   shows_nl . x)))
            (\ tpa ->
              catcha
                (check_trs_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) tpa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u',
                               'l', 'e', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l',
                               ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u',
                               'e'] .
                             shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (DP_Trans nfs m p prf) =
  debug (i []) ['D', 'P', ' ', 't', 'r', 'a', 'n', 's']
    (bindb
      (catcha (dependency_pairs_tt j ia tp nfs m Sharp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g',
                       ' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ', 'T',
                       'R', 'S'] .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl .
                           shows_string
                             ['t', 'o', ' ', 't', 'h', 'e', ' ', 'i', 'n', 'i',
                               't', 'i', 'a', 'l', ' ', 'D', 'P', ' ', 'p', 'r',
                               'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h',
                               ' ', 'p', 'a', 'i', 'r', 's', ' '] .
                             shows_nl .
                               shows_rules (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) [' ', '-', '>', ' ']
                                 p .
                                 shows_nl . x)))
      (\ dpp ->
        catcha
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dpp prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 's', 'w', 'i', 't', 'c', 'h', ' ', 't',
                         'o', ' ', 'd', 'e', 'p', 'e', 'n', 'd', 'e', 'n', 'c',
                         'y', ' ', 'p', 'a', 'i', 'r', 's'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (String_Reversal prf) =
  debug (i [])
    ['S', 't', 'r', 'i', 'n', 'g', ' ', 'R', 'e', 'v', 'e', 'r', 's', 'a', 'l']
    (bindb
      (catcha (string_reversal_tt j tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 't', 'r', 'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e',
                       'r', 's', 'a', 'l', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catcha
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 't', 'r', 'i',
                         'n', 'g', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'a', 'l',
                         ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Constant_String p prf) =
  debug (i [])
    ['C', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 't', 'o', ' ', 'U', 'n', 'a',
      'r', 'y']
    (bindb
      (catcha (const_to_string_sound_tt p j tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 't', 'u', 'r', 'n', 'i', 'n', 'g', ' ', 'c',
                       'o', 'n', 's', 't', 'a', 'n', 't', 's', ' ', 'i', 'n',
                       't', 'o', ' ', 'u', 'n', 'a', 'r', 'y', ' ', 's', 'y',
                       'm', 'b', 'o', 'l', 's', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catcha
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 's',
                         't', 'a', 'n', 't', ' ', 't', 'o', ' ', 'u', 'n', 'a',
                         'r', 'y', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u',
                         'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Semlab sli lQ lAll prf) =
  debug (i []) ['S', 'e', 'm', 'l', 'a', 'b']
    (bindb
      (catcha (semlab_fin_tt j sli lQ lAll tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 'e', 'm', 'a', 'n', 't', 'i', 'c', ' ', 'l', 'a',
                       'b', 'e', 'l', 'l', 'i', 'n', 'g', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catcha
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'e', 'm', '.',
                         'l', 'a', 'b', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q',
                         'u', 'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Bounds info) =
  debug (i []) ['B', 'o', 'u', 'n', 'd', 's']
    (catcha (bounds_tt j info tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'b', 'o',
                     'u', 'n', 'd', 's', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ',
                     't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                     'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                   shows_nl .
                     shows_tp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) j tp .
                       shows_nl . x)));
check_trs_termination_proof_main j ia assms i tp (Uncurry u_info rR prf) =
  debug (i []) ['U', 'n', 'c', 'u', 'r', 'r', 'y']
    (bindb
      (catcha (uncurry_tt j u_info rR tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       'c', 'u', 'r', 'r', 'y', 'i', 'n', 'g', ' ', 't', 'r',
                       'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i', 'o',
                       'n'] .
                     shows_nl . x)))
      (\ tpa ->
        catcha
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c', 'u',
                         'r', 'r', 'y', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Fcc fcs r prf) =
  debug (i []) ['F', 'c', 'c']
    (bindb
      (catcha (fcc_tt j fcs r tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       'f', 'l', 'a', 't', ' ', 'c', 'o', 'n', 't', 'e', 'x',
                       't', ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e'] .
                     shows_nl . x)))
      (\ tpa ->
        catcha
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 'f', 'l', 'a', 't', ' ', 'c', 'o', 'n',
                         't', 'e', 'x', 't', ' ', 'c', 'l', 'o', 's', 'u', 'r',
                         'e'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Split rrem prf1 prf2) =
  debug (i []) ['S', 'p', 'l', 'i', 't']
    (let {
       (tp1, tp2) = split_tt j tp rrem;
     } in bindb (catcha
                  (check_trs_termination_proof_main j ia assms
                    (i . shows_string ['.', '1']) tp1 prf1)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                 'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                 's', 'p', 'l', 'i', 't', 't', 'i', 'n', 'g'] .
                               shows_nl . indent x)))
            (\ _ ->
              catcha
                (check_trs_termination_proof_main j ia assms
                  (i . shows_string ['.', '2']) tp2 prf2)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'p',
                               'l', 'i', 't', 't', 'i', 'n', 'g'] .
                             shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Switch_Innermost joins prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', ' ', 'I', 'n', 'n', 'e', 'r', 'm', 'o', 's',
      't']
    (bindb
      (catcha (switch_innermost_tt j joins tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g',
                       ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r', 'm', 'o',
                       's', 't', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catcha
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'w', 'i', 't',
                         'c', 'h', ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r',
                         'm', 'o', 's', 't'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Drop_Equality prf) =
  debug (i []) ['D', 'r', 'o', 'p', ' ', 'E', 'q', 'u', 'a', 'l', 'i', 't', 'y']
    (let {
       tpa = mkb j (nfsb j tp) (qb j tp) (rb j tp)
               (filter (\ (l, r) -> not (equal_term l r)) (rwb j tp));
     } in catcha
            (check_trs_termination_proof_main j ia assms
              (i . shows_string ['.', '1']) tpa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 'd', 'r', 'o', 'p', 'p', 'i', 'n',
                           'g', ' ', 'e', 'q', 'u', 'a', 'l', 'i', 't', 'y',
                           ' ', 'r', 'u', 'l', 'e', 's'] .
                         shows_nl . indent x)));
check_trs_termination_proof_main j ia assms i tp
  (Remove_Nonapplicable_Rules r prf) =
  debug (i [])
    ['R', 'e', 'm', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a', 'p',
      'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']
    (let {
       _ = rb j tp;
     } in bindb (catcha (check_non_applicable_rules (is_QNFb j tp) r)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'r', 'e', 'm', 'o', 'v',
                                 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a',
                                 'p', 'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e',
                                 ' ', 'r', 'u', 'l', 'e', 's'] .
                               shows_nl .
                                 indent
                                   (shows_rule (shows_prec_lab Zero_nat)
                                      (shows_prec_list Zero_nat)
                                      [' ', '-', '>', ' '] x .
                                     shows_prec_list Zero_nat
                                       [' ', 'i', 's', ' ', 'a', 'p', 'p', 'l',
 'i', 'c', 'a', 'b', 'l', 'e']))))
            (\ _ ->
              let {
                tpa = delete_R_Rwb j tp r r;
              } in catcha
                     (check_trs_termination_proof_main j ia assms
                       (i . shows_string ['.', '1']) tpa prf)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                    'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                    'n', 'o', 'n', '-', 'a', 'p', 'p', 'l', 'i',
                                    'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l',
                                    'e', 's', ' ', 'r', 'e', 'm', 'o', 'v', 'a',
                                    'l'] .
                                  shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tp (Permuting_AFS pi prf) =
  debug (i [])
    ['P', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g', ' ', 's', 'o', 'm', 'e', ' ',
      'r', 'u', 'l', 'e', 's']
    (bindb
      (catcha (argument_filter_tt j pi tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'p', 'e', 'r', 'm', 'u', 't', 'i', 'n', 'g',
                       ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ' ',
                       'o', 'n', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j tp .
                         shows_nl . x)))
      (\ tpa ->
        catcha
          (check_trs_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'p', 'e', 'r', 'm',
                         'u', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ',
                         'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's'] .
                       shows_nl . indent x))));
check_trs_termination_proof_main j ia assms i tpa (Assume_SN tp ass) =
  debug (i [])
    ['T', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'A', 's', 's',
      'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n',
      'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catcha (check_tp_subsumes j tp tpa)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a',
                                  't', 'i', 'o', 'n', ' ', 'a', 's', 's', 'u',
                                  'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r',
                                  ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ',
                                  'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catcha
                 (forallM_index
                   (\ asa ja ->
                     check_assm j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_fptrs_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b [Nat]) [Prelude.Char],
                              (Term (Lab b [Nat]) [Prelude.Char], Location))],
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])]) ->
                            Fptrs_termination_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fptrs_termination_proof_main j ia assms i tpa (Assume_FP_SN tp ass) =
  debug (i [])
    ['O', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 'T', 'e', 'r', 'm', 'i',
      'n', 'a', 't', 'i', 'o', 'n', ' ', 'A', 's', 's', 'u', 'm', 'p', 't', 'i',
      'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'P',
      'r', 'o', 'o', 'f']
    (if assms
      then bindb (check (tpa == tp)
                   (shows_prec_list Zero_nat
                     ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 'a',
                       's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'd',
                       'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                       'c', 'h', ' ', 'c', 'u', 'r', 'r', 'e', 'n', 't', ' ',
                       'g', 'o', 'a', 'l']))
             (\ _ ->
               catcha
                 (forallM_index
                   (\ asa ja ->
                     check_assm j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_dp_termination_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          c -> Dp_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_termination_proof_main j ia assms i dpp P_is_Empty =
  debug (i []) ['P', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y']
    (if null (pa ia dpp) && (null (pwa ia dpp) || null (rc ia dpp)) then Inr ()
      else Inl (i . shows_string
                      [':', ' ', 'P', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ',
                        'e', 'm', 'p', 't', 'y', ' ', 'i', 'n', ' ', 't', 'h',
                        'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                        ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                        ' '] .
                      shows_nl .
                        shows_dpp (shows_prec_lab Zero_nat)
                          (shows_prec_list Zero_nat) ia dpp));
check_dp_termination_proof_main j ia assms i dpp
  (Subterm_Criterion_Proc p rseq rP prf) =
  debug (i [])
    ['S', 'u', 'b', 't', 'e', 'r', 'm', '_', 'C', 'r', 'i', 't', 'e', 'r', 'i',
      'o', 'n', '_', 'P', 'r', 'o', 'c']
    (let {
       pa = pairsa ia dpp;
       pr = ceta_list_diff pa rP;
     } in bindb (catcha (subterm_criterion_proc ia p rseq pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 's',
                                 'u', 'b', 't', 'e', 'r', 'm', ' ', 'c', 'r',
                                 'i', 't', 'e', 'r', 'i', 'o', 'n', ' ', 't',
                                 'o', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ',
                                 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       ['a', 'n', 'd', ' ', 't', 'r', 'y', 'i',
 'n', 'g', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o', 'v', 'e', ' ', 't', 'h', 'e',
 ' ', 'p', 'a', 'i', 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl . x)))
            (\ dppa ->
              catcha
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'u',
                               'b', 't', 'e', 'r', 'm', ' ', 'c', 'r', 'i', 't',
                               'e', 'r', 'i', 'o', 'n'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Redpair_Proc redp rP prf) =
  debug (i []) ['R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'P', 'r', 'o', 'c']
    (let {
       p = pairsa ia dpp;
       pr = ceta_list_diff p rP;
       proc =
         (case redp of {
           Inl rrp ->
             generic_ur_af_root_redtriple_proc ia (get_root_redtriple rrp)
               Nothing;
           Inr rp -> generic_ur_af_redtriple_proc ia (get_redtriple rp) Nothing;
         });
     } in bindb (catcha (proc pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'r',
                                 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ',
                                 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c',
                                 'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ',
                                 'r', 'e', 'm', 'o', 'v', 'e', ' ', 'f', 'r',
                                 'o', 'm', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                                 ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl . x)))
            (\ dppa ->
              catcha
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e',
                               'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                               'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                               'o', 'r'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Usable_Rules_Proc u prf) =
  debug (i [])
    ['U', 's', 'a', 'b', 'l', 'e', '_', 'R', 'u', 'l', 'e', 's', '_', 'P', 'r',
      'o', 'c']
    (bindb
      (catcha (usable_rules_proc ia u dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                       'r', 'u', 'l', 'e', 's', ' ', 'p', 'r', 'o', 'c', 'e',
                       's', 's', 'o', 'r', ' ', 't', 'o', ' ', 'r', 'e', 's',
                       't', 'r', 'i', 'c', 't', ' ', 't', 'h', 'e', ' ', 'D',
                       'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'u', 's',
                               'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's',
                               ' '] .
                             shows_nl .
                               shows_rules (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) [' ', '-', '>', ' ']
                                 u .
                                 shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 's', 'a', 'b',
                         'l', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'p', 'r',
                         'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Q_Reduction_Proc q prf) =
  debug (i [])
    ['Q', '_', 'R', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', '_', 'P', 'r', 'o',
      'c']
    (bindb
      (catcha (q_reduction_proc ia q dpp)
        (\ x ->
          Inl (i . shows_prec_list Zero_nat
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'Q', '-', 'r', 'e', 'd', 'u', 'c',
                       't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                       's', 'o', 'r'] .
                     shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', '-', 'r', 'e',
                         'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o',
                         'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_Redpair_Proc redp rP rR prf) =
  debug (i [])
    ['M', 'o', 'n', 'o', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'P', 'r',
      'o', 'c']
    (let {
       p = pairsa ia dpp;
       pr = ceta_list_diff p rP;
       r = rulesd ia dpp;
       rr = ceta_list_diff r rR;
     } in bindb (catcha (mono_redpair_proc ia (get_redtriple redp) pr rr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'm',
                                 'o', 'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c',
                                 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r',
                                 ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                                 'r', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
                                 'v', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't',
                                 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o',
                                 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl .
     shows_string
       [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's',
         ' '] .
       shows_nl .
         shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat)
           [' ', '-', '>', ' '] rr .
           shows_nl . x)))
            (\ dppa ->
              catcha
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o',
                               'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i',
                               'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r',
                               'o', 'c', 'e', 's', 's', 'o', 'r'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Dep_Graph_Proc edpts) =
  debug (i [])
    ['D', 'e', 'p', '_', 'G', 'r', 'a', 'p', 'h', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catcha (dep_graph_proc ia dpp edpts)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i',
                       'l', 'e', ' ', 't', 'r', 'y', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'p', 'e', 'r', 'f', 'o', 'r', 'm', ' ', 'S',
                       'C', 'C', '-', 'd', 'e', 'c', 'o', 'm', 'p', 'o', 's',
                       'i', 't', 'i', 'o', 'n', ' ', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl . x)))
      (\ pdpps ->
        catcha
          (catcha
            (forallM_index
              (\ (prof, dppa) ja ->
                check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.'] .
                         shows_prec_nat Zero_nat (plus_nat ja (Nat_of_num One)))
                  dppa prof)
              pdpps)
            (\ x -> Inl (snd x)))
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'd', 'e', 'p', 'e',
                         'n', 'd', 'e', 'n', 'c', 'y', ' ', 'g', 'r', 'a', 'p',
                         'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                         'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Redpair_UR_Proc redp rP ur prf) =
  debug (i [])
    ['R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'U', 'R', '_', 'P', 'r', 'o', 'c']
    (let {
       p = pairsa ia dpp;
       pr = ceta_list_diff p rP;
       proc =
         (case redp of {
           Inl rrp ->
             generic_ur_af_root_redtriple_proc ia (get_root_redtriple rrp)
               (Just ur);
           Inr rp ->
             generic_ur_af_redtriple_proc ia (get_redtriple rp) (Just ur);
         });
     } in bindb (catcha (proc pr dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'r',
                                 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ',
                                 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c',
                                 'e', 's', 's', 'o', 'r', ' ', 'w', 'i', 't',
                                 'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                                 'r', 'u', 'l', 'e', 's', ' ', 't', 'o', ' ',
                                 'r', 'e', 'm', 'o', 'v', 'e', ' ', 'f', 'r',
                                 'o', 'm', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                                 ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl . x)))
            (\ dppa ->
              catcha
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e',
                               'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
                               'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                               'o', 'r'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Mono_Redpair_UR_Proc redp rP rR ur prf) =
  debug (i [])
    ['M', 'o', 'n', 'o', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r', '_', 'U', 'R',
      '_', 'P', 'r', 'o', 'c']
    (let {
       p = pairsa ia dpp;
       pr = ceta_list_diff p rP;
       r = rulesd ia dpp;
       rr = ceta_list_diff r rR;
     } in bindb (catcha
                  (generic_mono_ur_redpair_proc ia (get_redtriple redp) pr rr ur
                    dpp)
                  (\ x ->
                    Inl (i . shows_string
                               [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                 'h', 'e', 'n', ' ', 'a', 'p', 'p', 'l', 'y',
                                 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'm',
                                 'o', 'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c',
                                 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r',
                                 ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                                 'r', ' ', 'w', 'i', 't', 'h', ' ', 'u', 's',
                                 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e',
                                 's', ' ', 't', 'o', ' ', 'r', 'e', 'm', 'o',
                                 'v', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 't',
                                 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o',
                                 'b', 'l', 'e', 'm'] .
                               shows_nl .
                                 shows_dpp (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat) ia dpp .
                                   shows_nl .
                                     shows_string
                                       [' ', 't', 'h', 'e', ' ', 'p', 'a', 'i',
 'r', 's', ' '] .
                                       shows_nl .
 shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat)
   [' ', '-', '>', ' '] pr .
   shows_nl .
     shows_string
       [' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', 's',
         ' '] .
       shows_nl .
         shows_rules (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat)
           [' ', '-', '>', ' '] rr .
           shows_nl . x)))
            (\ dppa ->
              catcha
                (check_dp_termination_proof_main j ia assms
                  (i . shows_string ['.', '1']) dppa prf)
                (\ x ->
                  Inl (i . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o',
                               'n', 'o', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i',
                               'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r',
                               'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'w', 'i',
                               't', 'h', ' ', 'u', 's', 'a', 'b', 'l', 'e', ' ',
                               'r', 'u', 'l', 'e', 's'] .
                             shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Uncurry_Proc mode u_info p r prf) =
  debug (i []) ['U', 'n', 'c', 'u', 'r', 'r', 'y', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catcha (uncurry_proc_both ia mode u_info p r dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'u', 'n', 'c', 'u', 'r', 'r', 'y',
                       'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'D',
                       'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c', 'u',
                         'r', 'r', 'y', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c',
                         'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Size_Change_Subterm_Proc graphs) =
  debug (i [])
    ['S', 'i', 'z', 'e', '_', 'C', 'h', 'a', 'n', 'g', 'e', '_', 'S', 'u', 'b',
      't', 'e', 'r', 'm', '_', 'P', 'r', 'o', 'c']
    (catcha (sct_subterm_proc ia graphs dpp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 't', 'h',
                     'e', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g',
                     'e', ' ', '(', 's', 'u', 'b', 't', 'e', 'r', 'm', ')', ' ',
                     'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'o', 'n',
                     ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b',
                     'l', 'e', 'm'] .
                   shows_nl .
                     shows_dpp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) ia dpp .
                       shows_nl . x)));
check_dp_termination_proof_main j ia assms i dpp
  (Size_Change_Redpair_Proc redp u_opt graphs) =
  debug (i [])
    ['S', 'i', 'z', 'e', '_', 'C', 'h', 'a', 'n', 'g', 'e', '_', 'R', 'e', 'd',
      'p', 'a', 'i', 'r', '_', 'P', 'r', 'o', 'c']
    (catcha (sct_ur_af_proc ia (get_redtriple redp) graphs u_opt dpp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 't', 'h',
                     'e', ' ', 's', 'i', 'z', 'e', '-', 'c', 'h', 'a', 'n', 'g',
                     'e', ' ', '(', 'r', 'e', 'd', 'p', 'a', 'i', 'r', ')', ' ',
                     'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'o', 'n',
                     ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b',
                     'l', 'e', 'm'] .
                   shows_nl .
                     shows_dpp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) ia dpp .
                       shows_nl . x)));
check_dp_termination_proof_main j ia assms i dpp (Fcc_Proc f fcs pb r prf) =
  debug (i []) ['F', 'c', 'c', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catcha (fcc_proc ia f fcs pb r dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'f', 'l', 'a', 't', ' ', 'c', 'o',
                       'n', 't', 'e', 'x', 't', ' ', 'c', 'l', 'o', 's', 'u',
                       'r', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ', 'D', 'P',
                       ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'f', 'l', 'a', 't',
                         ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', ' ', 'c', 'l',
                         'o', 's', 'u', 'r', 'e', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Split_Proc prem rrem prf1 prf2) =
  debug (i []) ['S', 'p', 'l', 'i', 't', '_', 'P', 'r', 'o', 'c']
    (case get_fcc_option prf1 of {
      Nothing ->
        let {
          (dpp1, dpp2) = split_proc ia dpp prem rrem;
        } in bindb (catcha
                     (check_dp_termination_proof_main j ia assms
                       (i . shows_string ['.', '1']) dpp1 prf1)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                    'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                    's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o',
                                    'c', 'e', 's', 's', 'o', 'r'] .
                                  shows_nl . indent x)))
               (\ _ ->
                 catcha
                   (check_dp_termination_proof_main j ia assms
                     (i . shows_string ['.', '2']) dpp2 prf2)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                  's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o',
                                  'c', 'e', 's', 's', 'o', 'r'] .
                                shows_nl . indent x)));
      Just (f, (fcs, (pb, (rb, prf1a)))) ->
        debug (i [])
          ['S', 'p', 'l', 'i', 't', '_', 'P', 'r', 'o', 'c', 'F', 'c', 'c']
          (bindb (fcc_split_proc ia f fcs pb rb prem rrem dpp)
            (\ (dpp1, dpp2) ->
              bindb (catcha
                      (check_dp_termination_proof_main j ia assms
                        (i . shows_string ['.', '1', '.', '1']) dpp1 prf1a)
                      (\ x ->
                        Inl (i . shows_string
                                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                     'e', 'l', 'o', 'w', ' ', 't', 'h', 'e',
                                     ' ', 's', 'p', 'l', 'i', 't', ' ', 'a',
                                     'n', 'd', ' ', 'f', 'c', 'c', ' ', 'p',
                                     'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                                   shows_nl . indent x)))
                (\ _ ->
                  catcha
                    (check_dp_termination_proof_main j ia assms
                      (i . shows_string ['.', '2']) dpp2 prf2)
                    (\ x ->
                      Inl (i . shows_string
                                 [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                   'e', 'l', 'o', 'w', ' ', 't', 'h', 'e', ' ',
                                   's', 'p', 'l', 'i', 't', ' ', 'p', 'r', 'o',
                                   'c', 'e', 's', 's', 'o', 'r'] .
                                 shows_nl . indent x)))));
    });
check_dp_termination_proof_main j ia assms i dpp (Semlab_Proc sli lP lQ lR prf)
  = debug (i []) ['S', 'e', 'm', 'l', 'a', 'b', '_', 'P', 'r', 'o', 'c']
      (bindb
        (catcha (semlab_fin_proc ia sli lP lQ lR dpp)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         't', 'h', 'e', ' ', 's', 'e', 'm', 'l', 'a', 'b', ' ',
                         'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'o',
                         'n', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r',
                         'o', 'b', 'l', 'e', 'm'] .
                       shows_nl .
                         shows_dpp (shows_prec_lab Zero_nat)
                           (shows_prec_list Zero_nat) ia dpp .
                           shows_nl . x)))
        (\ dppa ->
          catcha
            (check_dp_termination_proof_main j ia assms
              (i . shows_string ['.', '1']) dppa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'e', 'm',
                           'l', 'a', 'b', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                           's', 'o', 'r'] .
                         shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Switch_Innermost_Proc joins prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', '_', 'I', 'n', 'n', 'e', 'r', 'm', 'o', 's',
      't', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catcha (switch_innermost_proc ia joins dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 't', 'o', ' ', 's', 'w', 'i', 't', 'c',
                       'h', ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r', 'm',
                       'o', 's', 't', ' ', 'o', 'n', ' ', 't', 'h', 'e', ' ',
                       'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 'w', 'i', 't',
                         'c', 'h', ' ', 't', 'o', ' ', 'i', 'n', 'n', 'e', 'r',
                         'm', 'o', 's', 't', ' ', 'p', 'r', 'o', 'c', 'e', 's',
                         's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dppa (Assume_Finite dpp ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catcha (check_dpp_subsumes ia dpp dppa)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n',
                                  'e', 's', 's', ' ', 'a', 's', 's', 'u', 'm',
                                  'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ',
                                  'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                                  'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catcha
                 (catcha
                   (forallM_index
                     (\ asa ja ->
                       check_assm j ia
                         (check_trs_termination_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_dp_termination_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_fptrs_termination_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_unknown_proof_main j ia assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's',
                        ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
                        ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n',
                        ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));
check_dp_termination_proof_main j ia assms i dpp
  (Rewriting_Proc u_opt stb sta st lr p prf) =
  debug (i [])
    ['R', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catcha (rewriting_proc ia u_opt stb sta st lr p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r', ' ', 't', 'o', ' ', 'r', 'e', 'w', 'r', 'i', 't',
                       'e', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', ' '] .
                     shows_nl .
                       shows_rule (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) [' ', '-', '>', ' '] stb .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                               'i', 'r', ' '] .
                             shows_nl .
                               shows_rule (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) [' ', '-', '>', ' ']
                                 st .
                                 shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Narrowing_Proc st p sts prf) =
  debug (i [])
    ['N', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catcha (narrowing_proc ia st p sts dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'n', 'a', 'r', 'r', 'o', 'w', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r', ' ', 't', 'o', ' ', 'n', 'a', 'r', 'r', 'o', 'w',
                       ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r', ' '] .
                     shows_nl .
                       shows_rule (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) [' ', '-', '>', ' '] st .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                               'i', 'r', 's', ' '] .
                             shows_nl .
                               shows_trs (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat)
                                 ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                   'y', 's', 't', 'e', 'm', ':']
                                 [' ', '-', '>', ' '] sts .
                                 shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'n', 'a', 'r', 'r',
                         'o', 'w', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Instantiation_Proc st sts prf)
  = debug (i [])
      ['I', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n', '_',
        'P', 'r', 'o', 'c']
      (bindb
        (catcha (instantiation_proc ia st sts dpp)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         't', 'h', 'e', ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                         'i', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c',
                         'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ', 'i', 'n',
                         's', 't', 'a', 'n', 't', 'i', 'a', 't', 'e', ' ', 't',
                         'h', 'e', ' ', 'p', 'a', 'i', 'r', ' '] .
                       shows_nl .
                         shows_rule (shows_prec_lab Zero_nat)
                           (shows_prec_list Zero_nat) [' ', '-', '>', ' '] st .
                           shows_nl .
                             shows_string
                               [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p',
                                 'a', 'i', 'r', 's', ' '] .
                               shows_nl .
                                 shows_trs (shows_prec_lab Zero_nat)
                                   (shows_prec_list Zero_nat)
                                   ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                     'y', 's', 't', 'e', 'm', ':']
                                   [' ', '-', '>', ' '] sts .
                                   shows_nl . x)))
        (\ dppa ->
          catcha
            (check_dp_termination_proof_main j ia assms
              (i . shows_string ['.', '1']) dppa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 't', 'h', 'e', ' ', 'i', 'n', 's',
                           't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                           ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                         shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp
  (Forward_Instantiation_Proc st sts u_opt prf) =
  debug (i [])
    ['F', 'o', 'r', 'w', 'a', 'r', 'd', '_', 'I', 'n', 's', 't', 'a', 'n', 't',
      'i', 'a', 't', 'i', 'o', 'n', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catcha (forward_instantiation_proc ia st sts u_opt dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'f', 'o', 'r', 'w', 'a', 'r', 'd',
                       '_', 'i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't',
                       'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                       'o', 'r', ' ', 't', 'o', ' ', 'i', 'n', 's', 't', 'a',
                       'n', 't', 'i', 'a', 't', 'e', ' ', 't', 'h', 'e', ' ',
                       'p', 'a', 'i', 'r', ' '] .
                     shows_nl .
                       shows_rule (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) [' ', '-', '>', ' '] st .
                         shows_nl .
                           shows_string
                             [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                               'i', 'r', 's', ' '] .
                             shows_nl .
                               shows_trs (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat)
                                 ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's',
                                   'y', 's', 't', 'e', 'm', ':']
                                 [' ', '-', '>', ' '] sts .
                                 shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'r', 'w',
                         'a', 'r', 'd', ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                         'i', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c',
                         'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (Unlab_Proc p r prf) =
  debug (i []) ['U', 'n', 'l', 'a', 'b', '_', 'P', 'r', 'o', 'c']
    (Inl (shows_prec_list Zero_nat
           ['u', 'n', 'l', 'a', 'b', 'e', 'l', 'i', 'n', 'g', ' ', 'p', 'r',
             'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 'n', 'o', 't', ' ', 's',
             'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']));
check_dp_termination_proof_main j ia assms i dpp
  (General_Redpair_Proc rp ps pb prof prfs) =
  debug (i [])
    ['G', 'e', 'n', 'e', 'r', 'a', 'l', '_', 'R', 'e', 'd', 'p', 'a', 'i', 'r',
      '_', 'P', 'r', 'o', 'c', 'P', 'r', 'o', 'c']
    (let {
       n = size_list prfs;
     } in bindb (check (less_nat Zero_nat n)
                  (shows_prec_list Zero_nat
                    ['a', 't', ' ', 'l', 'e', 'a', 's', 't', ' ', 'o', 'n', 'e',
                      ' ', 's', 'u', 'b', 'p', 'r', 'o', 'o', 'f', ' ', 'i',
                      's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
            (\ _ ->
              let {
                merge = equal_nat n (Nat_of_num One);
              } in bindb (catcha
                           (conditional_general_reduction_pair_proc ia
                             (get_non_inf_order rp) ps pb prof merge dpp)
                           (\ x ->
                             Inl (i . shows_string
[':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'a', 'p', 'p',
  'l', 'y', 'i', 'n', 'g', ' ', 't', 'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r',
  'i', 'c', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a',
  'i', 'r', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r', ' ', 't', 'o',
  ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm'] .
shows_nl .
  shows_dpp (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) ia dpp .
    shows_nl . x)))
                     (\ dpps ->
                       bindb (catcha
                               (check_dp_termination_proof_main j ia assms
                                 (i . shows_string ['.', '1'])
                                 (nth dpps Zero_nat) (nth prfs Zero_nat))
                               (\ x ->
                                 Inl (i . shows_string
    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l', 'o', 'w', ' ', 't',
      'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r', 'i', 'c', ' ', 'r', 'e', 'd', 'u',
      'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p', 'r', 'o', 'c',
      'e', 's', 's', 'o', 'r'] .
    shows_nl . indent x)))
                         (\ _ ->
                           (if merge then Inr ()
                             else catcha
                                    (check_dp_termination_proof_main j ia assms
                                      (i . shows_string ['.', '2'])
                                      (nth dpps (Nat_of_num One))
                                      (nth prfs (Nat_of_num One)))
                                    (\ x ->
                                      Inl
(i . shows_string
       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l', 'o', 'w', ' ',
         't', 'h', 'e', ' ', 'g', 'e', 'n', 'e', 'r', 'i', 'c', ' ', 'r', 'e',
         'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', ' ', 'p',
         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
       shows_nl . indent x)))))));
check_dp_termination_proof_main j ia assms i dpp
  (Complex_Constant_Removal_Proc p prf) =
  debug (i [])
    ['C', 'o', 'm', 'p', 'l', 'e', 'x', '_', 'C', 'o', 'n', 's', 't', 'a', 'n',
      't', '_', 'R', 'e', 'm', 'o', 'v', 'a', 'l', '_', 'P', 'r', 'o', 'c']
    (bindb
      (catcha (complex_constant_removal_proc ia p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x',
                       ' ', 'c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'r',
                       'e', 'm', 'o', 'v', 'a', 'l', ' ', 'p', 'r', 'o', 'c',
                       'e', 's', 's', 'o', 'r', ' ', 't', 'o', ' ', 't', 'h',
                       'e', ' ', 'D', 'P', ' ', 'p', 'r', 'o', 'b', 'l', 'e',
                       'm'] .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia dpp .
                         shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_termination_proof_main j ia assms
            (i . shows_string ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'm', 'p',
                         'l', 'e', 'x', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n',
                         't', ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'p',
                         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_termination_proof_main j ia assms i dpp (To_Trs_Proc prf) =
  debug (i []) ['T', 'o', '_', 'T', 'r', 's', '_', 'P', 'r', 'o', 'c']
    (catcha
      (check_trs_termination_proof_main j ia assms (i . shows_string ['.', '1'])
        (mk_tp j
          (nfsc ia dpp,
            (qc ia dpp, (pa ia dpp ++ rc ia dpp, pwa ia dpp ++ rwc ia dpp))))
        prf)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l', 'o',
                     'w', ' ', 't', 'h', 'e', ' ', 'T', 'o', '-', 'T', 'r', 's',
                     ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                   shows_nl . indent x)));

check_unknown_proof_main ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Unknown_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_proof_main j ia assms i tpa (Assume_Unknown tp ass) =
  debug (i []) ['U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catcha
                   (check (tpa == tp)
                     (shows_prec_list Zero_nat
                        ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o',
                          'b', 'l', 'e', 'm', 's', ' ', 'a', 'r', 'e', ' ', 'n',
                          'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i', 'c', 'a',
                          'l', ':', ' '] .
                       shows_nl .
                         shows_prec_list Zero_nat tpa .
                           shows_nl .
                             shows_prec_list Zero_nat [' ', 'v', 's', ' '] .
                               shows_nl . shows_prec_list Zero_nat tp))
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a',
                                  't', 'i', 'o', 'n', ' ', 'a', 's', 's', 'u',
                                  'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r',
                                  ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ',
                                  'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catcha
                 (forallM_index
                   (\ asa ja ->
                     check_assm j ia
                       (check_trs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_dp_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_fptrs_termination_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_unknown_proof_main j ia assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                        'r', 'o', 'o', 'f'] .
                      shows_nl));

map_assm_proof ::
  forall a b c d e f g.
    (a -> a) ->
      (b -> b) ->
        (c -> c) ->
          (d -> d) ->
            Generic_assm_proof e f g a b c () d ->
              Generic_assm_proof e f g a b c () d;
map_assm_proof tp dpp fptp unk (SN_assm_proof r p) = SN_assm_proof r (tp p);
map_assm_proof tp dpp fptp unk (Finite_assm_proof d p) =
  Finite_assm_proof d (dpp p);
map_assm_proof tp dpp fptp unk (SN_FP_assm_proof r p) =
  SN_FP_assm_proof r (fptp p);
map_assm_proof tp dpp fptp unk (Unknown_assm_proof u p) =
  Unknown_assm_proof u (unk p);
map_assm_proof tp dpp fptp unk (Not_SN_assm_proof v va) =
  Not_SN_assm_proof v va;
map_assm_proof tp dpp fptp unk (Infinite_assm_proof v va) =
  Infinite_assm_proof v va;
map_assm_proof tp dpp fptp unk (Not_RelSN_assm_proof v va) =
  Not_RelSN_assm_proof v va;
map_assm_proof tp dpp fptp unk (Not_SN_FP_assm_proof v va) =
  Not_SN_FP_assm_proof v va;

no_decr ::
  forall a b c.
    (Eq a, Eq b,
      Eq c) => [(Term (Lab a b) c, Term (Lab a b) c)] ->
                 [(Term (Lab a b) c, Term (Lab a b) c)];
no_decr =
  filter
    (\ (l, r) ->
      not (not (equal_term l r) &&
            equal_term (map_term unlab l) (map_term unlab r)));

unlab_of_trs ::
  forall a b c.
    (Eq a, Eq b,
      Eq c) => [(Term (Lab a b) c, Term (Lab a b) c)] ->
                 [(Term (Lab a b) c, Term (Lab a b) c)];
unlab_of_trs r = map (map_rule unlab) (no_decr r);

updatec :: forall a b c. (a -> b) -> (a, c) -> (b, c);
updatec p_to_p (p, info) = (p_to_p p, info);

unlab_to_split_trs ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Trs_termination_proof a b c -> Trs_termination_proof a b c;
unlab_to_split_trs (DP_Trans a1 a2 a3 p) =
  DP_Trans a1 a2 a3 (fst (unlab_to_split_dp p));
unlab_to_split_trs (Rule_Removal a1 a2 p) =
  Rule_Removal a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (String_Reversal p) = String_Reversal (unlab_to_split_trs p);
unlab_to_split_trs (Constant_String a1 p) =
  Constant_String a1 (unlab_to_split_trs p);
unlab_to_split_trs (Bounds a) = Bounds a;
unlab_to_split_trs (Uncurry a1 a2 p) = Uncurry a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (Semlab a1 a2 a3 p) = Semlab a1 a2 a3 (unlab_to_split_trs p);
unlab_to_split_trs R_is_Empty = R_is_Empty;
unlab_to_split_trs (Fcc a1 a2 p) = Fcc a1 a2 (unlab_to_split_trs p);
unlab_to_split_trs (Split a1 p q) =
  Split a1 (unlab_to_split_trs p) (unlab_to_split_trs q);
unlab_to_split_trs (Switch_Innermost a1 p) =
  Switch_Innermost a1 (unlab_to_split_trs p);
unlab_to_split_trs (Drop_Equality p) = Drop_Equality (unlab_to_split_trs p);
unlab_to_split_trs (Remove_Nonapplicable_Rules a1 p) =
  Remove_Nonapplicable_Rules a1 (unlab_to_split_trs p);
unlab_to_split_trs (Permuting_AFS a1 p) =
  Permuting_AFS a1 (unlab_to_split_trs p);
unlab_to_split_trs (Assume_SN a p) =
  Assume_SN a
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_unknown ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Unknown_proof a b c -> Unknown_proof a b c;
unlab_to_split_unknown (Assume_Unknown a1 p) =
  Assume_Unknown a1
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_otrs ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Fptrs_termination_proof a b c -> Fptrs_termination_proof a b c;
unlab_to_split_otrs (Assume_FP_SN a p) =
  Assume_FP_SN a
    (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
           unlab_to_split_otrs unlab_to_split_unknown)
      p);

unlab_to_split_dp ::
  forall a b c.
    (Eq a, Key a, Eq b, Key b, Eq c,
      Key c) => Dp_termination_proof a b c ->
                  (Dp_termination_proof a b c,
                    [([(Term (Lab a b) c, Term (Lab a b) c)],
                       ([(Term (Lab a b) c, Term (Lab a b) c)],
                         Dp_termination_proof a b c))]);
unlab_to_split_dp P_is_Empty = (P_is_Empty, []);
unlab_to_split_dp (Dep_Graph_Proc ps) =
  (Dep_Graph_Proc
     (map (\ (po, a) -> (map_option (fst . unlab_to_split_dp) po, a)) ps),
    []);
unlab_to_split_dp (Subterm_Criterion_Proc a1 a2 a3 p) =
  updatec (Subterm_Criterion_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Redpair_Proc a1 a2 p) =
  updatec (Redpair_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Redpair_UR_Proc a1 a2 a3 p) =
  updatec (Redpair_UR_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Usable_Rules_Proc a1 p) =
  updatec (Usable_Rules_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Q_Reduction_Proc a1 p) =
  updatec (Q_Reduction_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_Redpair_Proc a1 a2 a3 p) =
  updatec (Mono_Redpair_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Mono_Redpair_UR_Proc a1 a2 a3 a4 p) =
  updatec (Mono_Redpair_UR_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Size_Change_Subterm_Proc a1) =
  (Size_Change_Subterm_Proc a1, []);
unlab_to_split_dp (Size_Change_Redpair_Proc a1 a2 a3) =
  (Size_Change_Redpair_Proc a1 a2 a3, []);
unlab_to_split_dp (Uncurry_Proc a1 a2 a3 a4 p) =
  updatec (Uncurry_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Fcc_Proc a1 a2 a3 a4 p) =
  updatec (Fcc_Proc a1 a2 a3 a4) (unlab_to_split_dp p);
unlab_to_split_dp (Switch_Innermost_Proc a1 p) =
  updatec (Switch_Innermost_Proc a1) (unlab_to_split_dp p);
unlab_to_split_dp (Rewriting_Proc a1 a2 a3 a4 a5 a6 p) =
  updatec (Rewriting_Proc a1 a2 a3 a4 a5 a6) (unlab_to_split_dp p);
unlab_to_split_dp (Narrowing_Proc a1 a2 a3 p) =
  updatec (Narrowing_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Instantiation_Proc a1 a2 p) =
  updatec (Instantiation_Proc a1 a2) (unlab_to_split_dp p);
unlab_to_split_dp (Forward_Instantiation_Proc a1 a2 a3 p) =
  updatec (Forward_Instantiation_Proc a1 a2 a3) (unlab_to_split_dp p);
unlab_to_split_dp (Assume_Finite d p) =
  (Assume_Finite d
     (map (map_assm_proof unlab_to_split_trs (fst . unlab_to_split_dp)
            unlab_to_split_otrs unlab_to_split_unknown)
       p),
    []);
unlab_to_split_dp (To_Trs_Proc p) = (To_Trs_Proc (unlab_to_split_trs p), []);
unlab_to_split_dp (Unlab_Proc pa r p) =
  let {
    (pb, list) = unlab_to_split_dp p;
  } in (P_is_Empty, (pa, (r, pb)) : list);
unlab_to_split_dp (Split_Proc a1 a2 p q) =
  (Split_Proc a1 a2 (fst (unlab_to_split_dp p)) (fst (unlab_to_split_dp q)),
    []);
unlab_to_split_dp (Semlab_Proc a1 lP a2 lR p) =
  let {
    (pa, list) = unlab_to_split_dp p;
    sl = Semlab_Proc a1 lP a2 lR pa;
  } in (case list of {
         [] -> (sl, list);
         (pb, (r, prof)) : lista ->
           let {
             ulP = unlab_of_trs lP;
             ulR = unlab_of_trs lR;
             pr = ceta_list_diff ulP pb;
             rr = ceta_list_diff ulR r;
           } in (Split_Proc pr rr sl prof, lista);
       });
unlab_to_split_dp (General_Redpair_Proc a1 a2 a3 a4 ps) =
  (General_Redpair_Proc a1 a2 a3 a4 ps, []);
unlab_to_split_dp (Complex_Constant_Removal_Proc a1 p) =
  updatec (Complex_Constant_Removal_Proc a1) (unlab_to_split_dp p);

check_trs_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_termination_proof ia j a i tp prf =
  check_trs_termination_proof_main ia j a i tp (unlab_to_split_trs prf);

check_cr_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            Cr_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_cr_proof a ia i j r (SN_WCR joins_i prf) =
  debug (ia []) ['S', 'N', '_', 'W', 'C', 'R']
    (let {
       tp = mkb i False [] r [];
     } in bindb (catcha
                  (check_trs_termination_proof i j a
                    (ia . shows_string ['.', '1']) tp prf)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 's', 't', 'r', 'o',
                                  'n', 'g', ' ', 'n', 'o', 'r', 'm', 'a', 'l',
                                  'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', '+',
                                  ' ', 'w', 'c', 'r'] .
                                shows_nl . indent x)))
            (\ _ ->
              catcha (check_critical_pairs r (critical_pairs_impl r r) joins_i)
                (\ x ->
                  Inl (ia . shows_prec_list Zero_nat
                              ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                                ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ',
                                'l', 'o', 'c', 'a', 'l', ' ', 'c', 'o', 'n',
                                'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'o',
                                'f', ' '] .
                              shows_tp (shows_prec_lab Zero_nat)
                                (shows_prec_list Zero_nat) i tp .
                                shows_nl . indent x))));
check_cr_proof a ia i j r Weakly_Orthogonal =
  debug (ia [])
    ['W', 'e', 'a', 'k', 'l', 'y', ' ', 'O', 'r', 't', 'h', 'o', 'g', 'o', 'n',
      'a', 'l']
    (catcha (check_weakly_orthogonal r)
      (\ x ->
        Inl (ia . shows_prec_list Zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                      'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'w', 'e', 'a',
                      'k', 'l', 'y', ' ', 'o', 'r', 't', 'h', 'o', 'g', 'o',
                      'n', 'a', 'l', ' ', 's', 'y', 's', 't', 'e', 'm', ' ',
                      'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'T', 'R', 'S'] .
                    shows_nl .
                      shows_trs (shows_prec_lab Zero_nat)
                        (shows_prec_list Zero_nat)
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                          't', 'e', 'm', ':']
                        [' ', '-', '>', ' '] r .
                        indent x)));
check_cr_proof a ia i j r (Strongly_Closed n) =
  debug (ia [])
    ['S', 't', 'r', 'o', 'n', 'g', 'l', 'y', ' ', 'C', 'l', 'o', 's', 'e', 'd']
    (catcha (check_strongly_closed r n)
      (\ x ->
        Inl (ia . shows_prec_list Zero_nat
                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                      'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 's', 't', 'r',
                      'o', 'n', 'g', ' ', 'c', 'l', 'o', 's', 'e', 'd', 'n',
                      'e', 's', 's', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e',
                      ' ', 'T', 'R', 'S'] .
                    shows_nl .
                      shows_trs (shows_prec_lab Zero_nat)
                        (shows_prec_list Zero_nat)
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                          't', 'e', 'm', ':']
                        [' ', '-', '>', ' '] r .
                        indent x)));

check_dp_loop ::
  forall a b c.
    (Eq b, Linorder b, Showa b, Ceq c, Corder c, Eq c, Mapping_impl c,
      Linorder c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> Dp_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_loop i dpp (DP_loop_prf s prseq sigma c) =
  let {
    p = pairsa i dpp;
    r = rulesd i dpp;
    nfs = nfsc i dpp;
    q = qc i dpp;
  } in (if equal_ctxt c Hole
         then bindb (check (not (null prseq))
                      (shows_prec_list Zero_nat
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'e', 'q',
                          'u', 'e', 'n', 'c', 'e', ' ', 'm', 'u', 's', 't', ' ',
                          'b', 'e', ' ', 'n', 'o', 'n', '-', 'e', 'm', 'p', 't',
                          'y']))
                (\ _ ->
                  (if null q
                    then check_qsteps (\ _ -> True) nfs p r prseq s
                           (subst_apply_term s (mk_subst Var sigma))
                    else check_qsteps_subst (check_NF_iteration sigma q) nfs p r
                           prseq s (subst_apply_term s (mk_subst Var sigma))))
         else check_loop q nfs s (map (\ (x, (y, (_, z))) -> (x, (y, z))) prseq)
                sigma c r);

check_rel_seq ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                        Term a b ->
                          Term a b ->
                            Bool -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_seq r sa [] s u True =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'e',
         ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e'] .
      shows_nl .
        shows_prec_term Zero_nat s .
          shows_string
            (shows_nl
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm']) .
            shows_nl . shows_prec_term Zero_nat u . shows_nl);
check_rel_seq r sa [] s u False =
  Inl (shows_prec_list Zero_nat
        ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd', ' ', 's',
          't', 'r', 'i', 'c', 't', ' ', 's', 't', 'e', 'p', ' ', 'i', 'n', ' ',
          'r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'e', 'q', 'u', 'e', 'n',
          'c', 'e']);
check_rel_seq ra sa ((p, (r, (True, t))) : prts) s u b =
  bindb (check_qrstep (\ _ -> True) False ra p r s t)
    (\ _ -> check_rel_seq ra sa prts t u True);
check_rel_seq ra sa ((p, (r, (False, t))) : prts) s u b =
  bindb (check_qrstep (\ _ -> True) False sa p r s t)
    (\ _ -> check_rel_seq ra sa prts t u b);

pat_dv_impl ::
  forall a b.
    (Eq a, Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) -> [b];
pat_dv_impl p =
  let {
    (_, (sigma, mu)) = p;
  } in remdups (map fst (mk_subst_domain sigma ++ mk_subst_domain mu));

shows_exp ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_exp (f, c) =
  shows_prec Zero_nat f .
    shows_prec_list Zero_nat ['n', '+', ' '] . shows_prec Zero_nat c;

shows_p ::
  forall a b c d e.
    (Showa a, Showa b, Showa c, Showa d,
      Showa e) => (a, ((b, (c, d)), e)) -> [Prelude.Char] -> [Prelude.Char];
shows_p (b, ((f, (c, m)), a)) =
  shows_prec Zero_nat b .
    shows_prec Zero_nat m .
      shows_prec_list Zero_nat [' ', '^', ' ', '('] .
        shows_exp (f, c) .
          shows_prec_list Zero_nat [')'] . shows_prec Zero_nat a;

set_option :: forall a. (Ceq a, Corder a, Set_impl a) => Maybe a -> Set a;
set_option Nothing = bot_set;
set_option (Just x2a) = inserta x2a bot_set;

enfc_cand ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                    [Term a [Prelude.Char]] ->
                      ([Term a [Prelude.Char]], Term a [Prelude.Char]) ->
                        [([Term a [Prelude.Char]], Term a [Prelude.Char])];
enfc_cand isQnf r q (uu, Var uv) = [];
enfc_cand isQnf r q (s, Fun f ts) =
  map (\ a -> (s, a)) ts ++
    concatMap
      (\ (l, ra) ->
        (if (case mgu_class (Fun f (map (icap_impla r q s) ts)) l of {
              Nothing -> False;
              Just mu ->
                all (\ u ->
                      isQnf (subst_apply_term (map_vars (\ a -> 'y' : a) u) mu))
                  (args l) &&
                  all (\ u ->
                        isQnf (subst_apply_term (map_vars (\ a -> 'x' : a) u)
                                mu))
                    s;
            })
          then [(args l, ra)] else []))
      r;

enfc_impl ::
  forall a.
    (Eq a,
      Key a) => (Term a [Prelude.Char] -> Bool) ->
                  (Term a [Prelude.Char] -> Bool) ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      [Term a [Prelude.Char]] ->
                        [Term a [Prelude.Char]] ->
                          Term a [Prelude.Char] -> Bool;
enfc_impl isQnf isRnf r q s t =
  all (\ (a, b) -> enfc_q isQnf isRnf r q a b)
    (mk_rtrancl_list (\ a b -> a == b) (enfc_cand isQnf r q) [(s, t)]);

check_nfc ::
  forall a.
    (Eq a, Key a,
      Showa a) => Bool ->
                    [(Term a [Prelude.Char], Term a [Prelude.Char])] ->
                      [Term a [Prelude.Char]] ->
                        [Term a [Prelude.Char]] ->
                          Bool ->
                            Term a [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_nfc inn r q ss nfs t =
  bindb (check_wf_trs r)
    (\ _ ->
      (if inn then Inr ()
        else catcha
               (forallM
                 (\ ta ->
                   check (enfc_impl (is_NF (any is_Var q) q (term_map q))
                           (is_NF (any (\ ra -> is_Var (fst ra)) r) (map fst r)
                             (term_map (map fst r)))
                           r q ss ta)
                     (shows_prec_list Zero_nat
                        [' ', 'n', 'f', 'c', ' ', 'n', 'o', 't', ' ', 's', 'a',
                          't', 'i', 's', 'f', 'i', 'e', 'd', ' ', 'f', 'o', 'r',
                          ' '] .
                       shows_prec_term Zero_nat ta))
                 (supteq_list t))
               (\ x -> Inl (snd x))));

intersect_values ::
  forall a b.
    (Eq a, Linorder b) => (a -> Maybe b) -> [a] -> Rbt b [a] -> Rbt b [a];
intersect_values key vs m = foldr (aux key m) vs empty;

intersect_rules ::
  forall a b.
    (Eq a, Linorder a,
      Eq b) => [(Term a b, Term a b)] ->
                 Rbt (a, Nat) [(Bool, (Term a b, Term a b))] ->
                   Rbt (a, Nat) [(Bool, (Term a b, Term a b))];
intersect_rules rs =
  intersect_values key
    (map (\ a -> (True, a)) rs ++ map (\ a -> (False, a)) rs);

check_wf_reltrs ::
  forall a b.
    (Showa a, Eq b,
      Showa b) => ([(Term a b, Term a b)], [(Term a b, Term a b)]) ->
                    Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_wf_reltrs (r, s) =
  bindb (check_wf_trs r)
    (\ _ -> (if null r then Inr () else check_varcond_subset s));

xml_ctrs_input ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => [((Term (Lab a [b]) c, Term (Lab a [b]) c),
                     [(Term (Lab a [b]) c, Term (Lab a [b]) c)])] ->
                    Xml;
xml_ctrs_input ctrs =
  XML ['c', 't', 'r', 's', 'I', 'n', 'p', 'u', 't'] []
    [XML ['c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'u', 'l',
           'e', 's']
       [] (map xml_crule ctrs) Nothing]
    Nothing;

starts_with :: [Prelude.Char] -> [Prelude.Char] -> Bool;
starts_with t s = take (size_list s) (trim t) == s;

check_modularity_ncr ::
  forall a b.
    (Cenum a, Ceq a, Corder a, Eq a, Set_impl a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_modularity_ncr ra r =
  bindb (catcha (check_subseteq r ra)
          (\ _ ->
            Inl (shows_prec_list Zero_nat
                  ['n', 'e', 'w', ' ', 'T', 'R', 'S', ' ', 'i', 's', ' ', 'n',
                    'o', 't', ' ', 'a', ' ', 's', 'u', 'b', 's', 'y', 's', 't',
                    'e', 'm', ' ', 'o', 'f', ' ', 'g', 'i', 'v', 'e', 'n', ' ',
                    'T', 'R', 'S'])))
    (\ _ ->
      let {
        s = list_diff ra r;
        f = funas_trs_list r;
        g = funas_trs_list s;
      } in bindb (check (less_eq_set (inf_set (set f) (set g)) bot_set)
                   (shows_prec_list Zero_nat
                     ['s', 'i', 'g', 'n', 'a', 't', 'u', 'r', 'e', 's', ' ',
                       'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'i', 's',
                       'j', 'o', 'i', 'n', 't']))
             (\ _ ->
               bindb (check_varcond_subset r)
                 (\ _ ->
                   catcha
                     (catcha
                       (forallM
                         (\ x ->
                           (if let {
                                 (l, _) = x;
                               } in not (is_Var l)
                             then Inr () else Inl x))
                         s)
                       (\ x -> Inl (snd x)))
                     (\ _ ->
                       Inl (shows_prec_list Zero_nat
                             ['l', 'h', 's', 's', ' ', 'm', 'u', 's', 't', ' ',
                               'n', 'o', 't', ' ', 'b', 'e', ' ', 'v', 'a', 'r',
                               'i', 'a', 'b', 'l', 'e', 's'])))));

sl_c :: forall a b c d e. Sl_ops_ext a b c d e -> b;
sl_c (Sl_ops_ext sl_La sl_LSa sl_I sl_C sl_c sl_check_decr sl_L sl_LS sl_lgen
       sl_LS_gen more)
  = sl_c;

check_qmodel_rule_ass ::
  forall a b c.
    (Showa a, Showa b,
      Showa c) => (a -> [b] -> b) ->
                    (b -> b -> Bool) ->
                      (c -> b) ->
                        (Term a c, Term a c) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel_rule_ass i cge alpha (l, r) =
  let {
    cl = eval i alpha l;
    cr = eval i alpha r;
  } in check (cge cl cr)
         (shows_string ['r', 'u', 'l', 'e', ' '] .
           shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
             [' ', '-', '>', ' '] (l, r) .
             shows_string
               [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 't', 'h', 'e',
                 ' ', 'm', 'o', 'd', 'e', 'l', ' ', 'c', 'o', 'n', 'd', 'i',
                 't', 'i', 'o', 'n', ',', ' ', '[', 'l', 'h', 's', ']', ' ',
                 '=', ' '] .
               shows_prec Zero_nat cl .
                 shows_string
                   [',', ' ', '[', 'r', 'h', 's', ']', ' ', '=', ' '] .
                   shows_prec Zero_nat cr);

check_qmodel_rule ::
  forall a b c.
    (Showa a, Showa b, Eq c,
      Showa c) => (a -> [b] -> b) ->
                    [b] ->
                      (b -> b -> Bool) ->
                        (Term a c, Term a c) ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel_rule i c cge lr =
  catcha
    (forallM (\ alpha -> check_qmodel_rule_ass i cge alpha lr)
      (map fun_of (enum_vectors c (vars_rule_list lr))))
    (\ x -> Inl (snd x));

check_qmodel ::
  forall a b c.
    (Showa a, Showa b, Eq c,
      Showa c) => (a -> [b] -> b) ->
                    [b] ->
                      (b -> b -> Bool) ->
                        [(Term a c, Term a c)] ->
                          Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_qmodel i c cge r =
  catcha (forallM (check_qmodel_rule i c cge) r) (\ x -> Inl (snd x));

check_non_join_model ::
  forall a b c d.
    (Showa a, Eq b, Showa b, Eq d,
      Showa d) => (a -> a -> Bool) ->
                    ([(b, Nat)] ->
                      [(b, Nat)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char])
                          (Sl_ops_ext b a c d ())) ->
                      [(Term b d, Term b d)] ->
                        [(Term b d, Term b d)] ->
                          Term b d ->
                            Term b d ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_model cge gen rs rt s t =
  catcha
    (bindb (gen (funas_trs_list (rs ++ rt)) [])
      (\ ops ->
        let {
          i = sl_I ops;
          e = eval i (\ _ -> sl_c ops);
          es = e s;
          et = e t;
        } in bindb (check (not (cge et es))
                     (shows_prec_list Zero_nat
                        ['t', 'h', 'e', ' ', 'i', 'n', 'e', 'q', 'u', 'a', 'l',
                          'i', 't', 'y', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o',
                          't', ' ', 'h', 'o', 'l', 'd', ':', ' ', '['] .
                       shows_prec_term Zero_nat t .
                         shows_prec_list Zero_nat [']', ' ', '=', ' '] .
                           shows_prec Zero_nat et .
                             shows_prec_list Zero_nat [' ', '>', '=', ' '] .
                               shows_prec Zero_nat es .
                                 shows_prec_list Zero_nat [' ', '=', ' ', '['] .
                                   shows_prec_term Zero_nat s .
                                     shows_prec_list Zero_nat [']']))
               (\ _ -> check_qmodel i (sl_C ops) cge (reverse_rules rs ++ rt))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'd', 'i',
               's', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-',
               'j', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'v',
               'i', 'a', ' ', 'i', 'n', 't', 'e', 'r', 'p', 'r', 'e', 't', 'a',
               't', 'i', 'o', 'n', 's'] .
            shows_nl . x));

check_non_join_finite_model ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => Sl_variant (Lab a [Nat]) b ->
                    [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                      [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                        Term (Lab a [Nat]) b ->
                          Term (Lab a [Nat]) b ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_finite_model (Rootlab x) rs rt s t =
  check_non_join_model equal_lab (slm_gen_to_sl_gen (rl_slm x)) rs rt s t;
check_non_join_finite_model (Finitelab sli) rs rt s t =
  check_non_join_model equal_nat
    (slm_gen_to_sl_gen (\ _ _ -> Inr (sli_to_slm sli))) rs rt s t;
check_non_join_finite_model (QuasiFinitelab sli v) rs rt s t =
  check_non_join_model qmodel_cge (\ f g -> qsli_to_sl v f g sli) rs rt s t;

match_cap_below_impl ::
  forall a b.
    (Eq a, Eq b) => Term a b -> [(Term a b, Term a b)] -> Term a b -> Bool;
match_cap_below_impl l r (Fun f ts) = matchb (GCFun f (map (capI r) ts)) l;
match_cap_below_impl l r (Var x) = False;

usable_rules_reach_U0_impl ::
  forall a b.
    (Eq a,
      Eq b) => [(Term a b, Term a b)] -> Term a b -> [(Term a b, Term a b)];
usable_rules_reach_U0_impl r t =
  inductive_set_impl r
    (\ ta (l, _) ->
      is_Var l ||
        any (\ u -> not (is_Var u) && match_cap_below_impl l r u)
          (supteq_list ta))
    (\ lr -> [snd lr]) [t];

usable_rules_reach_impl ::
  forall a b.
    (Eq a, Cenum b, Ceq b, Corder b, Eq b,
      Set_impl b) => [(Term a b, Term a b)] ->
                       Term a b -> [(Term a b, Term a b)];
usable_rules_reach_impl r t =
  let {
    u0t = usable_rules_reach_U0_impl r t;
  } in (if all (\ (l, ra) -> less_eq_set (vars_term ra) (vars_term l)) u0t
         then u0t else r);

check_non_join_redpair ::
  forall a b.
    (Key a, Showa a,
      Showa b) => Redtriple_ext a b () ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        Term a b ->
                          Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join_redpair rp rs rt sa t =
  catcha
    (bindb (valid rp)
      (\ _ ->
        bindb (catcha (forallM (ns rp) (reverse_rules rs ++ rt))
                (\ x -> Inl (snd x)))
          (\ _ -> s rp (sa, t))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'd', 'i',
               's', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-',
               'j', 'o', 'i', 'n', 'a', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'v',
               'i', 'a', ' ', 'd', 'i', 's', 'c', 'r', 'i', 'm', 'i', 'n', 'a',
               't', 'i', 'o', 'n', ' ', 'p', 'a', 'i', 'r', 's'] .
            shows_nl . x));

show_ta ::
  forall a b.
    (Showa a,
      Showa b) => Tree_automaton a b -> [Prelude.Char] -> [Prelude.Char];
show_ta (Tree_Automaton fin rules eps) =
  shows_prec_list Zero_nat ['f', 'i', 'n', 'a', 'l', ':', ' '] .
    shows_prec_list Zero_nat fin .
      shows_nl .
        shows_prec_list Zero_nat ['r', 'u', 'l', 'e', 's', ':', ' '] .
          shows_lines rules .
            shows_nl .
              shows_prec_list Zero_nat
                ['e', 'p', 's', 'i', 'l', 'o', 'n', ':', ' '] .
                shows_prec_list Zero_nat eps . shows_nl;

shows_prec_tree_automaton ::
  forall a b.
    (Showa a,
      Showa b) => Nat -> Tree_automaton a b -> [Prelude.Char] -> [Prelude.Char];
shows_prec_tree_automaton d r = show_ta r;

ta_rhs_states ::
  forall a b.
    (Cenum a, Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b,
      Linorder b) => Ta_ext a b () -> Set a;
ta_rhs_states ta =
  sup_set (image r_rhs (ta_rules ta))
    (compute_trancl (image r_rhs (ta_rules ta)) (ta_eps ta));

initial_rel ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b, Linorder b, Ceq c, Corder c, Eq c, Linorder c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) -> Set (a, Set a);
initial_rel ta r =
  let {
    rhs = ta_rhs_states ta;
    match = ta_matcha ta rhs;
    analyze_rule =
      (\ (l, ra) ->
        let {
          _ = vars_term l;
        } in sup_seta
               (image
                 (\ sigma ->
                   let {
                     qr = ta_res ta (map_vars (fun_of sigma) ra);
                   } in image (\ q -> (q, qr))
                          (ta_res ta (map_vars (fun_of sigma) l)))
                 (match l)));
  } in sup_seta (image analyze_rule r);

initial_relation ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b, Linorder b, Ceq c, Corder c, Eq c, Linorder c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) -> Maybe (Set (a, a));
initial_relation ta r =
  let {
    q_qs = initial_rel ta r;
  } in (if member bot_set (image snd q_qs) then Nothing
         else Just (sup_seta
                     (image (\ (q, a) -> image (\ aa -> (q, aa)) a) q_qs)));

decide_coherent_compatible_main ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b, Linorder b, Ceq c, Corder c, Eq c, Linorder c,
      Set_impl c) => Ta_ext a b () ->
                       Set (Term b c, Term b c) ->
                         (Maybe (Set (a, a)) -> Maybe (Set (a, a))) -> Bool;
decide_coherent_compatible_main ta r normalizer =
  (case normalizer (initial_relation ta r) of {
    Nothing -> False;
    Just rel -> less_eq_set (imagea rel (ta_final ta)) (ta_final ta);
  });

coherent_rule ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b,
      Linorder b) => Set (a, a) ->
                       Set (Ta_rule a b) -> Ta_rule a b -> Set (a, Maybe a);
coherent_rule rel rules (TA_rule f qs q) =
  foldr (sup_set .
          (\ i ->
            let {
              qi = nth qs i;
              qi_s = image snd (filtera (\ qq -> fst qq == qi) rel);
              a = sup_seta
                    (image
                      (\ qia ->
                        let {
                          qsa = list_update qs i qia;
                          rls = filtera
                                  (\ (TA_rule g qsaa _) ->
                                    g == f && qsaa == qsa)
                                  rules;
                        } in (if less_eq_set rls
                                   (set_empty (of_phantom set_impl_ta_rule))
                               then inserta Nothing bot_set
                               else image (Just . r_rhs) rls))
                      qi_s);
            } in image (\ aa -> (q, aa)) a))
    (upt Zero_nat (size_list qs)) bot_set;

new_states ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b,
      Linorder b) => Ta_ext a b () -> Set (a, a) -> Set (a, Maybe a);
new_states ta rel =
  let {
    rules = ta_rules ta;
  } in sup_seta (image (coherent_rule rel rules) rules);

minus_set :: forall a. (Ceq a, Corder a) => Set a -> Set a -> Set a;
minus_set a b = inf_set a (uminus_set b);

normalize_main ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b,
      Linorder b) => Ta_ext a b () ->
                       Set (a, a) -> Set (a, a) -> Maybe (Set (a, a));
normalize_main ta rel accu =
  let {
    new = new_states ta rel;
  } in (if member Nothing (image snd new) then Nothing
         else let {
                new_rel = image (\ (x, y) -> (x, the y)) new;
                new_accu = sup_set accu rel;
                todo = minus_set new_rel new_accu;
              } in (if less_eq_set todo bot_set then Just new_accu
                     else normalize_main ta todo new_accu));

normalizea ::
  forall a b.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b,
      Linorder b) => Ta_ext a b () -> Maybe (Set (a, a)) -> Maybe (Set (a, a));
normalizea ta (Just rel) = normalize_main ta rel bot_set;
normalizea ta Nothing = Nothing;

decide_coherent_compatible ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Eq b, Linorder b, Ceq c, Corder c, Eq c, Linorder c,
      Set_impl c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
decide_coherent_compatible ta r =
  decide_coherent_compatible_main ta r (normalizea ta);

closed_under_rewriting ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Default b, Eq b, Linorder b, Ceq c, Corder c, Eq c,
      Linorder c,
      Set_impl c) => Ta_ext a b () -> Set (Term b c, Term b c) -> Bool;
closed_under_rewriting ta r = decide_coherent_compatible (trim_ta ta) r;

is_Decision_Proc :: forall a. Ta_relation a -> Bool;
is_Decision_Proc Decision_Proc = True;
is_Decision_Proc Id_Relation = False;
is_Decision_Proc (Some_Relation v) = False;

ta_of_ta ::
  forall a b.
    (Ceq a, Corder a, Eq a, Linorder a, Set_impl a, Eq b,
      Linorder b) => Tree_automaton a b -> Ta_ext a b ();
ta_of_ta (Tree_Automaton fin rules eps) =
  Ta_ext (set fin) (set rules) (set eps) ();

tree_aut_trs_closed ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Showa a, Default b, Eq b, Linorder b, Showa b, Ceq c,
      Corder c, Eq c, Linorder c, Set_impl c,
      Showa c) => Tree_automaton a b ->
                    Ta_relation a ->
                      [(Term b c, Term b c)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
tree_aut_trs_closed ta rel r =
  catcha
    (if is_Decision_Proc rel
      then bindb (check_varcond_subset r)
             (\ _ ->
               bindb (catcha (check_det ta)
                       (\ x ->
                         Inl (shows_prec_list Zero_nat
                                ['d', 'e', 'c', 'i', 's', 'i', 'o', 'n', ' ',
                                  'p', 'r', 'o', 'c', 'e', 'd', 'u', 'r', 'e',
                                  ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 's',
                                  ' ', 'd', 'e', 't', '.', ' ', 'a', 'u', 't',
                                  'o', 'm', 'a', 't', 'o', 'n', ' ', 'a', 's',
                                  ' ', 'i', 'n', 'p', 'u', 't'] .
                               x)))
                 (\ _ ->
                   check (closed_under_rewriting (ta_of_ta ta) (set r))
                     (shows_prec_list Zero_nat
                       ['t', 'h', 'e', ' ', 'l', 'a', 'n', 'g', 'u', 'a', 'g',
                         'e', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'a', 'u',
                         't', 'o', 'm', 'a', 't', 'o', 'n', ' ', 'i', 's', ' ',
                         'n', 'o', 't', ' ', 'c', 'l', 'o', 's', 'e', 'd', ' ',
                         'u', 'n', 'd', 'e', 'r', ' ', 'r', 'e', 'w', 'r', 'i',
                         't', 'i', 'n', 'g'])))
      else bindb (check_varcond_subset r)
             (\ _ ->
               bindb (generate_ta_cond ta rel)
                 (\ taa ->
                   bindb (if isOK (check_left_linear_trs r) then Inr ()
                           else catcha (check_det ta)
                                  (\ x ->
                                    Inl (shows_prec_list Zero_nat
   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's', 'u', 'r',
     'e', ' ', 'l', 'e', 'f', 't', '-', 'l', 'i', 'n', 'e', 'a', 'r', 'i', 't',
     'y', ' ', 'o', 'r', ' ', 'd', 'e', 't', 'e', 'r', 'm', 'i', 'n', 'i', 's',
     'm'] .
  shows_nl . x)))
                     (\ _ ->
                       catcha
                         (state_compatible_eff_list taa (rel_checker rel) r)
                         (\ x ->
                           Inl (let {
                                  (lr, (lrq, q)) = x;
                                } in shows_prec_list Zero_nat
                                       ['T', 'A', ' ', 'i', 's', ' ', 'n', 'o',
 't', ' ', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ', 'w', 'i', 't',
 'h', ' ', 'R'] .
                                       shows_nl .
 shows_prec_list Zero_nat ['f', 'o', 'r', ' ', 'r', 'u', 'l', 'e', ' '] .
   shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) [' ', '-', '>', ' ']
     lr .
     shows_nl .
       shows_prec_list Zero_nat
         ['w', 'h', 'i', 'c', 'h', ' ', 'i', 's', ' ', 'i', 'n', 's', 't', 'a',
           'n', 't', 'i', 'a', 't', 'e', 'd', ' ', 'b', 'y', ' ', 's', 't', 'a',
           't', 'e', 's', ' ', 't', 'o', ' '] .
         shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
           [' ', '-', '>', ' '] lrq .
           shows_nl .
             shows_prec_list Zero_nat
               ['t', 'h', 'e', ' ', 's', 't', 'a', 't', 'e', ' '] .
               shows_prec Zero_nat q .
                 shows_prec_list Zero_nat
                   [' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'r', 'e', 'a',
                     'c', 'h', 'a', 'b', 'l', 'e', ' ', 'f', 'r', 'o', 'm', ' ',
                     't', 'h', 'e', ' ', 'l', 'h', 's'] .
                   shows_nl))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ',
               'e', 'n', 's', 'u', 'r', 'i', 'n', 'g', ' ', 'c', 'o', 'm', 'p',
               'a', 't', 'i', 'b', 'i', 'l', 'i', 't', 'y', ' ', 'o', 'f', ' ',
               'T', 'R', 'S', ' ', 'w', 'i', 't', 'h', ' ', 'T', 'A', ' '] .
            shows_nl . shows_prec_tree_automaton Zero_nat ta . shows_nl . x));

intersect_ta ::
  forall a b c.
    (Finite_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Ceq b, Corder b, Eq b, Linorder b, Set_impl b, Finite_UNIV c,
      Cenum c, Ceq c, Cproper_interval c, Eq c, Linorder c,
      Set_impl c) => Ta_ext a b () -> Ta_ext c b () -> Ta_ext (a, c) b ();
intersect_ta tA1 tA2 = prod_ta tA1 tA2 (productc (ta_final tA1) (ta_final tA2));

non_join_with_ta ::
  forall a b c.
    (Card_UNIV a, Cenum a, Ceq a, Cproper_interval a, Eq a, Linorder a,
      Set_impl a, Showa a, Ceq b, Corder b, Default b, Eq b, Linorder b,
      Set_impl b, Showa b, Ceq c, Corder c, Eq c, Linorder c, Set_impl c,
      Showa c) => Tree_automaton a b ->
                    Ta_relation a ->
                      [(Term b c, Term b c)] ->
                        Term b c ->
                          Tree_automaton a b ->
                            Ta_relation a ->
                              [(Term b c, Term b c)] ->
                                Term b c ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
non_join_with_ta ta1 rel1 r1 t1 ta2 rel2 r2 t2 =
  let {
    tA1 = ta_of_ta ta1;
    tA2 = ta_of_ta ta2;
  } in bindb (check (ta_member t1 tA1)
               (shows_prec_term Zero_nat t1 .
                 shows_prec_list Zero_nat
                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e',
                     'p', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'f', 'i', 'r', 's',
                     't', ' ', 'a', 'u', 't', 'o', 'm', 'a', 't', 'o', 'n']))
         (\ _ ->
           bindb (check (ta_member t2 tA2)
                   (shows_prec_term Zero_nat t2 .
                     shows_prec_list Zero_nat
                       [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                         'e', 'p', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'f', 'i',
                         'r', 's', 't', ' ', 'a', 'u', 't', 'o', 'm', 'a', 't',
                         'o', 'n']))
             (\ _ ->
               bindb (check (ta_empty (intersect_ta tA1 tA2))
                       (shows_prec_list Zero_nat
                         ['i', 'n', 't', 'e', 'r', 's', 'e', 'c', 't', 'i', 'o',
                           'n', ' ', 'o', 'f', ' ', 'a', 'u', 't', 'o', 'm',
                           'a', 't', 'a', ' ', 'i', 's', ' ', 'n', 'o', 'n',
                           '-', 'e', 'm', 'p', 't', 'y']))
                 (\ _ ->
                   bindb (catcha (tree_aut_trs_closed ta1 rel1 r1)
                           (\ x ->
                             Inl (shows_prec_list Zero_nat
                                    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o',
                                      't', ' ', 'e', 'n', 's', 'u', 'r', 'e',
                                      ' ', 'c', 'l', 'o', 's', 'u', 'r', 'e',
                                      ' ', 'u', 'n', 'd', 'e', 'r', ' ', 'r',
                                      'e', 'w', 'r', 'i', 't', 'i', 'n', 'g',
                                      ' ', 'f', 'o', 'r', ' ', 'f', 'i', 'r',
                                      's', 't', ' ', 'a', 'u', 't', 'o', 'm',
                                      'a', 't', 'o', 'n'] .
                                   shows_nl . x)))
                     (\ _ ->
                       catcha (tree_aut_trs_closed ta2 rel2 r2)
                         (\ x ->
                           Inl (shows_prec_list Zero_nat
                                  ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                    ' ', 'e', 'n', 's', 'u', 'r', 'e', ' ', 'c',
                                    'l', 'o', 's', 'u', 'r', 'e', ' ', 'u', 'n',
                                    'd', 'e', 'r', ' ', 'r', 'e', 'w', 'r', 'i',
                                    't', 'i', 'n', 'g', ' ', 'f', 'o', 'r', ' ',
                                    's', 'e', 'c', 'o', 'n', 'd', ' ', 'a', 'u',
                                    't', 'o', 'm', 'a', 't', 'o', 'n'] .
                                 shows_nl . x))))));

check_non_join ::
  forall a b c.
    (Default a, Eq a, Key a, Showa a, Cenum b, Ceq b, Corder b, Eq b,
      Mapping_impl b, Linorder b, Set_impl b, Showa b, Card_UNIV c, Cenum c,
      Ceq c, Cproper_interval c, Eq c, Linorder c, Set_impl c,
      Showa c) => [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                    [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                      Term (Lab a [Nat]) b ->
                        Term (Lab a [Nat]) b ->
                          Non_join_info (Lab a [Nat]) b c ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_join rs rt s t Diff_NFs =
  bindb (check (not (equal_term s t))
          (shows_prec_list Zero_nat
             ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', 's', ' '] .
            shows_prec_term Zero_nat s .
              shows_prec_list Zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term Zero_nat t .
                  shows_prec_list Zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'i', 'd', 'e', 'n', 't', 'i', 'c',
                      'a', 'l']))
    (\ _ ->
      let {
        chknf =
          (\ sa r ->
            check (nF_terms_list (map fst r) sa)
              (shows_prec_list Zero_nat
                 ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                shows_term (shows_prec_lab Zero_nat) (shows_prec Zero_nat) sa .
                  shows_prec_list Zero_nat
                    [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'n',
                      'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm']));
      } in bindb (chknf s rs) (\ _ -> chknf t rt));
check_non_join rs rt s t (Grounding sigma prf) =
  let {
    sigmaa = mk_subst Var sigma;
  } in check_non_join rs rt (subst_apply_term s sigmaa)
         (subst_apply_term t sigmaa) prf;
check_non_join rs rt s t (Tcap_Non_Unif grd_subst) =
  let {
    sigma = grd_subst s t;
    cs = capI rs (subst_apply_term s sigma);
    ct = capI rt (subst_apply_term t sigma);
  } in check (is_none (merge cs ct))
         (shows_prec_list Zero_nat
            ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
              'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
           shows_prec_term Zero_nat s .
             shows_prec_list Zero_nat [' ', 'a', 'n', 'd', ' '] .
               shows_prec_term Zero_nat t .
                 shows_prec_list Zero_nat
                   [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                     'n', 'a', 'b', 'l', 'e']);
check_non_join rs rt s t (Tree_Aut_Intersect_Empty ta1 rel1 ta2 rel2) =
  catcha (non_join_with_ta ta1 rel1 rs s ta2 rel2 rt t)
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
               'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
            shows_prec_term Zero_nat s .
              shows_prec_list Zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term Zero_nat t .
                  shows_prec_list Zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                      'n', 'a', 'b', 'l', 'e'] .
                    shows_nl . x));
check_non_join rs rt s t (Finite_Model_Gt i) =
  catcha (check_non_join_finite_model i rs rt s t)
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
               'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
            shows_prec_term Zero_nat s .
              shows_prec_list Zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term Zero_nat t .
                  shows_prec_list Zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                      'n', 'a', 'b', 'l', 'e'] .
                    shows_nl . x));
check_non_join rs rt s t (Reduction_Pair_Gt rp) =
  catcha (check_non_join_redpair (get_redtriple rp) rs rt s t)
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'i', 'n', 'f',
               'e', 'r', ' ', 't', 'h', 'a', 't', ' '] .
            shows_prec_term Zero_nat s .
              shows_prec_list Zero_nat [' ', 'a', 'n', 'd', ' '] .
                shows_prec_term Zero_nat t .
                  shows_prec_list Zero_nat
                    [' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'j', 'o', 'i',
                      'n', 'a', 'b', 'l', 'e'] .
                    shows_nl . x));
check_non_join rs rt s t (Usable_Rules_Reach_NJ prf) =
  check_non_join (usable_rules_reach_impl rs s) (usable_rules_reach_impl rt t) s
    t prf;
check_non_join rs rt s t (Argument_Filter_NJ pi prf) =
  bindb (check_wf_afs pi)
    (\ _ ->
      let {
        pia = afs_list_to_afs pi;
        af = af_term pia;
        afs = af_rules pia;
      } in check_non_join (afs rs) (afs rt) (af s) (af t) prf);

check_non_cr ::
  forall a b c.
    (Default a, Eq a, Key a, Showa a, Cenum b, Ceq b, Corder b, Eq b,
      Mapping_impl b, Linorder b, Set_impl b, Showa b, Card_UNIV c, Cenum c,
      Ceq c, Cproper_interval c, Eq c, Linorder c, Set_impl c,
      Showa c) => [(Term (Lab a [Nat]) b, Term (Lab a [Nat]) b)] ->
                    Term (Lab a [Nat]) b ->
                      [(Pos, ((Term (Lab a [Nat]) b, Term (Lab a [Nat]) b),
                               Term (Lab a [Nat]) b))] ->
                        [(Pos, ((Term (Lab a [Nat]) b, Term (Lab a [Nat]) b),
                                 Term (Lab a [Nat]) b))] ->
                          Non_join_info (Lab a [Nat]) b c ->
                            Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_cr r s seq1 seq2 reason =
  let {
    chk = check_rsteps_last r s;
  } in bindb (chk seq1)
         (\ _ ->
           bindb (chk seq2)
             (\ _ ->
               check_non_join r r (rseq_last s seq1) (rseq_last s seq2)
                 reason));

check_ncr_proof ::
  forall a b c.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            Ncr_proof b [Nat] [Prelude.Char] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_ncr_proof a ia i j r (SN_NWCR prf) =
  debug (ia []) ['S', 'N', '_', 'N', 'W', 'C', 'R']
    (let {
       tp = mkb i False [] r [];
     } in bindb (catcha
                  (check_trs_termination_proof i j a
                    (ia . shows_string ['.', '1']) tp prf)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 's', 't', 'r', 'o',
                                  'n', 'g', ' ', 'n', 'o', 'r', 'm', 'a', 'l',
                                  'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', '+',
                                  ' ', 'w', 'c', 'r'] .
                                shows_nl . indent x)))
            (\ _ ->
              catcha
                (check
                  (not (isOK (check_critical_pairs_NF r
                               (critical_pairs_impl r r))))
                  (shows_prec_list Zero_nat
                    ['a', 'l', 'l', ' ', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l',
                      ' ', 'p', 'a', 'i', 'r', 's', ' ', 'a', 'r', 'e', ' ',
                      'j', 'o', 'i', 'n', 'a', 'b', 'l', 'e']))
                (\ x ->
                  Inl (ia . shows_prec_list Zero_nat
                              ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                                ' ', 'd', 'i', 's', 'p', 'r', 'o', 'v', 'i',
                                'n', 'g', ' ', 'l', 'o', 'c', 'a', 'l', ' ',
                                'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c',
                                'e', ' ', 'o', 'f', ' '] .
                              shows_tp (shows_prec_lab Zero_nat)
                                (shows_prec_list Zero_nat) i tp .
                                shows_nl . indent x))));
check_ncr_proof a ia i j r (Non_Join s seq1 seq2 prf) =
  debug (ia []) ['N', 'o', 'n', '_', 'J', 'o', 'i', 'n']
    (catcha (check_non_cr r s seq1 seq2 prf)
      (\ x ->
        Inl (ia . shows_prec_list Zero_nat
                    ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'd',
                      'i', 's', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'C',
                      'R', ' ', 'o', 'f', ' '] .
                    shows_trs (shows_prec_lab Zero_nat)
                      (shows_prec_list Zero_nat)
                      ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                        't', 'e', 'm', ':']
                      [' ', '-', '>', ' '] r .
                      shows_nl . indent x)));
check_ncr_proof a ia i j ra (NCR_Disj_Subtrs r prf) =
  debug (ia []) ['M', 'o', 'd', 'u', 'l', 'a', 'r', 'i', 't', 'y']
    (bindb
      (catcha (check_modularity_ncr ra r)
        (\ x ->
          Inl (ia . shows_prec_list Zero_nat
                      ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                        'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ', 'm', 'o',
                        'd', 'u', 'l', 'a', 'r', 'i', 't', 'y', ' ', 't', 'o',
                        ' ', 's', 'w', 'i', 't', 'c', 'h', ' ', 't', 'o', ' '] .
                      shows_trs (shows_prec_lab Zero_nat)
                        (shows_prec_list Zero_nat)
                        ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y', 's',
                          't', 'e', 'm', ':']
                        [' ', '-', '>', ' '] r .
                        shows_nl . indent x)))
      (\ _ ->
        catcha (check_ncr_proof a (ia . shows_string ['.', '1']) i j r prf)
          (\ x ->
            Inl (ia . shows_string
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'm', 'o', 'd', 'u',
                          'l', 'a', 'r', ' ', 'd', 'e', 'c', 'o', 'm', 'p', 'o',
                          's', 'i', 't', 'i', 'o', 'n'] .
                        shows_nl . indent x))));

check_rel_loop ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => Term a b ->
                    [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                      [(b, Term a b)] ->
                        Ctxt a b ->
                          [(Term a b, Term a b)] ->
                            [(Term a b, Term a b)] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_loop sa rseq sigma c r s =
  check_rel_seq r s rseq sa
    (ctxt_apply c (subst_apply_term sa (mk_subst Var sigma))) False;

check_trs_loop ::
  forall a b c.
    (Eq b, Linorder b, Showa b, Ceq c, Corder c, Eq c, Mapping_impl c,
      Linorder c, Set_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Trs_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_loop i tp (TRS_loop_prf s rseq sigma c) =
  check_loop (qb i tp) (nfsb i tp) s rseq sigma c (rulesc i tp);

prems_ofa ::
  forall a.
    Dp_proof_step a ->
      [(([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))];
prems_ofa step =
  (case step of {
    OC1 _ _ -> [];
    OC2 _ p pa _ _ _ ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p))),
        (([], ((Zero_nat, (Zero_nat, [])), fst pa)),
          ([], ((Zero_nat, (Zero_nat, [])), snd pa)))];
    OC2p _ p pa _ _ _ ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p))),
        (([], ((Zero_nat, (Zero_nat, [])), fst pa)),
          ([], ((Zero_nat, (Zero_nat, [])), snd pa)))];
    OC3 _ p pa _ _ ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p))),
        (([], ((Zero_nat, (Zero_nat, [])), fst pa)),
          ([], ((Zero_nat, (Zero_nat, [])), snd pa)))];
    OC3p _ p pa _ _ ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p))),
        (([], ((Zero_nat, (Zero_nat, [])), fst pa)),
          ([], ((Zero_nat, (Zero_nat, [])), snd pa)))];
    OCDP1 _ p ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p)))];
    OCDP2 _ p ->
      [(([], ((Zero_nat, (Zero_nat, [])), fst p)),
         ([], ((Zero_nat, (Zero_nat, [])), snd p)))];
    WPEQ _ p -> [p];
    Lift _ p -> [p];
    DPOC1_1 _ p rl _ _ ->
      [p, (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
            ([], ((Zero_nat, (Zero_nat, [])), snd rl)))];
    DPOC1_2 _ p rl _ _ _ ->
      [p, (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
            ([], ((Zero_nat, (Zero_nat, [])), snd rl)))];
    DPOC2 _ p rl _ _ ->
      [p, (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
            ([], ((Zero_nat, (Zero_nat, [])), snd rl)))];
    DPOC3_1 _ p rl _ _ ->
      [p, (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
            ([], ((Zero_nat, (Zero_nat, [])), snd rl)))];
    DPOC3_2 _ p rl _ _ _ ->
      [p, (([], ((Zero_nat, (Zero_nat, [])), fst rl)),
            ([], ((Zero_nat, (Zero_nat, [])), snd rl)))];
    DPDP1_1 _ p1 p2 _ _ -> [p1, p2];
    DPDP1_2 _ p1 p2 _ _ -> [p1, p2];
    DPDP2_1 _ p1 p2 _ _ -> [p1, p2];
    DPDP2_2 _ p1 p2 _ _ -> [p1, p2];
  });

shows_oc ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_oc (l, r) =
  shows_prec Zero_nat l .
    shows_prec_list Zero_nat [' ', '-', '>', '+', ' '] . shows_prec Zero_nat r;

vars_subst_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [a];
vars_subst_impl sigma =
  let {
    sigmaa = mk_subst_domain sigma;
  } in map fst sigmaa ++ concatMap (vars_term_list . snd) sigmaa;

mk_tpa ::
  forall a b c d.
    Tp_ops_ext a b c d -> (Bool, ([Term b c], [(Term b c, Term b c)])) -> a;
mk_tpa i (nfs, (q, r)) = mkb i nfs q r [];

show_pat_term ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                    [Prelude.Char] -> [Prelude.Char];
show_pat_term p =
  let {
    (s, (sigma, tau)) = p;
  } in shows_prec_prod Zero_nat
         (s, (mk_subst_domain sigma, mk_subst_domain tau));

show_pat_rule ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                    ((Term a b, ([(b, Term a b)], [(b, Term a b)])), Bool)) ->
                    [Prelude.Char] -> [Prelude.Char];
show_pat_rule pr =
  let {
    (p1, (p2, _)) = pr;
  } in show_pat_term p1 .
         shows_string [' ', '-', '-', '>', ' '] . show_pat_term p2;

term_to_string :: forall a b. Term a b -> [a];
term_to_string (Fun f [t]) = f : term_to_string t;
term_to_string (Var v) = [];
term_to_string (Fun v []) = [];
term_to_string (Fun v (vb : vd : ve)) = [];

normalize_wp ::
  forall a.
    (Eq a) => ([a], ((Nat, (Nat, [a])), [a])) ->
                ([a], ((Nat, (Nat, [a])), [a]));
normalize_wp (x, ((xa, (xb, xc)), xd)) =
  let {
    (l, (f, aa)) = (x, (xa, (xb, (xc, xd))));
  } in (if equal_nat f Zero_nat
         then let {
                (aab, aaa) = aa;
              } in (if equal_nat aab Zero_nat
                     then let {
                            (_, r) = aaa;
                          } in ([], ((Zero_nat, (Zero_nat, [])), l ++ r))
                     else let {
                            (m, r) = aaa;
                          } in normalize_wp
                                 (l ++ concat
 (replicate (plus_nat (minus_nat aab (Nat_of_num One)) (Nat_of_num One)) m),
                                   ((Zero_nat, (Zero_nat, m)), r)))
         else (if equal_nat (minus_nat f (Nat_of_num One)) Zero_nat
                then let {
                       (aab, aaa) = aa;
                     } in (if equal_nat aab Zero_nat
                            then (case aaa of {
                                   ([], r) ->
                                     ([], ((Zero_nat, (Zero_nat, [])), l ++ r));
                                   (a : m, []) ->
                                     (l, ((plus_nat Zero_nat (Nat_of_num One),
    (Zero_nat, a : m)),
   []));
                                   (a : m, b : r) ->
                                     (if a == b
                                       then normalize_wp
      (l ++ [b],
        ((plus_nat Zero_nat (Nat_of_num One), (Zero_nat, m ++ [b])), r))
                                       else (l,
      ((plus_nat Zero_nat (Nat_of_num One), (Zero_nat, a : m)), b : r)));
                                 })
                            else let {
                                   (m, r) = aaa;
                                 } in normalize_wp
(l ++ concat
        (replicate (plus_nat (minus_nat aab (Nat_of_num One)) (Nat_of_num One))
          m),
  ((plus_nat Zero_nat (Nat_of_num One), (Zero_nat, m)), r)))
                else let {
                       (aab, aaa) = aa;
                     } in (if equal_nat aab Zero_nat
                            then (case aaa of {
                                   ([], r) ->
                                     ([], ((Zero_nat, (Zero_nat, [])), l ++ r));
                                   (vb : vba, r) ->
                                     normalize_wp
                                       (l,
 ((plus_nat Zero_nat (Nat_of_num One),
    (Zero_nat,
      concat
        (replicate
          (plus_nat
            (plus_nat
              (minus_nat (minus_nat f (Nat_of_num One)) (Nat_of_num One))
              (Nat_of_num One))
            (Nat_of_num One))
          (vb : vba)))),
   r));
                                 })
                            else let {
                                   (m, r) = aaa;
                                 } in normalize_wp
(l ++ concat
        (replicate (plus_nat (minus_nat aab (Nat_of_num One)) (Nat_of_num One))
          m),
  ((plus_nat
      (plus_nat (minus_nat (minus_nat f (Nat_of_num One)) (Nat_of_num One))
        (Nat_of_num One))
      (Nat_of_num One),
     (Zero_nat, m)),
    r)))));

word_pat_equiv ::
  forall a.
    (Eq a) => ([a], ((Nat, (Nat, [a])), [a])) ->
                ([a], ((Nat, (Nat, [a])), [a])) -> Bool;
word_pat_equiv wp1 wp2 = wp1 == wp2 || normalize_wp wp1 == normalize_wp wp2;

shows_pat ::
  forall a b c d e f g h i j.
    (Showa a, Showa b, Showa c, Showa d, Showa e, Showa f, Showa g, Showa h,
      Showa i,
      Showa j) => ((a, ((b, (c, d)), e)), (f, ((g, (h, i)), j))) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_pat (p1, p2) =
  shows_p p1 . shows_prec_list Zero_nat [' ', '-', '>', '+', ' '] . shows_p p2;

bounded_postfixes :: Pos -> [Pos] -> [Pos];
bounded_postfixes p ps =
  map_filter (\ x -> (if not (is_none x) then Just (the x) else Nothing))
    (map (pos_prefix p) ps);

rel_rules_of ::
  forall a b. Maybe [(Term a b, Term a b)] -> [(Term a b, Term a b)];
rel_rules_of Nothing = [];
rel_rules_of (Just r) = r;

subst_power_impl ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> Nat -> [(a, Term b a)];
subst_power_impl sigma n =
  (if equal_nat n Zero_nat then []
    else subst_compose_impl sigma
           (subst_power_impl sigma (minus_nat n (Nat_of_num One))));

impl_ofc ::
  forall b a.
    (Key b,
      Key a) => Tp b a ->
                  (Bool,
                    ([Term b a],
                      (Bool,
                        ([(Term b a, Term b a)],
                          ([(Term b a, Term b a)],
                            Rbt (b, Nat) [(Bool, (Term b a, Term b a))])))));
impl_ofc (TP x) = x;

q_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [(Bool, (Term a b, Term a b))]))))) ->
      [Term a b];
q_impl (uu, (q, uv)) = q;

q :: forall a b. (Key a, Key b) => Tp a b -> [Term a b];
q tp = q_impl (impl_ofc tp);

r_impl ::
  forall a b.
    (Linorder a) => (Bool,
                      ([Term a b],
                        (Bool,
                          ([(Term a b, Term a b)],
                            ([(Term a b, Term a b)],
                              Rbt (a, Nat)
                                [(Bool, (Term a b, Term a b))]))))) ->
                      [(Term a b, Term a b)];
r_impl (uu, (uv, (uw, (vR, (ux, m))))) = vR ++ rules_with id m;

r :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
r tp = r_impl (impl_ofc tp);

default_nfs_nt_trs :: Bool;
default_nfs_nt_trs = False;

xml2inn_rel_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Bool,
                       ([Term (Lab a b) [Prelude.Char]],
                         ([(Term (Lab a b) [Prelude.Char],
                             Term (Lab a b) [Prelude.Char])],
                           [(Term (Lab a b) [Prelude.Char],
                              Term (Lab a b) [Prelude.Char])])));
xml2inn_rel_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Inn_TRS_input (inn, (r, so)) ->
          returna
            (default_nfs_nt_trs,
              (strategy_to_Q inn r,
                (r, (case so of {
                      Nothing -> [];
                      Just s -> s;
                    }))));
        COMP_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        EQ_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        CPX_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        FP_TRS_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        CTRS_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Unknown_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
      }));

xml2inn_fp_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Sum (Bool,
                            ([Term (Lab a b) [Prelude.Char]],
                              [(Term (Lab a b) [Prelude.Char],
                                 Term (Lab a b) [Prelude.Char])]))
                       ([(Ctxt (Lab a b) [Prelude.Char],
                           (Term (Lab a b) [Prelude.Char], Location))],
                         [(Term (Lab a b) [Prelude.Char],
                            Term (Lab a b) [Prelude.Char])]));
xml2inn_fp_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Inn_TRS_input (inn, (r, Nothing)) ->
          returna (Inl (default_nfs_nt_trs, (strategy_to_Q inn r, r)));
        Inn_TRS_input (inn, (r, Just _)) ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        COMP_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        EQ_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        CPX_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        FP_TRS_input (fp, r) -> returna (Inr (strategy_to_fp fp r, r));
        CTRS_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Unknown_input _ ->
          errora
            ['n', 'o', 'n', '-', 'r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ',
              'T', 'R', 'S', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
      }));

xml2fp_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     ([(Ctxt (Lab a b) [Prelude.Char],
                         (Term (Lab a b) [Prelude.Char], Location))],
                       [(Term (Lab a b) [Prelude.Char],
                          Term (Lab a b) [Prelude.Char])]);
xml2fp_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        Inn_TRS_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        COMP_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        EQ_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        CPX_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        FP_TRS_input (fp, r) -> returna (strategy_to_fp fp r, r);
        CTRS_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
        Unknown_input _ ->
          errora
            ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', '/', 'f', 'o', 'r',
              'b', 'i', 'd', 'd', 'e', 'n', '-', 'p', 'a', 't', 't', 'e', 'r',
              'n', '/', 'c', 'o', 'n', 't', 'e', 'x', 't', '-', 's', 'e', 'n',
              's', 'i', 't', 'i', 'v', 'e', ' ', 'T', 'R', 'S', ' ', 'e', 'x',
              'p', 'e', 'c', 't', 'e', 'd'];
      }));

xml2inn_nt_trs_assm ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Bool,
                       ([Term (Lab a b) [Prelude.Char]],
                         [(Term (Lab a b) [Prelude.Char],
                            Term (Lab a b) [Prelude.Char])]));
xml2inn_nt_trs_assm xml2name x =
  binda (xml2pre_trs_input xml2name x)
    (\ a ->
      (case a of {
        DP_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Inn_TRS_input (inn, (r, Nothing)) ->
          returna (default_nfs_nt_trs, (strategy_to_Q inn r, r));
        Inn_TRS_input (inn, (r, Just _)) ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        COMP_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        EQ_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        CPX_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        FP_TRS_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        CTRS_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
        Unknown_input _ ->
          errora
            ['(', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ')', ' ', 'T',
              'R', 'S', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'e',
              'l', 'a', 't', 'i', 'v', 'e', ' ', 'r', 'u', 'l', 'e', 's', ' ',
              'e', 'x', 'p', 'e', 'c', 't', 'e', 'd'];
      }));

xml2reltrs_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Reltrs_nontermination_proof a b [Prelude.Char]);
xml2reltrs_nontermination_proof xml2name x =
  singleton
    ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'N', 'o', 'n', 't', 'e', 'r', 'm',
      'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i', 't',
          'i', 'o', 'n', 'V', 'i', 'o', 'l', 'a', 't', 'e', 'd'],
         leaf ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i',
                't', 'i', 'o', 'n', 'V', 'i', 'o', 'l', 'a', 't', 'e', 'd']
           Rel_Not_Well_Formed),
        (['l', 'o', 'o', 'p'],
          change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              Rel_Loop (Rel_trs_loop_prf s rseq sigma c))),
        (['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't',
           'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
          change (xml2trs_nontermination_proof xml2name) Rel_R_Not_SN),
        (['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
          triple ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
            (singleton ['t', 'r', 's'] (rules xml2name) Just)
            (singleton ['t', 'r', 's'] (rules xml2name) Just)
            (xml2reltrs_nontermination_proof xml2name)
            (\ r s -> Rel_Rule_Removal (Rule_removal_nonterm_reltrs_prf r s))),
        (['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a', 'l'],
          triple
            ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a',
              'l']
            (singleton ['t', 'r', 's'] (rules xml2name) Just)
            (singleton ['t', 'r', 's'] (rules xml2name) Just)
            (xml2reltrs_nontermination_proof xml2name)
            (\ _ _ -> Rel_TRS_String_Reversal)),
        (['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
           'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
              'n', 'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2inn_rel_nt_trs_assm xml2name)
            (\ qtrs -> Rel_TRS_Assume_Not_SN qtrs [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2inn_rel_nt_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == ['t', 'r']
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
       (xml2dp_inputa False xml2name) (xml2dp_nontermination_proof xml2name)
       Infinite_assm_proof xa
else (if inp == ['r', 'e']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == ['u', 'n']
              then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                     xml2unknown_input (xml2unknown_disproof xml2name)
                     Unknown_assm_proof xa
              else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa))))))
            (\ _ -> Rel_TRS_Assume_Not_SN))])
    id x;

xml2trs_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Trs_nontermination_proof a b [Prelude.Char]);
xml2trs_nontermination_proof xml2name x =
  singleton
    ['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
      'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i', 't',
          'i', 'o', 'n', 'V', 'i', 'o', 'l', 'a', 't', 'e', 'd'],
         leaf ['v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 'C', 'o', 'n', 'd', 'i',
                't', 'i', 'o', 'n', 'V', 'i', 'o', 'l', 'a', 't', 'e', 'd']
           TRS_Not_Well_Formed),
        (['l', 'o', 'o', 'p'],
          change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              TRS_Loop
                (TRS_loop_prf s (map (\ (xa, (y, (_, z))) -> (xa, (y, z))) rseq)
                  sigma c))),
        (['n', 'o', 'n', 'L', 'o', 'o', 'p'],
          change (nonloop xml2name) TRS_Nonloop),
        (['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'n', 'g',
           'S', 'R', 'S'],
          change (nonloop_srs xml2name) TRS_Nonloop_SRS),
        (['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
          pair ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ r -> TRS_Rule_Removal (Rule_removal_nonterm_trs_prf r))),
        (['d', 'p', 'T', 'r', 'a', 'n', 's'],
          triple ['d', 'p', 'T', 'r', 'a', 'n', 's']
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (bool ['m', 'a', 'r', 'k', 'e', 'd', 'S', 'y', 'm', 'b', 'o', 'l',
                    's'])
            (xml2dp_nontermination_proof xml2name)
            (\ p _ -> TRS_DP_Trans (DP_trans_nontermination_tt_prf p))),
        (['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a', 'l'],
          pair ['s', 't', 'r', 'i', 'n', 'g', 'R', 'e', 'v', 'e', 'r', 's', 'a',
                 'l']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ _ -> TRS_String_Reversal)),
        (['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U', 'n', 'a', 'r',
           'y'],
          triple
            ['c', 'o', 'n', 's', 't', 'a', 'n', 't', 'T', 'o', 'U', 'n', 'a',
              'r', 'y']
            (renaming xml2name) (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ ren s ->
              TRS_Constant_String (Const_string_complete_proof ren s))),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's', 'I',
           'n', 'c', 'r', 'e', 'a', 's', 'e'],
          pair ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's',
                 'I', 'n', 'c', 'r', 'e', 'a', 's', 'e']
            (innermostLhss xml2name) (xml2trs_nontermination_proof xml2name)
            (\ q -> TRS_Q_Increase (Q_increase_nonterm_trs_prf q))),
        (['s', 'w', 'i', 't', 'c', 'h', 'F', 'u', 'l', 'l', 'S', 't', 'r', 'a',
           't', 'e', 'g', 'y'],
          pair ['s', 'w', 'i', 't', 'c', 'h', 'F', 'u', 'l', 'l', 'S', 't', 'r',
                 'a', 't', 'e', 'g', 'y']
            (wcr_proof xml2name) (xml2trs_nontermination_proof xml2name)
            TRS_Termination_Switch),
        (['u', 'n', 'c', 'u', 'r', 'r', 'y'],
          triple ['u', 'n', 'c', 'u', 'r', 'r', 'y'] (uncurry_info xml2name)
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2trs_nontermination_proof xml2name)
            (\ i r -> TRS_Uncurry (Uncurry_nt_proof i r))),
        (['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
           'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
              'n', 'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2inn_nt_trs_assm xml2name)
            (\ qtrs -> TRS_Assume_Not_SN qtrs [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2inn_nt_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == ['t', 'r']
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
       (xml2dp_inputa False xml2name) (xml2dp_nontermination_proof xml2name)
       Infinite_assm_proof xa
else (if inp == ['r', 'e']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == ['u', 'n']
              then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                     xml2unknown_input (xml2unknown_disproof xml2name)
                     Unknown_assm_proof xa
              else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa))))))
            (\ _ -> TRS_Assume_Not_SN))])
    id x;

xml2fp_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Fp_nontermination_proof a b [Prelude.Char]);
xml2fp_nontermination_proof xml2name x =
  singleton
    ['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
      'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['l', 'o', 'o', 'p'],
         change (loop xml2name)
           (\ (s, (rseq, (sigma, c))) ->
             FPTRS_Loop
               (FP_loop_prf c sigma s
                 (map (\ (xa, (y, (_, z))) -> (xa, (y, z))) rseq)))),
        (['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
          pair ['r', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2fp_nontermination_proof xml2name)
            (\ r -> FPTRS_Rule_Removal (Rule_removal_nonterm_trs_prf r))),
        (['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
           'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
              'n', 'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2fp_nt_trs_assm xml2name)
            (\ qtrs -> FPTRS_Assume_Not_SN qtrs [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2fp_nt_trs_assm xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == ['t', 'r']
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
       (xml2dp_inputa False xml2name) (xml2dp_nontermination_proof xml2name)
       Infinite_assm_proof xa
else (if inp == ['r', 'e']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == ['u', 'n']
              then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                     xml2unknown_input (xml2unknown_disproof xml2name)
                     Unknown_assm_proof xa
              else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa))))))
            (\ _ -> FPTRS_Assume_Not_SN))])
    id x;

xml2dp_nontermination_proof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Dp_nontermination_proof a b [Prelude.Char]);
xml2dp_nontermination_proof xml2name x =
  singleton
    ['d', 'p', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
      'n', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l'],
         choice
           ['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
           [triple
              ['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
              (singleton ['d', 'p', 's'] (rules xml2name) Just)
              (singleton ['t', 'r', 's'] (rules xml2name) Just)
              (xml2dp_nontermination_proof xml2name)
              (\ p r -> DP_Rule_Removal (Rule_removal_nonterm_dp_prf p r)),
             pair ['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a',
                    'l']
               (singleton ['t', 'r', 's'] (rules xml2name) Just)
               (xml2dp_nontermination_proof xml2name)
               (\ r -> DP_Rule_Removal (Rule_removal_nonterm_dp_prf Nothing r)),
             pair ['d', 'p', 'R', 'u', 'l', 'e', 'R', 'e', 'm', 'o', 'v', 'a',
                    'l']
               (singleton ['d', 'p', 's'] (rules xml2name) Just)
               (xml2dp_nontermination_proof xml2name)
               (\ p ->
                 DP_Rule_Removal (Rule_removal_nonterm_dp_prf p Nothing))]),
        (['l', 'o', 'o', 'p'],
          change (loop xml2name)
            (\ (s, (rseq, (sigma, c))) ->
              DP_Loop (DP_loop_prf s rseq sigma c))),
        (['n', 'o', 'n', 'L', 'o', 'o', 'p'],
          change (nonloop xml2name) DP_Nonloop),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's', 'R',
           'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c'],
          pair ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's',
                 'R', 'e', 'm', 'o', 'v', 'a', 'l', 'P', 'r', 'o', 'c']
            (innermostLhss xml2name) (xml2dp_nontermination_proof xml2name)
            (\ q -> DP_Q_Reduction (DP_q_reduction_nonterm_prf q))),
        (['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's', 'I',
           'n', 'c', 'r', 'e', 'a', 's', 'e', 'P', 'r', 'o', 'c'],
          pair ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', 'L', 'h', 's', 's',
                 'I', 'n', 'c', 'r', 'e', 'a', 's', 'e', 'P', 'r', 'o', 'c']
            (innermostLhss xml2name) (xml2dp_nontermination_proof xml2name)
            (\ q -> DP_Q_Increase (Q_increase_nonterm_dp_prf q))),
        (['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n', 'P',
           'r', 'o', 'c'],
          pair ['i', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n',
                 'P', 'r', 'o', 'c']
            (singleton ['d', 'p', 's'] (rules xml2name) id)
            (xml2dp_nontermination_proof xml2name)
            (\ p -> DP_Instantiation (Instantiation_complete_proc_prf p))),
        (['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 'P', 'r', 'o', 'c'],
          tuple4
            ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 'P', 'r', 'o', 'c']
            (rule xml2name) pos
            (singleton ['n', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', 's']
              (rules xml2name) id)
            (xml2dp_nontermination_proof xml2name)
            (\ st po p -> DP_Narrowing (Narrowing_complete_proc_prf st po p))),
        (['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o', 'c'],
          guard (\ xa -> equal_nat (num_children xa) (Nat_of_num (Bit1 One)))
            (triple
              ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o', 'c']
              (rule xml2name) (rstep xml2name)
              (xml2dp_nontermination_proof xml2name)
              (\ (s, t) (p, (lr, ta)) ->
                DP_Rewriting
                  (Rewriting_complete_proc_prf Nothing (s, t) (s, ta) (s, ta) lr
                    p)))
            (guard
              (\ xa ->
                equal_nat (num_children xa) (Nat_of_num (Bit0 (Bit0 One))))
              (guard
                (\ xa ->
                  tag (nth (children xa) (Nat_of_num (Bit0 One))) ==
                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's'])
                (tuple4
                  ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                    'c']
                  (rule xml2name) (rstep xml2name)
                  (singleton
                    ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                    (rules xml2name) id)
                  (xml2dp_nontermination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) u ->
                    DP_Rewriting
                      (Rewriting_complete_proc_prf (Just u) (s, t) (s, ta)
                        (s, ta) lr p)))
                (tuple4
                  ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                    'c']
                  (rule xml2name) (rstep xml2name) (rule xml2name)
                  (xml2dp_nontermination_proof xml2name)
                  (\ (s, t) (p, (lr, ta)) st ->
                    DP_Rewriting
                      (Rewriting_complete_proc_prf Nothing (s, t) (s, ta) st lr
                        p))))
              (tuple5
                ['r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', 'P', 'r', 'o',
                  'c']
                (rule xml2name) (rstep xml2name) (rule xml2name)
                (singleton
                  ['u', 's', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
                  (rules xml2name) id)
                (xml2dp_nontermination_proof xml2name)
                (\ (s, t) (p, (lr, ta)) st u ->
                  DP_Rewriting
                    (Rewriting_complete_proc_prf (Just u) (s, t) (s, ta) st lr
                      p))))),
        (['s', 'w', 'i', 't', 'c', 'h', 'F', 'u', 'l', 'l', 'S', 't', 'r', 'a',
           't', 'e', 'g', 'y', 'P', 'r', 'o', 'c'],
          pair ['s', 'w', 'i', 't', 'c', 'h', 'F', 'u', 'l', 'l', 'S', 't', 'r',
                 'a', 't', 'e', 'g', 'y', 'P', 'r', 'o', 'c']
            (wcr_proof xml2name) (xml2dp_nontermination_proof xml2name)
            DP_Termination_Switch),
        (['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
           'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n'],
          singleton
            ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
              'n', 'A', 's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n']
            (xml2dp_inputa False xml2name)
            (\ qdp -> DP_Assume_Infinite qdp [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            (xml2dp_inputa False xml2name)
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == ['t', 'r']
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
       (xml2dp_inputa False xml2name) (xml2dp_nontermination_proof xml2name)
       Infinite_assm_proof xa
else (if inp == ['r', 'e']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == ['u', 'n']
              then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                     xml2unknown_input (xml2unknown_disproof xml2name)
                     Unknown_assm_proof xa
              else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa))))))
            (\ _ -> DP_Assume_Infinite))])
    id x;

xml2unknown_disproof ::
  forall a b.
    (Eq a,
      Eq b) => (Xml -> Sum_bot [Prelude.Char] (Lab a b)) ->
                 Xml ->
                   Sum_bot [Prelude.Char]
                     (Neg_unknown_proof a b [Prelude.Char]);
xml2unknown_disproof xml2name x =
  singleton
    ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't', 'P', 'r', 'o',
      'o', 'f']
    (options
      [(['u', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 's', 's', 'u', 'm', 'p', 't',
          'i', 'o', 'n'],
         singleton
           ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'A', 's', 's', 'u', 'm', 'p',
             't', 'i', 'o', 'n']
           xml2unknown_input (\ u -> Assume_NT_Unknown u [])),
        (['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f'],
          many2 ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'P', 'r', 'o', 'o', 'f']
            (text ['d', 'e', 's', 'c', 'r', 'i', 'p', 't', 'i', 'o', 'n'])
            xml2unknown_input
            (\ xa ->
              let {
                cs = children xa;
              } in (if not (equal_nat (size_list cs) (Nat_of_num (Bit0 One)))
                     then fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa
                     else let {
                            inp = take (Nat_of_num (Bit0 One))
                                    (tag (nth cs (Nat_of_num One)));
                          } in (if inp == ['t', 'r']
                                 then binda
(xml2inn_fp_nt_trs_assm xml2name (hd cs))
(\ io_trs ->
  (case io_trs of {
    Inl qtrs ->
      change (xml2trs_nontermination_proof xml2name) (Not_SN_assm_proof qtrs);
    Inr fptrs ->
      change (xml2fp_nontermination_proof xml2name)
        (Not_SN_FP_assm_proof fptrs);
  })
    (nth cs (Nat_of_num One)))
                                 else (if inp == ['d', 'p']
then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
       (xml2dp_inputa False xml2name) (xml2dp_nontermination_proof xml2name)
       Infinite_assm_proof xa
else (if inp == ['r', 'e']
       then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
              (xml2inn_rel_nt_trs_assm xml2name)
              (xml2reltrs_nontermination_proof xml2name) Not_RelSN_assm_proof xa
       else (if inp == ['u', 'n']
              then pair ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f']
                     xml2unknown_input (xml2unknown_disproof xml2name)
                     Unknown_assm_proof xa
              else fail ['s', 'u', 'b', 'P', 'r', 'o', 'o', 'f'] xa))))))
            (\ _ -> Assume_NT_Unknown))])
    id x;

xml2quasi_reductive_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Quasi_reductive_proof a [Nat] [Prelude.Char]);
xml2quasi_reductive_proof xml2name =
  singleton
    ['q', 'u', 'a', 's', 'i', 'R', 'e', 'd', 'u', 'c', 't', 'i', 'v', 'e', 'P',
      'r', 'o', 'o', 'f']
    (options
      [(['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g'],
         pair ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g']
           (many ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', 'I', 'n',
                   'f', 'o', 'r', 'm', 'a', 't', 'i', 'o', 'n']
             (many1
               ['u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', 'E', 'n', 't',
                 'r', 'y']
               (crule xml2name) (rule xml2name) (\ a b -> (a, b)))
             id)
           (xml2trs_termination_proof xml2name) Unravel)])
    id;

subsumption_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml ->
        Sum_bot [Prelude.Char]
          [((Term a [Prelude.Char], Term a [Prelude.Char]),
             [(Pos, ((Term a [Prelude.Char], Term a [Prelude.Char]),
                      (Bool, Term a [Prelude.Char])))])];
subsumption_proof xml2name =
  many ['s', 'u', 'b', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 'P', 'r', 'o',
         'o', 'f']
    (pair ['r', 'u', 'l', 'e', 'S', 'u', 'b', 's', 'u', 'm', 'p', 't', 'i', 'o',
            'n', 'P', 'r', 'o', 'o', 'f']
      (rule xml2name) (conversion xml2name) (\ a b -> (a, b)))
    id;

xml2completion_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Completion_proof a [Nat] [Prelude.Char]);
xml2completion_proof xml2name =
  triple
    ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f']
    (wcr_proof xml2name) (xml2trs_termination_proof xml2name)
    (xml1to2elements
      ['e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e', 'P', 'r', 'o',
        'o', 'f']
      (subsumption_proof xml2name) (subsumption_proof xml2name)
      (\ a b -> (a, b)))
    (\ w t (a, b) -> SN_WCR_Eq w t a b);

xml2equational_disproof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Equational_disproof a [Nat] [Prelude.Char]);
xml2equational_disproof xml2name =
  singleton
    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'D', 'i', 's', 'p', 'r',
      'o', 'o', 'f']
    (options
      [(['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'A', 'n', 'd', 'N',
          'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n'],
         pair ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'A', 'n', 'd',
                'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n']
           (singleton ['t', 'r', 's'] (rules xml2name) id)
           (xml2completion_proof xml2name)
           Completion_and_Normalization_Different)])
    id;

xml2equational_proof ::
  forall a.
    (Eq a,
      Key a) => (Xml -> Sum_bot [Prelude.Char] (Lab a [Nat])) ->
                  Xml ->
                    Sum_bot [Prelude.Char]
                      (Equational_proof a [Nat] [Prelude.Char]);
xml2equational_proof xml2name =
  singleton
    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o', 'o',
          'f', 'T', 'r', 'e', 'e'],
         singleton
           ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'P', 'r', 'o',
             'o', 'f', 'T', 'r', 'e', 'e']
           (xml2eq_proof xml2name) Equational_Proof_Tree),
        (['c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n'],
          change (conversion xml2name) Conversion),
        (['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'A', 'n', 'd', 'N',
           'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n'],
          pair ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'A', 'n', 'd',
                 'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o',
                 'n']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2completion_proof xml2name) Completion_and_Normalization)])
    id;

xml2complexity_proof ::
  forall a.
    (Xml -> Sum_bot [Prelude.Char] a) ->
      Xml -> Sum_bot [Prelude.Char] (Complexity_proof a [Prelude.Char]);
xml2complexity_proof xml2name x =
  singleton
    ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'P', 'r', 'o', 'o', 'f']
    (options
      [(['r', 'u', 'l', 'e', 'S', 'h', 'i', 'f', 't', 'i', 'n', 'g'],
         triple ['r', 'u', 'l', 'e', 'S', 'h', 'i', 'f', 't', 'i', 'n', 'g']
           (ordering_constraint_proof False xml2name)
           (singleton ['t', 'r', 's'] (rules xml2name) id)
           (xml2complexity_proof xml2name) Rule_Shift_Complexity),
        (['r', 'e', 'm', 'o', 'v', 'e', 'N', 'o', 'n', 'A', 'p', 'p', 'l', 'i',
           'c', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's'],
          pair ['r', 'e', 'm', 'o', 'v', 'e', 'N', 'o', 'n', 'A', 'p', 'p', 'l',
                 'i', 'c', 'a', 'b', 'l', 'e', 'R', 'u', 'l', 'e', 's']
            (singleton ['t', 'r', 's'] (rules xml2name) id)
            (xml2complexity_proof xml2name)
            Remove_Nonapplicable_Rules_Complexity),
        (['r', 'I', 's', 'E', 'm', 'p', 't', 'y'],
          leaf ['r', 'I', 's', 'E', 'm', 'p', 't', 'y'] RisEmpty_Complexity)])
    id x;

xml2cert_problem ::
  (Xml -> Sum_bot [Prelude.Char] [Prelude.Char]) ->
    (Xml -> Sum_bot [Prelude.Char] (Lab [Prelude.Char] [Nat])) ->
      Xml ->
        Sum_bot [Prelude.Char]
          (Cert_problem [Prelude.Char] [Nat] [Prelude.Char]);
xml2cert_problem xml2uname xml2name (XML name egal cs texta) =
  (if name ==
        ['c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', 'P',
          'r', 'o', 'b', 'l', 'e', 'm'] &&
        is_none texta && less_eq_nat (Nat_of_num (Bit1 One)) (size_list cs)
    then binda (xml2input xml2name (nth cs Zero_nat))
           (\ inp ->
             binda (text ['c', 'p', 'f', 'V', 'e', 'r', 's', 'i', 'o', 'n']
                     (nth cs (Nat_of_num One)))
               (\ _ ->
                 (case inp of {
                   DP_input (m, (p, (q, r))) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['d', 'p', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2dp_termination_proof xml2name)
                              (DP_Termination_Proof default_nfs_dp m p [] q []
                                r)),
                           (['d', 'p', 'N', 'o', 'n', 't', 'e', 'r', 'm', 'i',
                              'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o', 'o',
                              'f'],
                             change (xml2dp_nontermination_proof xml2name)
                               (DP_Nontermination_Proof default_nfs_dp m p q
                                 r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   Inn_TRS_input (q, (r, Nothing)) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a',
                             't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2trs_termination_proof xml2name)
                              (TRS_Termination_Proof default_nfs_trs q r
                                Nothing)),
                           (['c', 'r', 'P', 'r', 'o', 'o', 'f'],
                             (if null (strategy_to_Q q r)
                               then change (xml2cr_proof xml2name)
                                      (TRS_Confluence_Proof False r)
                               else (\ _ ->
                                      errora
['s', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ', 'f', 'o', 'r', ' ', 'c',
  'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'u', 'n', 's', 'u', 'p',
  'p', 'o', 'r', 't', 'e', 'd']))),
                           (['c', 'r', 'D', 'i', 's', 'p', 'r', 'o', 'o', 'f'],
                             (if null (strategy_to_Q q r)
                               then change (xml2ncr_proof xml2name)
                                      (TRS_Non_Confluence_Proof False r)
                               else (\ _ ->
                                      errora
['s', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ', 'f', 'o', 'r', ' ', 'c',
  'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'u', 'n', 's', 'u', 'p',
  'p', 'o', 'r', 't', 'e', 'd']))),
                           (['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm',
                              'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o',
                              'o', 'f'],
                             change (xml2trs_nontermination_proof xml2name)
                               (TRS_Nontermination_Proof default_nfs_trs q r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   Inn_TRS_input (q, (r, Just s)) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'T', 'e',
                             'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', 'P',
                             'r', 'o', 'o', 'f'],
                            change (xml2trs_termination_proof xml2name)
                              (TRS_Termination_Proof default_nfs_trs q r
                                (Just s))),
                           (['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', 'N', 'o',
                              'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                              'o', 'n', 'P', 'r', 'o', 'o', 'f'],
                             change (xml2reltrs_nontermination_proof xml2name)
                               (Relative_TRS_Nontermination_Proof
                                 default_nfs_trs q r s))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   COMP_input (e, r) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n',
                             'P', 'r', 'o', 'o', 'f'],
                            change (xml2completion_proof xml2name)
                              (Completion_Proof e r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   EQ_input (eqs, eq) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l',
                             'P', 'r', 'o', 'o', 'f'],
                            change (xml2equational_proof xml2name)
                              (Equational_Proof eqs eq)),
                           (['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l',
                              'D', 'i', 's', 'p', 'r', 'o', 'o', 'f'],
                             change (xml2equational_disproof xml2name)
                               (Equational_Disproof eqs eq))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   CPX_input (q, (r, (s, (cm, cc)))) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (change (xml2complexity_proof xml2name)
                         (Complexity_Proof q r s cm cc))
                       id (nth cs (Nat_of_num (Bit0 One)));
                   FP_TRS_input (Outermost, r) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a',
                             't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2fptrs_termination_proof xml2name)
                              (Outermost_Termination_Proof r)),
                           (['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm',
                              'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o',
                              'o', 'f'],
                             change (xml2fp_nontermination_proof xml2name)
                               (Outermost_Nontermination_Proof r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   FP_TRS_input (Context_Sensitive mu, r) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a',
                             't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2fptrs_termination_proof xml2name)
                              (CS_Termination_Proof mu r)),
                           (['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm',
                              'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o',
                              'o', 'f'],
                             change (xml2fp_nontermination_proof xml2name)
                               (CS_Nontermination_Proof mu r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   FP_TRS_input (Forbidden_Patterns p, r) ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (options
                         [(['t', 'r', 's', 'T', 'e', 'r', 'm', 'i', 'n', 'a',
                             't', 'i', 'o', 'n', 'P', 'r', 'o', 'o', 'f'],
                            change (xml2fptrs_termination_proof xml2name)
                              (FP_Termination_Proof p r)),
                           (['t', 'r', 's', 'N', 'o', 'n', 't', 'e', 'r', 'm',
                              'i', 'n', 'a', 't', 'i', 'o', 'n', 'P', 'r', 'o',
                              'o', 'f'],
                             change (xml2fp_nontermination_proof xml2name)
                               (FP_Nontermination_Proof p r))])
                       id (nth cs (Nat_of_num (Bit0 One)));
                   CTRS_input ctrs ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (change (xml2quasi_reductive_proof xml2name)
                         (Quasi_Reductive_Proof ctrs))
                       id (nth cs (Nat_of_num (Bit0 One)));
                   Unknown_input u ->
                     singleton ['p', 'r', 'o', 'o', 'f']
                       (choice
                         ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u',
                           't']
                         [change (xml2unknown_proof xml2name) (Unknown_Proof u),
                           change (xml2unknown_disproof xml2name)
                             (Unknown_Disproof u)])
                       id (nth cs (Nat_of_num (Bit0 One)));
                 })))
    else errora
           (['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'p', 'a', 'r',
              's', 'e', ' ', 'r', 'o', 'o', 't', ' ', 'e', 'l', 'e', 'm', 'e',
              'n', 't', ' ', '<'] ++
             name ++ ['>']));

xml_complexity_measure ::
  forall a b c. (Showa a, Showa b) => Complexity_measure (Lab a [b]) c -> Xml;
xml_complexity_measure (Derivational_Complexity f) =
  XML ['d', 'e', 'r', 'i', 'v', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'C', 'o',
        'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
    [] [xml_signature f] Nothing;
xml_complexity_measure (Runtime_Complexity c d) =
  XML ['r', 'u', 'n', 't', 'i', 'm', 'e', 'C', 'o', 'm', 'p', 'l', 'e', 'x',
        'i', 't', 'y']
    [] [xml_signature c, xml_signature d] Nothing;

xml_complexity_class :: Complexity_class -> Xml;
xml_complexity_class (Comp_Poly n) =
  XML ['p', 'o', 'l', 'y', 'n', 'o', 'm', 'i', 'a', 'l'] [] []
    (Just (shows_prec_nat Zero_nat n []));

xml_cert_problem ::
  forall a b c. (Showa a, Showa b, Showa c) => Cert_problem a [b] c -> Xml;
xml_cert_problem (TRS_Termination_Proof nfs q r s_o uu) =
  xml_trs_input (Inl q) r s_o;
xml_cert_problem (TRS_Nontermination_Proof nfs q r uv) =
  xml_trs_input (Inl q) r Nothing;
xml_cert_problem (Outermost_Nontermination_Proof r uw) =
  xml_trs_input (Inr Outermost) r Nothing;
xml_cert_problem (Outermost_Termination_Proof r ux) =
  xml_trs_input (Inr Outermost) r Nothing;
xml_cert_problem (FP_Nontermination_Proof p r uy) =
  xml_trs_input (Inr (Forbidden_Patterns p)) r Nothing;
xml_cert_problem (FP_Termination_Proof p r uz) =
  xml_trs_input (Inr (Forbidden_Patterns p)) r Nothing;
xml_cert_problem (CS_Nontermination_Proof mu r va) =
  xml_trs_input (Inr (Context_Sensitive mu)) r Nothing;
xml_cert_problem (CS_Termination_Proof mu r vb) =
  xml_trs_input (Inr (Context_Sensitive mu)) r Nothing;
xml_cert_problem (Relative_TRS_Nontermination_Proof nfs q r s vc) =
  xml_trs_input (Inl q) r (Just s);
xml_cert_problem (DP_Termination_Proof nfs m p pw q r rw vd) =
  XML ['d', 'p', 'I', 'n', 'p', 'u', 't'] []
    (xml_rules ['t', 'r', 's'] rw :
      xml_rules ['d', 'p', 's'] p :
        xml_strategy (Inl q) ++
          [XML ['m', 'i', 'n', 'i', 'm', 'a', 'l'] [] []
             (Just (if m then ['t', 'r', 'u', 'e']
                     else ['f', 'a', 'l', 's', 'e']))])
    Nothing;
xml_cert_problem (DP_Nontermination_Proof nfs m p q r ve) =
  XML ['d', 'p', 'I', 'n', 'p', 'u', 't'] []
    (xml_rules ['t', 'r', 's'] r :
      xml_rules ['d', 'p', 's'] p :
        xml_strategy (Inl q) ++
          [XML ['m', 'i', 'n', 'i', 'm', 'a', 'l'] [] []
             (Just (if m then ['t', 'r', 'u', 'e']
                     else ['f', 'a', 'l', 's', 'e']))])
    Nothing;
xml_cert_problem (TRS_Confluence_Proof nfs r vf) =
  xml_trs_input (Inl No_Strategy) r Nothing;
xml_cert_problem (TRS_Non_Confluence_Proof nfs r vg) =
  xml_trs_input (Inl No_Strategy) r Nothing;
xml_cert_problem (Completion_Proof e r vh) =
  XML ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', 'I', 'n', 'p', 'u',
        't']
    [] [xml_rules ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] e,
         xml_rules ['t', 'r', 's'] r]
    Nothing;
xml_cert_problem (Equational_Proof e eq vi) =
  XML ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'a', 's',
        'o', 'n', 'i', 'n', 'g', 'I', 'n', 'p', 'u', 't']
    [] [xml_rules ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] e,
         XML ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n'] []
           [xml_term (fst eq), xml_term (snd eq)] Nothing]
    Nothing;
xml_cert_problem (Equational_Disproof e eq vj) =
  XML ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'R', 'e', 'a', 's',
        'o', 'n', 'i', 'n', 'g', 'I', 'n', 'p', 'u', 't']
    [] [xml_rules ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] e,
         XML ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n'] []
           [xml_term (fst eq), xml_term (snd eq)] Nothing]
    Nothing;
xml_cert_problem (Complexity_Proof q r s cm cc vk) =
  XML ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', 'I', 'n', 'p', 'u',
        't']
    [] [xml_trs_input (Inl q) r s, xml_complexity_measure cm,
         xml_complexity_class cc]
    Nothing;
xml_cert_problem (Quasi_Reductive_Proof ctrs vl) = xml_ctrs_input ctrs;
xml_cert_problem (Unknown_Proof u vm) =
  XML ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't'] [] []
    (Just u);
xml_cert_problem (Unknown_Disproof u vn) =
  XML ['u', 'n', 'k', 'n', 'o', 'w', 'n', 'I', 'n', 'p', 'u', 't'] [] []
    (Just u);

rules_non_collapsing_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      Bool;
rules_non_collapsing_impl (uu, (uv, (uw, (ux, (uy, (uz, (nc, va))))))) = nc;

impl_ofd ::
  forall b a.
    (Linorder b) => Dpp b a ->
                      (Bool,
                        (Bool,
                          ([(Term b a, Term b a)],
                            ([(Term b a, Term b a)],
                              ([Term b a],
                                (Bool,
                                  (Bool,
                                    ([(Term b a, Term b a)],
                                      ([(Term b a, Term b a)],
(Rbt (b, Nat) [(Bool, (Term b a, Term b a))],
  (Rbt (b, Nat) [(Bool, (Term b a, Term b a))], Bool)))))))))));
impl_ofd (DPP x) = x;

rules_non_collapsing :: forall a b. (Linorder a) => Dpp a b -> Bool;
rules_non_collapsing d = rules_non_collapsing_impl (impl_ofd d);

nFQ_subset_NF_rules_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      Bool;
nFQ_subset_NF_rules_impla (uu, (uv, (uw, (ux, (uy, (b, uz)))))) = b;

nFQ_subset_NF_rulesa :: forall a b. (Linorder a) => Dpp a b -> Bool;
nFQ_subset_NF_rulesa d = nFQ_subset_NF_rules_impla (impl_ofd d);

rules_no_left_var_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      Bool;
rules_no_left_var_impl (uu, (uv, (uw, (ux, (uy, (uz, (va, ([], ([], vb)))))))))
  = True;
rules_no_left_var_impl (v, (vb, (ve, (vg, (vi, (vk, (vm, (vq : vr, vp)))))))) =
  False;
rules_no_left_var_impl
  (v, (vb, (ve, (vg, (vi, (vk, (vm, (vo, (vs : vt, vr))))))))) = False;

rules_no_left_var :: forall a b. (Linorder a) => Dpp a b -> Bool;
rules_no_left_var d = rules_no_left_var_impl (impl_ofd d);

reverse_rules_map_impl ::
  forall a b.
    (Linorder a) => (Bool,
                      (Bool,
                        ([(Term a b, Term a b)],
                          ([(Term a b, Term a b)],
                            ([Term a b],
                              (Bool,
                                (Bool,
                                  ([(Term a b, Term a b)],
                                    ([(Term a b, Term a b)],
                                      (Rbt (a, Nat)
 [(Bool, (Term a b, Term a b))],
(Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool))))))))))) ->
                      (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_map_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (m, ve))))))))))) fn =
  (case lookup m fn of {
    Nothing -> [];
    Just a -> map snd a;
  });

reverse_rules_map ::
  forall a b. (Linorder a) => Dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
reverse_rules_map d = reverse_rules_map_impl (impl_ofd d);

applicable_rule_implc ::
  forall a b. (Term a b -> Bool) -> (Term a b, Term a b) -> Bool;
applicable_rule_implc nf r = all nf (args (fst r));

wwf_qtrs_impl ::
  forall a b. (Eq b) => (Term a b -> Bool) -> [(Term a b, Term a b)] -> Bool;
wwf_qtrs_impl nf r =
  all (\ ra -> wf_rule ra || not (applicable_rule_implc nf ra)) r;

intersect_rules_impl ::
  forall a b.
    (Eq a, Linorder a, Corder b, Eq b,
      Mapping_impl b) => (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([Term a b],
                                   (Bool,
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
     (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool))))))))))) ->
                           [(Term a b, Term a b)] ->
                             (Bool,
                               (Bool,
                                 ([(Term a b, Term a b)],
                                   ([(Term a b, Term a b)],
                                     ([Term a b],
                                       (Bool,
 (Bool,
   ([(Term a b, Term a b)],
     ([(Term a b, Term a b)],
       (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool)))))))))));
intersect_rules_impl d ri =
  let {
    (nfs, (mi, (p, (pw, (q, (nfq, (nc, (vR, (vRw, (m, (rm, wwf))))))))))) = d;
    (vri, ria) = partition (is_Var . fst) ri;
    vr = list_inter vR vri;
    vrw = list_inter vRw vri;
    ma = intersect_rules ria m;
    rma = intersect_rules (reverse_rules ri) rm;
    rs = vr ++ vrw ++ map snd (values ma);
  } in (nfs, (mi, (p, (pw, (q, (nfq || nF_subset (map fst rs) q,
                                 (nc || all (\ (_, r) -> not (is_Var r)) rs,
                                   (vr, (vrw,
  (ma, (rma, wwf || wwf_qtrs_impl (nF_terms_list q) rs)))))))))));

intersect_rulesa ::
  forall a b.
    (Eq a, Linorder a, Corder b, Eq b,
      Mapping_impl b) => Dpp a b -> [(Term a b, Term a b)] -> Dpp a b;
intersect_rulesa d rs = DPP (intersect_rules_impl (impl_ofd d) rs);

intersect_pairs_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Bool))))))))))) ->
                 [(Term a b, Term a b)] ->
                   (Bool,
                     (Bool,
                       ([(Term a b, Term a b)],
                         ([(Term a b, Term a b)],
                           ([Term a b],
                             (Bool,
                               (Bool,
                                 ([(Term a b, Term a b)],
                                   ([(Term a b, Term a b)],
                                     (Rbt (a, Nat)
[(Bool, (Term a b, Term a b))],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 Bool)))))))))));
intersect_pairs_impl (nfs, (mi, (p, (pw, rest)))) ps =
  (nfs, (mi, (list_inter p ps, (list_inter pw ps, rest))));

intersect_pairs ::
  forall a b.
    (Eq a, Linorder a, Eq b) => Dpp a b -> [(Term a b, Term a b)] -> Dpp a b;
intersect_pairs d ps = DPP (intersect_pairs_impl (impl_ofd d) ps);

replace_pair_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Bool))))))))))) ->
                 (Term a b, Term a b) ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool)))))))))));
replace_pair_impl (nfs, (mi, (p, (pw, rest)))) pair ps =
  (nfs, (mi, (replace_impl pair ps p, (replace_impl pair ps pw, rest))));

replace_pair ::
  forall a b.
    (Eq a, Linorder a,
      Eq b) => Dpp a b ->
                 (Term a b, Term a b) -> [(Term a b, Term a b)] -> Dpp a b;
replace_pair d pair ps = DPP (replace_pair_impl (impl_ofd d) pair ps);

rules_implb ::
  forall a b.
    (Linorder a) => (Bool,
                      (Bool,
                        ([(Term a b, Term a b)],
                          ([(Term a b, Term a b)],
                            ([Term a b],
                              (Bool,
                                (Bool,
                                  ([(Term a b, Term a b)],
                                    ([(Term a b, Term a b)],
                                      (Rbt (a, Nat)
 [(Bool, (Term a b, Term a b))],
(Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool))))))))))) ->
                      [(Term a b, Term a b)];
rules_implb (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vrw, (m, vb)))))))))) =
  vr ++ vrw ++ map snd (values m);

split_rules_impla ::
  forall a b.
    (Eq a, Linorder a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Bool))))))))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules_impla d rs = partition (membera rs) (rules_implb d);

split_rulesa ::
  forall a b.
    (Eq a, Linorder a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rulesa d = split_rules_impla (impl_ofd d);

pairs_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      [(Term a b, Term a b)];
pairs_impl (uu, (uv, (p, (pw, uw)))) = p ++ pw;

split_pairs_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Bool))))))))))) ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_pairs_impl d ps = partition (membera ps) (pairs_impl d);

split_pairs ::
  forall a b.
    (Eq a, Linorder a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] ->
                   ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_pairs d = split_pairs_impl (impl_ofd d);

delete_R_Rw_impla ::
  forall a b.
    (Eq a, Linorder a, Corder b, Eq b,
      Mapping_impl b) => (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 ([Term a b],
                                   (Bool,
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)],
   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
     (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool))))))))))) ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] ->
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       ([Term a b],
 (Bool,
   (Bool,
     ([(Term a b, Term a b)],
       ([(Term a b, Term a b)],
         (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
           (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool)))))))))));
delete_R_Rw_impla d r rw =
  let {
    (nfs, (mi, (p, (pw, (q, (nfq, (nc, (vR, (vRw, (m, (rm, wwf))))))))))) = d;
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    vra = list_diff vR vr;
    vrwa = list_diff vRw vrw;
    ma = delete_rules True ra (delete_rules False rwa m);
    rma = delete_rules True (reverse_rules r)
            (delete_rules False (reverse_rules rw) rm);
    rs = vra ++ vrwa ++ map snd (values ma);
  } in (nfs, (mi, (p, (pw, (q, (nfq || nF_subset (map fst rs) q,
                                 (nc || all (\ (_, rb) -> not (is_Var rb)) rs,
                                   (vra, (vrwa,
   (ma, (rma, wwf || wwf_qtrs_impl (nF_terms_list q) rs)))))))))));

delete_R_Rwa ::
  forall a b.
    (Eq a, Linorder a, Corder b, Eq b,
      Mapping_impl b) => Dpp a b ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] -> Dpp a b;
delete_R_Rwa d r rw = DPP (delete_R_Rw_impla (impl_ofd d) r rw);

delete_P_Pw_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Bool))))))))))) ->
                 [(Term a b, Term a b)] ->
                   [(Term a b, Term a b)] ->
                     (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool)))))))))));
delete_P_Pw_impl (nfs, (mi, (p, (pw, rest)))) pd pwd =
  (nfs, (mi, (list_diff p pd, (list_diff pw pwd, rest))));

delete_P_Pw ::
  forall a b.
    (Eq a, Linorder a,
      Eq b) => Dpp a b ->
                 [(Term a b, Term a b)] -> [(Term a b, Term a b)] -> Dpp a b;
delete_P_Pw d p pw = DPP (delete_P_Pw_impl (impl_ofd d) p pw);

rules_map_impla ::
  forall a b.
    (Linorder a) => (Bool,
                      (Bool,
                        ([(Term a b, Term a b)],
                          ([(Term a b, Term a b)],
                            ([Term a b],
                              (Bool,
                                (Bool,
                                  ([(Term a b, Term a b)],
                                    ([(Term a b, Term a b)],
                                      (Rbt (a, Nat)
 [(Bool, (Term a b, Term a b))],
(Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool))))))))))) ->
                      (a, Nat) -> [(Term a b, Term a b)];
rules_map_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (m, vd)))))))))) fn
  = (case lookup m fn of {
      Nothing -> [];
      Just a -> map snd a;
    });

rules_mapa ::
  forall a b. (Linorder a) => Dpp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_mapa d = rules_map_impla (impl_ofd d);

wwf_rules_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      Bool;
wwf_rules_impl
  (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vc, (vd, (ve, wwf))))))))))) = wwf;

wwf_rules :: forall a b. (Linorder a) => Dpp a b -> Bool;
wwf_rules d = wwf_rules_impl (impl_ofd d);

q_empty_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      Bool;
q_empty_impla (uu, (uv, (uw, (ux, (q, uy))))) = null q;

q_emptya :: forall a b. (Linorder a) => Dpp a b -> Bool;
q_emptya d = q_empty_impla (impl_ofd d);

is_QNF_impla ::
  forall a b c.
    (Eq a, Corder b, Eq b, Mapping_impl b,
      Eq c) => (Bool,
                 (Bool,
                   ([(Term a b, Term a b)],
                     ([(Term a b, Term a b)],
                       ([Term a b],
                         (Bool,
                           (Bool,
                             ([(Term a b, Term a b)],
                               ([(Term a b, Term a b)],
                                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                                     Bool))))))))))) ->
                 Term a c -> Bool;
is_QNF_impla (uu, (uv, (uw, (ux, (q, uy))))) = nF_terms_list q;

is_QNFa ::
  forall a b.
    (Eq a, Linorder a, Corder b, Eq b,
      Mapping_impl b) => Dpp a b -> Term a b -> Bool;
is_QNFa d = is_QNF_impla (impl_ofd d);

rulesb :: forall a b. (Linorder a) => Dpp a b -> [(Term a b, Term a b)];
rulesb d = rules_implb (impl_ofd d);

pairs :: forall a b. (Linorder a) => Dpp a b -> [(Term a b, Term a b)];
pairs d = pairs_impl (impl_ofd d);

dpp_impl ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => (Bool,
                       (Bool,
                         ([(Term a b, Term a b)],
                           ([(Term a b, Term a b)],
                             ([Term a b],
                               (Bool,
                                 (Bool,
                                   ([(Term a b, Term a b)],
                                     ([(Term a b, Term a b)],
                                       (Rbt (a, Nat)
  [(Bool, (Term a b, Term a b))],
 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool))))))))))) ->
                       (Bool,
                         (Bool,
                           (Set (Term a b, Term a b),
                             (Set (Term a b, Term a b),
                               (Set (Term a b),
                                 (Set (Term a b, Term a b),
                                   Set (Term a b, Term a b)))))));
dpp_impl (nfs, (mi, (p, (pw, (q, (uu, (uv, (vr, (vrw, (m, uw)))))))))) =
  (nfs, (mi, (set p,
               (set pw,
                 (set q,
                   (set (vr ++ rules_with id m),
                     set (vrw ++ rules_with not m)))))));

dpp ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => Dpp a b ->
                       (Bool,
                         (Bool,
                           (Set (Term a b, Term a b),
                             (Set (Term a b, Term a b),
                               (Set (Term a b),
                                 (Set (Term a b, Term a b),
                                   Set (Term a b, Term a b)))))));
dpp d = dpp_impl (impl_ofd d);

nfs_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      Bool;
nfs_impla (nfs, uu) = nfs;

nfsa :: forall a b. (Linorder a) => Dpp a b -> Bool;
nfsa d = nfs_impla (impl_ofd d);

mk_impla ::
  forall a b.
    (Eq a, Linorder a, Corder b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 [Term a b] ->
                                   [(Term a b, Term a b)] ->
                                     [(Term a b, Term a b)] ->
                                       (Bool,
 (Bool,
   ([(Term a b, Term a b)],
     ([(Term a b, Term a b)],
       ([Term a b],
         (Bool,
           (Bool,
             ([(Term a b, Term a b)],
               ([(Term a b, Term a b)],
                 (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                   (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                     Bool)))))))))));
mk_impla nfs mi p pw q r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    rs = r ++ rw;
  } in (nfs, (mi, (p, (pw, (q, (nF_subset (map fst rs) q,
                                 (all (\ (_, rb) -> not (is_Var rb)) rs,
                                   (vr, (vrw,
  (insert_rules True ra (insert_rules False rwa empty),
    (insert_rules True (reverse_rules r)
       (insert_rules False (reverse_rules rw) empty),
      wwf_qtrs_impl (nF_terms_list q) rs)))))))))));

mka ::
  forall a b.
    (Eq a, Linorder a, Corder b, Eq b,
      Mapping_impl b) => Bool ->
                           Bool ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 [Term a b] ->
                                   [(Term a b, Term a b)] ->
                                     [(Term a b, Term a b)] -> Dpp a b;
mka nfs mi p pw q r rw = DPP (mk_impla nfs mi p pw q r rw);

rw_impla ::
  forall a b.
    (Linorder a) => (Bool,
                      (Bool,
                        ([(Term a b, Term a b)],
                          ([(Term a b, Term a b)],
                            ([Term a b],
                              (Bool,
                                (Bool,
                                  ([(Term a b, Term a b)],
                                    ([(Term a b, Term a b)],
                                      (Rbt (a, Nat)
 [(Bool, (Term a b, Term a b))],
(Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool))))))))))) ->
                      [(Term a b, Term a b)];
rw_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vb, (vrw, (m, vc)))))))))) =
  vrw ++ rules_with not m;

rwa :: forall a b. (Linorder a) => Dpp a b -> [(Term a b, Term a b)];
rwa d = rw_impla (impl_ofd d);

pw_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      [(Term a b, Term a b)];
pw_impl (uu, (uv, (uw, (pw, ux)))) = pw;

pw :: forall a b. (Linorder a) => Dpp a b -> [(Term a b, Term a b)];
pw d = pw_impl (impl_ofd d);

r_impla ::
  forall a b.
    (Linorder a) => (Bool,
                      (Bool,
                        ([(Term a b, Term a b)],
                          ([(Term a b, Term a b)],
                            ([Term a b],
                              (Bool,
                                (Bool,
                                  ([(Term a b, Term a b)],
                                    ([(Term a b, Term a b)],
                                      (Rbt (a, Nat)
 [(Bool, (Term a b, Term a b))],
(Rbt (a, Nat) [(Bool, (Term a b, Term a b))], Bool))))))))))) ->
                      [(Term a b, Term a b)];
r_impla (uu, (uv, (uw, (ux, (uy, (uz, (va, (vr, (vb, (m, vc)))))))))) =
  vr ++ rules_with id m;

ra :: forall a b. (Linorder a) => Dpp a b -> [(Term a b, Term a b)];
ra d = r_impla (impl_ofd d);

q_impla ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      [Term a b];
q_impla (uu, (uv, (uw, (ux, (q, uy))))) = q;

qa :: forall a b. (Linorder a) => Dpp a b -> [Term a b];
qa d = q_impla (impl_ofd d);

p_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      [(Term a b, Term a b)];
p_impl (uu, (uv, (p, uw))) = p;

p :: forall a b. (Linorder a) => Dpp a b -> [(Term a b, Term a b)];
p d = p_impl (impl_ofd d);

m_impl ::
  forall a b.
    (Bool,
      (Bool,
        ([(Term a b, Term a b)],
          ([(Term a b, Term a b)],
            ([Term a b],
              (Bool,
                (Bool,
                  ([(Term a b, Term a b)],
                    ([(Term a b, Term a b)],
                      (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                        (Rbt (a, Nat) [(Bool, (Term a b, Term a b))],
                          Bool))))))))))) ->
      Bool;
m_impl (uu, (mi, uv)) = mi;

m :: forall a b. (Linorder a) => Dpp a b -> Bool;
m d = m_impl (impl_ofd d);

dpp_rbt_impl ::
  forall a b.
    (Eq a, Linorder a, Corder b, Eq b, Mapping_impl b,
      Linorder b) => Dpp_ops_ext (Dpp a b) a b ();
dpp_rbt_impl =
  Dpp_ops_ext dpp p pw pairs qa ra rwa rulesb q_emptya rules_no_left_var
    rules_non_collapsing is_QNFa nFQ_subset_NF_rulesa rules_mapa
    reverse_rules_map intersect_pairs replace_pair intersect_rulesa delete_P_Pw
    delete_R_Rwa split_pairs split_rulesa mka m nfsa wwf_rules ();

nFQ_subset_NF_rules_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [(Bool, (Term a b, Term a b))]))))) ->
      Bool;
nFQ_subset_NF_rules_impl (uu, (uv, (b, uw))) = b;

nFQ_subset_NF_rules :: forall a b. (Key a, Key b) => Tp a b -> Bool;
nFQ_subset_NF_rules tp = nFQ_subset_NF_rules_impl (impl_ofc tp);

rules_impl ::
  forall a b.
    (Linorder a) => (Bool,
                      ([Term a b],
                        (Bool,
                          ([(Term a b, Term a b)],
                            ([(Term a b, Term a b)],
                              Rbt (a, Nat)
                                [(Bool, (Term a b, Term a b))]))))) ->
                      [(Term a b, Term a b)];
rules_impl (uu, (uv, (uw, (vR, (vRw, m))))) = vR ++ vRw ++ map snd (values m);

split_rules_impl ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => (Bool,
                  ([Term a b],
                    (Bool,
                      ([(Term a b, Term a b)],
                        ([(Term a b, Term a b)],
                          Rbt (a, Nat) [(Bool, (Term a b, Term a b))]))))) ->
                  [(Term a b, Term a b)] ->
                    ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules_impl tp rs =
  let {
    m = ceta_set_of rs;
  } in partition m (rules_impl tp);

split_rules ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => Tp a b ->
                  [(Term a b, Term a b)] ->
                    ([(Term a b, Term a b)], [(Term a b, Term a b)]);
split_rules tp = split_rules_impl (impl_ofc tp);

delete_R_Rw_impl ::
  forall a b.
    (Eq a, Linorder a, Corder b, Eq b,
      Mapping_impl b) => (Bool,
                           ([Term a b],
                             (Bool,
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   Rbt (a, Nat)
                                     [(Bool, (Term a b, Term a b))]))))) ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] ->
                               (Bool,
                                 ([Term a b],
                                   (Bool,
                                     ([(Term a b, Term a b)],
                                       ([(Term a b, Term a b)],
 Rbt (a, Nat) [(Bool, (Term a b, Term a b))])))));
delete_R_Rw_impl (nfs, (q, (uu, (vR, (vRw, m))))) r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
    vra = list_diff vR vr;
    vrwa = list_diff vRw vrw;
    ma = delete_rules True ra (delete_rules False rwa m);
  } in (nfs, (q, (nF_subset (map fst (vra ++ vrwa ++ map snd (values ma))) q,
                   (vra, (vrwa, ma)))));

delete_R_Rw ::
  forall a b.
    (Eq a, Key a, Corder b, Eq b, Key b,
      Mapping_impl b) => Tp a b ->
                           [(Term a b, Term a b)] ->
                             [(Term a b, Term a b)] -> Tp a b;
delete_R_Rw tp r rw = TP (delete_R_Rw_impl (impl_ofc tp) r rw);

rules_map_impl ::
  forall a b.
    (Linorder a) => (Bool,
                      ([Term a b],
                        (Bool,
                          ([(Term a b, Term a b)],
                            ([(Term a b, Term a b)],
                              Rbt (a, Nat)
                                [(Bool, (Term a b, Term a b))]))))) ->
                      (a, Nat) -> [(Term a b, Term a b)];
rules_map_impl (uu, (uv, (uw, (ux, (uy, m))))) fn =
  (case lookup m fn of {
    Nothing -> [];
    Just a -> map snd a;
  });

rules_map ::
  forall a b. (Key a, Key b) => Tp a b -> (a, Nat) -> [(Term a b, Term a b)];
rules_map tp = rules_map_impl (impl_ofc tp);

qreltrs_impl ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => (Bool,
                       ([Term a b],
                         (Bool,
                           ([(Term a b, Term a b)],
                             ([(Term a b, Term a b)],
                               Rbt (a, Nat)
                                 [(Bool, (Term a b, Term a b))]))))) ->
                       (Bool,
                         (Set (Term a b),
                           (Set (Term a b, Term a b),
                             Set (Term a b, Term a b))));
qreltrs_impl (nfs, (q, (uu, (vR, (vRw, m))))) =
  (nfs, (set q, (set (vR ++ rules_with id m), set (vRw ++ rules_with not m))));

qreltrs ::
  forall a b.
    (Eq a, Key a, Eq b,
      Key b) => Tp a b ->
                  (Bool,
                    (Set (Term a b),
                      (Set (Term a b, Term a b), Set (Term a b, Term a b))));
qreltrs tp = qreltrs_impl (impl_ofc tp);

q_empty_impl ::
  forall a b.
    (Bool,
      ([Term a b],
        (Bool,
          ([(Term a b, Term a b)],
            ([(Term a b, Term a b)],
              Rbt (a, Nat) [(Bool, (Term a b, Term a b))]))))) ->
      Bool;
q_empty_impl (uu, (q, uv)) = null q;

q_empty :: forall a b. (Key a, Key b) => Tp a b -> Bool;
q_empty tp = q_empty_impl (impl_ofc tp);

is_QNF_impl ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => (Bool,
                           ([Term a b],
                             (Bool,
                               ([(Term a b, Term a b)],
                                 ([(Term a b, Term a b)],
                                   Rbt (a, Nat)
                                     [(Bool, (Term a b, Term a b))]))))) ->
                           Term a b -> Bool;
is_QNF_impl (uu, (q, uv)) = nF_terms_list q;

is_QNF ::
  forall a b.
    (Eq a, Key a, Corder b, Eq b, Key b,
      Mapping_impl b) => Tp a b -> Term a b -> Bool;
is_QNF tp = is_QNF_impl (impl_ofc tp);

rulesa :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
rulesa tp = rules_impl (impl_ofc tp);

nfs_impl ::
  forall a b.
    (Linorder a) => (Bool,
                      ([Term a b],
                        (Bool,
                          ([(Term a b, Term a b)],
                            ([(Term a b, Term a b)],
                              Rbt (a, Nat)
                                [(Bool, (Term a b, Term a b))]))))) ->
                      Bool;
nfs_impl (nfs, uu) = nfs;

nfs :: forall a b. (Key a, Key b) => Tp a b -> Bool;
nfs tp = nfs_impl (impl_ofc tp);

mk_impl ::
  forall a b.
    (Eq a, Linorder a, Corder b, Eq b,
      Mapping_impl b) => Bool ->
                           [Term a b] ->
                             [(Term a b, Term a b)] ->
                               [(Term a b, Term a b)] ->
                                 (Bool,
                                   ([Term a b],
                                     (Bool,
                                       ([(Term a b, Term a b)],
 ([(Term a b, Term a b)], Rbt (a, Nat) [(Bool, (Term a b, Term a b))])))));
mk_impl nfs q r rw =
  let {
    (vr, ra) = partition (is_Var . fst) r;
    (vrw, rwa) = partition (is_Var . fst) rw;
  } in (nfs, (q, (nF_subset (map fst (r ++ rw)) q,
                   (vr, (vrw, insert_rules True ra
                                (insert_rules False rwa empty))))));

mk :: forall a b.
        (Eq a, Key a, Corder b, Eq b, Key b,
          Mapping_impl b) => Bool ->
                               [Term a b] ->
                                 [(Term a b, Term a b)] ->
                                   [(Term a b, Term a b)] -> Tp a b;
mk nfs q r rw = TP (mk_impl nfs q r rw);

rw_impl ::
  forall a b.
    (Linorder a) => (Bool,
                      ([Term a b],
                        (Bool,
                          ([(Term a b, Term a b)],
                            ([(Term a b, Term a b)],
                              Rbt (a, Nat)
                                [(Bool, (Term a b, Term a b))]))))) ->
                      [(Term a b, Term a b)];
rw_impl (uu, (uv, (uw, (ux, (vRw, m))))) = vRw ++ rules_with not m;

rw :: forall a b. (Key a, Key b) => Tp a b -> [(Term a b, Term a b)];
rw tp = rw_impl (impl_ofc tp);

tp_rbt_impl ::
  forall a b.
    (Eq a, Key a, Corder b, Eq b, Key b,
      Mapping_impl b) => Tp_ops_ext (Tp a b) a b ();
tp_rbt_impl =
  Tp_ops_ext qreltrs q r rw rulesa q_empty is_QNF nFQ_subset_NF_rules rules_map
    delete_R_Rw split_rules mk nfs ();

string_reversal_complete_rel_tt ::
  forall a b c d.
    (Showa b,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_complete_rel_tt i tp =
  bindb (check (q_emptyb i tp)
          (shows_prec_list Zero_nat
            ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't',
              'y']))
    (\ _ ->
      bindb (check_unary_signature (rulesc i tp))
        (\ _ ->
          Inr (mkb i default_nfs_nt_trs [] (map rev_rule (rb i tp))
                (map rev_rule (rwb i tp)))));

check_to_srs_complete ::
  forall a b.
    (Eq a, Showa a, Default b, Eq b,
      Showa b) => [(a, a)] ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_to_srs_complete old_new r s =
  let {
    mu = funas_trs_list r;
    (d, (da, nu)) = extract_components mu old_new;
  } in bindb (check_components mu (d, (da, nu)))
         (\ _ ->
           bindb (check_varcond_subset s)
             (\ _ ->
               catcha
                 (forallM
                   (\ slr ->
                     let {
                       y = choose_var defaulta (fst slr);
                       stra = str d y;
                       to_slr = (\ (l, ra) -> (stra l, stra ra));
                     } in check (any (\ lr -> to_slr lr == slr) r)
                            (shows_prec_list Zero_nat
                               ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't',
                                 ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l',
                                 ' ', 'r', 'u', 'l', 'e', ' ', 'f', 'o', 'r',
                                 ' '] .
                              shows_rule (shows_prec Zero_nat)
                                (shows_prec Zero_nat) [' ', '-', '>', ' '] slr))
                   s)
                 (\ x -> Inl (snd x))));

const_to_string_complete_tt ::
  forall a b c d.
    (Eq b, Showa b, Default c, Eq c,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Const_string_complete_proof b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
const_to_string_complete_tt i tp (Const_string_complete_proof old_new s) =
  bindb (check (q_emptyb i tp)
          (shows_prec_list Zero_nat
            ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't',
              'y']))
    (\ _ ->
      bindb (check_to_srs_complete old_new (rulesc i tp) s)
        (\ _ -> Inr (mkb i False [] s [])));

switch_termination_proc ::
  forall a b.
    (Eq b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_termination_proc i joins_i dpp =
  let {
    p = pairsa i dpp;
    r = rulesd i dpp;
    q = qc i dpp;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catcha
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list Zero_nat
                                  ['r', 'u', 'l', 'e', 's', ' ', 'a', 'r', 'e',
                                    ' ', 'n', 'o', 't', ' ', 'o', 'v', 'e', 'r',
                                    'l', 'a', 'y']))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_wf_trs r)
                        (\ _ ->
                          bindb (check_critical_pairs r cp joins_i)
                            (\ _ ->
                              bindb (check (null (critical_pairs_impl p r))
                                      (shows_prec_list Zero_nat
['t', 'h', 'e', 'r', 'e', ' ', 'a', 'r', 'e', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
  'p', 's', ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', 'P', ' ', 'a', 'n',
  'd', ' ', 'R']))
                                (\ _ ->
                                  catcha (check_NF_terms_subset (map fst r) q)
                                    (\ x ->
                                      Inl
(shows_prec_term Zero_nat x .
  shows_prec_list Zero_nat
    [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm',
      'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ', 'w', '.', 'r', '.', 't', '.', ' ',
      'R']))))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkc i (nfsc i dpp) False p [] [] [] r);
       });

check_instance ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_instance pa p =
  catcha
    (forallM
      (\ st ->
        check (any (instance_rule st) pa)
          (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
             [' ', '-', '>', ' '] st .
            shows_prec_list Zero_nat
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'i', 'n',
                's', 't', 'a', 'n', 'c', 'e', ' ', 'o', 'f', ' ', 'a', 'n', 'y',
                ' ', 'o', 'r', 'i', 'g', 'i', 'n', 'a', 'l', ' ', 'p', 'a', 'i',
                'r']))
      p)
    (\ x -> Inl (snd x));

instantiation_complete_proc ::
  forall a b c d.
    (Eq b, Showa b, Corder c, Eq c, Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Instantiation_complete_proc_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
instantiation_complete_proc i dpp (Instantiation_complete_proc_prf p) =
  let {
    pa = pairsa i dpp;
    q = qc i dpp;
    r = rulesd i dpp;
    nfs = nfsc i dpp;
  } in bindb (check (not nfs || null q)
               (shows_prec_list Zero_nat
                 ['n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ',
                   's', 'u', 'b', 's', 't', '.', ' ', 'c', 'u', 'r', 'r', 'e',
                   'n', 't', 'l', 'y', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p',
                   'p', 'o', 'r', 't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'i',
                   'n', 'n', 'e', 'r', 'm', 'o', 's', 't']))
         (\ _ ->
           bindb (check_instance pa p)
             (\ _ -> Inr (mkc i nfs False p [] q [] r)));

rule_removal_nonterm_dp ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Dpp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_dp_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_dp i dpp (Rule_removal_nonterm_dp_prf p r) =
  let {
    prm = (if is_none p then [] else ceta_list_diff (pairsa i dpp) (the p));
    rrm = (if is_none r then [] else ceta_list_diff (rulesd i dpp) (the r));
  } in Inr (delete_R_Rwc i (delete_P_Pwa i dpp prm prm) rrm rrm);

mk_rel_tp ::
  forall a b c d.
    Tp_ops_ext a b c d ->
      (Bool, ([Term b c], ([(Term b c, Term b c)], [(Term b c, Term b c)]))) ->
        a;
mk_rel_tp i (nfs, (q, (r, rw))) = mkb i nfs q r rw;

mk_dppa ::
  forall a b c d.
    Dpp_ops_ext a b c d ->
      (Bool,
        (Bool,
          ([(Term b c, Term b c)],
            ([(Term b c, Term b c)],
              ([Term b c],
                ([(Term b c, Term b c)], [(Term b c, Term b c)])))))) ->
        a;
mk_dppa i (nfs, (m, (p, (pw, (q, (r, rw)))))) = mkc i nfs m p pw q r rw;

check_assma ::
  forall a b c d e f g h i.
    (Key b, Showa b, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      (a -> e -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                        (d -> f -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          (a -> g -> Sum ([Prelude.Char] -> [Prelude.Char])
                                       ()) ->
                            (([(Ctxt (Lab b c) [Prelude.Char],
                                 (Term (Lab b c) [Prelude.Char], Location))],
                               [(Term (Lab b c) [Prelude.Char],
                                  Term (Lab b c) [Prelude.Char])]) ->
                              h -> Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                              ([Prelude.Char] ->
                                i -> Sum ([Prelude.Char] -> [Prelude.Char])
                                       ()) ->
                                Generic_assm_proof b c [Prelude.Char] e f g h
                                  i ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_assma i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_SN_assm_proof t prf) = tp_check (mk_tpa i t) prf;
check_assma i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_RelSN_assm_proof t prf) = rtp_check (mk_rel_tp i t) prf;
check_assma i j tp_check dp_check rtp_check fptp_check unk_check
  (Infinite_assm_proof t prf) = dp_check (mk_dppa j t) prf;
check_assma i j tp_check dp_check rtp_check fptp_check unk_check
  (Not_SN_FP_assm_proof t prf) = fptp_check t prf;
check_assma i j tp_check dp_check rtp_check fptp_check unk_check
  (Unknown_assm_proof t prf) = unk_check t prf;
check_assma i j uu uv uw ux uy (SN_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assma i j uu uv uw ux uy (Finite_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);
check_assma i j uu uv uw ux uy (SN_FP_assm_proof v va) =
  Inl (shows_prec_list Zero_nat
        ['n', 'o', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', ' ', 'f', 'o', 'r',
          ' ', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
          's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ',
          'n', 'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o',
          'n', ' ', 'p', 'r', 'o', 'o', 'f']);

q_increase_nonterm_dp ::
  forall a b c.
    (Eq b,
      Eq c) => Dpp_ops_ext a b c () ->
                 a -> Q_increase_nonterm_dp_prf b c ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_increase_nonterm_dp i dpp (Q_increase_nonterm_dp_prf q) =
  let {
    p = pairsa i dpp;
    r = rulesd i dpp;
    qa = qc i dpp;
    nfs = nfsc i dpp;
  } in Inr (mkc i nfs False p [] (list_union qa q) [] r);

dp_q_reduction_nonterm ::
  forall a b c d.
    (Cenum b, Ceq b, Corder b, Eq b, Set_impl b, Showa b, Corder c, Eq c,
      Mapping_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Dp_q_reduction_nonterm_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
dp_q_reduction_nonterm i dpp (DP_q_reduction_nonterm_prf q) =
  let {
    p = pairsa i dpp;
    r = rulesd i dpp;
    qa = qc i dpp;
    nfs = nfsc i dpp;
    f = set (funas_trs_list (p ++ r));
    rQ = filter (\ qb -> less_eq_set (funas_term qb) f) qa;
  } in bindb (catcha (check_NF_terms_subset q rQ)
               (\ x ->
                 Inl (shows_prec_list Zero_nat
                        ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                       shows_prec_term Zero_nat x .
                         shows_prec_list Zero_nat
                           [' ', 'i', 's', ' ', 'm', 'i', 's', 's', 'i', 'n',
                             'g', ' ', 'i', 'n', ' ', 'Q', '\'', ' '])))
         (\ _ -> Inr (mkc i nfs False p [] q [] r));

shows_rulea ::
  forall a b. (Showa a, Showa b) => (a, b) -> [Prelude.Char] -> [Prelude.Char];
shows_rulea (l, r) =
  shows_prec Zero_nat l .
    shows_prec_list Zero_nat [' ', '-', '>', ' '] . shows_prec Zero_nat r;

check_dpp_subsumesa ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Dpp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      (Bool,
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          ([(Term (Lab b c) [Prelude.Char],
                              Term (Lab b c) [Prelude.Char])],
                            ([Term (Lab b c) [Prelude.Char]],
                              ([(Term (Lab b c) [Prelude.Char],
                                  Term (Lab b c) [Prelude.Char])],
                                [(Term (Lab b c) [Prelude.Char],
                                   Term (Lab b c) [Prelude.Char])])))))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dpp_subsumesa j dp dpp =
  let {
    (nfsa, (_, (p, (pw, (q, (r, rw)))))) = dp;
    pairsaa = p ++ pw;
    rulesa = r ++ rw;
    nfs = nfsc j dpp;
    pairs = pairsa j dpp;
    rules = rulesd j dpp;
    qa = qc j dpp;
  } in catcha
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list Zero_nat
               ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ',
                 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
                 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm', 'a', 'l', '-',
                 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a', 'g', 's']))
           (\ _ ->
             bindb (catcha (check_subseteq pairsaa pairs)
                     (\ x ->
                       Inl (toomuch ['p', 'a', 'i', 'r'] (shows_rulea x))))
               (\ _ ->
                 bindb (catcha (check_subseteq rulesa rules)
                         (\ x ->
                           Inl (toomuch ['r', 'u', 'l', 'e'] (shows_rulea x))))
                   (\ _ ->
                     catcha (check_NF_terms_subset q qa)
                       (\ x ->
                         Inl (shows_prec_list Zero_nat
                                ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f',
                                  'f', 'e', 'r', 's', ' ', 'd', 'u', 'e', ' ',
                                  't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
                               shows_term (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) x))))))
         (\ x ->
           Inl (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 's', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

rewriting_complete_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Rewriting_complete_proc_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rewriting_complete_proc i (Rewriting_complete_proc_prf u_opt stb sta st lr p)
  dpp =
  (case catcha
          (let {
             s = fst stb;
             t = snd stb;
             ta = snd sta;
             r = rulesd i dpp;
           } in bindb (check_rstep r p lr t ta)
                  (\ _ ->
                    bindb (check (nFQ_subset_NF_rulesb i dpp)
                            (shows_prec_list Zero_nat
                              ['i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't', ' ',
                                'r', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g',
                                ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd']))
                      (\ _ ->
                        bindb (check_rewrite_common_preconditions i u_opt stb
                                (args s) (args (subt_at t p)) ta lr p False dpp)
                          (\ _ ->
                            bindb (check (not (is_Var s))
                                    (shows_prec_list Zero_nat
                                      ['l', 'h', 's', ' ', 'o', 'f', ' ', 'p',
'a', 'i', 'r', ' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ',
'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e']))
                              (\ _ ->
                                bindb (check (eq_rule_mod_vars sta st)
(shows_prec_list Zero_nat ['t', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' '] .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
    [' ', '-', '>', ' '] sta .
    shows_prec_list Zero_nat
      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r', 'e', 'n', 'a',
        'm', 'e', 'd', ' ', 'v', 'a', 'r', 'i', 'a', 'n', 't', ' ', 'o', 'f',
        ' '] .
      shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
        [' ', '-', '>', ' '] st))
                                  (\ _ ->
                                    bindb (check (equal_term s (fst sta))
    (shows_prec_list Zero_nat
      ['l', 'e', 'f', 't', '-', 'h', 'a', 'n', 'd', ' ', 's', 'i', 'd', 'e',
        's', ' ', 'o', 'f', ' ', 'o', 'l', 'd', ' ', 'a', 'n', 'd', ' ', 'n',
        'e', 'w', ' ', 'p', 'a', 'i', 'r', ' ', 'd', 'i', 'f', 'f', 'e', 'r']))
                                      (\ _ ->
let {
  q = qc i dpp;
  inn = isOK (check_NF_terms_subset (map fst r) q);
} in bindb (check_nfc inn r q (args s) (nfsc i dpp) (subt_at t p))
       (\ _ ->
         bindb (catcha
                 (forallM
                   (\ (l, _) ->
                     check (not (is_Var l))
                       (shows_prec_list Zero_nat
                         ['l', 'h', 's', 's', ' ', 'm', 'u', 's', 't', ' ', 'n',
                           'o', 't', ' ', 'b', 'e', ' ', 'v', 'a', 'r', 'i',
                           'a', 'b', 'l', 'e', 's']))
                   r)
                 (\ x -> Inl (snd x)))
           (\ _ ->
             (if not (is_Var t)
               then check (not (not (null (rules_mapb i dpp (the (root t))))))
                      (shows_prec_list Zero_nat
                         ['r', 'o', 'o', 't', ' ', 'o', 'f', ' '] .
                        shows_prec_term Zero_nat t .
                          shows_prec_list Zero_nat
                            [' ', 'm', 'u', 's', 't', ' ', 'n', 'o', 't', ' ',
                              'b', 'e', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd'])
               else Inr ()))))))))))
          (\ x ->
            Inl (shows_string
                   ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'r',
                     'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 't', 'h', 'e',
                     ' ', 'p', 'a', 'i', 'r', ' '] .
                  shows_nl .
                    shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                      [' ', '-', '>', ' '] stb .
                      shows_nl .
                        shows_string
                          [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                            'i', 'r', ' '] .
                          shows_nl .
                            shows_rule (shows_prec Zero_nat)
                              (shows_prec_list Zero_nat) [' ', '-', '>', ' ']
                              st .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp stb [st]);
  });

less_eq_pos :: Pos -> Pos -> Bool;
less_eq_pos (PCons i q1) (PCons j q2) = equal_nat i j && less_eq_pos q1 q2;
less_eq_pos (PCons i q1) Empty = False;
less_eq_pos Empty p = True;

rstep_enum_impl ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           Term a b ->
                             Term a b ->
                               Pos ->
                                 [((Term a b, Term a b), (b -> Term a b, Pos))];
rstep_enum_impl r ta t p =
  concat
    (map_filter
      (\ x ->
        (if less_eq_pos p x
          then Just (let {
                       tp = subt_at ta x;
                     } in (if membera (poss_list t) x
                            then (if equal_ctxt (ctxt_of_pos_term x ta)
                                       (ctxt_of_pos_term x t)
                                   then concatMap
  (\ tpa ->
    concatMap
      (\ (l, ra) ->
        map (\ mu -> ((l, ra), (mu, x)))
          (option_to_list (match_list Var [(l, tp), (ra, tpa)])))
      r)
  [subt_at t x]
                                   else [])
                            else []))
          else Nothing))
      (poss_list ta));

narrow_enum_impl ::
  forall a b.
    (Eq a, Corder b, Eq b,
      Mapping_impl b) => [(Term a b, Term a b)] ->
                           (Term a b, Term a b) ->
                             (Term a b, Term a b) ->
                               Pos ->
                                 [(b -> Term a b,
                                    ((Term a b, Term a b),
                                      (Pos, b -> Term a b)))];
narrow_enum_impl r sta st p =
  let {
    (s, t) = sta;
    (sa, ta) = st;
  } in concatMap
         (\ mu ->
           concatMap (\ (lr, (tau, q)) -> [(mu, (lr, (q, tau)))])
             (rstep_enum_impl r (subst_apply_term t mu) ta p))
         (option_to_list (match sa s));

check_narrow ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Bool ->
                    Dpp_ops_ext a b [Prelude.Char] () ->
                      a -> [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                             [Term b [Prelude.Char]] ->
                               Bool ->
                                 (Term b [Prelude.Char],
                                   Term b [Prelude.Char]) ->
                                   (Term b [Prelude.Char],
                                     Term b [Prelude.Char]) ->
                                     ([Prelude.Char] -> Term b [Prelude.Char],
                                       ((Term b [Prelude.Char],
  Term b [Prelude.Char]),
 (Pos, [Prelude.Char] -> Term b [Prelude.Char]))) ->
                                       Sum ([Prelude.Char] -> [Prelude.Char])
 ();
check_narrow inn i dpp r q nfs sta st quad =
  let {
    ((_, t), ((s, ta), (mu, (lr, (p, _))))) = (sta, (st, quad));
  } in bindb (check_nfc inn r q (args s) nfs
               (subt_at (subst_apply_term t mu) p))
         (\ _ ->
           check_rewrite_common_preconditions i Nothing
             (s, subst_apply_term t mu) (args s)
             (args (subt_at (subst_apply_term t mu) p)) ta lr p False dpp);

narrowing_complete_proc ::
  forall a b.
    (Eq b, Key b,
      Showa b) => Dpp_ops_ext a b [Prelude.Char] () ->
                    Narrowing_complete_proc_prf b [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
narrowing_complete_proc i (Narrowing_complete_proc_prf st p sts) dpp =
  (case catcha
          (let {
             (s, t) = st;
             q = qc i dpp;
             nfs = nfsc i dpp;
             rules = rulesd i dpp;
             check_ndef =
               check_no_defined_root (\ fn -> not (null (rules_mapb i dpp fn)));
             inn = isOK (check_NF_terms_subset (map fst rules) q);
             cnarrow = check_narrow inn i dpp rules q nfs st;
           } in bindb (check (null q || nFQ_subset_NF_rulesb i dpp)
                        (shows_prec_list Zero_nat
                          ['f', 'u', 'l', 'l', ' ', 'o', 'r', ' ', 'i', 'n',
                            'n', 'e', 'r', 'm', 'o', 's', 't', ' ', 'r', 'e',
                            'w', 'r', 'i', 't', 'i', 'n', 'g', ' ', 'r', 'e',
                            'q', 'u', 'i', 'r', 'e', 'd']))
                  (\ _ ->
                    bindb (if null q then Inr ()
                            else bindb (check_no_var s)
                                   (\ _ ->
                                     bindb (check_no_var t)
                                       (\ _ ->
 bindb (check_ndef t)
   (\ _ ->
     (if nfs
       then bindb (catcha (forallM (\ (l, _) -> check_no_var l) rules)
                    (\ x -> Inl (snd x)))
              (\ _ ->
                check (wf_rule (s, t))
                  (shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                     [' ', '-', '>', ' '] (s, t) .
                    shows_prec_list Zero_nat
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'w', 'e', 'l',
                        'l', ' ', 'f', 'o', 'r', 'm', 'e', 'd']))
       else Inr ())))))
                      (\ _ ->
                        catcha
                          (forallM
                            (\ sta ->
                              let {
                                quads = narrow_enum_impl rules st sta p;
                              } in catcha
                                     (existsM
                                       (\ quad ->
 catcha
   (check (null q)
     (shows_prec_list Zero_nat
       ['q', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't', 'y']))
   (\ _ -> cnarrow sta quad))
                                       quads)
                                     (\ x ->
                                       Inl
 (shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
    [' ', '-', '>', ' '] sta .
   shows_prec_list Zero_nat
     (case quads of {
       [] -> [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 's', 'e', 'e',
               'm', ' ', 't', 'o', ' ', 'b', 'e', ' ', 'n', 'a', 'r', 'r', 'o',
               'w', 'e', 'd', ' ', 'p', 'a', 'i', 'r'];
       _ : _ ->
         [' ', 'v', 'i', 'o', 'l', 'a', 't', 'e', 's', ' ', 's', 'i', 'd', 'e',
           ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's', ' ', 'f', 'o',
           'r', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'e', 'n', 'e', 's',
           's'];
     }) .
     shows_concat x)))
                            sts)
                          (\ x -> Inl (snd x)))))
          (\ x ->
            Inl (shows_string
                   ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 'n',
                     'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g', ' '] .
                  shows_nl .
                    shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
                      [' ', '-', '>', ' '] st .
                      shows_nl .
                        shows_string
                          [' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'p', 'a',
                            'i', 'r', 's', ' '] .
                          shows_nl .
                            shows_trs (shows_prec Zero_nat)
                              (shows_prec_list Zero_nat)
                              ['r', 'e', 'w', 'r', 'i', 't', 'e', ' ', 's', 'y',
                                's', 't', 'e', 'm', ':']
                              [' ', '-', '>', ' '] sts .
                              shows_nl . x))
    of {
    Inl a -> Inl a;
    Inr _ -> Inr (replace_paira i dpp st sts);
  });

inverse_var_renaming_impl ::
  forall a b. (Eq a, Eq b) => [(a, Term b a)] -> [(a, Term b a)];
inverse_var_renaming_impl sigma =
  let {
    a = mk_subst_domain sigma;
  } in map (\ (x, y) -> (the_Var y, Var x)) a;

vars_pat_term_impl ::
  forall a b.
    (Eq a, Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) -> [b];
vars_pat_term_impl p =
  let {
    (s, (sigma, mu)) = p;
  } in remdups
         (vars_term_list s ++ vars_subst_impl sigma ++ vars_subst_impl mu);

var_renaming_impl :: forall a b. (Eq a, Eq b) => [(a, Term b a)] -> Bool;
var_renaming_impl sigma =
  let {
    sigmaa = map snd (mk_subst_domain sigma);
  } in all is_Var sigmaa && distinct sigmaa;

pat_dom_renaming_impl ::
  forall a b.
    (Eq a,
      Eq b) => (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                 [(b, Term a b)] -> Bool;
pat_dom_renaming_impl p rho =
  let {
    rhoa = mk_subst_domain rho;
    xs = map Var (vars_pat_term_impl p);
  } in var_renaming_impl rho &&
         all (membera (pat_dv_impl p)) (map fst rhoa) &&
           all (\ t -> not (membera xs t)) (map snd rhoa);

check_pat_eqv_prf ::
  forall a b.
    (Eq a, Linorder a, Showa a, Cenum b, Ceq b, Corder b, Eq b, Linorder b,
      Set_impl b,
      Showa b) => Pat_eqv_prf a b ->
                    (Term a b, ([(b, Term a b)], [(b, Term a b)])) ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Term a b, ([(b, Term a b)], [(b, Term a b)]));
check_pat_eqv_prf (Pat_Irrelevant sigmaa mua) (t, (sigma, mu)) =
  let {
    w = w_impl (mk_subst_domain sigma) t;
    sig = mk_subst Var sigma;
    siga = mk_subst Var sigmaa;
    mub = mk_subst Var mu;
    muba = mk_subst Var mua;
  } in bindb (catcha
               (catcha
                 (forallM
                   (\ x ->
                     bindb (check (equal_term (sig x) (siga x))
                             (x, (sig x,
                                   (siga x,
                                     ['p', 'u', 'm', 'p', 'i', 'n', 'g']))))
                       (\ _ ->
                         check (equal_term (mub x) (muba x))
                           (x, (mub x,
                                 (muba x,
                                   ['c', 'l', 'o', 's', 'i', 'n', 'g'])))))
                   w)
                 (\ x -> Inl (snd x)))
               (\ x ->
                 Inl (let {
                        (xa, (tb, (ta, sub))) = x;
                      } in shows_string
                             ['e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'e',
                               'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e',
                               ' ', '(', 'i', 'r', 'r', 'e', 'l', 'e', 'v', 'a',
                               'n', 't', ')', ':', ' ', 'f', 'o', 'r', ' ', 'v',
                               'a', 'r', 'i', 'a', 'b', 'l', 'e', ' '] .
                             shows_prec Zero_nat xa .
                               shows_string
                                 [' ', 'o', 'b', 't', 'a', 'i', 'n', ' ', 'd',
                                   'i', 'f', 'f', 'e', 'r', 'e', 'n', 't', ' ',
                                   'v', 'a', 'l', 'u', 'e', 's', ' ', 'f', 'o',
                                   'r', ' '] .
                                 shows_prec_list Zero_nat sub .
                                   shows_string
                                     [' ', 's', 'u', 'b', 's', 't', 'i', 't',
                                       'u', 't', 'i', 'o', 'n', ':', ' '] .
                                     shows_prec_term Zero_nat tb .
                                       shows_string [' ', '!', '=', ' '] .
 shows_prec_term Zero_nat ta)))
         (\ _ -> Inr (t, (sigmaa, mua)));
check_pat_eqv_prf (Pat_Simplify mu_1 mu_2) (t, (sigma, mu)) =
  bindb (check (subst_eq mu (subst_compose_impl mu_1 mu_2))
          (shows_prec_list Zero_nat
            ['m', 'u', ' ', '!', '=', ' ', 'm', 'u', '1', ' ', 'm', 'u', '2']))
    (\ _ ->
      bindb (check (commutes_impl mu_1 sigma)
              (shows_prec_list Zero_nat
                ['s', 'i', 'g', 'm', 'a', ' ', 'a', 'n', 'd', ' ', 'm', 'u',
                  '1', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm',
                  'm', 'u', 't', 'e']))
        (\ _ -> Inr (subst_apply_term t (mk_subst Var mu_1), (sigma, mu_2))));
check_pat_eqv_prf (Pat_Dom_Renaming rho) (t, (sigma, mu)) =
  bindb (check (pat_dom_renaming_impl (t, (sigma, mu)) rho)
          (shows_prec_list Zero_nat
            ['r', 'h', 'o', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ',
              'd', 'o', 'm', 'a', 'i', 'n', ' ', 'r', 'e', 'n', 'a', 'm', 'i',
              'n', 'g', ' ', 'f', 'o', 'r', ' ', 'p']))
    (\ _ ->
      let {
        i_rho = inverse_var_renaming_impl rho;
        sigmaa =
          mk_subst_case
            (map (the_Var . mk_subst Var rho) (map fst (mk_subst_domain sigma)))
            (\ x ->
              subst_apply_term
                (subst_apply_term
                  (subst_apply_term (Var x) (mk_subst Var i_rho))
                  (mk_subst Var sigma))
                (mk_subst Var rho))
            [];
        mua = mk_subst_case
                (map (the_Var . mk_subst Var rho)
                  (map fst (mk_subst_domain mu)))
                (\ x ->
                  subst_apply_term
                    (subst_apply_term (Var x) (mk_subst Var i_rho))
                    (mk_subst Var mu))
                i_rho;
      } in Inr (subst_apply_term t (mk_subst Var rho), (sigmaa, mua)));

subst_compose_impla ::
  forall a b.
    (Eq a, Eq b) => [(a, Term b a)] -> (a -> Term b a) -> [(a, Term b a)];
subst_compose_impla sigma rho =
  map (\ (x, s) -> (x, subst_apply_term s rho)) (mk_subst_domain sigma);

subst_replace_impl ::
  forall a b. (Eq a) => [(a, Term b a)] -> a -> Term b a -> [(a, Term b a)];
subst_replace_impl sigma x t = (x, t) : filter (\ (y, _) -> not (y == x)) sigma;

check_pat_rule_prf ::
  forall a b.
    (Eq a, Linorder a, Showa a, Cenum b, Ceq b, Corder b, Eq b, Mapping_impl b,
      Linorder b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Pat_rule_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char])
                          ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                            ((Term a b, ([(b, Term a b)], [(b, Term a b)])),
                              Bool));
check_pat_rule_prf ra p (Pat_OrigRule (l, r) isPair) =
  (if isPair
    then bindb (check (membera p (l, r))
                 (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                    [' ', '-', '>', ' '] (l, r) .
                   shows_prec_list Zero_nat
                     [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p',
                       'a', 'i', 'r']))
           (\ _ -> Inr ((l, ([], [])), ((r, ([], [])), isPair)))
    else bindb (check (membera ra (l, r))
                 (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                    [' ', '-', '>', ' '] (l, r) .
                   shows_prec_list Zero_nat
                     [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'r',
                       'u', 'l', 'e']))
           (\ _ -> Inr ((l, ([], [])), ((r, ([], [])), isPair))));
check_pat_rule_prf r p (Pat_InitPump pat sigma theta) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sig, tau)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (siga, taua)) = aa;
             } in (\ bb ->
                    catcha
                      (bindb
                        (check (null (sig ++ tau ++ siga ++ taua))
                          (shows_prec_list Zero_nat
                            ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i',
                              'o', 'n', 's', ' ', 'm', 'u', 's', 't', ' ', 'b',
                              'e', ' ', 'e', 'm', 'p', 't', 'y']))
                        (\ _ ->
                          bindb (check
                                  (equal_term
                                    (subst_apply_term s (mk_subst Var theta))
                                    (subst_apply_term t (mk_subst Var sigma)))
                                  (shows_prec_list Zero_nat
                                    ['s', ' ', 't', 'h', 'e', 't', 'a', ' ',
                                      '!', '=', ' ', 't', ' ', 's', 'i', 'g',
                                      'm', 'a']))
                            (\ _ ->
                              bindb (check (commutes_impl theta sigma)
                                      (shows_prec_list Zero_nat
['s', 'i', 'g', 'm', 'a', ' ', 'a', 'n', 'd', ' ', 't', 'h', 'e', 't', 'a', ' ',
  'd', 'o', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm', 'm', 'u', 't', 'e']))
                                (\ _ ->
                                  Inr ((s, (sigma, [])),
((t, (theta, [])), bb))))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list Zero_nat
                                ['i', 'n', 'i', 't', 'i', 'a', 'l', ' ', 'p',
                                  'u', 'm', 'p', 'i', 'n', 'g'] .
                                shows_prec_list Zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sig, tau)),
((t, (siga, taua)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r pa (Pat_InitPumpCtxt pat sigma p z) =
  bindb (check_pat_rule_prf r pa pat)
    (\ (a, b) ->
      let {
        (s, (sig, tau)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (siga, taua)) = aa;
             } in (\ bb ->
                    catcha
                      (bindb
                        (check (not bb)
                          (shows_prec_list Zero_nat
                            ['p', 'a', 'i', 'r', 's', ' ', 'n', 'o', 't', ' ',
                              'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'i', 'n',
                              ' ', 'i', 'n', 'i', 't', ' ', 'p', 'u', 'm', 'p',
                              ' ', 'c', 't', 'x', 't']))
                        (\ _ ->
                          bindb (check (null (sig ++ tau ++ siga ++ taua))
                                  (shows_prec_list Zero_nat
                                    ['s', 'u', 'b', 's', 't', 'i', 't', 'u',
                                      't', 'i', 'o', 'n', 's', ' ', 'm', 'u',
                                      's', 't', ' ', 'b', 'e', ' ', 'e', 'm',
                                      'p', 't', 'y']))
                            (\ _ ->
                              bindb (check (in_poss p t)
                                      (shows_prec_list Zero_nat
['p', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'v', 'a', 'l', 'i', 'd',
  ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n']))
                                (\ _ ->
                                  bindb (check
  (equal_term s (subst_apply_term (subt_at t p) (mk_subst Var sigma)))
  (shows_prec_list Zero_nat
    ['s', ' ', '!', '=', ' ', 't', ' ', '|', '_', ' ', 'p', ' ', 's', 'i', 'g',
      'm', 'a']))
                                    (\ _ ->
                                      bindb
(check
  (not (membera (vars_term_list s ++ vars_term_list t ++ vars_subst_impl sigma)
         z))
  (shows_prec_list Zero_nat
    ['z', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'f', 'r', 'e', 's', 'h']))
(\ _ ->
  let {
    tz = ctxt_apply (ctxt_of_pos_term p t) (Var z);
  } in Inr ((s, (sigma, [])),
             ((tz, ((z, tz) : sigma, [(z, subt_at t p)])), bb))))))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list Zero_nat
                                ['i', 'n', 'i', 't', 'i', 'a', 'l', ' ', 'p',
                                  'u', 'm', 'p', 'i', 'n', 'g', ' ', '(', 'w',
                                  'i', 't', 'h', ' ', 'c', 't', 'x', 't', ')',
                                  ' '] .
                                shows_prec_list Zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sig, tau)),
((t, (siga, taua)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Equiv pat left eqv) =
  bindb (check_pat_rule_prf r p pat)
    (\ (pleft, (pright, b)) ->
      catcha
        (bindb (check_pat_eqv_prf eqv (if left then pleft else pright))
          (\ pnew ->
            Inr (if left then (pnew, (pright, b)) else (pleft, (pnew, b)))))
        (\ x ->
          Inl (shows_prec_list Zero_nat
                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h',
                   ' '] .
                shows_prec_list Zero_nat
                  ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'e', 'q', 'u', 'i',
                    'v', 'a', 'l', 'e', 'n', 'c', 'e'] .
                  shows_prec_list Zero_nat
                    [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e', 'r', 'i', 'v',
                      'i', 'n', 'g', ' ', 'c', 'o', 'r', 'r', 'e', 'c', 't',
                      ' ', 'p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r', 'u',
                      'l', 'e', ' '] .
                    shows_nl . show_pat_rule (pleft, (pright, b)) . x)));
check_pat_rule_prf r pa (Pat_Narrow pat1 pat2 p) =
  bindb (check_pat_rule_prf r pa pat1)
    (\ (a, b) ->
      let {
        (s, (sigma, mu)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sig, mua)) = aa;
             } in (\ b1 ->
                    bindb (check_pat_rule_prf r pa pat2)
                      (\ (ab, bb) ->
                        let {
                          (u, (sig1, mu1)) = ab;
                        } in (\ (ac, bc) ->
                               let {
                                 (v, (sig2, mu2)) = ac;
                               } in (\ b2 ->
                                      catcha
(bindb
  (check
    (subst_eq sig sigma &&
      subst_eq sig1 sigma &&
        subst_eq sig2 sigma &&
          subst_eq mua mu && subst_eq mu1 mu && subst_eq mu2 mu)
    (shows_prec_list Zero_nat
      ['s', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n', 's', ' ',
        'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i',
        'c', 'a', 'l']))
  (\ _ ->
    bindb (check (in_poss p t)
            (shows_prec_list Zero_nat
              ['p', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'v', 'a',
                'l', 'i', 'd', ' ', 'p', 'o', 's', 'i', 't', 'i', 'o', 'n']))
      (\ _ ->
        bindb (check (equal_term (subt_at t p) u)
                (shows_prec_list Zero_nat
                  ['t', ' ', '|', '_', ' ', 'p', ' ', '!', '=', ' ', 'u']))
          (\ _ ->
            bindb (check (if b2 then equal_pos p Empty else True)
                    (shows_prec_list Zero_nat
                      ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', ' ',
                        'P', ' ', 's', 't', 'e', 'p', ',', ' ', 's', 'o', ' ',
                        'p', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'e',
                        'p', 's', 'i', 'l', 'o', 'n']))
              (\ _ ->
                Inr ((s, (sigma, mu)),
                      ((ctxt_apply (ctxt_of_pos_term p t) v, (sigma, mu)),
                        b1 || b2)))))))
(\ x ->
  Inl (shows_prec_list Zero_nat
         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' '] .
        shows_prec_list Zero_nat
          ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'n', 'a', 'r', 'r', 'o', 'w',
            'i', 'n', 'g'] .
          shows_prec_list Zero_nat
            [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e', 'r', 'i', 'v', 'i',
              'n', 'g', ' ', 'c', 'o', 'r', 'r', 'e', 'c', 't', ' ', 'p', 'a',
              't', 't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e', 's', ' '] .
            shows_nl .
              show_pat_rule ((s, (sigma, mu)), ((t, (sig, mua)), b1)) .
                shows_nl .
                  shows_prec_list Zero_nat [' ', 'a', 'n', 'd', ' '] .
                    shows_nl .
                      show_pat_rule ((u, (sig1, mu1)), ((v, (sig2, mu2)), b2)) .
                        x)))
                                 bc)
                          bb))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Base) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catcha
                      (let {
                         xs = map fst
                                (mk_subst_domain sigma_s ++
                                  mk_subst_domain mu_s ++
                                    mk_subst_domain sigma_t ++
                                      mk_subst_domain mu_t);
                       } in bindb (catcha
                                    (forallM
                                      (\ x ->
check (not (membera xs x))
  (shows_prec_list Zero_nat
    ['d', 'o', 'm', 'a', 'i', 'n', 's', ' ', 'n', 'o', 't', ' ', 'd', 'i', 's',
      'j', 'o', 'i', 'n', 't']))
                                      (vars_subst_impl rho))
                                    (\ x -> Inl (snd x)))
                              (\ _ ->
                                let {
                                  rhoa = mk_subst Var rho;
                                } in Inr ((subst_apply_term s rhoa,
    (subst_compose_impla sigma_s rhoa, subst_compose_impla mu_s rhoa)),
   ((subst_apply_term t rhoa,
      (subst_compose_impla sigma_t rhoa, subst_compose_impla mu_t rhoa)),
     bb))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list Zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'i',
                                  'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't',
                                  'i', 'o', 'n', ' ', '(', 'b', 'a', 's', 'e',
                                  ')'] .
                                shows_prec_list Zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Pump) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catcha
                      (bindb
                        (check (commutes_impl rho sigma_s)
                          (shows_prec_list Zero_nat
                            ['r', 'h', 'o', ' ', 'd', 'o', 'e', 's', ' ', 'n',
                              'o', 't', ' ', 'c', 'o', 'm', 'm', 'u', 't', 'e',
                              ' ', 'w', 'i', 't', 'h', ' ', 's', 'i', 'g', 'm',
                              'a', '_', 's']))
                        (\ _ ->
                          bindb (check (commutes_impl rho mu_s)
                                  (shows_prec_list Zero_nat
                                    ['r', 'h', 'o', ' ', 'd', 'o', 'e', 's',
                                      ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm',
                                      'm', 'u', 't', 'e', ' ', 'w', 'i', 't',
                                      'h', ' ', 'm', 'u', '_', 's']))
                            (\ _ ->
                              bindb (check (commutes_impl rho sigma_t)
                                      (shows_prec_list Zero_nat
['r', 'h', 'o', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm',
  'm', 'u', 't', 'e', ' ', 'w', 'i', 't', 'h', ' ', 's', 'i', 'g', 'm', 'a',
  '_', 't']))
                                (\ _ ->
                                  bindb (check (commutes_impl rho mu_t)
  (shows_prec_list Zero_nat
    ['r', 'h', 'o', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o',
      'm', 'm', 'u', 't', 'e', ' ', 'w', 'i', 't', 'h', ' ', 'm', 'u', '_',
      't']))
                                    (\ _ ->
                                      Inr
((s, (subst_compose_impl sigma_s rho, mu_s)),
  ((t, (subst_compose_impl sigma_t rho, mu_t)), bb)))))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list Zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'i',
                                  'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't',
                                  'i', 'o', 'n', ' ', '(', 'p', 'u', 'm', 'p',
                                  'i', 'n', 'g', ')'] .
                                shows_prec_list Zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Inst pat rho Pat_Close) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    Inr ((s, (sigma_s, subst_compose_impl mu_s rho)),
                          ((t, (sigma_t, subst_compose_impl mu_t rho)), bb)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Base uu) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catcha
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check (equal_term t ta)
                                    (shows_prec_list Zero_nat
                                      ['t', 'e', 'r', 'm', 's', ' ', 't', ' ',
'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h']))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((tb, (sigma_t, mu_t)), bb)))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list Zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r',
                                  'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                                  '(', 'b', 'a', 's', 'e', ')'] .
                                shows_prec_list Zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      x)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Pump x) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catcha
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check
                                    (equal_term (mk_subst Var sigma_t x) ta)
                                    (shows_prec_list Zero_nat
                                      ['s', 'i', 'g', 'm', 'a', '_', 't', ' ',
'x', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h',
' ', 's', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ', 't', 'e', 'r', 'm']))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((t, (subst_replace_impl sigma_t x tb, mu_t)), bb)))))
                      (\ xa ->
                        Inl (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list Zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r',
                                  'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                                  '(', 'p', 'u', 'm', 'p', 'i', 'n', 'g', ')'] .
                                shows_prec_list Zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      xa)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Rewr pat rewr Pat_Close x) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    catcha
                      (let {
                         (ta, rseq) = rewr;
                         tb = last (ta : map (\ (_, (_, tb)) -> tb) rseq);
                       } in bindb (check (equal_term (mk_subst Var mu_t x) ta)
                                    (shows_prec_list Zero_nat
                                      ['s', 'i', 'g', 'm', 'a', '_', 't', ' ',
'x', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h',
' ', 's', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ', 't', 'e', 'r', 'm']))
                              (\ _ ->
                                bindb (check_rsteps r rseq ta tb)
                                  (\ _ ->
                                    Inr ((s, (sigma_s, mu_s)),
  ((t, (sigma_t, subst_replace_impl mu_t x tb)), bb)))))
                      (\ xa ->
                        Inl (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list Zero_nat
                                ['p', 'a', 't', 't', 'e', 'r', 'n', ' ', 'r',
                                  'e', 'w', 'r', 'i', 't', 'i', 'n', 'g', ' ',
                                  '(', 'c', 'l', 'o', 's', 'i', 'n', 'g', ')'] .
                                shows_prec_list Zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigma_s, mu_s)),
((t, (sigma_t, mu_t)), bb)) .
                                      xa)))
               ba)
        b);
check_pat_rule_prf r p (Pat_Exp_Sigma pat k) =
  bindb (check_pat_rule_prf r p pat)
    (\ (a, b) ->
      let {
        (s, (sigma_s, mu_s)) = a;
      } in (\ (aa, ba) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ bb ->
                    Inr ((subst_apply_term s
                            (mk_subst Var (subst_power_impl sigma_s k)),
                           (sigma_s, mu_s)),
                          ((subst_apply_term t
                              (mk_subst Var (subst_power_impl sigma_t k)),
                             (sigma_t, mu_t)),
                            bb)))
               ba)
        b);

check_non_loop_prf ::
  forall a b.
    (Eq a, Linorder a, Showa a, Cenum b, Ceq b, Corder b, Eq b, Mapping_impl b,
      Linorder b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Non_loop_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_prf r pa (Non_loop_prf pat sigma mu m b p) =
  bindb (check_pat_rule_prf r pa pat)
    (\ (a, c) ->
      let {
        (s, (sigmaa, mua)) = a;
      } in (\ (aa, ca) ->
             let {
               (t, (sigma_t, mu_t)) = aa;
             } in (\ is_pair ->
                    catcha
                      (bindb
                        (check (if is_pair then equal_pos p Empty else True)
                          (shows_prec_list Zero_nat
                            ['p', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ',
                              'e', 'm', 'p', 't', 'y', ',', ' ', 's', 'i', 'n',
                              'c', 'e', ' ', 'p', 'a', 'i', 'r', 's', ' ', 'a',
                              'r', 'e', ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n',
                              'e', 'd']))
                        (\ _ ->
                          bindb (check (commutes_impl sigmaa sigma)
                                  (shows_prec_list Zero_nat
                                    ['s', 'i', 'g', 'm', 'a', ' ', 'a', 'n',
                                      'd', ' ', 's', 'i', 'g', 'm', 'a', '\'',
                                      ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ',
                                      'c', 'o', 'm', 'm', 'u', 't', 'e']))
                            (\ _ ->
                              bindb (check (commutes_impl mua sigma)
                                      (shows_prec_list Zero_nat
['m', 'u', ' ', 'a', 'n', 'd', ' ', 's', 'i', 'g', 'm', 'a', '\'', ' ', 'd',
  'o', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'm', 'm', 'u', 't', 'e']))
                                (\ _ ->
                                  bindb (check
  (subst_eq sigma_t (subst_compose_impl (subst_power_impl sigmaa m) sigma))
  (shows_prec_list Zero_nat
    ['s', 'i', 'g', 'm', 'a', '_', 't', ' ', '!', '=', ' ', 's', 'i', 'g', 'm',
      'a', '^', 'm', ' ', 's', 'i', 'g', 'm', 'a', '\'', ' ']))
                                    (\ _ ->
                                      bindb
(check (subst_eq mu_t (subst_compose_impl mua mu))
  (shows_prec_list Zero_nat
    ['m', 'u', '_', 't', ' ', '!', '=', ' ', 'm', 'u', ' ', 'm', 'u', '\'',
      ' ']))
(\ _ ->
  bindb (check (in_poss p t)
          (shows_prec_list Zero_nat
            ['p', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
              's', 'i', 't', 'i', 'o', 'n', ' ', 'i', 'n', ' ', 't']))
    (\ _ ->
      check (equal_term
              (subst_apply_term s (mk_subst Var (subst_power_impl sigmaa b)))
              (subt_at t p))
        (shows_prec_list Zero_nat
          ['s', ' ', 's', 'i', 'g', 'm', 'a', '^', 'b', ' ', '!', '=', ' ', 't',
            ' ', '|', '_', ' ', 'p']))))))))
                      (\ x ->
                        Inl (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w',
                                 'i', 't', 'h', ' '] .
                              shows_prec_list Zero_nat
                                ['a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                                  'o', 'n', ' ', 'c', 'o', 'n', 'd', 'i', 't',
                                  'i', 'o', 'n', ' ', 'o', 'f', ' ', 'n', 'o',
                                  'n', '-', 'l', 'o', 'o', 'p', ' ', 't', 'h',
                                  'e', 'o', 'r', 'e', 'm'] .
                                shows_prec_list Zero_nat
                                  [' ', 'a', 'f', 't', 'e', 'r', ' ', 'd', 'e',
                                    'r', 'i', 'v', 'i', 'n', 'g', ' ', 'c', 'o',
                                    'r', 'r', 'e', 'c', 't', ' ', 'p', 'a', 't',
                                    't', 'e', 'r', 'n', ' ', 'r', 'u', 'l', 'e',
                                    ' '] .
                                  shows_nl .
                                    show_pat_rule
                                      ((s, (sigmaa, mua)),
((t, (sigma_t, mu_t)), is_pair)) .
                                      x)))
               ca)
        c);

check_non_loop_dp_prf ::
  forall a b c d.
    (Eq b, Linorder b, Showa b, Cenum c, Ceq c, Corder c, Eq c, Mapping_impl c,
      Linorder c, Set_impl c,
      Showa c) => Dpp_ops_ext a b c d ->
                    a -> Non_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_dp_prf i dpp prf =
  let {
    p = pairsa i dpp;
    r = rulesd i dpp;
  } in bindb (check (null (qc i dpp))
               (shows_prec_list Zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'f', 'o', 'r',
                   ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p', 's', ' ', 'u',
                   'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
         (\ _ -> check_non_loop_prf r p prf);

shows_stringa :: forall a. (Showa a) => [a] -> [Prelude.Char] -> [Prelude.Char];
shows_stringa =
  shows_sep (shows_prec Zero_nat) (shows_prec_list Zero_nat [' ']);

rule_removal_nonterm_trs ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_trs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_trs i tp (Rule_removal_nonterm_trs_prf r) =
  let {
    ra = rulesc i tp;
    rrm = ceta_list_diff ra r;
  } in Inr (delete_R_Rwb i tp rrm rrm);

shows_prec_location :: Nat -> Location -> [Prelude.Char] -> [Prelude.Char];
shows_prec_location uu A = shows_prec_list Zero_nat ['a', 'b', 'o', 'v', 'e'];
shows_prec_location uv Ba = shows_prec_list Zero_nat ['b', 'e', 'l', 'o', 'w'];
shows_prec_location uw H = shows_prec_list Zero_nat ['h', 'e', 'r', 'e'];
shows_prec_location ux Ra = shows_prec_list Zero_nat ['r', 'i', 'g', 'h', 't'];

shows_pattern ::
  forall a b.
    (Showa a,
      Showa b) => (Ctxt a b, (Term a b, Location)) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_pattern (c, (s, p)) =
  shows_prec_list Zero_nat ['('] .
    shows_prec_term Zero_nat (ctxt_apply c s) .
      shows_prec_list Zero_nat [',', ' '] .
        shows_prec_pos Zero_nat (hole_pos c) .
          shows_prec_list Zero_nat [',', ' '] .
            shows_prec_location Zero_nat p . shows_prec_list Zero_nat [')'];

fp_R_decide ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b ->
                       Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_R_decide mu l oo q c t =
  not (bex (let {
              h = hole_pos c;
              q_s = filter (\ qa -> is_left_of qa q) (poss_list t);
              m1 = map (\ qa -> (subt_at t qa, l)) q_s;
              sterms =
                remdups
                  (map (si_subst mu)
                    (remdups (concatMap (\ qa -> si_W mu (subt_at t qa)) q_s)));
              uterms = concatMap supteq_list sterms;
              m2 = map (\ u -> (u, l)) (remdups uterms);
              p_s = filter (\ qa -> is_left_of qa h)
                      (poss_list (ctxt_apply c t));
              m3 = map (\ p -> (subt_at (ctxt_apply c t) p, l)) p_s;
              stermsa =
                remdups
                  (map (si_subst mu)
                    (remdups
                      (concatMap (\ p -> si_W mu (subt_at (ctxt_apply c t) p))
                        p_s)));
              utermsa = concatMap supteq_list stermsa;
              m4 = map (\ u -> (u, l)) (remdups utermsa);
            } in set (m1 ++ m2 ++ m3 ++ m4))
        (match_decision mu));

size_pos :: Pos -> Nat;
size_pos Empty = Zero_nat;
size_pos (PCons x21 x22) =
  plus_nat (size_pos x22) (plus_nat Zero_nat (Nat_of_num One));

pos_dec :: Pos -> Pos -> Pos -> Maybe (Nat, Pos);
pos_dec p q oo =
  (if equal_pos p Empty
    then (case pos_suffix oo q of {
           Nothing -> Nothing;
           Just r -> Just (Zero_nat, r);
         })
    else let {
           n0 = nat (ceiling
                      (divide_rat
                        (of_nat (minus_nat (size_pos oo) (size_pos q)))
                        (of_nat (size_pos p))));
         } in (case pos_suffix oo (append (powera p n0) q) of {
                Nothing -> Nothing;
                Just r -> Just (n0, r);
              }));

ctxt_subst ::
  forall a b. Ctxt a b -> (b -> Term a b) -> Nat -> Term a b -> Term a b;
ctxt_subst uu uv n t =
  (if equal_nat n Zero_nat then t
    else ctxt_apply uu
           (subst_apply_term (ctxt_subst uu uv (minus_nat n (Nat_of_num One)) t)
             uv));

h_match_probs ::
  forall a b.
    (Eq a, Linorder a, Eq b,
      Linorder b) => (a -> Term b a) ->
                       Term b a ->
                         Pos ->
                           Pos ->
                             Ctxt b a -> Term b a -> Set (Term b a, Term b a);
h_match_probs mu l oo q c t =
  (case pos_dec (hole_pos c) q oo of {
    Nothing ->
      set_empty
        (of_phantom (set_impl_prod :: Phantom (Term b a, Term b a) Set_impla));
    Just (n, o) ->
      inserta (subt_at (ctxt_subst c mu n t) o, l)
        (set_empty
          (of_phantom
            (set_impl_prod :: Phantom (Term b a, Term b a) Set_impla)));
  });

fp_H_decide ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b ->
                       Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_H_decide mu l oo q c t =
  not (bex (h_match_probs (si_subst mu) l oo q c t) (match_decision mu));

decompositions :: Pos -> [(Pos, Pos)];
decompositions p = map (\ pa -> (pa, the (pos_prefix pa p))) (prefix_list p);

simplify_emp_main ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b ->
                       (Ctxt a b,
                         (Term a b,
                           (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                         [(Term a b, Term a b)] ->
                           Maybe (Maybe (Ctxt a b,
  (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))));
simplify_emp_main mu_incr (Hole, (Fun g ls, (c, (t, [])))) solved =
  (if gmatch_decision mu_incr ((t, Fun g ls) : solved) then Just Nothing
    else (if equal_ctxt c Hole then Nothing
           else simplify_emp_main mu_incr
                  (c, (Fun g ls,
                        (subst_apply_ctxt c (si_subst mu_incr),
                          (subst_apply_term t (si_subst mu_incr), []))))
                  solved));
simplify_emp_main mu_incr (More f bef d aft, (Fun g ls, (c, (t, [])))) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (guarda
             (equal_nat (size_list ls)
               (plus_nat (plus_nat (size_list bef) (size_list aft))
                 (Nat_of_num One))))
        (\ _ ->
          let {
            pairs_bef = zip bef (take (size_list bef) ls);
            pairs_aft =
              zip aft (drop (plus_nat (size_list bef) (Nat_of_num One)) ls);
          } in simplify_emp_main mu_incr
                 (d, (nth ls (size_list bef), (c, (t, pairs_bef ++ pairs_aft))))
                 solved));
simplify_emp_main mu_incr (d, (Var x, (c, (t, [])))) solved =
  Just (Just (d, (Var x, (c, (t, solved)))));
simplify_emp_main mu_incr (d, (l, (c, (t, (Var x, Fun f ls) : mp)))) solved =
  bind (guarda (member x (si_v_incr mu_incr)))
    (\ _ ->
      let {
        m = map (\ (s, a) -> (subst_apply_term s (si_subst mu_incr), a));
      } in simplify_emp_main mu_incr
             (subst_apply_ctxt d (si_subst mu_incr),
               (l, (subst_apply_ctxt c (si_subst mu_incr),
                     (subst_apply_term t (si_subst mu_incr),
                       m ((Var x, Fun f ls) : mp)))))
             (m solved));
simplify_emp_main mu_incr (d, (l, (c, (t, (Fun g ts, Fun f ls) : mp)))) solved =
  bind (guarda (f == g))
    (\ _ ->
      bind (zip_option ts ls)
        (\ pairs ->
          simplify_emp_main mu_incr (d, (l, (c, (t, pairs ++ mp)))) solved));
simplify_emp_main mu_incr (d, (l, (c, (t, (s, Var x) : mp)))) solved =
  simplify_emp_main mu_incr (d, (l, (c, (t, mp)))) ((s, Var x) : solved);

simplify_emp ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b ->
                       (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) ->
                         Sum (Ctxt a b,
                               (Term a b,
                                 (Ctxt a b,
                                   (Term a b, [(Term a b, Term a b)]))))
                           Bool;
simplify_emp mu_incr emp =
  let {
    (d, (l, (c, t))) = emp;
  } in (case simplify_emp_main mu_incr (d, (l, (c, (t, [])))) [] of {
         Nothing -> Inr False;
         Just Nothing -> Inr True;
         Just (Just a) -> Inl a;
       });

eident_prob_to_ident_prob ::
  forall a b.
    (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) -> (Term a b, Term a b);
eident_prob_to_ident_prob (d, (si, (c, t))) = (ctxt_apply d t, si);

eident_prob_of_semp ::
  forall a b.
    (Eq a,
      Eq b) => (Ctxt a b,
                 (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                 Maybe (Ctxt a b, (Term a b, (Ctxt a b, Term a b)));
eident_prob_of_semp (d, (l, (c, (t, mp)))) =
  bind (map_of (reverse_rules mp) l) (\ si -> Just (d, (si, (c, t))));

ident_prob_of_semp ::
  forall a b.
    (Eq a,
      Eq b) => (Ctxt a b,
                 (Term a b, (Ctxt a b, (Term a b, [(Term a b, Term a b)])))) ->
                 [(Term a b, Term a b)];
ident_prob_of_semp (d, (l, (c, (t, mp)))) = ident_prob_of_smp mp;

ident_prob_of_emp ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b ->
                       (Ctxt a b, (Term a b, (Ctxt a b, Term a b))) ->
                         Maybe [(Term a b, Term a b)];
ident_prob_of_emp mu_incr emp =
  (case simplify_emp mu_incr emp of {
    Inl semp ->
      Just (map eident_prob_to_ident_prob
              (option_to_list (eident_prob_of_semp semp)) ++
             ident_prob_of_semp semp);
    Inr True -> Just [];
    Inr False -> Nothing;
  });

n0b :: Pos -> Pos -> Pos -> Nat;
n0b p q oo =
  nat (ceiling
        (divide_rat
          (of_nat
            (minus_nat (plus_nat (size_pos oo) (Nat_of_num One)) (size_pos q)))
          (of_nat (size_pos p))));

less_pos :: Pos -> Pos -> Bool;
less_pos p q = less_eq_pos p q && not (equal_pos p q);

fp_B_decide ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b ->
                       Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_B_decide mu l oo q c t =
  not (bex (foldr (sup_set . (\ qa -> h_match_probs (si_subst mu) l oo qa c t))
             (proper_prefix_list q)
             (set_empty
               (of_phantom
                 (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla))))
        (match_decision mu)) &&
    not (bex (let {
                p = hole_pos c;
                n = (\ pa -> n0b p pa oo);
                ps = filter
                       (\ (pa, pb) ->
                         less_pos oo (append pb (powera p (n pb))) &&
                           less_pos pa p)
                       (remdups (decompositions p));
              } in set (map (\ (pb, pa) ->
                              (subt_at_ctxt c pb,
                                (l, (subst_apply_ctxt c (si_subst mu),
                                      subst_apply_term
(ctxt_subst c (si_subst mu) (n pa) t) (si_subst mu)))))
                         (remdups ps)))
          (\ ep ->
            bex (set_option (ident_prob_of_emp mu ep))
              (all (ident_decision mu))));

n0 :: Pos -> Pos -> Pos -> Nat;
n0 p q oo =
  nat (ceiling
        (divide_rat (of_nat (minus_nat (size_pos oo) (size_pos q)))
          (of_nat (size_pos p))));

fp_A_decide ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b ->
                       Term a b -> Pos -> Pos -> Ctxt a b -> Term a b -> Bool;
fp_A_decide mu l oo q c t =
  not (bex (case subt_at t q of {
             Var _ ->
               set_empty
                 (of_phantom
                   (set_impl_prod :: Phantom (Term a b, Term a b) Set_impla));
             Fun _ _ ->
               let {
                 h = hole_pos c;
                 n = n0 h q oo;
                 hn = powera h n;
                 cs = ctxt_subst c (si_subst mu) n t;
                 q_s = bounded_postfixes q (poss_list t);
                 qoo_s =
                   concatMap
                     (\ qa ->
                       map (\ a -> (qa, a))
                         (prefix_list (append hn (append q qa))))
                     q_s;
                 qoo_sf =
                   filter
                     (\ qoo -> less_pos (append hn q) (append (snd qoo) oo))
                     qoo_s;
                 m1 = map (\ qoo -> (subt_at cs (snd qoo), l)) qoo_sf;
                 sterms = remdups (map (si_subst mu) (si_W mu (subt_at t q)));
                 uterms =
                   concatMap (filter (\ ta -> not (is_Var ta)) . supteq_list)
                     sterms;
                 m2 = map (\ u -> (u, l)) (remdups uterms);
               } in set (m1 ++ m2);
           })
        (match_decision mu));

fp_decide ::
  forall a b.
    (Eq a, Linorder a, Ceq b, Corder b, Eq b,
      Linorder b) => Subst_incr a b ->
                       (Pos, (Ctxt a b, Term a b)) ->
                         (Ctxt a b, (Term a b, Location)) -> Bool;
fp_decide mu =
  (\ (q, (c, t)) (l, (la, loc)) ->
    (if equal_location loc H
      then fp_H_decide mu (ctxt_apply l la) (hole_pos l) q c t else True) &&
      (if equal_location loc A
        then fp_A_decide mu (ctxt_apply l la) (hole_pos l) q c t else True) &&
        (if equal_location loc Ba
          then fp_B_decide mu (ctxt_apply l la) (hole_pos l) q c t else True) &&
          (if equal_location loc Ra
            then fp_R_decide mu (ctxt_apply l la) (hole_pos l) q c t
            else True));

fp_valid ::
  forall a b c.
    (Eq a, Linorder a, Eq b, Linorder b, Ceq c,
      Corder c) => Set (Ctxt a b, (Term a b, c)) -> Bool;
fp_valid p = ball p (\ (l, (la, _)) -> not (is_Var (ctxt_apply l la)));

check_fploop ::
  forall a b.
    (Eq a, Linorder a, Showa a, Ceq b, Corder b, Eq b, Mapping_impl b,
      Linorder b, Set_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Ctxt a b, (Term a b, Location))] ->
                      Fp_loop_prf a b ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fploop r p (FP_loop_prf c sigma t seq) =
  let {
    mu = subst_incr sigma;
    mua = si_subst mu;
  } in bindb (check (not (null seq))
               (shows_prec_list Zero_nat
                 ['l', 'o', 'o', 'p', 'i', 'n', 'g', ' ', 'r', 'e', 'd', 'u',
                   'c', 't', 'i', 'o', 'n', ' ', 'm', 'u', 's', 't', ' ', 'n',
                   'o', 't', ' ', 'b', 'e', ' ', 'e', 'm', 'p', 't', 'y']))
         (\ _ ->
           bindb (check
                   (equal_term (let {
                                  (_, (_, ta)) = last seq;
                                } in ta)
                     (ctxt_apply c (subst_apply_term t mua)))
                   (shows_prec_list Zero_nat
                     ['l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ', 'i',
                       'n', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ' ',
                       'i', 's', ' ', 'n', 'o', 't', ' ', 'C', '[', 't', ' ',
                       's', 'i', 'g', 'm', 'a', ']']))
             (\ _ ->
               bindb (check (fp_valid (set p))
                       (shows_prec_list Zero_nat
                         ['l', 'h', 's', 's', ' ', 'i', 'n', ' ', 'f', 'o', 'r',
                           'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a', 't',
                           't', 'e', 'r', 'n', 's', ' ', 'm', 'u', 's', 't',
                           ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'v', 'a',
                           'r', 'i', 'a', 'b', 'l', 'e', 's']))
                 (\ _ ->
                   bindb (catcha
                           (forallM
                             (\ (l, _) ->
                               check (not (is_Var l))
                                 (shows_prec_list Zero_nat
                                   ['l', 'h', 's', 's', ' ', 'o', 'f', ' ', 'T',
                                     'R', 'S', ' ', 'm', 'u', 's', 't', ' ',
                                     'n', 'o', 't', ' ', 'b', 'e', ' ', 'v',
                                     'a', 'r', 'i', 'a', 'b', 'l', 'e', 's']))
                             r)
                           (\ x -> Inl (snd x)))
                     (\ _ ->
                       let {
                         seqa = zip (t : map (\ (_, (_, ta)) -> ta) seq) seq;
                       } in catcha
                              (forallM
                                (\ (ta, (q, (ra, s))) ->
                                  bindb (check_rstep r q ra ta s)
                                    (\ _ ->
                                      let {
check_fpstep = fp_decide mu (q, (c, ta));
                                      } in
catcha
  (forallM
    (\ pt ->
      check (check_fpstep pt)
        (shows_prec_list Zero_nat
           ['i', 't', 'e', 'r', 'a', 't', 'i', 'n', 'g', ' ', 'r', 'e', 'd',
             'u', 'c', 't', 'i', 'o', 'n', ' '] .
          shows_prec_term Zero_nat ta .
            shows_prec_list Zero_nat [' ', '-', '-', '>'] .
              shows_prec_pos Zero_nat q .
                shows_prec_list Zero_nat [' '] .
                  shows_prec_term Zero_nat s .
                    shows_prec_list Zero_nat
                      [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'r',
                        'e', 's', 'p', 'e', 'c', 't', ' ', 'f', 'o', 'r', 'b',
                        'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a', 't', 't', 'e',
                        'r', 'n', ' '] .
                      shows_pattern pt))
    p)
  (\ x -> Inl (snd x))))
                                seqa)
                              (\ x -> Inl (snd x))))));

check_fp_tp_subsumes ::
  forall a b.
    (Eq a, Key a, Showa a, Eq b, Key b,
      Showa b) => ([(Ctxt (Lab a b) [Prelude.Char],
                      (Term (Lab a b) [Prelude.Char], Location))],
                    [(Term (Lab a b) [Prelude.Char],
                       Term (Lab a b) [Prelude.Char])]) ->
                    ([(Ctxt (Lab a b) [Prelude.Char],
                        (Term (Lab a b) [Prelude.Char], Location))],
                      [(Term (Lab a b) [Prelude.Char],
                         Term (Lab a b) [Prelude.Char])]) ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fp_tp_subsumes ta t =
  let {
    ((p, r), (pa, ra)) = (ta, t);
  } in catcha
         (bindb
           (check (p == pa)
             (shows_prec_list Zero_nat
               ['d', 'i', 'f', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 'i', 'n',
                 ' ', 'f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p',
                 'a', 't', 't', 'e', 'r', 'n', 's', ' ', 's', 't', 'r', 'a',
                 't', 'e', 'g', 'y']))
           (\ _ ->
             catcha (check_subseteq r ra)
               (\ x -> Inl (toomuch ['r', 'u', 'l', 'e'] (shows_rulea x)))))
         (\ x ->
           Inl (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

string_reversal_complete_tt ::
  forall a b c d.
    (Showa b,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
string_reversal_complete_tt i tp =
  let {
    r = rulesc i tp;
  } in bindb (check (q_emptyb i tp)
               (shows_prec_list Zero_nat
                 ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p',
                   't', 'y']))
         (\ _ ->
           bindb (check_unary_signature r)
             (\ _ -> Inr (mkb i default_nfs_nt_trs [] (map rev_rule r) [])));

check_dps ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => (a -> a) ->
                    [(Term a b, Term a b)] ->
                      [(Term a b, Term a b)] -> Sum (Term a b, Term a b) ();
check_dps unshp r p =
  let {
    d = defined_list r;
  } in catcha
         (forallM
           (\ x ->
             (if let {
                   (ll, rr) = x;
                 } in not (is_Var rr) &&
                        not (membera d (the (root rr))) &&
                          any (\ (l, ra) ->
                                equal_term l (sharp_term unshp ll) &&
                                  (equal_term ra (sharp_term unshp rr) ||
                                    supt_impl ra (sharp_term unshp rr)))
                            r
               then Inr () else Inl x))
           p)
         (\ x -> Inl (snd x));

unsharp :: forall a b. Lab a b -> Lab a b;
unsharp (Sharp f) = f;
unsharp (Lab v va) = Lab v va;
unsharp (FunLab v va) = FunLab v va;
unsharp (UnLab v) = UnLab v;

dp_trans_nontermination_tt ::
  forall a b c d e f g.
    (Eq b, Showa b, Eq c, Showa c, Eq d,
      Showa d) => Tp_ops_ext a (Lab b c) d e ->
                    Dpp_ops_ext f (Lab b c) d g ->
                      a -> Dp_trans_nontermination_tt_prf b c d ->
                             Sum ([Prelude.Char] -> [Prelude.Char]) f;
dp_trans_nontermination_tt i j tp (DP_trans_nontermination_tt_prf p) =
  let {
    r = rulesc i tp;
    q = qb i tp;
  } in bindb (check (null q || not (nfsb i tp))
               (shows_prec_list Zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ', 'a',
                   'n', 'd', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o',
                   'r', 'm', ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't',
                   'i', 'o', 'n', 's', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm']))
         (\ _ ->
           bindb (catcha (check_dps unsharp r p)
                   (\ x ->
                     Inl (shows_prec_list Zero_nat
                            ['p', 'r', 'o', 'b', 'l', 'e', 'm', 'a', 't', 'i',
                              'c', ' ', 'r', 'u', 'l', 'e', ':', ' '] .
                           shows_rule (shows_prec_lab Zero_nat)
                             (shows_prec Zero_nat) [' ', '-', '>', ' '] x)))
             (\ _ -> Inr (mkc j False False p [] q [] r)));

switch_termination_tt ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    Join_info b ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
switch_termination_tt i joins_i tp =
  let {
    r = rulesc i tp;
    q = qb i tp;
  } in (case let {
               cp = critical_pairs_impl r r;
             } in bindb (catcha
                          (forallM
                            (\ (b, _) ->
                              check b
                                (shows_prec_list Zero_nat
                                  ['r', 'u', 'l', 'e', 's', ' ', 'a', 'r', 'e',
                                    ' ', 'n', 'o', 't', ' ', 'o', 'v', 'e', 'r',
                                    'l', 'a', 'y']))
                            cp)
                          (\ x -> Inl (snd x)))
                    (\ _ ->
                      bindb (check_wf_trs r)
                        (\ _ ->
                          bindb (check_critical_pairs r cp joins_i)
                            (\ _ ->
                              catcha (check_NF_terms_subset (map fst r) q)
                                (\ x ->
                                  Inl (shows_prec_term Zero_nat x .
shows_prec_list Zero_nat
  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n', ' ', 'n', 'o', 'r', 'm',
    'a', 'l', ' ', 'f', 'o', 'r', 'm', ' ', 'w', '.', 'r', '.', 't', '.', ' ',
    'R'])))))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i (nfsb i tp) [] r []);
       });

q_increase_nonterm_trs ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Q_increase_nonterm_trs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
q_increase_nonterm_trs i dpp (Q_increase_nonterm_trs_prf q) =
  let {
    r = rulesc i dpp;
    qa = qb i dpp;
    nfs = nfsb i dpp;
  } in Inr (mkb i nfs (list_union qa q) r []);

check_step ::
  forall a.
    (Ceq a, Corder a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Dp_proof_step a ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_step r step =
  (case step of {
    OC1 uv _ ->
      check (member uv r)
        (shows_rulea uv .
          shows_prec_list Zero_nat
            [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'o', 'r',
              'i', 'g', 'i', 'n', 'a', 'l', ' ', 'r', 'u', 'l', 'e']);
    OC2 oc_new oc1 oc2 t x l ->
      let {
        (wl, tr) = oc_new;
        (w, tx) = oc1;
        (xl, ra) = oc2;
      } in catcha
             (bindb
               (check (xl == x ++ l)
                 (shows_prec_list Zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x', 'l', ' ',
                     '!', '=', ' ', 'x', ' ', 'l']))
               (\ _ ->
                 bindb (check (tx == t ++ x)
                         (shows_prec_list Zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                             'x', ' ', '!', '=', ' ', 't', ' ', 'x']))
                   (\ _ ->
                     bindb (check (wl == w ++ l)
                             (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'w', 'l', ' ', '!', '=', ' ', 'w', ' ', 'l']))
                       (\ _ ->
                         check (tr == t ++ ra)
                           (shows_prec_list Zero_nat
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                               'r', ' ', '!', '=', ' ', 't', ' ', 'r'])))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '2', ' ', 'o',
                        'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list Zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC2p oc_new oc1 oc2 x t l ->
      let {
        (lw, rt) = oc_new;
        (w, xt) = oc1;
        (lx, ra) = oc2;
      } in catcha
             (bindb
               (check (lx == l ++ x)
                 (shows_prec_list Zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'x', ' ',
                     '!', '=', ' ', 'l', ' ', 'x']))
               (\ _ ->
                 bindb (check (lw == l ++ w)
                         (shows_prec_list Zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l',
                             'w', ' ', '!', '=', ' ', 'l', ' ', 'w']))
                   (\ _ ->
                     bindb (check (rt == ra ++ t)
                             (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'r', 't', ' ', '!', '=', ' ', 'r', ' ', 't']))
                       (\ _ ->
                         check (xt == x ++ t)
                           (shows_prec_list Zero_nat
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x',
                               't', ' ', '!', '=', ' ', 'x', ' ', 't'])))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '2', '\'', ' ',
                        'o', 'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list Zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC3 oc_new oc1 oc2 t1 t2 ->
      let {
        (w, t1rt2) = oc_new;
        (wa, t1xt2) = oc1;
        (x, ra) = oc2;
      } in catcha
             (bindb
               (check (t1rt2 == t1 ++ ra ++ t2)
                 (shows_prec_list Zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't', '1', '_',
                     'r', '_', 't', '2', ' ', '!', '=', ' ', 't', '1', ' ', 'r',
                     ' ', 't', '2']))
               (\ _ ->
                 bindb (check (t1xt2 == t1 ++ x ++ t2)
                         (shows_prec_list Zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                             '1', '_', 'x', '_', 't', '2', ' ', '!', '=', ' ',
                             't', '1', ' ', 'x', ' ', 't', '2']))
                   (\ _ ->
                     check (w == wa)
                       (shows_prec_list Zero_nat
                         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'w', ' ',
                           'd', 'i', 'f', 'f', 'e', 'r', 's']))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '3', ' ', 'o',
                        'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list Zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OC3p oc_new oc1 oc2 t1 t2 ->
      let {
        (t1wt2, ra) = oc_new;
        (t1xt2, raa) = oc1;
        (w, x) = oc2;
      } in catcha
             (bindb
               (check (t1wt2 == t1 ++ w ++ t2)
                 (shows_prec_list Zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't', '1', '_',
                     'w', '_', 't', '2', ' ', '!', '=', ' ', 't', '1', ' ', 'w',
                     ' ', 't', '2']))
               (\ _ ->
                 bindb (check (t1xt2 == t1 ++ x ++ t2)
                         (shows_prec_list Zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 't',
                             '1', '_', 'x', '_', 't', '2', ' ', '!', '=', ' ',
                             't', '1', ' ', 'x', ' ', 't', '2']))
                   (\ _ ->
                     check (ra == raa)
                       (shows_prec_list Zero_nat
                         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ',
                           'd', 'i', 'f', 'f', 'e', 'r', 's']))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C', '3', '\'', ' ',
                        'o', 'f', ' '] .
                     shows_nl .
                       shows_oc oc1 .
                         shows_nl .
                           shows_oc oc2 .
                             shows_nl .
                               shows_prec_list Zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_oc oc_new . shows_nl . xa));
    OCDP1 p oc1 ->
      let {
        (lc, cr) = oc1;
        (a, b) = p;
      } in let {
             (e1, (aa, ba)) = a;
           } in let {
                  (f, (d, l)) = aa;
                } in (\ c1 (c2, (ab, bb)) ->
                       let {
                         (fa, (da, ra)) = ab;
                       } in (\ e2 ->
                              catcha
                                (bindb
                                  (check (null e1)
                                    (shows_prec_list Zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'e', '1', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't', 'y']))
                                  (\ _ ->
                                    bindb (check (null e2)
    (shows_prec_list Zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'e', '2', ' ', 'n', 'o',
        't', ' ', 'e', 'm', 'p', 't', 'y']))
                                      (\ _ ->
bindb (check (c1 == c2)
        (shows_prec_list Zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', ' ', 'n', 'o', 't',
            ' ', 'e', 'q', 'u', 'a', 'l']))
  (\ _ ->
    bindb (check
            (equal_nat f (Nat_of_num One) &&
              equal_nat fa (Nat_of_num One) &&
                equal_nat d Zero_nat && equal_nat da Zero_nat)
            (shows_prec_list Zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', '0', ' ', 'a', 'n',
                'd', ' ', '1', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n',
                's', ' ', 'n', 'o', 't', ' ', 'm', 'e', 't']))
      (\ _ ->
        bindb (check (lc == l ++ c1)
                (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'c', ' ',
                    '!', '=', ' ', 'l', ' ', 'c']))
          (\ _ ->
            check (cr == c1 ++ ra)
              (shows_prec_list Zero_nat
                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'r', ' ',
                  '!', '=', ' ', 'c', ' ', 'r'])))))))
                                (\ x ->
                                  Inl (shows_prec_list Zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C',
   'D', 'P', '1', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_oc oc1 .
    shows_nl .
      shows_prec_list Zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
        shows_nl . shows_pat p . shows_nl . x)))
                         bb)
                  ba
             b;
    OCDP2 p oc1 ->
      let {
        (cl, rc) = oc1;
        (a, b) = p;
      } in let {
             (c1, (aa, ba)) = a;
           } in let {
                  (f, (d, l)) = aa;
                } in (\ e1 (e2, (ab, bb)) ->
                       let {
                         (fa, (da, ra)) = ab;
                       } in (\ c2 ->
                              catcha
                                (bindb
                                  (check (null e1 && null e2)
                                    (shows_prec_list Zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'e', '1', ' ', 'o', 'r', ' ', 'e', '2', ' ', 'n', 'o', 't', ' ', 'e', 'm',
'p', 't', 'y']))
                                  (\ _ ->
                                    bindb (check (c1 == c2)
    (shows_prec_list Zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', ' ', 'n', 'o', 't',
        ' ', 'e', 'q', 'u', 'a', 'l']))
                                      (\ _ ->
bindb (check
        (equal_nat f (Nat_of_num One) &&
          equal_nat fa (Nat_of_num One) &&
            equal_nat d Zero_nat && equal_nat da Zero_nat)
        (shows_prec_list Zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', '0', ' ', 'a', 'n', 'd',
            ' ', '1', ' ', 'c', 'o', 'n', 'd', 'i', 't', 'i', 'o', 'n', 's',
            ' ', 'n', 'o', 't', ' ', 'm', 'e', 't']))
  (\ _ ->
    bindb (check (cl == c1 ++ l)
            (shows_prec_list Zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'c', ' ', '!',
                '=', ' ', 'l', ' ', 'c']))
      (\ _ ->
        check (rc == ra ++ c1)
          (shows_prec_list Zero_nat
            ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'r', ' ', '!',
              '=', ' ', 'c', ' ', 'r']))))))
                                (\ x ->
                                  Inl (shows_prec_list Zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'O', 'C',
   'D', 'P', '1', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_oc oc1 .
    shows_nl .
      shows_prec_list Zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
        shows_nl . shows_pat p . shows_nl . x)))
                         bb)
                  ba
             b;
    WPEQ p_new p ->
      let {
        (left, right) = p;
        (lefta, righta) = p_new;
      } in catcha
             (bindb
               (check (word_pat_equiv left lefta)
                 (shows_prec_list Zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'h', 's',
                     's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'e', 'q',
                     'u', 'i', 'v', 'a', 'l', 'e', 'n', 't']))
               (\ _ ->
                 check (word_pat_equiv right righta)
                   (shows_prec_list Zero_nat
                     ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', 'h',
                       's', 's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ',
                       'e', 'q', 'u', 'i', 'v', 'a', 'l', 'e', 'n', 't'])))
             (\ x ->
               Inl (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'e', 'q',
                        'u', 'i', 'v', 'a', 'l', 'e', 'n', 'c', 'e', ' ', 'o',
                        'f', ' '] .
                     shows_nl .
                       shows_pat p .
                         shows_nl .
                           shows_prec_list Zero_nat ['a', 'n', 'd'] .
                             shows_nl . shows_pat p_new . shows_nl . x));
    Lift p_new p ->
      let {
        (a, b) = p;
      } in let {
             (l1, (aa, ba)) = a;
           } in let {
                  (f1, (c1, m1)) = aa;
                } in (\ r1 (l2, (ab, bb)) ->
                       let {
                         (f2, (c2, m2)) = ab;
                       } in (\ r2 ->
                              let {
                                (ac, bc) = p_new;
                              } in let {
                                     (l1a, (ad, bd)) = ac;
                                   } in let {
  (f1a, (c1a, m1a)) = ad;
} in (\ r1a (l2a, (ae, be)) ->
       let {
         (f2a, (c2a, m2a)) = ae;
       } in (\ r2a ->
              catcha
                (bindb
                  (check (l1 == l1a && l2 == l2a)
                    (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', ' ',
                        'a', 'n', 'd', ' ', 'l', '\'', ' ', 'd', 'o', ' ', 'n',
                        'o', 't', ' ', 'm', 'a', 't', 'c', 'h']))
                  (\ _ ->
                    bindb (check (r1 == r1a && r2 == r2a)
                            (shows_prec_list Zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r',
                                ' ', 'a', 'n', 'd', ' ', 'r', '\'', ' ', 'd',
                                'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                                'c', 'h']))
                      (\ _ ->
                        bindb (check (equal_nat f1 f1a && equal_nat f2 f2a)
                                (shows_prec_list Zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                    'f', ' ', 'a', 'n', 'd', ' ', 'f', '\'',
                                    ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'm',
                                    'a', 't', 'c', 'h']))
                          (\ _ ->
                            bindb (check (m1 == m1a && m2 == m2a)
                                    (shows_prec_list Zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'm', ' ', 'a', 'n', 'd', ' ', 'm', '\'', ' ', 'd', 'o', ' ', 'n', 'o', 't',
' ', 'm', 'a', 't', 'c', 'h']))
                              (\ _ ->
                                bindb (check (equal_nat c1a (plus_nat c1 f1))
(shows_prec_list Zero_nat
  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'o', 'n', 's', 't', 'a',
    'n', 't', ' ', 'f', 'a', 'c', 't', 'o', 'r', ' ', 'o', 'n', ' ', 't', 'h',
    'e', ' ', 'l', 'e', 'f', 't', ' ', 'n', 'o', 't', ' ', 'p', 'r', 'o', 'p',
    'e', 'r', 'l', 'y', ' ', 'i', 'n', 'c', 'r', 'e', 'a', 's', 'e', 'd']))
                                  (\ _ ->
                                    check (equal_nat c2a (plus_nat c2 f2))
                                      (shows_prec_list Zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n',
  't', ' ', 'f', 'a', 'c', 't', 'o', 'r', ' ', 'o', 'n', ' ', 't', 'h', 'e',
  ' ', 'r', 'i', 'g', 'h', 't', ' ', 'n', 'o', 't', ' ', 'p', 'r', 'o', 'p',
  'e', 'r', 'l', 'y', ' ', 'i', 'n', 'c', 'r', 'e', 'a', 's', 'e', 'd'])))))))
                (\ x ->
                  Inl (shows_prec_list Zero_nat
                         ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                           'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'l',
                           'i', 'f', 't', 'i', 'n', 'g', ' ', 'o', 'f', ' '] .
                        shows_nl .
                          shows_pat p .
                            shows_nl .
                              shows_prec_list Zero_nat
                                ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                shows_nl . shows_pat p_new . shows_nl . x)))
         be)
  bd
                                     bc)
                         bb)
                  ba
             b;
    DPOC1_1 p_new p1 oc1 l ra ->
      let {
        (left, (lxr, (m2, r2))) = p1;
        (x, v) = oc1;
        (lefta, (lvr, (m2a, r2a))) = p_new;
      } in catcha
             (bindb
               (check (left == lefta)
                 (shows_prec_list Zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'h', 's',
                     's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'e', 'q',
                     'u', 'a', 'l']))
               (\ _ ->
                 bindb (check (m2 == m2a)
                         (shows_prec_list Zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                             '2', ' ', 'a', 'n', 'd', ' ', 'm', '2', '\'', ' ',
                             'd', 'o', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't',
                             'c', 'h']))
                   (\ _ ->
                     bindb (check (r2 == r2a)
                             (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'r', '2', ' ', 'a', 'n', 'd', ' ', 'r', '2',
                                 '\'', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ',
                                 'm', 'a', 't', 'c', 'h']))
                       (\ _ ->
                         bindb (check (lxr == l ++ x ++ ra)
                                 (shows_prec_list Zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                     'l', '_', 'x', '_', 'r', ' ', '!', '=',
                                     ' ', 'l', ' ', '@', ' ', 'x', ' ', '@',
                                     ' ', 'r']))
                           (\ _ ->
                             check (lvr == l ++ v ++ ra)
                               (shows_prec_list Zero_nat
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                   'l', '_', 'v', '_', 'r', ' ', '!', '=', ' ',
                                   'l', ' ', '@', ' ', 'v', ' ', '@', ' ',
                                   'r']))))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P', 'O', 'C', '1',
                        '_', '1', ' ', 'o', 'f', ' '] .
                     shows_nl .
                       shows_pat p1 .
                         shows_nl .
                           shows_oc oc1 .
                             shows_nl .
                               shows_prec_list Zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_pat p_new . shows_nl . xa));
    DPOC1_2 p_new p1 oc1 l ra x ->
      let {
        (a, b) = p1;
      } in let {
             (l1, (m1, r1)) = a;
           } in (\ (xr, (m2, r2)) ->
                  let {
                    (lx, v) = oc1;
                    (aa, ba) = p_new;
                  } in let {
                         (ll1, (m1a, r1a)) = aa;
                       } in (\ (vr, (m2a, r2a)) ->
                              catcha
                                (bindb
                                  (check (m1 == m1a && m2 == m2a)
                                    (shows_prec_list Zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
'd', 'i', 'f', 'i', 'e', 'd']))
                                  (\ _ ->
                                    bindb (check (r1 == r1a && r2 == r2a)
    (shows_prec_list Zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ', 'c', 'o', 'm',
        'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
        'e', 'd']))
                                      (\ _ ->
bindb (check (ll1 == l ++ l1)
        (shows_prec_list Zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '1', ' ',
            '!', '=', ' ', 'l', ' ', '@', ' ', 'l', 'l', '1']))
  (\ _ ->
    bindb (check (xr == x ++ ra)
            (shows_prec_list Zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x', '_', 'r', ' ',
                '!', '=', ' ', 'x', ' ', '@', ' ', 'r']))
      (\ _ ->
        bindb (check (lx == l ++ x)
                (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'x',
                    ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'x']))
          (\ _ ->
            check (vr == v ++ ra)
              (shows_prec_list Zero_nat
                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'v', '_', 'r',
                  ' ', '!', '=', ' ', 'v', ' ', '@', ' ', 'r'])))))))
                                (\ xa ->
                                  Inl (shows_prec_list Zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P',
   'O', 'C', '1', '_', '2', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list Zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPOC2 p_new p1 oc1 l ra ->
      let {
        (left, (l2, (a, b))) = p1;
      } in let {
             (f2, (c2, lxr)) = a;
           } in (\ r2 ->
                  let {
                    (x, v) = oc1;
                    (lefta, (l2a, (aa, ba))) = p_new;
                  } in let {
                         (f2a, (c2a, lvr)) = aa;
                       } in (\ r2a ->
                              catcha
                                (bindb
                                  (check (left == lefta)
                                    (shows_prec_list Zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'l', 'e', 'f', 't', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                                  (\ _ ->
                                    bindb (check (equal_nat f2 f2a)
    (shows_prec_list Zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'f', ' ', 'c', 'o', 'm',
        'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
        'e', 'd']))
                                      (\ _ ->
bindb (check (equal_nat c2 c2a)
        (shows_prec_list Zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'c', ' ', 'c', 'o', 'm',
            'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f',
            'i', 'e', 'd']))
  (\ _ ->
    bindb (check (l2 == l2a)
            (shows_prec_list Zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', ' ', 'c', 'o',
                'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
                'f', 'i', 'e', 'd']))
      (\ _ ->
        bindb (check (r2 == r2a)
                (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', ' ', 'c',
                    'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
                    'd', 'i', 'f', 'i', 'e', 'd']))
          (\ _ ->
            bindb (check (lxr == l ++ x ++ ra)
                    (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_',
                        'x', '_', 'r', ' ', '!', '=', ' ', 'l', ' ', '@', ' ',
                        'x', ' ', '@', ' ', 'r']))
              (\ _ ->
                check (lvr == l ++ v ++ ra)
                  (shows_prec_list Zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'v',
                      '_', 'r', ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'v',
                      ' ', '@', ' ', 'r']))))))))
                                (\ xa ->
                                  Inl (shows_prec_list Zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P',
   'O', 'C', '2', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list Zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPOC3_1 p_new p1 oc1 l ra ->
      let {
        (left, (l2, (m2, lxr))) = p1;
        (x, v) = oc1;
        (lefta, (l2a, (m2a, lvr))) = p_new;
      } in catcha
             (bindb
               (check (left == lefta)
                 (shows_prec_list Zero_nat
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', 'e', 'f',
                     't', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
                     ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
               (\ _ ->
                 bindb (check (m2 == m2a)
                         (shows_prec_list Zero_nat
                           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                             ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't',
                             's', ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                   (\ _ ->
                     bindb (check (l2 == l2a)
                             (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'l', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e',
                                 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f',
                                 'i', 'e', 'd']))
                       (\ _ ->
                         bindb (check (lxr == l ++ x ++ ra)
                                 (shows_prec_list Zero_nat
                                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                     'l', '_', 'x', '_', 'r', ' ', '!', '=',
                                     ' ', 'l', ' ', '@', ' ', 'x', ' ', '@',
                                     ' ', 'r']))
                           (\ _ ->
                             check (lvr == l ++ v ++ ra)
                               (shows_prec_list Zero_nat
                                 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                   'l', '_', 'v', '_', 'r', ' ', '!', '=', ' ',
                                   'l', ' ', '@', ' ', 'v', ' ', '@', ' ',
                                   'r']))))))
             (\ xa ->
               Inl (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ',
                        'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v',
                        'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P', 'O', 'C', '3',
                        '_', '1', ' ', 'o', 'f', ' '] .
                     shows_nl .
                       shows_pat p1 .
                         shows_nl .
                           shows_oc oc1 .
                             shows_nl .
                               shows_prec_list Zero_nat
                                 ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                                 shows_nl . shows_pat p_new . shows_nl . xa));
    DPOC3_2 p_new p1 oc1 l ra x ->
      let {
        (a, b) = p1;
      } in let {
             (l1, (m1, r1)) = a;
           } in (\ (l2, (m2, lx)) ->
                  let {
                    (xr, v) = oc1;
                    (aa, ba) = p_new;
                  } in let {
                         (l1a, (m1a, r1r)) = aa;
                       } in (\ (l2a, (m2a, lv)) ->
                              catcha
                                (bindb
                                  (check (m2 == m2a && m1 == m1a)
                                    (shows_prec_list Zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
'd', 'i', 'f', 'i', 'e', 'd']))
                                  (\ _ ->
                                    bindb (check (l1 == l1a)
    (shows_prec_list Zero_nat
      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', ' ', 'c', 'o', 'm',
        'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
        'e', 'd']))
                                      (\ _ ->
bindb (check (l2 == l2a)
        (shows_prec_list Zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '2', ' ', 'c', 'o',
            'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
            'f', 'i', 'e', 'd']))
  (\ _ ->
    bindb (check (lx == l ++ x)
            (shows_prec_list Zero_nat
              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'x', ' ',
                '!', '=', ' ', 'l', ' ', '@', ' ', 'x']))
      (\ _ ->
        bindb (check (xr == x ++ ra)
                (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'x', '_', 'r',
                    ' ', '!', '=', ' ', 'x', ' ', '@', ' ', 'r']))
          (\ _ ->
            bindb (check (r1r == r1 ++ ra)
                    (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '1',
                        '_', 'r', ' ', '!', '=', ' ', 'r', '1', ' ', '@', ' ',
                        'r']))
              (\ _ ->
                check (lv == l ++ v)
                  (shows_prec_list Zero_nat
                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'v',
                      ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'v']))))))))
                                (\ xa ->
                                  Inl (shows_prec_list Zero_nat
 ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h', 'e', 'c',
   'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'D', 'P',
   'O', 'C', '3', '_', '2', ' ', 'o', 'f', ' '] .
shows_nl .
  shows_pat p1 .
    shows_nl .
      shows_oc oc1 .
        shows_nl .
          shows_prec_list Zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
            shows_nl . shows_pat p_new . shows_nl . xa)))
                         ba)
             b;
    DPDP1_1 p_new p1 p2 l ra ->
      let {
        (left, (ll2, (mm, r2r))) = p1;
        (a, b) = p2;
      } in let {
             (l2, (mma, r2)) = a;
           } in (\ (l2a, (mm2, r2a)) ->
                  let {
                    (lefta, (ll2a, (mm2a, r2pr))) = p_new;
                  } in catcha
                         (bindb
                           (check (left == lefta)
                             (shows_prec_list Zero_nat
                               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                 'l', 'e', 'f', 't', ' ', 'c', 'o', 'm', 'p',
                                 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
                                 'd', 'i', 'f', 'i', 'e', 'd']))
                           (\ _ ->
                             bindb (check (mm == mma)
                                     (shows_prec_list Zero_nat
                                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
 ' ', 'm', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm',
 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                               (\ _ ->
                                 bindb (check (mm2 == mm2a)
 (shows_prec_list Zero_nat
   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm', '2', ' ', 'c', 'o',
     'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
     'e', 'd']))
                                   (\ _ ->
                                     bindb (check (ll2 == l ++ l2)
     (shows_prec_list Zero_nat
       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '2', ' ',
         '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '2']))
                                       (\ _ ->
 bindb (check (r2r == r2 ++ ra)
         (shows_prec_list Zero_nat
           ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', '_', 'r',
             ' ', '!', '=', ' ', 'r', '2', ' ', '@', ' ', 'r']))
   (\ _ ->
     bindb (check (r2pr == r2a ++ ra)
             (shows_prec_list Zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', 'p', 'r',
                 ' ', '!', '=', ' ', 'r', '2', '\'', ' ', '@', ' ', 'r']))
       (\ _ ->
         check (ll2a == l ++ l2a)
           (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '2',
               ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '2', ' ']))))))))
                         (\ x ->
                           Inl (shows_prec_list Zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i',
                                    'n', ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n',
                                    'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a', 'p',
                                    ' ', 'D', 'P', 'D', 'P', '1', '_', '1', ' ',
                                    'o', 'f', ' '] .
                                 shows_nl .
                                   shows_pat p1 .
                                     shows_nl .
                                       shows_pat p2 .
 shows_nl .
   shows_prec_list Zero_nat ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
     shows_nl . shows_pat p_new . shows_nl . x)))
             b;
    DPDP1_2 p_new p1 p2 l ra ->
      let {
        (a, b) = p1;
      } in let {
             (l1, (mm1, r1)) = a;
           } in (\ (ll2, (mm, r1a)) ->
                  let {
                    (aa, ba) = p2;
                  } in let {
                         (l2, (mm2, r1r)) = aa;
                       } in (\ (l2a, (mm2a, r2)) ->
                              let {
                                (ab, bb) = p_new;
                              } in let {
                                     (l3, (mm3, r1pr)) = ab;
                                   } in (\ (ll2a, (mm3a, r3)) ->
  catcha
    (bindb
      (check (l1 == l3)
        (shows_prec_list Zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '1', '\'', ' ',
            'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o',
            'd', 'i', 'f', 'i', 'e', 'd']))
      (\ _ ->
        bindb (check (mm1 == mm3)
                (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm', '1',
                    '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
                    ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
          (\ _ ->
            bindb (check (mm == mm2)
                    (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm',
                        ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
                        ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
              (\ _ ->
                bindb (check (mm2a == mm3a)
                        (shows_prec_list Zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                            'm', '2', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                            'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f',
                            'i', 'e', 'd']))
                  (\ _ ->
                    bindb (check (r2 == r3)
                            (shows_prec_list Zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r',
                                '2', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                                'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
                                'f', 'i', 'e', 'd']))
                      (\ _ ->
                        bindb (check (ll2 == l ++ l2)
                                (shows_prec_list Zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                    'l', '_', 'l', '2', ' ', '!', '=', ' ', 'l',
                                    ' ', '@', ' ', 'l', '2']))
                          (\ _ ->
                            bindb (check (r1pr == r1 ++ ra)
                                    (shows_prec_list Zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'r', '1', '\'', 'r', ' ', '!', '=', ' ', 'r', '1', '\'', ' ', '@', ' ',
'r']))
                              (\ _ ->
                                bindb (check (r1r == r1a ++ ra)
(shows_prec_list Zero_nat
  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '1', 'r', ' ', '!', '=',
    ' ', 'r', '1', ' ', '@', ' ', 'r']))
                                  (\ _ ->
                                    check (ll2a == l ++ l2a)
                                      (shows_prec_list Zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l', '2', ' ', '!', '=',
  ' ', 'l', ' ', '@', ' ', 'l', '2', ' ']))))))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
               'p', ' ', 'D', 'P', 'D', 'P', '1', '_', '2', ' ', 'o', 'f',
               ' '] .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list Zero_nat
                        ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
    DPDP2_1 p_new p1 p2 l ra ->
      let {
        (a, b) = p1;
      } in let {
             (l1, (mm1, r1)) = a;
           } in (\ (l1a, (mm, r2r)) ->
                  let {
                    (aa, ba) = p2;
                  } in let {
                         (ll1, (mm2, r2)) = aa;
                       } in (\ (l2, (mm2a, r2a)) ->
                              let {
                                (ab, bb) = p_new;
                              } in let {
                                     (ll1a, (mm3, r3)) = ab;
                                   } in (\ (l3, (mm3a, r2pr)) ->
  catcha
    (bindb
      (check (r2r == r2 ++ ra)
        (shows_prec_list Zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', 'r', ' ', '!',
            '=', ' ', 'r', '2', ' ', '@', ' ', 'r']))
      (\ _ ->
        bindb (check (ll1 == l ++ l1a)
                (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l',
                    '1', ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '1']))
          (\ _ ->
            bindb (check (ll1a == l ++ l1)
                    (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_',
                        'l', '1', '\'', ' ', '!', '=', ' ', 'l', ' ', '@', ' ',
                        'l', '1', '\'', ' ']))
              (\ _ ->
                bindb (check (mm1 == mm3)
                        (shows_prec_list Zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                            'm', '1', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                            'e', 'n', 't', ' ', 'm', 'o', 'd', 'i', 'f', 'i',
                            'e', 'd']))
                  (\ _ ->
                    bindb (check (r1 == r3)
                            (shows_prec_list Zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r',
                                '1', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                                'e', 'n', 't', ' ', 'm', 'o', 'd', 'i', 'f',
                                'i', 'e', 'd']))
                      (\ _ ->
                        bindb (check (l2 == l3)
                                (shows_prec_list Zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                    'l', '2', '\'', ' ', 'c', 'o', 'm', 'p',
                                    'o', 'n', 'e', 'n', 't', ' ', 'm', 'o', 'd',
                                    'i', 'f', 'i', 'e', 'd']))
                          (\ _ ->
                            bindb (check (mm2a == mm3a)
                                    (shows_prec_list Zero_nat
                                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':',
' ', 'm', 'm', '2', '\'', ' ', 'c', 'o', 'm', 'p', 'o', 'n', 'e', 'n', 't', 's',
' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd']))
                              (\ _ ->
                                bindb (check (mm == mm2)
(shows_prec_list Zero_nat
  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm', 'm', ' ', 'c', 'o', 'm',
    'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e',
    'd']))
                                  (\ _ ->
                                    check (r2pr == r2a ++ ra)
                                      (shows_prec_list Zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '2', '\'', 'r', ' ', '!',
  '=', ' ', 'r', '2', '\'', ' ', '@', ' ', 'r']))))))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
               'p', ' ', 'D', 'P', 'D', 'P', '2', '_', '1', ' ', 'o', 'f',
               ' '] .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list Zero_nat
                        ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
    DPDP2_2 p_new p1 p2 l ra ->
      let {
        (a, b) = p1;
      } in let {
             (l1, (mm1, r1)) = a;
           } in (\ (l1a, (mm1a, r1a)) ->
                  let {
                    (aa, ba) = p2;
                  } in let {
                         (ll1, (mm2, r1r)) = aa;
                       } in (\ right ->
                              let {
                                (ab, bb) = p_new;
                              } in let {
                                     (ll1a, (mm3, r1pr)) = ab;
                                   } in (\ righta ->
  catcha
    (bindb
      (check (r1r == r1a ++ ra)
        (shows_prec_list Zero_nat
          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r', '1', 'r', ' ', '!',
            '=', ' ', 'r', '1', ' ', '@', ' ', 'r']))
      (\ _ ->
        bindb (check (ll1 == l ++ l1a)
                (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_', 'l',
                    '1', ' ', '!', '=', ' ', 'l', ' ', '@', ' ', 'l', '1']))
          (\ _ ->
            bindb (check (ll1a == l ++ l1)
                    (shows_prec_list Zero_nat
                      ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'l', '_',
                        'l', '1', '\'', ' ', '!', '=', ' ', 'l', ' ', '@', ' ',
                        'l', '1', '\'', ' ']))
              (\ _ ->
                bindb (check (r1pr == r1 ++ ra)
                        (shows_prec_list Zero_nat
                          ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'r',
                            '1', '\'', '_', 'r', ' ', '!', '=', ' ', 'r', '1',
                            '\'', ' ', '@', ' ', 'r', ' ']))
                  (\ _ ->
                    bindb (check (mm1 == mm3)
                            (shows_prec_list Zero_nat
                              ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'm',
                                'm', '1', '\'', ' ', 'c', 'o', 'm', 'p', 'o',
                                'n', 'e', 'n', 't', ' ', 'm', 'o', 'd', 'i',
                                'f', 'i', 'e', 'd']))
                      (\ _ ->
                        bindb (check (mm1a == mm2)
                                (shows_prec_list Zero_nat
                                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                    'm', 'm', ' ', 'c', 'o', 'm', 'p', 'o', 'n',
                                    'e', 'n', 't', 's', ' ', 'm', 'o', 'd', 'i',
                                    'f', 'i', 'e', 'd']))
                          (\ _ ->
                            check (right == righta)
                              (shows_prec_list Zero_nat
                                ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ',
                                  'r', 'i', 'g', 'h', 't', ' ', 'c', 'o', 'm',
                                  'p', 'o', 'n', 'e', 'n', 't', 's', ' ', 'm',
                                  'o', 'd', 'i', 'f', 'i', 'e', 'd']))))))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
               'e', 'c', 'k', 'i', 'n', 'g', ' ', 'o', 'v', 'e', 'r', 'l', 'a',
               'p', ' ', 'D', 'P', 'D', 'P', '2', '_', ' ', 'o', 'f', ' '] .
            shows_nl .
              shows_pat p1 .
                shows_nl .
                  shows_pat p2 .
                    shows_nl .
                      shows_prec_list Zero_nat
                        ['t', 'o', ' ', 'y', 'i', 'e', 'l', 'd'] .
                        shows_nl . shows_pat p_new . shows_nl . x)))
                                     bb)
                         ba)
             b;
  });

check_proof ::
  forall a.
    (Ceq a, Corder a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Set (([a], ((Nat, (Nat, [a])), [a])),
                          ([a], ((Nat, (Nat, [a])), [a]))) ->
                      [Dp_proof_step a] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_proof r delta (p : ps) =
  bindb (check_step r p)
    (\ _ ->
      bindb (catcha
              (forallM
                (\ pa ->
                  check (member pa delta)
                    (shows_prec_list Zero_nat
                       ['p', 'r', 'o', 'b', 'l', 'e', 'm', ':', ' ', 'n', 'o',
                         't', 'h', 'i', 'n', 'g', ' ', 'k', 'n', 'o', 'w', 'n',
                         ' ', 'a', 'b', 'o', 'u', 't', ' ', 'p', 'r', 'e', 'm',
                         'i', 's', 'e', ' '] .
                      shows_pat pa))
                (prems_ofa p))
              (\ x -> Inl (snd x)))
        (\ _ ->
          check_proof r
            (sup_set delta
              (inserta (pat_of p)
                (set_empty
                  (of_phantom
                    (set_impl_prod ::
                      Phantom
                        (([a], ((Nat, (Nat, [a])), [a])),
                          ([a], ((Nat, (Nat, [a])), [a])))
                        Set_impla)))))
            ps));
check_proof r delta [] = Inr ();

check_non_loop_srs_proof ::
  forall a.
    (Ceq a, Corder a, Eq a,
      Showa a) => Set ([a], [a]) ->
                    Non_loop_srs_proof a ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_srs_proof ra (SE_OC (m, lmr) l r steps) =
  bindb (check
          (membera (map pat_of steps)
            (([], ((Zero_nat, (Zero_nat, [])), m)),
              ([], ((Zero_nat, (Zero_nat, [])), lmr))))
          (shows_prec_list Zero_nat
            ['o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'c', 'l', 'o', 's', 'u',
              'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'e', 'r', 'i', 'v', 'e',
              'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'p', 'r', 'o', 'o',
              'f']))
    (\ _ ->
      bindb (check (lmr == l ++ m ++ r)
              (shows_prec_list Zero_nat
                ['n', 'o', ' ', 's', 'e', 'l', 'f', 'o', 'v', 'e', 'r', 'l',
                  'a', 'p']))
        (\ _ ->
          check_proof ra
            (set_empty
              (of_phantom
                (set_impl_prod ::
                  Phantom
                    (([a], ((Nat, (Nat, [a])), [a])),
                      ([a], ((Nat, (Nat, [a])), [a])))
                    Set_impla)))
            steps));
check_non_loop_srs_proof ra (SE_DP (left, right) l r steps) =
  bindb (check (membera (map pat_of steps) (left, right))
          (shows_prec_list Zero_nat
            ['o', 'v', 'e', 'r', 'l', 'a', 'p', ' ', 'c', 'l', 'o', 's', 'u',
              'r', 'e', ' ', 'n', 'o', 't', ' ', 'd', 'e', 'r', 'i', 'v', 'e',
              'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'p', 'r', 'o', 'o',
              'f']))
    (\ _ ->
      let {
        (l1, (a, b)) = left;
      } in let {
             (f1, (c1, m1)) = a;
           } in (\ r1 ->
                  let {
                    (l2, (aa, ba)) = right;
                  } in let {
                         (f2, (c2, m2)) = aa;
                       } in (\ r2 ->
                              bindb (check
                                      (m1 == m2 &&
l2 == l ++ l1 && r2 == r1 ++ r)
                                      (shows_prec_list Zero_nat
['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i', 't', 'h', ' ', 's', 'e', 'l',
  'f', 'o', 'v', 'e', 'r', 'l', 'a', 'p']))
                                (\ _ ->
                                  bindb (check
  (less_eq_nat f1 f2 &&
    equal_nat (mod_nat (max (minus_nat c2 c1) (minus_nat c1 c2)) f1) Zero_nat &&
      (if less_nat f1 f2 then equal_nat (mod_nat f2 f1) Zero_nat else True) &&
        (if equal_nat f1 f2 then less_eq_nat c1 c2 else True))
  (shows_prec_list Zero_nat
    ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'n', 's', 'u', 'r',
      'e', ' ', 'f', 'i', 't', 't', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 'd', 'i',
      't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 's', 'e', 'l', 'f', 'o', 'v',
      'e', 'r', 'l', 'a', 'p']))
                                    (\ _ ->
                                      check_proof ra
(set_empty
  (of_phantom
    (set_impl_prod ::
      Phantom (([a], ((Nat, (Nat, [a])), [a])), ([a], ((Nat, (Nat, [a])), [a])))
        Set_impla)))
steps)))
                         ba)
             b);

srs_of_trs_impl :: forall a b. [(Term a b, Term a b)] -> [([a], [a])];
srs_of_trs_impl r =
  concatMap
    (\ (l, ra) ->
      (if unary_term l
        then (if unary_term ra then [(term_to_string l, term_to_string ra)]
               else [])
        else []))
    r;

check_non_loop_srs_prf ::
  forall a b c d.
    (Ceq b, Corder b, Eq b,
      Showa b) => Tp_ops_ext a b c d ->
                    a -> Non_loop_srs_proof b ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_srs_prf i tp prf =
  let {
    r = rulesc i tp;
    s = set (srs_of_trs_impl r);
  } in bindb (check (null (qb i tp))
               (shows_prec_list Zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'f', 'o', 'r',
                   ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p', 's', ' ', 'u',
                   'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
         (\ _ -> check_non_loop_srs_proof s prf);

check_not_wwf_qtrs ::
  forall a b c.
    (Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_not_wwf_qtrs i tp =
  bindb (check (null (qb i tp) || not (nfsb i tp))
          (shows_prec_list Zero_nat
            ['s', 't', 'r', 'a', 't', 'e', 'g', 'i', 'e', 's', ' ', 'a', 'n',
              'd', ' ', 'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm',
              ' ', 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
              's', ' ', 'p', 'r', 'o', 'b', 'l', 'e', 'm']))
    (\ _ ->
      check (not (isOK (check_wwf_qtrs (is_QNFb i tp) (rulesc i tp))))
        (shows_string
           ['T', 'h', 'e', ' ', 'Q', '-', 'T', 'R', 'S', ' ', 'i', 's', ' ',
             'w', 'e', 'l', 'l', ' ', 'f', 'o', 'r', 'm', 'e', 'd'] .
          shows_nl));

check_tp_subsumesa ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      ([Term (Lab b c) [Prelude.Char]],
                        [(Term (Lab b c) [Prelude.Char],
                           Term (Lab b c) [Prelude.Char])])) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_tp_subsumesa i t tp =
  let {
    (nfsa, (q, rulesa)) = t;
    nfs = nfsb i tp;
    rules = rulesc i tp;
    qa = qb i tp;
  } in catcha
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list Zero_nat
               ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ',
                 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
                 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm', 'a', 'l', '-',
                 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a', 'g', 's']))
           (\ _ ->
             bindb (catcha (check_subseteq rulesa rules)
                     (\ x ->
                       Inl (toomuch ['r', 'u', 'l', 'e'] (shows_rulea x))))
               (\ _ ->
                 catcha (check_NF_terms_subset q qa)
                   (\ x ->
                     Inl (shows_prec_list Zero_nat
                            ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f', 'f',
                              'e', 'r', 's', ' ', 'd', 'u', 'e', ' ', 't', 'o',
                              ' ', 't', 'e', 'r', 'm', ' '] .
                           shows_term (shows_prec_lab Zero_nat)
                             (shows_prec_list Zero_nat) x)))))
         (\ x ->
           Inl (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

check_non_loop_trs_prf ::
  forall a b c d.
    (Eq b, Linorder b, Showa b, Cenum c, Ceq c, Corder c, Eq c, Mapping_impl c,
      Linorder c, Set_impl c,
      Showa c) => Tp_ops_ext a b c d ->
                    a -> Non_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_non_loop_trs_prf i tp prf =
  let {
    r = rulesc i tp;
  } in bindb (check (null (qb i tp))
               (shows_prec_list Zero_nat
                 ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'f', 'o', 'r',
                   ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p', 's', ' ', 'u',
                   'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
         (\ _ -> check_non_loop_prf r [] prf);

uncurry_nonterm_tt_check ::
  forall a b.
    (Eq b,
      Showa b) => Tp_ops_ext a b [Prelude.Char] () ->
                    (b, ([((b, Nat), [b])],
                          ([(Term b [Prelude.Char], Term b [Prelude.Char])],
                            [(Term b [Prelude.Char],
                               Term b [Prelude.Char])]))) ->
                      ([((b, Nat), [b])] -> b -> Nat -> b) ->
                        (b -> Nat ->
                                [((b, Nat), [b])] ->
                                  Sum ([Prelude.Char] -> [Prelude.Char]) ()) ->
                          [(Term b [Prelude.Char], Term b [Prelude.Char])] ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_nonterm_tt_check i info fmap check_inj r dpp =
  let {
    (a, (sml, (u, e))) = info;
    ra = rulesc i dpp;
    nfs = nfsb i dpp;
    sm = sig_list_to_sig_map a sml fmap;
    r_eta = e ++ ra;
    uR = uncurry_rules a sm r_eta;
  } in (case bindb (check (null (qb i dpp))
                     (shows_prec_list Zero_nat
                       ['s', 't', 'r', 'a', 't', 'e', 'g', 'y', ' ', 'n', 'o',
                         't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd',
                         ' ', 'f', 'o', 'r', ' ', 'u', 'n', 'c', 'u', 'r', 'r',
                         'y', 'i', 'n', 'g']))
               (\ _ ->
                 let {
                   s = uncurry_of_sig_list a sml sm;
                 } in bindb (only_eta_rules e r_eta)
                        (\ _ ->
                          bindb (check_inj a (Nat_of_num (Bit0 One)) sml)
                            (\ _ ->
                              bindb (catcha (check_CS_subseteq u s)
                                      (\ x ->
Inl (shows_prec_list Zero_nat ['r', 'u', 'l', 'e', ' '] .
      shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
        [' ', '-', '>', ' '] x .
        shows_prec_list Zero_nat
          [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'u', 'n', 'c',
            'u', 'r', 'r', 'y', ' ', 'r', 'u', 'l', 'e'])))
                                (\ _ ->
                                  catcha (check_subseteq r (u ++ uR))
                                    (\ x ->
                                      Inl
(shows_prec_list Zero_nat ['r', 'u', 'l', 'e', ' '] .
  shows_rule (shows_prec Zero_nat) (shows_prec_list Zero_nat)
    [' ', '-', '>', ' '] x .
    shows_prec_list Zero_nat
      [' ', 'i', 's', ' ', 'n', 'e', 'i', 't', 'h', 'e', 'r', ' ', 'u', 'n',
        'c', 'u', 'r', 'r', 'i', 'e', 'd', ' ', 'r', 'u', 'l', 'e', 's', ' ',
        'n', 'o', 'r', ' ', 'u', 'n', 'c', 'u', 'r', 'r', 'y', ' ', 'r', 'u',
        'l', 'e']))))))
         of {
         Inl aa -> Inl aa;
         Inr _ -> Inr (mkb i nfs [] r []);
       });

uncurry_nonterm_tt ::
  forall a b c.
    (Eq b, Showa b, Eq c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Uncurry_nt_proof b c [Prelude.Char] ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
uncurry_nonterm_tt i (Uncurry_nt_proof (a, (sml, (u, e))) r) tp =
  uncurry_nonterm_tt_check i (a, (sml, (u, e))) (fmap a (Nat_of_num (Bit0 One)))
    check_inj r tp;

rule_removal_nonterm_reltrs ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rule_removal_nonterm_reltrs_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_removal_nonterm_reltrs i tp (Rule_removal_nonterm_reltrs_prf r s) =
  let {
    rrm = (if is_none r then [] else ceta_list_diff (rb i tp) (the r));
    srm = (if is_none s then [] else ceta_list_diff (rwb i tp) (the s));
  } in Inr (delete_R_Rwb i tp rrm srm);

check_rel_tp_subsumes ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    (Bool,
                      ([Term (Lab b c) [Prelude.Char]],
                        ([(Term (Lab b c) [Prelude.Char],
                            Term (Lab b c) [Prelude.Char])],
                          [(Term (Lab b c) [Prelude.Char],
                             Term (Lab b c) [Prelude.Char])]))) ->
                      a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_tp_subsumes i t tp =
  let {
    (nfsa, (q, (r, rw))) = t;
    nfs = nfsb i tp;
    rules = rulesc i tp;
    ra = rb i tp;
    qa = qb i tp;
  } in catcha
         (bindb
           (check (if not (null q) then (if nfs then nfsa else True) else True)
             (shows_prec_list Zero_nat
               ['i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ',
                 's', 'u', 'b', 's', 't', 'i', 't', 'u', 't', 'i', 'o', 'n',
                 's', '-', 'i', 'n', '-', 'n', 'o', 'r', 'm', 'a', 'l', '-',
                 'f', 'o', 'r', 'm', ' ', 'f', 'l', 'a', 'g', 's']))
           (\ _ ->
             bindb (catcha (check_subseteq rw rules)
                     (\ x ->
                       Inl (toomuch ['r', 'u', 'l', 'e'] (shows_rulea x))))
               (\ _ ->
                 bindb (catcha (check_subseteq r ra)
                         (\ x ->
                           Inl (toomuch ['r', 'u', 'l', 'e'] (shows_rulea x))))
                   (\ _ ->
                     catcha (check_NF_terms_subset q qa)
                       (\ x ->
                         Inl (shows_prec_list Zero_nat
                                ['N', 'F', '(', 'Q', ')', ' ', 'd', 'i', 'f',
                                  'f', 'e', 'r', 's', ' ', 'd', 'u', 'e', ' ',
                                  't', 'o', ' ', 't', 'e', 'r', 'm', ' '] .
                               shows_term (shows_prec_lab Zero_nat)
                                 (shows_prec_list Zero_nat) x))))))
         (\ x ->
           Inl (shows_prec_list Zero_nat
                  ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 's',
                    'h', 'o', 'w', 'i', 'n', 'g', ' ', 's', 'u', 'b', 's', 'u',
                    'm', 'p', 't', 'i', 'o', 'n', ' ', 'f', 'o', 'r', ' ', 'n',
                    'o', 'n', '-', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                    'o', 'n'] .
                 shows_nl . x));

check_not_wf_reltrs ::
  forall a b c.
    (Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_not_wf_reltrs i tp =
  bindb (check (q_emptyb i tp)
          (shows_prec_list Zero_nat
            ['c', 'u', 'r', 'r', 'e', 'n', 't', 'l', 'y', ' ', 'o', 'n', 'l',
              'y', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'Q', ' ', 'i', 's', ' ',
              's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd']))
    (\ _ ->
      check (not (isOK (check_wf_reltrs (rb i tp, rwb i tp))))
        (shows_string
           ['T', 'h', 'e', ' ', 'T', 'R', 'S', 's', ' ', 'R', ' ', 'a', 'n',
             'd', ' ', 'S', ' ', 'a', 'r', 'e', ' ', 'w', 'e', 'l', 'l', ' ',
             'f', 'o', 'r', 'm', 'e', 'd'] .
          shows_nl));

reltrs_as_trs ::
  forall a b c.
    Tp_ops_ext a b c () -> a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
reltrs_as_trs i tp =
  let {
    q = qb i tp;
    r = rb i tp;
    nfs = nfsb i tp;
    a = mkb i nfs q r [];
  } in Inr a;

check_rel_trs_loop ::
  forall a b c.
    (Eq b, Showa b, Corder c, Eq c, Mapping_impl c,
      Showa c) => Tp_ops_ext a b c () ->
                    a -> Rel_trs_loop_prf b c ->
                           Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_rel_trs_loop i tp (Rel_trs_loop_prf s rseq sigma c) =
  bindb (check (q_emptyb i tp)
          (shows_prec_list Zero_nat
            ['Q', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm', 'p', 't',
              'y']))
    (\ _ -> check_rel_loop s rseq sigma c (rb i tp) (rwb i tp));

check_reltrs_nontermination_proof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Reltrs_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_reltrs_nontermination_proof ia j assms i tp (Rel_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catcha (check_rel_trs_loop ia tp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'l',
                     'o', 'o', 'p', ' ', 'p', 'r', 'o', 'o', 'f'] .
                   shows_nl . x)));
check_reltrs_nontermination_proof ia j assms i tp (Rel_R_Not_SN prf) =
  bindb (reltrs_as_trs ia tp)
    (\ tpa ->
      catcha
        (check_trs_nontermination_proof ia j assms
          (i . shows_stringa ['.', '1']) tpa prf)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                       'o', 'w', ' ', 't', 'h', 'e', ' ', 'n', 'o', 'n', 't',
                       'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                       'p', 'r', 'o', 'o', 'f', ' ', 'f', 'o', 'r', ' ', 'R'] .
                     shows_nl . indent x)));
check_reltrs_nontermination_proof ia j assms i tp Rel_Not_Well_Formed =
  debug (i [])
    ['N', 'o', 't', ' ', 'W', 'e', 'l', 'l', '-', 'F', 'o', 'r', 'm', 'e', 'd']
    (catcha (check_not_wf_reltrs ia tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'n',
                     'o', 't', '-', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm',
                     'e', 'd', ' ', 'p', 'r', 'o', 'o', 'f'] .
                   shows_nl . x)));
check_reltrs_nontermination_proof ia j assms i tp (Rel_TRS_String_Reversal prf)
  = debug (i [])
      ['S', 't', 'r', 'i', 'n', 'g', ' ', 'R', 'e', 'v', 'e', 'r', 's', 'a',
        'l']
      (bindb
        (catcha (string_reversal_complete_rel_tt ia tp)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                         'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                         's', 't', 'r', 'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e',
                         'r', 's', 'a', 'l', ' ', 'o', 'n'] .
                       shows_nl .
                         shows_tp (shows_prec_lab Zero_nat)
                           (shows_prec_list Zero_nat) ia tp .
                           shows_nl . x)))
        (\ tpa ->
          catcha
            (check_reltrs_nontermination_proof ia j assms
              (i . shows_stringa ['.', '1']) tpa prf)
            (\ x ->
              Inl (i . shows_string
                         [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                           'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 't', 'r',
                           'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e', 'r', 's',
                           'a', 'l', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q',
                           'u', 'e'] .
                         shows_nl . indent x))));
check_reltrs_nontermination_proof ia j assms i tp (Rel_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_reltrs ia tp p)
      (\ tpa ->
        catcha
          (check_reltrs_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_reltrs_nontermination_proof ia j assms i tp (Rel_TRS_Assume_Not_SN t ass)
  = debug (i [])
      ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's',
        'u', 'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k',
        'n', 'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
      (if assms
        then bindb (catcha (check_rel_tp_subsumes ia t tp)
                     (\ x ->
                       Inl (i . shows_string
                                  [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                    'n', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r',
                                    'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                                    'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                                    'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n',
                                    'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o',
                                    'f'] .
                                  shows_nl . x . shows_nl)))
               (\ _ ->
                 catcha
                   (catcha
                     (forallM_index
                       (\ asa ja ->
                         check_assma ia j
                           (check_trs_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat Zero_nat
                                      (plus_nat ja (Nat_of_num One))))
                           (check_dp_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat Zero_nat
                                      (plus_nat ja (Nat_of_num One))))
                           (check_reltrs_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat Zero_nat
                                      (plus_nat ja (Nat_of_num One))))
                           (check_fp_nontermination_proof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat Zero_nat
                                      (plus_nat ja (Nat_of_num One))))
                           (check_unknown_disproof ia j assms
                             (i . shows_string ['.'] .
                                    shows_prec_nat Zero_nat
                                      (plus_nat ja (Nat_of_num One))))
                           asa)
                       ass)
                     (\ x -> Inl (snd x)))
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n',
                                  'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . indent x)))
        else Inl (i . shows_string
                        [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                          ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                          'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                          'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                          'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                        shows_nl));

check_trs_nontermination_proof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          a -> Trs_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_trs_nontermination_proof ia j assms i tp (TRS_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catcha (check_trs_loop ia tp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'l', 'o',
                     'o', 'p', ' ', 'o', 'f', ' '] .
                   shows_nl .
                     shows_tp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) ia tp .
                       shows_nl . indent x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Nonloop p) =
  debug (i []) ['N', 'o', 'n', 'l', 'o', 'o', 'p']
    (catcha (check_non_loop_trs_prf ia tp p)
      (\ x ->
        Inl (shows_prec_list Zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
                 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'p', 'o', 's', 's', 'i',
                 'b', 'l', 'y', ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p',
                 'i', 'n', 'g', ' ', 'i', 'n', 'f', 'i', 'n', 'i', 't', 'e',
                 ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'f',
                 'o', 'r', ' '] .
              shows_nl .
                shows_tp (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) ia
                  tp .
                  indent x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Nonloop_SRS p) =
  debug (i []) ['N', 'o', 'n', 'l', 'o', 'o', 'p', ' ', 'S', 'R', 'S']
    (catcha (check_non_loop_srs_prf ia tp p)
      (\ x ->
        Inl (shows_prec_list Zero_nat
               ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c', 'h',
                 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'p', 'o', 's', 's', 'i',
                 'b', 'l', 'y', ' ', 'n', 'o', 'n', '-', 'l', 'o', 'o', 'p',
                 'i', 'n', 'g', ' ', 'i', 'n', 'f', 'i', 'n', 'i', 't', 'e',
                 ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n', ' ', 'f',
                 'o', 'r', ' '] .
              shows_nl .
                shows_tp (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) ia
                  tp .
                  indent x)));
check_trs_nontermination_proof ia j assms i tp TRS_Not_Well_Formed =
  debug (i [])
    ['N', 'o', 't', ' ', 'W', 'e', 'l', 'l', '-', 'F', 'o', 'r', 'm', 'e', 'd']
    (catcha (check_not_wwf_qtrs ia tp)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'n',
                     'o', 't', ' ', 'w', 'e', 'l', 'l', '-', 'f', 'o', 'r', 'm',
                     'e', 'd', ' ', 'p', 'r', 'o', 'o', 'f'] .
                   shows_nl . x)));
check_trs_nontermination_proof ia j assms i tp (TRS_Termination_Switch p prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', ' ', 't', 'o', ' ', 'T', 'e', 'r', 'm', 'i',
      'n', 'a', 't', 'i', 'o', 'n']
    (bindb
      (catcha (switch_termination_tt ia p tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'f', 'u', 'l', 'l', ' ', 's', 't', 'r', 'a',
                       't', 'e', 'g', 'y', ' ', 'f', 'o', 'r', ' ', 't', 'h',
                       'e', ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e',
                       'm', ' '] .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . indent x)))
      (\ tpa ->
        catcha
          (check_trs_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm',
                         'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 's', 'w', 'i',
                         't', 'c', 'h', ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q',
                         'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_trs ia tp p)
      (\ tpa ->
        catcha
          (check_trs_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_String_Reversal prf) =
  debug (i [])
    ['S', 't', 'r', 'i', 'n', 'g', ' ', 'R', 'e', 'v', 'e', 'r', 's', 'a', 'l']
    (bindb
      (catcha (string_reversal_complete_tt ia tp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       's', 't', 'r', 'i', 'n', 'g', ' ', 'r', 'e', 'v', 'e',
                       'r', 's', 'a', 'l', ' ', 'o', 'n'] .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catcha
          (check_trs_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 's', 't', 'r', 'i',
                         'n', 'g', ' ', 'r', 'e', 'v', 'e', 'r', 's', 'a', 'l',
                         ' ', 't', 'e', 'c', 'h', 'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Constant_String p prf) =
  debug (i [])
    ['C', 'o', 'n', 's', 't', 'a', 'n', 't', 's', ' ', 'i', 'n', 't', 'o', ' ',
      'U', 'n', 'a', 'r', 'y']
    (bindb
      (catcha (const_to_string_complete_tt ia tp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 't', 'u', 'r', 'n', 'i', 'n', 'g', ' ', 'c',
                       'o', 'n', 's', 't', 'a', 'n', 't', 's', ' ', 'i', 'n',
                       't', 'o', ' ', 's', 't', 'r', 'i', 'n', 'g', 's', ' ',
                       'o', 'n'] .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . x)))
      (\ tpa ->
        catcha
          (check_trs_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 's',
                         't', 'a', 'n', 't', 's', ' ', 'i', 'n', 't', 'o', ' ',
                         's', 't', 'r', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_DP_Trans p prf) =
  debug (i [])
    ['D', 'P', ' ', 'T', 'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
      'o', 'n']
    (bindb
      (catcha (dp_trans_nontermination_tt ia j tp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       'D', 'P', ' ', 't', 'r', 'a', 'n', 's', 'f', 'o', 'r',
                       'm', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'n'] .
                     shows_nl .
                       shows_tp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) ia tp .
                         shows_nl . x)))
      (\ dpp ->
        catcha
          (check_dp_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) dpp prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'D', 'P', ' ', 't',
                         'r', 'a', 'n', 's', 'f', 'o', 'r', 'm', 'a', 't', 'i',
                         'o', 'n'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Q_Increase p prf) =
  debug (i []) ['Q', ' ', 'i', 'n', 'c', 'r', 'e', 'a', 's', 'e']
    (bindb (q_increase_nonterm_trs ia tp p)
      (\ tpa ->
        catcha
          (check_trs_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', ' ', 'i', 'n',
                         'c', 'r', 'e', 'a', 's', 'e', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Uncurry p prf) =
  debug (i []) ['U', 'n', 'c', 'u', 'r', 'r', 'y', 'i', 'n', 'g']
    (bindb (uncurry_nonterm_tt ia p tp)
      (\ tpa ->
        catcha
          (check_trs_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) tpa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'u', 'n', 'c', 'u',
                         'r', 'r', 'y', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                         'n', 'i', 'q', 'u', 'e'] .
                       shows_nl . indent x))));
check_trs_nontermination_proof ia j assms i tp (TRS_Assume_Not_SN t ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catcha (check_tp_subsumesa ia t tp)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r',
                                  'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                                  'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                                  'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n',
                                  'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catcha
                 (catcha
                   (forallM_index
                     (\ asa ja ->
                       check_assma ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_unknown_disproof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_fp_nontermination_proof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b c) [Prelude.Char],
                              (Term (Lab b c) [Prelude.Char], Location))],
                            [(Term (Lab b c) [Prelude.Char],
                               Term (Lab b c) [Prelude.Char])]) ->
                            Fp_nontermination_proof b c [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fp_nontermination_proof ia j assms i (pa, r) (FPTRS_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catcha (check_fploop r pa p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n',
                     ' ', 'c', 'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'f', 'o',
                     'r', 'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a', 't', 't',
                     'e', 'r', 'n', ' ', 'l', 'o', 'o', 'p'] .
                   shows_nl . indent x)));
check_fp_nontermination_proof ia j assms i (pa, r) (FPTRS_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_trs ia (mkb ia False [] r []) p)
      (\ tp ->
        catcha
          (check_fp_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) (pa, rulesc ia tp) prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                         ' ', 'r', 'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_fp_nontermination_proof ia j assms i tp (FPTRS_Assume_Not_SN t ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catcha (check_fp_tp_subsumes t tp)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'n', 'o', 'n', '-', 't', 'e', 'r',
                                  'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                                  'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                                  'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n',
                                  'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catcha
                 (catcha
                   (forallM_index
                     (\ asa ja ->
                       check_assma ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_unknown_disproof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_dp_nontermination_proof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          d -> Dp_nontermination_proof b c [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_nontermination_proof ia j assms i dpp (DP_Loop p) =
  debug (i []) ['L', 'o', 'o', 'p']
    (catcha (check_dp_loop j dpp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                     'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'l', 'o', 'o', 'p',
                     ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ', 'f', 'o', 'l',
                     'l', 'o', 'w', 'i', 'n', 'g', ' ', 'D', 'P', '-', 'p', 'r',
                     'o', 'b', 'l', 'e', 'm', ' '] .
                   shows_nl .
                     shows_dpp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) j dpp .
                       shows_nl . indent x)));
check_dp_nontermination_proof ia j assms i dpp (DP_Nonloop p) =
  debug (i []) ['N', 'o', 'n', 'l', 'o', 'o', 'p']
    (catcha (check_non_loop_dp_prf j dpp p)
      (\ x ->
        Inl (i . shows_string
                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'c',
                     'h', 'e', 'c', 'k', 'i', 'n', 'g', ' ', 'n', 'o', 'n', 'l',
                     'o', 'o', 'p', ' ', 'f', 'o', 'r', ' ', 't', 'h', 'e', ' ',
                     'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'D', 'P',
                     '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm', ' '] .
                   shows_nl .
                     shows_dpp (shows_prec_lab Zero_nat)
                       (shows_prec_list Zero_nat) j dpp .
                       shows_nl . indent x)));
check_dp_nontermination_proof ia j assms i dpp (DP_Rule_Removal p prf) =
  debug (i []) ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l']
    (bindb (rule_removal_nonterm_dp j dpp p)
      (\ dppa ->
        catcha
          (check_dp_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'i', 'r',
                         ' ', 'a', 'n', 'd', ' ', 'r', 'u', 'l', 'e', ' ', 'r',
                         'e', 'm', 'o', 'v', 'a', 'l'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Q_Reduction p prf) =
  debug (i []) ['Q', ' ', 'r', 'e', 'd', 'u', 'c', 't', 'i', 'o', 'n']
    (bindb
      (catcha (dp_q_reduction_nonterm j dpp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       'r', 'e', 'd', 'u', 'c', 'i', 'n', 'g', ' ', 't', 'h',
                       'e', ' ', 'i', 'n', 'n', 'e', 'r', 'm', 'o', 's', 't',
                       ' ', 'l', 'h', 's', 's', ' ', 'i', 'n', ' ', 't', 'h',
                       'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                       ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e', 'm',
                       ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catcha
          (check_dp_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', ' ', 'r', 'e',
                         'd', 'u', 'c', 't', 'i', 'o', 'n'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Q_Increase p prf) =
  debug (i []) ['Q', ' ', 'i', 'n', 'c', 'r', 'e', 'a', 's', 'e']
    (bindb (q_increase_nonterm_dp j dpp p)
      (\ dppa ->
        catcha
          (check_dp_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'Q', ' ', 'i', 'n',
                         'c', 'r', 'e', 'a', 's', 'e'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Termination_Switch p prf) =
  debug (i [])
    ['S', 'w', 'i', 't', 'c', 'h', ' ', 't', 'o', ' ', 'T', 'e', 'r', 'm', 'i',
      'n', 'a', 't', 'i', 'o', 'n']
    (bindb
      (catcha (switch_termination_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                       's', 'w', 'i', 't', 'c', 'h', 'i', 'n', 'g', ' ', 't',
                       'o', ' ', 'f', 'u', 'l', 'l', ' ', 's', 't', 'r', 'a',
                       't', 'e', 'g', 'y', ' ', 'f', 'o', 'r', ' ', 't', 'h',
                       'e', ' ', 'D', 'P', '-', 'p', 'r', 'o', 'b', 'l', 'e',
                       'm', ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catcha
          (check_dp_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 't', 'e', 'r', 'm',
                         'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 's', 'w', 'i',
                         't', 'c', 'h', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's',
                         'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Instantiation p prf) =
  debug (i []) ['I', 'n', 's', 't', 'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n']
    (bindb
      (catcha (instantiation_complete_proc j dpp p)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'i', 'n', 's', 't', 'a', 'n', 't',
                       'i', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'c',
                       'e', 's', 's', 'o', 'r', ' ', 'o', 'n', ' '] .
                     shows_nl .
                       shows_dpp (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) j dpp .
                         shows_nl . indent x)))
      (\ dppa ->
        catcha
          (check_dp_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'i', 'n', 's', 't',
                         'a', 'n', 't', 'i', 'a', 't', 'i', 'o', 'n', ' ', 'p',
                         'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Rewriting p prf) =
  debug (i []) ['R', 'e', 'w', 'r', 'i', 't', 'i', 'n', 'g']
    (bindb
      (catcha (rewriting_complete_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'r', 'e', 'w', 'r', 'i', 't', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r'] .
                     shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Narrowing p prf) =
  debug (i []) ['N', 'a', 'r', 'r', 'o', 'w', 'i', 'n', 'g']
    (bindb
      (catcha (narrowing_complete_proc j p dpp)
        (\ x ->
          Inl (i . shows_string
                     [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                       'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                       't', 'h', 'e', ' ', 'n', 'a', 'r', 'r', 'o', 'w', 'i',
                       'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e', 's', 's', 'o',
                       'r'] .
                     shows_nl . x)))
      (\ dppa ->
        catcha
          (check_dp_nontermination_proof ia j assms
            (i . shows_stringa ['.', '1']) dppa prf)
          (\ x ->
            Inl (i . shows_string
                       [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                         'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'w', 'r',
                         'i', 't', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 'c', 'e',
                         's', 's', 'o', 'r'] .
                       shows_nl . indent x))));
check_dp_nontermination_proof ia j assms i dpp (DP_Assume_Infinite dp ass) =
  debug (i [])
    ['F', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'A', 's', 's', 'u',
      'm', 'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ', 'U', 'n', 'k', 'n', 'o',
      'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catcha (check_dpp_subsumesa j dp dpp)
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'f', 'i', 'n', 'i', 't', 'e', 'n',
                                  'e', 's', 's', ' ', 'a', 's', 's', 'u', 'm',
                                  'p', 't', 'i', 'o', 'n', ' ', 'o', 'r', ' ',
                                  'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                                  'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catcha
                 (catcha
                   (forallM_index
                     (\ asa ja ->
                       check_assma ia j
                         (check_trs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_dp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_reltrs_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_fp_nontermination_proof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         (check_unknown_disproof ia j assms
                           (i . shows_string ['.'] .
                                  shows_prec_nat Zero_nat
                                    (plus_nat ja (Nat_of_num One))))
                         asa)
                     ass)
                   (\ x -> Inl (snd x)))
                 (\ x ->
                   Inl (i . shows_string
                              [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                                'l', 'o', 'w', ' ', 'u', 'n', 'k', 'n', 'o',
                                'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                              shows_nl . indent x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'a', 's', 's', 'u', 'm', 'p', 't', 'i', 'o',
                        'n', ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o', 'w',
                        'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                      shows_nl));

check_unknown_disproof ::
  forall a b c d.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a (Lab b c) [Prelude.Char] () ->
                    Dpp_ops_ext d (Lab b c) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Neg_unknown_proof b c [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_disproof ia j assms i tpa (Assume_NT_Unknown tp ass) =
  debug (i []) ['U', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'P', 'r', 'o', 'o', 'f']
    (if assms
      then bindb (catcha
                   (check (tpa == tp)
                     (shows_prec_list Zero_nat
                        ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o',
                          'b', 'l', 'e', 'm', 's', ' ', 'a', 'r', 'e', ' ', 'n',
                          'o', 't', ' ', 'i', 'd', 'e', 'n', 't', 'i', 'c', 'a',
                          'l', ':', ' '] .
                       shows_nl .
                         shows_prec_list Zero_nat tpa .
                           shows_nl .
                             shows_prec_list Zero_nat [' ', 'v', 's', ' '] .
                               shows_nl . shows_prec_list Zero_nat tp))
                   (\ x ->
                     Inl (i . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i',
                                  'n', ' ', 'n', 'o', 'n', 't', 'e', 'r', 'm',
                                  'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'a',
                                  's', 's', 'u', 'm', 'p', 't', 'i', 'o', 'n',
                                  ' ', 'o', 'r', ' ', 'u', 'n', 'k', 'n', 'o',
                                  'w', 'n', ' ', 'p', 'r', 'o', 'o', 'f'] .
                                shows_nl . x . shows_nl)))
             (\ _ ->
               catcha
                 (forallM_index
                   (\ asa ja ->
                     check_assma ia j
                       (check_trs_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_dp_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_reltrs_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_fp_nontermination_proof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       (check_unknown_disproof ia j assms
                         (i . shows_string ['.'] .
                                shows_prec_nat Zero_nat
                                  (plus_nat ja (Nat_of_num One))))
                       asa)
                   ass)
                 (\ x -> Inl (snd x)))
      else Inl (i . shows_string
                      [':', ' ', 't', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f',
                        ' ', 'c', 'o', 'n', 't', 'a', 'i', 'n', 's', ' ', 'a',
                        'n', ' ', 'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p',
                        'r', 'o', 'o', 'f'] .
                      shows_nl));

shows_conditions ::
  forall a b.
    (Showa a,
      Showa b) => [(Term a b, Term a b)] ->
                    Bool -> [Prelude.Char] -> [Prelude.Char];
shows_conditions [] uu = id;
shows_conditions (x : xs) b =
  shows_prec_list Zero_nat (if b then [' ', '|', ' '] else [',', ' ']) .
    shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
      [' ', '-', '>', '*', ' '] x .
      shows_conditions xs False;

shows_crule ::
  forall a b.
    (Showa a,
      Showa b) => ((Term a b, Term a b), [(Term a b, Term a b)]) ->
                    [Prelude.Char] -> [Prelude.Char];
shows_crule cr =
  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) [' ', '-', '>', ' ']
    (fst cr) .
    shows_conditions (snd cr) True;

rhs_n ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Term a b;
rhs_n u (lr, cs) n =
  (if less_nat n (size_list cs) then ctxt_apply (u (lr, cs) n) (fst (nth cs n))
    else snd lr);

lhs_n ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Term a b;
lhs_n u (lr, cs) n =
  (if equal_nat n Zero_nat then fst lr
    else ctxt_apply (u (lr, cs) (minus_nat n (Nat_of_num One)))
           (snd (nth cs (minus_nat n (Nat_of_num One)))));

rules_impla ::
  forall a b.
    (((Term a b, Term a b), [(Term a b, Term a b)]) -> Nat -> Ctxt a b) ->
      ((Term a b, Term a b), [(Term a b, Term a b)]) -> [(Term a b, Term a b)];
rules_impla u cr =
  map (\ i -> (lhs_n u cr i, rhs_n u cr i))
    (upt Zero_nat (plus_nat (size_list (snd cr)) (Nat_of_num One)));

create_ctxts :: forall a b. [(Term a b, Term a b)] -> Maybe (Nat -> Ctxt a b);
create_ctxts r =
  (case r of {
    [] -> Nothing;
    _ : rr ->
      bind (mapMa
             (\ a ->
               (case a of {
                 (Var _, _) -> Nothing;
                 (Fun u [], _) -> Nothing;
                 (Fun u (_ : ts), _) -> Just (More u [] Hole ts);
               }))
             rr)
        (\ cs ->
          let {
            _ = size_list cs;
          } in Just (\ i ->
                      (if less_nat i (size_list cs) then nth cs i else Hole)));
  });

create_U ::
  forall a b.
    (Eq a,
      Eq b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                  [(Term a b, Term a b)])] ->
                 Maybe (((Term a b, Term a b), [(Term a b, Term a b)]) ->
                         Nat -> Ctxt a b);
create_U c_rs =
  bind (mapMa
         (\ (cr, rs) ->
           bind (guarda
                  (equal_nat (size_list rs)
                    (plus_nat (size_list (snd cr)) (Nat_of_num One))))
             (\ _ -> bind (create_ctxts rs) (\ ctxt -> Just (cr, ctxt))))
         c_rs)
    (\ cr_ctxts ->
      let {
        m = map_of cr_ctxts;
      } in Just (\ cr ->
                  (case m cr of {
                    Nothing -> (\ _ -> Hole);
                    Just ctxt -> ctxt;
                  })));

check_unraveling ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(((Term a b, Term a b), [(Term a b, Term a b)]),
                     [(Term a b, Term a b)])] ->
                    [((Term a b, Term a b), [(Term a b, Term a b)])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        [(Term a b, Term a b)];
check_unraveling c_rs ctrs =
  catcha
    (bindb
      (catcha (check_subseteq ctrs (map fst c_rs))
        (\ x ->
          Inl (shows_prec_list Zero_nat
                 ['d', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i', 'n', 'd',
                   ' ', 'r', 'u', 'l', 'e', ' '] .
                shows_crule x . shows_nl)))
      (\ _ ->
        bindb (case create_U c_rs of {
                Nothing ->
                  Inl (shows_prec_list Zero_nat
                        ['u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'e',
                          'x', 't', 'r', 'a', 'c', 't', ' ', 'u', 'n', 'r', 'a',
                          'v', 'e', 'l', 'i', 'n', 'g', ' ', 'c', 'o', 'n', 't',
                          'e', 'x', 't', 's']);
                Just a -> Inr a;
              })
          (\ u ->
            bindb (catcha
                    (forallM
                      (\ (c, rs) ->
                        check (rules_impla u c == rs)
                          (shows_prec_list Zero_nat
                             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'i',
                               't', 'h', ' ', 'r', 'u', 'l', 'e', 's', ' ', 'o',
                               'f', ' '] .
                            shows_crule c . shows_nl))
                      c_rs)
                    (\ x -> Inl (snd x)))
              (\ _ -> Inr (concatMap snd c_rs)))))
    (\ x ->
      Inl (shows_prec_list Zero_nat
             ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'u', 'n',
               'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g', ' '] .
            shows_nl . x));

check_quasi_reductive_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [((Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]),
                             [(Term (Lab b [Nat]) [Prelude.Char],
                                Term (Lab b [Nat]) [Prelude.Char])])] ->
                            Quasi_reductive_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_quasi_reductive_proof a ia i j ctrs (Unravel u_info prf) =
  debug (ia []) ['U', 'n', 'r', 'a', 'v', 'e', 'l']
    (bindb
      (catcha (check_unraveling u_info ctrs)
        (\ x ->
          Inl (ia . shows_string
                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ',
                        'u', 'n', 'r', 'a', 'v', 'e', 'l', 'i', 'n', 'g'] .
                      shows_nl . indent x)))
      (\ r ->
        let {
          tp = mkb i False [] r [];
        } in catcha
               (check_trs_termination_proof i j a (ia . shows_string ['.', '1'])
                 tp prf)
               (\ x ->
                 Inl (ia . shows_string
                             [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e',
                               'l', 'o', 'w', ' ', 's', 't', 'r', 'o', 'n', 'g',
                               ' ', 'n', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a',
                               't', 'i', 'o', 'n', ' ', '+', ' ', 'w', 'c',
                               'r'] .
                             shows_nl . indent x))));

check_estep ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    Pos ->
                      (Term a b, Term a b) ->
                        Bool ->
                          Term a b ->
                            Term a b ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_estep e p rule l_to_r s t =
  bindb (check (any (eq_rule_mod_vars rule) e)
          (shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
             [' ', '-', '>', ' '] rule .
            shows_string
              [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'n', ' ', 'e', 'q',
                'u', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f'] .
              shows_nl .
                shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
                  ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 's',
                    'y', 's', 't', 'e', 'm', ':']
                  [' ', '=', ' '] e .
                  shows_nl))
    (\ _ ->
      bindb (check (in_poss p s)
              (shows_prec_pos Zero_nat p .
                shows_string
                  [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p', 'o',
                    's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                  shows_prec_term Zero_nat s . shows_nl))
        (\ _ ->
          bindb (check (in_poss p t)
                  (shows_prec_pos Zero_nat p .
                    shows_string
                      [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'p',
                        'o', 's', 'i', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' '] .
                      shows_prec_term Zero_nat t . shows_nl))
            (\ _ ->
              let {
                c = ctxt_of_pos_term p s;
                d = ctxt_of_pos_term p t;
                u = subt_at s p;
                v = subt_at t p;
                rrule = (if l_to_r then rule else (snd rule, fst rule));
                err = shows_string
                        ['t', 'h', 'e', ' ', 't', 'e', 'r', 'm', ' '] .
                        shows_prec_term Zero_nat t .
                          shows_string
                            [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ',
                              'r', 'e', 's', 'u', 'l', 't', ' ', 'f', 'r', 'o',
                              'm', ' ', 'a', ' ', 'p', 'r', 'o', 'p', 'e', 'r',
                              ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i',
                              'o', 'n', ' ', 'o', 'f', ' ', 't', 'e', 'r', 'm',
                              ' '] .
                            shows_prec_term Zero_nat s .
                              shows_string
                                [' ', 'u', 's', 'i', 'n', 'g', ' ', 'e', 'q',
                                  'u', 'a', 't', 'i', 'o', 'n', ' '] .
                                shows_nl .
                                  shows_rule (shows_prec Zero_nat)
                                    (shows_prec Zero_nat) [' ', '=', ' ']
                                    rrule .
                                    shows_string
                                      [' ', 'a', 't', ' ', 'p', 'o', 's', 'i',
't', 'i', 'o', 'n', ' '] .
                                      shows_prec_pos Zero_nat p . shows_nl;
              } in (case match_list Var [(fst rrule, u), (snd rrule, v)] of {
                     Nothing -> Inl err;
                     Just _ -> check (equal_ctxt c d) err;
                   }))));

check_conversion ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Pos, ((Term a b, Term a b), (Bool, Term a b)))] ->
                      Term a b ->
                        Term a b -> Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_conversion e [] s u =
  check (equal_term s u)
    (shows_string
       ['t', 'h', 'e', ' ', 'l', 'a', 's', 't', ' ', 't', 'e', 'r', 'm', ' ',
         'o', 'f', ' ', 't', 'h', 'e', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's',
         'i', 'o', 'n', ' '] .
      shows_nl .
        shows_prec_term Zero_nat s .
          shows_nl .
            shows_string
              ['d', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
                'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 't', 'h', 'e',
                ' ', 'g', 'o', 'a', 'l', ' ', 't', 'e', 'r', 'm'] .
              shows_nl . shows_prec_term Zero_nat u . shows_nl);
check_conversion e ((p, (r, (l_to_r, t))) : c) s u =
  bindb (check_estep e p r l_to_r s t) (\ _ -> check_conversion e c t u);

check_subsumptions_guided ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [((Term a b, Term a b),
                       [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumptions_guided e [] = Inr ();
check_subsumptions_guided ea ((e, seq) : convs) =
  bindb (catcha (check_conversion ea seq (fst e) (snd e))
          (\ x ->
            Inl (shows_string
                   ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'i', 'n', ' ', 'c',
                     'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n', ' ', 'f', 'o',
                     'r', ' ', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n', ' '] .
                  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                    [' ', '=', ' '] e .
                    shows_nl . x)))
    (\ _ -> check_subsumptions_guided (e : ea) convs);

check_subsumption_guided ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      [((Term a b, Term a b),
                         [(Pos, ((Term a b, Term a b), (Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption_guided ea e convs =
  bindb (catcha (check_subseteq ea (map fst convs))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'f', 'i',
                     'n', 'd', ' ', 'c', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o',
                     'n', ' ', 'f', 'o', 'r', ' ', 'e', 'q', 'u', 'a', 't', 'i',
                     'o', 'n', ' '] .
                  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                    [' ', '=', ' '] x)))
    (\ _ -> check_subsumptions_guided e convs);

check_subsumption_NF ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption_NF e r =
  catcha
    (forallM
      (\ ea ->
        catcha (check_join_NF r (fst ea) (snd ea))
          (\ x ->
            Inl (shows_string
                   ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'j', 'o',
                     'i', 'n', ' ', 'e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
                     ' '] .
                  shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                    [' ', '=', ' '] ea .
                    shows_nl . x)))
      e)
    (\ x -> Inl (snd x));

check_subsumption ::
  forall a b.
    (Eq a, Showa a, Corder b, Eq b, Mapping_impl b,
      Showa b) => [(Term a b, Term a b)] ->
                    [(Term a b, Term a b)] ->
                      Maybe [((Term a b, Term a b),
                               [(Pos, ((Term a b, Term a b),
(Bool, Term a b)))])] ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_subsumption e r convs_o =
  (case convs_o of {
    Nothing -> check_subsumption_NF e r;
    Just a -> check_subsumption_guided e r a;
  });

check_completion_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])] ->
                              Completion_proof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_completion_proof a ia i j e r (SN_WCR_Eq joins_i prf conv1 conv2) =
  debug (ia []) ['S', 'N', '_', 'W', 'C', 'R', '_', 'E', 'q']
    (let {
       tp = mkb i False [] r [];
     } in bindb (catcha
                  (check_trs_termination_proof i j a
                    (ia . shows_string ['.', '1']) tp prf)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                  'e', 'l', 'o', 'w', ' ', 's', 't', 'r', 'o',
                                  'n', 'g', ' ', 'n', 'o', 'r', 'm', 'a', 'l',
                                  'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', '+',
                                  ' ', 'w', 'c', 'r'] .
                                shows_nl . indent x)))
            (\ _ ->
              bindb (catcha (check_subsumption_guided r e conv1)
                      (\ x ->
                        Inl (ia . shows_prec_list Zero_nat
                                    [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ',
                                      'w', 'h', 'e', 'n', ' ', 's', 'h', 'o',
                                      'w', 'i', 'n', 'g', ' ', 't', 'h', 'a',
                                      't', ' ', 'r', 'e', 'w', 'r', 'i', 't',
                                      'e', ' ', 'r', 'e', 'l', 'a', 't', 'i',
                                      'o', 'n', ' ', 'c', 'a', 'n', ' ', 'b',
                                      'e', ' ', 's', 'i', 'm', 'u', 'l', 'a',
                                      't', 'e', 'd', ' ', 'b', 'y', ' ', 'e',
                                      'q', 'u', 'a', 't', 'i', 'o', 'n', 's'] .
                                    shows_nl . indent x)))
                (\ _ ->
                  bindb (catcha (check_subsumption e r conv2)
                          (\ x ->
                            Inl (ia . shows_prec_list Zero_nat
[':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ', 's', 'h', 'o',
  'w', 'i', 'n', 'g', ' ', 't', 'h', 'a', 't', ' ', 'e', 'q', 'u', 'a', 't',
  'i', 'o', 'n', 's', ' ', 'c', 'a', 'n', ' ', 'b', 'e', ' ', 's', 'i', 'm',
  'u', 'l', 'a', 't', 'e', 'd', ' ', 'b', 'y', ' ', 'r', 'e', 'w', 'r', 'i',
  't', 'e', ' ', 's', 'y', 's', 't', 'e', 'm'] .
shows_nl . indent x)))
                    (\ _ ->
                      catcha
                        (check_critical_pairs r (critical_pairs_impl r r)
                          joins_i)
                        (\ x ->
                          Inl (ia . shows_prec_list Zero_nat
                                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ',
'w', 'h', 'e', 'n', ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g', ' ', 'l', 'o', 'c',
'a', 'l', ' ', 'c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'o', 'f',
' '] .
                                      shows_nl .
shows_tp (shows_prec_lab Zero_nat) (shows_prec_list Zero_nat) i tp .
  shows_nl . indent x))))));

check_equational_disproof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            (Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]) ->
                              Equational_disproof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_equational_disproof a ia i j e eq
  (Completion_and_Normalization_Different r p) =
  debug (ia [])
    ['C', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', '_', 'a', 'n', 'd', '_',
      'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n']
    (bindb (check_completion_proof a ia i j e r p)
      (\ _ ->
        let {
          s = fst eq;
          t = snd eq;
        } in (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
               (Nothing, b) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab Zero_nat)
                             (shows_prec_list Zero_nat) t);
               (Just sa, Nothing) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab Zero_nat)
                             (shows_prec_list Zero_nat) t);
               (Just sa, Just ta) ->
                 (if not (equal_term sa ta) then Inr ()
                   else Inl (shows_term (shows_prec_lab Zero_nat)
                               (shows_prec_list Zero_nat) s .
                              shows_string [' ', 'a', 'n', 'd', ' '] .
                                shows_term (shows_prec_lab Zero_nat)
                                  (shows_prec_list Zero_nat) t .
                                  shows_string
                                    [' ', 'h', 'a', 'v', 'e', ' ', 's', 'a',
                                      'm', 'e', ' ', 'n', 'o', 'r', 'm', 'a',
                                      'l', ' ', 'f', 'o', 'r', 'm', ' '] .
                                    shows_term (shows_prec_lab Zero_nat)
                                      (shows_prec_list Zero_nat) sa));
             })));

check_fptrs_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          ([(Ctxt (Lab b [Nat]) [Prelude.Char],
                              (Term (Lab b [Nat]) [Prelude.Char], Location))],
                            [(Term (Lab b [Nat]) [Prelude.Char],
                               Term (Lab b [Nat]) [Prelude.Char])]) ->
                            Fptrs_termination_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_fptrs_termination_proof ia j a i tp prf =
  check_fptrs_termination_proof_main ia j a i tp (unlab_to_split_otrs prf);

eq_proof_lines ::
  forall a b.
    (Showa a,
      Showa b) => Eq_proof a b ->
                    Nat ->
                      ([Prelude.Char] -> [Prelude.Char],
                        (Nat, (Term a b, Term a b)));
eq_proof_lines (Refl s) i =
  ((shows_nl .
     shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) .
       shows_string [':', ' ']) .
     shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) [' ', '=', ' ']
       (s, s) .
       shows_string [' ', '[', 'r', 'e', 'f', 'l', ']'],
    (plus_nat i (Nat_of_num One), (s, s)));
eq_proof_lines (Sym p) i =
  let {
    (s, (ia, (l, r))) = eq_proof_lines p i;
  } in (s . (shows_nl .
              shows_prec_nat Zero_nat (plus_nat ia (Nat_of_num One)) .
                shows_string [':', ' ']) .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                [' ', '=', ' '] (r, l) .
                shows_string [' ', '[', 's', 'y', 'm', ' '] .
                  shows_prec_nat Zero_nat ia . shows_string [']'],
         (plus_nat ia (Nat_of_num One), (r, l)));
eq_proof_lines (Trans p1 p2) i =
  let {
    (s1, (i1, (s, _))) = eq_proof_lines p1 i;
    (s2, (i2, (_, v))) = eq_proof_lines p2 i1;
  } in (s1 . s2 . (shows_nl .
                    shows_prec_nat Zero_nat (plus_nat i2 (Nat_of_num One)) .
                      shows_string [':', ' ']) .
                    shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                      [' ', '=', ' '] (s, v) .
                      shows_string [' ', '[', 't', 'r', 'a', 'n', 's', ' '] .
                        shows_prec_nat Zero_nat i1 .
                          shows_string [',', ' '] .
                            shows_prec_nat Zero_nat i2 . shows_string [']'],
         (plus_nat i2 (Nat_of_num One), (s, v)));
eq_proof_lines (Assm (l, r) sigma) i =
  let {
    eq = (subst_apply_term l sigma, subst_apply_term r sigma);
  } in ((shows_nl .
          shows_prec_nat Zero_nat (plus_nat i (Nat_of_num One)) .
            shows_string [':', ' ']) .
          shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat) [' ', '=', ' ']
            eq .
            shows_string [' ', '[', 'a', 's', 's', 'm', ' '] .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                [' ', '=', ' '] (l, r) .
                shows_string [']'],
         (plus_nat i (Nat_of_num One), eq));
eq_proof_lines (Cong f ps) i =
  let {
    (s, (is, (ls, rs))) = eq_proofs_lines ps i;
    eq = (Fun f ls, Fun f rs);
    ia = last is;
    isa = butlast is;
  } in (s . (shows_nl .
              shows_prec_nat Zero_nat (plus_nat ia (Nat_of_num One)) .
                shows_string [':', ' ']) .
              shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                [' ', '=', ' '] eq .
                shows_list_gen (shows_prec_nat Zero_nat)
                  [' ', '[', 'c', 'o', 'n', 'g', ']']
                  [' ', '[', 'c', 'o', 'n', 'g', ' '] [',', ' '] [']'] isa,
         (plus_nat ia (Nat_of_num One), eq));

eq_proofs_lines ::
  forall a b.
    (Showa a,
      Showa b) => [Eq_proof a b] ->
                    Nat ->
                      ([Prelude.Char] -> [Prelude.Char],
                        ([Nat], ([Term a b], [Term a b])));
eq_proofs_lines [] i = (id, ([i], ([], [])));
eq_proofs_lines (p : ps) i =
  let {
    (s1, (ia, (l, r))) = eq_proof_lines p i;
    (s2, (is, (ls, rs))) = eq_proofs_lines ps ia;
  } in (s1 . s2, (ia : is, (l : ls, r : rs)));

check_proves ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Eq_proof a b ->
                      Sum ([Prelude.Char] -> [Prelude.Char])
                        (Term a b, Term a b);
check_proves e (Refl s) = Inr (s, s);
check_proves e (Sym p) = bindb (check_proves e p) (\ (s, t) -> Inr (t, s));
check_proves e (Trans p1 p2) =
  bindb (check_proves e p1)
    (\ (s, t) ->
      bindb (check_proves e p2)
        (\ (ta, u) ->
          (if equal_term t ta then Inr (s, u)
            else Inl (shows_string
                        ['t', 'h', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o',
                          'c', 'c', 'u', 'r', 's', ' ', 'i', 'n', ' ', 't', 'h',
                          'e', ' ', 'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g',
                          ' ', 'p', 'a', 'r', 't', ' '] .
                       shows_nl .
                         fst (eq_proof_lines (Trans p1 p2) Zero_nat) .
                           shows_nl .
                             shows_nl .
                               shows_prec_term Zero_nat t .
                                 shows_string
                                   [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e',
                                     'q', 'u', 'a', 'l', ' ', 't', 'o', ' '] .
                                   shows_prec_term Zero_nat ta))));
check_proves e (Assm (l, r) sigma) =
  (if membera e (l, r)
    then Inr (subst_apply_term l sigma, subst_apply_term r sigma)
    else Inl (shows_string
                ['t', 'h', 'e', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'o', 'c',
                  'c', 'u', 'r', 's', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ',
                  'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g', ' ', 'p', 'a',
                  'r', 't', ' '] .
               shows_nl .
                 fst (eq_proof_lines (Assm (l, r) sigma) Zero_nat) .
                   shows_nl .
                     shows_nl .
                       shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                         [' ', '=', ' '] (l, r) .
                         shows_string
                           [' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'i', 'n',
                             ' ', 't', 'h', 'e', ' '] .
                           shows_trs (shows_prec Zero_nat) (shows_prec Zero_nat)
                             ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l',
                               ' ', 's', 'y', 's', 't', 'e', 'm', ':']
                             [' ', '=', ' '] e));
check_proves e (Cong f ps) =
  bindb (mapM (check_proves e) ps)
    (\ sts -> Inr (Fun f (map fst sts), Fun f (map snd sts)));

check_eq_proof ::
  forall a b.
    (Eq a, Showa a, Eq b,
      Showa b) => [(Term a b, Term a b)] ->
                    Eq_proof a b ->
                      (Term a b, Term a b) ->
                        Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_eq_proof e p eq =
  catcha
    (bindb (check_proves e p)
      (\ eqa ->
        (if eq == eqa then Inr ()
          else Inl (shows_string
                     ['t', 'h', 'e', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'd',
                       'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'f', 'i', 't',
                       ' ', 't', 'h', 'e', ' ', 'g', 'o', 'a', 'l']))))
    (\ x ->
      Inl (shows_string
             ['t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', 'n', ' ', 'e',
               'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'e',
               'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'l', 'o', 'g',
               'i', 'c', ' ', 'p', 'r', 'o', 'o', 'f'] .
            shows_nl .
              fst (eq_proof_lines p Zero_nat) .
                shows_nl .
                  shows_nl .
                    shows_string
                      ['f', 'o', 'r', ' ', 'p', 'r', 'o', 'v', 'i', 'n', 'g',
                        ' ', 't', 'h', 'e', ' ', 'e', 'q', 'u', 'a', 't', 'i',
                        'o', 'n'] .
                      shows_nl .
                        shows_nl .
                          shows_rule (shows_prec Zero_nat) (shows_prec Zero_nat)
                            [' ', '=', ' '] eq .
                            shows_nl .
                              shows_nl .
                                shows_string
                                  ['u', 's', 'i', 'n', 'g', ' ', 't', 'h', 'e',
                                    ' '] .
                                  shows_trs (shows_prec Zero_nat)
                                    (shows_prec Zero_nat)
                                    ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n',
                                      'a', 'l', ' ', 's', 'y', 's', 't', 'e',
                                      'm', ':']
                                    [' ', '=', ' '] e .
                                    shows_nl . x));

check_equational_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Bool ->
                    ([Prelude.Char] -> [Prelude.Char]) ->
                      Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                        Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                          [(Term (Lab b [Nat]) [Prelude.Char],
                             Term (Lab b [Nat]) [Prelude.Char])] ->
                            (Term (Lab b [Nat]) [Prelude.Char],
                              Term (Lab b [Nat]) [Prelude.Char]) ->
                              Equational_proof b [Nat] [Prelude.Char] ->
                                Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_equational_proof a ia i j e eq (Equational_Proof_Tree p) =
  debug (ia [])
    ['E', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', '_', 'P', 'r', 'o', 'o',
      'f', '_', 'T', 'r', 'e', 'e']
    (check_eq_proof e p eq);
check_equational_proof a ia i j e eq (Conversion eseq) =
  debug (ia []) ['C', 'o', 'n', 'v', 'e', 'r', 's', 'i', 'o', 'n']
    (check_conversion e eseq (fst eq) (snd eq));
check_equational_proof a ia i j e eq (Completion_and_Normalization r p) =
  debug (ia [])
    ['C', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', '_', 'a', 'n', 'd', '_',
      'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n']
    (bindb (check_completion_proof a ia i j e r p)
      (\ _ ->
        let {
          s = fst eq;
          t = snd eq;
        } in (case (compute_rstep_NF r s, compute_rstep_NF r t) of {
               (Nothing, b) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab Zero_nat)
                             (shows_prec_list Zero_nat) t);
               (Just sa, Nothing) ->
                 Inl (shows_string
                        ['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e', 'n', ' ',
                          'c', 'o', 'm', 'p', 'u', 't', 'i', 'n', 'g', ' ', 'n',
                          'o', 'r', 'm', 'a', 'l', ' ', 'f', 'o', 'r', 'm', 's',
                          ' ', 'o', 'f', ' '] .
                       shows_term (shows_prec_lab Zero_nat)
                         (shows_prec_list Zero_nat) s .
                         shows_string [' ', 'a', 'n', 'd', ' '] .
                           shows_term (shows_prec_lab Zero_nat)
                             (shows_prec_list Zero_nat) t);
               (Just sa, Just ta) ->
                 (if equal_term sa ta then Inr ()
                   else Inl (shows_term (shows_prec_lab Zero_nat)
                               (shows_prec_list Zero_nat) s .
                              shows_string [' ', 'a', 'n', 'd', ' '] .
                                shows_term (shows_prec_lab Zero_nat)
                                  (shows_prec_list Zero_nat) t .
                                  shows_string
                                    [' ', 'h', 'a', 'v', 'e', ' ', 'd', 'i',
                                      'f', 'f', 'e', 'r', 'e', 'n', 't', ' ',
                                      'n', 'o', 'r', 'm', 'a', 'l', ' ', 'f',
                                      'o', 'r', 'm', 's']));
             })));

check_dp_termination_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          c -> Dp_termination_proof b [Nat] [Prelude.Char] ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_dp_termination_proof ia j a i dpp prf =
  check_dp_termination_proof_main ia j a i dpp (fst (unlab_to_split_dp prf));

shows_prec_complexity_class ::
  Nat -> Complexity_class -> [Prelude.Char] -> [Prelude.Char];
shows_prec_complexity_class d c =
  (if equal_nat (degree c) Zero_nat
    then shows_prec_list Zero_nat ['O', '(', '1', ')']
    else (if equal_nat (degree c) (Nat_of_num One)
           then shows_prec_list Zero_nat ['O', '(', 'n', ')']
           else shows_prec_list Zero_nat ['O', '(', 'n', '^'] .
                  shows_prec_nat Zero_nat (degree c) .
                    shows_prec_list Zero_nat [')']));

less_eq_complexity_class :: Complexity_class -> Complexity_class -> Bool;
less_eq_complexity_class x y = less_eq_nat (degree x) (degree y);

cpx ::
  forall a b c.
    Redtriple_ext a b c ->
      Complexity_measure a b ->
        Sum ([Prelude.Char] -> [Prelude.Char]) Complexity_class;
cpx (Redtriple_ext valid s ns nst af mono desc cpx more) = cpx;

rule_shift_complexity_tt ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => Tp_ops_ext a b c () ->
                    Redtriple_ext b c () ->
                      [(Term b c, Term b c)] ->
                        Complexity_measure b c ->
                          Complexity_class ->
                            a -> Sum ([Prelude.Char] -> [Prelude.Char]) a;
rule_shift_complexity_tt i rp rdelete cm cc tp =
  let {
    r = rb i tp;
    rw = rwb i tp;
    r2 = ceta_list_diff r rdelete;
  } in (case catcha
               (bindb (valid rp)
                 (\ _ ->
                   bindb (catcha (mono rp (rdelete ++ rw ++ r2))
                           (\ x ->
                             Inl (shows_string
                                    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ',
                                      'w', 'i', 't', 'h', ' ', 'm', 'o', 'n',
                                      'o', 't', 'o', 'n', 'i', 'c', 'i', 't',
                                      'y', ' ', 'o', 'f', ' ', 's', 't', 'r',
                                      'i', 'c', 't', ' ', 'o', 'r', 'd', 'e',
                                      'r'] .
                                   shows_nl . x)))
                     (\ _ ->
                       bindb (catcha
                               (catcha (forallM (s rp) rdelete)
                                 (\ x -> Inl (snd x)))
                               (\ x ->
                                 Inl (shows_string
['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r', 'i',
  'e', 'n', 't', 'i', 'n', 'g', ' ', 's', 't', 'r', 'i', 'c', 't', ' ', 'T',
  'R', 'S'] .
                                       shows_nl . x)))
                         (\ _ ->
                           bindb (catcha
                                   (catcha (forallM (ns rp) (rw ++ r2))
                                     (\ x -> Inl (snd x)))
                                   (\ x ->
                                     Inl (shows_string
    ['p', 'r', 'o', 'b', 'l', 'e', 'm', ' ', 'w', 'h', 'e', 'n', ' ', 'o', 'r',
      'i', 'e', 'n', 't', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 's', 't', 'r',
      'i', 'c', 't', ' ', 'T', 'R', 'S'] .
   shows_nl . x)))
                             (\ _ ->
                               bindb (cpx rp cm)
                                 (\ cca ->
                                   check (less_eq_complexity_class cca cc)
                                     (shows_prec_list Zero_nat
['c', 'o', 'u', 'l', 'd', ' ', 'o', 'n', 'l', 'y', ' ', 'd', 'e', 'r', 'i', 'v',
  'e', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' '] .
                                       shows_prec_complexity_class Zero_nat
 cca)))))))
               (\ x ->
                 Inl (shows_string
                        ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'd',
                          'e', 'r', 'i', 'v', 'e', ' ', 't', 'h', 'e', ' ', 'i',
                          'n', 't', 'e', 'n', 'd', 'e', 'd', ' ', 'c', 'o', 'm',
                          'p', 'l', 'e', 'x', 'i', 't', 'y', ' '] .
                       shows_prec_complexity_class Zero_nat cc .
                         shows_prec_list Zero_nat
                           [' ', 'f', 'r', 'o', 'm', ' ', 't', 'h', 'e', ' ',
                             'f', 'o', 'l', 'l', 'o', 'w', 'i', 'n', 'g'] .
                           shows_nl . desc rp . shows_nl . x))
         of {
         Inl a -> Inl a;
         Inr _ -> Inr (mkb i (nfsb i tp) (qb i tp) r2 (list_union rw rdelete));
       });

check_complexity_proof ::
  forall a b c.
    (Eq b, Key b, Showa b, Eq c, Key c,
      Showa c) => ([Prelude.Char] -> [Prelude.Char]) ->
                    Tp_ops_ext a b c () ->
                      a -> Complexity_measure b c ->
                             Complexity_class ->
                               Complexity_proof b c ->
                                 Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_complexity_proof ia i tp cm cc (Rule_Shift_Complexity redp rdelete prf) =
  debug (ia [])
    ['R', 'u', 'l', 'e', ' ', 'R', 'e', 'm', 'o', 'v', 'a', 'l', ' ', 'C', 'o',
      'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
    (bindb
      (catcha (rule_shift_complexity_tt i (get_redtriple redp) rdelete cm cc tp)
        (\ x ->
          Inl (ia . shows_string
                      [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'e',
                        'n', ' ', 'a', 'p', 'p', 'l', 'y', 'i', 'n', 'g', ' ',
                        't', 'h', 'e', ' ', 'r', 'u', 'l', 'e', ' ', 's', 'h',
                        'i', 'f', 't', 'i', 'n', 'g', ' ', 't', 'e', 'c', 'h',
                        'n', 'i', 'q', 'u', 'e', ' ', 'o', 'n', ' '] .
                      shows_nl .
                        shows_tp (shows_prec Zero_nat) (shows_prec Zero_nat) i
                          tp .
                          shows_nl . x)))
      (\ tpa ->
        catcha
          (check_complexity_proof (ia . shows_string ['.', '1']) i tpa cm cc
            prf)
          (\ x ->
            Inl (ia . shows_string
                        [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b', 'e', 'l',
                          'o', 'w', ' ', 't', 'h', 'e', ' ', 'r', 'u', 'l', 'e',
                          ' ', 's', 'h', 'i', 'f', 't', 'i', 'n', 'g', ' ', 'p',
                          'r', 'o', 'c', 'e', 's', 's', 'o', 'r'] .
                        shows_nl . indent x))));
check_complexity_proof ia i tp cm cc RisEmpty_Complexity =
  debug (ia [])
    ['R', ' ', 'i', 's', ' ', 'e', 'm', 'p', 't', 'y', ' ', 'f', 'o', 'r', ' ',
      'c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y']
    (check (null (rb i tp))
      (ia . shows_string
              [':', ' ', 'R', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'e', 'm',
                'p', 't', 'y', ' ', 'i', 'n', ' '] .
              shows_nl .
                shows_tp (shows_prec Zero_nat) (shows_prec Zero_nat) i tp));
check_complexity_proof ia i tp cm cc
  (Remove_Nonapplicable_Rules_Complexity r prf) =
  debug (ia [])
    ['R', 'e', 'm', 'o', 'v', 'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a', 'p',
      'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e', ' ', 'r', 'u', 'l', 'e', 's']
    (let {
       _ = rb i tp;
     } in bindb (catcha (check_non_applicable_rules (is_QNFb i tp) r)
                  (\ x ->
                    Inl (ia . shows_string
                                [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'w',
                                  'h', 'e', 'n', ' ', 'r', 'e', 'm', 'o', 'v',
                                  'i', 'n', 'g', ' ', 'n', 'o', 'n', '-', 'a',
                                  'p', 'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e',
                                  ' ', 'r', 'u', 'l', 'e', 's'] .
                                shows_nl .
                                  indent
                                    (shows_rule (shows_prec Zero_nat)
                                       (shows_prec Zero_nat)
                                       [' ', '-', '>', ' '] x .
                                      shows_prec_list Zero_nat
[' ', 'i', 's', ' ', 'a', 'p', 'p', 'l', 'i', 'c', 'a', 'b', 'l', 'e']))))
            (\ _ ->
              let {
                tpa = delete_R_Rwb i tp r r;
              } in catcha
                     (check_complexity_proof (ia . shows_string ['.', '1']) i
                       tpa cm cc prf)
                     (\ x ->
                       Inl (ia . shows_string
                                   [':', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'b',
                                     'e', 'l', 'o', 'w', ' ', 't', 'h', 'e',
                                     ' ', 'n', 'o', 'n', '-', 'a', 'p', 'p',
                                     'l', 'i', 'c', 'a', 'b', 'l', 'e', ' ',
                                     'r', 'u', 'l', 'e', 's', ' ', 'r', 'e',
                                     'm', 'o', 'v', 'a', 'l'] .
                                   shows_nl . indent x))));

check_unknown_proof ::
  forall a b c.
    (Countable b, Eq b, Key b,
      Showa b) => Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                    Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                      Bool ->
                        ([Prelude.Char] -> [Prelude.Char]) ->
                          [Prelude.Char] ->
                            Unknown_proof b [Nat] [Prelude.Char] ->
                              Sum ([Prelude.Char] -> [Prelude.Char]) ();
check_unknown_proof ia j a i u prf =
  check_unknown_proof_main ia j a i u (unlab_to_split_unknown prf);

certify_cert_problem ::
  forall a b c.
    (Countable b, Default b, Eq b, Key b,
      Showa b) => Bool ->
                    Tp_ops_ext a (Lab b [Nat]) [Prelude.Char] () ->
                      Dpp_ops_ext c (Lab b [Nat]) [Prelude.Char] () ->
                        Cert_problem b [Nat] [Prelude.Char] -> Cert_result;
certify_cert_problem a i j (TRS_Termination_Proof nfs q r Nothing prf) =
  (case check_trs_termination_proof i j a (shows_stringa ['1'])
          (mkb i nfs (strategy_to_Q q r) r []) prf
    of {
    Inl err ->
      Error ((shows_string
                ['t', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                  'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c',
                  'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Termination_Proof nfs q r Nothing prf));
  });
certify_cert_problem a i j (TRS_Termination_Proof nfs q r (Just s) prf) =
  (case check_trs_termination_proof i j a (shows_stringa ['1'])
          (mkb i nfs (strategy_to_Q q r) r s) prf
    of {
    Inl err ->
      Error ((shows_string
                ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 't', 'e', 'r',
                  'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o',
                  'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e', 'p',
                  't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Termination_Proof nfs q r (Just s) prf));
  });
certify_cert_problem a i j (Complexity_Proof q r s_o cm cc prf) =
  (case check_complexity_proof (shows_stringa ['1']) i
          (mkb i True (strategy_to_Q q r) r (rel_rules_of s_o)) cm cc prf
    of {
    Inl err ->
      Error ((shows_string
                ['c', 'o', 'm', 'p', 'l', 'e', 'x', 'i', 't', 'y', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Complexity_Proof q r s_o cm cc prf));
  });
certify_cert_problem a i j (TRS_Nontermination_Proof nfs q r prf) =
  (case check_trs_nontermination_proof i j a (shows_stringa ['1'])
          (mkb i nfs (strategy_to_Q q r) r []) prf
    of {
    Inl err ->
      Error ((shows_string
                ['n', 'o', 'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i',
                  'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't',
                  ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Nontermination_Proof nfs q r prf));
  });
certify_cert_problem a i j (Outermost_Nontermination_Proof r prf) =
  (case check_fp_nontermination_proof i j a (shows_stringa ['1'])
          (o_to_fp_impl (map fst r), r) prf
    of {
    Inl err ->
      Error ((shows_string
                ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 'n', 'o',
                  'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
                  ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a',
                  'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Outermost_Nontermination_Proof r prf));
  });
certify_cert_problem a i j (Outermost_Termination_Proof r prf) =
  (case check_fptrs_termination_proof i j a (shows_stringa ['1'])
          (o_to_fp_impl (map fst r), r) prf
    of {
    Inl err ->
      Error ((shows_string
                ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 't', 'e',
                  'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r',
                  'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e',
                  'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Outermost_Termination_Proof r prf));
  });
certify_cert_problem a i j (CS_Nontermination_Proof mu r prf) =
  (case check_fp_nontermination_proof i j a (shows_stringa ['1'])
          (mu_to_fp_impl mu, r) prf
    of {
    Inl err ->
      Error ((shows_string
                ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 'n', 'o',
                  'n', 't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n',
                  ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a',
                  'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (CS_Nontermination_Proof mu r prf));
  });
certify_cert_problem a i j (CS_Termination_Proof mu r prf) =
  (case check_fptrs_termination_proof i j a (shows_stringa ['1'])
          (mu_to_fp_impl mu, r) prf
    of {
    Inl err ->
      Error ((shows_string
                ['o', 'u', 't', 'e', 'r', 'm', 'o', 's', 't', ' ', 't', 'e',
                  'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r',
                  'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e',
                  'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (CS_Termination_Proof mu r prf));
  });
certify_cert_problem a i j (FP_Termination_Proof p r prf) =
  (case check_fptrs_termination_proof i j a (shows_stringa ['1']) (p, r) prf of
    {
    Inl err ->
      Error ((shows_string
                ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a',
                  't', 't', 'e', 'r', 'n', ' ', 't', 'e', 'r', 'm', 'i', 'n',
                  'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o', 'o', 'f', ' ',
                  'n', 'o', 't', ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (FP_Termination_Proof p r prf));
  });
certify_cert_problem a i j (FP_Nontermination_Proof p r prf) =
  (case check_fp_nontermination_proof i j a (shows_stringa ['1']) (p, r) prf of
    {
    Inl err ->
      Error ((shows_string
                ['f', 'o', 'r', 'b', 'i', 'd', 'd', 'e', 'n', ' ', 'p', 'a',
                  't', 't', 'e', 'r', 'n', ' ', 'n', 'o', 'n', 't', 'e', 'r',
                  'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'p', 'r', 'o',
                  'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e', 'p',
                  't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (FP_Nontermination_Proof p r prf));
  });
certify_cert_problem a i j (Relative_TRS_Nontermination_Proof nfs q r s prf) =
  (case check_reltrs_nontermination_proof i j a (shows_stringa ['1'])
          (mkb i nfs (strategy_to_Q q r) r s) prf
    of {
    Inl err ->
      Error ((shows_string
                ['r', 'e', 'l', 'a', 't', 'i', 'v', 'e', ' ', 'n', 'o', 'n',
                  't', 'e', 'r', 'm', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ',
                  'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c',
                  'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ ->
      Certified (xml_tag (Relative_TRS_Nontermination_Proof nfs q r s prf));
  });
certify_cert_problem a i j (DP_Termination_Proof nfs m p pw q r rw prf) =
  (case check_dp_termination_proof i j a (shows_stringa ['1'])
          (mkc j nfs m p pw (strategy_to_Q q (r ++ rw)) r rw) prf
    of {
    Inl err ->
      Error ((shows_string
                ['f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (DP_Termination_Proof nfs m p pw q r rw prf));
  });
certify_cert_problem a i j (DP_Nontermination_Proof nfs m p q r prf) =
  (case check_dp_nontermination_proof i j a (shows_stringa ['1'])
          (mkc j nfs m p [] (strategy_to_Q q r) [] r) prf
    of {
    Inl err ->
      Error ((shows_string
                ['i', 'n', 'f', 'i', 'n', 'i', 't', 'e', 'n', 'e', 's', 's',
                  ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a',
                  'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (DP_Nontermination_Proof nfs m p q r prf));
  });
certify_cert_problem a i j (TRS_Confluence_Proof nfs r prf) =
  (case check_cr_proof a (shows_stringa ['1']) i j r prf of {
    Inl err ->
      Error ((shows_string
                ['c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Confluence_Proof nfs r prf));
  });
certify_cert_problem a i j (TRS_Non_Confluence_Proof nfs r prf) =
  (case check_ncr_proof a (shows_stringa ['1']) i j r prf of {
    Inl err ->
      Error ((shows_string
                ['c', 'o', 'n', 'f', 'l', 'u', 'e', 'n', 'c', 'e', ' ', 'd',
                  'i', 's', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ',
                  'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (TRS_Non_Confluence_Proof nfs r prf));
  });
certify_cert_problem a i j (Completion_Proof e r prf) =
  (case check_completion_proof a (shows_stringa ['1']) i j e r prf of {
    Inl err ->
      Error ((shows_string
                ['c', 'o', 'm', 'p', 'l', 'e', 't', 'i', 'o', 'n', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Completion_Proof e r prf));
  });
certify_cert_problem a i j (Equational_Proof e eq prf) =
  (case check_equational_proof a (shows_stringa ['1']) i j e eq prf of {
    Inl err ->
      Error ((shows_string
                ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'p',
                  'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c',
                  'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Equational_Proof e eq prf));
  });
certify_cert_problem a i j (Equational_Disproof e eq prf) =
  (case check_equational_disproof a (shows_stringa ['1']) i j e eq prf of {
    Inl err ->
      Error ((shows_string
                ['e', 'q', 'u', 'a', 't', 'i', 'o', 'n', 'a', 'l', ' ', 'd',
                  'i', 's', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o', 't', ' ',
                  'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Equational_Disproof e eq prf));
  });
certify_cert_problem a i j (Quasi_Reductive_Proof ctrs prf) =
  (case check_quasi_reductive_proof a (shows_stringa ['1']) i j ctrs prf of {
    Inl err ->
      Error ((shows_string
                ['q', 'u', 'a', 's', 'i', ' ', 'r', 'e', 'd', 'u', 'c', 't',
                  'i', 'v', 'e', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'n', 'o',
                  't', ' ', 'a', 'c', 'c', 'e', 'p', 't', 'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Quasi_Reductive_Proof ctrs prf));
  });
certify_cert_problem a i j (Unknown_Proof up prf) =
  (case check_unknown_proof i j a (shows_stringa ['1']) up prf of {
    Inl err ->
      Error ((shows_string
                ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o',
                  'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e', 'p', 't',
                  'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Unknown_Proof up prf));
  });
certify_cert_problem a i j (Unknown_Disproof up prf) =
  (case check_unknown_disproof i j a (shows_stringa ['1']) up prf of {
    Inl err ->
      Error ((shows_string
                ['u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'p', 'r', 'o', 'o',
                  'f', ' ', 'n', 'o', 't', ' ', 'a', 'c', 'c', 'e', 'p', 't',
                  'e', 'd'] .
               shows_nl . err)
              []);
    Inr _ -> Certified (xml_tag (Unknown_Disproof up prf));
  });

find_ctxt_len ::
  [Prelude.Char] ->
    [Prelude.Char] -> Nat -> Maybe ([Prelude.Char], [Prelude.Char]);
find_ctxt_len [] ys n = Nothing;
find_ctxt_len (v : va) ys n =
  (if take n (v : va) == ys then Just ([], drop n (v : va))
    else bind (find_ctxt_len (tl (v : va)) ys n)
           (\ (us, vs) -> Just (hd (v : va) : us, vs)));

extract_input_proof ::
  [Prelude.Char] -> Maybe ([Prelude.Char], ([Prelude.Char], [Prelude.Char]));
extract_input_proof s =
  bind (find_ctxt_len
         (filter (\ c -> not (membera [' ', '\n', '\t', '\r'] c)) s)
         ['<', 'i', 'n', 'p', 'u', 't', '>']
         (size_list ['<', 'i', 'n', 'p', 'u', 't', '>']))
    (\ (_, minput) ->
      bind (find_ctxt_len minput ['<', '/', 'i', 'n', 'p', 'u', 't', '>']
             (size_list ['<', '/', 'i', 'n', 'p', 'u', 't', '>']))
        (\ (input, sa) ->
          bind (find_ctxt_len sa ['<', 'p', 'r', 'o', 'o', 'f', '>']
                 (size_list ['<', 'p', 'r', 'o', 'o', 'f', '>']))
            (\ (version, proof) -> Just (input, (version, proof)))));

eval_list_haskell :: forall a. [a] -> Sum_bot [Prelude.Char] [a];
eval_list_haskell (x : xs) =
  binda (eval_list_haskell xs) (\ ys -> returna (x : ys));
eval_list_haskell [] = returna [];

xmldoc2cert_problem ::
  Xmldoc ->
    Sum_bot [Prelude.Char] (Cert_problem [Prelude.Char] [Nat] [Prelude.Char]);
xmldoc2cert_problem (XMLDOC header xml) =
  debug ['0']
    ['p', 'a', 'r', 's', 'i', 'n', 'g', ' ', 'x', 'm', 'l', ' ', 't', 'o', ' ',
      'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'p',
      'r', 'o', 'b', 'l', 'e', 'm']
    (xml2cert_problem (text ['n', 'a', 'm', 'e']) plain_name xml);

parse_cert_problem ::
  [Prelude.Char] ->
    Sum_bot [Prelude.Char] (Cert_problem [Prelude.Char] [Nat] [Prelude.Char]);
parse_cert_problem s =
  (case doc_of_stringa s of {
    Inl a -> errora a;
    Inr a -> xmldoc2cert_problem a;
  });

eq_white_space :: [Prelude.Char] -> [Prelude.Char] -> Bool;
eq_white_space s1 s2 =
  debug ['0']
    ['c', 'o', 'm', 'p', 'a', 'r', 'i', 'n', 'g', ' ', 'w', 'h', 'e', 't', 'h',
      'e', 'r', ' ', 'p', 'a', 'r', 's', 'e', 'd', ' ', 'i', 'n', 'p', 'u', 't',
      ' ', 'c', 'o', 'r', 'r', 'e', 's', 'p', 'o', 'n', 'd', 's', ' ', 't', 'o',
      ' ', 'r', 'e', 'a', 'l', ' ', 'i', 'n', 'p', 'u', 't']
    (filter (\ c -> not (membera [' ', '\n', '\t', '\r'] c)) s1 == s2);

certify_proof :: Bool -> [Prelude.Char] -> Sum_bot [Prelude.Char] Cert_result;
certify_proof a s =
  catch (case extract_input_proof s of {
          Nothing ->
            returna
              (Unsupported
                ['c', 'o', 'u', 'l', 'd', ' ', 'n', 'o', 't', ' ', 'e', 'x',
                  't', 'r', 'a', 'c', 't', ' ', 'i', 'n', 'p', 'u', 't', ' ',
                  'a', 'n', 'd', ' ', 'p', 'r', 'o', 'o', 'f', ' ', 'f', 'r',
                  'o', 'm', ' ', 'g', 'i', 'v', 'e', 'n', ' ', 's', 't', 'r',
                  'i', 'n', 'g']);
          Just (the_input, (_, the_proof)) ->
            binda (eval_list_haskell (take max_tag (trim the_proof)))
              (\ short_prf ->
                binda (parse_cert_problem s)
                  (\ cp ->
                    returna
                      (if eq_white_space
                            (shows_prec_xml Zero_nat (xml_cert_problem cp) [])
                            the_input
                        then (case certify_cert_problem a tp_rbt_impl
                                     dpp_rbt_impl cp
                               of {
                               Certified tag ->
                                 (if starts_with short_prf tag
                                   then Certified tag
                                   else Error
  (['p', 'r', 'o', 'v', 'e', 'n', ' ', 'p', 'r', 'o', 'p', 'e', 'r', 't', 'y',
     ' '] ++
    tag ++
      [' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r', 'r',
        'e', 's', 'p', 'o', 'n', 'd', ' ', 't', 'o', ' ', 'p', 'r', 'o', 'o',
        'f', ' ', 'i', 'n', ' ', 'i', 'n', 'p', 'u', 't', ' ', 's', 't', 'r',
        'i', 'n', 'g', ':', ' '] ++
        short_prf));
                               Unsupported aa -> Unsupported aa;
                               Error aa -> Error aa;
                             })
                        else Unsupported
                               (concat
                                 [['p', 'a', 'r', 's', 'e', 'd', ' ', 'p', 'r',
                                    'o', 'b', 'l', 'e', 'm', ' ', 'd', 'o', 'e',
                                    's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'r',
                                    'r', 'e', 's', 'p', 'o', 'n', 'd', ' ', 't',
                                    'o', ' ', 'i', 'n', 'p', 'u', 't'],
                                   ['\n'], ['i', 'n', 'p', 'u', 't', ':'],
                                   ['\n'],
                                   filter
                                     (\ c ->
                                       not (membera [' ', '\n', '\t', '\r'] c))
                                     the_input,
                                   ['\n'], ['\n'],
                                   ['p', 'a', 'r', 's', 'e', 'd', ':'], ['\n'],
                                   filter
                                     (\ c ->
                                       not (membera [' ', '\n', '\t', '\r'] c))
                                     (shows_prec_xml Zero_nat
                                       (xml_cert_problem cp) []),
                                   ['\n']]))));
        })
    (\ err ->
      returna
        (Unsupported
          (['e', 'r', 'r', 'o', 'r', ' ', 'w', 'h', 'i', 'l', 'e', ' ', 'p',
             'a', 'r', 's', 'i', 'n', 'g'] ++
            ['\n'] ++ err)));

}
